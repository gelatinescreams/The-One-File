<!DOCTYPE html> 
 <html lang="en" style="--panel: #44a781; --panel-alt: #243521; --accent: #186d29; --danger: #166a3a; --text-main: #ffffff; --text-soft: #fcfcfd; --topbar-bg: #496f44; --topbar-border: #00ff33; --topbar-height: 100px; --sidebar-width: 600px; --mobile-footer-height: 40vh; --draw-toolbar-height: 0px;"><head>
    <meta charset="UTF-8">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Corporate</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- 
      * ====================================================================================
      * THE ONE FILE
      * "There can be only one". A all in one file topology maker for enterprise or homelab
      * 
      * This is your last backup when all others fail. A completely self-contained
      * network topology visualization tool that works as a single HTML file.
      * Open it anywhere, anytime and the idea lives forever.
      * ====================================================================================
      -->
    <style>
      :root {
      color-scheme: dark;
      --bg: #050608;
      --panel: #0b0e13;
      --panel-alt: #10141b;
      --accent: #4fd1c5;
      --danger: #f56565;
      --text-main: #e2e8f0;
      --text-soft: #94a3b8;
      --edge-main: #475569;
      --node-min: 35px;
      --node-max: 70px;
      --topbar-bg: rgba(9, 12, 20, 0.9);
      --topbar-border: #1f2533;
      }
      * {
      box-sizing: border-box;
      user-select: none;
      }
      input,
      textarea,
      [contenteditable="true"] {
      user-select: text;
      -webkit-user-select: text;
      }
      body {
      margin: 0;
      font-family: system-ui, sans-serif;
      background: radial-gradient(circle at top, #1e2532 0, #050608 70%);
      color: var(--text-main);
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
      }
      header {
      padding: 0 20px;
      height: var(--topbar-height, 52px);
      min-height: var(--topbar-height, 52px);
      background: var(--topbar-bg);
      backdrop-filter: blur(6px);
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid var(--topbar-border);
      gap: 16px;
      }
      .title-block {
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-width: 0;
      }
      header h1 {
      font-size: clamp(22px, 3vw, 32px);
      margin: 0;
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
      }
      .editable-page-title {
      cursor: pointer;
      transition: opacity 0.2s;
      }
      .editable-page-title:hover {
      opacity: 0.7;
      }
      .save-row {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      }
      .save-btn {
      padding: 6px 12px;
      background: var(--accent);
      color: var(--bg);
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      white-space: nowrap;
      }
      .save-btn:hover {
      opacity: 0.9;
      }
      .help-icon {
      width: 22px;
      height: 22px;
      border-radius: 50%;
      border: 1px solid var(--edge-main);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      cursor: pointer;
      color: var(--text-soft);
      background: rgba(15, 23, 42, 0.9);
      flex-shrink: 0;
      }
      .help-icon:hover {
      color: var(--accent);
      border-color: var(--accent);
      }
      #settings-btn {
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 16px;
      flex-shrink: 0;
      }
      #settings-btn:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .header-resizer {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 6px;
      background: transparent;
      cursor: row-resize;
      z-index: 1000;
      transition: background 0.2s;
      }
      .header-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .header-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      .sidebar-resizer {
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 6px;
      background: transparent;
      cursor: col-resize;
      z-index: 1000;
      transition: background 0.2s;
      }
      .sidebar-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .sidebar-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      .mobile-footer-resizer {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 6px;
      background: transparent;
      cursor: row-resize;
      z-index: 1000;
      transition: background 0.2s;
      display: none;
      }
      .mobile-footer-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .mobile-footer-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      @media (max-width: 900px) {
      .mobile-footer-resizer {
      display: block;
      height: 12px;
      }
      .sidebar-resizer {
      display: none;
      }
      .header-resizer {
      height: 12px;
      }
      }
      @media (pointer: coarse) {
      .header-resizer {
      height: 16px;
      }
      .mobile-footer-resizer {
      height: 16px;
      }
      .sidebar-resizer {
      width: 16px;
      }
      }
      .resizer-icon {
      position: absolute;
      opacity: 0.5;
      transition: opacity 0.2s, transform 0.2s;
      pointer-events: none;
      fill: var(--accent);
      }
      .header-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .sidebar-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .mobile-footer-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .header-resizer:hover .resizer-icon,
      .sidebar-resizer:hover .resizer-icon,
      .mobile-footer-resizer:hover .resizer-icon {
      opacity: 1;
      }
      .header-resizer.resizing .resizer-icon,
      .sidebar-resizer.resizing .resizer-icon,
      .mobile-footer-resizer.resizing .resizer-icon {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1.2);
      }
      body.resizing {
      user-select: none;
      }
      body.resizing * {
      cursor: inherit !important;
      pointer-events: none;
      }
      header {
      position: relative;
      }
      .details-panel {
      position: relative;
      }
      main {
      display: grid;
      grid-template-columns: 1fr var(--sidebar-width, 350px);
      flex: 1;
      }
      main.sidebar-collapsed {
      grid-template-columns: 1fr 0;
      }
      @media (max-width: 900px) {
      main {
      grid-template-columns: 1fr;
      grid-template-rows: calc(100vh - var(--topbar-height, 52px) - var(--mobile-footer-height, 40vh)) var(--mobile-footer-height, 40vh);
      }
      main.sidebar-collapsed {
      grid-template-rows: 1fr 0;
      }
      .details-panel {
      max-height: var(--mobile-footer-height, 40vh);
      height: 100%;
      }
      }
      .topology-panel {
      background: var(--panel);
      border-right: 1px solid #111827;
      position: relative;
      overflow: hidden;
      }
      .topology-toolbar {
      position: absolute;
      top: 10px;
      right: 10px;
      display: none;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      background: rgba(15, 23, 42, 0.92);
      border: 1px solid #1f2937;
      border-radius: 6px;
      z-index: 99;
      font-size: 13px;
      }
      .topology-toolbar label {
      color: var(--text-soft);
      }
      .topology-toolbar select {
      padding: 4px 6px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: 13px;
      cursor: pointer;
      }
      .topology-toolbar button {
      padding: 4px 10px;
      background: var(--accent);
      color: var(--bg);
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      }
      .bulk-toolbar-desktop,
      .bulk-toolbar-mobile {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 9999;
      }
      .bulk-toolbar-desktop {
      position: absolute;
      top: 10px;
      right: 10px;
      bottom: auto;
      left: auto;
      transform: none;
      }
      @media (min-width: 768px) {
      .bulk-toolbar-mobile {
      display: none !important;
      }
      }	  
      .bulk-action-btn {
      padding: 16px;
      background: var(--panel-main);
      border: 1px solid var(--edge-main);
      border-radius: 8px;
      color: var(--text-main);
      font-size: 24px;
      cursor: pointer;
      text-align: center;
      line-height: 1.2;
      }
      .bulk-action-btn:active {
      transform: scale(0.95);
      background: var(--accent);
      }
      .draw-toolbar {
      position: absolute;
      top: 10px;
      left: 10px;
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 8px;
      background: rgba(15, 23, 42, 0.92);
      border: 1px solid #1f2937;
      border-radius: 6px;
      z-index: 99;
      font-size: 13px;
      pointer-events: auto;
      }
      .draw-toolbar button {
      padding: 4px 8px;
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      }
      .draw-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .draw-toolbar input[type="color"] {
      width: 30px;
      height: 22px;
      border-radius: 4px;
      border: 1px solid var(--edge-main);
      padding: 0;
      background: transparent;
      cursor: pointer;
      }
      .draw-toolbar select {
      padding: 4px 6px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: 13px;
      cursor: pointer;
      }
      .legend-container {
      position: absolute;
      left: 10px;
      bottom: 10px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      padding: 8px 10px;
      background: rgba(15, 23, 42, 0.92);
      border: 1px solid #1f2937;
      border-radius: 6px;
      font-size: 12px;
      z-index: 20;
      max-width: 260px;
      pointer-events: auto;
      }
      .legend-container {
      padding-right: 22px;
      }
      @media (max-width: 900px) {
      .legend-container {
      height:250px;
      overflow-y: auto;
      z-index:99;
      }
      }
      @media (max-width: 900px) {
      .bulk-toolbar-desktop,
      .topology-toolbar {
      display: none !important;
      }
      }
      .legend-close-btn {
      position: absolute;
      top: 5px;
      right: 5px;
      width: 18px;
      height: 18px;
      border-radius: 999px;
      border: 1px solid var(--edge-main);
      background: var(--panel-alt);
      color: var(--text-soft);
      font-size: 11px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      }
      .legend-close-btn:hover {
      background: var(--danger);
      color: #fff;
      }
      .legend-mini-btn {
      position: absolute;
      left: 10px;
      padding: 4px 8px;
      border-radius: 4px;
      border: 1px solid #1f2937;
      background: rgba(15, 23, 42, 0.92);
      color: var(--text-main);
      font-size: 11px;
      cursor: pointer;
      z-index: 20;
      display: none;
      transition: all 0.2s;
      }
      .legend-mini-btn:hover,
      .legend-mini-btn:active {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
      }
      .legend-title {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: var(--text-soft);
      margin-bottom: 2px;
      }
      .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      }
      .legend-swatch {
      width: 14px;
      height: 14px;
      border-radius: 3px;
      border: 1px solid #020617;
      flex-shrink: 0;
      }
      .legend-label {
      outline: none;
      cursor: text;
      flex: 1;
      min-width: 60px;
      user-select: text;
      -webkit-user-select: text;
      }
      .legend-label.editing {
      border-bottom: 1px dashed var(--accent);
      }
      .canvas-viewport {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      overflow: hidden;
      }
      .canvas-viewport.panning {
      cursor: grabbing !important;
      }
      .canvas-viewport.panning * {
      cursor: grabbing !important;
      }
      .canvas-viewport svg {
      width: 100%;
      height: 100%;
      display: block;
      background: linear-gradient(rgba(71, 85, 105, 0.1) 1px,
      transparent 1px),
      linear-gradient(90deg,
      rgba(71, 85, 105, 0.1) 1px,
      transparent 1px),
      linear-gradient(rgba(71, 85, 105, 0.05) 1px, transparent 1px),
      linear-gradient(90deg,
      rgba(71, 85, 105, 0.05) 1px,
      transparent 1px);
      background-size:
      100px 100px,
      100px 100px,
      20px 20px,
      20px 20px;
      background-position:
      -1px -1px,
      -1px -1px,
      -1px -1px,
      -1px -1px;
      }
      .zoom-toolbar {
      display: flex;
      gap: 4px;
      padding: 6px;
      background: rgba(15, 23, 42, 0.92);
      border: 1px solid #1f2937;
      border-radius: 6px;
      }
      .zoom-toolbar button {
      width: 32px;
      height: 32px;
      padding: 0;
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      font-size: 18px;
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
      }
      .zoom-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .zoom-toolbar .zoom-level {
      font-size: 11px;
      color: var(--text-soft);
      text-align: center;
      padding: 2px 0;
      min-width: 32px;
      }
      .zoom-toolbar .divider {
      height: 1px;
      background: var(--edge-main);
      margin: 2px 0;
      }
      .minimap-zoom-wrapper {
      position: absolute;
      bottom: 10px;
      right: 10px;
      z-index: 99;
      }
      .minimap-container {
      background: rgba(15, 23, 42, 0.92);
      border: 1px solid #1f2937;
      border-radius: 6px;
      overflow: hidden;
      margin-bottom: 4px;
      }
      .minimap-container svg {
      width: 100%;
      height: 100%;
      }
      .minimap-viewport {
      fill: rgba(79, 209, 197, 0.2);
      stroke: var(--accent);
      stroke-width: 2;
      cursor: move;
      }
      .minimap-node {
      fill: var(--text-soft);
      }
      .minimap-edge {
      stroke: var(--edge-main);
      stroke-width: 1;
      }
      .minimap-close-btn {
      position: absolute;
      top: 2px;
      right: 2px;
      width: 18px;
      height: 18px;
      background: rgba(15, 23, 42, 0.9);
      border: 1px solid var(--edge-main);
      border-radius: 3px;
      color: var(--text-soft);
      font-size: 11px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
      padding: 0;
      line-height: 1;
      }
      .minimap-close-btn:hover {
      background: var(--danger);
      color: white;
      border-color: var(--danger);
      }
      .toolbar-close-btn {
      width: 24px;
      height: 24px;
      background: rgba(15, 23, 42, 0.9);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-soft);
      font-size: 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      line-height: 1;
      flex-shrink: 0;
      }
      .toolbar-close-btn:hover {
      background: var(--danger);
      color: white;
      border-color: var(--danger);
      }
      .canvas-hint {
      position: absolute;
      top: 50px;
      left: 50%;
      transform: translateX(-50%);
      padding: 8px 16px;
      background: rgba(15, 23, 42, 0.92);
      border: 1px solid #1f2937;
      border-radius: 6px;
      font-size: 12px;
      color: var(--text-soft);
      z-index: 18;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
      }
      .canvas-hint.visible {
      opacity: 1;
      }
      .edge {
      stroke: var(--edge-main);
      stroke-width: 4;
      opacity: 0.75;
      transition: 0.25s ease-in-out;
      cursor: pointer;
      }
      .edge.backup {
      stroke: var(--danger);
      stroke-width: 5;
      }
      .edge.active {
      opacity: 1;
      stroke-width: 7;
      }
      .free-preview {
      fill: none;
      stroke-dasharray: 4 4;
      pointer-events: none;
      }
      .free-point {
      fill: #e5e7eb;
      stroke: #0f172a;
      stroke-width: 1.5;
      cursor: grab;
      }
	  .node-circle {
      fill: #1e293b;
      stroke: #475569;
      stroke-width: 2;
      transition: 0.25s ease;
      transform-origin: center center;
      }
      .node-hit-area {
      cursor: grab;
      pointer-events: all;
      }
      .node-group:hover .node-circle {
      filter: drop-shadow(0 0 10px rgba(79, 209, 197, 0.45));
      }
      .node-group.active .node-circle {
      stroke: var(--accent);
      animation: pulse 1.2s infinite ease-in-out;
      }
      .node-group.selected .node-circle {
      stroke: #f59e0b;
      stroke-width: 3;
      }
      .node-group.search-highlight .node-circle {
      stroke: #10b981;
      stroke-width: 3;
      filter: drop-shadow(0 0 8px #10b981);
      }
      @keyframes pulse {
      0% {
      filter: drop-shadow(0 0 4px #4fd1c5);
      }
      50% {
      filter: drop-shadow(0 0 14px #4fd1c5);
      }
      100% {
      filter: drop-shadow(0 0 4px #4fd1c5);
      }
      }
      .node-label {
      fill: var(--text-main);
      font-size: 18px;
      text-anchor: middle;
      font-weight: 600;
      }
      .node-sub {
      fill: var(--text-soft);
      font-size: 13px;
      text-anchor: middle;
      }
      @media (max-width: 1024px) {
      .node-label {
      font-size: 28px;
      }
      .node-sub {
      font-size: 20px;
      }
      }
      @media (max-width: 768px) {
      .node-label {
      font-size: 70px;
      }
      .node-sub {
      font-size: 50px;
      }
      }
      @media (max-width: 380px) {
      .node-label {
      font-size: 60px;
      }
      .node-sub {
      font-size: 42px;
      }
      }
      .details-panel {
      background: var(--panel-alt);
      padding: 22px;
      padding-bottom: 80px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 15px;
      position: relative;
      transition:
      width 0.3s ease,
      min-width 0.3s ease,
      padding 0.3s ease,
      opacity 0.3s ease;
      }
      .details-panel {
      min-width: 260px !important;
      }
      .details-panel {
      overflow-y: auto !important;
      overflow-x: hidden;
      }
      .details-panel.collapsed {
      width: 0 !important;
      min-width: 0 !important;
      padding: 0 !important;
      overflow: hidden;
      opacity: 0;
      }
      body {
      overflow-x: hidden;
      overflow-y: hidden;
      }
      main {
      overflow-x: hidden;
      overflow-y: visible;
      }
      .details-panel {
      overflow-y: auto !important;
      overflow-x: hidden;
      }
      .details-panel.collapsed {
      min-width: 0 !important;
      }
      .sidebar-toggle {
      position: absolute;
      left: -16px;
      top: 50%;
      transform: translateY(-50%);
      width: 16px;
      height: 60px;
      background: var(--panel-alt);
      border: 1px solid var(--edge-main);
      border-right: none;
      border-radius: 8px 0 0 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text-soft);
      font-size: 10px;
      z-index: 25;
      transition:
      background 0.2s,
      color 0.2s;
      }
      .sidebar-toggle:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .sidebar-toggle.collapsed {
      left: 0;
      border-right: 1px solid var(--edge-main);
      border-radius: 0 8px 8px 0;
      position: fixed;
      right: 0;
      left: auto;
      }
      .details-name {
      font-size: clamp(22px, 2.5vw, 30px);
      font-weight: 700;
      }
      .details-ip {
      font-size: clamp(16px, 2vw, 22px);
      color: var(--text-soft);
      }
      .details-role {
      font-size: clamp(16px, 2vw, 22px);
      color: var(--accent);
      }
      .details-info-row {
      display: flex;
      align-items: center;
      margin: 6px 0;
      }
      .size-controls {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-top: 10px;
      }
      .size-controls label {
      font-size: clamp(14px, 1.6vw, 18px);
      color: var(--text-soft);
      }
      .size-controls input[type="range"] {
      flex: 1;
      accent-color: var(--accent);
      }
      .size-controls button {
      padding: 6px 12px;
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      font-size: clamp(12px, 1.4vw, 16px);
      }
      .size-controls button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .style-section {
      margin-top: 15px;
      padding-top: 15px;
      border-top: 1px solid var(--edge-main);
      }
      .style-section summary {
      cursor: pointer;
      font-size: clamp(14px, 1.6vw, 20px);
      text-transform: uppercase;
      color: var(--text-soft);
      list-style: none;
      display: flex;
      justify-content: space-between;
      align-items: center;
      user-select: none;
      }
      .style-section summary::-webkit-details-marker {
      display: none;
      }
      .password-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #ffffff;
      z-index: 9999;
      }
      .style-section summary::after {
      content: "‚ñº";
      transition: transform 0.2s;
      }
      .style-section[open] summary::after {
      transform: rotate(180deg);
      }
      .style-content {
      margin-top: 10px;
      }
      .style-row {
      display: flex;
      gap: 10px;
      align-items: center;
      margin: 8px 0;
      }
      .style-row label {
      font-size: clamp(13px, 1.5vw, 17px);
      color: var(--text-soft);
      min-width: 80px;
      }
      .style-row input[type="color"] {
      width: 50px;
      height: 30px;
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      background: transparent;
      }
      .style-row input[type="number"] {
      width: 70px;
      padding: 4px 8px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(12px, 1.4vw, 16px);
      }
      .style-row select {
      flex: 1;
      padding: 4px 8px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(12px, 1.4vw, 16px);
      cursor: pointer;
      }
      .editable-text {
      cursor: pointer;
      transition: opacity 0.2s;
      }
      .editable-text:hover {
      opacity: 0.7;
      }
      .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      z-index: 999999;
      justify-content: center;
      align-items: center;
      padding-top: var(--topbar-height, 52px);
      }
      .modal.active {
      display: flex;
      }
      .modal-content {
      background: var(--panel-alt);
      padding: 25px;
      border-radius: 8px;
      border: 1px solid var(--edge-main);
      min-width: 300px;
      max-width: 90%;
      max-height: calc(100vh - var(--topbar-height, 52px) - 40px);
      overflow-y: auto;
      }
      .modal-content h3 {
      margin: 0 0 15px 0;
      color: var(--text-main);
      font-size: clamp(18px, 2vw, 24px);
      }
      .modal-content p {
      color: var(--text-soft);
      font-size: clamp(14px, 1.6vw, 18px);
      margin: 0 0 20px 0;
      }
      .modal-content input:not([type="color"]),
      .modal-content select {
      width: 100%;
      padding: 10px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(14px, 1.6vw, 18px);
      margin-bottom: 15px;
      user-select: text;
      -webkit-user-select: text;
      }
      .modal-content input[type="color"] {
      width: 60px;
      height: 36px;
      padding: 2px;
      border: 2px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      background: none;
      -webkit-appearance: none;
      appearance: none;
      }
      .modal-content input[type="color"]::-webkit-color-swatch-wrapper {
      padding: 0;
      }
      .modal-content input[type="color"]::-webkit-color-swatch {
      border: none;
      border-radius: 4px;
      }
      .modal-buttons {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
      margin-top: 10px;
      }
      .modal-buttons button {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: clamp(14px, 1.6vw, 18px);
      font-weight: 600;
      }
      .modal-buttons .btn-cancel {
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      }
      .modal-buttons .btn-save {
      background: var(--accent);
      color: var(--bg);
      }
      .modal-buttons .btn-delete {
      background: var(--danger);
      color: white;
      }
      .confirm-modal p {
      color: var(--text-soft);
      font-size: clamp(14px, 1.6vw, 18px);
      margin: 0 0 20px 0;
      }
      .context-menu-item {
      transition: background 0.15s;
      }
      .context-menu-item:hover {
      background: var(--panel);
      }
      .badge-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      }
      .badge {
      border: 1px solid var(--edge-main);
      padding: 5px 12px;
      border-radius: 22px;
      font-size: clamp(12px, 1.4vw, 18px);
      }
      .badge.wg {
      color: var(--accent);
      border-color: var(--accent);
      }
      .section-label {
      margin-top: 8px;
      font-size: clamp(14px, 1.6vw, 20px);
      text-transform: uppercase;
      color: var(--text-soft);
      }
      .list li {
      margin: 6px 0;
      font-size: clamp(14px, 1.6vw, 20px);
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      }
      .list li:hover {
      color: var(--accent);
      }
      .delete-note {
      color: var(--danger);
      font-size: 18px;
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.2s;
      flex-shrink: 0;
      }
      .list li:hover .delete-note {
      opacity: 1;
      }
      .editing {
      outline: 2px solid var(--accent);
      background: #0d141f;
      padding: 4px;
      border-radius: 6px;
      user-select: text;
      -webkit-user-select: text;
      }
      .version-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .version-item:hover {
      background: var(--panel-alt);
      border-color: var(--accent);
      }
      .version-item.current {
      border-color: var(--accent);
      background: rgba(79, 209, 197, 0.1);
      }
      .version-info {
      flex: 1;
      }
      .version-info .timestamp {
      font-size: 13px;
      color: var(--text-main);
      font-weight: 600;
      }
      .version-info .details {
      font-size: 11px;
      color: var(--text-soft);
      margin-top: 4px;
      }
      .version-actions {
      display: flex;
      gap: 6px;
      }
      .audit-entry {
      padding: 8px 12px;
      background: var(--panel);
      border-left: 3px solid var(--edge-main);
      border-radius: 4px;
      font-size: 12px;
      }
      .audit-entry.node { border-left-color: #4fd1c5; }
      .audit-entry.connection { border-left-color: #9f7aea; }
      .audit-entry.style { border-left-color: #ed8936; }
      .audit-entry.rack { border-left-color: #48bb78; }
      .audit-entry.layer { border-left-color: #4299e1; }
      .audit-entry .time {
      color: var(--text-soft);
      font-size: 10px;
      }
      .audit-entry .action {
      color: var(--text-main);
      font-weight: 500;
      }
      .tab-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .tab-item:hover {
      background: var(--panel-alt);
      }
      .tab-item.active {
      border-color: var(--accent);
      background: rgba(79, 209, 197, 0.1);
      }
      .tab-item .tab-name {
      font-weight: 600;
      color: var(--text-main);
      flex: 1;
      }
      .tab-item .tab-stats {
      font-size: 11px;
      color: var(--text-soft);
      margin-right: 10px;
      }
      .tab-actions {
      display: flex;
      gap: 6px;
      }    
      .secret-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      border-left: 3px solid var(--danger);
      }
      .secret-item .secret-name {
      font-weight: 600;
      color: var(--text-main);
      flex: 1;
      }
      .secret-item .secret-status {
      font-size: 11px;
      color: var(--text-soft);
      margin-right: 10px;
      }    
      .mobile-menu-btn {
      display: none;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      color: var(--text-main);
      font-size: 22px;
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      }
      #topbar-menu {
      gap: 8px;
      }
      @media (min-width: 721px) {
      #topbar-menu {
      display: flex !important;
      }
      }
      @media (max-width: 720px) {
      #topbar-menu {
      display: none;
      }
      #topbar-menu.open {
      display: flex;
      }
      }
      @media (max-width: 720px) {
      .mobile-menu-btn {
      display: block;
      }
      #topbar-menu {
      position: absolute;
      top: var(--topbar-height);
      right: 0;
      background: var(--panel-alt);
      border-left: 1px solid var(--topbar-border);
      border-bottom: 1px solid var(--topbar-border);
      padding: 12px;
      display: none;
      flex-direction: column;
      width: 180px;
      z-index: 999;
      }
      #topbar-menu.open {
      display: flex;
      }
      header {
      position: relative;
      z-index: 9999;
      }
      }
      @media (max-width: 720px) {
      .draw-toolbar {
      position: absolute;
      top: auto;
      bottom: auto;
      left: 10px !important;
      right: auto !important;
      width: auto;
      gap: 6px;
      padding: 8px;
      }
      .topology-toolbar {
      position: absolute;
      top: auto;
      bottom: auto;
      width: auto;
      gap: 6px;
      padding: 8px;
      }
      .draw-toolbar {
      top: 10px !important;
      z-index:99;
      }
      .topology-toolbar {
      z-index:99;
      top: calc(10px + var(--draw-toolbar-height, 50px)) !important;
      }
      .canvas-hint {
      top: calc(10px + 120px);
      }
      #search-input {
      width: 100%;
      }
      }
    </style>
  </head>
  <body style="background: rgb(212, 215, 221);" class="">
    <div class="modal" id="edit-modal">
      <div class="modal-content">
        <h3 id="modal-title">Edit Title</h3>
        <input type="text" id="modal-input">
        <div class="modal-buttons">
          <button class="btn-cancel" id="modal-cancel">Cancel</button>
          <button class="btn-save" id="modal-save">Save</button>
        </div>
      </div>
    </div>
    <div class="modal confirm-modal" id="confirm-modal">
      <div class="modal-content">
        <h3>Confirm</h3>
        <p id="confirm-message"> Are you sure you want to delete this line? </p>
        <div class="modal-buttons">
          <button class="btn-cancel" id="confirm-cancel">Cancel</button>
          <button class="btn-delete" id="confirm-delete">Delete</button>
        </div>
      </div>
    </div>
    <div class="modal" id="save-info-modal">
      <div class="modal-content">
        <h3>Why do I need to save?</h3>
        <p> Browsers are not allowed to overwrite local files automatically. When you click <strong>Save File</strong>, this page generates a new updated HTML file that contains all of your changes. Replace your old file with the new one to keep your edits. </p>
        <p style="margin-top: 12px;padding-top: 12px;border-top: 1px solid var(--edge-main);">
          <strong>Encryption:</strong> Check the "Encrypt" box before saving to password protect your data. You'll need the password to open the file later. No recovery possible!!
        </p>
		<p style="margin-top: 12px;padding-top: 12px;border-top: 1px solid var(--edge-main);">
          <strong>Decrpytion:</strong> Want to decrpyt your data? Simply export it using json export in top menu after successful password validation
        </p>
        <div class="modal-buttons">
          <button class="btn-cancel" id="save-info-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="settings-modal">
      <div class="modal-content" style="max-width: 400px">
        <h3>Page Settings</h3>
        <details class="style-section" open="">
          <summary>Background</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Solid Color</label>
              <input type="color" id="page-bg-color" value="#050608">
            </div>
            <p style="margin-top: 4px;font-size: 12px;color: var(--text-soft);">Change to apply a flat background color.</p>
          </div>
        </details>
        <details class="style-section" open="">
          <summary>Top Bar</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="topbar-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="topbar-border-color" value="#1f2533">
            </div>
          </div>
        </details>
        <details class="style-section" open="">
          <summary>Theme Colors</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Panel</label>
              <input type="color" id="panel-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Panel Alt</label>
              <input type="color" id="panel-alt-color" value="#10141b">
            </div>
            <div class="style-row">
              <label>Accent</label>
              <input type="color" id="accent-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Danger</label>
              <input type="color" id="danger-color" value="#f56565">
            </div>
            <div class="style-row">
              <label>Text Main</label>
              <input type="color" id="text-main-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Text Soft</label>
              <input type="color" id="text-soft-color" value="#94a3b8">
            </div>
          </div>
        </details>
        <details class="style-section" open="">
          <summary>Import / Export Data</summary>
          <div class="style-content">
            <p style="
              margin-bottom: 12px;
              font-size: 13px;
              color: var(--text-soft);
              "> Export/Import your data to upgrade/downgrade versions of The One File. </p>
            <button id="export-data-btn" style="width: 100%;margin-bottom: 10px;padding: 10px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Export Data (JSON)</button>
            <button id="import-data-btn" style="width: 100%;padding: 10px;background: var(--panel);color: var(--text-main);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Import Data (JSON)</button>
            <input type="file" id="import-data-file" accept=".json" style="display: none">
          </div>
        </details>
        <details class="style-section" open="">
          <summary>Clear All</summary>
          <div class="style-content">
            <p style="margin-bottom: 12px;font-size: 13px;color: var(--text-soft);">This deletes everything on the canvas!</p>
            <button id="clear-all-btn" title="Clear all nodes" style="padding: 6px 12px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Clear All</button>
            <input type="file" id="import-data-file" accept=".json" style="display: none">
          </div>
        </details>
        <div class="modal-buttons">
          <button class="btn-cancel" id="settings-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="add-node-modal">
      <div class="modal-content">
        <h3>Add New Node</h3>
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Name</label>
        <input type="text" id="new-node-name" placeholder="e.g. web-server">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">IP / Subtitle</label>
        <input type="text" id="new-node-ip" placeholder="e.g. 192.168.1.100">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Tags (comma separated)</label>
        <input type="text" id="new-node-tags" placeholder="e.g. Docker, nginx, WG: vpn">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Shape</label>
        <select id="new-node-shape">
          <optgroup label="Basic Shapes">
            <option value="circle">Circle</option>
            <option value="square">Square</option>
            <option value="rectangle">Rectangle</option>
            <option value="triangle">Triangle</option>
            <option value="hexagon">Hexagon</option>
            <option value="diamond">Diamond</option>
            <option value="star">Star</option>
            <option value="stop-sign">Stop Sign</option>
          </optgroup>
          <optgroup label="Network Equipment">
            <option value="server">Server</option>
            <option value="pc">PC / Desktop</option>
            <option value="laptop">Laptop</option>
            <option value="phone">Phone / Mobile</option>
            <option value="router">Router</option>
            <option value="switch">Switch</option>
            <option value="firewall">Firewall</option>
            <option value="cloud">Cloud</option>
            <option value="database">Database</option>
            <option value="printer">Printer</option>
          </optgroup>
        </select>
        <div class="modal-buttons">
          <button class="btn-cancel" id="add-node-cancel">Cancel</button>
          <button class="btn-save" id="add-node-save">Add Node</button>
        </div>
      </div>
    </div>
    <div class="modal" id="add-rack-modal">
      <div class="modal-content">
        <h3>Add New Rack</h3>
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Rack Name</label>
        <input type="text" id="new-rack-name" placeholder="e.g. Rack-A, DC1-R01">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">IP / Network Range (optional)</label>
        <input type="text" id="new-rack-ip" placeholder="e.g. 192.168.1.0/24">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Tags (comma separated)</label>
        <input type="text" id="new-rack-tags" placeholder="e.g. Production, Data Center 1">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Icon / Shape</label>
        <select id="new-rack-shape">
          <optgroup label="Basic Shapes">
            <option value="circle">Circle</option>
            <option value="square">Square</option>
            <option value="rectangle">Rectangle</option>
            <option value="triangle">Triangle</option>
            <option value="hexagon">Hexagon</option>
            <option value="diamond">Diamond</option>
            <option value="star">Star</option>
            <option value="stop-sign">Stop Sign</option>
          </optgroup>
          <optgroup label="Network Equipment">
            <option value="server" selected="">Server</option>
            <option value="pc">PC / Desktop</option>
            <option value="laptop">Laptop</option>
            <option value="phone">Phone / Mobile</option>
            <option value="router">Router</option>
            <option value="switch">Switch</option>
            <option value="firewall">Firewall</option>
            <option value="cloud">Cloud</option>
            <option value="database">Database</option>
            <option value="printer">Printer</option>
          </optgroup>
        </select>
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Rack Capacity</label>
        <select id="new-rack-capacity">
          <option value="42" selected="">42U (Standard Full Rack)</option>
          <option value="48">48U (Large Rack)</option>
          <option value="24">24U (Half Rack)</option>
          <option value="12">12U (Small/Wall Mount)</option>
          <option value="6">6U (Mini Rack)</option>
        </select>
        <div class="modal-buttons">
          <button class="btn-cancel" id="add-rack-cancel">Cancel</button>
          <button class="btn-save" id="add-rack-save">Add Rack</button>
        </div>
      </div>
    </div>
    <div class="modal confirm-modal" id="clear-all-modal">
      <div class="modal-content">
        <h3>Clear All Nodes</h3>
        <p> This will remove ALL nodes and connections. This cannot be undone until you reload without saving. Are you sure? </p>
        <div class="modal-buttons">
          <button class="btn-cancel" id="clear-all-cancel">Cancel</button>
          <button class="btn-delete" id="clear-all-confirm">Clear Everything</button>
        </div>
      </div>
    </div>
    <div class="modal" id="layer-modal">
      <div class="modal-content" style="max-width: 400px;">
        <h3>Layer Visibility</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Toggle which layers are visible on the canvas</p>
        <div style="display: flex; flex-direction: column; gap: 10px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-physical" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Physical Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-logical" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Logical Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-security" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Security Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-application" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Application Layer</span>
          </label>
        </div>
        <div style="margin-top: 15px; display: flex; gap: 8px;">
          <button class="btn-cancel" style="flex: 1;" onclick="document.querySelectorAll('#layer-modal input[type=checkbox]').forEach(cb =&gt; cb.checked = false); applyLayerFilter();">Hide All</button>
          <button class="btn-save" style="flex: 1;" onclick="document.querySelectorAll('#layer-modal input[type=checkbox]').forEach(cb =&gt; cb.checked = true); applyLayerFilter();">Show All</button>
        </div>
        <div class="modal-buttons" style="margin-top: 10px;">
          <button class="btn-cancel" id="layer-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="tabs-modal">
      <div class="modal-content" style="max-width: 600px;">
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Manage multiple topologies</p>
        <div id="tabs-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 400px; overflow-y: auto; margin-bottom: 15px;">
            <div class="tab-item active" onclick="switchTab(0)">
              <div class="tab-name">Corporate</div>
              <div class="tab-stats">36 nodes ‚Ä¢ 41 connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(0)" title="Rename tab">‚úèÔ∏è</button>
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(${index})" title="Delete tab">üóëÔ∏è</button>
              </div>
            </div>
          
            <div class="tab-item " onclick="switchTab(1)">
              <div class="tab-name">Homelab</div>
              <div class="tab-stats">19 nodes ‚Ä¢ 17 connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(1)" title="Rename tab">‚úèÔ∏è</button>
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(${index})" title="Delete tab">üóëÔ∏è</button>
              </div>
            </div>
          </div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="new-tab-name" placeholder="New tab name..." style="flex: 1; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <button class="btn-save" onclick="createNewTab()">+ Add Tab</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="tabs-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="rollback-modal">
      <div class="modal-content" style="max-width: 700px;">
        <h3>Version History</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Limit: Snapshots</p>
        <div id="rollback-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 450px; overflow-y: auto; margin-bottom: 15px;">
          <div style="text-align: center; padding: 40px; color: var(--text-soft);">No version history yet. Versions are saved automatically when you save the file.</div>
        </div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <button class="btn-cancel" onclick="clearRollbackHistory()">Clear History</button>
          <button class="btn-save" onclick="createManualSnapshot()">Create Snapshot</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="rollback-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="audit-log-modal">
      <div class="modal-content" style="max-width: 800px;">
        <h3>Audit Log</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Track all changes made to your topology</p>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <select id="audit-filter" style="padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
            <option value="all">All Events</option>
            <option value="node">Node Operations</option>
            <option value="connection">Connections</option>
            <option value="style">Style Changes</option>
            <option value="rack">Rack Operations</option>
            <option value="layer">Layer Changes</option>
          </select>
          <button class="btn-save" onclick="exportAuditLog()">Export</button>
        </div>
        <div id="audit-log-list" style="display: flex; flex-direction: column; gap: 4px; max-height: 450px; overflow-y: auto; margin-bottom: 15px; font-family: monospace; font-size: 12px;">
          <div style="text-align: center; padding: 40px; color: var(--text-soft);">No audit entries yet</div>
        </div>
        <div style="display: flex; gap: 8px;">
          <button class="btn-cancel" onclick="clearAuditLog()">Clear Log</button>
          <button class="btn-cancel" id="audit-log-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="secrets-modal">
      <div class="modal-content" style="max-width: 600px;">
        <h3>Notes</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Notes can also be stored with AES 256 encryption</p>
        <div id="secrets-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 350px; overflow-y: auto; margin-bottom: 15px;">
        </div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="new-secret-name" placeholder="Note name (e.g., 'Root Passwords')..." style="flex: 1; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <button class="btn-save" onclick="createNewSecret()">+ Add Note</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="secrets-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="secret-editor-modal">
      <div class="modal-content" style="max-width: 600px;">
        <h3 id="secret-editor-title">Edit Note</h3>
        <textarea id="secret-editor-content" placeholder="Enter sensitive information here..." style="width: 100%; height: 200px; padding: 12px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main); font-family: monospace; resize: vertical; margin-bottom: 15px;"></textarea>
        <div style="margin-bottom: 15px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
          <input type="checkbox" id="secret-auto-encrypt" checked="" style="cursor: pointer;">
          <span>Encrypt Note</span>
          </label>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" onclick="closeSecretEditor()">Cancel</button>
          <button class="btn-save" onclick="saveSecret()">Save</button>
        </div>
      </div>
    </div>
    <div id="context-menu" style="display: none !important;">
    </div>
    <header>
      <div class="title-block">
        <h1 id="page-title" class="editable-page-title">Corporate</h1>
        <div class="save-row">
          <button id="save-file-btn" class="save-btn" type="button">Save File</button>
          <label style="display: flex;align-items: center;gap: 4px;font-size: 12px;color: var(--text-soft);cursor: pointer;user-select: none;">
          <input type="checkbox" id="encrypt-toggle" style="cursor: pointer">
          <span title="Encrypt data with password">Encrypt</span>
          </label>
          <span id="save-help-btn" class="help-icon" title="Why save?">?</span>
        </div>
      </div>
      <div id="topbar-menu">
        <button id="back-to-topology-btn" title="Exit rack view and return to topology" style="padding: 6px 12px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;display: none;">‚Üê Back to Topology</button>
        <button id="add-node-btn" class="save-btn" title="Add new node" style="background: var(--accent)" draggable="true">+ Node</button>
        <button id="add-rack-btn" class="save-btn" title="Add new rack" style="background: var(--accent); margin-left: 8px;" draggable="true">+ Rack</button>
        <button id="undo-btn" title="Undo (Ctrl+Z)" style="padding: 6px 12px;background: var(--panel);color: var(--text-main);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;" disabled="">‚Ü∂</button>
        <button id="redo-btn" title="Redo (Ctrl+Y)" style="padding: 6px 12px;background: var(--panel);color: var(--text-main);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;" disabled="">‚Ü∑</button>
        <input type="text" id="search-nodes" placeholder="Search nodes..." title="Search by name, IP, MAC, role, or tag" style="padding: 6px 12px;background: var(--panel);color: var(--text-main);border: 1px solid var(--edge-main);border-radius: 6px;font-size: 14px;width: 180px;">
        <button id="layers-btn" title="Toggle layer visibility" style="padding: 6px 12px;background: var(--panel);color: var(--text-main);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Layers</button>
        <button id="tabs-btn" title="Manage document tabs" style="padding: 6px 12px;background: var(--panel);color: var(--text-main);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Tabs</button>
        <button id="rollback-btn" title="View version history" style="padding: 6px 12px;background: var(--panel);color: var(--text-main);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Snapshots</button>
        <button id="audit-log-btn" title="View audit log" style="padding: 6px 12px;background: var(--panel);color: var(--text-main);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Audit</button>
        <button id="secrets-btn" title="Manage encrypted notes" style="padding: 6px 12px;background: var(--panel);color: var(--text-main);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Notes</button>
        <button onclick="screenshotCanvas()" title="Export canvas as PNG image" style="padding: 6px 12px;background: var(--panel);color: var(--text-main);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">PNG</button>
        <button onclick="exportCanvasSVG()" title="Export canvas as SVG vector" style="padding: 6px 12px;background: var(--panel);color: var(--text-main);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">SVG</button>
        <button id="settings-btn" title="Page settings">‚öôÔ∏è</button>
      </div>
      <button id="mobile-menu-toggle" class="mobile-menu-btn">‚ò∞</button>
      <div class="header-resizer" id="header-resizer">
        <svg class="resizer-icon" width="40" height="6" viewBox="0 0 40 6" xmlns="http://www.w3.org/2000/svg">
          <circle cx="14" cy="3" r="2"></circle>
          <circle cx="20" cy="3" r="2"></circle>
          <circle cx="26" cy="3" r="2"></circle>
        </svg>
      </div>
    </header>
    <main>
      <section class="topology-panel">
        <div class="draw-toolbar" id="draw-toolbar" style="display: flex !important;">
          <button type="button" class="toolbar-close-btn" id="draw-toolbar-close-btn" title="Hide draw toolbar">‚úï</button>
          <button id="draw-toggle" title="Draw custom line">‚úèÔ∏è</button>
          <button id="rect-toggle" title="Draw rectangle">‚ñ≠</button>
          <button id="text-toggle" title="Add text">T</button>
          <select id="rect-style" title="Rectangle style">
            <option value="filled">Filled</option>
            <option value="outlined">Outlined</option>
          </select>
          <input type="color" id="draw-color" value="#f97316" title="Line color">
          <select id="draw-style" title="Line style">
            <option value="solid">Solid</option>
            <option value="dashed">Dashed</option>
            <option value="dotted">Dotted</option>
          </select>
          <select id="draw-arrow" title="Arrow direction">
            <option value="none">No arrows</option>
            <option value="forward">‚Üí Right</option>
            <option value="backward">‚Üê Left</option>
            <option value="both">‚Üî Both</option>
          </select>
          <button id="draw-undo" style="display: none" title="Undo last point">Undo</button>
        </div>
        <div class="topology-toolbar" id="topology-toolbar" style="display: flex !important;">
          <button type="button" class="toolbar-close-btn" id="topology-toolbar-close-btn" title="Hide add line toolbar">‚úï</button>
          <label for="add-line-select">Add line to:</label>
          <select id="add-line-select"><option value="edge-firewall">Edge Firewall</option><option value="core-router-1">Core Router 1</option><option value="core-router-2">Core Router 2</option><option value="core-switch-1">Core Switch 1</option><option value="core-switch-2">Core Switch 2</option><option value="load-balancer">Load Balancer</option><option value="web-server-1">Web Server 1</option><option value="web-server-2">Web Server 2</option><option value="web-server-3">Web Server 3</option><option value="internal-fw">Internal Firewall</option><option value="ad-dc-1">Domain Controller 1</option><option value="ad-dc-2">Domain Controller 2</option><option value="file-server">File Server</option><option value="db-primary">Database Primary</option><option value="db-replica">Database Replica</option><option value="app-server-1">App Server 1</option><option value="app-server-2">App Server 2</option><option value="app-server-3">App Server 3</option><option value="k8s-master-1">K8s Master 1</option><option value="k8s-master-2">K8s Master 2</option><option value="k8s-worker-1">K8s Worker 1</option><option value="k8s-worker-2">K8s Worker 2</option><option value="k8s-worker-3">K8s Worker 3</option><option value="backup-server">Backup Server</option><option value="monitoring">Monitoring</option><option value="vpn-gateway">VPN Gateway</option><option value="san-storage">SAN Storage</option><option value="workstation-vlan">User Workstations</option><option value="guest-wifi-controller">WiFi Controller</option><option value="remote-workers">Remote Workers</option><option value="mail-server">Mail Server</option><option value="racked">Racked</option><option value="noded">noded</option></select>
          <input type="color" id="add-line-color" value="#475569" title="Line color" style="width: 30px;height: 24px;border: 1px solid var(--edge-main);border-radius: 4px;cursor: pointer;background: transparent;padding: 0;">
          <select id="add-line-direction" title="Line direction">
            <option value="none">No arrows</option>
            <option value="forward">‚Üí Forward</option>
            <option value="backward">‚Üê Backward</option>
            <option value="both">‚Üî Both</option>
          </select>
          <button id="add-line-btn">Add</button>
        </div>
        <div class="topology-toolbar bulk-toolbar-desktop" id="bulk-toolbar" style="display: none">
          <button type="button" class="toolbar-close-btn" id="bulk-toolbar-close" title="Clear selection">‚úï</button>
          <label style="font-weight: 600; color: var(--accent)">Selected: <span id="bulk-count">0</span></label>
          <button id="bulk-align-left" title="Align left">‚¨Ö Left</button>
          <button id="bulk-align-right" title="Align right">‚û° Right</button>
          <button id="bulk-align-top" title="Align top">‚¨Ü Top</button>
          <button id="bulk-align-bottom" title="Align bottom">‚¨á Bottom</button>
          <button id="bulk-distribute-h" title="Distribute horizontally">‚Üî Distribute H</button>
          <button id="bulk-distribute-v" title="Distribute vertically">‚Üï Distribute V</button>
          <button id="bulk-clone" title="Clone selected">üìã Clone</button>
          <button id="bulk-delete" title="Delete selected" style="background: var(--danger); color: white;">Delete</button>
        </div>
        <div class="bulk-toolbar-mobile" id="bulk-toolbar-mobile" style="display: none">
          <button type="button" id="bulk-mobile-btn" style="background: var(--accent);color: white;padding: 12px 20px;border-radius: 25px;font-weight: 600;font-size: 16px;box-shadow: 0 4px 12px rgba(0,0,0,0.3);border: none;cursor: pointer;display: flex;align-items: center;gap: 8px;">
          <span id="bulk-count-mobile">0</span>Selected</button>
        </div>
        <div id="bulk-actions-modal" style="display: none;position: fixed;bottom: 0;left: 0;right: 0;background: var(--panel-alt);border-top-left-radius: 20px;border-top-right-radius: 20px;padding: 20px;padding-bottom: env(safe-area-inset-bottom, 20px);box-shadow: 0 -4px 20px rgba(0,0,0,0.5);z-index: 10000;max-height: calc(100vh - 80px);overflow-y: auto;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            <h3 style="margin: 0; color: var(--accent); font-size: 20px;">
              <span id="bulk-count-modal">0</span> Nodes Selected
            </h3>
            <button id="bulk-modal-close" style="background: none;border: none;font-size: 24px;cursor: pointer;color: var(--text-main);padding: 0;width: 32px;height: 32px;">‚úï</button>
          </div>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
            <button id="bulk-align-left-mobile" class="bulk-action-btn">‚¨Ö<br><span style="font-size: 12px;">Align Left</span></button>
            <button id="bulk-align-right-mobile" class="bulk-action-btn">‚û°<br><span style="font-size: 12px;">Align Right</span></button>
            <button id="bulk-align-top-mobile" class="bulk-action-btn">‚¨Ü<br><span style="font-size: 12px;">Align Top</span></button>
            <button id="bulk-align-bottom-mobile" class="bulk-action-btn">‚¨á<br><span style="font-size: 12px;">Align Bottom</span></button>
            <button id="bulk-distribute-h-mobile" class="bulk-action-btn">‚Üî<br><span style="font-size: 12px;">Distribute H</span></button>
            <button id="bulk-distribute-v-mobile" class="bulk-action-btn">‚Üï<br><span style="font-size: 12px;">Distribute V</span></button>
            <button id="bulk-lock-mobile" class="bulk-action-btn">üîí<br><span style="font-size: 12px;">Lock Toggle</span></button>
            <button id="bulk-group-mobile" class="bulk-action-btn">‚≠ï<br><span style="font-size: 12px;">Group Toggle</span></button>
            <button id="bulk-clone-mobile" class="bulk-action-btn">üìã<br><span style="font-size: 12px;">Clone All</span></button>
            <button id="bulk-delete-mobile" class="bulk-action-btn" style="background: var(--danger); color: white;">üóë<br><span style="font-size: 12px;">Delete All</span></button>
          </div>
          <button id="bulk-clear-mobile" style="width: 100%;margin-top: 16px;padding: 14px;background: var(--panel-main);border: 1px solid var(--edge-main);border-radius: 8px;color: var(--text-main);font-size: 16px;cursor: pointer;">Clear Selection</button>
        </div>
        <div class="canvas-hint" id="canvas-hint"><ul><li>Scroll to zoom</li><li>Drag to pan</li><li>Right-click to clone and align</li><li>Right-click to select multiple</li><li>You have the power</li><li>Your time is NOW!</li></ul></div>
        <div class="legend-container" id="edge-legend" style="display: flex;"><div class="legend-title">Line Legend</div><button type="button" class="legend-close-btn">‚úï</button><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(239, 68, 68); cursor: pointer;"></span><span class="legend-label" contenteditable="true">WAN / Internet (10 Gbps)</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(249, 115, 22); cursor: pointer;"></span><span class="legend-label" contenteditable="true">Core Layer (10-40 Gbps)</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(59, 130, 246); cursor: pointer;"></span><span class="legend-label" contenteditable="true">Core Switching &amp; HSRP</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(139, 92, 246); cursor: pointer;"></span><span class="legend-label" contenteditable="true">DMZ Network</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(16, 185, 129); cursor: pointer;"></span><span class="legend-label" contenteditable="true">Internal Corporate Network</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(6, 182, 212); cursor: pointer;"></span><span class="legend-label" contenteditable="true">Data Center / Application Tier</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(20, 184, 166); cursor: pointer;"></span><span class="legend-label" contenteditable="true">Database Replication</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(100, 116, 139); cursor: pointer;"></span><span class="legend-label" contenteditable="true">App-to-DB Connections</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(236, 72, 153); cursor: pointer;"></span><span class="legend-label" contenteditable="true">Kubernetes Cluster</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(245, 158, 11); cursor: pointer;"></span><span class="legend-label" contenteditable="true">Management Network</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(168, 85, 247); cursor: pointer;"></span><span class="legend-label" contenteditable="true">VPN / Remote Access</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(14, 165, 233); cursor: pointer;"></span><span class="legend-label" contenteditable="true">Storage Area Network (SAN)</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(132, 204, 22); cursor: pointer;"></span><span class="legend-label" contenteditable="true">Branch Office WAN</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(251, 191, 36); cursor: pointer;"></span><span class="legend-label" contenteditable="true">Guest WiFi Network</span></div></div>
        <div class="canvas-viewport" id="canvas-viewport">
          <svg id="map" viewBox="38.14866129557299 -55 2052.8478190104165 1539.6358642578125" style=""><defs><marker id="arrow-forward" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto" markerUnits="strokeWidth"><path d="M0,0 L0,6 L9,3 z" fill="context-stroke"></path></marker><marker id="arrow-backward" markerWidth="10" markerHeight="10" refX="0" refY="3" orient="auto" markerUnits="strokeWidth"><path d="M9,0 L9,6 L0,3 z" fill="context-stroke"></path></marker></defs><rect x="100" y="100" width="3800" height="2800" fill="none" stroke="rgba(71, 85, 105, 0.3)" stroke-width="2" stroke-dasharray="10 5" rx="8"></rect><path d="M 600 155 Q 600 202.5 600 250" fill="none" class="edge active" data-edge-id="e1" data-from="internet" data-to="edge-firewall" style="stroke: rgb(239, 68, 68); stroke-width: 8;"></path><path d="M 600 155 Q 600 202.5 600 250" fill="none" data-edge-id="e1" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 600 250 Q 499.07862854003906 335 398.1572570800781 420" fill="none" class="edge" data-edge-id="e2" data-from="edge-firewall" data-to="core-router-1" style="stroke: rgb(249, 115, 22); stroke-width: 7;"></path><path d="M 600 250 Q 499.07862854003906 335 398.1572570800781 420" fill="none" data-edge-id="e2" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 600 250 Q 700 335 800 420" fill="none" class="edge" data-edge-id="e3" data-from="edge-firewall" data-to="core-router-2" style="stroke: rgb(249, 115, 22); stroke-width: 7;"></path><path d="M 600 250 Q 700 335 800 420" fill="none" data-edge-id="e3" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 398.1572570800781 420 Q 599.0786285400391 420 800 420" fill="none" class="edge" data-edge-id="e4" data-from="core-router-1" data-to="core-router-2" style="stroke: rgb(59, 130, 246); stroke-width: 6;"></path><path d="M 398.1572570800781 420 Q 599.0786285400391 420 800 420" fill="none" data-edge-id="e4" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 398.1572570800781 420 Q 399.07862854003906 510 400 600" fill="none" class="edge" data-edge-id="e5" data-from="core-router-1" data-to="core-switch-1" style="stroke: rgb(59, 130, 246); stroke-width: 6;"></path><path d="M 398.1572570800781 420 Q 399.07862854003906 510 400 600" fill="none" data-edge-id="e5" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 800 420 Q 800 510 800 600" fill="none" class="edge" data-edge-id="e6" data-from="core-router-2" data-to="core-switch-2" style="stroke: rgb(59, 130, 246); stroke-width: 6;"></path><path d="M 800 420 Q 800 510 800 600" fill="none" data-edge-id="e6" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 400 600 Q 600 600 800 600" fill="none" class="edge" data-edge-id="e7" data-from="core-switch-1" data-to="core-switch-2" style="stroke: rgb(59, 130, 246); stroke-width: 5;"></path><path d="M 400 600 Q 600 600 800 600" fill="none" data-edge-id="e7" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 398.1572570800781 420 Q 299.07862854003906 460 200 500" fill="none" class="edge" data-edge-id="e8" data-from="core-router-1" data-to="load-balancer" style="stroke: rgb(139, 92, 246); stroke-width: 5;"></path><path d="M 398.1572570800781 420 Q 299.07862854003906 460 200 500" fill="none" data-edge-id="e8" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 200 500 Q 172.5 575 145 650" fill="none" class="edge" data-edge-id="e9" data-from="load-balancer" data-to="web-server-1" style="stroke: rgb(139, 92, 246); stroke-width: 4;"></path><path d="M 200 500 Q 172.5 575 145 650" fill="none" data-edge-id="e9" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 200 500 Q 200 600 200 700" fill="none" class="edge" data-edge-id="e10" data-from="load-balancer" data-to="web-server-2" style="stroke: rgb(139, 92, 246); stroke-width: 4;"></path><path d="M 200 500 Q 200 600 200 700" fill="none" data-edge-id="e10" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 200 500 Q 260 575 320 650" fill="none" class="edge" data-edge-id="e11" data-from="load-balancer" data-to="web-server-3" style="stroke: rgb(139, 92, 246); stroke-width: 4;"></path><path d="M 200 500 Q 260 575 320 650" fill="none" data-edge-id="e11" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 400 600 Q 500 690 600 780" fill="none" class="edge" data-edge-id="e12" data-from="core-switch-1" data-to="internal-fw" style="stroke: rgb(16, 185, 129); stroke-width: 6;"></path><path d="M 400 600 Q 500 690 600 780" fill="none" data-edge-id="e12" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 800 600 Q 700 690 600 780" fill="none" class="edge" data-edge-id="e13" data-from="core-switch-2" data-to="internal-fw" style="stroke: rgb(16, 185, 129); stroke-width: 6;"></path><path d="M 800 600 Q 700 690 600 780" fill="none" data-edge-id="e13" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 600 780 Q 550 865 500 950" fill="none" class="edge" data-edge-id="e14" data-from="internal-fw" data-to="ad-dc-1" style="stroke: rgb(16, 185, 129); stroke-width: 4;"></path><path d="M 600 780 Q 550 865 500 950" fill="none" data-edge-id="e14" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 600 780 Q 610 865 620 950" fill="none" class="edge" data-edge-id="e15" data-from="internal-fw" data-to="ad-dc-2" style="stroke: rgb(16, 185, 129); stroke-width: 4;"></path><path d="M 600 780 Q 610 865 620 950" fill="none" data-edge-id="e15" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 600 780 Q 670 865 740 950" fill="none" class="edge" data-edge-id="e16" data-from="internal-fw" data-to="file-server" style="stroke: rgb(16, 185, 129); stroke-width: 4;"></path><path d="M 600 780 Q 670 865 740 950" fill="none" data-edge-id="e16" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 600 780 Q 790 865 980 950" fill="none" class="edge" data-edge-id="e17" data-from="internal-fw" data-to="workstation-vlan" style="stroke: rgb(16, 185, 129); stroke-width: 5;"></path><path d="M 600 780 Q 790 865 980 950" fill="none" data-edge-id="e17" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 600 780 Q 730 865 860 950" fill="none" class="edge" data-edge-id="e18" data-from="internal-fw" data-to="mail-server" style="stroke: rgb(16, 185, 129); stroke-width: 4;"></path><path d="M 600 780 Q 730 865 860 950" fill="none" data-edge-id="e18" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 400 600 Q 300 725 200 850" fill="none" class="edge" data-edge-id="e19" data-from="core-switch-1" data-to="db-primary" style="stroke: rgb(6, 182, 212); stroke-width: 5;"></path><path d="M 400 600 Q 300 725 200 850" fill="none" data-edge-id="e19" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 200 850 Q 175 925 150 1000" fill="none" class="edge" data-edge-id="e20" data-from="db-primary" data-to="db-replica" style="stroke: rgb(20, 184, 166); stroke-width: 4;"></path><path d="M 200 850 Q 175 925 150 1000" fill="none" data-edge-id="e20" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 400 600 Q 300 825 200 1050" fill="none" class="edge" data-edge-id="e21" data-from="core-switch-1" data-to="app-server-1" style="stroke: rgb(6, 182, 212); stroke-width: 4;"></path><path d="M 400 600 Q 300 825 200 1050" fill="none" data-edge-id="e21" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 400 600 Q 360 825 320 1050" fill="none" class="edge" data-edge-id="e22" data-from="core-switch-1" data-to="app-server-2" style="stroke: rgb(6, 182, 212); stroke-width: 4;"></path><path d="M 400 600 Q 360 825 320 1050" fill="none" data-edge-id="e22" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 400 600 Q 420 825 440 1050" fill="none" class="edge" data-edge-id="e23" data-from="core-switch-1" data-to="app-server-3" style="stroke: rgb(6, 182, 212); stroke-width: 4;"></path><path d="M 400 600 Q 420 825 440 1050" fill="none" data-edge-id="e23" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 200 1050 Q 200 950 200 850" fill="none" class="edge" data-edge-id="e24" data-from="app-server-1" data-to="db-primary" style="stroke: rgb(100, 116, 139); stroke-width: 3;"></path><path d="M 200 1050 Q 200 950 200 850" fill="none" data-edge-id="e24" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 320 1050 Q 260 950 200 850" fill="none" class="edge" data-edge-id="e25" data-from="app-server-2" data-to="db-primary" style="stroke: rgb(100, 116, 139); stroke-width: 3;"></path><path d="M 320 1050 Q 260 950 200 850" fill="none" data-edge-id="e25" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 440 1050 Q 320 950 200 850" fill="none" class="edge" data-edge-id="e26" data-from="app-server-3" data-to="db-primary" style="stroke: rgb(100, 116, 139); stroke-width: 3;"></path><path d="M 440 1050 Q 320 950 200 850" fill="none" data-edge-id="e26" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 800 600 Q 850 650 900 700" fill="none" class="edge" data-edge-id="e27" data-from="core-switch-2" data-to="k8s-master-1" style="stroke: rgb(236, 72, 153); stroke-width: 4;"></path><path d="M 800 600 Q 850 650 900 700" fill="none" data-edge-id="e27" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 800 600 Q 910 650 1020 700" fill="none" class="edge" data-edge-id="e28" data-from="core-switch-2" data-to="k8s-master-2" style="stroke: rgb(236, 72, 153); stroke-width: 4;"></path><path d="M 800 600 Q 910 650 1020 700" fill="none" data-edge-id="e28" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 900 700 Q 875 775 850 850" fill="none" class="edge" data-edge-id="e29" data-from="k8s-master-1" data-to="k8s-worker-1" style="stroke: rgb(236, 72, 153); stroke-width: 3;"></path><path d="M 900 700 Q 875 775 850 850" fill="none" data-edge-id="e29" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 900 700 Q 935 775 970 850" fill="none" class="edge" data-edge-id="e30" data-from="k8s-master-1" data-to="k8s-worker-2" style="stroke: rgb(236, 72, 153); stroke-width: 3;"></path><path d="M 900 700 Q 935 775 970 850" fill="none" data-edge-id="e30" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 1020 700 Q 1055.92138671875 774.0786437988281 1091.8427734375 848.1572875976562" fill="none" class="edge" data-edge-id="e31" data-from="k8s-master-2" data-to="k8s-worker-3" style="stroke: rgb(236, 72, 153); stroke-width: 3;"></path><path d="M 1020 700 Q 1055.92138671875 774.0786437988281 1091.8427734375 848.1572875976562" fill="none" data-edge-id="e31" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 800 600 Q 925 600 1050 600" fill="none" class="edge" data-edge-id="e32" data-from="core-switch-2" data-to="backup-server" style="stroke: rgb(245, 158, 11); stroke-width: 4;"></path><path d="M 800 600 Q 925 600 1050 600" fill="none" data-edge-id="e32" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 800 600 Q 975 650 1150 700" fill="none" class="edge" data-edge-id="e33" data-from="core-switch-2" data-to="monitoring" style="stroke: rgb(245, 158, 11); stroke-width: 3;"></path><path d="M 800 600 Q 975 650 1150 700" fill="none" data-edge-id="e33" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 398.1572570800781 420 Q 374.07862854003906 335 350 250" fill="none" class="edge" data-edge-id="e34" data-from="core-router-1" data-to="vpn-gateway" style="stroke: rgb(168, 85, 247); stroke-width: 4;"></path><path d="M 398.1572570800781 420 Q 374.07862854003906 335 350 250" fill="none" data-edge-id="e34" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 350 250 Q 265 197.5 180 145" fill="none" class="edge" data-edge-id="e35" data-from="vpn-gateway" data-to="remote-workers" style="stroke: rgb(168, 85, 247); stroke-width: 3;"></path><path d="M 350 250 Q 265 197.5 180 145" fill="none" data-edge-id="e35" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 400 600 Q 277.5 675 155 750" fill="none" class="edge" data-edge-id="e36" data-from="core-switch-1" data-to="san-storage" style="stroke: rgb(14, 165, 233); stroke-width: 5;"></path><path d="M 400 600 Q 277.5 675 155 750" fill="none" data-edge-id="e36" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 155 750 Q 177.5 800 200 850" fill="none" class="edge" data-edge-id="e37" data-from="san-storage" data-to="db-primary" style="stroke: rgb(14, 165, 233); stroke-width: 3;"></path><path d="M 155 750 Q 177.5 800 200 850" fill="none" data-edge-id="e37" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 155 750 Q 177.5 900 200 1050" fill="none" class="edge" data-edge-id="e38" data-from="san-storage" data-to="app-server-1" style="stroke: rgb(14, 165, 233); stroke-width: 2;"></path><path d="M 155 750 Q 177.5 900 200 1050" fill="none" data-edge-id="e38" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 600 250 Q 1292.0725708007812 767.3179321289062 1984.1451416015625 1284.6358642578125" fill="none" class="edge" data-edge-id="e39" data-from="edge-firewall" data-to="branch-router" style="stroke: rgb(132, 204, 22); stroke-width: 4;"></path><path d="M 600 250 Q 1292.0725708007812 767.3179321289062 1984.1451416015625 1284.6358642578125" fill="none" data-edge-id="e39" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 800 420 Q 925 450 1050 480" fill="none" class="edge" data-edge-id="e41" data-from="core-router-2" data-to="guest-wifi-controller" style="stroke: rgb(251, 191, 36); stroke-width: 3;"></path><path d="M 800 420 Q 925 450 1050 480" fill="none" data-edge-id="e41" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><polyline class="edge" data-edge-id="custom-1764791521180" fill="none" marker-end="url(#arrow-forward)" points="1540.7069091796875,256.9247131347656 1772.041015625,258.7607116699219 1823.4486083984375,401.9675598144531 1610.4742431640625,587.402099609375" style="stroke: rgb(249, 115, 22); stroke-width: 4; stroke-dasharray: none;"></polyline><polyline points="1540.7069091796875,256.9247131347656 1772.041015625,258.7607116699219 1823.4486083984375,401.9675598144531 1610.4742431640625,587.402099609375" data-edge-id="custom-1764791521180" style="fill: none; stroke: transparent; stroke-width: 20; cursor: pointer;"></polyline><g class="node-group active" data-node-id="internet" transform="translate(600,155)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><path d="
             M -44 11
             Q -60.50000000000001 11 -60.50000000000001 -5.5
             Q -60.50000000000001 -27.5 -38.5 -27.5
             Q -38.5 -49.5 -11 -49.5
             Q 5.5 -60.50000000000001 27.5 -44
             Q 55 -44 60.50000000000001 -16.5
             Q 71.5 -5.5 60.50000000000001 11
             Q 60.50000000000001 27.5 38.5 27.5
             L -27.5 27.5
             Q -49.5 27.5 -49.5 11
             Z
            " class="node-circle"></path><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18.15px; pointer-events: none;">Internet</text><text class="node-sub" x="0" y="22" style="font-size: 13.2px; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="edge-firewall" transform="translate(600,250)" style="cursor: grab;"><circle r="105" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-70" y="-56" width="140" height="112" rx="4"></rect><line x1="-59.5" y1="-35" x2="59.5" y2="-35" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-59.5" y1="-3.5" x2="59.5" y2="-3.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-59.5" y1="28" x2="59.5" y2="28" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-35" y1="-56" x2="-35" y2="-24.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="14" y1="-56" x2="14" y2="-24.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-10.5" y1="-24.5" x2="-10.5" y2="7" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="38.5" y1="-24.5" x2="38.5" y2="7" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-35" y1="7" x2="-35" y2="38.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="14" y1="7" x2="14" y2="38.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-10.5" y1="38.5" x2="-10.5" y2="70" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="38.5" y1="38.5" x2="38.5" y2="70" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line></g><text class="node-label" x="0" y="-19.6" style="font-size: 23.1px; pointer-events: none;">Edge Firewall</text><text class="node-sub" x="0" y="28" style="font-size: 16.8px; pointer-events: none;">203.0.113.1</text></g><g class="node-group" data-node-id="core-router-1" transform="translate(398.1572570800781,420)" style="cursor: grab;"><circle r="97.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-71.5" y="-19.5" width="143" height="52" rx="6"></rect><rect x="-42.25" y="-58.5" width="6.5" height="39" rx="2"></rect><circle cx="-39" cy="-61.75" r="5.2"></circle><rect x="-3.25" y="-58.5" width="6.5" height="39" rx="2"></rect><circle cx="0" cy="-61.75" r="5.2"></circle><rect x="35.75" y="-58.5" width="6.5" height="39" rx="2"></rect><circle cx="39" cy="-61.75" r="5.2"></circle><circle cx="-45.5" cy="6.5" r="3.9" style="fill: rgb(74, 222, 128);"></circle><circle cx="-22.75" cy="6.5" r="3.9" style="fill: rgb(74, 222, 128);"></circle><circle cx="0" cy="6.5" r="3.9" style="fill: rgb(250, 204, 21);"></circle><circle cx="22.75" cy="6.5" r="3.9" style="fill: rgb(250, 204, 21);"></circle></g><text class="node-label" x="0" y="-18.200000000000003" style="font-size: 21.45px; pointer-events: none;">Core Router 1</text><text class="node-sub" x="0" y="26" style="font-size: 15.6px; pointer-events: none;">10.0.0.1</text></g><g class="node-group" data-node-id="core-router-2" transform="translate(800,420)" style="cursor: grab;"><circle r="97.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-71.5" y="-19.5" width="143" height="52" rx="6"></rect><rect x="-42.25" y="-58.5" width="6.5" height="39" rx="2"></rect><circle cx="-39" cy="-61.75" r="5.2"></circle><rect x="-3.25" y="-58.5" width="6.5" height="39" rx="2"></rect><circle cx="0" cy="-61.75" r="5.2"></circle><rect x="35.75" y="-58.5" width="6.5" height="39" rx="2"></rect><circle cx="39" cy="-61.75" r="5.2"></circle><circle cx="-45.5" cy="6.5" r="3.9" style="fill: rgb(74, 222, 128);"></circle><circle cx="-22.75" cy="6.5" r="3.9" style="fill: rgb(74, 222, 128);"></circle><circle cx="0" cy="6.5" r="3.9" style="fill: rgb(250, 204, 21);"></circle><circle cx="22.75" cy="6.5" r="3.9" style="fill: rgb(250, 204, 21);"></circle></g><text class="node-label" x="0" y="-18.200000000000003" style="font-size: 21.45px; pointer-events: none;">Core Router 2</text><text class="node-sub" x="0" y="26" style="font-size: 15.6px; pointer-events: none;">10.0.0.2</text></g><g class="node-group" data-node-id="core-switch-1" transform="translate(400,600)" style="cursor: grab;"><circle r="90" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-84" y="-24" width="168" height="48" rx="4"></rect><rect x="-72" y="-9" width="13.2" height="18" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-52.8" y="-9" width="13.2" height="18" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-33.6" y="-9" width="13.2" height="18" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-14.399999999999999" y="-9" width="13.2" height="18" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="4.799999999999997" y="-9" width="13.2" height="18" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="24" y="-9" width="13.2" height="18" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="43.2" y="-9" width="13.2" height="18" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="62.400000000000006" y="-9" width="13.2" height="18" rx="1" style="fill: rgb(30, 41, 59);"></rect></g><text class="node-label" x="0" y="-16.8" style="font-size: 19.8px; pointer-events: none;">Core Switch 1</text><text class="node-sub" x="0" y="24" style="font-size: 14.4px; pointer-events: none;">10.0.0.10</text></g><g class="node-group" data-node-id="core-switch-2" transform="translate(800,600)" style="cursor: grab;"><circle r="90" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-84" y="-24" width="168" height="48" rx="4"></rect><rect x="-72" y="-9" width="13.2" height="18" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-52.8" y="-9" width="13.2" height="18" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-33.6" y="-9" width="13.2" height="18" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-14.399999999999999" y="-9" width="13.2" height="18" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="4.799999999999997" y="-9" width="13.2" height="18" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="24" y="-9" width="13.2" height="18" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="43.2" y="-9" width="13.2" height="18" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="62.400000000000006" y="-9" width="13.2" height="18" rx="1" style="fill: rgb(30, 41, 59);"></rect></g><text class="node-label" x="0" y="-16.8" style="font-size: 19.8px; pointer-events: none;">Core Switch 2</text><text class="node-sub" x="0" y="24" style="font-size: 14.4px; pointer-events: none;">10.0.0.11</text></g><g class="node-group" data-node-id="load-balancer" transform="translate(200,500)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-66" y="-33" width="132" height="66" rx="4"></rect><line x1="-49.5" y1="-16.5" x2="-49.5" y2="16.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="-22" y1="-16.5" x2="-22" y2="16.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="5.5" y1="-16.5" x2="5.5" y2="16.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><circle cx="49.5" cy="0" r="5.5" style="fill: rgb(74, 222, 128);"></circle></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18.15px; pointer-events: none;">Load Balancer</text><text class="node-sub" x="0" y="22" style="font-size: 13.2px; pointer-events: none;">10.1.0.10</text></g><g class="node-group" data-node-id="web-server-1" transform="translate(145,650)" style="cursor: grab;"><circle r="67.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-54" y="-27" width="108" height="54" rx="4"></rect><line x1="-40.5" y1="-13.5" x2="-40.5" y2="13.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="-18" y1="-13.5" x2="-18" y2="13.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="4.5" y1="-13.5" x2="4.5" y2="13.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><circle cx="40.5" cy="0" r="4.5" style="fill: rgb(74, 222, 128);"></circle></g><text class="node-label" x="0" y="-12.600000000000001" style="font-size: 14.85px; pointer-events: none;">Web Server 1</text><text class="node-sub" x="0" y="18" style="font-size: 10.8px; pointer-events: none;">10.1.0.20</text></g><g class="node-group" data-node-id="web-server-2" transform="translate(200,700)" style="cursor: grab;"><circle r="67.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-54" y="-27" width="108" height="54" rx="4"></rect><line x1="-40.5" y1="-13.5" x2="-40.5" y2="13.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="-18" y1="-13.5" x2="-18" y2="13.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="4.5" y1="-13.5" x2="4.5" y2="13.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><circle cx="40.5" cy="0" r="4.5" style="fill: rgb(74, 222, 128);"></circle></g><text class="node-label" x="0" y="-12.600000000000001" style="font-size: 14.85px; pointer-events: none;">Web Server 2</text><text class="node-sub" x="0" y="18" style="font-size: 10.8px; pointer-events: none;">10.1.0.21</text></g><g class="node-group" data-node-id="web-server-3" transform="translate(320,650)" style="cursor: grab;"><circle r="67.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-54" y="-27" width="108" height="54" rx="4"></rect><line x1="-40.5" y1="-13.5" x2="-40.5" y2="13.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="-18" y1="-13.5" x2="-18" y2="13.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="4.5" y1="-13.5" x2="4.5" y2="13.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><circle cx="40.5" cy="0" r="4.5" style="fill: rgb(74, 222, 128);"></circle></g><text class="node-label" x="0" y="-12.600000000000001" style="font-size: 14.85px; pointer-events: none;">Web Server 3</text><text class="node-sub" x="0" y="18" style="font-size: 10.8px; pointer-events: none;">10.1.0.22</text></g><g class="node-group" data-node-id="internal-fw" transform="translate(600,780)" style="cursor: grab;"><circle r="90" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-60" y="-48" width="120" height="96" rx="4"></rect><line x1="-51" y1="-30" x2="51" y2="-30" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-51" y1="-3" x2="51" y2="-3" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-51" y1="24" x2="51" y2="24" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-30" y1="-48" x2="-30" y2="-21" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="12" y1="-48" x2="12" y2="-21" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-9" y1="-21" x2="-9" y2="6" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="33" y1="-21" x2="33" y2="6" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-30" y1="6" x2="-30" y2="33" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="12" y1="6" x2="12" y2="33" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-9" y1="33" x2="-9" y2="60" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="33" y1="33" x2="33" y2="60" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line></g><text class="node-label" x="0" y="-16.8" style="font-size: 19.8px; pointer-events: none;">Internal Firewall</text><text class="node-sub" x="0" y="24" style="font-size: 14.4px; pointer-events: none;">10.2.0.1</text></g><g class="node-group" data-node-id="ad-dc-1" transform="translate(500,950)" style="cursor: grab;"><circle r="75" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-60" y="-30" width="120" height="60" rx="4"></rect><line x1="-45" y1="-15" x2="-45" y2="15" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="-20" y1="-15" x2="-20" y2="15" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="5" y1="-15" x2="5" y2="15" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><circle cx="45" cy="0" r="5" style="fill: rgb(74, 222, 128);"></circle></g><text class="node-label" x="0" y="-14.000000000000002" style="font-size: 16.5px; pointer-events: none;">Domain Controller 1</text><text class="node-sub" x="0" y="20" style="font-size: 12px; pointer-events: none;">10.2.1.10</text></g><g class="node-group" data-node-id="ad-dc-2" transform="translate(620,950)" style="cursor: grab;"><circle r="75" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-60" y="-30" width="120" height="60" rx="4"></rect><line x1="-45" y1="-15" x2="-45" y2="15" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="-20" y1="-15" x2="-20" y2="15" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="5" y1="-15" x2="5" y2="15" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><circle cx="45" cy="0" r="5" style="fill: rgb(74, 222, 128);"></circle></g><text class="node-label" x="0" y="-14.000000000000002" style="font-size: 16.5px; pointer-events: none;">Domain Controller 2</text><text class="node-sub" x="0" y="20" style="font-size: 12px; pointer-events: none;">10.2.1.11</text></g><g class="node-group" data-node-id="file-server" transform="translate(740,950)" style="cursor: grab;"><circle r="75" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-35" y="-30" width="70" height="70"></rect><ellipse cx="0" cy="-30" rx="35" ry="12.5"></ellipse><ellipse cx="0" cy="40" rx="35" ry="12.5"></ellipse><ellipse cx="0" cy="-7.5" rx="35" ry="10" style="fill: none; stroke: rgb(71, 85, 105); stroke-width: 2;"></ellipse><ellipse cx="0" cy="17.5" rx="35" ry="10" style="fill: none; stroke: rgb(71, 85, 105); stroke-width: 2;"></ellipse></g><text class="node-label" x="0" y="-14.000000000000002" style="font-size: 16.5px; pointer-events: none;">File Server</text><text class="node-sub" x="0" y="20" style="font-size: 12px; pointer-events: none;">10.2.1.20</text></g><g class="node-group" data-node-id="db-primary" transform="translate(200,850)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-38.5" y="-33" width="77" height="77"></rect><ellipse cx="0" cy="-33" rx="38.5" ry="13.75"></ellipse><ellipse cx="0" cy="44" rx="38.5" ry="13.75"></ellipse><ellipse cx="0" cy="-8.25" rx="38.5" ry="11" style="fill: none; stroke: rgb(71, 85, 105); stroke-width: 2;"></ellipse><ellipse cx="0" cy="19.25" rx="38.5" ry="11" style="fill: none; stroke: rgb(71, 85, 105); stroke-width: 2;"></ellipse></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18.15px; pointer-events: none;">Database Primary</text><text class="node-sub" x="0" y="22" style="font-size: 13.2px; pointer-events: none;">10.3.0.10</text></g><g class="node-group" data-node-id="db-replica" transform="translate(150,1000)" style="cursor: grab;"><circle r="75" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-35" y="-30" width="70" height="70"></rect><ellipse cx="0" cy="-30" rx="35" ry="12.5"></ellipse><ellipse cx="0" cy="40" rx="35" ry="12.5"></ellipse><ellipse cx="0" cy="-7.5" rx="35" ry="10" style="fill: none; stroke: rgb(71, 85, 105); stroke-width: 2;"></ellipse><ellipse cx="0" cy="17.5" rx="35" ry="10" style="fill: none; stroke: rgb(71, 85, 105); stroke-width: 2;"></ellipse></g><text class="node-label" x="0" y="-14.000000000000002" style="font-size: 16.5px; pointer-events: none;">Database Replica</text><text class="node-sub" x="0" y="20" style="font-size: 12px; pointer-events: none;">10.3.0.11</text></g><g class="node-group" data-node-id="app-server-1" transform="translate(200,1050)" style="cursor: grab;"><circle r="67.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-54" y="-27" width="108" height="54" rx="4"></rect><line x1="-40.5" y1="-13.5" x2="-40.5" y2="13.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="-18" y1="-13.5" x2="-18" y2="13.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="4.5" y1="-13.5" x2="4.5" y2="13.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><circle cx="40.5" cy="0" r="4.5" style="fill: rgb(74, 222, 128);"></circle></g><text class="node-label" x="0" y="-12.600000000000001" style="font-size: 14.85px; pointer-events: none;">App Server 1</text><text class="node-sub" x="0" y="18" style="font-size: 10.8px; pointer-events: none;">10.3.0.20</text></g><g class="node-group" data-node-id="app-server-2" transform="translate(320,1050)" style="cursor: grab;"><circle r="67.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-54" y="-27" width="108" height="54" rx="4"></rect><line x1="-40.5" y1="-13.5" x2="-40.5" y2="13.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="-18" y1="-13.5" x2="-18" y2="13.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="4.5" y1="-13.5" x2="4.5" y2="13.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><circle cx="40.5" cy="0" r="4.5" style="fill: rgb(74, 222, 128);"></circle></g><text class="node-label" x="0" y="-12.600000000000001" style="font-size: 14.85px; pointer-events: none;">App Server 2</text><text class="node-sub" x="0" y="18" style="font-size: 10.8px; pointer-events: none;">10.3.0.21</text></g><g class="node-group" data-node-id="app-server-3" transform="translate(440,1050)" style="cursor: grab;"><circle r="67.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-54" y="-27" width="108" height="54" rx="4"></rect><line x1="-40.5" y1="-13.5" x2="-40.5" y2="13.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="-18" y1="-13.5" x2="-18" y2="13.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="4.5" y1="-13.5" x2="4.5" y2="13.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><circle cx="40.5" cy="0" r="4.5" style="fill: rgb(74, 222, 128);"></circle></g><text class="node-label" x="0" y="-12.600000000000001" style="font-size: 14.85px; pointer-events: none;">App Server 3</text><text class="node-sub" x="0" y="18" style="font-size: 10.8px; pointer-events: none;">10.3.0.22</text></g><g class="node-group" data-node-id="k8s-master-1" transform="translate(900,700)" style="cursor: grab;"><circle r="75" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-60" y="-30" width="120" height="60" rx="4"></rect><line x1="-45" y1="-15" x2="-45" y2="15" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="-20" y1="-15" x2="-20" y2="15" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="5" y1="-15" x2="5" y2="15" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><circle cx="45" cy="0" r="5" style="fill: rgb(74, 222, 128);"></circle></g><text class="node-label" x="0" y="-14.000000000000002" style="font-size: 16.5px; pointer-events: none;">K8s Master 1</text><text class="node-sub" x="0" y="20" style="font-size: 12px; pointer-events: none;">10.3.1.10</text></g><g class="node-group" data-node-id="k8s-master-2" transform="translate(1020,700)" style="cursor: grab;"><circle r="75" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-60" y="-30" width="120" height="60" rx="4"></rect><line x1="-45" y1="-15" x2="-45" y2="15" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="-20" y1="-15" x2="-20" y2="15" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="5" y1="-15" x2="5" y2="15" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><circle cx="45" cy="0" r="5" style="fill: rgb(74, 222, 128);"></circle></g><text class="node-label" x="0" y="-14.000000000000002" style="font-size: 16.5px; pointer-events: none;">K8s Master 2</text><text class="node-sub" x="0" y="20" style="font-size: 12px; pointer-events: none;">10.3.1.11</text></g><g class="node-group" data-node-id="k8s-worker-1" transform="translate(850,850)" style="cursor: grab;"><circle r="67.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-54" y="-27" width="108" height="54" rx="4"></rect><line x1="-40.5" y1="-13.5" x2="-40.5" y2="13.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="-18" y1="-13.5" x2="-18" y2="13.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="4.5" y1="-13.5" x2="4.5" y2="13.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><circle cx="40.5" cy="0" r="4.5" style="fill: rgb(74, 222, 128);"></circle></g><text class="node-label" x="0" y="-12.600000000000001" style="font-size: 14.85px; pointer-events: none;">K8s Worker 1</text><text class="node-sub" x="0" y="18" style="font-size: 10.8px; pointer-events: none;">10.3.1.20</text></g><g class="node-group" data-node-id="k8s-worker-2" transform="translate(970,850)" style="cursor: grab;"><circle r="67.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-54" y="-27" width="108" height="54" rx="4"></rect><line x1="-40.5" y1="-13.5" x2="-40.5" y2="13.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="-18" y1="-13.5" x2="-18" y2="13.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="4.5" y1="-13.5" x2="4.5" y2="13.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><circle cx="40.5" cy="0" r="4.5" style="fill: rgb(74, 222, 128);"></circle></g><text class="node-label" x="0" y="-12.600000000000001" style="font-size: 14.85px; pointer-events: none;">K8s Worker 2</text><text class="node-sub" x="0" y="18" style="font-size: 10.8px; pointer-events: none;">10.3.1.21</text></g><g class="node-group" data-node-id="k8s-worker-3" transform="translate(1091.8427734375,848.1572875976562)" style="cursor: grab;"><circle r="67.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-54" y="-27" width="108" height="54" rx="4"></rect><line x1="-40.5" y1="-13.5" x2="-40.5" y2="13.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="-18" y1="-13.5" x2="-18" y2="13.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="4.5" y1="-13.5" x2="4.5" y2="13.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><circle cx="40.5" cy="0" r="4.5" style="fill: rgb(74, 222, 128);"></circle></g><text class="node-label" x="0" y="-12.600000000000001" style="font-size: 14.85px; pointer-events: none;">K8s Worker 3</text><text class="node-sub" x="0" y="18" style="font-size: 10.8px; pointer-events: none;">10.3.1.22</text></g><g class="node-group" data-node-id="backup-server" transform="translate(1050,600)" style="cursor: grab;"><circle r="75" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-35" y="-30" width="70" height="70"></rect><ellipse cx="0" cy="-30" rx="35" ry="12.5"></ellipse><ellipse cx="0" cy="40" rx="35" ry="12.5"></ellipse><ellipse cx="0" cy="-7.5" rx="35" ry="10" style="fill: none; stroke: rgb(71, 85, 105); stroke-width: 2;"></ellipse><ellipse cx="0" cy="17.5" rx="35" ry="10" style="fill: none; stroke: rgb(71, 85, 105); stroke-width: 2;"></ellipse></g><text class="node-label" x="0" y="-14.000000000000002" style="font-size: 16.5px; pointer-events: none;">Backup Server</text><text class="node-sub" x="0" y="20" style="font-size: 12px; pointer-events: none;">10.4.0.10</text></g><g class="node-group" data-node-id="monitoring" transform="translate(1150,700)" style="cursor: grab;"><circle r="67.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-54" y="-27" width="108" height="54" rx="4"></rect><line x1="-40.5" y1="-13.5" x2="-40.5" y2="13.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="-18" y1="-13.5" x2="-18" y2="13.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="4.5" y1="-13.5" x2="4.5" y2="13.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><circle cx="40.5" cy="0" r="4.5" style="fill: rgb(74, 222, 128);"></circle></g><text class="node-label" x="0" y="-12.600000000000001" style="font-size: 14.85px; pointer-events: none;">Monitoring</text><text class="node-sub" x="0" y="18" style="font-size: 10.8px; pointer-events: none;">10.4.0.20</text></g><g class="node-group" data-node-id="vpn-gateway" transform="translate(350,250)" style="cursor: grab;"><circle r="75" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-50" y="-40" width="100" height="80" rx="4"></rect><line x1="-42.5" y1="-25" x2="42.5" y2="-25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-42.5" y1="-2.5" x2="42.5" y2="-2.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-42.5" y1="20" x2="42.5" y2="20" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-25" y1="-40" x2="-25" y2="-17.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="10" y1="-40" x2="10" y2="-17.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-7.5" y1="-17.5" x2="-7.5" y2="5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="27.5" y1="-17.5" x2="27.5" y2="5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-25" y1="5" x2="-25" y2="27.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="10" y1="5" x2="10" y2="27.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-7.5" y1="27.5" x2="-7.5" y2="50" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="27.5" y1="27.5" x2="27.5" y2="50" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line></g><text class="node-label" x="0" y="-14.000000000000002" style="font-size: 16.5px; pointer-events: none;">VPN Gateway</text><text class="node-sub" x="0" y="20" style="font-size: 12px; pointer-events: none;">10.0.1.10</text></g><g class="node-group" data-node-id="san-storage" transform="translate(155,750)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-38.5" y="-33" width="77" height="77"></rect><ellipse cx="0" cy="-33" rx="38.5" ry="13.75"></ellipse><ellipse cx="0" cy="44" rx="38.5" ry="13.75"></ellipse><ellipse cx="0" cy="-8.25" rx="38.5" ry="11" style="fill: none; stroke: rgb(71, 85, 105); stroke-width: 2;"></ellipse><ellipse cx="0" cy="19.25" rx="38.5" ry="11" style="fill: none; stroke: rgb(71, 85, 105); stroke-width: 2;"></ellipse></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18.15px; pointer-events: none;">SAN Storage</text><text class="node-sub" x="0" y="22" style="font-size: 13.2px; pointer-events: none;">10.5.0.10</text></g><g class="node-group" data-node-id="workstation-vlan" transform="translate(980,950)" style="cursor: grab;"><circle r="75" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-45" y="-40" width="90" height="60" rx="4"></rect><rect x="-37.5" y="-32.5" width="75" height="45" rx="2" style="fill: rgb(30, 41, 59);"></rect><rect x="-7.5" y="20" width="15" height="15"></rect><rect x="-25" y="35" width="50" height="7.5" rx="2"></rect></g><text class="node-label" x="0" y="-14.000000000000002" style="font-size: 16.5px; pointer-events: none;">User Workstations</text><text class="node-sub" x="0" y="20" style="font-size: 12px; pointer-events: none;">10.2.10.0/24</text></g><g class="node-group" data-node-id="guest-wifi-controller" transform="translate(1050,480)" style="cursor: grab;"><circle r="67.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-49.50000000000001" y="-13.5" width="99.00000000000001" height="36" rx="6"></rect><rect x="-29.25" y="-40.5" width="4.5" height="27" rx="2"></rect><circle cx="-27" cy="-42.75" r="3.6"></circle><rect x="-2.25" y="-40.5" width="4.5" height="27" rx="2"></rect><circle cx="0" cy="-42.75" r="3.6"></circle><rect x="24.75" y="-40.5" width="4.5" height="27" rx="2"></rect><circle cx="27" cy="-42.75" r="3.6"></circle><circle cx="-31.499999999999996" cy="4.5" r="2.6999999999999997" style="fill: rgb(74, 222, 128);"></circle><circle cx="-15.749999999999998" cy="4.5" r="2.6999999999999997" style="fill: rgb(74, 222, 128);"></circle><circle cx="0" cy="4.5" r="2.6999999999999997" style="fill: rgb(250, 204, 21);"></circle><circle cx="15.750000000000004" cy="4.5" r="2.6999999999999997" style="fill: rgb(250, 204, 21);"></circle></g><text class="node-label" x="0" y="-12.600000000000001" style="font-size: 14.85px; pointer-events: none;">WiFi Controller</text><text class="node-sub" x="0" y="18" style="font-size: 10.8px; pointer-events: none;">10.10.0.1</text></g><g class="node-group" data-node-id="remote-workers" transform="translate(180,145)" style="cursor: grab;"><circle r="67.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-36" y="-40.5" width="72" height="49.50000000000001" rx="4"></rect><rect x="-40.5" y="11.25" width="81" height="27" rx="4"></rect><rect x="-11.25" y="20.25" width="22.5" height="11.25" rx="2" style="fill: rgb(30, 41, 59);"></rect></g><text class="node-label" x="0" y="-12.600000000000001" style="font-size: 14.85px; pointer-events: none;">Remote Workers</text><text class="node-sub" x="0" y="18" style="font-size: 10.8px; pointer-events: none;">VPN Pool</text></g><g class="node-group" data-node-id="mail-server" transform="translate(860,950)" style="cursor: grab;"><circle r="67.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-54" y="-27" width="108" height="54" rx="4"></rect><line x1="-40.5" y1="-13.5" x2="-40.5" y2="13.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="-18" y1="-13.5" x2="-18" y2="13.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="4.5" y1="-13.5" x2="4.5" y2="13.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><circle cx="40.5" cy="0" r="4.5" style="fill: rgb(74, 222, 128);"></circle></g><text class="node-label" x="0" y="-12.600000000000001" style="font-size: 14.85px; pointer-events: none;">Mail Server</text><text class="node-sub" x="0" y="18" style="font-size: 10.8px; pointer-events: none;">10.2.2.10</text></g><g class="node-group" data-node-id="racked" transform="translate(1532.4381103515625,634.2197265625)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-66" y="-33" width="132" height="66" rx="4"></rect><line x1="-49.5" y1="-16.5" x2="-49.5" y2="16.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="-22" y1="-16.5" x2="-22" y2="16.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="5.5" y1="-16.5" x2="5.5" y2="16.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><circle cx="49.5" cy="0" r="5.5" style="fill: rgb(74, 222, 128);"></circle></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18.15px; pointer-events: none;">Racked</text><text class="node-sub" x="0" y="22" style="font-size: 13.2px; pointer-events: none;">1.1.1.1</text></g><g class="node-group" data-node-id="noded" transform="translate(663.8039355578157,581.0066280839653)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><circle r="55" class="node-circle"></circle><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18.15px; pointer-events: none;">noded</text><text class="node-sub" x="0" y="22" style="font-size: 13.2px; pointer-events: none;">0.0.0.0</text></g><g class="text-group" data-text-id="text-1764791492132"><text class="text-element" x="1403.008056640625" y="321.1842346191406" dominant-baseline="middle" style="fill: rgb(138, 0, 0); font-size: 32px; font-weight: normal; font-style: normal; text-anchor: start; text-decoration: none; opacity: 1; cursor: move; user-select: none;"><tspan x="1403.008056640625" dy="0">I am a rack.</tspan><tspan x="1403.008056640625" dy="38.4">Double click on desktop</tspan><tspan x="1403.008056640625" dy="38.4">or</tspan><tspan x="1403.008056640625" dy="38.4">long press on mobile</tspan><tspan x="1403.008056640625" dy="38.4">to enter rack view</tspan></text><g class="text-delete-btn" style="cursor: pointer; display: none;"><circle cx="1423.008056640625" cy="289.1842346191406" r="12" style="fill: rgb(245, 101, 101); stroke: white; stroke-width: 2;"></circle><text x="1423.008056640625" y="289.1842346191406" text-anchor="middle" dominant-baseline="middle" style="fill: white; font-size: 16px; font-weight: bold; pointer-events: none;">√ó</text></g></g></svg>
        </div>
        <div class="minimap-zoom-wrapper" id="minimap-zoom-wrapper" style="display: block;">
          <button type="button" class="minimap-close-btn" id="minimap-close-btn" title="Hide map &amp; zoom">‚úï</button>
          <div class="minimap-container" id="minimap-container">
            <svg id="minimap" viewBox="0 0 4000 3000">
              <line x1="600" y1="155" x2="600" y2="250" class="minimap-edge"></line><line x1="600" y1="250" x2="398.1572570800781" y2="420" class="minimap-edge"></line><line x1="600" y1="250" x2="800" y2="420" class="minimap-edge"></line><line x1="398.1572570800781" y1="420" x2="800" y2="420" class="minimap-edge"></line><line x1="398.1572570800781" y1="420" x2="400" y2="600" class="minimap-edge"></line><line x1="800" y1="420" x2="800" y2="600" class="minimap-edge"></line><line x1="400" y1="600" x2="800" y2="600" class="minimap-edge"></line><line x1="398.1572570800781" y1="420" x2="200" y2="500" class="minimap-edge"></line><line x1="200" y1="500" x2="145" y2="650" class="minimap-edge"></line><line x1="200" y1="500" x2="200" y2="700" class="minimap-edge"></line><line x1="200" y1="500" x2="320" y2="650" class="minimap-edge"></line><line x1="400" y1="600" x2="600" y2="780" class="minimap-edge"></line><line x1="800" y1="600" x2="600" y2="780" class="minimap-edge"></line><line x1="600" y1="780" x2="500" y2="950" class="minimap-edge"></line><line x1="600" y1="780" x2="620" y2="950" class="minimap-edge"></line><line x1="600" y1="780" x2="740" y2="950" class="minimap-edge"></line><line x1="600" y1="780" x2="980" y2="950" class="minimap-edge"></line><line x1="600" y1="780" x2="860" y2="950" class="minimap-edge"></line><line x1="400" y1="600" x2="200" y2="850" class="minimap-edge"></line><line x1="200" y1="850" x2="150" y2="1000" class="minimap-edge"></line><line x1="400" y1="600" x2="200" y2="1050" class="minimap-edge"></line><line x1="400" y1="600" x2="320" y2="1050" class="minimap-edge"></line><line x1="400" y1="600" x2="440" y2="1050" class="minimap-edge"></line><line x1="200" y1="1050" x2="200" y2="850" class="minimap-edge"></line><line x1="320" y1="1050" x2="200" y2="850" class="minimap-edge"></line><line x1="440" y1="1050" x2="200" y2="850" class="minimap-edge"></line><line x1="800" y1="600" x2="900" y2="700" class="minimap-edge"></line><line x1="800" y1="600" x2="1020" y2="700" class="minimap-edge"></line><line x1="900" y1="700" x2="850" y2="850" class="minimap-edge"></line><line x1="900" y1="700" x2="970" y2="850" class="minimap-edge"></line><line x1="1020" y1="700" x2="1091.8427734375" y2="848.1572875976562" class="minimap-edge"></line><line x1="800" y1="600" x2="1050" y2="600" class="minimap-edge"></line><line x1="800" y1="600" x2="1150" y2="700" class="minimap-edge"></line><line x1="398.1572570800781" y1="420" x2="350" y2="250" class="minimap-edge"></line><line x1="350" y1="250" x2="180" y2="145" class="minimap-edge"></line><line x1="400" y1="600" x2="155" y2="750" class="minimap-edge"></line><line x1="155" y1="750" x2="200" y2="850" class="minimap-edge"></line><line x1="155" y1="750" x2="200" y2="1050" class="minimap-edge"></line><line x1="800" y1="420" x2="1050" y2="480" class="minimap-edge"></line><circle cx="600" cy="155" r="40" class="minimap-node"></circle><circle cx="600" cy="250" r="40" class="minimap-node"></circle><circle cx="398.1572570800781" cy="420" r="40" class="minimap-node"></circle><circle cx="800" cy="420" r="40" class="minimap-node"></circle><circle cx="400" cy="600" r="40" class="minimap-node"></circle><circle cx="800" cy="600" r="40" class="minimap-node"></circle><circle cx="200" cy="500" r="40" class="minimap-node"></circle><circle cx="145" cy="650" r="40" class="minimap-node"></circle><circle cx="200" cy="700" r="40" class="minimap-node"></circle><circle cx="320" cy="650" r="40" class="minimap-node"></circle><circle cx="600" cy="780" r="40" class="minimap-node"></circle><circle cx="500" cy="950" r="40" class="minimap-node"></circle><circle cx="620" cy="950" r="40" class="minimap-node"></circle><circle cx="740" cy="950" r="40" class="minimap-node"></circle><circle cx="860" cy="950" r="40" class="minimap-node"></circle><circle cx="980" cy="950" r="40" class="minimap-node"></circle><circle cx="200" cy="850" r="40" class="minimap-node"></circle><circle cx="150" cy="1000" r="40" class="minimap-node"></circle><circle cx="200" cy="1050" r="40" class="minimap-node"></circle><circle cx="320" cy="1050" r="40" class="minimap-node"></circle><circle cx="440" cy="1050" r="40" class="minimap-node"></circle><circle cx="900" cy="700" r="40" class="minimap-node"></circle><circle cx="1020" cy="700" r="40" class="minimap-node"></circle><circle cx="850" cy="850" r="40" class="minimap-node"></circle><circle cx="970" cy="850" r="40" class="minimap-node"></circle><circle cx="1091.8427734375" cy="848.1572875976562" r="40" class="minimap-node"></circle><circle cx="1050" cy="600" r="40" class="minimap-node"></circle><circle cx="1150" cy="700" r="40" class="minimap-node"></circle><circle cx="350" cy="250" r="40" class="minimap-node"></circle><circle cx="180" cy="145" r="40" class="minimap-node"></circle><circle cx="155" cy="750" r="40" class="minimap-node"></circle><circle cx="1050" cy="480" r="40" class="minimap-node"></circle><circle cx="1532.4381103515625" cy="634.2197265625" r="40" class="minimap-node"></circle><circle cx="663.8039355578157" cy="581.0066280839653" r="40" class="minimap-node"></circle><rect class="minimap-viewport" id="minimap-viewport" x="38.14866129557299" y="-55" width="2052.8478190104165" height="1539.6358642578125"></rect>
            </svg>
          </div>
          <div class="zoom-toolbar" id="zoom-toolbar">
            <button id="zoom-in-btn" title="Zoom in">+</button>
            <div class="zoom-level" id="zoom-level">195%</div>
            <button id="zoom-out-btn" title="Zoom out">-</button>
            <div class="divider"></div>
            <button id="zoom-fit-btn" title="Fit to view">[ ]</button>
            <button id="zoom-reset-btn" title="Reset view">R</button>
          </div>
        </div>
        <button type="button" id="edge-legend-mini" class="legend-mini-btn" style="bottom: 10px; display: none;">Line Legend</button>
        <button type="button" id="minimap-mini" class="legend-mini-btn" style="right: 10px; left: auto; bottom: 10px; display: none;">Map</button>
        <button type="button" id="draw-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: 10px; right: auto; display: none;">Draw</button>
        <button type="button" id="topology-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: auto; right: 40px; display: none;">Add Line</button>
      <button type="button" id="edge-legend-mini" class="legend-mini-btn" style="bottom: 10px; display: none;">Legend</button><button type="button" id="minimap-mini" class="legend-mini-btn" style="right: 10px; left: auto; bottom: 10px; display: none;">Map</button><button type="button" id="draw-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: 10px; right: auto; display: none;">Draw</button><button type="button" id="topology-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: auto; right: 40px; display: none;">Add Line</button><button type="button" id="edge-legend-mini" class="legend-mini-btn" style="bottom: 10px; display: none;">Legend</button><button type="button" id="topology-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: auto; right: 40px; display: none;">Add Line</button><button type="button" id="minimap-mini" class="legend-mini-btn" style="right: 10px; left: auto; bottom: 10px; display: none;">Map</button><button type="button" id="draw-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: 10px; right: auto; display: none;">Draw</button><button type="button" id="edge-legend-mini" class="legend-mini-btn" style="bottom: 10px; display: none;">Legend</button><button type="button" id="topology-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: auto; right: 40px; display: none;">Add Line</button><button type="button" id="minimap-mini" class="legend-mini-btn" style="right: 10px; left: auto; bottom: 10px; display: none;">Map</button><button type="button" id="draw-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: 10px; right: auto; display: none;">Draw</button></section>
      <aside class="details-panel" id="details-panel">
        <div class="sidebar-resizer" id="sidebar-resizer">
          <svg class="resizer-icon" width="6" height="40" viewBox="0 0 6 40" xmlns="http://www.w3.org/2000/svg">
            <circle cx="3" cy="14" r="2"></circle>
            <circle cx="3" cy="20" r="2"></circle>
            <circle cx="3" cy="26" r="2"></circle>
          </svg>
        </div>
        <div class="mobile-footer-resizer" id="mobile-footer-resizer">
          <svg class="resizer-icon" width="40" height="6" viewBox="0 0 40 6" xmlns="http://www.w3.org/2000/svg">
            <circle cx="14" cy="3" r="2"></circle>
            <circle cx="20" cy="3" r="2"></circle>
            <circle cx="26" cy="3" r="2"></circle>
          </svg>
        </div>
        <div id="node-panel" style="display: block;">
          <div class="details-name editable-text" id="node-name">Internet</div>
          <div class="details-ip editable-text" id="node-ip">0.0.0.0</div>
          <div class="details-role" id="node-role">External</div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px;">MAC:</span>
            <span class="editable-text" id="node-mac" style="margin-left: 8px; font-size: 14px;">--</span>
          </div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px;">Rack Unit:</span>
            <span class="editable-text" id="node-rack" style="margin-left: 8px; font-size: 14px;">--</span>
          </div>
          <div class="details-info-row" id="uheight-row" style="display: none;">
            <span style="color: var(--text-soft); font-size: 14px;">U Height:</span>
            <span class="editable-text" id="node-uheight" style="margin-left: 8px; font-size: 14px;">1U</span>
          </div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px;">Layer:</span>
            <select id="node-layer" style="margin-left: 8px; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;">
              <option value="physical">Physical</option>
              <option value="logical">Logical</option>
              <option value="security">Security</option>
              <option value="application">Application</option>
            </select>
          </div>
          <div class="details-info-row" id="assigned-rack-row" style="display: flex;">
            <span style="color: var(--text-soft); font-size: 14px;">Assigned Rack:</span>
            <select id="node-assigned-rack" style="margin-left: 8px; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;"><option value="">None</option><option value="racked">Racked</option></select>
          </div>
          <div class="details-info-row" id="rack-capacity-row" style="display: none;">
            <span style="color: var(--text-soft); font-size: 14px;">Rack Capacity:</span>
            <select id="node-rack-capacity" style="margin-left: 8px; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;">
              <option value="42">42U</option>
              <option value="48">48U</option>
              <option value="24">24U</option>
              <option value="12">12U</option>
            </select>
          </div>
          <div class="badge-row" id="node-tags"><span class="badge" style="cursor: pointer; position: relative;"><span>External</span><span style="opacity: 0.6; margin-left: 4px; font-size: 10px;"> ‚úï</span></span><span class="badge" style="cursor: pointer; opacity: 0.6; border-style: dashed;">+ Add</span></div>
          <div class="size-controls">
            <label>Size:</label>
            <input type="range" id="size-slider" min="20" max="200" value="55">
            <span id="size-value">55</span>
            <button id="reset-size">Reset</button>
          </div>
          <details class="style-section">
            <summary>Styling</summary>
            <div class="style-content">
              <div class="style-row">
                <label>Screen:</label>
                <select id="style-scope">
                  <option value="all">All</option>
                  <option value="desktop">Desktop</option>
                  <option value="tablet">Tablet</option>
                  <option value="mobile">Mobile</option>
                  <option value="fold">Fold</option>
                </select>
              </div>
              <div class="style-row">
                <label>Shape:</label>
                <select id="shape-select">
                  <optgroup label="Basic Shapes">
                    <option value="circle">Circle</option>
                    <option value="square">Square</option>
                    <option value="rectangle">Rectangle</option>
                    <option value="triangle">Triangle</option>
                    <option value="hexagon">Hexagon</option>
                    <option value="diamond">Diamond</option>
                    <option value="star">Star</option>
                    <option value="stop-sign">Stop Sign</option>
                  </optgroup>
                  <optgroup label="Network Equipment">
                    <option value="server">Server</option>
                    <option value="pc">PC / Desktop</option>
                    <option value="laptop">Laptop</option>
                    <option value="phone">Phone / Mobile</option>
                    <option value="router">Router</option>
                    <option value="switch">Switch</option>
                    <option value="firewall">Firewall</option>
                    <option value="cloud">Cloud</option>
                    <option value="database">Database</option>
                    <option value="printer">Printer</option>
                  </optgroup>
                </select>
              </div>
              <div class="style-row">
                <label>Fill Color:</label>
                <input type="color" id="circle-color" value="#1e293b">
              </div>
              <div class="style-row">
                <label>Border Color:</label>
                <input type="color" id="circle-border" value="#475569">
              </div>
              <div class="style-row">
                <label>Title Color:</label>
                <input type="color" id="title-color" value="#e2e8f0">
              </div>
              <div class="style-row">
                <label>Title Font:</label>
                <select id="title-font">
                  <option value="system-ui, sans-serif"> System UI </option>
                  <option value="monospace">Monospace</option>
                  <option value="serif">Serif</option>
                  <option value="cursive">Cursive</option>
                  <option value="'Courier New', monospace"> Courier </option>
                  <option value="Arial, sans-serif">Arial</option>
                  <option value="'Times New Roman', serif"> Times </option>
                </select>
              </div>
              <div class="style-row">
                <label>Title Size:</label>
                <input type="number" id="title-size" min="8" max="100" value="18">
              </div>
              <div class="style-row">
                <label>Sub Color:</label>
                <input type="color" id="sub-color" value="#94a3b8">
              </div>
              <div class="style-row">
                <label>Sub Font:</label>
                <select id="sub-font">
                  <option value="system-ui, sans-serif"> System UI </option>
                  <option value="monospace">Monospace</option>
                  <option value="serif">Serif</option>
                  <option value="cursive">Cursive</option>
                  <option value="'Courier New', monospace"> Courier </option>
                  <option value="Arial, sans-serif">Arial</option>
                  <option value="'Times New Roman', serif"> Times </option>
                </select>
              </div>
              <div class="style-row">
                <label>Sub Size:</label>
                <input type="number" id="sub-size" min="6" max="80" value="13">
              </div>
              <div style="margin-top: 12px;padding-top: 10px;border-top: 1px solid var(--edge-main);">
                <div style="
                  font-size: 12px;
                  color: var(--text-soft);
                  margin-bottom: 8px;
                  text-transform: uppercase;
                  "> Text Position </div>
                <div class="style-row">
                  <label>Name Y:</label>
                  <input type="number" id="title-offset-y" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>Name X:</label>
                  <input type="number" id="title-offset-x" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>IP Y:</label>
                  <input type="number" id="sub-offset-y" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>IP X:</label>
                  <input type="number" id="sub-offset-x" min="-100" max="100" value="0" style="width: 60px">
                </div>
              </div>
              <button id="reset-styles" style="width: 100%;margin-top: 10px;padding: 8px;background: var(--panel);color: var(--text-main);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: clamp(13px, 1.5vw, 17px);">Reset Styles</button>
            </div>
          </details>
          <div class="section-label">Notes</div>
          <ul class="list" id="node-notes"><li><span style="flex: 1 1 0%;">Public internet</span><span class="delete-note">‚úï</span></li></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-note-input" placeholder="Type new note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-note-btn" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-node-btn" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: rgb(255, 255, 255);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;width: 100%;">Delete Node</button>
        </div>
        <div id="edge-panel" style="display: none">
          <div class="details-name" id="edge-title">Custom line</div>
          <div class="style-row" style="margin-top: 10px">
            <label>Width:</label>
            <input type="number" id="edge-width" min="1" max="20" value="4">
          </div>
          <div class="style-row">
            <label>Color:</label>
            <input type="color" id="edge-color" value="#475569">
          </div>
          <div class="style-row">
            <label>Line Style:</label>
            <select id="edge-line-style">
              <option value="solid">Solid</option>
              <option value="dashed">Dashed</option>
              <option value="dotted">Dotted</option>
            </select>
          </div>
          <div class="style-row">
            <label>Direction:</label>
            <select id="edge-direction">
              <option value="none">No arrows</option>
              <option value="forward">‚Üí Forward</option>
              <option value="backward">‚Üê Backward</option>
              <option value="both">‚Üî Bidirectional</option>
            </select>
          </div>
          <div class="style-row" id="edge-from-port-row" style="display: none;">
            <label>From Port:</label>
            <input type="text" id="edge-from-port" placeholder="e.g. eth0, gi0/1" style="flex: 1;">
          </div>
          <div class="style-row" id="edge-to-port-row" style="display: none;">
            <label>To Port:</label>
            <input type="text" id="edge-to-port" placeholder="e.g. eth1, gi0/2" style="flex: 1;">
          </div>
          <div class="section-label">Line Notes</div>
          <ul class="list" id="edge-notes"></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-edge-note" placeholder="Add note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-edge-note" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-edge" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Delete Line</button>
        </div>
        <div id="text-panel" style="display: none">
          <div class="details-name" id="text-title">Text Element</div>
          <div class="style-row" style="margin-top: 10px">
            <label>Content:</label>
            <textarea id="text-content" placeholder="Enter text..." style="width: 100%;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: 14px;min-height: 80px;resize: vertical;font-family: inherit;"></textarea>
          </div>
          <div class="style-row">
            <label>Font Size:</label>
            <input type="number" id="text-font-size" min="8" max="200" value="18" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);">
          </div>
          <div class="style-row">
            <label>Color:</label>
            <input type="color" id="text-color" value="#e2e8f0">
          </div>
          <div class="style-row">
            <label>Font Weight:</label>
            <select id="text-font-weight" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="normal">Normal</option>
              <option value="bold">Bold</option>
              <option value="600">Semi-Bold</option>
              <option value="300">Light</option>
            </select>
          </div>
          <div class="style-row">
            <label>Font Style:</label>
            <select id="text-font-style" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="normal">Normal</option>
              <option value="italic">Italic</option>
            </select>
          </div>
          <div class="style-row">
            <label>Text Align:</label>
            <select id="text-align" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="start">Left</option>
              <option value="middle">Center</option>
              <option value="end">Right</option>
            </select>
          </div>
          <div class="style-row">
            <label>Text Decoration:</label>
            <select id="text-decoration" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="none">None</option>
              <option value="underline">Underline</option>
              <option value="line-through">Strike Through</option>
            </select>
          </div>
          <div class="style-row">
            <label>Background:</label>
            <input type="color" id="text-bg-color" value="#000000">
            <label style="margin-left: 10px; display: flex; align-items: center; gap: 6px;">
            <input type="checkbox" id="text-bg-enabled" style="cursor: pointer;">
            <span style="font-size: 13px;">Enable</span>
            </label>
          </div>
          <div class="style-row">
            <label>Opacity:</label>
            <input type="range" id="text-opacity" min="0" max="1" step="0.1" value="1" style="flex: 1">
            <span id="text-opacity-val" style="min-width: 35px; text-align: right">100%</span>
          </div>
          <button id="delete-text" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;width: 100%;"> Delete Text </button>
        </div>
        <details class="style-section" open="">
          <summary>Page Layout</summary>
          <div class="style-content">
            <div style="padding: 12px; background: var(--panel-alt); border-radius: 6px; color: var(--text-soft); font-size: 13px; line-height: 1.6;">
              <strong style="color: var(--accent); display: block; margin-bottom: 8px;">Drag to Resize:</strong>
              ‚Ä¢ <strong>Header:</strong> Drag the bottom edge of the header bar<br>
              ‚Ä¢ <strong>Sidebar:</strong> Drag the left edge of the sidebar panel<br>
              ‚Ä¢ <strong>Mobile:</strong> Drag the top edge of the footer panel<br>
              <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--edge-main); font-size: 12px;">
                Hover over panel edges to see resize handles
              </div>
            </div>
          </div>
        </details>
      </aside>
    </main>
    <script id="nodes-json" type="application/json">{}</script>
    <script id="topology-state" type="application/json">ENCRYPTED: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</script>
    <script>
      const BASE_NODE_DATA = JSON.parse(document.getElementById("nodes-json").textContent, );
      let currentNodeId = "host";
      let textDrawMode = false;
      let currentEdgeId = null;
      let currentStyleScope = "all";
      let NODE_DATA = {};
      let EDGE_DATA = {
       list: []
      };
      let RECT_DATA = {
       list: []
      };
      let TEXT_DATA = {
       list: []
      };
      let EDGE_LEGEND = {};
      let savedPositions = {};
      let savedSizes = {};
      let savedStyles = {};
      let legendCollapsed = false;
      let minimapCollapsed = false;
      let drawToolbarCollapsed = false;
      let activeLayers = new Set(["physical", "logical", "security", "application"]);
      let currentView = {
       mode: "topology",  
       rackId: null      
      };
      let savedTopologyView = null; 
      let topologyToolbarCollapsed = false;
      let legendMiniBtn = null;
      let minimapMiniBtn = null;
      let drawToolbarMiniBtn = null;
      let topologyToolbarMiniBtn = null;
      
      let undoStack = [];
      let redoStack = [];
      const MAX_UNDO_STACK = 50;
      
      let selectedNodes = new Set();
      let isSelecting = false;
      let selectionStart = null;
      let selectionRect = null;
      let isDraggingSelection = false;
      let dragSelectionStart = null;
      
      let clipboard = null;
      
      const ROLLBACK_STORAGE_KEY = "theonefile_rollbacks";
      const MAX_ROLLBACK_VERSIONS = 50;
      let rollbackVersions = [];
      let currentRollbackIndex = -1;
      
      const AUDIT_STORAGE_KEY = "theonefile_audit_log";
      let auditLog = [];
      const MAX_AUDIT_ENTRIES = 1000;
      
      let documentTabs = [{
        id: "main",
        name: "Main Topology",
        nodes: {},
        edges: { list: [] },
        positions: {},
        sizes: {},
        styles: {},
        legend: {},
        rects: { list: [] },
        texts: { list: [] },
		pageState: null
      }];
      let currentTabIndex = 0;
      
      let encryptedSections = {}; 
      
      let performanceMode = "auto"; 
      let cullOffscreenNodes = true;
      let minimapNeedsUpdate = true;
      let lastMinimapUpdate = 0;
      
      const MobileManager = {
        isMobile: false,
        detect() {
          if (navigator.userAgentData?.mobile === true) {
            this.isMobile = true;
            return true;
          }
          const coarse = matchMedia("(pointer: coarse)").matches;
          const width = window.innerWidth <= 900;
          const portrait = matchMedia("(orientation: portrait)").matches;
          this.isMobile = coarse && (width || portrait);
          return this.isMobile;
        },
        applyInitialCollapse() {
          if (!this.isMobile) return;
          legendCollapsed = true;
          minimapCollapsed = true;
          drawToolbarCollapsed = true;
          topologyToolbarCollapsed = true;
          if (typeof updateLegendVisibility === "function") updateLegendVisibility();
          if (typeof updateMinimapVisibility === "function") updateMinimapVisibility();
          if (typeof updateDrawToolbarVisibility === "function") updateDrawToolbarVisibility();
          if (typeof updateTopologyToolbarVisibility === "function") updateTopologyToolbarVisibility();
        },
        updateBulkToolbar() {
          const desktop = document.getElementById("bulk-toolbar");
          const mobile = document.getElementById("bulk-toolbar-mobile");
          if (!desktop || !mobile) return;
      
          const isVisible = desktop.style.display !== "none" || mobile.style.display !== "none";
          
          if (this.isMobile) {
            desktop.style.display = "none";
            if (isVisible) {
              mobile.style.display = "flex";
            }
          } else {
            mobile.style.display = "none";
            if (isVisible) {
              desktop.style.display = "flex";
            }
          }
        },
        updateLayout() {
          const main = document.querySelector("main");
          if (!main) return;
        },
        updateCanvasHint() {
      const hint = document.getElementById("canvas-hint");
      if (!hint) return;
      
      const items = this.isMobile
      ? [
        "Pinch to zoom",
        "Drag to pan",
        "Add node from top menu",
        "Double tap to clone and align",
        "Double tap to select multiple",
        "You have the power",	
        "Your time is NOW!",
      ]
      : [
        "Scroll to zoom",
        "Drag to pan",
        "Right-click to clone and align",
        "Right-click to select multiple",
        "You have the power",
        "Your time is NOW!",
      ];
      
      const list = document.createElement("ul");
      for (const item of items) {
      const li = document.createElement("li");
      li.textContent = item;
      list.appendChild(li);
      }
      
      hint.replaceChildren(list);
      },
        autoSelectStyleScope() {
          const scope = document.getElementById("style-scope");
          if (!scope) return;
          if (this.isMobile) scope.value = "mobile";
        },
        updateToolbarStack() {
          if (!this.isMobile) return;
          const draw = document.getElementById("draw-toolbar");
          const topo = document.getElementById("topology-toolbar");
          if (!draw || !topo) return;
          const h = draw.getBoundingClientRect().height;
          document.documentElement.style.setProperty("--draw-toolbar-height", h + "px");
        },
        updateLayoutControls() {
          const sidebarRow = document.getElementById("sidebar-width-row");
          const footerRow = document.getElementById("mobile-footer-row");
          if (sidebarRow && footerRow) {
            if (this.isMobile) {
              sidebarRow.style.display = "none";
              footerRow.style.display = "flex";
            } else {
              sidebarRow.style.display = "flex";
              footerRow.style.display = "none";
            }
          }
        },
        applyAll() {
          this.detect();
          this.applyInitialCollapse();
          this.updateBulkToolbar();
          this.updateLayout();
          this.updateCanvasHint();
          this.autoSelectStyleScope();
          this.updateToolbarStack();
          this.updateLayoutControls();
        }
      };
      
      function isMobileDevice() {
        return MobileManager.isMobile;
      }
      
      function u8ToBase64(u8) {
      let binary = "";
      for (let i = 0; i < u8.length; i++) binary += String.fromCharCode(u8[i]);
      return btoa(binary);
      }
      
      function base64ToU8(base64) {
      const binary = atob(base64);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
      return bytes;
      }
      
      function ensureLegendMiniButton() {
       if (legendMiniBtn) return legendMiniBtn;
       const panel = document.querySelector(".topology-panel");
       if (!panel) return null;
       const btn = document.createElement("button");
       btn.type = "button";
       btn.id = "edge-legend-mini";
       btn.className = "legend-mini-btn";
       btn.textContent = "Legend";
       btn.style.bottom = "10px";
       const handleClick = (e) => {
        e.stopPropagation();
        e.preventDefault();
        legendCollapsed = false;
        updateLegendVisibility();
       };
       btn.addEventListener("click", handleClick);
       btn.addEventListener("touchend", handleClick);
       panel.appendChild(btn);
       legendMiniBtn = btn;
       return btn;
      }
      
      function ensureMinimapMiniButton() {
       if (minimapMiniBtn) return minimapMiniBtn;
       const panel = document.querySelector(".topology-panel");
       if (!panel) return null;
       const btn = document.createElement("button");
       btn.type = "button";
       btn.id = "minimap-mini";
       btn.className = "legend-mini-btn";
       btn.textContent = "Map";
       btn.style.right = "10px";
       btn.style.left = "auto";
       btn.style.bottom = "10px";
       const handleClick = (e) => {
        e.stopPropagation();
        e.preventDefault();
        minimapCollapsed = false;
        updateMinimapVisibility();
       };
       btn.addEventListener("click", handleClick);
       btn.addEventListener("touchend", handleClick);
       panel.appendChild(btn);
       minimapMiniBtn = btn;
       return btn;
      }
      
      function ensureDrawToolbarMiniButton() {
       if (drawToolbarMiniBtn) return drawToolbarMiniBtn;
       const panel = document.querySelector(".topology-panel");
       if (!panel) return null;
       const btn = document.createElement("button");
       btn.type = "button";
       btn.id = "draw-toolbar-mini";
       btn.className = "legend-mini-btn";
       btn.textContent = "Draw";
       btn.style.top = "10px";
       btn.style.left = "10px";
       btn.style.right = "auto";
       const handleClick = (e) => {
        e.stopPropagation();
        e.preventDefault();
        drawToolbarCollapsed = false;
        updateDrawToolbarVisibility();
       };
       btn.addEventListener("click", handleClick);
       btn.addEventListener("touchend", handleClick);
       panel.appendChild(btn);
       drawToolbarMiniBtn = btn;
       return btn;
      }
      
      function ensureTopologyToolbarMiniButton() {
       if (topologyToolbarMiniBtn) return topologyToolbarMiniBtn;
       const panel = document.querySelector(".topology-panel");
       if (!panel) return null;
       const btn = document.createElement("button");
       btn.type = "button";
       btn.id = "topology-toolbar-mini";
       btn.className = "legend-mini-btn";
       btn.textContent = "Add Line";
       btn.style.top = "10px";
       btn.style.left = "auto";
       btn.style.right = "40px";
       const handleClick = (e) => {
        e.stopPropagation();
        e.preventDefault();
        topologyToolbarCollapsed = false;
        updateTopologyToolbarVisibility();
       };
       btn.addEventListener("click", handleClick);
       btn.addEventListener("touchend", handleClick);
       panel.appendChild(btn);
       topologyToolbarMiniBtn = btn;
       return btn;
      }
      
      function updateToolbarStack() {
       if (!isMobileDevice()) return;
       const draw = document.getElementById("draw-toolbar");
       const topo = document.getElementById("topology-toolbar");
       if (!draw || !topo) return;
       const h = draw.getBoundingClientRect().height;
       document.documentElement.style.setProperty("--draw-toolbar-height", h + "px");
      }
      window.addEventListener("resize", updateToolbarStack);
      window.addEventListener("DOMContentLoaded", updateToolbarStack);
      updateToolbarStack();
      
      function updateLegendVisibility() {
       const legend = document.getElementById("edge-legend");
       const mini = ensureLegendMiniButton();
       if (!legend || !mini) return;
       const hasItems = legend.querySelectorAll(".legend-item").length > 0;
       if (!hasItems) {
        legend.style.display = "none";
        mini.style.display = "none";
        return;
       }
       if (legendCollapsed) {
        legend.style.display = "none";
        mini.style.display = "inline-flex";
       } else {
        legend.style.display = "flex";
        mini.style.display = "none";
       }
      }
      
      function updateMinimapVisibility() {
       const wrapper = document.getElementById("minimap-zoom-wrapper");
       const mini = ensureMinimapMiniButton();
       if (!wrapper || !mini) return;
       if (minimapCollapsed) {
        wrapper.style.display = "none";
        mini.style.display = "inline-flex";
       } else {
        wrapper.style.display = "block";
        mini.style.display = "none";
       }
      }
      
      function updateDrawToolbarVisibility() {
       const toolbar = document.getElementById("draw-toolbar");
       const mini = ensureDrawToolbarMiniButton();
       if (!toolbar || !mini) return;
       if (drawToolbarCollapsed) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "inline-flex";
       } else {
      if (isMobileDevice()) {    	   
        toolbar.style.setProperty('display', 'grid', 'important');
        mini.style.display = "none";
      } else {   
        toolbar.style.setProperty('display', 'flex', 'important');
        mini.style.display = "none";	  
      }
       }
      }
      
      function updateTopologyToolbarVisibility() {
       const toolbar = document.getElementById("topology-toolbar");
       const mini = ensureTopologyToolbarMiniButton();
       if (!toolbar || !mini) return;
       const hasSelectedNode = currentNodeId !== null;
       if (!hasSelectedNode) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "none";
       } else if (topologyToolbarCollapsed) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "inline-flex";
       } else {   
      if (isMobileDevice()) {    	   
        toolbar.style.setProperty('display', 'grid', 'important');
        mini.style.display = "none";
        } else {   
        toolbar.style.setProperty('display', 'flex', 'important');
        mini.style.display = "none";	  
      }
       }
      }
      
      const DEFAULT_PAGE_STATE = {
       title: "The One File",
       background: "",
       topbarBg: "rgba(9, 12, 20, 0.9)",
       topbarBorder: "#1f2533",
       panel: "#0b0e13",
       panelAlt: "#10141b",
       accent: "#4fd1c5",
       danger: "#f56565",
       textMain: "#e2e8f0",
       textSoft: "#94a3b8",
       topbarHeight: 52,
       sidebarWidth: 350,
       mobileFooterHeight: 40,
       sidebarCollapsed: false,
      };
      let PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE);
      const CANVAS_WIDTH = 4000;
      let CANVAS_HEIGHT = 3000;
      const BASE_CANVAS_HEIGHT = 3000;
      const CANVAS_PADDING = 100;
      
      const RACK_U_HEIGHT = 70; 
      const RACK_WIDTH = 600;
      const RACK_START_X = CANVAS_WIDTH / 2; 
      const RACK_START_Y = CANVAS_PADDING + 100;
      function getRackUHeight(rackId) {
      const capacity = getRackCapacity(rackId);
      const availableHeight = CANVAS_HEIGHT - RACK_START_Y - 200;
      return Math.floor(availableHeight / capacity);
      }
      let canvasState = {
       zoom: 1,
       panX: 0,
       panY: 0,
       minZoom: 0.25,
       maxZoom: 4,
       isPanning: false,
       panStartX: 0,
       panStartY: 0,
       spacePressed: false,
      };
      
      function getViewBox() {
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       return {
        x: canvasState.panX,
        y: canvasState.panY,
        width: viewWidth,
        height: viewHeight,
       };
      }
      
      function updateViewBox() {
       const svg = document.getElementById("map");
       const vb = getViewBox();
       svg.setAttribute("viewBox", `${vb.x} ${vb.y} ${vb.width} ${vb.height}`, );
       const zoomLevel = document.getElementById("zoom-level");
       if (zoomLevel) {
        zoomLevel.textContent = Math.round(canvasState.zoom * 100) + "%";
       }
       updateMinimap();
       populateRackDropdown();
      }
      
      function updateMinimap() {
       const minimapViewport = document.getElementById("minimap-viewport");
       const minimapSvg = document.getElementById("minimap");
       if (!minimapViewport || !minimapSvg) return;
       const vb = getViewBox();
       minimapViewport.setAttribute("x", vb.x);
       minimapViewport.setAttribute("y", vb.y);
       minimapViewport.setAttribute("width", vb.width);
       minimapViewport.setAttribute("height", vb.height);
       const minimapNodes = minimapSvg.querySelectorAll(".minimap-node");
       minimapNodes.forEach((n) => n.remove());
       const minimapEdges = minimapSvg.querySelectorAll(".minimap-edge");
       minimapEdges.forEach((e) => e.remove());
       
       EDGE_DATA.list.forEach((edge) => {
        if (edge.type === "custom") return;
        
        const fromNode = NODE_DATA[edge.from];
        const toNode = NODE_DATA[edge.to];
        if (!fromNode || !toNode) return;
        
        if (currentView.mode === "rack") {
         if (fromNode.assignedRack !== currentView.rackId || 
             toNode.assignedRack !== currentView.rackId) {
          return;
         }
        } else {
         if (fromNode.assignedRack || toNode.assignedRack) {
          return;
         }
        }
        
        const p1 = savedPositions[edge.from];
        const p2 = savedPositions[edge.to];
        if (!p1 || !p2) return;
        const line = document.createElementNS("http://www.w3.org/2000/svg", "line", );
        line.setAttribute("x1", p1.x);
        line.setAttribute("y1", p1.y);
        line.setAttribute("x2", p2.x);
        line.setAttribute("y2", p2.y);
        line.classList.add("minimap-edge");
        minimapSvg.insertBefore(line, minimapViewport);
       });
       
       Object.entries(savedPositions).forEach(([id, pos]) => {
        const node = NODE_DATA[id];
        if (!node) return;
        
        if (currentView.mode === "rack") {
         if (node.assignedRack !== currentView.rackId) {
          return; 
         }
        } else {
         if (node.assignedRack) {
          return; 
         }
        }
        
        const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle", );
        circle.setAttribute("cx", pos.x);
        circle.setAttribute("cy", pos.y);
        circle.setAttribute("r", 40);
        circle.classList.add("minimap-node");
        minimapSvg.insertBefore(circle, minimapViewport);
       });
      }
      
      function zoomTo(newZoom, centerX, centerY) {
       const oldZoom = canvasState.zoom;
       newZoom = Math.max(canvasState.minZoom, Math.min(canvasState.maxZoom, newZoom), );
       if (centerX !== undefined && centerY !== undefined) {
        const oldWidth = CANVAS_WIDTH / oldZoom;
        const oldHeight = CANVAS_HEIGHT / oldZoom;
        const newWidth = CANVAS_WIDTH / newZoom;
        const newHeight = CANVAS_HEIGHT / newZoom;
        const pointX = canvasState.panX + centerX * oldWidth;
        const pointY = canvasState.panY + centerY * oldHeight;
        canvasState.panX = pointX - centerX * newWidth;
        canvasState.panY = pointY - centerY * newHeight;
       }
       canvasState.zoom = newZoom;
       constrainPan();
       updateViewBox();
      }
      
      function constrainPan() {
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       const minVisiblePortion = 0.1;
       const maxPanX = CANVAS_WIDTH - viewWidth * minVisiblePortion;
       const maxPanY = CANVAS_HEIGHT - viewHeight * minVisiblePortion;
       const minPanX = -viewWidth * (1 - minVisiblePortion);
       const minPanY = -viewHeight * (1 - minVisiblePortion);
       canvasState.panX = Math.max(minPanX, Math.min(maxPanX, canvasState.panX), );
       canvasState.panY = Math.max(minPanY, Math.min(maxPanY, canvasState.panY), );
      }
      
      function fitToContent() {
       const positions = Object.values(savedPositions);
       if (positions.length === 0) {
        resetView();
        return;
       }
       let minX = Infinity,
        minY = Infinity,
        maxX = -Infinity,
        maxY = -Infinity;
       positions.forEach((pos) => {
        minX = Math.min(minX, pos.x - 100);
        minY = Math.min(minY, pos.y - 100);
        maxX = Math.max(maxX, pos.x + 100);
        maxY = Math.max(maxY, pos.y + 100);
       });
       const contentWidth = maxX - minX + 200;
       const contentHeight = maxY - minY + 200;
       const viewport = document.getElementById("canvas-viewport");
       const vpRect = viewport.getBoundingClientRect();
       const aspectRatio = vpRect.width / vpRect.height;
       const contentAspect = contentWidth / contentHeight;
       let newZoom;
       if (contentAspect > aspectRatio) {
        newZoom = (vpRect.width / contentWidth) * (CANVAS_WIDTH / vpRect.width);
       } else {
        newZoom = (vpRect.height / contentHeight) * (CANVAS_HEIGHT / vpRect.height);
       }
       newZoom = Math.max(canvasState.minZoom, Math.min(2, newZoom));
       const viewWidth = CANVAS_WIDTH / newZoom;
       const viewHeight = CANVAS_HEIGHT / newZoom;
       canvasState.zoom = newZoom;
       canvasState.panX = minX - 100 - (viewWidth - contentWidth) / 2;
       canvasState.panY = minY - 100 - (viewHeight - contentHeight) / 2;
       constrainPan();
       updateViewBox();
      }
      
      function resetView() {
       canvasState.zoom = 1;
       canvasState.panX = 0;
       canvasState.panY = 0;
       updateViewBox();
      }
      window.addEventListener("DOMContentLoaded", () => {
       const toggle = document.getElementById("mobile-menu-toggle");
       const menu = document.getElementById("topbar-menu");
       if (!toggle || !menu) return;
       toggle.addEventListener("click", () => {
        menu.classList.toggle("open");
       });
       menu.addEventListener("click", (e) => {
        const target = e.target.closest("a, button");
        if (!target) return;
        if (isMobileDevice()) {
       menu.classList.remove("open");
      }
       });
       const minimapCloseBtn = document.getElementById("minimap-close-btn");
       if (minimapCloseBtn) {
        const handleMinimapClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         minimapCollapsed = true;
         updateMinimapVisibility();
        };
        minimapCloseBtn.addEventListener("click", handleMinimapClose);
        minimapCloseBtn.addEventListener("touchend", handleMinimapClose);
       }
       const drawToolbarCloseBtn = document.getElementById("draw-toolbar-close-btn");
       if (drawToolbarCloseBtn) {
        const handleDrawClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         drawToolbarCollapsed = true;
         updateDrawToolbarVisibility();
        };
        drawToolbarCloseBtn.addEventListener("click", handleDrawClose);
        drawToolbarCloseBtn.addEventListener("touchend", handleDrawClose);
       }
       const topologyToolbarCloseBtn = document.getElementById("topology-toolbar-close-btn");
       if (topologyToolbarCloseBtn) {
        const handleTopologyClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         topologyToolbarCollapsed = true;
         updateTopologyToolbarVisibility();
        };
        topologyToolbarCloseBtn.addEventListener("click", handleTopologyClose);
        topologyToolbarCloseBtn.addEventListener("touchstart", (e) => e.preventDefault(), {
         passive: false
        });
        topologyToolbarCloseBtn.addEventListener("touchend", handleTopologyClose);
       }
      
       updateMinimapVisibility();
       updateDrawToolbarVisibility();
       updateTopologyToolbarVisibility();
      });
      
      function applyLayerFilter() {
       activeLayers.clear();
       if (document.getElementById("layer-physical").checked) activeLayers.add("physical");
       if (document.getElementById("layer-logical").checked) activeLayers.add("logical");
       if (document.getElementById("layer-security").checked) activeLayers.add("security");
       if (document.getElementById("layer-application").checked) activeLayers.add("application");
       forgeTheTopology();
      }
      
      function isNodeVisible(nodeId) {
       const node = NODE_DATA[nodeId];
       if (!node) return false;
       const nodeLayer = node.layer || "physical";
       return activeLayers.has(nodeLayer);
      }
      
      function enterRack(rackId) {
      if (!NODE_DATA[rackId] || !NODE_DATA[rackId].isRack) return;
      const rackCapacity = getRackCapacity(rackId);
      const neededHeight = RACK_START_Y + (rackCapacity * RACK_U_HEIGHT) + 200;
      if (neededHeight > BASE_CANVAS_HEIGHT) {
      CANVAS_HEIGHT = neededHeight;
      }
       
       savedTopologyView = {
        zoom: canvasState.zoom,
        panX: canvasState.panX,
        panY: canvasState.panY
       };
       
       currentView.mode = "rack";
       currentView.rackId = rackId;
       
       const backBtn = document.getElementById("back-to-topology-btn");
       if (backBtn) backBtn.style.display = "inline-block";
       
       const hint = document.getElementById("canvas-hint");
       if (hint) {
        hint.textContent = `Viewing: ${NODE_DATA[rackId].name} | Double-click empty space to exit`;
        hint.classList.add("visible");
       }
       
      
      const rackUHeight = getRackUHeight(rackId);
      const rackHeight = rackCapacity * rackUHeight;
      const rackCenterX = RACK_START_X;
      const rackCenterY = RACK_START_Y + (rackHeight / 2);
       
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       
       canvasState.panX = rackCenterX - (viewWidth / 2);
       canvasState.panY = rackCenterY - (viewHeight / 2);
       
       constrainPan();
       updateViewBox();
       
       forgeTheTopology();
      }
      
      function exitRack() {
      CANVAS_HEIGHT = BASE_CANVAS_HEIGHT;
      currentView.mode = "topology";
      currentView.rackId = null;
       
       const backBtn = document.getElementById("back-to-topology-btn");
       if (backBtn) backBtn.style.display = "none";
       
       const hint = document.getElementById("canvas-hint");
       if (hint) {
        hint.classList.remove("visible");
       }
       
       if (savedTopologyView) {
        canvasState.zoom = savedTopologyView.zoom;
        canvasState.panX = savedTopologyView.panX;
        canvasState.panY = savedTopologyView.panY;
        updateViewBox();
       }
       
       forgeTheTopology();
      }
      
      function getRackCapacity(rackId) {
       const node = NODE_DATA[rackId];
       return node && node.rackCapacity ? parseInt(node.rackCapacity) : 42;
      }
      
      function populateRackDropdown() {
       const dropdown = document.getElementById("node-assigned-rack");
       if (!dropdown) return;
       
       dropdown.innerHTML = '<option value="">None</option>';
       
       Object.keys(NODE_DATA).forEach(id => {
        if (NODE_DATA[id].isRack) {
         const option = document.createElement("option");
         option.value = id;
         option.textContent = NODE_DATA[id].name;
         dropdown.appendChild(option);
        }
       });
      }
      
      function wieldThePower() {
       const root = document.documentElement;
       root.style.setProperty("--panel", PAGE_STATE.panel);
       root.style.setProperty("--panel-alt", PAGE_STATE.panelAlt);
       root.style.setProperty("--accent", PAGE_STATE.accent);
       root.style.setProperty("--danger", PAGE_STATE.danger);
       root.style.setProperty("--text-main", PAGE_STATE.textMain);
       root.style.setProperty("--text-soft", PAGE_STATE.textSoft);
       root.style.setProperty("--topbar-bg", PAGE_STATE.topbarBg);
       root.style.setProperty("--topbar-border", PAGE_STATE.topbarBorder);
       const topbarHeight = PAGE_STATE.topbarHeight || 52;
       const sidebarWidth = PAGE_STATE.sidebarWidth || 350;
       const mobileFooterHeight = PAGE_STATE.mobileFooterHeight || 40;
       root.style.setProperty("--topbar-height", topbarHeight + "px");
       root.style.setProperty("--sidebar-width", sidebarWidth + "px");
       root.style.setProperty("--mobile-footer-height", mobileFooterHeight + "vh", );
       const mainEl = document.querySelector("main");
       const detailsPanel = document.getElementById("details-panel");
       const sidebarToggle = document.getElementById("sidebar-toggle");
       if (PAGE_STATE.sidebarCollapsed) {
        if (mainEl) mainEl.classList.add("sidebar-collapsed");
        if (detailsPanel) detailsPanel.classList.add("collapsed");
        if (sidebarToggle) {
         sidebarToggle.classList.add("collapsed");
         sidebarToggle.textContent = "‚ñ∂";
        }
       } else {
        if (mainEl) mainEl.classList.remove("sidebar-collapsed");
        if (detailsPanel) detailsPanel.classList.remove("collapsed");
        if (sidebarToggle) {
         sidebarToggle.classList.remove("collapsed");
         sidebarToggle.textContent = "‚óÄ";
        }
       }
       if (PAGE_STATE.background) {
        document.body.style.background = PAGE_STATE.background;
       } else {
        document.body.style.background = "radial-gradient(circle at top, #1e2532 0, #050608 70%)";
       }
       document.title = PAGE_STATE.title || DEFAULT_PAGE_STATE.title;
       const titleEl = document.getElementById("page-title");
       if (titleEl) {
        titleEl.textContent = PAGE_STATE.title || DEFAULT_PAGE_STATE.title;
       }
       
       const sidebarToggleEl = document.getElementById("sidebar-toggle");
       const isMobile = isMobileDevice();
       if (sidebarToggleEl) {
        sidebarToggleEl.style.display = isMobile ? "none" : "flex";
       }
      }
      (async function awakeTheImmortal() {
       let initialState = {};
       let decryptionCancelled = false;
       const stateEl = document.getElementById("topology-state");
       if (stateEl && stateEl.textContent.trim()) {
        try {
         let stateText = stateEl.textContent.trim();
         if (isEncrypted(stateText)) {
          let decrypted = false;
          let attempts = 0;
          const maxAttempts = 3;
          while (!decrypted && attempts < maxAttempts) {
           const password = prompt("This file is encrypted. Enter password to decrypt:\n(Attempt " + (attempts + 1) + " of " + maxAttempts + ")", );
           if (!password) {
            alert("Decryption cancelled. The file will not be loaded.", );
            decryptionCancelled = true;
            break;
           }
           try {
            stateText = await decryptData(stateText, password);
            decrypted = true;
           } catch (e) {
            attempts++;
            if (attempts < maxAttempts) {
             alert("Incorrect password. Please try again.");
            } else {
             alert("Maximum attempts reached. The file will not be loaded.", );
             decryptionCancelled = true;
            }
           }
          }
          if (!decrypted) {
           stateText = "{}";
          }
         }
         initialState = JSON.parse(stateText);
        } catch (e) {
         console.error("Failed to load state:", e);
         initialState = {};
        }
       }
       if (decryptionCancelled) {
        NODE_DATA = {};
        EDGE_DATA = {
         list: []
        };
        EDGE_LEGEND = {};
        savedPositions = {};
        savedSizes = {};
        savedStyles = {};
       } else {
        NODE_DATA = initialState.nodeData ? initialState.nodeData : BASE_NODE_DATA;
        EDGE_DATA = initialState.edgeData ? initialState.edgeData : {
         list: [],
        };
        RECT_DATA = initialState.rectData ? initialState.rectData : { list: [] };
        TEXT_DATA = initialState.textData ? initialState.textData : { list: [] };
        EDGE_LEGEND = initialState.edgeLegend || {};
        savedPositions = initialState.nodePositions || {};
        savedSizes = initialState.nodeSizes || {};
        savedStyles = initialState.nodeStyles || {};
       }
       if (initialState.page) {
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, initialState.page, );
       }
       if (initialState.canvas) {
        canvasState.zoom = initialState.canvas.zoom || 1;
        canvasState.panX = initialState.canvas.panX || 0;
        canvasState.panY = initialState.canvas.panY || 0;
       }
       
       if (initialState.savedTopologyView) {
        savedTopologyView = initialState.savedTopologyView;
       }
       
       if (initialState.documentTabs) {
        documentTabs = initialState.documentTabs;
        currentTabIndex = initialState.currentTabIndex || 0;
        
        const currentTab = documentTabs[currentTabIndex];
        if (currentTab) {
          NODE_DATA = currentTab.nodes || NODE_DATA;
          EDGE_DATA = currentTab.edges || EDGE_DATA;
          savedPositions = currentTab.positions || savedPositions;
          savedSizes = currentTab.sizes || savedSizes;
          savedStyles = currentTab.styles || savedStyles;
          EDGE_LEGEND = currentTab.legend || EDGE_LEGEND;
          RECT_DATA = currentTab.rects || RECT_DATA;
          TEXT_DATA = currentTab.texts || TEXT_DATA;
		  if (currentTab.pageState) PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, currentTab.pageState);
        }
       }
           
       if (initialState.encryptedSections) {
        encryptedSections = initialState.encryptedSections;
       }
       
       wieldThePower();
       forgeTheTopology();
       updateViewBox();
       
       MobileManager.applyAll();
       
       const initialNodes = Object.keys(NODE_DATA);
       if (initialNodes.length > 0) {
        claimTheImmortal(initialNodes.includes("host") ? "host" : initialNodes[0], );
       } else {
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.display = "none";
       }
      })();
      
      window.addEventListener("resize", () => {
        MobileManager.applyAll();
      });
      
      function saveEdgeData() {}
      
      function saveEdgeLegend() {}
      
      function getBreakpointKey() {
       const w = window.innerWidth;
       if (w <= 380) return "fold";
       if (w <= 768) return "mobile";
       if (w <= 1024) return "tablet";
       return "desktop";
      }
      
      function resolveStylesEntry(styleEntry) {
       if (!styleEntry) return {};
       if (styleEntry.circleColor || styleEntry.titleColor || styleEntry.titleFont || styleEntry.titleSize || styleEntry.subColor || styleEntry.subFont || styleEntry.subSize) {
        return styleEntry;
       }
       const bp = getBreakpointKey();
       const base = styleEntry.all || {};
       const bpStyles = styleEntry[bp] || {};
       return Object.assign({}, base, bpStyles);
      }
      
      function resolveStylesForNode(id) {
       const styleEntry = savedStyles[id];
       if (!styleEntry) return {};
       return resolveStylesEntry(styleEntry);
      }
      
      function ensureStyleEntry(id) {
       if (!savedStyles[id]) savedStyles[id] = {};
       const entry = savedStyles[id];
       const flatProps = ["circleColor", "circleBorder", "titleColor", "titleFont", "titleSize", "subColor", "subFont", "subSize", ];
       const isFlat = flatProps.some((p) => Object.prototype.hasOwnProperty.call(entry, p), );
       if (isFlat) {
        const all = entry.all || {};
        flatProps.forEach((p) => {
         if (entry[p] !== undefined) {
          all[p] = entry[p];
          delete entry[p];
         }
        });
        entry.all = all;
       }
       return entry;
      }
      
      function getDefaultSize() {
       if (window.innerWidth <= 380) return 120;
       if (window.innerWidth <= 768) return 140;
       if (window.innerWidth <= 1024) return 70;
       return 55;
      }
      
      function createShapeElement(shape, size) {
       const ns = "http://www.w3.org/2000/svg";
       if (shape === "circle") {
        const c = document.createElementNS(ns, "circle");
        c.setAttribute("r", size);
        return c;
       }
       if (shape === "square") {
        const r = document.createElementNS(ns, "rect");
        const s = size * 2;
        r.setAttribute("x", -size);
        r.setAttribute("y", -size);
        r.setAttribute("width", s);
        r.setAttribute("height", s);
        r.setAttribute("rx", 4);
        return r;
       }
       if (shape === "rectangle") {
        const r = document.createElementNS(ns, "rect");
        r.setAttribute("x", -size * 1.4);
        r.setAttribute("y", -size * 0.8);
        r.setAttribute("width", size * 2.8);
        r.setAttribute("height", size * 1.6);
        r.setAttribute("rx", 6);
        return r;
       }
       if (shape === "triangle") {
        const p = document.createElementNS(ns, "polygon");
        const h = size * 1.8;
        const w = size * 2;
        p.setAttribute("points", `0,${-h} ${w / 2},${h / 2} ${-w / 2},${h / 2}`, );
        return p;
       }
       if (shape === "hexagon") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        const pts = [
         [0, -s],
         [s * 0.86, -s * 0.5],
         [s * 0.86, s * 0.5],
         [0, s],
         [-s * 0.86, s * 0.5],
         [-s * 0.86, -s * 0.5],
        ].map((pt) => pt.join(",")).join(" ");
        p.setAttribute("points", pts);
        return p;
       }
       if (shape === "stop-sign") {
        const p = document.createElementNS(ns, "polygon");
        const r = size;
        const ptsArr = [];
        for (let i = 0; i < 8; i++) {
         const a = (Math.PI / 4) * i + Math.PI / 8;
         ptsArr.push([Math.cos(a) * r, Math.sin(a) * r]);
        }
        const pts = ptsArr.map((pt) => pt.join(",")).join(" ");
        p.setAttribute("points", pts);
        return p;
       }
       if (shape === "star") {
        const p = document.createElementNS(ns, "polygon");
        const outer = size;
        const inner = size * 0.45;
        let pts = "";
        for (let i = 0; i < 10; i++) {
         const a = (Math.PI / 5) * i - Math.PI / 2;
         const r = i % 2 === 0 ? outer : inner;
         pts += `${Math.cos(a) * r},${Math.sin(a) * r} `;
        }
        p.setAttribute("points", pts.trim());
        return p;
       }
       if (shape === "diamond") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `0,${-s} ${s},0 0,${s} ${-s},0`);
        return p;
       }
       if (shape === "server") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.2);
        body.setAttribute("y", -size * 0.6);
        body.setAttribute("width", size * 2.4);
        body.setAttribute("height", size * 1.2);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 3; i++) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", -size * 0.9 + i * size * 0.5);
         line.setAttribute("y1", -size * 0.3);
         line.setAttribute("x2", -size * 0.9 + i * size * 0.5);
         line.setAttribute("y2", size * 0.3);
         line.style.stroke = "currentColor";
         line.style.strokeWidth = "2";
         line.style.opacity = "0.5";
         g.appendChild(line);
        }
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", size * 0.9);
        led.setAttribute("cy", 0);
        led.setAttribute("r", size * 0.1);
        led.style.fill = "#4ade80";
        g.appendChild(led);
        return g;
       }
       if (shape === "pc" || shape === "desktop") {
        const g = document.createElementNS(ns, "g");
        const monitor = document.createElementNS(ns, "rect");
        monitor.setAttribute("x", -size * 0.9);
        monitor.setAttribute("y", -size * 0.8);
        monitor.setAttribute("width", size * 1.8);
        monitor.setAttribute("height", size * 1.2);
        monitor.setAttribute("rx", 4);
        g.appendChild(monitor);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.75);
        screen.setAttribute("y", -size * 0.65);
        screen.setAttribute("width", size * 1.5);
        screen.setAttribute("height", size * 0.9);
        screen.setAttribute("rx", 2);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        const neck = document.createElementNS(ns, "rect");
        neck.setAttribute("x", -size * 0.15);
        neck.setAttribute("y", size * 0.4);
        neck.setAttribute("width", size * 0.3);
        neck.setAttribute("height", size * 0.3);
        g.appendChild(neck);
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.5);
        base.setAttribute("y", size * 0.7);
        base.setAttribute("width", size * 1);
        base.setAttribute("height", size * 0.15);
        base.setAttribute("rx", 2);
        g.appendChild(base);
        return g;
       }
       if (shape === "laptop") {
        const g = document.createElementNS(ns, "g");
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.8);
        screen.setAttribute("y", -size * 0.9);
        screen.setAttribute("width", size * 1.6);
        screen.setAttribute("height", size * 1.1);
        screen.setAttribute("rx", 4);
        g.appendChild(screen);
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.9);
        base.setAttribute("y", size * 0.25);
        base.setAttribute("width", size * 1.8);
        base.setAttribute("height", size * 0.6);
        base.setAttribute("rx", 4);
        g.appendChild(base);
        const pad = document.createElementNS(ns, "rect");
        pad.setAttribute("x", -size * 0.25);
        pad.setAttribute("y", size * 0.45);
        pad.setAttribute("width", size * 0.5);
        pad.setAttribute("height", size * 0.25);
        pad.setAttribute("rx", 2);
        pad.style.fill = "#1e293b";
        g.appendChild(pad);
        return g;
       }
       if (shape === "phone" || shape === "mobile") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.45);
        body.setAttribute("y", -size);
        body.setAttribute("width", size * 0.9);
        body.setAttribute("height", size * 2);
        body.setAttribute("rx", 8);
        g.appendChild(body);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.38);
        screen.setAttribute("y", -size * 0.85);
        screen.setAttribute("width", size * 0.76);
        screen.setAttribute("height", size * 1.6);
        screen.setAttribute("rx", 4);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        const btn = document.createElementNS(ns, "rect");
        btn.setAttribute("x", -size * 0.15);
        btn.setAttribute("y", size * 0.82);
        btn.setAttribute("width", size * 0.3);
        btn.setAttribute("height", size * 0.06);
        btn.setAttribute("rx", 2);
        btn.style.fill = "#475569";
        g.appendChild(btn);
        return g;
       }
       if (shape === "router") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.1);
        body.setAttribute("y", -size * 0.3);
        body.setAttribute("width", size * 2.2);
        body.setAttribute("height", size * 0.8);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        for (let i = -1; i <= 1; i++) {
         const ant = document.createElementNS(ns, "rect");
         ant.setAttribute("x", i * size * 0.6 - size * 0.05);
         ant.setAttribute("y", -size * 0.9);
         ant.setAttribute("width", size * 0.1);
         ant.setAttribute("height", size * 0.6);
         ant.setAttribute("rx", 2);
         g.appendChild(ant);
         const tip = document.createElementNS(ns, "circle");
         tip.setAttribute("cx", i * size * 0.6);
         tip.setAttribute("cy", -size * 0.95);
         tip.setAttribute("r", size * 0.08);
         g.appendChild(tip);
        }
        for (let i = 0; i < 4; i++) {
         const led = document.createElementNS(ns, "circle");
         led.setAttribute("cx", -size * 0.7 + i * size * 0.35);
         led.setAttribute("cy", size * 0.1);
         led.setAttribute("r", size * 0.06);
         led.style.fill = i < 2 ? "#4ade80" : "#facc15";
         g.appendChild(led);
        }
        return g;
       }
       if (shape === "switch") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.4);
        body.setAttribute("y", -size * 0.4);
        body.setAttribute("width", size * 2.8);
        body.setAttribute("height", size * 0.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 8; i++) {
         const port = document.createElementNS(ns, "rect");
         port.setAttribute("x", -size * 1.2 + i * size * 0.32);
         port.setAttribute("y", -size * 0.15);
         port.setAttribute("width", size * 0.22);
         port.setAttribute("height", size * 0.3);
         port.setAttribute("rx", 1);
         port.style.fill = "#1e293b";
         g.appendChild(port);
        }
        return g;
       }
       if (shape === "firewall") {
        const g = document.createElementNS(ns, "g");
        const wall = document.createElementNS(ns, "rect");
        wall.setAttribute("x", -size);
        wall.setAttribute("y", -size * 0.8);
        wall.setAttribute("width", size * 2);
        wall.setAttribute("height", size * 1.6);
        wall.setAttribute("rx", 4);
        g.appendChild(wall);
        for (let row = 0; row < 3; row++) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", -size * 0.85);
         line.setAttribute("y1", -size * 0.5 + row * size * 0.45);
         line.setAttribute("x2", size * 0.85);
         line.setAttribute("y2", -size * 0.5 + row * size * 0.45);
         line.style.stroke = "#475569";
         line.style.strokeWidth = "2";
         g.appendChild(line);
        }
        for (let row = 0; row < 4; row++) {
         const offset = row % 2 === 0 ? 0 : size * 0.35;
         for (let col = 0; col < 3; col++) {
          const line = document.createElementNS(ns, "line");
          const x = -size * 0.5 + col * size * 0.7 + offset;
          if (x > -size * 0.85 && x < size * 0.85) {
           line.setAttribute("x1", x);
           line.setAttribute("y1", -size * 0.8 + row * size * 0.45, );
           line.setAttribute("x2", x);
           line.setAttribute("y2", -size * 0.8 + row * size * 0.45 + size * 0.45, );
           line.style.stroke = "#475569";
           line.style.strokeWidth = "2";
           g.appendChild(line);
          }
         }
        }
        return g;
       }
       if (shape === "cloud") {
        const p = document.createElementNS(ns, "path");
        const s = size;
        p.setAttribute("d", `
             M ${-s * 0.8} ${s * 0.2}
             Q ${-s * 1.1} ${s * 0.2} ${-s * 1.1} ${-s * 0.1}
             Q ${-s * 1.1} ${-s * 0.5} ${-s * 0.7} ${-s * 0.5}
             Q ${-s * 0.7} ${-s * 0.9} ${-s * 0.2} ${-s * 0.9}
             Q ${s * 0.1} ${-s * 1.1} ${s * 0.5} ${-s * 0.8}
             Q ${s * 1} ${-s * 0.8} ${s * 1.1} ${-s * 0.3}
             Q ${s * 1.3} ${-s * 0.1} ${s * 1.1} ${s * 0.2}
             Q ${s * 1.1} ${s * 0.5} ${s * 0.7} ${s * 0.5}
             L ${-s * 0.5} ${s * 0.5}
             Q ${-s * 0.9} ${s * 0.5} ${-s * 0.9} ${s * 0.2}
             Z
            `, );
        return p;
       }
       if (shape === "database") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.7);
        body.setAttribute("y", -size * 0.6);
        body.setAttribute("width", size * 1.4);
        body.setAttribute("height", size * 1.4);
        g.appendChild(body);
        const top = document.createElementNS(ns, "ellipse");
        top.setAttribute("cx", 0);
        top.setAttribute("cy", -size * 0.6);
        top.setAttribute("rx", size * 0.7);
        top.setAttribute("ry", size * 0.25);
        g.appendChild(top);
        const bottom = document.createElementNS(ns, "ellipse");
        bottom.setAttribute("cx", 0);
        bottom.setAttribute("cy", size * 0.8);
        bottom.setAttribute("rx", size * 0.7);
        bottom.setAttribute("ry", size * 0.25);
        g.appendChild(bottom);
        const mid1 = document.createElementNS(ns, "ellipse");
        mid1.setAttribute("cx", 0);
        mid1.setAttribute("cy", -size * 0.15);
        mid1.setAttribute("rx", size * 0.7);
        mid1.setAttribute("ry", size * 0.2);
        mid1.style.fill = "none";
        mid1.style.stroke = "#475569";
        mid1.style.strokeWidth = "2";
        g.appendChild(mid1);
        const mid2 = document.createElementNS(ns, "ellipse");
        mid2.setAttribute("cx", 0);
        mid2.setAttribute("cy", size * 0.35);
        mid2.setAttribute("rx", size * 0.7);
        mid2.setAttribute("ry", size * 0.2);
        mid2.style.fill = "none";
        mid2.style.stroke = "#475569";
        mid2.style.strokeWidth = "2";
        g.appendChild(mid2);
        return g;
       }
       if (shape === "printer") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.4);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size * 0.9);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const trayTop = document.createElementNS(ns, "rect");
        trayTop.setAttribute("x", -size * 0.7);
        trayTop.setAttribute("y", -size * 0.8);
        trayTop.setAttribute("width", size * 1.4);
        trayTop.setAttribute("height", size * 0.4);
        trayTop.setAttribute("rx", 2);
        trayTop.style.fill = "#1e293b";
        g.appendChild(trayTop);
        const trayOut = document.createElementNS(ns, "rect");
        trayOut.setAttribute("x", -size * 0.6);
        trayOut.setAttribute("y", size * 0.5);
        trayOut.setAttribute("width", size * 1.2);
        trayOut.setAttribute("height", size * 0.35);
        trayOut.setAttribute("rx", 2);
        g.appendChild(trayOut);
        const paper = document.createElementNS(ns, "rect");
        paper.setAttribute("x", -size * 0.5);
        paper.setAttribute("y", size * 0.3);
        paper.setAttribute("width", size * 1);
        paper.setAttribute("height", size * 0.5);
        paper.style.fill = "#e2e8f0";
        g.appendChild(paper);
        return g;
       }
       const c = document.createElementNS(ns, "circle");
       c.setAttribute("r", size);
       return c;
      }
      
      function createNodeShape(id, size) {
       const shapeType = (NODE_DATA[id] && NODE_DATA[id].shape) || "circle";
       const shapeEl = createShapeElement(shapeType, size);
       shapeEl.classList.add("node-circle");
       const styles = resolveStylesForNode(id);
       if (styles.circleColor) {
        shapeEl.style.fill = styles.circleColor;
       }
       if (styles.circleBorder) {
        shapeEl.style.stroke = styles.circleBorder;
       }
       return shapeEl;
      }
      
      function forgeTheLegend() {
       const container = document.getElementById("edge-legend");
       if (!container) return;
       container.innerHTML = "";
       const title = document.createElement("div");
       title.className = "legend-title";
       title.textContent = "Line Legend";
       container.appendChild(title);
       const closeBtn = document.createElement("button");
       closeBtn.type = "button";
       closeBtn.className = "legend-close-btn";
       closeBtn.textContent = "‚úï";
       closeBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        legendCollapsed = true;
        updateLegendVisibility();
       });
       container.appendChild(closeBtn);
       const colors = [...new Set(EDGE_DATA.list.map((e) => e.color).filter(Boolean))];
       if (colors.length === 0) {
        updateLegendVisibility();
        return;
       }
       colors.forEach((color) => {
        if (!EDGE_LEGEND[color]) {
         EDGE_LEGEND[color] = "you can edit me too";
        }
        const item = document.createElement("div");
        item.className = "legend-item";
        item.addEventListener("mousedown", (e) => e.stopPropagation());
        item.addEventListener("click", (e) => e.stopPropagation());
        const swatch = document.createElement("span");
        swatch.className = "legend-swatch";
        swatch.style.backgroundColor = color;
        swatch.style.cursor = "pointer";
        swatch.addEventListener("click", (e) => {
         e.stopPropagation();
         const edgeWithColor = EDGE_DATA.list.find(edge => edge.color === color);
         if (edgeWithColor) {
          selectTheConnection(edgeWithColor.id);
         }
        });
        let swatchTouchStart = null;
        let swatchTouchMoved = false;
        swatch.addEventListener("touchstart", (e) => {
         swatchTouchStart = Date.now();
         swatchTouchMoved = false;
        }, {
         passive: false
        });
        swatch.addEventListener("touchmove", (e) => {
         swatchTouchMoved = true;
        }, {
         passive: false
        });
        swatch.addEventListener("touchend", (e) => {
         if (swatchTouchStart && !swatchTouchMoved && Date.now() - swatchTouchStart < 400) {
          e.stopPropagation();
          e.preventDefault();
          const edgeWithColor = EDGE_DATA.list.find(edge => edge.color === color);
          if (edgeWithColor) {
           selectTheConnection(edgeWithColor.id);
          }
         }
         swatchTouchStart = null;
         swatchTouchMoved = false;
        }, {
         passive: false
        });
        const label = document.createElement("span");
        label.className = "legend-label";
        label.textContent = EDGE_LEGEND[color];
        if (isMobileDevice()) {
         label.style.cursor = "pointer";
         let labelTapStart = null;
         let labelTapMoved = false;
         label.addEventListener("touchstart", (e) => {
          labelTapStart = Date.now();
          labelTapMoved = false;
          e.stopPropagation();
         });
         label.addEventListener("touchmove", (e) => {
          labelTapMoved = true;
         });
         label.addEventListener("touchend", (e) => {
          if (labelTapStart && !labelTapMoved && Date.now() - labelTapStart < 400) {
           e.preventDefault();
           e.stopPropagation();
           const currentText = label.textContent;
           const newText = prompt("Edit legend label:", currentText);
           if (newText !== null && newText.trim()) {
            label.textContent = newText.trim();
            EDGE_LEGEND[color] = newText.trim();
            saveEdgeLegend();
           }
          }
          labelTapStart = null;
          labelTapMoved = false;
         });
        } else {
         label.contentEditable = true;
         label.addEventListener("focus", () => {
          label.classList.add("editing");
         });
         label.addEventListener("blur", () => {
          label.classList.remove("editing");
          const text = label.textContent.trim() || "you can edit me too";
          EDGE_LEGEND[color] = text;
          saveEdgeLegend();
         });
         label.addEventListener("keydown", (e) => {
          if (e.key === "Enter") {
           e.preventDefault();
           label.blur();
          }
         });
        }
        item.append(swatch, label);
        container.appendChild(item);
       });
       updateLegendVisibility();
      }
      
       function deleteRectangle(rectId) {
      pushUndo("delete rectangle");
        RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== rectId);
        forgeTheTopology();
       }
      
       function updateRectangleDeleteButtons() {
        const deleteButtons = document.querySelectorAll('.rect-delete-btn');
        deleteButtons.forEach(btn => {
         btn.style.display = rectDrawMode ? 'block' : 'none';
        });
       }
      
      function forgeTheTopology() {
       if (!NODE_DATA || !EDGE_DATA) {
        console.warn("forgeTheTopology called before data initialized");
        return;
       }
       const svg = document.getElementById("map");
       svg.innerHTML = "";
       const ns = "http://www.w3.org/2000/svg";
       const defs = document.createElementNS(ns, "defs");
       const markerForward = document.createElementNS(ns, "marker");
       markerForward.id = "arrow-forward";
       markerForward.setAttribute("markerWidth", "10");
       markerForward.setAttribute("markerHeight", "10");
       markerForward.setAttribute("refX", "9");
       markerForward.setAttribute("refY", "3");
       markerForward.setAttribute("orient", "auto");
       markerForward.setAttribute("markerUnits", "strokeWidth");
       const pathForward = document.createElementNS(ns, "path");
       pathForward.setAttribute("d", "M0,0 L0,6 L9,3 z");
       pathForward.setAttribute("fill", "context-stroke");
       markerForward.appendChild(pathForward);
       defs.appendChild(markerForward);
       const markerBackward = document.createElementNS(ns, "marker");
       markerBackward.id = "arrow-backward";
       markerBackward.setAttribute("markerWidth", "10");
       markerBackward.setAttribute("markerHeight", "10");
       markerBackward.setAttribute("refX", "0");
       markerBackward.setAttribute("refY", "3");
       markerBackward.setAttribute("orient", "auto");
       markerBackward.setAttribute("markerUnits", "strokeWidth");
       const pathBackward = document.createElementNS(ns, "path");
       pathBackward.setAttribute("d", "M9,0 L9,6 L0,3 z");
       pathBackward.setAttribute("fill", "context-stroke");
       markerBackward.appendChild(pathBackward);
       defs.appendChild(markerBackward);
       svg.appendChild(defs);
       const boundary = document.createElementNS(ns, "rect");
       boundary.setAttribute("x", CANVAS_PADDING);
       boundary.setAttribute("y", CANVAS_PADDING);
       boundary.setAttribute("width", CANVAS_WIDTH - CANVAS_PADDING * 2);
       boundary.setAttribute("height", CANVAS_HEIGHT - CANVAS_PADDING * 2);
       boundary.setAttribute("fill", "none");
       boundary.setAttribute("stroke", "rgba(71, 85, 105, 0.3)");
       boundary.setAttribute("stroke-width", "2");
       boundary.setAttribute("stroke-dasharray", "10 5");
       boundary.setAttribute("rx", "8");
       svg.appendChild(boundary);
       
       if (currentView.mode === "rack" && currentView.rackId) {
        const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
        const rackGroup = document.createElementNS(ns, "g");
        rackGroup.id = "rack-visualization";
        
        const rackFrame = document.createElementNS(ns, "rect");
        rackFrame.setAttribute("x", RACK_START_X - RACK_WIDTH / 2);
        rackFrame.setAttribute("y", RACK_START_Y);
        rackFrame.setAttribute("width", RACK_WIDTH);
      
      rackFrame.setAttribute("height", rackCapacity * rackUHeight);
      
        rackFrame.setAttribute("fill", "rgba(15, 23, 42, 0.3)");
        rackFrame.setAttribute("stroke", "var(--accent)");
        rackFrame.setAttribute("stroke-width", "3");
        rackFrame.setAttribute("rx", "4");
        rackGroup.appendChild(rackFrame);
        
        for (let u = 0; u <= rackCapacity; u++) {
         const y = RACK_START_Y + u * rackUHeight;
      
         
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", RACK_START_X - RACK_WIDTH / 2);
         line.setAttribute("y1", y);
         line.setAttribute("x2", RACK_START_X + RACK_WIDTH / 2);
         line.setAttribute("y2", y);
         line.setAttribute("stroke", "rgba(71, 85, 105, 0.4)");
         line.setAttribute("stroke-width", u % 5 === 0 ? "2" : "1");
         line.setAttribute("stroke-dasharray", u % 5 === 0 ? "none" : "5,5");
         rackGroup.appendChild(line);
         
         if (u < rackCapacity) {
          const uNumber = rackCapacity - u; 
          const text = document.createElementNS(ns, "text");
          text.setAttribute("x", RACK_START_X - RACK_WIDTH / 2 - 30);
          text.setAttribute("y", y + rackUHeight / 2);
      
          text.setAttribute("text-anchor", "middle");
          text.setAttribute("dominant-baseline", "middle");
          text.style.fill = "var(--accent)";
          text.style.fontSize = "14px";
          text.style.fontWeight = "bold";
          text.textContent = `U${uNumber}`;
          rackGroup.appendChild(text);
          
          const textRight = document.createElementNS(ns, "text");
          textRight.setAttribute("x", RACK_START_X + RACK_WIDTH / 2 + 30);
          textRight.setAttribute("y", y + rackUHeight / 2);
      
          textRight.setAttribute("text-anchor", "middle");
          textRight.setAttribute("dominant-baseline", "middle");
          textRight.style.fill = "var(--accent)";
          textRight.style.fontSize = "14px";
          textRight.style.fontWeight = "bold";
          textRight.textContent = `U${uNumber}`;
          rackGroup.appendChild(textRight);
         }
        }
        
        svg.appendChild(rackGroup);
       }
       
        if (RECT_DATA && RECT_DATA.list) {
         RECT_DATA.list.forEach((rect) => {
          if (currentView.mode === "rack") return;
          
          if (rect.style === "filled") {
           const g = document.createElementNS(ns, "g");
           g.classList.add("rect-group");
           g.dataset.rectId = rect.id;
           
           const rectEl = document.createElementNS(ns, "rect");
           rectEl.classList.add("rect-shape");
           rectEl.setAttribute("x", rect.x);
           rectEl.setAttribute("y", rect.y);
           rectEl.setAttribute("width", rect.width);
           rectEl.setAttribute("height", rect.height);
           rectEl.style.fill = rect.color;
           rectEl.style.fillOpacity = "0.3";
           rectEl.style.stroke = rect.color;
           rectEl.style.strokeWidth = "2";
           rectEl.style.cursor = "move";
           
           const deleteBtn = document.createElementNS(ns, "g");
           deleteBtn.classList.add("rect-delete-btn");
           deleteBtn.style.cursor = "pointer";
           deleteBtn.style.display = rectDrawMode ? "block" : "none";
           
           const deleteBg = document.createElementNS(ns, "circle");
           deleteBg.setAttribute("cx", rect.x + rect.width - 10);
           deleteBg.setAttribute("cy", rect.y + 10);
           deleteBg.setAttribute("r", 12);
           deleteBg.style.fill = "#f56565";
           deleteBg.style.stroke = "white";
           deleteBg.style.strokeWidth = "2";
           
           const deleteX = document.createElementNS(ns, "text");
           deleteX.setAttribute("x", rect.x + rect.width - 10);
           deleteX.setAttribute("y", rect.y + 10);
           deleteX.setAttribute("text-anchor", "middle");
           deleteX.setAttribute("dominant-baseline", "middle");
           deleteX.style.fill = "white";
           deleteX.style.fontSize = "16px";
           deleteX.style.fontWeight = "bold";
           deleteX.style.pointerEvents = "none";
           deleteX.textContent = "√ó";
           
           deleteBtn.appendChild(deleteBg);
           deleteBtn.appendChild(deleteX);
           
           deleteBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            e.preventDefault();
            deleteRectangle(rect.id);
           });
      
           deleteBtn.addEventListener("touchend", (e) => {
      e.stopPropagation();
           e.preventDefault();
           deleteRectangle(rect.id);
           });
           
           let isDragging = false;
           let dragStartX, dragStartY;
           let rectStartX, rectStartY;
           
           rectEl.addEventListener("mousedown", (e) => {
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            dragStartX = e.clientX;
            dragStartY = e.clientY;
            rectStartX = rect.x;
            rectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           });
           
           const moveHandler = (e) => {
            if (!isDragging || rectDrawMode) return;
            const svgEl = svg;
            const pt1 = svgEl.createSVGPoint();
            pt1.x = dragStartX;
            pt1.y = dragStartY;
            const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
            
            const pt2 = svgEl.createSVGPoint();
            pt2.x = e.clientX;
            pt2.y = e.clientY;
            const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
            
            const dx = svgP2.x - svgP1.x;
            const dy = svgP2.y - svgP1.y;
            
            rect.x = rectStartX + dx;
            rect.y = rectStartY + dy;
            
            forgeTheTopology();
           };
           
           const upHandler = () => {
            if (isDragging) {
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           };
           
           document.addEventListener("mousemove", moveHandler);
           document.addEventListener("mouseup", upHandler);
           
           let touchStartX, touchStartY;
           let touchRectStartX, touchRectStartY;
           
           rectEl.addEventListener("touchstart", (e) => {
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchRectStartX = rect.x;
            touchRectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           }, { passive: false });
           
           rectEl.addEventListener("touchmove", (e) => {
            if (!isDragging || rectDrawMode) return;
            if (!e.touches[0]) return;
            e.preventDefault();
            e.stopPropagation();
            
            const svgEl = svg;
            const pt1 = svgEl.createSVGPoint();
            pt1.x = touchStartX;
            pt1.y = touchStartY;
            const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
            
            const touch = e.touches[0];
            const pt2 = svgEl.createSVGPoint();
            pt2.x = touch.clientX;
            pt2.y = touch.clientY;
            const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
            
            const dx = svgP2.x - svgP1.x;
            const dy = svgP2.y - svgP1.y;
            
            rect.x = touchRectStartX + dx;
            rect.y = touchRectStartY + dy;
            
            forgeTheTopology();
           }, { passive: false });
           
           rectEl.addEventListener("touchend", (e) => {
            if (isDragging) {
             e.preventDefault();
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           }, { passive: false });
           
           g.appendChild(rectEl);
           g.appendChild(deleteBtn);
           svg.appendChild(g);
          }
         });
        }
       const centerX = CANVAS_WIDTH / 2;
       const centerY = CANVAS_HEIGHT / 2;
       let positions = {};
              Object.keys(NODE_DATA).forEach((id) => {
        if (currentView.mode === "rack") {
         const node = NODE_DATA[id];
         if (!node || node.assignedRack !== currentView.rackId) {
          return; 
         }
        }
        
        positions[id] = savedPositions[id] || {
         x: centerX,
         y: centerY
        };
       });
       if (Object.keys(savedPositions).length === 0) {
        const nodeIds = Object.keys(NODE_DATA).filter(id => {
         if (currentView.mode === "rack") {
          const node = NODE_DATA[id];
          return node && node.assignedRack === currentView.rackId;
         }
         return true;
        });
        
        const baseY = centerY - 300;
        if (nodeIds.length > 0) {
         positions[nodeIds[0]] = {
          x: centerX,
          y: baseY
         };
         const remaining = nodeIds.slice(1);
         const radius = 350;
         const startAngle = Math.PI * 0.3;
         const endAngle = Math.PI * 0.7;
         remaining.forEach((id, i) => {
          const angle = startAngle + (endAngle - startAngle) * (i / Math.max(1, remaining.length - 1));
          positions[id] = {
           x: centerX + Math.cos(angle) * radius * (i % 2 === 0 ? 1 : 1.3),
           y: baseY + 200 + Math.sin(angle) * radius * 0.8 + i * 80,
          };
         });
        }
       }
       Object.keys(positions).forEach((id) => {
        let pos = savedPositions[id] || positions[id];
        const nodeSize = savedSizes[id] || 55;
        pos.x = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, pos.x), );
        pos.y = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, pos.y), );
        positions[id] = {
         x: pos.x,
         y: pos.y
        };
        savedPositions[id] = {
         x: pos.x,
         y: pos.y
        };
       });
       const edgePairCount = {};
       const edgePairIndex = {};
       EDGE_DATA.list.forEach((edge) => {
        if (edge.type === "custom") return;
        const key = [edge.from, edge.to].sort().join("||");
        edgePairCount[key] = (edgePairCount[key] || 0) + 1;
       });
       EDGE_DATA.list.forEach((edge) => {
        if (edge.type === "custom") return;
        const key = [edge.from, edge.to].sort().join("||");
        if (!edgePairIndex[key]) edgePairIndex[key] = 0;
        edge._pairIndex = edgePairIndex[key];
        edge._pairTotal = edgePairCount[key];
        edgePairIndex[key]++;
       });
       EDGE_DATA.list.forEach((edge) => {
        if (edge.type === "custom" && Array.isArray(edge.points) && edge.points.length >= 2) {
         const poly = document.createElementNS(ns, "polyline");
         poly.classList.add("edge");
         poly.dataset.edgeId = edge.id;
         poly.style.stroke = edge.color || "#475569";
         poly.style.strokeWidth = edge.width || 4;
         poly.setAttribute("fill", "none");
         const lineStyle = edge.lineStyle || "solid";
         if (lineStyle === "dashed") {
          poly.style.strokeDasharray = "10,5";
         } else if (lineStyle === "dotted") {
          poly.style.strokeDasharray = "2,4";
         } else {
          poly.style.strokeDasharray = "none";
         }
         const direction = edge.direction || "none";
         if (direction === "forward") {
          poly.setAttribute("marker-end", "url(#arrow-forward)");
         } else if (direction === "backward") {
          poly.setAttribute("marker-start", "url(#arrow-backward)");
         } else if (direction === "both") {
          poly.setAttribute("marker-start", "url(#arrow-backward)");
          poly.setAttribute("marker-end", "url(#arrow-forward)");
         }
         const ptsStr = edge.points.map((p) => `${p.x},${p.y}`).join(" ");
         poly.setAttribute("points", ptsStr);
         const polyHit = document.createElementNS(ns, "polyline");
         polyHit.setAttribute("points", ptsStr);
         polyHit.style.fill = "none";
         polyHit.style.stroke = "transparent";
         polyHit.style.strokeWidth = "20";
         polyHit.style.cursor = "pointer";
         polyHit.dataset.edgeId = edge.id;
         polyHit.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         let edgeTouchStart = null;
         let edgeTouchMoved = false;
         polyHit.addEventListener("touchstart", (e) => {
          edgeTouchStart = Date.now();
          edgeTouchMoved = false;
         }, {
          passive: false
         });
         polyHit.addEventListener("touchmove", (e) => {
          edgeTouchMoved = true;
         }, {
          passive: false
         });
         polyHit.addEventListener("touchend", (e) => {
          if (edgeTouchStart && !edgeTouchMoved && Date.now() - edgeTouchStart < 400) {
           e.stopPropagation();
           e.preventDefault();
           selectTheConnection(edge.id);
          }
          edgeTouchStart = null;
          edgeTouchMoved = false;
         }, {
          passive: false
         });
         poly.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         
         if (currentView.mode === "rack") {
          return;
         }
         
         svg.appendChild(poly);
         svg.appendChild(polyHit);
         return;
        }
        const p1 = positions[edge.from];
        const p2 = positions[edge.to];
        if (!p1 || !p2) return;
        const pairTotal = edge._pairTotal || 1;
        const pairIndex = edge._pairIndex || 0;
        const midX = (p1.x + p2.x) / 2;
        const midY = (p1.y + p2.y) / 2;
        const dx = p2.x - p1.x;
        const dy = p2.y - p1.y;
        const len = Math.sqrt(dx * dx + dy * dy) || 1;
        const perpX = -dy / len;
        const perpY = dx / len;
        let offsetAmount = 0;
        if (pairTotal > 1) {
         offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
        }
        const ctrlX = midX + perpX * offsetAmount;
        const ctrlY = midY + perpY * offsetAmount;
        const path = document.createElementNS(ns, "path");
        path.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
        path.setAttribute("fill", "none");
        path.classList.add("edge");
        if (edge.type === "backup") path.classList.add("backup");
        path.dataset.edgeId = edge.id;
        path.dataset.from = edge.from;
        path.dataset.to = edge.to;
        path.style.stroke = edge.color;
        path.style.strokeWidth = edge.width;
        const pathHit = document.createElementNS(ns, "path");
        pathHit.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
        pathHit.setAttribute("fill", "none");
        pathHit.style.stroke = "transparent";
        pathHit.style.strokeWidth = "20";
        pathHit.style.cursor = "pointer";
        pathHit.dataset.edgeId = edge.id;
        pathHit.addEventListener("click", (e) => {
         e.stopPropagation();
         selectTheConnection(edge.id);
        });
        let pathTouchStart = null;
        let pathTouchMoved = false;
        pathHit.addEventListener("touchstart", (e) => {
         pathTouchStart = Date.now();
         pathTouchMoved = false;
        }, {
         passive: false
        });
        pathHit.addEventListener("touchmove", (e) => {
         pathTouchMoved = true;
        }, {
         passive: false
        });
        pathHit.addEventListener("touchend", (e) => {
         if (pathTouchStart && !pathTouchMoved && Date.now() - pathTouchStart < 400) {
          e.stopPropagation();
          e.preventDefault();
          selectTheConnection(edge.id);
         }
         pathTouchStart = null;
         pathTouchMoved = false;
        }, {
         passive: false
        });
        path.addEventListener("click", (e) => {
         e.stopPropagation();
         selectTheConnection(edge.id);
        });
        
        if (currentView.mode === "rack") {
         const fromNode = NODE_DATA[edge.from];
         const toNode = NODE_DATA[edge.to];
         if (!fromNode || !toNode || 
             fromNode.assignedRack !== currentView.rackId || 
             toNode.assignedRack !== currentView.rackId) {
          return; 
         }
        }
        
        const fromVisible = isNodeVisible(edge.from);
        const toVisible = isNodeVisible(edge.to);
        if (!fromVisible || !toVisible) {
         path.style.opacity = "0.1";
         path.style.pointerEvents = "none";
         pathHit.style.pointerEvents = "none";
        }
        
        svg.appendChild(path);
        svg.appendChild(pathHit);
        
        if (edge.fromPort || edge.toPort) {
         const ns = "http://www.w3.org/2000/svg";
         
         if (edge.fromPort) {
          const fromLabel = document.createElementNS(ns, "text");
          fromLabel.textContent = edge.fromPort;
          fromLabel.setAttribute("x", p1.x);
          fromLabel.setAttribute("y", p1.y - 10);
          fromLabel.setAttribute("text-anchor", "middle");
          fromLabel.style.fill = "#94a3b8";
          fromLabel.style.fontSize = "12px";
          fromLabel.style.fontWeight = "600";
          fromLabel.style.pointerEvents = "none";
          fromLabel.classList.add("port-label");
          svg.appendChild(fromLabel);
         }
         
         if (edge.toPort) {
          const toLabel = document.createElementNS(ns, "text");
          toLabel.textContent = edge.toPort;
          toLabel.setAttribute("x", p2.x);
          toLabel.setAttribute("y", p2.y - 10);
          toLabel.setAttribute("text-anchor", "middle");
          toLabel.style.fill = "#94a3b8";
          toLabel.style.fontSize = "12px";
          toLabel.style.fontWeight = "600";
          toLabel.style.pointerEvents = "none";
          toLabel.classList.add("port-label");
          svg.appendChild(toLabel);
         }
        }
       });
       Object.entries(positions).forEach(([id, pos]) => {
        const node = NODE_DATA[id];
        if (!node) return;
        
        if (currentView.mode === "rack") {
         if (node.assignedRack !== currentView.rackId) return;
         
         const rackUnit = parseInt(node.rackUnit) || 1;
      const uHeight = parseInt(node.uHeight) || 1;
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      pos.x = RACK_START_X;
      pos.y = RACK_START_Y + (rackCapacity - rackUnit - uHeight + 1) * rackUHeight + (uHeight * rackUHeight) / 2;
      
        } else {
         if (node.assignedRack) return;
        }
        
        const g = document.createElementNS("http://www.w3.org/2000/svg", "g", );
        g.classList.add("node-group");
        g.dataset.nodeId = id;
        g.setAttribute("transform", `translate(${pos.x},${pos.y})`);
        let r = savedSizes[id] || 55;
        if (!savedSizes[id]) {
         if (window.innerWidth <= 380) r = 120;
         else if (window.innerWidth <= 768) r = 140;
         else if (window.innerWidth <= 1024) r = 70;
        }
        const styles = resolveStylesForNode(id);
        const ns = "http://www.w3.org/2000/svg";
        const hitArea = document.createElementNS(ns, "circle");
        hitArea.setAttribute("r", r * 1.5);
        hitArea.style.fill = "transparent";
        hitArea.style.stroke = "none";
        hitArea.style.cursor = "grab";
        hitArea.classList.add("node-hit-area");
        const shapeEl = createNodeShape(id, r);
        const titleOffsetX = styles.titleOffsetX || 0;
        const titleOffsetY = styles.titleOffsetY || 0;
        const subOffsetX = styles.subOffsetX || 0;
        const subOffsetY = styles.subOffsetY || 0;
        const label = document.createElementNS("http://www.w3.org/2000/svg", "text", );
        label.classList.add("node-label");
        label.setAttribute("x", titleOffsetX);
        label.setAttribute("y", -r * 0.28 + titleOffsetY);
        const labelFontSize = styles.titleSize || r * 0.33;
        label.style.fontSize = labelFontSize + "px";
        label.textContent = NODE_DATA[id].name;
        if (styles.titleColor) label.style.fill = styles.titleColor;
        if (styles.titleFont) label.style.fontFamily = styles.titleFont;
        label.style.pointerEvents = "none";
        const sub = document.createElementNS("http://www.w3.org/2000/svg", "text", );
        sub.classList.add("node-sub");
        sub.setAttribute("x", subOffsetX);
        sub.setAttribute("y", r * 0.4 + subOffsetY);
        const subFontSize = styles.subSize || r * 0.24;
        sub.style.fontSize = subFontSize + "px";
        sub.textContent = NODE_DATA[id].ip;
        if (styles.subColor) sub.style.fill = styles.subColor;
        if (styles.subFont) sub.style.fontFamily = styles.subFont;
        sub.style.pointerEvents = "none";
        g.append(hitArea, shapeEl, label, sub);
        
        if (NODE_DATA[id]?.locked) {
          const lockIcon = document.createElementNS(ns, "text");
          lockIcon.textContent = "üîí";
          lockIcon.setAttribute("x", r * 0.6);
          lockIcon.setAttribute("y", -r * 0.6);
          lockIcon.style.fontSize = (r * 0.4) + "px";
          lockIcon.style.pointerEvents = "none";
          lockIcon.style.userSelect = "none";
          lockIcon.classList.add("lock-indicator");
          g.appendChild(lockIcon);
        }
        
        if (NODE_DATA[id]?.groupId) {
          const groupIndicator = document.createElementNS(ns, "circle");
          groupIndicator.setAttribute("r", r + 4);
          groupIndicator.style.fill = "none";
          groupIndicator.style.stroke = "#4fd1c5";
          groupIndicator.style.strokeWidth = "3";
          groupIndicator.style.strokeDasharray = "5,5";
          groupIndicator.style.pointerEvents = "none";
          groupIndicator.classList.add("group-indicator");
          g.insertBefore(groupIndicator, g.firstChild);
        }
        
        let isDragging = false;
        let startX, startY;
        let initialPositions = {};
        let longPressTimer = null;
        let longPressTriggered = false;
        
        g.addEventListener("contextmenu", (e) => {
         e.preventDefault();
         e.stopPropagation();
         
         if (selectedNodes.has(id)) {
          selectedNodes.delete(id);
         } else {
          selectedNodes.add(id);
         }
         updateNodeSelection();
         return false;
        });
        
        g.addEventListener("touchstart", (e) => {
         if (NODE_DATA[id].isRack) {
          longPressTimer = setTimeout(() => {
           longPressTriggered = true;
           if (navigator.vibrate) {
            navigator.vibrate(100);
           }
           enterRack(id);
          }, 500); 
         }
        }, { passive: true });
        
        let lastTapTime = 0;
        let lastTapNode = null;
        
        g.addEventListener("touchend", (e) => {
         const currentTime = new Date().getTime();
         const tapLength = currentTime - lastTapTime;
         
         if (tapLength < 300 && tapLength > 0 && lastTapNode === id) {
          e.preventDefault();
          e.stopPropagation();
          
          if (selectedNodes.has(id)) {
           selectedNodes.delete(id);
          } else {
           selectedNodes.add(id);
          }
          updateNodeSelection();
          
          if (navigator.vibrate) {
           navigator.vibrate(50);
          }
          
          lastTapTime = 0;
          lastTapNode = null;
         } else {
          lastTapTime = currentTime;
          lastTapNode = id;
         }
        });
        
        g.addEventListener("touchend", (e) => {
         if (longPressTimer) {
          clearTimeout(longPressTimer);
          longPressTimer = null;
         }
         if (longPressTriggered) {
          e.preventDefault();
          e.stopPropagation();
          longPressTriggered = false;
         }
        });
        
        g.addEventListener("touchmove", (e) => {
         if (longPressTimer) {
          clearTimeout(longPressTimer);
          longPressTimer = null;
          longPressTriggered = false;
         }
        });
        
        g.addEventListener("mousedown", (e) => {
         if (e.button === 2) {
          return;
         }
         
         if (NODE_DATA[id]?.locked) {
          return;
         }
         
         e.preventDefault();
         isDragging = true;
         const svgEl = document.getElementById("map");
         const pt = svgEl.createSVGPoint();
         pt.x = e.clientX;
         pt.y = e.clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
         startX = svgP.x;
         startY = svgP.y;
         
      if (selectedNodes.has(id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) {
      initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      }
      });
      } else {
      initialPositions = { [id]: { x: pos.x, y: pos.y } };
      }
      if (currentView.mode === "rack") {
      initialPositions[id] = { x: pos.x, y: pos.y };
      }
         
         g.style.cursor = "grabbing";
         hitArea.style.cursor = "grabbing";
         e.stopPropagation();
        });
        const handleMouseMove = (e) => {
         if (!isDragging) return;
         e.preventDefault();
         const svgEl = document.getElementById("map");
         const pt = svgEl.createSVGPoint();
         pt.x = e.clientX;
         pt.y = e.clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
         const dx = svgP.x - startX;
         const dy = svgP.y - startY;
         
         let nodesToMove = selectedNodes.has(id) ? Array.from(selectedNodes) : [id];
         
         const groupIds = new Set();
         nodesToMove.forEach(nodeId => {
          const groupId = NODE_DATA[nodeId]?.groupId;
          if (groupId) {
            groupIds.add(groupId);
          }
         });
         
         if (groupIds.size > 0) {
          Object.keys(NODE_DATA).forEach(nodeId => {
            const nodeGroupId = NODE_DATA[nodeId]?.groupId;
            if (nodeGroupId && groupIds.has(nodeGroupId)) {
              if (!nodesToMove.includes(nodeId)) {
                nodesToMove.push(nodeId);
                if (!initialPositions[nodeId]) {
                  const nodePos = savedPositions[nodeId];
                  if (nodePos) {
                    initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
                  }
                }
              }
            }
          });
         }
         
         nodesToMove = nodesToMove.filter(nodeId => !NODE_DATA[nodeId]?.locked);
         
         nodesToMove.forEach(nodeId => {
          if (!initialPositions[nodeId]) return;
          const initialPos = initialPositions[nodeId];
          let newX = initialPos.x + dx;
          let newY = initialPos.y + dy;
          const nodeSize = savedSizes[nodeId] || 55;
          newX = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, newX), );
          newY = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, newY), );
          
          savedPositions[nodeId] = { x: newX, y: newY };
          positions[nodeId] = { x: newX, y: newY };
          
          if (nodeId === id) {
           pos.x = newX;
           pos.y = newY;
          }
          
          const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
          if (nodeGroup) {
           nodeGroup.setAttribute("transform", `translate(${newX},${newY})`);
          }
         });
         
         updateMinimap();
         document.querySelectorAll(".edge").forEach((edgeEl) => {
          const fromId = edgeEl.dataset.from;
          const toId = edgeEl.dataset.to;
          if (nodesToMove.includes(fromId) || nodesToMove.includes(toId)) {
           const p1 = savedPositions[fromId] || positions[fromId] || {
            x: 600,
            y: 350
           };
           const p2 = savedPositions[toId] || positions[toId] || {
            x: 600,
            y: 350
           };
           if (edgeEl.tagName === "line") {
            edgeEl.setAttribute("x1", p1.x);
            edgeEl.setAttribute("y1", p1.y);
            edgeEl.setAttribute("x2", p2.x);
            edgeEl.setAttribute("y2", p2.y);
           } else if (edgeEl.tagName === "path") {
            const edgeId = edgeEl.dataset.edgeId;
            const edge = EDGE_DATA.list.find(
             (e) => e.id === edgeId, );
            if (edge) {
             const pairTotal = edge._pairTotal || 1;
             const pairIndex = edge._pairIndex || 0;
             const midX = (p1.x + p2.x) / 2;
             const midY = (p1.y + p2.y) / 2;
             const dx = p2.x - p1.x;
             const dy = p2.y - p1.y;
             const len = Math.sqrt(dx * dx + dy * dy) || 1;
             const perpX = -dy / len;
             const perpY = dx / len;
             let offsetAmount = 0;
             if (pairTotal > 1) {
              offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
             }
             const ctrlX = midX + perpX * offsetAmount;
             const ctrlY = midY + perpY * offsetAmount;
             edgeEl.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
            }
           }
          }
         });
        };
      const handleMouseUp = () => {
      if (isDragging) {
      pushUndo("move nodes");
      isDragging = false;
      g.style.cursor = "grab";
      hitArea.style.cursor = "grab";
      if (currentView.mode === "rack" && NODE_DATA[id]?.assignedRack === currentView.rackId) {
      const draggedY = savedPositions[id]?.y || pos.y;
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      let newUnit = rackCapacity - Math.round((draggedY - RACK_START_Y) / rackUHeight);
      newUnit = Math.max(1, Math.min(newUnit, rackCapacity));
      NODE_DATA[id].rackUnit = newUnit;
      
      forgeTheTopology();
      claimTheImmortal(id);
      }
      }
      };
        document.addEventListener("mousemove", handleMouseMove);
        document.addEventListener("mouseup", handleMouseUp);
        let touchStartTime = 0;
        let touchStartX = 0;
        let touchStartY = 0;
        let touchMoved = false;
       g.addEventListener("touchstart",
         (e) => {
          if (NODE_DATA[id]?.locked) {
           return;
          }
          
          e.preventDefault();
          touchStartTime = Date.now();
          touchMoved = false;
          const svgEl = document.getElementById("map");
          const pt = svgEl.createSVGPoint();
          const touch = e.touches[0];
          pt.x = touch.clientX;
          pt.y = touch.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          touchStartX = svgP.x;
          touchStartY = svgP.y;
          startX = svgP.x;
          startY = svgP.y;
          
          if (selectedNodes.has(id)) {
           initialPositions = {};
           selectedNodes.forEach(nodeId => {
            const nodePos = savedPositions[nodeId];
            if (nodePos) {
             initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
            }
           });
          } else {
           initialPositions = { [id]: { x: pos.x, y: pos.y } };
          }
          
          e.stopPropagation();
         }, {
          passive: false
         }, );
        g.addEventListener("touchmove", (e) => {
         e.preventDefault();
         const svgEl = document.getElementById("map");
         const pt = svgEl.createSVGPoint();
         const touch = e.touches[0];
         pt.x = touch.clientX;
         pt.y = touch.clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
         const dx = Math.abs(svgP.x - touchStartX);
         const dy = Math.abs(svgP.y - touchStartY);
         if (dx > (isMobileDevice() ? 4 : 10) || dy > (isMobileDevice() ? 4 : 10)) {
      touchMoved = true;
      isDragging = true;
      }
         if (!isDragging) return;
         
         const deltaX = svgP.x - startX;
         const deltaY = svgP.y - startY;
         
         let nodesToMove = selectedNodes.has(id) ? Array.from(selectedNodes) : [id];
         
         const groupIds = new Set();
         nodesToMove.forEach(nodeId => {
          const groupId = NODE_DATA[nodeId]?.groupId;
          if (groupId) {
            groupIds.add(groupId);
          }
         });
         
         if (groupIds.size > 0) {
          Object.keys(NODE_DATA).forEach(nodeId => {
            const nodeGroupId = NODE_DATA[nodeId]?.groupId;
            if (nodeGroupId && groupIds.has(nodeGroupId)) {
              if (!nodesToMove.includes(nodeId)) {
                nodesToMove.push(nodeId);
                if (!initialPositions[nodeId]) {
                  const nodePos = savedPositions[nodeId];
                  if (nodePos) {
                    initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
                  }
                }
              }
            }
          });
         }
         
         nodesToMove = nodesToMove.filter(nodeId => !NODE_DATA[nodeId]?.locked);
         
         nodesToMove.forEach(nodeId => {
          if (!initialPositions[nodeId]) return;
          const initialPos = initialPositions[nodeId];
          let newX = initialPos.x + deltaX;
          let newY = initialPos.y + deltaY;
          const nodeSize = savedSizes[nodeId] || 55;
          newX = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, newX), );
          newY = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, newY), );
          
          savedPositions[nodeId] = { x: newX, y: newY };
          positions[nodeId] = { x: newX, y: newY };
          
          if (nodeId === id) {
           pos.x = newX;
           pos.y = newY;
          }
          
          const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
          if (nodeGroup) {
           nodeGroup.setAttribute("transform", `translate(${newX},${newY})`);
          }
         });
         
         updateMinimap();
         document.querySelectorAll(".edge").forEach((edgeEl) => {
          const fromId = edgeEl.dataset.from;
          const toId = edgeEl.dataset.to;
          if (nodesToMove.includes(fromId) || nodesToMove.includes(toId)) {
           const p1 = savedPositions[fromId] || positions[fromId] || {
            x: 600,
            y: 350
           };
           const p2 = savedPositions[toId] || positions[toId] || {
            x: 600,
            y: 350
           };
           if (edgeEl.tagName === "line") {
            edgeEl.setAttribute("x1", p1.x);
            edgeEl.setAttribute("y1", p1.y);
            edgeEl.setAttribute("x2", p2.x);
            edgeEl.setAttribute("y2", p2.y);
           } else if (edgeEl.tagName === "path") {
            const edgeId = edgeEl.dataset.edgeId;
            const edge = EDGE_DATA.list.find(
             (e) => e.id === edgeId, );
            if (edge) {
             const pairTotal = edge._pairTotal || 1;
             const pairIndex = edge._pairIndex || 0;
             const midX = (p1.x + p2.x) / 2;
             const midY = (p1.y + p2.y) / 2;
             const dx = p2.x - p1.x;
             const dy = p2.y - p1.y;
             const len = Math.sqrt(dx * dx + dy * dy) || 1;
             const perpX = -dy / len;
             const perpY = dx / len;
             let offsetAmount = 0;
             if (pairTotal > 1) {
              offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
             }
             const ctrlX = midX + perpX * offsetAmount;
             const ctrlY = midY + perpY * offsetAmount;
             edgeEl.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
            }
           }
          }
         });
        }, {
         passive: false
        });
      g.addEventListener("touchend", (e) => {
      const touchDuration = Date.now() - touchStartTime;
      if (!touchMoved && touchDuration < 400) {
      claimTheImmortal(id);
      }
      if (isDragging) {
      const draggedY = pos.y;
      isDragging = false;
      savedPositions[id] = {
      x: pos.x,
      y: pos.y
      };
      if (currentView.mode === "rack" && NODE_DATA[id]?.assignedRack === currentView.rackId) {
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      let newUnit = rackCapacity - Math.round((draggedY - RACK_START_Y) / rackUHeight);
      
      newUnit = Math.max(1, Math.min(newUnit, rackCapacity));
      NODE_DATA[id].rackUnit = newUnit;
      forgeTheTopology();
      claimTheImmortal(id);
      }
      }
      touchMoved = false;
      });
        g.style.cursor = "grab";
        g.addEventListener("click", (e) => {
         if (!isDragging) {
          claimTheImmortal(id);
         }
        });
        
        g.addEventListener("dblclick", (e) => {
         e.preventDefault();
         e.stopPropagation();
         if (NODE_DATA[id].isRack) {
          enterRack(id);
         }
        });
        
        if (!isNodeVisible(id)) {
         g.style.opacity = "0.1";
         g.style.pointerEvents = "none";
        }
        
        svg.appendChild(g);
       });
        if (RECT_DATA && RECT_DATA.list) {
         RECT_DATA.list.forEach((rect) => {
          if (rect.style === "outlined") {
           const g = document.createElementNS(ns, "g");
           g.classList.add("rect-group");
           g.dataset.rectId = rect.id;
           
           const rectEl = document.createElementNS(ns, "rect");
           rectEl.classList.add("rect-shape");
           rectEl.setAttribute("x", rect.x);
           rectEl.setAttribute("y", rect.y);
           rectEl.setAttribute("width", rect.width);
           rectEl.setAttribute("height", rect.height);
           rectEl.style.fill = "none";
           rectEl.style.stroke = rect.color;
           rectEl.style.strokeWidth = "3";
           rectEl.style.cursor = "move";
           
           const deleteBtn = document.createElementNS(ns, "g");
           deleteBtn.classList.add("rect-delete-btn");
           deleteBtn.style.cursor = "pointer";
           deleteBtn.style.display = rectDrawMode ? "block" : "none";
           
           const deleteBg = document.createElementNS(ns, "circle");
           deleteBg.setAttribute("cx", rect.x + rect.width - 10);
           deleteBg.setAttribute("cy", rect.y + 10);
           deleteBg.setAttribute("r", 12);
           deleteBg.style.fill = "#f56565";
           deleteBg.style.stroke = "white";
           deleteBg.style.strokeWidth = "2";
           
           const deleteX = document.createElementNS(ns, "text");
           deleteX.setAttribute("x", rect.x + rect.width - 10);
           deleteX.setAttribute("y", rect.y + 10);
           deleteX.setAttribute("text-anchor", "middle");
           deleteX.setAttribute("dominant-baseline", "middle");
           deleteX.style.fill = "white";
           deleteX.style.fontSize = "16px";
           deleteX.style.fontWeight = "bold";
           deleteX.style.pointerEvents = "none";
           deleteX.textContent = "√ó";
           
           deleteBtn.appendChild(deleteBg);
           deleteBtn.appendChild(deleteX);
           
           deleteBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            e.preventDefault();
            deleteRectangle(rect.id);
           });
           
           let isDragging = false;
           let dragStartX, dragStartY;
           let rectStartX, rectStartY;
           
           rectEl.addEventListener("mousedown", (e) => {
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            dragStartX = e.clientX;
            dragStartY = e.clientY;
            rectStartX = rect.x;
            rectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           });
           
           const moveHandler = (e) => {
            if (!isDragging || rectDrawMode) return;
            const svgEl = svg;
            const pt1 = svgEl.createSVGPoint();
            pt1.x = dragStartX;
            pt1.y = dragStartY;
            const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
            
            const pt2 = svgEl.createSVGPoint();
            pt2.x = e.clientX;
            pt2.y = e.clientY;
            const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
            
            const dx = svgP2.x - svgP1.x;
            const dy = svgP2.y - svgP1.y;
            
            rect.x = rectStartX + dx;
            rect.y = rectStartY + dy;
            
            forgeTheTopology();
           };
           
           const upHandler = () => {
            if (isDragging) {
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           };
           
           document.addEventListener("mousemove", moveHandler);
           document.addEventListener("mouseup", upHandler);
           
           let touchStartX, touchStartY;
           let touchRectStartX, touchRectStartY;
           
           rectEl.addEventListener("touchstart", (e) => {
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchRectStartX = rect.x;
            touchRectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           }, { passive: false });
           
           rectEl.addEventListener("touchmove", (e) => {
            if (!isDragging || rectDrawMode) return;
            if (!e.touches[0]) return;
            e.preventDefault();
            e.stopPropagation();
            
            const svgEl = svg;
            const pt1 = svgEl.createSVGPoint();
            pt1.x = touchStartX;
            pt1.y = touchStartY;
            const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
            
            const touch = e.touches[0];
            const pt2 = svgEl.createSVGPoint();
            pt2.x = touch.clientX;
            pt2.y = touch.clientY;
            const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
            
            const dx = svgP2.x - svgP1.x;
            const dy = svgP2.y - svgP1.y;
            
            rect.x = touchRectStartX + dx;
            rect.y = touchRectStartY + dy;
            
            forgeTheTopology();
           }, { passive: false });
           
           rectEl.addEventListener("touchend", (e) => {
            if (isDragging) {
             e.preventDefault();
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           }, { passive: false });
           
           g.appendChild(rectEl);
           g.appendChild(deleteBtn);
           svg.appendChild(g);
          }
         });
        }
        
        if (TEXT_DATA && TEXT_DATA.list) {
         TEXT_DATA.list.forEach((textItem) => {
          if (currentView.mode === "rack") return;
          
          const g = document.createElementNS(ns, "g");
          g.classList.add("text-group");
          g.dataset.textId = textItem.id;
          
          if (textItem.bgEnabled) {
           const bgRect = document.createElementNS(ns, "rect");
           bgRect.classList.add("text-bg");
           
           bgRect.setAttribute("x", textItem.x - 5);
           bgRect.setAttribute("y", textItem.y - textItem.fontSize - 2);
           bgRect.setAttribute("width", 100);
           bgRect.setAttribute("height", textItem.fontSize + 10);
           bgRect.style.fill = textItem.bgColor;
           bgRect.style.opacity = "0.7";
           bgRect.style.rx = "4";
           g.appendChild(bgRect);
          }
          
          const textEl = document.createElementNS(ns, "text");
          textEl.classList.add("text-element");
          textEl.setAttribute("x", textItem.x);
          textEl.setAttribute("y", textItem.y);
          textEl.style.fill = textItem.color;
          textEl.style.fontSize = textItem.fontSize + "px";
          textEl.style.fontWeight = textItem.fontWeight;
          textEl.style.fontStyle = textItem.fontStyle;
          textEl.style.textAnchor = textItem.textAlign;
          textEl.style.textDecoration = textItem.textDecoration;
          textEl.style.opacity = textItem.opacity;
          textEl.style.cursor = "move";
          textEl.style.userSelect = "none";
          textEl.setAttribute("dominant-baseline", "middle");
          
          const lines = textItem.content.split('\n');
          if (lines.length === 1) {
           textEl.textContent = textItem.content;
          } else {
           lines.forEach((line, i) => {
            const tspan = document.createElementNS(ns, "tspan");
            tspan.textContent = line;
            tspan.setAttribute("x", textItem.x);
            tspan.setAttribute("dy", i === 0 ? 0 : textItem.fontSize * 1.2);
            textEl.appendChild(tspan);
           });
          }
          
          g.appendChild(textEl);
          
          if (textItem.bgEnabled) {
           setTimeout(() => {
            try {
             const bbox = textEl.getBBox();
             const bgRect = g.querySelector('.text-bg');
             if (bgRect && bbox) {
              bgRect.setAttribute("x", bbox.x - 5);
              bgRect.setAttribute("y", bbox.y - 2);
              bgRect.setAttribute("width", bbox.width + 10);
              bgRect.setAttribute("height", bbox.height + 4);
             }
            } catch (e) {
            }
           }, 0);
          }
          
          const deleteBtn = document.createElementNS(ns, "g");
          deleteBtn.classList.add("text-delete-btn");
          deleteBtn.style.cursor = "pointer";
          deleteBtn.style.display = textDrawMode ? "block" : "none";
          
          const deleteBg = document.createElementNS(ns, "circle");
          deleteBg.setAttribute("cx", textItem.x + 20);
          deleteBg.setAttribute("cy", textItem.y - textItem.fontSize);
          deleteBg.setAttribute("r", 12);
          deleteBg.style.fill = "#f56565";
          deleteBg.style.stroke = "white";
          deleteBg.style.strokeWidth = "2";
          
          const deleteX = document.createElementNS(ns, "text");
          deleteX.setAttribute("x", textItem.x + 20);
          deleteX.setAttribute("y", textItem.y - textItem.fontSize);
          deleteX.setAttribute("text-anchor", "middle");
          deleteX.setAttribute("dominant-baseline", "middle");
          deleteX.style.fill = "white";
          deleteX.style.fontSize = "16px";
          deleteX.style.fontWeight = "bold";
          deleteX.style.pointerEvents = "none";
          deleteX.textContent = "√ó";
          
          deleteBtn.appendChild(deleteBg);
          deleteBtn.appendChild(deleteX);
          
          deleteBtn.addEventListener("click", (e) => {
           e.stopPropagation();
           e.preventDefault();
           deleteText(textItem.id);
          });
          
          let isDragging = false;
          let dragStartX, dragStartY;
          let textStartX, textStartY;
          
          textEl.addEventListener("mousedown", (e) => {
           if (textDrawMode) return;
           e.preventDefault();
           e.stopPropagation();
           isDragging = true;
           dragStartX = e.clientX;
           dragStartY = e.clientY;
           textStartX = textItem.x;
           textStartY = textItem.y;
           textEl.style.cursor = "grabbing";
           
           showTextPanel(textItem.id);
          });
          
          const moveHandler = (e) => {
           if (!isDragging || textDrawMode) return;
           const svgEl = svg;
           const pt1 = svgEl.createSVGPoint();
           pt1.x = dragStartX;
           pt1.y = dragStartY;
           const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
           
           const pt2 = svgEl.createSVGPoint();
           pt2.x = e.clientX;
           pt2.y = e.clientY;
           const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
           
           const dx = svgP2.x - svgP1.x;
           const dy = svgP2.y - svgP1.y;
           
           textItem.x = textStartX + dx;
           textItem.y = textStartY + dy;
           
           forgeTheTopology();
          };
          
          const upHandler = () => {
           if (isDragging) {
            isDragging = false;
            textEl.style.cursor = "move";
           }
          };
          
          document.addEventListener("mousemove", moveHandler);
          document.addEventListener("mouseup", upHandler);
          
          let touchStartX = 0, touchStartY = 0;
          let textTouchStartX = 0, textTouchStartY = 0;
          
          textEl.addEventListener("touchstart", (e) => {
           if (textDrawMode) return;
           if (e.touches.length !== 1) return;
           
           e.preventDefault();
           e.stopPropagation();
           const touch = e.touches[0];
           isDragging = true;
           touchStartX = touch.clientX;
           touchStartY = touch.clientY;
           textTouchStartX = textItem.x;
           textTouchStartY = textItem.y;
           
           showTextPanel(textItem.id);
          }, { passive: false });
          
          textEl.addEventListener("touchmove", (e) => {
           if (!isDragging || textDrawMode) return;
           if (e.touches.length !== 1) return;
           
           e.preventDefault();
           const touch = e.touches[0];
           const svgEl = svg;
           
           const pt1 = svgEl.createSVGPoint();
           pt1.x = touchStartX;
           pt1.y = touchStartY;
           const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
           
           const pt2 = svgEl.createSVGPoint();
           pt2.x = touch.clientX;
           pt2.y = touch.clientY;
           const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
           
           const dx = svgP2.x - svgP1.x;
           const dy = svgP2.y - svgP1.y;
           
           textItem.x = textTouchStartX + dx;
           textItem.y = textTouchStartY + dy;
           
           forgeTheTopology();
          }, { passive: false });
          
          textEl.addEventListener("touchend", () => {
           if (isDragging) {
            isDragging = false;
           }
          }, { passive: false });
          
          g.appendChild(deleteBtn);
          svg.appendChild(g);
         });
        }
        
       forgeTheLegend();
       updateMinimap();
       populateRackDropdown();
      }
      
      function showEditModal(title, currentValue, onSave) {
       const modal = document.getElementById("edit-modal");
       const input = document.getElementById("modal-input");
       const titleEl = document.getElementById("modal-title");
       const saveBtn = document.getElementById("modal-save");
       const cancelBtn = document.getElementById("modal-cancel");
       titleEl.textContent = title;
       input.value = currentValue;
       modal.classList.add("active");
       input.focus();
       input.select();
       const handleSave = () => {
        if (input.value.trim()) {
         onSave(input.value.trim());
        }
        modal.classList.remove("active");
        saveBtn.removeEventListener("click", handleSave);
        cancelBtn.removeEventListener("click", handleCancel);
        input.removeEventListener("keypress", handleEnter);
       };
       const handleCancel = () => {
        modal.classList.remove("active");
        saveBtn.removeEventListener("click", handleSave);
        cancelBtn.removeEventListener("click", handleCancel);
        input.removeEventListener("keypress", handleEnter);
       };
       const handleEnter = (e) => {
        if (e.key === "Enter") handleSave();
       };
       saveBtn.addEventListener("click", handleSave);
       cancelBtn.addEventListener("click", handleCancel);
       input.addEventListener("keypress", handleEnter);
       modal.addEventListener("click", function bgHandler(e) {
        if (e.target === modal) {
         handleCancel();
         modal.removeEventListener("click", bgHandler);
        }
       });
      }
      
      function challengeTheImmortal(message, onConfirm) {
       const modal = document.getElementById("confirm-modal");
       const messageEl = document.getElementById("confirm-message");
       const deleteBtn = document.getElementById("confirm-delete");
       const cancelBtn = document.getElementById("confirm-cancel");
       messageEl.textContent = message;
       modal.classList.add("active");
       const handleConfirm = () => {
        onConfirm();
        modal.classList.remove("active");
        deleteBtn.removeEventListener("click", handleConfirm);
        cancelBtn.removeEventListener("click", handleCancel);
       };
       const handleCancel = () => {
        modal.classList.remove("active");
        deleteBtn.removeEventListener("click", handleConfirm);
        cancelBtn.removeEventListener("click", handleCancel);
       };
       deleteBtn.addEventListener("click", handleConfirm);
       cancelBtn.addEventListener("click", handleCancel);
       modal.addEventListener("click", function bgHandler(e) {
        if (e.target === modal) {
         handleCancel();
         modal.removeEventListener("click", bgHandler);
        }
       });
      }
      const pageTitleEl = document.getElementById("page-title");
      if (pageTitleEl) {
       pageTitleEl.addEventListener("click", () => {
        showEditModal("Edit Title", PAGE_STATE.title || DEFAULT_PAGE_STATE.title,
         (newTitle) => {
          PAGE_STATE.title = newTitle;
          wieldThePower();
         }, );
       });
      }
      
      function editNodeName(id) {
       showEditModal("Edit Name", NODE_DATA[id].name, (newName) => {
        NODE_DATA[id].name = newName;
        const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`, );
        if (nodeGroup) {
         const label = nodeGroup.querySelector(".node-label");
         if (label) label.textContent = newName;
        }
        if (currentNodeId === id) {
         document.getElementById("node-name").textContent = newName;
        }
       });
      }
      
      function editNodeIp(id) {
       showEditModal("Edit IP/Subtitle", NODE_DATA[id].ip, (newIp) => {
        NODE_DATA[id].ip = newIp;
        const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`, );
        if (nodeGroup) {
         const sub = nodeGroup.querySelector(".node-sub");
         if (sub) sub.textContent = newIp;
        }
        if (currentNodeId === id) {
         document.getElementById("node-ip").textContent = newIp;
        }
       });
      }
      
      function claimTheImmortal(id) {
       currentNodeId = id;
       currentEdgeId = null;
       
       if (isMobileDevice()) {
        const currentHeight = PAGE_STATE.mobileFooterHeight || 40;
        if (currentHeight <= 20) {
         PAGE_STATE.mobileFooterHeight = 80;
         const root = document.documentElement;
         root.style.setProperty("--mobile-footer-height", "80vh");
         const mobileFooterHeightInput = document.getElementById("mobile-footer-height");
         const mobileFooterHeightVal = document.getElementById("mobile-footer-height-val");
         if (mobileFooterHeightInput) mobileFooterHeightInput.value = 80;
         if (mobileFooterHeightVal) mobileFooterHeightVal.textContent = "80%";
        }
       }
       
       const data = NODE_DATA[id];
       document.querySelectorAll(".node-group").forEach((n) => {
        n.classList.toggle("active", n.dataset.nodeId === id);
       });
       document.querySelectorAll(".edge").forEach((e) => {
        const active = e.dataset.from === id || e.dataset.to === id;
        e.classList.toggle("active", active);
       });
       document.getElementById("node-panel").style.display = "block";
       document.getElementById("edge-panel").style.display = "none";
       document.getElementById("text-panel").style.display = "none";
       const toolbar = document.getElementById("topology-toolbar");
       if (!topologyToolbarCollapsed) {
        toolbar.style.display = "flex";
       }
       updateTopologyToolbarVisibility();
       document.getElementById("node-name").textContent = data.name;
       document.getElementById("node-ip").textContent = data.ip;
       document.getElementById("node-role").textContent = data.role;
       document.getElementById("node-mac").textContent = data.mac || "--";
       document.getElementById("node-rack").textContent = data.rackUnit || "--";
       document.getElementById("node-uheight").textContent = (data.uHeight || "1") + "U";
       document.getElementById("node-layer").value = data.layer || "physical";
       
       populateRackDropdown();
       const assignedRackSelect = document.getElementById("node-assigned-rack");
       if (assignedRackSelect) {
        assignedRackSelect.value = data.assignedRack || "";
       }
       
       const rackCapacitySelect = document.getElementById("node-rack-capacity");
       if (rackCapacitySelect) {
        rackCapacitySelect.value = data.rackCapacity || "42";
       }
       
       const isRack = data.isRack === true;
       const isAssignedToRack = !!data.assignedRack;
       const assignedRackRow = document.getElementById("assigned-rack-row");
       const rackCapacityRow = document.getElementById("rack-capacity-row");
       const uheightRow = document.getElementById("uheight-row");
       if (assignedRackRow) assignedRackRow.style.display = isRack ? "none" : "flex";
       if (rackCapacityRow) rackCapacityRow.style.display = isRack ? "flex" : "none";
       if (uheightRow) uheightRow.style.display = isAssignedToRack ? "flex" : "none";
       
       document.getElementById("node-name").onclick = () => editNodeName(id);
       document.getElementById("node-ip").onclick = () => editNodeIp(id);
       document.getElementById("node-mac").onclick = () => editNodeMac(id);
       document.getElementById("node-rack").onclick = () => editNodeRack(id);
       document.getElementById("node-uheight").onclick = () => editNodeUHeight(id);
       const currentSize = savedSizes[id] || getDefaultSize();
       document.getElementById("size-slider").value = currentSize;
       document.getElementById("size-value").textContent = currentSize;
       const styleEntry = savedStyles[id] || {};
       const resolvedStyles = resolveStylesEntry(styleEntry);
       const scopeKey = currentStyleScope || "all";
       const flatProps = ["circleColor", "circleBorder", "titleColor", "titleFont", "titleSize", "subColor", "subFont", "subSize", ];
       const isFlat = flatProps.some((p) => Object.prototype.hasOwnProperty.call(styleEntry, p), );
       const scopedStyles = isFlat ? styleEntry : styleEntry[scopeKey] || {};
       const circleColorInput = document.getElementById("circle-color");
       const titleColorInput = document.getElementById("title-color");
       const titleFontSelect = document.getElementById("title-font");
       const titleSizeInput = document.getElementById("title-size");
       const subColorInput = document.getElementById("sub-color");
       const subFontSelect = document.getElementById("sub-font");
       const subSizeInput = document.getElementById("sub-size");
       const shapeSelect = document.getElementById("shape-select");
       const scopeSelect = document.getElementById("style-scope");
       circleColorInput.value = scopedStyles.circleColor || resolvedStyles.circleColor || "#1e293b";
       const circleBorderInput = document.getElementById("circle-border");
       circleBorderInput.value = scopedStyles.circleBorder || resolvedStyles.circleBorder || "#475569";
       titleColorInput.value = scopedStyles.titleColor || resolvedStyles.titleColor || "#e2e8f0";
       titleFontSelect.value = scopedStyles.titleFont || resolvedStyles.titleFont || "system-ui, sans-serif";
       titleSizeInput.value = scopedStyles.titleSize || resolvedStyles.titleSize || 18;
       subColorInput.value = scopedStyles.subColor || resolvedStyles.subColor || "#94a3b8";
       subFontSelect.value = scopedStyles.subFont || resolvedStyles.subFont || "system-ui, sans-serif";
       subSizeInput.value = scopedStyles.subSize || resolvedStyles.subSize || 13;
       shapeSelect.value = data.shape || "circle";
       scopeSelect.value = currentStyleScope || "all";
       document.getElementById("title-offset-y").value = scopedStyles.titleOffsetY || resolvedStyles.titleOffsetY || 0;
       document.getElementById("title-offset-x").value = scopedStyles.titleOffsetX || resolvedStyles.titleOffsetX || 0;
       document.getElementById("sub-offset-y").value = scopedStyles.subOffsetY || resolvedStyles.subOffsetY || 0;
       document.getElementById("sub-offset-x").value = scopedStyles.subOffsetX || resolvedStyles.subOffsetX || 0;
       const tagEl = document.getElementById("node-tags");
       tagEl.innerHTML = "";
       data.tags.forEach((tag, i) => {
        const b = document.createElement("span");
        b.className = "badge";
        if (tag.toLowerCase().includes("wg")) b.classList.add("wg");
        b.style.cursor = "pointer";
        b.style.position = "relative";
        const tagText = document.createElement("span");
        tagText.textContent = tag;
        tagText.addEventListener("click", (e) => {
         e.stopPropagation();
         showEditModal("Edit Tag", tag, (newTag) => {
          if (newTag) {
           data.tags[i] = newTag;
           claimTheImmortal(id);
          }
         });
        });
        const deleteTag = document.createElement("span");
        deleteTag.textContent = " ‚úï";
        deleteTag.style.opacity = "0.6";
        deleteTag.style.marginLeft = "4px";
        deleteTag.style.fontSize = "10px";
        deleteTag.addEventListener("click", (e) => {
         e.stopPropagation();
         data.tags.splice(i, 1);
         claimTheImmortal(id);
        });
        b.append(tagText, deleteTag);
        tagEl.append(b);
       });
       const addTagBtn = document.createElement("span");
       addTagBtn.className = "badge";
       addTagBtn.style.cursor = "pointer";
       addTagBtn.style.opacity = "0.6";
       addTagBtn.style.borderStyle = "dashed";
       addTagBtn.textContent = "+ Add";
       addTagBtn.addEventListener("click", () => {
        showEditModal("Add Tag(s) : comma separated", "",
         (newTagStr) => {
          if (newTagStr) {
           const newTags = newTagStr.split(",").map((t) => t.trim()).filter((t) => t);
           newTags.forEach((t) => data.tags.push(t));
           claimTheImmortal(id);
          }
         }, );
       });
       tagEl.append(addTagBtn);
       const notesEl = document.getElementById("node-notes");
       notesEl.innerHTML = "";
       data.notes.forEach((note, i) => {
        const li = document.createElement("li");
        const noteText = document.createElement("span");
        noteText.textContent = note;
        noteText.style.flex = "1";
        const deleteBtn = document.createElement("span");
        deleteBtn.className = "delete-note";
        deleteBtn.textContent = "‚úï";
        deleteBtn.addEventListener("click", (e) => {
         e.stopPropagation();
         challengeTheImmortal("Are you sure you want to delete this note?",
          () => {
           data.notes.splice(i, 1);
           claimTheImmortal(id);
          }, );
        });
        li.append(noteText, deleteBtn);
        noteText.addEventListener("dblclick", () => {
         noteText.classList.add("editing");
         noteText.contentEditable = true;
         noteText.focus();
        });
        noteText.addEventListener("blur", () => {
         noteText.classList.remove("editing");
         noteText.contentEditable = false;
         data.notes[i] = noteText.textContent;
        });
        notesEl.append(li);
       });
      const addLineSelect = document.getElementById("add-line-select");
      addLineSelect.innerHTML = "";
      const currentRack = data.assignedRack || "";
      Object.entries(NODE_DATA).forEach(([nodeId, node]) => {
      if (nodeId !== id) {
      const nodeRack = node.assignedRack || "";
      if (currentRack === nodeRack) {
      const opt = document.createElement("option");
      opt.value = nodeId;
      opt.textContent = node.name;
      addLineSelect.appendChild(opt);
      }
      }
      });
      }
      
      function selectTheConnection(id) {
       currentEdgeId = id;
       
       if (isMobileDevice()) {
        const currentHeight = PAGE_STATE.mobileFooterHeight || 40;
        if (currentHeight <= 20) {
         PAGE_STATE.mobileFooterHeight = 80;
         const root = document.documentElement;
         root.style.setProperty("--mobile-footer-height", "80vh");
         const mobileFooterHeightInput = document.getElementById("mobile-footer-height");
         const mobileFooterHeightVal = document.getElementById("mobile-footer-height-val");
         if (mobileFooterHeightInput) mobileFooterHeightInput.value = 80;
         if (mobileFooterHeightVal) mobileFooterHeightVal.textContent = "80%";
        }
       }
       
       document.getElementById("node-panel").style.display = "none";
       document.getElementById("edge-panel").style.display = "block";
       document.getElementById("text-panel").style.display = "none";
       document.getElementById("topology-toolbar").style.display = "none";
       document.querySelectorAll(".node-group").forEach((n) => n.classList.remove("active"));
       document.querySelectorAll(".edge").forEach((e) => {
        e.classList.toggle("active", e.dataset.edgeId === id);
       });
       const edge = EDGE_DATA.list.find((e) => e.id === id);
       if (!edge) return;
       const directionSymbols = {
        none: "‚áÑ",
        forward: "‚Üí",
        backward: "‚Üê",
        both: "‚Üî",
       };
       const dirSymbol = directionSymbols[edge.direction] || "‚áÑ";
       let titleText = "Custom line";
       if (edge.from || edge.to) {
        const fromName = edge.from ? NODE_DATA[edge.from]?.name || edge.from : "";
        const toName = edge.to ? NODE_DATA[edge.to]?.name || edge.to : "";
        titleText = `${fromName || "?"} ${dirSymbol} ${toName || "?"}`;
       }
       document.getElementById("edge-title").textContent = titleText;
       const widthInput = document.getElementById("edge-width");
       const colorInput = document.getElementById("edge-color");
       const directionSelect = document.getElementById("edge-direction");
       const lineStyleSelect = document.getElementById("edge-line-style");
       widthInput.value = edge.width;
       colorInput.value = edge.color;
       directionSelect.value = edge.direction || "none";
       lineStyleSelect.value = edge.lineStyle || "solid";
       
       const fromPortRow = document.getElementById("edge-from-port-row");
       const toPortRow = document.getElementById("edge-to-port-row");
       const fromPortInput = document.getElementById("edge-from-port");
       const toPortInput = document.getElementById("edge-to-port");
       
       if (edge.type === "custom") {
        fromPortRow.style.display = "none";
        toPortRow.style.display = "none";
       } else {
        fromPortRow.style.display = "flex";
        toPortRow.style.display = "flex";
        fromPortInput.value = edge.fromPort || "";
        toPortInput.value = edge.toPort || "";
        
        fromPortInput.onchange = () => updateEdgePortLabels(id);
        toPortInput.onchange = () => updateEdgePortLabels(id);
       }
       
       const list = document.getElementById("edge-notes");
       list.innerHTML = "";
       edge.notes.forEach((note, i) => {
        const li = document.createElement("li");
        const txt = document.createElement("span");
        txt.textContent = note;
        txt.style.flex = "1";
        const del = document.createElement("span");
        del.className = "delete-note";
        del.textContent = "‚úï";
        del.addEventListener("click", (e) => {
         e.stopPropagation();
         challengeTheImmortal("Delete this line note?", () => {
          edge.notes.splice(i, 1);
          saveEdgeData();
          selectTheConnection(id);
         });
        });
        txt.addEventListener("dblclick", () => {
         txt.classList.add("editing");
         txt.contentEditable = true;
         txt.focus();
        });
        txt.addEventListener("blur", () => {
         txt.classList.remove("editing");
         txt.contentEditable = false;
         edge.notes[i] = txt.textContent;
         saveEdgeData();
        });
        li.append(txt, del);
        list.appendChild(li);
       });
      }
      window.addEventListener("resize", () => {
       forgeTheTopology();
       if (currentEdgeId) {
        selectTheConnection(currentEdgeId);
       } else if (currentNodeId && NODE_DATA[currentNodeId]) {
        claimTheImmortal(currentNodeId);
       } else {
        const availableNodes = Object.keys(NODE_DATA);
        if (availableNodes.length > 0) {
         claimTheImmortal(availableNodes[0]);
        }
       }
      });
      (function initZoomPan() {
       const viewport = document.getElementById("canvas-viewport");
       const svg = document.getElementById("map");
       const hint = document.getElementById("canvas-hint");
       setTimeout(() => {
        hint.classList.add("visible");
        setTimeout(() => hint.classList.remove("visible"), 4000);
       }, 1000);
       viewport.addEventListener("wheel",
        (e) => {
         e.preventDefault();
         const rect = viewport.getBoundingClientRect();
         const mouseX = (e.clientX - rect.left) / rect.width;
         const mouseY = (e.clientY - rect.top) / rect.height;
         const delta = e.deltaY > 0 ? 0.9 : 1.1;
         zoomTo(canvasState.zoom * delta, mouseX, mouseY);
        }, {
         passive: false
        }, );
       let initialPinchDistance = 0;
       let initialPinchZoom = 1;
       let pinchCenter = {
        x: 0.5,
        y: 0.5
       };
       viewport.addEventListener("touchstart",
        (e) => {
         if (e.touches.length === 2) {
          e.preventDefault();
          const touch1 = e.touches[0];
          const touch2 = e.touches[1];
          initialPinchDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY, );
          initialPinchZoom = canvasState.zoom;
          const rect = viewport.getBoundingClientRect();
          const centerX = (touch1.clientX + touch2.clientX) / 2;
          const centerY = (touch1.clientY + touch2.clientY) / 2;
          pinchCenter.x = (centerX - rect.left) / rect.width;
          pinchCenter.y = (centerY - rect.top) / rect.height;
         }
        }, {
         passive: false
        }, );
       viewport.addEventListener("touchmove",
        (e) => {
         if (e.touches.length === 2) {
          e.preventDefault();
          const touch1 = e.touches[0];
          const touch2 = e.touches[1];
          const currentDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY, );
          if (initialPinchDistance > 0) {
           const scale = currentDistance / initialPinchDistance;
           const newZoom = initialPinchZoom * scale;
           zoomTo(newZoom, pinchCenter.x, pinchCenter.y);
          }
         }
        }, {
         passive: false
        }, );
       let panStartViewX = 0;
       let panStartViewY = 0;
       
       let lastEmptyTapTime = 0;
       let emptyTapTimeout = null;
       let emptyTapMoved = false;
       
       viewport.addEventListener("touchend", (e) => {
         if (currentView.mode !== "rack") return;
         
         if (e.changedTouches.length !== 1) return;
         
         const isEmptySpace = e.target === svg || e.target === viewport || e.target.tagName === "svg";
         if (!isEmptySpace) return;
         
         if (emptyTapMoved) {
           emptyTapMoved = false;
           return;
         }
         
         const currentTime = new Date().getTime();
         const tapGap = currentTime - lastEmptyTapTime;
         
         if (tapGap < 300 && tapGap > 0) {
           e.preventDefault();
           
           exitRack();
           
           if (navigator.vibrate) {
             navigator.vibrate(50);
           }
           
           lastEmptyTapTime = 0;
           if (emptyTapTimeout) {
             clearTimeout(emptyTapTimeout);
             emptyTapTimeout = null;
           }
         } else {
           lastEmptyTapTime = currentTime;
           
           if (emptyTapTimeout) clearTimeout(emptyTapTimeout);
           emptyTapTimeout = setTimeout(() => {
             lastEmptyTapTime = 0;
           }, 300);
         }
       }, { passive: false });
       
       viewport.addEventListener("mousedown", (e) => {
        if (e.target.closest(".draw-toolbar") || e.target.closest(".topology-toolbar") || e.target.closest(".legend-container")) {
         return;
        }
      
        if (freeDrawMode || rectDrawMode) {
         return;
        }
        const isEmptySpace = e.target === svg || e.target === viewport || e.target.tagName === "svg";
        if (isEmptySpace || e.button === 2 || e.button === 1) {
         e.preventDefault();
         canvasState.isPanning = true;
         canvasState.panStartX = e.clientX;
         canvasState.panStartY = e.clientY;
         panStartViewX = canvasState.panX;
         panStartViewY = canvasState.panY;
         viewport.classList.add("panning");
        }
       });
       viewport.addEventListener("touchstart",
        (e) => {
         if (e.target.closest(".draw-toolbar") || e.target.closest(".topology-toolbar") || e.target.closest(".legend-container")) {
          return;
         }
      
         if (freeDrawMode || rectDrawMode) {
          return;
         }
         const isEmptySpace = e.target === svg || e.target === viewport || e.target.tagName === "svg";
         if (isEmptySpace && e.touches.length === 1) {
          e.preventDefault();
          emptyTapMoved = false;
          canvasState.isPanning = true;
          canvasState.panStartX = e.touches[0].clientX;
          canvasState.panStartY = e.touches[0].clientY;
          panStartViewX = canvasState.panX;
          panStartViewY = canvasState.panY;
          viewport.classList.add("panning");
         }
        }, {
         passive: false
        }, );
       document.addEventListener("mousemove", (e) => {
        if (!canvasState.isPanning) return;
        const dx = e.clientX - canvasState.panStartX;
        const dy = e.clientY - canvasState.panStartY;
        const rect = viewport.getBoundingClientRect();
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        const canvasDx = (dx / rect.width) * viewWidth;
        const canvasDy = (dy / rect.height) * viewHeight;
        canvasState.panX = panStartViewX - canvasDx;
        canvasState.panY = panStartViewY - canvasDy;
        constrainPan();
        updateViewBox();
       });
       document.addEventListener("touchmove", (e) => {
        if (!canvasState.isPanning || !e.touches[0]) return;
        emptyTapMoved = true; 
        const dx = e.touches[0].clientX - canvasState.panStartX;
        const dy = e.touches[0].clientY - canvasState.panStartY;
        const rect = viewport.getBoundingClientRect();
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        const canvasDx = (dx / rect.width) * viewWidth;
        const canvasDy = (dy / rect.height) * viewHeight;
        canvasState.panX = panStartViewX - canvasDx;
        canvasState.panY = panStartViewY - canvasDy;
        constrainPan();
        updateViewBox();
       });
       document.addEventListener("mouseup", () => {
        if (canvasState.isPanning) {
         canvasState.isPanning = false;
         viewport.classList.remove("panning");
        }
       });
       document.addEventListener("touchend", () => {
        if (canvasState.isPanning) {
         canvasState.isPanning = false;
         viewport.classList.remove("panning");
        }
       });
       document.addEventListener("keydown", (e) => {
        const isEditing = document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "TEXTAREA" || document.activeElement.isContentEditable;
        if (e.code === "Space" && !e.repeat && !isEditing) {
         e.preventDefault();
         canvasState.spacePressed = true;
         viewport.style.cursor = "grab";
        }
       });
       document.addEventListener("keyup", (e) => {
        if (e.code === "Space") {
         canvasState.spacePressed = false;
         viewport.style.cursor = "";
        }
       });
       document.getElementById("zoom-in-btn").addEventListener("click", () => {
        zoomTo(canvasState.zoom * 1.25, 0.5, 0.5);
       });
       document.getElementById("zoom-out-btn").addEventListener("click", () => {
        zoomTo(canvasState.zoom * 0.8, 0.5, 0.5);
       });
       document.getElementById("zoom-fit-btn").addEventListener("click", fitToContent);
       document.getElementById("zoom-reset-btn").addEventListener("click", resetView);
       const minimapContainer = document.getElementById("minimap-container");
       const minimapSvg = document.getElementById("minimap");
       let minimapDragging = false;
       minimapContainer.addEventListener("mousedown", (e) => {
        e.preventDefault();
        minimapDragging = true;
        updatePanFromMinimap(e);
       });
       minimapContainer.addEventListener("touchstart",
        (e) => {
         e.preventDefault();
         minimapDragging = true;
         updatePanFromMinimapTouch(e);
        }, {
         passive: false
        }, );
       document.addEventListener("mousemove", (e) => {
        if (minimapDragging) {
         updatePanFromMinimap(e);
        }
       });
       document.addEventListener("touchmove", (e) => {
        if (minimapDragging && e.touches[0]) {
         updatePanFromMinimapTouch(e);
        }
       });
       document.addEventListener("mouseup", () => {
        minimapDragging = false;
       });
       document.addEventListener("touchend", () => {
        minimapDragging = false;
       });
      
       function updatePanFromMinimap(e) {
        const rect = minimapContainer.getBoundingClientRect();
        const x = (e.clientX - rect.left) / rect.width;
        const y = (e.clientY - rect.top) / rect.height;
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        canvasState.panX = x * CANVAS_WIDTH - viewWidth / 2;
        canvasState.panY = y * CANVAS_HEIGHT - viewHeight / 2;
        constrainPan();
        updateViewBox();
       }
      
       function updatePanFromMinimapTouch(e) {
        const rect = minimapContainer.getBoundingClientRect();
        const touch = e.touches[0];
        const x = (touch.clientX - rect.left) / rect.width;
        const y = (touch.clientY - rect.top) / rect.height;
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        canvasState.panX = x * CANVAS_WIDTH - viewWidth / 2;
        canvasState.panY = y * CANVAS_HEIGHT - viewHeight / 2;
        constrainPan();
        updateViewBox();
       }
       document.addEventListener("keydown", (e) => {
        if (document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "TEXTAREA") return;
        if (
         (e.key === "+" || e.key === "=") && (e.ctrlKey || e.metaKey)) {
         e.preventDefault();
         zoomTo(canvasState.zoom * 1.25, 0.5, 0.5);
        } else if (e.key === "-" && (e.ctrlKey || e.metaKey)) {
         e.preventDefault();
         zoomTo(canvasState.zoom * 0.8, 0.5, 0.5);
        } else if (e.key === "0" && (e.ctrlKey || e.metaKey)) {
         e.preventDefault();
         resetView();
        }
       });
       setTimeout(() => {
        fitToContent();
       }, 100);
      })();
      const sizeSlider = document.getElementById("size-slider");
      const sizeValue = document.getElementById("size-value");
      const resetSizeBtn = document.getElementById("reset-size");
      sizeSlider.addEventListener("input", () => {
       const newSize = parseInt(sizeSlider.value, 10);
       sizeValue.textContent = newSize;
       savedSizes[currentNodeId] = newSize;
       const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
       if (nodeGroup) {
        const oldShape = nodeGroup.querySelector(".node-circle");
        if (oldShape) oldShape.remove();
        const shapeType = (NODE_DATA[currentNodeId] && NODE_DATA[currentNodeId].shape) || "circle";
        const newShape = createShapeElement(shapeType, newSize);
        newShape.classList.add("node-circle");
        const styles = resolveStylesForNode(currentNodeId);
        if (styles.circleColor) newShape.style.fill = styles.circleColor;
        if (styles.circleBorder) newShape.style.stroke = styles.circleBorder;
        nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
        const label = nodeGroup.querySelector(".node-label");
        const sub = nodeGroup.querySelector(".node-sub");
        if (label) {
         label.setAttribute("y", -newSize * 0.28);
         const labelSize = styles.titleSize || newSize * 0.33;
         label.style.fontSize = labelSize + "px";
        }
        if (sub) {
         sub.setAttribute("y", newSize * 0.4);
         const subSize = styles.subSize || newSize * 0.24;
         sub.style.fontSize = subSize + "px";
        }
       }
      });
      resetSizeBtn.addEventListener("click", () => {
       delete savedSizes[currentNodeId];
       const defaultSize = getDefaultSize();
       sizeSlider.value = defaultSize;
       sizeValue.textContent = defaultSize;
       const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
       if (nodeGroup) {
        const oldShape = nodeGroup.querySelector(".node-circle");
        if (oldShape) oldShape.remove();
        const shapeType = (NODE_DATA[currentNodeId] && NODE_DATA[currentNodeId].shape) || "circle";
        const newShape = createNodeShape(currentNodeId, defaultSize);
        nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
        const styles = resolveStylesForNode(currentNodeId);
        if (styles.circleColor) newShape.style.fill = styles.circleColor;
        if (styles.circleBorder) newShape.style.stroke = styles.circleBorder;
        const label = nodeGroup.querySelector(".node-label");
        const sub = nodeGroup.querySelector(".node-sub");
        if (label) {
         label.setAttribute("y", -defaultSize * 0.28);
         const labelSize = styles.titleSize || defaultSize * 0.33;
         label.style.fontSize = labelSize + "px";
        }
        if (sub) {
         sub.setAttribute("y", defaultSize * 0.4);
         const subSize = styles.subSize || defaultSize * 0.24;
         sub.style.fontSize = subSize + "px";
        }
       }
      });
      const applyStyle = (property, value) => {
       const styleEntry = ensureStyleEntry(currentNodeId);
       const scopeKey = currentStyleScope || "all";
       if (!styleEntry[scopeKey]) styleEntry[scopeKey] = {};
       styleEntry[scopeKey][property] = value;
       const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
       if (!nodeGroup) return;
       const shapeEl = nodeGroup.querySelector(".node-circle");
       const label = nodeGroup.querySelector(".node-label");
       const sub = nodeGroup.querySelector(".node-sub");
       if (property === "circleColor" && shapeEl) shapeEl.style.fill = value;
	   else if (property === "circleBorder" && shapeEl) shapeEl.style.stroke = value;
       else if (property === "titleColor" && label) label.style.fill = value;
       else if (property === "titleFont" && label) label.style.fontFamily = value;
       else if (property === "titleSize" && label) label.style.fontSize = value + "px";
       else if (property === "subColor" && sub) sub.style.fill = value;
       else if (property === "subFont" && sub) sub.style.fontFamily = value;
       else if (property === "subSize" && sub) sub.style.fontSize = value + "px";
      };
      document.getElementById("circle-color").addEventListener("input", (e) => applyStyle("circleColor", e.target.value), );
      document.getElementById("circle-border").addEventListener("input", (e) => applyStyle("circleBorder", e.target.value), );
      document.getElementById("title-color").addEventListener("input", (e) => applyStyle("titleColor", e.target.value), );
      document.getElementById("title-font").addEventListener("change", (e) => applyStyle("titleFont", e.target.value), );
      document.getElementById("title-size").addEventListener("input", (e) => applyStyle("titleSize", parseInt(e.target.value, 10)), );
      document.getElementById("sub-color").addEventListener("input", (e) => applyStyle("subColor", e.target.value), );
      document.getElementById("sub-font").addEventListener("change", (e) => applyStyle("subFont", e.target.value), );
      document.getElementById("sub-size").addEventListener("input", (e) => applyStyle("subSize", parseInt(e.target.value, 10)), );
      document.getElementById("title-offset-y").addEventListener("input", (e) => {
       applyStyle("titleOffsetY", parseInt(e.target.value, 10) || 0);
       forgeTheTopology();
       if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      document.getElementById("title-offset-x").addEventListener("input", (e) => {
       applyStyle("titleOffsetX", parseInt(e.target.value, 10) || 0);
       forgeTheTopology();
       if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      document.getElementById("sub-offset-y").addEventListener("input", (e) => {
       applyStyle("subOffsetY", parseInt(e.target.value, 10) || 0);
       forgeTheTopology();
       if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      document.getElementById("sub-offset-x").addEventListener("input", (e) => {
       applyStyle("subOffsetX", parseInt(e.target.value, 10) || 0);
       forgeTheTopology();
       if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      document.getElementById("reset-styles").addEventListener("click", () => {
       delete savedStyles[currentNodeId];
       forgeTheTopology();
       claimTheImmortal(currentNodeId);
      });
      document.getElementById("style-scope").addEventListener("change", (e) => {
       currentStyleScope = e.target.value || "all";
       claimTheImmortal(currentNodeId);
      });
      document.getElementById("shape-select").addEventListener("change", (e) => {
       const shape = e.target.value || "circle";
       NODE_DATA[currentNodeId].shape = shape;
       const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
       if (!nodeGroup) return;
       const oldShape = nodeGroup.querySelector(".node-circle");
       if (oldShape) oldShape.remove();
       const size = savedSizes[currentNodeId] || getDefaultSize();
       const newShape = createNodeShape(currentNodeId, size);
       nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
      });
      const addNoteBtn = document.getElementById("add-note-btn");
      const noteInput = document.getElementById("new-note-input");
      addNoteBtn.addEventListener("click", () => {
       const newNote = noteInput.value.trim();
       if (newNote && currentNodeId) {
        NODE_DATA[currentNodeId].notes.push(newNote);
        claimTheImmortal(currentNodeId);
        noteInput.value = "";
       }
      });
      noteInput.addEventListener("keypress", (e) => {
       if (e.key === "Enter") {
        addNoteBtn.click();
       }
      });
      document.getElementById("edge-width").addEventListener("input", () => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       const v = parseInt(document.getElementById("edge-width").value, 10);
       if (Number.isNaN(v) || v <= 0) return;
       edge.width = v;
       saveEdgeData();
       const el = document.querySelector(`.edge[data-edge-id="${currentEdgeId}"]`, );
       if (el) el.style.strokeWidth = v;
      });
      document.getElementById("edge-color").addEventListener("input", () => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       const color = document.getElementById("edge-color").value;
       edge.color = color;
       saveEdgeData();
       const el = document.querySelector(`.edge[data-edge-id="${currentEdgeId}"]`, );
       if (el) el.style.stroke = color;
       forgeTheLegend();
      });
      document.getElementById("edge-direction").addEventListener("change", () => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       edge.direction = document.getElementById("edge-direction").value;
       saveEdgeData();
       forgeTheTopology();
       selectTheConnection(currentEdgeId);
      });
      document.getElementById("edge-line-style").addEventListener("change", () => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       edge.lineStyle = document.getElementById("edge-line-style").value;
       saveEdgeData();
       forgeTheTopology();
       selectTheConnection(currentEdgeId);
      });
      const addEdgeNoteBtn = document.getElementById("add-edge-note");
      const newEdgeNoteInput = document.getElementById("new-edge-note");
      addEdgeNoteBtn.addEventListener("click", () => {
       const txt = newEdgeNoteInput.value.trim();
       if (!txt || !currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       edge.notes.push(txt);
       saveEdgeData();
       newEdgeNoteInput.value = "";
       selectTheConnection(currentEdgeId);
      });
      newEdgeNoteInput.addEventListener("keypress", (e) => {
       if (e.key === "Enter") {
        addEdgeNoteBtn.click();
       }
      });
      document.getElementById("delete-edge").addEventListener("click", () => {
       if (!currentEdgeId) return;
       challengeTheImmortal("Are you sure you want to delete this line?",
        () => {
         EDGE_DATA.list = EDGE_DATA.list.filter(
          (e) => e.id !== currentEdgeId, );
         saveEdgeData();
         currentEdgeId = null;
         forgeTheTopology();
         const availableNodes = Object.keys(NODE_DATA);
         if (availableNodes.length > 0) {
          claimTheImmortal(availableNodes[0]);
         } else {
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("topology-toolbar", ).style.display = "none";
         }
        }, );
      });
      document.getElementById("add-line-btn").addEventListener("click", () => {
       if (!currentNodeId) return;
       const select = document.getElementById("add-line-select");
       const directionSelect = document.getElementById("add-line-direction");
       const colorInput = document.getElementById("add-line-color");
       const targetId = select.value;
       if (!targetId || targetId === currentNodeId) return;
       const direction = directionSelect.value || "none";
       const lineColor = colorInput.value || "#475569";
       const newId = `${currentNodeId}-${targetId}-${Date.now()}`;
       const newEdge = {
        id: newId,
        from: currentNodeId,
        to: targetId,
        width: 4,
        color: lineColor,
        direction: direction,
        type: "main",
        notes: [],
        fromPort: "",
        toPort: "",
        lineStyle: "solid",
       };
       EDGE_DATA.list.push(newEdge);
       saveEdgeData();
       forgeTheTopology();
       claimTheImmortal(currentNodeId);
      });
      let freeDrawMode = false;
      let freeDrawPoints = [];
      let freeDrawPolylineEl = null;
      let freeDrawPointEls = [];
       let rectDrawMode = false;
       let currentTextId = null;
       let rectStartPoint = null;
       let rectPreviewEl = null;
       let rectStyle = "filled";
      const drawToggleBtn = document.getElementById("draw-toggle");
      const drawUndoBtn = document.getElementById("draw-undo");
      const drawColorInput = document.getElementById("draw-color");
      const drawStyleSelect = document.getElementById("draw-style");
      const drawArrowSelect = document.getElementById("draw-arrow");
      const svgMap = document.getElementById("map");
      
      function updateFreeDrawGraphics() {
       const ns = "http://www.w3.org/2000/svg";
       const svg = svgMap;
       if (!freeDrawPolylineEl && freeDrawPoints.length > 0) {
        freeDrawPolylineEl = document.createElementNS(ns, "polyline");
        freeDrawPolylineEl.classList.add("edge", "free-preview");
        freeDrawPolylineEl.setAttribute("fill", "none");
        svg.appendChild(freeDrawPolylineEl);
       }
       if (freeDrawPolylineEl) {
        if (freeDrawPoints.length === 0) {
         freeDrawPolylineEl.remove();
         freeDrawPolylineEl = null;
        } else {
         const ptsStr = freeDrawPoints.map((p) => `${p.x},${p.y}`).join(" ");
         freeDrawPolylineEl.setAttribute("points", ptsStr);
         freeDrawPolylineEl.style.stroke = drawColorInput.value || "#475569";
         freeDrawPolylineEl.style.strokeWidth = 3;
         const lineStyle = drawStyleSelect.value || "solid";
         if (lineStyle === "dashed") {
          freeDrawPolylineEl.style.strokeDasharray = "10,5";
         } else if (lineStyle === "dotted") {
          freeDrawPolylineEl.style.strokeDasharray = "2,4";
         } else {
          freeDrawPolylineEl.style.strokeDasharray = "none";
         }
        }
       }
       freeDrawPointEls.forEach((el) => el.remove());
       freeDrawPointEls = [];
       freeDrawPoints.forEach((p, idx) => {
        const c = document.createElementNS(ns, "circle");
        c.classList.add("free-point");
        c.setAttribute("cx", p.x);
        c.setAttribute("cy", p.y);
        c.setAttribute("r", 5);
        c.dataset.index = String(idx);
        c.addEventListener("mousedown", (e) => {
         if (!freeDrawMode) return;
         e.preventDefault();
         e.stopPropagation();
         let dragging = true;
         const svgEl = svgMap;
         const moveHandler = (ev) => {
          if (!dragging) return;
          const pt = svgEl.createSVGPoint();
          pt.x = ev.clientX;
          pt.y = ev.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          const i = parseInt(c.dataset.index, 10);
          if (Number.isNaN(i) || !freeDrawPoints[i]) return;
          freeDrawPoints[i].x = svgP.x;
          freeDrawPoints[i].y = svgP.y;
          updateFreeDrawGraphics();
         };
         const upHandler = () => {
          dragging = false;
          document.removeEventListener("mousemove", moveHandler);
          document.removeEventListener("mouseup", upHandler);
         };
         document.addEventListener("mousemove", moveHandler);
         document.addEventListener("mouseup", upHandler);
        });
        c.addEventListener("touchstart",
         (e) => {
          if (!freeDrawMode) return;
          e.preventDefault();
          e.stopPropagation();
          let dragging = true;
          const svgEl = svgMap;
          const touchMoveHandler = (ev) => {
           if (!dragging || !ev.touches[0]) return;
           const pt = svgEl.createSVGPoint();
           pt.x = ev.touches[0].clientX;
           pt.y = ev.touches[0].clientY;
           const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
           const i = parseInt(c.dataset.index, 10);
           if (Number.isNaN(i) || !freeDrawPoints[i]) return;
           freeDrawPoints[i].x = svgP.x;
           freeDrawPoints[i].y = svgP.y;
           updateFreeDrawGraphics();
          };
          const touchUpHandler = () => {
           dragging = false;
           document.removeEventListener("touchmove", touchMoveHandler, );
           document.removeEventListener("touchend", touchUpHandler, );
          };
          document.addEventListener("touchmove", touchMoveHandler);
          document.addEventListener("touchend", touchUpHandler);
         }, {
          passive: false
         }, );
        svg.appendChild(c);
        freeDrawPointEls.push(c);
       });
       drawUndoBtn.style.display = freeDrawPoints.length ? "inline-block" : "none";
      }
      
      function addFreeDrawPoint(x, y) {
       freeDrawPoints.push({
        x,
        y
       });
       updateFreeDrawGraphics();
      }
      
      function startFreeDraw() {
       freeDrawMode = true;
       freeDrawPoints = [];
       if (freeDrawPolylineEl) {
        freeDrawPolylineEl.remove();
        freeDrawPolylineEl = null;
       }
       freeDrawPointEls.forEach((el) => el.remove());
       freeDrawPointEls = [];
       svgMap.style.cursor = "crosshair";
       drawToggleBtn.textContent = "Done";
       drawUndoBtn.style.display = "none";
      }
      
      function finishFreeDraw() {
       freeDrawMode = false;
       svgMap.style.cursor = "";
       drawToggleBtn.textContent = "‚úèÔ∏è";
       if (freeDrawPoints.length >= 2) {
        const color = drawColorInput.value || "#475569";
        const lineStyle = drawStyleSelect.value || "solid";
        const arrowDir = drawArrowSelect.value || "none";
        const newId = "custom-" + Date.now();
        const pointsCopy = freeDrawPoints.map((p) => ({
         x: p.x,
         y: p.y,
        }));
        EDGE_DATA.list.push({
         id: newId,
         type: "custom",
         color,
         width: 4,
         lineStyle: lineStyle,
         direction: arrowDir,
         points: pointsCopy,
         notes: [],
        });
        saveEdgeData();
        freeDrawPoints = [];
        if (freeDrawPolylineEl) {
         freeDrawPolylineEl.remove();
         freeDrawPolylineEl = null;
        }
        freeDrawPointEls.forEach((el) => el.remove());
        freeDrawPointEls = [];
        forgeTheTopology();
        selectTheConnection(newId);
       } else {
        freeDrawPoints = [];
        if (freeDrawPolylineEl) {
         freeDrawPolylineEl.remove();
         freeDrawPolylineEl = null;
        }
        freeDrawPointEls.forEach((el) => el.remove());
        freeDrawPointEls = [];
        forgeTheLegend();
       }
       drawUndoBtn.style.display = "none";
      }
      drawToggleBtn.addEventListener("click", () => {
       if (currentView.mode === "rack") {
        alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
        return;
       }
       
       if (freeDrawMode) {
        finishFreeDraw();
       } else {
        startFreeDraw();
       }
      });
      drawUndoBtn.addEventListener("click", () => {
       if (!freeDrawMode || !freeDrawPoints.length) return;
       freeDrawPoints.pop();
       updateFreeDrawGraphics();
      });
      const drawToolbar = document.getElementById("draw-toolbar");
      drawToolbar.addEventListener("mousedown", (e) => {
       e.stopPropagation();
      });
      drawToolbar.addEventListener("click", (e) => {
       if (e.target !== drawToggleBtn && e.target !== drawUndoBtn) {
        e.stopPropagation();
       }
      });
      drawStyleSelect.addEventListener("change", () => {
       if (freeDrawMode) {
        updateFreeDrawGraphics();
       }
      });
      drawArrowSelect.addEventListener("change", () => {
       if (freeDrawMode) {
        updateFreeDrawGraphics();
       }
      });
      drawColorInput.addEventListener("input", () => {
       if (freeDrawMode) {
        updateFreeDrawGraphics();
       }
      });
      drawStyleSelect.addEventListener("mousedown", (e) => {
       e.stopPropagation();
      });
      drawStyleSelect.addEventListener("click", (e) => {
       e.stopPropagation();
      });
      drawArrowSelect.addEventListener("mousedown", (e) => {
       e.stopPropagation();
      });
      drawArrowSelect.addEventListener("click", (e) => {
       e.stopPropagation();
      });
      drawColorInput.addEventListener("mousedown", (e) => {
       e.stopPropagation();
      });
      drawColorInput.addEventListener("click", (e) => {
       e.stopPropagation();
      });
      
      svgMap.addEventListener("click", (e) => {
       if (!freeDrawMode) return;
       if (e.button !== 0) return;
       const target = e.target;
       if (target && target.classList && target.classList.contains("free-point")) return;
       const svgEl = svgMap;
       const pt = svgEl.createSVGPoint();
       pt.x = e.clientX;
       pt.y = e.clientY;
       const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
       addFreeDrawPoint(svgP.x, svgP.y);
      });
      svgMap.addEventListener("touchend",
       (e) => {
        if (!freeDrawMode) return;
        const target = e.target;
        if (target && target.classList && target.classList.contains("free-point")) return;
        if (e.changedTouches && e.changedTouches[0]) {
         e.preventDefault();
         const svgEl = svgMap;
         const pt = svgEl.createSVGPoint();
         pt.x = e.changedTouches[0].clientX;
         pt.y = e.changedTouches[0].clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
         addFreeDrawPoint(svgP.x, svgP.y);
        }
       }, {
        passive: false
       }, );
      
       const rectToggleBtn = document.getElementById("rect-toggle");
       const rectStyleSelect = document.getElementById("rect-style");
      
       function startRectDraw() {
        rectDrawMode = true;
        rectStartPoint = null;
        rectPreviewEl = null;
        svgMap.style.cursor = "crosshair";
        rectToggleBtn.textContent = "Done";
        rectStyle = rectStyleSelect.value || "filled";
        
        if (freeDrawMode) {
         finishFreeDraw();
        }
        updateRectangleDeleteButtons();
       }
      
       function finishRectDraw() {
        rectDrawMode = false;
        svgMap.style.cursor = "";
        rectToggleBtn.textContent = "‚ñ≠";
        
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
        updateRectangleDeleteButtons();
       }
      
       rectToggleBtn.addEventListener("click", () => {
        if (currentView.mode === "rack") {
         alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
         return;
        }
        
        if (rectDrawMode) {
         finishRectDraw();
        } else {
         startRectDraw();
        }
       });
      
       rectStyleSelect.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       rectStyleSelect.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       rectStyleSelect.addEventListener("change", () => {
        if (rectDrawMode) {
         rectStyle = rectStyleSelect.value || "filled";
        }
       });
      
       svgMap.addEventListener("mousedown", (e) => {
        if (!rectDrawMode) return;
        if (e.button !== 0) return;
        e.preventDefault();
        e.stopPropagation();
        
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        rectStartPoint = { x: svgP.x, y: svgP.y };
        
        const ns = "http://www.w3.org/2000/svg";
        rectPreviewEl = document.createElementNS(ns, "rect");
        rectPreviewEl.classList.add("rect-preview");
        rectPreviewEl.setAttribute("x", svgP.x);
        rectPreviewEl.setAttribute("y", svgP.y);
        rectPreviewEl.setAttribute("width", 0);
        rectPreviewEl.setAttribute("height", 0);
        
        const color = drawColorInput.value || "#f97316";
        rectPreviewEl.style.stroke = color;
        rectPreviewEl.style.strokeWidth = 2;
        rectPreviewEl.style.strokeDasharray = "5,5";
        
        if (rectStyle === "filled") {
         rectPreviewEl.style.fill = color;
         rectPreviewEl.style.fillOpacity = "0.3";
        } else {
         rectPreviewEl.style.fill = "none";
        }
        
        svgEl.appendChild(rectPreviewEl);
       });
      
       svgMap.addEventListener("mousemove", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        
        rectPreviewEl.setAttribute("x", x);
        rectPreviewEl.setAttribute("y", y);
        rectPreviewEl.setAttribute("width", width);
        rectPreviewEl.setAttribute("height", height);
       });
      
       svgMap.addEventListener("mouseup", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        
        if (width > 10 && height > 10) {
      pushUndo("draw rectangle");
         const color = drawColorInput.value || "#f97316";
         const newId = "rect-" + Date.now();
         
         RECT_DATA.list.push({
          id: newId,
          x: x,
          y: y,
          width: width,
          height: height,
          color: color,
          style: rectStyle,
          notes: []
         });
         
         forgeTheTopology();
        }
        
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
       });
      
       let rectTouchStart = null;
       
       svgMap.addEventListener("touchstart", (e) => {
        if (!rectDrawMode) return;
        if (e.touches.length !== 1) return;
        
        e.preventDefault();
        const touch = e.touches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        rectStartPoint = { x: svgP.x, y: svgP.y };
        rectTouchStart = { x: svgP.x, y: svgP.y };
        
        const ns = "http://www.w3.org/2000/svg";
        rectPreviewEl = document.createElementNS(ns, "rect");
        rectPreviewEl.classList.add("rect-preview");
        rectPreviewEl.setAttribute("x", svgP.x);
        rectPreviewEl.setAttribute("y", svgP.y);
        rectPreviewEl.setAttribute("width", 0);
        rectPreviewEl.setAttribute("height", 0);
        
        const color = drawColorInput.value || "#f97316";
        rectPreviewEl.style.stroke = color;
        rectPreviewEl.style.strokeWidth = 2;
        rectPreviewEl.style.strokeDasharray = "5,5";
        
        if (rectStyle === "filled") {
         rectPreviewEl.style.fill = color;
         rectPreviewEl.style.fillOpacity = "0.3";
        } else {
         rectPreviewEl.style.fill = "none";
        }
        
        svgEl.appendChild(rectPreviewEl);
       }, { passive: false });
      
       svgMap.addEventListener("touchmove", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        if (e.touches.length !== 1) return;
        
        e.preventDefault();
        const touch = e.touches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        
        rectPreviewEl.setAttribute("x", x);
        rectPreviewEl.setAttribute("y", y);
        rectPreviewEl.setAttribute("width", width);
        rectPreviewEl.setAttribute("height", height);
       }, { passive: false });
      
       svgMap.addEventListener("touchend", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        if (!rectTouchStart) return;
        
        e.preventDefault();
        const touch = e.changedTouches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        
        if (width > 10 && height > 10) {
      pushUndo("draw rectangle");
         const color = drawColorInput.value || "#f97316";
         const newId = "rect-" + Date.now();
         
         RECT_DATA.list.push({
          id: newId,
          x: x,
          y: y,
          width: width,
          height: height,
          color: color,
          style: rectStyle,
          notes: []
         });
         
         forgeTheTopology();
        }
        
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
        rectTouchStart = null;
       }, { passive: false });
      
      const textToggleBtn = document.getElementById("text-toggle");
      
      function startTextMode() {
       textDrawMode = true;
       svgMap.style.cursor = "crosshair";
       textToggleBtn.textContent = "Done";
       textToggleBtn.style.background = "var(--accent)";
       textToggleBtn.style.color = "var(--bg)";
       
       if (freeDrawMode) {
        finishFreeDraw();
       }
       if (rectDrawMode) {
        finishRectDraw();
       }
       
       updateTextDeleteButtons();
      }
      
      function finishTextMode() {
       textDrawMode = false;
       svgMap.style.cursor = "";
       textToggleBtn.textContent = "T";
       textToggleBtn.style.background = "";
       textToggleBtn.style.color = "";
       updateTextDeleteButtons();
      }
      
      textToggleBtn.addEventListener("click", () => {
       if (currentView.mode === "rack") {
        alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
        return;
       }
       
       if (textDrawMode) {
        finishTextMode();
       } else {
        startTextMode();
       }
      });
      
      function handleTextPlacement(e) {
       if (!textDrawMode) return;
       
       const svgEl = svgMap;
       const pt = svgEl.createSVGPoint();
       pt.x = e.clientX;
       pt.y = e.clientY;
       const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
       
       const newId = "text-" + Date.now();
      pushUndo("add text");
       TEXT_DATA.list.push({
        id: newId,
        x: svgP.x,
        y: svgP.y,
        content: "New Text",
        fontSize: 18,
        color: "#e2e8f0",
        fontWeight: "normal",
        fontStyle: "normal",
        textAlign: "start",
        textDecoration: "none",
        bgColor: "#000000",
        bgEnabled: false,
        opacity: 1
       });
       
       forgeTheTopology();
       
       showTextPanel(newId);
      }
      
      svgMap.addEventListener("click", (e) => {
       if (!textDrawMode) return;
       if (e.target.closest('.text-delete-btn')) return;
       if (e.target.closest('.text-group')) return;
       
       e.preventDefault();
       e.stopPropagation();
       handleTextPlacement(e);
      });
      
      svgMap.addEventListener("touchend", (e) => {
       if (!textDrawMode) return;
       if (e.target.closest('.text-delete-btn')) return;
       if (e.target.closest('.text-group')) return;
       if (e.touches.length > 0) return;
       
       e.preventDefault();
       const touch = e.changedTouches[0];
       const fakeEvent = {
        clientX: touch.clientX,
        clientY: touch.clientY,
        preventDefault: () => {},
        stopPropagation: () => {}
       };
       handleTextPlacement(fakeEvent);
      }, { passive: false });
      
      function showTextPanel(textId) {
       currentTextId = textId;
       const textItem = TEXT_DATA.list.find(t => t.id === textId);
       if (!textItem) return;
       
       document.getElementById("node-panel").style.display = "none";
       document.getElementById("edge-panel").style.display = "none";
       
       const textPanel = document.getElementById("text-panel");
       textPanel.style.display = "block";
       
       document.getElementById("text-content").value = textItem.content;
       document.getElementById("text-font-size").value = textItem.fontSize;
       document.getElementById("text-color").value = textItem.color;
       document.getElementById("text-font-weight").value = textItem.fontWeight;
       document.getElementById("text-font-style").value = textItem.fontStyle;
       document.getElementById("text-align").value = textItem.textAlign;
       document.getElementById("text-decoration").value = textItem.textDecoration;
       document.getElementById("text-bg-color").value = textItem.bgColor;
       document.getElementById("text-bg-enabled").checked = textItem.bgEnabled;
       document.getElementById("text-opacity").value = textItem.opacity;
       document.getElementById("text-opacity-val").textContent = Math.round(textItem.opacity * 100) + "%";
      }
      
      function updateTextDeleteButtons() {
       const deleteButtons = document.querySelectorAll('.text-delete-btn');
       deleteButtons.forEach(btn => {
        btn.style.display = textDrawMode ? 'block' : 'none';
       });
      }
      
      function deleteText(textId) {
      pushUndo("delete text");
       TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== textId);
       forgeTheTopology();
       
       if (currentTextId === textId) {
        document.getElementById("text-panel").style.display = "none";
        currentTextId = null;
       }
      }
      
      document.getElementById("text-content").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
      pushUndo("edit text");
        textItem.content = e.target.value;
        forgeTheTopology();
       }
      });
      
      document.getElementById("text-font-size").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        textItem.fontSize = parseInt(e.target.value);
        forgeTheTopology();
       }
      });
      
      document.getElementById("text-color").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        textItem.color = e.target.value;
        forgeTheTopology();
       }
      });
      
      document.getElementById("text-font-weight").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        textItem.fontWeight = e.target.value;
        forgeTheTopology();
       }
      });
      
      document.getElementById("text-font-style").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        textItem.fontStyle = e.target.value;
        forgeTheTopology();
       }
      });
      
      document.getElementById("text-align").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        textItem.textAlign = e.target.value;
        forgeTheTopology();
       }
      });
      
      document.getElementById("text-decoration").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        textItem.textDecoration = e.target.value;
        forgeTheTopology();
       }
      });
      
      document.getElementById("text-bg-color").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        textItem.bgColor = e.target.value;
        forgeTheTopology();
       }
      });
      
      document.getElementById("text-bg-enabled").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        textItem.bgEnabled = e.target.checked;
        forgeTheTopology();
       }
      });
      
      document.getElementById("text-opacity").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        textItem.opacity = parseFloat(e.target.value);
        document.getElementById("text-opacity-val").textContent = Math.round(textItem.opacity * 100) + "%";
        forgeTheTopology();
       }
      });
      
      document.getElementById("delete-text").addEventListener("click", () => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        challengeTheImmortal(`Delete text "${textItem.content.substring(0, 30)}..."?`, () => {
         deleteText(currentTextId);
        });
       }
      });
      
      const settingsBtn = document.getElementById("settings-btn");
      const settingsModal = document.getElementById("settings-modal");
      const settingsClose = document.getElementById("settings-close");
      settingsBtn.addEventListener("click", () => {
       document.getElementById("page-bg-color").value = PAGE_STATE.background || "#050608";
       document.getElementById("topbar-bg-color").value = PAGE_STATE.topbarBg || "#0b0e13";
       document.getElementById("topbar-border-color").value = PAGE_STATE.topbarBorder || "#1f2533";
       document.getElementById("panel-color").value = PAGE_STATE.panel || "#0b0e13";
       document.getElementById("panel-alt-color").value = PAGE_STATE.panelAlt || "#10141b";
       document.getElementById("accent-color").value = PAGE_STATE.accent || "#4fd1c5";
       document.getElementById("danger-color").value = PAGE_STATE.danger || "#f56565";
       document.getElementById("text-main-color").value = PAGE_STATE.textMain || "#e2e8f0";
       document.getElementById("text-soft-color").value = PAGE_STATE.textSoft || "#94a3b8";
       settingsModal.classList.add("active");
      });
      settingsClose.addEventListener("click", () => {
       settingsModal.classList.remove("active");
      });
      settingsModal.addEventListener("click", (e) => {
       if (e.target === settingsModal) {
        settingsModal.classList.remove("active");
       }
      });
      document.getElementById("page-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.background = e.target.value;
       wieldThePower();
      });
      document.getElementById("topbar-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.topbarBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("topbar-border-color").addEventListener("input", (e) => {
       PAGE_STATE.topbarBorder = e.target.value;
       wieldThePower();
      });
      document.getElementById("panel-color").addEventListener("input", (e) => {
       PAGE_STATE.panel = e.target.value;
       wieldThePower();
      });
      document.getElementById("panel-alt-color").addEventListener("input", (e) => {
       PAGE_STATE.panelAlt = e.target.value;
       wieldThePower();
      });
      document.getElementById("accent-color").addEventListener("input", (e) => {
       PAGE_STATE.accent = e.target.value;
       wieldThePower();
      });
      document.getElementById("danger-color").addEventListener("input", (e) => {
       PAGE_STATE.danger = e.target.value;
       wieldThePower();
      });
      document.getElementById("text-main-color").addEventListener("input", (e) => {
       PAGE_STATE.textMain = e.target.value;
       wieldThePower();
      });
      document.getElementById("text-soft-color").addEventListener("input", (e) => {
       PAGE_STATE.textSoft = e.target.value;
       wieldThePower();
      });
      
      (function initializeResizers() {
        const headerResizer = document.getElementById('header-resizer');
        const sidebarResizer = document.getElementById('sidebar-resizer');
        const mobileFooterResizer = document.getElementById('mobile-footer-resizer');
        
        let isResizing = false;
        let currentResizer = null;
        let startY = 0;
        let startX = 0;
        let startHeight = 0;
        let startWidth = 0;
        
        function getClientPos(e) {
          if (e.touches && e.touches.length > 0) {
            return { x: e.touches[0].clientX, y: e.touches[0].clientY };
          }
          return { x: e.clientX, y: e.clientY };
        }
        
        function startResize(resizer, type, e) {
          isResizing = true;
          currentResizer = type;
          const pos = getClientPos(e);
          
          if (type === 'header') {
            startY = pos.y;
            startHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--topbar-height'));
          } else if (type === 'sidebar') {
            startX = pos.x;
            startWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width'));
          } else if (type === 'mobile-footer') {
            startY = pos.y;
            const currentVh = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--mobile-footer-height'));
            startHeight = (currentVh / 100) * window.innerHeight;
          }
          
          resizer.classList.add('resizing');
          document.body.classList.add('resizing');
          document.body.style.cursor = (type === 'sidebar') ? 'col-resize' : 'row-resize';
          e.preventDefault();
        }
        
        if (headerResizer) {
          headerResizer.addEventListener('mousedown', (e) => startResize(headerResizer, 'header', e));
          headerResizer.addEventListener('touchstart', (e) => startResize(headerResizer, 'header', e), { passive: false });
        }
        
        if (sidebarResizer) {
          sidebarResizer.addEventListener('mousedown', (e) => startResize(sidebarResizer, 'sidebar', e));
          sidebarResizer.addEventListener('touchstart', (e) => startResize(sidebarResizer, 'sidebar', e), { passive: false });
        }
        
        if (mobileFooterResizer) {
          mobileFooterResizer.addEventListener('mousedown', (e) => startResize(mobileFooterResizer, 'mobile-footer', e));
          mobileFooterResizer.addEventListener('touchstart', (e) => startResize(mobileFooterResizer, 'mobile-footer', e), { passive: false });
        }
        
        function handleMove(e) {
          if (!isResizing) return;
          
          const pos = getClientPos(e);
          
          if (currentResizer === 'header') {
            const deltaY = pos.y - startY;
            const newHeight = Math.max(40, Math.min(150, startHeight + deltaY));
            document.documentElement.style.setProperty('--topbar-height', newHeight + 'px');
          } else if (currentResizer === 'sidebar') {
            const deltaX = startX - pos.x;
            const newWidth = Math.max(200, Math.min(800, startWidth + deltaX));
            document.documentElement.style.setProperty('--sidebar-width', newWidth + 'px');
          } else if (currentResizer === 'mobile-footer') {
            const deltaY = startY - pos.y;
            const newHeight = startHeight + deltaY;
            const newVh = Math.max(15, Math.min(80, (newHeight / window.innerHeight) * 100));
            document.documentElement.style.setProperty('--mobile-footer-height', newVh + 'vh');
          }
          
          e.preventDefault();
        }
        
        document.addEventListener('mousemove', handleMove);
        document.addEventListener('touchmove', handleMove, { passive: false });
        
        function handleEnd() {
          if (isResizing) {
            isResizing = false;
            
            if (currentResizer === 'header') {
              PAGE_STATE.topbarHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--topbar-height'));
              headerResizer.classList.remove('resizing');
            } else if (currentResizer === 'sidebar') {
              PAGE_STATE.sidebarWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width'));
              sidebarResizer.classList.remove('resizing');
            } else if (currentResizer === 'mobile-footer') {
              PAGE_STATE.mobileFooterHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--mobile-footer-height'));
              mobileFooterResizer.classList.remove('resizing');
            }
            
            document.body.classList.remove('resizing');
            document.body.style.cursor = '';
            currentResizer = null;
          }
        }
        
        document.addEventListener('mouseup', handleEnd);
        document.addEventListener('touchend', handleEnd);
        document.addEventListener('touchcancel', handleEnd);
      })();
      
      document.getElementById("export-data-btn").addEventListener("click", () => {
       const data = captureTheQuickening();
       const jsonStr = JSON.stringify(data, null, 2);
       const blob = new Blob([jsonStr], {
        type: "application/json"
       });
       const url = URL.createObjectURL(blob);
       const a = document.createElement("a");
       a.href = url;
       const safeTitle = (PAGE_STATE.title || "network-topology").toLowerCase().replace(/[^a-z0-9\-]+/g, "-");
       const timestamp = new Date().toISOString().split("T")[0];
       a.download = `${safeTitle}-data-${timestamp}.json`;
       document.body.appendChild(a);
       a.click();
       document.body.removeChild(a);
       URL.revokeObjectURL(url);
      });
      document.getElementById("import-data-btn").addEventListener("click", () => {
       document.getElementById("import-data-file").click();
      });
      document.getElementById("import-data-file").addEventListener("change", async (e) => {
       const file = e.target.files[0];
       if (!file) return;
       try {
        const text = await file.text();
        const data = JSON.parse(text);
        if (!data.nodeData || !data.edgeData) {
         alert("Invalid data file. Missing required fields.");
         return;
        }
        const confirmMsg = `This will replace all current data with the imported data.\n\nImporting:\n- ${Object.keys(data.nodeData).length} nodes\n- ${data.edgeData.list?.length || 0} connections\n\nContinue?`;
        if (!confirm(confirmMsg)) {
         e.target.value = "";
         return;
        }
        NODE_DATA = data.nodeData || {};
        EDGE_DATA = data.edgeData || {
         list: []
        };
        EDGE_LEGEND = data.edgeLegend || {};
        RECT_DATA = data.rectData || { list: [] };
        TEXT_DATA = data.textData || { list: [] };
        savedPositions = data.nodePositions || {};
        savedSizes = data.nodeSizes || {};
        savedStyles = data.nodeStyles || {};
        if (data.page) {
         PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, data.page, );
         wieldThePower();
        }
        if (data.canvas) {
         canvasState.zoom = data.canvas.zoom || 1;
         canvasState.panX = data.canvas.panX || 0;
         canvasState.panY = data.canvas.panY || 0;
        }
        if (data.page?.title) {
         document.title = data.page.title;
         document.querySelector(".editable-page-title", ).textContent = data.page.title;
        }
        forgeTheTopology();
        forgeTheLegend();
        updateViewBox();
        const nodeIds = Object.keys(NODE_DATA);
        if (nodeIds.length > 0) {
         claimTheImmortal(nodeIds[0]);
        } else {
         document.getElementById("node-panel").style.display = "none";
         document.getElementById("edge-panel").style.display = "none";
         document.getElementById("topology-toolbar").style.display = "none";
        }
        e.target.value = "";
       } catch (err) {
        console.error("Import error:", err);
        alert(`Failed to import data: ${err.message}`);
        e.target.value = "";
       }
      });
      const saveHelpBtn = document.getElementById("save-help-btn");
      const saveInfoModal = document.getElementById("save-info-modal");
      const saveInfoClose = document.getElementById("save-info-close");
      saveHelpBtn.addEventListener("click", () => {
       saveInfoModal.classList.add("active");
      });
      saveInfoClose.addEventListener("click", () => {
       saveInfoModal.classList.remove("active");
      });
      saveInfoModal.addEventListener("click", (e) => {
       if (e.target === saveInfoModal) {
        saveInfoModal.classList.remove("active");
       }
      });
      async function deriveKey(password, salt) {
      const encoder = new TextEncoder();
      
      const keyMaterial = await crypto.subtle.importKey(
      "raw",
      encoder.encode(password),
      "PBKDF2",
      false,
      ["deriveKey"]
      );
      
      return crypto.subtle.deriveKey(
      {
      name: "PBKDF2",
      salt: salt,
      iterations: 200000,
      hash: "SHA-256"
      },
      keyMaterial,
      {
      name: "AES-GCM",
      length: 256
      },
      false,
      ["encrypt", "decrypt"]
      );
      }
      
      async function encryptData(data, password) {
      const encoder = new TextEncoder();
      const salt = crypto.getRandomValues(new Uint8Array(16));
      const iv   = crypto.getRandomValues(new Uint8Array(12));
      
      const key = await deriveKey(password, salt);
      const encrypted = await crypto.subtle.encrypt(
      { name: "AES-GCM", iv },
      key,
      encoder.encode(data)
      );
      
      const encryptedU8 = new Uint8Array(encrypted);
      
      const result = new Uint8Array(salt.length + iv.length + encryptedU8.length);
      result.set(salt, 0);
      result.set(iv, salt.length);
      result.set(encryptedU8, salt.length + iv.length);
      
      return "ENCRYPTED:" + u8ToBase64(result);
      }
      
      async function decryptData(encryptedData, password) {
      const base64Data = encryptedData.replace("ENCRYPTED:", "");
      const fullData   = base64ToU8(base64Data);
      
      const salt      = fullData.slice(0, 16);
      const iv        = fullData.slice(16, 28);
      const encrypted = fullData.slice(28);
      
      const key = await deriveKey(password, salt);
      
      const decrypted = await crypto.subtle.decrypt(
      { name: "AES-GCM", iv },
      key,
      encrypted
      );
      
      const decoder = new TextDecoder();
      return decoder.decode(decrypted);
      }
      
      
      function isEncrypted(data) {
       return typeof data === "string" && data.startsWith("ENCRYPTED:");
      }
      
      function captureTheQuickening() {
       const currentTab = documentTabs[currentTabIndex];
       currentTab.nodes = JSON.parse(JSON.stringify(NODE_DATA));
       currentTab.edges = JSON.parse(JSON.stringify(EDGE_DATA));
       currentTab.positions = JSON.parse(JSON.stringify(savedPositions));
       currentTab.sizes = JSON.parse(JSON.stringify(savedSizes));
       currentTab.styles = JSON.parse(JSON.stringify(savedStyles));
       currentTab.legend = JSON.parse(JSON.stringify(EDGE_LEGEND));
       currentTab.rects = JSON.parse(JSON.stringify(RECT_DATA));
       currentTab.texts = JSON.parse(JSON.stringify(TEXT_DATA));
       currentTab.pageState = JSON.parse(JSON.stringify(PAGE_STATE));
       
       return {
        nodeData: NODE_DATA,
        edgeData: EDGE_DATA,
        rectData: RECT_DATA,
        textData: TEXT_DATA,
        edgeLegend: EDGE_LEGEND,
        nodePositions: savedPositions,
        nodeSizes: savedSizes,
        nodeStyles: savedStyles,
        page: PAGE_STATE,
        canvas: {
         zoom: canvasState.zoom,
         panX: canvasState.panX,
         panY: canvasState.panY,
        },
        savedTopologyView: savedTopologyView,
        documentTabs: documentTabs,
        currentTabIndex: currentTabIndex,
        encryptedSections: encryptedSections,
       };
      }
      
      function assembleTheImmortalForm() {
       const clone = document.documentElement.cloneNode(true);
       const nodeScript = clone.querySelector("#nodes-json");
       if (nodeScript) {
        nodeScript.textContent = JSON.stringify(NODE_DATA, null, 2);
       }
       let stateScript = clone.querySelector("#topology-state");
       if (!stateScript) {
        stateScript = document.createElement("script");
        stateScript.id = "topology-state";
        stateScript.type = "application/json";
        const body = clone.querySelector("body") || clone;
        body.appendChild(stateScript);
       }
       stateScript.textContent = JSON.stringify(captureTheQuickening(), null, 2, );
       return "<!DOCTYPE html> \n " + clone.outerHTML;
      }
      async function becomeImmortal() {
       saveRollbackVersion("Auto-save");
       
       const encryptEnabled = document.getElementById("encrypt-toggle").checked;
       let stateData = JSON.stringify(captureTheQuickening(), null, 2);
       if (encryptEnabled) {
        const password = prompt("Enter a password to encrypt your data:\n(Remember this password! You will need it to open this file and its non recoverable!)", );
        if (!password) {
         alert("Encryption cancelled. File not saved.");
         return;
        }
        const confirmPassword = prompt("Confirm your password:");
        if (password !== confirmPassword) {
         alert("Passwords do not match. File not saved.");
         return;
        }
        try {
         stateData = await encryptData(stateData, password);
        } catch (e) {
         alert("Encryption failed: " + e.message);
         return;
        }
       }
       const clone = document.documentElement.cloneNode(true);
       const nodeScript = clone.querySelector("#nodes-json");
       if (nodeScript) {
        if (encryptEnabled) {
         nodeScript.textContent = JSON.stringify({}, null, 2);
        } else {
         nodeScript.textContent = JSON.stringify(NODE_DATA, null, 2);
        }
       }
       let stateScript = clone.querySelector("#topology-state");
       if (!stateScript) {
        stateScript = document.createElement("script");
        stateScript.id = "topology-state";
        stateScript.type = "application/json";
        const body = clone.querySelector("body") || clone;
        body.appendChild(stateScript);
       }
       stateScript.textContent = stateData;
       const html = "<!DOCTYPE html> \n " + clone.outerHTML;
       const blob = new Blob([html], {
        type: "text/html"
       });
       const url = URL.createObjectURL(blob);
       const a = document.createElement("a");
       a.href = url;
       const safeTitle = (PAGE_STATE.title || document.title || "network-topology").toLowerCase().replace(/[^a-z0-9\-]+/g, "-");
       a.download = safeTitle + ".html";
       document.body.appendChild(a);
       a.click();
       document.body.removeChild(a);
       URL.revokeObjectURL(url);
       
       logAuditEvent("save", `File saved: ${safeTitle}.html`);
      }
      
      function captureState() {
      return {
       nodes: JSON.parse(JSON.stringify(NODE_DATA)),
       edges: JSON.parse(JSON.stringify(EDGE_DATA)),
       positions: JSON.parse(JSON.stringify(savedPositions)),
       sizes: JSON.parse(JSON.stringify(savedSizes)),
       styles: JSON.parse(JSON.stringify(savedStyles)),
       legend: JSON.parse(JSON.stringify(EDGE_LEGEND)),
       rects: JSON.parse(JSON.stringify(RECT_DATA)),
       texts: JSON.parse(JSON.stringify(TEXT_DATA))
       };
      }
      
      function pushUndo(action = "") {
       const state = captureState();
       undoStack.push(state);
       if (undoStack.length > MAX_UNDO_STACK) {
        undoStack.shift();
       }
       redoStack = [];
       updateUndoButtons();
       
       if (action) {
        const actionTypeMap = {
          "create node": "node",
          "delete node": "node",
          "edit": "node",
          "create rack": "rack",
          "add connection": "connection",
          "delete connection": "connection",
          "style change": "style",
          "change layer": "layer",
          "change assigned rack": "rack",
        };
        
        const type = actionTypeMap[action] || "node";
        logAuditEvent(type, action);
       }
      }
      
      function undo() {
       if (undoStack.length === 0) return;
       const currentState = captureState();
       redoStack.push(currentState);
       const previousState = undoStack.pop();
       restoreState(previousState);
       updateUndoButtons();
      }
      
      function redo() {
       if (redoStack.length === 0) return;
       const currentState = captureState();
       undoStack.push(currentState);
       const nextState = redoStack.pop();
       restoreState(nextState);
       updateUndoButtons();
      }
      
      function restoreState(state) {
      NODE_DATA = state.nodes;
      EDGE_DATA = state.edges;
      savedPositions = state.positions;
      savedSizes = state.sizes;
      savedStyles = state.styles;
      EDGE_LEGEND = state.legend;
      RECT_DATA = state.rects || { list: [] };
      TEXT_DATA = state.texts || { list: [] };
      forgeTheTopology();
      if (currentNodeId && NODE_DATA[currentNodeId]) {
       claimTheImmortal(currentNodeId);
      } else if (currentEdgeId) {
       selectTheConnection(currentEdgeId);
       }
      }
      
      function updateUndoButtons() {
       const undoBtn = document.getElementById("undo-btn");
       const redoBtn = document.getElementById("redo-btn");
       if (undoBtn) {
        undoBtn.disabled = undoStack.length === 0;
        undoBtn.style.opacity = undoStack.length === 0 ? "0.5" : "1";
       }
       if (redoBtn) {
        redoBtn.disabled = redoStack.length === 0;
        redoBtn.style.opacity = redoStack.length === 0 ? "0.5" : "1";
       }
      }
      
      function editNodeMac(id) {
       const currentMac = NODE_DATA[id].mac || "";
       showEditModal("Edit MAC Address", currentMac, (newMac) => {
        pushUndo("edit mac");
        NODE_DATA[id].mac = newMac;
        if (currentNodeId === id) {
         document.getElementById("node-mac").textContent = newMac || "--";
        }
       });
      }
      
      function editNodeRack(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       
       document.getElementById("modal-title").textContent = "Edit Rack Unit";
       document.getElementById("modal-input").value = node.rackUnit || "";
       document.getElementById("edit-modal").style.display = "flex";
       document.getElementById("modal-input").focus();
       
       const saveHandler = () => {
        pushUndo("edit rack");
        const value = document.getElementById("modal-input").value.trim();
        node.rackUnit = value;
        document.getElementById("edit-modal").style.display = "none";
        claimTheImmortal(id);
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       
       const cancelHandler = () => {
        document.getElementById("edit-modal").style.display = "none";
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       
       document.getElementById("edit-modal").addEventListener("click", function bgHandler(e) {
        if (e.target === document.getElementById("edit-modal")) {
         cancelHandler();
         document.getElementById("edit-modal").removeEventListener("click", bgHandler);
        }
       });
      }
      
      function editNodeUHeight(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       
       document.getElementById("modal-title").textContent = "Edit U Height";
       document.getElementById("modal-input").value = node.uHeight || "1";
       document.getElementById("edit-modal").style.display = "flex";
       document.getElementById("modal-input").focus();
       
       const saveHandler = () => {
        pushUndo("edit U height");
        const value = document.getElementById("modal-input").value.trim();
        node.uHeight = value;
        document.getElementById("edit-modal").style.display = "none";
        claimTheImmortal(id);
        forgeTheTopology();
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       
       const cancelHandler = () => {
        document.getElementById("edit-modal").style.display = "none";
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       
       document.getElementById("edit-modal").addEventListener("click", function bgHandler(e) {
        if (e.target === document.getElementById("edit-modal")) {
         cancelHandler();
         document.getElementById("edit-modal").removeEventListener("click", bgHandler);
        }
       });
      }
      
      function updateEdgePortLabels(edgeId) {
       const edge = EDGE_DATA.list.find(e => e.id === edgeId);
       if (!edge || edge.type === "custom") return;
       
       const fromPortInput = document.getElementById("edge-from-port");
       const toPortInput = document.getElementById("edge-to-port");
       
       if (fromPortInput && toPortInput) {
        edge.fromPort = fromPortInput.value || "";
        edge.toPort = toPortInput.value || "";
        saveEdgeData();
        forgeTheTopology();
       }
      }
      
      function selectNode(nodeId, addToSelection = false) {
       if (!addToSelection) {
        clearSelection();
       }
       selectedNodes.add(nodeId);
       updateNodeSelection();
      }
      
      function clearSelection() {
       selectedNodes.clear();
       updateNodeSelection();
      }
      
      function updateNodeSelection() {
       document.querySelectorAll(".node-group").forEach(node => {
        const nodeId = node.dataset.nodeId;
        if (selectedNodes.has(nodeId)) {
         node.classList.add("selected");
        } else {
         node.classList.remove("selected");
        }
       });
       
       const bulkToolbar = document.getElementById("bulk-toolbar");
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       const bulkCount = document.getElementById("bulk-count");
       const bulkCountMobile = document.getElementById("bulk-count-mobile");
       const bulkCountModal = document.getElementById("bulk-count-modal");
       
       if (selectedNodes.size > 0) {
        if (bulkToolbar) bulkToolbar.style.display = "flex";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
        if (bulkCount) bulkCount.textContent = selectedNodes.size;
        if (bulkCountMobile) bulkCountMobile.textContent = selectedNodes.size;
        if (bulkCountModal) bulkCountModal.textContent = selectedNodes.size;
       } else {
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        const modal = document.getElementById("bulk-actions-modal");
        if (modal) modal.style.display = "none";
       }
      }
      
      function deleteSelected() {
       if (selectedNodes.size === 0) return;
       const message = `Delete ${selectedNodes.size} selected node(s)?`;
       challengeTheImmortal(message, () => {
        pushUndo("delete selected");
        selectedNodes.forEach(nodeId => {
         delete NODE_DATA[nodeId];
         delete savedPositions[nodeId];
         delete savedSizes[nodeId];
         delete savedStyles[nodeId];
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== nodeId && e.to !== nodeId);
        });
        clearSelection();
        saveEdgeData();
        forgeTheTopology();
       });
      }
      
      function startSelection(event) {
       if (event.button !== 0) return;
       if (event.target.closest(".node-group")) return;
       
       isSelecting = true;
       const svg = document.getElementById("map");
       const pt = svg.createSVGPoint();
       pt.x = event.clientX;
       pt.y = event.clientY;
       const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
       selectionStart = { x: svgP.x, y: svgP.y };
       
       if (!event.shiftKey) {
        clearSelection();
       }
       
       if (!selectionRect) {
        selectionRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        selectionRect.setAttribute("fill", "rgba(79, 209, 197, 0.1)");
        selectionRect.setAttribute("stroke", "#4fd1c5");
        selectionRect.setAttribute("stroke-width", "2");
        selectionRect.setAttribute("stroke-dasharray", "5,5");
        svg.appendChild(selectionRect);
       }
       selectionRect.style.display = "block";
      }
      
      function updateSelection(event) {
       if (!isSelecting || !selectionStart) return;
       
       const svg = document.getElementById("map");
       const pt = svg.createSVGPoint();
       pt.x = event.clientX;
       pt.y = event.clientY;
       const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
       
       const x = Math.min(selectionStart.x, svgP.x);
       const y = Math.min(selectionStart.y, svgP.y);
       const width = Math.abs(svgP.x - selectionStart.x);
       const height = Math.abs(svgP.y - selectionStart.y);
       
       selectionRect.setAttribute("x", x);
       selectionRect.setAttribute("y", y);
       selectionRect.setAttribute("width", width);
       selectionRect.setAttribute("height", height);
       
       Object.entries(savedPositions).forEach(([nodeId, pos]) => {
        if (pos.x >= x && pos.x <= x + width && pos.y >= y && pos.y <= y + height) {
         selectedNodes.add(nodeId);
        } else if (!event.shiftKey) {
         selectedNodes.delete(nodeId);
        }
       });
       updateNodeSelection();
      }
      
      function endSelection() {
       isSelecting = false;
       if (selectionRect) {
        selectionRect.style.display = "none";
       }
      }
      
      function cloneNode(sourceId) {
       if (!NODE_DATA[sourceId]) return;
       
       pushUndo("clone node");
       const source = NODE_DATA[sourceId];
       const baseName = source.name + " copy";
       let newName = baseName;
       let counter = 1;
       while (Object.values(NODE_DATA).some(n => n.name === newName)) {
        newName = `${baseName} ${counter}`;
        counter++;
       }
       
       const baseId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
       let newId = baseId;
       counter = 1;
       while (NODE_DATA[newId]) {
        newId = `${baseId}-${counter}`;
        counter++;
       }
       
       NODE_DATA[newId] = {
        shape: source.shape,
        name: newName,
        ip: source.ip,
        role: source.role,
        tags: [...source.tags],
        notes: [...source.notes],
        mac: source.mac || "",
        rackUnit: source.rackUnit || "",
        uHeight: source.uHeight || "1",
        layer: source.layer || "physical",
        assignedRack: source.assignedRack || "",
        rackCapacity: source.rackCapacity || "42",
        isRack: source.isRack || false
       };
       
       const sourcePos = savedPositions[sourceId];
       savedPositions[newId] = {
        x: sourcePos.x + 100,
        y: sourcePos.y + 100
       };
       
       if (savedSizes[sourceId]) {
        savedSizes[newId] = savedSizes[sourceId];
       }
       
       if (savedStyles[sourceId]) {
        savedStyles[newId] = JSON.parse(JSON.stringify(savedStyles[sourceId]));
       }
       
       forgeTheTopology();
       claimTheImmortal(newId);
      }
      
      function alignSelectedNodes(direction) {
       if (selectedNodes.size < 2) return;
       
       pushUndo("align nodes");
       const nodes = Array.from(selectedNodes).map(id => ({
        id,
        pos: savedPositions[id]
       }));
       
       switch(direction) {
        case "left":
         const minX = Math.min(...nodes.map(n => n.pos.x));
         nodes.forEach(n => savedPositions[n.id].x = minX);
         break;
        case "right":
         const maxX = Math.max(...nodes.map(n => n.pos.x));
         nodes.forEach(n => savedPositions[n.id].x = maxX);
         break;
        case "top":
         const minY = Math.min(...nodes.map(n => n.pos.y));
         nodes.forEach(n => savedPositions[n.id].y = minY);
         break;
        case "bottom":
         const maxY = Math.max(...nodes.map(n => n.pos.y));
         nodes.forEach(n => savedPositions[n.id].y = maxY);
         break;
        case "center-h":
         const avgX = nodes.reduce((sum, n) => sum + n.pos.x, 0) / nodes.length;
         nodes.forEach(n => savedPositions[n.id].x = avgX);
         break;
        case "center-v":
         const avgY = nodes.reduce((sum, n) => sum + n.pos.y, 0) / nodes.length;
         nodes.forEach(n => savedPositions[n.id].y = avgY);
         break;
       }
       
       forgeTheTopology();
      }
      
      function distributeSelectedNodes(direction) {
       if (selectedNodes.size < 3) return;
       
       pushUndo("distribute nodes");
       const nodes = Array.from(selectedNodes).map(id => ({
        id,
        pos: savedPositions[id]
       }));
       
       if (direction === "horizontal") {
        nodes.sort((a, b) => a.pos.x - b.pos.x);
        const minX = nodes[0].pos.x;
        const maxX = nodes[nodes.length - 1].pos.x;
        const gap = (maxX - minX) / (nodes.length - 1);
        nodes.forEach((n, i) => {
         savedPositions[n.id].x = minX + (gap * i);
        });
       } else {
        nodes.sort((a, b) => a.pos.y - b.pos.y);
        const minY = nodes[0].pos.y;
        const maxY = nodes[nodes.length - 1].pos.y;
        const gap = (maxY - minY) / (nodes.length - 1);
        nodes.forEach((n, i) => {
         savedPositions[n.id].y = minY + (gap * i);
        });
       }
       
       forgeTheTopology();
      }
      
      function snapToGrid(nodeId, gridSize = 50) {
       if (!savedPositions[nodeId]) return;
       
       pushUndo("snap to grid");
       const pos = savedPositions[nodeId];
       pos.x = Math.round(pos.x / gridSize) * gridSize;
       pos.y = Math.round(pos.y / gridSize) * gridSize;
       forgeTheTopology();
      }
      
      function searchNodes(query) {
       if (!query) {
        clearSearchHighlight();
        return [];
       }
       
       query = query.toLowerCase();
       const results = [];
       
       Object.entries(NODE_DATA).forEach(([id, data]) => {
        if (data.name.toLowerCase().includes(query) ||
            data.ip.toLowerCase().includes(query) ||
            data.role.toLowerCase().includes(query) ||
            data.tags.some(tag => tag.toLowerCase().includes(query)) ||
            (data.mac && data.mac.toLowerCase().includes(query)) ||
            (data.rackUnit && data.rackUnit.toLowerCase().includes(query))) {
         results.push(id);
        }
       });
       
       highlightSearchResults(results);
       return results;
      }
      
      function highlightSearchResults(nodeIds) {
       document.querySelectorAll(".node-group").forEach(node => {
        const nodeId = node.dataset.nodeId;
        if (nodeIds.includes(nodeId)) {
         node.classList.add("search-highlight");
        } else {
         node.classList.remove("search-highlight");
        }
       });
      }
      
      function clearSearchHighlight() {
       document.querySelectorAll(".search-highlight").forEach(node => {
        node.classList.remove("search-highlight");
       });
      }
      
      function nudgeSelectedNodes(direction, distance) {
        const nodesToNudge = selectedNodes.size > 0 
          ? Array.from(selectedNodes) 
          : (currentNodeId ? [currentNodeId] : []);
        
        if (nodesToNudge.length === 0) return;
        
        const unlockedNodes = nodesToNudge.filter(id => !NODE_DATA[id]?.locked);
        
        if (unlockedNodes.length === 0) {
          return;
        }
        
        pushUndo("nudge nodes");
        
        unlockedNodes.forEach(id => {
          if (!savedPositions[id]) {
            savedPositions[id] = { x: 0, y: 0 };
          }
          
          switch(direction) {
            case "ArrowUp":
              savedPositions[id].y -= distance;
              break;
            case "ArrowDown":
              savedPositions[id].y += distance;
              break;
            case "ArrowLeft":
              savedPositions[id].x -= distance;
              break;
            case "ArrowRight":
              savedPositions[id].x += distance;
              break;
          }
        });
        
        forgeTheTopology();
      }
      
      function cycleNodes(reverse = false) {
        const nodeIds = Object.keys(NODE_DATA).filter(id => {
          if (currentView.mode === "rack" && currentView.rackId) {
            return NODE_DATA[id].assignedRack === currentView.rackId;
          }
          return !NODE_DATA[id].assignedRack;
        });
        
        if (nodeIds.length === 0) return;
        
        let currentIndex = nodeIds.indexOf(currentNodeId);
        
        if (reverse) {
          currentIndex = currentIndex <= 0 ? nodeIds.length - 1 : currentIndex - 1;
        } else {
          currentIndex = currentIndex >= nodeIds.length - 1 ? 0 : currentIndex + 1;
        }
        
        const nextNodeId = nodeIds[currentIndex];
        claimTheImmortal(nextNodeId);
        
        selectedNodes.clear();
        updateNodeSelection();
      }
      
      function focusOnSelected() {
        const nodesToFocus = selectedNodes.size > 0 
          ? Array.from(selectedNodes) 
          : (currentNodeId ? [currentNodeId] : []);
        
        if (nodesToFocus.length === 0) return;
        
        let minX = Infinity, minY = Infinity;
        let maxX = -Infinity, maxY = -Infinity;
        
        nodesToFocus.forEach(id => {
          const pos = savedPositions[id];
          if (pos) {
            const size = savedSizes[id] || 50;
            minX = Math.min(minX, pos.x - size/2);
            minY = Math.min(minY, pos.y - size/2);
            maxX = Math.max(maxX, pos.x + size/2);
            maxY = Math.max(maxY, pos.y + size/2);
          }
        });
        
        if (!isFinite(minX)) return;
        
        const padding = 100;
        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;
        const width = maxX - minX + padding * 2;
        const height = maxY - minY + padding * 2;
        
        const zoomX = CANVAS_WIDTH / width;
        const zoomY = CANVAS_HEIGHT / height;
        const targetZoom = Math.min(zoomX, zoomY, 2); 
        
        canvasState.zoom = targetZoom;
        canvasState.panX = centerX - (CANVAS_WIDTH / targetZoom) / 2;
        canvasState.panY = centerY - (CANVAS_HEIGHT / targetZoom) / 2;
        
        forgeTheTopology();
      }
      
      function toggleLockSelected() {
        const nodesToToggle = selectedNodes.size > 0 
          ? Array.from(selectedNodes) 
          : (currentNodeId ? [currentNodeId] : []);
        
        if (nodesToToggle.length === 0) return;
        
        pushUndo("toggle lock");
        
        const hasUnlocked = nodesToToggle.some(id => !NODE_DATA[id]?.locked);
        
        nodesToToggle.forEach(id => {
          if (NODE_DATA[id]) {
            NODE_DATA[id].locked = hasUnlocked;
          }
        });
        
        forgeTheTopology();
      
        const lockState = hasUnlocked ? "locked" : "unlocked";
      }
      
      function toggleGroupSelected() {
        const nodesToGroup = Array.from(selectedNodes);
        if (nodesToGroup.length < 2) {
          return;
        }
        
        pushUndo("toggle group");
        
        const groupIds = nodesToGroup.map(id => NODE_DATA[id]?.groupId).filter(g => g !== null && g !== undefined);
        const uniqueGroups = [...new Set(groupIds)];
        
        if (uniqueGroups.length === 1 && groupIds.length === nodesToGroup.length) {
          nodesToGroup.forEach(id => {
            if (NODE_DATA[id]) {
              NODE_DATA[id].groupId = null;
            }
          });
        } else {
          const newGroupId = "group-" + Date.now();
          nodesToGroup.forEach(id => {
            if (NODE_DATA[id]) {
              NODE_DATA[id].groupId = newGroupId;
            }
          });
        }
        
        forgeTheTopology();
      }
      
      function handleKeyDown(event) {
       if (event.target.tagName === "INPUT" || event.target.tagName === "TEXTAREA" || event.target.isContentEditable) {
        return;
       }
       
       if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(event.key)) {
        event.preventDefault();
        const distance = event.shiftKey ? 10 : 1;
        nudgeSelectedNodes(event.key, distance);
       }
       
       if (event.key === "Tab") {
        event.preventDefault();
        cycleNodes(event.shiftKey);
       }
       
       if (event.key === "f" || event.key === "F") {
        event.preventDefault();
        focusOnSelected();
       }
       
       if (event.key === "l" || event.key === "L") {
        event.preventDefault();
        toggleLockSelected();
       }
       
       if (event.key === "g" || event.key === "G") {
        event.preventDefault();
        toggleGroupSelected();
       }
       
       if (event.ctrlKey && event.key === "z") {
        event.preventDefault();
        undo();
       }
       
       if ((event.ctrlKey && event.key === "y") || (event.ctrlKey && event.shiftKey && event.key === "z")) {
        event.preventDefault();
        redo();
       }
       
       if (event.ctrlKey && event.key === "c") {
        event.preventDefault();
        if (currentNodeId && NODE_DATA[currentNodeId]) {
         clipboard = {
          type: "node",
          data: JSON.parse(JSON.stringify(NODE_DATA[currentNodeId])),
          size: savedSizes[currentNodeId],
          style: savedStyles[currentNodeId] ? JSON.parse(JSON.stringify(savedStyles[currentNodeId])) : null
         };
        }
       }
       
       if (event.ctrlKey && event.key === "v") {
        event.preventDefault();
        if (clipboard && clipboard.type === "node") {
         const data = clipboard.data;
         const baseName = data.name + " copy";
         let newName = baseName;
         let counter = 1;
         while (Object.values(NODE_DATA).some(n => n.name === newName)) {
          newName = `${baseName} ${counter}`;
          counter++;
         }
         
         const baseId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
         let newId = baseId;
         counter = 1;
         while (NODE_DATA[newId]) {
          newId = `${baseId}-${counter}`;
          counter++;
         }
         
         pushUndo("paste node");
         NODE_DATA[newId] = {
          ...data,
          name: newName
         };
         
      const viewWidth = CANVAS_WIDTH / canvasState.zoom;
      const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
      const centerX = canvasState.panX + (viewWidth / 2);
      const centerY = canvasState.panY + (viewHeight / 2);
      savedPositions[nodeId] = {
      x: centerX,
      y: centerY
      };
         
         if (clipboard.size) savedSizes[newId] = clipboard.size;
         if (clipboard.style) savedStyles[newId] = clipboard.style;
         
         forgeTheTopology();
         claimTheImmortal(newId);
        }
       }
       
       if (event.key === "Delete") {
        event.preventDefault();
        if (selectedNodes.size > 0) {
         deleteSelected();
        } else if (currentNodeId && NODE_DATA[currentNodeId]) {
         challengeTheImmortal(`Delete node "${NODE_DATA[currentNodeId].name}"?`, () => {
          pushUndo("delete node");
          delete NODE_DATA[currentNodeId];
          delete savedPositions[currentNodeId];
          delete savedSizes[currentNodeId];
          delete savedStyles[currentNodeId];
          EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== currentNodeId && e.to !== currentNodeId);
          currentNodeId = null;
          saveEdgeData();
          forgeTheTopology();
          document.getElementById("node-panel").style.display = "none";
         });
        } else if (currentEdgeId) {
         challengeTheImmortal("Delete this line?", () => {
          pushUndo("delete edge");
          EDGE_DATA.list = EDGE_DATA.list.filter(e => e.id !== currentEdgeId);
          currentEdgeId = null;
          saveEdgeData();
          forgeTheTopology();
          document.getElementById("edge-panel").style.display = "none";
         });
        }
       }
      
       if (event.ctrlKey && event.key === "a") {
        event.preventDefault();
        Object.keys(NODE_DATA).forEach(id => selectedNodes.add(id));
        updateNodeSelection();
       }
       
       if (event.key === "Escape") {
        clearSelection();
        clearSearchHighlight();
       }
      
       if (event.ctrlKey && event.key === "d") {
        event.preventDefault();
        if (currentNodeId && NODE_DATA[currentNodeId]) {
         cloneNode(currentNodeId);
        }
       }
      }
      
      function saveRollbackVersion(description = "Auto-save") {
        const version = {
          timestamp: Date.now(),
          description,
          data: captureTheQuickening()
        };
        
        try {
          const stored = localStorage.getItem(ROLLBACK_STORAGE_KEY);
          rollbackVersions = stored ? JSON.parse(stored) : [];
        } catch (e) {
          rollbackVersions = [];
        }
        
        rollbackVersions.unshift(version);
        
        if (rollbackVersions.length > MAX_ROLLBACK_VERSIONS) {
          rollbackVersions = rollbackVersions.slice(0, MAX_ROLLBACK_VERSIONS);
        }
        
        try {
          localStorage.setItem(ROLLBACK_STORAGE_KEY, JSON.stringify(rollbackVersions));
        } catch (e) {
          console.warn("Failed to save rollback version:", e);
        }
      }
      
      function loadRollbackVersions() {
        try {
          const stored = localStorage.getItem(ROLLBACK_STORAGE_KEY);
          rollbackVersions = stored ? JSON.parse(stored) : [];
          displayRollbackVersions();
        } catch (e) {
          console.warn("Failed to load rollback versions:", e);
          rollbackVersions = [];
        }
      }
      
      function displayRollbackVersions() {
        const listEl = document.getElementById("rollback-list");
        if (!listEl) return;
        
        if (rollbackVersions.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No version history yet. Versions are saved automatically when you save the file.</div>';
          return;
        }
        
        listEl.innerHTML = rollbackVersions.map((version, index) => {
          const date = new Date(version.timestamp);
          const timeStr = date.toLocaleString();
          const nodeCount = Object.keys(version.data.nodeData || {}).length;
          const edgeCount = (version.data.edgeData?.list || []).length;
          
          return `
            <div class="version-item" onclick="restoreRollbackVersion(${index})">
              <div class="version-info">
                <div class="timestamp">${timeStr}</div>
                <div class="details">${version.description} ‚Ä¢ ${nodeCount} nodes ‚Ä¢ ${edgeCount} connections</div>
              </div>
              <div class="version-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteRollbackVersion(${index})" title="Delete this version">üóëÔ∏è</button>
              </div>
            </div>
          `;
        }).join('');
      }
      
      function restoreRollbackVersion(index) {
        if (!confirm(`Restore version from ${new Date(rollbackVersions[index].timestamp).toLocaleString()}?\n\nYour current work will be lost unless you save first.`)) {
          return;
        }
        
        const version = rollbackVersions[index];
        const data = version.data;
        
        NODE_DATA = data.nodeData || {};
        EDGE_DATA = data.edgeData || { list: [] };
        RECT_DATA = data.rectData || { list: [] };
        TEXT_DATA = data.textData || { list: [] };
        EDGE_LEGEND = data.edgeLegend || {};
        savedPositions = data.nodePositions || {};
        savedSizes = data.nodeSizes || {};
        savedStyles = data.nodeStyles || {};
        PAGE_STATE = data.page || PAGE_STATE;
        
        if (data.canvas) {
          canvasState.zoom = data.canvas.zoom;
          canvasState.panX = data.canvas.panX;
          canvasState.panY = data.canvas.panY;
        }
        
        wieldThePower();
        forgeTheTopology();
        
        document.getElementById("rollback-modal").classList.remove("active");
        
        logAuditEvent("rollback", `Restored version from ${new Date(version.timestamp).toLocaleString()}`);
      }
      
      function deleteRollbackVersion(index) {
        if (!confirm("Delete this version from history?")) return;
        
        rollbackVersions.splice(index, 1);
        try {
          localStorage.setItem(ROLLBACK_STORAGE_KEY, JSON.stringify(rollbackVersions));
        } catch (e) {
          console.warn("Failed to delete version:", e);
        }
        displayRollbackVersions();
      }
      
      function clearRollbackHistory() {
        if (!confirm("Clear all version history?\n\nThis cannot be undone.")) return;
        
        rollbackVersions = [];
        localStorage.removeItem(ROLLBACK_STORAGE_KEY);
        displayRollbackVersions();
      }
      
      function createManualSnapshot() {
        const description = prompt("Enter a description for this snapshot:", "Manual snapshot");
        if (!description) return;
        
        saveRollbackVersion(description);
        displayRollbackVersions();
      }
      
      function switchTab(index) {
        if (index === currentTabIndex) return;
        
        const currentTab = documentTabs[currentTabIndex];
        currentTab.nodes = JSON.parse(JSON.stringify(NODE_DATA));
        currentTab.edges = JSON.parse(JSON.stringify(EDGE_DATA));
        currentTab.positions = JSON.parse(JSON.stringify(savedPositions));
        currentTab.sizes = JSON.parse(JSON.stringify(savedSizes));
        currentTab.styles = JSON.parse(JSON.stringify(savedStyles));
        currentTab.legend = JSON.parse(JSON.stringify(EDGE_LEGEND));
        currentTab.rects = JSON.parse(JSON.stringify(RECT_DATA));
        currentTab.texts = JSON.parse(JSON.stringify(TEXT_DATA));
        currentTab.pageState = JSON.parse(JSON.stringify(PAGE_STATE));
      
        currentTabIndex = index;
        const newTab = documentTabs[index];
        NODE_DATA = JSON.parse(JSON.stringify(newTab.nodes));
        EDGE_DATA = JSON.parse(JSON.stringify(newTab.edges));
        savedPositions = JSON.parse(JSON.stringify(newTab.positions));
        savedSizes = JSON.parse(JSON.stringify(newTab.sizes));
        savedStyles = JSON.parse(JSON.stringify(newTab.styles));
        EDGE_LEGEND = JSON.parse(JSON.stringify(newTab.legend));
        RECT_DATA = JSON.parse(JSON.stringify(newTab.rects));
        TEXT_DATA = JSON.parse(JSON.stringify(newTab.texts));
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, newTab.pageState || {});
               wieldThePower();
        document.title = newTab.name;
      document.getElementById("page-title").textContent = newTab.name;
        forgeTheTopology();
        displayTabs();
        
        logAuditEvent("tab", `Switched to tab: ${newTab.name}`);
      }
      
      function createNewTab() {
        const nameInput = document.getElementById("new-tab-name");
        const name = nameInput.value.trim();
        
        if (!name) {
          alert("Please enter a tab name");
          return;
        }
        
        const newTab = {
          id: `tab-${Date.now()}`,
          name,
          nodes: {},
          edges: { list: [] },
          positions: {},
          sizes: {},
          styles: {},
          legend: {},
          rects: { list: [] },
          texts: { list: [] },
		  pageState: null
        };
        
        documentTabs.push(newTab);
        nameInput.value = "";
        displayTabs();
        
        logAuditEvent("tab", `Created new tab: ${name}`);
      }
      
      function renameTab(index) {
        const tab = documentTabs[index];
        const newName = prompt("Enter new name:", tab.name);
        if (!newName || newName === tab.name) return;
        
        tab.name = newName;
        displayTabs();
        
        logAuditEvent("tab", `Renamed tab to: ${newName}`);
      }
      
      function deleteTab(index) {
        if (documentTabs.length === 1) {
          alert("Cannot delete the last tab");
          return;
        }
        
        if (!confirm(`Delete tab "${documentTabs[index].name}"?`)) return;
        
        documentTabs.splice(index, 1);
        
        if (currentTabIndex >= documentTabs.length) {
          currentTabIndex = documentTabs.length - 1;
        }
        
        if (currentTabIndex === index) {
          switchTab(currentTabIndex);
        }
        
        displayTabs();
      }
      
      function displayTabs() {
        const listEl = document.getElementById("tabs-list");
        if (!listEl) return;
        
        listEl.innerHTML = documentTabs.map((tab, index) => {
          const nodeCount = Object.keys(tab.nodes).length;
          const edgeCount = tab.edges.list.length;
          const isActive = index === currentTabIndex;
          
          return `
            <div class="tab-item ${isActive ? 'active' : ''}" onclick="switchTab(${index})">
              <div class="tab-name">${tab.name}</div>
              <div class="tab-stats">${nodeCount} nodes ‚Ä¢ ${edgeCount} connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(${index})" title="Rename tab">‚úèÔ∏è</button>
                ${documentTabs.length > 1 ? '<button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(${index})" title="Delete tab">üóëÔ∏è</button>' : ''}
              </div>
            </div>
          `;
        }).join('');
      }
      
      function logAuditEvent(type, description, details = {}) {
        const event = {
          timestamp: Date.now(),
          type,
          description,
          details,
          tab: documentTabs[currentTabIndex]?.name || "Main"
        };
        
        auditLog.unshift(event);
        
        if (auditLog.length > MAX_AUDIT_ENTRIES) {
          auditLog = auditLog.slice(0, MAX_AUDIT_ENTRIES);
        }
      
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to save audit log:", e);
        }
      }
      
      function loadAuditLog() {
        try {
          const stored = localStorage.getItem(AUDIT_STORAGE_KEY);
          auditLog = stored ? JSON.parse(stored) : [];
        } catch (e) {
          console.warn("Failed to load audit log:", e);
          auditLog = [];
        }
      }
      
      function displayAuditLog(filter = "all") {
        const listEl = document.getElementById("audit-log-list");
        if (!listEl) return;
        
        const filtered = filter === "all" ? auditLog : auditLog.filter(e => e.type === filter);
        
        if (filtered.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No audit entries yet</div>';
          return;
        }
        
        listEl.innerHTML = filtered.map(event => {
          const date = new Date(event.timestamp);
          const timeStr = date.toLocaleString();
          
          return `
            <div class="audit-entry ${event.type}">
              <div class="time">[${timeStr}] ${event.tab}</div>
              <div class="action">[${event.type.toUpperCase()}] ${event.description}</div>
            </div>
          `;
        }).join('');
      }
      
      function clearAuditLog() {
        if (!confirm("Clear all audit log entries?\n\nThis cannot be undone.")) return;
        
        auditLog = [];
        localStorage.removeItem(AUDIT_STORAGE_KEY);
        displayAuditLog();
      }
      
      function exportAuditLog() {
        if (auditLog.length === 0) {
          alert("No audit entries to export");
          return;
        }
        
        const csv = [
          ["Timestamp", "Tab", "Type", "Description"],
          ...auditLog.map(e => [
            new Date(e.timestamp).toISOString(),
            e.tab,
            e.type,
            e.description
          ])
        ].map(row => row.map(cell => `"${cell}"`).join(",")).join("\n");
        
        const blob = new Blob([csv], { type: "text/csv" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `audit-log-${Date.now()}.csv`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }
      
      let currentSecretName = null;
      
      function createNewSecret() {
        const nameInput = document.getElementById("new-secret-name");
        const name = nameInput.value.trim();
        
        if (!name) {
          alert("Please enter a note name");
          return;
        }
        
        if (encryptedSections[name]) {
          alert("A note with this name already exists");
          return;
        }
        
        currentSecretName = name;
        encryptedSections[name] = { encrypted: false, data: "" };
        nameInput.value = "";
        
        document.getElementById("secret-editor-title").textContent = `New note: ${name}`;
        document.getElementById("secret-editor-content").value = "";
        document.getElementById("secrets-modal").classList.remove("active");
        document.getElementById("secret-editor-modal").classList.add("active");
        
        displaySecrets();
      }
      
      function editSecret(name) {
        currentSecretName = name;
        const section = encryptedSections[name];
        
        if (section.encrypted) {
          const password = prompt(`Enter password to decrypt "${name}":`);
          if (!password) return;
          
          try {
            decryptData(section.data, password).then(decrypted => {
              document.getElementById("secret-editor-title").textContent = `Edit note: ${name}`;
              document.getElementById("secret-editor-content").value = decrypted;
              document.getElementById("secrets-modal").classList.remove("active");
              document.getElementById("secret-editor-modal").classList.add("active");
            }).catch(e => {
              alert("Failed to decrypt. Wrong password?");
            });
          } catch (e) {
            alert("Failed to decrypt. Wrong password?");
          }
        } else {
          document.getElementById("secret-editor-title").textContent = `Edit note: ${name}`;
          document.getElementById("secret-editor-content").value = section.data;
          document.getElementById("secrets-modal").classList.remove("active");
          document.getElementById("secret-editor-modal").classList.add("active");
        }
      }
      
      async function saveSecret() {
        if (!currentSecretName) return;
        
        const content = document.getElementById("secret-editor-content").value;
        const autoEncrypt = document.getElementById("secret-auto-encrypt").checked;
        
        if (autoEncrypt) {
          const password = prompt(`Enter password to encrypt "${currentSecretName}":`);
          if (!password) return;
          
          const confirmPassword = prompt("Confirm password:");
          if (password !== confirmPassword) {
            alert("Passwords do not match");
            return;
          }
          
          try {
            const encrypted = await encryptData(content, password);
            encryptedSections[currentSecretName] = { encrypted: true, data: encrypted };
          } catch (e) {
            alert("Encryption failed: " + e.message);
            return;
          }
        } else {
          encryptedSections[currentSecretName] = { encrypted: false, data: content };
        }
        
        closeSecretEditor();
        displaySecrets();
        
        logAuditEvent("secret", `Saved note: ${currentSecretName}`);
      }
      
      function closeSecretEditor() {
        document.getElementById("secret-editor-modal").classList.remove("active");
        document.getElementById("secrets-modal").classList.add("active");
        currentSecretName = null;
      }
      
      function deleteSecret(name) {
        if (!confirm(`Delete note "${name}"?`)) return;
        
        delete encryptedSections[name];
        displaySecrets();
        
        logAuditEvent("secret", `Deleted note: ${name}`);
      }
      
      function displaySecrets() {
        const listEl = document.getElementById("secrets-list");
        if (!listEl) return;
        
        const secrets = Object.keys(encryptedSections);
        
        if (secrets.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No notes yet</div>';
          return;
        }
        
        listEl.innerHTML = secrets.map(name => {
          const section = encryptedSections[name];
          const status = section.encrypted ? "üîí Encrypted" : "üîì Plaintext";
          
          return `
            <div class="secret-item">
              <div class="secret-name">${name}</div>
              <div class="secret-status">${status}</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="editSecret('${name}')" title="Edit note">‚úèÔ∏è</button>
                <button class="btn-cancel" onclick="deleteSecret('${name}')" title="Delete note">üóëÔ∏è</button>
              </div>
            </div>
          `;
        }).join('');
      }
      
      let rafId = null;
      let lastRender = 0;
      const RENDER_THROTTLE = 16;
      
      function optimizedForgeTheTopology() {
        if (rafId) return;
        
        rafId = requestAnimationFrame((timestamp) => {
          if (timestamp - lastRender < RENDER_THROTTLE) {
            rafId = requestAnimationFrame(optimizedForgeTheTopology);
            return;
          }
          
          lastRender = timestamp;
          rafId = null;
          
          if (cullOffscreenNodes && Object.keys(NODE_DATA).length > 100) {
            cullOffscreenElements();
          }
          
          forgeTheTopology();
          
          if (Date.now() - lastMinimapUpdate > 500) {
            updateMinimapOptimized();
            lastMinimapUpdate = Date.now();
          }
        });
      }
      
      function cullOffscreenElements() {
        const viewX = canvasState.panX;
        const viewY = canvasState.panY;
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        
        Object.keys(NODE_DATA).forEach(id => {
          const pos = savedPositions[id];
          if (!pos) return;
          
          const nodeEl = document.querySelector(`[data-node-id="${id}"]`);
          if (!nodeEl) return;
          
          const isVisible = (
            pos.x + 100 >= viewX &&
            pos.x - 100 <= viewX + viewWidth &&
            pos.y + 100 >= viewY &&
            pos.y - 100 <= viewY + viewHeight
          );
          
          nodeEl.style.display = isVisible ? "" : "none";
        });
      }
      
      function updateMinimapOptimized() {
        minimapNeedsUpdate = true;
      }
      
      function setupDragToCreate() {
        const addNodeBtn = document.getElementById("add-node-btn");
        const addRackBtn = document.getElementById("add-rack-btn");
        const canvas = document.getElementById("map");
        
        if (!addNodeBtn || !addRackBtn || !canvas) return;
        
        let dragType = null;
        
        [addNodeBtn, addRackBtn].forEach(btn => {
          btn.setAttribute("draggable", "true");
          
          btn.addEventListener("dragstart", e => {
            dragType = btn.id === "add-node-btn" ? "node" : "rack";
            e.dataTransfer.effectAllowed = "copy";
            e.dataTransfer.setData("text/plain", dragType);
          });
        });
        
        canvas.addEventListener("dragover", e => {
          if (dragType) {
            e.preventDefault();
            e.dataTransfer.dropEffect = "copy";
          }
        });
        
        canvas.addEventListener("drop", e => {
          if (!dragType) return;
          
          e.preventDefault();
          
          const rect = canvas.getBoundingClientRect();
          const x = (e.clientX - rect.left) / canvasState.zoom + canvasState.panX;
          const y = (e.clientY - rect.top) / canvasState.zoom + canvasState.panY;
          
          if (dragType === "node") {
            createNodeAtPosition(x, y);
          } else if (dragType === "rack") {
            createRackAtPosition(x, y);
          }
          
          dragType = null;
        });
      }
      
      function createNodeAtPosition(x, y) {
        const timestamp = Date.now();
        const newId = `host-${timestamp}`;
        
        NODE_DATA[newId] = {
          name: "New Node",
          ip: "0.0.0.0",
          shape: "server",
          role: "",
          tags: [],
          notes: "",
          layer: "physical",
          isRack: false
        };
        
        savedPositions[newId] = { x, y };
        savedSizes[newId] = 55;
        
        pushUndo("create node");
        forgeTheTopology();
        claimTheImmortal(newId);
        
        logAuditEvent("node", `Created node at (${Math.round(x)}, ${Math.round(y)})`);
      }
      
      function createRackAtPosition(x, y) {
        const timestamp = Date.now();
        const newId = `rack-${timestamp}`;
        
        NODE_DATA[newId] = {
          name: "New Rack",
          ip: "",
          shape: "server",
          role: "rack",
          tags: [],
          notes: "",
          layer: "physical",
          isRack: true,
          rackCapacity: 42
        };
        
        savedPositions[newId] = { x, y };
        savedSizes[newId] = 55;
        
        pushUndo("create rack");
        populateRackDropdown();
        forgeTheTopology();
        claimTheImmortal(newId);
        
        logAuditEvent("rack", `Created rack at (${Math.round(x)}, ${Math.round(y)})`);
      }
      
      document.addEventListener("keydown", handleKeyDown);
      
      document.getElementById("save-file-btn").addEventListener("click", becomeImmortal);
      const addNodeBtn = document.getElementById("add-node-btn");
      const addNodeModal = document.getElementById("add-node-modal");
      const addNodeCancel = document.getElementById("add-node-cancel");
      const addNodeSave = document.getElementById("add-node-save");
      
      const undoBtn = document.getElementById("undo-btn");
      const redoBtn = document.getElementById("redo-btn");
      if (undoBtn) undoBtn.addEventListener("click", undo);
      if (redoBtn) redoBtn.addEventListener("click", redo);
      
      const backToTopologyBtn = document.getElementById("back-to-topology-btn");
      if (backToTopologyBtn) {
       backToTopologyBtn.addEventListener("click", exitRack);
      }
      
      const canvasViewport = document.getElementById("canvas-viewport");
      if (canvasViewport) {
       canvasViewport.addEventListener("dblclick", (e) => {
        if (currentView.mode === "rack" && e.target.id === "map") {
         exitRack();
        }
       });
      }
      
      const layersBtn = document.getElementById("layers-btn");
      const layerModal = document.getElementById("layer-modal");
      const layerModalClose = document.getElementById("layer-modal-close");
      if (layersBtn && layerModal) {
       layersBtn.addEventListener("click", () => {
        layerModal.classList.add("active");
       });
      }
      if (layerModalClose && layerModal) {
       layerModalClose.addEventListener("click", () => {
        layerModal.classList.remove("active");
       });
      }
      if (layerModal) {
       layerModal.addEventListener("click", (e) => {
        if (e.target === layerModal) {
         layerModal.classList.remove("active");
        }
       });
      }
      
      ["physical", "logical", "security", "application"].forEach(layer => {
       const checkbox = document.getElementById(`layer-${layer}`);
       if (checkbox) {
        checkbox.addEventListener("change", applyLayerFilter);
       }
      });
            
      const tabsBtn = document.getElementById("tabs-btn");
      const tabsModal = document.getElementById("tabs-modal");
      const tabsModalClose = document.getElementById("tabs-modal-close");
      
      if (tabsBtn && tabsModal) {
        tabsBtn.addEventListener("click", () => {
          displayTabs();
          tabsModal.classList.add("active");
        });
      }
      
      if (tabsModalClose && tabsModal) {
        tabsModalClose.addEventListener("click", () => {
          tabsModal.classList.remove("active");
        });
      }
      
      if (tabsModal) {
        tabsModal.addEventListener("click", (e) => {
          if (e.target === tabsModal) {
            tabsModal.classList.remove("active");
          }
        });
      }
      
      const rollbackBtn = document.getElementById("rollback-btn");
      const rollbackModal = document.getElementById("rollback-modal");
      const rollbackModalClose = document.getElementById("rollback-modal-close");
      
      if (rollbackBtn && rollbackModal) {
        rollbackBtn.addEventListener("click", () => {
          loadRollbackVersions();
          rollbackModal.classList.add("active");
        });
      }
      
      if (rollbackModalClose && rollbackModal) {
        rollbackModalClose.addEventListener("click", () => {
          rollbackModal.classList.remove("active");
        });
      }
      
      if (rollbackModal) {
        rollbackModal.addEventListener("click", (e) => {
          if (e.target === rollbackModal) {
            rollbackModal.classList.remove("active");
          }
        });
      }
      
      const auditLogBtn = document.getElementById("audit-log-btn");
      const auditLogModal = document.getElementById("audit-log-modal");
      const auditLogModalClose = document.getElementById("audit-log-modal-close");
      const auditFilter = document.getElementById("audit-filter");
      
      if (auditLogBtn && auditLogModal) {
        auditLogBtn.addEventListener("click", () => {
          loadAuditLog();
          displayAuditLog();
          auditLogModal.classList.add("active");
        });
      }
      
      if (auditFilter) {
        auditFilter.addEventListener("change", (e) => {
          displayAuditLog(e.target.value);
        });
      }
      
      if (auditLogModalClose && auditLogModal) {
        auditLogModalClose.addEventListener("click", () => {
          auditLogModal.classList.remove("active");
        });
      }
      
      if (auditLogModal) {
        auditLogModal.addEventListener("click", (e) => {
          if (e.target === auditLogModal) {
            auditLogModal.classList.remove("active");
          }
        });
      }
      
      const secretsBtn = document.getElementById("secrets-btn");
      const secretsModal = document.getElementById("secrets-modal");
      const secretsModalClose = document.getElementById("secrets-modal-close");
      const secretEditorModal = document.getElementById("secret-editor-modal");
      
      if (secretsBtn && secretsModal) {
        secretsBtn.addEventListener("click", () => {
          displaySecrets();
          secretsModal.classList.add("active");
        });
      }
      
      if (secretsModalClose && secretsModal) {
        secretsModalClose.addEventListener("click", () => {
          secretsModal.classList.remove("active");
        });
      }
      
      if (secretsModal) {
        secretsModal.addEventListener("click", (e) => {
          if (e.target === secretsModal) {
            secretsModal.classList.remove("active");
          }
        });
      }
      
      if (secretEditorModal) {
        secretEditorModal.addEventListener("click", (e) => {
          if (e.target === secretEditorModal) {
            closeSecretEditor();
          }
        });
      }
      
      loadAuditLog();
      setupDragToCreate();
      
      ["physical", "logical", "security", "application"].forEach(layer => {
       const checkbox = document.getElementById(`layer-${layer}`);
       if (checkbox) {
        checkbox.addEventListener("change", applyLayerFilter);
       }
      });
      
      const layerSelect = document.getElementById("node-layer");
      if (layerSelect) {
       layerSelect.addEventListener("change", (e) => {
        if (currentNodeId) {
         pushUndo("change layer");
         NODE_DATA[currentNodeId].layer = e.target.value;
         forgeTheTopology();
        }
       });
      }
      
       const assignedRackSelect = document.getElementById("node-assigned-rack");
       if (assignedRackSelect) {
      assignedRackSelect.addEventListener("change", (e) => {
      if (currentNodeId) {
      pushUndo("change assigned rack");
      EDGE_DATA.list = EDGE_DATA.list.filter(edge => edge.from !== currentNodeId && edge.to !== currentNodeId);
      NODE_DATA[currentNodeId].assignedRack = e.target.value;
      forgeTheTopology();
      claimTheImmortal(currentNodeId);
      }
      });
       }
      
      const rackCapacitySelect = document.getElementById("node-rack-capacity");
      if (rackCapacitySelect) {
       rackCapacitySelect.addEventListener("change", (e) => {
        if (currentNodeId) {
         pushUndo("change rack capacity");
         NODE_DATA[currentNodeId].rackCapacity = e.target.value;
         forgeTheTopology();
        }
       });
      }
      
      const bulkToolbarClose = document.getElementById("bulk-toolbar-close");
      if (bulkToolbarClose) {
       bulkToolbarClose.addEventListener("click", clearSelection);
      }
      
      const bulkAlignLeft = document.getElementById("bulk-align-left");
      if (bulkAlignLeft) {
       bulkAlignLeft.addEventListener("click", () => alignSelectedNodes("left"));
      }
      
      const bulkAlignRight = document.getElementById("bulk-align-right");
      if (bulkAlignRight) {
       bulkAlignRight.addEventListener("click", () => alignSelectedNodes("right"));
      }
      
      const bulkAlignTop = document.getElementById("bulk-align-top");
      if (bulkAlignTop) {
       bulkAlignTop.addEventListener("click", () => alignSelectedNodes("top"));
      }
      
      const bulkAlignBottom = document.getElementById("bulk-align-bottom");
      if (bulkAlignBottom) {
       bulkAlignBottom.addEventListener("click", () => alignSelectedNodes("bottom"));
      }
      
      const bulkDistributeH = document.getElementById("bulk-distribute-h");
      if (bulkDistributeH) {
       bulkDistributeH.addEventListener("click", () => distributeSelectedNodes("horizontal"));
      }
      
      const bulkDistributeV = document.getElementById("bulk-distribute-v");
      if (bulkDistributeV) {
       bulkDistributeV.addEventListener("click", () => distributeSelectedNodes("vertical"));
      }
      
      const bulkClone = document.getElementById("bulk-clone");
      if (bulkClone) {
       bulkClone.addEventListener("click", () => {
        if (selectedNodes.size === 0) return;
        pushUndo("clone selected");
        const nodesToClone = Array.from(selectedNodes);
        selectedNodes.clear();
        nodesToClone.forEach(id => {
         cloneNode(id);
         selectedNodes.add(currentNodeId);
        });
        updateNodeSelection();
       });
      }
      
      const bulkDelete = document.getElementById("bulk-delete");
      if (bulkDelete) {
       bulkDelete.addEventListener("click", deleteSelected);
      }
      
      const bulkMobileBtn = document.getElementById("bulk-mobile-btn");
      const bulkActionsModal = document.getElementById("bulk-actions-modal");
      const bulkModalClose = document.getElementById("bulk-modal-close");
      
      if (bulkMobileBtn) {
       bulkMobileBtn.addEventListener("click", () => {
        if (bulkActionsModal) bulkActionsModal.style.display = "block";
       });
      }
      
      if (bulkModalClose) {
       bulkModalClose.addEventListener("click", () => {
        if (bulkActionsModal) bulkActionsModal.style.display = "none";
       });
      }
      
      const closeModalAfterAction = () => {
       if (bulkActionsModal) bulkActionsModal.style.display = "none";
      };
      
      const bulkAlignLeftMobile = document.getElementById("bulk-align-left-mobile");
      if (bulkAlignLeftMobile) {
       bulkAlignLeftMobile.addEventListener("click", () => {
        alignSelectedNodes("left");
        closeModalAfterAction();
       });
      }
      
      const bulkAlignRightMobile = document.getElementById("bulk-align-right-mobile");
      if (bulkAlignRightMobile) {
       bulkAlignRightMobile.addEventListener("click", () => {
        alignSelectedNodes("right");
        closeModalAfterAction();
       });
      }
      
      const bulkAlignTopMobile = document.getElementById("bulk-align-top-mobile");
      if (bulkAlignTopMobile) {
       bulkAlignTopMobile.addEventListener("click", () => {
        alignSelectedNodes("top");
        closeModalAfterAction();
       });
      }
      
      const bulkAlignBottomMobile = document.getElementById("bulk-align-bottom-mobile");
      if (bulkAlignBottomMobile) {
       bulkAlignBottomMobile.addEventListener("click", () => {
        alignSelectedNodes("bottom");
        closeModalAfterAction();
       });
      }
      
      const bulkDistributeHMobile = document.getElementById("bulk-distribute-h-mobile");
      if (bulkDistributeHMobile) {
       bulkDistributeHMobile.addEventListener("click", () => {
        distributeSelectedNodes("horizontal");
        closeModalAfterAction();
       });
      }
      
      const bulkDistributeVMobile = document.getElementById("bulk-distribute-v-mobile");
      if (bulkDistributeVMobile) {
       bulkDistributeVMobile.addEventListener("click", () => {
        distributeSelectedNodes("vertical");
        closeModalAfterAction();
       });
      }
      
      const bulkCloneMobile = document.getElementById("bulk-clone-mobile");
      if (bulkCloneMobile) {
       bulkCloneMobile.addEventListener("click", () => {
        if (selectedNodes.size === 0) return;
        pushUndo("clone selected");
        const nodesToClone = Array.from(selectedNodes);
        selectedNodes.clear();
        nodesToClone.forEach(id => {
         cloneNode(id);
         selectedNodes.add(currentNodeId);
        });
        updateNodeSelection();
        closeModalAfterAction();
       });
      }
      
      const bulkDeleteMobile = document.getElementById("bulk-delete-mobile");
      if (bulkDeleteMobile) {
       bulkDeleteMobile.addEventListener("click", () => {
        deleteSelected();
        closeModalAfterAction();
       });
      }
      
      const bulkLockMobile = document.getElementById("bulk-lock-mobile");
      if (bulkLockMobile) {
       bulkLockMobile.addEventListener("click", () => {
        toggleLockSelected();
        closeModalAfterAction();
       });
      }
      
      const bulkGroupMobile = document.getElementById("bulk-group-mobile");
      if (bulkGroupMobile) {
       bulkGroupMobile.addEventListener("click", () => {
        toggleGroupSelected();
        closeModalAfterAction();
       });
      }
      
      const bulkClearMobile = document.getElementById("bulk-clear-mobile");
      if (bulkClearMobile) {
       bulkClearMobile.addEventListener("click", () => {
        clearSelection();
        closeModalAfterAction();
       });
      }
      
      const searchInput = document.getElementById("search-nodes");
      if (searchInput) {
       searchInput.addEventListener("input", (e) => {
        searchNodes(e.target.value);
       });
      }
      
      addNodeBtn.addEventListener("click", () => {
       document.getElementById("new-node-name").value = "";
       document.getElementById("new-node-ip").value = "";
       document.getElementById("new-node-tags").value = "";
       document.getElementById("new-node-shape").value = "circle";
       addNodeModal.classList.add("active");
       document.getElementById("new-node-name").focus();
      });
      
      const addRackBtn = document.getElementById("add-rack-btn");
      const addRackModal = document.getElementById("add-rack-modal");
      const addRackCancel = document.getElementById("add-rack-cancel");
      const addRackSave = document.getElementById("add-rack-save");
      
      if (addRackBtn && addRackModal) {
       addRackBtn.addEventListener("click", () => {
        document.getElementById("new-rack-name").value = "";
        document.getElementById("new-rack-ip").value = "";
        document.getElementById("new-rack-tags").value = "";
        document.getElementById("new-rack-shape").value = "server";
        document.getElementById("new-rack-capacity").value = "42";
        addRackModal.classList.add("active");
        document.getElementById("new-rack-name").focus();
       });
      }
      
      if (addRackCancel && addRackModal) {
       addRackCancel.addEventListener("click", () => {
        addRackModal.classList.remove("active");
       });
      }
      
      if (addRackModal) {
       addRackModal.addEventListener("click", (e) => {
        if (e.target === addRackModal) {
         addRackModal.classList.remove("active");
        }
       });
      }
      
      if (addRackSave && addRackModal) {
       addRackSave.addEventListener("click", () => {
        const name = document.getElementById("new-rack-name").value.trim();
        const ip = document.getElementById("new-rack-ip").value.trim();
        const tagsStr = document.getElementById("new-rack-tags").value.trim();
        const shape = document.getElementById("new-rack-shape").value;
        const capacity = document.getElementById("new-rack-capacity").value;
        
        if (!name) {
         alert("Please enter a rack name.");
         return;
        }
        
        const tags = tagsStr ? tagsStr.split(",").map((t) => t.trim()).filter((t) => t) : [];
        let baseId = name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");
        if (!baseId) baseId = "rack";
        let nodeId = baseId;
        let counter = 1;
        while (NODE_DATA[nodeId]) {
         nodeId = baseId + "-" + counter;
         counter++;
        }
        
        pushUndo("add rack");
        
        NODE_DATA[nodeId] = {
         shape: shape,
         name: name,
         ip: ip || "",
         role: "Rack",
         tags: tags,
         notes: [],
         mac: "",
         rackUnit: "",
         uHeight: "1",
         layer: "physical",
         assignedRack: "",
         rackCapacity: capacity,
         isRack: true,  
         locked: false, 
         groupId: null 
        };
        
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        const centerX = canvasState.panX + (viewWidth / 2);
        const centerY = canvasState.panY + (viewHeight / 2);
        savedPositions[nodeId] = {
         x: centerX,
         y: centerY
        };
        
        addRackModal.classList.remove("active");
        forgeTheTopology();
        claimTheImmortal(nodeId);
       });
       
       ["new-rack-name", "new-rack-ip", "new-rack-tags"].forEach((inputId) => {
        const input = document.getElementById(inputId);
        if (input) {
         input.addEventListener("keypress", (e) => {
          if (e.key === "Enter") {
           addRackSave.click();
          }
         });
        }
       });
      }
      
      addNodeCancel.addEventListener("click", () => {
       addNodeModal.classList.remove("active");
      });
      addNodeModal.addEventListener("click", (e) => {
       if (e.target === addNodeModal) {
        addNodeModal.classList.remove("active");
       }
      });
      addNodeSave.addEventListener("click", () => {
       const name = document.getElementById("new-node-name").value.trim();
       const ip = document.getElementById("new-node-ip").value.trim();
       const tagsStr = document.getElementById("new-node-tags").value.trim();
       const shape = document.getElementById("new-node-shape").value;
       if (!name) {
        alert("Please enter a node name.");
        return;
       }
       const tags = tagsStr ? tagsStr.split(",").map((t) => t.trim()).filter((t) => t) : [];
       let baseId = name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");
       if (!baseId) baseId = "node";
       let nodeId = baseId;
       let counter = 1;
       while (NODE_DATA[nodeId]) {
        nodeId = baseId + "-" + counter;
        counter++;
       }
       NODE_DATA[nodeId] = {
        shape: shape || "circle",
        name: name,
        ip: ip || "0.0.0.0",
        role: "",
        tags: tags,
        notes: [],
        mac: "",
        rackUnit: "",
        uHeight: "1",
        layer: "physical",
        assignedRack: "",  
        rackCapacity: "42",
        isRack: false, 
        locked: false, 
        groupId: null 
       };
       
       if (currentView.mode === "rack" && currentView.rackId) {
        NODE_DATA[nodeId].assignedRack = currentView.rackId;
       }
       
      const viewWidth = CANVAS_WIDTH / canvasState.zoom;
      const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
      const centerX = canvasState.panX + (viewWidth / 2);
      const centerY = canvasState.panY + (viewHeight / 2);
      savedPositions[nodeId] = {
      x: centerX,
      y: centerY
      };
       pushUndo("add node");
       addNodeModal.classList.remove("active");
       forgeTheTopology();
       claimTheImmortal(nodeId);
      });
      ["new-node-name", "new-node-ip", "new-node-tags"].forEach(
       (inputId) => {
        document.getElementById(inputId).addEventListener("keypress", (e) => {
         if (e.key === "Enter") {
          addNodeSave.click();
         }
        });
       }, );
      const clearAllBtn = document.getElementById("clear-all-btn");
      const clearAllModal = document.getElementById("clear-all-modal");
      const clearAllCancel = document.getElementById("clear-all-cancel");
      const clearAllConfirm = document.getElementById("clear-all-confirm");
      clearAllBtn.addEventListener("click", () => {
       clearAllModal.classList.add("active");
      });
      clearAllCancel.addEventListener("click", () => {
       clearAllModal.classList.remove("active");
      });
      clearAllModal.addEventListener("click", (e) => {
       if (e.target === clearAllModal) {
        clearAllModal.classList.remove("active");
       }
      });
      clearAllConfirm.addEventListener("click", () => {
       NODE_DATA = {};
       EDGE_DATA = {
        list: []
       };
       EDGE_LEGEND = {};
       RECT_DATA = { list: [] };
       TEXT_DATA = { list: [] };
       savedPositions = {};
       savedSizes = {};
       savedStyles = {};
       clearAllModal.classList.remove("active");
       forgeTheTopology();
       document.getElementById("node-panel").style.display = "none";
       document.getElementById("edge-panel").style.display = "none";
       document.getElementById("text-panel").style.display = "none";
       document.getElementById("topology-toolbar").style.display = "none";
       currentNodeId = null;
       currentEdgeId = null;
       currentTextId = null;
      });
      (function addDeleteNodeButton() {
       const nodePanel = document.getElementById("node-panel");
       if (!nodePanel) return;
       if (document.getElementById("delete-node-btn")) return;
       const deleteBtn = document.createElement("button");
       deleteBtn.id = "delete-node-btn";
       deleteBtn.textContent = "Delete Node";
       deleteBtn.style.cssText = "margin-top:15px; padding:10px 16px; background:var(--danger); color:#fff; border:none; border-radius:6px; cursor:pointer; font-size:clamp(14px,1.6vw,18px); font-weight:600; width:100%;";
       deleteBtn.addEventListener("click", () => {
        if (!currentNodeId) return;
        challengeTheImmortal(`Delete node "${NODE_DATA[currentNodeId]?.name || currentNodeId}" and all its connections?`,
         () => {
          EDGE_DATA.list = EDGE_DATA.list.filter(
           (e) => e.from !== currentNodeId && e.to !== currentNodeId, );
          delete NODE_DATA[currentNodeId];
          delete savedPositions[currentNodeId];
          delete savedSizes[currentNodeId];
          delete savedStyles[currentNodeId];
          currentNodeId = null;
          currentEdgeId = null;
          forgeTheTopology();
          const remainingNodes = Object.keys(NODE_DATA);
          if (remainingNodes.length > 0) {
           claimTheImmortal(remainingNodes[0]);
          } else {
           document.getElementById("node-panel").style.display = "none";
           document.getElementById("edge-panel").style.display = "none";
           document.getElementById("topology-toolbar", ).style.display = "none";
          }
         }, );
       });
       nodePanel.appendChild(deleteBtn);
      })();
      
      function screenshotCanvas() {
       const svg = document.getElementById("map");
       const svgClone = svg.cloneNode(true);
       const viewBox = svg.getAttribute("viewBox").split(" ").map(Number);
       const [x, y, width, height] = viewBox;
       svgClone.setAttribute("width", width);
       svgClone.setAttribute("height", height);
       svgClone.setAttribute("viewBox", `${x} ${y} ${width} ${height}`);
       const wrapper = document.createElement("div");
       wrapper.style.position = "absolute";
       wrapper.style.left = "-9999px";
       wrapper.appendChild(svgClone);
       document.body.appendChild(wrapper);
      
       function inlineStyles(original, clone) {
        const elements = original.querySelectorAll("*");
        const clonedElements = clone.querySelectorAll("*");
        const rootStyles = getComputedStyle(document.documentElement);
        const bgColor = rootStyles.getPropertyValue("--bg").trim() || "#050608";
        const bgRect = document.createElementNS("http://www.w3.org/2000/svg", "rect", );
        bgRect.setAttribute("x", x);
        bgRect.setAttribute("y", y);
        bgRect.setAttribute("width", width);
        bgRect.setAttribute("height", height);
        bgRect.setAttribute("fill", bgColor);
        clone.insertBefore(bgRect, clone.firstChild);
        elements.forEach((el, index) => {
         const clonedEl = clonedElements[index];
         if (!clonedEl) return;
         const computedStyle = getComputedStyle(el);
         const svgProps = ["fill", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin", "opacity", "font-family", "font-size", "font-weight", "font-style", "text-anchor", "dominant-baseline", "marker-start", "marker-end", ];
         svgProps.forEach((prop) => {
          const value = computedStyle.getPropertyValue(prop);
          if (value && value !== "none" && value !== "normal") {
           clonedEl.style[prop] = value;
          }
         });
         clonedEl.removeAttribute("class");
        });
       }
       inlineStyles(svg, svgClone);
       const svgData = new XMLSerializer().serializeToString(svgClone);
       document.body.removeChild(wrapper);
       const svgBlob = new Blob([svgData], {
        type: "image/svg+xml;charset=utf-8",
       });
       const url = URL.createObjectURL(svgBlob);
       const img = new Image();
       img.onload = function() {
        const canvas = document.createElement("canvas");
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext("2d");
        ctx.drawImage(img, 0, 0);
        canvas.toBlob(function(blob) {
         const link = document.createElement("a");
         const timestamp = new Date().toISOString().slice(0, 10);
         link.download = `topology-${timestamp}.png`;
         link.href = URL.createObjectURL(blob);
         link.click();
         URL.revokeObjectURL(url);
         URL.revokeObjectURL(link.href);
        }, "image/png");
       };
       img.onerror = function() {
        console.error("Failed to load SVG image");
        alert("Screenshot failed. Please try again.");
        URL.revokeObjectURL(url);
       };
       img.src = url;
      }
      
      function exportCanvasSVG() {
       const svg = document.getElementById("map");
       const svgClone = svg.cloneNode(true);
       const viewBox = svg.getAttribute("viewBox").split(" ").map(Number);
       const [x, y, width, height] = viewBox;
       svgClone.setAttribute("width", width);
       svgClone.setAttribute("height", height);
       const rootStyles = getComputedStyle(document.documentElement);
       const bgColor = rootStyles.getPropertyValue("--bg").trim() || "#050608";
       const bgRect = document.createElementNS("http://www.w3.org/2000/svg", "rect", );
       bgRect.setAttribute("x", x);
       bgRect.setAttribute("y", y);
       bgRect.setAttribute("width", width);
       bgRect.setAttribute("height", height);
       bgRect.setAttribute("fill", bgColor);
       svgClone.insertBefore(bgRect, svgClone.firstChild);
       const wrapper = document.createElement("div");
       wrapper.style.position = "absolute";
       wrapper.style.left = "-9999px";
       wrapper.appendChild(svgClone);
       document.body.appendChild(wrapper);
       const elements = svg.querySelectorAll("*");
       const clonedElements = svgClone.querySelectorAll("*");
       elements.forEach((el, index) => {
        const clonedEl = clonedElements[index];
        if (!clonedEl) return;
        const computedStyle = getComputedStyle(el);
        const svgProps = ["fill", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin", "opacity", "font-family", "font-size", "font-weight", "font-style", "text-anchor", "dominant-baseline", "marker-start", "marker-end", ];
        svgProps.forEach((prop) => {
         const value = computedStyle.getPropertyValue(prop);
         if (value && value !== "none" && value !== "normal") {
          clonedEl.setAttribute(prop, value);
         }
        });
        clonedEl.removeAttribute("class");
       });
       const svgData = new XMLSerializer().serializeToString(svgClone);
       document.body.removeChild(wrapper);
       const blob = new Blob([svgData], {
        type: "image/svg+xml;charset=utf-8",
       });
       const url = URL.createObjectURL(blob);
       const link = document.createElement("a");
       const timestamp = new Date().toISOString().slice(0, 10);
       link.download = `topology-${timestamp}.svg`;
       link.href = url;
       link.click();
       URL.revokeObjectURL(url);
      }
      let resizeTimeout;
       window.addEventListener('resize', () => {
       clearTimeout(resizeTimeout);
       resizeTimeout = setTimeout(() => {
       updateDrawToolbarVisibility();
       updateTopologyToolbarVisibility();
       }, 100);
      });
    </script>
  
</body></html>