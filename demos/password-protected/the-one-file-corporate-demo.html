<!DOCTYPE html> 
 <html lang="en" style="--panel: #3c536d; --panel-alt: #202731; --sidebar-bg: #10141b; --btn-bg: #0b0e13; --accent: #ffffff; --danger: #e6c665; --text-main: #ffffff; --text-soft: #dcb7b7; --topbar-bg: #8599ff; --topbar-border: #000000; --topbar-height: 100px; --sidebar-width: 435px; --mobile-footer-height: 20vh; --draw-toolbar-height: 0px; --btn-text: #e2e8f0; --tag-fill: #1e293b; --tag-text: #e2e8f0; --tag-border: #475569; --input-bg: #0b0e13; --input-text: #e2e8f0; --input-border: #1f2937; --input-font: Inter, system-ui, sans-serif; --input-font-size: 14px; --toolbar-bg: #0f172a; --toolbar-border: #1f2937; --toolbar-text: #94a3b8; --toolbar-btn-bg: #0b0e13; --toolbar-btn-text: #e2e8f0; --minimap-dots: #94a3b8; --canvas-hint-bg: #0f172a; --canvas-hint-color: #94a3b8; --node-fill: #344156; --node-stroke: #ffffff; --node-title: #e2e8f0; --node-sub: #94a3b8; --node-title-size: 40px; --node-sub-size: 31px; --node-font: Helvetica, sans-serif; --default-edge: #475569; --selection-handle: #f59e0b; --selection-handle-size: 8px; --group-indicator: #4fd1c5;"><head>
    <meta charset="UTF-8">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Corporate</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- 
      * ====================================================================================
      * THE ONE FILE
      * "There can be only one". A all in one file topology maker for enterprise or homelab
      * 
      * This is your last backup when all others fail. A completely self-contained
      * network topology visualization tool that works as a single HTML file.
      * Open it anywhere, anytime and the idea lives forever.
      * ====================================================================================
      -->
    <style>
      :root {
      color-scheme: dark;
      --bg: #050608;
      --panel: #0b0e13;
      --panel-alt: #10141b;
      --accent: #4fd1c5;
      --danger: #f56565;
      --text-main: #e2e8f0;
      --text-soft: #94a3b8;
      --edge-main: #475569;
      --node-min: 35px;
      --node-max: 70px;
      --topbar-bg: rgba(9, 12, 20, 0.9);
      --topbar-border: #1f2533;
      }
      * {
      box-sizing: border-box;
      user-select: none;
      }
      input,
      textarea,
      [contenteditable="true"] {
      user-select: text;
      -webkit-user-select: text;
      }
      body {
      margin: 0;
      font-family: system-ui, sans-serif;
      background: radial-gradient(circle at top, #1e2532 0, #050608 70%);
      color: var(--text-main);
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
      }
      header {
      padding: 0 20px;
      height: var(--topbar-height, 52px);
      min-height: var(--topbar-height, 52px);
      background: var(--topbar-bg);
      backdrop-filter: blur(6px);
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid var(--topbar-border);
      gap: 16px;
      }
      .title-block {
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-width: 0;
      }
      header h1 {
      font-size: clamp(22px, 3vw, 32px);
      margin: 0;
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
      }
      .editable-page-title {
      cursor: pointer;
      transition: opacity 0.2s;
      }
      .editable-page-title:hover {
      opacity: 0.7;
      }
      .save-row {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      }
      .save-btn {
      padding: 6px 12px;
      background: var(--accent);
      color: var(--bg);
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      white-space: nowrap;
      }
      .save-btn:hover {
      opacity: 0.9;
      }
      .help-icon {
      width: 22px;
      height: 22px;
      border-radius: 50%;
      border: 1px solid var(--edge-main);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      cursor: pointer;
      color: var(--text-soft);
      background: rgba(15, 23, 42, 0.9);
      flex-shrink: 0;
      }
      .help-icon:hover {
      color: var(--accent);
      border-color: var(--accent);
      }
      #settings-btn {
      background: var(--btn-bg, var(--panel));
      color: var(--btn-text, var(--text-main));
      border: 1px solid var(--edge-main);
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 16px;
      flex-shrink: 0;
      }
      #settings-btn:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .header-resizer {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 6px;
      background: transparent;
      cursor: row-resize;
      z-index: 1000;
      transition: background 0.2s;
      }
      .header-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .header-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      .sidebar-resizer {
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 6px;
      background: transparent;
      cursor: col-resize;
      z-index: 1000;
      transition: background 0.2s;
      }
      .sidebar-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .sidebar-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      .mobile-footer-resizer {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 6px;
      background: transparent;
      cursor: row-resize;
      z-index: 1000;
      transition: background 0.2s;
      display: none;
      }
      .mobile-footer-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .mobile-footer-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      @media (max-width: 900px) {
      .mobile-footer-resizer {
      display: block;
      height: 12px;
      }
      .sidebar-resizer {
      display: none;
      }
      .header-resizer {
      height: 12px;
      }
      }
      @media (pointer: coarse) {
      .header-resizer {
      height: 16px;
      }
      .mobile-footer-resizer {
      height: 16px;
      }
      .sidebar-resizer {
      width: 16px;
      }
      }
      .resizer-icon {
      position: absolute;
      opacity: 0.5;
      transition: opacity 0.2s, transform 0.2s;
      pointer-events: none;
      fill: var(--accent);
      }
      .header-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .sidebar-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .mobile-footer-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .header-resizer:hover .resizer-icon,
      .sidebar-resizer:hover .resizer-icon,
      .mobile-footer-resizer:hover .resizer-icon {
      opacity: 1;
      }
      .header-resizer.resizing .resizer-icon,
      .sidebar-resizer.resizing .resizer-icon,
      .mobile-footer-resizer.resizing .resizer-icon {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1.2);
      }
      body.resizing {
      user-select: none;
      }
      body.resizing * {
      cursor: inherit !important;
      pointer-events: none;
      }
      header {
      position: relative;
      }
      .details-panel {
      position: relative;
      }
      main {
      display: grid;
      grid-template-columns: 1fr var(--sidebar-width, 350px);
      flex: 1;
      }
      main.sidebar-collapsed {
      grid-template-columns: 1fr 0;
      }
      @media (max-width: 900px) {
      main {
      grid-template-columns: 1fr;
      grid-template-rows: calc(100vh - var(--topbar-height, 52px) - var(--mobile-footer-height, 40vh)) var(--mobile-footer-height, 40vh);
      }
      main.sidebar-collapsed {
      grid-template-rows: 1fr 0;
      }
      .details-panel {
      max-height: var(--mobile-footer-height, 40vh);
      height: 100%;
      }
      }
      .topology-panel {
      background: var(--panel);
      border-right: 1px solid #111827;
      position: relative;
      overflow: hidden;
      }
      .topology-toolbar {
      position: absolute;
      top: 10px;
      right: 10px;
      display: none;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      z-index: 99;
      font-size: 13px;
      color: var(--toolbar-text, #94a3b8);
      }
      .topology-toolbar label {
      color: var(--toolbar-text, var(--text-soft));
      }
      .topology-toolbar select {
      padding: 4px 6px;
      background: var(--toolbar-btn-bg, var(--panel));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 13px;
      cursor: pointer;
      }
      .topology-toolbar button {
      padding: 4px 10px;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      }
      .topology-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .bulk-toolbar-desktop,
      .bulk-toolbar-mobile {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 9999;
      }
      .bulk-toolbar-desktop {
      position: absolute;
      top: 10px;
      right: 10px;
      bottom: auto;
      left: auto;
      transform: none;
      }
      @media (min-width: 768px) {
      .bulk-toolbar-mobile {
      display: none !important;
      }
      }	  
      .bulk-action-btn {
      padding: 16px;
      background: var(--panel-main);
      border: 1px solid var(--edge-main);
      border-radius: 8px;
      color: var(--text-main);
      font-size: 24px;
      cursor: pointer;
      text-align: center;
      line-height: 1.2;
      }
      .bulk-action-btn:active {
      transform: scale(0.95);
      background: var(--accent);
      }
      .draw-toolbar {
      position: absolute;
      top: 10px;
      left: 10px;
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 8px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      z-index: 99;
      font-size: 13px;
      pointer-events: auto;
      color: var(--toolbar-text, #94a3b8);
      }
      .draw-toolbar button {
      padding: 4px 8px;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      }
      .draw-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .draw-toolbar input[type="color"] {
      width: 30px;
      height: 22px;
      border-radius: 4px;
      border: 1px solid var(--edge-main);
      padding: 0;
      background: transparent;
      cursor: pointer;
      }
      .draw-toolbar select {
      padding: 4px 6px;
      background: var(--toolbar-btn-bg, var(--panel));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 13px;
      cursor: pointer;
      }
      .legend-container {
      position: absolute;
      left: 10px;
      bottom: 10px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      padding: 8px 10px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      font-size: 12px;
      z-index: 20;
      max-width: 260px;
      pointer-events: auto;
      color: var(--toolbar-text, #94a3b8);
      }
      .legend-container {
      padding-right: 22px;
      }
      @media (max-width: 900px) {
      .legend-container {
      height:250px;
      overflow-y: auto;
      z-index:99;
      }
      }
      @media (max-width: 900px) {
      .bulk-toolbar-desktop,
      .topology-toolbar {
      display: none !important;
      }
      }
      .legend-close-btn {
      position: absolute;
      top: 5px;
      right: 5px;
      width: 18px;
      height: 18px;
      border-radius: 999px;
      border: 1px solid var(--edge-main);
      background: var(--panel-alt);
      color: var(--text-soft);
      font-size: 11px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      }
      .legend-close-btn:hover {
      background: var(--danger);
      color: #fff;
      }
      .legend-mini-btn {
      position: absolute;
      left: 10px;
      padding: 4px 8px;
      border-radius: 4px;
      border: 1px solid var(--toolbar-border, #1f2937);
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 11px;
      cursor: pointer;
      z-index: 20;
      display: none;
      transition: all 0.2s;
      }
      .legend-mini-btn:hover,
      .legend-mini-btn:active {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
      }
      .legend-title {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: var(--toolbar-text, var(--text-soft));
      margin-bottom: 2px;
      }
      .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      }
      .legend-swatch {
      width: 14px;
      height: 14px;
      border-radius: 3px;
      border: 1px solid #020617;
      flex-shrink: 0;
      }
      .legend-label {
      outline: none;
      cursor: text;
      flex: 1;
      min-width: 60px;
      user-select: text;
      -webkit-user-select: text;
      }
      .legend-label.editing {
      border-bottom: 1px dashed var(--accent);
      }
      .canvas-viewport {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      overflow: hidden;
      }
      .canvas-viewport.panning {
      cursor: grabbing !important;
      }
      .canvas-viewport.panning * {
      cursor: grabbing !important;
      }
      .canvas-viewport svg {
      width: 100%;
      height: 100%;
      display: block;
      background: linear-gradient(rgba(71, 85, 105, 0.1) 1px,
      transparent 1px),
      linear-gradient(90deg,
      rgba(71, 85, 105, 0.1) 1px,
      transparent 1px),
      linear-gradient(rgba(71, 85, 105, 0.05) 1px, transparent 1px),
      linear-gradient(90deg,
      rgba(71, 85, 105, 0.05) 1px,
      transparent 1px);
      background-size:
      100px 100px,
      100px 100px,
      20px 20px,
      20px 20px;
      background-position:
      -1px -1px,
      -1px -1px,
      -1px -1px,
      -1px -1px;
      }
      .zoom-toolbar {
      display: flex;
      gap: 4px;
      padding: 6px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      }
      .zoom-toolbar button {
      width: 32px;
      height: 32px;
      padding: 0;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 18px;
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
      }
      .zoom-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .zoom-toolbar .zoom-level {
      font-size: 11px;
      color: var(--toolbar-text, var(--text-soft));
      text-align: center;
      padding: 2px 0;
      min-width: 32px;
      }
      .zoom-toolbar .divider {
      height: 1px;
      background: var(--toolbar-border, var(--edge-main));
      margin: 2px 0;
      }
      .minimap-zoom-wrapper {
      position: absolute;
      bottom: 10px;
      right: 10px;
      z-index: 99;
      }
      .minimap-container {
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      overflow: hidden;
      margin-bottom: 4px;
      }
      .minimap-container svg {
      width: 100%;
      height: 100%;
      }
      .minimap-viewport {
      fill: rgba(79, 209, 197, 0.2);
      stroke: var(--accent);
      stroke-width: 2;
      cursor: move;
      }
      .minimap-node {
      fill: var(--minimap-dots, var(--text-soft));
      }
      .minimap-edge {
      stroke: var(--edge-main);
      stroke-width: 1;
      }
      .minimap-close-btn {
      position: absolute;
      top: 2px;
      right: 2px;
      width: 18px;
      height: 18px;
      background: var(--toolbar-btn-bg, rgba(15, 23, 42, 0.9));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 3px;
      color: var(--toolbar-text, var(--text-soft));
      font-size: 11px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
      padding: 0;
      line-height: 1;
      }
      .minimap-close-btn:hover {
      background: var(--danger);
      color: white;
      border-color: var(--danger);
      }
      .toolbar-close-btn {
      width: 24px;
      height: 24px;
      background: var(--toolbar-btn-bg, rgba(15, 23, 42, 0.9));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-text, var(--text-soft));
      font-size: 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      line-height: 1;
      flex-shrink: 0;
      }
      .toolbar-close-btn:hover {
      background: var(--danger);
      color: white;
      border-color: var(--danger);
      }
      .canvas-hint {
      position: absolute;
      top: 50px;
      left: 50%;
      transform: translateX(-50%);
      padding: 8px 16px;
      background: rgba(15, 23, 42, 0.92);
      border: 1px solid #1f2937;
      border-radius: 6px;
      font-size: 12px;
      color: var(--text-soft);
      z-index: 18;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
      }
      .canvas-hint.visible {
      opacity: 1;
      }
      .edge {
      stroke: var(--edge-main);
      stroke-width: 4;
      opacity: 0.75;
      transition: 0.25s ease-in-out;
      cursor: pointer;
      }
      .edge.backup {
      stroke: var(--danger);
      stroke-width: 5;
      }
      .edge.active {
      opacity: 1;
      stroke-width: 7;
      }
      .free-preview {
      fill: none;
      stroke-dasharray: 4 4;
      pointer-events: none;
      }
      .free-point {
      fill: #e5e7eb;
      stroke: #0f172a;
      stroke-width: 1.5;
      cursor: grab;
      }
      .node-circle {
      fill: var(--node-fill, #1e293b);
      stroke: var(--node-stroke, #475569);
      stroke-width: 2;
      transition: 0.25s ease;
      transform-origin: center center;
      }
      .node-hit-area {
      cursor: grab;
      pointer-events: all;
      }
      .node-group:hover .node-circle {
      filter: drop-shadow(0 0 10px rgba(79, 209, 197, 0.45));
      }
      .node-group.active .node-circle {
      stroke: var(--accent);
      animation: pulse 1.2s infinite ease-in-out;
      }
      .node-group.selected .node-circle {
      stroke: var(--selection-handle, #f59e0b);
      stroke-width: 3;
      }
      .node-group.search-highlight .node-circle {
      stroke: #10b981;
      stroke-width: 3;
      filter: drop-shadow(0 0 8px #10b981);
      }
      @keyframes pulse {
      0% {
      filter: drop-shadow(0 0 4px #4fd1c5);
      }
      50% {
      filter: drop-shadow(0 0 14px #4fd1c5);
      }
      100% {
      filter: drop-shadow(0 0 4px #4fd1c5);
      }
      }
      .node-label {
      fill: var(--text-main);
      font-size: 18px;
      text-anchor: middle;
      font-weight: 600;
      }
      .node-sub {
      fill: var(--text-soft);
      font-size: 13px;
      text-anchor: middle;
      }
      @media (max-width: 1024px) {
      .node-label {
      font-size: 28px;
      }
      .node-sub {
      font-size: 20px;
      }
      }
      @media (max-width: 768px) {
      .node-label {
      font-size: 70px;
      }
      .node-sub {
      font-size: 50px;
      }
      }
      @media (max-width: 380px) {
      .node-label {
      font-size: 60px;
      }
      .node-sub {
      font-size: 42px;
      }
      }
      .details-panel {
      background: var(--sidebar-bg, var(--panel-alt));
      padding: 22px;
      padding-bottom: 80px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 15px;
      position: relative;
      transition:
      width 0.3s ease,
      min-width 0.3s ease,
      padding 0.3s ease,
      opacity 0.3s ease;
      }
      .details-panel {
      min-width: 260px !important;
      }
      .details-panel {
      overflow-y: auto !important;
      overflow-x: hidden;
      }
      .details-panel.collapsed {
      width: 0 !important;
      min-width: 0 !important;
      padding: 0 !important;
      overflow: hidden;
      opacity: 0;
      }
      body {
      overflow-x: hidden;
      overflow-y: hidden;
      }
      main {
      overflow-x: hidden;
      overflow-y: visible;
      }
      .details-panel {
      overflow-y: auto !important;
      overflow-x: hidden;
      }
      .details-panel.collapsed {
      min-width: 0 !important;
      }
      .sidebar-toggle {
      position: absolute;
      left: -16px;
      top: 50%;
      transform: translateY(-50%);
      width: 16px;
      height: 60px;
      background: var(--sidebar-bg, var(--panel-alt));
      border: 1px solid var(--edge-main);
      border-right: none;
      border-radius: 8px 0 0 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text-soft);
      font-size: 10px;
      z-index: 25;
      transition:
      background 0.2s,
      color 0.2s;
      }
      .sidebar-toggle:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .sidebar-toggle.collapsed {
      left: 0;
      border-right: 1px solid var(--edge-main);
      border-radius: 0 8px 8px 0;
      position: fixed;
      right: 0;
      left: auto;
      }
      .details-name {
      font-size: clamp(22px, 2.5vw, 30px);
      font-weight: 700;
      }
      .details-ip {
      font-size: clamp(16px, 2vw, 22px);
      color: var(--text-soft);
      }
      .details-role {
      font-size: clamp(16px, 2vw, 22px);
      color: var(--accent);
      }
      .details-info-row {
      display: flex;
      align-items: center;
      margin: 6px 0;
      }
      .size-controls {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-top: 10px;
      }
      .size-controls label {
      font-size: clamp(14px, 1.6vw, 18px);
      color: var(--text-soft);
      }
      .size-controls input[type="range"] {
      flex: 1;
      accent-color: var(--accent);
      }
      .size-controls button {
      padding: 6px 12px;
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      font-size: clamp(12px, 1.4vw, 16px);
      }
      .size-controls button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .style-section {
      margin-top: 15px;
      padding-top: 15px;
      border-top: 1px solid var(--edge-main);
      }
      .style-section summary {
      cursor: pointer;
      font-size: clamp(14px, 1.6vw, 20px);
      text-transform: uppercase;
      color: var(--text-soft);
      list-style: none;
      display: flex;
      justify-content: space-between;
      align-items: center;
      user-select: none;
      }
      .style-section summary::-webkit-details-marker {
      display: none;
      }
      .password-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #ffffff;
      z-index: 9999;
      }
      .style-section summary::after {
      content: "â–¼";
      transition: transform 0.2s;
      }
      .style-section[open] summary::after {
      transform: rotate(180deg);
      }
      .style-content {
      margin-top: 10px;
      }
      .style-row {
      display: flex;
      gap: 10px;
      align-items: center;
      margin: 8px 0;
      }
      .style-row label {
      font-size: clamp(13px, 1.5vw, 17px);
      color: var(--text-soft);
      min-width: 80px;
      }
      .style-row input[type="color"] {
      width: 50px;
      height: 30px;
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      background: transparent;
      }
      .style-row input[type="number"] {
      width: 70px;
      padding: 4px 8px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(12px, 1.4vw, 16px);
      }
      .style-row select {
      flex: 1;
      padding: 4px 8px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(12px, 1.4vw, 16px);
      cursor: pointer;
      }
      .editable-text {
      cursor: pointer;
      transition: opacity 0.2s;
      }
      .editable-text:hover {
      opacity: 0.7;
      }
      .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 999999;
      justify-content: center;
      align-items: center;
      padding-top: var(--topbar-height, 52px);
      }
      .modal.active {
      display: flex;
      }
      .modal-content {
      background: var(--panel-alt);
      padding: 25px;
      border-radius: 8px;
      border: 1px solid var(--edge-main);
      min-width: 300px;
      max-width: 90%;
      max-height: calc(100vh - var(--topbar-height, 52px) - 40px);
      overflow-y: auto;
      }
      .modal-content h3 {
      margin: 0 0 15px 0;
      color: var(--text-main);
      font-size: clamp(18px, 2vw, 24px);
      }
      .modal-content p {
      color: var(--text-soft);
      font-size: clamp(14px, 1.6vw, 18px);
      margin: 0 0 20px 0;
      }
      .modal-content input:not([type="color"]),
      .modal-content select {
      width: 100%;
      padding: 10px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(14px, 1.6vw, 18px);
      margin-bottom: 15px;
      user-select: text;
      -webkit-user-select: text;
      }
      .modal-content input[type="color"] {
      width: 60px;
      height: 36px;
      padding: 2px;
      border: 2px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      background: none;
      -webkit-appearance: none;
      appearance: none;
      }
      .modal-content input[type="color"]::-webkit-color-swatch-wrapper {
      padding: 0;
      }
      .modal-content input[type="color"]::-webkit-color-swatch {
      border: none;
      border-radius: 4px;
      }
      .modal-buttons {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
      margin-top: 10px;
      }
      .modal-buttons button {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: clamp(14px, 1.6vw, 18px);
      font-weight: 600;
      }
      .modal-buttons .btn-cancel {
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      }
      .modal-buttons .btn-save {
      background: var(--accent);
      color: var(--bg);
      }
      .modal-buttons .btn-delete {
      background: var(--danger);
      color: white;
      }
      .confirm-modal p {
      color: var(--text-soft);
      font-size: clamp(14px, 1.6vw, 18px);
      margin: 0 0 20px 0;
      }
      .context-menu-item {
      transition: background 0.15s;
      }
      .context-menu-item:hover {
      background: var(--panel);
      }
      .badge-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      }
      .badge {
      background: var(--tag-fill, #1e293b);
      color: var(--tag-text, #e2e8f0);
      border: 1px solid var(--tag-border, var(--edge-main));
      padding: 5px 12px;
      border-radius: 22px;
      font-size: clamp(12px, 1.4vw, 18px);
      }
      .badge.wg {
      color: var(--accent);
      border-color: var(--accent);
      }
      input[type="text"],
      input[type="number"],
      input[type="password"],
      textarea,
      select {
      background: var(--input-bg, #0b0e13) !important;
      color: var(--input-text, #e2e8f0) !important;
      border-color: var(--input-border, #1f2937) !important;
      font-family: var(--input-font, Inter, system-ui, sans-serif) !important;
      font-size: var(--input-font-size, 14px) !important;
      }
      .section-label {
      margin-top: 8px;
      font-size: clamp(14px, 1.6vw, 20px);
      text-transform: uppercase;
      color: var(--text-soft);
      }
      .list li {
      margin: 6px 0;
      font-size: clamp(14px, 1.6vw, 20px);
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      }
      .list li:hover {
      color: var(--accent);
      }
      .delete-note {
      color: var(--danger);
      font-size: 18px;
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.2s;
      flex-shrink: 0;
      }
      .list li:hover .delete-note {
      opacity: 1;
      }
      .editing {
      outline: 2px solid var(--accent);
      background: #0d141f;
      padding: 4px;
      border-radius: 6px;
      user-select: text;
      -webkit-user-select: text;
      }
      .version-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .version-item:hover {
      background: var(--panel-alt);
      border-color: var(--accent);
      }
      .version-item.current {
      border-color: var(--accent);
      background: rgba(79, 209, 197, 0.1);
      }
      .version-info {
      flex: 1;
      }
      .version-info .timestamp {
      font-size: 13px;
      color: var(--text-main);
      font-weight: 600;
      }
      .version-info .details {
      font-size: 11px;
      color: var(--text-soft);
      margin-top: 4px;
      }
      .version-actions {
      display: flex;
      gap: 6px;
      }
      .audit-entry {
      padding: 8px 12px;
      background: var(--panel);
      border-left: 3px solid var(--edge-main);
      border-radius: 4px;
      font-size: 12px;
      }
      .audit-entry.node { border-left-color: #4fd1c5; }
      .audit-entry.connection { border-left-color: #9f7aea; }
      .audit-entry.style { border-left-color: #ed8936; }
      .audit-entry.rack { border-left-color: #48bb78; }
      .audit-entry.layer { border-left-color: #4299e1; }
      .audit-entry .time {
      color: var(--text-soft);
      font-size: 10px;
      }
      .audit-entry .action {
      color: var(--text-main);
      font-weight: 500;
      }
      .tab-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .tab-item:hover {
      background: var(--panel-alt);
      }
      .tab-item.active {
      border-color: var(--accent);
      background: rgba(79, 209, 197, 0.1);
      }
      .tab-item .tab-name {
      font-weight: 600;
      color: var(--text-main);
      flex: 1;
      }
      .tab-item .tab-stats {
      font-size: 11px;
      color: var(--text-soft);
      margin-right: 10px;
      }
      .tab-actions {
      display: flex;
      gap: 6px;
      }    
      .secret-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      border-left: 3px solid var(--danger);
      }
      .secret-item .secret-name {
      font-weight: 600;
      color: var(--text-main);
      flex: 1;
      }
      .secret-item .secret-status {
      font-size: 11px;
      color: var(--text-soft);
      margin-right: 10px;
      }    
      .mobile-menu-btn {
      display: none;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      color: var(--text-main);
      font-size: 22px;
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      }
      #topbar-menu {
      gap: 8px;
      }
      @media (min-width: 721px) {
      #topbar-menu {
      display: flex !important;
      }
      }
      @media (max-width: 720px) {
      #topbar-menu {
      display: none;
      }
      #topbar-menu.open {
      display: flex;
      }
      }
      @media (max-width: 720px) {
      .mobile-menu-btn {
      display: block;
      }
      #topbar-menu {
      position: absolute;
      top: var(--topbar-height);
      right: 0;
      background: var(--panel-alt);
      border-left: 1px solid var(--topbar-border);
      border-bottom: 1px solid var(--topbar-border);
      padding: 12px;
      display: none;
      flex-direction: column;
      width: 180px;
      z-index: 999;
      }
      #topbar-menu.open {
      display: flex;
      }
      header {
      position: relative;
      z-index: 9999;
      }
      }
      @media (max-width: 720px) {
      .draw-toolbar {
      position: absolute;
      top: auto;
      bottom: auto;
      left: 10px !important;
      right: auto !important;
      width: auto;
      gap: 6px;
      padding: 8px;
      }
      .topology-toolbar {
      position: absolute;
      top: auto;
      bottom: auto;
      width: auto;
      gap: 6px;
      padding: 8px;
      }
      .draw-toolbar {
      top: 10px !important;
      z-index:99;
      }
      .topology-toolbar {
      z-index:99;
      top: calc(10px + var(--draw-toolbar-height, 50px)) !important;
      }
      .canvas-hint {
      top: calc(10px + 120px);
      }
      #search-input {
      width: 100%;
      }
      }
    </style>
  </head>
  <body style="background: rgb(5, 5, 5);" class="">
    <div class="modal" id="edit-modal">
      <div class="modal-content">
        <h3 id="modal-title">Edit Title</h3>
        <input type="text" id="modal-input">
        <div class="modal-buttons">
          <button class="btn-cancel" id="modal-cancel">Cancel</button>
          <button class="btn-save" id="modal-save">Save</button>
        </div>
      </div>
    </div>
    <div class="modal confirm-modal" id="confirm-modal">
      <div class="modal-content">
        <h3>Confirm</h3>
        <p id="confirm-message"> Are you sure you want to delete this line? </p>
        <div class="modal-buttons">
          <button class="btn-cancel" id="confirm-cancel">Cancel</button>
          <button class="btn-delete" id="confirm-delete">Delete</button>
        </div>
      </div>
    </div>
    <div class="modal" id="save-info-modal">
      <div class="modal-content" style="max-width: 700px; max-height: 80vh; overflow-y: auto;">
        <h3 style="margin-bottom: 16px;">Help</h3>
        <div style="display: flex; gap: 8px; margin-bottom: 16px; flex-wrap: wrap;">
          <button class="help-tab active" data-tab="general" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--accent); color: var(--bg); border-radius: 6px; cursor: pointer; font-weight: 600;">General</button>
          <button class="help-tab" data-tab="desktop" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--panel); color: var(--text-main); border-radius: 6px; cursor: pointer; font-weight: 600;">Desktop</button>
          <button class="help-tab" data-tab="mobile" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--panel); color: var(--text-main); border-radius: 6px; cursor: pointer; font-weight: 600;">Mobile</button>
        </div>
        <div id="help-tab-general" class="help-tab-content" style="display: block;">
          <ul style="margin-left: 20px; margin-bottom: 12px; line-height: 1.8;">
            <li><strong>Add Nodes:</strong> Click "+ Node" or "+ Rack" in the top menu</li>
            <li><strong>Connect Nodes:</strong> Select a node, then use "Add Connection" in the panel</li>
            <li><strong>Move Nodes:</strong> Drag nodes to reposition them</li>
            <li><strong>Enter Rack View:</strong> Double click on desktop or Long press on mobile</li>
            <li><strong>Multi Select:</strong> Right click (desktop) or double tap (mobile)</li>
            <li><strong>Pan Canvas:</strong> Drag empty space or hold Space + drag</li>
            <li><strong>Zoom:</strong> Scroll wheel or pinch gesture</li>
            <li><strong>Free Draw:</strong> Use draw toolbar for drawing lines, boxes/zones , and text</li>
          </ul>
          <h4 style="color: var(--accent); margin-bottom: 8px;">Saving &amp; Encryption</h4>
          <p style="margin-bottom: 8px;">Browsers cannot overwrite local files. Click <strong>Save File</strong> to download an updated HTML with all changes. Replace your old file to keep edits.</p>
          <p style="margin-bottom: 8px;"><strong>Encryption of data:</strong> Check "Encrypt" before saving to password protect your data. Beware! No recovery possible without password!!</p>
          <p><strong>Decryption of data:</strong> Export via JSON in top settings menu after successful password validation to decrypt your data. You can then reimport back into the same file and save!</p>
        </div>
        <div id="help-tab-desktop" class="help-tab-content" style="display: none;">
          <h4 style="color: var(--accent); margin-bottom: 12px;">Navigation</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Arrow Keys</code></td>
              <td style="padding: 8px;">Move selected 1px</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Shift + Arrows</code></td>
              <td style="padding: 8px;">Move selected 10px</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Tab / Shift+Tab</code></td>
              <td style="padding: 8px;">Cycle through nodes</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">F</code></td>
              <td style="padding: 8px;">Focus on selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Space + Drag</code></td>
              <td style="padding: 8px;">Pan canvas</td>
            </tr>
          </tbody></table>
          <h4 style="color: var(--accent); margin-bottom: 12px;">Management</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">L</code></td>
              <td style="padding: 8px;">Lock/unlock selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">G</code></td>
              <td style="padding: 8px;">Group/ungroup selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+C / Ctrl+V</code></td>
              <td style="padding: 8px;">Copy / Paste</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+D</code></td>
              <td style="padding: 8px;">Duplicate</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+A</code></td>
              <td style="padding: 8px;">Select all</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Delete</code></td>
              <td style="padding: 8px;">Delete selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Escape</code></td>
              <td style="padding: 8px;">Clear selection</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+Z / Ctrl+Y</code></td>
              <td style="padding: 8px;">Undo / Redo</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Right Click</code></td>
              <td style="padding: 8px;">Multi select toggle</td>
            </tr>
          </tbody></table>
        </div>
        <div id="help-tab-mobile" class="help-tab-content" style="display: none;">
          <h4 style="color: var(--accent); margin-bottom: 12px;">Basic Gestures</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Tap node</strong></td>
              <td style="padding: 8px;">Select &amp; open properties</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Tap empty</strong></td>
              <td style="padding: 8px;">Deselect all</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Drag node</strong></td>
              <td style="padding: 8px;">Move node</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Drag empty</strong></td>
              <td style="padding: 8px;">Pan canvas</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Pinch</strong></td>
              <td style="padding: 8px;">Zoom in/out</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Double-tap node</strong></td>
              <td style="padding: 8px;">Add/remove from selection</td>
            </tr>
          </tbody></table>
          <h4 style="color: var(--accent); margin-bottom: 12px;">Rack View</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Long-press rack</strong></td>
              <td style="padding: 8px;">Enter rack view</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Double-tap empty</strong></td>
              <td style="padding: 8px;">Exit rack view</td>
            </tr>
          </tbody></table>
        </div>
        <div class="modal-buttons" style="margin-top: 16px;">
          <button class="btn-cancel" id="save-info-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="settings-modal">
      <div class="modal-content">
        <h2>Settings</h2>
        <details class="style-section">
          <summary>General Theme</summary>
          <div class="style-content">
		    <div class="style-row">
              <label>Main Background</label>
              <input type="color" id="panel-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Modal Window (popup) Background</label>
              <input type="color" id="panel-alt-color" value="#10141b">
            </div>
            <div class="style-row">
              <label>Accent Buttons</label>
              <input type="color" id="accent-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Danger Buttons</label>
              <input type="color" id="danger-color" value="#f56565">
            </div>
            <div class="style-row">
              <label>Primary Text</label>
              <input type="color" id="text-main-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Secondary Text</label>
              <input type="color" id="text-soft-color" value="#94a3b8">
            </div>
          </div>
        </details>
		<details class="style-section">
          <summary>Top Bar</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="topbar-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="topbar-border-color" value="#1f2533">
            </div>
          </div>
		  <div class="style-content">
            <div class="style-row">
              <label>Button Fill</label>
              <input type="color" id="btn-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Button Text</label>
              <input type="color" id="btn-text-color" value="#e2e8f0">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Main Canvas</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="canvas-border-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Grid Lines</label>
              <input type="color" id="canvas-grid-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Grid Size</label>
              <input type="number" id="canvas-grid-size" value="50" min="20" max="200" style="width:60px;">
            </div>
			<div class="style-row">
              <label>Background Top</label>
              <input type="color" id="canvas-gradient-top" value="#1e2532">
            </div>
            <div class="style-row">
              <label>Background Bottom</label>
              <input type="color" id="canvas-gradient-bottom" value="#050608">
            </div>
            <div class="style-row">
              <label>Solid Background</label>
              <input type="color" id="page-bg-color" value="#050608">
            </div>
            <p style="margin-top:4px;font-size:12px;color:var(--text-soft);">Set solid background to override gradient.</p>
          </div>
			</details>
		  <details class="style-section">
          <summary>Rack Canvas</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Frame Fill</label>
              <input type="color" id="rack-frame-fill" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Frame Border</label>
              <input type="color" id="rack-frame-stroke" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Grid Lines</label>
              <input type="color" id="rack-line-color" value="#475569">
            </div>
            <div class="style-row">
              <label>U Labels</label>
              <input type="color" id="rack-text-color" value="#4fd1c5">
            </div>
          </div>
        </details>
		        <details class="style-section">
          <summary>Canvas Toolbars</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="toolbar-bg-color" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="toolbar-border-color" value="#1f2937">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="toolbar-text-color" value="#94a3b8">
            </div>
            <div class="style-row">
              <label>Button Fill</label>
              <input type="color" id="toolbar-btn-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Button Text</label>
              <input type="color" id="toolbar-btn-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Minimap Dots</label>
              <input type="color" id="minimap-dots-color" value="#94a3b8">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Nodes</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Fill</label>
              <input type="color" id="node-fill-color" value="#1e293b">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="node-stroke-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Title Color</label>
              <input type="color" id="node-title-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Title Size</label>
              <input type="number" id="node-title-size" value="18" min="8" max="48" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Subtitle Color</label>
              <input type="color" id="node-sub-color" value="#94a3b8">
            </div>
            <div class="style-row">
              <label>Subtitle Size</label>
              <input type="number" id="node-sub-size" value="13" min="8" max="48" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Font</label>
              <select id="node-font-family" style="flex:1;padding:4px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;">
                <option value="Inter, system-ui, sans-serif">Inter</option>
                <option value="Arial, sans-serif">Arial</option>
                <option value="Helvetica, sans-serif">Helvetica</option>
                <option value="Georgia, serif">Georgia</option>
                <option value="monospace">Monospace</option>
              </select>
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Connections</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Default Color</label>
              <input type="color" id="default-edge-color" value="#475569">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Groups &amp; Editing</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Resize handle Color</label>
              <input type="color" id="selection-handle-color" value="#f59e0b">
            </div>
            <div class="style-row">
              <label>Resize Handle Size</label>
              <input type="number" id="selection-handle-size" value="8" min="4" max="16" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Grouped Icon Outline</label>
              <input type="color" id="group-indicator-color" value="#4fd1c5">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Inputs &amp; Dropdowns</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="input-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="input-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="input-border-color" value="#1f2937">
            </div>
            <div class="style-row">
              <label>Font</label>
              <select id="input-font-family" style="flex:1;padding:4px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;">
                <option value="Inter, system-ui, sans-serif">Inter</option>
                <option value="Arial, sans-serif">Arial</option>
                <option value="Helvetica, sans-serif">Helvetica</option>
                <option value="Georgia, serif">Georgia</option>
                <option value="monospace">Monospace</option>
              </select>
            </div>
            <div class="style-row">
              <label>Font Size</label>
              <input type="number" id="input-font-size" value="14" min="10" max="24" style="width:60px;">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Welcome Message</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Enabled</label>
              <input type="checkbox" id="canvas-hint-enabled" checked="" style="width:auto;">
            </div>
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="canvas-hint-bg-color" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Text Color</label>
              <input type="color" id="canvas-hint-text-color" value="#94a3b8">
            </div>
            <div class="style-row" style="flex-direction:column;align-items:stretch;">
              <label>Custom Text (HTML)</label>
              <textarea id="canvas-hint-text" rows="4" style="width:100%;margin-top:4px;padding:6px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;font-size:12px;resize:vertical;" placeholder="Leave empty for default"></textarea>
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Sidebar / Mobile Footer</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="sidebar-bg-color" value="#10141b">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Tags</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Fill</label>
              <input type="color" id="tag-fill-color" value="#1e293b">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="tag-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="tag-border-color" value="#475569">
            </div>
          </div>
        </details>
        <details class="style-section" open="">
          <summary>Import / Export / Upgrade JSON</summary>
          <div class="style-content">
            <button id="export-data-btn" style="width:100%;margin-bottom:10px;padding:10px;background:var(--accent);color:var(--bg);border:none;border-radius:6px;cursor:pointer;font-size:14px;font-weight:600;">Export JSON</button>
            <button id="import-data-btn" style="width:100%;padding:10px;background:var(--panel);color:var(--text-main);border:1px solid var(--edge-main);border-radius:6px;cursor:pointer;font-size:14px;font-weight:600;">Import JSON</button>
            <input type="file" id="import-data-file" accept=".json" style="display:none">
          </div>
        </details>
        <details class="style-section">
          <summary>Danger Zone</summary>
          <div class="style-content">
            <p style="margin-bottom:12px;font-size:13px;color:var(--text-soft);">Permanently delete everything on the canvas.</p>
            <button id="clear-all-btn" title="Clear all nodes" style="padding:6px 12px;background:var(--danger);color:#fff;border:none;border-radius:6px;cursor:pointer;font-size:14px;font-weight:600;">Clear All</button>
            <input type="file" id="import-data-file" accept=".json" style="display:none">
          </div>
        </details>
        <div class="modal-buttons">
          <button class="btn-cancel" id="settings-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="add-node-modal">
      <div class="modal-content">
        <h3>Add New Node</h3>
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Name</label>
        <input type="text" id="new-node-name" placeholder="e.g. web-server">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">IP / Subtitle</label>
        <input type="text" id="new-node-ip" placeholder="e.g. 192.168.1.100">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Tags (comma separated)</label>
        <input type="text" id="new-node-tags" placeholder="e.g. Docker, nginx, WG: vpn">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Shape</label>
        <select id="new-node-shape">
          <optgroup label="Basic Shapes">
            <option value="circle">Circle</option>
            <option value="square">Square</option>
            <option value="rectangle">Rectangle</option>
            <option value="triangle">Triangle</option>
            <option value="hexagon">Hexagon</option>
            <option value="diamond">Diamond</option>
            <option value="star">Star</option>
            <option value="stop-sign">Stop Sign</option>
          </optgroup>
          <optgroup label="Network Equipment">
            <option value="server">Server</option>
            <option value="pc">PC / Desktop</option>
            <option value="laptop">Laptop</option>
            <option value="phone">Phone / Mobile</option>
            <option value="router">Router</option>
            <option value="switch">Switch</option>
            <option value="firewall">Firewall</option>
            <option value="cloud">Cloud</option>
            <option value="database">Database</option>
            <option value="printer">Printer</option>
          </optgroup>
        </select>
        <div class="modal-buttons">
          <button class="btn-cancel" id="add-node-cancel">Cancel</button>
          <button class="btn-save" id="add-node-save">Add Node</button>
        </div>
      </div>
    </div>
    <div class="modal" id="add-rack-modal">
      <div class="modal-content">
        <h3>Add New Rack</h3>
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Rack Name</label>
        <input type="text" id="new-rack-name" placeholder="e.g. Rack-A, DC1-R01">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">IP / Network Range (optional)</label>
        <input type="text" id="new-rack-ip" placeholder="e.g. 192.168.1.0/24">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Tags (comma separated)</label>
        <input type="text" id="new-rack-tags" placeholder="e.g. Production, Data Center 1">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Icon / Shape</label>
        <select id="new-rack-shape">
          <optgroup label="Basic Shapes">
            <option value="circle">Circle</option>
            <option value="square">Square</option>
            <option value="rectangle">Rectangle</option>
            <option value="triangle">Triangle</option>
            <option value="hexagon">Hexagon</option>
            <option value="diamond">Diamond</option>
            <option value="star">Star</option>
            <option value="stop-sign">Stop Sign</option>
          </optgroup>
          <optgroup label="Network Equipment">
            <option value="server" selected="">Server</option>
            <option value="pc">PC / Desktop</option>
            <option value="laptop">Laptop</option>
            <option value="phone">Phone / Mobile</option>
            <option value="router">Router</option>
            <option value="switch">Switch</option>
            <option value="firewall">Firewall</option>
            <option value="cloud">Cloud</option>
            <option value="database">Database</option>
            <option value="printer">Printer</option>
          </optgroup>
        </select>
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Rack Capacity</label>
        <select id="new-rack-capacity">
          <option value="42" selected="">42U (Standard Full Rack)</option>
          <option value="48">48U (Large Rack)</option>
          <option value="24">24U (Half Rack)</option>
          <option value="12">12U (Small/Wall Mount)</option>
          <option value="6">6U (Mini Rack)</option>
        </select>
        <div class="modal-buttons">
          <button class="btn-cancel" id="add-rack-cancel">Cancel</button>
          <button class="btn-save" id="add-rack-save">Add Rack</button>
        </div>
      </div>
    </div>
    <div class="modal confirm-modal" id="clear-all-modal">
      <div class="modal-content">
        <h3>Clear All Nodes</h3>
        <p> This will remove ALL nodes and connections. This cannot be undone until you reload without saving. Are you sure? </p>
        <div class="modal-buttons">
          <button class="btn-cancel" id="clear-all-cancel">Cancel</button>
          <button class="btn-delete" id="clear-all-confirm">Clear Everything</button>
        </div>
      </div>
    </div>
    <div class="modal" id="layer-modal">
      <div class="modal-content" style="max-width: 400px;">
        <h3>Layer Visibility</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Toggle which layers are visible on the canvas</p>
        <div style="display: flex; flex-direction: column; gap: 10px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-physical" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Physical Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-logical" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Logical Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-security" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Security Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-application" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Application Layer</span>
          </label>
        </div>
        <div style="margin-top: 15px; display: flex; gap: 8px;">
          <button class="btn-cancel" style="flex: 1;" onclick="document.querySelectorAll('#layer-modal input[type=checkbox]').forEach(cb =&gt; cb.checked = false); applyLayerFilter();">Hide All</button>
          <button class="btn-save" style="flex: 1;" onclick="document.querySelectorAll('#layer-modal input[type=checkbox]').forEach(cb =&gt; cb.checked = true); applyLayerFilter();">Show All</button>
        </div>
        <div class="modal-buttons" style="margin-top: 10px;">
          <button class="btn-cancel" id="layer-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="tabs-modal">
      <div class="modal-content" style="max-width: 600px;">
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Manage multiple topologies</p>
        <div id="tabs-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 400px; overflow-y: auto; margin-bottom: 15px;">
            <div class="tab-item active" onclick="switchTab(0)">
              <div class="tab-name">Corporate</div>
              <div class="tab-stats">21 nodes â€¢ 22 connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(0)" title="Rename tab">âœï¸</button>
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(${index})" title="Delete tab">ðŸ—‘ï¸</button>
              </div>
            </div>
          
            <div class="tab-item " onclick="switchTab(1)">
              <div class="tab-name">Homelab</div>
              <div class="tab-stats">20 nodes â€¢ 22 connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(1)" title="Rename tab">âœï¸</button>
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(${index})" title="Delete tab">ðŸ—‘ï¸</button>
              </div>
            </div>
          </div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="new-tab-name" placeholder="New tab name..." style="flex: 1; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <button class="btn-save" onclick="createNewTab()">+ Add Tab</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="tabs-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="rollback-modal">
      <div class="modal-content" style="max-width: 700px;">
        <h3>Version History</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Limit: Snapshots</p>
        <div id="rollback-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 450px; overflow-y: auto; margin-bottom: 15px;">
          <div style="text-align: center; padding: 40px; color: var(--text-soft);">No version history yet. Versions are saved automatically when you save the file.</div>
        </div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <button class="btn-cancel" onclick="clearRollbackHistory()">Clear History</button>
          <button class="btn-save" onclick="createManualSnapshot()">Create Snapshot</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="rollback-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="audit-log-modal">
      <div class="modal-content" style="max-width: 800px;">
        <h3>Audit Log</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Track all changes made to your topology</p>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <select id="audit-filter" style="padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
            <option value="all">All Events</option>
            <option value="node">Node Operations</option>
            <option value="connection">Connections</option>
            <option value="style">Style Changes</option>
            <option value="rack">Rack Operations</option>
            <option value="layer">Layer Changes</option>
          </select>
          <button class="btn-save" onclick="exportAuditLog()">Export</button>
        </div>
        <div id="audit-log-list" style="display: flex; flex-direction: column; gap: 4px; max-height: 450px; overflow-y: auto; margin-bottom: 15px; font-family: monospace; font-size: 12px;">
          <div style="text-align: center; padding: 40px; color: var(--text-soft);">No audit entries yet</div>
        </div>
        <div style="display: flex; gap: 8px;">
          <button class="btn-cancel" onclick="clearAuditLog()">Clear Log</button>
          <button class="btn-cancel" id="audit-log-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="secrets-modal">
      <div class="modal-content" style="max-width: 600px;">
        <h3>Notes</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Notes can also be stored with AES 256 encryption</p>
        <div id="secrets-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 350px; overflow-y: auto; margin-bottom: 15px;">
        </div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="new-secret-name" placeholder="Note name (e.g., 'Root Passwords')..." style="flex: 1; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <button class="btn-save" onclick="createNewSecret()">+ Add Note</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="secrets-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="secret-editor-modal">
      <div class="modal-content" style="max-width: 600px;">
        <h3 id="secret-editor-title">Edit Note</h3>
        <textarea id="secret-editor-content" placeholder="Enter sensitive information here..." style="width: 100%; height: 200px; padding: 12px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main); font-family: monospace; resize: vertical; margin-bottom: 15px;"></textarea>
        <div style="margin-bottom: 15px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
          <input type="checkbox" id="secret-auto-encrypt" checked="" style="cursor: pointer;">
          <span>Encrypt Note</span>
          </label>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" onclick="closeSecretEditor()">Cancel</button>
          <button class="btn-save" onclick="saveSecret()">Save</button>
        </div>
      </div>
    </div>
    <div id="context-menu" style="display: none !important;">
    </div>
    <header>
      <div class="title-block">
        <h1 id="page-title" class="editable-page-title">Corporate</h1>
        <div class="save-row">
          <button id="save-file-btn" class="save-btn" type="button">Save File</button>
          <label style="display: flex;align-items: center;gap: 4px;font-size: 12px;color: var(--text-soft);cursor: pointer;user-select: none;">
          <input type="checkbox" id="encrypt-toggle" style="cursor: pointer">
          <span title="Encrypt data with password">Encrypt</span>
          </label>
          <span id="save-help-btn" class="help-icon" title="Why save?">?</span>
        </div>
      </div>
      <div id="topbar-menu">
        <button id="back-to-topology-btn" title="Exit rack view and return to topology" style="padding: 6px 12px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;display: none;">â† Back to Topology</button>
        <button id="add-node-btn" class="save-btn" title="Add new node" style="background: var(--accent)" draggable="true">+ Node</button>
        <button id="add-rack-btn" class="save-btn" title="Add new rack" style="background: var(--accent); margin-left: 8px;" draggable="true">+ Rack</button>
        <button id="undo-btn" title="Undo (Ctrl+Z)" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;" disabled="">â†¶</button>
        <button id="redo-btn" title="Redo (Ctrl+Y)" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;" disabled="">â†·</button>
        <input type="text" id="search-nodes" placeholder="Search nodes..." title="Search by name, IP, MAC, role, or tag" style="padding: 6px 12px;background: var(--input-bg);color: var(--input-text);border: 1px solid var(--input-border);border-radius: 6px;font-family: var(--input-font);font-size: var(--input-font-size);width: 180px;">
        <button id="layers-btn" title="Toggle layer visibility" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Layers</button>
        <button id="tabs-btn" title="Manage document tabs" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Tabs</button>
        <button id="rollback-btn" title="View version history" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Snapshots</button>
        <button id="audit-log-btn" title="View audit log" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Audit</button>
        <button id="secrets-btn" title="Manage encrypted notes" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Notes</button>
        <button onclick="screenshotCanvas()" title="Export canvas as PNG image" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">PNG</button>
        <button onclick="exportCanvasSVG()" title="Export canvas as SVG vector" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">SVG</button>
        <button id="settings-btn" title="Page settings">âš™ï¸</button>
      </div>
      <button id="mobile-menu-toggle" class="mobile-menu-btn">â˜°</button>
      <div class="header-resizer" id="header-resizer">
        <svg class="resizer-icon" width="40" height="6" viewBox="0 0 40 6" xmlns="http://www.w3.org/2000/svg">
          <circle cx="14" cy="3" r="2"></circle>
          <circle cx="20" cy="3" r="2"></circle>
          <circle cx="26" cy="3" r="2"></circle>
        </svg>
      </div>
    </header>
    <main>
      <section class="topology-panel">
        <div class="draw-toolbar" id="draw-toolbar" style="display: flex !important;">
          <button type="button" class="toolbar-close-btn" id="draw-toolbar-close-btn" title="Hide draw toolbar">âœ•</button>
          <button id="draw-toggle" title="Draw custom line">âœï¸</button>
          <button id="rect-toggle" title="Draw zone">â–­</button>
          <button id="text-toggle" title="Add text">T</button>
          <select id="rect-style" title="zone style">
            <option value="filled">Filled</option>
            <option value="outlined">Outlined</option>
          </select>
          <input type="color" id="draw-color" value="#f97316" title="Line color">
          <select id="draw-style" title="Line style">
            <option value="solid">Solid</option>
            <option value="dashed">Dashed</option>
            <option value="dotted">Dotted</option>
          </select>
          <select id="draw-arrow" title="Arrow direction">
            <option value="none">No arrows</option>
            <option value="forward">â†’ Right</option>
            <option value="backward">â† Left</option>
            <option value="both">â†” Both</option>
          </select>
          <button id="draw-undo" style="display: none" title="Undo last point">Undo</button>
        </div>
        <div class="topology-toolbar" id="topology-toolbar" style="display: flex !important;">
          <button type="button" class="toolbar-close-btn" id="topology-toolbar-close-btn" title="Hide add line toolbar">âœ•</button>
          <label for="add-line-select">Add line to:</label>
          <select id="add-line-select"><option value="edge-firewall">Edge Firewall</option><option value="core-switch-1">Core Switch 1</option><option value="core-switch-2">Core Switch 2</option><option value="dmz-firewall">DMZ Firewall</option><option value="web-server">Web Server</option><option value="mail-server">Mail Server</option><option value="dist-switch-1">Distribution SW 1</option><option value="dist-switch-2">Distribution SW 2</option><option value="access-switch-1">Access SW 1-1</option><option value="access-switch-2">Access SW 1-2</option><option value="access-switch-3">Access SW 2-1</option><option value="domain-controller">Domain Controller</option><option value="file-server">File Server</option><option value="db-server">Database Server</option><option value="backup-server">Backup Server</option><option value="wifi-controller">WiFi Controller</option><option value="vpn-gateway">VPN Gateway</option><option value="im-a-rack">IM A RACK</option></select>
          <input type="color" id="add-line-color" value="#475569" title="Line color" style="width: 30px;height: 24px;border: 1px solid var(--toolbar-border);border-radius: 4px;cursor: pointer;background: transparent;padding: 0;">     
          <select id="add-line-direction" title="Line direction">
            <option value="none">No arrows</option>
            <option value="forward">â†’ Forward</option>
            <option value="backward">â† Backward</option>
            <option value="both">â†” Both</option>
          </select>
          <button id="add-line-btn">Add</button>
        </div>
        <div class="topology-toolbar bulk-toolbar-desktop" id="bulk-toolbar" style="display: none">
          <button type="button" class="toolbar-close-btn" id="bulk-toolbar-close" title="Clear selection">âœ•</button>
          <label style="font-weight: 600; color: var(--accent)">Selected: <span id="bulk-count">0</span></label>
          <button id="bulk-align-left" title="Align left">â¬… Left</button>
          <button id="bulk-align-right" title="Align right">âž¡ Right</button>
          <button id="bulk-align-top" title="Align top">â¬† Top</button>
          <button id="bulk-align-bottom" title="Align bottom">â¬‡ Bottom</button>
          <button id="bulk-distribute-h" title="Distribute horizontally">â†” Distribute H</button>
          <button id="bulk-distribute-v" title="Distribute vertically">â†• Distribute V</button>
          <button id="bulk-clone" title="Clone selected">ðŸ“‹ Clone</button>
          <button id="bulk-delete" title="Delete selected" style="background: var(--danger); color: white;">Delete</button>
        </div>
        <div class="bulk-toolbar-mobile" id="bulk-toolbar-mobile" style="display: none">
          <button type="button" id="bulk-mobile-btn" style="background: var(--accent);color: white;padding: 12px 20px;border-radius: 25px;font-weight: 600;font-size: 16px;box-shadow: 0 4px 12px rgba(0,0,0,0.3);border: none;cursor: pointer;display: flex;align-items: center;gap: 8px;">
          <span id="bulk-count-mobile">0</span>Selected</button>
        </div>
        <div id="bulk-actions-modal" style="display: none;position: fixed;bottom: 0;left: 0;right: 0;background: var(--panel-alt);border-top-left-radius: 20px;border-top-right-radius: 20px;padding: 20px;padding-bottom: env(safe-area-inset-bottom, 20px);box-shadow: 0 -4px 20px rgba(0,0,0,0.5);z-index: 10000;max-height: calc(100vh - 80px);overflow-y: auto;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            <h3 style="margin: 0; color: var(--accent); font-size: 20px;">
              <span id="bulk-count-modal">0</span> Nodes Selected
            </h3>
            <button id="bulk-modal-close" style="background: none;border: none;font-size: 24px;cursor: pointer;color: var(--text-main);padding: 0;width: 32px;height: 32px;">âœ•</button>
          </div>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
            <button id="bulk-align-left-mobile" class="bulk-action-btn">â¬…<br><span style="font-size: 12px;">Align Left</span></button>
            <button id="bulk-align-right-mobile" class="bulk-action-btn">âž¡<br><span style="font-size: 12px;">Align Right</span></button>
            <button id="bulk-align-top-mobile" class="bulk-action-btn">â¬†<br><span style="font-size: 12px;">Align Top</span></button>
            <button id="bulk-align-bottom-mobile" class="bulk-action-btn">â¬‡<br><span style="font-size: 12px;">Align Bottom</span></button>
            <button id="bulk-distribute-h-mobile" class="bulk-action-btn">â†”<br><span style="font-size: 12px;">Distribute H</span></button>
            <button id="bulk-distribute-v-mobile" class="bulk-action-btn">â†•<br><span style="font-size: 12px;">Distribute V</span></button>
            <button id="bulk-lock-mobile" class="bulk-action-btn">ðŸ”’<br><span style="font-size: 12px;">Lock Toggle</span></button>
            <button id="bulk-group-mobile" class="bulk-action-btn">â­•<br><span style="font-size: 12px;">Group Toggle</span></button>
            <button id="bulk-clone-mobile" class="bulk-action-btn">ðŸ“‹<br><span style="font-size: 12px;">Clone All</span></button>
            <button id="bulk-delete-mobile" class="bulk-action-btn" style="background: var(--danger); color: white;">ðŸ—‘<br><span style="font-size: 12px;">Delete All</span></button>
          </div>
          <button id="bulk-clear-mobile" style="width: 100%;margin-top: 16px;padding: 14px;background: var(--panel-main);border: 1px solid var(--edge-main);border-radius: 8px;color: var(--text-main);font-size: 16px;cursor: pointer;">Clear Selection</button>
        </div>
        <div class="canvas-hint" id="canvas-hint">
          <ul>
            <li>Scroll to zoom</li>
            <li>Drag to pan</li>
            <li>Right click to clone and align</li>
            <li>Right click to select multiple</li>
            <li>You have the power</li>
            <li>Your time is NOW!</li>
          </ul>
        </div>
        <div class="legend-container" id="edge-legend" style="display: flex;"><div class="legend-title">Line Legend</div><button type="button" class="legend-close-btn">âœ•</button><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(239, 68, 68); cursor: pointer;"></span><span class="legend-label" contenteditable="true">WAN / DMZ</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(245, 158, 11); cursor: pointer;"></span><span class="legend-label" contenteditable="true">Trunk / Uplink</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(16, 185, 129); cursor: pointer;"></span><span class="legend-label" contenteditable="true">Core / Distribution</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(59, 130, 246); cursor: pointer;"></span><span class="legend-label" contenteditable="true">Access Layer</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(139, 92, 246); cursor: pointer;"></span><span class="legend-label" contenteditable="true">Server VLAN</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(6, 182, 212); cursor: pointer;"></span><span class="legend-label" contenteditable="true">Management</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(249, 115, 22); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div></div>
        <div class="canvas-viewport" id="canvas-viewport">
          <svg id="map" viewBox="563.4450887044272 95.16763305664074 2673.1098225911455 2004.8323669433591" style=""><defs><marker id="arrow-forward" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto" markerUnits="strokeWidth"><path d="M0,0 L0,6 L9,3 z" fill="context-stroke"></path></marker><marker id="arrow-backward" markerWidth="10" markerHeight="10" refX="0" refY="3" orient="auto" markerUnits="strokeWidth"><path d="M9,0 L9,6 L0,3 z" fill="context-stroke"></path></marker></defs><rect x="100" y="100" width="3800" height="2800" fill="none" stroke="#d6d6d64D" stroke-width="20" stroke-dasharray="10 5" rx="8"></rect><g id="canvas-grid"><line x1="100" y1="100" x2="100" y2="2900" stroke="#ffffff66" stroke-width="2"></line><line x1="147" y1="100" x2="147" y2="2900" stroke="#ffffff33" stroke-width="1"></line><line x1="194" y1="100" x2="194" y2="2900" stroke="#ffffff33" stroke-width="1"></line><line x1="241" y1="100" x2="241" y2="2900" stroke="#ffffff33" stroke-width="1"></line><line x1="288" y1="100" x2="288" y2="2900" stroke="#ffffff33" stroke-width="1"></line><line x1="335" y1="100" x2="335" y2="2900" stroke="#ffffff66" stroke-width="2"></line><line x1="382" y1="100" x2="382" y2="2900" stroke="#ffffff33" stroke-width="1"></line><line x1="429" y1="100" x2="429" y2="2900" stroke="#ffffff33" stroke-width="1"></line><line x1="476" y1="100" x2="476" y2="2900" stroke="#ffffff33" stroke-width="1"></line><line x1="523" y1="100" x2="523" y2="2900" stroke="#ffffff33" stroke-width="1"></line><line x1="570" y1="100" x2="570" y2="2900" stroke="#ffffff66" stroke-width="2"></line><line x1="617" y1="100" x2="617" y2="2900" stroke="#ffffff33" stroke-width="1"></line><line x1="664" y1="100" x2="664" y2="2900" stroke="#ffffff33" stroke-width="1"></line><line x1="711" y1="100" x2="711" y2="2900" stroke="#ffffff33" stroke-width="1"></line><line x1="758" y1="100" x2="758" y2="2900" stroke="#ffffff33" stroke-width="1"></line><line x1="805" y1="100" x2="805" y2="2900" stroke="#ffffff66" stroke-width="2"></line><line x1="852" y1="100" x2="852" y2="2900" stroke="#ffffff33" stroke-width="1"></line><line x1="899" y1="100" x2="899" y2="2900" stroke="#ffffff33" stroke-width="1"></line><line x1="946" y1="100" x2="946" y2="2900" stroke="#ffffff33" stroke-width="1"></line><line x1="993" y1="100" x2="993" y2="2900" stroke="#ffffff33" stroke-width="1"></line><line x1="1040" y1="100" x2="1040" y2="2900" stroke="#ffffff66" stroke-width="2"></line><line x1="1087" y1="100" x2="1087" y2="2900" stroke="#ffffff33" stroke-width="1"></line><line x1="1134" y1="100" x2="1134" y2="2900" stroke="#ffffff33" stroke-width="1"></line><line x1="1181" y1="100" x2="1181" y2="2900" stroke="#ffffff33" stroke-width="1"></line><line x1="1228" y1="100" x2="1228" y2="2900" stroke="#ffffff33" stroke-width="1"></line><line x1="1275" y1="100" x2="1275" y2="2900" stroke="#ffffff66" stroke-width="2"></line><line x1="1322" y1="100" x2="1322" y2="2900" stroke="#ffffff33" stroke-width="1"></line><line x1="1369" y1="100" x2="1369" y2="2900" stroke="#ffffff33" stroke-width="1"></line><line x1="1416" y1="100" x2="1416" y2="2900" stroke="#ffffff33" stroke-width="1"></line><line x1="1463" y1="100" x2="1463" y2="2900" stroke="#ffffff33" stroke-width="1"></line><line x1="1510" y1="100" x2="1510" y2="2900" stroke="#ffffff66" stroke-width="2"></line><line x1="1557" y1="100" x2="1557" y2="2900" stroke="#ffffff33" stroke-width="1"></line><line x1="1604" y1="100" x2="1604" y2="2900" stroke="#ffffff33" stroke-width="1"></line><line x1="1651" y1="100" x2="1651" y2="2900" stroke="#ffffff33" stroke-width="1"></line><line x1="1698" y1="100" x2="1698" y2="2900" stroke="#ffffff33" stroke-width="1"></line><line x1="1745" y1="100" x2="1745" y2="2900" stroke="#ffffff66" stroke-width="2"></line><line x1="1792" y1="100" x2="1792" y2="2900" stroke="#ffffff33" stroke-width="1"></line><line x1="1839" y1="100" x2="1839" y2="2900" stroke="#ffffff33" stroke-width="1"></line><line x1="1886" y1="100" x2="1886" y2="2900" stroke="#ffffff33" stroke-width="1"></line><line x1="1933" y1="100" x2="1933" y2="2900" stroke="#ffffff33" stroke-width="1"></line><line x1="1980" y1="100" x2="1980" y2="2900" stroke="#ffffff66" stroke-width="2"></line><line x1="2027" y1="100" x2="2027" y2="2900" stroke="#ffffff33" stroke-width="1"></line><line x1="2074" y1="100" x2="2074" y2="2900" stroke="#ffffff33" stroke-width="1"></line><line x1="2121" y1="100" x2="2121" y2="2900" stroke="#ffffff33" stroke-width="1"></line><line x1="2168" y1="100" x2="2168" y2="2900" stroke="#ffffff33" stroke-width="1"></line><line x1="2215" y1="100" x2="2215" y2="2900" stroke="#ffffff66" stroke-width="2"></line><line x1="2262" y1="100" x2="2262" y2="2900" stroke="#ffffff33" stroke-width="1"></line><line x1="2309" y1="100" x2="2309" y2="2900" stroke="#ffffff33" stroke-width="1"></line><line x1="2356" y1="100" x2="2356" y2="2900" stroke="#ffffff33" stroke-width="1"></line><line x1="2403" y1="100" x2="2403" y2="2900" stroke="#ffffff33" stroke-width="1"></line><line x1="2450" y1="100" x2="2450" y2="2900" stroke="#ffffff66" stroke-width="2"></line><line x1="2497" y1="100" x2="2497" y2="2900" stroke="#ffffff33" stroke-width="1"></line><line x1="2544" y1="100" x2="2544" y2="2900" stroke="#ffffff33" stroke-width="1"></line><line x1="2591" y1="100" x2="2591" y2="2900" stroke="#ffffff33" stroke-width="1"></line><line x1="2638" y1="100" x2="2638" y2="2900" stroke="#ffffff33" stroke-width="1"></line><line x1="2685" y1="100" x2="2685" y2="2900" stroke="#ffffff66" stroke-width="2"></line><line x1="2732" y1="100" x2="2732" y2="2900" stroke="#ffffff33" stroke-width="1"></line><line x1="2779" y1="100" x2="2779" y2="2900" stroke="#ffffff33" stroke-width="1"></line><line x1="2826" y1="100" x2="2826" y2="2900" stroke="#ffffff33" stroke-width="1"></line><line x1="2873" y1="100" x2="2873" y2="2900" stroke="#ffffff33" stroke-width="1"></line><line x1="2920" y1="100" x2="2920" y2="2900" stroke="#ffffff66" stroke-width="2"></line><line x1="2967" y1="100" x2="2967" y2="2900" stroke="#ffffff33" stroke-width="1"></line><line x1="3014" y1="100" x2="3014" y2="2900" stroke="#ffffff33" stroke-width="1"></line><line x1="3061" y1="100" x2="3061" y2="2900" stroke="#ffffff33" stroke-width="1"></line><line x1="3108" y1="100" x2="3108" y2="2900" stroke="#ffffff33" stroke-width="1"></line><line x1="3155" y1="100" x2="3155" y2="2900" stroke="#ffffff66" stroke-width="2"></line><line x1="3202" y1="100" x2="3202" y2="2900" stroke="#ffffff33" stroke-width="1"></line><line x1="3249" y1="100" x2="3249" y2="2900" stroke="#ffffff33" stroke-width="1"></line><line x1="3296" y1="100" x2="3296" y2="2900" stroke="#ffffff33" stroke-width="1"></line><line x1="3343" y1="100" x2="3343" y2="2900" stroke="#ffffff33" stroke-width="1"></line><line x1="3390" y1="100" x2="3390" y2="2900" stroke="#ffffff66" stroke-width="2"></line><line x1="3437" y1="100" x2="3437" y2="2900" stroke="#ffffff33" stroke-width="1"></line><line x1="3484" y1="100" x2="3484" y2="2900" stroke="#ffffff33" stroke-width="1"></line><line x1="3531" y1="100" x2="3531" y2="2900" stroke="#ffffff33" stroke-width="1"></line><line x1="3578" y1="100" x2="3578" y2="2900" stroke="#ffffff33" stroke-width="1"></line><line x1="3625" y1="100" x2="3625" y2="2900" stroke="#ffffff66" stroke-width="2"></line><line x1="3672" y1="100" x2="3672" y2="2900" stroke="#ffffff33" stroke-width="1"></line><line x1="3719" y1="100" x2="3719" y2="2900" stroke="#ffffff33" stroke-width="1"></line><line x1="3766" y1="100" x2="3766" y2="2900" stroke="#ffffff33" stroke-width="1"></line><line x1="3813" y1="100" x2="3813" y2="2900" stroke="#ffffff33" stroke-width="1"></line><line x1="3860" y1="100" x2="3860" y2="2900" stroke="#ffffff66" stroke-width="2"></line><line x1="100" y1="100" x2="3900" y2="100" stroke="#ffffff66" stroke-width="2"></line><line x1="100" y1="147" x2="3900" y2="147" stroke="#ffffff33" stroke-width="1"></line><line x1="100" y1="194" x2="3900" y2="194" stroke="#ffffff33" stroke-width="1"></line><line x1="100" y1="241" x2="3900" y2="241" stroke="#ffffff33" stroke-width="1"></line><line x1="100" y1="288" x2="3900" y2="288" stroke="#ffffff33" stroke-width="1"></line><line x1="100" y1="335" x2="3900" y2="335" stroke="#ffffff66" stroke-width="2"></line><line x1="100" y1="382" x2="3900" y2="382" stroke="#ffffff33" stroke-width="1"></line><line x1="100" y1="429" x2="3900" y2="429" stroke="#ffffff33" stroke-width="1"></line><line x1="100" y1="476" x2="3900" y2="476" stroke="#ffffff33" stroke-width="1"></line><line x1="100" y1="523" x2="3900" y2="523" stroke="#ffffff33" stroke-width="1"></line><line x1="100" y1="570" x2="3900" y2="570" stroke="#ffffff66" stroke-width="2"></line><line x1="100" y1="617" x2="3900" y2="617" stroke="#ffffff33" stroke-width="1"></line><line x1="100" y1="664" x2="3900" y2="664" stroke="#ffffff33" stroke-width="1"></line><line x1="100" y1="711" x2="3900" y2="711" stroke="#ffffff33" stroke-width="1"></line><line x1="100" y1="758" x2="3900" y2="758" stroke="#ffffff33" stroke-width="1"></line><line x1="100" y1="805" x2="3900" y2="805" stroke="#ffffff66" stroke-width="2"></line><line x1="100" y1="852" x2="3900" y2="852" stroke="#ffffff33" stroke-width="1"></line><line x1="100" y1="899" x2="3900" y2="899" stroke="#ffffff33" stroke-width="1"></line><line x1="100" y1="946" x2="3900" y2="946" stroke="#ffffff33" stroke-width="1"></line><line x1="100" y1="993" x2="3900" y2="993" stroke="#ffffff33" stroke-width="1"></line><line x1="100" y1="1040" x2="3900" y2="1040" stroke="#ffffff66" stroke-width="2"></line><line x1="100" y1="1087" x2="3900" y2="1087" stroke="#ffffff33" stroke-width="1"></line><line x1="100" y1="1134" x2="3900" y2="1134" stroke="#ffffff33" stroke-width="1"></line><line x1="100" y1="1181" x2="3900" y2="1181" stroke="#ffffff33" stroke-width="1"></line><line x1="100" y1="1228" x2="3900" y2="1228" stroke="#ffffff33" stroke-width="1"></line><line x1="100" y1="1275" x2="3900" y2="1275" stroke="#ffffff66" stroke-width="2"></line><line x1="100" y1="1322" x2="3900" y2="1322" stroke="#ffffff33" stroke-width="1"></line><line x1="100" y1="1369" x2="3900" y2="1369" stroke="#ffffff33" stroke-width="1"></line><line x1="100" y1="1416" x2="3900" y2="1416" stroke="#ffffff33" stroke-width="1"></line><line x1="100" y1="1463" x2="3900" y2="1463" stroke="#ffffff33" stroke-width="1"></line><line x1="100" y1="1510" x2="3900" y2="1510" stroke="#ffffff66" stroke-width="2"></line><line x1="100" y1="1557" x2="3900" y2="1557" stroke="#ffffff33" stroke-width="1"></line><line x1="100" y1="1604" x2="3900" y2="1604" stroke="#ffffff33" stroke-width="1"></line><line x1="100" y1="1651" x2="3900" y2="1651" stroke="#ffffff33" stroke-width="1"></line><line x1="100" y1="1698" x2="3900" y2="1698" stroke="#ffffff33" stroke-width="1"></line><line x1="100" y1="1745" x2="3900" y2="1745" stroke="#ffffff66" stroke-width="2"></line><line x1="100" y1="1792" x2="3900" y2="1792" stroke="#ffffff33" stroke-width="1"></line><line x1="100" y1="1839" x2="3900" y2="1839" stroke="#ffffff33" stroke-width="1"></line><line x1="100" y1="1886" x2="3900" y2="1886" stroke="#ffffff33" stroke-width="1"></line><line x1="100" y1="1933" x2="3900" y2="1933" stroke="#ffffff33" stroke-width="1"></line><line x1="100" y1="1980" x2="3900" y2="1980" stroke="#ffffff66" stroke-width="2"></line><line x1="100" y1="2027" x2="3900" y2="2027" stroke="#ffffff33" stroke-width="1"></line><line x1="100" y1="2074" x2="3900" y2="2074" stroke="#ffffff33" stroke-width="1"></line><line x1="100" y1="2121" x2="3900" y2="2121" stroke="#ffffff33" stroke-width="1"></line><line x1="100" y1="2168" x2="3900" y2="2168" stroke="#ffffff33" stroke-width="1"></line><line x1="100" y1="2215" x2="3900" y2="2215" stroke="#ffffff66" stroke-width="2"></line><line x1="100" y1="2262" x2="3900" y2="2262" stroke="#ffffff33" stroke-width="1"></line><line x1="100" y1="2309" x2="3900" y2="2309" stroke="#ffffff33" stroke-width="1"></line><line x1="100" y1="2356" x2="3900" y2="2356" stroke="#ffffff33" stroke-width="1"></line><line x1="100" y1="2403" x2="3900" y2="2403" stroke="#ffffff33" stroke-width="1"></line><line x1="100" y1="2450" x2="3900" y2="2450" stroke="#ffffff66" stroke-width="2"></line><line x1="100" y1="2497" x2="3900" y2="2497" stroke="#ffffff33" stroke-width="1"></line><line x1="100" y1="2544" x2="3900" y2="2544" stroke="#ffffff33" stroke-width="1"></line><line x1="100" y1="2591" x2="3900" y2="2591" stroke="#ffffff33" stroke-width="1"></line><line x1="100" y1="2638" x2="3900" y2="2638" stroke="#ffffff33" stroke-width="1"></line><line x1="100" y1="2685" x2="3900" y2="2685" stroke="#ffffff66" stroke-width="2"></line><line x1="100" y1="2732" x2="3900" y2="2732" stroke="#ffffff33" stroke-width="1"></line><line x1="100" y1="2779" x2="3900" y2="2779" stroke="#ffffff33" stroke-width="1"></line><line x1="100" y1="2826" x2="3900" y2="2826" stroke="#ffffff33" stroke-width="1"></line><line x1="100" y1="2873" x2="3900" y2="2873" stroke="#ffffff33" stroke-width="1"></line></g><path d="M 2107.5723876953125 295.1676330566406 Q 2053.7861938476562 397.5838165283203 2000 500" fill="none" class="edge active" data-edge-id="edge-1" data-from="internet" data-to="edge-firewall" style="stroke: rgb(239, 68, 68); stroke-width: 6;"></path><path d="M 2107.5723876953125 295.1676330566406 Q 2053.7861938476562 397.5838165283203 2000 500" fill="none" data-edge-id="edge-1" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2000 500 Q 1850 700 1700 900" fill="none" class="edge" data-edge-id="edge-2" data-from="edge-firewall" data-to="core-switch-1" style="stroke: rgb(245, 158, 11); stroke-width: 5;"></path><path d="M 2000 500 Q 1850 700 1700 900" fill="none" data-edge-id="edge-2" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2000 500 Q 2150 700 2300 900" fill="none" class="edge" data-edge-id="edge-3" data-from="edge-firewall" data-to="core-switch-2" style="stroke: rgb(245, 158, 11); stroke-width: 5;"></path><path d="M 2000 500 Q 2150 700 2300 900" fill="none" data-edge-id="edge-3" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 1700 900 Q 2000 900 2300 900" fill="none" class="edge" data-edge-id="edge-4" data-from="core-switch-1" data-to="core-switch-2" style="stroke: rgb(16, 185, 129); stroke-width: 6;"></path><path d="M 1700 900 Q 2000 900 2300 900" fill="none" data-edge-id="edge-4" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 1700 900 Q 2250 900 2800 900" fill="none" class="edge" data-edge-id="edge-5" data-from="core-switch-1" data-to="dmz-firewall" style="stroke: rgb(239, 68, 68); stroke-width: 4;"></path><path d="M 1700 900 Q 2250 900 2800 900" fill="none" data-edge-id="edge-5" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2800 900 Q 2798.65185546875 1075 2797.3037109375 1250" fill="none" class="edge" data-edge-id="edge-6" data-from="dmz-firewall" data-to="web-server" style="stroke: rgb(239, 68, 68); stroke-width: 4;"></path><path d="M 2800 900 Q 2798.65185546875 1075 2797.3037109375 1250" fill="none" data-edge-id="edge-6" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2800 900 Q 2800 1225 2800 1550" fill="none" class="edge" data-edge-id="edge-7" data-from="dmz-firewall" data-to="mail-server" style="stroke: rgb(239, 68, 68); stroke-width: 4;"></path><path d="M 2800 900 Q 2800 1225 2800 1550" fill="none" data-edge-id="edge-7" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 1700 900 Q 1450 1150 1200 1400" fill="none" class="edge" data-edge-id="edge-8" data-from="core-switch-1" data-to="dist-switch-1" style="stroke: rgb(16, 185, 129); stroke-width: 5;"></path><path d="M 1700 900 Q 1450 1150 1200 1400" fill="none" data-edge-id="edge-8" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2300 900 Q 1750 1150 1200 1400" fill="none" class="edge" data-edge-id="edge-9" data-from="core-switch-2" data-to="dist-switch-1" style="stroke: rgb(16, 185, 129); stroke-width: 5;"></path><path d="M 2300 900 Q 1750 1150 1200 1400" fill="none" data-edge-id="edge-9" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 1700 900 Q 2100 1150 2500 1400" fill="none" class="edge" data-edge-id="edge-10" data-from="core-switch-1" data-to="dist-switch-2" style="stroke: rgb(16, 185, 129); stroke-width: 5;"></path><path d="M 1700 900 Q 2100 1150 2500 1400" fill="none" data-edge-id="edge-10" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2300 900 Q 2400 1150 2500 1400" fill="none" class="edge" data-edge-id="edge-11" data-from="core-switch-2" data-to="dist-switch-2" style="stroke: rgb(16, 185, 129); stroke-width: 5;"></path><path d="M 2300 900 Q 2400 1150 2500 1400" fill="none" data-edge-id="edge-11" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 1200 1400 Q 1000 1650 800 1900" fill="none" class="edge" data-edge-id="edge-12" data-from="dist-switch-1" data-to="access-switch-1" style="stroke: rgb(59, 130, 246); stroke-width: 4;"></path><path d="M 1200 1400 Q 1000 1650 800 1900" fill="none" data-edge-id="edge-12" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 1200 1400 Q 1200 1650 1200 1900" fill="none" class="edge" data-edge-id="edge-13" data-from="dist-switch-1" data-to="access-switch-2" style="stroke: rgb(59, 130, 246); stroke-width: 4;"></path><path d="M 1200 1400 Q 1200 1650 1200 1900" fill="none" data-edge-id="edge-13" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2500 1400 Q 2500 1650 2500 1900" fill="none" class="edge" data-edge-id="edge-14" data-from="dist-switch-2" data-to="access-switch-3" style="stroke: rgb(59, 130, 246); stroke-width: 4;"></path><path d="M 2500 1400 Q 2500 1650 2500 1900" fill="none" data-edge-id="edge-14" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 1700 900 Q 1397.3038940429688 900 1094.6077880859375 900" fill="none" class="edge" data-edge-id="edge-15" data-from="core-switch-1" data-to="domain-controller" style="stroke: rgb(139, 92, 246); stroke-width: 4;"></path><path d="M 1700 900 Q 1397.3038940429688 900 1094.6077880859375 900" fill="none" data-edge-id="edge-15" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 1700 900 Q 1150 900 600 900" fill="none" class="edge" data-edge-id="edge-16" data-from="core-switch-1" data-to="file-server" style="stroke: rgb(139, 92, 246); stroke-width: 4;"></path><path d="M 1700 900 Q 1150 900 600 900" fill="none" data-edge-id="edge-16" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 1700 900 Q 1150 1100 600 1300" fill="none" class="edge" data-edge-id="edge-17" data-from="core-switch-1" data-to="db-server" style="stroke: rgb(139, 92, 246); stroke-width: 4;"></path><path d="M 1700 900 Q 1150 1100 600 1300" fill="none" data-edge-id="edge-17" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 1700 900 Q 1475.4909973144531 1062.2545166015625 1250.9819946289062 1224.509033203125" fill="none" class="edge" data-edge-id="edge-18" data-from="core-switch-1" data-to="backup-server" style="stroke: rgb(139, 92, 246); stroke-width: 4;"></path><path d="M 1700 900 Q 1475.4909973144531 1062.2545166015625 1250.9819946289062 1224.509033203125" fill="none" data-edge-id="edge-18" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 1700 900 Q 2450 1150 3200 1400" fill="none" class="edge" data-edge-id="edge-19" data-from="core-switch-1" data-to="wifi-controller" style="stroke: rgb(6, 182, 212); stroke-width: 4;"></path><path d="M 1700 900 Q 2450 1150 3200 1400" fill="none" data-edge-id="edge-19" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2000 500 Q 1721.3592529296875 496.2307434082031 1442.718505859375 492.46148681640625" fill="none" class="edge" data-edge-id="edge-20" data-from="edge-firewall" data-to="vpn-gateway" style="stroke: rgb(245, 158, 11); stroke-width: 4;"></path><path d="M 2000 500 Q 1721.3592529296875 496.2307434082031 1442.718505859375 492.46148681640625" fill="none" data-edge-id="edge-20" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><polyline class="edge" data-edge-id="custom-1764789640610" fill="none" marker-end="url(#arrow-forward)" points="1692.203125,87.20563507080078 1797.742919921875,-18.33414649963379 1870.6156005859375,62.07711410522461" style="stroke: rgb(249, 115, 22); stroke-width: 4; stroke-dasharray: none;"></polyline><polyline points="1692.203125,87.20563507080078 1797.742919921875,-18.33414649963379 1870.6156005859375,62.07711410522461" data-edge-id="custom-1764789640610" style="fill: none; stroke: transparent; stroke-width: 20; cursor: pointer;"></polyline><polyline class="edge" data-edge-id="custom-1764789700766" fill="none" marker-start="url(#arrow-backward)" marker-end="url(#arrow-forward)" points="3094.37451171875,531.9804077148438 2848.114990234375,396.2864074707031" style="stroke: rgb(249, 115, 22); stroke-width: 4; stroke-dasharray: none;"></polyline><polyline points="3094.37451171875,531.9804077148438 2848.114990234375,396.2864074707031" data-edge-id="custom-1764789700766" style="fill: none; stroke: transparent; stroke-width: 20; cursor: pointer;"></polyline><g class="node-group active" data-node-id="internet" transform="translate(2107.5723876953125,295.1676330566406)" style="cursor: grab;"><circle r="220.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><path d="
             M -117.60000000000001 29.400000000000002
             Q -161.70000000000002 29.400000000000002 -161.70000000000002 -14.700000000000001
             Q -161.70000000000002 -73.5 -102.89999999999999 -73.5
             Q -102.89999999999999 -132.3 -29.400000000000002 -132.3
             Q 14.700000000000001 -161.70000000000002 73.5 -117.60000000000001
             Q 147 -117.60000000000001 161.70000000000002 -44.1
             Q 191.1 -14.700000000000001 161.70000000000002 29.400000000000002
             Q 161.70000000000002 73.5 102.89999999999999 73.5
             L -73.5 73.5
             Q -132.3 73.5 -132.3 29.400000000000002
             Z
            " class="node-circle" style="fill: rgb(0, 0, 0); stroke: rgb(235, 0, 0);"></path><text class="node-label" x="0" y="-41.160000000000004" style="font-size: 40px; fill: rgb(226, 232, 240); font-family: Helvetica, sans-serif; pointer-events: none;">Internet</text><text class="node-sub" x="0" y="58.800000000000004" style="font-size: 31px; fill: rgb(148, 163, 184); font-family: Helvetica, sans-serif; pointer-events: none;">google.com</text></g><g class="node-group" data-node-id="edge-firewall" transform="translate(2000,500)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(52, 65, 86); stroke: rgb(255, 255, 255);"><rect x="-55" y="-44" width="110" height="88" rx="4"></rect><line x1="-46.75" y1="-27.5" x2="46.75" y2="-27.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="-2.75" x2="46.75" y2="-2.75" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="22" x2="46.75" y2="22" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="-44" x2="-27.5" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="-44" x2="11" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="-19.25" x2="-8.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="-19.25" x2="30.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="5.5" x2="-27.5" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="5.5" x2="11" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="30.25" x2="-8.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="30.25" x2="30.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line></g><text class="node-label" x="0" y="-58.400000000000006" style="font-size: 40px; fill: rgb(226, 232, 240); font-family: Helvetica, sans-serif; pointer-events: none;">Edge Firewall</text><text class="node-sub" x="0" y="22" style="font-size: 31px; fill: rgb(148, 163, 184); font-family: Helvetica, sans-serif; pointer-events: none;">192.168.1.1</text></g><g class="node-group" data-node-id="core-switch-1" transform="translate(1700,900)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(52, 65, 86); stroke: rgb(255, 255, 255);"><rect x="-77" y="-22" width="154" height="44" rx="4"></rect><rect x="-66" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-48.4" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-30.799999999999997" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-13.199999999999996" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="4.400000000000006" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="22" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="39.60000000000001" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="57.2" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect></g><text class="node-label" x="0" y="-58.400000000000006" style="font-size: 40px; fill: rgb(226, 232, 240); font-family: Helvetica, sans-serif; pointer-events: none;">Core Switch 1</text><text class="node-sub" x="0" y="22" style="font-size: 31px; fill: rgb(148, 163, 184); font-family: Helvetica, sans-serif; pointer-events: none;">10.0.0.1</text></g><g class="node-group" data-node-id="core-switch-2" transform="translate(2300,900)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(52, 65, 86); stroke: rgb(255, 255, 255);"><rect x="-77" y="-22" width="154" height="44" rx="4"></rect><rect x="-66" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-48.4" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-30.799999999999997" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-13.199999999999996" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="4.400000000000006" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="22" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="39.60000000000001" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="57.2" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect></g><text class="node-label" x="0" y="-41.400000000000006" style="font-size: 40px; fill: rgb(226, 232, 240); font-family: Helvetica, sans-serif; pointer-events: none;">Core Switch 2</text><text class="node-sub" x="0" y="22" style="font-size: 31px; fill: rgb(148, 163, 184); font-family: Helvetica, sans-serif; pointer-events: none;">10.0.0.2</text></g><g class="node-group" data-node-id="dmz-firewall" transform="translate(2800,900)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(52, 65, 86); stroke: rgb(255, 255, 255);"><rect x="-55" y="-44" width="110" height="88" rx="4"></rect><line x1="-46.75" y1="-27.5" x2="46.75" y2="-27.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="-2.75" x2="46.75" y2="-2.75" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="22" x2="46.75" y2="22" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="-44" x2="-27.5" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="-44" x2="11" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="-19.25" x2="-8.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="-19.25" x2="30.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="5.5" x2="-27.5" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="5.5" x2="11" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="30.25" x2="-8.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="30.25" x2="30.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line></g><text class="node-label" x="0" y="-58.400000000000006" style="font-size: 40px; fill: rgb(226, 232, 240); font-family: Helvetica, sans-serif; pointer-events: none;">DMZ Firewall</text><text class="node-sub" x="0" y="22" style="font-size: 31px; fill: rgb(148, 163, 184); font-family: Helvetica, sans-serif; pointer-events: none;">10.10.0.1</text></g><g class="node-group" data-node-id="web-server" transform="translate(2797.3037109375,1250)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(52, 65, 86); stroke: rgb(255, 255, 255);"><rect x="-66" y="-33" width="132" height="66" rx="4"></rect><line x1="-49.5" y1="-16.5" x2="-49.5" y2="16.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="-22" y1="-16.5" x2="-22" y2="16.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="5.5" y1="-16.5" x2="5.5" y2="16.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><circle cx="49.5" cy="0" r="5.5" style="fill: rgb(74, 222, 128);"></circle></g><text class="node-label" x="0" y="-58.400000000000006" style="font-size: 40px; fill: rgb(226, 232, 240); font-family: Helvetica, sans-serif; pointer-events: none;">Web Server</text><text class="node-sub" x="0" y="22" style="font-size: 31px; fill: rgb(148, 163, 184); font-family: Helvetica, sans-serif; pointer-events: none;">10.10.1.10</text></g><g class="node-group" data-node-id="mail-server" transform="translate(2800,1550)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(52, 65, 86); stroke: rgb(255, 255, 255);"><rect x="-66" y="-33" width="132" height="66" rx="4"></rect><line x1="-49.5" y1="-16.5" x2="-49.5" y2="16.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="-22" y1="-16.5" x2="-22" y2="16.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="5.5" y1="-16.5" x2="5.5" y2="16.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><circle cx="49.5" cy="0" r="5.5" style="fill: rgb(74, 222, 128);"></circle></g><text class="node-label" x="0" y="-58.400000000000006" style="font-size: 40px; fill: rgb(226, 232, 240); font-family: Helvetica, sans-serif; pointer-events: none;">Mail Server</text><text class="node-sub" x="0" y="22" style="font-size: 31px; fill: rgb(148, 163, 184); font-family: Helvetica, sans-serif; pointer-events: none;">10.10.1.20</text></g><g class="node-group" data-node-id="dist-switch-1" transform="translate(1200,1400)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(52, 65, 86); stroke: rgb(255, 255, 255);"><rect x="-77" y="-22" width="154" height="44" rx="4"></rect><rect x="-66" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-48.4" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-30.799999999999997" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-13.199999999999996" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="4.400000000000006" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="22" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="39.60000000000001" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="57.2" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect></g><text class="node-label" x="0" y="-58.400000000000006" style="font-size: 40px; fill: rgb(226, 232, 240); font-family: Helvetica, sans-serif; pointer-events: none;">Distribution SW 1</text><text class="node-sub" x="0" y="22" style="font-size: 31px; fill: rgb(148, 163, 184); font-family: Helvetica, sans-serif; pointer-events: none;">10.1.0.1</text></g><g class="node-group" data-node-id="dist-switch-2" transform="translate(2500,1400)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(52, 65, 86); stroke: rgb(255, 255, 255);"><rect x="-77" y="-22" width="154" height="44" rx="4"></rect><rect x="-66" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-48.4" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-30.799999999999997" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-13.199999999999996" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="4.400000000000006" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="22" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="39.60000000000001" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="57.2" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect></g><text class="node-label" x="0" y="-58.400000000000006" style="font-size: 40px; fill: rgb(226, 232, 240); font-family: Helvetica, sans-serif; pointer-events: none;">Distribution SW 2</text><text class="node-sub" x="0" y="22" style="font-size: 31px; fill: rgb(148, 163, 184); font-family: Helvetica, sans-serif; pointer-events: none;">10.2.0.1</text></g><g class="node-group" data-node-id="access-switch-1" transform="translate(800,1900)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(52, 65, 86); stroke: rgb(255, 255, 255);"><rect x="-77" y="-22" width="154" height="44" rx="4"></rect><rect x="-66" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-48.4" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-30.799999999999997" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-13.199999999999996" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="4.400000000000006" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="22" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="39.60000000000001" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="57.2" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect></g><text class="node-label" x="0" y="-58.400000000000006" style="font-size: 40px; fill: rgb(226, 232, 240); font-family: Helvetica, sans-serif; pointer-events: none;">Access SW 1-1</text><text class="node-sub" x="0" y="22" style="font-size: 31px; fill: rgb(148, 163, 184); font-family: Helvetica, sans-serif; pointer-events: none;">10.1.1.1</text></g><g class="node-group" data-node-id="access-switch-2" transform="translate(1200,1900)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(52, 65, 86); stroke: rgb(255, 255, 255);"><rect x="-77" y="-22" width="154" height="44" rx="4"></rect><rect x="-66" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-48.4" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-30.799999999999997" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-13.199999999999996" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="4.400000000000006" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="22" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="39.60000000000001" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="57.2" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect></g><text class="node-label" x="0" y="-58.400000000000006" style="font-size: 40px; fill: rgb(226, 232, 240); font-family: Helvetica, sans-serif; pointer-events: none;">Access SW 1-2</text><text class="node-sub" x="0" y="22" style="font-size: 31px; fill: rgb(148, 163, 184); font-family: Helvetica, sans-serif; pointer-events: none;">10.1.2.1</text></g><g class="node-group" data-node-id="access-switch-3" transform="translate(2500,1900)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(52, 65, 86); stroke: rgb(255, 255, 255);"><rect x="-77" y="-22" width="154" height="44" rx="4"></rect><rect x="-66" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-48.4" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-30.799999999999997" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-13.199999999999996" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="4.400000000000006" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="22" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="39.60000000000001" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="57.2" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect></g><text class="node-label" x="0" y="-58.400000000000006" style="font-size: 40px; fill: rgb(226, 232, 240); font-family: Helvetica, sans-serif; pointer-events: none;">Access SW 2-1</text><text class="node-sub" x="0" y="22" style="font-size: 31px; fill: rgb(148, 163, 184); font-family: Helvetica, sans-serif; pointer-events: none;">10.2.1.1</text></g><g class="node-group" data-node-id="domain-controller" transform="translate(1094.6077880859375,900)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(52, 65, 86); stroke: rgb(255, 255, 255);"><rect x="-66" y="-33" width="132" height="66" rx="4"></rect><line x1="-49.5" y1="-16.5" x2="-49.5" y2="16.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="-22" y1="-16.5" x2="-22" y2="16.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="5.5" y1="-16.5" x2="5.5" y2="16.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><circle cx="49.5" cy="0" r="5.5" style="fill: rgb(74, 222, 128);"></circle></g><text class="node-label" x="0" y="-58.400000000000006" style="font-size: 40px; fill: rgb(226, 232, 240); font-family: Helvetica, sans-serif; pointer-events: none;">Domain Controller</text><text class="node-sub" x="0" y="22" style="font-size: 31px; fill: rgb(148, 163, 184); font-family: Helvetica, sans-serif; pointer-events: none;">10.1.10.10</text></g><g class="node-group" data-node-id="file-server" transform="translate(600,900)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(52, 65, 86); stroke: rgb(255, 255, 255);"><rect x="-66" y="-33" width="132" height="66" rx="4"></rect><line x1="-49.5" y1="-16.5" x2="-49.5" y2="16.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="-22" y1="-16.5" x2="-22" y2="16.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="5.5" y1="-16.5" x2="5.5" y2="16.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><circle cx="49.5" cy="0" r="5.5" style="fill: rgb(74, 222, 128);"></circle></g><text class="node-label" x="0" y="-58.400000000000006" style="font-size: 40px; fill: rgb(226, 232, 240); font-family: Helvetica, sans-serif; pointer-events: none;">File Server</text><text class="node-sub" x="0" y="22" style="font-size: 31px; fill: rgb(148, 163, 184); font-family: Helvetica, sans-serif; pointer-events: none;">10.1.10.20</text></g><g class="node-group" data-node-id="db-server" transform="translate(600,1300)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(52, 65, 86); stroke: rgb(255, 255, 255);"><rect x="-38.5" y="-33" width="77" height="77"></rect><ellipse cx="0" cy="-33" rx="38.5" ry="13.75"></ellipse><ellipse cx="0" cy="44" rx="38.5" ry="13.75"></ellipse><ellipse cx="0" cy="-8.25" rx="38.5" ry="11" style="fill: none; stroke: rgb(71, 85, 105); stroke-width: 2;"></ellipse><ellipse cx="0" cy="19.25" rx="38.5" ry="11" style="fill: none; stroke: rgb(71, 85, 105); stroke-width: 2;"></ellipse></g><text class="node-label" x="0" y="-58.400000000000006" style="font-size: 40px; fill: rgb(226, 232, 240); font-family: Helvetica, sans-serif; pointer-events: none;">Database Server</text><text class="node-sub" x="0" y="22" style="font-size: 31px; fill: rgb(148, 163, 184); font-family: Helvetica, sans-serif; pointer-events: none;">10.1.10.30</text></g><g class="node-group" data-node-id="backup-server" transform="translate(1250.9819946289062,1224.509033203125)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(52, 65, 86); stroke: rgb(255, 255, 255);"><rect x="-66" y="-33" width="132" height="66" rx="4"></rect><line x1="-49.5" y1="-16.5" x2="-49.5" y2="16.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="-22" y1="-16.5" x2="-22" y2="16.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="5.5" y1="-16.5" x2="5.5" y2="16.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><circle cx="49.5" cy="0" r="5.5" style="fill: rgb(74, 222, 128);"></circle></g><text class="node-label" x="0" y="-58.400000000000006" style="font-size: 40px; fill: rgb(226, 232, 240); font-family: Helvetica, sans-serif; pointer-events: none;">Backup Server</text><text class="node-sub" x="0" y="22" style="font-size: 31px; fill: rgb(148, 163, 184); font-family: Helvetica, sans-serif; pointer-events: none;">10.1.10.40</text></g><g class="node-group" data-node-id="wifi-controller" transform="translate(3200,1400)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(52, 65, 86); stroke: rgb(255, 255, 255);"><rect x="-60.50000000000001" y="-16.5" width="121.00000000000001" height="44" rx="6"></rect><rect x="-35.75" y="-49.5" width="5.5" height="33" rx="2"></rect><circle cx="-33" cy="-52.25" r="4.4"></circle><rect x="-2.75" y="-49.5" width="5.5" height="33" rx="2"></rect><circle cx="0" cy="-52.25" r="4.4"></circle><rect x="30.25" y="-49.5" width="5.5" height="33" rx="2"></rect><circle cx="33" cy="-52.25" r="4.4"></circle><circle cx="-38.5" cy="5.5" r="3.3" style="fill: rgb(74, 222, 128);"></circle><circle cx="-19.25" cy="5.5" r="3.3" style="fill: rgb(74, 222, 128);"></circle><circle cx="0" cy="5.5" r="3.3" style="fill: rgb(250, 204, 21);"></circle><circle cx="19.249999999999993" cy="5.5" r="3.3" style="fill: rgb(250, 204, 21);"></circle></g><text class="node-label" x="0" y="-58.400000000000006" style="font-size: 40px; fill: rgb(226, 232, 240); font-family: Helvetica, sans-serif; pointer-events: none;">WiFi Controller</text><text class="node-sub" x="0" y="22" style="font-size: 31px; fill: rgb(148, 163, 184); font-family: Helvetica, sans-serif; pointer-events: none;">10.0.0.100</text></g><g class="node-group" data-node-id="vpn-gateway" transform="translate(1442.718505859375,492.46148681640625)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(52, 65, 86); stroke: rgb(255, 255, 255);"><rect x="-60.50000000000001" y="-16.5" width="121.00000000000001" height="44" rx="6"></rect><rect x="-35.75" y="-49.5" width="5.5" height="33" rx="2"></rect><circle cx="-33" cy="-52.25" r="4.4"></circle><rect x="-2.75" y="-49.5" width="5.5" height="33" rx="2"></rect><circle cx="0" cy="-52.25" r="4.4"></circle><rect x="30.25" y="-49.5" width="5.5" height="33" rx="2"></rect><circle cx="33" cy="-52.25" r="4.4"></circle><circle cx="-38.5" cy="5.5" r="3.3" style="fill: rgb(74, 222, 128);"></circle><circle cx="-19.25" cy="5.5" r="3.3" style="fill: rgb(74, 222, 128);"></circle><circle cx="0" cy="5.5" r="3.3" style="fill: rgb(250, 204, 21);"></circle><circle cx="19.249999999999993" cy="5.5" r="3.3" style="fill: rgb(250, 204, 21);"></circle></g><text class="node-label" x="0" y="-58.400000000000006" style="font-size: 40px; fill: rgb(226, 232, 240); font-family: Helvetica, sans-serif; pointer-events: none;">VPN Gateway</text><text class="node-sub" x="0" y="22" style="font-size: 31px; fill: rgb(148, 163, 184); font-family: Helvetica, sans-serif; pointer-events: none;">10.0.0.50</text></g><g class="node-group" data-node-id="im-a-rack" transform="translate(2704.9699135614965,335.6130504631501)" style="cursor: grab;"><circle r="300" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(219, 0, 0); stroke: rgb(255, 255, 255);"><rect x="-240" y="-120" width="480" height="240" rx="4"></rect><line x1="-180" y1="-60" x2="-180" y2="60" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="-80" y1="-60" x2="-80" y2="60" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="20" y1="-60" x2="20" y2="60" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><circle cx="180" cy="0" r="20" style="fill: rgb(74, 222, 128);"></circle></g><text class="node-label" x="0" y="-56.00000000000001" style="font-size: 52px; fill: rgb(226, 232, 240); font-family: Helvetica, sans-serif; pointer-events: none;">IM A RACK</text><text class="node-sub" x="0" y="80" style="font-size: 31px; fill: rgb(148, 163, 184); font-family: Helvetica, sans-serif; pointer-events: none;"></text></g><g class="text-group" data-text-id="text-1764789614780"><text class="text-element" x="1511.4969482421875" y="142.70753479003906" dominant-baseline="middle" style="fill: rgb(10, 10, 10); font-size: 48px; font-weight: normal; font-style: normal; text-anchor: start; text-decoration: none; opacity: 1; cursor: move; user-select: none;">Google is live!</text><g class="text-delete-btn" style="cursor: pointer; display: none;"><circle cx="1531.4969482421875" cy="94.70753479003906" r="12" style="fill: rgb(245, 101, 101); stroke: white; stroke-width: 2;"></circle><text x="1531.4969482421875" y="94.70753479003906" text-anchor="middle" dominant-baseline="middle" style="fill: white; font-size: 16px; font-weight: bold; pointer-events: none;">Ã—</text></g></g><g class="text-group" data-text-id="text-1764789667151"><text class="text-element" x="2755.139404296875" y="592.2888336181641" dominant-baseline="middle" style="fill: rgb(226, 232, 240); font-size: 43px; font-weight: normal; font-style: normal; text-anchor: start; text-decoration: none; opacity: 1; cursor: move; user-select: none;"><tspan x="2755.139404296875" dy="0">Double click me on desktop</tspan><tspan x="2755.139404296875" dy="51.6">or long press on mobile</tspan><tspan x="2755.139404296875" dy="51.6">to open the rack view</tspan></text><g class="text-delete-btn" style="cursor: pointer; display: none;"><circle cx="2775.139404296875" cy="549.2888336181641" r="12" style="fill: rgb(245, 101, 101); stroke: white; stroke-width: 2;"></circle><text x="2775.139404296875" y="549.2888336181641" text-anchor="middle" dominant-baseline="middle" style="fill: white; font-size: 16px; font-weight: bold; pointer-events: none;">Ã—</text></g></g></svg>
        </div>
        <div class="minimap-zoom-wrapper" id="minimap-zoom-wrapper" style="display: block;">
          <button type="button" class="minimap-close-btn" id="minimap-close-btn" title="Hide map &amp; zoom">âœ•</button>
          <div class="minimap-container" id="minimap-container">
            <svg id="minimap" viewBox="0 0 4000 3000">
              <line x1="2107.5723876953125" y1="295.1676330566406" x2="2000" y2="500" class="minimap-edge"></line><line x1="2000" y1="500" x2="1700" y2="900" class="minimap-edge"></line><line x1="2000" y1="500" x2="2300" y2="900" class="minimap-edge"></line><line x1="1700" y1="900" x2="2300" y2="900" class="minimap-edge"></line><line x1="1700" y1="900" x2="2800" y2="900" class="minimap-edge"></line><line x1="2800" y1="900" x2="2797.3037109375" y2="1250" class="minimap-edge"></line><line x1="2800" y1="900" x2="2800" y2="1550" class="minimap-edge"></line><line x1="1700" y1="900" x2="1200" y2="1400" class="minimap-edge"></line><line x1="2300" y1="900" x2="1200" y2="1400" class="minimap-edge"></line><line x1="1700" y1="900" x2="2500" y2="1400" class="minimap-edge"></line><line x1="2300" y1="900" x2="2500" y2="1400" class="minimap-edge"></line><line x1="1200" y1="1400" x2="800" y2="1900" class="minimap-edge"></line><line x1="1200" y1="1400" x2="1200" y2="1900" class="minimap-edge"></line><line x1="2500" y1="1400" x2="2500" y2="1900" class="minimap-edge"></line><line x1="1700" y1="900" x2="1094.6077880859375" y2="900" class="minimap-edge"></line><line x1="1700" y1="900" x2="600" y2="900" class="minimap-edge"></line><line x1="1700" y1="900" x2="600" y2="1300" class="minimap-edge"></line><line x1="1700" y1="900" x2="1250.9819946289062" y2="1224.509033203125" class="minimap-edge"></line><line x1="1700" y1="900" x2="3200" y2="1400" class="minimap-edge"></line><line x1="2000" y1="500" x2="1442.718505859375" y2="492.46148681640625" class="minimap-edge"></line><circle cx="2107.5723876953125" cy="295.1676330566406" r="40" class="minimap-node"></circle><circle cx="2000" cy="500" r="40" class="minimap-node"></circle><circle cx="1700" cy="900" r="40" class="minimap-node"></circle><circle cx="2300" cy="900" r="40" class="minimap-node"></circle><circle cx="2800" cy="900" r="40" class="minimap-node"></circle><circle cx="2797.3037109375" cy="1250" r="40" class="minimap-node"></circle><circle cx="2800" cy="1550" r="40" class="minimap-node"></circle><circle cx="1200" cy="1400" r="40" class="minimap-node"></circle><circle cx="2500" cy="1400" r="40" class="minimap-node"></circle><circle cx="800" cy="1900" r="40" class="minimap-node"></circle><circle cx="1200" cy="1900" r="40" class="minimap-node"></circle><circle cx="2500" cy="1900" r="40" class="minimap-node"></circle><circle cx="1094.6077880859375" cy="900" r="40" class="minimap-node"></circle><circle cx="600" cy="900" r="40" class="minimap-node"></circle><circle cx="600" cy="1300" r="40" class="minimap-node"></circle><circle cx="1250.9819946289062" cy="1224.509033203125" r="40" class="minimap-node"></circle><circle cx="3200" cy="1400" r="40" class="minimap-node"></circle><circle cx="1442.718505859375" cy="492.46148681640625" r="40" class="minimap-node"></circle><circle cx="2704.9699135614965" cy="335.6130504631501" r="40" class="minimap-node"></circle><rect class="minimap-viewport" id="minimap-viewport" x="563.4450887044272" y="95.16763305664074" width="2673.1098225911455" height="2004.8323669433591"></rect>
            </svg>
          </div>
          <div class="zoom-toolbar" id="zoom-toolbar">
            <button id="zoom-in-btn" title="Zoom in">+</button>
            <div class="zoom-level" id="zoom-level">150%</div>
            <button id="zoom-out-btn" title="Zoom out">-</button>
            <div class="divider"></div>
            <button id="zoom-fit-btn" title="Fit to view">[ ]</button>
            <button id="zoom-reset-btn" title="Reset view">R</button>
          </div>
        </div>
        <button type="button" id="edge-legend-mini" class="legend-mini-btn" style="bottom: 10px; display: none;">Line Legend</button>
        <button type="button" id="minimap-mini" class="legend-mini-btn" style="right: 10px; left: auto; bottom: 10px; display: none;">Map</button>
        <button type="button" id="draw-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: 10px; right: auto; display: none;">Draw</button>
        <button type="button" id="topology-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: auto; right: 40px; display: none;">Add Line</button>
      <button type="button" id="edge-legend-mini" class="legend-mini-btn" style="bottom: 10px; display: none;">Legend</button><button type="button" id="minimap-mini" class="legend-mini-btn" style="right: 10px; left: auto; bottom: 10px; display: none;">Map</button><button type="button" id="draw-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: 10px; right: auto; display: none;">Draw</button><button type="button" id="topology-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: auto; right: 40px; display: none;">Add Line</button><button type="button" id="edge-legend-mini" class="legend-mini-btn" style="bottom: 10px; display: none;">Legend</button><button type="button" id="topology-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: auto; right: 40px; display: none;">Add Line</button><button type="button" id="minimap-mini" class="legend-mini-btn" style="right: 10px; left: auto; bottom: 10px; display: none;">Map</button><button type="button" id="draw-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: 10px; right: auto; display: none;">Draw</button></section>
      <aside class="details-panel" id="details-panel">
        <div class="sidebar-resizer" id="sidebar-resizer">
          <svg class="resizer-icon" width="6" height="40" viewBox="0 0 6 40" xmlns="http://www.w3.org/2000/svg">
            <circle cx="3" cy="14" r="2"></circle>
            <circle cx="3" cy="20" r="2"></circle>
            <circle cx="3" cy="26" r="2"></circle>
          </svg>
        </div>
        <div class="mobile-footer-resizer" id="mobile-footer-resizer">
          <svg class="resizer-icon" width="40" height="6" viewBox="0 0 40 6" xmlns="http://www.w3.org/2000/svg">
            <circle cx="14" cy="3" r="2"></circle>
            <circle cx="20" cy="3" r="2"></circle>
            <circle cx="26" cy="3" r="2"></circle>
          </svg>
        </div>
        <div id="node-panel" style="display: block;">
          <div class="details-name editable-text" id="node-name">Internet</div>
          <div class="details-ip editable-text" id="node-ip">google.com</div>
          <div class="details-role" id="node-role">WAN</div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px;">MAC:</span>
            <span class="editable-text" id="node-mac" style="margin-left: 8px; font-size: 14px;">--</span>
          </div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px;">Rack Unit:</span>
            <span class="editable-text" id="node-rack" style="margin-left: 8px; font-size: 14px;">--</span>
          </div>
          <div class="details-info-row" id="uheight-row" style="display: none;">
            <span style="color: var(--text-soft); font-size: 14px;">U Height:</span>
            <span class="editable-text" id="node-uheight" style="margin-left: 8px; font-size: 14px;">1U</span>
          </div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px;">Layer:</span>
            <select id="node-layer" style="margin-left: 8px; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;">
              <option value="physical">Physical</option>
              <option value="logical">Logical</option>
              <option value="security">Security</option>
              <option value="application">Application</option>
            </select>
          </div>
          <div class="details-info-row" id="assigned-rack-row" style="display: flex;">
            <span style="color: var(--text-soft); font-size: 14px;">Assigned Rack:</span>
            <select id="node-assigned-rack" style="margin-left: 8px; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;"><option value="">None</option><option value="im-a-rack">IM A RACK</option></select>
          </div>
          <div class="details-info-row" id="rack-capacity-row" style="display: none;">
            <span style="color: var(--text-soft); font-size: 14px;">Rack Capacity:</span>
            <select id="node-rack-capacity" style="margin-left: 8px; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;">
              <option value="42">42U</option>
              <option value="48">48U</option>
              <option value="24">24U</option>
              <option value="12">12U</option>
            </select>
          </div>
          <div class="badge-row" id="node-tags"><span class="badge" style="cursor: pointer; position: relative;"><span>1Gbps</span><span style="opacity: 0.6; margin-left: 4px; font-size: 10px;"> âœ•</span></span><span class="badge" style="cursor: pointer; position: relative;"><span>Redundant</span><span style="opacity: 0.6; margin-left: 4px; font-size: 10px;"> âœ•</span></span><span class="badge" style="cursor: pointer; opacity: 0.6; border-style: dashed;">+ Add</span></div>
          <div class="size-controls">
            <label>Size:</label>
            <input type="range" id="size-slider" min="20" max="200" value="55">
            <span id="size-value">147</span>
            <button id="reset-size">Reset</button>
          </div>
          <details class="style-section">
            <summary>Styling</summary>
            <div class="style-content">
              <div class="style-row">
                <label>Screen:</label>
                <select id="style-scope">
                  <option value="all">All</option>
                  <option value="desktop">Desktop</option>
                  <option value="tablet">Tablet</option>
                  <option value="mobile">Mobile</option>
                  <option value="fold">Fold</option>
                </select>
              </div>
              <div class="style-row">
                <label>Shape:</label>
                <select id="shape-select">
                  <optgroup label="Basic Shapes">
                    <option value="circle">Circle</option>
                    <option value="square">Square</option>
                    <option value="rectangle">Rectangle</option>
                    <option value="triangle">Triangle</option>
                    <option value="hexagon">Hexagon</option>
                    <option value="diamond">Diamond</option>
                    <option value="star">Star</option>
                    <option value="stop-sign">Stop Sign</option>
                  </optgroup>
                  <optgroup label="Network Equipment">
                    <option value="server">Server</option>
                    <option value="pc">PC / Desktop</option>
                    <option value="laptop">Laptop</option>
                    <option value="phone">Phone / Mobile</option>
                    <option value="router">Router</option>
                    <option value="switch">Switch</option>
                    <option value="firewall">Firewall</option>
                    <option value="cloud">Cloud</option>
                    <option value="database">Database</option>
                    <option value="printer">Printer</option>
                  </optgroup>
                </select>
              </div>
              <div class="style-row">
                <label>Fill Color:</label>
                <input type="color" id="circle-color" value="#1e293b">
              </div>
              <div class="style-row">
                <label>Border Color:</label>
                <input type="color" id="circle-border" value="#475569">
              </div>
              <div class="style-row">
                <label>Title Color:</label>
                <input type="color" id="title-color" value="#e2e8f0">
              </div>
              <div class="style-row">
                <label>Title Font:</label>
                <select id="title-font">
                  <option value="system-ui, sans-serif"> System UI </option>
                  <option value="monospace">Monospace</option>
                  <option value="serif">Serif</option>
                  <option value="cursive">Cursive</option>
                  <option value="'Courier New', monospace"> Courier </option>
                  <option value="Arial, sans-serif">Arial</option>
                  <option value="'Times New Roman', serif"> Times </option>
                </select>
              </div>
              <div class="style-row">
                <label>Title Size:</label>
                <input type="number" id="title-size" min="8" max="100" value="18">
              </div>
              <div class="style-row">
                <label>Sub Color:</label>
                <input type="color" id="sub-color" value="#94a3b8">
              </div>
              <div class="style-row">
                <label>Sub Font:</label>
                <select id="sub-font">
                  <option value="system-ui, sans-serif"> System UI </option>
                  <option value="monospace">Monospace</option>
                  <option value="serif">Serif</option>
                  <option value="cursive">Cursive</option>
                  <option value="'Courier New', monospace"> Courier </option>
                  <option value="Arial, sans-serif">Arial</option>
                  <option value="'Times New Roman', serif"> Times </option>
                </select>
              </div>
              <div class="style-row">
                <label>Sub Size:</label>
                <input type="number" id="sub-size" min="6" max="80" value="13">
              </div>
              <div style="margin-top: 12px;padding-top: 10px;border-top: 1px solid var(--edge-main);">
                <div style="
                  font-size: 12px;
                  color: var(--text-soft);
                  margin-bottom: 8px;
                  text-transform: uppercase;
                  "> Text Position </div>
                <div class="style-row">
                  <label>Name Y:</label>
                  <input type="number" id="title-offset-y" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>Name X:</label>
                  <input type="number" id="title-offset-x" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>IP Y:</label>
                  <input type="number" id="sub-offset-y" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>IP X:</label>
                  <input type="number" id="sub-offset-x" min="-100" max="100" value="0" style="width: 60px">
                </div>
              </div>
              <button id="reset-styles" style="width: 100%;margin-top: 10px;padding: 8px;background: var(--panel);color: var(--text-main);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: clamp(13px, 1.5vw, 17px);">Reset Styles</button>
            </div>
          </details>
          <div class="section-label">Notes</div>
          <ul class="list" id="node-notes"><li><span style="flex: 1 1 0%;">Primary: Fiber</span><span class="delete-note">âœ•</span></li><li><span style="flex: 1 1 0%;">Backup: Cable</span><span class="delete-note">âœ•</span></li></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-note-input" placeholder="Type new note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-note-btn" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-node-btn" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: rgb(255, 255, 255);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;width: 100%;">Delete Node</button>
        </div>
        <div id="edge-panel" style="display: none">
          <div class="details-name" id="edge-title">Custom line</div>
          <div class="style-row" style="margin-top: 10px">
            <label>Width:</label>
            <input type="number" id="edge-width" min="1" max="20" value="4">
          </div>
          <div class="style-row">
            <label>Color:</label>
            <input type="color" id="edge-color" value="#475569">
          </div>
          <div class="style-row">
            <label>Line Style:</label>
            <select id="edge-line-style">
              <option value="solid">Solid</option>
              <option value="dashed">Dashed</option>
              <option value="dotted">Dotted</option>
            </select>
          </div>
          <div class="style-row">
            <label>Direction:</label>
            <select id="edge-direction">
              <option value="none">No arrows</option>
              <option value="forward">â†’ Forward</option>
              <option value="backward">â† Backward</option>
              <option value="both">â†” Bidirectional</option>
            </select>
          </div>
          <div class="style-row" id="edge-from-port-row" style="display: none;">
            <label>From Port:</label>
            <input type="text" id="edge-from-port" placeholder="e.g. eth0, gi0/1" style="flex: 1;">
          </div>
          <div class="style-row" id="edge-to-port-row" style="display: none;">
            <label>To Port:</label>
            <input type="text" id="edge-to-port" placeholder="e.g. eth1, gi0/2" style="flex: 1;">
          </div>
          <div class="section-label">Line Notes</div>
          <ul class="list" id="edge-notes"></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-edge-note" placeholder="Add note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-edge-note" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-edge" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Delete Line</button>
        </div>
        <div id="rect-panel" style="display: none">
          <div class="details-name" id="rect-title">Zone</div>
          <div class="style-row" id="rect-fill-row" style="margin-top: 10px">
            <label>Fill Color:</label>
            <input type="color" id="rect-color" value="#f97316">
          </div>
          <div class="style-row">
            <label>Border Color:</label>
            <input type="color" id="rect-border-color" value="#f97316">
          </div>
          <div class="style-row">
            <label>Border Width:</label>
            <input type="number" id="rect-border-width" min="0" max="20" value="2">
          </div>
          <div class="style-row">
            <label>Style:</label>
            <select id="rect-style-select">
              <option value="filled">Filled</option>
              <option value="outlined">Outlined</option>
            </select>
          </div>
          <div class="section-label">Zone Notes</div>
          <ul class="list" id="rect-notes"></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-rect-note" placeholder="Add note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-rect-note" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-rect" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Delete Zone</button>
        </div>
        <div id="text-panel" style="display: none">
          <div class="details-name" id="text-title">Text Element</div>
          <div class="style-row" style="margin-top: 10px">
            <label>Content:</label>
            <textarea id="text-content" placeholder="Enter text..." style="width: 100%;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: 14px;min-height: 80px;resize: vertical;font-family: inherit;"></textarea>
          </div>
          <div class="style-row">
            <label>Font Size:</label>
            <input type="number" id="text-font-size" min="8" max="200" value="18" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);">
          </div>
          <div class="style-row">
            <label>Color:</label>
            <input type="color" id="text-color" value="#e2e8f0">
          </div>
          <div class="style-row">
            <label>Font Weight:</label>
            <select id="text-font-weight" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="normal">Normal</option>
              <option value="bold">Bold</option>
              <option value="600">Semi-Bold</option>
              <option value="300">Light</option>
            </select>
          </div>
          <div class="style-row">
            <label>Font Style:</label>
            <select id="text-font-style" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="normal">Normal</option>
              <option value="italic">Italic</option>
            </select>
          </div>
          <div class="style-row">
            <label>Text Align:</label>
            <select id="text-align" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="start">Left</option>
              <option value="middle">Center</option>
              <option value="end">Right</option>
            </select>
          </div>
          <div class="style-row">
            <label>Text Decoration:</label>
            <select id="text-decoration" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="none">None</option>
              <option value="underline">Underline</option>
              <option value="line-through">Strike Through</option>
            </select>
          </div>
          <div class="style-row">
            <label>Background:</label>
            <input type="color" id="text-bg-color" value="#000000">
            <label style="margin-left: 10px; display: flex; align-items: center; gap: 6px;">
            <input type="checkbox" id="text-bg-enabled" style="cursor: pointer;">
            <span style="font-size: 13px;">Enable</span>
            </label>
          </div>
          <div class="style-row">
            <label>Opacity:</label>
            <input type="range" id="text-opacity" min="0" max="1" step="0.1" value="1" style="flex: 1">
            <span id="text-opacity-val" style="min-width: 35px; text-align: right">100%</span>
          </div>
          <button id="delete-text" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;width: 100%;"> Delete Text </button>
        </div>
        <details class="style-section" open="">
          <summary>Page Layout</summary>
          <div class="style-content">
            <div style="padding: 12px; background: var(--panel-alt); border-radius: 6px; color: var(--text-soft); font-size: 13px; line-height: 1.6;">
              <strong style="color: var(--accent); display: block; margin-bottom: 8px;">Drag to Resize:</strong>
              â€¢ <strong>Header:</strong> Drag the bottom edge of the header bar<br>
              â€¢ <strong>Sidebar:</strong> Drag the left edge of the sidebar panel<br>
              â€¢ <strong>Mobile:</strong> Drag the top edge of the footer panel<br>
              <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--edge-main); font-size: 12px;">
                Hover over panel edges to see resize handles
              </div>
            </div>
          </div>
        </details>
      </aside>
    </main>
    <script id="nodes-json" type="application/json">{}</script>
    <script id="topology-state" type="application/json">ENCRYPTED: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</script>
    <script>
      const BASE_NODE_DATA = JSON.parse(document.getElementById("nodes-json").textContent, );
      let currentNodeId = "host";
      let textDrawMode = false;
      let currentEdgeId = null;
      let currentStyleScope = "all";
      let NODE_DATA = {};
      let EDGE_DATA = {
       list: []
      };
      let currentRectId = null;
      let rectDrawMode = false;
      let RECT_DATA = {
       list: []
      };
      let TEXT_DATA = {
       list: []
      };
      let EDGE_LEGEND = {};
      let freeDrawMode = false;
      let savedPositions = {};
      let savedSizes = {};
      let savedStyles = {};
      let legendCollapsed = false;
      let minimapCollapsed = false;
      let drawToolbarCollapsed = false;
      let activeLayers = new Set(["physical", "logical", "security", "application"]);
      let currentView = {
       mode: "topology",  
       rackId: null      
      };
      let savedTopologyView = null; 
      let topologyToolbarCollapsed = false;
      let legendMiniBtn = null;
      let minimapMiniBtn = null;
      let drawToolbarMiniBtn = null;
      let topologyToolbarMiniBtn = null;
      
      let undoStack = [];
      let redoStack = [];
      const MAX_UNDO_STACK = 50;
      
      let selectedNodes = new Set();
      let selectedEdges = new Set();
      let selectedRects = new Set();
      let selectedTexts = new Set();
      let isSelecting = false;
      let selectionStart = null;
      let selectionRect = null;
      let isDraggingSelection = false;
      let dragSelectionStart = null;
      
      let clipboard = null;
      
      const ROLLBACK_STORAGE_KEY = "theonefile_rollbacks";
      const MAX_ROLLBACK_VERSIONS = 50;
      let rollbackVersions = [];
      let currentRollbackIndex = -1;
      
      const AUDIT_STORAGE_KEY = "theonefile_audit_log";
      let auditLog = [];
      const MAX_AUDIT_ENTRIES = 1000;
      
      let documentTabs = [{
        id: "main",
        name: "Main Topology",
        nodes: {},
        edges: { list: [] },
        positions: {},
        sizes: {},
        styles: {},
        legend: {},
        rects: { list: [] },
        texts: { list: [] },
      pageState: null
      }];
      let currentTabIndex = 0;
      
      let encryptedSections = {}; 
      
      let performanceMode = "auto"; 
      let cullOffscreenNodes = true;
      let minimapNeedsUpdate = true;
      let lastMinimapUpdate = 0;
      
      const MobileManager = {
        isMobile: false,
        detect() {
          if (navigator.userAgentData?.mobile === true) {
            this.isMobile = true;
            return true;
          }
          const coarse = matchMedia("(pointer: coarse)").matches;
          const width = window.innerWidth <= 900;
          const portrait = matchMedia("(orientation: portrait)").matches;
          this.isMobile = coarse && (width || portrait);
          return this.isMobile;
        },
        applyInitialCollapse() {
          if (!this.isMobile) return;
          legendCollapsed = true;
          minimapCollapsed = true;
          drawToolbarCollapsed = true;
          topologyToolbarCollapsed = true;
          if (typeof updateLegendVisibility === "function") updateLegendVisibility();
          if (typeof updateMinimapVisibility === "function") updateMinimapVisibility();
          if (typeof updateDrawToolbarVisibility === "function") updateDrawToolbarVisibility();
          if (typeof updateTopologyToolbarVisibility === "function") updateTopologyToolbarVisibility();
        },
        updateBulkToolbar() {
          const desktop = document.getElementById("bulk-toolbar");
          const mobile = document.getElementById("bulk-toolbar-mobile");
          if (!desktop || !mobile) return;
      
          const isVisible = desktop.style.display !== "none" || mobile.style.display !== "none";
          
          if (this.isMobile) {
            desktop.style.display = "none";
            if (isVisible) {
              mobile.style.display = "flex";
            }
          } else {
            mobile.style.display = "none";
            if (isVisible) {
              desktop.style.display = "flex";
            }
          }
        },
        updateLayout() {
          const main = document.querySelector("main");
          if (!main) return;
        },
        updateCanvasHint() {
      const hint = document.getElementById("canvas-hint");
      if (!hint) return;
      
      if (PAGE_STATE.canvasHintText !== undefined && PAGE_STATE.canvasHintText !== "") {
        hint.innerHTML = PAGE_STATE.canvasHintText;
        return;
      }
      
      const items = this.isMobile
      ? [
        "Pinch to zoom",
        "Drag to pan",
        "Add node from top menu",
        "Double tap to clone and align",
        "Double tap to select multiple",
        "You have the power",	
        "Your time is NOW!",
      ]
      : [
        "Scroll to zoom",
        "Drag to pan",
        "Right click to clone and align",
        "Right click to select multiple",
        "You have the power",
        "Your time is NOW!",
      ];
      
      const list = document.createElement("ul");
      for (const item of items) {
      const li = document.createElement("li");
      li.textContent = item;
      list.appendChild(li);
      }
      
      hint.replaceChildren(list);
      },
        autoSelectStyleScope() {
          const scope = document.getElementById("style-scope");
          if (!scope) return;
          if (this.isMobile) scope.value = "mobile";
        },
        updateToolbarStack() {
          if (!this.isMobile) return;
          const draw = document.getElementById("draw-toolbar");
          const topo = document.getElementById("topology-toolbar");
          if (!draw || !topo) return;
          const h = draw.getBoundingClientRect().height;
          document.documentElement.style.setProperty("--draw-toolbar-height", h + "px");
        },
        updateLayoutControls() {
          const sidebarRow = document.getElementById("sidebar-width-row");
          const footerRow = document.getElementById("mobile-footer-row");
          if (sidebarRow && footerRow) {
            if (this.isMobile) {
              sidebarRow.style.display = "none";
              footerRow.style.display = "flex";
            } else {
              sidebarRow.style.display = "flex";
              footerRow.style.display = "none";
            }
          }
        },
        applyAll() {
          this.detect();
          this.applyInitialCollapse();
          this.updateBulkToolbar();
          this.updateLayout();
          this.updateCanvasHint();
          this.autoSelectStyleScope();
          this.updateToolbarStack();
          this.updateLayoutControls();
        }
      };
      
      function isMobileDevice() {
        return MobileManager.isMobile;
      }
      
      function u8ToBase64(u8) {
      let binary = "";
      for (let i = 0; i < u8.length; i++) binary += String.fromCharCode(u8[i]);
      return btoa(binary);
      }
      
      function base64ToU8(base64) {
      const binary = atob(base64);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
      return bytes;
      }
      
      function ensureLegendMiniButton() {
       if (legendMiniBtn) return legendMiniBtn;
       const panel = document.querySelector(".topology-panel");
       if (!panel) return null;
       const btn = document.createElement("button");
       btn.type = "button";
       btn.id = "edge-legend-mini";
       btn.className = "legend-mini-btn";
       btn.textContent = "Legend";
       btn.style.bottom = "10px";
       const handleClick = (e) => {
        e.stopPropagation();
        e.preventDefault();
        legendCollapsed = false;
        updateLegendVisibility();
       };
       btn.addEventListener("click", handleClick);
       btn.addEventListener("touchend", handleClick);
       panel.appendChild(btn);
       legendMiniBtn = btn;
       return btn;
      }
      
      function ensureMinimapMiniButton() {
       if (minimapMiniBtn) return minimapMiniBtn;
       const panel = document.querySelector(".topology-panel");
       if (!panel) return null;
       const btn = document.createElement("button");
       btn.type = "button";
       btn.id = "minimap-mini";
       btn.className = "legend-mini-btn";
       btn.textContent = "Map";
       btn.style.right = "10px";
       btn.style.left = "auto";
       btn.style.bottom = "10px";
       const handleClick = (e) => {
        e.stopPropagation();
        e.preventDefault();
        minimapCollapsed = false;
        updateMinimapVisibility();
       };
       btn.addEventListener("click", handleClick);
       btn.addEventListener("touchend", handleClick);
       panel.appendChild(btn);
       minimapMiniBtn = btn;
       return btn;
      }
      
      function ensureDrawToolbarMiniButton() {
       if (drawToolbarMiniBtn) return drawToolbarMiniBtn;
       const panel = document.querySelector(".topology-panel");
       if (!panel) return null;
       const btn = document.createElement("button");
       btn.type = "button";
       btn.id = "draw-toolbar-mini";
       btn.className = "legend-mini-btn";
       btn.textContent = "Draw";
       btn.style.top = "10px";
       btn.style.left = "10px";
       btn.style.right = "auto";
       const handleClick = (e) => {
        e.stopPropagation();
        e.preventDefault();
        drawToolbarCollapsed = false;
        updateDrawToolbarVisibility();
       };
       btn.addEventListener("click", handleClick);
       btn.addEventListener("touchend", handleClick);
       panel.appendChild(btn);
       drawToolbarMiniBtn = btn;
       return btn;
      }
      
      function ensureTopologyToolbarMiniButton() {
       if (topologyToolbarMiniBtn) return topologyToolbarMiniBtn;
       const panel = document.querySelector(".topology-panel");
       if (!panel) return null;
       const btn = document.createElement("button");
       btn.type = "button";
       btn.id = "topology-toolbar-mini";
       btn.className = "legend-mini-btn";
       btn.textContent = "Add Line";
       btn.style.top = "10px";
       btn.style.left = "auto";
       btn.style.right = "40px";
       const handleClick = (e) => {
        e.stopPropagation();
        e.preventDefault();
        topologyToolbarCollapsed = false;
        updateTopologyToolbarVisibility();
       };
       btn.addEventListener("click", handleClick);
       btn.addEventListener("touchend", handleClick);
       panel.appendChild(btn);
       topologyToolbarMiniBtn = btn;
       return btn;
      }
      
      function updateToolbarStack() {
       if (!isMobileDevice()) return;
       const draw = document.getElementById("draw-toolbar");
       const topo = document.getElementById("topology-toolbar");
       if (!draw || !topo) return;
       const h = draw.getBoundingClientRect().height;
       document.documentElement.style.setProperty("--draw-toolbar-height", h + "px");
      }
      window.addEventListener("resize", updateToolbarStack);
      window.addEventListener("DOMContentLoaded", updateToolbarStack);
      updateToolbarStack();
      
      function updateLegendVisibility() {
       const legend = document.getElementById("edge-legend");
       const mini = ensureLegendMiniButton();
       if (!legend || !mini) return;
       const hasItems = legend.querySelectorAll(".legend-item").length > 0;
       if (!hasItems) {
        legend.style.display = "none";
        mini.style.display = "none";
        return;
       }
       if (legendCollapsed) {
        legend.style.display = "none";
        mini.style.display = "inline-flex";
       } else {
        legend.style.display = "flex";
        mini.style.display = "none";
       }
      }
      
      function updateMinimapVisibility() {
       const wrapper = document.getElementById("minimap-zoom-wrapper");
       const mini = ensureMinimapMiniButton();
       if (!wrapper || !mini) return;
       if (minimapCollapsed) {
        wrapper.style.display = "none";
        mini.style.display = "inline-flex";
       } else {
        wrapper.style.display = "block";
        mini.style.display = "none";
       }
      }
      
      function updateDrawToolbarVisibility() {
       const toolbar = document.getElementById("draw-toolbar");
       const mini = ensureDrawToolbarMiniButton();
       if (!toolbar || !mini) return;
       if (drawToolbarCollapsed) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "inline-flex";
       } else {
      if (isMobileDevice()) {    	   
        toolbar.style.setProperty('display', 'grid', 'important');
        mini.style.display = "none";
      } else {   
        toolbar.style.setProperty('display', 'flex', 'important');
        mini.style.display = "none";	  
      }
       }
      }
      
      function updateTopologyToolbarVisibility() {
       const toolbar = document.getElementById("topology-toolbar");
       const mini = ensureTopologyToolbarMiniButton();
       if (!toolbar || !mini) return;
       const hasSelectedNode = currentNodeId !== null;
       if (!hasSelectedNode) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "none";
       } else if (topologyToolbarCollapsed) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "inline-flex";
       } else {   
      if (isMobileDevice()) {    	   
        toolbar.style.setProperty('display', 'grid', 'important');
        mini.style.display = "none";
        } else {   
        toolbar.style.setProperty('display', 'flex', 'important');
        mini.style.display = "none";	  
      }
       }
      }
      const DEFAULT_CANVAS_HINT = document.getElementById("canvas-hint")?.innerHTML || "";
      const DEFAULT_PAGE_STATE = {
       title: "The One File",
       background: "",
       topbarBg: "rgba(9, 12, 20, 0.9)",
       topbarBorder: "#1f2533",
       panel: "#0b0e13",
       panelAlt: "#10141b",
       accent: "#4fd1c5",
       sidebarBg: "#10141b",
       btnBg: "#0b0e13",
       btnText: "#e2e8f0",
       tagFill: "#1e293b",
       tagText: "#e2e8f0",
       tagBorder: "#475569",
       inputBg: "#0b0e13",
       inputText: "#e2e8f0",
       inputBorder: "#1f2937",
       inputFont: "Inter, system-ui, sans-serif",
       inputFontSize: 14,
       toolbarBg: "#0f172a",
       toolbarBorder: "#1f2937",
       toolbarText: "#94a3b8",
       toolbarBtnBg: "#0b0e13",
       toolbarBtnText: "#e2e8f0",
       minimapDots: "#94a3b8",
       canvasHintEnabled: true,
       canvasHintText: "",
       canvasHintBg: "#0f172a",
       canvasHintColor: "#94a3b8",
       danger: "#f56565",
       textMain: "#e2e8f0",
       textSoft: "#94a3b8",
       topbarHeight: 52,
       sidebarWidth: 350,
       mobileFooterHeight: 40,
       sidebarCollapsed: false,
       nodeFill: "#1e293b",
       nodeStroke: "#475569",
       nodeTitle: "#e2e8f0",
       nodeSub: "#94a3b8",
       nodeTitleSize: 18,
       nodeSubSize: 13,
       nodeFont: "Inter, system-ui, sans-serif",
       defaultEdge: "#475569",
       selectionHandle: "#f59e0b",
       selectionHandleSize: 8,
       groupIndicator: "#4fd1c5",
      canvasGradientTop: "#1e2532",
       canvasGradientBottom: "#050608",
       canvasBorder: "#475569",
       canvasGrid: "#475569",
       canvasGridSize: 50,
       rackFrameFill: "#0f172a",
       rackFrameStroke: "#4fd1c5",
       rackLineColor: "#475569",
       rackTextColor: "#4fd1c5",
      };
      let PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE);
      const CANVAS_WIDTH = 4000;
      let CANVAS_HEIGHT = 3000;
      const BASE_CANVAS_HEIGHT = 3000;
      const CANVAS_PADDING = 100;
      
      const RACK_U_HEIGHT = 70; 
      const RACK_WIDTH = 600;
      const RACK_START_X = CANVAS_WIDTH / 2; 
      const RACK_START_Y = CANVAS_PADDING + 100;
      function getRackUHeight(rackId) {
      const capacity = getRackCapacity(rackId);
      const availableHeight = CANVAS_HEIGHT - RACK_START_Y - 200;
      return Math.floor(availableHeight / capacity);
      }
      let canvasState = {
       zoom: 1,
       panX: 0,
       panY: 0,
       minZoom: 0.25,
       maxZoom: 4,
       isPanning: false,
       panStartX: 0,
       panStartY: 0,
       spacePressed: false,
      };
      
      function getViewBox() {
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       return {
        x: canvasState.panX,
        y: canvasState.panY,
        width: viewWidth,
        height: viewHeight,
       };
      }
      
      function updateViewBox() {
       const svg = document.getElementById("map");
       const vb = getViewBox();
       svg.setAttribute("viewBox", `${vb.x} ${vb.y} ${vb.width} ${vb.height}`, );
       const zoomLevel = document.getElementById("zoom-level");
       if (zoomLevel) {
        zoomLevel.textContent = Math.round(canvasState.zoom * 100) + "%";
       }
       updateMinimap();
       populateRackDropdown();
      }
      
      function updateMinimap() {
       const minimapViewport = document.getElementById("minimap-viewport");
       const minimapSvg = document.getElementById("minimap");
       if (!minimapViewport || !minimapSvg) return;
       const vb = getViewBox();
       minimapViewport.setAttribute("x", vb.x);
       minimapViewport.setAttribute("y", vb.y);
       minimapViewport.setAttribute("width", vb.width);
       minimapViewport.setAttribute("height", vb.height);
       const minimapNodes = minimapSvg.querySelectorAll(".minimap-node");
       minimapNodes.forEach((n) => n.remove());
       const minimapEdges = minimapSvg.querySelectorAll(".minimap-edge");
       minimapEdges.forEach((e) => e.remove());
       
       EDGE_DATA.list.forEach((edge) => {
        if (edge.type === "custom") return;
        
        const fromNode = NODE_DATA[edge.from];
        const toNode = NODE_DATA[edge.to];
        if (!fromNode || !toNode) return;
        
        if (currentView.mode === "rack") {
         if (fromNode.assignedRack !== currentView.rackId || 
             toNode.assignedRack !== currentView.rackId) {
          return;
         }
        } else {
         if (fromNode.assignedRack || toNode.assignedRack) {
          return;
         }
        }
        
        const p1 = savedPositions[edge.from];
        const p2 = savedPositions[edge.to];
        if (!p1 || !p2) return;
        const line = document.createElementNS("http://www.w3.org/2000/svg", "line", );
        line.setAttribute("x1", p1.x);
        line.setAttribute("y1", p1.y);
        line.setAttribute("x2", p2.x);
        line.setAttribute("y2", p2.y);
        line.classList.add("minimap-edge");
        minimapSvg.insertBefore(line, minimapViewport);
       });
       
       Object.entries(savedPositions).forEach(([id, pos]) => {
        const node = NODE_DATA[id];
        if (!node) return;
        
        if (currentView.mode === "rack") {
         if (node.assignedRack !== currentView.rackId) {
          return; 
         }
        } else {
         if (node.assignedRack) {
          return; 
         }
        }
        
        const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle", );
        circle.setAttribute("cx", pos.x);
        circle.setAttribute("cy", pos.y);
        circle.setAttribute("r", 40);
        circle.classList.add("minimap-node");
        minimapSvg.insertBefore(circle, minimapViewport);
       });
      }
      
      function zoomTo(newZoom, centerX, centerY) {
       const oldZoom = canvasState.zoom;
       newZoom = Math.max(canvasState.minZoom, Math.min(canvasState.maxZoom, newZoom), );
       if (centerX !== undefined && centerY !== undefined) {
        const oldWidth = CANVAS_WIDTH / oldZoom;
        const oldHeight = CANVAS_HEIGHT / oldZoom;
        const newWidth = CANVAS_WIDTH / newZoom;
        const newHeight = CANVAS_HEIGHT / newZoom;
        const pointX = canvasState.panX + centerX * oldWidth;
        const pointY = canvasState.panY + centerY * oldHeight;
        canvasState.panX = pointX - centerX * newWidth;
        canvasState.panY = pointY - centerY * newHeight;
       }
       canvasState.zoom = newZoom;
       constrainPan();
       updateViewBox();
      }
      
      function constrainPan() {
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       const minVisiblePortion = 0.1;
       const maxPanX = CANVAS_WIDTH - viewWidth * minVisiblePortion;
       const maxPanY = CANVAS_HEIGHT - viewHeight * minVisiblePortion;
       const minPanX = -viewWidth * (1 - minVisiblePortion);
       const minPanY = -viewHeight * (1 - minVisiblePortion);
       canvasState.panX = Math.max(minPanX, Math.min(maxPanX, canvasState.panX), );
       canvasState.panY = Math.max(minPanY, Math.min(maxPanY, canvasState.panY), );
      }
      
      function fitToContent() {
       const positions = Object.values(savedPositions);
       if (positions.length === 0) {
        resetView();
        return;
       }
       let minX = Infinity,
        minY = Infinity,
        maxX = -Infinity,
        maxY = -Infinity;
       positions.forEach((pos) => {
        minX = Math.min(minX, pos.x - 100);
        minY = Math.min(minY, pos.y - 100);
        maxX = Math.max(maxX, pos.x + 100);
        maxY = Math.max(maxY, pos.y + 100);
       });
       const contentWidth = maxX - minX + 200;
       const contentHeight = maxY - minY + 200;
       const viewport = document.getElementById("canvas-viewport");
       const vpRect = viewport.getBoundingClientRect();
       const aspectRatio = vpRect.width / vpRect.height;
       const contentAspect = contentWidth / contentHeight;
       let newZoom;
       if (contentAspect > aspectRatio) {
        newZoom = (vpRect.width / contentWidth) * (CANVAS_WIDTH / vpRect.width);
       } else {
        newZoom = (vpRect.height / contentHeight) * (CANVAS_HEIGHT / vpRect.height);
       }
       newZoom = Math.max(canvasState.minZoom, Math.min(2, newZoom));
       const viewWidth = CANVAS_WIDTH / newZoom;
       const viewHeight = CANVAS_HEIGHT / newZoom;
       canvasState.zoom = newZoom;
       canvasState.panX = minX - 100 - (viewWidth - contentWidth) / 2;
       canvasState.panY = minY - 100 - (viewHeight - contentHeight) / 2;
       constrainPan();
       updateViewBox();
      }
      
      function resetView() {
       canvasState.zoom = 1;
       canvasState.panX = 0;
       canvasState.panY = 0;
       updateViewBox();
      }
      window.addEventListener("DOMContentLoaded", () => {
       const toggle = document.getElementById("mobile-menu-toggle");
       const menu = document.getElementById("topbar-menu");
       if (!toggle || !menu) return;
       toggle.addEventListener("click", () => {
        menu.classList.toggle("open");
       });
       menu.addEventListener("click", (e) => {
        const target = e.target.closest("a, button");
        if (!target) return;
        if (isMobileDevice()) {
       menu.classList.remove("open");
      }
       });
       const minimapCloseBtn = document.getElementById("minimap-close-btn");
       if (minimapCloseBtn) {
        const handleMinimapClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         minimapCollapsed = true;
         updateMinimapVisibility();
        };
        minimapCloseBtn.addEventListener("click", handleMinimapClose);
        minimapCloseBtn.addEventListener("touchend", handleMinimapClose);
       }
       const drawToolbarCloseBtn = document.getElementById("draw-toolbar-close-btn");
       if (drawToolbarCloseBtn) {
        const handleDrawClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         drawToolbarCollapsed = true;
         updateDrawToolbarVisibility();
        };
        drawToolbarCloseBtn.addEventListener("click", handleDrawClose);
        drawToolbarCloseBtn.addEventListener("touchend", handleDrawClose);
       }
       const topologyToolbarCloseBtn = document.getElementById("topology-toolbar-close-btn");
       if (topologyToolbarCloseBtn) {
        const handleTopologyClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         topologyToolbarCollapsed = true;
         updateTopologyToolbarVisibility();
        };
        topologyToolbarCloseBtn.addEventListener("click", handleTopologyClose);
        topologyToolbarCloseBtn.addEventListener("touchstart", (e) => e.preventDefault(), {
         passive: false
        });
        topologyToolbarCloseBtn.addEventListener("touchend", handleTopologyClose);
       }
      
       updateMinimapVisibility();
       updateDrawToolbarVisibility();
       updateTopologyToolbarVisibility();
      });
      
      function applyLayerFilter() {
       activeLayers.clear();
       if (document.getElementById("layer-physical").checked) activeLayers.add("physical");
       if (document.getElementById("layer-logical").checked) activeLayers.add("logical");
       if (document.getElementById("layer-security").checked) activeLayers.add("security");
       if (document.getElementById("layer-application").checked) activeLayers.add("application");
       forgeTheTopology();
      }
      
      function isNodeVisible(nodeId) {
       const node = NODE_DATA[nodeId];
       if (!node) return false;
       const nodeLayer = node.layer || "physical";
       return activeLayers.has(nodeLayer);
      }
      
      function enterRack(rackId) {
      if (!NODE_DATA[rackId] || !NODE_DATA[rackId].isRack) return;
      const rackCapacity = getRackCapacity(rackId);
      const neededHeight = RACK_START_Y + (rackCapacity * RACK_U_HEIGHT) + 200;
      if (neededHeight > BASE_CANVAS_HEIGHT) {
      CANVAS_HEIGHT = neededHeight;
      }
       
       savedTopologyView = {
        zoom: canvasState.zoom,
        panX: canvasState.panX,
        panY: canvasState.panY
       };
       
       currentView.mode = "rack";
       currentView.rackId = rackId;
       
       const backBtn = document.getElementById("back-to-topology-btn");
       if (backBtn) backBtn.style.display = "inline-block";
       
       const hint = document.getElementById("canvas-hint");
       if (hint) {
        hint.textContent = `Viewing: ${NODE_DATA[rackId].name} | Double click empty space to exit`;
        hint.classList.add("visible");
       }
       
      
      const rackUHeight = getRackUHeight(rackId);
      const rackHeight = rackCapacity * rackUHeight;
      const rackCenterX = RACK_START_X;
      const rackCenterY = RACK_START_Y + (rackHeight / 2);
       
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       
       canvasState.panX = rackCenterX - (viewWidth / 2);
       canvasState.panY = rackCenterY - (viewHeight / 2);
       
       constrainPan();
       updateViewBox();
       
       forgeTheTopology();
      }
      
      function exitRack() {
      CANVAS_HEIGHT = BASE_CANVAS_HEIGHT;
      currentView.mode = "topology";
      currentView.rackId = null;
       
       const backBtn = document.getElementById("back-to-topology-btn");
       if (backBtn) backBtn.style.display = "none";
       
       const hint = document.getElementById("canvas-hint");
       if (hint) {
        hint.classList.remove("visible");
       }
       
       if (savedTopologyView) {
        canvasState.zoom = savedTopologyView.zoom;
        canvasState.panX = savedTopologyView.panX;
        canvasState.panY = savedTopologyView.panY;
        updateViewBox();
       }
       
       forgeTheTopology();
      }
      
      function getRackCapacity(rackId) {
       const node = NODE_DATA[rackId];
       return node && node.rackCapacity ? parseInt(node.rackCapacity) : 42;
      }
      
      function populateRackDropdown() {
       const dropdown = document.getElementById("node-assigned-rack");
       if (!dropdown) return;
       
       dropdown.innerHTML = '<option value="">None</option>';
       
       Object.keys(NODE_DATA).forEach(id => {
        if (NODE_DATA[id].isRack) {
         const option = document.createElement("option");
         option.value = id;
         option.textContent = NODE_DATA[id].name;
         dropdown.appendChild(option);
        }
       });
      }
      
      function wieldThePower() {
       const root = document.documentElement;
       root.style.setProperty("--panel", PAGE_STATE.panel);
       root.style.setProperty("--panel-alt", PAGE_STATE.panelAlt);
       root.style.setProperty("--sidebar-bg", PAGE_STATE.sidebarBg || PAGE_STATE.panelAlt);
       root.style.setProperty("--btn-bg", PAGE_STATE.btnBg || PAGE_STATE.panel);
       root.style.setProperty("--btn-text", PAGE_STATE.btnText || "#e2e8f0");
       root.style.setProperty("--tag-fill", PAGE_STATE.tagFill || "#1e293b");
       root.style.setProperty("--tag-text", PAGE_STATE.tagText || "#e2e8f0");
       root.style.setProperty("--tag-border", PAGE_STATE.tagBorder || "#475569");
       root.style.setProperty("--input-bg", PAGE_STATE.inputBg || "#0b0e13");
       root.style.setProperty("--input-text", PAGE_STATE.inputText || "#e2e8f0");
       root.style.setProperty("--input-border", PAGE_STATE.inputBorder || "#1f2937");
       root.style.setProperty("--input-font", PAGE_STATE.inputFont || "Inter, system-ui, sans-serif");
       root.style.setProperty("--input-font-size", (PAGE_STATE.inputFontSize || 14) + "px");
       root.style.setProperty("--toolbar-bg", PAGE_STATE.toolbarBg || "#0f172a");
       root.style.setProperty("--toolbar-border", PAGE_STATE.toolbarBorder || "#1f2937");
       root.style.setProperty("--toolbar-text", PAGE_STATE.toolbarText || "#94a3b8");
       root.style.setProperty("--toolbar-btn-bg", PAGE_STATE.toolbarBtnBg || "#0b0e13");
       root.style.setProperty("--toolbar-btn-text", PAGE_STATE.toolbarBtnText || "#e2e8f0");
       root.style.setProperty("--minimap-dots", PAGE_STATE.minimapDots || "#94a3b8");
       root.style.setProperty("--canvas-hint-bg", PAGE_STATE.canvasHintBg || "#0f172a");
       root.style.setProperty("--canvas-hint-color", PAGE_STATE.canvasHintColor || "#94a3b8");
       
       const canvasHint = document.getElementById("canvas-hint");
       if (canvasHint) {
        canvasHint.style.display = PAGE_STATE.canvasHintEnabled === false ? "none" : "";
        if (PAGE_STATE.canvasHintText !== undefined && PAGE_STATE.canvasHintText !== "") {
         canvasHint.innerHTML = PAGE_STATE.canvasHintText;
        } else {
         canvasHint.innerHTML = DEFAULT_CANVAS_HINT;
        }
       }
       root.style.setProperty("--accent", PAGE_STATE.accent);
       root.style.setProperty("--danger", PAGE_STATE.danger);
       root.style.setProperty("--text-main", PAGE_STATE.textMain);
       root.style.setProperty("--text-soft", PAGE_STATE.textSoft);
       root.style.setProperty("--topbar-bg", PAGE_STATE.topbarBg);
      root.style.setProperty("--topbar-border", PAGE_STATE.topbarBorder);
       root.style.setProperty("--node-fill", PAGE_STATE.nodeFill || "#1e293b");
       root.style.setProperty("--node-stroke", PAGE_STATE.nodeStroke || "#475569");
       root.style.setProperty("--node-title", PAGE_STATE.nodeTitle || "#e2e8f0");
       root.style.setProperty("--node-sub", PAGE_STATE.nodeSub || "#94a3b8");
       root.style.setProperty("--node-title-size", (PAGE_STATE.nodeTitleSize || 18) + "px");
       root.style.setProperty("--node-sub-size", (PAGE_STATE.nodeSubSize || 13) + "px");
       root.style.setProperty("--node-font", PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif");
       root.style.setProperty("--default-edge", PAGE_STATE.defaultEdge || "#475569");
       root.style.setProperty("--selection-handle", PAGE_STATE.selectionHandle || "#f59e0b");
       root.style.setProperty("--selection-handle-size", (PAGE_STATE.selectionHandleSize || 8) + "px");
       root.style.setProperty("--group-indicator", PAGE_STATE.groupIndicator || "#4fd1c5");
       const topbarHeight = PAGE_STATE.topbarHeight || 52;
       const sidebarWidth = PAGE_STATE.sidebarWidth || 350;
       const mobileFooterHeight = PAGE_STATE.mobileFooterHeight || 40;
       root.style.setProperty("--topbar-height", topbarHeight + "px");
       root.style.setProperty("--sidebar-width", sidebarWidth + "px");
       root.style.setProperty("--mobile-footer-height", mobileFooterHeight + "vh", );
       const mainEl = document.querySelector("main");
       const detailsPanel = document.getElementById("details-panel");
       const sidebarToggle = document.getElementById("sidebar-toggle");
       if (PAGE_STATE.sidebarCollapsed) {
        if (mainEl) mainEl.classList.add("sidebar-collapsed");
        if (detailsPanel) detailsPanel.classList.add("collapsed");
        if (sidebarToggle) {
         sidebarToggle.classList.add("collapsed");
         sidebarToggle.textContent = "â–¶";
        }
       } else {
        if (mainEl) mainEl.classList.remove("sidebar-collapsed");
        if (detailsPanel) detailsPanel.classList.remove("collapsed");
        if (sidebarToggle) {
         sidebarToggle.classList.remove("collapsed");
         sidebarToggle.textContent = "â—€";
        }
       }
       if (PAGE_STATE.background) {
        document.body.style.background = PAGE_STATE.background;
       } else {
        document.body.style.background = `radial-gradient(circle at top, ${PAGE_STATE.canvasGradientTop || "#1e2532"} 0, ${PAGE_STATE.canvasGradientBottom || "#050608"} 70%)`;
       }
       document.title = PAGE_STATE.title || DEFAULT_PAGE_STATE.title;
       const titleEl = document.getElementById("page-title");
       if (titleEl) {
        titleEl.textContent = PAGE_STATE.title || DEFAULT_PAGE_STATE.title;
       }
       
       const sidebarToggleEl = document.getElementById("sidebar-toggle");
       const isMobile = isMobileDevice();
       if (sidebarToggleEl) {
        sidebarToggleEl.style.display = isMobile ? "none" : "flex";
       }
      }
      (async function awakeTheImmortal() {
       let initialState = {};
       let decryptionCancelled = false;
       const stateEl = document.getElementById("topology-state");
       if (stateEl && stateEl.textContent.trim()) {
        try {
         let stateText = stateEl.textContent.trim();
         if (isEncrypted(stateText)) {
          let decrypted = false;
          let attempts = 0;
          const maxAttempts = 3;
          while (!decrypted && attempts < maxAttempts) {
           const password = prompt("This file is encrypted. Enter password to decrypt:\n(Attempt " + (attempts + 1) + " of " + maxAttempts + ")", );
           if (!password) {
            alert("Decryption cancelled. The file will not be loaded.", );
            decryptionCancelled = true;
            break;
           }
           try {
            stateText = await decryptData(stateText, password);
            decrypted = true;
           } catch (e) {
            attempts++;
            if (attempts < maxAttempts) {
             alert("Incorrect password. Please try again.");
            } else {
             alert("Maximum attempts reached. The file will not be loaded.", );
             decryptionCancelled = true;
            }
           }
          }
          if (!decrypted) {
           stateText = "{}";
          }
         }
         initialState = JSON.parse(stateText);
        } catch (e) {
         console.error("Failed to load state:", e);
         initialState = {};
        }
       }
       if (decryptionCancelled) {
        NODE_DATA = {};
        EDGE_DATA = {
         list: []
        };
        RECT_DATA = { list: [] };
        TEXT_DATA = { list: [] };
        EDGE_LEGEND = {};
        savedPositions = {};
        savedSizes = {};
        savedStyles = {};
       } else {
        NODE_DATA = initialState.nodeData ? initialState.nodeData : BASE_NODE_DATA;
        EDGE_DATA = initialState.edgeData ? initialState.edgeData : {
         list: [],
        };
        RECT_DATA = initialState.rectData ? initialState.rectData : { list: [] };
        TEXT_DATA = initialState.textData ? initialState.textData : { list: [] };
        EDGE_LEGEND = initialState.edgeLegend || {};
        savedPositions = initialState.nodePositions || {};
        savedSizes = initialState.nodeSizes || {};
        savedStyles = initialState.nodeStyles || {};
       }
       if (initialState.page) {
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, initialState.page, );
       }
       if (initialState.canvas) {
        canvasState.zoom = initialState.canvas.zoom || 1;
        canvasState.panX = initialState.canvas.panX || 0;
        canvasState.panY = initialState.canvas.panY || 0;
       }
       
       if (initialState.savedTopologyView) {
        savedTopologyView = initialState.savedTopologyView;
       }
       
       if (initialState.documentTabs) {
        documentTabs = initialState.documentTabs;
        currentTabIndex = initialState.currentTabIndex || 0;
        
        const currentTab = documentTabs[currentTabIndex];
        if (currentTab) {
          NODE_DATA = currentTab.nodes || NODE_DATA;
          EDGE_DATA = currentTab.edges || EDGE_DATA;
          savedPositions = currentTab.positions || savedPositions;
          savedSizes = currentTab.sizes || savedSizes;
          savedStyles = currentTab.styles || savedStyles;
          EDGE_LEGEND = currentTab.legend || EDGE_LEGEND;
          RECT_DATA = currentTab.rects || RECT_DATA;
          TEXT_DATA = currentTab.texts || TEXT_DATA;
      if (currentTab.pageState) PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, currentTab.pageState);
        }
       }
           
       if (initialState.encryptedSections) {
        encryptedSections = initialState.encryptedSections;
       }
       
       wieldThePower();
       forgeTheTopology();
       updateViewBox();
       
       MobileManager.applyAll();
       
       const initialNodes = Object.keys(NODE_DATA);
       if (initialNodes.length > 0) {
        claimTheImmortal(initialNodes.includes("host") ? "host" : initialNodes[0], );
       } else {
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.display = "none";
       }
      })();
      
      window.addEventListener("resize", () => {
        MobileManager.applyAll();
      });
      
      function saveEdgeData() {}
      
      function saveEdgeLegend() {}
      
      function getBreakpointKey() {
       const w = window.innerWidth;
       if (w <= 380) return "fold";
       if (w <= 768) return "mobile";
       if (w <= 1024) return "tablet";
       return "desktop";
      }
      
      function resolveStylesEntry(styleEntry) {
       if (!styleEntry) return {};
       if (styleEntry.circleColor || styleEntry.titleColor || styleEntry.titleFont || styleEntry.titleSize || styleEntry.subColor || styleEntry.subFont || styleEntry.subSize) {
        return styleEntry;
       }
       const bp = getBreakpointKey();
       const base = styleEntry.all || {};
       const bpStyles = styleEntry[bp] || {};
       return Object.assign({}, base, bpStyles);
      }
      
      function resolveStylesForNode(id) {
       const styleEntry = savedStyles[id];
       if (!styleEntry) return {};
       return resolveStylesEntry(styleEntry);
      }
      
      function ensureStyleEntry(id) {
       if (!savedStyles[id]) savedStyles[id] = {};
       const entry = savedStyles[id];
       const flatProps = ["circleColor", "circleBorder", "titleColor", "titleFont", "titleSize", "subColor", "subFont", "subSize", ];
       const isFlat = flatProps.some((p) => Object.prototype.hasOwnProperty.call(entry, p), );
       if (isFlat) {
        const all = entry.all || {};
        flatProps.forEach((p) => {
         if (entry[p] !== undefined) {
          all[p] = entry[p];
          delete entry[p];
         }
        });
        entry.all = all;
       }
       return entry;
      }
      
      function getDefaultSize() {
       if (window.innerWidth <= 380) return 120;
       if (window.innerWidth <= 768) return 140;
       if (window.innerWidth <= 1024) return 70;
       return 55;
      }
      
      function createShapeElement(shape, size) {
       const ns = "http://www.w3.org/2000/svg";
       if (shape === "circle") {
        const c = document.createElementNS(ns, "circle");
        c.setAttribute("r", size);
        return c;
       }
       if (shape === "square") {
        const r = document.createElementNS(ns, "rect");
        const s = size * 2;
        r.setAttribute("x", -size);
        r.setAttribute("y", -size);
        r.setAttribute("width", s);
        r.setAttribute("height", s);
        r.setAttribute("rx", 4);
        return r;
       }
       if (shape === "rectangle") {
        const r = document.createElementNS(ns, "rect");
        r.setAttribute("x", -size * 1.4);
        r.setAttribute("y", -size * 0.8);
        r.setAttribute("width", size * 2.8);
        r.setAttribute("height", size * 1.6);
        r.setAttribute("rx", 6);
        return r;
       }
       if (shape === "triangle") {
        const p = document.createElementNS(ns, "polygon");
        const h = size * 1.8;
        const w = size * 2;
        p.setAttribute("points", `0,${-h} ${w / 2},${h / 2} ${-w / 2},${h / 2}`, );
        return p;
       }
       if (shape === "hexagon") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        const pts = [
         [0, -s],
         [s * 0.86, -s * 0.5],
         [s * 0.86, s * 0.5],
         [0, s],
         [-s * 0.86, s * 0.5],
         [-s * 0.86, -s * 0.5],
        ].map((pt) => pt.join(",")).join(" ");
        p.setAttribute("points", pts);
        return p;
       }
       if (shape === "stop-sign") {
        const p = document.createElementNS(ns, "polygon");
        const r = size;
        const ptsArr = [];
        for (let i = 0; i < 8; i++) {
         const a = (Math.PI / 4) * i + Math.PI / 8;
         ptsArr.push([Math.cos(a) * r, Math.sin(a) * r]);
        }
        const pts = ptsArr.map((pt) => pt.join(",")).join(" ");
        p.setAttribute("points", pts);
        return p;
       }
       if (shape === "star") {
        const p = document.createElementNS(ns, "polygon");
        const outer = size;
        const inner = size * 0.45;
        let pts = "";
        for (let i = 0; i < 10; i++) {
         const a = (Math.PI / 5) * i - Math.PI / 2;
         const r = i % 2 === 0 ? outer : inner;
         pts += `${Math.cos(a) * r},${Math.sin(a) * r} `;
        }
        p.setAttribute("points", pts.trim());
        return p;
       }
       if (shape === "diamond") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `0,${-s} ${s},0 0,${s} ${-s},0`);
        return p;
       }
       if (shape === "server") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.2);
        body.setAttribute("y", -size * 0.6);
        body.setAttribute("width", size * 2.4);
        body.setAttribute("height", size * 1.2);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 3; i++) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", -size * 0.9 + i * size * 0.5);
         line.setAttribute("y1", -size * 0.3);
         line.setAttribute("x2", -size * 0.9 + i * size * 0.5);
         line.setAttribute("y2", size * 0.3);
         line.style.stroke = "currentColor";
         line.style.strokeWidth = "2";
         line.style.opacity = "0.5";
         g.appendChild(line);
        }
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", size * 0.9);
        led.setAttribute("cy", 0);
        led.setAttribute("r", size * 0.1);
        led.style.fill = "#4ade80";
        g.appendChild(led);
        return g;
       }
       if (shape === "pc" || shape === "desktop") {
        const g = document.createElementNS(ns, "g");
        const monitor = document.createElementNS(ns, "rect");
        monitor.setAttribute("x", -size * 0.9);
        monitor.setAttribute("y", -size * 0.8);
        monitor.setAttribute("width", size * 1.8);
        monitor.setAttribute("height", size * 1.2);
        monitor.setAttribute("rx", 4);
        g.appendChild(monitor);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.75);
        screen.setAttribute("y", -size * 0.65);
        screen.setAttribute("width", size * 1.5);
        screen.setAttribute("height", size * 0.9);
        screen.setAttribute("rx", 2);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        const neck = document.createElementNS(ns, "rect");
        neck.setAttribute("x", -size * 0.15);
        neck.setAttribute("y", size * 0.4);
        neck.setAttribute("width", size * 0.3);
        neck.setAttribute("height", size * 0.3);
        g.appendChild(neck);
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.5);
        base.setAttribute("y", size * 0.7);
        base.setAttribute("width", size * 1);
        base.setAttribute("height", size * 0.15);
        base.setAttribute("rx", 2);
        g.appendChild(base);
        return g;
       }
       if (shape === "laptop") {
        const g = document.createElementNS(ns, "g");
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.8);
        screen.setAttribute("y", -size * 0.9);
        screen.setAttribute("width", size * 1.6);
        screen.setAttribute("height", size * 1.1);
        screen.setAttribute("rx", 4);
        g.appendChild(screen);
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.9);
        base.setAttribute("y", size * 0.25);
        base.setAttribute("width", size * 1.8);
        base.setAttribute("height", size * 0.6);
        base.setAttribute("rx", 4);
        g.appendChild(base);
        const pad = document.createElementNS(ns, "rect");
        pad.setAttribute("x", -size * 0.25);
        pad.setAttribute("y", size * 0.45);
        pad.setAttribute("width", size * 0.5);
        pad.setAttribute("height", size * 0.25);
        pad.setAttribute("rx", 2);
        pad.style.fill = "#1e293b";
        g.appendChild(pad);
        return g;
       }
       if (shape === "phone" || shape === "mobile") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.45);
        body.setAttribute("y", -size);
        body.setAttribute("width", size * 0.9);
        body.setAttribute("height", size * 2);
        body.setAttribute("rx", 8);
        g.appendChild(body);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.38);
        screen.setAttribute("y", -size * 0.85);
        screen.setAttribute("width", size * 0.76);
        screen.setAttribute("height", size * 1.6);
        screen.setAttribute("rx", 4);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        const btn = document.createElementNS(ns, "rect");
        btn.setAttribute("x", -size * 0.15);
        btn.setAttribute("y", size * 0.82);
        btn.setAttribute("width", size * 0.3);
        btn.setAttribute("height", size * 0.06);
        btn.setAttribute("rx", 2);
        btn.style.fill = "#475569";
        g.appendChild(btn);
        return g;
       }
       if (shape === "router") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.1);
        body.setAttribute("y", -size * 0.3);
        body.setAttribute("width", size * 2.2);
        body.setAttribute("height", size * 0.8);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        for (let i = -1; i <= 1; i++) {
         const ant = document.createElementNS(ns, "rect");
         ant.setAttribute("x", i * size * 0.6 - size * 0.05);
         ant.setAttribute("y", -size * 0.9);
         ant.setAttribute("width", size * 0.1);
         ant.setAttribute("height", size * 0.6);
         ant.setAttribute("rx", 2);
         g.appendChild(ant);
         const tip = document.createElementNS(ns, "circle");
         tip.setAttribute("cx", i * size * 0.6);
         tip.setAttribute("cy", -size * 0.95);
         tip.setAttribute("r", size * 0.08);
         g.appendChild(tip);
        }
        for (let i = 0; i < 4; i++) {
         const led = document.createElementNS(ns, "circle");
         led.setAttribute("cx", -size * 0.7 + i * size * 0.35);
         led.setAttribute("cy", size * 0.1);
         led.setAttribute("r", size * 0.06);
         led.style.fill = i < 2 ? "#4ade80" : "#facc15";
         g.appendChild(led);
        }
        return g;
       }
       if (shape === "switch") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.4);
        body.setAttribute("y", -size * 0.4);
        body.setAttribute("width", size * 2.8);
        body.setAttribute("height", size * 0.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 8; i++) {
         const port = document.createElementNS(ns, "rect");
         port.setAttribute("x", -size * 1.2 + i * size * 0.32);
         port.setAttribute("y", -size * 0.15);
         port.setAttribute("width", size * 0.22);
         port.setAttribute("height", size * 0.3);
         port.setAttribute("rx", 1);
         port.style.fill = "#1e293b";
         g.appendChild(port);
        }
        return g;
       }
       if (shape === "firewall") {
        const g = document.createElementNS(ns, "g");
        const wall = document.createElementNS(ns, "rect");
        wall.setAttribute("x", -size);
        wall.setAttribute("y", -size * 0.8);
        wall.setAttribute("width", size * 2);
        wall.setAttribute("height", size * 1.6);
        wall.setAttribute("rx", 4);
        g.appendChild(wall);
        for (let row = 0; row < 3; row++) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", -size * 0.85);
         line.setAttribute("y1", -size * 0.5 + row * size * 0.45);
         line.setAttribute("x2", size * 0.85);
         line.setAttribute("y2", -size * 0.5 + row * size * 0.45);
         line.style.stroke = "#475569";
         line.style.strokeWidth = "2";
         g.appendChild(line);
        }
        for (let row = 0; row < 4; row++) {
         const offset = row % 2 === 0 ? 0 : size * 0.35;
         for (let col = 0; col < 3; col++) {
          const line = document.createElementNS(ns, "line");
          const x = -size * 0.5 + col * size * 0.7 + offset;
          if (x > -size * 0.85 && x < size * 0.85) {
           line.setAttribute("x1", x);
           line.setAttribute("y1", -size * 0.8 + row * size * 0.45, );
           line.setAttribute("x2", x);
           line.setAttribute("y2", -size * 0.8 + row * size * 0.45 + size * 0.45, );
           line.style.stroke = "#475569";
           line.style.strokeWidth = "2";
           g.appendChild(line);
          }
         }
        }
        return g;
       }
       if (shape === "cloud") {
        const p = document.createElementNS(ns, "path");
        const s = size;
        p.setAttribute("d", `
             M ${-s * 0.8} ${s * 0.2}
             Q ${-s * 1.1} ${s * 0.2} ${-s * 1.1} ${-s * 0.1}
             Q ${-s * 1.1} ${-s * 0.5} ${-s * 0.7} ${-s * 0.5}
             Q ${-s * 0.7} ${-s * 0.9} ${-s * 0.2} ${-s * 0.9}
             Q ${s * 0.1} ${-s * 1.1} ${s * 0.5} ${-s * 0.8}
             Q ${s * 1} ${-s * 0.8} ${s * 1.1} ${-s * 0.3}
             Q ${s * 1.3} ${-s * 0.1} ${s * 1.1} ${s * 0.2}
             Q ${s * 1.1} ${s * 0.5} ${s * 0.7} ${s * 0.5}
             L ${-s * 0.5} ${s * 0.5}
             Q ${-s * 0.9} ${s * 0.5} ${-s * 0.9} ${s * 0.2}
             Z
            `, );
        return p;
       }
       if (shape === "database") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.7);
        body.setAttribute("y", -size * 0.6);
        body.setAttribute("width", size * 1.4);
        body.setAttribute("height", size * 1.4);
        g.appendChild(body);
        const top = document.createElementNS(ns, "ellipse");
        top.setAttribute("cx", 0);
        top.setAttribute("cy", -size * 0.6);
        top.setAttribute("rx", size * 0.7);
        top.setAttribute("ry", size * 0.25);
        g.appendChild(top);
        const bottom = document.createElementNS(ns, "ellipse");
        bottom.setAttribute("cx", 0);
        bottom.setAttribute("cy", size * 0.8);
        bottom.setAttribute("rx", size * 0.7);
        bottom.setAttribute("ry", size * 0.25);
        g.appendChild(bottom);
        const mid1 = document.createElementNS(ns, "ellipse");
        mid1.setAttribute("cx", 0);
        mid1.setAttribute("cy", -size * 0.15);
        mid1.setAttribute("rx", size * 0.7);
        mid1.setAttribute("ry", size * 0.2);
        mid1.style.fill = "none";
        mid1.style.stroke = "#475569";
        mid1.style.strokeWidth = "2";
        g.appendChild(mid1);
        const mid2 = document.createElementNS(ns, "ellipse");
        mid2.setAttribute("cx", 0);
        mid2.setAttribute("cy", size * 0.35);
        mid2.setAttribute("rx", size * 0.7);
        mid2.setAttribute("ry", size * 0.2);
        mid2.style.fill = "none";
        mid2.style.stroke = "#475569";
        mid2.style.strokeWidth = "2";
        g.appendChild(mid2);
        return g;
       }
       if (shape === "printer") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.4);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size * 0.9);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const trayTop = document.createElementNS(ns, "rect");
        trayTop.setAttribute("x", -size * 0.7);
        trayTop.setAttribute("y", -size * 0.8);
        trayTop.setAttribute("width", size * 1.4);
        trayTop.setAttribute("height", size * 0.4);
        trayTop.setAttribute("rx", 2);
        trayTop.style.fill = "#1e293b";
        g.appendChild(trayTop);
        const trayOut = document.createElementNS(ns, "rect");
        trayOut.setAttribute("x", -size * 0.6);
        trayOut.setAttribute("y", size * 0.5);
        trayOut.setAttribute("width", size * 1.2);
        trayOut.setAttribute("height", size * 0.35);
        trayOut.setAttribute("rx", 2);
        g.appendChild(trayOut);
        const paper = document.createElementNS(ns, "rect");
        paper.setAttribute("x", -size * 0.5);
        paper.setAttribute("y", size * 0.3);
        paper.setAttribute("width", size * 1);
        paper.setAttribute("height", size * 0.5);
        paper.style.fill = "#e2e8f0";
        g.appendChild(paper);
        return g;
       }
       const c = document.createElementNS(ns, "circle");
       c.setAttribute("r", size);
       return c;
      }
      
      function createNodeShape(id, size) {
       const shapeType = (NODE_DATA[id] && NODE_DATA[id].shape) || "circle";
       const shapeEl = createShapeElement(shapeType, size);
       shapeEl.classList.add("node-circle");
       const styles = resolveStylesForNode(id);
       shapeEl.style.fill = styles.circleColor || PAGE_STATE.nodeFill || "#1e293b";
       shapeEl.style.stroke = styles.circleBorder || PAGE_STATE.nodeStroke || "#475569";
       return shapeEl;
      }
      
      function forgeTheLegend() {
       const container = document.getElementById("edge-legend");
       if (!container) return;
       container.innerHTML = "";
       const title = document.createElement("div");
       title.className = "legend-title";
       title.textContent = "Line Legend";
       container.appendChild(title);
       const closeBtn = document.createElement("button");
       closeBtn.type = "button";
       closeBtn.className = "legend-close-btn";
       closeBtn.textContent = "âœ•";
       closeBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        legendCollapsed = true;
        updateLegendVisibility();
       });
       container.appendChild(closeBtn);
       const colors = [...new Set(EDGE_DATA.list.map((e) => e.color).filter(Boolean))];
       if (colors.length === 0) {
        updateLegendVisibility();
        return;
       }
       colors.forEach((color) => {
        if (!EDGE_LEGEND[color]) {
         EDGE_LEGEND[color] = "you can edit me too";
        }
        const item = document.createElement("div");
        item.className = "legend-item";
        item.addEventListener("mousedown", (e) => e.stopPropagation());
        item.addEventListener("click", (e) => e.stopPropagation());
        const swatch = document.createElement("span");
        swatch.className = "legend-swatch";
        swatch.style.backgroundColor = color;
        swatch.style.cursor = "pointer";
        swatch.addEventListener("click", (e) => {
         e.stopPropagation();
         const edgeWithColor = EDGE_DATA.list.find(edge => edge.color === color);
         if (edgeWithColor) {
          selectTheConnection(edgeWithColor.id);
         }
        });
        let swatchTouchStart = null;
        let swatchTouchMoved = false;
        swatch.addEventListener("touchstart", (e) => {
         swatchTouchStart = Date.now();
         swatchTouchMoved = false;
         if (e.touches[0]) {
          swatchTouchStartX = e.touches[0].clientX;
          swatchTouchStartY = e.touches[0].clientY;
         }
        }, {
         passive: false
        });
        let swatchTouchStartX = 0, swatchTouchStartY = 0;
        swatch.addEventListener("touchmove", (e) => {
         if (e.touches[0]) {
          const dx = Math.abs(e.touches[0].clientX - swatchTouchStartX);
          const dy = Math.abs(e.touches[0].clientY - swatchTouchStartY);
          if (dx > 10 || dy > 10) swatchTouchMoved = true;
         }
        }, {
         passive: false
        });
        swatch.addEventListener("touchend", (e) => {
         if (swatchTouchStart && !swatchTouchMoved && Date.now() - swatchTouchStart < 400) {
          e.stopPropagation();
          e.preventDefault();
          const edgeWithColor = EDGE_DATA.list.find(edge => edge.color === color);
          if (edgeWithColor) {
           selectTheConnection(edgeWithColor.id);
          }
         }
         swatchTouchStart = null;
         swatchTouchMoved = false;
        }, {
         passive: false
        });
        const label = document.createElement("span");
        label.className = "legend-label";
        label.textContent = EDGE_LEGEND[color];
        if (isMobileDevice()) {
         label.style.cursor = "pointer";
         let labelTapStart = null;
         let labelTapMoved = false;
         label.addEventListener("touchstart", (e) => {
          labelTapStart = Date.now();
          labelTapMoved = false;
          if (e.touches[0]) {
           labelTapStartX = e.touches[0].clientX;
           labelTapStartY = e.touches[0].clientY;
          }
          e.stopPropagation();
         });
         let labelTapStartX = 0, labelTapStartY = 0;
         label.addEventListener("touchmove", (e) => {
          if (e.touches[0]) {
           const dx = Math.abs(e.touches[0].clientX - labelTapStartX);
           const dy = Math.abs(e.touches[0].clientY - labelTapStartY);
           if (dx > 10 || dy > 10) labelTapMoved = true;
          }
         });
         label.addEventListener("touchend", (e) => {
          if (labelTapStart && !labelTapMoved && Date.now() - labelTapStart < 400) {
           e.preventDefault();
           e.stopPropagation();
           const currentText = label.textContent;
           const newText = prompt("Edit legend label:", currentText);
           if (newText !== null && newText.trim()) {
            label.textContent = newText.trim();
            EDGE_LEGEND[color] = newText.trim();
            saveEdgeLegend();
           }
          }
          labelTapStart = null;
          labelTapMoved = false;
         });
        } else {
         label.contentEditable = true;
         label.addEventListener("focus", () => {
          label.classList.add("editing");
         });
         label.addEventListener("blur", () => {
          label.classList.remove("editing");
          const text = label.textContent.trim() || "you can edit me too";
          EDGE_LEGEND[color] = text;
          saveEdgeLegend();
         });
         label.addEventListener("keydown", (e) => {
          if (e.key === "Enter") {
           e.preventDefault();
           label.blur();
          }
         });
        }
        item.append(swatch, label);
        container.appendChild(item);
       });
       updateLegendVisibility();
      }
      
       function deleteRectangle(rectId) {
      pushUndo("delete zone");
        RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== rectId);
        forgeTheTopology();
       }
      
       function updateRectangleDeleteButtons() {
        const deleteButtons = document.querySelectorAll('.rect-delete-btn');
        deleteButtons.forEach(btn => {
         btn.style.display = rectDrawMode ? 'block' : 'none';
        });
       }
      
      function forgeTheTopology() {
       if (!NODE_DATA || !EDGE_DATA) {
        console.warn("forgeTheTopology called before data initialized");
        return;
       }
       const svg = document.getElementById("map");
       svg.innerHTML = "";
       const ns = "http://www.w3.org/2000/svg";
       const defs = document.createElementNS(ns, "defs");
       const markerForward = document.createElementNS(ns, "marker");
       markerForward.id = "arrow-forward";
       markerForward.setAttribute("markerWidth", "10");
       markerForward.setAttribute("markerHeight", "10");
       markerForward.setAttribute("refX", "9");
       markerForward.setAttribute("refY", "3");
       markerForward.setAttribute("orient", "auto");
       markerForward.setAttribute("markerUnits", "strokeWidth");
       const pathForward = document.createElementNS(ns, "path");
       pathForward.setAttribute("d", "M0,0 L0,6 L9,3 z");
       pathForward.setAttribute("fill", "context-stroke");
       markerForward.appendChild(pathForward);
       defs.appendChild(markerForward);
       const markerBackward = document.createElementNS(ns, "marker");
       markerBackward.id = "arrow-backward";
       markerBackward.setAttribute("markerWidth", "10");
       markerBackward.setAttribute("markerHeight", "10");
       markerBackward.setAttribute("refX", "0");
       markerBackward.setAttribute("refY", "3");
       markerBackward.setAttribute("orient", "auto");
       markerBackward.setAttribute("markerUnits", "strokeWidth");
       const pathBackward = document.createElementNS(ns, "path");
       pathBackward.setAttribute("d", "M9,0 L9,6 L0,3 z");
       pathBackward.setAttribute("fill", "context-stroke");
       markerBackward.appendChild(pathBackward);
       defs.appendChild(markerBackward);
       svg.appendChild(defs);
       const boundary = document.createElementNS(ns, "rect");
       boundary.setAttribute("x", CANVAS_PADDING);
       boundary.setAttribute("y", CANVAS_PADDING);
       boundary.setAttribute("width", CANVAS_WIDTH - CANVAS_PADDING * 2);
       boundary.setAttribute("height", CANVAS_HEIGHT - CANVAS_PADDING * 2);
       boundary.setAttribute("fill", "none");
       boundary.setAttribute("stroke", (PAGE_STATE.canvasBorder || "#475569") + "4D");
       boundary.setAttribute("stroke-width", "20");
       boundary.setAttribute("stroke-dasharray", "10 5");
       boundary.setAttribute("rx", "8");
       svg.appendChild(boundary);
       
       if (currentView.mode !== "rack") {
        const gridGroup = document.createElementNS(ns, "g");
        gridGroup.id = "canvas-grid";
        const gridSize = PAGE_STATE.canvasGridSize || 50;
        const gridColor = (PAGE_STATE.canvasGrid || "#475569") + "33";
        const majorGridColor = (PAGE_STATE.canvasGrid || "#475569") + "66";
        
        for (let x = CANVAS_PADDING; x <= CANVAS_WIDTH - CANVAS_PADDING; x += gridSize) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", x);
         line.setAttribute("y1", CANVAS_PADDING);
         line.setAttribute("x2", x);
         line.setAttribute("y2", CANVAS_HEIGHT - CANVAS_PADDING);
         line.setAttribute("stroke", (x - CANVAS_PADDING) % (gridSize * 5) === 0 ? majorGridColor : gridColor);
         line.setAttribute("stroke-width", (x - CANVAS_PADDING) % (gridSize * 5) === 0 ? "2" : "1");
         gridGroup.appendChild(line);
        }
        
        for (let y = CANVAS_PADDING; y <= CANVAS_HEIGHT - CANVAS_PADDING; y += gridSize) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", CANVAS_PADDING);
         line.setAttribute("y1", y);
         line.setAttribute("x2", CANVAS_WIDTH - CANVAS_PADDING);
         line.setAttribute("y2", y);
         line.setAttribute("stroke", (y - CANVAS_PADDING) % (gridSize * 5) === 0 ? majorGridColor : gridColor);
         line.setAttribute("stroke-width", (y - CANVAS_PADDING) % (gridSize * 5) === 0 ? "2" : "1");
         gridGroup.appendChild(line);
        }
        
        svg.appendChild(gridGroup);
       }
       
       if (currentView.mode === "rack" && currentView.rackId) {
        const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
        const rackGroup = document.createElementNS(ns, "g");
        rackGroup.id = "rack-visualization";
        
        const rackFrame = document.createElementNS(ns, "rect");
        rackFrame.setAttribute("x", RACK_START_X - RACK_WIDTH / 2);
        rackFrame.setAttribute("y", RACK_START_Y);
        rackFrame.setAttribute("width", RACK_WIDTH);
      
      rackFrame.setAttribute("height", rackCapacity * rackUHeight);
      
        rackFrame.setAttribute("fill", (PAGE_STATE.rackFrameFill || "#0f172a") + "4D");
        rackFrame.setAttribute("stroke", PAGE_STATE.rackFrameStroke || "#4fd1c5");
        rackFrame.setAttribute("stroke-width", "3");
        rackFrame.setAttribute("rx", "4");
        rackGroup.appendChild(rackFrame);
        
        for (let u = 0; u <= rackCapacity; u++) {
         const y = RACK_START_Y + u * rackUHeight;
      
         
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", RACK_START_X - RACK_WIDTH / 2);
         line.setAttribute("y1", y);
         line.setAttribute("x2", RACK_START_X + RACK_WIDTH / 2);
         line.setAttribute("y2", y);
         line.setAttribute("stroke", (PAGE_STATE.rackLineColor || "#475569") + "66");
         line.setAttribute("stroke-width", u % 5 === 0 ? "2" : "1");
         line.setAttribute("stroke-dasharray", u % 5 === 0 ? "none" : "5,5");
         rackGroup.appendChild(line);
         
         if (u < rackCapacity) {
          const uNumber = rackCapacity - u; 
          const text = document.createElementNS(ns, "text");
          text.setAttribute("x", RACK_START_X - RACK_WIDTH / 2 - 30);
          text.setAttribute("y", y + rackUHeight / 2);
      
          text.setAttribute("text-anchor", "middle");
          text.setAttribute("dominant-baseline", "middle");
          text.style.fill = PAGE_STATE.rackTextColor || "#4fd1c5";
          text.style.fontSize = "14px";
          text.style.fontWeight = "bold";
          text.textContent = `U${uNumber}`;
          rackGroup.appendChild(text);
          
          const textRight = document.createElementNS(ns, "text");
          textRight.setAttribute("x", RACK_START_X + RACK_WIDTH / 2 + 30);
          textRight.setAttribute("y", y + rackUHeight / 2);
      
          textRight.setAttribute("text-anchor", "middle");
          textRight.setAttribute("dominant-baseline", "middle");
          textRight.style.fill = PAGE_STATE.rackTextColor || "#4fd1c5";
          textRight.style.fontSize = "14px";
          textRight.style.fontWeight = "bold";
          textRight.textContent = `U${uNumber}`;
          rackGroup.appendChild(textRight);
         }
        }
        
        svg.appendChild(rackGroup);
       }
       
        if (RECT_DATA && RECT_DATA.list) {
         RECT_DATA.list.forEach((rect) => {
          if (currentView.mode === "rack") return;
          
          if (rect.style === "filled") {
           const g = document.createElementNS(ns, "g");
           g.classList.add("rect-group");
           g.dataset.rectId = rect.id;
           
           const rectEl = document.createElementNS(ns, "rect");
           rectEl.classList.add("rect-shape");
           rectEl.setAttribute("x", rect.x);
           rectEl.setAttribute("y", rect.y);
           rectEl.setAttribute("width", rect.width);
           rectEl.setAttribute("height", rect.height);
           rectEl.style.fill = rect.color;
           rectEl.style.fillOpacity = "0.3";
           rectEl.style.stroke = rect.borderColor || rect.color;
           rectEl.style.strokeWidth = (rect.borderWidth !== undefined ? rect.borderWidth : 2) + "px";
           if (rect.lineStyle === "dashed") { rectEl.style.strokeDasharray = "10,5"; }
           else if (rect.lineStyle === "dotted") { rectEl.style.strokeDasharray = "2,4"; }
           else { rectEl.style.strokeDasharray = "none"; }
           rectEl.style.cursor = "move";
           
          rectEl.addEventListener("click", (e) => {
             if (rectDrawMode) return;
             e.stopPropagation();
             currentRectId = rect.id;
             selectTheRect(rect.id);
           });
           
           rectEl.addEventListener("contextmenu", (e) => {
             e.preventDefault();
             e.stopPropagation();
             if (selectedRects.has(rect.id)) {
               selectedRects.delete(rect.id);
             } else {
               selectedRects.add(rect.id);
             }
             updateAllSelections();
           });
           
           let rectLastTap = 0;
           rectEl.addEventListener("touchend", (e) => {
             const now = Date.now();
             if (now - rectLastTap < 300) {
               e.preventDefault();
               if (selectedRects.has(rect.id)) {
                 selectedRects.delete(rect.id);
               } else {
                 selectedRects.add(rect.id);
               }
               updateAllSelections();
               if (navigator.vibrate) navigator.vibrate(50);
               rectLastTap = 0;
             } else {
               rectLastTap = now;
             }
           }, { passive: false });
      
           const deleteBtn = document.createElementNS(ns, "g");
           deleteBtn.classList.add("rect-delete-btn");
           deleteBtn.style.cursor = "pointer";
           deleteBtn.style.display = rectDrawMode ? "block" : "none";
           
           const deleteBg = document.createElementNS(ns, "circle");
           deleteBg.setAttribute("cx", rect.x + rect.width - 10);
           deleteBg.setAttribute("cy", rect.y + 10);
           deleteBg.setAttribute("r", 12);
           deleteBg.style.fill = "#f56565";
           deleteBg.style.stroke = "white";
           deleteBg.style.strokeWidth = "2";
           
           const deleteX = document.createElementNS(ns, "text");
           deleteX.setAttribute("x", rect.x + rect.width - 10);
           deleteX.setAttribute("y", rect.y + 10);
           deleteX.setAttribute("text-anchor", "middle");
           deleteX.setAttribute("dominant-baseline", "middle");
           deleteX.style.fill = "white";
           deleteX.style.fontSize = "16px";
           deleteX.style.fontWeight = "bold";
           deleteX.style.pointerEvents = "none";
           deleteX.textContent = "Ã—";
           
           deleteBtn.appendChild(deleteBg);
           deleteBtn.appendChild(deleteX);
           
           deleteBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            e.preventDefault();
            deleteRectangle(rect.id);
           });
      
           deleteBtn.addEventListener("touchend", (e) => {
      e.stopPropagation();
           e.preventDefault();
           deleteRectangle(rect.id);
           });
           
           let isDragging = false;
           let dragStartX, dragStartY;
           let rectStartX, rectStartY;
           
         rectEl.addEventListener("mousedown", (e) => {
      if (rectDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      rectStartX = rect.x;
      rectStartY = rect.y;
      rectEl.style.cursor = "grabbing";
      
      if (selectedRects.has(rect.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
           
           const moveHandler = (e) => {
      if (!isDragging || rectDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      
      rect.x = rectStartX + dx;
      rect.y = rectStartY + dy;
      
      if (selectedRects.has(rect.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       const newX = initialPositions[nodeId].x + dx;
       const newY = initialPositions[nodeId].y + dy;
       savedPositions[nodeId] = { x: newX, y: newY };
      }
      });
      selectedRects.forEach(rectId => {
      if (rectId === rect.id) return;
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      
      forgeTheTopology();
      };
           
           const upHandler = () => {
            if (isDragging) {
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           };
           
           document.addEventListener("mousemove", moveHandler);
           document.addEventListener("mouseup", upHandler);
           
           let touchStartX, touchStartY;
           let touchRectStartX, touchRectStartY;
           
           rectEl.addEventListener("touchstart", (e) => {
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchRectStartX = rect.x;
            touchRectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           }, { passive: false });
           
           rectEl.addEventListener("touchmove", (e) => {
            if (!isDragging || rectDrawMode) return;
            if (!e.touches[0]) return;
            e.preventDefault();
            e.stopPropagation();
            
            const svgEl = svg;
            const pt1 = svgEl.createSVGPoint();
            pt1.x = touchStartX;
            pt1.y = touchStartY;
            const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
            
            const touch = e.touches[0];
            const pt2 = svgEl.createSVGPoint();
            pt2.x = touch.clientX;
            pt2.y = touch.clientY;
            const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
            
            const dx = svgP2.x - svgP1.x;
            const dy = svgP2.y - svgP1.y;
            
            rect.x = touchRectStartX + dx;
            rect.y = touchRectStartY + dy;
            
            forgeTheTopology();
           }, { passive: false });
           
           rectEl.addEventListener("touchend", (e) => {
            if (isDragging) {
             e.preventDefault();
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           }, { passive: false });
            if (currentRectId === rect.id) {
      const corners = [
      { cx: rect.x, cy: rect.y, cursor: 'nwse-resize', dx: -1, dy: -1 },
      { cx: rect.x + rect.width, cy: rect.y, cursor: 'nesw-resize', dx: 1, dy: -1 },
      { cx: rect.x, cy: rect.y + rect.height, cursor: 'nesw-resize', dx: -1, dy: 1 },
      { cx: rect.x + rect.width, cy: rect.y + rect.height, cursor: 'nwse-resize', dx: 1, dy: 1 }
      ];
      corners.forEach((corner, idx) => {
      const handle = document.createElementNS(ns, "circle");
      handle.setAttribute("cx", corner.cx);
      handle.setAttribute("cy", corner.cy);
      handle.setAttribute("r", PAGE_STATE.selectionHandleSize || 8);
      handle.style.fill = PAGE_STATE.selectionHandle || "#f59e0b";
      handle.style.stroke = "#fff";
      handle.style.strokeWidth = "2";
      handle.style.cursor = corner.cursor;
      handle.addEventListener("mousedown", (e) => {
      e.preventDefault();
      e.stopPropagation();
      let dragging = true;
      const startX = e.clientX, startY = e.clientY;
      const origX = rect.x, origY = rect.y, origW = rect.width, origH = rect.height;
      const moveHandler = (ev) => {
        if (!dragging) return;
        const pt1 = svg.createSVGPoint(); pt1.x = startX; pt1.y = startY;
        const pt2 = svg.createSVGPoint(); pt2.x = ev.clientX; pt2.y = ev.clientY;
        const svgP1 = pt1.matrixTransform(svg.getScreenCTM().inverse());
        const svgP2 = pt2.matrixTransform(svg.getScreenCTM().inverse());
        const dx = svgP2.x - svgP1.x, dy = svgP2.y - svgP1.y;
        if (corner.dx < 0) { rect.x = origX + dx; rect.width = origW - dx; }
        else { rect.width = origW + dx; }
        if (corner.dy < 0) { rect.y = origY + dy; rect.height = origH - dy; }
        else { rect.height = origH + dy; }
        if (rect.width < 20) rect.width = 20;
        if (rect.height < 20) rect.height = 20;
        forgeTheTopology();
      };
      const upHandler = () => { dragging = false; document.removeEventListener("mousemove", moveHandler); document.removeEventListener("mouseup", upHandler); };
      document.addEventListener("mousemove", moveHandler);
      document.addEventListener("mouseup", upHandler);
      });
      g.appendChild(handle);
      });
      }
          if (rect.groupId) {
      const groupIndicator = document.createElementNS(ns, "rect");
      groupIndicator.setAttribute("x", rect.x - 4);
      groupIndicator.setAttribute("y", rect.y - 4);
      groupIndicator.setAttribute("width", rect.width + 8);
      groupIndicator.setAttribute("height", rect.height + 8);
      groupIndicator.style.fill = "none";
      groupIndicator.style.stroke = "#4fd1c5";
      groupIndicator.style.strokeWidth = "3";
      groupIndicator.style.strokeDasharray = "5,5";
      groupIndicator.style.pointerEvents = "none";
      g.insertBefore(groupIndicator, g.firstChild);
      }
      g.appendChild(rectEl);
      g.appendChild(deleteBtn);
      svg.appendChild(g);
          }
         });
        }
       const centerX = CANVAS_WIDTH / 2;
       const centerY = CANVAS_HEIGHT / 2;
       let positions = {};
              Object.keys(NODE_DATA).forEach((id) => {
        if (currentView.mode === "rack") {
         const node = NODE_DATA[id];
         if (!node || node.assignedRack !== currentView.rackId) {
          return; 
         }
        }
        
        positions[id] = savedPositions[id] || {
         x: centerX,
         y: centerY
        };
       });
       if (Object.keys(savedPositions).length === 0) {
        const nodeIds = Object.keys(NODE_DATA).filter(id => {
         if (currentView.mode === "rack") {
          const node = NODE_DATA[id];
          return node && node.assignedRack === currentView.rackId;
         }
         return true;
        });
        
        const baseY = centerY - 300;
        if (nodeIds.length > 0) {
         positions[nodeIds[0]] = {
          x: centerX,
          y: baseY
         };
         const remaining = nodeIds.slice(1);
         const radius = 350;
         const startAngle = Math.PI * 0.3;
         const endAngle = Math.PI * 0.7;
         remaining.forEach((id, i) => {
          const angle = startAngle + (endAngle - startAngle) * (i / Math.max(1, remaining.length - 1));
          positions[id] = {
           x: centerX + Math.cos(angle) * radius * (i % 2 === 0 ? 1 : 1.3),
           y: baseY + 200 + Math.sin(angle) * radius * 0.8 + i * 80,
          };
         });
        }
       }
       Object.keys(positions).forEach((id) => {
        let pos = savedPositions[id] || positions[id];
        const nodeSize = savedSizes[id] || 55;
        pos.x = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, pos.x), );
        pos.y = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, pos.y), );
        positions[id] = {
         x: pos.x,
         y: pos.y
        };
        savedPositions[id] = {
         x: pos.x,
         y: pos.y
        };
       });
       const edgePairCount = {};
       const edgePairIndex = {};
       EDGE_DATA.list.forEach((edge) => {
        if (edge.type === "custom") return;
        const key = [edge.from, edge.to].sort().join("||");
        edgePairCount[key] = (edgePairCount[key] || 0) + 1;
       });
       EDGE_DATA.list.forEach((edge) => {
        if (edge.type === "custom") return;
        const key = [edge.from, edge.to].sort().join("||");
        if (!edgePairIndex[key]) edgePairIndex[key] = 0;
        edge._pairIndex = edgePairIndex[key];
        edge._pairTotal = edgePairCount[key];
        edgePairIndex[key]++;
       });
       EDGE_DATA.list.forEach((edge) => {
        if (edge.type === "custom" && Array.isArray(edge.points) && edge.points.length >= 2) {
         const poly = document.createElementNS(ns, "polyline");
         poly.classList.add("edge");
         poly.dataset.edgeId = edge.id;
         poly.style.stroke = edge.color || PAGE_STATE.defaultEdge || "#475569";
         poly.style.strokeWidth = edge.width || 4;
         poly.setAttribute("fill", "none");
         const lineStyle = edge.lineStyle || "solid";
         if (lineStyle === "dashed") {
          poly.style.strokeDasharray = "10,5";
         } else if (lineStyle === "dotted") {
          poly.style.strokeDasharray = "2,4";
         } else {
          poly.style.strokeDasharray = "none";
         }
         const direction = edge.direction || "none";
         if (direction === "forward") {
          poly.setAttribute("marker-end", "url(#arrow-forward)");
         } else if (direction === "backward") {
          poly.setAttribute("marker-start", "url(#arrow-backward)");
         } else if (direction === "both") {
          poly.setAttribute("marker-start", "url(#arrow-backward)");
          poly.setAttribute("marker-end", "url(#arrow-forward)");
         }
         const ptsStr = edge.points.map((p) => `${p.x},${p.y}`).join(" ");
         poly.setAttribute("points", ptsStr);
         const polyHit = document.createElementNS(ns, "polyline");
         polyHit.setAttribute("points", ptsStr);
         polyHit.style.fill = "none";
         polyHit.style.stroke = "transparent";
         polyHit.style.strokeWidth = "20";
         polyHit.style.cursor = "pointer";
         polyHit.dataset.edgeId = edge.id;
         polyHit.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         let edgeTouchStart = null;
         let edgeTouchMoved = false;
         polyHit.addEventListener("touchstart", (e) => {
          edgeTouchStart = Date.now();
          edgeTouchMoved = false;
          if (e.touches[0]) {
           edgeTouchStartX = e.touches[0].clientX;
           edgeTouchStartY = e.touches[0].clientY;
          }
         }, {
          passive: false
         });
         let edgeTouchStartX = 0, edgeTouchStartY = 0;
         polyHit.addEventListener("touchmove", (e) => {
          if (e.touches[0]) {
           const dx = Math.abs(e.touches[0].clientX - edgeTouchStartX);
           const dy = Math.abs(e.touches[0].clientY - edgeTouchStartY);
           if (dx > 10 || dy > 10) edgeTouchMoved = true;
          }
         }, {
          passive: false
         });
         polyHit.addEventListener("touchend", (e) => {
          if (edgeTouchStart && !edgeTouchMoved && Date.now() - edgeTouchStart < 400) {
           e.stopPropagation();
           e.preventDefault();
           selectTheConnection(edge.id);
          }
          edgeTouchStart = null;
          edgeTouchMoved = false;
         }, {
          passive: false
         });
         poly.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         
         polyHit.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (selectedEdges.has(edge.id)) {
           selectedEdges.delete(edge.id);
          } else {
           selectedEdges.add(edge.id);
          }
          updateAllSelections();
         });
         
         let customEdgeLastTap = 0;
         polyHit.addEventListener("touchend", (e) => {
          const now = Date.now();
          if (now - customEdgeLastTap < 300) {
           e.preventDefault();
           if (selectedEdges.has(edge.id)) {
            selectedEdges.delete(edge.id);
           } else {
            selectedEdges.add(edge.id);
           }
           updateAllSelections();
           if (navigator.vibrate) navigator.vibrate(50);
           customEdgeLastTap = 0;
          } else {
           customEdgeLastTap = now;
          }
         }, { passive: false });   
         poly.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (selectedEdges.has(edge.id)) {
           selectedEdges.delete(edge.id);
          } else {
           selectedEdges.add(edge.id);
          }
          updateAllSelections();
         });
         
         let edgeLastTap = 0;
         poly.addEventListener("touchend", (e) => {
          const now = Date.now();
          if (now - edgeLastTap < 300) {
           e.preventDefault();
           if (selectedEdges.has(edge.id)) {
            selectedEdges.delete(edge.id);
           } else {
            selectedEdges.add(edge.id);
           }
           updateAllSelections();
           if (navigator.vibrate) navigator.vibrate(50);
           edgeLastTap = 0;
          } else {
           edgeLastTap = now;
          }
         });
         
         if (currentView.mode === "rack") {
          return;
         }
         if (edge.groupId) {
      const bounds = edge.points.reduce((acc, p) => ({ minX: Math.min(acc.minX, p.x), minY: Math.min(acc.minY, p.y), maxX: Math.max(acc.maxX, p.x), maxY: Math.max(acc.maxY, p.y) }), { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity });
      const groupIndicator = document.createElementNS(ns, "rect");
      groupIndicator.setAttribute("x", bounds.minX - 8);
      groupIndicator.setAttribute("y", bounds.minY - 8);
      groupIndicator.setAttribute("width", bounds.maxX - bounds.minX + 16);
      groupIndicator.setAttribute("height", bounds.maxY - bounds.minY + 16);
      groupIndicator.setAttribute("rx", "4");
      groupIndicator.style.fill = "none";
      groupIndicator.style.stroke = "#4fd1c5";
      groupIndicator.style.strokeWidth = "3";
      groupIndicator.style.strokeDasharray = "5,5";
      groupIndicator.style.pointerEvents = "none";
      svg.appendChild(groupIndicator);
      }
         let lineDragging = false;
      let lineDragStartX, lineDragStartY;
      let linePointsStart = [];
      
      polyHit.addEventListener("mousedown", (e) => {
      if (freeDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      lineDragging = true;
      lineDragStartX = e.clientX;
      lineDragStartY = e.clientY;
      linePointsStart = edge.points.map(p => ({x: p.x, y: p.y}));
      
      if (selectedEdges.has(edge.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
      
      const lineMoveHandler = (e) => {
      if (!lineDragging || freeDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = lineDragStartX;
      pt1.y = lineDragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      
      edge.points.forEach((p, i) => { p.x = linePointsStart[i].x + dx; p.y = linePointsStart[i].y + dy; });
      
      if (selectedEdges.has(edge.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       savedPositions[nodeId] = { x: initialPositions[nodeId].x + dx, y: initialPositions[nodeId].y + dy };
      }
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      if (edgeId === edge.id) return;
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      forgeTheTopology();
      };
      
      const lineUpHandler = () => { lineDragging = false; };
      document.addEventListener("mousemove", lineMoveHandler);
      document.addEventListener("mouseup", lineUpHandler);
      
      svg.appendChild(poly);
      svg.appendChild(polyHit);
         
         if (currentEdgeId === edge.id) {
          edge.points.forEach((p, idx) => {
           const c = document.createElementNS(ns, "circle");
           c.classList.add("edge-edit-point");
           c.setAttribute("cx", p.x);
           c.setAttribute("cy", p.y);
      c.setAttribute("r", PAGE_STATE.selectionHandleSize || 8);
           c.style.fill = PAGE_STATE.selectionHandle || "#f59e0b";
           c.style.stroke = "#fff";
           c.style.strokeWidth = "2";
           c.style.cursor = "move";
           c.dataset.edgeId = edge.id;
           c.dataset.pointIndex = String(idx);
           
           c.addEventListener("mousedown", (e) => {
            e.preventDefault();
            e.stopPropagation();
            let dragging = true;
            const svgEl = svg;
            const moveHandler = (ev) => {
             if (!dragging) return;
             const pt = svgEl.createSVGPoint();
             pt.x = ev.clientX;
             pt.y = ev.clientY;
             const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
             edge.points[idx].x = svgP.x;
             edge.points[idx].y = svgP.y;
             forgeTheTopology();
            };
            const upHandler = () => {
             dragging = false;
             document.removeEventListener("mousemove", moveHandler);
             document.removeEventListener("mouseup", upHandler);
            };
            document.addEventListener("mousemove", moveHandler);
            document.addEventListener("mouseup", upHandler);
           });
           
           c.addEventListener("touchstart", (e) => {
            e.preventDefault();
            e.stopPropagation();
            let dragging = true;
            const svgEl = svg;
            const touchMoveHandler = (ev) => {
             if (!dragging || !ev.touches[0]) return;
             const pt = svgEl.createSVGPoint();
             pt.x = ev.touches[0].clientX;
             pt.y = ev.touches[0].clientY;
             const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
             edge.points[idx].x = svgP.x;
             edge.points[idx].y = svgP.y;
             forgeTheTopology();
            };
            const touchUpHandler = () => {
             dragging = false;
             document.removeEventListener("touchmove", touchMoveHandler);
             document.removeEventListener("touchend", touchUpHandler);
            };
            document.addEventListener("touchmove", touchMoveHandler);
            document.addEventListener("touchend", touchUpHandler);
           }, { passive: false });
           
           svg.appendChild(c);
          });
         }
         
         return;
        }
        const p1 = positions[edge.from];
        const p2 = positions[edge.to];
        if (!p1 || !p2) return;
        const pairTotal = edge._pairTotal || 1;
        const pairIndex = edge._pairIndex || 0;
        const midX = (p1.x + p2.x) / 2;
        const midY = (p1.y + p2.y) / 2;
        const dx = p2.x - p1.x;
        const dy = p2.y - p1.y;
        const len = Math.sqrt(dx * dx + dy * dy) || 1;
        const perpX = -dy / len;
        const perpY = dx / len;
        let offsetAmount = 0;
        if (pairTotal > 1) {
         offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
        }
        const ctrlX = midX + perpX * offsetAmount;
        const ctrlY = midY + perpY * offsetAmount;
        const path = document.createElementNS(ns, "path");
        path.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
        path.setAttribute("fill", "none");
        path.classList.add("edge");
        if (edge.type === "backup") path.classList.add("backup");
        path.dataset.edgeId = edge.id;
        path.dataset.from = edge.from;
        path.dataset.to = edge.to;
        path.style.stroke = edge.color;
        path.style.strokeWidth = edge.width;
        const pathHit = document.createElementNS(ns, "path");
        pathHit.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
        pathHit.setAttribute("fill", "none");
        pathHit.style.stroke = "transparent";
        pathHit.style.strokeWidth = "20";
        pathHit.style.cursor = "pointer";
        pathHit.dataset.edgeId = edge.id;
        pathHit.addEventListener("click", (e) => {
         e.stopPropagation();
         selectTheConnection(edge.id);
        });
        let pathTouchStart = null;
        let pathTouchMoved = false;
        pathHit.addEventListener("touchstart", (e) => {
         pathTouchStart = Date.now();
         pathTouchMoved = false;
         if (e.touches[0]) {
          pathTouchStartX = e.touches[0].clientX;
          pathTouchStartY = e.touches[0].clientY;
         }
        }, {
         passive: false
        });
        let pathTouchStartX = 0, pathTouchStartY = 0;
        pathHit.addEventListener("touchmove", (e) => {
         if (e.touches[0]) {
          const dx = Math.abs(e.touches[0].clientX - pathTouchStartX);
          const dy = Math.abs(e.touches[0].clientY - pathTouchStartY);
          if (dx > 10 || dy > 10) pathTouchMoved = true;
         }
        }, {
         passive: false
        });
        pathHit.addEventListener("touchend", (e) => {
         if (pathTouchStart && !pathTouchMoved && Date.now() - pathTouchStart < 400) {
          e.stopPropagation();
          e.preventDefault();
          selectTheConnection(edge.id);
         }
         pathTouchStart = null;
         pathTouchMoved = false;
        }, {
         passive: false
        });
        path.addEventListener("click", (e) => {
         e.stopPropagation();
         selectTheConnection(edge.id);
        });
        
        if (currentView.mode === "rack") {
         const fromNode = NODE_DATA[edge.from];
         const toNode = NODE_DATA[edge.to];
         if (!fromNode || !toNode || 
             fromNode.assignedRack !== currentView.rackId || 
             toNode.assignedRack !== currentView.rackId) {
          return; 
         }
        }
        
        const fromVisible = isNodeVisible(edge.from);
        const toVisible = isNodeVisible(edge.to);
        if (!fromVisible || !toVisible) {
         path.style.opacity = "0.1";
         path.style.pointerEvents = "none";
         pathHit.style.pointerEvents = "none";
        }
        
        svg.appendChild(path);
        svg.appendChild(pathHit);
        
        if (edge.fromPort || edge.toPort) {
         const ns = "http://www.w3.org/2000/svg";
         
         if (edge.fromPort) {
          const fromLabel = document.createElementNS(ns, "text");
          fromLabel.textContent = edge.fromPort;
          fromLabel.setAttribute("x", p1.x);
          fromLabel.setAttribute("y", p1.y - 10);
          fromLabel.setAttribute("text-anchor", "middle");
          fromLabel.style.fill = "#94a3b8";
          fromLabel.style.fontSize = "12px";
          fromLabel.style.fontWeight = "600";
          fromLabel.style.pointerEvents = "none";
          fromLabel.classList.add("port-label");
          svg.appendChild(fromLabel);
         }
         
         if (edge.toPort) {
          const toLabel = document.createElementNS(ns, "text");
          toLabel.textContent = edge.toPort;
          toLabel.setAttribute("x", p2.x);
          toLabel.setAttribute("y", p2.y - 10);
          toLabel.setAttribute("text-anchor", "middle");
          toLabel.style.fill = "#94a3b8";
          toLabel.style.fontSize = "12px";
          toLabel.style.fontWeight = "600";
          toLabel.style.pointerEvents = "none";
          toLabel.classList.add("port-label");
          svg.appendChild(toLabel);
         }
        }
       });
       Object.entries(positions).forEach(([id, pos]) => {
        const node = NODE_DATA[id];
        if (!node) return;
        
        if (currentView.mode === "rack") {
         if (node.assignedRack !== currentView.rackId) return;
         
         const rackUnit = parseInt(node.rackUnit) || 1;
      const uHeight = parseInt(node.uHeight) || 1;
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      pos.x = RACK_START_X;
      pos.y = RACK_START_Y + (rackCapacity - rackUnit - uHeight + 1) * rackUHeight + (uHeight * rackUHeight) / 2;
      
        } else {
         if (node.assignedRack) return;
        }
        
        const g = document.createElementNS("http://www.w3.org/2000/svg", "g", );
        g.classList.add("node-group");
        g.dataset.nodeId = id;
        g.setAttribute("transform", `translate(${pos.x},${pos.y})`);
        let r = savedSizes[id] || 55;
        if (!savedSizes[id]) {
         if (window.innerWidth <= 380) r = 120;
         else if (window.innerWidth <= 768) r = 140;
         else if (window.innerWidth <= 1024) r = 70;
        }
        const styles = resolveStylesForNode(id);
        const ns = "http://www.w3.org/2000/svg";
        const hitArea = document.createElementNS(ns, "circle");
        hitArea.setAttribute("r", r * 1.5);
        hitArea.style.fill = "transparent";
        hitArea.style.stroke = "none";
        hitArea.style.cursor = "grab";
        hitArea.classList.add("node-hit-area");
        const shapeEl = createNodeShape(id, r);
        const titleOffsetX = styles.titleOffsetX || 0;
        const titleOffsetY = styles.titleOffsetY || 0;
        const subOffsetX = styles.subOffsetX || 0;
        const subOffsetY = styles.subOffsetY || 0;
        const label = document.createElementNS("http://www.w3.org/2000/svg", "text", );
        label.classList.add("node-label");
        label.setAttribute("x", titleOffsetX);
        label.setAttribute("y", -r * 0.28 + titleOffsetY);
      const labelFontSize = styles.titleSize || PAGE_STATE.nodeTitleSize || r * 0.33;
        label.style.fontSize = labelFontSize + "px";
        label.textContent = NODE_DATA[id].name;
      label.style.fill = styles.titleColor || PAGE_STATE.nodeTitle || "#e2e8f0";
        label.style.fontFamily = styles.titleFont || PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
        label.style.pointerEvents = "none";
        const sub = document.createElementNS("http://www.w3.org/2000/svg", "text", );
        sub.classList.add("node-sub");
        sub.setAttribute("x", subOffsetX);
        sub.setAttribute("y", r * 0.4 + subOffsetY);
      const subFontSize = styles.subSize || PAGE_STATE.nodeSubSize || r * 0.24;
        sub.style.fontSize = subFontSize + "px";
        sub.textContent = NODE_DATA[id].ip;
      sub.style.fill = styles.subColor || PAGE_STATE.nodeSub || "#94a3b8";
        sub.style.fontFamily = styles.subFont || PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
        sub.style.pointerEvents = "none";
        g.append(hitArea, shapeEl, label, sub);
        
        if (NODE_DATA[id]?.locked) {
          const lockIcon = document.createElementNS(ns, "text");
          lockIcon.textContent = "ðŸ”’";
          lockIcon.setAttribute("x", r * 0.6);
          lockIcon.setAttribute("y", -r * 0.6);
          lockIcon.style.fontSize = (r * 0.4) + "px";
          lockIcon.style.pointerEvents = "none";
          lockIcon.style.userSelect = "none";
          lockIcon.classList.add("lock-indicator");
          g.appendChild(lockIcon);
        }
        
        if (NODE_DATA[id]?.groupId) {
          const groupIndicator = document.createElementNS(ns, "circle");
          groupIndicator.setAttribute("r", r + 4);
          groupIndicator.style.fill = "none";
      groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
          groupIndicator.style.strokeWidth = "3";
          groupIndicator.style.strokeDasharray = "5,5";
          groupIndicator.style.pointerEvents = "none";
          groupIndicator.classList.add("group-indicator");
          g.insertBefore(groupIndicator, g.firstChild);
        }
        
        let isDragging = false;
        let startX, startY;
        let initialPositions = {};
        let longPressTimer = null;
        let longPressTriggered = false;
        
        g.addEventListener("contextmenu", (e) => {
         e.preventDefault();
         e.stopPropagation();
         
         if (selectedNodes.has(id)) {
          selectedNodes.delete(id);
         } else {
          selectedNodes.add(id);
         }
         updateNodeSelection();
         return false;
        });
        
        g.addEventListener("touchstart", (e) => {
         if (NODE_DATA[id].isRack) {
          const touch = e.touches[0];
          longPressStartX = touch.clientX;
          longPressStartY = touch.clientY;
          longPressTimer = setTimeout(() => {
           longPressTriggered = true;
           if (navigator.vibrate) {
            navigator.vibrate(100);
           }
           enterRack(id);
          }, 500); 
         }
        }, { passive: true });
        
        let lastTapTime = 0;
        let lastTapNode = null;
        
        g.addEventListener("touchend", (e) => {
         const currentTime = new Date().getTime();
         const tapLength = currentTime - lastTapTime;
         
         if (tapLength < 300 && tapLength > 0 && lastTapNode === id) {
          e.preventDefault();
          e.stopPropagation();
          
          if (selectedNodes.has(id)) {
           selectedNodes.delete(id);
          } else {
           selectedNodes.add(id);
          }
          updateNodeSelection();
          
          if (navigator.vibrate) {
           navigator.vibrate(50);
          }
          
          lastTapTime = 0;
          lastTapNode = null;
         } else {
          lastTapTime = currentTime;
          lastTapNode = id;
         }
        });
        
        g.addEventListener("touchend", (e) => {
         if (longPressTimer) {
          clearTimeout(longPressTimer);
          longPressTimer = null;
         }
         if (longPressTriggered) {
          e.preventDefault();
          e.stopPropagation();
          longPressTriggered = false;
         }
        });
        
        let longPressStartX = 0;
        let longPressStartY = 0;
        g.addEventListener("touchmove", (e) => {
         if (longPressTimer) {
          const touch = e.touches[0];
          const dx = Math.abs(touch.clientX - longPressStartX);
          const dy = Math.abs(touch.clientY - longPressStartY);
          if (dx > 15 || dy > 15) {
           clearTimeout(longPressTimer);
           longPressTimer = null;
           longPressTriggered = false;
          }
         }
        });
        
        g.addEventListener("mousedown", (e) => {
         if (e.button === 2) {
          return;
         }
         
         if (NODE_DATA[id]?.locked) {
          return;
         }
         
         e.preventDefault();
         isDragging = true;
         const svgEl = document.getElementById("map");
         const pt = svgEl.createSVGPoint();
         pt.x = e.clientX;
         pt.y = e.clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
         startX = svgP.x;
         startY = svgP.y;
      if (selectedNodes.has(id)) {
      initialPositions = {};
      const allSelectedRects = Array.from(selectedRects);
      const allSelectedTexts = Array.from(selectedTexts);
      const allSelectedEdges = Array.from(selectedEdges).map(eid => EDGE_DATA.list.find(e => e.id === eid)).filter(Boolean);   
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) {
      initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      }
      });
      Array.from(selectedRects).forEach(rectId => {
        const rect = RECT_DATA.list.find(r => r.id === rectId);
        if (rect) { rect._dragStartX = rect.x; rect._dragStartY = rect.y; }
      });
      Array.from(selectedTexts).forEach(textId => {
        const text = TEXT_DATA.list.find(t => t.id === textId);
        if (text) { text._dragStartX = text.x; text._dragStartY = text.y; }
      });
      Array.from(selectedEdges).forEach(edgeId => {
        const edge = EDGE_DATA.list.find(e => e.id === edgeId);
        if (edge && edge.points) { edge._dragStartPoints = edge.points.map(p => ({x: p.x, y: p.y})); }
      });
      
      
      
      
      } else {
      initialPositions = { [id]: { x: pos.x, y: pos.y } };
      }
      if (currentView.mode === "rack") {
      initialPositions[id] = { x: pos.x, y: pos.y };
      }
         
         g.style.cursor = "grabbing";
         hitArea.style.cursor = "grabbing";
         e.stopPropagation();
        });
        const handleMouseMove = (e) => {
         if (!isDragging) return;
         e.preventDefault();
         const svgEl = document.getElementById("map");
         const pt = svgEl.createSVGPoint();
         pt.x = e.clientX;
         pt.y = e.clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
         const dx = svgP.x - startX;
         const dy = svgP.y - startY;
         
         let nodesToMove = selectedNodes.has(id) ? Array.from(selectedNodes) : [id];
         
         const groupIds = new Set();
         nodesToMove.forEach(nodeId => {
          const groupId = NODE_DATA[nodeId]?.groupId;
          if (groupId) {
            groupIds.add(groupId);
          }
         });
         
         if (groupIds.size > 0) {
          Object.keys(NODE_DATA).forEach(nodeId => {
            const nodeGroupId = NODE_DATA[nodeId]?.groupId;
            if (nodeGroupId && groupIds.has(nodeGroupId)) {
              if (!nodesToMove.includes(nodeId)) {
                nodesToMove.push(nodeId);
                if (!initialPositions[nodeId]) {
                  const nodePos = savedPositions[nodeId];
                  if (nodePos) {
                    initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
                  }
                }
              }
            }
          });
         }
         
         nodesToMove = nodesToMove.filter(nodeId => !NODE_DATA[nodeId]?.locked);
         
         nodesToMove.forEach(nodeId => {
          if (!initialPositions[nodeId]) return;
          const initialPos = initialPositions[nodeId];
          let newX = initialPos.x + dx;
          let newY = initialPos.y + dy;
          const nodeSize = savedSizes[nodeId] || 55;
          newX = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, newX), );
          newY = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, newY), );
          
          savedPositions[nodeId] = { x: newX, y: newY };
          positions[nodeId] = { x: newX, y: newY };
          
          if (nodeId === id) {
           pos.x = newX;
           pos.y = newY;
          }
          
          const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
          if (nodeGroup) {
           nodeGroup.setAttribute("transform", `translate(${newX},${newY})`);
          }
         });
         
         Array.from(selectedRects).forEach(rectId => {
           const rect = RECT_DATA.list.find(r => r.id === rectId);
           if (rect && rect._dragStartX !== undefined) {
             rect.x = rect._dragStartX + dx;
             rect.y = rect._dragStartY + dy;
           }
         });
         Array.from(selectedTexts).forEach(textId => {
           const text = TEXT_DATA.list.find(t => t.id === textId);
           if (text && text._dragStartX !== undefined) {
             text.x = text._dragStartX + dx;
             text.y = text._dragStartY + dy;
           }
         });
         Array.from(selectedEdges).forEach(edgeId => {
           const edge = EDGE_DATA.list.find(e => e.id === edgeId);
           if (edge && edge._dragStartPoints) {
             edge.points.forEach((p, i) => {
               p.x = edge._dragStartPoints[i].x + dx;
               p.y = edge._dragStartPoints[i].y + dy;
             });
           }
         });
         forgeTheTopology();
         
         updateMinimap();
         document.querySelectorAll(".edge").forEach((edgeEl) => {
          const fromId = edgeEl.dataset.from;
          const toId = edgeEl.dataset.to;
          if (nodesToMove.includes(fromId) || nodesToMove.includes(toId)) {
           const p1 = savedPositions[fromId] || positions[fromId] || {
            x: 600,
            y: 350
           };
           const p2 = savedPositions[toId] || positions[toId] || {
            x: 600,
            y: 350
           };
           if (edgeEl.tagName === "line") {
            edgeEl.setAttribute("x1", p1.x);
            edgeEl.setAttribute("y1", p1.y);
            edgeEl.setAttribute("x2", p2.x);
            edgeEl.setAttribute("y2", p2.y);
           } else if (edgeEl.tagName === "path") {
            const edgeId = edgeEl.dataset.edgeId;
            const edge = EDGE_DATA.list.find(
             (e) => e.id === edgeId, );
            if (edge) {
             const pairTotal = edge._pairTotal || 1;
             const pairIndex = edge._pairIndex || 0;
             const midX = (p1.x + p2.x) / 2;
             const midY = (p1.y + p2.y) / 2;
             const dx = p2.x - p1.x;
             const dy = p2.y - p1.y;
             const len = Math.sqrt(dx * dx + dy * dy) || 1;
             const perpX = -dy / len;
             const perpY = dx / len;
             let offsetAmount = 0;
             if (pairTotal > 1) {
              offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
             }
             const ctrlX = midX + perpX * offsetAmount;
             const ctrlY = midY + perpY * offsetAmount;
             edgeEl.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
            }
           }
          }
         });
        };
      const handleMouseUp = () => {
      if (isDragging) {
      pushUndo("move nodes");
      isDragging = false;
      g.style.cursor = "grab";
      hitArea.style.cursor = "grab";
      if (currentView.mode === "rack" && NODE_DATA[id]?.assignedRack === currentView.rackId) {
      const draggedY = savedPositions[id]?.y || pos.y;
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      let newUnit = rackCapacity - Math.round((draggedY - RACK_START_Y) / rackUHeight);
      newUnit = Math.max(1, Math.min(newUnit, rackCapacity));
      NODE_DATA[id].rackUnit = newUnit;
      
      forgeTheTopology();
      claimTheImmortal(id);
      }
      }
      };
        document.addEventListener("mousemove", handleMouseMove);
        document.addEventListener("mouseup", handleMouseUp);
        let touchStartTime = 0;
        let touchStartX = 0;
        let touchStartY = 0;
        let touchMoved = false;
       g.addEventListener("touchstart",
         (e) => {
          if (NODE_DATA[id]?.locked) {
           return;
          }
          
          e.preventDefault();
          touchStartTime = Date.now();
          touchMoved = false;
          const svgEl = document.getElementById("map");
          const pt = svgEl.createSVGPoint();
          const touch = e.touches[0];
          pt.x = touch.clientX;
          pt.y = touch.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          touchStartX = svgP.x;
          touchStartY = svgP.y;
          startX = svgP.x;
          startY = svgP.y;
          
          if (selectedNodes.has(id)) {
           initialPositions = {};
           selectedNodes.forEach(nodeId => {
            const nodePos = savedPositions[nodeId];
            if (nodePos) {
             initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
            }
           });
          } else {
           initialPositions = { [id]: { x: pos.x, y: pos.y } };
          }
          
          e.stopPropagation();
         }, {
          passive: false
         }, );
        g.addEventListener("touchmove", (e) => {
         e.preventDefault();
         const svgEl = document.getElementById("map");
         const pt = svgEl.createSVGPoint();
         const touch = e.touches[0];
         pt.x = touch.clientX;
         pt.y = touch.clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
         const dx = Math.abs(svgP.x - touchStartX);
         const dy = Math.abs(svgP.y - touchStartY);
         if (dx > (isMobileDevice() ? 4 : 10) || dy > (isMobileDevice() ? 4 : 10)) {
      touchMoved = true;
      isDragging = true;
      }
         if (!isDragging) return;
         
         const deltaX = svgP.x - startX;
         const deltaY = svgP.y - startY;
         
         let nodesToMove = selectedNodes.has(id) ? Array.from(selectedNodes) : [id];
         
         const groupIds = new Set();
         nodesToMove.forEach(nodeId => {
          const groupId = NODE_DATA[nodeId]?.groupId;
          if (groupId) {
            groupIds.add(groupId);
          }
         });
         
         if (groupIds.size > 0) {
          Object.keys(NODE_DATA).forEach(nodeId => {
            const nodeGroupId = NODE_DATA[nodeId]?.groupId;
            if (nodeGroupId && groupIds.has(nodeGroupId)) {
              if (!nodesToMove.includes(nodeId)) {
                nodesToMove.push(nodeId);
                if (!initialPositions[nodeId]) {
                  const nodePos = savedPositions[nodeId];
                  if (nodePos) {
                    initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
                  }
                }
              }
            }
          });
         }
         
         nodesToMove = nodesToMove.filter(nodeId => !NODE_DATA[nodeId]?.locked);
         
         nodesToMove.forEach(nodeId => {
          if (!initialPositions[nodeId]) return;
          const initialPos = initialPositions[nodeId];
          let newX = initialPos.x + deltaX;
          let newY = initialPos.y + deltaY;
          const nodeSize = savedSizes[nodeId] || 55;
          newX = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, newX), );
          newY = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, newY), );
          
          savedPositions[nodeId] = { x: newX, y: newY };
          positions[nodeId] = { x: newX, y: newY };
          
          if (nodeId === id) {
           pos.x = newX;
           pos.y = newY;
          }
          
          const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
          if (nodeGroup) {
           nodeGroup.setAttribute("transform", `translate(${newX},${newY})`);
          }
         });
         
         updateMinimap();
         document.querySelectorAll(".edge").forEach((edgeEl) => {
          const fromId = edgeEl.dataset.from;
          const toId = edgeEl.dataset.to;
          if (nodesToMove.includes(fromId) || nodesToMove.includes(toId)) {
           const p1 = savedPositions[fromId] || positions[fromId] || {
            x: 600,
            y: 350
           };
           const p2 = savedPositions[toId] || positions[toId] || {
            x: 600,
            y: 350
           };
           if (edgeEl.tagName === "line") {
            edgeEl.setAttribute("x1", p1.x);
            edgeEl.setAttribute("y1", p1.y);
            edgeEl.setAttribute("x2", p2.x);
            edgeEl.setAttribute("y2", p2.y);
           } else if (edgeEl.tagName === "path") {
            const edgeId = edgeEl.dataset.edgeId;
            const edge = EDGE_DATA.list.find(
             (e) => e.id === edgeId, );
            if (edge) {
             const pairTotal = edge._pairTotal || 1;
             const pairIndex = edge._pairIndex || 0;
             const midX = (p1.x + p2.x) / 2;
             const midY = (p1.y + p2.y) / 2;
             const dx = p2.x - p1.x;
             const dy = p2.y - p1.y;
             const len = Math.sqrt(dx * dx + dy * dy) || 1;
             const perpX = -dy / len;
             const perpY = dx / len;
             let offsetAmount = 0;
             if (pairTotal > 1) {
              offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
             }
             const ctrlX = midX + perpX * offsetAmount;
             const ctrlY = midY + perpY * offsetAmount;
             edgeEl.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
            }
           }
          }
         });
        }, {
         passive: false
        });
      g.addEventListener("touchend", (e) => {
      const touchDuration = Date.now() - touchStartTime;
      if (!touchMoved && touchDuration < 400) {
      claimTheImmortal(id);
      }
      if (isDragging) {
      const draggedY = pos.y;
      isDragging = false;
      savedPositions[id] = {
      x: pos.x,
      y: pos.y
      };
      if (currentView.mode === "rack" && NODE_DATA[id]?.assignedRack === currentView.rackId) {
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      let newUnit = rackCapacity - Math.round((draggedY - RACK_START_Y) / rackUHeight);
      
      newUnit = Math.max(1, Math.min(newUnit, rackCapacity));
      NODE_DATA[id].rackUnit = newUnit;
      forgeTheTopology();
      claimTheImmortal(id);
      }
      }
      touchMoved = false;
      });
        g.style.cursor = "grab";
        g.addEventListener("click", (e) => {
         if (!isDragging) {
          claimTheImmortal(id);
         }
        });
        
        g.addEventListener("dblclick", (e) => {
         e.preventDefault();
         e.stopPropagation();
         if (NODE_DATA[id].isRack) {
          enterRack(id);
         }
        });
        
        if (!isNodeVisible(id)) {
         g.style.opacity = "0.1";
         g.style.pointerEvents = "none";
        }
        
        svg.appendChild(g);
       });
        if (RECT_DATA && RECT_DATA.list) {
         RECT_DATA.list.forEach((rect) => {
          if (currentView.mode === "rack") return;
          if (rect.style === "outlined") {
           const g = document.createElementNS(ns, "g");
           g.classList.add("rect-group");
           g.dataset.rectId = rect.id;
           
           const rectEl = document.createElementNS(ns, "rect");
           rectEl.classList.add("rect-shape");
           rectEl.setAttribute("x", rect.x);
           rectEl.setAttribute("y", rect.y);
           rectEl.setAttribute("width", rect.width);
           rectEl.setAttribute("height", rect.height);
           rectEl.style.fill = "none";
           rectEl.style.stroke = rect.borderColor || rect.color;
           rectEl.style.strokeWidth = (rect.borderWidth !== undefined ? rect.borderWidth : 3) + "px";
           if (rect.lineStyle === "dashed") { rectEl.style.strokeDasharray = "10,5"; }
           else if (rect.lineStyle === "dotted") { rectEl.style.strokeDasharray = "2,4"; }
           else { rectEl.style.strokeDasharray = "none"; }
           rectEl.style.cursor = "move";
           
           rectEl.addEventListener("click", (e) => {
             if (rectDrawMode) return;
             e.stopPropagation();
             currentRectId = rect.id;
             selectTheRect(rect.id);
           });
           
           rectEl.addEventListener("contextmenu", (e) => {
             e.preventDefault();
             e.stopPropagation();
             if (selectedRects.has(rect.id)) {
               selectedRects.delete(rect.id);
             } else {
               selectedRects.add(rect.id);
             }
             updateAllSelections();
           });
           
           let rectLastTap = 0;
           rectEl.addEventListener("touchend", (e) => {
             const now = Date.now();
             if (now - rectLastTap < 300) {
               e.preventDefault();
               if (selectedRects.has(rect.id)) {
                 selectedRects.delete(rect.id);
               } else {
                 selectedRects.add(rect.id);
               }
               updateAllSelections();
               if (navigator.vibrate) navigator.vibrate(50);
               rectLastTap = 0;
             } else {
               rectLastTap = now;
             }
           }, { passive: false });
           
           const deleteBtn = document.createElementNS(ns, "g");
           deleteBtn.classList.add("rect-delete-btn");
           deleteBtn.style.cursor = "pointer";
           deleteBtn.style.display = rectDrawMode ? "block" : "none";
           
           const deleteBg = document.createElementNS(ns, "circle");
           deleteBg.setAttribute("cx", rect.x + rect.width - 10);
           deleteBg.setAttribute("cy", rect.y + 10);
           deleteBg.setAttribute("r", 12);
           deleteBg.style.fill = "#f56565";
           deleteBg.style.stroke = "white";
           deleteBg.style.strokeWidth = "2";
           
           const deleteX = document.createElementNS(ns, "text");
           deleteX.setAttribute("x", rect.x + rect.width - 10);
           deleteX.setAttribute("y", rect.y + 10);
           deleteX.setAttribute("text-anchor", "middle");
           deleteX.setAttribute("dominant-baseline", "middle");
           deleteX.style.fill = "white";
           deleteX.style.fontSize = "16px";
           deleteX.style.fontWeight = "bold";
           deleteX.style.pointerEvents = "none";
           deleteX.textContent = "Ã—";
           
           deleteBtn.appendChild(deleteBg);
           deleteBtn.appendChild(deleteX);
           
           deleteBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            e.preventDefault();
            deleteRectangle(rect.id);
           });
           
           let isDragging = false;
           let dragStartX, dragStartY;
           let rectStartX, rectStartY;
           
           rectEl.addEventListener("mousedown", (e) => {
      if (rectDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      rectStartX = rect.x;
      rectStartY = rect.y;
      rectEl.style.cursor = "grabbing";
      
      if (selectedRects.has(rect.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
           
           const moveHandler = (e) => {
      if (!isDragging || rectDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      
      rect.x = rectStartX + dx;
      rect.y = rectStartY + dy;
      
      if (selectedRects.has(rect.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       const newX = initialPositions[nodeId].x + dx;
       const newY = initialPositions[nodeId].y + dy;
       savedPositions[nodeId] = { x: newX, y: newY };
      }
      });
      selectedRects.forEach(rectId => {
      if (rectId === rect.id) return;
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      
      forgeTheTopology();
      };
           
           const upHandler = () => {
            if (isDragging) {
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           };
           
           document.addEventListener("mousemove", moveHandler);
           document.addEventListener("mouseup", upHandler);
           
           let touchStartX, touchStartY;
           let touchRectStartX, touchRectStartY;
           
           rectEl.addEventListener("touchstart", (e) => {
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchRectStartX = rect.x;
            touchRectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           }, { passive: false });
           
           rectEl.addEventListener("touchmove", (e) => {
            if (!isDragging || rectDrawMode) return;
            if (!e.touches[0]) return;
            e.preventDefault();
            e.stopPropagation();
            
            const svgEl = svg;
            const pt1 = svgEl.createSVGPoint();
            pt1.x = touchStartX;
            pt1.y = touchStartY;
            const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
            
            const touch = e.touches[0];
            const pt2 = svgEl.createSVGPoint();
            pt2.x = touch.clientX;
            pt2.y = touch.clientY;
            const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
            
            const dx = svgP2.x - svgP1.x;
            const dy = svgP2.y - svgP1.y;
            
            rect.x = touchRectStartX + dx;
            rect.y = touchRectStartY + dy;
            
            forgeTheTopology();
           }, { passive: false });
           
           rectEl.addEventListener("touchend", (e) => {
            if (isDragging) {
             e.preventDefault();
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           }, { passive: false });
           
           if (rect.groupId) {
             const groupIndicator = document.createElementNS(ns, "rect");
             groupIndicator.setAttribute("x", rect.x - 4);
             groupIndicator.setAttribute("y", rect.y - 4);
             groupIndicator.setAttribute("width", rect.width + 8);
             groupIndicator.setAttribute("height", rect.height + 8);
             groupIndicator.style.fill = "none";
             groupIndicator.style.stroke = "#4fd1c5";
             groupIndicator.style.strokeWidth = "3";
             groupIndicator.style.strokeDasharray = "5,5";
             groupIndicator.style.pointerEvents = "none";
             g.insertBefore(groupIndicator, g.firstChild);
           }
           g.appendChild(rectEl);
           g.appendChild(deleteBtn);
           svg.appendChild(g);
          }
         });
        }
        
        if (TEXT_DATA && TEXT_DATA.list) {
         TEXT_DATA.list.forEach((textItem) => {
          if (currentView.mode === "rack") return;
          
          const g = document.createElementNS(ns, "g");
          g.classList.add("text-group");
          g.dataset.textId = textItem.id;
          
          if (textItem.bgEnabled) {
           const bgRect = document.createElementNS(ns, "rect");
           bgRect.classList.add("text-bg");
           
           bgRect.setAttribute("x", textItem.x - 5);
           bgRect.setAttribute("y", textItem.y - textItem.fontSize - 2);
           bgRect.setAttribute("width", 100);
           bgRect.setAttribute("height", textItem.fontSize + 10);
           bgRect.style.fill = textItem.bgColor;
           bgRect.style.opacity = "0.7";
           bgRect.style.rx = "4";
           g.appendChild(bgRect);
          }
          
          const textEl = document.createElementNS(ns, "text");
          textEl.classList.add("text-element");
          textEl.setAttribute("x", textItem.x);
          textEl.setAttribute("y", textItem.y);
          textEl.style.fill = textItem.color;
          textEl.style.fontSize = textItem.fontSize + "px";
          textEl.style.fontWeight = textItem.fontWeight;
          textEl.style.fontStyle = textItem.fontStyle;
          textEl.style.textAnchor = textItem.textAlign;
          textEl.style.textDecoration = textItem.textDecoration;
          textEl.style.opacity = textItem.opacity;
          textEl.style.cursor = "move";
          textEl.style.userSelect = "none";
          textEl.setAttribute("dominant-baseline", "middle");
          
          const lines = textItem.content.split('\n');
          if (lines.length === 1) {
           textEl.textContent = textItem.content;
          } else {
           lines.forEach((line, i) => {
            const tspan = document.createElementNS(ns, "tspan");
            tspan.textContent = line;
            tspan.setAttribute("x", textItem.x);
            tspan.setAttribute("dy", i === 0 ? 0 : textItem.fontSize * 1.2);
            textEl.appendChild(tspan);
           });
          }
          
          g.appendChild(textEl);
          
          if (textItem.bgEnabled) {
           setTimeout(() => {
            try {
             const bbox = textEl.getBBox();
             const bgRect = g.querySelector('.text-bg');
             if (bgRect && bbox) {
              bgRect.setAttribute("x", bbox.x - 5);
              bgRect.setAttribute("y", bbox.y - 2);
              bgRect.setAttribute("width", bbox.width + 10);
              bgRect.setAttribute("height", bbox.height + 4);
             }
            } catch (e) {
            }
           }, 0);
          }
          
          const deleteBtn = document.createElementNS(ns, "g");
          deleteBtn.classList.add("text-delete-btn");
          deleteBtn.style.cursor = "pointer";
          deleteBtn.style.display = textDrawMode ? "block" : "none";
          
          const deleteBg = document.createElementNS(ns, "circle");
          deleteBg.setAttribute("cx", textItem.x + 20);
          deleteBg.setAttribute("cy", textItem.y - textItem.fontSize);
          deleteBg.setAttribute("r", 12);
          deleteBg.style.fill = "#f56565";
          deleteBg.style.stroke = "white";
          deleteBg.style.strokeWidth = "2";
          
          const deleteX = document.createElementNS(ns, "text");
          deleteX.setAttribute("x", textItem.x + 20);
          deleteX.setAttribute("y", textItem.y - textItem.fontSize);
          deleteX.setAttribute("text-anchor", "middle");
          deleteX.setAttribute("dominant-baseline", "middle");
          deleteX.style.fill = "white";
          deleteX.style.fontSize = "16px";
          deleteX.style.fontWeight = "bold";
          deleteX.style.pointerEvents = "none";
          deleteX.textContent = "Ã—";
          
          deleteBtn.appendChild(deleteBg);
          deleteBtn.appendChild(deleteX);
          
          deleteBtn.addEventListener("click", (e) => {
           e.stopPropagation();
           e.preventDefault();
           deleteText(textItem.id);
          });
          
          let isDragging = false;
          let dragStartX, dragStartY;
          let textStartX, textStartY;
          
          textEl.addEventListener("mousedown", (e) => {
      if (textDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      textStartX = textItem.x;
      textStartY = textItem.y;
      textEl.style.cursor = "grabbing";
      
      showTextPanel(textItem.id);
      
      if (selectedTexts.has(textItem.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
          
          const moveHandler = (e) => {
      if (!isDragging || textDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      
      textItem.x = textStartX + dx;
      textItem.y = textStartY + dy;
      
      if (selectedTexts.has(textItem.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       const newX = initialPositions[nodeId].x + dx;
       const newY = initialPositions[nodeId].y + dy;
       savedPositions[nodeId] = { x: newX, y: newY };
      }
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      if (textId === textItem.id) return;
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      
      forgeTheTopology();
      };
          
          const upHandler = () => {
           if (isDragging) {
            isDragging = false;
            textEl.style.cursor = "move";
           }
          };
          
          document.addEventListener("mousemove", moveHandler);
          document.addEventListener("mouseup", upHandler);
          
          let touchStartX = 0, touchStartY = 0;
          let textTouchStartX = 0, textTouchStartY = 0;
          
          textEl.addEventListener("touchstart", (e) => {
           if (textDrawMode) return;
           if (e.touches.length !== 1) return;
           
           e.preventDefault();
           e.stopPropagation();
           const touch = e.touches[0];
           isDragging = true;
           touchStartX = touch.clientX;
           touchStartY = touch.clientY;
           textTouchStartX = textItem.x;
           textTouchStartY = textItem.y;
           
           showTextPanel(textItem.id);
          }, { passive: false });
          
          textEl.addEventListener("touchmove", (e) => {
           if (!isDragging || textDrawMode) return;
           if (e.touches.length !== 1) return;
           
           e.preventDefault();
           const touch = e.touches[0];
           const svgEl = svg;
           
           const pt1 = svgEl.createSVGPoint();
           pt1.x = touchStartX;
           pt1.y = touchStartY;
           const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
           
           const pt2 = svgEl.createSVGPoint();
           pt2.x = touch.clientX;
           pt2.y = touch.clientY;
           const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
           
           const dx = svgP2.x - svgP1.x;
           const dy = svgP2.y - svgP1.y;
           
           textItem.x = textTouchStartX + dx;
           textItem.y = textTouchStartY + dy;
           
           forgeTheTopology();
          }, { passive: false });
          
          textEl.addEventListener("touchend", () => {
           if (isDragging) {
            isDragging = false;
           }
          }, { passive: false });
          
          textEl.addEventListener("contextmenu", (e) => {
           e.preventDefault();
           e.stopPropagation();
           if (selectedTexts.has(textItem.id)) {
            selectedTexts.delete(textItem.id);
           } else {
            selectedTexts.add(textItem.id);
           }
           updateAllSelections();
          });
          
          let textLastTap = 0;
          g.addEventListener("touchend", (e) => {
           const now = Date.now();
           if (now - textLastTap < 300) {
            e.preventDefault();
            if (selectedTexts.has(textItem.id)) {
             selectedTexts.delete(textItem.id);
            } else {
             selectedTexts.add(textItem.id);
            }
            updateAllSelections();
            if (navigator.vibrate) navigator.vibrate(50);
            textLastTap = 0;
           } else {
            textLastTap = now;
           }
          }, { passive: false });
          
          if (textItem.groupId) {
            const groupIndicator = document.createElementNS(ns, "rect");
            groupIndicator.setAttribute("x", textItem.x - 54);
            groupIndicator.setAttribute("y", textItem.y - 24);
            groupIndicator.setAttribute("width", 108);
            groupIndicator.setAttribute("height", 48);
            groupIndicator.setAttribute("rx", "8");
            groupIndicator.style.fill = "none";
            groupIndicator.style.stroke = "#4fd1c5";
            groupIndicator.style.strokeWidth = "3";
            groupIndicator.style.strokeDasharray = "5,5";
            groupIndicator.style.pointerEvents = "none";
            g.insertBefore(groupIndicator, g.firstChild);
          }
          g.appendChild(deleteBtn);
          svg.appendChild(g);
         });
        }
        
       forgeTheLegend();
       updateMinimap();
       populateRackDropdown();
      }
      
      function showEditModal(title, currentValue, onSave) {
       const modal = document.getElementById("edit-modal");
       const input = document.getElementById("modal-input");
       const titleEl = document.getElementById("modal-title");
       const saveBtn = document.getElementById("modal-save");
       const cancelBtn = document.getElementById("modal-cancel");
       titleEl.textContent = title;
       input.value = currentValue;
       modal.classList.add("active");
       input.focus();
       input.select();
       const handleSave = () => {
        if (input.value.trim()) {
         onSave(input.value.trim());
        }
        modal.classList.remove("active");
        saveBtn.removeEventListener("click", handleSave);
        cancelBtn.removeEventListener("click", handleCancel);
        input.removeEventListener("keypress", handleEnter);
       };
       const handleCancel = () => {
        modal.classList.remove("active");
        saveBtn.removeEventListener("click", handleSave);
        cancelBtn.removeEventListener("click", handleCancel);
        input.removeEventListener("keypress", handleEnter);
       };
       const handleEnter = (e) => {
        if (e.key === "Enter") handleSave();
       };
       saveBtn.addEventListener("click", handleSave);
       cancelBtn.addEventListener("click", handleCancel);
       input.addEventListener("keypress", handleEnter);
       modal.addEventListener("click", function bgHandler(e) {
        if (e.target === modal) {
         handleCancel();
         modal.removeEventListener("click", bgHandler);
        }
       });
      }
      
      function challengeTheImmortal(message, onConfirm) {
       const modal = document.getElementById("confirm-modal");
       const messageEl = document.getElementById("confirm-message");
       const deleteBtn = document.getElementById("confirm-delete");
       const cancelBtn = document.getElementById("confirm-cancel");
       messageEl.textContent = message;
       modal.classList.add("active");
       const handleConfirm = () => {
        onConfirm();
        modal.classList.remove("active");
        deleteBtn.removeEventListener("click", handleConfirm);
        cancelBtn.removeEventListener("click", handleCancel);
       };
       const handleCancel = () => {
        modal.classList.remove("active");
        deleteBtn.removeEventListener("click", handleConfirm);
        cancelBtn.removeEventListener("click", handleCancel);
       };
       deleteBtn.addEventListener("click", handleConfirm);
       cancelBtn.addEventListener("click", handleCancel);
       modal.addEventListener("click", function bgHandler(e) {
        if (e.target === modal) {
         handleCancel();
         modal.removeEventListener("click", bgHandler);
        }
       });
      }
      const pageTitleEl = document.getElementById("page-title");
      if (pageTitleEl) {
       pageTitleEl.addEventListener("click", () => {
        showEditModal("Edit Title", PAGE_STATE.title || DEFAULT_PAGE_STATE.title,
         (newTitle) => {
          PAGE_STATE.title = newTitle;
          wieldThePower();
         }, );
       });
      }
      
      function editNodeName(id) {
       showEditModal("Edit Name", NODE_DATA[id].name, (newName) => {
        NODE_DATA[id].name = newName;
        const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`, );
        if (nodeGroup) {
         const label = nodeGroup.querySelector(".node-label");
         if (label) label.textContent = newName;
        }
        if (currentNodeId === id) {
         document.getElementById("node-name").textContent = newName;
        }
       });
      }
      
      function editNodeIp(id) {
       showEditModal("Edit IP/Subtitle", NODE_DATA[id].ip, (newIp) => {
        NODE_DATA[id].ip = newIp;
        const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`, );
        if (nodeGroup) {
         const sub = nodeGroup.querySelector(".node-sub");
         if (sub) sub.textContent = newIp;
        }
        if (currentNodeId === id) {
         document.getElementById("node-ip").textContent = newIp;
        }
       });
      }
      
      function claimTheImmortal(id) {
       currentNodeId = id;
       currentEdgeId = null;
       
       if (isMobileDevice()) {
        const currentHeight = PAGE_STATE.mobileFooterHeight || 40;
        if (currentHeight <= 20) {
         PAGE_STATE.mobileFooterHeight = 80;
         const root = document.documentElement;
         root.style.setProperty("--mobile-footer-height", "80vh");
         const mobileFooterHeightInput = document.getElementById("mobile-footer-height");
         const mobileFooterHeightVal = document.getElementById("mobile-footer-height-val");
         if (mobileFooterHeightInput) mobileFooterHeightInput.value = 80;
         if (mobileFooterHeightVal) mobileFooterHeightVal.textContent = "80%";
        }
       }
       
       const data = NODE_DATA[id];
       document.querySelectorAll(".node-group").forEach((n) => {
        n.classList.toggle("active", n.dataset.nodeId === id);
       });
       document.querySelectorAll(".edge").forEach((e) => {
        const active = e.dataset.from === id || e.dataset.to === id;
        e.classList.toggle("active", active);
       });
       document.getElementById("node-panel").style.display = "block";
       document.getElementById("edge-panel").style.display = "none";
       document.getElementById("text-panel").style.display = "none";
       const toolbar = document.getElementById("topology-toolbar");
       if (!topologyToolbarCollapsed) {
        toolbar.style.display = "flex";
       }
       updateTopologyToolbarVisibility();
       document.getElementById("node-name").textContent = data.name;
       document.getElementById("node-ip").textContent = data.ip;
       document.getElementById("node-role").textContent = data.role;
       document.getElementById("node-mac").textContent = data.mac || "--";
       document.getElementById("node-rack").textContent = data.rackUnit || "--";
       document.getElementById("node-uheight").textContent = (data.uHeight || "1") + "U";
       document.getElementById("node-layer").value = data.layer || "physical";
       
       populateRackDropdown();
       const assignedRackSelect = document.getElementById("node-assigned-rack");
       if (assignedRackSelect) {
        assignedRackSelect.value = data.assignedRack || "";
       }
       
       const rackCapacitySelect = document.getElementById("node-rack-capacity");
       if (rackCapacitySelect) {
        rackCapacitySelect.value = data.rackCapacity || "42";
       }
       
       const isRack = data.isRack === true;
       const isAssignedToRack = !!data.assignedRack;
       const assignedRackRow = document.getElementById("assigned-rack-row");
       const rackCapacityRow = document.getElementById("rack-capacity-row");
       const uheightRow = document.getElementById("uheight-row");
       if (assignedRackRow) assignedRackRow.style.display = isRack ? "none" : "flex";
       if (rackCapacityRow) rackCapacityRow.style.display = isRack ? "flex" : "none";
       if (uheightRow) uheightRow.style.display = isAssignedToRack ? "flex" : "none";
       
       document.getElementById("node-name").onclick = () => editNodeName(id);
       document.getElementById("node-ip").onclick = () => editNodeIp(id);
       document.getElementById("node-mac").onclick = () => editNodeMac(id);
       document.getElementById("node-rack").onclick = () => editNodeRack(id);
       document.getElementById("node-uheight").onclick = () => editNodeUHeight(id);
       const currentSize = savedSizes[id] || getDefaultSize();
       document.getElementById("size-slider").value = currentSize;
       document.getElementById("size-value").textContent = currentSize;
       const styleEntry = savedStyles[id] || {};
       const resolvedStyles = resolveStylesEntry(styleEntry);
       const scopeKey = currentStyleScope || "all";
       const flatProps = ["circleColor", "circleBorder", "titleColor", "titleFont", "titleSize", "subColor", "subFont", "subSize", ];
       const isFlat = flatProps.some((p) => Object.prototype.hasOwnProperty.call(styleEntry, p), );
       const scopedStyles = isFlat ? styleEntry : styleEntry[scopeKey] || {};
       const circleColorInput = document.getElementById("circle-color");
       const titleColorInput = document.getElementById("title-color");
       const titleFontSelect = document.getElementById("title-font");
       const titleSizeInput = document.getElementById("title-size");
       const subColorInput = document.getElementById("sub-color");
       const subFontSelect = document.getElementById("sub-font");
       const subSizeInput = document.getElementById("sub-size");
       const shapeSelect = document.getElementById("shape-select");
       const scopeSelect = document.getElementById("style-scope");
      circleColorInput.value = scopedStyles.circleColor || resolvedStyles.circleColor || PAGE_STATE.nodeFill || "#1e293b";
       const circleBorderInput = document.getElementById("circle-border");
       circleBorderInput.value = scopedStyles.circleBorder || resolvedStyles.circleBorder || PAGE_STATE.nodeStroke || "#475569";
        titleColorInput.value = scopedStyles.titleColor || resolvedStyles.titleColor || PAGE_STATE.textMain || "#e2e8f0";
        titleFontSelect.value = scopedStyles.titleFont || resolvedStyles.titleFont || "system-ui, sans-serif";
        titleSizeInput.value = scopedStyles.titleSize || resolvedStyles.titleSize || 18;
        subColorInput.value = scopedStyles.subColor || resolvedStyles.subColor || PAGE_STATE.textSoft || "#94a3b8";
       subFontSelect.value = scopedStyles.subFont || resolvedStyles.subFont || "system-ui, sans-serif";
       subSizeInput.value = scopedStyles.subSize || resolvedStyles.subSize || 13;
       shapeSelect.value = data.shape || "circle";
       scopeSelect.value = currentStyleScope || "all";
       document.getElementById("title-offset-y").value = scopedStyles.titleOffsetY || resolvedStyles.titleOffsetY || 0;
       document.getElementById("title-offset-x").value = scopedStyles.titleOffsetX || resolvedStyles.titleOffsetX || 0;
       document.getElementById("sub-offset-y").value = scopedStyles.subOffsetY || resolvedStyles.subOffsetY || 0;
       document.getElementById("sub-offset-x").value = scopedStyles.subOffsetX || resolvedStyles.subOffsetX || 0;
       const tagEl = document.getElementById("node-tags");
       tagEl.innerHTML = "";
       data.tags.forEach((tag, i) => {
        const b = document.createElement("span");
        b.className = "badge";
        if (tag.toLowerCase().includes("wg")) b.classList.add("wg");
        b.style.cursor = "pointer";
        b.style.position = "relative";
        const tagText = document.createElement("span");
        tagText.textContent = tag;
        tagText.addEventListener("click", (e) => {
         e.stopPropagation();
         showEditModal("Edit Tag", tag, (newTag) => {
          if (newTag) {
           data.tags[i] = newTag;
           claimTheImmortal(id);
          }
         });
        });
        const deleteTag = document.createElement("span");
        deleteTag.textContent = " âœ•";
        deleteTag.style.opacity = "0.6";
        deleteTag.style.marginLeft = "4px";
        deleteTag.style.fontSize = "10px";
        deleteTag.addEventListener("click", (e) => {
         e.stopPropagation();
         data.tags.splice(i, 1);
         claimTheImmortal(id);
        });
        b.append(tagText, deleteTag);
        tagEl.append(b);
       });
       const addTagBtn = document.createElement("span");
       addTagBtn.className = "badge";
       addTagBtn.style.cursor = "pointer";
       addTagBtn.style.opacity = "0.6";
       addTagBtn.style.borderStyle = "dashed";
       addTagBtn.textContent = "+ Add";
       addTagBtn.addEventListener("click", () => {
        showEditModal("Add Tag(s) : comma separated", "",
         (newTagStr) => {
          if (newTagStr) {
           const newTags = newTagStr.split(",").map((t) => t.trim()).filter((t) => t);
           newTags.forEach((t) => data.tags.push(t));
           claimTheImmortal(id);
          }
         }, );
       });
       tagEl.append(addTagBtn);
       const notesEl = document.getElementById("node-notes");
       notesEl.innerHTML = "";
       data.notes.forEach((note, i) => {
        const li = document.createElement("li");
        const noteText = document.createElement("span");
        noteText.textContent = note;
        noteText.style.flex = "1";
        const deleteBtn = document.createElement("span");
        deleteBtn.className = "delete-note";
        deleteBtn.textContent = "âœ•";
        deleteBtn.addEventListener("click", (e) => {
         e.stopPropagation();
         challengeTheImmortal("Are you sure you want to delete this note?",
          () => {
           data.notes.splice(i, 1);
           claimTheImmortal(id);
          }, );
        });
        li.append(noteText, deleteBtn);
        noteText.addEventListener("dblclick", () => {
         noteText.classList.add("editing");
         noteText.contentEditable = true;
         noteText.focus();
        });
        noteText.addEventListener("blur", () => {
         noteText.classList.remove("editing");
         noteText.contentEditable = false;
         data.notes[i] = noteText.textContent;
        });
        notesEl.append(li);
       });
      const addLineSelect = document.getElementById("add-line-select");
      addLineSelect.innerHTML = "";
      const currentRack = data.assignedRack || "";
      Object.entries(NODE_DATA).forEach(([nodeId, node]) => {
      if (nodeId !== id) {
      const nodeRack = node.assignedRack || "";
      if (currentRack === nodeRack) {
      const opt = document.createElement("option");
      opt.value = nodeId;
      opt.textContent = node.name;
      addLineSelect.appendChild(opt);
      }
      }
      });
      }
      
      function selectTheConnection(id) {
       currentEdgeId = id;
       
       if (isMobileDevice()) {
        const currentHeight = PAGE_STATE.mobileFooterHeight || 40;
        if (currentHeight <= 20) {
         PAGE_STATE.mobileFooterHeight = 80;
         const root = document.documentElement;
         root.style.setProperty("--mobile-footer-height", "80vh");
         const mobileFooterHeightInput = document.getElementById("mobile-footer-height");
         const mobileFooterHeightVal = document.getElementById("mobile-footer-height-val");
         if (mobileFooterHeightInput) mobileFooterHeightInput.value = 80;
         if (mobileFooterHeightVal) mobileFooterHeightVal.textContent = "80%";
        }
       }
       
       document.getElementById("node-panel").style.display = "none";
       document.getElementById("edge-panel").style.display = "block";
       document.getElementById("text-panel").style.display = "none";
       document.getElementById("topology-toolbar").style.display = "none";
       document.querySelectorAll(".node-group").forEach((n) => n.classList.remove("active"));
       document.querySelectorAll(".edge").forEach((e) => {
        e.classList.toggle("active", e.dataset.edgeId === id);
       });
       const edge = EDGE_DATA.list.find((e) => e.id === id);
       if (!edge) return;
       const directionSymbols = {
        none: "â‡„",
        forward: "â†’",
        backward: "â†",
        both: "â†”",
       };
       const dirSymbol = directionSymbols[edge.direction] || "â‡„";
       let titleText = "Custom line";
       if (edge.from || edge.to) {
        const fromName = edge.from ? NODE_DATA[edge.from]?.name || edge.from : "";
        const toName = edge.to ? NODE_DATA[edge.to]?.name || edge.to : "";
        titleText = `${fromName || "?"} ${dirSymbol} ${toName || "?"}`;
       }
       document.getElementById("edge-title").textContent = titleText;
       const widthInput = document.getElementById("edge-width");
       const colorInput = document.getElementById("edge-color");
       const directionSelect = document.getElementById("edge-direction");
       const lineStyleSelect = document.getElementById("edge-line-style");
       widthInput.value = edge.width;
       colorInput.value = edge.color;
       directionSelect.value = edge.direction || "none";
       lineStyleSelect.value = edge.lineStyle || "solid";
       
       const fromPortRow = document.getElementById("edge-from-port-row");
       const toPortRow = document.getElementById("edge-to-port-row");
       const fromPortInput = document.getElementById("edge-from-port");
       const toPortInput = document.getElementById("edge-to-port");
       
       if (edge.type === "custom") {
        fromPortRow.style.display = "none";
        toPortRow.style.display = "none";
       } else {
        fromPortRow.style.display = "flex";
        toPortRow.style.display = "flex";
        fromPortInput.value = edge.fromPort || "";
        toPortInput.value = edge.toPort || "";
        
        fromPortInput.onchange = () => updateEdgePortLabels(id);
        toPortInput.onchange = () => updateEdgePortLabels(id);
       }
       
       const list = document.getElementById("edge-notes");
       list.innerHTML = "";
       edge.notes.forEach((note, i) => {
        const li = document.createElement("li");
        const txt = document.createElement("span");
        txt.textContent = note;
        txt.style.flex = "1";
        const del = document.createElement("span");
        del.className = "delete-note";
        del.textContent = "âœ•";
        del.addEventListener("click", (e) => {
         e.stopPropagation();
         challengeTheImmortal("Delete this line note?", () => {
          edge.notes.splice(i, 1);
          saveEdgeData();
          selectTheConnection(id);
         });
        });
        txt.addEventListener("dblclick", () => {
         txt.classList.add("editing");
         txt.contentEditable = true;
         txt.focus();
        });
        txt.addEventListener("blur", () => {
         txt.classList.remove("editing");
         txt.contentEditable = false;
         edge.notes[i] = txt.textContent;
         saveEdgeData();
        });
        li.append(txt, del);
        list.appendChild(li);
       });
       
       if (edge.type === "custom" && Array.isArray(edge.points)) {
        forgeTheTopology();
       }
      }
      window.addEventListener("resize", () => {
       forgeTheTopology();
       if (currentEdgeId) {
        selectTheConnection(currentEdgeId);
       } else if (currentNodeId && NODE_DATA[currentNodeId]) {
        claimTheImmortal(currentNodeId);
       } else {
        const availableNodes = Object.keys(NODE_DATA);
        if (availableNodes.length > 0) {
         claimTheImmortal(availableNodes[0]);
        }
       }
      });
      (function initZoomPan() {
       const viewport = document.getElementById("canvas-viewport");
       const svg = document.getElementById("map");
       const hint = document.getElementById("canvas-hint");
       setTimeout(() => {
        hint.classList.add("visible");
        setTimeout(() => hint.classList.remove("visible"), 4000);
       }, 1000);
       viewport.addEventListener("wheel",
        (e) => {
         e.preventDefault();
         const rect = viewport.getBoundingClientRect();
         const mouseX = (e.clientX - rect.left) / rect.width;
         const mouseY = (e.clientY - rect.top) / rect.height;
         const delta = e.deltaY > 0 ? 0.9 : 1.1;
         zoomTo(canvasState.zoom * delta, mouseX, mouseY);
        }, {
         passive: false
        }, );
       let initialPinchDistance = 0;
       let initialPinchZoom = 1;
       let pinchCenter = {
        x: 0.5,
        y: 0.5
       };
       viewport.addEventListener("touchstart",
        (e) => {
         if (e.touches.length === 2) {
          e.preventDefault();
          const touch1 = e.touches[0];
          const touch2 = e.touches[1];
          initialPinchDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY, );
          initialPinchZoom = canvasState.zoom;
          const rect = viewport.getBoundingClientRect();
          const centerX = (touch1.clientX + touch2.clientX) / 2;
          const centerY = (touch1.clientY + touch2.clientY) / 2;
          pinchCenter.x = (centerX - rect.left) / rect.width;
          pinchCenter.y = (centerY - rect.top) / rect.height;
         }
        }, {
         passive: false
        }, );
       viewport.addEventListener("touchmove",
        (e) => {
         if (e.touches.length === 2) {
          e.preventDefault();
          const touch1 = e.touches[0];
          const touch2 = e.touches[1];
          const currentDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY, );
          if (initialPinchDistance > 0) {
           const scale = currentDistance / initialPinchDistance;
           const newZoom = initialPinchZoom * scale;
           zoomTo(newZoom, pinchCenter.x, pinchCenter.y);
          }
         }
        }, {
         passive: false
        }, );
       let panStartViewX = 0;
       let panStartViewY = 0;
       
       let lastEmptyTapTime = 0;
       let emptyTapTimeout = null;
       let emptyTapMoved = false;
       let emptyTapStartX = 0;
       let emptyTapStartY = 0;
       
       viewport.addEventListener("touchend", (e) => {
         if (currentView.mode !== "rack") return;
         
         if (e.changedTouches.length !== 1) return;
         
      const isNodeOrEdge = e.target.closest(".node-group") || e.target.closest(".edge-group");
         if (isNodeOrEdge) return;
         
         if (emptyTapMoved) {
           emptyTapMoved = false;
           return;
         }
         
         const currentTime = new Date().getTime();
         const tapGap = currentTime - lastEmptyTapTime;
         
         if (tapGap < 300 && tapGap > 0) {
           e.preventDefault();
           
           exitRack();
           
           if (navigator.vibrate) {
             navigator.vibrate(50);
           }
           
           lastEmptyTapTime = 0;
           if (emptyTapTimeout) {
             clearTimeout(emptyTapTimeout);
             emptyTapTimeout = null;
           }
         } else {
           lastEmptyTapTime = currentTime;
           
           if (emptyTapTimeout) clearTimeout(emptyTapTimeout);
           emptyTapTimeout = setTimeout(() => {
             lastEmptyTapTime = 0;
           }, 300);
         }
       }, { passive: false });
       
       viewport.addEventListener("mousedown", (e) => {
        if (e.target.closest(".draw-toolbar") || e.target.closest(".topology-toolbar") || e.target.closest(".legend-container")) {
         return;
        }
      
        if (freeDrawMode || rectDrawMode) {
         return;
        }
      const isEmptySpace = e.target === svg || e.target === viewport || e.target.tagName === "svg";
      const isEdgeElement = e.target.closest('.edge') || e.target.classList.contains('edge-edit-point');
      const isTextElement = e.target.closest('.text-group') || e.target.closest('.text-element');
      const isRectElement = e.target.closest('.rect-group');
      if (!isEdgeElement && !isTextElement && !isRectElement && currentEdgeId) {
      currentEdgeId = null;
      forgeTheTopology();
      }
      if (!isRectElement && currentRectId) {
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      }
        if (isEmptySpace || e.button === 2 || e.button === 1) {
         e.preventDefault();
         canvasState.isPanning = true;
         canvasState.panStartX = e.clientX;
         canvasState.panStartY = e.clientY;
         panStartViewX = canvasState.panX;
         panStartViewY = canvasState.panY;
         viewport.classList.add("panning");
        }
       });
       viewport.addEventListener("touchstart",
        (e) => {
         if (e.target.closest(".draw-toolbar") || e.target.closest(".topology-toolbar") || e.target.closest(".legend-container")) {
          return;
         }
      
         if (freeDrawMode || rectDrawMode) {
          return;
         }
      const isEmptySpace = e.target === svg || e.target === viewport || e.target.tagName === "svg";
      const isEdgeElement = e.target.closest('.edge') || e.target.classList.contains('edge-edit-point');
      const isTextElement = e.target.closest('.text-group') || e.target.closest('.text-element');
      const isRectElement = e.target.closest('.rect-group');
      if (!isEdgeElement && !isTextElement && !isRectElement && currentEdgeId) {
      currentEdgeId = null;
      forgeTheTopology();
      }
      if (!isRectElement && currentRectId) {
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      }
          if (isEmptySpace && e.touches.length === 1) {
           e.preventDefault();
           emptyTapMoved = false;
           emptyTapStartX = e.touches[0].clientX;
           emptyTapStartY = e.touches[0].clientY;
           canvasState.isPanning = true;
           canvasState.panStartX = e.touches[0].clientX;
           canvasState.panStartY = e.touches[0].clientY;
           panStartViewX = canvasState.panX;
           panStartViewY = canvasState.panY;
           viewport.classList.add("panning");
         }
        }, {
         passive: false
        }, );
       document.addEventListener("mousemove", (e) => {
        if (!canvasState.isPanning) return;
        const dx = e.clientX - canvasState.panStartX;
        const dy = e.clientY - canvasState.panStartY;
        const rect = viewport.getBoundingClientRect();
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        const canvasDx = (dx / rect.width) * viewWidth;
        const canvasDy = (dy / rect.height) * viewHeight;
        canvasState.panX = panStartViewX - canvasDx;
        canvasState.panY = panStartViewY - canvasDy;
        constrainPan();
        updateViewBox();
       });
       document.addEventListener("touchmove", (e) => {
        if (!canvasState.isPanning || !e.touches[0]) return;
        const moveDx = Math.abs(e.touches[0].clientX - emptyTapStartX);
        const moveDy = Math.abs(e.touches[0].clientY - emptyTapStartY);
        if (moveDx > 15 || moveDy > 15) {
         emptyTapMoved = true;
        }
        const dx = e.touches[0].clientX - canvasState.panStartX;
        const dy = e.touches[0].clientY - canvasState.panStartY;
        const rect = viewport.getBoundingClientRect();
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        const canvasDx = (dx / rect.width) * viewWidth;
        const canvasDy = (dy / rect.height) * viewHeight;
        canvasState.panX = panStartViewX - canvasDx;
        canvasState.panY = panStartViewY - canvasDy;
        constrainPan();
        updateViewBox();
       });
       document.addEventListener("mouseup", () => {
        if (canvasState.isPanning) {
         canvasState.isPanning = false;
         viewport.classList.remove("panning");
        }
       });
       document.addEventListener("touchend", () => {
        if (canvasState.isPanning) {
         canvasState.isPanning = false;
         viewport.classList.remove("panning");
        }
       });
       document.addEventListener("keydown", (e) => {
        const isEditing = document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "TEXTAREA" || document.activeElement.isContentEditable;
        if (e.code === "Space" && !e.repeat && !isEditing) {
         e.preventDefault();
         canvasState.spacePressed = true;
         viewport.style.cursor = "grab";
        }
       });
       document.addEventListener("keyup", (e) => {
        if (e.code === "Space") {
         canvasState.spacePressed = false;
         viewport.style.cursor = "";
        }
       });
       document.getElementById("zoom-in-btn").addEventListener("click", () => {
        zoomTo(canvasState.zoom * 1.25, 0.5, 0.5);
       });
       document.getElementById("zoom-out-btn").addEventListener("click", () => {
        zoomTo(canvasState.zoom * 0.8, 0.5, 0.5);
       });
       document.getElementById("zoom-fit-btn").addEventListener("click", fitToContent);
       document.getElementById("zoom-reset-btn").addEventListener("click", resetView);
       const minimapContainer = document.getElementById("minimap-container");
       const minimapSvg = document.getElementById("minimap");
       let minimapDragging = false;
       minimapContainer.addEventListener("mousedown", (e) => {
        e.preventDefault();
        minimapDragging = true;
        updatePanFromMinimap(e);
       });
       minimapContainer.addEventListener("touchstart",
        (e) => {
         e.preventDefault();
         minimapDragging = true;
         updatePanFromMinimapTouch(e);
        }, {
         passive: false
        }, );
       document.addEventListener("mousemove", (e) => {
        if (minimapDragging) {
         updatePanFromMinimap(e);
        }
       });
       document.addEventListener("touchmove", (e) => {
        if (minimapDragging && e.touches[0]) {
         updatePanFromMinimapTouch(e);
        }
       });
       document.addEventListener("mouseup", () => {
        minimapDragging = false;
       });
       document.addEventListener("touchend", () => {
        minimapDragging = false;
       });
      
       function updatePanFromMinimap(e) {
        const rect = minimapContainer.getBoundingClientRect();
        const x = (e.clientX - rect.left) / rect.width;
        const y = (e.clientY - rect.top) / rect.height;
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        canvasState.panX = x * CANVAS_WIDTH - viewWidth / 2;
        canvasState.panY = y * CANVAS_HEIGHT - viewHeight / 2;
        constrainPan();
        updateViewBox();
       }
      
       function updatePanFromMinimapTouch(e) {
        const rect = minimapContainer.getBoundingClientRect();
        const touch = e.touches[0];
        const x = (touch.clientX - rect.left) / rect.width;
        const y = (touch.clientY - rect.top) / rect.height;
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        canvasState.panX = x * CANVAS_WIDTH - viewWidth / 2;
        canvasState.panY = y * CANVAS_HEIGHT - viewHeight / 2;
        constrainPan();
        updateViewBox();
       }
       document.addEventListener("keydown", (e) => {
        if (document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "TEXTAREA") return;
        if (
         (e.key === "+" || e.key === "=") && (e.ctrlKey || e.metaKey)) {
         e.preventDefault();
         zoomTo(canvasState.zoom * 1.25, 0.5, 0.5);
        } else if (e.key === "-" && (e.ctrlKey || e.metaKey)) {
         e.preventDefault();
         zoomTo(canvasState.zoom * 0.8, 0.5, 0.5);
        } else if (e.key === "0" && (e.ctrlKey || e.metaKey)) {
         e.preventDefault();
         resetView();
        }
       });
       setTimeout(() => {
        fitToContent();
       }, 100);
      })();
      const sizeSlider = document.getElementById("size-slider");
      const sizeValue = document.getElementById("size-value");
      const resetSizeBtn = document.getElementById("reset-size");
      sizeSlider.addEventListener("input", () => {
       const newSize = parseInt(sizeSlider.value, 10);
       sizeValue.textContent = newSize;
       savedSizes[currentNodeId] = newSize;
       const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
       if (nodeGroup) {
        const oldShape = nodeGroup.querySelector(".node-circle");
        if (oldShape) oldShape.remove();
        const shapeType = (NODE_DATA[currentNodeId] && NODE_DATA[currentNodeId].shape) || "circle";
        const newShape = createShapeElement(shapeType, newSize);
        newShape.classList.add("node-circle");
        const styles = resolveStylesForNode(currentNodeId);
        if (styles.circleColor) newShape.style.fill = styles.circleColor;
        if (styles.circleBorder) newShape.style.stroke = styles.circleBorder;
        nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
        const label = nodeGroup.querySelector(".node-label");
        const sub = nodeGroup.querySelector(".node-sub");
        if (label) {
         label.setAttribute("y", -newSize * 0.28);
         const labelSize = styles.titleSize || newSize * 0.33;
         label.style.fontSize = labelSize + "px";
        }
        if (sub) {
         sub.setAttribute("y", newSize * 0.4);
         const subSize = styles.subSize || newSize * 0.24;
         sub.style.fontSize = subSize + "px";
        }
       }
      });
      resetSizeBtn.addEventListener("click", () => {
       delete savedSizes[currentNodeId];
       const defaultSize = getDefaultSize();
       sizeSlider.value = defaultSize;
       sizeValue.textContent = defaultSize;
       const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
       if (nodeGroup) {
        const oldShape = nodeGroup.querySelector(".node-circle");
        if (oldShape) oldShape.remove();
        const shapeType = (NODE_DATA[currentNodeId] && NODE_DATA[currentNodeId].shape) || "circle";
        const newShape = createNodeShape(currentNodeId, defaultSize);
        nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
        const styles = resolveStylesForNode(currentNodeId);
        if (styles.circleColor) newShape.style.fill = styles.circleColor;
        if (styles.circleBorder) newShape.style.stroke = styles.circleBorder;
        const label = nodeGroup.querySelector(".node-label");
        const sub = nodeGroup.querySelector(".node-sub");
        if (label) {
         label.setAttribute("y", -defaultSize * 0.28);
         const labelSize = styles.titleSize || defaultSize * 0.33;
         label.style.fontSize = labelSize + "px";
        }
        if (sub) {
         sub.setAttribute("y", defaultSize * 0.4);
         const subSize = styles.subSize || defaultSize * 0.24;
         sub.style.fontSize = subSize + "px";
        }
       }
      });
      const applyStyle = (property, value) => {
       const styleEntry = ensureStyleEntry(currentNodeId);
       const scopeKey = currentStyleScope || "all";
       if (!styleEntry[scopeKey]) styleEntry[scopeKey] = {};
       styleEntry[scopeKey][property] = value;
       const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
       if (!nodeGroup) return;
       const shapeEl = nodeGroup.querySelector(".node-circle");
       const label = nodeGroup.querySelector(".node-label");
       const sub = nodeGroup.querySelector(".node-sub");
       if (property === "circleColor" && shapeEl) shapeEl.style.fill = value;
      else if (property === "circleBorder" && shapeEl) shapeEl.style.stroke = value;
       else if (property === "titleColor" && label) label.style.fill = value;
       else if (property === "titleFont" && label) label.style.fontFamily = value;
       else if (property === "titleSize" && label) label.style.fontSize = value + "px";
       else if (property === "subColor" && sub) sub.style.fill = value;
       else if (property === "subFont" && sub) sub.style.fontFamily = value;
       else if (property === "subSize" && sub) sub.style.fontSize = value + "px";
      };
      document.getElementById("circle-color").addEventListener("input", (e) => applyStyle("circleColor", e.target.value), );
      document.getElementById("circle-border").addEventListener("input", (e) => applyStyle("circleBorder", e.target.value), );
      document.getElementById("title-color").addEventListener("input", (e) => applyStyle("titleColor", e.target.value), );
      document.getElementById("title-font").addEventListener("change", (e) => applyStyle("titleFont", e.target.value), );
      document.getElementById("title-size").addEventListener("input", (e) => applyStyle("titleSize", parseInt(e.target.value, 10)), );
      document.getElementById("sub-color").addEventListener("input", (e) => applyStyle("subColor", e.target.value), );
      document.getElementById("sub-font").addEventListener("change", (e) => applyStyle("subFont", e.target.value), );
      document.getElementById("sub-size").addEventListener("input", (e) => applyStyle("subSize", parseInt(e.target.value, 10)), );
      document.getElementById("title-offset-y").addEventListener("input", (e) => {
       applyStyle("titleOffsetY", parseInt(e.target.value, 10) || 0);
       forgeTheTopology();
       if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      document.getElementById("title-offset-x").addEventListener("input", (e) => {
       applyStyle("titleOffsetX", parseInt(e.target.value, 10) || 0);
       forgeTheTopology();
       if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      document.getElementById("sub-offset-y").addEventListener("input", (e) => {
       applyStyle("subOffsetY", parseInt(e.target.value, 10) || 0);
       forgeTheTopology();
       if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      document.getElementById("sub-offset-x").addEventListener("input", (e) => {
       applyStyle("subOffsetX", parseInt(e.target.value, 10) || 0);
       forgeTheTopology();
       if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      document.getElementById("reset-styles").addEventListener("click", () => {
       delete savedStyles[currentNodeId];
       forgeTheTopology();
       claimTheImmortal(currentNodeId);
      });
      document.getElementById("style-scope").addEventListener("change", (e) => {
       currentStyleScope = e.target.value || "all";
       claimTheImmortal(currentNodeId);
      });
      document.getElementById("shape-select").addEventListener("change", (e) => {
       const shape = e.target.value || "circle";
       NODE_DATA[currentNodeId].shape = shape;
       const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
       if (!nodeGroup) return;
       const oldShape = nodeGroup.querySelector(".node-circle");
       if (oldShape) oldShape.remove();
       const size = savedSizes[currentNodeId] || getDefaultSize();
       const newShape = createNodeShape(currentNodeId, size);
       nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
      });
      const addNoteBtn = document.getElementById("add-note-btn");
      const noteInput = document.getElementById("new-note-input");
      addNoteBtn.addEventListener("click", () => {
       const newNote = noteInput.value.trim();
       if (newNote && currentNodeId) {
        NODE_DATA[currentNodeId].notes.push(newNote);
        claimTheImmortal(currentNodeId);
        noteInput.value = "";
       }
      });
      noteInput.addEventListener("keypress", (e) => {
       if (e.key === "Enter") {
        addNoteBtn.click();
       }
      });
      document.getElementById("edge-width").addEventListener("input", () => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       const v = parseInt(document.getElementById("edge-width").value, 10);
       if (Number.isNaN(v) || v <= 0) return;
       edge.width = v;
       saveEdgeData();
       const el = document.querySelector(`.edge[data-edge-id="${currentEdgeId}"]`, );
       if (el) el.style.strokeWidth = v;
      });
      document.getElementById("edge-color").addEventListener("input", () => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       const color = document.getElementById("edge-color").value;
       edge.color = color;
       saveEdgeData();
       const el = document.querySelector(`.edge[data-edge-id="${currentEdgeId}"]`, );
       if (el) el.style.stroke = color;
       forgeTheLegend();
      });
      document.getElementById("edge-direction").addEventListener("change", () => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       edge.direction = document.getElementById("edge-direction").value;
       saveEdgeData();
       forgeTheTopology();
       selectTheConnection(currentEdgeId);
      });
      document.getElementById("edge-line-style").addEventListener("change", () => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       edge.lineStyle = document.getElementById("edge-line-style").value;
       saveEdgeData();
       forgeTheTopology();
       selectTheConnection(currentEdgeId);
      });
      const addEdgeNoteBtn = document.getElementById("add-edge-note");
      const newEdgeNoteInput = document.getElementById("new-edge-note");
      addEdgeNoteBtn.addEventListener("click", () => {
       const txt = newEdgeNoteInput.value.trim();
       if (!txt || !currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       edge.notes.push(txt);
       saveEdgeData();
       newEdgeNoteInput.value = "";
       selectTheConnection(currentEdgeId);
      });
      newEdgeNoteInput.addEventListener("keypress", (e) => {
       if (e.key === "Enter") {
        addEdgeNoteBtn.click();
       }
      });
      function selectTheRect(id) {
      currentRectId = id;
      document.getElementById("node-panel").style.display = "none";
      document.getElementById("edge-panel").style.display = "none";
      document.getElementById("text-panel").style.display = "none";
      document.getElementById("rect-panel").style.display = "block";
      document.getElementById("topology-toolbar").style.display = "none";
      
      const rect = RECT_DATA.list.find(r => r.id === id);
      if (!rect) return;
      
      document.getElementById("rect-title").textContent = "";
      document.getElementById("rect-color").value = rect.color || "#f97316";
      document.getElementById("rect-border-color").value = rect.borderColor || rect.color || "#f97316";
      document.getElementById("rect-border-width").value = rect.borderWidth !== undefined ? rect.borderWidth : 2;
      document.getElementById("rect-style-select").value = rect.style || "filled";
      document.getElementById("rect-fill-row").style.display = (rect.style === "outlined") ? "none" : "flex";
      
      const list = document.getElementById("rect-notes");
      list.innerHTML = "";
      (rect.notes || []).forEach((note, i) => {
      const li = document.createElement("li");
      const txt = document.createElement("span");
      txt.textContent = note;
      txt.style.flex = "1";
      const del = document.createElement("span");
      del.className = "delete-note";
      del.textContent = "âœ•";
      del.addEventListener("click", (e) => {
      e.stopPropagation();
      challengeTheImmortal("Delete this note?", () => {
        rect.notes.splice(i, 1);
        selectTheRect(id);
      });
      });
      li.appendChild(txt);
      li.appendChild(del);
      list.appendChild(li);
      });
      
      forgeTheTopology();
      }
      
      document.getElementById("rect-color").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      rect.color = document.getElementById("rect-color").value;
      forgeTheTopology();
      });
      
      document.getElementById("rect-border-color").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      rect.borderColor = document.getElementById("rect-border-color").value;
      forgeTheTopology();
      });
      
      document.getElementById("rect-border-width").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      rect.borderWidth = parseInt(document.getElementById("rect-border-width").value) || 2;
      forgeTheTopology();
      });
      
      document.getElementById("rect-style-select").addEventListener("change", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      rect.style = document.getElementById("rect-style-select").value;
      forgeTheTopology();
      selectTheRect(currentRectId);
      });
      
      document.getElementById("add-rect-note").addEventListener("click", () => {
      const input = document.getElementById("new-rect-note");
      const txt = input.value.trim();
      if (!txt || !currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      if (!rect.notes) rect.notes = [];
      rect.notes.push(txt);
      input.value = "";
      selectTheRect(currentRectId);
      });
      
      document.getElementById("new-rect-note").addEventListener("keypress", (e) => {
      if (e.key === "Enter") {
      document.getElementById("add-rect-note").click();
      }
      });
      
      document.getElementById("delete-rect").addEventListener("click", () => {
      if (!currentRectId) return;
      challengeTheImmortal("Delete this zone?", () => {
      RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== currentRectId);
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      });
      });
      document.getElementById("delete-edge").addEventListener("click", () => {
       if (!currentEdgeId) return;
       challengeTheImmortal("Are you sure you want to delete this line?",
        () => {
         EDGE_DATA.list = EDGE_DATA.list.filter(
          (e) => e.id !== currentEdgeId, );
         saveEdgeData();
         currentEdgeId = null;
         forgeTheTopology();
         const availableNodes = Object.keys(NODE_DATA);
         if (availableNodes.length > 0) {
          claimTheImmortal(availableNodes[0]);
         } else {
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("topology-toolbar", ).style.display = "none";
         }
        }, );
      });
      document.getElementById("add-line-btn").addEventListener("click", () => {
       if (!currentNodeId) return;
       const select = document.getElementById("add-line-select");
       const directionSelect = document.getElementById("add-line-direction");
       const colorInput = document.getElementById("add-line-color");
       const targetId = select.value;
       if (!targetId || targetId === currentNodeId) return;
       const direction = directionSelect.value || "none";
       const lineColor = colorInput.value || "#475569";
       const newId = `${currentNodeId}-${targetId}-${Date.now()}`;
       const newEdge = {
        id: newId,
        from: currentNodeId,
        to: targetId,
        width: 4,
        color: lineColor,
        direction: direction,
        type: "main",
        notes: [],
        fromPort: "",
        toPort: "",
        lineStyle: "solid",
       };
       EDGE_DATA.list.push(newEdge);
       saveEdgeData();
       forgeTheTopology();
       claimTheImmortal(currentNodeId);
      });
      let freeDrawPoints = [];
      let freeDrawPolylineEl = null;
      let freeDrawPointEls = [];
       let currentTextId = null;
       let rectStartPoint = null;
       let rectPreviewEl = null;
       let rectStyle = "filled";
      const drawToggleBtn = document.getElementById("draw-toggle");
      const drawUndoBtn = document.getElementById("draw-undo");
      const drawColorInput = document.getElementById("draw-color");
      const drawStyleSelect = document.getElementById("draw-style");
      const drawArrowSelect = document.getElementById("draw-arrow");
      const svgMap = document.getElementById("map");
      
      function updateFreeDrawGraphics() {
       const ns = "http://www.w3.org/2000/svg";
       const svg = svgMap;
       if (!freeDrawPolylineEl && freeDrawPoints.length > 0) {
        freeDrawPolylineEl = document.createElementNS(ns, "polyline");
        freeDrawPolylineEl.classList.add("edge", "free-preview");
        freeDrawPolylineEl.setAttribute("fill", "none");
        svg.appendChild(freeDrawPolylineEl);
       }
       if (freeDrawPolylineEl) {
        if (freeDrawPoints.length === 0) {
         freeDrawPolylineEl.remove();
         freeDrawPolylineEl = null;
        } else {
         const ptsStr = freeDrawPoints.map((p) => `${p.x},${p.y}`).join(" ");
         freeDrawPolylineEl.setAttribute("points", ptsStr);
         freeDrawPolylineEl.style.stroke = drawColorInput.value || "#475569";
         freeDrawPolylineEl.style.strokeWidth = 3;
         const lineStyle = drawStyleSelect.value || "solid";
         if (lineStyle === "dashed") {
          freeDrawPolylineEl.style.strokeDasharray = "10,5";
         } else if (lineStyle === "dotted") {
          freeDrawPolylineEl.style.strokeDasharray = "2,4";
         } else {
          freeDrawPolylineEl.style.strokeDasharray = "none";
         }
        }
       }
       freeDrawPointEls.forEach((el) => el.remove());
       freeDrawPointEls = [];
       freeDrawPoints.forEach((p, idx) => {
        const c = document.createElementNS(ns, "circle");
        c.classList.add("free-point");
        c.setAttribute("cx", p.x);
        c.setAttribute("cy", p.y);
        c.setAttribute("r", 5);
        c.dataset.index = String(idx);
        c.addEventListener("mousedown", (e) => {
         if (!freeDrawMode) return;
         e.preventDefault();
         e.stopPropagation();
         let dragging = true;
         const svgEl = svgMap;
         const moveHandler = (ev) => {
          if (!dragging) return;
          const pt = svgEl.createSVGPoint();
          pt.x = ev.clientX;
          pt.y = ev.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          const i = parseInt(c.dataset.index, 10);
          if (Number.isNaN(i) || !freeDrawPoints[i]) return;
          freeDrawPoints[i].x = svgP.x;
          freeDrawPoints[i].y = svgP.y;
          updateFreeDrawGraphics();
         };
         const upHandler = () => {
          dragging = false;
          document.removeEventListener("mousemove", moveHandler);
          document.removeEventListener("mouseup", upHandler);
         };
         document.addEventListener("mousemove", moveHandler);
         document.addEventListener("mouseup", upHandler);
        });
        c.addEventListener("touchstart",
         (e) => {
          if (!freeDrawMode) return;
          e.preventDefault();
          e.stopPropagation();
          let dragging = true;
          const svgEl = svgMap;
          const touchMoveHandler = (ev) => {
           if (!dragging || !ev.touches[0]) return;
           const pt = svgEl.createSVGPoint();
           pt.x = ev.touches[0].clientX;
           pt.y = ev.touches[0].clientY;
           const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
           const i = parseInt(c.dataset.index, 10);
           if (Number.isNaN(i) || !freeDrawPoints[i]) return;
           freeDrawPoints[i].x = svgP.x;
           freeDrawPoints[i].y = svgP.y;
           updateFreeDrawGraphics();
          };
          const touchUpHandler = () => {
           dragging = false;
           document.removeEventListener("touchmove", touchMoveHandler, );
           document.removeEventListener("touchend", touchUpHandler, );
          };
          document.addEventListener("touchmove", touchMoveHandler);
          document.addEventListener("touchend", touchUpHandler);
         }, {
          passive: false
         }, );
        svg.appendChild(c);
        freeDrawPointEls.push(c);
       });
       drawUndoBtn.style.display = freeDrawPoints.length ? "inline-block" : "none";
      }
      
      function addFreeDrawPoint(x, y) {
       freeDrawPoints.push({
        x,
        y
       });
       updateFreeDrawGraphics();
      }
      
      function startFreeDraw() {
       freeDrawMode = true;
       freeDrawPoints = [];
       if (freeDrawPolylineEl) {
        freeDrawPolylineEl.remove();
        freeDrawPolylineEl = null;
       }
       freeDrawPointEls.forEach((el) => el.remove());
       freeDrawPointEls = [];
       svgMap.style.cursor = "crosshair";
       drawToggleBtn.textContent = "Done";
       drawUndoBtn.style.display = "none";
      }
      
      function finishFreeDraw() {
       freeDrawMode = false;
       svgMap.style.cursor = "";
       drawToggleBtn.textContent = "âœï¸";
       if (freeDrawPoints.length >= 2) {
        const color = drawColorInput.value || "#475569";
        const lineStyle = drawStyleSelect.value || "solid";
        const arrowDir = drawArrowSelect.value || "none";
        const newId = "custom-" + Date.now();
        const pointsCopy = freeDrawPoints.map((p) => ({
         x: p.x,
         y: p.y,
        }));
        EDGE_DATA.list.push({
         id: newId,
         type: "custom",
         color,
         width: 4,
         lineStyle: lineStyle,
         direction: arrowDir,
         points: pointsCopy,
         notes: [],
        });
        saveEdgeData();
        freeDrawPoints = [];
        if (freeDrawPolylineEl) {
         freeDrawPolylineEl.remove();
         freeDrawPolylineEl = null;
        }
        freeDrawPointEls.forEach((el) => el.remove());
        freeDrawPointEls = [];
        forgeTheTopology();
        selectTheConnection(newId);
       } else {
        freeDrawPoints = [];
        if (freeDrawPolylineEl) {
         freeDrawPolylineEl.remove();
         freeDrawPolylineEl = null;
        }
        freeDrawPointEls.forEach((el) => el.remove());
        freeDrawPointEls = [];
        forgeTheLegend();
       }
       drawUndoBtn.style.display = "none";
      }
      drawToggleBtn.addEventListener("click", () => {
       if (currentView.mode === "rack") {
        alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
        return;
       }
       
       if (freeDrawMode) {
        finishFreeDraw();
       } else {
        startFreeDraw();
       }
      });
      drawUndoBtn.addEventListener("click", () => {
       if (!freeDrawMode || !freeDrawPoints.length) return;
       freeDrawPoints.pop();
       updateFreeDrawGraphics();
      });
      const drawToolbar = document.getElementById("draw-toolbar");
      drawToolbar.addEventListener("mousedown", (e) => {
       e.stopPropagation();
      });
      drawToolbar.addEventListener("click", (e) => {
       if (e.target !== drawToggleBtn && e.target !== drawUndoBtn) {
        e.stopPropagation();
       }
      });
      drawStyleSelect.addEventListener("change", () => {
       if (freeDrawMode) {
        updateFreeDrawGraphics();
       }
      });
      drawArrowSelect.addEventListener("change", () => {
       if (freeDrawMode) {
        updateFreeDrawGraphics();
       }
      });
      drawColorInput.addEventListener("input", () => {
       if (freeDrawMode) {
        updateFreeDrawGraphics();
       }
      });
      drawStyleSelect.addEventListener("mousedown", (e) => {
       e.stopPropagation();
      });
      drawStyleSelect.addEventListener("click", (e) => {
       e.stopPropagation();
      });
      drawArrowSelect.addEventListener("mousedown", (e) => {
       e.stopPropagation();
      });
      drawArrowSelect.addEventListener("click", (e) => {
       e.stopPropagation();
      });
      drawColorInput.addEventListener("mousedown", (e) => {
       e.stopPropagation();
      });
      drawColorInput.addEventListener("click", (e) => {
       e.stopPropagation();
      });
      
      svgMap.addEventListener("click", (e) => {
       if (!freeDrawMode) return;
       if (e.button !== 0) return;
       const target = e.target;
       if (target && target.classList && target.classList.contains("free-point")) return;
       const svgEl = svgMap;
       const pt = svgEl.createSVGPoint();
       pt.x = e.clientX;
       pt.y = e.clientY;
       const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
       addFreeDrawPoint(svgP.x, svgP.y);
      });
      svgMap.addEventListener("touchend",
       (e) => {
        if (!freeDrawMode) return;
        const target = e.target;
        if (target && target.classList && target.classList.contains("free-point")) return;
        if (e.changedTouches && e.changedTouches[0]) {
         e.preventDefault();
         const svgEl = svgMap;
         const pt = svgEl.createSVGPoint();
         pt.x = e.changedTouches[0].clientX;
         pt.y = e.changedTouches[0].clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
         addFreeDrawPoint(svgP.x, svgP.y);
        }
       }, {
        passive: false
       }, );
      
       const rectToggleBtn = document.getElementById("rect-toggle");
       const rectStyleSelect = document.getElementById("rect-style");
      
       function startRectDraw() {
        rectDrawMode = true;
        rectStartPoint = null;
        rectPreviewEl = null;
        svgMap.style.cursor = "crosshair";
        rectToggleBtn.textContent = "Done";
        rectStyle = rectStyleSelect.value || "filled";
        
        if (freeDrawMode) {
         finishFreeDraw();
        }
        updateRectangleDeleteButtons();
       }
      
       function finishRectDraw() {
        rectDrawMode = false;
        svgMap.style.cursor = "";
        rectToggleBtn.textContent = "â–­";
        
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
        updateRectangleDeleteButtons();
       }
      
       rectToggleBtn.addEventListener("click", () => {
        if (currentView.mode === "rack") {
         alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
         return;
        }
        
        if (rectDrawMode) {
         finishRectDraw();
        } else {
         startRectDraw();
        }
       });
      
       rectStyleSelect.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       rectStyleSelect.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       rectStyleSelect.addEventListener("change", () => {
        if (rectDrawMode) {
         rectStyle = rectStyleSelect.value || "filled";
        }
       });
      
       svgMap.addEventListener("mousedown", (e) => {
        if (!rectDrawMode) return;
        if (e.button !== 0) return;
        e.preventDefault();
        e.stopPropagation();
        
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        rectStartPoint = { x: svgP.x, y: svgP.y };
        
        const ns = "http://www.w3.org/2000/svg";
        rectPreviewEl = document.createElementNS(ns, "rect");
        rectPreviewEl.classList.add("rect-preview");
        rectPreviewEl.setAttribute("x", svgP.x);
        rectPreviewEl.setAttribute("y", svgP.y);
        rectPreviewEl.setAttribute("width", 0);
        rectPreviewEl.setAttribute("height", 0);
        
        const color = drawColorInput.value || "#f97316";
        rectPreviewEl.style.stroke = color;
        rectPreviewEl.style.strokeWidth = 2;
        rectPreviewEl.style.strokeDasharray = "5,5";
        
        if (rectStyle === "filled") {
         rectPreviewEl.style.fill = color;
         rectPreviewEl.style.fillOpacity = "0.3";
        } else {
         rectPreviewEl.style.fill = "none";
        }
        
        svgEl.appendChild(rectPreviewEl);
       });
      
       svgMap.addEventListener("mousemove", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        
        rectPreviewEl.setAttribute("x", x);
        rectPreviewEl.setAttribute("y", y);
        rectPreviewEl.setAttribute("width", width);
        rectPreviewEl.setAttribute("height", height);
       });
      
       svgMap.addEventListener("mouseup", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        
        if (width > 10 && height > 10) {
      pushUndo("draw zone");
         const color = drawColorInput.value || "#f97316";
         const newId = "rect-" + Date.now();
         
          const lineStyle = document.getElementById("draw-style").value || "solid";
         RECT_DATA.list.push({
          id: newId,
          x: x,
          y: y,
          width: width,
          height: height,
          color: color,
          style: rectStyle,
          lineStyle: lineStyle,
          notes: []
         });
         
         forgeTheTopology();
        }
        
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
       });
      
       let rectTouchStart = null;
       
       svgMap.addEventListener("touchstart", (e) => {
        if (!rectDrawMode) return;
        if (e.touches.length !== 1) return;
        
        e.preventDefault();
        const touch = e.touches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        rectStartPoint = { x: svgP.x, y: svgP.y };
        rectTouchStart = { x: svgP.x, y: svgP.y };
        
        const ns = "http://www.w3.org/2000/svg";
        rectPreviewEl = document.createElementNS(ns, "rect");
        rectPreviewEl.classList.add("rect-preview");
        rectPreviewEl.setAttribute("x", svgP.x);
        rectPreviewEl.setAttribute("y", svgP.y);
        rectPreviewEl.setAttribute("width", 0);
        rectPreviewEl.setAttribute("height", 0);
        
        const color = drawColorInput.value || "#f97316";
        rectPreviewEl.style.stroke = color;
        rectPreviewEl.style.strokeWidth = 2;
        rectPreviewEl.style.strokeDasharray = "5,5";
        
        if (rectStyle === "filled") {
         rectPreviewEl.style.fill = color;
         rectPreviewEl.style.fillOpacity = "0.3";
        } else {
         rectPreviewEl.style.fill = "none";
        }
        
        svgEl.appendChild(rectPreviewEl);
       }, { passive: false });
      
       svgMap.addEventListener("touchmove", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        if (e.touches.length !== 1) return;
        
        e.preventDefault();
        const touch = e.touches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        
        rectPreviewEl.setAttribute("x", x);
        rectPreviewEl.setAttribute("y", y);
        rectPreviewEl.setAttribute("width", width);
        rectPreviewEl.setAttribute("height", height);
       }, { passive: false });
      
       svgMap.addEventListener("touchend", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        if (!rectTouchStart) return;
        
        e.preventDefault();
        const touch = e.changedTouches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        
        if (width > 10 && height > 10) {
      pushUndo("draw zone");
         const color = drawColorInput.value || "#f97316";
         const newId = "rect-" + Date.now();
         
        const lineStyle = document.getElementById("draw-style").value || "solid";
         RECT_DATA.list.push({
          id: newId,
          x: x,
          y: y,
          width: width,
          height: height,
          color: color,
          style: rectStyle,
          lineStyle: lineStyle,
          notes: []
         });
         
         forgeTheTopology();
        }
        
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
        rectTouchStart = null;
       }, { passive: false });
      
      const textToggleBtn = document.getElementById("text-toggle");
      
      function startTextMode() {
       textDrawMode = true;
       svgMap.style.cursor = "crosshair";
       textToggleBtn.textContent = "Done";
       textToggleBtn.style.background = "var(--accent)";
       textToggleBtn.style.color = "var(--bg)";
       
       if (freeDrawMode) {
        finishFreeDraw();
       }
       if (rectDrawMode) {
        finishRectDraw();
       }
       
       updateTextDeleteButtons();
      }
      
      function finishTextMode() {
       textDrawMode = false;
       svgMap.style.cursor = "";
       textToggleBtn.textContent = "T";
       textToggleBtn.style.background = "";
       textToggleBtn.style.color = "";
       updateTextDeleteButtons();
      }
      
      textToggleBtn.addEventListener("click", () => {
       if (currentView.mode === "rack") {
        alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
        return;
       }
       
       if (textDrawMode) {
        finishTextMode();
       } else {
        startTextMode();
       }
      });
      
      function handleTextPlacement(e) {
       if (!textDrawMode) return;
       
       const svgEl = svgMap;
       const pt = svgEl.createSVGPoint();
       pt.x = e.clientX;
       pt.y = e.clientY;
       const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
       
       const newId = "text-" + Date.now();
      pushUndo("add text");
       TEXT_DATA.list.push({
        id: newId,
        x: svgP.x,
        y: svgP.y,
        content: "New Text",
        fontSize: 18,
        color: "#e2e8f0",
        fontWeight: "normal",
        fontStyle: "normal",
        textAlign: "start",
        textDecoration: "none",
        bgColor: "#000000",
        bgEnabled: false,
        opacity: 1
       });
       
       forgeTheTopology();
       
       showTextPanel(newId);
      }
      
      svgMap.addEventListener("click", (e) => {
       if (!textDrawMode) return;
       if (e.target.closest('.text-delete-btn')) return;
       if (e.target.closest('.text-group')) return;
       
       e.preventDefault();
       e.stopPropagation();
       handleTextPlacement(e);
      });
      
      svgMap.addEventListener("touchend", (e) => {
       if (!textDrawMode) return;
       if (e.target.closest('.text-delete-btn')) return;
       if (e.target.closest('.text-group')) return;
       if (e.touches.length > 0) return;
       
       e.preventDefault();
       const touch = e.changedTouches[0];
       const fakeEvent = {
        clientX: touch.clientX,
        clientY: touch.clientY,
        preventDefault: () => {},
        stopPropagation: () => {}
       };
       handleTextPlacement(fakeEvent);
      }, { passive: false });
      
      function showTextPanel(textId) {
       currentTextId = textId;
       const textItem = TEXT_DATA.list.find(t => t.id === textId);
       if (!textItem) return;
       
       document.getElementById("node-panel").style.display = "none";
       document.getElementById("edge-panel").style.display = "none";
       
       const textPanel = document.getElementById("text-panel");
       textPanel.style.display = "block";
       
       document.getElementById("text-content").value = textItem.content;
       document.getElementById("text-font-size").value = textItem.fontSize;
       document.getElementById("text-color").value = textItem.color;
       document.getElementById("text-font-weight").value = textItem.fontWeight;
       document.getElementById("text-font-style").value = textItem.fontStyle;
       document.getElementById("text-align").value = textItem.textAlign;
       document.getElementById("text-decoration").value = textItem.textDecoration;
       document.getElementById("text-bg-color").value = textItem.bgColor;
       document.getElementById("text-bg-enabled").checked = textItem.bgEnabled;
       document.getElementById("text-opacity").value = textItem.opacity;
       document.getElementById("text-opacity-val").textContent = Math.round(textItem.opacity * 100) + "%";
      }
      
      function updateTextDeleteButtons() {
       const deleteButtons = document.querySelectorAll('.text-delete-btn');
       deleteButtons.forEach(btn => {
        btn.style.display = textDrawMode ? 'block' : 'none';
       });
      }
      
      function deleteText(textId) {
      pushUndo("delete text");
       TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== textId);
       forgeTheTopology();
       
       if (currentTextId === textId) {
        document.getElementById("text-panel").style.display = "none";
        currentTextId = null;
       }
      }
      
      document.getElementById("text-content").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
      pushUndo("edit text");
        textItem.content = e.target.value;
        forgeTheTopology();
       }
      });
      
      document.getElementById("text-font-size").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        textItem.fontSize = parseInt(e.target.value);
        forgeTheTopology();
       }
      });
      
      document.getElementById("text-color").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        textItem.color = e.target.value;
        forgeTheTopology();
       }
      });
      
      document.getElementById("text-font-weight").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        textItem.fontWeight = e.target.value;
        forgeTheTopology();
       }
      });
      
      document.getElementById("text-font-style").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        textItem.fontStyle = e.target.value;
        forgeTheTopology();
       }
      });
      
      document.getElementById("text-align").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        textItem.textAlign = e.target.value;
        forgeTheTopology();
       }
      });
      
      document.getElementById("text-decoration").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        textItem.textDecoration = e.target.value;
        forgeTheTopology();
       }
      });
      
      document.getElementById("text-bg-color").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        textItem.bgColor = e.target.value;
        forgeTheTopology();
       }
      });
      
      document.getElementById("text-bg-enabled").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        textItem.bgEnabled = e.target.checked;
        forgeTheTopology();
       }
      });
      
      document.getElementById("text-opacity").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        textItem.opacity = parseFloat(e.target.value);
        document.getElementById("text-opacity-val").textContent = Math.round(textItem.opacity * 100) + "%";
        forgeTheTopology();
       }
      });
      
      document.getElementById("delete-text").addEventListener("click", () => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        challengeTheImmortal(`Delete text "${textItem.content.substring(0, 30)}..."?`, () => {
         deleteText(currentTextId);
        });
       }
      });
      
      const settingsBtn = document.getElementById("settings-btn");
      const settingsModal = document.getElementById("settings-modal");
      const settingsClose = document.getElementById("settings-close");
      settingsBtn.addEventListener("click", () => {
       document.getElementById("page-bg-color").value = PAGE_STATE.background || "#050608";
       document.getElementById("topbar-bg-color").value = PAGE_STATE.topbarBg || "#0b0e13";
       document.getElementById("topbar-border-color").value = PAGE_STATE.topbarBorder || "#1f2533";
       document.getElementById("panel-color").value = PAGE_STATE.panel || "#0b0e13";
       document.getElementById("panel-alt-color").value = PAGE_STATE.panelAlt || "#10141b";
       document.getElementById("sidebar-bg-color").value = PAGE_STATE.sidebarBg || "#10141b";
       document.getElementById("btn-bg-color").value = PAGE_STATE.btnBg || "#0b0e13";
       document.getElementById("btn-text-color").value = PAGE_STATE.btnText || "#e2e8f0";
       document.getElementById("tag-fill-color").value = PAGE_STATE.tagFill || "#1e293b";
       document.getElementById("tag-text-color").value = PAGE_STATE.tagText || "#e2e8f0";
       document.getElementById("tag-border-color").value = PAGE_STATE.tagBorder || "#475569";
       document.getElementById("input-bg-color").value = PAGE_STATE.inputBg || "#0b0e13";
       document.getElementById("input-text-color").value = PAGE_STATE.inputText || "#e2e8f0";
       document.getElementById("input-border-color").value = PAGE_STATE.inputBorder || "#1f2937";
       document.getElementById("input-font-family").value = PAGE_STATE.inputFont || "Inter, system-ui, sans-serif";
       document.getElementById("input-font-size").value = PAGE_STATE.inputFontSize || 14;
       document.getElementById("toolbar-bg-color").value = PAGE_STATE.toolbarBg || "#0f172a";
       document.getElementById("toolbar-border-color").value = PAGE_STATE.toolbarBorder || "#1f2937";
       document.getElementById("toolbar-text-color").value = PAGE_STATE.toolbarText || "#94a3b8";
       document.getElementById("toolbar-btn-bg-color").value = PAGE_STATE.toolbarBtnBg || "#0b0e13";
       document.getElementById("toolbar-btn-text-color").value = PAGE_STATE.toolbarBtnText || "#e2e8f0";
       document.getElementById("minimap-dots-color").value = PAGE_STATE.minimapDots || "#94a3b8";
       document.getElementById("canvas-hint-enabled").checked = PAGE_STATE.canvasHintEnabled !== false;
       document.getElementById("canvas-hint-bg-color").value = PAGE_STATE.canvasHintBg || "#0f172a";
       document.getElementById("canvas-hint-text-color").value = PAGE_STATE.canvasHintColor || "#94a3b8";
       document.getElementById("canvas-hint-text").value = PAGE_STATE.canvasHintText || "";
       document.getElementById("accent-color").value = PAGE_STATE.accent || "#4fd1c5";
       document.getElementById("danger-color").value = PAGE_STATE.danger || "#f56565";
       document.getElementById("text-main-color").value = PAGE_STATE.textMain || "#e2e8f0";
       document.getElementById("text-soft-color").value = PAGE_STATE.textSoft || "#94a3b8";
       document.getElementById("node-fill-color").value = PAGE_STATE.nodeFill || "#1e293b";
       document.getElementById("node-stroke-color").value = PAGE_STATE.nodeStroke || "#475569";
       document.getElementById("node-title-color").value = PAGE_STATE.nodeTitle || "#e2e8f0";
       document.getElementById("node-sub-color").value = PAGE_STATE.nodeSub || "#94a3b8";
       document.getElementById("node-title-size").value = PAGE_STATE.nodeTitleSize || 18;
       document.getElementById("node-sub-size").value = PAGE_STATE.nodeSubSize || 13;
       document.getElementById("node-font-family").value = PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
       document.getElementById("default-edge-color").value = PAGE_STATE.defaultEdge || "#475569";
       document.getElementById("selection-handle-color").value = PAGE_STATE.selectionHandle || "#f59e0b";
       document.getElementById("selection-handle-size").value = PAGE_STATE.selectionHandleSize || 8;
       document.getElementById("group-indicator-color").value = PAGE_STATE.groupIndicator || "#4fd1c5";
       document.getElementById("canvas-gradient-top").value = PAGE_STATE.canvasGradientTop || "#1e2532";
       document.getElementById("canvas-gradient-bottom").value = PAGE_STATE.canvasGradientBottom || "#050608";
       document.getElementById("canvas-border-color").value = PAGE_STATE.canvasBorder || "#475569";
       document.getElementById("canvas-grid-color").value = PAGE_STATE.canvasGrid || "#475569";
       document.getElementById("canvas-grid-size").value = PAGE_STATE.canvasGridSize || 50;
       document.getElementById("rack-frame-fill").value = PAGE_STATE.rackFrameFill || "#0f172a";
       document.getElementById("rack-frame-stroke").value = PAGE_STATE.rackFrameStroke || "#4fd1c5";
       document.getElementById("rack-line-color").value = PAGE_STATE.rackLineColor || "#475569";
       document.getElementById("rack-text-color").value = PAGE_STATE.rackTextColor || "#4fd1c5";
       settingsModal.classList.add("active");
      });
      settingsClose.addEventListener("click", () => {
       settingsModal.classList.remove("active");
      });
      settingsModal.addEventListener("click", (e) => {
       if (e.target === settingsModal) {
        settingsModal.classList.remove("active");
       }
      });
      document.getElementById("page-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.background = e.target.value;
       wieldThePower();
      });
      document.getElementById("topbar-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.topbarBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("topbar-border-color").addEventListener("input", (e) => {
       PAGE_STATE.topbarBorder = e.target.value;
       wieldThePower();
      });
      document.getElementById("panel-color").addEventListener("input", (e) => {
       PAGE_STATE.panel = e.target.value;
       wieldThePower();
      });
      document.getElementById("panel-alt-color").addEventListener("input", (e) => {
       PAGE_STATE.panelAlt = e.target.value;
       wieldThePower();
      });
      document.getElementById("sidebar-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.sidebarBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("btn-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.btnBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("btn-text-color").addEventListener("input", (e) => {
       PAGE_STATE.btnText = e.target.value;
       wieldThePower();
      });
      document.getElementById("tag-fill-color").addEventListener("input", (e) => {
       PAGE_STATE.tagFill = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("tag-text-color").addEventListener("input", (e) => {
       PAGE_STATE.tagText = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("tag-border-color").addEventListener("input", (e) => {
       PAGE_STATE.tagBorder = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("input-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.inputBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-text-color").addEventListener("input", (e) => {
       PAGE_STATE.inputText = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-border-color").addEventListener("input", (e) => {
       PAGE_STATE.inputBorder = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-font-family").addEventListener("change", (e) => {
       PAGE_STATE.inputFont = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-font-size").addEventListener("input", (e) => {
       PAGE_STATE.inputFontSize = parseInt(e.target.value) || 14;
       wieldThePower();
      });
      document.getElementById("toolbar-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-border-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBorder = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-text-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarText = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-btn-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBtnBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-btn-text-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBtnText = e.target.value;
       wieldThePower();
      });
      document.getElementById("minimap-dots-color").addEventListener("input", (e) => {
       PAGE_STATE.minimapDots = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("canvas-hint-enabled").addEventListener("change", (e) => {
       PAGE_STATE.canvasHintEnabled = e.target.checked;
       wieldThePower();
      });
      document.getElementById("canvas-hint-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-hint-text-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintColor = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-hint-text").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintText = e.target.value;
       wieldThePower();
      });
      document.getElementById("accent-color").addEventListener("input", (e) => {
       PAGE_STATE.accent = e.target.value;
       wieldThePower();
      });
      document.getElementById("danger-color").addEventListener("input", (e) => {
       PAGE_STATE.danger = e.target.value;
       wieldThePower();
      });
      document.getElementById("text-main-color").addEventListener("input", (e) => {
       PAGE_STATE.textMain = e.target.value;
       wieldThePower();
      });
      document.getElementById("text-soft-color").addEventListener("input", (e) => {
       PAGE_STATE.textSoft = e.target.value;
       wieldThePower();
      });
      document.getElementById("node-fill-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeFill = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-stroke-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeStroke = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-title-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeTitle = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-sub-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeSub = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-title-size").addEventListener("input", (e) => {
       PAGE_STATE.nodeTitleSize = parseInt(e.target.value) || 18;
       forgeTheTopology();
      });
      document.getElementById("node-sub-size").addEventListener("input", (e) => {
       PAGE_STATE.nodeSubSize = parseInt(e.target.value) || 13;
       forgeTheTopology();
      });
      document.getElementById("node-font-family").addEventListener("change", (e) => {
       PAGE_STATE.nodeFont = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("default-edge-color").addEventListener("input", (e) => {
       PAGE_STATE.defaultEdge = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("selection-handle-color").addEventListener("input", (e) => {
       PAGE_STATE.selectionHandle = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("selection-handle-size").addEventListener("input", (e) => {
       PAGE_STATE.selectionHandleSize = parseInt(e.target.value) || 8;
       forgeTheTopology();
      });
      document.getElementById("group-indicator-color").addEventListener("input", (e) => {
       PAGE_STATE.groupIndicator = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-gradient-top").addEventListener("input", (e) => {
       PAGE_STATE.canvasGradientTop = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-gradient-bottom").addEventListener("input", (e) => {
       PAGE_STATE.canvasGradientBottom = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-border-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasBorder = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-grid-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasGrid = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-grid-size").addEventListener("input", (e) => {
       PAGE_STATE.canvasGridSize = parseInt(e.target.value) || 50;
       forgeTheTopology();
      });
      document.getElementById("rack-frame-fill").addEventListener("input", (e) => {
       PAGE_STATE.rackFrameFill = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-frame-stroke").addEventListener("input", (e) => {
       PAGE_STATE.rackFrameStroke = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-line-color").addEventListener("input", (e) => {
       PAGE_STATE.rackLineColor = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-text-color").addEventListener("input", (e) => {
       PAGE_STATE.rackTextColor = e.target.value;
       forgeTheTopology();
      });
      
      (function initializeResizers() {
        const headerResizer = document.getElementById('header-resizer');
        const sidebarResizer = document.getElementById('sidebar-resizer');
        const mobileFooterResizer = document.getElementById('mobile-footer-resizer');
        
        let isResizing = false;
        let currentResizer = null;
        let startY = 0;
        let startX = 0;
        let startHeight = 0;
        let startWidth = 0;
        
        function getClientPos(e) {
          if (e.touches && e.touches.length > 0) {
            return { x: e.touches[0].clientX, y: e.touches[0].clientY };
          }
          return { x: e.clientX, y: e.clientY };
        }
        
        function startResize(resizer, type, e) {
          isResizing = true;
          currentResizer = type;
          const pos = getClientPos(e);
          
          if (type === 'header') {
            startY = pos.y;
            startHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--topbar-height'));
          } else if (type === 'sidebar') {
            startX = pos.x;
            startWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width'));
          } else if (type === 'mobile-footer') {
            startY = pos.y;
            const currentVh = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--mobile-footer-height'));
            startHeight = (currentVh / 100) * window.innerHeight;
          }
          
          resizer.classList.add('resizing');
          document.body.classList.add('resizing');
          document.body.style.cursor = (type === 'sidebar') ? 'col-resize' : 'row-resize';
          e.preventDefault();
        }
        
        if (headerResizer) {
          headerResizer.addEventListener('mousedown', (e) => startResize(headerResizer, 'header', e));
          headerResizer.addEventListener('touchstart', (e) => startResize(headerResizer, 'header', e), { passive: false });
        }
        
        if (sidebarResizer) {
          sidebarResizer.addEventListener('mousedown', (e) => startResize(sidebarResizer, 'sidebar', e));
          sidebarResizer.addEventListener('touchstart', (e) => startResize(sidebarResizer, 'sidebar', e), { passive: false });
        }
        
        if (mobileFooterResizer) {
          mobileFooterResizer.addEventListener('mousedown', (e) => startResize(mobileFooterResizer, 'mobile-footer', e));
          mobileFooterResizer.addEventListener('touchstart', (e) => startResize(mobileFooterResizer, 'mobile-footer', e), { passive: false });
        }
        
        function handleMove(e) {
          if (!isResizing) return;
          
          const pos = getClientPos(e);
          
          if (currentResizer === 'header') {
            const deltaY = pos.y - startY;
            const newHeight = Math.max(40, Math.min(150, startHeight + deltaY));
            document.documentElement.style.setProperty('--topbar-height', newHeight + 'px');
          } else if (currentResizer === 'sidebar') {
            const deltaX = startX - pos.x;
            const newWidth = Math.max(200, Math.min(800, startWidth + deltaX));
            document.documentElement.style.setProperty('--sidebar-width', newWidth + 'px');
          } else if (currentResizer === 'mobile-footer') {
            const deltaY = startY - pos.y;
            const newHeight = startHeight + deltaY;
            const newVh = Math.max(15, Math.min(80, (newHeight / window.innerHeight) * 100));
            document.documentElement.style.setProperty('--mobile-footer-height', newVh + 'vh');
          }
          
          e.preventDefault();
        }
        
        document.addEventListener('mousemove', handleMove);
        document.addEventListener('touchmove', handleMove, { passive: false });
        
        function handleEnd() {
          if (isResizing) {
            isResizing = false;
            
            if (currentResizer === 'header') {
              PAGE_STATE.topbarHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--topbar-height'));
              headerResizer.classList.remove('resizing');
            } else if (currentResizer === 'sidebar') {
              PAGE_STATE.sidebarWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width'));
              sidebarResizer.classList.remove('resizing');
            } else if (currentResizer === 'mobile-footer') {
              PAGE_STATE.mobileFooterHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--mobile-footer-height'));
              mobileFooterResizer.classList.remove('resizing');
            }
            
            document.body.classList.remove('resizing');
            document.body.style.cursor = '';
            currentResizer = null;
          }
        }
        
        document.addEventListener('mouseup', handleEnd);
        document.addEventListener('touchend', handleEnd);
        document.addEventListener('touchcancel', handleEnd);
      })();
      
      document.getElementById("export-data-btn").addEventListener("click", () => {
       const data = captureTheQuickening();
       const jsonStr = JSON.stringify(data, null, 2);
       const blob = new Blob([jsonStr], {
        type: "application/json"
       });
       const url = URL.createObjectURL(blob);
       const a = document.createElement("a");
       a.href = url;
       const safeTitle = (PAGE_STATE.title || "network-topology").toLowerCase().replace(/[^a-z0-9\-]+/g, "-");
       const timestamp = new Date().toISOString().split("T")[0];
       a.download = `${safeTitle}-data-${timestamp}.json`;
       document.body.appendChild(a);
       a.click();
       document.body.removeChild(a);
       URL.revokeObjectURL(url);
      });
      document.getElementById("import-data-btn").addEventListener("click", () => {
       document.getElementById("import-data-file").click();
      });
      document.getElementById("import-data-file").addEventListener("change", async (e) => {
       const file = e.target.files[0];
       if (!file) return;
       try {
        const text = await file.text();
        const data = JSON.parse(text);
        if (!data.nodeData || !data.edgeData) {
         alert("Invalid data file. Missing required fields.");
         return;
        }
        const confirmMsg = `This will replace all current data with the imported data.\n\nImporting:\n- ${Object.keys(data.nodeData).length} nodes\n- ${data.edgeData.list?.length || 0} connections\n- ${data.documentTabs?.length || 1} tab(s)\n\nContinue?`;
        if (!confirm(confirmMsg)) {
         e.target.value = "";
         return;
        }
        NODE_DATA = data.nodeData || {};
        EDGE_DATA = data.edgeData || {
         list: []
        };
        EDGE_LEGEND = data.edgeLegend || {};
        RECT_DATA = data.rectData || { list: [] };
        TEXT_DATA = data.textData || { list: [] };
        savedPositions = data.nodePositions || {};
        savedSizes = data.nodeSizes || {};
        savedStyles = data.nodeStyles || {};
        if (data.page) {
         PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, data.page, );
         wieldThePower();
        }
        if (data.canvas) {
         canvasState.zoom = data.canvas.zoom || 1;
         canvasState.panX = data.canvas.panX || 0;
         canvasState.panY = data.canvas.panY || 0;
        }
        if (data.page?.title) {
         document.title = data.page.title;
         document.querySelector(".editable-page-title", ).textContent = data.page.title;
        }
        if (data.documentTabs) {
         documentTabs = data.documentTabs;
         currentTabIndex = data.currentTabIndex || 0;
        }
        if (data.savedTopologyView) {
         savedTopologyView = data.savedTopologyView;
        }
        if (data.encryptedSections) {
         encryptedSections = data.encryptedSections;
        }
        forgeTheTopology();
        forgeTheLegend();
        updateViewBox();
        const nodeIds = Object.keys(NODE_DATA);
        if (nodeIds.length > 0) {
         claimTheImmortal(nodeIds[0]);
        } else {
         document.getElementById("node-panel").style.display = "none";
         document.getElementById("edge-panel").style.display = "none";
         document.getElementById("topology-toolbar").style.display = "none";
        }
        e.target.value = "";
       } catch (err) {
        console.error("Import error:", err);
        alert(`Failed to import data: ${err.message}`);
        e.target.value = "";
       }
      });
      const saveHelpBtn = document.getElementById("save-help-btn");
      const saveInfoModal = document.getElementById("save-info-modal");
      const saveInfoClose = document.getElementById("save-info-close");
      saveHelpBtn.addEventListener("click", () => {
       saveInfoModal.classList.add("active");
      });
      saveInfoClose.addEventListener("click", () => {
       saveInfoModal.classList.remove("active");
      });
      saveInfoModal.addEventListener("click", (e) => {
       if (e.target === saveInfoModal) {
        saveInfoModal.classList.remove("active");
       }
      });
      document.querySelectorAll(".help-tab").forEach(tab => {
        tab.addEventListener("click", () => {
          document.querySelectorAll(".help-tab").forEach(t => { t.style.background = "var(--panel)"; t.style.color = "var(--text-main)"; });
          tab.style.background = "var(--accent)"; tab.style.color = "var(--bg)";
          document.querySelectorAll(".help-tab-content").forEach(c => c.style.display = "none");
          document.getElementById("help-tab-" + tab.dataset.tab).style.display = "block";
        });
      });
      async function deriveKey(password, salt) {
      const encoder = new TextEncoder();
      
      const keyMaterial = await crypto.subtle.importKey(
      "raw",
      encoder.encode(password),
      "PBKDF2",
      false,
      ["deriveKey"]
      );
      
      return crypto.subtle.deriveKey(
      {
      name: "PBKDF2",
      salt: salt,
      iterations: 200000,
      hash: "SHA-256"
      },
      keyMaterial,
      {
      name: "AES-GCM",
      length: 256
      },
      false,
      ["encrypt", "decrypt"]
      );
      }
      
      async function encryptData(data, password) {
      const encoder = new TextEncoder();
      const salt = crypto.getRandomValues(new Uint8Array(16));
      const iv   = crypto.getRandomValues(new Uint8Array(12));
      
      const key = await deriveKey(password, salt);
      const encrypted = await crypto.subtle.encrypt(
      { name: "AES-GCM", iv },
      key,
      encoder.encode(data)
      );
      
      const encryptedU8 = new Uint8Array(encrypted);
      
      const result = new Uint8Array(salt.length + iv.length + encryptedU8.length);
      result.set(salt, 0);
      result.set(iv, salt.length);
      result.set(encryptedU8, salt.length + iv.length);
      
      return "ENCRYPTED:" + u8ToBase64(result);
      }
      
      async function decryptData(encryptedData, password) {
      const base64Data = encryptedData.replace("ENCRYPTED:", "");
      const fullData   = base64ToU8(base64Data);
      
      const salt      = fullData.slice(0, 16);
      const iv        = fullData.slice(16, 28);
      const encrypted = fullData.slice(28);
      
      const key = await deriveKey(password, salt);
      
      const decrypted = await crypto.subtle.decrypt(
      { name: "AES-GCM", iv },
      key,
      encrypted
      );
      
      const decoder = new TextDecoder();
      return decoder.decode(decrypted);
      }
      
      
      function isEncrypted(data) {
       return typeof data === "string" && data.startsWith("ENCRYPTED:");
      }
      
      function captureTheQuickening() {
       const currentTab = documentTabs[currentTabIndex];
       currentTab.nodes = JSON.parse(JSON.stringify(NODE_DATA));
       currentTab.edges = JSON.parse(JSON.stringify(EDGE_DATA));
       currentTab.positions = JSON.parse(JSON.stringify(savedPositions));
       currentTab.sizes = JSON.parse(JSON.stringify(savedSizes));
       currentTab.styles = JSON.parse(JSON.stringify(savedStyles));
       currentTab.legend = JSON.parse(JSON.stringify(EDGE_LEGEND));
       currentTab.rects = JSON.parse(JSON.stringify(RECT_DATA));
       currentTab.texts = JSON.parse(JSON.stringify(TEXT_DATA));
       currentTab.pageState = JSON.parse(JSON.stringify(PAGE_STATE));
       
       return {
        nodeData: NODE_DATA,
        edgeData: EDGE_DATA,
        rectData: RECT_DATA,
        textData: TEXT_DATA,
        edgeLegend: EDGE_LEGEND,
        nodePositions: savedPositions,
        nodeSizes: savedSizes,
        nodeStyles: savedStyles,
        page: PAGE_STATE,
        canvas: {
         zoom: canvasState.zoom,
         panX: canvasState.panX,
         panY: canvasState.panY,
        },
        savedTopologyView: savedTopologyView,
        documentTabs: documentTabs,
        currentTabIndex: currentTabIndex,
        encryptedSections: encryptedSections,
       };
      }
      
      function assembleTheImmortalForm() {
      const canvasHintEl = document.getElementById("canvas-hint");
       const savedHintHTML = canvasHintEl ? canvasHintEl.innerHTML : "";
       if (canvasHintEl) canvasHintEl.innerHTML = DEFAULT_CANVAS_HINT;
       const clone = document.documentElement.cloneNode(true);
       const nodeScript = clone.querySelector("#nodes-json");
       if (nodeScript) {
        nodeScript.textContent = JSON.stringify(NODE_DATA, null, 2);
       }
       let stateScript = clone.querySelector("#topology-state");
       if (!stateScript) {
        stateScript = document.createElement("script");
        stateScript.id = "topology-state";
        stateScript.type = "application/json";
        const body = clone.querySelector("body") || clone;
        body.appendChild(stateScript);
       }
       stateScript.textContent = JSON.stringify(captureTheQuickening(), null, 2, );
       return "<!DOCTYPE html> \n " + clone.outerHTML;
      }
      async function becomeImmortal() {
       saveRollbackVersion("Auto-save");
       
       const encryptEnabled = document.getElementById("encrypt-toggle").checked;
       let stateData = JSON.stringify(captureTheQuickening(), null, 2);
       if (encryptEnabled) {
        const password = prompt("Enter a password to encrypt your data:\n(Remember this password! You will need it to open this file and its non recoverable!)", );
        if (!password) {
         alert("Encryption cancelled. File not saved.");
         return;
        }
        const confirmPassword = prompt("Confirm your password:");
        if (password !== confirmPassword) {
         alert("Passwords do not match. File not saved.");
         return;
        }
        try {
         stateData = await encryptData(stateData, password);
        } catch (e) {
         alert("Encryption failed: " + e.message);
         return;
        }
       }
       const canvasHintEl = document.getElementById("canvas-hint");
       const savedHintHTML = canvasHintEl ? canvasHintEl.innerHTML : "";
       if (canvasHintEl) canvasHintEl.innerHTML = DEFAULT_CANVAS_HINT;
       
       const clone = document.documentElement.cloneNode(true);
       const nodeScript = clone.querySelector("#nodes-json");
       if (nodeScript) {
        if (encryptEnabled) {
         nodeScript.textContent = JSON.stringify({}, null, 2);
        } else {
         nodeScript.textContent = JSON.stringify(NODE_DATA, null, 2);
        }
       }
       let stateScript = clone.querySelector("#topology-state");
       if (!stateScript) {
        stateScript = document.createElement("script");
        stateScript.id = "topology-state";
        stateScript.type = "application/json";
        const body = clone.querySelector("body") || clone;
        body.appendChild(stateScript);
       }
       stateScript.textContent = stateData;
       const html = "<!DOCTYPE html> \n " + clone.outerHTML;
       const blob = new Blob([html], {
        type: "text/html"
       });
       const url = URL.createObjectURL(blob);
       const a = document.createElement("a");
       a.href = url;
       const safeTitle = (PAGE_STATE.title || document.title || "network-topology").toLowerCase().replace(/[^a-z0-9\-]+/g, "-");
       a.download = safeTitle + ".html";
       document.body.appendChild(a);
       a.click();
       document.body.removeChild(a);
       URL.revokeObjectURL(url);
       if (canvasHintEl) canvasHintEl.innerHTML = savedHintHTML;
       logAuditEvent("save", `File saved: ${safeTitle}.html`);
      }
      
      function captureState() {
      return {
       nodes: JSON.parse(JSON.stringify(NODE_DATA)),
       edges: JSON.parse(JSON.stringify(EDGE_DATA)),
       positions: JSON.parse(JSON.stringify(savedPositions)),
       sizes: JSON.parse(JSON.stringify(savedSizes)),
       styles: JSON.parse(JSON.stringify(savedStyles)),
       legend: JSON.parse(JSON.stringify(EDGE_LEGEND)),
       rects: JSON.parse(JSON.stringify(RECT_DATA)),
       texts: JSON.parse(JSON.stringify(TEXT_DATA))
       };
      }
      
      function pushUndo(action = "") {
       const state = captureState();
       undoStack.push(state);
       if (undoStack.length > MAX_UNDO_STACK) {
        undoStack.shift();
       }
       redoStack = [];
       updateUndoButtons();
       
       if (action) {
        const actionTypeMap = {
          "create node": "node",
          "delete node": "node",
          "edit": "node",
          "create rack": "rack",
          "add connection": "connection",
          "delete connection": "connection",
          "style change": "style",
          "change layer": "layer",
          "change assigned rack": "rack",
        };
        
        const type = actionTypeMap[action] || "node";
        logAuditEvent(type, action);
       }
      }
      
      function undo() {
       if (undoStack.length === 0) return;
       const currentState = captureState();
       redoStack.push(currentState);
       const previousState = undoStack.pop();
       restoreState(previousState);
       updateUndoButtons();
      }
      
      function redo() {
       if (redoStack.length === 0) return;
       const currentState = captureState();
       undoStack.push(currentState);
       const nextState = redoStack.pop();
       restoreState(nextState);
       updateUndoButtons();
      }
      
      function restoreState(state) {
      NODE_DATA = state.nodes;
      EDGE_DATA = state.edges;
      savedPositions = state.positions;
      savedSizes = state.sizes;
      savedStyles = state.styles;
      EDGE_LEGEND = state.legend;
      RECT_DATA = state.rects || { list: [] };
      TEXT_DATA = state.texts || { list: [] };
      forgeTheTopology();
      if (currentNodeId && NODE_DATA[currentNodeId]) {
       claimTheImmortal(currentNodeId);
      } else if (currentEdgeId) {
       selectTheConnection(currentEdgeId);
       }
      }
      
      function updateUndoButtons() {
       const undoBtn = document.getElementById("undo-btn");
       const redoBtn = document.getElementById("redo-btn");
       if (undoBtn) {
        undoBtn.disabled = undoStack.length === 0;
        undoBtn.style.opacity = undoStack.length === 0 ? "0.5" : "1";
       }
       if (redoBtn) {
        redoBtn.disabled = redoStack.length === 0;
        redoBtn.style.opacity = redoStack.length === 0 ? "0.5" : "1";
       }
      }
      
      function editNodeMac(id) {
       const currentMac = NODE_DATA[id].mac || "";
       showEditModal("Edit MAC Address", currentMac, (newMac) => {
        pushUndo("edit mac");
        NODE_DATA[id].mac = newMac;
        if (currentNodeId === id) {
         document.getElementById("node-mac").textContent = newMac || "--";
        }
       });
      }
      
      function editNodeRack(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       
       document.getElementById("modal-title").textContent = "Edit Rack Unit";
       document.getElementById("modal-input").value = node.rackUnit || "";
       document.getElementById("edit-modal").style.display = "flex";
       document.getElementById("modal-input").focus();
       
       const saveHandler = () => {
        pushUndo("edit rack");
        const value = document.getElementById("modal-input").value.trim();
        node.rackUnit = value;
        document.getElementById("edit-modal").style.display = "none";
        claimTheImmortal(id);
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       
       const cancelHandler = () => {
        document.getElementById("edit-modal").style.display = "none";
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       
       document.getElementById("edit-modal").addEventListener("click", function bgHandler(e) {
        if (e.target === document.getElementById("edit-modal")) {
         cancelHandler();
         document.getElementById("edit-modal").removeEventListener("click", bgHandler);
        }
       });
      }
      
      function editNodeUHeight(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       
       document.getElementById("modal-title").textContent = "Edit U Height";
       document.getElementById("modal-input").value = node.uHeight || "1";
       document.getElementById("edit-modal").style.display = "flex";
       document.getElementById("modal-input").focus();
       
       const saveHandler = () => {
        pushUndo("edit U height");
        const value = document.getElementById("modal-input").value.trim();
        node.uHeight = value;
        document.getElementById("edit-modal").style.display = "none";
        claimTheImmortal(id);
        forgeTheTopology();
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       
       const cancelHandler = () => {
        document.getElementById("edit-modal").style.display = "none";
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       
       document.getElementById("edit-modal").addEventListener("click", function bgHandler(e) {
        if (e.target === document.getElementById("edit-modal")) {
         cancelHandler();
         document.getElementById("edit-modal").removeEventListener("click", bgHandler);
        }
       });
      }
      
      function updateEdgePortLabels(edgeId) {
       const edge = EDGE_DATA.list.find(e => e.id === edgeId);
       if (!edge || edge.type === "custom") return;
       
       const fromPortInput = document.getElementById("edge-from-port");
       const toPortInput = document.getElementById("edge-to-port");
       
       if (fromPortInput && toPortInput) {
        edge.fromPort = fromPortInput.value || "";
        edge.toPort = toPortInput.value || "";
        saveEdgeData();
        forgeTheTopology();
       }
      }
      
      function selectNode(nodeId, addToSelection = false) {
       if (!addToSelection) {
        clearSelection();
       }
       selectedNodes.add(nodeId);
       updateNodeSelection();
      }
      
      function clearSelection() {
       selectedNodes.clear();
       selectedEdges.clear();
       selectedRects.clear();
       selectedTexts.clear();
       updateAllSelections();
      }
      
      function updateAllSelections() {
      updateNodeSelection();
      
      document.querySelectorAll(".edge").forEach(el => {
      const edgeId = el.dataset.edgeId;
      if (selectedEdges.has(edgeId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      
      document.querySelectorAll(".rect-group").forEach(el => {
      const rectId = el.dataset.rectId;
      if (selectedRects.has(rectId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      
      document.querySelectorAll(".text-group").forEach(el => {
      const textId = el.dataset.textId;
      if (selectedTexts.has(textId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      
      const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
      const bulkToolbar = document.getElementById("bulk-toolbar");
      const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
      const bulkCount = document.getElementById("bulk-count");
      const bulkCountMobile = document.getElementById("bulk-count-mobile");
      
      if (total > 0) {
      if (bulkToolbar) bulkToolbar.style.display = "flex";
      if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
      if (bulkCount) bulkCount.textContent = total;
      if (bulkCountMobile) bulkCountMobile.textContent = total;
      } else {
      if (bulkToolbar) bulkToolbar.style.display = "none";
      if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
      }
      }
      
      function updateNodeSelection() {
       document.querySelectorAll(".node-group").forEach(node => {
        const nodeId = node.dataset.nodeId;
        if (selectedNodes.has(nodeId)) {
         node.classList.add("selected");
        } else {
         node.classList.remove("selected");
        }
       });
       
       const bulkToolbar = document.getElementById("bulk-toolbar");
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       const bulkCount = document.getElementById("bulk-count");
       const bulkCountMobile = document.getElementById("bulk-count-mobile");
       const bulkCountModal = document.getElementById("bulk-count-modal");
       
       if (selectedNodes.size > 0) {
        if (bulkToolbar) bulkToolbar.style.display = "flex";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
        if (bulkCount) bulkCount.textContent = selectedNodes.size;
        if (bulkCountMobile) bulkCountMobile.textContent = selectedNodes.size;
        if (bulkCountModal) bulkCountModal.textContent = selectedNodes.size;
       } else {
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        const modal = document.getElementById("bulk-actions-modal");
        if (modal) modal.style.display = "none";
       }
      }
      
      function deleteSelected() {
       const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
       if (total === 0) return;
       const message = `Delete ${total} selected item(s)?`;
       challengeTheImmortal(message, () => {
        pushUndo("delete selected");
        selectedNodes.forEach(nodeId => {
         delete NODE_DATA[nodeId];
         delete savedPositions[nodeId];
         delete savedSizes[nodeId];
         delete savedStyles[nodeId];
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== nodeId && e.to !== nodeId);
        });
        selectedEdges.forEach(edgeId => {
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.id !== edgeId);
        });
        selectedRects.forEach(rectId => {
         RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== rectId);
        });
        selectedTexts.forEach(textId => {
         TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== textId);
        });
        clearSelection();
        saveEdgeData();
        forgeTheTopology();
       });
      }
      
      function startSelection(event) {
       if (event.button !== 0) return;
       if (event.target.closest(".node-group")) return;
       
       isSelecting = true;
       const svg = document.getElementById("map");
       const pt = svg.createSVGPoint();
       pt.x = event.clientX;
       pt.y = event.clientY;
       const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
       selectionStart = { x: svgP.x, y: svgP.y };
       
       if (!event.shiftKey) {
        clearSelection();
       }
       
       if (!selectionRect) {
        selectionRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        selectionRect.setAttribute("fill", "rgba(79, 209, 197, 0.1)");
        selectionRect.setAttribute("stroke", "#4fd1c5");
        selectionRect.setAttribute("stroke-width", "2");
        selectionRect.setAttribute("stroke-dasharray", "5,5");
        svg.appendChild(selectionRect);
       }
       selectionRect.style.display = "block";
      }
      
      function updateSelection(event) {
       if (!isSelecting || !selectionStart) return;
       
       const svg = document.getElementById("map");
       const pt = svg.createSVGPoint();
       pt.x = event.clientX;
       pt.y = event.clientY;
       const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
       
       const x = Math.min(selectionStart.x, svgP.x);
       const y = Math.min(selectionStart.y, svgP.y);
       const width = Math.abs(svgP.x - selectionStart.x);
       const height = Math.abs(svgP.y - selectionStart.y);
       
       selectionRect.setAttribute("x", x);
       selectionRect.setAttribute("y", y);
       selectionRect.setAttribute("width", width);
       selectionRect.setAttribute("height", height);
       
       Object.entries(savedPositions).forEach(([nodeId, pos]) => {
        if (pos.x >= x && pos.x <= x + width && pos.y >= y && pos.y <= y + height) {
         selectedNodes.add(nodeId);
        } else if (!event.shiftKey) {
         selectedNodes.delete(nodeId);
        }
       });
       updateNodeSelection();
      }
      
      function endSelection() {
       isSelecting = false;
       if (selectionRect) {
        selectionRect.style.display = "none";
       }
      }
      
      function cloneNode(sourceId) {
       if (!NODE_DATA[sourceId]) return;
       
       pushUndo("clone node");
       const source = NODE_DATA[sourceId];
       const baseName = source.name + " copy";
       let newName = baseName;
       let counter = 1;
       while (Object.values(NODE_DATA).some(n => n.name === newName)) {
        newName = `${baseName} ${counter}`;
        counter++;
       }
       
       const baseId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
       let newId = baseId;
       counter = 1;
       while (NODE_DATA[newId]) {
        newId = `${baseId}-${counter}`;
        counter++;
       }
       
       NODE_DATA[newId] = {
        shape: source.shape,
        name: newName,
        ip: source.ip,
        role: source.role,
        tags: [...source.tags],
        notes: [...source.notes],
        mac: source.mac || "",
        rackUnit: source.rackUnit || "",
        uHeight: source.uHeight || "1",
        layer: source.layer || "physical",
        assignedRack: source.assignedRack || "",
        rackCapacity: source.rackCapacity || "42",
        isRack: source.isRack || false
       };
       
       if (currentView.mode === "rack" && currentView.rackId) {
        NODE_DATA[newId].assignedRack = currentView.rackId;
       }
       
       const sourcePos = savedPositions[sourceId];
       savedPositions[newId] = {
        x: sourcePos.x + 100,
        y: sourcePos.y + 100
       };
       
       if (savedSizes[sourceId]) {
        savedSizes[newId] = savedSizes[sourceId];
       }
       
       if (savedStyles[sourceId]) {
        savedStyles[newId] = JSON.parse(JSON.stringify(savedStyles[sourceId]));
       }
       
       forgeTheTopology();
       claimTheImmortal(newId);
      }
      
      function alignSelectedNodes(direction) {
       if (selectedNodes.size < 2) return;
       
       pushUndo("align nodes");
       const nodes = Array.from(selectedNodes).map(id => ({
        id,
        pos: savedPositions[id]
       }));
       
       switch(direction) {
        case "left":
         const minX = Math.min(...nodes.map(n => n.pos.x));
         nodes.forEach(n => savedPositions[n.id].x = minX);
         break;
        case "right":
         const maxX = Math.max(...nodes.map(n => n.pos.x));
         nodes.forEach(n => savedPositions[n.id].x = maxX);
         break;
        case "top":
         const minY = Math.min(...nodes.map(n => n.pos.y));
         nodes.forEach(n => savedPositions[n.id].y = minY);
         break;
        case "bottom":
         const maxY = Math.max(...nodes.map(n => n.pos.y));
         nodes.forEach(n => savedPositions[n.id].y = maxY);
         break;
        case "center-h":
         const avgX = nodes.reduce((sum, n) => sum + n.pos.x, 0) / nodes.length;
         nodes.forEach(n => savedPositions[n.id].x = avgX);
         break;
        case "center-v":
         const avgY = nodes.reduce((sum, n) => sum + n.pos.y, 0) / nodes.length;
         nodes.forEach(n => savedPositions[n.id].y = avgY);
         break;
       }
       
       forgeTheTopology();
      }
      
      function distributeSelectedNodes(direction) {
       if (selectedNodes.size < 3) return;
       
       pushUndo("distribute nodes");
       const nodes = Array.from(selectedNodes).map(id => ({
        id,
        pos: savedPositions[id]
       }));
       
       if (direction === "horizontal") {
        nodes.sort((a, b) => a.pos.x - b.pos.x);
        const minX = nodes[0].pos.x;
        const maxX = nodes[nodes.length - 1].pos.x;
        const gap = (maxX - minX) / (nodes.length - 1);
        nodes.forEach((n, i) => {
         savedPositions[n.id].x = minX + (gap * i);
        });
       } else {
        nodes.sort((a, b) => a.pos.y - b.pos.y);
        const minY = nodes[0].pos.y;
        const maxY = nodes[nodes.length - 1].pos.y;
        const gap = (maxY - minY) / (nodes.length - 1);
        nodes.forEach((n, i) => {
         savedPositions[n.id].y = minY + (gap * i);
        });
       }
       
       forgeTheTopology();
      }
      
      function snapToGrid(nodeId, gridSize = 50) {
       if (!savedPositions[nodeId]) return;
       
       pushUndo("snap to grid");
       const pos = savedPositions[nodeId];
       pos.x = Math.round(pos.x / gridSize) * gridSize;
       pos.y = Math.round(pos.y / gridSize) * gridSize;
       forgeTheTopology();
      }
      
      function searchNodes(query) {
       if (!query) {
        clearSearchHighlight();
        return [];
       }
       
       query = query.toLowerCase();
       const results = [];
       
       Object.entries(NODE_DATA).forEach(([id, data]) => {
        if (data.name.toLowerCase().includes(query) ||
            data.ip.toLowerCase().includes(query) ||
            data.role.toLowerCase().includes(query) ||
            data.tags.some(tag => tag.toLowerCase().includes(query)) ||
            (data.mac && data.mac.toLowerCase().includes(query)) ||
            (data.rackUnit && data.rackUnit.toLowerCase().includes(query))) {
         results.push(id);
        }
       });
       
       highlightSearchResults(results);
       return results;
      }
      
      function highlightSearchResults(nodeIds) {
       document.querySelectorAll(".node-group").forEach(node => {
        const nodeId = node.dataset.nodeId;
        if (nodeIds.includes(nodeId)) {
         node.classList.add("search-highlight");
        } else {
         node.classList.remove("search-highlight");
        }
       });
      }
      
      function clearSearchHighlight() {
       document.querySelectorAll(".search-highlight").forEach(node => {
        node.classList.remove("search-highlight");
       });
      }
      
      function nudgeSelectedNodes(direction, distance) {
        const nodesToNudge = selectedNodes.size > 0 
          ? Array.from(selectedNodes) 
          : (currentNodeId ? [currentNodeId] : []);
        
        if (nodesToNudge.length === 0) return;
        
        const unlockedNodes = nodesToNudge.filter(id => !NODE_DATA[id]?.locked);
        
        if (unlockedNodes.length === 0) {
          return;
        }
        
        pushUndo("nudge nodes");
        
        unlockedNodes.forEach(id => {
          if (!savedPositions[id]) {
            savedPositions[id] = { x: 0, y: 0 };
          }
          
          switch(direction) {
            case "ArrowUp":
              savedPositions[id].y -= distance;
              break;
            case "ArrowDown":
              savedPositions[id].y += distance;
              break;
            case "ArrowLeft":
              savedPositions[id].x -= distance;
              break;
            case "ArrowRight":
              savedPositions[id].x += distance;
              break;
          }
        });
        
        forgeTheTopology();
      }
      
      function cycleNodes(reverse = false) {
        const nodeIds = Object.keys(NODE_DATA).filter(id => {
          if (currentView.mode === "rack" && currentView.rackId) {
            return NODE_DATA[id].assignedRack === currentView.rackId;
          }
          return !NODE_DATA[id].assignedRack;
        });
        
        if (nodeIds.length === 0) return;
        
        let currentIndex = nodeIds.indexOf(currentNodeId);
        
        if (reverse) {
          currentIndex = currentIndex <= 0 ? nodeIds.length - 1 : currentIndex - 1;
        } else {
          currentIndex = currentIndex >= nodeIds.length - 1 ? 0 : currentIndex + 1;
        }
        
        const nextNodeId = nodeIds[currentIndex];
        claimTheImmortal(nextNodeId);
        
        selectedNodes.clear();
        updateNodeSelection();
      }
      
      function focusOnSelected() {
        const nodesToFocus = selectedNodes.size > 0 
          ? Array.from(selectedNodes) 
          : (currentNodeId ? [currentNodeId] : []);
        
        if (nodesToFocus.length === 0) return;
        
        let minX = Infinity, minY = Infinity;
        let maxX = -Infinity, maxY = -Infinity;
        
        nodesToFocus.forEach(id => {
          const pos = savedPositions[id];
          if (pos) {
            const size = savedSizes[id] || 50;
            minX = Math.min(minX, pos.x - size/2);
            minY = Math.min(minY, pos.y - size/2);
            maxX = Math.max(maxX, pos.x + size/2);
            maxY = Math.max(maxY, pos.y + size/2);
          }
        });
        
        if (!isFinite(minX)) return;
        
        const padding = 100;
        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;
        const width = maxX - minX + padding * 2;
        const height = maxY - minY + padding * 2;
        
        const zoomX = CANVAS_WIDTH / width;
        const zoomY = CANVAS_HEIGHT / height;
        const targetZoom = Math.min(zoomX, zoomY, 2); 
        
        canvasState.zoom = targetZoom;
        canvasState.panX = centerX - (CANVAS_WIDTH / targetZoom) / 2;
        canvasState.panY = centerY - (CANVAS_HEIGHT / targetZoom) / 2;
        
        forgeTheTopology();
      }
      
      function toggleLockSelected() {
        const nodesToToggle = selectedNodes.size > 0 
          ? Array.from(selectedNodes) 
          : (currentNodeId ? [currentNodeId] : []);
        
        if (nodesToToggle.length === 0) return;
        
        pushUndo("toggle lock");
        
        const hasUnlocked = nodesToToggle.some(id => !NODE_DATA[id]?.locked);
        
        nodesToToggle.forEach(id => {
          if (NODE_DATA[id]) {
            NODE_DATA[id].locked = hasUnlocked;
          }
        });
        
        forgeTheTopology();
      
        const lockState = hasUnlocked ? "locked" : "unlocked";
      }
      
      function toggleGroupSelected() {
      const nodesToGroup = Array.from(selectedNodes);
      const rectsToGroup = Array.from(selectedRects);
      const textsToGroup = Array.from(selectedTexts);
      const edgesToGroup = Array.from(selectedEdges);
      const totalItems = nodesToGroup.length + rectsToGroup.length + textsToGroup.length + edgesToGroup.length;
      if (totalItems < 2) return;
      
      pushUndo("toggle group");
      
      const allGroupIds = [];
      nodesToGroup.forEach(id => { if (NODE_DATA[id]?.groupId) allGroupIds.push(NODE_DATA[id].groupId); });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r?.groupId) allGroupIds.push(r.groupId); });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t?.groupId) allGroupIds.push(t.groupId); });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e?.groupId) allGroupIds.push(e.groupId); });
      const uniqueGroups = [...new Set(allGroupIds)];
      
      if (uniqueGroups.length === 1 && allGroupIds.length === totalItems) {
      nodesToGroup.forEach(id => { if (NODE_DATA[id]) NODE_DATA[id].groupId = null; });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r) r.groupId = null; });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t) t.groupId = null; });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e) e.groupId = null; });
      } else {
      const newGroupId = "group-" + Date.now();
      nodesToGroup.forEach(id => { if (NODE_DATA[id]) NODE_DATA[id].groupId = newGroupId; });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r) r.groupId = newGroupId; });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t) t.groupId = newGroupId; });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e) e.groupId = newGroupId; });
      }
      
      forgeTheTopology();
      }
      
      function handleKeyDown(event) {
       if (event.target.tagName === "INPUT" || event.target.tagName === "TEXTAREA" || event.target.isContentEditable) {
        return;
       }
       
       if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(event.key)) {
        event.preventDefault();
        const distance = event.shiftKey ? 10 : 1;
        nudgeSelectedNodes(event.key, distance);
       }
       
       if (event.key === "Tab") {
        event.preventDefault();
        cycleNodes(event.shiftKey);
       }
       
       if (event.key === "f" || event.key === "F") {
        event.preventDefault();
        focusOnSelected();
       }
       
       if (event.key === "l" || event.key === "L") {
        event.preventDefault();
        toggleLockSelected();
       }
       
       if (event.key === "g" || event.key === "G") {
        event.preventDefault();
        toggleGroupSelected();
       }
       
       if (event.ctrlKey && event.key === "z") {
        event.preventDefault();
        undo();
       }
       
       if ((event.ctrlKey && event.key === "y") || (event.ctrlKey && event.shiftKey && event.key === "z")) {
        event.preventDefault();
        redo();
       }
       
       if (event.ctrlKey && event.key === "c") {
        event.preventDefault();
        if (currentNodeId && NODE_DATA[currentNodeId]) {
         clipboard = {
          type: "node",
          data: JSON.parse(JSON.stringify(NODE_DATA[currentNodeId])),
          size: savedSizes[currentNodeId],
          style: savedStyles[currentNodeId] ? JSON.parse(JSON.stringify(savedStyles[currentNodeId])) : null
         };
        }
       }
       
       if (event.ctrlKey && event.key === "v") {
        event.preventDefault();
        if (clipboard && clipboard.type === "node") {
         const data = clipboard.data;
         const baseName = data.name + " copy";
         let newName = baseName;
         let counter = 1;
         while (Object.values(NODE_DATA).some(n => n.name === newName)) {
          newName = `${baseName} ${counter}`;
          counter++;
         }
         
         const baseId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
         let newId = baseId;
         counter = 1;
         while (NODE_DATA[newId]) {
          newId = `${baseId}-${counter}`;
          counter++;
         }
         
         pushUndo("paste node");
         NODE_DATA[newId] = {
          ...data,
          name: newName
         };
         
      const viewWidth = CANVAS_WIDTH / canvasState.zoom;
      const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
      const centerX = canvasState.panX + (viewWidth / 2);
      const centerY = canvasState.panY + (viewHeight / 2);
      savedPositions[nodeId] = {
      x: centerX,
      y: centerY
      };
         
         if (clipboard.size) savedSizes[newId] = clipboard.size;
         if (clipboard.style) savedStyles[newId] = clipboard.style;
         
         forgeTheTopology();
         claimTheImmortal(newId);
        }
       }
       
       if (event.key === "Delete") {
        event.preventDefault();
        if (selectedNodes.size > 0) {
         deleteSelected();
        } else if (currentNodeId && NODE_DATA[currentNodeId]) {
         challengeTheImmortal(`Delete node "${NODE_DATA[currentNodeId].name}"?`, () => {
          pushUndo("delete node");
          delete NODE_DATA[currentNodeId];
          delete savedPositions[currentNodeId];
          delete savedSizes[currentNodeId];
          delete savedStyles[currentNodeId];
          EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== currentNodeId && e.to !== currentNodeId);
          currentNodeId = null;
          saveEdgeData();
          forgeTheTopology();
          document.getElementById("node-panel").style.display = "none";
         });
        } else if (currentEdgeId) {
         challengeTheImmortal("Delete this line?", () => {
          pushUndo("delete edge");
          EDGE_DATA.list = EDGE_DATA.list.filter(e => e.id !== currentEdgeId);
          currentEdgeId = null;
          saveEdgeData();
          forgeTheTopology();
          document.getElementById("edge-panel").style.display = "none";
         });
        }
       }
      
       if (event.ctrlKey && event.key === "a") {
        event.preventDefault();
        Object.keys(NODE_DATA).forEach(id => selectedNodes.add(id));
        updateNodeSelection();
       }
       
       if (event.key === "Escape") {
        clearSelection();
        clearSearchHighlight();
       }
      
       if (event.ctrlKey && event.key === "d") {
        event.preventDefault();
        if (currentNodeId && NODE_DATA[currentNodeId]) {
         cloneNode(currentNodeId);
        }
       }
      }
      
      function saveRollbackVersion(description = "Auto-save") {
        const version = {
          timestamp: Date.now(),
          description,
          data: captureTheQuickening()
        };
        
        try {
          const stored = localStorage.getItem(ROLLBACK_STORAGE_KEY);
          rollbackVersions = stored ? JSON.parse(stored) : [];
        } catch (e) {
          rollbackVersions = [];
        }
        
        rollbackVersions.unshift(version);
        
        if (rollbackVersions.length > MAX_ROLLBACK_VERSIONS) {
          rollbackVersions = rollbackVersions.slice(0, MAX_ROLLBACK_VERSIONS);
        }
        
        try {
          localStorage.setItem(ROLLBACK_STORAGE_KEY, JSON.stringify(rollbackVersions));
        } catch (e) {
          console.warn("Failed to save rollback version:", e);
        }
      }
      
      function loadRollbackVersions() {
        try {
          const stored = localStorage.getItem(ROLLBACK_STORAGE_KEY);
          rollbackVersions = stored ? JSON.parse(stored) : [];
          displayRollbackVersions();
        } catch (e) {
          console.warn("Failed to load rollback versions:", e);
          rollbackVersions = [];
        }
      }
      
      function displayRollbackVersions() {
        const listEl = document.getElementById("rollback-list");
        if (!listEl) return;
        
        if (rollbackVersions.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No version history yet. Versions are saved automatically when you save the file.</div>';
          return;
        }
        
        listEl.innerHTML = rollbackVersions.map((version, index) => {
          const date = new Date(version.timestamp);
          const timeStr = date.toLocaleString();
          const nodeCount = Object.keys(version.data.nodeData || {}).length;
          const edgeCount = (version.data.edgeData?.list || []).length;
          
          return `
            <div class="version-item" onclick="restoreRollbackVersion(${index})">
              <div class="version-info">
                <div class="timestamp">${timeStr}</div>
                <div class="details">${version.description} â€¢ ${nodeCount} nodes â€¢ ${edgeCount} connections</div>
              </div>
              <div class="version-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteRollbackVersion(${index})" title="Delete this version">ðŸ—‘ï¸</button>
              </div>
            </div>
          `;
        }).join('');
      }
      
      function restoreRollbackVersion(index) {
        if (!confirm(`Restore version from ${new Date(rollbackVersions[index].timestamp).toLocaleString()}?\n\nYour current work will be lost unless you save first.`)) {
          return;
        }
        
        const version = rollbackVersions[index];
        const data = version.data;
        
        NODE_DATA = data.nodeData || {};
        EDGE_DATA = data.edgeData || { list: [] };
        RECT_DATA = data.rectData || { list: [] };
        TEXT_DATA = data.textData || { list: [] };
        EDGE_LEGEND = data.edgeLegend || {};
        savedPositions = data.nodePositions || {};
        savedSizes = data.nodeSizes || {};
        savedStyles = data.nodeStyles || {};
        PAGE_STATE = data.page || PAGE_STATE;
        
        if (data.canvas) {
          canvasState.zoom = data.canvas.zoom;
          canvasState.panX = data.canvas.panX;
          canvasState.panY = data.canvas.panY;
        }
        
        wieldThePower();
        forgeTheTopology();
        
        document.getElementById("rollback-modal").classList.remove("active");
        
        logAuditEvent("rollback", `Restored version from ${new Date(version.timestamp).toLocaleString()}`);
      }
      
      function deleteRollbackVersion(index) {
        if (!confirm("Delete this version from history?")) return;
        
        rollbackVersions.splice(index, 1);
        try {
          localStorage.setItem(ROLLBACK_STORAGE_KEY, JSON.stringify(rollbackVersions));
        } catch (e) {
          console.warn("Failed to delete version:", e);
        }
        displayRollbackVersions();
      }
      
      function clearRollbackHistory() {
        if (!confirm("Clear all version history?\n\nThis cannot be undone.")) return;
        
        rollbackVersions = [];
        localStorage.removeItem(ROLLBACK_STORAGE_KEY);
        displayRollbackVersions();
      }
      
      function createManualSnapshot() {
        const description = prompt("Enter a description for this snapshot:", "Manual snapshot");
        if (!description) return;
        
        saveRollbackVersion(description);
        displayRollbackVersions();
      }
      
      function switchTab(index) {
        if (index === currentTabIndex) return;
        
        const currentTab = documentTabs[currentTabIndex];
        currentTab.nodes = JSON.parse(JSON.stringify(NODE_DATA));
        currentTab.edges = JSON.parse(JSON.stringify(EDGE_DATA));
        currentTab.positions = JSON.parse(JSON.stringify(savedPositions));
        currentTab.sizes = JSON.parse(JSON.stringify(savedSizes));
        currentTab.styles = JSON.parse(JSON.stringify(savedStyles));
        currentTab.legend = JSON.parse(JSON.stringify(EDGE_LEGEND));
        currentTab.rects = JSON.parse(JSON.stringify(RECT_DATA));
        currentTab.texts = JSON.parse(JSON.stringify(TEXT_DATA));
        currentTab.pageState = JSON.parse(JSON.stringify(PAGE_STATE));
      
        currentTabIndex = index;
        const newTab = documentTabs[index];
        NODE_DATA = JSON.parse(JSON.stringify(newTab.nodes));
        EDGE_DATA = JSON.parse(JSON.stringify(newTab.edges));
        savedPositions = JSON.parse(JSON.stringify(newTab.positions));
        savedSizes = JSON.parse(JSON.stringify(newTab.sizes));
        savedStyles = JSON.parse(JSON.stringify(newTab.styles));
        EDGE_LEGEND = JSON.parse(JSON.stringify(newTab.legend));
        RECT_DATA = JSON.parse(JSON.stringify(newTab.rects));
        TEXT_DATA = JSON.parse(JSON.stringify(newTab.texts));
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, newTab.pageState || {});
               wieldThePower();
        document.title = newTab.name;
      document.getElementById("page-title").textContent = newTab.name;
        forgeTheTopology();
        displayTabs();
        
        logAuditEvent("tab", `Switched to tab: ${newTab.name}`);
      }
      
      function createNewTab() {
        const nameInput = document.getElementById("new-tab-name");
        const name = nameInput.value.trim();
        
        if (!name) {
          alert("Please enter a tab name");
          return;
        }
        
        const newTab = {
          id: `tab-${Date.now()}`,
          name,
          nodes: {},
          edges: { list: [] },
          positions: {},
          sizes: {},
          styles: {},
          legend: {},
          rects: { list: [] },
          texts: { list: [] },
      pageState: null
        };
        
        documentTabs.push(newTab);
        nameInput.value = "";
        displayTabs();
        
        logAuditEvent("tab", `Created new tab: ${name}`);
      }
      
      function renameTab(index) {
        const tab = documentTabs[index];
        const newName = prompt("Enter new name:", tab.name);
        if (!newName || newName === tab.name) return;
        
        tab.name = newName;
        displayTabs();
        
        logAuditEvent("tab", `Renamed tab to: ${newName}`);
      }
      
      function deleteTab(index) {
        if (documentTabs.length === 1) {
          alert("Cannot delete the last tab");
          return;
        }
        
        if (!confirm(`Delete tab "${documentTabs[index].name}"?`)) return;
        
        documentTabs.splice(index, 1);
        
        if (currentTabIndex >= documentTabs.length) {
          currentTabIndex = documentTabs.length - 1;
        }
        
        if (currentTabIndex === index) {
          switchTab(currentTabIndex);
        }
        
        displayTabs();
      }
      
      function displayTabs() {
        const listEl = document.getElementById("tabs-list");
        if (!listEl) return;
        
        listEl.innerHTML = documentTabs.map((tab, index) => {
          const nodeCount = Object.keys(tab.nodes).length;
          const edgeCount = tab.edges.list.length;
          const isActive = index === currentTabIndex;
          
          return `
            <div class="tab-item ${isActive ? 'active' : ''}" onclick="switchTab(${index})">
              <div class="tab-name">${tab.name}</div>
              <div class="tab-stats">${nodeCount} nodes â€¢ ${edgeCount} connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(${index})" title="Rename tab">âœï¸</button>
                ${documentTabs.length > 1 ? '<button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(${index})" title="Delete tab">ðŸ—‘ï¸</button>' : ''}
              </div>
            </div>
          `;
        }).join('');
      }
      
      function logAuditEvent(type, description, details = {}) {
        const event = {
          timestamp: Date.now(),
          type,
          description,
          details,
          tab: documentTabs[currentTabIndex]?.name || "Main"
        };
        
        auditLog.unshift(event);
        
        if (auditLog.length > MAX_AUDIT_ENTRIES) {
          auditLog = auditLog.slice(0, MAX_AUDIT_ENTRIES);
        }
      
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to save audit log:", e);
        }
      }
      
      function loadAuditLog() {
        try {
          const stored = localStorage.getItem(AUDIT_STORAGE_KEY);
          auditLog = stored ? JSON.parse(stored) : [];
        } catch (e) {
          console.warn("Failed to load audit log:", e);
          auditLog = [];
        }
      }
      
      function displayAuditLog(filter = "all") {
        const listEl = document.getElementById("audit-log-list");
        if (!listEl) return;
        
        const filtered = filter === "all" ? auditLog : auditLog.filter(e => e.type === filter);
        
        if (filtered.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No audit entries yet</div>';
          return;
        }
        
        listEl.innerHTML = filtered.map(event => {
          const date = new Date(event.timestamp);
          const timeStr = date.toLocaleString();
          
          return `
            <div class="audit-entry ${event.type}">
              <div class="time">[${timeStr}] ${event.tab}</div>
              <div class="action">[${event.type.toUpperCase()}] ${event.description}</div>
            </div>
          `;
        }).join('');
      }
      
      function clearAuditLog() {
        if (!confirm("Clear all audit log entries?\n\nThis cannot be undone.")) return;
        
        auditLog = [];
        localStorage.removeItem(AUDIT_STORAGE_KEY);
        displayAuditLog();
      }
      
      function exportAuditLog() {
        if (auditLog.length === 0) {
          alert("No audit entries to export");
          return;
        }
        
        const csv = [
          ["Timestamp", "Tab", "Type", "Description"],
          ...auditLog.map(e => [
            new Date(e.timestamp).toISOString(),
            e.tab,
            e.type,
            e.description
          ])
        ].map(row => row.map(cell => `"${cell}"`).join(",")).join("\n");
        
        const blob = new Blob([csv], { type: "text/csv" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `audit-log-${Date.now()}.csv`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }
      
      let currentSecretName = null;
      
      function createNewSecret() {
        const nameInput = document.getElementById("new-secret-name");
        const name = nameInput.value.trim();
        
        if (!name) {
          alert("Please enter a note name");
          return;
        }
        
        if (encryptedSections[name]) {
          alert("A note with this name already exists");
          return;
        }
        
        currentSecretName = name;
        encryptedSections[name] = { encrypted: false, data: "" };
        nameInput.value = "";
        
        document.getElementById("secret-editor-title").textContent = `New note: ${name}`;
        document.getElementById("secret-editor-content").value = "";
        document.getElementById("secrets-modal").classList.remove("active");
        document.getElementById("secret-editor-modal").classList.add("active");
        
        displaySecrets();
      }
      
      function editSecret(name) {
        currentSecretName = name;
        const section = encryptedSections[name];
        
        if (section.encrypted) {
          const password = prompt(`Enter password to decrypt "${name}":`);
          if (!password) return;
          
          try {
            decryptData(section.data, password).then(decrypted => {
              document.getElementById("secret-editor-title").textContent = `Edit note: ${name}`;
              document.getElementById("secret-editor-content").value = decrypted;
              document.getElementById("secrets-modal").classList.remove("active");
              document.getElementById("secret-editor-modal").classList.add("active");
            }).catch(e => {
              alert("Failed to decrypt. Wrong password?");
            });
          } catch (e) {
            alert("Failed to decrypt. Wrong password?");
          }
        } else {
          document.getElementById("secret-editor-title").textContent = `Edit note: ${name}`;
          document.getElementById("secret-editor-content").value = section.data;
          document.getElementById("secrets-modal").classList.remove("active");
          document.getElementById("secret-editor-modal").classList.add("active");
        }
      }
      
      async function saveSecret() {
        if (!currentSecretName) return;
        
        const content = document.getElementById("secret-editor-content").value;
        const autoEncrypt = document.getElementById("secret-auto-encrypt").checked;
        
        if (autoEncrypt) {
          const password = prompt(`Enter password to encrypt "${currentSecretName}":`);
          if (!password) return;
          
          const confirmPassword = prompt("Confirm password:");
          if (password !== confirmPassword) {
            alert("Passwords do not match");
            return;
          }
          
          try {
            const encrypted = await encryptData(content, password);
            encryptedSections[currentSecretName] = { encrypted: true, data: encrypted };
          } catch (e) {
            alert("Encryption failed: " + e.message);
            return;
          }
        } else {
          encryptedSections[currentSecretName] = { encrypted: false, data: content };
        }
        
        closeSecretEditor();
        displaySecrets();
        
        logAuditEvent("secret", `Saved note: ${currentSecretName}`);
      }
      
      function closeSecretEditor() {
        document.getElementById("secret-editor-modal").classList.remove("active");
        document.getElementById("secrets-modal").classList.add("active");
        currentSecretName = null;
      }
      
      function deleteSecret(name) {
        if (!confirm(`Delete note "${name}"?`)) return;
        
        delete encryptedSections[name];
        displaySecrets();
        
        logAuditEvent("secret", `Deleted note: ${name}`);
      }
      
      function displaySecrets() {
        const listEl = document.getElementById("secrets-list");
        if (!listEl) return;
        
        const secrets = Object.keys(encryptedSections);
        
        if (secrets.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No notes yet</div>';
          return;
        }
        
        listEl.innerHTML = secrets.map(name => {
          const section = encryptedSections[name];
          const status = section.encrypted ? "ðŸ”’ Encrypted" : "ðŸ”“ Plaintext";
          
          return `
            <div class="secret-item">
              <div class="secret-name">${name}</div>
              <div class="secret-status">${status}</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="editSecret('${name}')" title="Edit note">âœï¸</button>
                <button class="btn-cancel" onclick="deleteSecret('${name}')" title="Delete note">ðŸ—‘ï¸</button>
              </div>
            </div>
          `;
        }).join('');
      }
      
      let rafId = null;
      let lastRender = 0;
      const RENDER_THROTTLE = 16;
      
      function optimizedForgeTheTopology() {
        if (rafId) return;
        
        rafId = requestAnimationFrame((timestamp) => {
          if (timestamp - lastRender < RENDER_THROTTLE) {
            rafId = requestAnimationFrame(optimizedForgeTheTopology);
            return;
          }
          
          lastRender = timestamp;
          rafId = null;
          
          if (cullOffscreenNodes && Object.keys(NODE_DATA).length > 100) {
            cullOffscreenElements();
          }
          
          forgeTheTopology();
          
          if (Date.now() - lastMinimapUpdate > 500) {
            updateMinimapOptimized();
            lastMinimapUpdate = Date.now();
          }
        });
      }
      
      function cullOffscreenElements() {
        const viewX = canvasState.panX;
        const viewY = canvasState.panY;
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        
        Object.keys(NODE_DATA).forEach(id => {
          const pos = savedPositions[id];
          if (!pos) return;
          
          const nodeEl = document.querySelector(`[data-node-id="${id}"]`);
          if (!nodeEl) return;
          
          const isVisible = (
            pos.x + 100 >= viewX &&
            pos.x - 100 <= viewX + viewWidth &&
            pos.y + 100 >= viewY &&
            pos.y - 100 <= viewY + viewHeight
          );
          
          nodeEl.style.display = isVisible ? "" : "none";
        });
      }
      
      function updateMinimapOptimized() {
        minimapNeedsUpdate = true;
      }
      
      function setupDragToCreate() {
        const addNodeBtn = document.getElementById("add-node-btn");
        const addRackBtn = document.getElementById("add-rack-btn");
        const canvas = document.getElementById("map");
        
        if (!addNodeBtn || !addRackBtn || !canvas) return;
        
        let dragType = null;
        
        [addNodeBtn, addRackBtn].forEach(btn => {
          btn.setAttribute("draggable", "true");
          
          btn.addEventListener("dragstart", e => {
            dragType = btn.id === "add-node-btn" ? "node" : "rack";
            e.dataTransfer.effectAllowed = "copy";
            e.dataTransfer.setData("text/plain", dragType);
          });
        });
        
        canvas.addEventListener("dragover", e => {
          if (dragType) {
            e.preventDefault();
            e.dataTransfer.dropEffect = "copy";
          }
        });
        
        canvas.addEventListener("drop", e => {
          if (!dragType) return;
          
          e.preventDefault();
          
          const rect = canvas.getBoundingClientRect();
          const x = (e.clientX - rect.left) / canvasState.zoom + canvasState.panX;
          const y = (e.clientY - rect.top) / canvasState.zoom + canvasState.panY;
          
          if (dragType === "node") {
            createNodeAtPosition(x, y);
          } else if (dragType === "rack") {
            createRackAtPosition(x, y);
          }
          
          dragType = null;
        });
      }
      
      function createNodeAtPosition(x, y) {
        const timestamp = Date.now();
        const newId = `host-${timestamp}`;
        
        NODE_DATA[newId] = {
          name: "New Node",
          ip: "0.0.0.0",
          shape: "server",
          role: "",
          tags: [],
          notes: "",
          layer: "physical",
          isRack: false
        };
        
        savedPositions[newId] = { x, y };
        savedSizes[newId] = 55;
        
        pushUndo("create node");
        forgeTheTopology();
        claimTheImmortal(newId);
        
        logAuditEvent("node", `Created node at (${Math.round(x)}, ${Math.round(y)})`);
      }
      
      function createRackAtPosition(x, y) {
        const timestamp = Date.now();
        const newId = `rack-${timestamp}`;
        
        NODE_DATA[newId] = {
          name: "New Rack",
          ip: "",
          shape: "server",
          role: "rack",
          tags: [],
          notes: "",
          layer: "physical",
          isRack: true,
          rackCapacity: 42
        };
        
        savedPositions[newId] = { x, y };
        savedSizes[newId] = 55;
        
        pushUndo("create rack");
        populateRackDropdown();
        forgeTheTopology();
        claimTheImmortal(newId);
        
        logAuditEvent("rack", `Created rack at (${Math.round(x)}, ${Math.round(y)})`);
      }
      
      document.addEventListener("keydown", handleKeyDown);
      
      document.getElementById("save-file-btn").addEventListener("click", becomeImmortal);
      const addNodeBtn = document.getElementById("add-node-btn");
      const addNodeModal = document.getElementById("add-node-modal");
      const addNodeCancel = document.getElementById("add-node-cancel");
      const addNodeSave = document.getElementById("add-node-save");
      
      const undoBtn = document.getElementById("undo-btn");
      const redoBtn = document.getElementById("redo-btn");
      if (undoBtn) undoBtn.addEventListener("click", undo);
      if (redoBtn) redoBtn.addEventListener("click", redo);
      
      const backToTopologyBtn = document.getElementById("back-to-topology-btn");
      if (backToTopologyBtn) {
       backToTopologyBtn.addEventListener("click", exitRack);
      }
      
      const canvasViewport = document.getElementById("canvas-viewport");
      if (canvasViewport) {
       canvasViewport.addEventListener("dblclick", (e) => {
        if (currentView.mode === "rack" && e.target.id === "map") {
         exitRack();
        }
       });
      }
      
      const layersBtn = document.getElementById("layers-btn");
      const layerModal = document.getElementById("layer-modal");
      const layerModalClose = document.getElementById("layer-modal-close");
      if (layersBtn && layerModal) {
       layersBtn.addEventListener("click", () => {
        layerModal.classList.add("active");
       });
      }
      if (layerModalClose && layerModal) {
       layerModalClose.addEventListener("click", () => {
        layerModal.classList.remove("active");
       });
      }
      if (layerModal) {
       layerModal.addEventListener("click", (e) => {
        if (e.target === layerModal) {
         layerModal.classList.remove("active");
        }
       });
      }
      
      ["physical", "logical", "security", "application"].forEach(layer => {
       const checkbox = document.getElementById(`layer-${layer}`);
       if (checkbox) {
        checkbox.addEventListener("change", applyLayerFilter);
       }
      });
            
      const tabsBtn = document.getElementById("tabs-btn");
      const tabsModal = document.getElementById("tabs-modal");
      const tabsModalClose = document.getElementById("tabs-modal-close");
      
      if (tabsBtn && tabsModal) {
        tabsBtn.addEventListener("click", () => {
          displayTabs();
          tabsModal.classList.add("active");
        });
      }
      
      if (tabsModalClose && tabsModal) {
        tabsModalClose.addEventListener("click", () => {
          tabsModal.classList.remove("active");
        });
      }
      
      if (tabsModal) {
        tabsModal.addEventListener("click", (e) => {
          if (e.target === tabsModal) {
            tabsModal.classList.remove("active");
          }
        });
      }
      
      const rollbackBtn = document.getElementById("rollback-btn");
      const rollbackModal = document.getElementById("rollback-modal");
      const rollbackModalClose = document.getElementById("rollback-modal-close");
      
      if (rollbackBtn && rollbackModal) {
        rollbackBtn.addEventListener("click", () => {
          loadRollbackVersions();
          rollbackModal.classList.add("active");
        });
      }
      
      if (rollbackModalClose && rollbackModal) {
        rollbackModalClose.addEventListener("click", () => {
          rollbackModal.classList.remove("active");
        });
      }
      
      if (rollbackModal) {
        rollbackModal.addEventListener("click", (e) => {
          if (e.target === rollbackModal) {
            rollbackModal.classList.remove("active");
          }
        });
      }
      
      const auditLogBtn = document.getElementById("audit-log-btn");
      const auditLogModal = document.getElementById("audit-log-modal");
      const auditLogModalClose = document.getElementById("audit-log-modal-close");
      const auditFilter = document.getElementById("audit-filter");
      
      if (auditLogBtn && auditLogModal) {
        auditLogBtn.addEventListener("click", () => {
          loadAuditLog();
          displayAuditLog();
          auditLogModal.classList.add("active");
        });
      }
      
      if (auditFilter) {
        auditFilter.addEventListener("change", (e) => {
          displayAuditLog(e.target.value);
        });
      }
      
      if (auditLogModalClose && auditLogModal) {
        auditLogModalClose.addEventListener("click", () => {
          auditLogModal.classList.remove("active");
        });
      }
      
      if (auditLogModal) {
        auditLogModal.addEventListener("click", (e) => {
          if (e.target === auditLogModal) {
            auditLogModal.classList.remove("active");
          }
        });
      }
      
      const secretsBtn = document.getElementById("secrets-btn");
      const secretsModal = document.getElementById("secrets-modal");
      const secretsModalClose = document.getElementById("secrets-modal-close");
      const secretEditorModal = document.getElementById("secret-editor-modal");
      
      if (secretsBtn && secretsModal) {
        secretsBtn.addEventListener("click", () => {
          displaySecrets();
          secretsModal.classList.add("active");
        });
      }
      
      if (secretsModalClose && secretsModal) {
        secretsModalClose.addEventListener("click", () => {
          secretsModal.classList.remove("active");
        });
      }
      
      if (secretsModal) {
        secretsModal.addEventListener("click", (e) => {
          if (e.target === secretsModal) {
            secretsModal.classList.remove("active");
          }
        });
      }
      
      if (secretEditorModal) {
        secretEditorModal.addEventListener("click", (e) => {
          if (e.target === secretEditorModal) {
            closeSecretEditor();
          }
        });
      }
      
      loadAuditLog();
      setupDragToCreate();
      
      ["physical", "logical", "security", "application"].forEach(layer => {
       const checkbox = document.getElementById(`layer-${layer}`);
       if (checkbox) {
        checkbox.addEventListener("change", applyLayerFilter);
       }
      });
      
      const layerSelect = document.getElementById("node-layer");
      if (layerSelect) {
       layerSelect.addEventListener("change", (e) => {
        if (currentNodeId) {
         pushUndo("change layer");
         NODE_DATA[currentNodeId].layer = e.target.value;
         forgeTheTopology();
        }
       });
      }
      
       const assignedRackSelect = document.getElementById("node-assigned-rack");
       if (assignedRackSelect) {
      assignedRackSelect.addEventListener("change", (e) => {
      if (currentNodeId) {
      pushUndo("change assigned rack");
      EDGE_DATA.list = EDGE_DATA.list.filter(edge => edge.from !== currentNodeId && edge.to !== currentNodeId);
      NODE_DATA[currentNodeId].assignedRack = e.target.value;
      forgeTheTopology();
      claimTheImmortal(currentNodeId);
      }
      });
       }
      
      const rackCapacitySelect = document.getElementById("node-rack-capacity");
      if (rackCapacitySelect) {
       rackCapacitySelect.addEventListener("change", (e) => {
        if (currentNodeId) {
         pushUndo("change rack capacity");
         NODE_DATA[currentNodeId].rackCapacity = e.target.value;
         forgeTheTopology();
        }
       });
      }
      
      const bulkToolbarClose = document.getElementById("bulk-toolbar-close");
      if (bulkToolbarClose) {
       bulkToolbarClose.addEventListener("click", clearSelection);
      }
      
      const bulkAlignLeft = document.getElementById("bulk-align-left");
      if (bulkAlignLeft) {
       bulkAlignLeft.addEventListener("click", () => alignSelectedNodes("left"));
      }
      
      const bulkAlignRight = document.getElementById("bulk-align-right");
      if (bulkAlignRight) {
       bulkAlignRight.addEventListener("click", () => alignSelectedNodes("right"));
      }
      
      const bulkAlignTop = document.getElementById("bulk-align-top");
      if (bulkAlignTop) {
       bulkAlignTop.addEventListener("click", () => alignSelectedNodes("top"));
      }
      
      const bulkAlignBottom = document.getElementById("bulk-align-bottom");
      if (bulkAlignBottom) {
       bulkAlignBottom.addEventListener("click", () => alignSelectedNodes("bottom"));
      }
      
      const bulkDistributeH = document.getElementById("bulk-distribute-h");
      if (bulkDistributeH) {
       bulkDistributeH.addEventListener("click", () => distributeSelectedNodes("horizontal"));
      }
      
      const bulkDistributeV = document.getElementById("bulk-distribute-v");
      if (bulkDistributeV) {
       bulkDistributeV.addEventListener("click", () => distributeSelectedNodes("vertical"));
      }
      
      const bulkClone = document.getElementById("bulk-clone");
      if (bulkClone) {
       bulkClone.addEventListener("click", () => {
        if (selectedNodes.size === 0) return;
        pushUndo("clone selected");
        const nodesToClone = Array.from(selectedNodes);
        selectedNodes.clear();
        nodesToClone.forEach(id => {
         cloneNode(id);
         selectedNodes.add(currentNodeId);
        });
        updateNodeSelection();
       });
      }
      
      const bulkDelete = document.getElementById("bulk-delete");
      if (bulkDelete) {
       bulkDelete.addEventListener("click", deleteSelected);
      }
      
      const bulkMobileBtn = document.getElementById("bulk-mobile-btn");
      const bulkActionsModal = document.getElementById("bulk-actions-modal");
      const bulkModalClose = document.getElementById("bulk-modal-close");
      
      if (bulkMobileBtn) {
       bulkMobileBtn.addEventListener("click", () => {
        if (bulkActionsModal) bulkActionsModal.style.display = "block";
       });
      }
      
      if (bulkModalClose) {
       bulkModalClose.addEventListener("click", () => {
        if (bulkActionsModal) bulkActionsModal.style.display = "none";
       });
      }
      
      const closeModalAfterAction = () => {
       if (bulkActionsModal) bulkActionsModal.style.display = "none";
      };
      
      const bulkAlignLeftMobile = document.getElementById("bulk-align-left-mobile");
      if (bulkAlignLeftMobile) {
       bulkAlignLeftMobile.addEventListener("click", () => {
        alignSelectedNodes("left");
        closeModalAfterAction();
       });
      }
      
      const bulkAlignRightMobile = document.getElementById("bulk-align-right-mobile");
      if (bulkAlignRightMobile) {
       bulkAlignRightMobile.addEventListener("click", () => {
        alignSelectedNodes("right");
        closeModalAfterAction();
       });
      }
      
      const bulkAlignTopMobile = document.getElementById("bulk-align-top-mobile");
      if (bulkAlignTopMobile) {
       bulkAlignTopMobile.addEventListener("click", () => {
        alignSelectedNodes("top");
        closeModalAfterAction();
       });
      }
      
      const bulkAlignBottomMobile = document.getElementById("bulk-align-bottom-mobile");
      if (bulkAlignBottomMobile) {
       bulkAlignBottomMobile.addEventListener("click", () => {
        alignSelectedNodes("bottom");
        closeModalAfterAction();
       });
      }
      
      const bulkDistributeHMobile = document.getElementById("bulk-distribute-h-mobile");
      if (bulkDistributeHMobile) {
       bulkDistributeHMobile.addEventListener("click", () => {
        distributeSelectedNodes("horizontal");
        closeModalAfterAction();
       });
      }
      
      const bulkDistributeVMobile = document.getElementById("bulk-distribute-v-mobile");
      if (bulkDistributeVMobile) {
       bulkDistributeVMobile.addEventListener("click", () => {
        distributeSelectedNodes("vertical");
        closeModalAfterAction();
       });
      }
      
      const bulkCloneMobile = document.getElementById("bulk-clone-mobile");
      if (bulkCloneMobile) {
       bulkCloneMobile.addEventListener("click", () => {
        if (selectedNodes.size === 0) return;
        pushUndo("clone selected");
        const nodesToClone = Array.from(selectedNodes);
        selectedNodes.clear();
        nodesToClone.forEach(id => {
         cloneNode(id);
         selectedNodes.add(currentNodeId);
        });
        updateNodeSelection();
        closeModalAfterAction();
       });
      }
      
      const bulkDeleteMobile = document.getElementById("bulk-delete-mobile");
      if (bulkDeleteMobile) {
       bulkDeleteMobile.addEventListener("click", () => {
        deleteSelected();
        closeModalAfterAction();
       });
      }
      
      const bulkLockMobile = document.getElementById("bulk-lock-mobile");
      if (bulkLockMobile) {
       bulkLockMobile.addEventListener("click", () => {
        toggleLockSelected();
        closeModalAfterAction();
       });
      }
      
      const bulkGroupMobile = document.getElementById("bulk-group-mobile");
      if (bulkGroupMobile) {
       bulkGroupMobile.addEventListener("click", () => {
        toggleGroupSelected();
        closeModalAfterAction();
       });
      }
      
      const bulkClearMobile = document.getElementById("bulk-clear-mobile");
      if (bulkClearMobile) {
       bulkClearMobile.addEventListener("click", () => {
        clearSelection();
        closeModalAfterAction();
       });
      }
      
      const searchInput = document.getElementById("search-nodes");
      if (searchInput) {
       searchInput.addEventListener("input", (e) => {
        searchNodes(e.target.value);
       });
      }
      
      addNodeBtn.addEventListener("click", () => {
       document.getElementById("new-node-name").value = "";
       document.getElementById("new-node-ip").value = "";
       document.getElementById("new-node-tags").value = "";
       document.getElementById("new-node-shape").value = "circle";
       addNodeModal.classList.add("active");
       document.getElementById("new-node-name").focus();
      });
      
      const addRackBtn = document.getElementById("add-rack-btn");
      const addRackModal = document.getElementById("add-rack-modal");
      const addRackCancel = document.getElementById("add-rack-cancel");
      const addRackSave = document.getElementById("add-rack-save");
      
      if (addRackBtn && addRackModal) {
       addRackBtn.addEventListener("click", () => {
        document.getElementById("new-rack-name").value = "";
        document.getElementById("new-rack-ip").value = "";
        document.getElementById("new-rack-tags").value = "";
        document.getElementById("new-rack-shape").value = "server";
        document.getElementById("new-rack-capacity").value = "42";
        addRackModal.classList.add("active");
        document.getElementById("new-rack-name").focus();
       });
      }
      
      if (addRackCancel && addRackModal) {
       addRackCancel.addEventListener("click", () => {
        addRackModal.classList.remove("active");
       });
      }
      
      if (addRackModal) {
       addRackModal.addEventListener("click", (e) => {
        if (e.target === addRackModal) {
         addRackModal.classList.remove("active");
        }
       });
      }
      
      if (addRackSave && addRackModal) {
       addRackSave.addEventListener("click", () => {
        const name = document.getElementById("new-rack-name").value.trim();
        const ip = document.getElementById("new-rack-ip").value.trim();
        const tagsStr = document.getElementById("new-rack-tags").value.trim();
        const shape = document.getElementById("new-rack-shape").value;
        const capacity = document.getElementById("new-rack-capacity").value;
        
        if (!name) {
         alert("Please enter a rack name.");
         return;
        }
        
        const tags = tagsStr ? tagsStr.split(",").map((t) => t.trim()).filter((t) => t) : [];
        let baseId = name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");
        if (!baseId) baseId = "rack";
        let nodeId = baseId;
        let counter = 1;
        while (NODE_DATA[nodeId]) {
         nodeId = baseId + "-" + counter;
         counter++;
        }
        
        pushUndo("add rack");
        
        NODE_DATA[nodeId] = {
         shape: shape,
         name: name,
         ip: ip || "",
         role: "Rack",
         tags: tags,
         notes: [],
         mac: "",
         rackUnit: "",
         uHeight: "1",
         layer: "physical",
         assignedRack: "",
         rackCapacity: capacity,
         isRack: true,  
         locked: false, 
         groupId: null 
        };
        
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        const centerX = canvasState.panX + (viewWidth / 2);
        const centerY = canvasState.panY + (viewHeight / 2);
        savedPositions[nodeId] = {
         x: centerX,
         y: centerY
        };
        
        addRackModal.classList.remove("active");
        forgeTheTopology();
        claimTheImmortal(nodeId);
       });
       
       ["new-rack-name", "new-rack-ip", "new-rack-tags"].forEach((inputId) => {
        const input = document.getElementById(inputId);
        if (input) {
         input.addEventListener("keypress", (e) => {
          if (e.key === "Enter") {
           addRackSave.click();
          }
         });
        }
       });
      }
      
      addNodeCancel.addEventListener("click", () => {
       addNodeModal.classList.remove("active");
      });
      addNodeModal.addEventListener("click", (e) => {
       if (e.target === addNodeModal) {
        addNodeModal.classList.remove("active");
       }
      });
      addNodeSave.addEventListener("click", () => {
       const name = document.getElementById("new-node-name").value.trim();
       const ip = document.getElementById("new-node-ip").value.trim();
       const tagsStr = document.getElementById("new-node-tags").value.trim();
       const shape = document.getElementById("new-node-shape").value;
       if (!name) {
        alert("Please enter a node name.");
        return;
       }
       const tags = tagsStr ? tagsStr.split(",").map((t) => t.trim()).filter((t) => t) : [];
       let baseId = name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");
       if (!baseId) baseId = "node";
       let nodeId = baseId;
       let counter = 1;
       while (NODE_DATA[nodeId]) {
        nodeId = baseId + "-" + counter;
        counter++;
       }
       NODE_DATA[nodeId] = {
        shape: shape || "circle",
        name: name,
        ip: ip || "0.0.0.0",
        role: "",
        tags: tags,
        notes: [],
        mac: "",
        rackUnit: "",
        uHeight: "1",
        layer: "physical",
        assignedRack: "",  
        rackCapacity: "42",
        isRack: false, 
        locked: false, 
        groupId: null 
       };
       
       if (currentView.mode === "rack" && currentView.rackId) {
        NODE_DATA[nodeId].assignedRack = currentView.rackId;
       }
       
      const viewWidth = CANVAS_WIDTH / canvasState.zoom;
      const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
      const centerX = canvasState.panX + (viewWidth / 2);
      const centerY = canvasState.panY + (viewHeight / 2);
      savedPositions[nodeId] = {
      x: centerX,
      y: centerY
      };
       pushUndo("add node");
       addNodeModal.classList.remove("active");
       forgeTheTopology();
       claimTheImmortal(nodeId);
      });
      ["new-node-name", "new-node-ip", "new-node-tags"].forEach(
       (inputId) => {
        document.getElementById(inputId).addEventListener("keypress", (e) => {
         if (e.key === "Enter") {
          addNodeSave.click();
         }
        });
       }, );
      const clearAllBtn = document.getElementById("clear-all-btn");
      const clearAllModal = document.getElementById("clear-all-modal");
      const clearAllCancel = document.getElementById("clear-all-cancel");
      const clearAllConfirm = document.getElementById("clear-all-confirm");
      clearAllBtn.addEventListener("click", () => {
       clearAllModal.classList.add("active");
      });
      clearAllCancel.addEventListener("click", () => {
       clearAllModal.classList.remove("active");
      });
      clearAllModal.addEventListener("click", (e) => {
       if (e.target === clearAllModal) {
        clearAllModal.classList.remove("active");
       }
      });
      clearAllConfirm.addEventListener("click", () => {
       NODE_DATA = {};
       EDGE_DATA = {
        list: []
       };
       EDGE_LEGEND = {};
       RECT_DATA = { list: [] };
       TEXT_DATA = { list: [] };
       savedPositions = {};
       savedSizes = {};
       savedStyles = {};
       clearAllModal.classList.remove("active");
       forgeTheTopology();
       document.getElementById("node-panel").style.display = "none";
       document.getElementById("edge-panel").style.display = "none";
       document.getElementById("text-panel").style.display = "none";
       document.getElementById("topology-toolbar").style.display = "none";
       currentNodeId = null;
       currentEdgeId = null;
       currentTextId = null;
      });
      (function addDeleteNodeButton() {
       const nodePanel = document.getElementById("node-panel");
       if (!nodePanel) return;
       if (document.getElementById("delete-node-btn")) return;
       const deleteBtn = document.createElement("button");
       deleteBtn.id = "delete-node-btn";
       deleteBtn.textContent = "Delete Node";
       deleteBtn.style.cssText = "margin-top:15px; padding:10px 16px; background:var(--danger); color:#fff; border:none; border-radius:6px; cursor:pointer; font-size:clamp(14px,1.6vw,18px); font-weight:600; width:100%;";
       deleteBtn.addEventListener("click", () => {
        if (!currentNodeId) return;
        challengeTheImmortal(`Delete node "${NODE_DATA[currentNodeId]?.name || currentNodeId}" and all its connections?`,
         () => {
          EDGE_DATA.list = EDGE_DATA.list.filter(
           (e) => e.from !== currentNodeId && e.to !== currentNodeId, );
          delete NODE_DATA[currentNodeId];
          delete savedPositions[currentNodeId];
          delete savedSizes[currentNodeId];
          delete savedStyles[currentNodeId];
          currentNodeId = null;
          currentEdgeId = null;
          forgeTheTopology();
          const remainingNodes = Object.keys(NODE_DATA);
          if (remainingNodes.length > 0) {
           claimTheImmortal(remainingNodes[0]);
          } else {
           document.getElementById("node-panel").style.display = "none";
           document.getElementById("edge-panel").style.display = "none";
           document.getElementById("topology-toolbar", ).style.display = "none";
          }
         }, );
       });
       nodePanel.appendChild(deleteBtn);
      })();
      
      function screenshotCanvas() {
       const svg = document.getElementById("map");
       const svgClone = svg.cloneNode(true);
       const viewBox = svg.getAttribute("viewBox").split(" ").map(Number);
       const [x, y, width, height] = viewBox;
       svgClone.setAttribute("width", width);
       svgClone.setAttribute("height", height);
       svgClone.setAttribute("viewBox", `${x} ${y} ${width} ${height}`);
       const wrapper = document.createElement("div");
       wrapper.style.position = "absolute";
       wrapper.style.left = "-9999px";
       wrapper.appendChild(svgClone);
       document.body.appendChild(wrapper);
      
       function inlineStyles(original, clone) {
        const elements = original.querySelectorAll("*");
        const clonedElements = clone.querySelectorAll("*");
        const rootStyles = getComputedStyle(document.documentElement);
        const bgColor = rootStyles.getPropertyValue("--bg").trim() || "#050608";
        const bgRect = document.createElementNS("http://www.w3.org/2000/svg", "rect", );
        bgRect.setAttribute("x", x);
        bgRect.setAttribute("y", y);
        bgRect.setAttribute("width", width);
        bgRect.setAttribute("height", height);
        bgRect.setAttribute("fill", bgColor);
        clone.insertBefore(bgRect, clone.firstChild);
        elements.forEach((el, index) => {
         const clonedEl = clonedElements[index];
         if (!clonedEl) return;
         const computedStyle = getComputedStyle(el);
         const svgProps = ["fill", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin", "opacity", "font-family", "font-size", "font-weight", "font-style", "text-anchor", "dominant-baseline", "marker-start", "marker-end", ];
         svgProps.forEach((prop) => {
          const value = computedStyle.getPropertyValue(prop);
          if (value && value !== "none" && value !== "normal") {
           clonedEl.style[prop] = value;
          }
         });
         clonedEl.removeAttribute("class");
        });
       }
       inlineStyles(svg, svgClone);
       const svgData = new XMLSerializer().serializeToString(svgClone);
       document.body.removeChild(wrapper);
       const svgBlob = new Blob([svgData], {
        type: "image/svg+xml;charset=utf-8",
       });
       const url = URL.createObjectURL(svgBlob);
       const img = new Image();
       img.onload = function() {
        const canvas = document.createElement("canvas");
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext("2d");
        ctx.drawImage(img, 0, 0);
        canvas.toBlob(function(blob) {
         const link = document.createElement("a");
         const timestamp = new Date().toISOString().slice(0, 10);
         link.download = `topology-${timestamp}.png`;
         link.href = URL.createObjectURL(blob);
         link.click();
         URL.revokeObjectURL(url);
         URL.revokeObjectURL(link.href);
        }, "image/png");
       };
       img.onerror = function() {
        console.error("Failed to load SVG image");
        alert("Screenshot failed. Please try again.");
        URL.revokeObjectURL(url);
       };
       img.src = url;
      }
      
      function exportCanvasSVG() {
       const svg = document.getElementById("map");
       const svgClone = svg.cloneNode(true);
       const viewBox = svg.getAttribute("viewBox").split(" ").map(Number);
       const [x, y, width, height] = viewBox;
       svgClone.setAttribute("width", width);
       svgClone.setAttribute("height", height);
       const rootStyles = getComputedStyle(document.documentElement);
       const bgColor = rootStyles.getPropertyValue("--bg").trim() || "#050608";
       const bgRect = document.createElementNS("http://www.w3.org/2000/svg", "rect", );
       bgRect.setAttribute("x", x);
       bgRect.setAttribute("y", y);
       bgRect.setAttribute("width", width);
       bgRect.setAttribute("height", height);
       bgRect.setAttribute("fill", bgColor);
       svgClone.insertBefore(bgRect, svgClone.firstChild);
       const wrapper = document.createElement("div");
       wrapper.style.position = "absolute";
       wrapper.style.left = "-9999px";
       wrapper.appendChild(svgClone);
       document.body.appendChild(wrapper);
       const elements = svg.querySelectorAll("*");
       const clonedElements = svgClone.querySelectorAll("*");
       elements.forEach((el, index) => {
        const clonedEl = clonedElements[index];
        if (!clonedEl) return;
        const computedStyle = getComputedStyle(el);
        const svgProps = ["fill", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin", "opacity", "font-family", "font-size", "font-weight", "font-style", "text-anchor", "dominant-baseline", "marker-start", "marker-end", ];
        svgProps.forEach((prop) => {
         const value = computedStyle.getPropertyValue(prop);
         if (value && value !== "none" && value !== "normal") {
          clonedEl.setAttribute(prop, value);
         }
        });
        clonedEl.removeAttribute("class");
       });
       const svgData = new XMLSerializer().serializeToString(svgClone);
       document.body.removeChild(wrapper);
       const blob = new Blob([svgData], {
        type: "image/svg+xml;charset=utf-8",
       });
       const url = URL.createObjectURL(blob);
       const link = document.createElement("a");
       const timestamp = new Date().toISOString().slice(0, 10);
       link.download = `topology-${timestamp}.svg`;
       link.href = url;
       link.click();
       URL.revokeObjectURL(url);
      }
      let resizeTimeout;
       window.addEventListener('resize', () => {
       clearTimeout(resizeTimeout);
       resizeTimeout = setTimeout(() => {
       updateDrawToolbarVisibility();
       updateTopologyToolbarVisibility();
       }, 100);
      });
    </script>
  
</body></html>