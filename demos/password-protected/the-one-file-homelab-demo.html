<!DOCTYPE html> 
 <html lang="en" style="--panel: #2f0e0e; --panel-alt: #10141b; --sidebar-bg: #10141b; --btn-bg: #0b0e13; --accent: #a75252; --danger: #f56565; --text-main: #e2e8f0; --text-soft: #94a3b8; --topbar-bg: rgba(9, 12, 20, 0.9); --topbar-border: #1f2533; --topbar-height: 112px; --sidebar-width: 350px; --mobile-footer-height: 40vh; --draw-toolbar-height: 0px; --btn-text: #e2e8f0; --tag-fill: #1e293b; --tag-text: #e2e8f0; --tag-border: #475569; --input-bg: #0b0e13; --input-text: #e2e8f0; --input-border: #1f2937; --input-font: Inter, system-ui, sans-serif; --input-font-size: 14px; --toolbar-bg: #441215; --toolbar-border: #1f2937; --toolbar-text: #94a3b8; --toolbar-btn-bg: #0b0e13; --toolbar-btn-text: #e2e8f0; --minimap-dots: #94a3b8; --canvas-hint-bg: #0f172a; --canvas-hint-color: #94a3b8; --node-fill: #1e293b; --node-stroke: #475569; --node-title: #e2e8f0; --node-sub: #94a3b8; --node-title-size: 18px; --node-sub-size: 13px; --node-font: Inter, system-ui, sans-serif; --default-edge: #475569; --selection-handle: #f59e0b; --selection-handle-size: 8px; --group-indicator: #4fd1c5;"><head>
    <meta charset="UTF-8">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>The One File</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- 
      * ====================================================================================
      * THE ONE FILE
      * "There can be only one". A all in one file topology maker for enterprise or homelab
      * 
      * This is your last backup when all others fail. A completely self-contained
      * network topology visualization tool that works as a single HTML file.
      * Open it anywhere, anytime and the idea lives forever.
      * ====================================================================================
      -->
    <style>
      :root {
      color-scheme: dark;
      --bg: #050608;
      --panel: #0b0e13;
      --panel-alt: #10141b;
      --accent: #4fd1c5;
      --danger: #f56565;
      --text-main: #e2e8f0;
      --text-soft: #94a3b8;
      --edge-main: #475569;
      --node-min: 35px;
      --node-max: 70px;
      --topbar-bg: rgba(9, 12, 20, 0.9);
      --topbar-border: #1f2533;
      }
	  html, body, svg, .map-container {
      touch-action: none;
      }
      * {
      box-sizing: border-box;
      user-select: none;
      }
      input,
      textarea,
      [contenteditable="true"] {
      user-select: text;
      -webkit-user-select: text;
      }
      body {
      margin: 0;
      font-family: system-ui, sans-serif;
      background: radial-gradient(circle at top, #1e2532 0, #050608 70%);
      color: var(--text-main);
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
      }
      header {
      padding: 0 20px;
      height: var(--topbar-height, 52px);
      min-height: var(--topbar-height, 52px);
      background: var(--topbar-bg);
      backdrop-filter: blur(6px);
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid var(--topbar-border);
      gap: 16px;
      }
      .title-block {
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-width: 0;
      }
      header h1 {
      font-size: clamp(22px, 3vw, 32px);
      margin: 0;
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
      }
      .editable-page-title {
      cursor: pointer;
      transition: opacity 0.2s;
      }
      .editable-page-title:hover {
      opacity: 0.7;
      }
      .save-row {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      }
      .save-btn {
      padding: 6px 12px;
      background: var(--accent);
      color: var(--bg);
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      white-space: nowrap;
      }
      .save-btn:hover {
      opacity: 0.9;
      }
      .help-icon {
      width: 22px;
      height: 22px;
      border-radius: 50%;
      border: 1px solid var(--edge-main);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      cursor: pointer;
      color: var(--text-soft);
      background: rgba(15, 23, 42, 0.9);
      flex-shrink: 0;
      }
      .help-icon:hover {
      color: var(--accent);
      border-color: var(--accent);
      }
      #settings-btn {
      background: var(--btn-bg, var(--panel));
      color: var(--btn-text, var(--text-main));
      border: 1px solid var(--edge-main);
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 16px;
      flex-shrink: 0;
      }
      #settings-btn:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .header-resizer {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 6px;
      background: transparent;
      cursor: row-resize;
      z-index: 1000;
      transition: background 0.2s;
      }
      .header-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .header-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      .sidebar-resizer {
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 6px;
      background: transparent;
      cursor: col-resize;
      z-index: 1000;
      transition: background 0.2s;
      }
      .sidebar-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .sidebar-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      .mobile-footer-resizer {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 6px;
      background: transparent;
      cursor: row-resize;
      z-index: 1000;
      transition: background 0.2s;
      display: none;
      }
      .mobile-footer-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .mobile-footer-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      @media (max-width: 900px) {
      .mobile-footer-resizer {
      display: block;
      height: 12px;
      }
      .sidebar-resizer {
      display: none;
      }
      .header-resizer {
      height: 12px;
      }
      }
      @media (pointer: coarse) {
      .header-resizer {
      height: 16px;
      }
      .mobile-footer-resizer {
      height: 16px;
      }
      .sidebar-resizer {
      width: 16px;
      }
      }
      .resizer-icon {
      position: absolute;
      opacity: 0.5;
      transition: opacity 0.2s, transform 0.2s;
      pointer-events: none;
      fill: var(--accent);
      }
      .header-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .sidebar-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .mobile-footer-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .header-resizer:hover .resizer-icon,
      .sidebar-resizer:hover .resizer-icon,
      .mobile-footer-resizer:hover .resizer-icon {
      opacity: 1;
      }
      .header-resizer.resizing .resizer-icon,
      .sidebar-resizer.resizing .resizer-icon,
      .mobile-footer-resizer.resizing .resizer-icon {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1.2);
      }
      body.resizing {
      user-select: none;
      }
      body.resizing * {
      cursor: inherit !important;
      pointer-events: none;
      }
      header {
      position: relative;
      }
      .details-panel {
      position: relative;
      }
      main {
      display: grid;
      grid-template-columns: 1fr var(--sidebar-width, 350px);
      flex: 1;
      }
      main.sidebar-collapsed {
      grid-template-columns: 1fr 0;
      }
      @media (max-width: 900px) {
      main {
      grid-template-columns: 1fr;
      grid-template-rows: calc(100vh - var(--topbar-height, 52px) - var(--mobile-footer-height, 40vh)) var(--mobile-footer-height, 40vh);
      }
      main.sidebar-collapsed {
      grid-template-rows: 1fr 0;
      }
      .details-panel {
      max-height: var(--mobile-footer-height, 40vh);
      height: 100%;
      }
      }
      .topology-panel {
      background: var(--panel);
      border-right: 1px solid #111827;
      position: relative;
      overflow: hidden;
      }
      .topology-toolbar {
      position: absolute;
      top: 10px;
      right: 10px;
      display: none;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      z-index: 99;
      font-size: 13px;
      color: var(--toolbar-text, #94a3b8);
      }
      .topology-toolbar label {
      color: var(--toolbar-text, var(--text-soft));
      }
      .topology-toolbar select {
      padding: 4px 6px;
      background: var(--toolbar-btn-bg, var(--panel));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 13px;
      cursor: pointer;
      }
      .topology-toolbar button {
      padding: 4px 10px;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      }
      .topology-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .bulk-toolbar-desktop,
      .bulk-toolbar-mobile {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 9999;
      }
      .bulk-toolbar-desktop {
      position: absolute;
      top: 10px;
      right: 10px;
      bottom: auto;
      left: auto;
      transform: none;
      }
      @media (min-width: 768px) {
      .bulk-toolbar-mobile {
      display: none !important;
      }
      }	  
      .bulk-action-btn {
      padding: 16px;
      background: var(--panel-main);
      border: 1px solid var(--edge-main);
      border-radius: 8px;
      color: var(--text-main);
      font-size: 24px;
      cursor: pointer;
      text-align: center;
      line-height: 1.2;
      }
      .bulk-action-btn:active {
      transform: scale(0.95);
      background: var(--accent);
      }
      .draw-toolbar {
      position: absolute;
      top: 10px;
      left: 10px;
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 8px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      z-index: 99;
      font-size: 13px;
      pointer-events: auto;
      color: var(--toolbar-text, #94a3b8);
      }
      .draw-toolbar button {
      padding: 4px 8px;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      }
      .draw-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .draw-toolbar input[type="color"] {
      width: 30px;
      height: 22px;
      border-radius: 4px;
      border: 1px solid var(--edge-main);
      padding: 0;
      background: transparent;
      cursor: pointer;
      }
      .draw-toolbar select {
      padding: 4px 6px;
      background: var(--toolbar-btn-bg, var(--panel));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 13px;
      cursor: pointer;
      }
      .legend-container {
      position: absolute;
      left: 10px;
      bottom: 10px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      padding: 8px 10px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      font-size: 12px;
      z-index: 20;
      max-width: 260px;
      pointer-events: auto;
      color: var(--toolbar-text, #94a3b8);
      }
      .legend-container {
      padding-right: 22px;
      }
      @media (max-width: 900px) {
      .legend-container {
      height:250px;
      overflow-y: auto;
      z-index:99;
      }
      }
      @media (max-width: 900px) {
      .bulk-toolbar-desktop,
      .topology-toolbar {
      display: none !important;
      }
      }
      .legend-close-btn {
      position: absolute;
      top: 5px;
      right: 5px;
      width: 18px;
      height: 18px;
      border-radius: 999px;
      border: 1px solid var(--edge-main);
      background: var(--panel-alt);
      color: var(--text-soft);
      font-size: 11px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      }
      .legend-close-btn:hover {
      background: var(--danger);
      color: #fff;
      }
      .legend-mini-btn {
      position: absolute;
      left: 10px;
      padding: 4px 8px;
      border-radius: 4px;
      border: 1px solid var(--toolbar-border, #1f2937);
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 11px;
      cursor: pointer;
      z-index: 20;
      display: none;
      transition: all 0.2s;
      }
      .legend-mini-btn:hover,
      .legend-mini-btn:active {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
      }
      .legend-title {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: var(--toolbar-text, var(--text-soft));
      margin-bottom: 2px;
      }
      .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      }
      .legend-swatch {
      width: 14px;
      height: 14px;
      border-radius: 3px;
      border: 1px solid #020617;
      flex-shrink: 0;
      }
      .legend-label {
      outline: none;
      cursor: text;
      flex: 1;
      min-width: 60px;
      user-select: text;
      -webkit-user-select: text;
      }
      .legend-label.editing {
      border-bottom: 1px dashed var(--accent);
      }
      .canvas-viewport {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      overflow: hidden;
      }
      .canvas-viewport.panning {
      cursor: grabbing !important;
      }
      .canvas-viewport.panning * {
      cursor: grabbing !important;
      }
      .canvas-viewport svg {
      width: 100%;
      height: 100%;
      display: block;
      background: linear-gradient(rgba(71, 85, 105, 0.1) 1px,
      transparent 1px),
      linear-gradient(90deg,
      rgba(71, 85, 105, 0.1) 1px,
      transparent 1px),
      linear-gradient(rgba(71, 85, 105, 0.05) 1px, transparent 1px),
      linear-gradient(90deg,
      rgba(71, 85, 105, 0.05) 1px,
      transparent 1px);
      background-size:
      100px 100px,
      100px 100px,
      20px 20px,
      20px 20px;
      background-position:
      -1px -1px,
      -1px -1px,
      -1px -1px,
      -1px -1px;
      }
      .zoom-toolbar {
      display: flex;
      gap: 4px;
      padding: 6px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      }
      .zoom-toolbar button {
      width: 32px;
      height: 32px;
      padding: 0;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 18px;
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
      }
      .zoom-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .zoom-toolbar .zoom-level {
      font-size: 11px;
      color: var(--toolbar-text, var(--text-soft));
      text-align: center;
      padding: 2px 0;
      min-width: 32px;
      }
      .zoom-toolbar .divider {
      height: 1px;
      background: var(--toolbar-border, var(--edge-main));
      margin: 2px 0;
      }
      .minimap-zoom-wrapper {
      position: absolute;
      bottom: 10px;
      right: 10px;
      z-index: 99;
      }
      .minimap-container {
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      overflow: hidden;
      margin-bottom: 4px;
      }
      .minimap-container svg {
      width: 100%;
      height: 100%;
      }
      .minimap-viewport {
      fill: rgba(79, 209, 197, 0.2);
      stroke: var(--accent);
      stroke-width: 2;
      cursor: move;
      }
      .minimap-node {
      fill: var(--minimap-dots, var(--text-soft));
      }
      .minimap-edge {
      stroke: var(--edge-main);
      stroke-width: 1;
      }
      .minimap-close-btn {
      position: absolute;
      top: 2px;
      right: 2px;
      width: 18px;
      height: 18px;
      background: var(--toolbar-btn-bg, rgba(15, 23, 42, 0.9));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 3px;
      color: var(--toolbar-text, var(--text-soft));
      font-size: 11px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
      padding: 0;
      line-height: 1;
      }
      .minimap-close-btn:hover {
      background: var(--danger);
      color: white;
      border-color: var(--danger);
      }
      .toolbar-close-btn {
      width: 24px;
      height: 24px;
      background: var(--toolbar-btn-bg, rgba(15, 23, 42, 0.9));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-text, var(--text-soft));
      font-size: 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      line-height: 1;
      flex-shrink: 0;
      }
      .toolbar-close-btn:hover {
      background: var(--danger);
      color: white;
      border-color: var(--danger);
      }
      .canvas-hint {
      position: absolute;
      top: 50px;
      left: 50%;
      transform: translateX(-50%);
      padding: 8px 16px;
      background: rgba(15, 23, 42, 0.92);
      border: 1px solid #1f2937;
      border-radius: 6px;
      font-size: 12px;
      color: var(--text-soft);
      z-index: 18;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
      }
      .canvas-hint.visible {
      opacity: 1;
      }
      .edge {
      stroke: var(--edge-main);
      stroke-width: 4;
      opacity: 0.75;
      transition: 0.25s ease-in-out;
      cursor: pointer;
      }
      .edge.backup {
      stroke: var(--danger);
      stroke-width: 5;
      }
      .edge.active {
      opacity: 1;
      stroke-width: 7;
      filter: drop-shadow(0 0 8px var(--accent, #4fd1c5));
      }
      .rect-group.active .rect-shape {
      filter: drop-shadow(0 0 10px var(--accent, #4fd1c5));
      animation: pulse 1.2s infinite ease-in-out;
      }
      .text-element.active {
      filter: drop-shadow(0 0 10px var(--accent, #4fd1c5));
      animation: pulse 1.2s infinite ease-in-out;
      }
      .free-preview {
      fill: none;
      stroke-dasharray: 4 4;
      pointer-events: none;
      }
      .free-point {
      fill: #e5e7eb;
      stroke: #0f172a;
      stroke-width: 1.5;
      cursor: grab;
      }
      .node-circle {
      fill: var(--node-fill, #1e293b);
      stroke: var(--node-stroke, #475569);
      stroke-width: 2;
      transition: 0.25s ease;
      transform-origin: center center;
      }
      .node-hit-area {
      cursor: grab;
      pointer-events: all;
      }
      .node-group:hover .node-circle {
      filter: drop-shadow(0 0 10px rgba(79, 209, 197, 0.45));
      }
      .node-group.active .node-circle {
      stroke: var(--accent);
      animation: pulse 1.2s infinite ease-in-out;
      }
      .node-group.selected .node-circle {
      stroke: var(--selection-handle, #f59e0b);
      stroke-width: 3;
      }
      .node-group.search-highlight .node-circle {
      stroke: #10b981;
      stroke-width: 3;
      filter: drop-shadow(0 0 8px #10b981);
      }
      @keyframes pulse {
      0% {
      filter: drop-shadow(0 0 4px #4fd1c5);
      }
      50% {
      filter: drop-shadow(0 0 14px #4fd1c5);
      }
      100% {
      filter: drop-shadow(0 0 4px #4fd1c5);
      }
      }
      .node-label {
      fill: var(--text-main);
      font-size: 18px;
      text-anchor: middle;
      font-weight: 600;
      }
      .node-sub {
      fill: var(--text-soft);
      font-size: 13px;
      text-anchor: middle;
      }
      @media (max-width: 1024px) {
      .node-label {
      font-size: 28px;
      }
      .node-sub {
      font-size: 20px;
      }
      }
      @media (max-width: 768px) {
      .node-label {
      font-size: 70px;
      }
      .node-sub {
      font-size: 50px;
      }
      }
      @media (max-width: 380px) {
      .node-label {
      font-size: 60px;
      }
      .node-sub {
      font-size: 42px;
      }
      }
      .details-panel {
      background: var(--sidebar-bg, var(--panel-alt));
      padding: 22px;
      padding-bottom: 80px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 15px;
      position: relative;
      transition:
      width 0.3s ease,
      min-width 0.3s ease,
      padding 0.3s ease,
      opacity 0.3s ease;
      }
      .details-panel {
      min-width: 260px !important;
      }
      .details-panel {
      overflow-y: auto !important;
      overflow-x: hidden;
      }
      .details-panel.collapsed {
      width: 0 !important;
      min-width: 0 !important;
      padding: 0 !important;
      overflow: hidden;
      opacity: 0;
      }
      body {
      overflow-x: hidden;
      overflow-y: hidden;
      }
      main {
      overflow-x: hidden;
      overflow-y: visible;
      }
      .details-panel {
      overflow-y: auto !important;
      overflow-x: hidden;
      }
      .details-panel.collapsed {
      min-width: 0 !important;
      }
      .sidebar-toggle {
      position: absolute;
      left: -16px;
      top: 50%;
      transform: translateY(-50%);
      width: 16px;
      height: 60px;
      background: var(--sidebar-bg, var(--panel-alt));
      border: 1px solid var(--edge-main);
      border-right: none;
      border-radius: 8px 0 0 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text-soft);
      font-size: 10px;
      z-index: 25;
      transition:
      background 0.2s,
      color 0.2s;
      }
      .sidebar-toggle:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .sidebar-toggle.collapsed {
      left: 0;
      border-right: 1px solid var(--edge-main);
      border-radius: 0 8px 8px 0;
      position: fixed;
      right: 0;
      left: auto;
      }
      .details-name {
      font-size: clamp(22px, 2.5vw, 30px);
      font-weight: 700;
      }
      .details-ip {
      font-size: clamp(16px, 2vw, 22px);
      color: var(--text-soft);
      }
      .details-role {
      font-size: clamp(16px, 2vw, 22px);
      color: var(--accent);
      }
      .details-info-row {
      display: flex;
      align-items: center;
      margin: 6px 0;
      }
      .size-controls {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-top: 10px;
      }
      .size-controls label {
      font-size: clamp(14px, 1.6vw, 18px);
      color: var(--text-soft);
      }
      .size-controls input[type="range"] {
      flex: 1;
      accent-color: var(--accent);
      }
      .size-controls button {
      padding: 6px 12px;
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      font-size: clamp(12px, 1.4vw, 16px);
      }
      .size-controls button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .style-section {
      margin-top: 15px;
      padding-top: 15px;
      border-top: 1px solid var(--edge-main);
      }
      .style-section summary {
      cursor: pointer;
      font-size: clamp(14px, 1.6vw, 20px);
      text-transform: uppercase;
      color: var(--text-soft);
      list-style: none;
      display: flex;
      justify-content: space-between;
      align-items: center;
      user-select: none;
      }
      .style-section summary::-webkit-details-marker {
      display: none;
      }
      .password-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #ffffff;
      z-index: 9999;
      }
      .style-section summary::after {
      content: "▼";
      transition: transform 0.2s;
      }
      .style-section[open] summary::after {
      transform: rotate(180deg);
      }
      .style-content {
      margin-top: 10px;
      }
      .style-row {
      display: flex;
      gap: 10px;
      align-items: center;
      margin: 8px 0;
      }
      .style-row label {
      font-size: clamp(13px, 1.5vw, 17px);
      color: var(--text-soft);
      min-width: 80px;
      }
      .style-row input[type="color"] {
      width: 50px;
      height: 30px;
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      background: transparent;
      }
      .style-row input[type="number"] {
      width: 70px;
      padding: 4px 8px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(12px, 1.4vw, 16px);
      }
      .style-row select {
      flex: 1;
      padding: 4px 8px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(12px, 1.4vw, 16px);
      cursor: pointer;
      }
      .editable-text {
      cursor: pointer;
      transition: opacity 0.2s;
      }
      .editable-text:hover {
      opacity: 0.7;
      }
      .modal {
	  display: none;
	  position: fixed;
	  top: 0;
	  left: 0;
	  width: 100%;
	  height: 100%;
	  z-index: 999999;
	  justify-content: center;
	  align-items: center;
	  overflow: auto;
	  }
	  .modal.active {
	  display: inline-grid;
	  }
	  .modal-content {
	  background: var(--panel-alt);
	  padding: 25px;
	  border-radius: 8px;
	  border: 1px solid var(--edge-main);
	  min-width: 300px;
	  max-width: 90%;
	  }
      .modal-content h3 {
      margin: 0 0 15px 0;
      color: var(--text-main);
      font-size: clamp(18px, 2vw, 24px);
      }
      .modal-content p {
      color: var(--text-soft);
      font-size: clamp(14px, 1.6vw, 18px);
      margin: 0 0 20px 0;
      }
      .modal-content input:not([type="color"]),
      .modal-content select {
      width: 100%;
      padding: 10px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(14px, 1.6vw, 18px);
      margin-bottom: 15px;
      user-select: text;
      -webkit-user-select: text;
      }
      .modal-content input[type="color"] {
      width: 60px;
      height: 36px;
      padding: 2px;
      border: 2px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      background: none;
      -webkit-appearance: none;
      appearance: none;
      }
      .modal-content input[type="color"]::-webkit-color-swatch-wrapper {
      padding: 0;
      }
      .modal-content input[type="color"]::-webkit-color-swatch {
      border: none;
      border-radius: 4px;
      }
      .modal-buttons {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
      margin-top: 10px;
      }
      .modal-buttons button {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: clamp(14px, 1.6vw, 18px);
      font-weight: 600;
      }
      .modal-buttons .btn-cancel {
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      }
      .modal-buttons .btn-save {
      background: var(--accent);
      color: var(--bg);
      }
      .modal-buttons .btn-delete {
      background: var(--danger);
      color: white;
      }
      .confirm-modal p {
      color: var(--text-soft);
      font-size: clamp(14px, 1.6vw, 18px);
      margin: 0 0 20px 0;
      }
      .context-menu-item {
      transition: background 0.15s;
      }
      .context-menu-item:hover {
      background: var(--panel);
      }
      .badge-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      }
      .badge {
      background: var(--tag-fill, #1e293b);
      color: var(--tag-text, #e2e8f0);
      border: 1px solid var(--tag-border, var(--edge-main));
      padding: 5px 12px;
      border-radius: 22px;
      font-size: clamp(12px, 1.4vw, 18px);
      }
      .badge.wg {
      color: var(--accent);
      border-color: var(--accent);
      }
      input[type="text"],
      input[type="number"],
      input[type="password"],
      textarea,
      select {
      background: var(--input-bg, #0b0e13) !important;
      color: var(--input-text, #e2e8f0) !important;
      border-color: var(--input-border, #1f2937) !important;
      font-family: var(--input-font, Inter, system-ui, sans-serif) !important;
      font-size: var(--input-font-size, 14px) !important;
      }
      .section-label {
      margin-top: 8px;
      font-size: clamp(14px, 1.6vw, 20px);
      text-transform: uppercase;
      color: var(--text-soft);
      }
      .list li {
      margin: 6px 0;
      font-size: clamp(14px, 1.6vw, 20px);
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      }
      .list li:hover {
      color: var(--accent);
      }
      .delete-note {
      color: var(--danger);
      font-size: 18px;
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.2s;
      flex-shrink: 0;
      }
      .list li:hover .delete-note {
      opacity: 1;
      }
      .editing {
      outline: 2px solid var(--accent);
      background: #0d141f;
      padding: 4px;
      border-radius: 6px;
      user-select: text;
      -webkit-user-select: text;
      }
      .version-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .version-item:hover {
      background: var(--panel-alt);
      border-color: var(--accent);
      }
      .version-item.current {
      border-color: var(--accent);
      background: rgba(79, 209, 197, 0.1);
      }
      .version-info {
      flex: 1;
      }
      .version-info .timestamp {
      font-size: 13px;
      color: var(--text-main);
      font-weight: 600;
      }
      .version-info .details {
      font-size: 11px;
      color: var(--text-soft);
      margin-top: 4px;
      }
      .version-actions {
      display: flex;
      gap: 6px;
      }
      .audit-entry {
      padding: 8px 12px;
      background: var(--panel);
      border-left: 3px solid var(--edge-main);
      border-radius: 4px;
      font-size: 12px;
      }
      .audit-entry.node { border-left-color: #4fd1c5; }
      .audit-entry.connection { border-left-color: #9f7aea; }
      .audit-entry.style { border-left-color: #ed8936; }
      .audit-entry.rack { border-left-color: #48bb78; }
      .audit-entry.layer { border-left-color: #4299e1; }
      .audit-entry .time {
      color: var(--text-soft);
      font-size: 10px;
      }
      .audit-entry .action {
      color: var(--text-main);
      font-weight: 500;
      }
      .tab-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .tab-item:hover {
      background: var(--panel-alt);
      }
      .tab-item.active {
      border-color: var(--accent);
      background: rgba(79, 209, 197, 0.1);
      }
      .tab-item .tab-name {
      font-weight: 600;
      color: var(--text-main);
      flex: 1;
      }
      .tab-item .tab-stats {
      font-size: 11px;
      color: var(--text-soft);
      margin-right: 10px;
      }
      .tab-actions {
      display: flex;
      gap: 6px;
      }    
      .secret-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      border-left: 3px solid var(--danger);
      }
      .secret-item .secret-name {
      font-weight: 600;
      color: var(--text-main);
      flex: 1;
      }
      .secret-item .secret-status {
      font-size: 11px;
      color: var(--text-soft);
      margin-right: 10px;
      }    
      .mobile-menu-btn {
      display: none;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      color: var(--text-main);
      font-size: 22px;
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      }
      #topbar-menu {
      gap: 8px;
      }
      @media (min-width: 721px) {
      #topbar-menu {
      display: flex !important;
      }
      }
      @media (max-width: 720px) {
      #topbar-menu {
      display: none;
      }
      #topbar-menu.open {
      display: flex;
      }
      }
      @media (max-width: 720px) {
      .mobile-menu-btn {
      display: block;
      }
      #topbar-menu {
      position: absolute;
      top: var(--topbar-height);
      right: 0;
      background: var(--panel-alt);
      border-left: 1px solid var(--topbar-border);
      border-bottom: 1px solid var(--topbar-border);
      padding: 12px;
      display: none;
      flex-direction: column;
      width: 180px;
      z-index: 999;
      }
      #topbar-menu.open {
      display: flex;
      }
      header {
      position: relative;
      z-index: 9999;
      }
      }
      @media (max-width: 720px) {
      .draw-toolbar {
      position: absolute;
      top: auto;
      bottom: auto;
      left: 10px !important;
      right: auto !important;
      width: auto;
      gap: 6px;
      padding: 8px;
      }
      .topology-toolbar {
      position: absolute;
      top: auto;
      bottom: auto;
      width: auto;
      gap: 6px;
      padding: 8px;
      }
      .draw-toolbar {
      top: 10px !important;
      z-index:99;
      }
      .topology-toolbar {
      z-index:99;
      top: calc(10px + var(--draw-toolbar-height, 50px)) !important;
      }
      .canvas-hint {
      top: calc(10px + 120px);
      }
      #search-input {
      width: 100%;
      }
      }
	  body.view-only-mode:not(.view-only-inspect) #node-panel,
      body.view-only-mode:not(.view-only-inspect) #edge-panel,
      body.view-only-mode:not(.view-only-inspect) #text-panel,
      body.view-only-mode:not(.view-only-inspect) #rect-panel {
        display: none !important;
      }
      body.view-only-mode .node-group,
      body.view-only-mode .edge,
      body.view-only-mode .rect-group,
      body.view-only-mode .text-element {
        cursor: default !important;
      }
      body.view-only-mode #bulk-toolbar,
      body.view-only-mode #bulk-toolbar-mobile,
      body.view-only-mode #bulk-actions-modal {
        display: none !important;
      }
      body.view-only-mode::after {
        content: "VIEW ONLY • tap 5× to inspect";
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(245, 101, 101, 0.9);
        color: white;
        padding: 6px 16px;
        border-radius: 20px;
        font-size: 12px;
        font-weight: 600;
        letter-spacing: 1px;
        z-index: 9999;
        pointer-events: none;
      }
    </style>
  </head>
  <body style="background: radial-gradient(circle at center top, rgb(30, 37, 50) 0px, rgb(5, 6, 8) 70%);" class="">
    <div class="modal" id="edit-modal">
      <div class="modal-content">
        <h3 id="modal-title">Edit Title</h3>
        <input type="text" id="modal-input">
        <div class="modal-buttons">
          <button class="btn-cancel" id="modal-cancel">Cancel</button>
          <button class="btn-save" id="modal-save">Save</button>
        </div>
      </div>
    </div>
    <div class="modal confirm-modal" id="confirm-modal">
      <div class="modal-content">
        <h3>Confirm</h3>
        <p id="confirm-message"> Are you sure you want to delete this line? </p>
        <div class="modal-buttons">
          <button class="btn-cancel" id="confirm-cancel">Cancel</button>
          <button class="btn-delete" id="confirm-delete">Delete</button>
        </div>
      </div>
    </div>
    <div class="modal" id="save-info-modal">
      <div class="modal-content" style="max-width: 700px; max-height: 80vh; overflow-y: auto;">
        <h3 style="margin-bottom: 16px;">Help</h3>
        <div style="display: flex; gap: 8px; margin-bottom: 16px; flex-wrap: wrap;">
          <button class="help-tab active" data-tab="general" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--accent); color: var(--bg); border-radius: 6px; cursor: pointer; font-weight: 600;">General</button>
          <button class="help-tab" data-tab="desktop" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--panel); color: var(--text-main); border-radius: 6px; cursor: pointer; font-weight: 600;">Desktop</button>
          <button class="help-tab" data-tab="mobile" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--panel); color: var(--text-main); border-radius: 6px; cursor: pointer; font-weight: 600;">Mobile</button>
        </div>
        <div id="help-tab-general" class="help-tab-content" style="display: block;">
          <ul style="margin-left: 20px; margin-bottom: 12px; line-height: 1.8;">
            <li><strong>Add Nodes:</strong> Click "+ Node" or "+ Rack" in the top menu</li>
            <li><strong>Connect Nodes:</strong> Select a node, then use "Add Connection" in the panel</li>
            <li><strong>Move Nodes:</strong> Drag nodes to reposition them</li>
            <li><strong>Enter Rack View:</strong> Double click on desktop or Long press on mobile</li>
            <li><strong>Multi Select:</strong> Right click (desktop) or double tap (mobile)</li>
            <li><strong>Pan Canvas:</strong> Drag empty space or hold Space + drag</li>
            <li><strong>Zoom:</strong> Scroll wheel or pinch gesture</li>
            <li><strong>Free Draw:</strong> Use draw toolbar for drawing lines, boxes/zones , and text</li>
          </ul>
          <h4 style="color: var(--accent); margin-bottom: 8px;">Saving &amp; Encryption</h4>
          <p style="margin-bottom: 8px;">Browsers cannot overwrite local files. Click <strong>Save File</strong> to download an updated HTML with all changes. Replace your old file to keep edits.</p>
          <p style="margin-bottom: 8px;"><strong>Encryption of data:</strong> Check "Encrypt" before saving to password protect your data. Beware! No recovery possible without password!!</p>
          <p><strong>Decryption of data:</strong> Export via JSON in top settings menu after successful password validation to decrypt your data. You can then reimport back into the same file and save!</p>
        </div>
        <div id="help-tab-desktop" class="help-tab-content" style="display: none;">
          <h4 style="color: var(--accent); margin-bottom: 12px;">Navigation</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Arrow Keys</code></td>
              <td style="padding: 8px;">Move selected 1px</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Shift + Arrows</code></td>
              <td style="padding: 8px;">Move selected 10px</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Tab / Shift+Tab</code></td>
              <td style="padding: 8px;">Cycle through nodes</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">F</code></td>
              <td style="padding: 8px;">Focus on selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Space + Drag</code></td>
              <td style="padding: 8px;">Pan canvas</td>
            </tr>
          </tbody></table>
          <h4 style="color: var(--accent); margin-bottom: 12px;">Management</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">L</code></td>
              <td style="padding: 8px;">Lock/unlock selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">G</code></td>
              <td style="padding: 8px;">Group/ungroup selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+C / Ctrl+V</code></td>
              <td style="padding: 8px;">Copy / Paste</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+D</code></td>
              <td style="padding: 8px;">Duplicate</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+A</code></td>
              <td style="padding: 8px;">Select all</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Delete</code></td>
              <td style="padding: 8px;">Delete selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Escape</code></td>
              <td style="padding: 8px;">Clear selection</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+Z / Ctrl+Y</code></td>
              <td style="padding: 8px;">Undo / Redo</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Right Click</code></td>
              <td style="padding: 8px;">Multi select toggle</td>
            </tr>
          </tbody></table>
        </div>
        <div id="help-tab-mobile" class="help-tab-content" style="display: none;">
          <h4 style="color: var(--accent); margin-bottom: 12px;">Basic Gestures</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Tap node</strong></td>
              <td style="padding: 8px;">Select &amp; open properties</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Tap empty</strong></td>
              <td style="padding: 8px;">Deselect all</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Drag node</strong></td>
              <td style="padding: 8px;">Move node</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Drag empty</strong></td>
              <td style="padding: 8px;">Pan canvas</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Pinch</strong></td>
              <td style="padding: 8px;">Zoom in/out</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Double-tap node</strong></td>
              <td style="padding: 8px;">Add/remove from selection</td>
            </tr>
          </tbody></table>
          <h4 style="color: var(--accent); margin-bottom: 12px;">Rack View</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Long-press rack</strong></td>
              <td style="padding: 8px;">Enter rack view</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Double-tap empty</strong></td>
              <td style="padding: 8px;">Exit rack view</td>
            </tr>
          </tbody></table>
        </div>
        <div class="modal-buttons" style="margin-top: 16px;">
          <button class="btn-cancel" id="save-info-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="settings-modal">
      <div class="modal-content">
        <h2>Settings</h2>
		<details class="style-section">
          <summary>View Only Mode</summary>
          <div class="style-content">
            <div class="style-row">
              <label>View Only (disable editing)</label>
              <input type="checkbox" id="view-only-mode" style="width:auto;">
            </div>
            <p style="margin-top:4px;font-size:12px;color:var(--text-soft);">When enabled, all editing of the canvas is disabled. Pan and zoom still work.</p>
          </div>
        </details>
        <details class="style-section">
          <summary>General Theme</summary>
          <div class="style-content">
		    <div class="style-row">
              <label>Main Background</label>
              <input type="color" id="panel-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Modal Window (popup) Background</label>
              <input type="color" id="panel-alt-color" value="#10141b">
            </div>
            <div class="style-row">
              <label>Accent Buttons</label>
              <input type="color" id="accent-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Danger Buttons</label>
              <input type="color" id="danger-color" value="#f56565">
            </div>
            <div class="style-row">
              <label>Primary Text</label>
              <input type="color" id="text-main-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Secondary Text</label>
              <input type="color" id="text-soft-color" value="#94a3b8">
            </div>
          </div>
        </details>
		<details class="style-section">
          <summary>Top Bar</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="topbar-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="topbar-border-color" value="#1f2533">
            </div>
          </div>
		  <div class="style-content">
            <div class="style-row">
              <label>Button Fill</label>
              <input type="color" id="btn-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Button Text</label>
              <input type="color" id="btn-text-color" value="#e2e8f0">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Main Canvas</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="canvas-border-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Grid Lines</label>
              <input type="color" id="canvas-grid-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Grid Size</label>
              <input type="number" id="canvas-grid-size" value="50" min="20" max="200" style="width:60px;">
            </div>
			<div class="style-row">
              <label>Background Top</label>
              <input type="color" id="canvas-gradient-top" value="#1e2532">
            </div>
            <div class="style-row">
              <label>Background Bottom</label>
              <input type="color" id="canvas-gradient-bottom" value="#050608">
            </div>
            <div class="style-row">
              <label>Solid Background</label>
              <input type="color" id="page-bg-color" value="#050608">
            </div>
            <p style="margin-top:4px;font-size:12px;color:var(--text-soft);">Set solid background to override gradient.</p>
          </div>
			</details>
		  <details class="style-section">
          <summary>Rack Canvas</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Frame Fill</label>
              <input type="color" id="rack-frame-fill" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Frame Border</label>
              <input type="color" id="rack-frame-stroke" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Grid Lines</label>
              <input type="color" id="rack-line-color" value="#475569">
            </div>
            <div class="style-row">
              <label>U Labels</label>
              <input type="color" id="rack-text-color" value="#4fd1c5">
            </div>
          </div>
        </details>
		        <details class="style-section">
          <summary>Canvas Toolbars</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="toolbar-bg-color" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="toolbar-border-color" value="#1f2937">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="toolbar-text-color" value="#94a3b8">
            </div>
            <div class="style-row">
              <label>Button Fill</label>
              <input type="color" id="toolbar-btn-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Button Text</label>
              <input type="color" id="toolbar-btn-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Minimap Dots</label>
              <input type="color" id="minimap-dots-color" value="#94a3b8">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Nodes</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Fill</label>
              <input type="color" id="node-fill-color" value="#1e293b">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="node-stroke-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Title Color</label>
              <input type="color" id="node-title-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Title Size</label>
              <input type="number" id="node-title-size" value="18" min="8" max="48" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Subtitle Color</label>
              <input type="color" id="node-sub-color" value="#94a3b8">
            </div>
            <div class="style-row">
              <label>Subtitle Size</label>
              <input type="number" id="node-sub-size" value="13" min="8" max="48" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Font</label>
              <select id="node-font-family" style="flex:1;padding:4px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;">
                <option value="Inter, system-ui, sans-serif">Inter</option>
                <option value="Arial, sans-serif">Arial</option>
                <option value="Helvetica, sans-serif">Helvetica</option>
                <option value="Georgia, serif">Georgia</option>
                <option value="monospace">Monospace</option>
              </select>
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Connections</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Default Color</label>
              <input type="color" id="default-edge-color" value="#475569">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Groups &amp; Editing</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Resize handle Color</label>
              <input type="color" id="selection-handle-color" value="#f59e0b">
            </div>
            <div class="style-row">
              <label>Resize Handle Size</label>
              <input type="number" id="selection-handle-size" value="8" min="4" max="16" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Grouped Icon Outline</label>
              <input type="color" id="group-indicator-color" value="#4fd1c5">
            </div>
          </div>
		   <div class="style-content">
            <div class="style-row">
              <label>Multiselect Fill Color (Desktop)</label>
              <input type="color" id="selection-fill-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Multiselect Fill Opacity (Desktop)</label>
              <input type="range" id="selection-fill-opacity" min="0" max="1" step="0.05" value="0.1">
              <span id="selection-fill-opacity-val" style="min-width:35px;text-align:right;">10%</span>
            </div>
            <div class="style-row">
              <label>Multiselect Border Color (Desktop)</label>
              <input type="color" id="selection-stroke-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Multiselect Border Width (Desktop)</label>
              <input type="number" id="selection-stroke-width" min="1" max="10" value="2">
            </div>
            <div class="style-row">
              <label>Multiselect Border Style (Desktop)</label>
              <select id="selection-stroke-style">
                <option value="5,5">Dashed</option>
                <option value="2,4">Dotted</option>
                <option value="none">Solid</option>
              </select>
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Inputs &amp; Dropdowns</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="input-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="input-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="input-border-color" value="#1f2937">
            </div>
            <div class="style-row">
              <label>Font</label>
              <select id="input-font-family" style="flex:1;padding:4px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;">
                <option value="Inter, system-ui, sans-serif">Inter</option>
                <option value="Arial, sans-serif">Arial</option>
                <option value="Helvetica, sans-serif">Helvetica</option>
                <option value="Georgia, serif">Georgia</option>
                <option value="monospace">Monospace</option>
              </select>
            </div>
            <div class="style-row">
              <label>Font Size</label>
              <input type="number" id="input-font-size" value="14" min="10" max="24" style="width:60px;">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Welcome Message</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Enabled</label>
              <input type="checkbox" id="canvas-hint-enabled" checked="" style="width:auto;">
            </div>
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="canvas-hint-bg-color" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Text Color</label>
              <input type="color" id="canvas-hint-text-color" value="#94a3b8">
            </div>
            <div class="style-row" style="flex-direction:column;align-items:stretch;">
              <label>Custom Text (HTML)</label>
              <textarea id="canvas-hint-text" rows="4" style="width:100%;margin-top:4px;padding:6px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;font-size:12px;resize:vertical;" placeholder="Leave empty for default"></textarea>
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Sidebar / Mobile Footer</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="sidebar-bg-color" value="#10141b">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Tags</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Fill</label>
              <input type="color" id="tag-fill-color" value="#1e293b">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="tag-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="tag-border-color" value="#475569">
            </div>
          </div>
        </details>
        <details class="style-section" open="">
          <summary>Import / Export / Upgrade JSON</summary>
          <div class="style-content">
            <button id="export-data-btn" style="width:100%;margin-bottom:10px;padding:10px;background:var(--accent);color:var(--bg);border:none;border-radius:6px;cursor:pointer;font-size:14px;font-weight:600;">Export JSON</button>
            <button id="import-data-btn" style="width:100%;padding:10px;background:var(--panel);color:var(--text-main);border:1px solid var(--edge-main);border-radius:6px;cursor:pointer;font-size:14px;font-weight:600;">Import JSON</button>
            <input type="file" id="import-data-file" accept=".json" style="display:none">
          </div>
        </details>
        <details class="style-section" open="">
          <summary>Danger Zone</summary>
          <div class="style-content">
            <p style="margin-bottom:12px;font-size:13px;color:var(--text-soft);">Permanently delete everything on the canvas.</p>
            <button id="clear-all-btn" title="Clear all nodes" style="padding:6px 12px;background:var(--danger);color:#fff;border:none;border-radius:6px;cursor:pointer;font-size:14px;font-weight:600;">Clear All</button>
            <input type="file" id="import-data-file" accept=".json" style="display:none">
          </div>
        </details>
        <div class="modal-buttons">
          <button class="btn-cancel" id="settings-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="add-node-modal">
      <div class="modal-content">
        <h3>Add New Node</h3>
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Name</label>
        <input type="text" id="new-node-name" placeholder="e.g. web-server">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">IP / Subtitle</label>
        <input type="text" id="new-node-ip" placeholder="e.g. 192.168.1.100">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Tags (comma separated)</label>
        <input type="text" id="new-node-tags" placeholder="e.g. Docker, nginx, WG: vpn">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Shape</label>
        <select id="new-node-shape">
                  <optgroup label="Basic Shapes">
				  <option value="circle">Circle</option>
				  <option value="square">Square</option>
				  <option value="rectangle">Rectangle</option>
				  <option value="triangle">Triangle</option>
				  <option value="hexagon">Hexagon</option>
				  <option value="diamond">Diamond</option>
				  <option value="star">Star</option>
				  <option value="stop-sign">Stop Sign</option>
				  <option value="octagon">Octagon</option>
				  <option value="pentagon">Pentagon</option>
				  <option value="cross">Cross</option>
				  <option value="rounded-square">Rounded Square</option>
				  <option value="pill">Pill</option>
				  <option value="parallelogram">Parallelogram</option>
				  <option value="trapezoid">Trapezoid</option>
				</optgroup>
			  <optgroup label="Computers &amp; Devices">
			      <option value="server">Server</option>
				  <option value="pc">PC / Desktop</option>
				  <option value="laptop">Laptop</option>
				  <option value="phone">Phone / Mobile</option>
				  <option value="printer">Printer</option>
				  <option value="pi">Raspberry Pi</option>
				  <option value="sensor">Sensor / IoT</option>
			  </optgroup>
			  <optgroup label="Network Equipment">
				  <option value="router">Router</option>
				  <option value="switch">Switch</option>
				  <option value="firewall">Firewall</option>
				  <option value="access-point">Access Point</option>
				  <option value="load-balancer">Load Balancer</option>
				  <option value="gateway">Gateway</option>
				  <option value="vpn">VPN / Tunnel</option>
				  <option value="nas">NAS / Storage</option>
			  </optgroup>
			  <optgroup label="Cloud &amp; Services">
			      <option value="cloud">Cloud</option>
				  <option value="database">Database</option>
				  <option value="docker">Docker</option>
				  <option value="container">Container</option>
				  <option value="vm">Virtual Machine</option>
				  <option value="kubernetes">Kubernetes</option>
				  <option value="api">API / Endpoint</option>
				  <option value="queue">Queue / Message</option>
				  <option value="lambda">Lambda / Function</option>
				  <option value="bucket">Bucket / S3</option>
			  </optgroup>
			  <optgroup label="Security &amp; Monitoring">
				  <option value="shield">Shield</option>
				  <option value="camera">Camera / CCTV</option>
				  <option value="monitor">Monitor / Dashboard</option>
			  </optgroup>
        </select>
        <div class="modal-buttons">
          <button class="btn-cancel" id="add-node-cancel">Cancel</button>
          <button class="btn-save" id="add-node-save">Add Node</button>
        </div>
      </div>
    </div>
    <div class="modal" id="add-rack-modal">
      <div class="modal-content">
        <h3>Add New Rack</h3>
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Rack Name</label>
        <input type="text" id="new-rack-name" placeholder="e.g. Rack-A, DC1-R01">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">IP / Network Range (optional)</label>
        <input type="text" id="new-rack-ip" placeholder="e.g. 192.168.1.0/24">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Tags (comma separated)</label>
        <input type="text" id="new-rack-tags" placeholder="e.g. Production, Data Center 1">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Icon / Shape</label>
        <select id="new-rack-shape">
                  <optgroup label="Basic Shapes">
				  <option value="circle">Circle</option>
				  <option value="square">Square</option>
				  <option value="rectangle">Rectangle</option>
				  <option value="triangle">Triangle</option>
				  <option value="hexagon">Hexagon</option>
				  <option value="diamond">Diamond</option>
				  <option value="star">Star</option>
				  <option value="stop-sign">Stop Sign</option>
				  <option value="octagon">Octagon</option>
				  <option value="pentagon">Pentagon</option>
				  <option value="cross">Cross</option>
				  <option value="rounded-square">Rounded Square</option>
				  <option value="pill">Pill</option>
				  <option value="parallelogram">Parallelogram</option>
				  <option value="trapezoid">Trapezoid</option>
				</optgroup>
			  <optgroup label="Computers &amp; Devices">
			      <option value="server">Server</option>
				  <option value="pc">PC / Desktop</option>
				  <option value="laptop">Laptop</option>
				  <option value="phone">Phone / Mobile</option>
				  <option value="printer">Printer</option>
				  <option value="pi">Raspberry Pi</option>
				  <option value="sensor">Sensor / IoT</option>
			  </optgroup>
			  <optgroup label="Network Equipment">
				  <option value="router">Router</option>
				  <option value="switch">Switch</option>
				  <option value="firewall">Firewall</option>
				  <option value="access-point">Access Point</option>
				  <option value="load-balancer">Load Balancer</option>
				  <option value="gateway">Gateway</option>
				  <option value="vpn">VPN / Tunnel</option>
				  <option value="nas">NAS / Storage</option>
			  </optgroup>
			  <optgroup label="Cloud &amp; Services">
			      <option value="cloud">Cloud</option>
				  <option value="database">Database</option>
				  <option value="docker">Docker</option>
				  <option value="container">Container</option>
				  <option value="vm">Virtual Machine</option>
				  <option value="kubernetes">Kubernetes</option>
				  <option value="api">API / Endpoint</option>
				  <option value="queue">Queue / Message</option>
				  <option value="lambda">Lambda / Function</option>
				  <option value="bucket">Bucket / S3</option>
			  </optgroup>
			  <optgroup label="Security &amp; Monitoring">
				  <option value="shield">Shield</option>
				  <option value="camera">Camera / CCTV</option>
				  <option value="monitor">Monitor / Dashboard</option>
			  </optgroup>
        </select>
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Rack Capacity</label>
        <select id="new-rack-capacity">
          <option value="42" selected="">42U (Standard Full Rack)</option>
          <option value="48">48U (Large Rack)</option>
          <option value="24">24U (Half Rack)</option>
          <option value="12">12U (Small/Wall Mount)</option>
          <option value="6">6U (Mini Rack)</option>
        </select>
        <div class="modal-buttons">
          <button class="btn-cancel" id="add-rack-cancel">Cancel</button>
          <button class="btn-save" id="add-rack-save">Add Rack</button>
        </div>
      </div>
    </div>
    <div class="modal confirm-modal" id="clear-all-modal">
      <div class="modal-content">
        <h3>Clear All Nodes</h3>
        <p> This will remove ALL nodes and connections. This cannot be undone until you reload without saving. Are you sure? </p>
        <div class="modal-buttons">
          <button class="btn-cancel" id="clear-all-cancel">Cancel</button>
          <button class="btn-delete" id="clear-all-confirm">Clear Everything</button>
        </div>
      </div>
    </div>
    <div class="modal" id="layer-modal">
      <div class="modal-content" style="max-width: 400px;">
        <h3>Layer Visibility</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Toggle which layers are visible on the canvas</p>
        <div style="display: flex; flex-direction: column; gap: 10px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-physical" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Physical Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-logical" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Logical Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-security" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Security Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-application" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Application Layer</span>
          </label>
        </div>
        <div style="margin-top: 15px; display: flex; gap: 8px;">
          <button class="btn-cancel" style="flex: 1;" onclick="document.querySelectorAll('#layer-modal input[type=checkbox]').forEach(cb =&gt; cb.checked = false); applyLayerFilter();">Hide All</button>
          <button class="btn-save" style="flex: 1;" onclick="document.querySelectorAll('#layer-modal input[type=checkbox]').forEach(cb =&gt; cb.checked = true); applyLayerFilter();">Show All</button>
        </div>
        <div class="modal-buttons" style="margin-top: 10px;">
          <button class="btn-cancel" id="layer-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="tabs-modal">
      <div class="modal-content" style="max-width: 600px;">
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Manage multiple topologies</p>
        <div id="tabs-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 400px; overflow-y: auto; margin-bottom: 15px;">
            <div class="tab-item " onclick="switchTab(0)">
              <div class="tab-name">Corporate Site B</div>
              <div class="tab-stats">105 nodes • 64 connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(0)" title="Rename tab">✏️</button>
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(${index})" title="Delete tab">🗑️</button>
              </div>
            </div>
          
            <div class="tab-item active" onclick="switchTab(1)">
              <div class="tab-name">Homelab 2</div>
              <div class="tab-stats">11 nodes • 10 connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(1)" title="Rename tab">✏️</button>
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(${index})" title="Delete tab">🗑️</button>
              </div>
            </div>
          </div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="new-tab-name" placeholder="New tab name..." style="flex: 1; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <button class="btn-save" onclick="createNewTab()">+ Add Tab</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="tabs-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="rollback-modal">
      <div class="modal-content" style="max-width: 700px;">
        <h3>Version History</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Limit: Snapshots</p>
        <div id="rollback-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 450px; overflow-y: auto; margin-bottom: 15px;">
          <div style="text-align: center; padding: 40px; color: var(--text-soft);">No version history yet. Versions are saved automatically when you save the file.</div>
        </div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <button class="btn-cancel" onclick="clearRollbackHistory()">Clear History</button>
          <button class="btn-save" onclick="createManualSnapshot()">Create Snapshot</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="rollback-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="audit-log-modal">
      <div class="modal-content" style="max-width: 800px;">
        <h3>Audit Log</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Track all changes made to your topology</p>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <select id="audit-filter" style="padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
            <option value="all">All Events</option>
            <option value="node">Node Operations</option>
            <option value="connection">Connections</option>
            <option value="style">Style Changes</option>
            <option value="rack">Rack Operations</option>
            <option value="layer">Layer Changes</option>
          </select>
          <button class="btn-save" onclick="exportAuditLog()">Export</button>
        </div>
        <div id="audit-log-list" style="display: flex; flex-direction: column; gap: 4px; max-height: 450px; overflow-y: auto; margin-bottom: 15px; font-family: monospace; font-size: 12px;">
          <div style="text-align: center; padding: 40px; color: var(--text-soft);">No audit entries yet</div>
        </div>
        <div style="display: flex; gap: 8px;">
          <button class="btn-cancel" onclick="clearAuditLog()">Clear Log</button>
          <button class="btn-cancel" id="audit-log-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="secrets-modal">
      <div class="modal-content" style="max-width: 600px;">
        <h3>Notes</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Notes can also be stored with AES 256 encryption</p>
        <div id="secrets-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 350px; overflow-y: auto; margin-bottom: 15px;">
        </div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="new-secret-name" placeholder="Note name (e.g., 'Root Passwords')..." style="flex: 1; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <button class="btn-save" onclick="createNewSecret()">+ Add Note</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="secrets-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="secret-editor-modal">
      <div class="modal-content" style="max-width: 600px;">
        <h3 id="secret-editor-title">Edit Note</h3>
        <textarea id="secret-editor-content" placeholder="Enter sensitive information here..." style="width: 100%; height: 200px; padding: 12px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main); font-family: monospace; resize: vertical; margin-bottom: 15px;"></textarea>
        <div style="margin-bottom: 15px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
          <input type="checkbox" id="secret-auto-encrypt" checked="" style="cursor: pointer;">
          <span>Encrypt Note</span>
          </label>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" onclick="closeSecretEditor()">Cancel</button>
          <button class="btn-save" onclick="saveSecret()">Save</button>
        </div>
      </div>
    </div>
    <div id="context-menu" style="display: none !important;">
    </div>
    <header>
      <div class="title-block">
        <h1 id="page-title" class="editable-page-title">The One File</h1>
        <div class="save-row">
          <button id="save-file-btn" class="save-btn" type="button">Save File</button>
          <label style="display: flex;align-items: center;gap: 4px;font-size: 12px;color: var(--text-soft);cursor: pointer;user-select: none;">
          <input type="checkbox" id="encrypt-toggle" style="cursor: pointer">
          <span title="Encrypt data with password">Encrypt</span>
          </label>
          <span id="save-help-btn" class="help-icon" title="Why save?">?</span>
        </div>
      </div>
      <div id="topbar-menu">
        <button id="back-to-topology-btn" title="Exit rack view and return to topology" style="padding: 6px 12px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;display: none;">← Back to Topology</button>
        <button id="add-node-btn" class="save-btn" title="Add new node" style="background: var(--accent)" draggable="true">+ Node</button>
        <button id="add-rack-btn" class="save-btn" title="Add new rack" style="background: var(--accent); margin-left: 8px;" draggable="true">+ Rack</button>
        <button id="undo-btn" title="Undo (Ctrl+Z)" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;" disabled="">↶</button>
        <button id="redo-btn" title="Redo (Ctrl+Y)" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;" disabled="">↷</button>
        <input type="text" id="search-nodes" placeholder="Search nodes..." title="Search by name, IP, MAC, role, or tag" style="padding: 6px 12px;background: var(--input-bg);color: var(--input-text);border: 1px solid var(--input-border);border-radius: 6px;font-family: var(--input-font);font-size: var(--input-font-size);width: 180px;">
        <button id="layers-btn" title="Toggle layer visibility" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Layers</button>
        <button id="tabs-btn" title="Manage document tabs" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Tabs</button>
        <button id="rollback-btn" title="View version history" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Snapshots</button>
        <button id="audit-log-btn" title="View audit log" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Audit</button>
        <button id="secrets-btn" title="Manage encrypted notes" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Notes</button>
        <button onclick="screenshotCanvas()" title="Export canvas as PNG image" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">PNG</button>
        <button onclick="exportCanvasSVG()" title="Export canvas as SVG vector" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">SVG</button>
        <button id="settings-btn" title="Page settings">⚙️</button>
      </div>
      <button id="mobile-menu-toggle" class="mobile-menu-btn">☰</button>
      <div class="header-resizer" id="header-resizer">
        <svg class="resizer-icon" width="40" height="6" viewBox="0 0 40 6" xmlns="http://www.w3.org/2000/svg">
          <circle cx="14" cy="3" r="2"></circle>
          <circle cx="20" cy="3" r="2"></circle>
          <circle cx="26" cy="3" r="2"></circle>
        </svg>
      </div>
    </header>
    <main>
      <section class="topology-panel">
        <div class="draw-toolbar" id="draw-toolbar" style="display: flex !important;">
          <button type="button" class="toolbar-close-btn" id="draw-toolbar-close-btn" title="Hide draw toolbar">✕</button>
          <button id="draw-toggle" title="Draw custom line">✏️</button>
          <button id="rect-toggle" title="Draw zone">▭</button>
          <button id="text-toggle" title="Add text">T</button>
          <select id="rect-style" title="zone style">
            <option value="filled">Filled</option>
            <option value="outlined">Outlined</option>
          </select>
          <input type="color" id="draw-color" value="#f97316" title="Line color">
          <select id="draw-style" title="Line style">
            <option value="solid">Solid</option>
            <option value="dashed">Dashed</option>
            <option value="dotted">Dotted</option>
          </select>
          <select id="draw-arrow" title="Arrow direction">
            <option value="none">No arrows</option>
            <option value="forward">→ Right</option>
            <option value="backward">← Left</option>
            <option value="both">↔ Both</option>
          </select>
          <button id="draw-undo" style="display: none" title="Undo last point">Undo</button>
        </div>
        <div class="topology-toolbar" id="topology-toolbar" style="display: flex !important;">
          <button type="button" class="toolbar-close-btn" id="topology-toolbar-close-btn" title="Hide add line toolbar">✕</button>
          <label for="add-line-select">Add line to:</label>
          <select id="add-line-select"><option value="core-router-2">Core Router 2</option><option value="fw-external-1">External FW 1</option><option value="fw-external-2">External FW 2</option><option value="fw-internal">Internal FW</option><option value="core-switch-1">Core Switch 1</option><option value="core-switch-2">Core Switch 2</option><option value="dc-rack-a1">DC Rack A1</option><option value="dc-rack-a2">DC Rack A2</option><option value="dc-rack-b1">DC Rack B1</option><option value="dc-rack-b2">DC Rack B2</option><option value="dmz-rack">DMZ Rack</option><option value="mgmt-rack">Management Rack</option><option value="wlc-primary">WLC Primary</option><option value="wlc-secondary">WLC Secondary</option><option value="mobile-zone-hq">HQ Mobile Zone</option><option value="mobile-zone-guest">Guest WiFi Zone</option><option value="mobile-zone-iot">IoT Device Zone</option><option value="branch-router-ny">NYC Branch Router</option><option value="branch-router-la">LA Branch Router</option><option value="branch-router-chi">Chicago Branch Router</option><option value="branch-router-lon">London Branch Router</option><option value="branch-router-tokyo">Tokyo Branch Router</option><option value="cloud-aws">AWS Cloud</option><option value="cloud-azure">Azure Cloud</option><option value="cloud-gcp">GCP Cloud</option><option value="isp-primary">ISP Primary</option><option value="isp-secondary">ISP Secondary</option><option value="proxy-server-1">Proxy Server 1</option><option value="proxy-server-2">Proxy Server 2</option><option value="vpn-concentrator">VPN Concentrator</option><option value="nac-server">NAC Server</option><option value="voip-cluster">VoIP Cluster</option><option value="video-conf">Video Conference</option><option value="security-cameras">Security Cameras</option><option value="dev-server-1">Dev Server 1</option><option value="dev-server-2">Dev Server 2</option><option value="test-environment">Test Environment</option><option value="erp-system">ERP System</option><option value="crm-system">CRM System</option><option value="endpoint-1000">Corporate Endpoints</option><option value="dist-switch-floor1">Floor 1 Switch</option><option value="dist-switch-floor2">Floor 2 Switch</option><option value="dist-switch-floor3">Floor 3 Switch</option><option value="dist-switch-floor4">Floor 4 Switch</option><option value="ap-floor1-zone1">AP Floor 1 Zone 1</option><option value="ap-floor2-zone1">AP Floor 2 Zone 1</option><option value="ap-floor3-zone1">AP Floor 3 Zone 1</option><option value="ap-floor4-zone1">AP Floor 4 Zone 1</option><option value="ups-dc-1">UPS DC-1</option><option value="ups-dc-2">UPS DC-2</option><option value="cooling-1">CRAC Unit 1</option><option value="cooling-2">CRAC Unit 2</option></select>
          <input type="color" id="add-line-color" value="#475569" title="Line color" style="width: 30px;height: 24px;border: 1px solid var(--toolbar-border);border-radius: 4px;cursor: pointer;background: transparent;padding: 0;">     
          <select id="add-line-direction" title="Line direction">
            <option value="none">No arrows</option>
            <option value="forward">→ Forward</option>
            <option value="backward">← Backward</option>
            <option value="both">↔ Both</option>
          </select>
          <button id="add-line-btn">Add</button>
        </div>
        <div class="topology-toolbar bulk-toolbar-desktop" id="bulk-toolbar" style="display: none">
          <button type="button" class="toolbar-close-btn" id="bulk-toolbar-close" title="Clear selection">✕</button>
          <label style="font-weight: 600; color: var(--accent)">Selected: <span id="bulk-count">0</span></label>
          <button id="bulk-align-left" title="Align left">⬅ Left</button>
          <button id="bulk-align-right" title="Align right">➡ Right</button>
          <button id="bulk-align-top" title="Align top">⬆ Top</button>
          <button id="bulk-align-bottom" title="Align bottom">⬇ Bottom</button>
          <button id="bulk-distribute-h" title="Distribute horizontally">↔ Distribute H</button>
          <button id="bulk-distribute-v" title="Distribute vertically">↕ Distribute V</button>
          <button id="bulk-clone" title="Clone selected">📋 Clone</button>
          <button id="bulk-delete" title="Delete selected" style="background: var(--danger); color: white;">Delete</button>
        </div>
        <div class="bulk-toolbar-mobile" id="bulk-toolbar-mobile" style="">
          <button type="button" id="bulk-mobile-btn" style="background: var(--accent);color: white;padding: 12px 20px;border-radius: 25px;font-weight: 600;font-size: 16px;box-shadow: 0 4px 12px rgba(0,0,0,0.3);border: none;cursor: pointer;display: flex;align-items: center;gap: 8px;">
          <span id="bulk-count-mobile">0</span>Selected</button>
        </div>
        <div id="bulk-actions-modal" style="display: none;position: fixed;bottom: 0;left: 0;right: 0;background: var(--panel-alt);border-top-left-radius: 20px;border-top-right-radius: 20px;padding: 20px;padding-bottom: env(safe-area-inset-bottom, 20px);box-shadow: 0 -4px 20px rgba(0,0,0,0.5);z-index: 10000;max-height: calc(100vh - 80px);overflow-y: auto;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            <h3 style="margin: 0; color: var(--accent); font-size: 20px;">
              <span id="bulk-count-modal">0</span> Nodes Selected
            </h3>
            <button id="bulk-modal-close" style="background: none;border: none;font-size: 24px;cursor: pointer;color: var(--text-main);padding: 0;width: 32px;height: 32px;">✕</button>
          </div>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
            <button id="bulk-align-left-mobile" class="bulk-action-btn">⬅<br><span style="font-size: 12px;">Align Left</span></button>
            <button id="bulk-align-right-mobile" class="bulk-action-btn">➡<br><span style="font-size: 12px;">Align Right</span></button>
            <button id="bulk-align-top-mobile" class="bulk-action-btn">⬆<br><span style="font-size: 12px;">Align Top</span></button>
            <button id="bulk-align-bottom-mobile" class="bulk-action-btn">⬇<br><span style="font-size: 12px;">Align Bottom</span></button>
            <button id="bulk-distribute-h-mobile" class="bulk-action-btn">↔<br><span style="font-size: 12px;">Distribute H</span></button>
            <button id="bulk-distribute-v-mobile" class="bulk-action-btn">↕<br><span style="font-size: 12px;">Distribute V</span></button>
            <button id="bulk-lock-mobile" class="bulk-action-btn">🔒<br><span style="font-size: 12px;">Lock Toggle</span></button>
            <button id="bulk-group-mobile" class="bulk-action-btn">⭕<br><span style="font-size: 12px;">Group Toggle</span></button>
            <button id="bulk-clone-mobile" class="bulk-action-btn">📋<br><span style="font-size: 12px;">Clone All</span></button>
            <button id="bulk-delete-mobile" class="bulk-action-btn" style="background: var(--danger); color: white;">🗑<br><span style="font-size: 12px;">Delete All</span></button>
          </div>
          <button id="bulk-clear-mobile" style="width: 100%;margin-top: 16px;padding: 14px;background: var(--panel-main);border: 1px solid var(--edge-main);border-radius: 8px;color: var(--text-main);font-size: 16px;cursor: pointer;">Clear Selection</button>
        </div>
        <div class="canvas-hint" id="canvas-hint">
          <ul>
            <li>Scroll to zoom</li>
            <li>Drag to pan</li>
            <li>Right click to clone and align</li>
            <li>Right click to select multiple</li>
			<li>Hold Shift + drag mouse for marquee selection</li>
            <li>You have the power</li>
            <li>Your time is NOW!</li>
          </ul>
        </div>
        <div class="legend-container" id="edge-legend" style="display: flex;"><div class="legend-title">Line Legend</div><button type="button" class="legend-close-btn">✕</button><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(85, 226, 8); cursor: pointer;"></span><span class="legend-label" contenteditable="true">ISP LINE</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(76, 0, 255); cursor: pointer;"></span><span class="legend-label" contenteditable="true">MY Guest NETWORK</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(128, 255, 0); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(251, 0, 255); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(255, 0, 208); cursor: pointer;"></span><span class="legend-label" contenteditable="true">iPhone (always guest iPhone)</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(249, 115, 22); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div></div>
        <div class="canvas-viewport" id="canvas-viewport">
          <svg id="map" viewBox="-74.99705309342698 -7.395887697909075 4069.861183597212 3052.395887697909" style=""><defs><marker id="arrow-forward" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto" markerUnits="strokeWidth"><path d="M0,0 L0,6 L9,3 z" fill="context-stroke"></path></marker><marker id="arrow-backward" markerWidth="10" markerHeight="10" refX="0" refY="3" orient="auto" markerUnits="strokeWidth"><path d="M9,0 L9,6 L0,3 z" fill="context-stroke"></path></marker></defs><rect x="100" y="100" width="3800" height="2800" fill="none" stroke="#4755694D" stroke-width="20" stroke-dasharray="10 5" rx="8"></rect><g id="canvas-grid"><line x1="100" y1="100" x2="100" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="150" y1="100" x2="150" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="200" y1="100" x2="200" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="250" y1="100" x2="250" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="300" y1="100" x2="300" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="350" y1="100" x2="350" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="400" y1="100" x2="400" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="450" y1="100" x2="450" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="500" y1="100" x2="500" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="550" y1="100" x2="550" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="600" y1="100" x2="600" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="650" y1="100" x2="650" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="700" y1="100" x2="700" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="750" y1="100" x2="750" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="800" y1="100" x2="800" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="850" y1="100" x2="850" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="900" y1="100" x2="900" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="950" y1="100" x2="950" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1000" y1="100" x2="1000" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1050" y1="100" x2="1050" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1100" y1="100" x2="1100" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="1150" y1="100" x2="1150" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1200" y1="100" x2="1200" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1250" y1="100" x2="1250" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1300" y1="100" x2="1300" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1350" y1="100" x2="1350" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="1400" y1="100" x2="1400" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1450" y1="100" x2="1450" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1500" y1="100" x2="1500" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1550" y1="100" x2="1550" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1600" y1="100" x2="1600" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="1650" y1="100" x2="1650" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1700" y1="100" x2="1700" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1750" y1="100" x2="1750" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1800" y1="100" x2="1800" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1850" y1="100" x2="1850" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="1900" y1="100" x2="1900" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1950" y1="100" x2="1950" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2000" y1="100" x2="2000" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2050" y1="100" x2="2050" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2100" y1="100" x2="2100" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="2150" y1="100" x2="2150" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2200" y1="100" x2="2200" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2250" y1="100" x2="2250" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2300" y1="100" x2="2300" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2350" y1="100" x2="2350" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="2400" y1="100" x2="2400" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2450" y1="100" x2="2450" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2500" y1="100" x2="2500" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2550" y1="100" x2="2550" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2600" y1="100" x2="2600" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="2650" y1="100" x2="2650" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2700" y1="100" x2="2700" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2750" y1="100" x2="2750" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2800" y1="100" x2="2800" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2850" y1="100" x2="2850" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="2900" y1="100" x2="2900" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2950" y1="100" x2="2950" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3000" y1="100" x2="3000" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3050" y1="100" x2="3050" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3100" y1="100" x2="3100" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="3150" y1="100" x2="3150" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3200" y1="100" x2="3200" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3250" y1="100" x2="3250" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3300" y1="100" x2="3300" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3350" y1="100" x2="3350" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="3400" y1="100" x2="3400" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3450" y1="100" x2="3450" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3500" y1="100" x2="3500" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3550" y1="100" x2="3550" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3600" y1="100" x2="3600" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="3650" y1="100" x2="3650" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3700" y1="100" x2="3700" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3750" y1="100" x2="3750" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3800" y1="100" x2="3800" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3850" y1="100" x2="3850" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="3900" y1="100" x2="3900" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="100" x2="3900" y2="100" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="150" x2="3900" y2="150" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="200" x2="3900" y2="200" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="250" x2="3900" y2="250" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="300" x2="3900" y2="300" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="350" x2="3900" y2="350" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="400" x2="3900" y2="400" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="450" x2="3900" y2="450" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="500" x2="3900" y2="500" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="550" x2="3900" y2="550" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="600" x2="3900" y2="600" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="650" x2="3900" y2="650" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="700" x2="3900" y2="700" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="750" x2="3900" y2="750" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="800" x2="3900" y2="800" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="850" x2="3900" y2="850" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="900" x2="3900" y2="900" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="950" x2="3900" y2="950" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1000" x2="3900" y2="1000" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1050" x2="3900" y2="1050" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1100" x2="3900" y2="1100" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="1150" x2="3900" y2="1150" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1200" x2="3900" y2="1200" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1250" x2="3900" y2="1250" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1300" x2="3900" y2="1300" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1350" x2="3900" y2="1350" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="1400" x2="3900" y2="1400" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1450" x2="3900" y2="1450" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1500" x2="3900" y2="1500" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1550" x2="3900" y2="1550" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1600" x2="3900" y2="1600" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="1650" x2="3900" y2="1650" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1700" x2="3900" y2="1700" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1750" x2="3900" y2="1750" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1800" x2="3900" y2="1800" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1850" x2="3900" y2="1850" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="1900" x2="3900" y2="1900" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1950" x2="3900" y2="1950" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2000" x2="3900" y2="2000" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2050" x2="3900" y2="2050" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2100" x2="3900" y2="2100" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="2150" x2="3900" y2="2150" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2200" x2="3900" y2="2200" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2250" x2="3900" y2="2250" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2300" x2="3900" y2="2300" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2350" x2="3900" y2="2350" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="2400" x2="3900" y2="2400" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2450" x2="3900" y2="2450" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2500" x2="3900" y2="2500" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2550" x2="3900" y2="2550" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2600" x2="3900" y2="2600" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="2650" x2="3900" y2="2650" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2700" x2="3900" y2="2700" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2750" x2="3900" y2="2750" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2800" x2="3900" y2="2800" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2850" x2="3900" y2="2850" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="2900" x2="3900" y2="2900" stroke="#47556933" stroke-width="1"></line></g><g class="rect-group" data-rect-id="rect-1765238219615"><rect class="rect-shape" x="2680.053955078125" y="251.44879150390625" width="814.10400390625" height="389.26678466796875" style="fill: rgb(236, 9, 153); fill-opacity: 0.3; stroke: rgb(236, 9, 153); stroke-width: 2px; stroke-dasharray: none; cursor: move;"></rect><g class="rect-delete-btn" style="cursor: pointer; display: none;"><circle cx="3484.157958984375" cy="261.44879150390625" r="12" style="fill: rgb(245, 101, 101); stroke: white; stroke-width: 2;"></circle><text x="3484.157958984375" y="261.44879150390625" text-anchor="middle" dominant-baseline="middle" style="fill: white; font-size: 16px; font-weight: bold; pointer-events: none;">×</text></g></g><path d="M 2071.640165880771 218.24354238566275 Q 2069.3039587352528 345.82772790170964 2066.9677515897347 473.4119134177565" fill="none" class="edge" data-edge-id="internet-internet-copy-1765238145151" data-from="internet" data-to="internet-copy" style="stroke: rgb(85, 226, 8); stroke-width: 4;"></path><path d="M 2071.640165880771 218.24354238566275 Q 2069.3039587352528 345.82772790170964 2066.9677515897347 473.4119134177565" fill="none" data-edge-id="internet-internet-copy-1765238145151" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 1921.3019190702034 570.8918786277175 1775.6360865506722 668.3718438376784" fill="none" class="edge" data-edge-id="internet-copy-opnsense-copy-1765238187451" data-from="internet-copy" data-to="opnsense-copy" style="stroke: rgb(76, 0, 255); stroke-width: 4;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 1921.3019190702034 570.8918786277175 1775.6360865506722 668.3718438376784" fill="none" data-edge-id="internet-copy-opnsense-copy-1765238187451" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2000.8787827715962 627.8447547749242 1934.7898139534577 782.2775961320921" fill="none" class="edge" data-edge-id="internet-copy-docker-copy-1765238242477" data-from="internet-copy" data-to="docker-copy" style="stroke: rgb(76, 0, 255); stroke-width: 4;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2000.8787827715962 627.8447547749242 1934.7898139534577 782.2775961320921" fill="none" data-edge-id="internet-copy-docker-copy-1765238242477" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2112.546995662221 620.5620704487524 2158.1262397347077 767.7122274797483" fill="none" class="edge" data-edge-id="internet-copy-docker-copy-1-1765238244637" data-from="internet-copy" data-to="docker-copy-1" style="stroke: rgb(76, 0, 255); stroke-width: 4;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2112.546995662221 620.5620704487524 2158.1262397347077 767.7122274797483" fill="none" data-edge-id="internet-copy-docker-copy-1-1765238244637" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2206.4130845294085 552.590055067893 2345.8584174690827 631.7681967180296" fill="none" class="edge" data-edge-id="internet-copy-docker-copy-2-1765238246233" data-from="internet-copy" data-to="docker-copy-2" style="stroke: rgb(76, 0, 255); stroke-width: 4;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2206.4130845294085 552.590055067893 2345.8584174690827 631.7681967180296" fill="none" data-edge-id="internet-copy-docker-copy-2-1765238246233" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2071.640165880771 218.24354238566275 Q 2414.759822984287 262.92762699742593 2757.879480087803 307.6117116091891" fill="none" class="edge" data-edge-id="internet-opnsense-copy-1-1765238266117" data-from="internet" data-to="opnsense-copy-1" style="stroke: rgb(128, 255, 0); stroke-width: 4;"></path><path d="M 2071.640165880771 218.24354238566275 Q 2414.759822984287 262.92762699742593 2757.879480087803 307.6117116091891" fill="none" data-edge-id="internet-opnsense-copy-1-1765238266117" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2757.879480087803 307.6117116091891 Q 2979.171899521397 314.04065142852505 3200.4643189549906 320.469591247861" fill="none" class="edge" data-edge-id="opnsense-copy-1-dns-1765238347996" data-from="opnsense-copy-1" data-to="dns" style="stroke: rgb(251, 0, 255); stroke-width: 4;"></path><path d="M 2757.879480087803 307.6117116091891 Q 2979.171899521397 314.04065142852505 3200.4643189549906 320.469591247861" fill="none" data-edge-id="opnsense-copy-1-dns-1765238347996" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 3200.4643189549906 320.469591247861 Q 3094.0802247167094 404.02690325957974 2987.696130478428 487.5842152712985" fill="none" class="edge" data-edge-id="dns-desktop-1765238386101" data-from="dns" data-to="desktop" style="stroke: rgb(255, 0, 208); stroke-width: 4;"></path><path d="M 3200.4643189549906 320.469591247861 Q 3094.0802247167094 404.02690325957974 2987.696130478428 487.5842152712985" fill="none" data-edge-id="dns-desktop-1765238386101" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 3312.857751572178 502.58220111114224 Q 3256.6610352635844 411.5258961795016 3200.4643189549906 320.469591247861" fill="none" class="edge" data-edge-id="phone-dns-1765238391156" data-from="phone" data-to="dns" style="stroke: rgb(255, 0, 208); stroke-width: 4;"></path><path d="M 3312.857751572178 502.58220111114224 Q 3256.6610352635844 411.5258961795016 3200.4643189549906 320.469591247861" fill="none" data-edge-id="phone-dns-1765238391156" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><polyline class="edge" data-edge-id="custom-1765238841477" fill="none" marker-start="url(#arrow-backward)" marker-end="url(#arrow-forward)" points="2905.255615234375,805.3433837890625 3189.95556640625,1005.8710327148438 2788.900390625,1008.3466796875" style="stroke: rgb(249, 115, 22); stroke-width: 4; stroke-dasharray: none;"></polyline><polyline points="2905.255615234375,805.3433837890625 3189.95556640625,1005.8710327148438 2788.900390625,1008.3466796875" data-edge-id="custom-1765238841477" style="fill: none; stroke: transparent; stroke-width: 20; cursor: pointer;"></polyline><g class="node-group" data-node-id="internet" transform="translate(2071.640165880771,218.24354238566275)" style="cursor: grab;"><circle r="127.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><rect x="-85" y="-85" width="170" height="170" rx="4" class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"></rect><text class="node-label" x="0" y="-23.8" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Internet</text><text class="node-sub" x="0" y="34" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="internet-copy" transform="translate(2066.9677515897347,473.4119134177565)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-55" y="-44" width="110" height="88" rx="4"></rect><line x1="-46.75" y1="-27.5" x2="46.75" y2="-27.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="-2.75" x2="46.75" y2="-2.75" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="22" x2="46.75" y2="22" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="-44" x2="-27.5" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="-44" x2="11" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="-19.25" x2="-8.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="-19.25" x2="30.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="5.5" x2="-27.5" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="5.5" x2="11" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="30.25" x2="-8.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="30.25" x2="30.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">OPNSENSE</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="opnsense-copy" transform="translate(1775.6360865506722,668.3718438376784)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-55" y="-44" width="110" height="88" rx="4"></rect><line x1="-46.75" y1="-27.5" x2="46.75" y2="-27.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="-2.75" x2="46.75" y2="-2.75" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="22" x2="46.75" y2="22" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="-44" x2="-27.5" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="-44" x2="11" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="-19.25" x2="-8.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="-19.25" x2="30.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="5.5" x2="-27.5" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="5.5" x2="11" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="30.25" x2="-8.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="30.25" x2="30.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Docker</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="docker-copy" transform="translate(1934.7898139534577,782.2775961320921)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-55" y="-44" width="110" height="88" rx="4"></rect><line x1="-46.75" y1="-27.5" x2="46.75" y2="-27.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="-2.75" x2="46.75" y2="-2.75" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="22" x2="46.75" y2="22" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="-44" x2="-27.5" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="-44" x2="11" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="-19.25" x2="-8.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="-19.25" x2="30.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="5.5" x2="-27.5" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="5.5" x2="11" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="30.25" x2="-8.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="30.25" x2="30.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Docker2</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="docker-copy-1" transform="translate(2158.1262397347077,767.7122274797483)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-55" y="-44" width="110" height="88" rx="4"></rect><line x1="-46.75" y1="-27.5" x2="46.75" y2="-27.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="-2.75" x2="46.75" y2="-2.75" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="22" x2="46.75" y2="22" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="-44" x2="-27.5" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="-44" x2="11" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="-19.25" x2="-8.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="-19.25" x2="30.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="5.5" x2="-27.5" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="5.5" x2="11" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="30.25" x2="-8.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="30.25" x2="30.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Docker3</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="docker-copy-2" transform="translate(2345.8584174690827,631.7681967180296)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-55" y="-44" width="110" height="88" rx="4"></rect><line x1="-46.75" y1="-27.5" x2="46.75" y2="-27.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="-2.75" x2="46.75" y2="-2.75" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="22" x2="46.75" y2="22" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="-44" x2="-27.5" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="-44" x2="11" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="-19.25" x2="-8.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="-19.25" x2="30.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="5.5" x2="-27.5" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="5.5" x2="11" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="30.25" x2="-8.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="30.25" x2="30.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Docker 4</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="opnsense-copy-1" transform="translate(2757.879480087803,307.6117116091891)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-55" y="-44" width="110" height="88" rx="4"></rect><line x1="-46.75" y1="-27.5" x2="46.75" y2="-27.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="-2.75" x2="46.75" y2="-2.75" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="22" x2="46.75" y2="22" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="-44" x2="-27.5" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="-44" x2="11" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="-19.25" x2="-8.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="-19.25" x2="30.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="5.5" x2="-27.5" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="5.5" x2="11" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="30.25" x2="-8.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="30.25" x2="30.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">OPNSENSE GUEST</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="phone" transform="translate(3312.857751572178,502.58220111114224)" style="cursor: grab;"><circle r="181.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-54.45" y="-121" width="108.9" height="242" rx="8"></rect><rect x="-45.980000000000004" y="-102.85" width="91.96000000000001" height="193.60000000000002" rx="4" style="fill: rgb(30, 41, 59);"></rect><rect x="-18.15" y="99.22" width="36.3" height="7.26" rx="2" style="fill: rgb(71, 85, 105);"></rect></g><text class="node-label" x="0" y="-33.88" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Phone</text><text class="node-sub" x="0" y="48.400000000000006" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="desktop" transform="translate(2987.696130478428,487.5842152712985)" style="cursor: grab;"><circle r="220.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-132.3" y="-117.60000000000001" width="264.6" height="176.4" rx="4"></rect><rect x="-110.25" y="-95.55" width="220.5" height="132.3" rx="2" style="fill: rgb(30, 41, 59);"></rect><rect x="-22.05" y="58.800000000000004" width="44.1" height="44.1"></rect><rect x="-73.5" y="102.89999999999999" width="147" height="22.05" rx="2"></rect></g><text class="node-label" x="0" y="-41.160000000000004" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Desktop</text><text class="node-sub" x="0" y="58.800000000000004" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="dns" transform="translate(3200.4643189549906,320.469591247861)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><path d="
             M -44 11
             Q -60.50000000000001 11 -60.50000000000001 -5.5
             Q -60.50000000000001 -27.5 -38.5 -27.5
             Q -38.5 -49.5 -11 -49.5
             Q 5.5 -60.50000000000001 27.5 -44
             Q 55 -44 60.50000000000001 -16.5
             Q 71.5 -5.5 60.50000000000001 11
             Q 60.50000000000001 27.5 38.5 27.5
             L -27.5 27.5
             Q -49.5 27.5 -49.5 11
             Z
            " class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"></path><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">DNS</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="racked" transform="translate(2600.8697010779656,975.5665527522032)" style="cursor: grab;"><circle r="205.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-164.4" y="-82.2" width="328.8" height="164.4" rx="4"></rect><line x1="-123.3" y1="-41.1" x2="-123.3" y2="41.1" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="-54.8" y1="-41.1" x2="-54.8" y2="41.1" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="13.700000000000003" y1="-41.1" x2="13.700000000000003" y2="41.1" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><circle cx="123.3" cy="0" r="13.700000000000001" style="fill: rgb(74, 222, 128);"></circle></g><text class="node-label" x="0" y="-38.36000000000001" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Racked</text><text class="node-sub" x="0" y="54.800000000000004" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;"></text></g><g class="text-group" data-text-id="text-1765238422602"><text class="text-element" x="2402.130859375" y="736.7828979492188" dominant-baseline="middle" style="fill: rgb(226, 232, 240); font-size: 48px; font-weight: normal; font-style: normal; text-anchor: start; text-decoration: none; opacity: 1; cursor: move; user-select: none;"><tspan x="2402.130859375" dy="0">Double click on desktop</tspan><tspan x="2402.130859375" dy="57.599999999999994">or long press on mobile</tspan><tspan x="2402.130859375" dy="57.599999999999994">to enter rack canvas view</tspan></text><g class="text-delete-btn" style="cursor: pointer; display: none;"><circle cx="2422.130859375" cy="688.7828979492188" r="12" style="fill: rgb(245, 101, 101); stroke: white; stroke-width: 2;"></circle><text x="2422.130859375" y="688.7828979492188" text-anchor="middle" dominant-baseline="middle" style="fill: white; font-size: 16px; font-weight: bold; pointer-events: none;">×</text></g></g></svg>
        </div>
        <div class="minimap-zoom-wrapper" id="minimap-zoom-wrapper" style="display: block;">
          <button type="button" class="minimap-close-btn" id="minimap-close-btn" title="Hide map &amp; zoom">✕</button>
          <div class="minimap-container" id="minimap-container">
            <svg id="minimap" viewBox="0 0 4000 3000">
              <line x1="2071.640165880771" y1="218.24354238566275" x2="2066.9677515897347" y2="473.4119134177565" class="minimap-edge"></line><line x1="2066.9677515897347" y1="473.4119134177565" x2="1775.6360865506722" y2="668.3718438376784" class="minimap-edge"></line><line x1="2066.9677515897347" y1="473.4119134177565" x2="1934.7898139534577" y2="782.2775961320921" class="minimap-edge"></line><line x1="2066.9677515897347" y1="473.4119134177565" x2="2158.1262397347077" y2="767.7122274797483" class="minimap-edge"></line><line x1="2066.9677515897347" y1="473.4119134177565" x2="2345.8584174690827" y2="631.7681967180296" class="minimap-edge"></line><line x1="2071.640165880771" y1="218.24354238566275" x2="2757.879480087803" y2="307.6117116091891" class="minimap-edge"></line><line x1="2757.879480087803" y1="307.6117116091891" x2="3200.4643189549906" y2="320.469591247861" class="minimap-edge"></line><line x1="3200.4643189549906" y1="320.469591247861" x2="2987.696130478428" y2="487.5842152712985" class="minimap-edge"></line><line x1="3312.857751572178" y1="502.58220111114224" x2="3200.4643189549906" y2="320.469591247861" class="minimap-edge"></line><circle cx="2071.640165880771" cy="218.24354238566275" r="40" class="minimap-node"></circle><circle cx="2066.9677515897347" cy="473.4119134177565" r="40" class="minimap-node"></circle><circle cx="1775.6360865506722" cy="668.3718438376784" r="40" class="minimap-node"></circle><circle cx="1934.7898139534577" cy="782.2775961320921" r="40" class="minimap-node"></circle><circle cx="2158.1262397347077" cy="767.7122274797483" r="40" class="minimap-node"></circle><circle cx="2345.8584174690827" cy="631.7681967180296" r="40" class="minimap-node"></circle><circle cx="2757.879480087803" cy="307.6117116091891" r="40" class="minimap-node"></circle><circle cx="3312.857751572178" cy="502.58220111114224" r="40" class="minimap-node"></circle><circle cx="2987.696130478428" cy="487.5842152712985" r="40" class="minimap-node"></circle><circle cx="3200.4643189549906" cy="320.469591247861" r="40" class="minimap-node"></circle><circle cx="2600.8697010779656" cy="975.5665527522032" r="40" class="minimap-node"></circle><rect class="minimap-viewport" id="minimap-viewport" x="-74.99705309342698" y="-7.395887697909075" width="4069.861183597212" height="3052.395887697909"></rect>
            </svg>
          </div>
          <div class="zoom-toolbar" id="zoom-toolbar">
            <button id="zoom-in-btn" title="Zoom in">+</button>
            <div class="zoom-level" id="zoom-level">98%</div>
            <button id="zoom-out-btn" title="Zoom out">-</button>
            <div class="divider"></div>
            <button id="zoom-fit-btn" title="Fit to view">[ ]</button>
            <button id="zoom-reset-btn" title="Reset view">R</button>
          </div>
        </div>
        <button type="button" id="edge-legend-mini" class="legend-mini-btn" style="bottom: 10px; display: none;">Line Legend</button>
        <button type="button" id="minimap-mini" class="legend-mini-btn" style="right: 10px; left: auto; bottom: 10px; display: none;">Map</button>
        <button type="button" id="draw-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: 10px; right: auto;">Draw</button>
        <button type="button" id="topology-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: auto; right: 40px;">Add Line</button></section>
      <aside class="details-panel" id="details-panel">
        <div class="sidebar-resizer" id="sidebar-resizer">
          <svg class="resizer-icon" width="6" height="40" viewBox="0 0 6 40" xmlns="http://www.w3.org/2000/svg">
            <circle cx="3" cy="14" r="2"></circle>
            <circle cx="3" cy="20" r="2"></circle>
            <circle cx="3" cy="26" r="2"></circle>
          </svg>
        </div>
        <div class="mobile-footer-resizer" id="mobile-footer-resizer">
          <svg class="resizer-icon" width="40" height="6" viewBox="0 0 40 6" xmlns="http://www.w3.org/2000/svg">
            <circle cx="14" cy="3" r="2"></circle>
            <circle cx="20" cy="3" r="2"></circle>
            <circle cx="26" cy="3" r="2"></circle>
          </svg>
        </div>
        <div id="node-panel" style="display: none;">
          <div class="details-name editable-text" id="node-name">Core Router 1</div>
          <div class="details-ip editable-text" id="node-ip">10.0.0.1</div>
          <div class="details-role" id="node-role">Core Routing</div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px;">MAC:</span>
            <span class="editable-text" id="node-mac" style="margin-left: 8px; font-size: 14px;">00:1A:2B:3C:4D:01</span>
          </div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px;">Rack Unit:</span>
            <span class="editable-text" id="node-rack" style="margin-left: 8px; font-size: 14px;">--</span>
          </div>
          <div class="details-info-row" id="uheight-row" style="display: none;">
            <span style="color: var(--text-soft); font-size: 14px;">U Height:</span>
            <span class="editable-text" id="node-uheight" style="margin-left: 8px; font-size: 14px;">2U</span>
          </div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px;">Layer:</span>
            <select id="node-layer" style="margin-left: 8px; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;">
              <option value="physical">Physical</option>
              <option value="logical">Logical</option>
              <option value="security">Security</option>
              <option value="application">Application</option>
            </select>
          </div>
          <div class="details-info-row" id="assigned-rack-row" style="display: flex;">
            <span style="color: var(--text-soft); font-size: 14px;">Assigned Rack:</span>
            <select id="node-assigned-rack" style="margin-left: 8px; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;"><option value="">None</option><option value="racked">Racked</option></select>
          </div>
          <div class="details-info-row" id="rack-capacity-row" style="display: none;">
            <span style="color: var(--text-soft); font-size: 14px;">Rack Capacity:</span>
            <select id="node-rack-capacity" style="margin-left: 8px; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;">
              <option value="42">42U</option>
              <option value="48">48U</option>
              <option value="24">24U</option>
              <option value="12">12U</option>
			  <option value="6">6U</option>
            </select>
          </div>
		  <details id="rack-contents-section" style="display: none; margin-top: 12px; margin-bottom: 12px; padding: 10px; background: var(--panel-alt); border-radius: 6px;" open="">
            <summary style="color: var(--accent); font-weight: 600; font-size: 14px; cursor: pointer;">Nodes in Rack (<span id="rack-contents-count">0</span>)</summary>
            <div id="rack-contents-list" style="max-height: 200px; overflow-y: auto; margin-top: 8px;"></div>
          </details>
          <div class="badge-row" id="node-tags"><span class="badge" style="cursor: pointer; position: relative;"><span>core</span><span style="opacity: 0.6; margin-left: 4px; font-size: 10px;"> ✕</span></span><span class="badge" style="cursor: pointer; position: relative;"><span>tier-1</span><span style="opacity: 0.6; margin-left: 4px; font-size: 10px;"> ✕</span></span><span class="badge" style="cursor: pointer; position: relative;"><span>redundant</span><span style="opacity: 0.6; margin-left: 4px; font-size: 10px;"> ✕</span></span><span class="badge" style="cursor: pointer; opacity: 0.6; border-style: dashed;">+ Add Tag</span></div>
          <div class="size-controls">
            <label>Size:</label>
            <input type="range" id="size-slider" min="20" max="200" value="55">
            <span id="size-value">55</span>
            <button id="reset-size">Reset</button>
          </div>
          <details class="style-section">
            <summary>Styling</summary>
            <div class="style-content">
              <div class="style-row">
                <label>Screen:</label>
                <select id="style-scope">
                  <option value="all">All</option>
                  <option value="desktop">Desktop</option>
                  <option value="tablet">Tablet</option>
                  <option value="mobile">Mobile</option>
                  <option value="fold">Fold</option>
                </select>
              </div>
              <div class="style-row">
                <label>Shape:</label>
                <select id="shape-select">
                  <optgroup label="Basic Shapes">
				  <option value="circle">Circle</option>
				  <option value="square">Square</option>
				  <option value="rectangle">Rectangle</option>
				  <option value="triangle">Triangle</option>
				  <option value="hexagon">Hexagon</option>
				  <option value="diamond">Diamond</option>
				  <option value="star">Star</option>
				  <option value="stop-sign">Stop Sign</option>
				  <option value="octagon">Octagon</option>
				  <option value="pentagon">Pentagon</option>
				  <option value="cross">Cross</option>
				  <option value="rounded-square">Rounded Square</option>
				  <option value="pill">Pill</option>
				  <option value="parallelogram">Parallelogram</option>
				  <option value="trapezoid">Trapezoid</option>
				</optgroup>
			  <optgroup label="Computers &amp; Devices">
			      <option value="server">Server</option>
				  <option value="pc">PC / Desktop</option>
				  <option value="laptop">Laptop</option>
				  <option value="phone">Phone / Mobile</option>
				  <option value="printer">Printer</option>
				  <option value="pi">Raspberry Pi</option>
				  <option value="sensor">Sensor / IoT</option>
			  </optgroup>
			  <optgroup label="Network Equipment">
				  <option value="router">Router</option>
				  <option value="switch">Switch</option>
				  <option value="firewall">Firewall</option>
				  <option value="access-point">Access Point</option>
				  <option value="load-balancer">Load Balancer</option>
				  <option value="gateway">Gateway</option>
				  <option value="vpn">VPN / Tunnel</option>
				  <option value="nas">NAS / Storage</option>
			  </optgroup>
			  <optgroup label="Cloud &amp; Services">
			      <option value="cloud">Cloud</option>
				  <option value="database">Database</option>
				  <option value="docker">Docker</option>
				  <option value="container">Container</option>
				  <option value="vm">Virtual Machine</option>
				  <option value="kubernetes">Kubernetes</option>
				  <option value="api">API / Endpoint</option>
				  <option value="queue">Queue / Message</option>
				  <option value="lambda">Lambda / Function</option>
				  <option value="bucket">Bucket / S3</option>
			  </optgroup>
			  <optgroup label="Security &amp; Monitoring">
				  <option value="shield">Shield</option>
				  <option value="camera">Camera / CCTV</option>
				  <option value="monitor">Monitor / Dashboard</option>
			  </optgroup>
             </select>
              </div>
              <div class="style-row">
                <label>Fill Color:</label>
                <input type="color" id="circle-color" value="#1e293b">
              </div>
              <div class="style-row">
                <label>Border Color:</label>
                <input type="color" id="circle-border" value="#475569">
              </div>
              <div class="style-row">
                <label>Title Color:</label>
                <input type="color" id="title-color" value="#e2e8f0">
              </div>
              <div class="style-row">
                <label>Title Font:</label>
                <select id="title-font">
                  <option value="system-ui, sans-serif"> System UI </option>
                  <option value="monospace">Monospace</option>
                  <option value="serif">Serif</option>
                  <option value="cursive">Cursive</option>
                  <option value="'Courier New', monospace"> Courier </option>
                  <option value="Arial, sans-serif">Arial</option>
                  <option value="'Times New Roman', serif"> Times </option>
                </select>
              </div>
              <div class="style-row">
                <label>Title Size:</label>
                <input type="number" id="title-size" min="8" max="100" value="18">
              </div>
              <div class="style-row">
                <label>Sub Color:</label>
                <input type="color" id="sub-color" value="#94a3b8">
              </div>
              <div class="style-row">
                <label>Sub Font:</label>
                <select id="sub-font">
                  <option value="system-ui, sans-serif"> System UI </option>
                  <option value="monospace">Monospace</option>
                  <option value="serif">Serif</option>
                  <option value="cursive">Cursive</option>
                  <option value="'Courier New', monospace"> Courier </option>
                  <option value="Arial, sans-serif">Arial</option>
                  <option value="'Times New Roman', serif"> Times </option>
                </select>
              </div>
              <div class="style-row">
                <label>Sub Size:</label>
                <input type="number" id="sub-size" min="6" max="80" value="13">
              </div>
              <div style="margin-top: 12px;padding-top: 10px;border-top: 1px solid var(--edge-main);">
                <div style="
                  font-size: 12px;
                  color: var(--text-soft);
                  margin-bottom: 8px;
                  text-transform: uppercase;
                  "> Text Position </div>
                <div class="style-row">
                  <label>Name Y:</label>
                  <input type="number" id="title-offset-y" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>Name X:</label>
                  <input type="number" id="title-offset-x" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>IP Y:</label>
                  <input type="number" id="sub-offset-y" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>IP X:</label>
                  <input type="number" id="sub-offset-x" min="-100" max="100" value="0" style="width: 60px">
                </div>
              </div>
              <button id="reset-styles" style="width: 100%;margin-top: 10px;padding: 8px;background: var(--panel);color: var(--text-main);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: clamp(13px, 1.5vw, 17px);">Reset Styles</button>
            </div>
          </details>
          <div class="section-label">Notes</div>
          <ul class="list" id="node-notes"><li><span style="flex: 1 1 0%;">Primary core router</span><span class="delete-note">✕</span></li><li><span style="flex: 1 1 0%;">BGP peering enabled</span><span class="delete-note">✕</span></li></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-note-input" placeholder="Type new note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-note-btn" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-node-btn" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: rgb(255, 255, 255);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;width: 100%;">Delete Node</button>
        </div>
        <div id="edge-panel" style="display: none">
          <div class="details-name" id="edge-title">Custom line</div>
          <div class="style-row" style="margin-top: 10px">
            <label>Width:</label>
            <input type="number" id="edge-width" min="1" max="20" value="4">
          </div>
          <div class="style-row">
            <label>Color:</label>
            <input type="color" id="edge-color" value="#475569">
          </div>
          <div class="style-row">
            <label>Line Style:</label>
            <select id="edge-line-style">
              <option value="solid">Solid</option>
              <option value="dashed">Dashed</option>
              <option value="dotted">Dotted</option>
            </select>
          </div>
          <div class="style-row">
            <label>Direction:</label>
            <select id="edge-direction">
              <option value="none">No arrows</option>
              <option value="forward">→ Forward</option>
              <option value="backward">← Backward</option>
              <option value="both">↔ Bidirectional</option>
            </select>
          </div>
          <div class="style-row" id="edge-from-port-row" style="display: none;">
            <label>From Port:</label>
            <input type="text" id="edge-from-port" placeholder="e.g. eth0, gi0/1" style="flex: 1;">
          </div>
          <div class="style-row" id="edge-to-port-row" style="display: none;">
            <label>To Port:</label>
            <input type="text" id="edge-to-port" placeholder="e.g. eth1, gi0/2" style="flex: 1;">
          </div>
          <div class="section-label">Line Notes</div>
          <ul class="list" id="edge-notes"></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-edge-note" placeholder="Add note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-edge-note" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-edge" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Delete Line</button>
        </div>
        <div id="rect-panel" style="display: none">
          <div class="details-name" id="rect-title">Zone</div>
          <div class="style-row" id="rect-fill-row" style="margin-top: 10px">
            <label>Fill Color:</label>
            <input type="color" id="rect-color" value="#f97316">
          </div>
          <div class="style-row">
            <label>Border Color:</label>
            <input type="color" id="rect-border-color" value="#f97316">
          </div>
          <div class="style-row">
            <label>Border Width:</label>
            <input type="number" id="rect-border-width" min="0" max="20" value="2">
          </div>
          <div class="style-row">
            <label>Style:</label>
            <select id="rect-style-select">
              <option value="filled">Filled</option>
              <option value="outlined">Outlined</option>
            </select>
          </div>
          <div class="style-row">
            <label>Line Style:</label>
            <select id="rect-line-style">
              <option value="solid">Solid</option>
              <option value="dashed">Dashed</option>
              <option value="dotted">Dotted</option>
            </select>
          </div>
          <div class="section-label">Zone Notes</div>
          <ul class="list" id="rect-notes"></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-rect-note" placeholder="Add note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-rect-note" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-rect" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Delete Zone</button>
        </div>
        <div id="text-panel" style="display: none">
          <div class="details-name" id="text-title">Text Element</div>
          <div class="style-row" style="margin-top: 10px">
            <label>Content:</label>
            <textarea id="text-content" placeholder="Enter text..." style="width: 100%;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: 14px;min-height: 80px;resize: vertical;font-family: inherit;"></textarea>
          </div>
          <div class="style-row">
            <label>Font Size:</label>
            <input type="number" id="text-font-size" min="8" max="200" value="18" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);">
          </div>
          <div class="style-row">
            <label>Color:</label>
            <input type="color" id="text-color" value="#e2e8f0">
          </div>
          <div class="style-row">
            <label>Font Weight:</label>
            <select id="text-font-weight" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="normal">Normal</option>
              <option value="bold">Bold</option>
              <option value="600">Semi-Bold</option>
              <option value="300">Light</option>
            </select>
          </div>
          <div class="style-row">
            <label>Font Style:</label>
            <select id="text-font-style" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="normal">Normal</option>
              <option value="italic">Italic</option>
            </select>
          </div>
          <div class="style-row">
            <label>Text Align:</label>
            <select id="text-align" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="start">Left</option>
              <option value="middle">Center</option>
              <option value="end">Right</option>
            </select>
          </div>
          <div class="style-row">
            <label>Text Decoration:</label>
            <select id="text-decoration" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="none">None</option>
              <option value="underline">Underline</option>
              <option value="line-through">Strike Through</option>
            </select>
          </div>
          <div class="style-row">
            <label>Background:</label>
            <input type="color" id="text-bg-color" value="#000000">
            <label style="margin-left: 10px; display: flex; align-items: center; gap: 6px;">
            <input type="checkbox" id="text-bg-enabled" style="cursor: pointer;">
            <span style="font-size: 13px;">Enable</span>
            </label>
          </div>
          <div class="style-row">
            <label>Opacity:</label>
            <input type="range" id="text-opacity" min="0" max="1" step="0.1" value="1" style="flex: 1">
            <span id="text-opacity-val" style="min-width: 35px; text-align: right">100%</span>
          </div>
          <button id="delete-text" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;width: 100%;"> Delete Text </button>
        </div>
        <details class="style-section" open="">
          <summary>Page Layout</summary>
          <div class="style-content">
            <div style="padding: 12px; background: var(--panel-alt); border-radius: 6px; color: var(--text-soft); font-size: 13px; line-height: 1.6;">
              <strong style="color: var(--accent); display: block; margin-bottom: 8px;">Drag to Resize:</strong>
              • <strong>Header:</strong> Drag the bottom edge of the header bar<br>
              • <strong>Sidebar:</strong> Drag the left edge of the sidebar panel<br>
              • <strong>Mobile:</strong> Drag the top edge of the footer panel<br>
              <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--edge-main); font-size: 12px;">
                Hover over panel edges to see resize handles
              </div>
            </div>
          </div>
        </details>
      </aside>
    </main>
    <script id="nodes-json" type="application/json">{}</script>
    <script id="topology-state" type="application/json">ENCRYPTED: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</script>
    <script>
      const BASE_NODE_DATA = JSON.parse(document.getElementById("nodes-json").textContent, );
      let currentNodeId = "host";
      let textDrawMode = false;
      let currentEdgeId = null;
      let currentStyleScope = "all";
      let NODE_DATA = {};
      let EDGE_DATA = {
       list: []
      };
      let currentRectId = null;
      let currentTextId = null;
      let rectDrawMode = false;
      let RECT_DATA = {
       list: []
      };
      let TEXT_DATA = {
       list: []
      };
      let EDGE_LEGEND = {};
      let freeDrawMode = false;
      let savedPositions = {};
      let savedSizes = {};
      let savedStyles = {};
      let legendCollapsed = false;
      let minimapCollapsed = false;
      let drawToolbarCollapsed = false;
      let activeLayers = new Set(["physical", "logical", "security", "application"]);
      let currentView = {
       mode: "topology",  
       rackId: null      
      };
      let savedTopologyView = null; 
      let topologyToolbarCollapsed = false;
      let legendMiniBtn = null;
      let minimapMiniBtn = null;
      let drawToolbarMiniBtn = null;
      let topologyToolbarMiniBtn = null;
      
      let undoStack = [];
      let redoStack = [];
      const MAX_UNDO_STACK = 50;
      
      let selectedNodes = new Set();
      let selectedEdges = new Set();
      let selectedRects = new Set();
      let selectedTexts = new Set();
      let isSelecting = false;
      let selectionStart = null;
      let preDragSelectedNodes = new Set();
      let preDragSelectedEdges = new Set();
      let preDragSelectedRects = new Set();
      let preDragSelectedTexts = new Set();
      let selectionRect = null;
      let selectionBoxStyle = {
       fillColor: "#4fd1c5",
       fillOpacity: 0.1,
       strokeColor: "#4fd1c5",
       strokeWidth: 2,
       strokeDasharray: "5,5"
      };
      let isDraggingSelection = false;
      let dragSelectionStart = null;
      
      let clipboard = null;
      
      const ROLLBACK_STORAGE_KEY = "theonefile_rollbacks";
      const MAX_ROLLBACK_VERSIONS = 50;
      let rollbackVersions = [];
      let currentRollbackIndex = -1;
      
      const AUDIT_STORAGE_KEY = "theonefile_audit_log";
      let auditLog = [];
      const MAX_AUDIT_ENTRIES = 1000;
      
      let documentTabs = [{
        id: "main",
        name: "Main Topology",
        nodes: {},
        edges: { list: [] },
        positions: {},
        sizes: {},
        styles: {},
        legend: {},
        rects: { list: [] },
        texts: { list: [] },
      pageState: null
      }];
      let currentTabIndex = 0;
      
      let encryptedSections = {}; 
      
      let performanceMode = "auto"; 
      let cullOffscreenNodes = true;
      let minimapNeedsUpdate = true;
      let lastMinimapUpdate = 0;
      
      const MobileManager = {
        isMobile: false,
        detect() {
          if (navigator.userAgentData?.mobile === true) {
            this.isMobile = true;
            return true;
          }
          const coarse = matchMedia("(pointer: coarse)").matches;
          const width = window.innerWidth <= 900;
          const portrait = matchMedia("(orientation: portrait)").matches;
          this.isMobile = coarse && (width || portrait);
          return this.isMobile;
        },
        applyInitialCollapse() {
          if (!this.isMobile) return;
          legendCollapsed = true;
          minimapCollapsed = true;
          drawToolbarCollapsed = true;
          topologyToolbarCollapsed = true;
          if (typeof updateLegendVisibility === "function") updateLegendVisibility();
          if (typeof updateMinimapVisibility === "function") updateMinimapVisibility();
          if (typeof updateDrawToolbarVisibility === "function") updateDrawToolbarVisibility();
          if (typeof updateTopologyToolbarVisibility === "function") updateTopologyToolbarVisibility();
        },
        updateBulkToolbar() {
          const desktop = document.getElementById("bulk-toolbar");
          const mobile = document.getElementById("bulk-toolbar-mobile");
          if (!desktop || !mobile) return;
          
          if (typeof selectedNodes === 'undefined' || selectedNodes.size === 0) {
           desktop.style.display = "none";
           mobile.style.display = "none";
           return;
          }
      
          const isVisible = desktop.style.display !== "none" || mobile.style.display !== "none";
          
          if (this.isMobile) {
            desktop.style.display = "none";
            if (isVisible) {
              mobile.style.display = "flex";
            }
          } else {
            mobile.style.display = "none";
            if (isVisible) {
              desktop.style.display = "flex";
            }
          }
        },
        updateLayout() {
          const main = document.querySelector("main");
          if (!main) return;
        },
        updateCanvasHint() {
      const hint = document.getElementById("canvas-hint");
      if (!hint) return;
      
      if (PAGE_STATE.canvasHintText !== undefined && PAGE_STATE.canvasHintText !== "") {
        hint.innerHTML = PAGE_STATE.canvasHintText;
        return;
      }
      
      const items = this.isMobile
      ? [
        "Pinch to zoom",
        "Drag to pan",
        "Add node from top menu",
        "Double tap to clone and align",
        "Double tap to select multiple",
        "You have the power",	
        "Your time is NOW!",
      ]
      : [
        "Scroll to zoom",
        "Drag to pan",
        "Right click to clone and align",
        "Right click to select multiple",
	    "Hold Shift + drag mouse for marquee selection",
        "You have the power",
        "Your time is NOW!",
      ];
      
      const list = document.createElement("ul");
      for (const item of items) {
      const li = document.createElement("li");
      li.textContent = item;
      list.appendChild(li);
      }
      
      hint.replaceChildren(list);
      },
        autoSelectStyleScope() {
          const scope = document.getElementById("style-scope");
          if (!scope) return;
          if (this.isMobile) scope.value = "mobile";
        },
        updateToolbarStack() {
          if (!this.isMobile) return;
          const draw = document.getElementById("draw-toolbar");
          const topo = document.getElementById("topology-toolbar");
          if (!draw || !topo) return;
          const h = draw.getBoundingClientRect().height;
          document.documentElement.style.setProperty("--draw-toolbar-height", h + "px");
        },
        updateLayoutControls() {
          const sidebarRow = document.getElementById("sidebar-width-row");
          const footerRow = document.getElementById("mobile-footer-row");
          if (sidebarRow && footerRow) {
            if (this.isMobile) {
              sidebarRow.style.display = "none";
              footerRow.style.display = "flex";
            } else {
              sidebarRow.style.display = "flex";
              footerRow.style.display = "none";
            }
          }
        },
        applyAll() {
          this.detect();
          this.applyInitialCollapse();
          this.updateBulkToolbar();
          this.updateLayout();
          this.updateCanvasHint();
          this.autoSelectStyleScope();
          this.updateToolbarStack();
          this.updateLayoutControls();
        }
      };
      
      function isMobileDevice() {
        return MobileManager.isMobile;
      }
      
      function u8ToBase64(u8) {
      let binary = "";
      for (let i = 0; i < u8.length; i++) binary += String.fromCharCode(u8[i]);
      return btoa(binary);
      }
      
      function base64ToU8(base64) {
      const binary = atob(base64);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
      return bytes;
      }
      
			  function ensureLegendMiniButton() {
		   if (legendMiniBtn) return legendMiniBtn;
		   const handleClick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			legendCollapsed = false;
			updateLegendVisibility();
		   };
		   const preventTouch = (e) => { e.preventDefault(); };
		   const existing = document.getElementById("edge-legend-mini");
		   if (existing) {
			existing.addEventListener("click", handleClick);
			existing.addEventListener("touchstart", preventTouch, { passive: false });
			existing.addEventListener("touchend", handleClick);
			legendMiniBtn = existing;
			return existing;
		   }
		   const panel = document.querySelector(".topology-panel");
		   if (!panel) return null;
		   const btn = document.createElement("button");
		   btn.type = "button";
		   btn.id = "edge-legend-mini";
		   btn.className = "legend-mini-btn";
		   btn.textContent = "Legend";
		   btn.style.bottom = "10px";
		   btn.addEventListener("click", handleClick);
		   btn.addEventListener("touchstart", preventTouch, { passive: false });
		   btn.addEventListener("touchend", handleClick);
		   panel.appendChild(btn);
		   legendMiniBtn = btn;
		   return btn;
		}
			  
			  function ensureMinimapMiniButton() {
		   if (minimapMiniBtn) return minimapMiniBtn;
		   const handleClick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			minimapCollapsed = false;
			updateMinimapVisibility();
		   };
		   const preventTouch = (e) => { e.preventDefault(); };
		   const existing = document.getElementById("minimap-mini");
		   if (existing) {
			existing.addEventListener("click", handleClick);
			existing.addEventListener("touchstart", preventTouch, { passive: false });
			existing.addEventListener("touchend", handleClick);
			minimapMiniBtn = existing;
			return existing;
		   }
		   const panel = document.querySelector(".topology-panel");
		   if (!panel) return null;
		   const btn = document.createElement("button");
		   btn.type = "button";
		   btn.id = "minimap-mini";
		   btn.className = "legend-mini-btn";
		   btn.textContent = "Map";
		   btn.style.right = "10px";
		   btn.style.left = "auto";
		   btn.style.bottom = "10px";
		   btn.addEventListener("click", handleClick);
		   btn.addEventListener("touchstart", preventTouch, { passive: false });
		   btn.addEventListener("touchend", handleClick);
		   panel.appendChild(btn);
		   minimapMiniBtn = btn;
		   return btn;
		}
			  
			  function ensureDrawToolbarMiniButton() {
		   if (drawToolbarMiniBtn) return drawToolbarMiniBtn;
		   const handleClick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			drawToolbarCollapsed = false;
			updateDrawToolbarVisibility();
		   };
		   const preventTouch = (e) => { e.preventDefault(); };
		   const existing = document.getElementById("draw-toolbar-mini");
		   if (existing) {
			existing.addEventListener("click", handleClick);
			existing.addEventListener("touchstart", preventTouch, { passive: false });
			existing.addEventListener("touchend", handleClick);
			drawToolbarMiniBtn = existing;
			return existing;
		   }
		   const panel = document.querySelector(".topology-panel");
		   if (!panel) return null;
		   const btn = document.createElement("button");
		   btn.type = "button";
		   btn.id = "draw-toolbar-mini";
		   btn.className = "legend-mini-btn";
		   btn.textContent = "Draw";
		   btn.style.top = "10px";
		   btn.style.left = "10px";
		   btn.style.right = "auto";
		   btn.addEventListener("click", handleClick);
		   btn.addEventListener("touchstart", preventTouch, { passive: false });
		   btn.addEventListener("touchend", handleClick);
		   panel.appendChild(btn);
		   drawToolbarMiniBtn = btn;
		   return btn;
		}
			  
			  function ensureTopologyToolbarMiniButton() {
		   if (topologyToolbarMiniBtn) return topologyToolbarMiniBtn;
		   const handleClick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			topologyToolbarCollapsed = false;
			updateTopologyToolbarVisibility();
		   };
		   const preventTouch = (e) => { e.preventDefault(); };
		   const existing = document.getElementById("topology-toolbar-mini");
		   if (existing) {
			existing.addEventListener("click", handleClick);
			existing.addEventListener("touchstart", preventTouch, { passive: false });
			existing.addEventListener("touchend", handleClick);
			topologyToolbarMiniBtn = existing;
			return existing;
		   }
		   const panel = document.querySelector(".topology-panel");
		   if (!panel) return null;
		   const btn = document.createElement("button");
		   btn.type = "button";
		   btn.id = "topology-toolbar-mini";
		   btn.className = "legend-mini-btn";
		   btn.textContent = "Add Line";
		   btn.style.top = "10px";
		   btn.style.left = "auto";
		   btn.style.right = "40px";
		   btn.addEventListener("click", handleClick);
		   btn.addEventListener("touchstart", preventTouch, { passive: false });
		   btn.addEventListener("touchend", handleClick);
		   panel.appendChild(btn);
		   topologyToolbarMiniBtn = btn;
		   return btn;
		}
      
      function updateToolbarStack() {
       if (!isMobileDevice()) return;
       const draw = document.getElementById("draw-toolbar");
       const topo = document.getElementById("topology-toolbar");
       if (!draw || !topo) return;
       const h = draw.getBoundingClientRect().height;
       document.documentElement.style.setProperty("--draw-toolbar-height", h + "px");
      }
      window.addEventListener("resize", updateToolbarStack);
      window.addEventListener("DOMContentLoaded", updateToolbarStack);
      updateToolbarStack();
      
      function updateLegendVisibility() {
       const legend = document.getElementById("edge-legend");
       const mini = ensureLegendMiniButton();
       if (!legend || !mini) return;
       const hasItems = legend.querySelectorAll(".legend-item").length > 0;
       if (!hasItems) {
        legend.style.display = "none";
        mini.style.display = "none";
        return;
       }
       if (legendCollapsed) {
        legend.style.display = "none";
        mini.style.display = "inline-flex";
       } else {
        legend.style.display = "flex";
        mini.style.display = "none";
       }
      }
      
      function updateMinimapVisibility() {
       const wrapper = document.getElementById("minimap-zoom-wrapper");
       const mini = ensureMinimapMiniButton();
       if (!wrapper || !mini) return;
       if (minimapCollapsed) {
        wrapper.style.display = "none";
        mini.style.display = "inline-flex";
       } else {
        wrapper.style.display = "block";
        mini.style.display = "none";
       }
      }
      
      function updateDrawToolbarVisibility() {
       const toolbar = document.getElementById("draw-toolbar");
       const mini = ensureDrawToolbarMiniButton();
       if (isViewOnly()) {
        if (toolbar) toolbar.style.setProperty('display', 'none', 'important');
        if (mini) mini.style.display = "none";
        return;
       }
       if (!toolbar || !mini) return;
       if (drawToolbarCollapsed) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "inline-flex";
       } else {
      if (isMobileDevice()) {    	   
        toolbar.style.setProperty('display', 'grid', 'important');
        mini.style.display = "none";
      } else {   
        toolbar.style.setProperty('display', 'flex', 'important');
        mini.style.display = "none";	  
      }
       }
      }
      
      function updateTopologyToolbarVisibility() {
       const toolbar = document.getElementById("topology-toolbar");
       const mini = ensureTopologyToolbarMiniButton();
       if (isViewOnly()) {
        if (toolbar) toolbar.style.setProperty('display', 'none', 'important');
        if (mini) mini.style.display = "none";
        return;
       }
       if (!toolbar || !mini) return;
       const hasSelectedNode = currentNodeId !== null;
       if (!hasSelectedNode) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "none";
       } else if (topologyToolbarCollapsed) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "inline-flex";
       } else {   
      if (isMobileDevice()) {    	   
        toolbar.style.setProperty('display', 'grid', 'important');
        mini.style.display = "none";
        } else {   
        toolbar.style.setProperty('display', 'flex', 'important');
        mini.style.display = "none";	  
      }
       }
      }
      const DEFAULT_CANVAS_HINT = document.getElementById("canvas-hint")?.innerHTML || "";
      const DEFAULT_PAGE_STATE = {
       title: "The One File",
       background: "",
       topbarBg: "rgba(9, 12, 20, 0.9)",
       topbarBorder: "#1f2533",
       panel: "#0b0e13",
       panelAlt: "#10141b",
       accent: "#4fd1c5",
       sidebarBg: "#10141b",
       btnBg: "#0b0e13",
       btnText: "#e2e8f0",
       tagFill: "#1e293b",
       tagText: "#e2e8f0",
       tagBorder: "#475569",
       inputBg: "#0b0e13",
       inputText: "#e2e8f0",
       inputBorder: "#1f2937",
       inputFont: "Inter, system-ui, sans-serif",
       inputFontSize: 14,
       toolbarBg: "#0f172a",
       toolbarBorder: "#1f2937",
       toolbarText: "#94a3b8",
       toolbarBtnBg: "#0b0e13",
       toolbarBtnText: "#e2e8f0",
       minimapDots: "#94a3b8",
       canvasHintEnabled: true,
       canvasHintText: "",
       canvasHintBg: "#0f172a",
       canvasHintColor: "#94a3b8",
       danger: "#f56565",
       textMain: "#e2e8f0",
       textSoft: "#94a3b8",
       topbarHeight: 52,
       sidebarWidth: 350,
       mobileFooterHeight: 40,
       sidebarCollapsed: false,
       nodeFill: "#1e293b",
       nodeStroke: "#475569",
       nodeTitle: "#e2e8f0",
       nodeSub: "#94a3b8",
       nodeTitleSize: 18,
       nodeSubSize: 13,
       nodeFont: "Inter, system-ui, sans-serif",
       defaultEdge: "#475569",
       selectionHandle: "#f59e0b",
       selectionHandleSize: 8,
       groupIndicator: "#4fd1c5",
      canvasGradientTop: "#1e2532",
       canvasGradientBottom: "#050608",
       canvasBorder: "#475569",
       canvasGrid: "#475569",
       canvasGridSize: 50,
       rackFrameFill: "#0f172a",
       rackFrameStroke: "#4fd1c5",
       rackLineColor: "#475569",
       rackTextColor: "#4fd1c5",
	   viewOnly: false,
      };
      let PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE);
	  function isViewOnly() {
       return PAGE_STATE.viewOnly === true;
      }
	  let viewOnlyClickCount = 0;
      let viewOnlyClickTimer = null;
      let viewOnlyClickTarget = null;
      
      function handleViewOnlyClick(id, type) {
       if (!isViewOnly()) return false;
       
       if (viewOnlyClickTarget !== id) {
        viewOnlyClickCount = 0;
        viewOnlyClickTarget = id;
       }
       
       viewOnlyClickCount++;
       
       clearTimeout(viewOnlyClickTimer);
       viewOnlyClickTimer = setTimeout(() => {
        viewOnlyClickCount = 0;
        viewOnlyClickTarget = null;
       }, 2000);
       
       if (viewOnlyClickCount >= 5) {
        viewOnlyClickCount = 0;
        viewOnlyClickTarget = null;
        
        document.body.classList.add("view-only-inspect");
        
        if (type === 'node') {
         currentNodeId = id;
         const data = NODE_DATA[id];
         if (data) {
          document.querySelectorAll(".node-group").forEach((n) => {
           n.classList.toggle("active", n.dataset.nodeId === id);
          });
          document.getElementById("node-panel").style.display = "block";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("node-name").textContent = data.name;
          document.getElementById("node-ip").textContent = data.ip;
          document.getElementById("node-role").textContent = data.role;
          document.getElementById("node-mac").textContent = data.mac || "--";
          document.getElementById("node-rack").textContent = data.rackUnit || "--";
          document.getElementById("node-uheight").textContent = (data.uHeight || "1") + "U";
          
          const tagList = document.getElementById("node-tags");
          if (tagList) {
           tagList.innerHTML = "";
           if (data.tags && data.tags.length > 0) {
            data.tags.forEach((tag) => {
             const li = document.createElement("li");
             li.textContent = tag;
             tagList.appendChild(li);
            });
           }
          }
          
          const noteList = document.getElementById("node-notes");
          if (noteList) {
           noteList.innerHTML = "";
           if (data.notes && data.notes.length > 0) {
            data.notes.forEach((note) => {
             const li = document.createElement("li");
             li.textContent = note;
             noteList.appendChild(li);
            });
           }
          }
         }
        } else if (type === 'edge') {
         currentEdgeId = id;
         const edge = EDGE_DATA.list.find(e => e.id === id);
         if (edge) {
          document.querySelectorAll(".edge").forEach((e) => {
           e.classList.toggle("active", e.dataset.edgeId === id);
          });
          document.getElementById("edge-panel").style.display = "block";
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-from").textContent = NODE_DATA[edge.from]?.name || edge.from;
          document.getElementById("edge-to").textContent = NODE_DATA[edge.to]?.name || edge.to;
          document.getElementById("edge-label").value = edge.label || "";
         }
        }
        return true;
       }
       return false;
      }
	  
      const CANVAS_WIDTH = 4000;
      let CANVAS_HEIGHT = 3000;
      const BASE_CANVAS_HEIGHT = 3000;
      const CANVAS_PADDING = 100;
      
      const RACK_U_HEIGHT = 70; 
      const RACK_WIDTH = 600;
      const RACK_START_X = CANVAS_WIDTH / 2; 
      const RACK_START_Y = CANVAS_PADDING + 100;
      function getRackUHeight(rackId) {
      const capacity = getRackCapacity(rackId);
      const availableHeight = CANVAS_HEIGHT - RACK_START_Y - 200;
      return Math.floor(availableHeight / capacity);
      }
      let canvasState = {
       zoom: 1,
       panX: 0,
       panY: 0,
       minZoom: 0.25,
       maxZoom: 4,
       isPanning: false,
       panStartX: 0,
       panStartY: 0,
       spacePressed: false,
      };
      
      function getViewBox() {
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       return {
        x: canvasState.panX,
        y: canvasState.panY,
        width: viewWidth,
        height: viewHeight,
       };
      }
      
      function updateViewBox() {
       const svg = document.getElementById("map");
       const vb = getViewBox();
       svg.setAttribute("viewBox", `${vb.x} ${vb.y} ${vb.width} ${vb.height}`, );
       const zoomLevel = document.getElementById("zoom-level");
       if (zoomLevel) {
        zoomLevel.textContent = Math.round(canvasState.zoom * 100) + "%";
       }
       updateMinimap();
       populateRackDropdown();
      }
      
      function updateMinimap() {
       const minimapViewport = document.getElementById("minimap-viewport");
       const minimapSvg = document.getElementById("minimap");
       if (!minimapViewport || !minimapSvg) return;
       const vb = getViewBox();
       minimapViewport.setAttribute("x", vb.x);
       minimapViewport.setAttribute("y", vb.y);
       minimapViewport.setAttribute("width", vb.width);
       minimapViewport.setAttribute("height", vb.height);
       const minimapNodes = minimapSvg.querySelectorAll(".minimap-node");
       minimapNodes.forEach((n) => n.remove());
       const minimapEdges = minimapSvg.querySelectorAll(".minimap-edge");
       minimapEdges.forEach((e) => e.remove());
       
       EDGE_DATA.list.forEach((edge) => {
        if (edge.type === "custom") return;
        
        const fromNode = NODE_DATA[edge.from];
        const toNode = NODE_DATA[edge.to];
        if (!fromNode || !toNode) return;
        
        if (currentView.mode === "rack") {
         if (fromNode.assignedRack !== currentView.rackId || 
             toNode.assignedRack !== currentView.rackId) {
          return;
         }
        } else {
         if (fromNode.assignedRack || toNode.assignedRack) {
          return;
         }
        }
        
        const p1 = savedPositions[edge.from];
        const p2 = savedPositions[edge.to];
        if (!p1 || !p2) return;
        const line = document.createElementNS("http://www.w3.org/2000/svg", "line", );
        line.setAttribute("x1", p1.x);
        line.setAttribute("y1", p1.y);
        line.setAttribute("x2", p2.x);
        line.setAttribute("y2", p2.y);
        line.classList.add("minimap-edge");
        minimapSvg.insertBefore(line, minimapViewport);
       });
       
       Object.entries(savedPositions).forEach(([id, pos]) => {
        const node = NODE_DATA[id];
        if (!node) return;
        
        if (currentView.mode === "rack") {
         if (node.assignedRack !== currentView.rackId) {
          return; 
         }
        } else {
         if (node.assignedRack) {
          return; 
         }
        }
        
        const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle", );
        circle.setAttribute("cx", pos.x);
        circle.setAttribute("cy", pos.y);
        circle.setAttribute("r", 40);
        circle.classList.add("minimap-node");
        minimapSvg.insertBefore(circle, minimapViewport);
       });
      }
      
      function zoomTo(newZoom, centerX, centerY) {
       const oldZoom = canvasState.zoom;
       newZoom = Math.max(canvasState.minZoom, Math.min(canvasState.maxZoom, newZoom), );
       if (centerX !== undefined && centerY !== undefined) {
        const oldWidth = CANVAS_WIDTH / oldZoom;
        const oldHeight = CANVAS_HEIGHT / oldZoom;
        const newWidth = CANVAS_WIDTH / newZoom;
        const newHeight = CANVAS_HEIGHT / newZoom;
        const pointX = canvasState.panX + centerX * oldWidth;
        const pointY = canvasState.panY + centerY * oldHeight;
        canvasState.panX = pointX - centerX * newWidth;
        canvasState.panY = pointY - centerY * newHeight;
       }
       canvasState.zoom = newZoom;
       constrainPan();
       updateViewBox();
      }
      
      function constrainPan() {
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       const minVisiblePortion = 0.1;
       const maxPanX = CANVAS_WIDTH - viewWidth * minVisiblePortion;
       const maxPanY = CANVAS_HEIGHT - viewHeight * minVisiblePortion;
       const minPanX = -viewWidth * (1 - minVisiblePortion);
       const minPanY = -viewHeight * (1 - minVisiblePortion);
       canvasState.panX = Math.max(minPanX, Math.min(maxPanX, canvasState.panX), );
       canvasState.panY = Math.max(minPanY, Math.min(maxPanY, canvasState.panY), );
      }
      
      function fitToContent() {
       const positions = Object.values(savedPositions);
       if (positions.length === 0) {
        resetView();
        return;
       }
       let minX = Infinity,
        minY = Infinity,
        maxX = -Infinity,
        maxY = -Infinity;
       positions.forEach((pos) => {
        minX = Math.min(minX, pos.x - 100);
        minY = Math.min(minY, pos.y - 100);
        maxX = Math.max(maxX, pos.x + 100);
        maxY = Math.max(maxY, pos.y + 100);
       });
       const contentWidth = maxX - minX + 200;
       const contentHeight = maxY - minY + 200;
       const viewport = document.getElementById("canvas-viewport");
       const vpRect = viewport.getBoundingClientRect();
       const aspectRatio = vpRect.width / vpRect.height;
       const contentAspect = contentWidth / contentHeight;
       let newZoom;
       if (contentAspect > aspectRatio) {
        newZoom = (vpRect.width / contentWidth) * (CANVAS_WIDTH / vpRect.width);
       } else {
        newZoom = (vpRect.height / contentHeight) * (CANVAS_HEIGHT / vpRect.height);
       }
       newZoom = Math.max(canvasState.minZoom, Math.min(2, newZoom));
       const viewWidth = CANVAS_WIDTH / newZoom;
       const viewHeight = CANVAS_HEIGHT / newZoom;
       canvasState.zoom = newZoom;
       canvasState.panX = minX - 100 - (viewWidth - contentWidth) / 2;
       canvasState.panY = minY - 100 - (viewHeight - contentHeight) / 2;
       constrainPan();
       updateViewBox();
      }
      
      function resetView() {
       canvasState.zoom = 1;
       canvasState.panX = 0;
       canvasState.panY = 0;
       updateViewBox();
      }
      window.addEventListener("DOMContentLoaded", () => {
       const toggle = document.getElementById("mobile-menu-toggle");
       const menu = document.getElementById("topbar-menu");
       if (!toggle || !menu) return;
       toggle.addEventListener("click", () => {
        menu.classList.toggle("open");
       });
       menu.addEventListener("click", (e) => {
        const target = e.target.closest("a, button");
        if (!target) return;
        if (isMobileDevice()) {
       menu.classList.remove("open");
      }
       });
       const minimapCloseBtn = document.getElementById("minimap-close-btn");
       if (minimapCloseBtn) {
        const handleMinimapClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         minimapCollapsed = true;
         updateMinimapVisibility();
        };
        minimapCloseBtn.addEventListener("click", handleMinimapClose);
        minimapCloseBtn.addEventListener("touchend", handleMinimapClose);
       }
       const drawToolbarCloseBtn = document.getElementById("draw-toolbar-close-btn");
       if (drawToolbarCloseBtn) {
        const handleDrawClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         drawToolbarCollapsed = true;
         updateDrawToolbarVisibility();
        };
        drawToolbarCloseBtn.addEventListener("click", handleDrawClose);
        drawToolbarCloseBtn.addEventListener("touchend", handleDrawClose);
       }
       const topologyToolbarCloseBtn = document.getElementById("topology-toolbar-close-btn");
       if (topologyToolbarCloseBtn) {
        const handleTopologyClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         topologyToolbarCollapsed = true;
         updateTopologyToolbarVisibility();
        };
        topologyToolbarCloseBtn.addEventListener("click", handleTopologyClose);
        topologyToolbarCloseBtn.addEventListener("touchstart", (e) => e.preventDefault(), {
         passive: false
        });
        topologyToolbarCloseBtn.addEventListener("touchend", handleTopologyClose);
       }
      
       updateMinimapVisibility();
       updateDrawToolbarVisibility();
       updateTopologyToolbarVisibility();
      });
      
      function applyLayerFilter() {
       activeLayers.clear();
       if (document.getElementById("layer-physical").checked) activeLayers.add("physical");
       if (document.getElementById("layer-logical").checked) activeLayers.add("logical");
       if (document.getElementById("layer-security").checked) activeLayers.add("security");
       if (document.getElementById("layer-application").checked) activeLayers.add("application");
       forgeTheTopology();
      }
      
      function isNodeVisible(nodeId) {
       const node = NODE_DATA[nodeId];
       if (!node) return false;
       const nodeLayer = node.layer || "physical";
       return activeLayers.has(nodeLayer);
      }
      
      function enterRack(rackId) {
      if (!NODE_DATA[rackId] || !NODE_DATA[rackId].isRack) return;
      const rackCapacity = getRackCapacity(rackId);
      const neededHeight = RACK_START_Y + (rackCapacity * RACK_U_HEIGHT) + 200;
      if (neededHeight > BASE_CANVAS_HEIGHT) {
      CANVAS_HEIGHT = neededHeight;
      }
       
       savedTopologyView = {
        zoom: canvasState.zoom,
        panX: canvasState.panX,
        panY: canvasState.panY
       };
       
       currentView.mode = "rack";
       currentView.rackId = rackId;
       
       const backBtn = document.getElementById("back-to-topology-btn");
       if (backBtn) backBtn.style.display = "inline-block";
       
       const hint = document.getElementById("canvas-hint");
       if (hint) {
        hint.textContent = `Viewing: ${NODE_DATA[rackId].name} | Double click empty space to exit`;
        hint.classList.add("visible");
       }
       
      
      const rackUHeight = getRackUHeight(rackId);
      const rackHeight = rackCapacity * rackUHeight;
      const rackCenterX = RACK_START_X;
      const rackCenterY = RACK_START_Y + (rackHeight / 2);
       
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       
       canvasState.panX = rackCenterX - (viewWidth / 2);
       canvasState.panY = rackCenterY - (viewHeight / 2);
       
       constrainPan();
       updateViewBox();
       
       forgeTheTopology();
      }
      
      function exitRack() {
      CANVAS_HEIGHT = BASE_CANVAS_HEIGHT;
      currentView.mode = "topology";
      currentView.rackId = null;
       
       const backBtn = document.getElementById("back-to-topology-btn");
       if (backBtn) backBtn.style.display = "none";
       
       const hint = document.getElementById("canvas-hint");
       if (hint) {
        hint.classList.remove("visible");
       }
       
       if (savedTopologyView) {
        canvasState.zoom = savedTopologyView.zoom;
        canvasState.panX = savedTopologyView.panX;
        canvasState.panY = savedTopologyView.panY;
        updateViewBox();
       }
       
       forgeTheTopology();
      }
      
      function getRackCapacity(rackId) {
       const node = NODE_DATA[rackId];
       return node && node.rackCapacity ? parseInt(node.rackCapacity) : 42;
      }
      
      function populateRackDropdown() {
       const dropdown = document.getElementById("node-assigned-rack");
       if (!dropdown) return;
       
       dropdown.innerHTML = '<option value="">None</option>';
       
       Object.keys(NODE_DATA).forEach(id => {
        if (NODE_DATA[id].isRack) {
         const option = document.createElement("option");
         option.value = id;
         option.textContent = NODE_DATA[id].name;
         dropdown.appendChild(option);
        }
       });
      }
      
      function wieldThePower() {
       const root = document.documentElement;
       root.style.setProperty("--panel", PAGE_STATE.panel);
       root.style.setProperty("--panel-alt", PAGE_STATE.panelAlt);
       root.style.setProperty("--sidebar-bg", PAGE_STATE.sidebarBg || PAGE_STATE.panelAlt);
       root.style.setProperty("--btn-bg", PAGE_STATE.btnBg || PAGE_STATE.panel);
       root.style.setProperty("--btn-text", PAGE_STATE.btnText || "#e2e8f0");
       root.style.setProperty("--tag-fill", PAGE_STATE.tagFill || "#1e293b");
       root.style.setProperty("--tag-text", PAGE_STATE.tagText || "#e2e8f0");
       root.style.setProperty("--tag-border", PAGE_STATE.tagBorder || "#475569");
       root.style.setProperty("--input-bg", PAGE_STATE.inputBg || "#0b0e13");
       root.style.setProperty("--input-text", PAGE_STATE.inputText || "#e2e8f0");
       root.style.setProperty("--input-border", PAGE_STATE.inputBorder || "#1f2937");
       root.style.setProperty("--input-font", PAGE_STATE.inputFont || "Inter, system-ui, sans-serif");
       root.style.setProperty("--input-font-size", (PAGE_STATE.inputFontSize || 14) + "px");
       root.style.setProperty("--toolbar-bg", PAGE_STATE.toolbarBg || "#0f172a");
       root.style.setProperty("--toolbar-border", PAGE_STATE.toolbarBorder || "#1f2937");
       root.style.setProperty("--toolbar-text", PAGE_STATE.toolbarText || "#94a3b8");
       root.style.setProperty("--toolbar-btn-bg", PAGE_STATE.toolbarBtnBg || "#0b0e13");
       root.style.setProperty("--toolbar-btn-text", PAGE_STATE.toolbarBtnText || "#e2e8f0");
       root.style.setProperty("--minimap-dots", PAGE_STATE.minimapDots || "#94a3b8");
       root.style.setProperty("--canvas-hint-bg", PAGE_STATE.canvasHintBg || "#0f172a");
       root.style.setProperty("--canvas-hint-color", PAGE_STATE.canvasHintColor || "#94a3b8");
       
       const canvasHint = document.getElementById("canvas-hint");
       if (canvasHint) {
        canvasHint.style.display = PAGE_STATE.canvasHintEnabled === false ? "none" : "";
        if (PAGE_STATE.canvasHintText !== undefined && PAGE_STATE.canvasHintText !== "") {
         canvasHint.innerHTML = PAGE_STATE.canvasHintText;
        } else {
         canvasHint.innerHTML = DEFAULT_CANVAS_HINT;
        }
       }
       root.style.setProperty("--accent", PAGE_STATE.accent);
       root.style.setProperty("--danger", PAGE_STATE.danger);
       root.style.setProperty("--text-main", PAGE_STATE.textMain);
       root.style.setProperty("--text-soft", PAGE_STATE.textSoft);
       root.style.setProperty("--topbar-bg", PAGE_STATE.topbarBg);
       root.style.setProperty("--topbar-border", PAGE_STATE.topbarBorder);
       root.style.setProperty("--node-fill", PAGE_STATE.nodeFill || "#1e293b");
       root.style.setProperty("--node-stroke", PAGE_STATE.nodeStroke || "#475569");
       root.style.setProperty("--node-title", PAGE_STATE.nodeTitle || "#e2e8f0");
       root.style.setProperty("--node-sub", PAGE_STATE.nodeSub || "#94a3b8");
       root.style.setProperty("--node-title-size", (PAGE_STATE.nodeTitleSize || 18) + "px");
       root.style.setProperty("--node-sub-size", (PAGE_STATE.nodeSubSize || 13) + "px");
       root.style.setProperty("--node-font", PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif");
       root.style.setProperty("--default-edge", PAGE_STATE.defaultEdge || "#475569");
       root.style.setProperty("--selection-handle", PAGE_STATE.selectionHandle || "#f59e0b");
       root.style.setProperty("--selection-handle-size", (PAGE_STATE.selectionHandleSize || 8) + "px");
       root.style.setProperty("--group-indicator", PAGE_STATE.groupIndicator || "#4fd1c5");
       const topbarHeight = PAGE_STATE.topbarHeight || 52;
       const sidebarWidth = PAGE_STATE.sidebarWidth || 350;
       const mobileFooterHeight = PAGE_STATE.mobileFooterHeight || 40;
       root.style.setProperty("--topbar-height", topbarHeight + "px");
       root.style.setProperty("--sidebar-width", sidebarWidth + "px");
       root.style.setProperty("--mobile-footer-height", mobileFooterHeight + "vh", );
       const mainEl = document.querySelector("main");
       const detailsPanel = document.getElementById("details-panel");
       const sidebarToggle = document.getElementById("sidebar-toggle");
       if (PAGE_STATE.sidebarCollapsed) {
        if (mainEl) mainEl.classList.add("sidebar-collapsed");
        if (detailsPanel) detailsPanel.classList.add("collapsed");
        if (sidebarToggle) {
         sidebarToggle.classList.add("collapsed");
         sidebarToggle.textContent = "▶";
        }
       } else {
        if (mainEl) mainEl.classList.remove("sidebar-collapsed");
        if (detailsPanel) detailsPanel.classList.remove("collapsed");
        if (sidebarToggle) {
         sidebarToggle.classList.remove("collapsed");
         sidebarToggle.textContent = "◀";
        }
       }
       if (PAGE_STATE.background) {
        document.body.style.background = PAGE_STATE.background;
       } else {
        document.body.style.background = `radial-gradient(circle at top, ${PAGE_STATE.canvasGradientTop || "#1e2532"} 0, ${PAGE_STATE.canvasGradientBottom || "#050608"} 70%)`;
       }
       document.title = PAGE_STATE.title || DEFAULT_PAGE_STATE.title;
       const titleEl = document.getElementById("page-title");
       if (titleEl) {
        titleEl.textContent = PAGE_STATE.title || DEFAULT_PAGE_STATE.title;
       }
       
       const sidebarToggleEl = document.getElementById("sidebar-toggle");
       const isMobile = isMobileDevice();
       if (sidebarToggleEl) {
        sidebarToggleEl.style.display = isMobile ? "none" : "flex";
       }
       const viewOnlyMode = PAGE_STATE.viewOnly === true;
       const addNodeBtn = document.getElementById("add-node-btn");
       const addRackBtn = document.getElementById("add-rack-btn");
       const drawToolbar = document.getElementById("draw-toolbar");
       const topologyToolbar = document.getElementById("topology-toolbar");
       const bulkToolbar = document.getElementById("bulk-toolbar");
       
       if (addNodeBtn) addNodeBtn.style.display = viewOnlyMode ? "none" : "";
       if (addRackBtn) addRackBtn.style.display = viewOnlyMode ? "none" : "";
       if (viewOnlyMode) {
        if (drawToolbar) drawToolbar.style.setProperty('display', 'none', 'important');
        if (topologyToolbar) topologyToolbar.style.setProperty('display', 'none', 'important');
        if (bulkToolbar) bulkToolbar.style.display = "none";
        const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
       }
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       if (bulkToolbarMobile) bulkToolbarMobile.style.display = viewOnlyMode ? "none" : "";
       ["draw-toolbar-mini", "topology-toolbar-mini"].forEach(id => {
        const el = document.getElementById(id);
        if (el) el.style.display = viewOnlyMode ? "none" : "";
       });
       
       document.body.classList.toggle("view-only-mode", viewOnlyMode);
      }
      (async function awakeTheImmortal() {
       let initialState = {};
       let decryptionCancelled = false;
       const stateEl = document.getElementById("topology-state");
       if (stateEl && stateEl.textContent.trim()) {
        try {
         let stateText = stateEl.textContent.trim();
         if (isEncrypted(stateText)) {
          let decrypted = false;
          let attempts = 0;
          const maxAttempts = 3;
          while (!decrypted && attempts < maxAttempts) {
           const password = prompt("This file is encrypted. Enter password to decrypt:\n(Attempt " + (attempts + 1) + " of " + maxAttempts + ")", );
           if (!password) {
            alert("Decryption cancelled. The file will not be loaded.", );
            decryptionCancelled = true;
            break;
           }
           try {
            stateText = await decryptData(stateText, password);
            decrypted = true;
           } catch (e) {
            attempts++;
            if (attempts < maxAttempts) {
             alert("Incorrect password. Please try again.");
            } else {
             alert("Maximum attempts reached. The file will not be loaded.", );
             decryptionCancelled = true;
            }
           }
          }
          if (!decrypted) {
           stateText = "{}";
          }
         }
         initialState = JSON.parse(stateText);
        } catch (e) {
         console.error("Failed to load state:", e);
         initialState = {};
        }
       }
       if (decryptionCancelled) {
        NODE_DATA = {};
        EDGE_DATA = {
         list: []
        };
        RECT_DATA = { list: [] };
        TEXT_DATA = { list: [] };
        EDGE_LEGEND = {};
        savedPositions = {};
        savedSizes = {};
        savedStyles = {};
       } else {
        NODE_DATA = initialState.nodeData ? initialState.nodeData : BASE_NODE_DATA;
        EDGE_DATA = initialState.edgeData ? initialState.edgeData : {
         list: [],
        };
        RECT_DATA = initialState.rectData ? initialState.rectData : { list: [] };
        TEXT_DATA = initialState.textData ? initialState.textData : { list: [] };
        EDGE_LEGEND = initialState.edgeLegend || {};
        savedPositions = initialState.nodePositions || {};
        savedSizes = initialState.nodeSizes || {};
        savedStyles = initialState.nodeStyles || {};
       }
       if (initialState.page) {
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, initialState.page, );
       }
       if (initialState.canvas) {
        canvasState.zoom = initialState.canvas.zoom || 1;
        canvasState.panX = initialState.canvas.panX || 0;
        canvasState.panY = initialState.canvas.panY || 0;
       }
       
       if (initialState.savedTopologyView) {
        savedTopologyView = initialState.savedTopologyView;
       }
       
       if (initialState.documentTabs) {
        documentTabs = initialState.documentTabs;
        currentTabIndex = initialState.currentTabIndex || 0;
        
        const currentTab = documentTabs[currentTabIndex];
        if (currentTab) {
          NODE_DATA = currentTab.nodes || NODE_DATA;
          EDGE_DATA = currentTab.edges || EDGE_DATA;
          savedPositions = currentTab.positions || savedPositions;
          savedSizes = currentTab.sizes || savedSizes;
          savedStyles = currentTab.styles || savedStyles;
          EDGE_LEGEND = currentTab.legend || EDGE_LEGEND;
          RECT_DATA = currentTab.rects || RECT_DATA;
          TEXT_DATA = currentTab.texts || TEXT_DATA;
      if (currentTab.pageState) PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, currentTab.pageState);
        }
       }
           
       if (initialState.encryptedSections) {
        encryptedSections = initialState.encryptedSections;
       }
       
       wieldThePower();
       forgeTheTopology();
       updateViewBox();
       
       MobileManager.applyAll();
       
       const initialNodes = Object.keys(NODE_DATA);
       if (initialNodes.length > 0) {
        claimTheImmortal(initialNodes.includes("host") ? "host" : initialNodes[0], );
       } else {
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.display = "none";
       }
      })();
      
      let resizeDebounceTimer = null;
      window.addEventListener("resize", () => {
        clearTimeout(resizeDebounceTimer);
        resizeDebounceTimer = setTimeout(() => {
          MobileManager.applyAll();
          if (typeof updateDrawToolbarVisibility === 'function') updateDrawToolbarVisibility();
          if (typeof updateTopologyToolbarVisibility === 'function') updateTopologyToolbarVisibility();
        }, 100);
      });
      
      function getBreakpointKey() {
       const w = window.innerWidth;
       if (w <= 380) return "fold";
       if (w <= 768) return "mobile";
       if (w <= 1024) return "tablet";
       return "desktop";
      }
      
      function resolveStylesEntry(styleEntry) {
       if (!styleEntry) return {};
       if (styleEntry.circleColor || styleEntry.titleColor || styleEntry.titleFont || styleEntry.titleSize || styleEntry.subColor || styleEntry.subFont || styleEntry.subSize) {
        return styleEntry;
       }
       const bp = getBreakpointKey();
       const base = styleEntry.all || {};
       const bpStyles = styleEntry[bp] || {};
       return Object.assign({}, base, bpStyles);
      }
      
      function resolveStylesForNode(id) {
       const styleEntry = savedStyles[id];
       if (!styleEntry) return {};
       return resolveStylesEntry(styleEntry);
      }
      
      function ensureStyleEntry(id) {
       if (!savedStyles[id]) savedStyles[id] = {};
       const entry = savedStyles[id];
       const flatProps = ["circleColor", "circleBorder", "titleColor", "titleFont", "titleSize", "subColor", "subFont", "subSize", ];
       const isFlat = flatProps.some((p) => Object.prototype.hasOwnProperty.call(entry, p), );
       if (isFlat) {
        const all = entry.all || {};
        flatProps.forEach((p) => {
         if (entry[p] !== undefined) {
          all[p] = entry[p];
          delete entry[p];
         }
        });
        entry.all = all;
       }
       return entry;
      }
      
      function getDefaultSize() {
       if (window.innerWidth <= 380) return 120;
       if (window.innerWidth <= 768) return 140;
       if (window.innerWidth <= 1024) return 70;
       return 55;
      }
      
      function createShapeElement(shape, size) {
       const ns = "http://www.w3.org/2000/svg";
       if (shape === "circle") {
        const c = document.createElementNS(ns, "circle");
        c.setAttribute("r", size);
        return c;
       }
       if (shape === "square") {
        const r = document.createElementNS(ns, "rect");
        const s = size * 2;
        r.setAttribute("x", -size);
        r.setAttribute("y", -size);
        r.setAttribute("width", s);
        r.setAttribute("height", s);
        r.setAttribute("rx", 4);
        return r;
       }
       if (shape === "rectangle") {
        const r = document.createElementNS(ns, "rect");
        r.setAttribute("x", -size * 1.4);
        r.setAttribute("y", -size * 0.8);
        r.setAttribute("width", size * 2.8);
        r.setAttribute("height", size * 1.6);
        r.setAttribute("rx", 6);
        return r;
       }
       if (shape === "triangle") {
        const p = document.createElementNS(ns, "polygon");
        const h = size * 1.8;
        const w = size * 2;
        p.setAttribute("points", `0,${-h} ${w / 2},${h / 2} ${-w / 2},${h / 2}`, );
        return p;
       }
       if (shape === "hexagon") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        const pts = [
         [0, -s],
         [s * 0.86, -s * 0.5],
         [s * 0.86, s * 0.5],
         [0, s],
         [-s * 0.86, s * 0.5],
         [-s * 0.86, -s * 0.5],
        ].map((pt) => pt.join(",")).join(" ");
        p.setAttribute("points", pts);
        return p;
       }
       if (shape === "stop-sign") {
        const p = document.createElementNS(ns, "polygon");
        const r = size;
        const ptsArr = [];
        for (let i = 0; i < 8; i++) {
         const a = (Math.PI / 4) * i + Math.PI / 8;
         ptsArr.push([Math.cos(a) * r, Math.sin(a) * r]);
        }
        const pts = ptsArr.map((pt) => pt.join(",")).join(" ");
        p.setAttribute("points", pts);
        return p;
       }
       if (shape === "star") {
        const p = document.createElementNS(ns, "polygon");
        const outer = size;
        const inner = size * 0.45;
        let pts = "";
        for (let i = 0; i < 10; i++) {
         const a = (Math.PI / 5) * i - Math.PI / 2;
         const r = i % 2 === 0 ? outer : inner;
         pts += `${Math.cos(a) * r},${Math.sin(a) * r} `;
        }
        p.setAttribute("points", pts.trim());
        return p;
       }
       if (shape === "diamond") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `0,${-s} ${s},0 0,${s} ${-s},0`);
        return p;
       }
       if (shape === "server") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.2);
        body.setAttribute("y", -size * 0.6);
        body.setAttribute("width", size * 2.4);
        body.setAttribute("height", size * 1.2);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 3; i++) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", -size * 0.9 + i * size * 0.5);
         line.setAttribute("y1", -size * 0.3);
         line.setAttribute("x2", -size * 0.9 + i * size * 0.5);
         line.setAttribute("y2", size * 0.3);
         line.style.stroke = "currentColor";
         line.style.strokeWidth = "2";
         line.style.opacity = "0.5";
         g.appendChild(line);
        }
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", size * 0.9);
        led.setAttribute("cy", 0);
        led.setAttribute("r", size * 0.1);
        led.style.fill = "#4ade80";
        g.appendChild(led);
        return g;
       }
       if (shape === "pc" || shape === "desktop") {
        const g = document.createElementNS(ns, "g");
        const monitor = document.createElementNS(ns, "rect");
        monitor.setAttribute("x", -size * 0.9);
        monitor.setAttribute("y", -size * 0.8);
        monitor.setAttribute("width", size * 1.8);
        monitor.setAttribute("height", size * 1.2);
        monitor.setAttribute("rx", 4);
        g.appendChild(monitor);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.75);
        screen.setAttribute("y", -size * 0.65);
        screen.setAttribute("width", size * 1.5);
        screen.setAttribute("height", size * 0.9);
        screen.setAttribute("rx", 2);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        const neck = document.createElementNS(ns, "rect");
        neck.setAttribute("x", -size * 0.15);
        neck.setAttribute("y", size * 0.4);
        neck.setAttribute("width", size * 0.3);
        neck.setAttribute("height", size * 0.3);
        g.appendChild(neck);
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.5);
        base.setAttribute("y", size * 0.7);
        base.setAttribute("width", size * 1);
        base.setAttribute("height", size * 0.15);
        base.setAttribute("rx", 2);
        g.appendChild(base);
        return g;
       }
       if (shape === "laptop") {
        const g = document.createElementNS(ns, "g");
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.8);
        screen.setAttribute("y", -size * 0.9);
        screen.setAttribute("width", size * 1.6);
        screen.setAttribute("height", size * 1.1);
        screen.setAttribute("rx", 4);
        g.appendChild(screen);
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.9);
        base.setAttribute("y", size * 0.25);
        base.setAttribute("width", size * 1.8);
        base.setAttribute("height", size * 0.6);
        base.setAttribute("rx", 4);
        g.appendChild(base);
        const pad = document.createElementNS(ns, "rect");
        pad.setAttribute("x", -size * 0.25);
        pad.setAttribute("y", size * 0.45);
        pad.setAttribute("width", size * 0.5);
        pad.setAttribute("height", size * 0.25);
        pad.setAttribute("rx", 2);
        pad.style.fill = "#1e293b";
        g.appendChild(pad);
        return g;
       }
       if (shape === "phone" || shape === "mobile") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.45);
        body.setAttribute("y", -size);
        body.setAttribute("width", size * 0.9);
        body.setAttribute("height", size * 2);
        body.setAttribute("rx", 8);
        g.appendChild(body);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.38);
        screen.setAttribute("y", -size * 0.85);
        screen.setAttribute("width", size * 0.76);
        screen.setAttribute("height", size * 1.6);
        screen.setAttribute("rx", 4);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        const btn = document.createElementNS(ns, "rect");
        btn.setAttribute("x", -size * 0.15);
        btn.setAttribute("y", size * 0.82);
        btn.setAttribute("width", size * 0.3);
        btn.setAttribute("height", size * 0.06);
        btn.setAttribute("rx", 2);
        btn.style.fill = "#475569";
        g.appendChild(btn);
        return g;
       }
       if (shape === "router") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.1);
        body.setAttribute("y", -size * 0.3);
        body.setAttribute("width", size * 2.2);
        body.setAttribute("height", size * 0.8);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        for (let i = -1; i <= 1; i++) {
         const ant = document.createElementNS(ns, "rect");
         ant.setAttribute("x", i * size * 0.6 - size * 0.05);
         ant.setAttribute("y", -size * 0.9);
         ant.setAttribute("width", size * 0.1);
         ant.setAttribute("height", size * 0.6);
         ant.setAttribute("rx", 2);
         g.appendChild(ant);
         const tip = document.createElementNS(ns, "circle");
         tip.setAttribute("cx", i * size * 0.6);
         tip.setAttribute("cy", -size * 0.95);
         tip.setAttribute("r", size * 0.08);
         g.appendChild(tip);
        }
        for (let i = 0; i < 4; i++) {
         const led = document.createElementNS(ns, "circle");
         led.setAttribute("cx", -size * 0.7 + i * size * 0.35);
         led.setAttribute("cy", size * 0.1);
         led.setAttribute("r", size * 0.06);
         led.style.fill = i < 2 ? "#4ade80" : "#facc15";
         g.appendChild(led);
        }
        return g;
       }
       if (shape === "switch") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.4);
        body.setAttribute("y", -size * 0.4);
        body.setAttribute("width", size * 2.8);
        body.setAttribute("height", size * 0.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 8; i++) {
         const port = document.createElementNS(ns, "rect");
         port.setAttribute("x", -size * 1.2 + i * size * 0.32);
         port.setAttribute("y", -size * 0.15);
         port.setAttribute("width", size * 0.22);
         port.setAttribute("height", size * 0.3);
         port.setAttribute("rx", 1);
         port.style.fill = "#1e293b";
         g.appendChild(port);
        }
        return g;
       }
       if (shape === "firewall") {
        const g = document.createElementNS(ns, "g");
        const wall = document.createElementNS(ns, "rect");
        wall.setAttribute("x", -size);
        wall.setAttribute("y", -size * 0.8);
        wall.setAttribute("width", size * 2);
        wall.setAttribute("height", size * 1.6);
        wall.setAttribute("rx", 4);
        g.appendChild(wall);
        for (let row = 0; row < 3; row++) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", -size * 0.85);
         line.setAttribute("y1", -size * 0.5 + row * size * 0.45);
         line.setAttribute("x2", size * 0.85);
         line.setAttribute("y2", -size * 0.5 + row * size * 0.45);
         line.style.stroke = "#475569";
         line.style.strokeWidth = "2";
         g.appendChild(line);
        }
        for (let row = 0; row < 4; row++) {
         const offset = row % 2 === 0 ? 0 : size * 0.35;
         for (let col = 0; col < 3; col++) {
          const line = document.createElementNS(ns, "line");
          const x = -size * 0.5 + col * size * 0.7 + offset;
          if (x > -size * 0.85 && x < size * 0.85) {
           line.setAttribute("x1", x);
           line.setAttribute("y1", -size * 0.8 + row * size * 0.45, );
           line.setAttribute("x2", x);
           line.setAttribute("y2", -size * 0.8 + row * size * 0.45 + size * 0.45, );
           line.style.stroke = "#475569";
           line.style.strokeWidth = "2";
           g.appendChild(line);
          }
         }
        }
        return g;
       }
       if (shape === "cloud") {
        const p = document.createElementNS(ns, "path");
        const s = size;
        p.setAttribute("d", `
             M ${-s * 0.8} ${s * 0.2}
             Q ${-s * 1.1} ${s * 0.2} ${-s * 1.1} ${-s * 0.1}
             Q ${-s * 1.1} ${-s * 0.5} ${-s * 0.7} ${-s * 0.5}
             Q ${-s * 0.7} ${-s * 0.9} ${-s * 0.2} ${-s * 0.9}
             Q ${s * 0.1} ${-s * 1.1} ${s * 0.5} ${-s * 0.8}
             Q ${s * 1} ${-s * 0.8} ${s * 1.1} ${-s * 0.3}
             Q ${s * 1.3} ${-s * 0.1} ${s * 1.1} ${s * 0.2}
             Q ${s * 1.1} ${s * 0.5} ${s * 0.7} ${s * 0.5}
             L ${-s * 0.5} ${s * 0.5}
             Q ${-s * 0.9} ${s * 0.5} ${-s * 0.9} ${s * 0.2}
             Z
            `, );
        return p;
       }
       if (shape === "database") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.7);
        body.setAttribute("y", -size * 0.6);
        body.setAttribute("width", size * 1.4);
        body.setAttribute("height", size * 1.4);
        g.appendChild(body);
        const top = document.createElementNS(ns, "ellipse");
        top.setAttribute("cx", 0);
        top.setAttribute("cy", -size * 0.6);
        top.setAttribute("rx", size * 0.7);
        top.setAttribute("ry", size * 0.25);
        g.appendChild(top);
        const bottom = document.createElementNS(ns, "ellipse");
        bottom.setAttribute("cx", 0);
        bottom.setAttribute("cy", size * 0.8);
        bottom.setAttribute("rx", size * 0.7);
        bottom.setAttribute("ry", size * 0.25);
        g.appendChild(bottom);
        const mid1 = document.createElementNS(ns, "ellipse");
        mid1.setAttribute("cx", 0);
        mid1.setAttribute("cy", -size * 0.15);
        mid1.setAttribute("rx", size * 0.7);
        mid1.setAttribute("ry", size * 0.2);
        mid1.style.fill = "none";
        mid1.style.stroke = "#475569";
        mid1.style.strokeWidth = "2";
        g.appendChild(mid1);
        const mid2 = document.createElementNS(ns, "ellipse");
        mid2.setAttribute("cx", 0);
        mid2.setAttribute("cy", size * 0.35);
        mid2.setAttribute("rx", size * 0.7);
        mid2.setAttribute("ry", size * 0.2);
        mid2.style.fill = "none";
        mid2.style.stroke = "#475569";
        mid2.style.strokeWidth = "2";
        g.appendChild(mid2);
        return g;
       }
       if (shape === "printer") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.4);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size * 0.9);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const trayTop = document.createElementNS(ns, "rect");
        trayTop.setAttribute("x", -size * 0.7);
        trayTop.setAttribute("y", -size * 0.8);
        trayTop.setAttribute("width", size * 1.4);
        trayTop.setAttribute("height", size * 0.4);
        trayTop.setAttribute("rx", 2);
        trayTop.style.fill = "#1e293b";
        g.appendChild(trayTop);
        const trayOut = document.createElementNS(ns, "rect");
        trayOut.setAttribute("x", -size * 0.6);
        trayOut.setAttribute("y", size * 0.5);
        trayOut.setAttribute("width", size * 1.2);
        trayOut.setAttribute("height", size * 0.35);
        trayOut.setAttribute("rx", 2);
        g.appendChild(trayOut);
        const paper = document.createElementNS(ns, "rect");
        paper.setAttribute("x", -size * 0.5);
        paper.setAttribute("y", size * 0.3);
        paper.setAttribute("width", size * 1);
        paper.setAttribute("height", size * 0.5);
        paper.style.fill = "#e2e8f0";
        g.appendChild(paper);
        return g;
       }
       if (shape === "access-point" || shape === "wifi") {
        const g = document.createElementNS(ns, "g");
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.3);
        base.setAttribute("y", size * 0.2);
        base.setAttribute("width", size * 0.6);
        base.setAttribute("height", size * 0.3);
        base.setAttribute("rx", 3);
        g.appendChild(base);
        for (let i = 1; i <= 3; i++) {
         const arc = document.createElementNS(ns, "path");
         const r = size * 0.3 * i;
         arc.setAttribute("d", `M ${-r * 0.7} ${size * 0.1 - r * 0.5} A ${r} ${r} 0 0 1 ${r * 0.7} ${size * 0.1 - r * 0.5}`);
         arc.style.fill = "none";
         arc.style.stroke = "currentColor";
         arc.style.strokeWidth = "2";
         arc.style.opacity = 1 - (i * 0.2);
         g.appendChild(arc);
        }
        return g;
       }
       if (shape === "load-balancer") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.5);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        const bar = document.createElementNS(ns, "line");
        bar.setAttribute("x1", -size * 0.6);
        bar.setAttribute("y1", 0);
        bar.setAttribute("x2", size * 0.6);
        bar.setAttribute("y2", 0);
        bar.style.stroke = "#4ade80";
        bar.style.strokeWidth = "3";
        g.appendChild(bar);
        [-1, 1].forEach(dir => {
         const arrow = document.createElementNS(ns, "path");
         arrow.setAttribute("d", `M ${dir * size * 0.3} ${-size * 0.2} L ${dir * size * 0.6} 0 L ${dir * size * 0.3} ${size * 0.2}`);
         arrow.style.fill = "none";
         arrow.style.stroke = "#4ade80";
         arrow.style.strokeWidth = "2";
         g.appendChild(arrow);
        });
        return g;
       }
       if (shape === "nas" || shape === "storage") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.8);
        body.setAttribute("y", -size * 0.9);
        body.setAttribute("width", size * 1.6);
        body.setAttribute("height", size * 1.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 4; i++) {
         const bay = document.createElementNS(ns, "rect");
         bay.setAttribute("x", -size * 0.6);
         bay.setAttribute("y", -size * 0.7 + i * size * 0.4);
         bay.setAttribute("width", size * 1.2);
         bay.setAttribute("height", size * 0.3);
         bay.setAttribute("rx", 2);
         bay.style.fill = "#1e293b";
         g.appendChild(bay);
        }
        return g;
       }
       if (shape === "gateway" || shape === "modem") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.5);
        body.setAttribute("y", -size * 0.9);
        body.setAttribute("width", size);
        body.setAttribute("height", size * 1.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 4; i++) {
         const led = document.createElementNS(ns, "circle");
         led.setAttribute("cx", 0);
         led.setAttribute("cy", -size * 0.6 + i * size * 0.35);
         led.setAttribute("r", size * 0.08);
         led.style.fill = ["#4ade80", "#4ade80", "#facc15", "#60a5fa"][i];
         g.appendChild(led);
        }
        return g;
       }
       if (shape === "vpn" || shape === "tunnel") {
        const g = document.createElementNS(ns, "g");
        const outer = document.createElementNS(ns, "ellipse");
        outer.setAttribute("cx", 0);
        outer.setAttribute("cy", 0);
        outer.setAttribute("rx", size);
        outer.setAttribute("ry", size * 0.6);
        g.appendChild(outer);
        const inner = document.createElementNS(ns, "ellipse");
        inner.setAttribute("cx", 0);
        inner.setAttribute("cy", 0);
        inner.setAttribute("rx", size * 0.5);
        inner.setAttribute("ry", size * 0.3);
        inner.style.fill = "#1e293b";
        g.appendChild(inner);
        const lock = document.createElementNS(ns, "rect");
        lock.setAttribute("x", -size * 0.15);
        lock.setAttribute("y", -size * 0.1);
        lock.setAttribute("width", size * 0.3);
        lock.setAttribute("height", size * 0.25);
        lock.setAttribute("rx", 2);
        lock.style.fill = "#4ade80";
        g.appendChild(lock);
        return g;
       }
       if (shape === "container") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.5);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 3; i++) {
         const block = document.createElementNS(ns, "rect");
         block.setAttribute("x", -size * 0.8 + i * size * 0.55);
         block.setAttribute("y", -size * 0.3);
         block.setAttribute("width", size * 0.45);
         block.setAttribute("height", size * 0.6);
         block.setAttribute("rx", 2);
         block.style.fill = "#1e293b";
         g.appendChild(block);
        }
        return g;
       }
       if (shape === "vm" || shape === "virtual") {
        const g = document.createElementNS(ns, "g");
        const shadow = document.createElementNS(ns, "rect");
        shadow.setAttribute("x", -size * 0.85 + 4);
        shadow.setAttribute("y", -size * 0.65 + 4);
        shadow.setAttribute("width", size * 1.7);
        shadow.setAttribute("height", size * 1.3);
        shadow.setAttribute("rx", 4);
        shadow.style.opacity = "0.3";
        g.appendChild(shadow);
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.85);
        body.setAttribute("y", -size * 0.65);
        body.setAttribute("width", size * 1.7);
        body.setAttribute("height", size * 1.3);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.65);
        screen.setAttribute("y", -size * 0.45);
        screen.setAttribute("width", size * 1.3);
        screen.setAttribute("height", size * 0.7);
        screen.setAttribute("rx", 2);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        return g;
       }
       if (shape === "kubernetes" || shape === "k8s") {
        const g = document.createElementNS(ns, "g");
        const outer = document.createElementNS(ns, "circle");
        outer.setAttribute("cx", 0);
        outer.setAttribute("cy", 0);
        outer.setAttribute("r", size);
        g.appendChild(outer);
        const inner = document.createElementNS(ns, "circle");
        inner.setAttribute("cx", 0);
        inner.setAttribute("cy", 0);
        inner.setAttribute("r", size * 0.4);
        inner.style.fill = "#1e293b";
        g.appendChild(inner);
        for (let i = 0; i < 7; i++) {
         const angle = (Math.PI * 2 / 7) * i - Math.PI / 2;
         const spoke = document.createElementNS(ns, "line");
         spoke.setAttribute("x1", Math.cos(angle) * size * 0.4);
         spoke.setAttribute("y1", Math.sin(angle) * size * 0.4);
         spoke.setAttribute("x2", Math.cos(angle) * size * 0.85);
         spoke.setAttribute("y2", Math.sin(angle) * size * 0.85);
         spoke.style.stroke = "#326ce5";
         spoke.style.strokeWidth = "3";
         g.appendChild(spoke);
        }
        return g;
       }
       
       if (shape === "shield" || shape === "security") {
        const p = document.createElementNS(ns, "path");
        const s = size;
        p.setAttribute("d", `M 0 ${-s} L ${s * 0.85} ${-s * 0.5} L ${s * 0.85} ${s * 0.2} Q ${s * 0.7} ${s * 0.9} 0 ${s} Q ${-s * 0.7} ${s * 0.9} ${-s * 0.85} ${s * 0.2} L ${-s * 0.85} ${-s * 0.5} Z`);
        return p;
       }
       if (shape === "camera" || shape === "cctv") {
        const g = document.createElementNS(ns, "g");
        const mount = document.createElementNS(ns, "rect");
        mount.setAttribute("x", -size * 1.1);
        mount.setAttribute("y", -size * 0.5);
        mount.setAttribute("width", size * 0.25);
        mount.setAttribute("height", size * 0.6);
        mount.setAttribute("rx", 2);
        g.appendChild(mount);
        const arm = document.createElementNS(ns, "rect");
        arm.setAttribute("x", -size * 0.9);
        arm.setAttribute("y", -size * 0.15);
        arm.setAttribute("width", size * 0.5);
        arm.setAttribute("height", size * 0.15);
        g.appendChild(arm);
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.45);
        body.setAttribute("y", -size * 0.35);
        body.setAttribute("width", size * 1.1);
        body.setAttribute("height", size * 0.7);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const lensHousing = document.createElementNS(ns, "circle");
        lensHousing.setAttribute("cx", size * 0.85);
        lensHousing.setAttribute("cy", 0);
        lensHousing.setAttribute("r", size * 0.4);
        g.appendChild(lensHousing);
        const lensOuter = document.createElementNS(ns, "circle");
        lensOuter.setAttribute("cx", size * 0.85);
        lensOuter.setAttribute("cy", 0);
        lensOuter.setAttribute("r", size * 0.28);
        lensOuter.style.fill = "#1e293b";
        g.appendChild(lensOuter);
        const lensInner = document.createElementNS(ns, "circle");
        lensInner.setAttribute("cx", size * 0.85);
        lensInner.setAttribute("cy", 0);
        lensInner.setAttribute("r", size * 0.15);
        lensInner.style.fill = "#3b82f6";
        g.appendChild(lensInner);
        const reflection = document.createElementNS(ns, "circle");
        reflection.setAttribute("cx", size * 0.8);
        reflection.setAttribute("cy", -size * 0.05);
        reflection.setAttribute("r", size * 0.05);
        reflection.style.fill = "#93c5fd";
        g.appendChild(reflection);
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", -size * 0.2);
        led.setAttribute("cy", -size * 0.15);
        led.setAttribute("r", size * 0.06);
        led.style.fill = "#ef4444";
        g.appendChild(led);
        return g;
       }
       if (shape === "monitor" || shape === "dashboard") {
        const g = document.createElementNS(ns, "g");
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size);
        screen.setAttribute("y", -size * 0.7);
        screen.setAttribute("width", size * 2);
        screen.setAttribute("height", size * 1.2);
        screen.setAttribute("rx", 4);
        g.appendChild(screen);
        const graph = document.createElementNS(ns, "polyline");
        graph.setAttribute("points", `${-size * 0.8},${size * 0.2} ${-size * 0.3},${-size * 0.2} ${size * 0.2},${size * 0.1} ${size * 0.7},${-size * 0.3}`);
        graph.style.fill = "none";
        graph.style.stroke = "#4ade80";
        graph.style.strokeWidth = "3";
        g.appendChild(graph);
        return g;
       }
       if (shape === "docker" || shape === "whale") {
        const g = document.createElementNS(ns, "g");
        const s = size;
        const body = document.createElementNS(ns, "path");
        body.setAttribute("d", `
         M ${-s * 0.9} ${s * 0.2}
         Q ${-s * 1.1} ${s * 0.5} ${-s * 0.7} ${s * 0.7}
         Q ${-s * 0.3} ${s * 0.85} ${s * 0.3} ${s * 0.75}
         Q ${s * 0.8} ${s * 0.6} ${s * 1.0} ${s * 0.3}
         Q ${s * 1.1} ${s * 0.1} ${s * 1.0} ${-s * 0.1}
         L ${s * 0.85} ${-s * 0.1}
         Q ${s * 0.7} ${-s * 0.15} ${s * 0.4} ${-s * 0.2}
         L ${-s * 0.5} ${-s * 0.2}
         Q ${-s * 0.8} ${-s * 0.1} ${-s * 0.9} ${s * 0.2}
         Z
        `);
        body.style.fill = "#0db7ed";
        g.appendChild(body);
        const tail = document.createElementNS(ns, "path");
        tail.setAttribute("d", `
         M ${-s * 0.85} ${s * 0.1}
         Q ${-s * 1.2} ${-s * 0.2} ${-s * 1.0} ${-s * 0.55}
         Q ${-s * 0.95} ${-s * 0.35} ${-s * 0.8} ${-s * 0.15}
         Z
        `);
        tail.style.fill = "#0db7ed";
        g.appendChild(tail);
        const belly = document.createElementNS(ns, "path");
        belly.setAttribute("d", `
         M ${-s * 0.5} ${s * 0.65}
         Q ${s * 0.1} ${s * 0.75} ${s * 0.6} ${s * 0.55}
         Q ${s * 0.8} ${s * 0.45} ${s * 0.9} ${s * 0.25}
         Q ${s * 0.7} ${s * 0.5} ${s * 0.3} ${s * 0.6}
         Q ${-s * 0.1} ${s * 0.7} ${-s * 0.5} ${s * 0.65}
         Z
        `);
        belly.style.fill = "#ffffff";
        belly.style.opacity = "0.3";
        g.appendChild(belly);
        for (let row = 0; row < 2; row++) {
         for (let col = 0; col < 3; col++) {
          const container = document.createElementNS(ns, "rect");
          container.setAttribute("x", -s * 0.45 + col * s * 0.35);
          container.setAttribute("y", -s * 0.7 + row * s * 0.28);
          container.setAttribute("width", s * 0.3);
          container.setAttribute("height", s * 0.23);
          container.setAttribute("rx", 2);
          container.style.fill = "#0db7ed";
          container.style.stroke = "#0a9ed8";
          container.style.strokeWidth = "1.5";
          g.appendChild(container);
         }
        }
        const topContainer = document.createElementNS(ns, "rect");
        topContainer.setAttribute("x", -s * 0.1);
        topContainer.setAttribute("y", -s * 0.95);
        topContainer.setAttribute("width", s * 0.3);
        topContainer.setAttribute("height", s * 0.23);
        topContainer.setAttribute("rx", 2);
        topContainer.style.fill = "#0db7ed";
        topContainer.style.stroke = "#0a9ed8";
        topContainer.style.strokeWidth = "1.5";
        g.appendChild(topContainer);
        const eye = document.createElementNS(ns, "circle");
        eye.setAttribute("cx", s * 0.65);
        eye.setAttribute("cy", s * 0.25);
        eye.setAttribute("r", s * 0.08);
        eye.style.fill = "#0a5f7a";
        g.appendChild(eye);
        
        return g;
       }
       if (shape === "rounded-square") {
        const r = document.createElementNS(ns, "rect");
        const s = size * 1.6;
        r.setAttribute("x", -s / 2);
        r.setAttribute("y", -s / 2);
        r.setAttribute("width", s);
        r.setAttribute("height", s);
        r.setAttribute("rx", size * 0.4);
        return r;
       }
       if (shape === "pill" || shape === "capsule") {
        const r = document.createElementNS(ns, "rect");
        r.setAttribute("x", -size * 1.2);
        r.setAttribute("y", -size * 0.5);
        r.setAttribute("width", size * 2.4);
        r.setAttribute("height", size);
        r.setAttribute("rx", size * 0.5);
        return r;
       }
       if (shape === "octagon") {
        const p = document.createElementNS(ns, "polygon");
        const r = size;
        const pts = [];
        for (let i = 0; i < 8; i++) {
         const a = (Math.PI / 4) * i - Math.PI / 8;
         pts.push([Math.cos(a) * r, Math.sin(a) * r]);
        }
        p.setAttribute("points", pts.map(pt => pt.join(",")).join(" "));
        return p;
       }
       if (shape === "pentagon") {
        const p = document.createElementNS(ns, "polygon");
        const pts = [];
        for (let i = 0; i < 5; i++) {
         const a = (Math.PI * 2 / 5) * i - Math.PI / 2;
         pts.push([Math.cos(a) * size, Math.sin(a) * size]);
        }
        p.setAttribute("points", pts.map(pt => pt.join(",")).join(" "));
        return p;
       }
       if (shape === "cross" || shape === "plus") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        const t = size * 0.35;
        p.setAttribute("points", `${-t},${-s} ${t},${-s} ${t},${-t} ${s},${-t} ${s},${t} ${t},${t} ${t},${s} ${-t},${s} ${-t},${t} ${-s},${t} ${-s},${-t} ${-t},${-t}`);
        return p;
       }
       if (shape === "parallelogram") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `${-s * 0.6},${-s * 0.6} ${s * 1.2},${-s * 0.6} ${s * 0.6},${s * 0.6} ${-s * 1.2},${s * 0.6}`);
        return p;
       }
       if (shape === "trapezoid") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `${-s * 0.6},${-s * 0.6} ${s * 0.6},${-s * 0.6} ${s},${s * 0.6} ${-s},${s * 0.6}`);
        return p;
       }
       if (shape === "sensor" || shape === "iot") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "circle");
        body.setAttribute("cx", 0);
        body.setAttribute("cy", 0);
        body.setAttribute("r", size * 0.7);
        g.appendChild(body);
        const ant = document.createElementNS(ns, "line");
        ant.setAttribute("x1", 0);
        ant.setAttribute("y1", -size * 0.7);
        ant.setAttribute("x2", 0);
        ant.setAttribute("y2", -size);
        ant.style.stroke = "currentColor";
        ant.style.strokeWidth = "2";
        g.appendChild(ant);
        const tip = document.createElementNS(ns, "circle");
        tip.setAttribute("cx", 0);
        tip.setAttribute("cy", -size);
        tip.setAttribute("r", size * 0.1);
        tip.style.fill = "#4ade80";
        g.appendChild(tip);
        return g;
       }
       if (shape === "pi" || shape === "sbc" || shape === "raspberry") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.65);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size * 1.3);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 10; i++) {
         const pin = document.createElementNS(ns, "rect");
         pin.setAttribute("x", -size * 0.85 + i * size * 0.19);
         pin.setAttribute("y", -size * 0.8);
         pin.setAttribute("width", size * 0.08);
         pin.setAttribute("height", size * 0.15);
         pin.style.fill = "#facc15";
         g.appendChild(pin);
        }
        const port = document.createElementNS(ns, "rect");
        port.setAttribute("x", size * 0.6);
        port.setAttribute("y", -size * 0.2);
        port.setAttribute("width", size * 0.35);
        port.setAttribute("height", size * 0.4);
        port.style.fill = "#1e293b";
        g.appendChild(port);
        return g;
       }
       if (shape === "api" || shape === "endpoint") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.9);
        body.setAttribute("y", -size * 0.7);
        body.setAttribute("width", size * 1.8);
        body.setAttribute("height", size * 1.4);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        const left = document.createElementNS(ns, "text");
        left.setAttribute("x", -size * 0.5);
        left.setAttribute("y", size * 0.15);
        left.setAttribute("font-size", size * 0.9);
        left.setAttribute("fill", "#4ade80");
        left.setAttribute("font-family", "monospace");
        left.textContent = "{";
        g.appendChild(left);
        const right = document.createElementNS(ns, "text");
        right.setAttribute("x", size * 0.15);
        right.setAttribute("y", size * 0.15);
        right.setAttribute("font-size", size * 0.9);
        right.setAttribute("fill", "#4ade80");
        right.setAttribute("font-family", "monospace");
        right.textContent = "}";
        g.appendChild(right);
        return g;
       }
       if (shape === "queue" || shape === "message") {
        const g = document.createElementNS(ns, "g");
        for (let i = 2; i >= 0; i--) {
         const card = document.createElementNS(ns, "rect");
         card.setAttribute("x", -size * 0.7 + i * 4);
         card.setAttribute("y", -size * 0.5 + i * 4);
         card.setAttribute("width", size * 1.4);
         card.setAttribute("height", size * 0.8);
         card.setAttribute("rx", 3);
         card.style.opacity = 1 - i * 0.25;
         g.appendChild(card);
        }
        return g;
       }
       if (shape === "lambda" || shape === "function") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.8);
        body.setAttribute("y", -size * 0.8);
        body.setAttribute("width", size * 1.6);
        body.setAttribute("height", size * 1.6);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const lambda = document.createElementNS(ns, "text");
        lambda.setAttribute("x", 0);
        lambda.setAttribute("y", size * 0.2);
        lambda.setAttribute("font-size", size * 1.2);
        lambda.setAttribute("fill", "#f59e0b");
        lambda.setAttribute("text-anchor", "middle");
        lambda.setAttribute("font-family", "serif");
        lambda.textContent = "λ";
        g.appendChild(lambda);
        return g;
       }
       if (shape === "bucket" || shape === "s3") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "path");
        body.setAttribute("d", `M ${-size * 0.8} ${-size * 0.7} L ${-size * 0.6} ${size * 0.8} Q ${-size * 0.5} ${size} 0 ${size} Q ${size * 0.5} ${size} ${size * 0.6} ${size * 0.8} L ${size * 0.8} ${-size * 0.7} Z`);
        g.appendChild(body);
        const rim = document.createElementNS(ns, "ellipse");
        rim.setAttribute("cx", 0);
        rim.setAttribute("cy", -size * 0.7);
        rim.setAttribute("rx", size * 0.8);
        rim.setAttribute("ry", size * 0.25);
        g.appendChild(rim);
        return g;
       }   
       const c = document.createElementNS(ns, "circle");
       c.setAttribute("r", size);
       return c;
      }
      
      function createNodeShape(id, size) {
       const shapeType = (NODE_DATA[id] && NODE_DATA[id].shape) || "circle";
       const shapeEl = createShapeElement(shapeType, size);
       shapeEl.classList.add("node-circle");
       const styles = resolveStylesForNode(id);
       shapeEl.style.fill = styles.circleColor || PAGE_STATE.nodeFill || "#1e293b";
       shapeEl.style.stroke = styles.circleBorder || PAGE_STATE.nodeStroke || "#475569";
       return shapeEl;
      }
      
      function forgeTheLegend() {
       const container = document.getElementById("edge-legend");
       if (!container) return;
       container.innerHTML = "";
       const title = document.createElement("div");
       title.className = "legend-title";
       title.textContent = "Line Legend";
       container.appendChild(title);
       const closeBtn = document.createElement("button");
       closeBtn.type = "button";
       closeBtn.className = "legend-close-btn";
       closeBtn.textContent = "✕";
       closeBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        legendCollapsed = true;
        updateLegendVisibility();
       });
       container.appendChild(closeBtn);
       const colors = [...new Set(EDGE_DATA.list.map((e) => e.color).filter(Boolean))];
       if (colors.length === 0) {
        updateLegendVisibility();
        return;
       }
       colors.forEach((color) => {
        if (!EDGE_LEGEND[color]) {
         EDGE_LEGEND[color] = "you can edit me too";
        }
        const item = document.createElement("div");
        item.className = "legend-item";
        item.addEventListener("mousedown", (e) => e.stopPropagation());
        item.addEventListener("click", (e) => e.stopPropagation());
        const swatch = document.createElement("span");
        swatch.className = "legend-swatch";
        swatch.style.backgroundColor = color;
        swatch.style.cursor = "pointer";
        swatch.addEventListener("click", (e) => {
         e.stopPropagation();
         const edgeWithColor = EDGE_DATA.list.find(edge => edge.color === color);
         if (edgeWithColor) {
          selectTheConnection(edgeWithColor.id);
         }
        });
        let swatchTouchStart = null;
        let swatchTouchMoved = false;
        swatch.addEventListener("touchstart", (e) => {
         swatchTouchStart = Date.now();
         swatchTouchMoved = false;
         if (e.touches[0]) {
          swatchTouchStartX = e.touches[0].clientX;
          swatchTouchStartY = e.touches[0].clientY;
         }
        }, {
         passive: false
        });
        let swatchTouchStartX = 0, swatchTouchStartY = 0;
        swatch.addEventListener("touchmove", (e) => {
         if (e.touches[0]) {
          const dx = Math.abs(e.touches[0].clientX - swatchTouchStartX);
          const dy = Math.abs(e.touches[0].clientY - swatchTouchStartY);
          if (dx > 10 || dy > 10) swatchTouchMoved = true;
         }
        }, {
         passive: false
        });
        swatch.addEventListener("touchend", (e) => {
         if (swatchTouchStart && !swatchTouchMoved && Date.now() - swatchTouchStart < 400) {
          e.stopPropagation();
          e.preventDefault();
          const edgeWithColor = EDGE_DATA.list.find(edge => edge.color === color);
          if (edgeWithColor) {
           selectTheConnection(edgeWithColor.id);
          }
         }
         swatchTouchStart = null;
         swatchTouchMoved = false;
        }, {
         passive: false
        });
        const label = document.createElement("span");
        label.className = "legend-label";
        label.textContent = EDGE_LEGEND[color];
        if (isMobileDevice()) {
         label.style.cursor = "pointer";
         let labelTapStart = null;
         let labelTapMoved = false;
         label.addEventListener("touchstart", (e) => {
          labelTapStart = Date.now();
          labelTapMoved = false;
          if (e.touches[0]) {
           labelTapStartX = e.touches[0].clientX;
           labelTapStartY = e.touches[0].clientY;
          }
          e.stopPropagation();
         });
         let labelTapStartX = 0, labelTapStartY = 0;
         label.addEventListener("touchmove", (e) => {
          if (e.touches[0]) {
           const dx = Math.abs(e.touches[0].clientX - labelTapStartX);
           const dy = Math.abs(e.touches[0].clientY - labelTapStartY);
           if (dx > 10 || dy > 10) labelTapMoved = true;
          }
         });
         label.addEventListener("touchend", (e) => {
          if (labelTapStart && !labelTapMoved && Date.now() - labelTapStart < 400) {
           e.preventDefault();
           e.stopPropagation();
           const currentText = label.textContent;
           const newText = prompt("Edit legend label:", currentText);
           if (newText !== null && newText.trim()) {
            label.textContent = newText.trim();
            EDGE_LEGEND[color] = newText.trim();
            
           }
          }
          labelTapStart = null;
          labelTapMoved = false;
         });
        } else {
         label.contentEditable = true;
         label.addEventListener("focus", () => {
          label.classList.add("editing");
         });
         label.addEventListener("blur", () => {
          label.classList.remove("editing");
          const text = label.textContent.trim() || "you can edit me too";
          EDGE_LEGEND[color] = text;
          
         });
         label.addEventListener("keydown", (e) => {
          if (e.key === "Enter") {
           e.preventDefault();
           label.blur();
          }
         });
        }
        item.append(swatch, label);
        container.appendChild(item);
       });
       updateLegendVisibility();
      }
      
       function deleteRectangle(rectId) {
      pushUndo("delete zone");
        RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== rectId);
        forgeTheTopology();
       }
      
       function updateRectangleDeleteButtons() {
        const deleteButtons = document.querySelectorAll('.rect-delete-btn');
        deleteButtons.forEach(btn => {
         btn.style.display = rectDrawMode ? 'block' : 'none';
        });
       }
      
      function forgeTheTopology() {
       if (!NODE_DATA || !EDGE_DATA) {
        console.warn("forgeTheTopology called before data initialized");
        return;
       }
       const svg = document.getElementById("map");
       svg.innerHTML = "";
       const ns = "http://www.w3.org/2000/svg";
       const defs = document.createElementNS(ns, "defs");
       const markerForward = document.createElementNS(ns, "marker");
       markerForward.id = "arrow-forward";
       markerForward.setAttribute("markerWidth", "10");
       markerForward.setAttribute("markerHeight", "10");
       markerForward.setAttribute("refX", "9");
       markerForward.setAttribute("refY", "3");
       markerForward.setAttribute("orient", "auto");
       markerForward.setAttribute("markerUnits", "strokeWidth");
       const pathForward = document.createElementNS(ns, "path");
       pathForward.setAttribute("d", "M0,0 L0,6 L9,3 z");
       pathForward.setAttribute("fill", "context-stroke");
       markerForward.appendChild(pathForward);
       defs.appendChild(markerForward);
       const markerBackward = document.createElementNS(ns, "marker");
       markerBackward.id = "arrow-backward";
       markerBackward.setAttribute("markerWidth", "10");
       markerBackward.setAttribute("markerHeight", "10");
       markerBackward.setAttribute("refX", "0");
       markerBackward.setAttribute("refY", "3");
       markerBackward.setAttribute("orient", "auto");
       markerBackward.setAttribute("markerUnits", "strokeWidth");
       const pathBackward = document.createElementNS(ns, "path");
       pathBackward.setAttribute("d", "M9,0 L9,6 L0,3 z");
       pathBackward.setAttribute("fill", "context-stroke");
       markerBackward.appendChild(pathBackward);
       defs.appendChild(markerBackward);
       svg.appendChild(defs);
       const boundary = document.createElementNS(ns, "rect");
       boundary.setAttribute("x", CANVAS_PADDING);
       boundary.setAttribute("y", CANVAS_PADDING);
       boundary.setAttribute("width", CANVAS_WIDTH - CANVAS_PADDING * 2);
       boundary.setAttribute("height", CANVAS_HEIGHT - CANVAS_PADDING * 2);
       boundary.setAttribute("fill", "none");
       boundary.setAttribute("stroke", (PAGE_STATE.canvasBorder || "#475569") + "4D");
       boundary.setAttribute("stroke-width", "20");
       boundary.setAttribute("stroke-dasharray", "10 5");
       boundary.setAttribute("rx", "8");
       svg.appendChild(boundary);
       
       if (currentView.mode !== "rack") {
        const gridGroup = document.createElementNS(ns, "g");
        gridGroup.id = "canvas-grid";
        const gridSize = PAGE_STATE.canvasGridSize || 50;
        const gridColor = (PAGE_STATE.canvasGrid || "#475569") + "33";
        const majorGridColor = (PAGE_STATE.canvasGrid || "#475569") + "66";
        
        for (let x = CANVAS_PADDING; x <= CANVAS_WIDTH - CANVAS_PADDING; x += gridSize) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", x);
         line.setAttribute("y1", CANVAS_PADDING);
         line.setAttribute("x2", x);
         line.setAttribute("y2", CANVAS_HEIGHT - CANVAS_PADDING);
         line.setAttribute("stroke", (x - CANVAS_PADDING) % (gridSize * 5) === 0 ? majorGridColor : gridColor);
         line.setAttribute("stroke-width", (x - CANVAS_PADDING) % (gridSize * 5) === 0 ? "2" : "1");
         gridGroup.appendChild(line);
        }
        
        for (let y = CANVAS_PADDING; y <= CANVAS_HEIGHT - CANVAS_PADDING; y += gridSize) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", CANVAS_PADDING);
         line.setAttribute("y1", y);
         line.setAttribute("x2", CANVAS_WIDTH - CANVAS_PADDING);
         line.setAttribute("y2", y);
         line.setAttribute("stroke", (y - CANVAS_PADDING) % (gridSize * 5) === 0 ? majorGridColor : gridColor);
         line.setAttribute("stroke-width", (y - CANVAS_PADDING) % (gridSize * 5) === 0 ? "2" : "1");
         gridGroup.appendChild(line);
        }
        
        svg.appendChild(gridGroup);
       }
       
       if (currentView.mode === "rack" && currentView.rackId) {
        const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
        const rackGroup = document.createElementNS(ns, "g");
        rackGroup.id = "rack-visualization";
        
        const rackFrame = document.createElementNS(ns, "rect");
        rackFrame.setAttribute("x", RACK_START_X - RACK_WIDTH / 2);
        rackFrame.setAttribute("y", RACK_START_Y);
        rackFrame.setAttribute("width", RACK_WIDTH);
      
      rackFrame.setAttribute("height", rackCapacity * rackUHeight);
      
        rackFrame.setAttribute("fill", (PAGE_STATE.rackFrameFill || "#0f172a") + "4D");
        rackFrame.setAttribute("stroke", PAGE_STATE.rackFrameStroke || "#4fd1c5");
        rackFrame.setAttribute("stroke-width", "3");
        rackFrame.setAttribute("rx", "4");
        rackGroup.appendChild(rackFrame);
        
        for (let u = 0; u <= rackCapacity; u++) {
         const y = RACK_START_Y + u * rackUHeight;
      
         
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", RACK_START_X - RACK_WIDTH / 2);
         line.setAttribute("y1", y);
         line.setAttribute("x2", RACK_START_X + RACK_WIDTH / 2);
         line.setAttribute("y2", y);
         line.setAttribute("stroke", (PAGE_STATE.rackLineColor || "#475569") + "66");
         line.setAttribute("stroke-width", u % 5 === 0 ? "2" : "1");
         line.setAttribute("stroke-dasharray", u % 5 === 0 ? "none" : "5,5");
         rackGroup.appendChild(line);
         
         if (u < rackCapacity) {
          const uNumber = rackCapacity - u; 
          const text = document.createElementNS(ns, "text");
          text.setAttribute("x", RACK_START_X - RACK_WIDTH / 2 - 30);
          text.setAttribute("y", y + rackUHeight / 2);
      
          text.setAttribute("text-anchor", "middle");
          text.setAttribute("dominant-baseline", "middle");
          text.style.fill = PAGE_STATE.rackTextColor || "#4fd1c5";
          text.style.fontSize = "14px";
          text.style.fontWeight = "bold";
          text.textContent = `U${uNumber}`;
          rackGroup.appendChild(text);
          
          const textRight = document.createElementNS(ns, "text");
          textRight.setAttribute("x", RACK_START_X + RACK_WIDTH / 2 + 30);
          textRight.setAttribute("y", y + rackUHeight / 2);
      
          textRight.setAttribute("text-anchor", "middle");
          textRight.setAttribute("dominant-baseline", "middle");
          textRight.style.fill = PAGE_STATE.rackTextColor || "#4fd1c5";
          textRight.style.fontSize = "14px";
          textRight.style.fontWeight = "bold";
          textRight.textContent = `U${uNumber}`;
          rackGroup.appendChild(textRight);
         }
        }
        
        svg.appendChild(rackGroup);
       }
       
        if (RECT_DATA && RECT_DATA.list) {
         RECT_DATA.list.forEach((rect) => {
          if (currentView.mode === "rack") return;
          
          if (rect.style === "filled") {
           const g = document.createElementNS(ns, "g");
           g.classList.add("rect-group");
           g.dataset.rectId = rect.id;
           
           const rectEl = document.createElementNS(ns, "rect");
           rectEl.classList.add("rect-shape");
           rectEl.setAttribute("x", rect.x);
           rectEl.setAttribute("y", rect.y);
           rectEl.setAttribute("width", rect.width);
           rectEl.setAttribute("height", rect.height);
           rectEl.style.fill = rect.color;
           rectEl.style.fillOpacity = "0.3";
           rectEl.style.stroke = rect.borderColor || rect.color;
           rectEl.style.strokeWidth = (rect.borderWidth !== undefined ? rect.borderWidth : 2) + "px";
           if (rect.lineStyle === "dashed") { rectEl.style.strokeDasharray = "10,5"; }
           else if (rect.lineStyle === "dotted") { rectEl.style.strokeDasharray = "2,4"; }
           else { rectEl.style.strokeDasharray = "none"; }
           rectEl.style.cursor = "move";
           
          rectEl.addEventListener("click", (e) => {
		  if (isViewOnly()) return;
             if (rectDrawMode) return;
             e.stopPropagation();
             currentRectId = rect.id;
             selectTheRect(rect.id);
           });
           
           rectEl.addEventListener("contextmenu", (e) => {
		   if (isViewOnly()) return;
             e.preventDefault();
             e.stopPropagation();
             if (selectedRects.has(rect.id)) {
               selectedRects.delete(rect.id);
             } else {
               selectedRects.add(rect.id);
             }
             updateAllSelections();
           });
           
           let rectLastTap = 0;
           rectEl.addEventListener("touchend", (e) => {
             const now = Date.now();
             if (now - rectLastTap < 300) {
               e.preventDefault();
               if (selectedRects.has(rect.id)) {
                 selectedRects.delete(rect.id);
               } else {
                 selectedRects.add(rect.id);
               }
               updateAllSelections();
               if (navigator.vibrate) navigator.vibrate(50);
               rectLastTap = 0;
             } else {
               rectLastTap = now;
             }
           }, { passive: false });
      
           const deleteBtn = document.createElementNS(ns, "g");
           deleteBtn.classList.add("rect-delete-btn");
           deleteBtn.style.cursor = "pointer";
           deleteBtn.style.display = rectDrawMode ? "block" : "none";
           
           const deleteBg = document.createElementNS(ns, "circle");
           deleteBg.setAttribute("cx", rect.x + rect.width - 10);
           deleteBg.setAttribute("cy", rect.y + 10);
           deleteBg.setAttribute("r", 12);
           deleteBg.style.fill = "#f56565";
           deleteBg.style.stroke = "white";
           deleteBg.style.strokeWidth = "2";
           
           const deleteX = document.createElementNS(ns, "text");
           deleteX.setAttribute("x", rect.x + rect.width - 10);
           deleteX.setAttribute("y", rect.y + 10);
           deleteX.setAttribute("text-anchor", "middle");
           deleteX.setAttribute("dominant-baseline", "middle");
           deleteX.style.fill = "white";
           deleteX.style.fontSize = "16px";
           deleteX.style.fontWeight = "bold";
           deleteX.style.pointerEvents = "none";
           deleteX.textContent = "×";
           
           deleteBtn.appendChild(deleteBg);
           deleteBtn.appendChild(deleteX);
           
           deleteBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            e.preventDefault();
            deleteRectangle(rect.id);
           });
      
           deleteBtn.addEventListener("touchend", (e) => {
      e.stopPropagation();
           e.preventDefault();
           deleteRectangle(rect.id);
           });
           
           let isDragging = false;
           let dragStartX, dragStartY;
           let rectStartX, rectStartY;
           
         rectEl.addEventListener("mousedown", (e) => {
		 if (isViewOnly()) return;
      if (rectDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      rectStartX = rect.x;
      rectStartY = rect.y;
      rectEl.style.cursor = "grabbing";
      
      if (selectedRects.has(rect.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
           
           const moveHandler = (e) => {
      if (!isDragging || rectDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      
      rect.x = rectStartX + dx;
      rect.y = rectStartY + dy;
      
      if (selectedRects.has(rect.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       const newX = initialPositions[nodeId].x + dx;
       const newY = initialPositions[nodeId].y + dy;
       savedPositions[nodeId] = { x: newX, y: newY };
      }
      });
      selectedRects.forEach(rectId => {
      if (rectId === rect.id) return;
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      
      forgeTheTopology();
      };
           
           const upHandler = () => {
            if (isDragging) {
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           };
           
           document.addEventListener("mousemove", moveHandler);
           document.addEventListener("mouseup", upHandler);
           
           let touchStartX, touchStartY;
           let touchRectStartX, touchRectStartY;
           
           rectEl.addEventListener("touchstart", (e) => {
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchRectStartX = rect.x;
            touchRectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           }, { passive: false });
           
           rectEl.addEventListener("touchmove", (e) => {
            if (!isDragging || rectDrawMode) return;
            if (!e.touches[0]) return;
            e.preventDefault();
            e.stopPropagation();
            
            const svgEl = svg;
            const pt1 = svgEl.createSVGPoint();
            pt1.x = touchStartX;
            pt1.y = touchStartY;
            const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
            
            const touch = e.touches[0];
            const pt2 = svgEl.createSVGPoint();
            pt2.x = touch.clientX;
            pt2.y = touch.clientY;
            const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
            
            const dx = svgP2.x - svgP1.x;
            const dy = svgP2.y - svgP1.y;
            
            rect.x = touchRectStartX + dx;
            rect.y = touchRectStartY + dy;
            
            forgeTheTopology();
           }, { passive: false });
           
           rectEl.addEventListener("touchend", (e) => {
            if (isDragging) {
             e.preventDefault();
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           }, { passive: false });
            if (currentRectId === rect.id) {
      const corners = [
      { cx: rect.x, cy: rect.y, cursor: 'nwse-resize', dx: -1, dy: -1 },
      { cx: rect.x + rect.width, cy: rect.y, cursor: 'nesw-resize', dx: 1, dy: -1 },
      { cx: rect.x, cy: rect.y + rect.height, cursor: 'nesw-resize', dx: -1, dy: 1 },
      { cx: rect.x + rect.width, cy: rect.y + rect.height, cursor: 'nwse-resize', dx: 1, dy: 1 }
      ];
      corners.forEach((corner, idx) => {
      const handle = document.createElementNS(ns, "circle");
      handle.setAttribute("cx", corner.cx);
      handle.setAttribute("cy", corner.cy);
      handle.setAttribute("r", PAGE_STATE.selectionHandleSize || 8);
      handle.style.fill = PAGE_STATE.selectionHandle || "#f59e0b";
      handle.style.stroke = "#fff";
      handle.style.strokeWidth = "2";
      handle.style.cursor = corner.cursor;
      handle.addEventListener("mousedown", (e) => {
      e.preventDefault();
      e.stopPropagation();
      let dragging = true;
      const startX = e.clientX, startY = e.clientY;
      const origX = rect.x, origY = rect.y, origW = rect.width, origH = rect.height;
      const moveHandler = (ev) => {
        if (!dragging) return;
        const pt1 = svg.createSVGPoint(); pt1.x = startX; pt1.y = startY;
        const pt2 = svg.createSVGPoint(); pt2.x = ev.clientX; pt2.y = ev.clientY;
        const svgP1 = pt1.matrixTransform(svg.getScreenCTM().inverse());
        const svgP2 = pt2.matrixTransform(svg.getScreenCTM().inverse());
        const dx = svgP2.x - svgP1.x, dy = svgP2.y - svgP1.y;
        if (corner.dx < 0) { rect.x = origX + dx; rect.width = origW - dx; }
        else { rect.width = origW + dx; }
        if (corner.dy < 0) { rect.y = origY + dy; rect.height = origH - dy; }
        else { rect.height = origH + dy; }
        if (rect.width < 20) rect.width = 20;
        if (rect.height < 20) rect.height = 20;
        forgeTheTopology();
      };
      const upHandler = () => { dragging = false; document.removeEventListener("mousemove", moveHandler); document.removeEventListener("mouseup", upHandler); };
      document.addEventListener("mousemove", moveHandler);
      document.addEventListener("mouseup", upHandler);
      });
      g.appendChild(handle);
      });
      }
          if (rect.groupId) {
      const groupIndicator = document.createElementNS(ns, "rect");
      groupIndicator.setAttribute("x", rect.x - 4);
      groupIndicator.setAttribute("y", rect.y - 4);
      groupIndicator.setAttribute("width", rect.width + 8);
      groupIndicator.setAttribute("height", rect.height + 8);
      groupIndicator.style.fill = "none";
      groupIndicator.style.stroke = "#4fd1c5";
      groupIndicator.style.strokeWidth = "3";
      groupIndicator.style.strokeDasharray = "5,5";
      groupIndicator.style.pointerEvents = "none";
      g.insertBefore(groupIndicator, g.firstChild);
      }
      g.appendChild(rectEl);
      g.appendChild(deleteBtn);
      svg.appendChild(g);
          }
         });
        }
       const centerX = CANVAS_WIDTH / 2;
       const centerY = CANVAS_HEIGHT / 2;
       let positions = {};
              Object.keys(NODE_DATA).forEach((id) => {
        if (currentView.mode === "rack") {
         const node = NODE_DATA[id];
         if (!node || node.assignedRack !== currentView.rackId) {
          return; 
         }
        }
        
        positions[id] = savedPositions[id] || {
         x: centerX,
         y: centerY
        };
       });
       if (Object.keys(savedPositions).length === 0) {
        const nodeIds = Object.keys(NODE_DATA).filter(id => {
         if (currentView.mode === "rack") {
          const node = NODE_DATA[id];
          return node && node.assignedRack === currentView.rackId;
         }
         return true;
        });
        
        const baseY = centerY - 300;
        if (nodeIds.length > 0) {
         positions[nodeIds[0]] = {
          x: centerX,
          y: baseY
         };
         const remaining = nodeIds.slice(1);
         const radius = 350;
         const startAngle = Math.PI * 0.3;
         const endAngle = Math.PI * 0.7;
         remaining.forEach((id, i) => {
          const angle = startAngle + (endAngle - startAngle) * (i / Math.max(1, remaining.length - 1));
          positions[id] = {
           x: centerX + Math.cos(angle) * radius * (i % 2 === 0 ? 1 : 1.3),
           y: baseY + 200 + Math.sin(angle) * radius * 0.8 + i * 80,
          };
         });
        }
       }
       Object.keys(positions).forEach((id) => {
        let pos = savedPositions[id] || positions[id];
        const nodeSize = savedSizes[id] || 55;
        pos.x = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, pos.x), );
        pos.y = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, pos.y), );
        positions[id] = {
         x: pos.x,
         y: pos.y
        };
        savedPositions[id] = {
         x: pos.x,
         y: pos.y
        };
       });
       const edgePairCount = {};
       const edgePairIndex = {};
       EDGE_DATA.list.forEach((edge) => {
        if (edge.type === "custom") return;
        const key = [edge.from, edge.to].sort().join("||");
        edgePairCount[key] = (edgePairCount[key] || 0) + 1;
       });
       EDGE_DATA.list.forEach((edge) => {
        if (edge.type === "custom") return;
        const key = [edge.from, edge.to].sort().join("||");
        if (!edgePairIndex[key]) edgePairIndex[key] = 0;
        edge._pairIndex = edgePairIndex[key];
        edge._pairTotal = edgePairCount[key];
        edgePairIndex[key]++;
       });
       EDGE_DATA.list.forEach((edge) => {
        if (edge.type === "custom" && Array.isArray(edge.points) && edge.points.length >= 2) {
         const poly = document.createElementNS(ns, "polyline");
         poly.classList.add("edge");
         poly.dataset.edgeId = edge.id;
         poly.style.stroke = edge.color || PAGE_STATE.defaultEdge || "#475569";
         poly.style.strokeWidth = edge.width || 4;
         poly.setAttribute("fill", "none");
         const lineStyle = edge.lineStyle || "solid";
         if (lineStyle === "dashed") {
          poly.style.strokeDasharray = "10,5";
         } else if (lineStyle === "dotted") {
          poly.style.strokeDasharray = "2,4";
         } else {
          poly.style.strokeDasharray = "none";
         }
         const direction = edge.direction || "none";
         if (direction === "forward") {
          poly.setAttribute("marker-end", "url(#arrow-forward)");
         } else if (direction === "backward") {
          poly.setAttribute("marker-start", "url(#arrow-backward)");
         } else if (direction === "both") {
          poly.setAttribute("marker-start", "url(#arrow-backward)");
          poly.setAttribute("marker-end", "url(#arrow-forward)");
         }
         const ptsStr = edge.points.map((p) => `${p.x},${p.y}`).join(" ");
         poly.setAttribute("points", ptsStr);
         const polyHit = document.createElementNS(ns, "polyline");
         polyHit.setAttribute("points", ptsStr);
         polyHit.style.fill = "none";
         polyHit.style.stroke = "transparent";
         polyHit.style.strokeWidth = "20";
         polyHit.style.cursor = "pointer";
         polyHit.dataset.edgeId = edge.id;
         polyHit.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         let edgeTouchStart = null;
         let edgeTouchMoved = false;
         polyHit.addEventListener("touchstart", (e) => {
          edgeTouchStart = Date.now();
          edgeTouchMoved = false;
          if (e.touches[0]) {
           edgeTouchStartX = e.touches[0].clientX;
           edgeTouchStartY = e.touches[0].clientY;
          }
         }, {
          passive: false
         });
         let edgeTouchStartX = 0, edgeTouchStartY = 0;
         polyHit.addEventListener("touchmove", (e) => {
          if (e.touches[0]) {
           const dx = Math.abs(e.touches[0].clientX - edgeTouchStartX);
           const dy = Math.abs(e.touches[0].clientY - edgeTouchStartY);
           if (dx > 10 || dy > 10) edgeTouchMoved = true;
          }
         }, {
          passive: false
         });
         polyHit.addEventListener("touchend", (e) => {
          if (edgeTouchStart && !edgeTouchMoved && Date.now() - edgeTouchStart < 400) {
           e.stopPropagation();
           e.preventDefault();
           selectTheConnection(edge.id);
          }
          edgeTouchStart = null;
          edgeTouchMoved = false;
         }, {
          passive: false
         });
         poly.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         
         polyHit.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (selectedEdges.has(edge.id)) {
           selectedEdges.delete(edge.id);
          } else {
           selectedEdges.add(edge.id);
          }
          updateAllSelections();
         });
         
         let customEdgeLastTap = 0;
         polyHit.addEventListener("touchend", (e) => {
          const now = Date.now();
          if (now - customEdgeLastTap < 300) {
           e.preventDefault();
           if (selectedEdges.has(edge.id)) {
            selectedEdges.delete(edge.id);
           } else {
            selectedEdges.add(edge.id);
           }
           updateAllSelections();
           if (navigator.vibrate) navigator.vibrate(50);
           customEdgeLastTap = 0;
          } else {
           customEdgeLastTap = now;
          }
         }, { passive: false });   
         poly.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (selectedEdges.has(edge.id)) {
           selectedEdges.delete(edge.id);
          } else {
           selectedEdges.add(edge.id);
          }
          updateAllSelections();
         });
         
         let edgeLastTap = 0;
         poly.addEventListener("touchend", (e) => {
          const now = Date.now();
          if (now - edgeLastTap < 300) {
           e.preventDefault();
           if (selectedEdges.has(edge.id)) {
            selectedEdges.delete(edge.id);
           } else {
            selectedEdges.add(edge.id);
           }
           updateAllSelections();
           if (navigator.vibrate) navigator.vibrate(50);
           edgeLastTap = 0;
          } else {
           edgeLastTap = now;
          }
         });
         
         if (currentView.mode === "rack") {
          return;
         }
         if (edge.groupId) {
      const bounds = edge.points.reduce((acc, p) => ({ minX: Math.min(acc.minX, p.x), minY: Math.min(acc.minY, p.y), maxX: Math.max(acc.maxX, p.x), maxY: Math.max(acc.maxY, p.y) }), { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity });
      const groupIndicator = document.createElementNS(ns, "rect");
      groupIndicator.setAttribute("x", bounds.minX - 8);
      groupIndicator.setAttribute("y", bounds.minY - 8);
      groupIndicator.setAttribute("width", bounds.maxX - bounds.minX + 16);
      groupIndicator.setAttribute("height", bounds.maxY - bounds.minY + 16);
      groupIndicator.setAttribute("rx", "4");
      groupIndicator.style.fill = "none";
      groupIndicator.style.stroke = "#4fd1c5";
      groupIndicator.style.strokeWidth = "3";
      groupIndicator.style.strokeDasharray = "5,5";
      groupIndicator.style.pointerEvents = "none";
      svg.appendChild(groupIndicator);
      }
         let lineDragging = false;
      let lineDragStartX, lineDragStartY;
      let linePointsStart = [];
      
      polyHit.addEventListener("mousedown", (e) => {
      if (freeDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      lineDragging = true;
      lineDragStartX = e.clientX;
      lineDragStartY = e.clientY;
      linePointsStart = edge.points.map(p => ({x: p.x, y: p.y}));
      
      if (selectedEdges.has(edge.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
      
      const lineMoveHandler = (e) => {
      if (!lineDragging || freeDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = lineDragStartX;
      pt1.y = lineDragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      
      edge.points.forEach((p, i) => { p.x = linePointsStart[i].x + dx; p.y = linePointsStart[i].y + dy; });
      
      if (selectedEdges.has(edge.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       savedPositions[nodeId] = { x: initialPositions[nodeId].x + dx, y: initialPositions[nodeId].y + dy };
      }
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      if (edgeId === edge.id) return;
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      forgeTheTopology();
      };
      
      const lineUpHandler = () => { lineDragging = false; };
      document.addEventListener("mousemove", lineMoveHandler);
      document.addEventListener("mouseup", lineUpHandler);
      
      svg.appendChild(poly);
      svg.appendChild(polyHit);
         
         if (currentEdgeId === edge.id) {
          edge.points.forEach((p, idx) => {
           const c = document.createElementNS(ns, "circle");
           c.classList.add("edge-edit-point");
           c.setAttribute("cx", p.x);
           c.setAttribute("cy", p.y);
      c.setAttribute("r", PAGE_STATE.selectionHandleSize || 8);
           c.style.fill = PAGE_STATE.selectionHandle || "#f59e0b";
           c.style.stroke = "#fff";
           c.style.strokeWidth = "2";
           c.style.cursor = "move";
           c.dataset.edgeId = edge.id;
           c.dataset.pointIndex = String(idx);
           
           c.addEventListener("mousedown", (e) => {
		   if (isViewOnly()) return;
            e.preventDefault();
            e.stopPropagation();
            let dragging = true;
            const svgEl = svg;
            const moveHandler = (ev) => {
             if (!dragging) return;
             const pt = svgEl.createSVGPoint();
             pt.x = ev.clientX;
             pt.y = ev.clientY;
             const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
             edge.points[idx].x = svgP.x;
             edge.points[idx].y = svgP.y;
             forgeTheTopology();
            };
            const upHandler = () => {
             dragging = false;
             document.removeEventListener("mousemove", moveHandler);
             document.removeEventListener("mouseup", upHandler);
            };
            document.addEventListener("mousemove", moveHandler);
            document.addEventListener("mouseup", upHandler);
           });
           
           c.addEventListener("touchstart", (e) => {
            e.preventDefault();
            e.stopPropagation();
            let dragging = true;
            const svgEl = svg;
            const touchMoveHandler = (ev) => {
             if (!dragging || !ev.touches[0]) return;
             const pt = svgEl.createSVGPoint();
             pt.x = ev.touches[0].clientX;
             pt.y = ev.touches[0].clientY;
             const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
             edge.points[idx].x = svgP.x;
             edge.points[idx].y = svgP.y;
             forgeTheTopology();
            };
            const touchUpHandler = () => {
             dragging = false;
             document.removeEventListener("touchmove", touchMoveHandler);
             document.removeEventListener("touchend", touchUpHandler);
            };
            document.addEventListener("touchmove", touchMoveHandler);
            document.addEventListener("touchend", touchUpHandler);
           }, { passive: false });
           
           svg.appendChild(c);
          });
         }
         
         return;
        }
        const p1 = positions[edge.from];
        const p2 = positions[edge.to];
        if (!p1 || !p2) return;
        const pairTotal = edge._pairTotal || 1;
        const pairIndex = edge._pairIndex || 0;
        const midX = (p1.x + p2.x) / 2;
        const midY = (p1.y + p2.y) / 2;
        const dx = p2.x - p1.x;
        const dy = p2.y - p1.y;
        const len = Math.sqrt(dx * dx + dy * dy) || 1;
        const perpX = -dy / len;
        const perpY = dx / len;
        let offsetAmount = 0;
        if (pairTotal > 1) {
         offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
        }
        const ctrlX = midX + perpX * offsetAmount;
        const ctrlY = midY + perpY * offsetAmount;
        const path = document.createElementNS(ns, "path");
        path.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
        path.setAttribute("fill", "none");
        path.classList.add("edge");
        if (edge.type === "backup") path.classList.add("backup");
        path.dataset.edgeId = edge.id;
        path.dataset.from = edge.from;
        path.dataset.to = edge.to;
        path.style.stroke = edge.color;
        path.style.strokeWidth = edge.width;
        const pathHit = document.createElementNS(ns, "path");
        pathHit.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
        pathHit.setAttribute("fill", "none");
        pathHit.style.stroke = "transparent";
        pathHit.style.strokeWidth = "20";
        pathHit.style.cursor = "pointer";
        pathHit.dataset.edgeId = edge.id;
        pathHit.addEventListener("click", (e) => {
         e.stopPropagation();
         selectTheConnection(edge.id);
        });
        let pathTouchStart = null;
        let pathTouchMoved = false;
        pathHit.addEventListener("touchstart", (e) => {
         pathTouchStart = Date.now();
         pathTouchMoved = false;
         if (e.touches[0]) {
          pathTouchStartX = e.touches[0].clientX;
          pathTouchStartY = e.touches[0].clientY;
         }
        }, {
         passive: false
        });
        let pathTouchStartX = 0, pathTouchStartY = 0;
        pathHit.addEventListener("touchmove", (e) => {
         if (e.touches[0]) {
          const dx = Math.abs(e.touches[0].clientX - pathTouchStartX);
          const dy = Math.abs(e.touches[0].clientY - pathTouchStartY);
          if (dx > 10 || dy > 10) pathTouchMoved = true;
         }
        }, {
         passive: false
        });
        pathHit.addEventListener("touchend", (e) => {
         if (pathTouchStart && !pathTouchMoved && Date.now() - pathTouchStart < 400) {
          e.stopPropagation();
          e.preventDefault();
          selectTheConnection(edge.id);
         }
         pathTouchStart = null;
         pathTouchMoved = false;
        }, {
         passive: false
        });
        path.addEventListener("click", (e) => {
         e.stopPropagation();
         selectTheConnection(edge.id);
        });
        
        if (currentView.mode === "rack") {
         const fromNode = NODE_DATA[edge.from];
         const toNode = NODE_DATA[edge.to];
         if (!fromNode || !toNode || 
             fromNode.assignedRack !== currentView.rackId || 
             toNode.assignedRack !== currentView.rackId) {
          return; 
         }
        }
        
        const fromVisible = isNodeVisible(edge.from);
        const toVisible = isNodeVisible(edge.to);
        if (!fromVisible || !toVisible) {
         path.style.opacity = "0.1";
         path.style.pointerEvents = "none";
         pathHit.style.pointerEvents = "none";
        }
        
        svg.appendChild(path);
        svg.appendChild(pathHit);
        
        if (edge.fromPort || edge.toPort) {
         const ns = "http://www.w3.org/2000/svg";
         
         if (edge.fromPort) {
          const fromLabel = document.createElementNS(ns, "text");
          fromLabel.textContent = edge.fromPort;
          fromLabel.setAttribute("x", p1.x);
          fromLabel.setAttribute("y", p1.y - 10);
          fromLabel.setAttribute("text-anchor", "middle");
          fromLabel.style.fill = "#94a3b8";
          fromLabel.style.fontSize = "12px";
          fromLabel.style.fontWeight = "600";
          fromLabel.style.pointerEvents = "none";
          fromLabel.classList.add("port-label");
          svg.appendChild(fromLabel);
         }
         
         if (edge.toPort) {
          const toLabel = document.createElementNS(ns, "text");
          toLabel.textContent = edge.toPort;
          toLabel.setAttribute("x", p2.x);
          toLabel.setAttribute("y", p2.y - 10);
          toLabel.setAttribute("text-anchor", "middle");
          toLabel.style.fill = "#94a3b8";
          toLabel.style.fontSize = "12px";
          toLabel.style.fontWeight = "600";
          toLabel.style.pointerEvents = "none";
          toLabel.classList.add("port-label");
          svg.appendChild(toLabel);
         }
        }
       });
       Object.entries(positions).forEach(([id, pos]) => {
        const node = NODE_DATA[id];
        if (!node) return;
        
        if (currentView.mode === "rack") {
         if (node.assignedRack !== currentView.rackId) return;
         
         const rackUnit = parseInt(node.rackUnit) || 1;
      const uHeight = parseInt(node.uHeight) || 1;
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      pos.x = RACK_START_X;
      pos.y = RACK_START_Y + (rackCapacity - rackUnit - uHeight + 1) * rackUHeight + (uHeight * rackUHeight) / 2;
      
        } else {
         if (node.assignedRack) return;
        }
        
        const g = document.createElementNS("http://www.w3.org/2000/svg", "g", );
        g.classList.add("node-group");
        g.dataset.nodeId = id;
        g.setAttribute("transform", `translate(${pos.x},${pos.y})`);
        let r = savedSizes[id] || 55;
        if (!savedSizes[id]) {
         if (window.innerWidth <= 380) r = 120;
         else if (window.innerWidth <= 768) r = 140;
         else if (window.innerWidth <= 1024) r = 70;
        }
        const styles = resolveStylesForNode(id);
        const ns = "http://www.w3.org/2000/svg";
        const hitArea = document.createElementNS(ns, "circle");
        hitArea.setAttribute("r", r * 1.5);
        hitArea.style.fill = "transparent";
        hitArea.style.stroke = "none";
        hitArea.style.cursor = "grab";
        hitArea.classList.add("node-hit-area");
        const shapeEl = createNodeShape(id, r);
        const titleOffsetX = styles.titleOffsetX || 0;
        const titleOffsetY = styles.titleOffsetY || 0;
        const subOffsetX = styles.subOffsetX || 0;
        const subOffsetY = styles.subOffsetY || 0;
        const label = document.createElementNS("http://www.w3.org/2000/svg", "text", );
        label.classList.add("node-label");
        label.setAttribute("x", titleOffsetX);
        label.setAttribute("y", -r * 0.28 + titleOffsetY);
      const labelFontSize = styles.titleSize || PAGE_STATE.nodeTitleSize || r * 0.33;
        label.style.fontSize = labelFontSize + "px";
        label.textContent = NODE_DATA[id].name;
      label.style.fill = styles.titleColor || PAGE_STATE.nodeTitle || "#e2e8f0";
        label.style.fontFamily = styles.titleFont || PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
        label.style.pointerEvents = "none";
        const sub = document.createElementNS("http://www.w3.org/2000/svg", "text", );
        sub.classList.add("node-sub");
        sub.setAttribute("x", subOffsetX);
        sub.setAttribute("y", r * 0.4 + subOffsetY);
      const subFontSize = styles.subSize || PAGE_STATE.nodeSubSize || r * 0.24;
        sub.style.fontSize = subFontSize + "px";
        sub.textContent = NODE_DATA[id].ip;
      sub.style.fill = styles.subColor || PAGE_STATE.nodeSub || "#94a3b8";
        sub.style.fontFamily = styles.subFont || PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
        sub.style.pointerEvents = "none";
        g.append(hitArea, shapeEl, label, sub);
        
        if (NODE_DATA[id]?.locked) {
          const lockIcon = document.createElementNS(ns, "text");
          lockIcon.textContent = "🔒";
          lockIcon.setAttribute("x", r * 0.6);
          lockIcon.setAttribute("y", -r * 0.6);
          lockIcon.style.fontSize = (r * 0.4) + "px";
          lockIcon.style.pointerEvents = "none";
          lockIcon.style.userSelect = "none";
          lockIcon.classList.add("lock-indicator");
          g.appendChild(lockIcon);
        }
        
        if (NODE_DATA[id]?.groupId) {
          const groupIndicator = document.createElementNS(ns, "circle");
          groupIndicator.setAttribute("r", r + 4);
          groupIndicator.style.fill = "none";
      groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
          groupIndicator.style.strokeWidth = "3";
          groupIndicator.style.strokeDasharray = "5,5";
          groupIndicator.style.pointerEvents = "none";
          groupIndicator.classList.add("group-indicator");
          g.insertBefore(groupIndicator, g.firstChild);
        }
        
        let isDragging = false;
        let startX, startY;
        let initialPositions = {};
        let longPressTimer = null;
        let longPressTriggered = false;
        
        g.addEventListener("contextmenu", (e) => {
         e.preventDefault();
         e.stopPropagation();
         if (isViewOnly()) return;
         
         if (selectedNodes.has(id)) {
          selectedNodes.delete(id);
         } else {
          selectedNodes.add(id);
         }
         updateNodeSelection();
         return false;
        });
        
        g.addEventListener("touchstart", (e) => {
         if (NODE_DATA[id].isRack) {
          const touch = e.touches[0];
          longPressStartX = touch.clientX;
          longPressStartY = touch.clientY;
          longPressTimer = setTimeout(() => {
           longPressTriggered = true;
           if (navigator.vibrate) {
            navigator.vibrate(100);
           }
           enterRack(id);
          }, 500); 
         }
        }, { passive: true });
        
        let lastTapTime = 0;
        let lastTapNode = null;
        
        g.addEventListener("touchend", (e) => {
         const currentTime = new Date().getTime();
         const tapLength = currentTime - lastTapTime;
         
         if (tapLength < 300 && tapLength > 0 && lastTapNode === id) {
          e.preventDefault();
          e.stopPropagation();
          if (isViewOnly()) return;
          
          if (selectedNodes.has(id)) {
           selectedNodes.delete(id);
          } else {
           selectedNodes.add(id);
          }
          updateNodeSelection();
          
          if (navigator.vibrate) {
           navigator.vibrate(50);
          }
          
          lastTapTime = 0;
          lastTapNode = null;
         } else {
          lastTapTime = currentTime;
          lastTapNode = id;
         }
        });
        
        g.addEventListener("touchend", (e) => {
         if (longPressTimer) {
          clearTimeout(longPressTimer);
          longPressTimer = null;
         }
         if (longPressTriggered) {
          e.preventDefault();
          e.stopPropagation();
          longPressTriggered = false;
         }
        });
        
        let longPressStartX = 0;
        let longPressStartY = 0;
        g.addEventListener("touchmove", (e) => {
         if (longPressTimer) {
          const touch = e.touches[0];
          const dx = Math.abs(touch.clientX - longPressStartX);
          const dy = Math.abs(touch.clientY - longPressStartY);
          if (dx > 15 || dy > 15) {
           clearTimeout(longPressTimer);
           longPressTimer = null;
           longPressTriggered = false;
          }
         }
        });
        
        g.addEventListener("mousedown", (e) => {
		 if (isViewOnly()) return;
         if (e.button === 2) {
          return;
         }
         
         if (NODE_DATA[id]?.locked) {
          return;
         }
         
         e.preventDefault();
         isDragging = true;
         const svgEl = document.getElementById("map");
         const pt = svgEl.createSVGPoint();
         pt.x = e.clientX;
         pt.y = e.clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
         startX = svgP.x;
         startY = svgP.y;
      if (selectedNodes.has(id)) {
      initialPositions = {};
      const allSelectedRects = Array.from(selectedRects);
      const allSelectedTexts = Array.from(selectedTexts);
      const allSelectedEdges = Array.from(selectedEdges).map(eid => EDGE_DATA.list.find(e => e.id === eid)).filter(Boolean);   
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) {
      initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      }
      });
      Array.from(selectedRects).forEach(rectId => {
        const rect = RECT_DATA.list.find(r => r.id === rectId);
        if (rect) { rect._dragStartX = rect.x; rect._dragStartY = rect.y; }
      });
      Array.from(selectedTexts).forEach(textId => {
        const text = TEXT_DATA.list.find(t => t.id === textId);
        if (text) { text._dragStartX = text.x; text._dragStartY = text.y; }
      });
      Array.from(selectedEdges).forEach(edgeId => {
        const edge = EDGE_DATA.list.find(e => e.id === edgeId);
        if (edge && edge.points) { edge._dragStartPoints = edge.points.map(p => ({x: p.x, y: p.y})); }
      });
      
      
      
      
      } else {
      initialPositions = { [id]: { x: pos.x, y: pos.y } };
      }
      if (currentView.mode === "rack") {
      initialPositions[id] = { x: pos.x, y: pos.y };
      }
         
         g.style.cursor = "grabbing";
         hitArea.style.cursor = "grabbing";
         e.stopPropagation();
        });
        const handleMouseMove = (e) => {
         if (!isDragging) return;
         e.preventDefault();
         const svgEl = document.getElementById("map");
         const pt = svgEl.createSVGPoint();
         pt.x = e.clientX;
         pt.y = e.clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
         const dx = svgP.x - startX;
         const dy = svgP.y - startY;
         
         let nodesToMove = selectedNodes.has(id) ? Array.from(selectedNodes) : [id];
         
         const groupIds = new Set();
         nodesToMove.forEach(nodeId => {
          const groupId = NODE_DATA[nodeId]?.groupId;
          if (groupId) {
            groupIds.add(groupId);
          }
         });
         
         if (groupIds.size > 0) {
          Object.keys(NODE_DATA).forEach(nodeId => {
            const nodeGroupId = NODE_DATA[nodeId]?.groupId;
            if (nodeGroupId && groupIds.has(nodeGroupId)) {
              if (!nodesToMove.includes(nodeId)) {
                nodesToMove.push(nodeId);
                if (!initialPositions[nodeId]) {
                  const nodePos = savedPositions[nodeId];
                  if (nodePos) {
                    initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
                  }
                }
              }
            }
          });
         }
         
         nodesToMove = nodesToMove.filter(nodeId => !NODE_DATA[nodeId]?.locked);
         
         nodesToMove.forEach(nodeId => {
          if (!initialPositions[nodeId]) return;
          const initialPos = initialPositions[nodeId];
          let newX = initialPos.x + dx;
          let newY = initialPos.y + dy;
          const nodeSize = savedSizes[nodeId] || 55;
          newX = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, newX), );
          newY = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, newY), );
          
          savedPositions[nodeId] = { x: newX, y: newY };
          positions[nodeId] = { x: newX, y: newY };
          
          if (nodeId === id) {
           pos.x = newX;
           pos.y = newY;
          }
          
          const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
          if (nodeGroup) {
           nodeGroup.setAttribute("transform", `translate(${newX},${newY})`);
          }
         });
         
         Array.from(selectedRects).forEach(rectId => {
           const rect = RECT_DATA.list.find(r => r.id === rectId);
           if (rect && rect._dragStartX !== undefined) {
             rect.x = rect._dragStartX + dx;
             rect.y = rect._dragStartY + dy;
           }
         });
         Array.from(selectedTexts).forEach(textId => {
           const text = TEXT_DATA.list.find(t => t.id === textId);
           if (text && text._dragStartX !== undefined) {
             text.x = text._dragStartX + dx;
             text.y = text._dragStartY + dy;
           }
         });
         Array.from(selectedEdges).forEach(edgeId => {
           const edge = EDGE_DATA.list.find(e => e.id === edgeId);
           if (edge && edge._dragStartPoints) {
             edge.points.forEach((p, i) => {
               p.x = edge._dragStartPoints[i].x + dx;
               p.y = edge._dragStartPoints[i].y + dy;
             });
           }
         });
         forgeTheTopology();
         
         updateMinimap();
         document.querySelectorAll(".edge").forEach((edgeEl) => {
          const fromId = edgeEl.dataset.from;
          const toId = edgeEl.dataset.to;
          if (nodesToMove.includes(fromId) || nodesToMove.includes(toId)) {
           const p1 = savedPositions[fromId] || positions[fromId] || {
            x: 600,
            y: 350
           };
           const p2 = savedPositions[toId] || positions[toId] || {
            x: 600,
            y: 350
           };
           if (edgeEl.tagName === "line") {
            edgeEl.setAttribute("x1", p1.x);
            edgeEl.setAttribute("y1", p1.y);
            edgeEl.setAttribute("x2", p2.x);
            edgeEl.setAttribute("y2", p2.y);
           } else if (edgeEl.tagName === "path") {
            const edgeId = edgeEl.dataset.edgeId;
            const edge = EDGE_DATA.list.find(
             (e) => e.id === edgeId, );
            if (edge) {
             const pairTotal = edge._pairTotal || 1;
             const pairIndex = edge._pairIndex || 0;
             const midX = (p1.x + p2.x) / 2;
             const midY = (p1.y + p2.y) / 2;
             const dx = p2.x - p1.x;
             const dy = p2.y - p1.y;
             const len = Math.sqrt(dx * dx + dy * dy) || 1;
             const perpX = -dy / len;
             const perpY = dx / len;
             let offsetAmount = 0;
             if (pairTotal > 1) {
              offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
             }
             const ctrlX = midX + perpX * offsetAmount;
             const ctrlY = midY + perpY * offsetAmount;
             edgeEl.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
            }
           }
          }
         });
        };
      const handleMouseUp = () => {
      if (isDragging) {
      pushUndo("move nodes");
      isDragging = false;
      g.style.cursor = "grab";
      hitArea.style.cursor = "grab";
      if (currentView.mode === "rack" && NODE_DATA[id]?.assignedRack === currentView.rackId) {
      const draggedY = savedPositions[id]?.y || pos.y;
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      let newUnit = rackCapacity - Math.round((draggedY - RACK_START_Y) / rackUHeight);
      newUnit = Math.max(1, Math.min(newUnit, rackCapacity));
      NODE_DATA[id].rackUnit = newUnit;
      
      forgeTheTopology();
      claimTheImmortal(id);
      }
      }
      };
        document.addEventListener("mousemove", handleMouseMove);
        document.addEventListener("mouseup", handleMouseUp);
        let touchStartTime = 0;
        let touchStartX = 0;
        let touchStartY = 0;
        let touchMoved = false;
        g.addEventListener("touchstart",
         (e) => {
          if (isViewOnly()) {
           touchStartTime = Date.now();
           touchMoved = false;
           e.stopPropagation();
           return;
          }
          if (NODE_DATA[id]?.locked) {
           return;
          }
          
          e.preventDefault();
          touchStartTime = Date.now();
          touchMoved = false;
          const svgEl = document.getElementById("map");
          const pt = svgEl.createSVGPoint();
          const touch = e.touches[0];
          pt.x = touch.clientX;
          pt.y = touch.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          touchStartX = svgP.x;
          touchStartY = svgP.y;
          startX = svgP.x;
          startY = svgP.y;
          
          if (selectedNodes.has(id)) {
           initialPositions = {};
           selectedNodes.forEach(nodeId => {
            const nodePos = savedPositions[nodeId];
            if (nodePos) {
             initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
            }
           });
          } else {
           initialPositions = { [id]: { x: pos.x, y: pos.y } };
          }
          
          e.stopPropagation();
         }, {
          passive: false
         }, );
        g.addEventListener("touchmove", (e) => {
         e.preventDefault();
         const svgEl = document.getElementById("map");
         const pt = svgEl.createSVGPoint();
         const touch = e.touches[0];
         pt.x = touch.clientX;
         pt.y = touch.clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
         const dx = Math.abs(svgP.x - touchStartX);
         const dy = Math.abs(svgP.y - touchStartY);
         if (dx > (isMobileDevice() ? 4 : 10) || dy > (isMobileDevice() ? 4 : 10)) {
      touchMoved = true;
      isDragging = true;
      }
         if (!isDragging) return;
         
         const deltaX = svgP.x - startX;
         const deltaY = svgP.y - startY;
         
         let nodesToMove = selectedNodes.has(id) ? Array.from(selectedNodes) : [id];
         
         const groupIds = new Set();
         nodesToMove.forEach(nodeId => {
          const groupId = NODE_DATA[nodeId]?.groupId;
          if (groupId) {
            groupIds.add(groupId);
          }
         });
         
         if (groupIds.size > 0) {
          Object.keys(NODE_DATA).forEach(nodeId => {
            const nodeGroupId = NODE_DATA[nodeId]?.groupId;
            if (nodeGroupId && groupIds.has(nodeGroupId)) {
              if (!nodesToMove.includes(nodeId)) {
                nodesToMove.push(nodeId);
                if (!initialPositions[nodeId]) {
                  const nodePos = savedPositions[nodeId];
                  if (nodePos) {
                    initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
                  }
                }
              }
            }
          });
         }
         
         nodesToMove = nodesToMove.filter(nodeId => !NODE_DATA[nodeId]?.locked);
         
         nodesToMove.forEach(nodeId => {
          if (!initialPositions[nodeId]) return;
          const initialPos = initialPositions[nodeId];
          let newX = initialPos.x + deltaX;
          let newY = initialPos.y + deltaY;
          const nodeSize = savedSizes[nodeId] || 55;
          newX = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, newX), );
          newY = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, newY), );
          
          savedPositions[nodeId] = { x: newX, y: newY };
          positions[nodeId] = { x: newX, y: newY };
          
          if (nodeId === id) {
           pos.x = newX;
           pos.y = newY;
          }
          
          const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
          if (nodeGroup) {
           nodeGroup.setAttribute("transform", `translate(${newX},${newY})`);
          }
         });
         
         updateMinimap();
         document.querySelectorAll(".edge").forEach((edgeEl) => {
          const fromId = edgeEl.dataset.from;
          const toId = edgeEl.dataset.to;
          if (nodesToMove.includes(fromId) || nodesToMove.includes(toId)) {
           const p1 = savedPositions[fromId] || positions[fromId] || {
            x: 600,
            y: 350
           };
           const p2 = savedPositions[toId] || positions[toId] || {
            x: 600,
            y: 350
           };
           if (edgeEl.tagName === "line") {
            edgeEl.setAttribute("x1", p1.x);
            edgeEl.setAttribute("y1", p1.y);
            edgeEl.setAttribute("x2", p2.x);
            edgeEl.setAttribute("y2", p2.y);
           } else if (edgeEl.tagName === "path") {
            const edgeId = edgeEl.dataset.edgeId;
            const edge = EDGE_DATA.list.find(
             (e) => e.id === edgeId, );
            if (edge) {
             const pairTotal = edge._pairTotal || 1;
             const pairIndex = edge._pairIndex || 0;
             const midX = (p1.x + p2.x) / 2;
             const midY = (p1.y + p2.y) / 2;
             const dx = p2.x - p1.x;
             const dy = p2.y - p1.y;
             const len = Math.sqrt(dx * dx + dy * dy) || 1;
             const perpX = -dy / len;
             const perpY = dx / len;
             let offsetAmount = 0;
             if (pairTotal > 1) {
              offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
             }
             const ctrlX = midX + perpX * offsetAmount;
             const ctrlY = midY + perpY * offsetAmount;
             edgeEl.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
            }
           }
          }
         });
        }, {
         passive: false
        });
      g.addEventListener("touchend", (e) => {
      const touchDuration = Date.now() - touchStartTime;
      if (!touchMoved && touchDuration < 400) {
       if (isViewOnly()) {
        handleViewOnlyClick(id, 'node');
        return;
       }
       claimTheImmortal(id);
      }
      if (isDragging) {
      const draggedY = pos.y;
      isDragging = false;
      savedPositions[id] = {
      x: pos.x,
      y: pos.y
      };
      if (currentView.mode === "rack" && NODE_DATA[id]?.assignedRack === currentView.rackId) {
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      let newUnit = rackCapacity - Math.round((draggedY - RACK_START_Y) / rackUHeight);
      
      newUnit = Math.max(1, Math.min(newUnit, rackCapacity));
      NODE_DATA[id].rackUnit = newUnit;
      forgeTheTopology();
      claimTheImmortal(id);
      }
      }
      touchMoved = false;
      });
        g.style.cursor = "grab";
        g.addEventListener("click", (e) => {
         if (!isDragging) {
          if (isViewOnly()) {
           handleViewOnlyClick(id, 'node');
           return;
          }
          claimTheImmortal(id);
         }
        });
        
        g.addEventListener("dblclick", (e) => {
         e.preventDefault();
         e.stopPropagation();
         if (NODE_DATA[id].isRack) {
          enterRack(id);
         }
        });
        
        if (!isNodeVisible(id)) {
         g.style.opacity = "0.1";
         g.style.pointerEvents = "none";
        }
        
        svg.appendChild(g);
       });
        if (RECT_DATA && RECT_DATA.list) {
         RECT_DATA.list.forEach((rect) => {
          if (currentView.mode === "rack") return;
          if (rect.style === "outlined") {
           const g = document.createElementNS(ns, "g");
           g.classList.add("rect-group");
           g.dataset.rectId = rect.id;
           
           const rectEl = document.createElementNS(ns, "rect");
           rectEl.classList.add("rect-shape");
           rectEl.setAttribute("x", rect.x);
           rectEl.setAttribute("y", rect.y);
           rectEl.setAttribute("width", rect.width);
           rectEl.setAttribute("height", rect.height);
           rectEl.style.fill = "none";
           rectEl.style.stroke = rect.borderColor || rect.color;
           rectEl.style.strokeWidth = (rect.borderWidth !== undefined ? rect.borderWidth : 3) + "px";
           if (rect.lineStyle === "dashed") { rectEl.style.strokeDasharray = "10,5"; }
           else if (rect.lineStyle === "dotted") { rectEl.style.strokeDasharray = "2,4"; }
           else { rectEl.style.strokeDasharray = "none"; }
           rectEl.style.cursor = "move";
           
           rectEl.addEventListener("click", (e) => {
             if (rectDrawMode) return;
             e.stopPropagation();
             currentRectId = rect.id;
             selectTheRect(rect.id);
           });
           
           rectEl.addEventListener("contextmenu", (e) => {
		   if (isViewOnly()) return;
             e.preventDefault();
             e.stopPropagation();
             if (selectedRects.has(rect.id)) {
               selectedRects.delete(rect.id);
             } else {
               selectedRects.add(rect.id);
             }
             updateAllSelections();
           });
           
           let rectLastTap = 0;
           rectEl.addEventListener("touchend", (e) => {
             const now = Date.now();
             if (now - rectLastTap < 300) {
               e.preventDefault();
               if (selectedRects.has(rect.id)) {
                 selectedRects.delete(rect.id);
               } else {
                 selectedRects.add(rect.id);
               }
               updateAllSelections();
               if (navigator.vibrate) navigator.vibrate(50);
               rectLastTap = 0;
             } else {
               rectLastTap = now;
             }
           }, { passive: false });
           
           const deleteBtn = document.createElementNS(ns, "g");
           deleteBtn.classList.add("rect-delete-btn");
           deleteBtn.style.cursor = "pointer";
           deleteBtn.style.display = rectDrawMode ? "block" : "none";
           
           const deleteBg = document.createElementNS(ns, "circle");
           deleteBg.setAttribute("cx", rect.x + rect.width - 10);
           deleteBg.setAttribute("cy", rect.y + 10);
           deleteBg.setAttribute("r", 12);
           deleteBg.style.fill = "#f56565";
           deleteBg.style.stroke = "white";
           deleteBg.style.strokeWidth = "2";
           
           const deleteX = document.createElementNS(ns, "text");
           deleteX.setAttribute("x", rect.x + rect.width - 10);
           deleteX.setAttribute("y", rect.y + 10);
           deleteX.setAttribute("text-anchor", "middle");
           deleteX.setAttribute("dominant-baseline", "middle");
           deleteX.style.fill = "white";
           deleteX.style.fontSize = "16px";
           deleteX.style.fontWeight = "bold";
           deleteX.style.pointerEvents = "none";
           deleteX.textContent = "×";
           
           deleteBtn.appendChild(deleteBg);
           deleteBtn.appendChild(deleteX);
           
           deleteBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            e.preventDefault();
            deleteRectangle(rect.id);
           });
           
           let isDragging = false;
           let dragStartX, dragStartY;
           let rectStartX, rectStartY;
           
           rectEl.addEventListener("mousedown", (e) => {
		   if (isViewOnly()) return;
      if (rectDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      rectStartX = rect.x;
      rectStartY = rect.y;
      rectEl.style.cursor = "grabbing";
      
      if (selectedRects.has(rect.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
           
           const moveHandler = (e) => {
      if (!isDragging || rectDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      
      rect.x = rectStartX + dx;
      rect.y = rectStartY + dy;
      
      if (selectedRects.has(rect.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       const newX = initialPositions[nodeId].x + dx;
       const newY = initialPositions[nodeId].y + dy;
       savedPositions[nodeId] = { x: newX, y: newY };
      }
      });
      selectedRects.forEach(rectId => {
      if (rectId === rect.id) return;
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      
      forgeTheTopology();
      };
           
           const upHandler = () => {
            if (isDragging) {
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           };
           
           document.addEventListener("mousemove", moveHandler);
           document.addEventListener("mouseup", upHandler);
           
           let touchStartX, touchStartY;
           let touchRectStartX, touchRectStartY;
           
           rectEl.addEventListener("touchstart", (e) => {
		   if (isViewOnly()) return;
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchRectStartX = rect.x;
            touchRectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           }, { passive: false });
           
           rectEl.addEventListener("touchmove", (e) => {
            if (!isDragging || rectDrawMode) return;
            if (!e.touches[0]) return;
            e.preventDefault();
            e.stopPropagation();
            
            const svgEl = svg;
            const pt1 = svgEl.createSVGPoint();
            pt1.x = touchStartX;
            pt1.y = touchStartY;
            const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
            
            const touch = e.touches[0];
            const pt2 = svgEl.createSVGPoint();
            pt2.x = touch.clientX;
            pt2.y = touch.clientY;
            const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
            
            const dx = svgP2.x - svgP1.x;
            const dy = svgP2.y - svgP1.y;
            
            rect.x = touchRectStartX + dx;
            rect.y = touchRectStartY + dy;
            
            forgeTheTopology();
           }, { passive: false });
           
           rectEl.addEventListener("touchend", (e) => {
            if (isDragging) {
             e.preventDefault();
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           }, { passive: false });
           
           if (rect.groupId) {
             const groupIndicator = document.createElementNS(ns, "rect");
             groupIndicator.setAttribute("x", rect.x - 4);
             groupIndicator.setAttribute("y", rect.y - 4);
             groupIndicator.setAttribute("width", rect.width + 8);
             groupIndicator.setAttribute("height", rect.height + 8);
             groupIndicator.style.fill = "none";
             groupIndicator.style.stroke = "#4fd1c5";
             groupIndicator.style.strokeWidth = "3";
             groupIndicator.style.strokeDasharray = "5,5";
             groupIndicator.style.pointerEvents = "none";
             g.insertBefore(groupIndicator, g.firstChild);
           }
           g.appendChild(rectEl);
           g.appendChild(deleteBtn);
           svg.appendChild(g);
          }
         });
        }
        
        if (TEXT_DATA && TEXT_DATA.list) {
         TEXT_DATA.list.forEach((textItem) => {
          if (currentView.mode === "rack") return;
          
          const g = document.createElementNS(ns, "g");
          g.classList.add("text-group");
          g.dataset.textId = textItem.id;
          
          if (textItem.bgEnabled) {
           const bgRect = document.createElementNS(ns, "rect");
           bgRect.classList.add("text-bg");
           
           bgRect.setAttribute("x", textItem.x - 5);
           bgRect.setAttribute("y", textItem.y - textItem.fontSize - 2);
           bgRect.setAttribute("width", 100);
           bgRect.setAttribute("height", textItem.fontSize + 10);
           bgRect.style.fill = textItem.bgColor;
           bgRect.style.opacity = "0.7";
           bgRect.style.rx = "4";
           g.appendChild(bgRect);
          }
          
          const textEl = document.createElementNS(ns, "text");
          textEl.classList.add("text-element");
          textEl.setAttribute("x", textItem.x);
          textEl.setAttribute("y", textItem.y);
          textEl.style.fill = textItem.color;
          textEl.style.fontSize = textItem.fontSize + "px";
          textEl.style.fontWeight = textItem.fontWeight;
          textEl.style.fontStyle = textItem.fontStyle;
          textEl.style.textAnchor = textItem.textAlign;
          textEl.style.textDecoration = textItem.textDecoration;
          textEl.style.opacity = textItem.opacity;
          textEl.style.cursor = "move";
          textEl.style.userSelect = "none";
          textEl.setAttribute("dominant-baseline", "middle");
          
          const lines = textItem.content.split('\n');
          if (lines.length === 1) {
           textEl.textContent = textItem.content;
          } else {
           lines.forEach((line, i) => {
            const tspan = document.createElementNS(ns, "tspan");
            tspan.textContent = line;
            tspan.setAttribute("x", textItem.x);
            tspan.setAttribute("dy", i === 0 ? 0 : textItem.fontSize * 1.2);
            textEl.appendChild(tspan);
           });
          }
          
          g.appendChild(textEl);
          
          if (textItem.bgEnabled) {
           setTimeout(() => {
            try {
             const bbox = textEl.getBBox();
             const bgRect = g.querySelector('.text-bg');
             if (bgRect && bbox) {
              bgRect.setAttribute("x", bbox.x - 5);
              bgRect.setAttribute("y", bbox.y - 2);
              bgRect.setAttribute("width", bbox.width + 10);
              bgRect.setAttribute("height", bbox.height + 4);
             }
            } catch (e) {
            }
           }, 0);
          }
          
          const deleteBtn = document.createElementNS(ns, "g");
          deleteBtn.classList.add("text-delete-btn");
          deleteBtn.style.cursor = "pointer";
          deleteBtn.style.display = textDrawMode ? "block" : "none";
          
          const deleteBg = document.createElementNS(ns, "circle");
          deleteBg.setAttribute("cx", textItem.x + 20);
          deleteBg.setAttribute("cy", textItem.y - textItem.fontSize);
          deleteBg.setAttribute("r", 12);
          deleteBg.style.fill = "#f56565";
          deleteBg.style.stroke = "white";
          deleteBg.style.strokeWidth = "2";
          
          const deleteX = document.createElementNS(ns, "text");
          deleteX.setAttribute("x", textItem.x + 20);
          deleteX.setAttribute("y", textItem.y - textItem.fontSize);
          deleteX.setAttribute("text-anchor", "middle");
          deleteX.setAttribute("dominant-baseline", "middle");
          deleteX.style.fill = "white";
          deleteX.style.fontSize = "16px";
          deleteX.style.fontWeight = "bold";
          deleteX.style.pointerEvents = "none";
          deleteX.textContent = "×";
          
          deleteBtn.appendChild(deleteBg);
          deleteBtn.appendChild(deleteX);
          
          deleteBtn.addEventListener("click", (e) => {
           e.stopPropagation();
           e.preventDefault();
           deleteText(textItem.id);
          });
          
          let isDragging = false;
          let dragStartX, dragStartY;
          let textStartX, textStartY;
          
          textEl.addEventListener("mousedown", (e) => {
		  if (isViewOnly()) return;
      if (textDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      textStartX = textItem.x;
      textStartY = textItem.y;
      textEl.style.cursor = "grabbing";
      
      showTextPanel(textItem.id);
      
      if (selectedTexts.has(textItem.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
          
          const moveHandler = (e) => {
      if (!isDragging || textDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      
      textItem.x = textStartX + dx;
      textItem.y = textStartY + dy;
      
      if (selectedTexts.has(textItem.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       const newX = initialPositions[nodeId].x + dx;
       const newY = initialPositions[nodeId].y + dy;
       savedPositions[nodeId] = { x: newX, y: newY };
      }
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      if (textId === textItem.id) return;
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      
      forgeTheTopology();
      };
          
          const upHandler = () => {
           if (isDragging) {
            isDragging = false;
            textEl.style.cursor = "move";
           }
          };
          
          document.addEventListener("mousemove", moveHandler);
          document.addEventListener("mouseup", upHandler);
          
          let touchStartX = 0, touchStartY = 0;
          let textTouchStartX = 0, textTouchStartY = 0;
          
          textEl.addEventListener("touchstart", (e) => {
		   if (isViewOnly()) return;
           if (textDrawMode) return;
           if (e.touches.length !== 1) return;
           
           e.preventDefault();
           e.stopPropagation();
           const touch = e.touches[0];
           isDragging = true;
           touchStartX = touch.clientX;
           touchStartY = touch.clientY;
           textTouchStartX = textItem.x;
           textTouchStartY = textItem.y;
           
           showTextPanel(textItem.id);
          }, { passive: false });
          
          textEl.addEventListener("touchmove", (e) => {
           if (!isDragging || textDrawMode) return;
           if (e.touches.length !== 1) return;
           
           e.preventDefault();
           const touch = e.touches[0];
           const svgEl = svg;
           
           const pt1 = svgEl.createSVGPoint();
           pt1.x = touchStartX;
           pt1.y = touchStartY;
           const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
           
           const pt2 = svgEl.createSVGPoint();
           pt2.x = touch.clientX;
           pt2.y = touch.clientY;
           const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
           
           const dx = svgP2.x - svgP1.x;
           const dy = svgP2.y - svgP1.y;
           
           textItem.x = textTouchStartX + dx;
           textItem.y = textTouchStartY + dy;
           
           forgeTheTopology();
          }, { passive: false });
          
          textEl.addEventListener("touchend", () => {
           if (isDragging) {
            isDragging = false;
           }
          }, { passive: false });
          
          textEl.addEventListener("contextmenu", (e) => {
		  if (isViewOnly()) return;
           e.preventDefault();
           e.stopPropagation();
           if (selectedTexts.has(textItem.id)) {
            selectedTexts.delete(textItem.id);
           } else {
            selectedTexts.add(textItem.id);
           }
           updateAllSelections();
          });
          
          let textLastTap = 0;
          g.addEventListener("touchend", (e) => {
           const now = Date.now();
           if (now - textLastTap < 300) {
            e.preventDefault();
            if (selectedTexts.has(textItem.id)) {
             selectedTexts.delete(textItem.id);
            } else {
             selectedTexts.add(textItem.id);
            }
            updateAllSelections();
            if (navigator.vibrate) navigator.vibrate(50);
            textLastTap = 0;
           } else {
            textLastTap = now;
           }
          }, { passive: false });
          
          if (textItem.groupId) {
            const groupIndicator = document.createElementNS(ns, "rect");
            groupIndicator.setAttribute("x", textItem.x - 54);
            groupIndicator.setAttribute("y", textItem.y - 24);
            groupIndicator.setAttribute("width", 108);
            groupIndicator.setAttribute("height", 48);
            groupIndicator.setAttribute("rx", "8");
            groupIndicator.style.fill = "none";
            groupIndicator.style.stroke = "#4fd1c5";
            groupIndicator.style.strokeWidth = "3";
            groupIndicator.style.strokeDasharray = "5,5";
            groupIndicator.style.pointerEvents = "none";
            g.insertBefore(groupIndicator, g.firstChild);
          }
          g.appendChild(deleteBtn);
          svg.appendChild(g);
         });
        }
        
       forgeTheLegend();
       updateMinimap();
       populateRackDropdown();
      }
      
      function showEditModal(title, currentValue, onSave) {
       const modal = document.getElementById("edit-modal");
       const input = document.getElementById("modal-input");
       const titleEl = document.getElementById("modal-title");
       const saveBtn = document.getElementById("modal-save");
       const cancelBtn = document.getElementById("modal-cancel");
       titleEl.textContent = title;
       input.value = currentValue;
       modal.classList.add("active");
       input.focus();
       input.select();
       const handleSave = () => {
        if (input.value.trim()) {
         onSave(input.value.trim());
        }
        modal.classList.remove("active");
        saveBtn.removeEventListener("click", handleSave);
        cancelBtn.removeEventListener("click", handleCancel);
        input.removeEventListener("keypress", handleEnter);
       };
       const handleCancel = () => {
        modal.classList.remove("active");
        saveBtn.removeEventListener("click", handleSave);
        cancelBtn.removeEventListener("click", handleCancel);
        input.removeEventListener("keypress", handleEnter);
       };
       const handleEnter = (e) => {
        if (e.key === "Enter") handleSave();
       };
       saveBtn.addEventListener("click", handleSave);
       cancelBtn.addEventListener("click", handleCancel);
       input.addEventListener("keypress", handleEnter);
       modal.addEventListener("click", function bgHandler(e) {
        if (e.target === modal) {
         handleCancel();
         modal.removeEventListener("click", bgHandler);
        }
       });
      }
      
      function challengeTheImmortal(message, onConfirm) {
       const modal = document.getElementById("confirm-modal");
       const messageEl = document.getElementById("confirm-message");
       const deleteBtn = document.getElementById("confirm-delete");
       const cancelBtn = document.getElementById("confirm-cancel");
       messageEl.textContent = message;
       modal.classList.add("active");
       const handleConfirm = () => {
        onConfirm();
        modal.classList.remove("active");
        deleteBtn.removeEventListener("click", handleConfirm);
        cancelBtn.removeEventListener("click", handleCancel);
       };
       const handleCancel = () => {
        modal.classList.remove("active");
        deleteBtn.removeEventListener("click", handleConfirm);
        cancelBtn.removeEventListener("click", handleCancel);
       };
       deleteBtn.addEventListener("click", handleConfirm);
       cancelBtn.addEventListener("click", handleCancel);
       modal.addEventListener("click", function bgHandler(e) {
        if (e.target === modal) {
         handleCancel();
         modal.removeEventListener("click", bgHandler);
        }
       });
      }
      const pageTitleEl = document.getElementById("page-title");
      if (pageTitleEl) {
       pageTitleEl.addEventListener("click", () => {
        showEditModal("Edit Title", PAGE_STATE.title || DEFAULT_PAGE_STATE.title,
         (newTitle) => {
          PAGE_STATE.title = newTitle;
          wieldThePower();
         }, );
       });
      }
      
      function editNodeName(id) {
       showEditModal("Edit Name", NODE_DATA[id].name, (newName) => {
        NODE_DATA[id].name = newName;
        const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`, );
        if (nodeGroup) {
         const label = nodeGroup.querySelector(".node-label");
         if (label) label.textContent = newName;
        }
        if (currentNodeId === id) {
         document.getElementById("node-name").textContent = newName;
        }
       });
      }
      
      function editNodeIp(id) {
       showEditModal("Edit IP/Subtitle", NODE_DATA[id].ip, (newIp) => {
        NODE_DATA[id].ip = newIp;
        const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`, );
        if (nodeGroup) {
         const sub = nodeGroup.querySelector(".node-sub");
         if (sub) sub.textContent = newIp;
        }
        if (currentNodeId === id) {
         document.getElementById("node-ip").textContent = newIp;
        }
       });
      }
      
      function claimTheImmortal(id) {
	   if (isViewOnly()) return;
	   if (!NODE_DATA[id]) return;
       currentNodeId = id;
       currentEdgeId = null;
       currentRectId = null;
       currentTextId = null;
       
       if (isMobileDevice()) {
        const currentHeight = PAGE_STATE.mobileFooterHeight || 40;
        if (currentHeight <= 20) {
         PAGE_STATE.mobileFooterHeight = 80;
         const root = document.documentElement;
         root.style.setProperty("--mobile-footer-height", "80vh");
         const mobileFooterHeightInput = document.getElementById("mobile-footer-height");
         const mobileFooterHeightVal = document.getElementById("mobile-footer-height-val");
         if (mobileFooterHeightInput) mobileFooterHeightInput.value = 80;
         if (mobileFooterHeightVal) mobileFooterHeightVal.textContent = "80%";
        }
       }
       
       const data = NODE_DATA[id];
       document.querySelectorAll(".node-group").forEach((n) => {
        n.classList.toggle("active", n.dataset.nodeId === id);
       });
       document.querySelectorAll(".edge").forEach((e) => {
        const active = e.dataset.from === id || e.dataset.to === id;
        e.classList.toggle("active", active);
       });
       document.querySelectorAll(".rect-group").forEach((r) => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach((t) => t.classList.remove("active"));
       document.getElementById("node-panel").style.display = "block";
       document.getElementById("edge-panel").style.display = "none";
       document.getElementById("text-panel").style.display = "none";
       const toolbar = document.getElementById("topology-toolbar");
       if (!topologyToolbarCollapsed) {
        toolbar.style.display = "flex";
       }
       updateTopologyToolbarVisibility();
       document.getElementById("node-name").textContent = data.name;
       document.getElementById("node-ip").textContent = data.ip;
       document.getElementById("node-role").textContent = data.role;
       document.getElementById("node-mac").textContent = data.mac || "--";
       document.getElementById("node-rack").textContent = data.rackUnit || "--";
       document.getElementById("node-uheight").textContent = (data.uHeight || "1") + "U";
       document.getElementById("node-layer").value = data.layer || "physical";
       
       populateRackDropdown();
       const assignedRackSelect = document.getElementById("node-assigned-rack");
       if (assignedRackSelect) {
        assignedRackSelect.value = data.assignedRack || "";
       }
       
       const rackCapacitySelect = document.getElementById("node-rack-capacity");
       if (rackCapacitySelect) {
        rackCapacitySelect.value = data.rackCapacity || "42";
       }
       
       const isRack = data.isRack === true;
       const isAssignedToRack = !!data.assignedRack;
       const assignedRackRow = document.getElementById("assigned-rack-row");
       const rackCapacityRow = document.getElementById("rack-capacity-row");
       const uheightRow = document.getElementById("uheight-row");
       if (assignedRackRow) assignedRackRow.style.display = isRack ? "none" : "flex";
       if (rackCapacityRow) rackCapacityRow.style.display = isRack ? "flex" : "none";
       if (uheightRow) uheightRow.style.display = isAssignedToRack ? "flex" : "none";
       const rackContentsSection = document.getElementById("rack-contents-section");
       const rackContentsList = document.getElementById("rack-contents-list");
       if (rackContentsSection && rackContentsList) {
        if (isRack) {
         const nodesInRack = Object.entries(NODE_DATA).filter(([nid, n]) => n.assignedRack === id);
         if (nodesInRack.length > 0) {
          rackContentsList.innerHTML = nodesInRack.map(([nid, n]) => {
           const tags = (n.tags || []).map(t => `<span style="background: var(--accent); color: var(--bg); padding: 2px 6px; border-radius: 4px; font-size: 11px; margin-left: 4px;">${t}</span>`).join('');
           return `<div style="padding: 6px 0; border-bottom: 1px solid var(--edge-main); cursor: pointer;" onclick="claimTheImmortal('${nid}')">
            <span style="color: var(--text-main);">${n.name}</span>${tags}
           </div>`;
          }).join('');
          rackContentsSection.style.display = "block";
         } else {
          rackContentsList.innerHTML = '<div style="color: var(--text-soft); font-style: italic;">No nodes assigned</div>';
          rackContentsSection.style.display = "block";
         }
        } else {
         rackContentsSection.style.display = "none";
        }
       }
       document.getElementById("node-name").onclick = () => editNodeName(id);
       document.getElementById("node-ip").onclick = () => editNodeIp(id);
       document.getElementById("node-mac").onclick = () => editNodeMac(id);
       document.getElementById("node-rack").onclick = () => editNodeRack(id);
       document.getElementById("node-uheight").onclick = () => editNodeUHeight(id);
       const currentSize = savedSizes[id] || getDefaultSize();
       document.getElementById("size-slider").value = currentSize;
       document.getElementById("size-value").textContent = currentSize;
       const styleEntry = savedStyles[id] || {};
       const resolvedStyles = resolveStylesEntry(styleEntry);
       const scopeKey = currentStyleScope || "all";
       const flatProps = ["circleColor", "circleBorder", "titleColor", "titleFont", "titleSize", "subColor", "subFont", "subSize", ];
       const isFlat = flatProps.some((p) => Object.prototype.hasOwnProperty.call(styleEntry, p), );
       const scopedStyles = isFlat ? styleEntry : styleEntry[scopeKey] || {};
       const circleColorInput = document.getElementById("circle-color");
       const titleColorInput = document.getElementById("title-color");
       const titleFontSelect = document.getElementById("title-font");
       const titleSizeInput = document.getElementById("title-size");
       const subColorInput = document.getElementById("sub-color");
       const subFontSelect = document.getElementById("sub-font");
       const subSizeInput = document.getElementById("sub-size");
       const shapeSelect = document.getElementById("shape-select");
       const scopeSelect = document.getElementById("style-scope");
      circleColorInput.value = scopedStyles.circleColor || resolvedStyles.circleColor || PAGE_STATE.nodeFill || "#1e293b";
       const circleBorderInput = document.getElementById("circle-border");
       circleBorderInput.value = scopedStyles.circleBorder || resolvedStyles.circleBorder || PAGE_STATE.nodeStroke || "#475569";
        titleColorInput.value = scopedStyles.titleColor || resolvedStyles.titleColor || PAGE_STATE.textMain || "#e2e8f0";
        titleFontSelect.value = scopedStyles.titleFont || resolvedStyles.titleFont || "system-ui, sans-serif";
        titleSizeInput.value = scopedStyles.titleSize || resolvedStyles.titleSize || 18;
        subColorInput.value = scopedStyles.subColor || resolvedStyles.subColor || PAGE_STATE.textSoft || "#94a3b8";
       subFontSelect.value = scopedStyles.subFont || resolvedStyles.subFont || "system-ui, sans-serif";
       subSizeInput.value = scopedStyles.subSize || resolvedStyles.subSize || 13;
       shapeSelect.value = data.shape || "circle";
       scopeSelect.value = currentStyleScope || "all";
       document.getElementById("title-offset-y").value = scopedStyles.titleOffsetY || resolvedStyles.titleOffsetY || 0;
       document.getElementById("title-offset-x").value = scopedStyles.titleOffsetX || resolvedStyles.titleOffsetX || 0;
       document.getElementById("sub-offset-y").value = scopedStyles.subOffsetY || resolvedStyles.subOffsetY || 0;
       document.getElementById("sub-offset-x").value = scopedStyles.subOffsetX || resolvedStyles.subOffsetX || 0;
       const tagEl = document.getElementById("node-tags");
       tagEl.innerHTML = "";
       data.tags.forEach((tag, i) => {
        const b = document.createElement("span");
        b.className = "badge";
        if (tag.toLowerCase().includes("wg")) b.classList.add("wg");
        b.style.cursor = "pointer";
        b.style.position = "relative";
        const tagText = document.createElement("span");
        tagText.textContent = tag;
        tagText.addEventListener("click", (e) => {
         e.stopPropagation();
         showEditModal("Edit Tag", tag, (newTag) => {
          if (newTag) {
           data.tags[i] = newTag;
           claimTheImmortal(id);
          }
         });
        });
        const deleteTag = document.createElement("span");
        deleteTag.textContent = " ✕";
        deleteTag.style.opacity = "0.6";
        deleteTag.style.marginLeft = "4px";
        deleteTag.style.fontSize = "10px";
        deleteTag.addEventListener("click", (e) => {
         e.stopPropagation();
         data.tags.splice(i, 1);
         claimTheImmortal(id);
        });
        b.append(tagText, deleteTag);
        tagEl.append(b);
       });
       const addTagBtn = document.createElement("span");
       addTagBtn.className = "badge";
       addTagBtn.style.cursor = "pointer";
       addTagBtn.style.opacity = "0.6";
       addTagBtn.style.borderStyle = "dashed";
       addTagBtn.textContent = "+ Add Tag";
       addTagBtn.addEventListener("click", () => {
        showEditModal("Add Tag(s) : comma separated", "",
         (newTagStr) => {
          if (newTagStr) {
           const newTags = newTagStr.split(",").map((t) => t.trim()).filter((t) => t);
           newTags.forEach((t) => data.tags.push(t));
           claimTheImmortal(id);
          }
         }, );
       });
       tagEl.append(addTagBtn);
       const notesEl = document.getElementById("node-notes");
       notesEl.innerHTML = "";
       data.notes.forEach((note, i) => {
        const li = document.createElement("li");
        const noteText = document.createElement("span");
        noteText.textContent = note;
        noteText.style.flex = "1";
        const deleteBtn = document.createElement("span");
        deleteBtn.className = "delete-note";
        deleteBtn.textContent = "✕";
        deleteBtn.addEventListener("click", (e) => {
         e.stopPropagation();
         challengeTheImmortal("Are you sure you want to delete this note?",
          () => {
           data.notes.splice(i, 1);
           claimTheImmortal(id);
          }, );
        });
        li.append(noteText, deleteBtn);
        noteText.addEventListener("dblclick", () => {
         noteText.classList.add("editing");
         noteText.contentEditable = true;
         noteText.focus();
        });
        noteText.addEventListener("blur", () => {
         noteText.classList.remove("editing");
         noteText.contentEditable = false;
         data.notes[i] = noteText.textContent;
        });
        notesEl.append(li);
       });
      const addLineSelect = document.getElementById("add-line-select");
      addLineSelect.innerHTML = "";
      const currentRack = data.assignedRack || "";
      Object.entries(NODE_DATA).forEach(([nodeId, node]) => {
      if (nodeId !== id) {
      const nodeRack = node.assignedRack || "";
      if (currentRack === nodeRack) {
      const opt = document.createElement("option");
      opt.value = nodeId;
      opt.textContent = node.name;
      addLineSelect.appendChild(opt);
      }
      }
      });
      }
      
      function selectTheConnection(id) {
	   if (isViewOnly()) return;
       currentEdgeId = id;
       currentNodeId = null;
       currentRectId = null;
       currentTextId = null;
       
       if (isMobileDevice()) {
        const currentHeight = PAGE_STATE.mobileFooterHeight || 40;
        if (currentHeight <= 20) {
         PAGE_STATE.mobileFooterHeight = 80;
         const root = document.documentElement;
         root.style.setProperty("--mobile-footer-height", "80vh");
         const mobileFooterHeightInput = document.getElementById("mobile-footer-height");
         const mobileFooterHeightVal = document.getElementById("mobile-footer-height-val");
         if (mobileFooterHeightInput) mobileFooterHeightInput.value = 80;
         if (mobileFooterHeightVal) mobileFooterHeightVal.textContent = "80%";
        }
       }
       
       document.getElementById("node-panel").style.display = "none";
       document.getElementById("edge-panel").style.display = "block";
       document.getElementById("text-panel").style.display = "none";
       document.getElementById("rect-panel").style.display = "none";
       document.getElementById("topology-toolbar").style.display = "none";
       document.querySelectorAll(".node-group").forEach((n) => n.classList.remove("active"));
       document.querySelectorAll(".rect-group").forEach((r) => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach((t) => t.classList.remove("active"));
       document.querySelectorAll(".edge").forEach((e) => {
        e.classList.toggle("active", e.dataset.edgeId === id);
       });
       const edge = EDGE_DATA.list.find((e) => e.id === id);
       if (!edge) return;
       const directionSymbols = {
        none: "⇄",
        forward: "→",
        backward: "←",
        both: "↔",
       };
       const dirSymbol = directionSymbols[edge.direction] || "⇄";
       let titleText = "Custom line";
       if (edge.from || edge.to) {
        const fromName = edge.from ? NODE_DATA[edge.from]?.name || edge.from : "";
        const toName = edge.to ? NODE_DATA[edge.to]?.name || edge.to : "";
        titleText = `${fromName || "?"} ${dirSymbol} ${toName || "?"}`;
       }
       document.getElementById("edge-title").textContent = titleText;
       const widthInput = document.getElementById("edge-width");
       const colorInput = document.getElementById("edge-color");
       const directionSelect = document.getElementById("edge-direction");
       const lineStyleSelect = document.getElementById("edge-line-style");
       widthInput.value = edge.width;
       colorInput.value = edge.color;
       directionSelect.value = edge.direction || "none";
       lineStyleSelect.value = edge.lineStyle || "solid";
       
       const fromPortRow = document.getElementById("edge-from-port-row");
       const toPortRow = document.getElementById("edge-to-port-row");
       const fromPortInput = document.getElementById("edge-from-port");
       const toPortInput = document.getElementById("edge-to-port");
       
       if (edge.type === "custom") {
        fromPortRow.style.display = "none";
        toPortRow.style.display = "none";
       } else {
        fromPortRow.style.display = "flex";
        toPortRow.style.display = "flex";
        fromPortInput.value = edge.fromPort || "";
        toPortInput.value = edge.toPort || "";
        
        fromPortInput.onchange = () => updateEdgePortLabels(id);
        toPortInput.onchange = () => updateEdgePortLabels(id);
       }
       
       const list = document.getElementById("edge-notes");
       list.innerHTML = "";
       edge.notes.forEach((note, i) => {
        const li = document.createElement("li");
        const txt = document.createElement("span");
        txt.textContent = note;
        txt.style.flex = "1";
        const del = document.createElement("span");
        del.className = "delete-note";
        del.textContent = "✕";
        del.addEventListener("click", (e) => {
         e.stopPropagation();
         challengeTheImmortal("Delete this line note?", () => {
          edge.notes.splice(i, 1);
          
          selectTheConnection(id);
         });
        });
        txt.addEventListener("dblclick", () => {
         txt.classList.add("editing");
         txt.contentEditable = true;
         txt.focus();
        });
        txt.addEventListener("blur", () => {
         txt.classList.remove("editing");
         txt.contentEditable = false;
         edge.notes[i] = txt.textContent;
         
        });
        li.append(txt, del);
        list.appendChild(li);
       });
       
       if (edge.type === "custom" && Array.isArray(edge.points)) {
        forgeTheTopology();
       }
      }
      window.addEventListener("resize", () => {
       forgeTheTopology();
       if (currentEdgeId) {
        selectTheConnection(currentEdgeId);
       } else if (currentNodeId && NODE_DATA[currentNodeId]) {
        claimTheImmortal(currentNodeId);
       } else {
        const availableNodes = Object.keys(NODE_DATA);
        if (availableNodes.length > 0) {
         claimTheImmortal(availableNodes[0]);
        }
       }
      });
      (function initZoomPan() {
       const viewport = document.getElementById("canvas-viewport");
       const svg = document.getElementById("map");
       const hint = document.getElementById("canvas-hint");
       setTimeout(() => {
        hint.classList.add("visible");
        setTimeout(() => hint.classList.remove("visible"), 4000);
       }, 1000);
       viewport.addEventListener("wheel",
        (e) => {
         e.preventDefault();
         const rect = viewport.getBoundingClientRect();
         const mouseX = (e.clientX - rect.left) / rect.width;
         const mouseY = (e.clientY - rect.top) / rect.height;
         const delta = e.deltaY > 0 ? 0.9 : 1.1;
         zoomTo(canvasState.zoom * delta, mouseX, mouseY);
        }, {
         passive: false
        }, );
       let initialPinchDistance = 0;
       let initialPinchZoom = 1;
       let pinchCenter = {
        x: 0.5,
        y: 0.5
       };
       viewport.addEventListener("touchstart",
        (e) => {
         if (e.touches.length === 2) {
          e.preventDefault();
          const touch1 = e.touches[0];
          const touch2 = e.touches[1];
          initialPinchDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY, );
          initialPinchZoom = canvasState.zoom;
          const rect = viewport.getBoundingClientRect();
          const centerX = (touch1.clientX + touch2.clientX) / 2;
          const centerY = (touch1.clientY + touch2.clientY) / 2;
          pinchCenter.x = (centerX - rect.left) / rect.width;
          pinchCenter.y = (centerY - rect.top) / rect.height;
         }
        }, {
         passive: false
        }, );
       viewport.addEventListener("touchmove",
        (e) => {
         if (e.touches.length === 2) {
          e.preventDefault();
          const touch1 = e.touches[0];
          const touch2 = e.touches[1];
          const currentDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY, );
          if (initialPinchDistance > 0) {
           const scale = currentDistance / initialPinchDistance;
           const newZoom = initialPinchZoom * scale;
           zoomTo(newZoom, pinchCenter.x, pinchCenter.y);
          }
         }
        }, {
         passive: false
        }, );
       let panStartViewX = 0;
       let panStartViewY = 0;
       
       let lastEmptyTapTime = 0;
       let emptyTapTimeout = null;
       let emptyTapMoved = false;
       let emptyTapStartX = 0;
       let emptyTapStartY = 0;
       
       viewport.addEventListener("touchend", (e) => {
         if (currentView.mode !== "rack") return;
         
         if (e.changedTouches.length !== 1) return;
         
      const isNodeOrEdge = e.target.closest(".node-group") || e.target.closest(".edge-group");
         if (isNodeOrEdge) return;
         
         if (emptyTapMoved) {
           emptyTapMoved = false;
           return;
         }
         
         const currentTime = new Date().getTime();
         const tapGap = currentTime - lastEmptyTapTime;
         
         if (tapGap < 300 && tapGap > 0) {
           e.preventDefault();
           
           exitRack();
           
           if (navigator.vibrate) {
             navigator.vibrate(50);
           }
           
           lastEmptyTapTime = 0;
           if (emptyTapTimeout) {
             clearTimeout(emptyTapTimeout);
             emptyTapTimeout = null;
           }
         } else {
           lastEmptyTapTime = currentTime;
           
           if (emptyTapTimeout) clearTimeout(emptyTapTimeout);
           emptyTapTimeout = setTimeout(() => {
             lastEmptyTapTime = 0;
           }, 300);
         }
       }, { passive: false });
       
       viewport.addEventListener("mousedown", (e) => {
        if (e.target.closest(".draw-toolbar") || e.target.closest(".topology-toolbar") || e.target.closest(".legend-container")) {
         return;
        }
      
        if (freeDrawMode || rectDrawMode) {
         return;
        }
      const isEmptySpace = e.target === svg || e.target === viewport || e.target.tagName === "svg";
      const isEdgeElement = e.target.closest('.edge') || e.target.classList.contains('edge-edit-point');
      const isTextElement = e.target.closest('.text-group') || e.target.closest('.text-element');
      const isRectElement = e.target.closest('.rect-group');
      if (!isEdgeElement && !isTextElement && !isRectElement && currentEdgeId) {
      currentEdgeId = null;
      forgeTheTopology();
      }
      if (!isRectElement && currentRectId) {
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      }
	  if (isViewOnly()) {
         document.body.classList.remove("view-only-inspect");
         document.getElementById("node-panel").style.display = "none";
         document.getElementById("edge-panel").style.display = "none";
        }
        if (isEmptySpace && e.shiftKey && e.button === 0) {
         if (isViewOnly()) return;
         e.preventDefault();
         startSelection(e);
         return;
        }
        if (isEmptySpace || e.button === 2 || e.button === 1) {
         e.preventDefault();
         canvasState.isPanning = true;
         canvasState.panStartX = e.clientX;
         canvasState.panStartY = e.clientY;
         panStartViewX = canvasState.panX;
         panStartViewY = canvasState.panY;
         viewport.classList.add("panning");
        }
       });
       viewport.addEventListener("touchstart",
        (e) => {
         if (e.target.closest(".draw-toolbar") || e.target.closest(".topology-toolbar") || e.target.closest(".legend-container")) {
          return;
         }
      
         if (freeDrawMode || rectDrawMode) {
          return;
         }
      const isEmptySpace = e.target === svg || e.target === viewport || e.target.tagName === "svg";
      const isEdgeElement = e.target.closest('.edge') || e.target.classList.contains('edge-edit-point');
      const isTextElement = e.target.closest('.text-group') || e.target.closest('.text-element');
      const isRectElement = e.target.closest('.rect-group');
      if (!isEdgeElement && !isTextElement && !isRectElement && currentEdgeId) {
      currentEdgeId = null;
      forgeTheTopology();
      }
      if (!isRectElement && currentRectId) {
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      }
          if (isEmptySpace && e.touches.length === 1) {
           e.preventDefault();
           emptyTapMoved = false;
           emptyTapStartX = e.touches[0].clientX;
           emptyTapStartY = e.touches[0].clientY;
           canvasState.isPanning = true;
           canvasState.panStartX = e.touches[0].clientX;
           canvasState.panStartY = e.touches[0].clientY;
           panStartViewX = canvasState.panX;
           panStartViewY = canvasState.panY;
           viewport.classList.add("panning");
         }
        }, {
         passive: false
        }, );
       document.addEventListener("mousemove", (e) => {
        if (isSelecting) {
         updateSelection(e);
         return;
        }
        if (!canvasState.isPanning) return;
        const dx = e.clientX - canvasState.panStartX;
        const dy = e.clientY - canvasState.panStartY;
        const rect = viewport.getBoundingClientRect();
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        const canvasDx = (dx / rect.width) * viewWidth;
        const canvasDy = (dy / rect.height) * viewHeight;
        canvasState.panX = panStartViewX - canvasDx;
        canvasState.panY = panStartViewY - canvasDy;
        constrainPan();
        updateViewBox();
       });
       document.addEventListener("touchmove", (e) => {
        if (!canvasState.isPanning || !e.touches[0]) return;
        const moveDx = Math.abs(e.touches[0].clientX - emptyTapStartX);
        const moveDy = Math.abs(e.touches[0].clientY - emptyTapStartY);
        if (moveDx > 15 || moveDy > 15) {
         emptyTapMoved = true;
        }
        const dx = e.touches[0].clientX - canvasState.panStartX;
        const dy = e.touches[0].clientY - canvasState.panStartY;
        const rect = viewport.getBoundingClientRect();
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        const canvasDx = (dx / rect.width) * viewWidth;
        const canvasDy = (dy / rect.height) * viewHeight;
        canvasState.panX = panStartViewX - canvasDx;
        canvasState.panY = panStartViewY - canvasDy;
        constrainPan();
        updateViewBox();
       });
       document.addEventListener("mouseup", () => {
        if (isSelecting) {
         endSelection();
        }
        if (canvasState.isPanning) {
         canvasState.isPanning = false;
         viewport.classList.remove("panning");
        }
       });
       document.addEventListener("touchend", () => {
        if (canvasState.isPanning) {
         canvasState.isPanning = false;
         viewport.classList.remove("panning");
        }
       });
       document.addEventListener("keydown", (e) => {
        const isEditing = document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "TEXTAREA" || document.activeElement.isContentEditable;
        if (e.code === "Space" && !e.repeat && !isEditing) {
         e.preventDefault();
         canvasState.spacePressed = true;
         viewport.style.cursor = "grab";
        }
       });
       document.addEventListener("keyup", (e) => {
        if (e.code === "Space") {
         canvasState.spacePressed = false;
         viewport.style.cursor = "";
        }
       });
       document.getElementById("zoom-in-btn").addEventListener("click", () => {
        zoomTo(canvasState.zoom * 1.25, 0.5, 0.5);
       });
       document.getElementById("zoom-out-btn").addEventListener("click", () => {
        zoomTo(canvasState.zoom * 0.8, 0.5, 0.5);
       });
       document.getElementById("zoom-fit-btn").addEventListener("click", fitToContent);
       document.getElementById("zoom-reset-btn").addEventListener("click", resetView);
       const minimapContainer = document.getElementById("minimap-container");
       const minimapSvg = document.getElementById("minimap");
       let minimapDragging = false;
       minimapContainer.addEventListener("mousedown", (e) => {
        e.preventDefault();
        minimapDragging = true;
        updatePanFromMinimap(e);
       });
       minimapContainer.addEventListener("touchstart",
        (e) => {
         e.preventDefault();
         minimapDragging = true;
         updatePanFromMinimapTouch(e);
        }, {
         passive: false
        }, );
       document.addEventListener("mousemove", (e) => {
        if (minimapDragging) {
         updatePanFromMinimap(e);
        }
       });
       document.addEventListener("touchmove", (e) => {
        if (minimapDragging && e.touches[0]) {
         updatePanFromMinimapTouch(e);
        }
       });
       document.addEventListener("mouseup", () => {
        minimapDragging = false;
       });
       document.addEventListener("touchend", () => {
        minimapDragging = false;
       });
      
       function updatePanFromMinimap(e) {
        const rect = minimapContainer.getBoundingClientRect();
        const x = (e.clientX - rect.left) / rect.width;
        const y = (e.clientY - rect.top) / rect.height;
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        canvasState.panX = x * CANVAS_WIDTH - viewWidth / 2;
        canvasState.panY = y * CANVAS_HEIGHT - viewHeight / 2;
        constrainPan();
        updateViewBox();
       }
      
       function updatePanFromMinimapTouch(e) {
        const rect = minimapContainer.getBoundingClientRect();
        const touch = e.touches[0];
        const x = (touch.clientX - rect.left) / rect.width;
        const y = (touch.clientY - rect.top) / rect.height;
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        canvasState.panX = x * CANVAS_WIDTH - viewWidth / 2;
        canvasState.panY = y * CANVAS_HEIGHT - viewHeight / 2;
        constrainPan();
        updateViewBox();
       }
       document.addEventListener("keydown", (e) => {
        if (document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "TEXTAREA") return;
        if (
         (e.key === "+" || e.key === "=") && (e.ctrlKey || e.metaKey)) {
         e.preventDefault();
         zoomTo(canvasState.zoom * 1.25, 0.5, 0.5);
        } else if (e.key === "-" && (e.ctrlKey || e.metaKey)) {
         e.preventDefault();
         zoomTo(canvasState.zoom * 0.8, 0.5, 0.5);
        } else if (e.key === "0" && (e.ctrlKey || e.metaKey)) {
         e.preventDefault();
         resetView();
        }
       });
       setTimeout(() => {
        fitToContent();
       }, 100);
      })();
      const sizeSlider = document.getElementById("size-slider");
      const sizeValue = document.getElementById("size-value");
      const resetSizeBtn = document.getElementById("reset-size");
      sizeSlider.addEventListener("input", () => {
       const newSize = parseInt(sizeSlider.value, 10);
       sizeValue.textContent = newSize;
       savedSizes[currentNodeId] = newSize;
       const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
       if (nodeGroup) {
        const oldShape = nodeGroup.querySelector(".node-circle");
        if (oldShape) oldShape.remove();
        const shapeType = (NODE_DATA[currentNodeId] && NODE_DATA[currentNodeId].shape) || "circle";
        const newShape = createShapeElement(shapeType, newSize);
        newShape.classList.add("node-circle");
        const styles = resolveStylesForNode(currentNodeId);
        if (styles.circleColor) newShape.style.fill = styles.circleColor;
        if (styles.circleBorder) newShape.style.stroke = styles.circleBorder;
        nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
        const label = nodeGroup.querySelector(".node-label");
        const sub = nodeGroup.querySelector(".node-sub");
        if (label) {
         label.setAttribute("y", -newSize * 0.28);
         const labelSize = styles.titleSize || newSize * 0.33;
         label.style.fontSize = labelSize + "px";
        }
        if (sub) {
         sub.setAttribute("y", newSize * 0.4);
         const subSize = styles.subSize || newSize * 0.24;
         sub.style.fontSize = subSize + "px";
        }
       }
      });
      resetSizeBtn.addEventListener("click", () => {
       delete savedSizes[currentNodeId];
       const defaultSize = getDefaultSize();
       sizeSlider.value = defaultSize;
       sizeValue.textContent = defaultSize;
       const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
       if (nodeGroup) {
        const oldShape = nodeGroup.querySelector(".node-circle");
        if (oldShape) oldShape.remove();
        const shapeType = (NODE_DATA[currentNodeId] && NODE_DATA[currentNodeId].shape) || "circle";
        const newShape = createNodeShape(currentNodeId, defaultSize);
        nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
        const styles = resolveStylesForNode(currentNodeId);
        if (styles.circleColor) newShape.style.fill = styles.circleColor;
        if (styles.circleBorder) newShape.style.stroke = styles.circleBorder;
        const label = nodeGroup.querySelector(".node-label");
        const sub = nodeGroup.querySelector(".node-sub");
        if (label) {
         label.setAttribute("y", -defaultSize * 0.28);
         const labelSize = styles.titleSize || defaultSize * 0.33;
         label.style.fontSize = labelSize + "px";
        }
        if (sub) {
         sub.setAttribute("y", defaultSize * 0.4);
         const subSize = styles.subSize || defaultSize * 0.24;
         sub.style.fontSize = subSize + "px";
        }
       }
      });
      const applyStyle = (property, value) => {
       const styleEntry = ensureStyleEntry(currentNodeId);
       const scopeKey = currentStyleScope || "all";
       if (!styleEntry[scopeKey]) styleEntry[scopeKey] = {};
       styleEntry[scopeKey][property] = value;
       const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
       if (!nodeGroup) return;
       const shapeEl = nodeGroup.querySelector(".node-circle");
       const label = nodeGroup.querySelector(".node-label");
       const sub = nodeGroup.querySelector(".node-sub");
       if (property === "circleColor" && shapeEl) shapeEl.style.fill = value;
      else if (property === "circleBorder" && shapeEl) shapeEl.style.stroke = value;
       else if (property === "titleColor" && label) label.style.fill = value;
       else if (property === "titleFont" && label) label.style.fontFamily = value;
       else if (property === "titleSize" && label) label.style.fontSize = value + "px";
       else if (property === "subColor" && sub) sub.style.fill = value;
       else if (property === "subFont" && sub) sub.style.fontFamily = value;
       else if (property === "subSize" && sub) sub.style.fontSize = value + "px";
      };
      document.getElementById("circle-color").addEventListener("input", (e) => applyStyle("circleColor", e.target.value), );
      document.getElementById("circle-border").addEventListener("input", (e) => applyStyle("circleBorder", e.target.value), );
      document.getElementById("title-color").addEventListener("input", (e) => applyStyle("titleColor", e.target.value), );
      document.getElementById("title-font").addEventListener("change", (e) => applyStyle("titleFont", e.target.value), );
      document.getElementById("title-size").addEventListener("input", (e) => applyStyle("titleSize", parseInt(e.target.value, 10)), );
      document.getElementById("sub-color").addEventListener("input", (e) => applyStyle("subColor", e.target.value), );
      document.getElementById("sub-font").addEventListener("change", (e) => applyStyle("subFont", e.target.value), );
      document.getElementById("sub-size").addEventListener("input", (e) => applyStyle("subSize", parseInt(e.target.value, 10)), );
      document.getElementById("title-offset-y").addEventListener("input", (e) => {
       applyStyle("titleOffsetY", parseInt(e.target.value, 10) || 0);
       forgeTheTopology();
       if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      document.getElementById("title-offset-x").addEventListener("input", (e) => {
       applyStyle("titleOffsetX", parseInt(e.target.value, 10) || 0);
       forgeTheTopology();
       if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      document.getElementById("sub-offset-y").addEventListener("input", (e) => {
       applyStyle("subOffsetY", parseInt(e.target.value, 10) || 0);
       forgeTheTopology();
       if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      document.getElementById("sub-offset-x").addEventListener("input", (e) => {
       applyStyle("subOffsetX", parseInt(e.target.value, 10) || 0);
       forgeTheTopology();
       if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      document.getElementById("reset-styles").addEventListener("click", () => {
       delete savedStyles[currentNodeId];
       forgeTheTopology();
       claimTheImmortal(currentNodeId);
      });
      document.getElementById("style-scope").addEventListener("change", (e) => {
       currentStyleScope = e.target.value || "all";
       claimTheImmortal(currentNodeId);
      });
      document.getElementById("shape-select").addEventListener("change", (e) => {
       const shape = e.target.value || "circle";
       NODE_DATA[currentNodeId].shape = shape;
       const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
       if (!nodeGroup) return;
       const oldShape = nodeGroup.querySelector(".node-circle");
       if (oldShape) oldShape.remove();
       const size = savedSizes[currentNodeId] || getDefaultSize();
       const newShape = createNodeShape(currentNodeId, size);
       nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
      });
      const addNoteBtn = document.getElementById("add-note-btn");
      const noteInput = document.getElementById("new-note-input");
      addNoteBtn.addEventListener("click", () => {
       const newNote = noteInput.value.trim();
       if (newNote && currentNodeId) {
        NODE_DATA[currentNodeId].notes.push(newNote);
        claimTheImmortal(currentNodeId);
        noteInput.value = "";
       }
      });
      noteInput.addEventListener("keypress", (e) => {
       if (e.key === "Enter") {
        addNoteBtn.click();
       }
      });
      document.getElementById("edge-width").addEventListener("input", () => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       const v = parseInt(document.getElementById("edge-width").value, 10);
       if (Number.isNaN(v) || v <= 0) return;
       edge.width = v;
       
       const el = document.querySelector(`.edge[data-edge-id="${currentEdgeId}"]`, );
       if (el) el.style.strokeWidth = v;
      });
      document.getElementById("edge-color").addEventListener("input", () => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       const color = document.getElementById("edge-color").value;
       edge.color = color;
       
       const el = document.querySelector(`.edge[data-edge-id="${currentEdgeId}"]`, );
       if (el) el.style.stroke = color;
       forgeTheLegend();
      });
      document.getElementById("edge-direction").addEventListener("change", () => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       edge.direction = document.getElementById("edge-direction").value;
       
       forgeTheTopology();
       selectTheConnection(currentEdgeId);
      });
      document.getElementById("edge-line-style").addEventListener("change", () => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       edge.lineStyle = document.getElementById("edge-line-style").value;
       
       forgeTheTopology();
       selectTheConnection(currentEdgeId);
      });
      const addEdgeNoteBtn = document.getElementById("add-edge-note");
      const newEdgeNoteInput = document.getElementById("new-edge-note");
      addEdgeNoteBtn.addEventListener("click", () => {
       const txt = newEdgeNoteInput.value.trim();
       if (!txt || !currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       edge.notes.push(txt);
       
       newEdgeNoteInput.value = "";
       selectTheConnection(currentEdgeId);
      });
      newEdgeNoteInput.addEventListener("keypress", (e) => {
       if (e.key === "Enter") {
        addEdgeNoteBtn.click();
       }
      });
	  
      function selectTheRect(id) {
	  if (isViewOnly()) return;
      currentRectId = id;
      currentNodeId = null;
      currentEdgeId = null;
      currentTextId = null;
      document.getElementById("node-panel").style.display = "none";
      document.getElementById("edge-panel").style.display = "none";
      document.getElementById("text-panel").style.display = "none";
      document.getElementById("rect-panel").style.display = "block";
      document.getElementById("topology-toolbar").style.display = "none";
      document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active"));
      document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
      document.querySelectorAll(".text-element").forEach(t => t.classList.remove("active"));
      document.querySelectorAll(".rect-group").forEach(r => r.classList.toggle("active", r.dataset.rectId === id));
      
      const rect = RECT_DATA.list.find(r => r.id === id);
      if (!rect) return;
      
      document.getElementById("rect-title").textContent = "";
      document.getElementById("rect-color").value = rect.color || "#f97316";
      document.getElementById("rect-border-color").value = rect.borderColor || rect.color || "#f97316";
      document.getElementById("rect-border-width").value = rect.borderWidth !== undefined ? rect.borderWidth : 2;
      document.getElementById("rect-style-select").value = rect.style || "filled";
      document.getElementById("rect-line-style").value = rect.lineStyle || "solid";
      document.getElementById("rect-fill-row").style.display = (rect.style === "outlined") ? "none" : "flex";
      
      const list = document.getElementById("rect-notes");
      list.innerHTML = "";
      (rect.notes || []).forEach((note, i) => {
      const li = document.createElement("li");
      const txt = document.createElement("span");
      txt.textContent = note;
      txt.style.flex = "1";
      const del = document.createElement("span");
      del.className = "delete-note";
      del.textContent = "✕";
      del.addEventListener("click", (e) => {
      e.stopPropagation();
      challengeTheImmortal("Delete this note?", () => {
        rect.notes.splice(i, 1);
        selectTheRect(id);
      });
      });
      li.appendChild(txt);
      li.appendChild(del);
      list.appendChild(li);
      });
      
      forgeTheTopology();
      }
      
      document.getElementById("rect-color").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      rect.color = document.getElementById("rect-color").value;
      forgeTheTopology();
      });
      
      document.getElementById("rect-border-color").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      rect.borderColor = document.getElementById("rect-border-color").value;
      forgeTheTopology();
      });
      
      document.getElementById("rect-border-width").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      rect.borderWidth = parseInt(document.getElementById("rect-border-width").value) || 2;
      forgeTheTopology();
      });
      
      document.getElementById("rect-style-select").addEventListener("change", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      rect.style = document.getElementById("rect-style-select").value;
      forgeTheTopology();
      selectTheRect(currentRectId);
      });
      
      document.getElementById("rect-line-style").addEventListener("change", () => {
      if (!currentRectId) return;
      pushUndo("change zone line style");
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      rect.lineStyle = document.getElementById("rect-line-style").value;
      forgeTheTopology();
      });
      
      document.getElementById("add-rect-note").addEventListener("click", () => {
      const input = document.getElementById("new-rect-note");
      const txt = input.value.trim();
      if (!txt || !currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      if (!rect.notes) rect.notes = [];
      rect.notes.push(txt);
      input.value = "";
      selectTheRect(currentRectId);
      });
      
      document.getElementById("new-rect-note").addEventListener("keypress", (e) => {
      if (e.key === "Enter") {
      document.getElementById("add-rect-note").click();
      }
      });
      
      document.getElementById("delete-rect").addEventListener("click", () => {
      if (!currentRectId) return;
      challengeTheImmortal("Delete this zone?", () => {
      RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== currentRectId);
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      });
      });
      document.getElementById("delete-edge").addEventListener("click", () => {
       if (!currentEdgeId) return;
       challengeTheImmortal("Are you sure you want to delete this line?",
        () => {
         EDGE_DATA.list = EDGE_DATA.list.filter(
          (e) => e.id !== currentEdgeId, );
         
         currentEdgeId = null;
         forgeTheTopology();
         const availableNodes = Object.keys(NODE_DATA);
         if (availableNodes.length > 0) {
          claimTheImmortal(availableNodes[0]);
         } else {
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("topology-toolbar", ).style.display = "none";
         }
        }, );
      });
      document.getElementById("add-line-btn").addEventListener("click", () => {
       if (!currentNodeId) return;
       const select = document.getElementById("add-line-select");
       const directionSelect = document.getElementById("add-line-direction");
       const colorInput = document.getElementById("add-line-color");
       const targetId = select.value;
       if (!targetId || targetId === currentNodeId) return;
       const direction = directionSelect.value || "none";
       const lineColor = colorInput.value || "#475569";
       const newId = `${currentNodeId}-${targetId}-${Date.now()}`;
       const newEdge = {
        id: newId,
        from: currentNodeId,
        to: targetId,
        width: 4,
        color: lineColor,
        direction: direction,
        type: "main",
        notes: [],
        fromPort: "",
        toPort: "",
        lineStyle: "solid",
       };
       EDGE_DATA.list.push(newEdge);
       
       forgeTheTopology();
       claimTheImmortal(currentNodeId);
      });
      let freeDrawPoints = [];
      let freeDrawPolylineEl = null;
      let freeDrawPointEls = [];
    
       let rectStartPoint = null;
       let rectPreviewEl = null;
       let rectStyle = "filled";
      const drawToggleBtn = document.getElementById("draw-toggle");
      const drawUndoBtn = document.getElementById("draw-undo");
      const drawColorInput = document.getElementById("draw-color");
      const drawStyleSelect = document.getElementById("draw-style");
      const drawArrowSelect = document.getElementById("draw-arrow");
      const svgMap = document.getElementById("map");
      
      function updateFreeDrawGraphics() {
       const ns = "http://www.w3.org/2000/svg";
       const svg = svgMap;
       if (!freeDrawPolylineEl && freeDrawPoints.length > 0) {
        freeDrawPolylineEl = document.createElementNS(ns, "polyline");
        freeDrawPolylineEl.classList.add("edge", "free-preview");
        freeDrawPolylineEl.setAttribute("fill", "none");
        svg.appendChild(freeDrawPolylineEl);
       }
       if (freeDrawPolylineEl) {
        if (freeDrawPoints.length === 0) {
         freeDrawPolylineEl.remove();
         freeDrawPolylineEl = null;
        } else {
         const ptsStr = freeDrawPoints.map((p) => `${p.x},${p.y}`).join(" ");
         freeDrawPolylineEl.setAttribute("points", ptsStr);
         freeDrawPolylineEl.style.stroke = drawColorInput.value || "#475569";
         freeDrawPolylineEl.style.strokeWidth = 3;
         const lineStyle = drawStyleSelect.value || "solid";
         if (lineStyle === "dashed") {
          freeDrawPolylineEl.style.strokeDasharray = "10,5";
         } else if (lineStyle === "dotted") {
          freeDrawPolylineEl.style.strokeDasharray = "2,4";
         } else {
          freeDrawPolylineEl.style.strokeDasharray = "none";
         }
        }
       }
       freeDrawPointEls.forEach((el) => el.remove());
       freeDrawPointEls = [];
       freeDrawPoints.forEach((p, idx) => {
        const c = document.createElementNS(ns, "circle");
        c.classList.add("free-point");
        c.setAttribute("cx", p.x);
        c.setAttribute("cy", p.y);
        c.setAttribute("r", 5);
        c.dataset.index = String(idx);
        c.addEventListener("mousedown", (e) => {
         if (!freeDrawMode) return;
         e.preventDefault();
         e.stopPropagation();
         let dragging = true;
         const svgEl = svgMap;
         const moveHandler = (ev) => {
          if (!dragging) return;
          const pt = svgEl.createSVGPoint();
          pt.x = ev.clientX;
          pt.y = ev.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          const i = parseInt(c.dataset.index, 10);
          if (Number.isNaN(i) || !freeDrawPoints[i]) return;
          freeDrawPoints[i].x = svgP.x;
          freeDrawPoints[i].y = svgP.y;
          updateFreeDrawGraphics();
         };
         const upHandler = () => {
          dragging = false;
          document.removeEventListener("mousemove", moveHandler);
          document.removeEventListener("mouseup", upHandler);
         };
         document.addEventListener("mousemove", moveHandler);
         document.addEventListener("mouseup", upHandler);
        });
        c.addEventListener("touchstart",
         (e) => {
          if (!freeDrawMode) return;
          e.preventDefault();
          e.stopPropagation();
          let dragging = true;
          const svgEl = svgMap;
          const touchMoveHandler = (ev) => {
           if (!dragging || !ev.touches[0]) return;
           const pt = svgEl.createSVGPoint();
           pt.x = ev.touches[0].clientX;
           pt.y = ev.touches[0].clientY;
           const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
           const i = parseInt(c.dataset.index, 10);
           if (Number.isNaN(i) || !freeDrawPoints[i]) return;
           freeDrawPoints[i].x = svgP.x;
           freeDrawPoints[i].y = svgP.y;
           updateFreeDrawGraphics();
          };
          const touchUpHandler = () => {
           dragging = false;
           document.removeEventListener("touchmove", touchMoveHandler, );
           document.removeEventListener("touchend", touchUpHandler, );
          };
          document.addEventListener("touchmove", touchMoveHandler);
          document.addEventListener("touchend", touchUpHandler);
         }, {
          passive: false
         }, );
        svg.appendChild(c);
        freeDrawPointEls.push(c);
       });
       drawUndoBtn.style.display = freeDrawPoints.length ? "inline-block" : "none";
      }
      
      function addFreeDrawPoint(x, y) {
       freeDrawPoints.push({
        x,
        y
       });
       updateFreeDrawGraphics();
      }
      
      function startFreeDraw() {
       freeDrawMode = true;
       freeDrawPoints = [];
       if (freeDrawPolylineEl) {
        freeDrawPolylineEl.remove();
        freeDrawPolylineEl = null;
       }
       freeDrawPointEls.forEach((el) => el.remove());
       freeDrawPointEls = [];
       svgMap.style.cursor = "crosshair";
       drawToggleBtn.textContent = "Done";
       drawUndoBtn.style.display = "none";
      }
      
      function finishFreeDraw() {
       freeDrawMode = false;
       svgMap.style.cursor = "";
       drawToggleBtn.textContent = "✏️";
       if (freeDrawPoints.length >= 2) {
        const color = drawColorInput.value || "#475569";
        const lineStyle = drawStyleSelect.value || "solid";
        const arrowDir = drawArrowSelect.value || "none";
        const newId = "custom-" + Date.now();
        const pointsCopy = freeDrawPoints.map((p) => ({
         x: p.x,
         y: p.y,
        }));
        EDGE_DATA.list.push({
         id: newId,
         type: "custom",
         color,
         width: 4,
         lineStyle: lineStyle,
         direction: arrowDir,
         points: pointsCopy,
         notes: [],
        });
        
        freeDrawPoints = [];
        if (freeDrawPolylineEl) {
         freeDrawPolylineEl.remove();
         freeDrawPolylineEl = null;
        }
        freeDrawPointEls.forEach((el) => el.remove());
        freeDrawPointEls = [];
        forgeTheTopology();
        selectTheConnection(newId);
       } else {
        freeDrawPoints = [];
        if (freeDrawPolylineEl) {
         freeDrawPolylineEl.remove();
         freeDrawPolylineEl = null;
        }
        freeDrawPointEls.forEach((el) => el.remove());
        freeDrawPointEls = [];
        forgeTheLegend();
       }
       drawUndoBtn.style.display = "none";
      }
      drawToggleBtn.addEventListener("click", () => {
       if (currentView.mode === "rack") {
        alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
        return;
       }
       
       if (freeDrawMode) {
        finishFreeDraw();
       } else {
        startFreeDraw();
       }
      });
      drawUndoBtn.addEventListener("click", () => {
       if (!freeDrawMode || !freeDrawPoints.length) return;
       freeDrawPoints.pop();
       updateFreeDrawGraphics();
      });
      const drawToolbar = document.getElementById("draw-toolbar");
      drawToolbar.addEventListener("mousedown", (e) => {
       e.stopPropagation();
      });
      drawToolbar.addEventListener("click", (e) => {
       if (e.target !== drawToggleBtn && e.target !== drawUndoBtn) {
        e.stopPropagation();
       }
      });
      drawStyleSelect.addEventListener("change", () => {
       if (freeDrawMode) {
        updateFreeDrawGraphics();
       }
      });
      drawArrowSelect.addEventListener("change", () => {
       if (freeDrawMode) {
        updateFreeDrawGraphics();
       }
      });
      drawColorInput.addEventListener("input", () => {
       if (freeDrawMode) {
        updateFreeDrawGraphics();
       }
      });
      drawStyleSelect.addEventListener("mousedown", (e) => {
       e.stopPropagation();
      });
      drawStyleSelect.addEventListener("click", (e) => {
       e.stopPropagation();
      });
      drawArrowSelect.addEventListener("mousedown", (e) => {
       e.stopPropagation();
      });
      drawArrowSelect.addEventListener("click", (e) => {
       e.stopPropagation();
      });
      drawColorInput.addEventListener("mousedown", (e) => {
       e.stopPropagation();
      });
      drawColorInput.addEventListener("click", (e) => {
       e.stopPropagation();
      });
      
      svgMap.addEventListener("click", (e) => {
       if (!freeDrawMode) return;
       if (e.button !== 0) return;
       const target = e.target;
       if (target && target.classList && target.classList.contains("free-point")) return;
       const svgEl = svgMap;
       const pt = svgEl.createSVGPoint();
       pt.x = e.clientX;
       pt.y = e.clientY;
       const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
       addFreeDrawPoint(svgP.x, svgP.y);
      });
      svgMap.addEventListener("touchend",
       (e) => {
        if (!freeDrawMode) return;
        const target = e.target;
        if (target && target.classList && target.classList.contains("free-point")) return;
        if (e.changedTouches && e.changedTouches[0]) {
         e.preventDefault();
         const svgEl = svgMap;
         const pt = svgEl.createSVGPoint();
         pt.x = e.changedTouches[0].clientX;
         pt.y = e.changedTouches[0].clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
         addFreeDrawPoint(svgP.x, svgP.y);
        }
       }, {
        passive: false
       }, );
      
       const rectToggleBtn = document.getElementById("rect-toggle");
       const rectStyleSelect = document.getElementById("rect-style");
      
       function startRectDraw() {
        rectDrawMode = true;
        rectStartPoint = null;
        rectPreviewEl = null;
        svgMap.style.cursor = "crosshair";
        rectToggleBtn.textContent = "Done";
        rectStyle = rectStyleSelect.value || "filled";
        
        if (freeDrawMode) {
         finishFreeDraw();
        }
        updateRectangleDeleteButtons();
       }
      
       function finishRectDraw() {
        rectDrawMode = false;
        svgMap.style.cursor = "";
        rectToggleBtn.textContent = "▭";
        
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
        updateRectangleDeleteButtons();
       }
      
       rectToggleBtn.addEventListener("click", () => {
        if (currentView.mode === "rack") {
         alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
         return;
        }
        
        if (rectDrawMode) {
         finishRectDraw();
        } else {
         startRectDraw();
        }
       });
      
       rectStyleSelect.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       rectStyleSelect.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       rectStyleSelect.addEventListener("change", () => {
        if (rectDrawMode) {
         rectStyle = rectStyleSelect.value || "filled";
        }
       });
      
       svgMap.addEventListener("mousedown", (e) => {
        if (!rectDrawMode) return;
        if (e.button !== 0) return;
        e.preventDefault();
        e.stopPropagation();
        
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        rectStartPoint = { x: svgP.x, y: svgP.y };
        
        const ns = "http://www.w3.org/2000/svg";
        rectPreviewEl = document.createElementNS(ns, "rect");
        rectPreviewEl.classList.add("rect-preview");
        rectPreviewEl.setAttribute("x", svgP.x);
        rectPreviewEl.setAttribute("y", svgP.y);
        rectPreviewEl.setAttribute("width", 0);
        rectPreviewEl.setAttribute("height", 0);
        
        const color = drawColorInput.value || "#f97316";
        rectPreviewEl.style.stroke = color;
        rectPreviewEl.style.strokeWidth = 2;
        rectPreviewEl.style.strokeDasharray = "5,5";
        
        if (rectStyle === "filled") {
         rectPreviewEl.style.fill = color;
         rectPreviewEl.style.fillOpacity = "0.3";
        } else {
         rectPreviewEl.style.fill = "none";
        }
        
        svgEl.appendChild(rectPreviewEl);
       });
      
       svgMap.addEventListener("mousemove", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        
        rectPreviewEl.setAttribute("x", x);
        rectPreviewEl.setAttribute("y", y);
        rectPreviewEl.setAttribute("width", width);
        rectPreviewEl.setAttribute("height", height);
       });
      
       svgMap.addEventListener("mouseup", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        
        if (width > 10 && height > 10) {
      pushUndo("draw zone");
         const color = drawColorInput.value || "#f97316";
         const newId = "rect-" + Date.now();
         
          const lineStyle = document.getElementById("draw-style").value || "solid";
         RECT_DATA.list.push({
          id: newId,
          x: x,
          y: y,
          width: width,
          height: height,
          color: color,
          style: rectStyle,
          lineStyle: lineStyle,
          notes: []
         });
         
         forgeTheTopology();
        }
        
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
       });
      
       let rectTouchStart = null;
       
       svgMap.addEventListener("touchstart", (e) => {
        if (!rectDrawMode) return;
        if (e.touches.length !== 1) return;
        
        e.preventDefault();
        const touch = e.touches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        rectStartPoint = { x: svgP.x, y: svgP.y };
        rectTouchStart = { x: svgP.x, y: svgP.y };
        
        const ns = "http://www.w3.org/2000/svg";
        rectPreviewEl = document.createElementNS(ns, "rect");
        rectPreviewEl.classList.add("rect-preview");
        rectPreviewEl.setAttribute("x", svgP.x);
        rectPreviewEl.setAttribute("y", svgP.y);
        rectPreviewEl.setAttribute("width", 0);
        rectPreviewEl.setAttribute("height", 0);
        
        const color = drawColorInput.value || "#f97316";
        rectPreviewEl.style.stroke = color;
        rectPreviewEl.style.strokeWidth = 2;
        rectPreviewEl.style.strokeDasharray = "5,5";
        
        if (rectStyle === "filled") {
         rectPreviewEl.style.fill = color;
         rectPreviewEl.style.fillOpacity = "0.3";
        } else {
         rectPreviewEl.style.fill = "none";
        }
        
        svgEl.appendChild(rectPreviewEl);
       }, { passive: false });
      
       svgMap.addEventListener("touchmove", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        if (e.touches.length !== 1) return;
        
        e.preventDefault();
        const touch = e.touches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        
        rectPreviewEl.setAttribute("x", x);
        rectPreviewEl.setAttribute("y", y);
        rectPreviewEl.setAttribute("width", width);
        rectPreviewEl.setAttribute("height", height);
       }, { passive: false });
      
       svgMap.addEventListener("touchend", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        if (!rectTouchStart) return;
        
        e.preventDefault();
        const touch = e.changedTouches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        
        if (width > 10 && height > 10) {
      pushUndo("draw zone");
         const color = drawColorInput.value || "#f97316";
         const newId = "rect-" + Date.now();
         
        const lineStyle = document.getElementById("draw-style").value || "solid";
         RECT_DATA.list.push({
          id: newId,
          x: x,
          y: y,
          width: width,
          height: height,
          color: color,
          style: rectStyle,
          lineStyle: lineStyle,
          notes: []
         });
         
         forgeTheTopology();
        }
        
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
        rectTouchStart = null;
       }, { passive: false });
      
      const textToggleBtn = document.getElementById("text-toggle");
      
      function startTextMode() {
       textDrawMode = true;
       svgMap.style.cursor = "crosshair";
       textToggleBtn.textContent = "Done";
       textToggleBtn.style.background = "var(--accent)";
       textToggleBtn.style.color = "var(--bg)";
       
       if (freeDrawMode) {
        finishFreeDraw();
       }
       if (rectDrawMode) {
        finishRectDraw();
       }
       
       updateTextDeleteButtons();
      }
      
      function finishTextMode() {
       textDrawMode = false;
       svgMap.style.cursor = "";
       textToggleBtn.textContent = "T";
       textToggleBtn.style.background = "";
       textToggleBtn.style.color = "";
       updateTextDeleteButtons();
      }
      
      textToggleBtn.addEventListener("click", () => {
       if (currentView.mode === "rack") {
        alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
        return;
       }
       
       if (textDrawMode) {
        finishTextMode();
       } else {
        startTextMode();
       }
      });
      
      function handleTextPlacement(e) {
       if (!textDrawMode) return;
       
       const svgEl = svgMap;
       const pt = svgEl.createSVGPoint();
       pt.x = e.clientX;
       pt.y = e.clientY;
       const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
       
       const newId = "text-" + Date.now();
      pushUndo("add text");
       TEXT_DATA.list.push({
        id: newId,
        x: svgP.x,
        y: svgP.y,
        content: "New Text",
        fontSize: 18,
        color: "#e2e8f0",
        fontWeight: "normal",
        fontStyle: "normal",
        textAlign: "start",
        textDecoration: "none",
        bgColor: "#000000",
        bgEnabled: false,
        opacity: 1
       });
       
       forgeTheTopology();
       
       showTextPanel(newId);
      }
      
      svgMap.addEventListener("click", (e) => {
       if (!textDrawMode) return;
       if (e.target.closest('.text-delete-btn')) return;
       if (e.target.closest('.text-group')) return;
       
       e.preventDefault();
       e.stopPropagation();
       handleTextPlacement(e);
      });
      
      svgMap.addEventListener("touchend", (e) => {
       if (!textDrawMode) return;
       if (e.target.closest('.text-delete-btn')) return;
       if (e.target.closest('.text-group')) return;
       if (e.touches.length > 0) return;
       
       e.preventDefault();
       const touch = e.changedTouches[0];
       const fakeEvent = {
        clientX: touch.clientX,
        clientY: touch.clientY,
        preventDefault: () => {},
        stopPropagation: () => {}
       };
       handleTextPlacement(fakeEvent);
      }, { passive: false });
      
      function showTextPanel(textId) {
	  if (isViewOnly()) return;
       currentTextId = textId;
       currentNodeId = null;
       currentEdgeId = null;
       currentRectId = null;
       const textItem = TEXT_DATA.list.find(t => t.id === textId);
       if (!textItem) return;
       
       document.getElementById("node-panel").style.display = "none";
       document.getElementById("edge-panel").style.display = "none";
       document.getElementById("rect-panel").style.display = "none";
       
       const textPanel = document.getElementById("text-panel");
       textPanel.style.display = "block";
       document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active"));
       document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
       document.querySelectorAll(".rect-group").forEach(r => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach(t => t.classList.toggle("active", t.dataset.textId === textId));
       
       document.getElementById("text-content").value = textItem.content;
       document.getElementById("text-font-size").value = textItem.fontSize;
       document.getElementById("text-color").value = textItem.color;
       document.getElementById("text-font-weight").value = textItem.fontWeight;
       document.getElementById("text-font-style").value = textItem.fontStyle;
       document.getElementById("text-align").value = textItem.textAlign;
       document.getElementById("text-decoration").value = textItem.textDecoration;
       document.getElementById("text-bg-color").value = textItem.bgColor;
       document.getElementById("text-bg-enabled").checked = textItem.bgEnabled;
       document.getElementById("text-opacity").value = textItem.opacity;
       document.getElementById("text-opacity-val").textContent = Math.round(textItem.opacity * 100) + "%";
      }
      
      function updateTextDeleteButtons() {
       const deleteButtons = document.querySelectorAll('.text-delete-btn');
       deleteButtons.forEach(btn => {
        btn.style.display = textDrawMode ? 'block' : 'none';
       });
      }
      
      function deleteText(textId) {
      pushUndo("delete text");
       TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== textId);
       forgeTheTopology();
       
       if (currentTextId === textId) {
        document.getElementById("text-panel").style.display = "none";
        currentTextId = null;
       }
      }
      
      document.getElementById("text-content").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
      pushUndo("edit text");
        textItem.content = e.target.value;
        forgeTheTopology();
       }
      });
      
      document.getElementById("text-font-size").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        textItem.fontSize = parseInt(e.target.value);
        forgeTheTopology();
       }
      });
      
      document.getElementById("text-color").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        textItem.color = e.target.value;
        forgeTheTopology();
       }
      });
      
      document.getElementById("text-font-weight").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        textItem.fontWeight = e.target.value;
        forgeTheTopology();
       }
      });
      
      document.getElementById("text-font-style").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        textItem.fontStyle = e.target.value;
        forgeTheTopology();
       }
      });
      
      document.getElementById("text-align").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        textItem.textAlign = e.target.value;
        forgeTheTopology();
       }
      });
      
      document.getElementById("text-decoration").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        textItem.textDecoration = e.target.value;
        forgeTheTopology();
       }
      });
      
      document.getElementById("text-bg-color").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        textItem.bgColor = e.target.value;
        forgeTheTopology();
       }
      });
      
      document.getElementById("text-bg-enabled").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        textItem.bgEnabled = e.target.checked;
        forgeTheTopology();
       }
      });
      
      document.getElementById("text-opacity").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        textItem.opacity = parseFloat(e.target.value);
        document.getElementById("text-opacity-val").textContent = Math.round(textItem.opacity * 100) + "%";
        forgeTheTopology();
       }
      });
      
      document.getElementById("delete-text").addEventListener("click", () => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        challengeTheImmortal(`Delete text "${textItem.content.substring(0, 30)}..."?`, () => {
         deleteText(currentTextId);
        });
       }
      });
      
      const settingsBtn = document.getElementById("settings-btn");
      const settingsModal = document.getElementById("settings-modal");
      const settingsClose = document.getElementById("settings-close");
      settingsBtn.addEventListener("click", () => {
       document.getElementById("page-bg-color").value = PAGE_STATE.background || "#050608";
       document.getElementById("topbar-bg-color").value = PAGE_STATE.topbarBg || "#0b0e13";
       document.getElementById("topbar-border-color").value = PAGE_STATE.topbarBorder || "#1f2533";
       document.getElementById("panel-color").value = PAGE_STATE.panel || "#0b0e13";
       document.getElementById("panel-alt-color").value = PAGE_STATE.panelAlt || "#10141b";
       document.getElementById("sidebar-bg-color").value = PAGE_STATE.sidebarBg || "#10141b";
       document.getElementById("btn-bg-color").value = PAGE_STATE.btnBg || "#0b0e13";
       document.getElementById("btn-text-color").value = PAGE_STATE.btnText || "#e2e8f0";
       document.getElementById("tag-fill-color").value = PAGE_STATE.tagFill || "#1e293b";
       document.getElementById("tag-text-color").value = PAGE_STATE.tagText || "#e2e8f0";
       document.getElementById("tag-border-color").value = PAGE_STATE.tagBorder || "#475569";
       document.getElementById("input-bg-color").value = PAGE_STATE.inputBg || "#0b0e13";
       document.getElementById("input-text-color").value = PAGE_STATE.inputText || "#e2e8f0";
       document.getElementById("input-border-color").value = PAGE_STATE.inputBorder || "#1f2937";
       document.getElementById("input-font-family").value = PAGE_STATE.inputFont || "Inter, system-ui, sans-serif";
       document.getElementById("input-font-size").value = PAGE_STATE.inputFontSize || 14;
       document.getElementById("toolbar-bg-color").value = PAGE_STATE.toolbarBg || "#0f172a";
       document.getElementById("toolbar-border-color").value = PAGE_STATE.toolbarBorder || "#1f2937";
       document.getElementById("toolbar-text-color").value = PAGE_STATE.toolbarText || "#94a3b8";
       document.getElementById("toolbar-btn-bg-color").value = PAGE_STATE.toolbarBtnBg || "#0b0e13";
       document.getElementById("toolbar-btn-text-color").value = PAGE_STATE.toolbarBtnText || "#e2e8f0";
       document.getElementById("minimap-dots-color").value = PAGE_STATE.minimapDots || "#94a3b8";
       document.getElementById("canvas-hint-enabled").checked = PAGE_STATE.canvasHintEnabled !== false;
       document.getElementById("canvas-hint-bg-color").value = PAGE_STATE.canvasHintBg || "#0f172a";
       document.getElementById("canvas-hint-text-color").value = PAGE_STATE.canvasHintColor || "#94a3b8";
       document.getElementById("canvas-hint-text").value = PAGE_STATE.canvasHintText || "";
       document.getElementById("accent-color").value = PAGE_STATE.accent || "#4fd1c5";
       document.getElementById("danger-color").value = PAGE_STATE.danger || "#f56565";
       document.getElementById("text-main-color").value = PAGE_STATE.textMain || "#e2e8f0";
       document.getElementById("text-soft-color").value = PAGE_STATE.textSoft || "#94a3b8";
       document.getElementById("node-fill-color").value = PAGE_STATE.nodeFill || "#1e293b";
       document.getElementById("node-stroke-color").value = PAGE_STATE.nodeStroke || "#475569";
       document.getElementById("node-title-color").value = PAGE_STATE.nodeTitle || "#e2e8f0";
       document.getElementById("node-sub-color").value = PAGE_STATE.nodeSub || "#94a3b8";
       document.getElementById("node-title-size").value = PAGE_STATE.nodeTitleSize || 18;
       document.getElementById("node-sub-size").value = PAGE_STATE.nodeSubSize || 13;
       document.getElementById("node-font-family").value = PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
       document.getElementById("default-edge-color").value = PAGE_STATE.defaultEdge || "#475569";
       document.getElementById("selection-handle-color").value = PAGE_STATE.selectionHandle || "#f59e0b";
       document.getElementById("selection-handle-size").value = PAGE_STATE.selectionHandleSize || 8;
       document.getElementById("group-indicator-color").value = PAGE_STATE.groupIndicator || "#4fd1c5";
       document.getElementById("canvas-gradient-top").value = PAGE_STATE.canvasGradientTop || "#1e2532";
       document.getElementById("canvas-gradient-bottom").value = PAGE_STATE.canvasGradientBottom || "#050608";
       document.getElementById("canvas-border-color").value = PAGE_STATE.canvasBorder || "#475569";
       document.getElementById("canvas-grid-color").value = PAGE_STATE.canvasGrid || "#475569";
       document.getElementById("canvas-grid-size").value = PAGE_STATE.canvasGridSize || 50;
       document.getElementById("rack-frame-fill").value = PAGE_STATE.rackFrameFill || "#0f172a";
       document.getElementById("rack-frame-stroke").value = PAGE_STATE.rackFrameStroke || "#4fd1c5";
       document.getElementById("rack-line-color").value = PAGE_STATE.rackLineColor || "#475569";
       document.getElementById("rack-text-color").value = PAGE_STATE.rackTextColor || "#4fd1c5";
	   document.getElementById("view-only-mode").checked = PAGE_STATE.viewOnly === true;
       settingsModal.classList.add("active");
      });
      settingsClose.addEventListener("click", () => {
       settingsModal.classList.remove("active");
      });
	  document.getElementById("view-only-mode").addEventListener("change", (e) => {
       PAGE_STATE.viewOnly = e.target.checked;
       
       if (e.target.checked) {
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        document.getElementById("rect-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.setProperty('display', 'none', 'important');
        document.getElementById("draw-toolbar").style.setProperty('display', 'none', 'important');      
        currentNodeId = null;
        currentEdgeId = null;
        currentRectId = null;
        currentTextId = null;
        selectedNodes.clear();
        selectedRects.clear();
        selectedTexts.clear();
        selectedEdges.clear();   
        const bulkToolbar = document.getElementById("bulk-toolbar");
        const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active", "selected"));
        document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
        document.querySelectorAll(".rect-group").forEach(r => r.classList.remove("active"));
        document.querySelectorAll(".text-element").forEach(t => t.classList.remove("active"));
       }
       
       wieldThePower();
       if (!e.target.checked) {
        updateDrawToolbarVisibility();
        updateTopologyToolbarVisibility();
       }
       forgeTheTopology();
      });
      settingsModal.addEventListener("click", (e) => {
       if (e.target === settingsModal) {
        settingsModal.classList.remove("active");
       }
      });
      document.getElementById("page-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.background = e.target.value;
       wieldThePower();
      });
      document.getElementById("topbar-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.topbarBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("topbar-border-color").addEventListener("input", (e) => {
       PAGE_STATE.topbarBorder = e.target.value;
       wieldThePower();
      });
      document.getElementById("panel-color").addEventListener("input", (e) => {
       PAGE_STATE.panel = e.target.value;
       wieldThePower();
      });
      document.getElementById("panel-alt-color").addEventListener("input", (e) => {
       PAGE_STATE.panelAlt = e.target.value;
       wieldThePower();
      });
      document.getElementById("sidebar-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.sidebarBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("btn-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.btnBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("btn-text-color").addEventListener("input", (e) => {
       PAGE_STATE.btnText = e.target.value;
       wieldThePower();
      });
      document.getElementById("tag-fill-color").addEventListener("input", (e) => {
       PAGE_STATE.tagFill = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("tag-text-color").addEventListener("input", (e) => {
       PAGE_STATE.tagText = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("tag-border-color").addEventListener("input", (e) => {
       PAGE_STATE.tagBorder = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
	  document.getElementById("selection-fill-color").addEventListener("input", function() {
       selectionBoxStyle.fillColor = this.value;
      });
      document.getElementById("selection-fill-opacity").addEventListener("input", function() {
       selectionBoxStyle.fillOpacity = parseFloat(this.value);
       document.getElementById("selection-fill-opacity-val").textContent = Math.round(this.value * 100) + "%";
      });
      document.getElementById("selection-stroke-color").addEventListener("input", function() {
       selectionBoxStyle.strokeColor = this.value;
      });
      document.getElementById("selection-stroke-width").addEventListener("input", function() {
       selectionBoxStyle.strokeWidth = parseInt(this.value) || 2;
      });
      document.getElementById("selection-stroke-style").addEventListener("change", function() {
       selectionBoxStyle.strokeDasharray = this.value;
      });
      document.getElementById("input-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.inputBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-text-color").addEventListener("input", (e) => {
       PAGE_STATE.inputText = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-border-color").addEventListener("input", (e) => {
       PAGE_STATE.inputBorder = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-font-family").addEventListener("change", (e) => {
       PAGE_STATE.inputFont = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-font-size").addEventListener("input", (e) => {
       PAGE_STATE.inputFontSize = parseInt(e.target.value) || 14;
       wieldThePower();
      });
      document.getElementById("toolbar-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-border-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBorder = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-text-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarText = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-btn-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBtnBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-btn-text-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBtnText = e.target.value;
       wieldThePower();
      });
      document.getElementById("minimap-dots-color").addEventListener("input", (e) => {
       PAGE_STATE.minimapDots = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("canvas-hint-enabled").addEventListener("change", (e) => {
       PAGE_STATE.canvasHintEnabled = e.target.checked;
       wieldThePower();
      });
      document.getElementById("canvas-hint-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-hint-text-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintColor = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-hint-text").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintText = e.target.value;
       wieldThePower();
      });
      document.getElementById("accent-color").addEventListener("input", (e) => {
       PAGE_STATE.accent = e.target.value;
       wieldThePower();
      });
      document.getElementById("danger-color").addEventListener("input", (e) => {
       PAGE_STATE.danger = e.target.value;
       wieldThePower();
      });
      document.getElementById("text-main-color").addEventListener("input", (e) => {
       PAGE_STATE.textMain = e.target.value;
       wieldThePower();
      });
      document.getElementById("text-soft-color").addEventListener("input", (e) => {
       PAGE_STATE.textSoft = e.target.value;
       wieldThePower();
      });
      document.getElementById("node-fill-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeFill = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-stroke-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeStroke = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-title-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeTitle = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-sub-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeSub = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-title-size").addEventListener("input", (e) => {
       PAGE_STATE.nodeTitleSize = parseInt(e.target.value) || 18;
       forgeTheTopology();
      });
      document.getElementById("node-sub-size").addEventListener("input", (e) => {
       PAGE_STATE.nodeSubSize = parseInt(e.target.value) || 13;
       forgeTheTopology();
      });
      document.getElementById("node-font-family").addEventListener("change", (e) => {
       PAGE_STATE.nodeFont = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("default-edge-color").addEventListener("input", (e) => {
       PAGE_STATE.defaultEdge = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("selection-handle-color").addEventListener("input", (e) => {
       PAGE_STATE.selectionHandle = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("selection-handle-size").addEventListener("input", (e) => {
       PAGE_STATE.selectionHandleSize = parseInt(e.target.value) || 8;
       forgeTheTopology();
      });
      document.getElementById("group-indicator-color").addEventListener("input", (e) => {
       PAGE_STATE.groupIndicator = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-gradient-top").addEventListener("input", (e) => {
       PAGE_STATE.canvasGradientTop = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-gradient-bottom").addEventListener("input", (e) => {
       PAGE_STATE.canvasGradientBottom = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-border-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasBorder = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-grid-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasGrid = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-grid-size").addEventListener("input", (e) => {
       PAGE_STATE.canvasGridSize = parseInt(e.target.value) || 50;
       forgeTheTopology();
      });
      document.getElementById("rack-frame-fill").addEventListener("input", (e) => {
       PAGE_STATE.rackFrameFill = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-frame-stroke").addEventListener("input", (e) => {
       PAGE_STATE.rackFrameStroke = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-line-color").addEventListener("input", (e) => {
       PAGE_STATE.rackLineColor = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-text-color").addEventListener("input", (e) => {
       PAGE_STATE.rackTextColor = e.target.value;
       forgeTheTopology();
      });
      
      (function initializeResizers() {
        const headerResizer = document.getElementById('header-resizer');
        const sidebarResizer = document.getElementById('sidebar-resizer');
        const mobileFooterResizer = document.getElementById('mobile-footer-resizer');
        
        let isResizing = false;
        let currentResizer = null;
        let startY = 0;
        let startX = 0;
        let startHeight = 0;
        let startWidth = 0;
        
        function getClientPos(e) {
          if (e.touches && e.touches.length > 0) {
            return { x: e.touches[0].clientX, y: e.touches[0].clientY };
          }
          return { x: e.clientX, y: e.clientY };
        }
        
        function startResize(resizer, type, e) {
          isResizing = true;
          currentResizer = type;
          const pos = getClientPos(e);
          
          if (type === 'header') {
            startY = pos.y;
            startHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--topbar-height'));
          } else if (type === 'sidebar') {
            startX = pos.x;
            startWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width'));
          } else if (type === 'mobile-footer') {
            startY = pos.y;
            const currentVh = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--mobile-footer-height'));
            startHeight = (currentVh / 100) * window.innerHeight;
          }
          
          resizer.classList.add('resizing');
          document.body.classList.add('resizing');
          document.body.style.cursor = (type === 'sidebar') ? 'col-resize' : 'row-resize';
          e.preventDefault();
        }
        
        if (headerResizer) {
          headerResizer.addEventListener('mousedown', (e) => startResize(headerResizer, 'header', e));
          headerResizer.addEventListener('touchstart', (e) => startResize(headerResizer, 'header', e), { passive: false });
        }
        
        if (sidebarResizer) {
          sidebarResizer.addEventListener('mousedown', (e) => startResize(sidebarResizer, 'sidebar', e));
          sidebarResizer.addEventListener('touchstart', (e) => startResize(sidebarResizer, 'sidebar', e), { passive: false });
        }
        
        if (mobileFooterResizer) {
          mobileFooterResizer.addEventListener('mousedown', (e) => startResize(mobileFooterResizer, 'mobile-footer', e));
          mobileFooterResizer.addEventListener('touchstart', (e) => startResize(mobileFooterResizer, 'mobile-footer', e), { passive: false });
        }
        
        function handleMove(e) {
          if (!isResizing) return;
          
          const pos = getClientPos(e);
          
          if (currentResizer === 'header') {
            const deltaY = pos.y - startY;
            const newHeight = Math.max(40, Math.min(150, startHeight + deltaY));
            document.documentElement.style.setProperty('--topbar-height', newHeight + 'px');
          } else if (currentResizer === 'sidebar') {
            const deltaX = startX - pos.x;
            const newWidth = Math.max(200, Math.min(800, startWidth + deltaX));
            document.documentElement.style.setProperty('--sidebar-width', newWidth + 'px');
          } else if (currentResizer === 'mobile-footer') {
            const deltaY = startY - pos.y;
            const newHeight = startHeight + deltaY;
            const newVh = Math.max(15, Math.min(80, (newHeight / window.innerHeight) * 100));
            document.documentElement.style.setProperty('--mobile-footer-height', newVh + 'vh');
          }
          
          e.preventDefault();
        }
        
        document.addEventListener('mousemove', handleMove);
        document.addEventListener('touchmove', handleMove, { passive: false });
        
        function handleEnd() {
          if (isResizing) {
            isResizing = false;
            
            if (currentResizer === 'header') {
              PAGE_STATE.topbarHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--topbar-height'));
              headerResizer.classList.remove('resizing');
            } else if (currentResizer === 'sidebar') {
              PAGE_STATE.sidebarWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width'));
              sidebarResizer.classList.remove('resizing');
            } else if (currentResizer === 'mobile-footer') {
              PAGE_STATE.mobileFooterHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--mobile-footer-height'));
              mobileFooterResizer.classList.remove('resizing');
            }
            
            document.body.classList.remove('resizing');
            document.body.style.cursor = '';
            currentResizer = null;
          }
        }
        
        document.addEventListener('mouseup', handleEnd);
        document.addEventListener('touchend', handleEnd);
        document.addEventListener('touchcancel', handleEnd);
      })();
      
      document.getElementById("export-data-btn").addEventListener("click", () => {
       const data = captureTheQuickening();
       const jsonStr = JSON.stringify(data, null, 2);
       const blob = new Blob([jsonStr], {
        type: "application/json"
       });
       const url = URL.createObjectURL(blob);
       const a = document.createElement("a");
       a.href = url;
       const safeTitle = (PAGE_STATE.title || "network-topology").toLowerCase().replace(/[^a-z0-9\-]+/g, "-");
       const timestamp = new Date().toISOString().split("T")[0];
       a.download = `${safeTitle}-data-${timestamp}.json`;
       document.body.appendChild(a);
       a.click();
       document.body.removeChild(a);
       URL.revokeObjectURL(url);
       logAuditEvent("export", `Exported JSON: ${a.download}`);
      });
      document.getElementById("import-data-btn").addEventListener("click", () => {
       document.getElementById("import-data-file").click();
      });
      document.getElementById("import-data-file").addEventListener("change", async (e) => {
       const file = e.target.files[0];
       if (!file) return;
       try {
        const text = await file.text();
        const data = JSON.parse(text);
        if (!data.nodeData || !data.edgeData) {
         alert("Invalid data file. Missing required fields.");
         return;
        }
        const confirmMsg = `This will replace all current data with the imported data.\n\nImporting:\n- ${Object.keys(data.nodeData).length} nodes\n- ${data.edgeData.list?.length || 0} connections\n- ${data.documentTabs?.length || 1} tab(s)\n\nContinue?`;
        if (!confirm(confirmMsg)) {
         e.target.value = "";
         return;
        }
        NODE_DATA = data.nodeData || {};
        EDGE_DATA = data.edgeData || {
         list: []
        };
        EDGE_LEGEND = data.edgeLegend || {};
        RECT_DATA = data.rectData || { list: [] };
        TEXT_DATA = data.textData || { list: [] };
        savedPositions = data.nodePositions || {};
        savedSizes = data.nodeSizes || {};
        savedStyles = data.nodeStyles || {};
        if (data.page) {
         PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, data.page, );
         wieldThePower();
        }
        if (data.canvas) {
         canvasState.zoom = data.canvas.zoom || 1;
         canvasState.panX = data.canvas.panX || 0;
         canvasState.panY = data.canvas.panY || 0;
        }
        if (data.page?.title) {
         document.title = data.page.title;
         document.querySelector(".editable-page-title", ).textContent = data.page.title;
        }
        if (data.documentTabs) {
         documentTabs = data.documentTabs;
         currentTabIndex = data.currentTabIndex || 0;
        }
        if (data.savedTopologyView) {
         savedTopologyView = data.savedTopologyView;
        }
        if (data.encryptedSections) {
         encryptedSections = data.encryptedSections;
        }
        if (data.auditLog && Array.isArray(data.auditLog)) {
         auditLog = data.auditLog;
         try {
           localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
         } catch (e) {
           console.warn("Failed to sync audit log to localStorage:", e);
         }
        }
        forgeTheTopology();
        forgeTheLegend();
		logAuditEvent("import", `Imported JSON: ${file.name} (${Object.keys(data.nodeData).length} nodes, ${data.edgeData.list?.length || 0} connections)`);
        updateViewBox();
        const nodeIds = Object.keys(NODE_DATA);
        if (nodeIds.length > 0) {
         claimTheImmortal(nodeIds[0]);
        } else {
         document.getElementById("node-panel").style.display = "none";
         document.getElementById("edge-panel").style.display = "none";
         document.getElementById("topology-toolbar").style.display = "none";
        }
        e.target.value = "";
       } catch (err) {
        console.error("Import error:", err);
        alert(`Failed to import data: ${err.message}`);
        e.target.value = "";
       }
      });
      const saveHelpBtn = document.getElementById("save-help-btn");
      const saveInfoModal = document.getElementById("save-info-modal");
      const saveInfoClose = document.getElementById("save-info-close");
      saveHelpBtn.addEventListener("click", () => {
       saveInfoModal.classList.add("active");
      });
      saveInfoClose.addEventListener("click", () => {
       saveInfoModal.classList.remove("active");
      });
      saveInfoModal.addEventListener("click", (e) => {
       if (e.target === saveInfoModal) {
        saveInfoModal.classList.remove("active");
       }
      });
      document.querySelectorAll(".help-tab").forEach(tab => {
        tab.addEventListener("click", () => {
          document.querySelectorAll(".help-tab").forEach(t => { t.style.background = "var(--panel)"; t.style.color = "var(--text-main)"; });
          tab.style.background = "var(--accent)"; tab.style.color = "var(--bg)";
          document.querySelectorAll(".help-tab-content").forEach(c => c.style.display = "none");
          document.getElementById("help-tab-" + tab.dataset.tab).style.display = "block";
        });
      });
      async function deriveKey(password, salt) {
      const encoder = new TextEncoder();
      
      const keyMaterial = await crypto.subtle.importKey(
      "raw",
      encoder.encode(password),
      "PBKDF2",
      false,
      ["deriveKey"]
      );
      
      return crypto.subtle.deriveKey(
      {
      name: "PBKDF2",
      salt: salt,
      iterations: 200000,
      hash: "SHA-256"
      },
      keyMaterial,
      {
      name: "AES-GCM",
      length: 256
      },
      false,
      ["encrypt", "decrypt"]
      );
      }
      
      async function encryptData(data, password) {
      const encoder = new TextEncoder();
      const salt = crypto.getRandomValues(new Uint8Array(16));
      const iv   = crypto.getRandomValues(new Uint8Array(12));
      
      const key = await deriveKey(password, salt);
      const encrypted = await crypto.subtle.encrypt(
      { name: "AES-GCM", iv },
      key,
      encoder.encode(data)
      );
      
      const encryptedU8 = new Uint8Array(encrypted);
      
      const result = new Uint8Array(salt.length + iv.length + encryptedU8.length);
      result.set(salt, 0);
      result.set(iv, salt.length);
      result.set(encryptedU8, salt.length + iv.length);
      
      return "ENCRYPTED:" + u8ToBase64(result);
      }
      
      async function decryptData(encryptedData, password) {
      const base64Data = encryptedData.replace("ENCRYPTED:", "");
      const fullData   = base64ToU8(base64Data);
      
      const salt      = fullData.slice(0, 16);
      const iv        = fullData.slice(16, 28);
      const encrypted = fullData.slice(28);
      
      const key = await deriveKey(password, salt);
      
      const decrypted = await crypto.subtle.decrypt(
      { name: "AES-GCM", iv },
      key,
      encrypted
      );
      
      const decoder = new TextDecoder();
      return decoder.decode(decrypted);
      }
      
      
      function isEncrypted(data) {
       return typeof data === "string" && data.startsWith("ENCRYPTED:");
      }
      
      function captureTheQuickening() {
       const currentTab = documentTabs[currentTabIndex];
       currentTab.nodes = JSON.parse(JSON.stringify(NODE_DATA));
       currentTab.edges = JSON.parse(JSON.stringify(EDGE_DATA));
       currentTab.positions = JSON.parse(JSON.stringify(savedPositions));
       currentTab.sizes = JSON.parse(JSON.stringify(savedSizes));
       currentTab.styles = JSON.parse(JSON.stringify(savedStyles));
       currentTab.legend = JSON.parse(JSON.stringify(EDGE_LEGEND));
       currentTab.rects = JSON.parse(JSON.stringify(RECT_DATA));
       currentTab.texts = JSON.parse(JSON.stringify(TEXT_DATA));
       currentTab.pageState = JSON.parse(JSON.stringify(PAGE_STATE));
       
       return {
        nodeData: NODE_DATA,
        edgeData: EDGE_DATA,
        rectData: RECT_DATA,
        textData: TEXT_DATA,
        edgeLegend: EDGE_LEGEND,
        nodePositions: savedPositions,
        nodeSizes: savedSizes,
        nodeStyles: savedStyles,
        page: PAGE_STATE,
        canvas: {
         zoom: canvasState.zoom,
         panX: canvasState.panX,
         panY: canvasState.panY,
        },
        savedTopologyView: savedTopologyView,
        documentTabs: documentTabs,
        currentTabIndex: currentTabIndex,
        encryptedSections: encryptedSections,
        auditLog: auditLog,
       };
      }
      
      function assembleTheImmortalForm() {
      const canvasHintEl = document.getElementById("canvas-hint");
       const savedHintHTML = canvasHintEl ? canvasHintEl.innerHTML : "";
       if (canvasHintEl) canvasHintEl.innerHTML = DEFAULT_CANVAS_HINT;
       const clone = document.documentElement.cloneNode(true);
       ["edge-legend-mini", "minimap-mini", "draw-toolbar-mini", "topology-toolbar-mini"].forEach(id => {
        const all = clone.querySelectorAll("#" + id);
        for (let i = 1; i < all.length; i++) {
         all[i].remove();
        }
       });
       const nodeScript = clone.querySelector("#nodes-json");
       if (nodeScript) {
        nodeScript.textContent = JSON.stringify(NODE_DATA, null, 2);
       }
       let stateScript = clone.querySelector("#topology-state");
       if (!stateScript) {
        stateScript = document.createElement("script");
        stateScript.id = "topology-state";
        stateScript.type = "application/json";
        const body = clone.querySelector("body") || clone;
        body.appendChild(stateScript);
       }
       stateScript.textContent = JSON.stringify(captureTheQuickening(), null, 2, );
       return "<!DOCTYPE html> \n " + clone.outerHTML;
      }
      async function becomeImmortal() {
       saveRollbackVersion("Auto-save");
       
       const encryptEnabled = document.getElementById("encrypt-toggle").checked;
       let stateData = JSON.stringify(captureTheQuickening(), null, 2);
       if (encryptEnabled) {
        const password = prompt("Enter a password to encrypt your data:\n(Remember this password! You will need it to open this file and its non recoverable!)", );
        if (!password) {
         alert("Encryption cancelled. File not saved.");
         return;
        }
        const confirmPassword = prompt("Confirm your password:");
        if (password !== confirmPassword) {
         alert("Passwords do not match. File not saved.");
         return;
        }
        try {
         stateData = await encryptData(stateData, password);
        } catch (e) {
         alert("Encryption failed: " + e.message);
         return;
        }
       }
       const canvasHintEl = document.getElementById("canvas-hint");
       const savedHintHTML = canvasHintEl ? canvasHintEl.innerHTML : "";
       if (canvasHintEl) canvasHintEl.innerHTML = DEFAULT_CANVAS_HINT;    
       const clone = document.documentElement.cloneNode(true);
       ["edge-legend-mini", "minimap-mini", "draw-toolbar-mini", "topology-toolbar-mini"].forEach(id => {
        const all = clone.querySelectorAll("#" + id);
        for (let i = 1; i < all.length; i++) {
         all[i].remove();
        }
       });
       
       const nodeScript = clone.querySelector("#nodes-json");
       if (nodeScript) {
        if (encryptEnabled) {
         nodeScript.textContent = JSON.stringify({}, null, 2);
        } else {
         nodeScript.textContent = JSON.stringify(NODE_DATA, null, 2);
        }
       }
       let stateScript = clone.querySelector("#topology-state");
       if (!stateScript) {
        stateScript = document.createElement("script");
        stateScript.id = "topology-state";
        stateScript.type = "application/json";
        const body = clone.querySelector("body") || clone;
        body.appendChild(stateScript);
       }
       stateScript.textContent = stateData;
       const html = "<!DOCTYPE html> \n " + clone.outerHTML;
       const blob = new Blob([html], {
        type: "text/html"
       });
       const url = URL.createObjectURL(blob);
       const a = document.createElement("a");
       a.href = url;
       const safeTitle = (PAGE_STATE.title || document.title || "network-topology").toLowerCase().replace(/[^a-z0-9\-]+/g, "-");
       a.download = safeTitle + ".html";
       document.body.appendChild(a);
       a.click();
       document.body.removeChild(a);
       URL.revokeObjectURL(url);
       if (canvasHintEl) canvasHintEl.innerHTML = savedHintHTML;
       logAuditEvent("save", `File saved: ${safeTitle}.html`);
      }
      
      function captureState() {
      return {
       nodes: JSON.parse(JSON.stringify(NODE_DATA)),
       edges: JSON.parse(JSON.stringify(EDGE_DATA)),
       positions: JSON.parse(JSON.stringify(savedPositions)),
       sizes: JSON.parse(JSON.stringify(savedSizes)),
       styles: JSON.parse(JSON.stringify(savedStyles)),
       legend: JSON.parse(JSON.stringify(EDGE_LEGEND)),
       rects: JSON.parse(JSON.stringify(RECT_DATA)),
       texts: JSON.parse(JSON.stringify(TEXT_DATA))
       };
      }
      
      function pushUndo(action = "") {
       const state = captureState();
       undoStack.push(state);
       if (undoStack.length > MAX_UNDO_STACK) {
        undoStack.shift();
       }
       redoStack = [];
       updateUndoButtons();
       
       if (action) {
        const actionTypeMap = {
  "create node": "node",
  "delete node": "node",
  "add node": "node",
  "edit": "node",
  "clone node": "node",
  "paste node": "node",
  "move nodes": "node",
  "nudge": "node",
  "align nodes": "node",
  "distribute nodes": "node",
  "snap to grid": "node",
  "toggle group": "node",
  "toggle lock": "node",
  "create rack": "rack",
  "add rack": "rack",
  "edit rack": "rack",
  "edit mac": "rack",
  "edit U height": "rack",
  "change rack capacity": "rack",
  "change assigned rack": "rack",
  "add connection": "connection",
  "delete connection": "connection",
  "delete edge": "connection",
  "clone edge": "connection",
  "paste edge": "connection",
  "style change": "style",
  "change layer": "layer",
  "add text": "text",
  "edit text": "text",
  "delete text": "text",
  "clone text": "text",
  "paste text": "text",
  "draw zone": "zone",
  "delete zone": "zone",
  "delete rect": "zone",
  "clone rect": "zone",
  "paste rect": "zone",
  "change zone line style": "zone",
  "delete selected": "bulk",
  "clone selected": "bulk",
};
        
        const type = actionTypeMap[action] || "node";
        logAuditEvent(type, action);
       }
      }
      
      function undo() {
       if (undoStack.length === 0) return;
       const currentState = captureState();
       redoStack.push(currentState);
       const previousState = undoStack.pop();
       restoreState(previousState);
       updateUndoButtons();
       logAuditEvent("undo", "Undo action performed");
      }
      
      function redo() {
       if (redoStack.length === 0) return;
       logAuditEvent("redo", "Redo action performed");
       const currentState = captureState();
       undoStack.push(currentState);
       const nextState = redoStack.pop();
       restoreState(nextState);
       updateUndoButtons();
      }
      
      function restoreState(state) {
      NODE_DATA = state.nodes;
      EDGE_DATA = state.edges;
      savedPositions = state.positions;
      savedSizes = state.sizes;
      savedStyles = state.styles;
      EDGE_LEGEND = state.legend;
      RECT_DATA = state.rects || { list: [] };
      TEXT_DATA = state.texts || { list: [] };
      forgeTheTopology();
      if (currentNodeId && NODE_DATA[currentNodeId]) {
       claimTheImmortal(currentNodeId);
      } else if (currentEdgeId) {
       selectTheConnection(currentEdgeId);
       }
      }
      
      function updateUndoButtons() {
       const undoBtn = document.getElementById("undo-btn");
       const redoBtn = document.getElementById("redo-btn");
       if (undoBtn) {
        undoBtn.disabled = undoStack.length === 0;
        undoBtn.style.opacity = undoStack.length === 0 ? "0.5" : "1";
       }
       if (redoBtn) {
        redoBtn.disabled = redoStack.length === 0;
        redoBtn.style.opacity = redoStack.length === 0 ? "0.5" : "1";
       }
      }
      
      function editNodeMac(id) {
       const currentMac = NODE_DATA[id].mac || "";
       showEditModal("Edit MAC Address", currentMac, (newMac) => {
        pushUndo("edit mac");
        NODE_DATA[id].mac = newMac;
        if (currentNodeId === id) {
         document.getElementById("node-mac").textContent = newMac || "--";
        }
       });
      }
      
      function editNodeRack(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       
       document.getElementById("modal-title").textContent = "Edit Rack Unit";
       document.getElementById("modal-input").value = node.rackUnit || "";
       document.getElementById("edit-modal").style.display = "flex";
       document.getElementById("modal-input").focus();
       
       const saveHandler = () => {
        pushUndo("edit rack");
        const value = document.getElementById("modal-input").value.trim();
        node.rackUnit = value;
        document.getElementById("edit-modal").style.display = "none";
        claimTheImmortal(id);
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       
       const cancelHandler = () => {
        document.getElementById("edit-modal").style.display = "none";
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       
       document.getElementById("edit-modal").addEventListener("click", function bgHandler(e) {
        if (e.target === document.getElementById("edit-modal")) {
         cancelHandler();
         document.getElementById("edit-modal").removeEventListener("click", bgHandler);
        }
       });
      }
      
      function editNodeUHeight(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       
       document.getElementById("modal-title").textContent = "Edit U Height";
       document.getElementById("modal-input").value = node.uHeight || "1";
       document.getElementById("edit-modal").style.display = "flex";
       document.getElementById("modal-input").focus();
       
       const saveHandler = () => {
        pushUndo("edit U height");
        const value = document.getElementById("modal-input").value.trim();
        node.uHeight = value;
        document.getElementById("edit-modal").style.display = "none";
        claimTheImmortal(id);
        forgeTheTopology();
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       
       const cancelHandler = () => {
        document.getElementById("edit-modal").style.display = "none";
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       
       document.getElementById("edit-modal").addEventListener("click", function bgHandler(e) {
        if (e.target === document.getElementById("edit-modal")) {
         cancelHandler();
         document.getElementById("edit-modal").removeEventListener("click", bgHandler);
        }
       });
      }
      
      function updateEdgePortLabels(edgeId) {
       const edge = EDGE_DATA.list.find(e => e.id === edgeId);
       if (!edge || edge.type === "custom") return;
       
       const fromPortInput = document.getElementById("edge-from-port");
       const toPortInput = document.getElementById("edge-to-port");
       
       if (fromPortInput && toPortInput) {
        edge.fromPort = fromPortInput.value || "";
        edge.toPort = toPortInput.value || "";
        
        forgeTheTopology();
       }
      }
      
      function clearSelection() {
       selectedNodes.clear();
       selectedEdges.clear();
       selectedRects.clear();
       selectedTexts.clear();
       updateAllSelections();
      }
      
      function updateAllSelections() {
      updateNodeSelection();
      
      document.querySelectorAll(".edge").forEach(el => {
      const edgeId = el.dataset.edgeId;
      if (selectedEdges.has(edgeId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      
      document.querySelectorAll(".rect-group").forEach(el => {
      const rectId = el.dataset.rectId;
      if (selectedRects.has(rectId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      
      document.querySelectorAll(".text-group").forEach(el => {
      const textId = el.dataset.textId;
      if (selectedTexts.has(textId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      
      const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
      const bulkToolbar = document.getElementById("bulk-toolbar");
      const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
      const bulkCount = document.getElementById("bulk-count");
      const bulkCountMobile = document.getElementById("bulk-count-mobile");
      
      if (total > 0) {
      if (bulkToolbar) bulkToolbar.style.display = "flex";
      if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
      if (bulkCount) bulkCount.textContent = total;
      if (bulkCountMobile) bulkCountMobile.textContent = total;
      } else {
      if (bulkToolbar) bulkToolbar.style.display = "none";
      if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
      }
      }
      
      function updateNodeSelection() {
       if (isViewOnly()) {
        selectedNodes.clear();
        selectedRects.clear();
        selectedTexts.clear();
        const bulkToolbar = document.getElementById("bulk-toolbar");
        const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        return;
       }
       document.querySelectorAll(".node-group").forEach(node => {
        const nodeId = node.dataset.nodeId;
        if (selectedNodes.has(nodeId)) {
         node.classList.add("selected");
        } else {
         node.classList.remove("selected");
        }
       });
       
       const bulkToolbar = document.getElementById("bulk-toolbar");
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       const bulkCount = document.getElementById("bulk-count");
       const bulkCountMobile = document.getElementById("bulk-count-mobile");
       const bulkCountModal = document.getElementById("bulk-count-modal");
       
       if (selectedNodes.size > 0) {
        if (bulkToolbar) bulkToolbar.style.display = "flex";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
        if (bulkCount) bulkCount.textContent = selectedNodes.size;
        if (bulkCountMobile) bulkCountMobile.textContent = selectedNodes.size;
        if (bulkCountModal) bulkCountModal.textContent = selectedNodes.size;
       } else {
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        const modal = document.getElementById("bulk-actions-modal");
        if (modal) modal.style.display = "none";
       }
      }
      
      function deleteSelected() {
       const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
       if (total === 0) return;
       
       let nodesInsideRacks = [];
       selectedNodes.forEach(nodeId => {
        if (NODE_DATA[nodeId]?.isRack) {
         Object.entries(NODE_DATA).forEach(([id, n]) => {
          if (n.assignedRack === nodeId) nodesInsideRacks.push(n.name || id);
         });
        }
       });
       
       let message = `Delete ${total} selected item(s)?`;
       if (nodesInsideRacks.length > 0) {
        message += `\n\nThis will also delete ${nodesInsideRacks.length} node(s) inside rack(s):\n• ${nodesInsideRacks.join('\n• ')}`;
       }
       
       challengeTheImmortal(message, () => {
        pushUndo("delete selected");
        selectedNodes.forEach(nodeId => {
         if (NODE_DATA[nodeId]?.isRack) {
          Object.keys(NODE_DATA).forEach(id => {
           if (NODE_DATA[id]?.assignedRack === nodeId) {
            EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== id && e.to !== id);
            delete NODE_DATA[id];
            delete savedPositions[id];
            delete savedSizes[id];
            delete savedStyles[id];
           }
          });
         }
         delete NODE_DATA[nodeId];
         delete savedPositions[nodeId];
         delete savedSizes[nodeId];
         delete savedStyles[nodeId];
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== nodeId && e.to !== nodeId);
        });
        selectedEdges.forEach(edgeId => {
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.id !== edgeId);
        });
        selectedRects.forEach(rectId => {
         RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== rectId);
        });
        selectedTexts.forEach(textId => {
         TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== textId);
        });
        clearSelection();
        
        forgeTheTopology();
       });
      }
      
      function startSelection(event) {
       if (event.button !== 0) return;
       if (event.target.closest(".node-group")) return;
       
       isSelecting = true;
       const svg = document.getElementById("map");
       const pt = svg.createSVGPoint();
       pt.x = event.clientX;
       pt.y = event.clientY;
       const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
       selectionStart = { x: svgP.x, y: svgP.y };
       
       if (!event.shiftKey) {
        clearSelection();
       }
       
       preDragSelectedNodes = new Set(selectedNodes);
       preDragSelectedEdges = new Set(selectedEdges);
       preDragSelectedRects = new Set(selectedRects);
       preDragSelectedTexts = new Set(selectedTexts);
       
       if (!selectionRect || !selectionRect.parentNode) {
        selectionRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        selectionRect.setAttribute("fill", selectionBoxStyle.fillColor);
        selectionRect.setAttribute("fill-opacity", selectionBoxStyle.fillOpacity);
        selectionRect.setAttribute("stroke", selectionBoxStyle.strokeColor);
        selectionRect.setAttribute("stroke-width", selectionBoxStyle.strokeWidth);
        selectionRect.setAttribute("stroke-dasharray", selectionBoxStyle.strokeDasharray);
        svg.appendChild(selectionRect);
       }
       selectionRect.style.display = "block";
      }
      
      function updateSelection(event) {
       if (!isSelecting || !selectionStart) return;
       
       const svg = document.getElementById("map");
       const pt = svg.createSVGPoint();
       pt.x = event.clientX;
       pt.y = event.clientY;
       const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
       
       const x = Math.min(selectionStart.x, svgP.x);
       const y = Math.min(selectionStart.y, svgP.y);
       const width = Math.abs(svgP.x - selectionStart.x);
       const height = Math.abs(svgP.y - selectionStart.y);
       
       selectionRect.setAttribute("x", x);
       selectionRect.setAttribute("y", y);
       selectionRect.setAttribute("width", width);
       selectionRect.setAttribute("height", height);
       
       const box = { x, y, width, height };
       
       Object.entries(savedPositions).forEach(([nodeId, pos]) => {
        const size = savedSizes[nodeId] || 50;
        const halfSize = size / 2;
        const nodeBox = { x: pos.x - halfSize, y: pos.y - halfSize, width: size, height: size };
        if (boxesIntersect(box, nodeBox)) {
         selectedNodes.add(nodeId);
        } else if (!preDragSelectedNodes.has(nodeId)) {
         selectedNodes.delete(nodeId);
        }
       });
       
      EDGE_DATA.list.forEach(edge => {
        if (!edge.points || edge.points.length === 0) return;
        for (let i = 0; i < edge.points.length - 1; i++) {
         const p1 = edge.points[i];
         const p2 = edge.points[i + 1];
         if (lineIntersectsBox(p1.x, p1.y, p2.x, p2.y, box)) {
          selectedEdges.add(edge.id);
          return;
         }
        }
        if (!preDragSelectedEdges.has(edge.id)) {
         selectedEdges.delete(edge.id);
        }
       });
       
       RECT_DATA.list.forEach(rect => {
        const rectBox = { x: rect.x, y: rect.y, width: rect.width, height: rect.height };
        if (boxesIntersect(box, rectBox)) {
         selectedRects.add(rect.id);
        } else if (!preDragSelectedRects.has(rect.id)) {
         selectedRects.delete(rect.id);
        }
       });
       
       TEXT_DATA.list.forEach(text => {
        const fontSize = text.fontSize || 18;
        const textBox = { x: text.x - 50, y: text.y - fontSize, width: 100, height: fontSize * 1.5 };
        if (boxesIntersect(box, textBox)) {
         selectedTexts.add(text.id);
        } else if (!preDragSelectedTexts.has(text.id)) {
         selectedTexts.delete(text.id);
        }
       });
       
       updateAllSelectionVisuals();
      }
      
      function endSelection() {
       isSelecting = false;
       if (selectionRect) {
        selectionRect.style.display = "none";
       }
      }
      
      function boxesIntersect(a, b) {
       return !(a.x + a.width < b.x || b.x + b.width < a.x || a.y + a.height < b.y || b.y + b.height < a.y);
      }
      
      function lineIntersectsBox(x1, y1, x2, y2, box) {
       if (pointInBox(x1, y1, box) || pointInBox(x2, y2, box)) return true;
       const lines = [
        [box.x, box.y, box.x + box.width, box.y],
        [box.x + box.width, box.y, box.x + box.width, box.y + box.height],
        [box.x + box.width, box.y + box.height, box.x, box.y + box.height],
        [box.x, box.y + box.height, box.x, box.y]
       ];
       for (const [bx1, by1, bx2, by2] of lines) {
        if (linesIntersect(x1, y1, x2, y2, bx1, by1, bx2, by2)) return true;
       }
       return false;
      }
      
      function pointInBox(x, y, box) {
       return x >= box.x && x <= box.x + box.width && y >= box.y && y <= box.y + box.height;
      }
      
      function linesIntersect(x1, y1, x2, y2, x3, y3, x4, y4) {
       const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
       if (Math.abs(denom) < 0.0001) return false;
       const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom;
       const ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denom;
       return ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1;
      }
      
      function updateAllSelectionVisuals() {
       document.querySelectorAll(".node-group").forEach(node => {
        const nodeId = node.dataset.nodeId;
        if (selectedNodes.has(nodeId)) {
         node.classList.add("selected");
        } else {
         node.classList.remove("selected");
        }
       });
       
       document.querySelectorAll(".edge").forEach(edge => {
        const edgeId = edge.dataset.edgeId;
        if (selectedEdges.has(edgeId)) {
         edge.style.filter = "drop-shadow(0 0 6px #4fd1c5)";
        } else {
         edge.style.filter = "";
        }
       });
       
       document.querySelectorAll(".rect-group rect").forEach(el => {
        const rectId = el.closest(".rect-group")?.dataset?.rectId;
        if (selectedRects.has(rectId)) {
         el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
        } else {
         el.style.filter = "";
        }
       });
       
       document.querySelectorAll(".text-group, .text-element").forEach(el => {
        const textId = el.dataset?.textId;
        if (selectedTexts.has(textId)) {
         el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
        } else {
         el.style.filter = "";
        }
       });
       
       const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
       const bulkToolbar = document.getElementById("bulk-toolbar");
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       const bulkCount = document.getElementById("bulk-count");
       const bulkCountMobile = document.getElementById("bulk-count-mobile");
       
       if (total > 0) {
        if (bulkToolbar) bulkToolbar.style.display = "flex";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
        if (bulkCount) bulkCount.textContent = total;
        if (bulkCountMobile) bulkCountMobile.textContent = total;
       } else {
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
       }
      }
      
      function cloneNode(sourceId) {
       if (!NODE_DATA[sourceId]) return;
       
       pushUndo("clone node");
       const source = NODE_DATA[sourceId];
       const baseName = source.name + " copy";
       let newName = baseName;
       let counter = 1;
       while (Object.values(NODE_DATA).some(n => n.name === newName)) {
        newName = `${baseName} ${counter}`;
        counter++;
       }
       
       const baseId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
       let newId = baseId;
       counter = 1;
       while (NODE_DATA[newId]) {
        newId = `${baseId}-${counter}`;
        counter++;
       }
       
       NODE_DATA[newId] = {
        shape: source.shape,
        name: newName,
        ip: source.ip,
        role: source.role,
        tags: [...source.tags],
        notes: [...source.notes],
        mac: source.mac || "",
        rackUnit: source.rackUnit || "",
        uHeight: source.uHeight || "1",
        layer: source.layer || "physical",
        assignedRack: source.assignedRack || "",
        rackCapacity: source.rackCapacity || "42",
        isRack: source.isRack || false
       }; 
	   
       if (source.isRack) {
        const childNodes = Object.entries(NODE_DATA).filter(([id, n]) => 
         id !== newId && n.assignedRack === sourceId
        );
        childNodes.forEach(([childId, childNode]) => {
         const childBaseName = childNode.name + " copy";
         let childNewName = childBaseName;
         let c = 1;
         while (Object.values(NODE_DATA).some(n => n.name === childNewName)) {
          childNewName = `${childBaseName} ${c}`;
          c++;
         }
         const childBaseId = childNewName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
         let childNewId = childBaseId;
         c = 1;
         while (NODE_DATA[childNewId]) {
          childNewId = `${childBaseId}-${c}`;
          c++;
         }
         NODE_DATA[childNewId] = {
          ...JSON.parse(JSON.stringify(childNode)),
          name: childNewName,
          assignedRack: newId
         };
         if (savedPositions[childId]) {
          savedPositions[childNewId] = { ...savedPositions[childId] };
         }
         if (savedSizes[childId]) {
          savedSizes[childNewId] = savedSizes[childId];
         }
         if (savedStyles[childId]) {
          savedStyles[childNewId] = JSON.parse(JSON.stringify(savedStyles[childId]));
         }
        });
       }
       
       if (currentView.mode === "rack" && currentView.rackId) {
        NODE_DATA[newId].assignedRack = currentView.rackId;
       }
       
       const sourcePos = savedPositions[sourceId];
       savedPositions[newId] = {
        x: sourcePos.x + 100,
        y: sourcePos.y + 100
       };
       
       if (savedSizes[sourceId]) {
        savedSizes[newId] = savedSizes[sourceId];
       }
       
       if (savedStyles[sourceId]) {
        savedStyles[newId] = JSON.parse(JSON.stringify(savedStyles[sourceId]));
       }
       
       forgeTheTopology();
       claimTheImmortal(newId);
      }
      
      function alignSelectedNodes(direction) {
       if (selectedNodes.size < 2) return;
       
       pushUndo("align nodes");
       const nodes = Array.from(selectedNodes).map(id => ({
        id,
        pos: savedPositions[id]
       }));
       
       switch(direction) {
        case "left":
         const minX = Math.min(...nodes.map(n => n.pos.x));
         nodes.forEach(n => savedPositions[n.id].x = minX);
         break;
        case "right":
         const maxX = Math.max(...nodes.map(n => n.pos.x));
         nodes.forEach(n => savedPositions[n.id].x = maxX);
         break;
        case "top":
         const minY = Math.min(...nodes.map(n => n.pos.y));
         nodes.forEach(n => savedPositions[n.id].y = minY);
         break;
        case "bottom":
         const maxY = Math.max(...nodes.map(n => n.pos.y));
         nodes.forEach(n => savedPositions[n.id].y = maxY);
         break;
        case "center-h":
         const avgX = nodes.reduce((sum, n) => sum + n.pos.x, 0) / nodes.length;
         nodes.forEach(n => savedPositions[n.id].x = avgX);
         break;
        case "center-v":
         const avgY = nodes.reduce((sum, n) => sum + n.pos.y, 0) / nodes.length;
         nodes.forEach(n => savedPositions[n.id].y = avgY);
         break;
       }
       
       forgeTheTopology();
      }
      
      function distributeSelectedNodes(direction) {
       if (selectedNodes.size < 3) return;
       
       pushUndo("distribute nodes");
       const nodes = Array.from(selectedNodes).map(id => ({
        id,
        pos: savedPositions[id]
       }));
       
       if (direction === "horizontal") {
        nodes.sort((a, b) => a.pos.x - b.pos.x);
        const minX = nodes[0].pos.x;
        const maxX = nodes[nodes.length - 1].pos.x;
        const gap = (maxX - minX) / (nodes.length - 1);
        nodes.forEach((n, i) => {
         savedPositions[n.id].x = minX + (gap * i);
        });
       } else {
        nodes.sort((a, b) => a.pos.y - b.pos.y);
        const minY = nodes[0].pos.y;
        const maxY = nodes[nodes.length - 1].pos.y;
        const gap = (maxY - minY) / (nodes.length - 1);
        nodes.forEach((n, i) => {
         savedPositions[n.id].y = minY + (gap * i);
        });
       }
       
       forgeTheTopology();
      }
      
      function snapToGrid(nodeId, gridSize = 50) {
       if (!savedPositions[nodeId]) return;
       
       pushUndo("snap to grid");
       const pos = savedPositions[nodeId];
       pos.x = Math.round(pos.x / gridSize) * gridSize;
       pos.y = Math.round(pos.y / gridSize) * gridSize;
       forgeTheTopology();
      }
      
      function searchNodes(query) {
       if (!query) {
        clearSearchHighlight();
        return [];
       }
       
       query = query.toLowerCase();
       const results = [];
       
       Object.entries(NODE_DATA).forEach(([id, data]) => {
        if (data.name.toLowerCase().includes(query) ||
            data.ip.toLowerCase().includes(query) ||
            data.role.toLowerCase().includes(query) ||
            data.tags.some(tag => tag.toLowerCase().includes(query)) ||
            (data.mac && data.mac.toLowerCase().includes(query)) ||
            (data.rackUnit && data.rackUnit.toLowerCase().includes(query))) {
         results.push(id);
        }
       });
       
       highlightSearchResults(results);
       return results;
      }
      
      function highlightSearchResults(nodeIds) {
       document.querySelectorAll(".node-group").forEach(node => {
        const nodeId = node.dataset.nodeId;
        if (nodeIds.includes(nodeId)) {
         node.classList.add("search-highlight");
        } else {
         node.classList.remove("search-highlight");
        }
       });
      }
      
      function clearSearchHighlight() {
       document.querySelectorAll(".search-highlight").forEach(node => {
        node.classList.remove("search-highlight");
       });
      }
      
      function nudgeSelectedNodes(direction, distance) {
        const nodesToNudge = selectedNodes.size > 0 
          ? Array.from(selectedNodes) 
          : (currentNodeId ? [currentNodeId] : []);
        const rectsToNudge = selectedRects.size > 0 
          ? Array.from(selectedRects) 
          : (currentRectId ? [currentRectId] : []);
        const textsToNudge = selectedTexts.size > 0 
          ? Array.from(selectedTexts) 
          : (currentTextId ? [currentTextId] : []);
        
        if (nodesToNudge.length === 0 && rectsToNudge.length === 0 && textsToNudge.length === 0) return;
        
        const unlockedNodes = nodesToNudge.filter(id => !NODE_DATA[id]?.locked);
        const unlockedRects = rectsToNudge.filter(id => { const r = RECT_DATA.list.find(x => x.id === id); return r && !r.locked; });
        const unlockedTexts = textsToNudge.filter(id => { const t = TEXT_DATA.list.find(x => x.id === id); return t && !t.locked; });
        
        if (unlockedNodes.length === 0 && unlockedRects.length === 0 && unlockedTexts.length === 0) return;
        
        pushUndo("nudge");
        
        const dx = direction === "ArrowLeft" ? -distance : direction === "ArrowRight" ? distance : 0;
        const dy = direction === "ArrowUp" ? -distance : direction === "ArrowDown" ? distance : 0;
        
        unlockedNodes.forEach(id => {
          if (!savedPositions[id]) savedPositions[id] = { x: 0, y: 0 };
          savedPositions[id].x += dx;
          savedPositions[id].y += dy;
        });
        
        unlockedRects.forEach(id => {
          const r = RECT_DATA.list.find(x => x.id === id);
          if (r) { r.x += dx; r.y += dy; }
        });
        
        unlockedTexts.forEach(id => {
          const t = TEXT_DATA.list.find(x => x.id === id);
          if (t) { t.x += dx; t.y += dy; }
        });
        
        forgeTheTopology();
      }
      
      function cycleNodes(reverse = false) {
        const nodeIds = Object.keys(NODE_DATA).filter(id => {
          if (currentView.mode === "rack" && currentView.rackId) {
            return NODE_DATA[id].assignedRack === currentView.rackId;
          }
          return !NODE_DATA[id].assignedRack;
        });
        
        if (nodeIds.length === 0) return;
        
        let currentIndex = nodeIds.indexOf(currentNodeId);
        
        if (reverse) {
          currentIndex = currentIndex <= 0 ? nodeIds.length - 1 : currentIndex - 1;
        } else {
          currentIndex = currentIndex >= nodeIds.length - 1 ? 0 : currentIndex + 1;
        }
        
        const nextNodeId = nodeIds[currentIndex];
        claimTheImmortal(nextNodeId);
        
        selectedNodes.clear();
        updateNodeSelection();
      }
      
      function focusOnSelected() {
        let minX = Infinity, minY = Infinity;
        let maxX = -Infinity, maxY = -Infinity;
        let hasItems = false;

        const nodesToFocus = selectedNodes.size > 0 
          ? Array.from(selectedNodes) 
          : (currentNodeId ? [currentNodeId] : []);
        nodesToFocus.forEach(id => {
          const pos = savedPositions[id];
          if (pos) {
            hasItems = true;
            const size = savedSizes[id] || 50;
            minX = Math.min(minX, pos.x - size/2);
            minY = Math.min(minY, pos.y - size/2);
            maxX = Math.max(maxX, pos.x + size/2);
            maxY = Math.max(maxY, pos.y + size/2);
          }
        });
        
        const rectsToFocus = selectedRects.size > 0 ? Array.from(selectedRects) : (currentRectId ? [currentRectId] : []);
        rectsToFocus.forEach(id => {
          const r = RECT_DATA.list.find(x => x.id === id);
          if (r) {
            hasItems = true;
            minX = Math.min(minX, r.x);
            minY = Math.min(minY, r.y);
            maxX = Math.max(maxX, r.x + r.width);
            maxY = Math.max(maxY, r.y + r.height);
          }
        });
        
        const textsToFocus = selectedTexts.size > 0 ? Array.from(selectedTexts) : (currentTextId ? [currentTextId] : []);
        textsToFocus.forEach(id => {
          const t = TEXT_DATA.list.find(x => x.id === id);
          if (t) {
            hasItems = true;
            minX = Math.min(minX, t.x - 50);
            minY = Math.min(minY, t.y - 20);
            maxX = Math.max(maxX, t.x + 50);
            maxY = Math.max(maxY, t.y + 20);
          }
        });
        
        const edgesToFocus = selectedEdges.size > 0 ? Array.from(selectedEdges) : (currentEdgeId ? [currentEdgeId] : []);
        edgesToFocus.forEach(id => {
          const e = EDGE_DATA.list.find(x => x.id === id);
          if (e) {
            const fromPos = savedPositions[e.from];
            const toPos = savedPositions[e.to];
            if (fromPos && toPos) {
              hasItems = true;
              minX = Math.min(minX, fromPos.x, toPos.x);
              minY = Math.min(minY, fromPos.y, toPos.y);
              maxX = Math.max(maxX, fromPos.x, toPos.x);
              maxY = Math.max(maxY, fromPos.y, toPos.y);
            }
          }
        });
        
        if (!hasItems || !isFinite(minX)) return;
        
        const padding = 100;
        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;
        const width = maxX - minX + padding * 2;
        const height = maxY - minY + padding * 2;
        
        const zoomX = CANVAS_WIDTH / width;
        const zoomY = CANVAS_HEIGHT / height;
        const targetZoom = Math.min(zoomX, zoomY, 2); 
        
        canvasState.zoom = targetZoom;
        canvasState.panX = centerX - (CANVAS_WIDTH / targetZoom) / 2;
        canvasState.panY = centerY - (CANVAS_HEIGHT / targetZoom) / 2;
        
        forgeTheTopology();
      }
      
      function toggleLockSelected() {
        const nodesToToggle = selectedNodes.size > 0 
          ? Array.from(selectedNodes) 
          : (currentNodeId ? [currentNodeId] : []);
        const rectsToToggle = selectedRects.size > 0 
          ? Array.from(selectedRects) 
          : (currentRectId ? [currentRectId] : []);
        const textsToToggle = selectedTexts.size > 0 
          ? Array.from(selectedTexts) 
          : (currentTextId ? [currentTextId] : []);
        
        if (nodesToToggle.length === 0 && rectsToToggle.length === 0 && textsToToggle.length === 0) return;
        
        pushUndo("toggle lock");
        
        let hasUnlocked = nodesToToggle.some(id => !NODE_DATA[id]?.locked);
        hasUnlocked = hasUnlocked || rectsToToggle.some(id => { const r = RECT_DATA.list.find(x => x.id === id); return r && !r.locked; });
        hasUnlocked = hasUnlocked || textsToToggle.some(id => { const t = TEXT_DATA.list.find(x => x.id === id); return t && !t.locked; });
        
        nodesToToggle.forEach(id => {
          if (NODE_DATA[id]) NODE_DATA[id].locked = hasUnlocked;
        });
        rectsToToggle.forEach(id => {
          const r = RECT_DATA.list.find(x => x.id === id);
          if (r) r.locked = hasUnlocked;
        });
        textsToToggle.forEach(id => {
          const t = TEXT_DATA.list.find(x => x.id === id);
          if (t) t.locked = hasUnlocked;
        });
        
        forgeTheTopology();
      }
      
      function toggleGroupSelected() {
      const nodesToGroup = Array.from(selectedNodes);
      const rectsToGroup = Array.from(selectedRects);
      const textsToGroup = Array.from(selectedTexts);
      const edgesToGroup = Array.from(selectedEdges);
      const totalItems = nodesToGroup.length + rectsToGroup.length + textsToGroup.length + edgesToGroup.length;
      if (totalItems < 2) return;
      
      pushUndo("toggle group");
      
      const allGroupIds = [];
      nodesToGroup.forEach(id => { if (NODE_DATA[id]?.groupId) allGroupIds.push(NODE_DATA[id].groupId); });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r?.groupId) allGroupIds.push(r.groupId); });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t?.groupId) allGroupIds.push(t.groupId); });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e?.groupId) allGroupIds.push(e.groupId); });
      const uniqueGroups = [...new Set(allGroupIds)];
      
      if (uniqueGroups.length === 1 && allGroupIds.length === totalItems) {
      nodesToGroup.forEach(id => { if (NODE_DATA[id]) NODE_DATA[id].groupId = null; });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r) r.groupId = null; });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t) t.groupId = null; });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e) e.groupId = null; });
      } else {
      const newGroupId = "group-" + Date.now();
      nodesToGroup.forEach(id => { if (NODE_DATA[id]) NODE_DATA[id].groupId = newGroupId; });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r) r.groupId = newGroupId; });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t) t.groupId = newGroupId; });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e) e.groupId = newGroupId; });
      }
      
      forgeTheTopology();
      }
      
      function handleKeyDown(event) {
       if (event.target.tagName === "INPUT" || event.target.tagName === "TEXTAREA" || event.target.isContentEditable) {
        return;
       }
       
       if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(event.key)) {
        event.preventDefault();
        const distance = event.shiftKey ? 10 : 1;
        nudgeSelectedNodes(event.key, distance);
       }
       
       if (event.key === "Tab") {
        event.preventDefault();
        cycleNodes(event.shiftKey);
       }
       
       if (event.key === "f" || event.key === "F") {
        event.preventDefault();
        focusOnSelected();
       }
       
       if (event.key === "l" || event.key === "L") {
        event.preventDefault();
        toggleLockSelected();
       }
       
       if (event.key === "g" || event.key === "G") {
        event.preventDefault();
        toggleGroupSelected();
       }
       
       if (event.ctrlKey && event.key === "z") {
        event.preventDefault();
        undo();
       }
       
       if ((event.ctrlKey && event.key === "y") || (event.ctrlKey && event.shiftKey && event.key === "z")) {
        event.preventDefault();
        redo();
       }
       
 if (event.ctrlKey && event.key === "c") {
        event.preventDefault();
        clipboard = null;
        if (currentNodeId && NODE_DATA[currentNodeId]) {
         clipboard = {
          type: "node",
          data: JSON.parse(JSON.stringify(NODE_DATA[currentNodeId])),
          size: savedSizes[currentNodeId],
          style: savedStyles[currentNodeId] ? JSON.parse(JSON.stringify(savedStyles[currentNodeId])) : null
         };
        } else if (currentEdgeId) {
         const edge = EDGE_DATA.list.find(e => e.id === currentEdgeId);
         if (edge) clipboard = { type: "edge", data: JSON.parse(JSON.stringify(edge)) };
        } else if (currentRectId) {
         const rect = RECT_DATA.list.find(r => r.id === currentRectId);
         if (rect) clipboard = { type: "rect", data: JSON.parse(JSON.stringify(rect)) };
        } else if (currentTextId) {
         const text = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (text) clipboard = { type: "text", data: JSON.parse(JSON.stringify(text)) };
        }
       }
       
       if (event.ctrlKey && event.key === "v") {
        event.preventDefault();
        if (!clipboard) return;
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        const centerX = canvasState.panX + (viewWidth / 2);
        const centerY = canvasState.panY + (viewHeight / 2);
        
        if (clipboard.type === "node") {
         const data = clipboard.data;
         let newName = data.name + " copy";
         let counter = 1;
         while (Object.values(NODE_DATA).some(n => n.name === newName)) {
          newName = data.name + " copy " + counter;
          counter++;
         }
         let newId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
         counter = 1;
         while (NODE_DATA[newId]) {
          newId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-") + "-" + counter;
          counter++;
         }
         pushUndo("paste node");
         NODE_DATA[newId] = { ...data, name: newName };
         savedPositions[newId] = { x: centerX, y: centerY };
         if (clipboard.size) savedSizes[newId] = clipboard.size;
         if (clipboard.style) savedStyles[newId] = JSON.parse(JSON.stringify(clipboard.style));
         forgeTheTopology();
         claimTheImmortal(newId);
        } else if (clipboard.type === "edge") {
         pushUndo("paste edge");
         const newEdge = { ...clipboard.data, id: "edge-" + Date.now() };
         EDGE_DATA.list.push(newEdge);
         
         forgeTheTopology();
         selectTheConnection(newEdge.id);
        } else if (clipboard.type === "rect") {
         pushUndo("paste rect");
         const newRect = { ...clipboard.data, id: "rect-" + Date.now(), x: centerX - (clipboard.data.width || 100) / 2, y: centerY - (clipboard.data.height || 100) / 2 };
         RECT_DATA.list.push(newRect);
         forgeTheTopology();
         selectTheRect(newRect.id);
        } else if (clipboard.type === "text") {
         pushUndo("paste text");
         const newText = { ...clipboard.data, id: "text-" + Date.now(), x: centerX, y: centerY };
         TEXT_DATA.list.push(newText);
         forgeTheTopology();
         showTextPanel(newText.id);
        }
       }
       
       if (event.key === "Delete") {
        event.preventDefault();
        const totalSelected = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
        if (totalSelected > 0) {
         deleteSelected();
        } else if (currentNodeId && NODE_DATA[currentNodeId]) {
         challengeTheImmortal(`Delete node "${NODE_DATA[currentNodeId].name}"?`, () => {
          pushUndo("delete node");
          delete NODE_DATA[currentNodeId];
          delete savedPositions[currentNodeId];
          delete savedSizes[currentNodeId];
          delete savedStyles[currentNodeId];
          EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== currentNodeId && e.to !== currentNodeId);
          currentNodeId = null;
          
          forgeTheTopology();
          document.getElementById("node-panel").style.display = "none";
         });
        } else if (currentEdgeId) {
         challengeTheImmortal("Delete this line?", () => {
          pushUndo("delete edge");
          EDGE_DATA.list = EDGE_DATA.list.filter(e => e.id !== currentEdgeId);
          currentEdgeId = null;
          
          forgeTheTopology();
          document.getElementById("edge-panel").style.display = "none";
         });
        } else if (currentRectId) {
         challengeTheImmortal("Delete this zone?", () => {
          pushUndo("delete rect");
          RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== currentRectId);
          currentRectId = null;
          forgeTheTopology();
          document.getElementById("rect-panel").style.display = "none";
         });
        } else if (currentTextId) {
         const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (textItem) {
          challengeTheImmortal(`Delete text "${textItem.content.substring(0, 30)}..."?`, () => {
           pushUndo("delete text");
           TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== currentTextId);
           currentTextId = null;
           forgeTheTopology();
           document.getElementById("text-panel").style.display = "none";
          });
         }
        }
       }
      
       if (event.ctrlKey && event.key === "a") {
        event.preventDefault();
        Object.keys(NODE_DATA).forEach(id => selectedNodes.add(id));
        EDGE_DATA.list.forEach(e => selectedEdges.add(e.id));
        RECT_DATA.list.forEach(r => selectedRects.add(r.id));
        TEXT_DATA.list.forEach(t => selectedTexts.add(t.id));
        updateNodeSelection();
       }
       
       if (event.key === "Escape") {
        clearSelection();
        clearSearchHighlight();
       }
      
       if (event.ctrlKey && event.key === "d") {
        event.preventDefault();
        if (currentNodeId && NODE_DATA[currentNodeId]) {
         cloneNode(currentNodeId);
        } else if (currentEdgeId) {
         const edge = EDGE_DATA.list.find(e => e.id === currentEdgeId);
         if (edge) {
          pushUndo("clone edge");
          const newEdge = { ...JSON.parse(JSON.stringify(edge)), id: "edge-" + Date.now() };
          EDGE_DATA.list.push(newEdge);
          
          forgeTheTopology();
          selectTheConnection(newEdge.id);
         }
        } else if (currentRectId) {
         const rect = RECT_DATA.list.find(r => r.id === currentRectId);
         if (rect) {
          pushUndo("clone rect");
          const newRect = { ...JSON.parse(JSON.stringify(rect)), id: "rect-" + Date.now(), x: rect.x + 50, y: rect.y + 50 };
          RECT_DATA.list.push(newRect);
          forgeTheTopology();
          selectTheRect(newRect.id);
         }
        } else if (currentTextId) {
         const text = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (text) {
          pushUndo("clone text");
          const newText = { ...JSON.parse(JSON.stringify(text)), id: "text-" + Date.now(), x: text.x + 50, y: text.y + 50 };
          TEXT_DATA.list.push(newText);
          forgeTheTopology();
          showTextPanel(newText.id);
         }
        }
       }
      }
      
      function saveRollbackVersion(description = "Auto-save") {
        const version = {
          timestamp: Date.now(),
          description,
          data: captureTheQuickening()
        };
        
        try {
          const stored = localStorage.getItem(ROLLBACK_STORAGE_KEY);
          rollbackVersions = stored ? JSON.parse(stored) : [];
        } catch (e) {
          rollbackVersions = [];
        }
        
        rollbackVersions.unshift(version);
        
        if (rollbackVersions.length > MAX_ROLLBACK_VERSIONS) {
          rollbackVersions = rollbackVersions.slice(0, MAX_ROLLBACK_VERSIONS);
        }
        
        try {
          localStorage.setItem(ROLLBACK_STORAGE_KEY, JSON.stringify(rollbackVersions));
        } catch (e) {
          console.warn("Failed to save rollback version:", e);
        }
      }
      
      function loadRollbackVersions() {
        try {
          const stored = localStorage.getItem(ROLLBACK_STORAGE_KEY);
          rollbackVersions = stored ? JSON.parse(stored) : [];
          displayRollbackVersions();
        } catch (e) {
          console.warn("Failed to load rollback versions:", e);
          rollbackVersions = [];
        }
      }
      
      function displayRollbackVersions() {
        const listEl = document.getElementById("rollback-list");
        if (!listEl) return;
        
        if (rollbackVersions.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No version history yet. Versions are saved automatically when you save the file.</div>';
          return;
        }
        
        listEl.innerHTML = rollbackVersions.map((version, index) => {
          const date = new Date(version.timestamp);
          const timeStr = date.toLocaleString();
          const nodeCount = Object.keys(version.data.nodeData || {}).length;
          const edgeCount = (version.data.edgeData?.list || []).length;
          
          return `
            <div class="version-item" onclick="restoreRollbackVersion(${index})">
              <div class="version-info">
                <div class="timestamp">${timeStr}</div>
                <div class="details">${version.description} • ${nodeCount} nodes • ${edgeCount} connections</div>
              </div>
              <div class="version-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteRollbackVersion(${index})" title="Delete this version">🗑️</button>
              </div>
            </div>
          `;
        }).join('');
      }
      
      function restoreRollbackVersion(index) {
        if (!confirm(`Restore version from ${new Date(rollbackVersions[index].timestamp).toLocaleString()}?\n\nYour current work will be lost unless you save first.`)) {
          return;
        }
        
        const version = rollbackVersions[index];
        const data = version.data;
        
        NODE_DATA = data.nodeData || {};
        EDGE_DATA = data.edgeData || { list: [] };
        RECT_DATA = data.rectData || { list: [] };
        TEXT_DATA = data.textData || { list: [] };
        EDGE_LEGEND = data.edgeLegend || {};
        savedPositions = data.nodePositions || {};
        savedSizes = data.nodeSizes || {};
        savedStyles = data.nodeStyles || {};
        PAGE_STATE = data.page || PAGE_STATE;
        
        if (data.canvas) {
          canvasState.zoom = data.canvas.zoom;
          canvasState.panX = data.canvas.panX;
          canvasState.panY = data.canvas.panY;
        }
        
        wieldThePower();
        forgeTheTopology();
        
        document.getElementById("rollback-modal").classList.remove("active");
        
        logAuditEvent("rollback", `Restored version from ${new Date(version.timestamp).toLocaleString()}`);
      }
      
      function deleteRollbackVersion(index) {
        if (!confirm("Delete this version from history?")) return;
        
        rollbackVersions.splice(index, 1);
        try {
          localStorage.setItem(ROLLBACK_STORAGE_KEY, JSON.stringify(rollbackVersions));
        } catch (e) {
          console.warn("Failed to delete version:", e);
        }
        displayRollbackVersions();
      }
      
      function clearRollbackHistory() {
        if (!confirm("Clear all version history?\n\nThis cannot be undone.")) return;
        
        rollbackVersions = [];
        localStorage.removeItem(ROLLBACK_STORAGE_KEY);
        displayRollbackVersions();
      }
      
      function createManualSnapshot() {
        const description = prompt("Enter a description for this snapshot:", "Manual snapshot");
        if (!description) return;
        
        saveRollbackVersion(description);
        displayRollbackVersions();
      }
      
      function switchTab(index) {
        if (index === currentTabIndex) return;
        
        const currentTab = documentTabs[currentTabIndex];
        currentTab.nodes = JSON.parse(JSON.stringify(NODE_DATA));
        currentTab.edges = JSON.parse(JSON.stringify(EDGE_DATA));
        currentTab.positions = JSON.parse(JSON.stringify(savedPositions));
        currentTab.sizes = JSON.parse(JSON.stringify(savedSizes));
        currentTab.styles = JSON.parse(JSON.stringify(savedStyles));
        currentTab.legend = JSON.parse(JSON.stringify(EDGE_LEGEND));
        currentTab.rects = JSON.parse(JSON.stringify(RECT_DATA));
        currentTab.texts = JSON.parse(JSON.stringify(TEXT_DATA));
        currentTab.pageState = JSON.parse(JSON.stringify(PAGE_STATE));
      
        currentTabIndex = index;
        const newTab = documentTabs[index];
        NODE_DATA = JSON.parse(JSON.stringify(newTab.nodes));
        EDGE_DATA = JSON.parse(JSON.stringify(newTab.edges));
        savedPositions = JSON.parse(JSON.stringify(newTab.positions));
        savedSizes = JSON.parse(JSON.stringify(newTab.sizes));
        savedStyles = JSON.parse(JSON.stringify(newTab.styles));
        EDGE_LEGEND = JSON.parse(JSON.stringify(newTab.legend));
        RECT_DATA = JSON.parse(JSON.stringify(newTab.rects));
        TEXT_DATA = JSON.parse(JSON.stringify(newTab.texts));
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, newTab.pageState || {});
        wieldThePower();
        document.title = PAGE_STATE.title || newTab.name;
        document.getElementById("page-title").textContent = PAGE_STATE.title || newTab.name;
        forgeTheTopology();
        currentNodeId = null;
        currentEdgeId = null;
        currentTextId = null;
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        displayTabs();
        
        logAuditEvent("tab", `Switched to tab: ${newTab.name}`);
      }
      
      function createNewTab() {
        const nameInput = document.getElementById("new-tab-name");
        const name = nameInput.value.trim();
        
        if (!name) {
          alert("Please enter a tab name");
          return;
        }
        
        const newTab = {
          id: `tab-${Date.now()}`,
          name,
          nodes: {},
          edges: { list: [] },
          positions: {},
          sizes: {},
          styles: {},
          legend: {},
          rects: { list: [] },
          texts: { list: [] },
      pageState: null
        };
        
        documentTabs.push(newTab);
        nameInput.value = "";
        displayTabs();
        
        logAuditEvent("tab", `Created new tab: ${name}`);
      }
      
      function renameTab(index) {
        const tab = documentTabs[index];
        const newName = prompt("Enter new name:", tab.name);
        if (!newName || newName === tab.name) return;
        
        tab.name = newName;
        displayTabs();
        
        logAuditEvent("tab", `Renamed tab to: ${newName}`);
      }
      
      function deleteTab(index) {
        if (documentTabs.length === 1) {
          alert("Cannot delete the last tab");
          return;
        }
        
        if (!confirm(`Delete tab "${documentTabs[index].name}"?`)) return;
        
        documentTabs.splice(index, 1);
        
        if (currentTabIndex >= documentTabs.length) {
          currentTabIndex = documentTabs.length - 1;
        }
        
        if (currentTabIndex === index) {
          switchTab(currentTabIndex);
        }
        
        displayTabs();
      }
      
      function displayTabs() {
        const listEl = document.getElementById("tabs-list");
        if (!listEl) return;
        
        listEl.innerHTML = documentTabs.map((tab, index) => {
          const nodeCount = Object.keys(tab.nodes).length;
          const edgeCount = tab.edges.list.length;
          const isActive = index === currentTabIndex;
          
          return `
            <div class="tab-item ${isActive ? 'active' : ''}" onclick="switchTab(${index})">
              <div class="tab-name">${tab.name}</div>
              <div class="tab-stats">${nodeCount} nodes • ${edgeCount} connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(${index})" title="Rename tab">✏️</button>
                ${documentTabs.length > 1 ? '<button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(${index})" title="Delete tab">🗑️</button>' : ''}
              </div>
            </div>
          `;
        }).join('');
      }
      
      function logAuditEvent(type, description, details = {}) {
        const event = {
          timestamp: Date.now(),
          type,
          description,
          details,
          tab: documentTabs[currentTabIndex]?.name || "Main"
        };
        
        auditLog.unshift(event);
        
        if (auditLog.length > MAX_AUDIT_ENTRIES) {
          auditLog = auditLog.slice(0, MAX_AUDIT_ENTRIES);
        }
      
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to save audit log:", e);
        }
      }
      
      function loadAuditLog() {
        let embeddedLog = [];
        let localLog = [];
        try {
          const stateScript = document.getElementById("topology-state");
          if (stateScript) {
            const stateData = JSON.parse(stateScript.textContent);
            if (stateData.auditLog && Array.isArray(stateData.auditLog)) {
              embeddedLog = stateData.auditLog;
            }
          }
        } catch (e) {
          console.warn("Failed to load embedded audit log:", e);
        }
        try {
          const stored = localStorage.getItem(AUDIT_STORAGE_KEY);
          if (stored) {
            localLog = JSON.parse(stored);
          }
        } catch (e) {
          console.warn("Failed to load localStorage audit log:", e);
        }
        const merged = [...embeddedLog, ...localLog];
        const seen = new Set();
        auditLog = merged.filter(entry => {
          const key = entry.timestamp + entry.description;
          if (seen.has(key)) return false;
          seen.add(key);
          return true;
        }).sort((a, b) => b.timestamp - a.timestamp);
        if (auditLog.length > MAX_AUDIT_ENTRIES) {
          auditLog = auditLog.slice(0, MAX_AUDIT_ENTRIES);
        }
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to sync audit log:", e);
        }
      }
      
      function displayAuditLog(filter = "all") {
        const listEl = document.getElementById("audit-log-list");
        if (!listEl) return;
        
        const filtered = filter === "all" ? auditLog : auditLog.filter(e => e.type === filter);
        
        if (filtered.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No audit entries yet</div>';
          return;
        }
        
        listEl.innerHTML = filtered.map(event => {
          const date = new Date(event.timestamp);
          const timeStr = date.toLocaleString();
          
          return `
            <div class="audit-entry ${event.type}">
              <div class="time">[${timeStr}] ${event.tab}</div>
              <div class="action">[${event.type.toUpperCase()}] ${event.description}</div>
            </div>
          `;
        }).join('');
      }
      
      function clearAuditLog() {
        if (!confirm("Clear all audit log entries?\n\nThis cannot be undone.")) return;
        
        auditLog = [];
        localStorage.removeItem(AUDIT_STORAGE_KEY);
        displayAuditLog();
      }
      
      function exportAuditLog() {
        if (auditLog.length === 0) {
          alert("No audit entries to export");
          return;
        }
        
        const csv = [
          ["Timestamp", "Tab", "Type", "Description"],
          ...auditLog.map(e => [
            new Date(e.timestamp).toISOString(),
            e.tab,
            e.type,
            e.description
          ])
        ].map(row => row.map(cell => `"${cell}"`).join(",")).join("\n");
        
        const blob = new Blob([csv], { type: "text/csv" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `audit-log-${Date.now()}.csv`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }
      
      let currentSecretName = null;
      
      function createNewSecret() {
        const nameInput = document.getElementById("new-secret-name");
        const name = nameInput.value.trim();
        
        if (!name) {
          alert("Please enter a note name");
          return;
        }
        
        if (encryptedSections[name]) {
          alert("A note with this name already exists");
          return;
        }
        
        currentSecretName = name;
        encryptedSections[name] = { encrypted: false, data: "" };
        nameInput.value = "";
        
        document.getElementById("secret-editor-title").textContent = `New note: ${name}`;
        document.getElementById("secret-editor-content").value = "";
        document.getElementById("secrets-modal").classList.remove("active");
        document.getElementById("secret-editor-modal").classList.add("active");
        
        displaySecrets();
      }
      
      function editSecret(name) {
        currentSecretName = name;
        const section = encryptedSections[name];
        
        if (section.encrypted) {
          const password = prompt(`Enter password to decrypt "${name}":`);
          if (!password) return;
          
          try {
            decryptData(section.data, password).then(decrypted => {
              document.getElementById("secret-editor-title").textContent = `Edit note: ${name}`;
              document.getElementById("secret-editor-content").value = decrypted;
              document.getElementById("secrets-modal").classList.remove("active");
              document.getElementById("secret-editor-modal").classList.add("active");
            }).catch(e => {
              alert("Failed to decrypt. Wrong password?");
            });
          } catch (e) {
            alert("Failed to decrypt. Wrong password?");
          }
        } else {
          document.getElementById("secret-editor-title").textContent = `Edit note: ${name}`;
          document.getElementById("secret-editor-content").value = section.data;
          document.getElementById("secrets-modal").classList.remove("active");
          document.getElementById("secret-editor-modal").classList.add("active");
        }
      }
      
      async function saveSecret() {
        if (!currentSecretName) return;
        
        const content = document.getElementById("secret-editor-content").value;
        const autoEncrypt = document.getElementById("secret-auto-encrypt").checked;
        
        if (autoEncrypt) {
          const password = prompt(`Enter password to encrypt "${currentSecretName}":`);
          if (!password) return;
          
          const confirmPassword = prompt("Confirm password:");
          if (password !== confirmPassword) {
            alert("Passwords do not match");
            return;
          }
          
          try {
            const encrypted = await encryptData(content, password);
            encryptedSections[currentSecretName] = { encrypted: true, data: encrypted };
          } catch (e) {
            alert("Encryption failed: " + e.message);
            return;
          }
        } else {
          encryptedSections[currentSecretName] = { encrypted: false, data: content };
        }
        
        closeSecretEditor();
        displaySecrets();
        
        logAuditEvent("secret", `Saved note: ${currentSecretName}`);
      }
      
      function closeSecretEditor() {
        document.getElementById("secret-editor-modal").classList.remove("active");
        document.getElementById("secrets-modal").classList.add("active");
        currentSecretName = null;
      }
      
      function deleteSecret(name) {
        if (!confirm(`Delete note "${name}"?`)) return;
        
        delete encryptedSections[name];
        displaySecrets();
        
        logAuditEvent("secret", `Deleted note: ${name}`);
      }
      
      function displaySecrets() {
        const listEl = document.getElementById("secrets-list");
        if (!listEl) return;
        
        const secrets = Object.keys(encryptedSections);
        
        if (secrets.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No notes yet</div>';
          return;
        }
        
        listEl.innerHTML = secrets.map(name => {
          const section = encryptedSections[name];
          const status = section.encrypted ? "🔒 Encrypted" : "🔓 Plaintext";
          
          return `
            <div class="secret-item">
              <div class="secret-name">${name}</div>
              <div class="secret-status">${status}</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="editSecret('${name}')" title="Edit note">✏️</button>
                <button class="btn-cancel" onclick="deleteSecret('${name}')" title="Delete note">🗑️</button>
              </div>
            </div>
          `;
        }).join('');
      }
      
      let rafId = null;
      let lastRender = 0;
      const RENDER_THROTTLE = 16;
      
      function setupDragToCreate() {
        const addNodeBtn = document.getElementById("add-node-btn");
        const addRackBtn = document.getElementById("add-rack-btn");
        const canvas = document.getElementById("map");
        
        if (!addNodeBtn || !addRackBtn || !canvas) return;
        
        let dragType = null;
        
        [addNodeBtn, addRackBtn].forEach(btn => {
          btn.setAttribute("draggable", "true");
          
          btn.addEventListener("dragstart", e => {
            dragType = btn.id === "add-node-btn" ? "node" : "rack";
            e.dataTransfer.effectAllowed = "copy";
            e.dataTransfer.setData("text/plain", dragType);
          });
        });
        
        canvas.addEventListener("dragover", e => {
          if (dragType) {
            e.preventDefault();
            e.dataTransfer.dropEffect = "copy";
          }
        });
        
        canvas.addEventListener("drop", e => {
          if (!dragType) return;
          
          e.preventDefault();
          
          const rect = canvas.getBoundingClientRect();
          const x = (e.clientX - rect.left) / canvasState.zoom + canvasState.panX;
          const y = (e.clientY - rect.top) / canvasState.zoom + canvasState.panY;
          
          if (dragType === "node") {
            createNodeAtPosition(x, y);
          } else if (dragType === "rack") {
            createRackAtPosition(x, y);
          }
          
          dragType = null;
        });
      }
      
      function createNodeAtPosition(x, y) {
        const timestamp = Date.now();
        const newId = `host-${timestamp}`;
        
        NODE_DATA[newId] = {
          name: "New Node",
          ip: "0.0.0.0",
          shape: "server",
          role: "",
          tags: [],
          notes: "",
          layer: "physical",
          isRack: false
        };
        
        savedPositions[newId] = { x, y };
        savedSizes[newId] = 55;
        
        pushUndo("create node");
        forgeTheTopology();
        claimTheImmortal(newId);
        
        logAuditEvent("node", `Created node at (${Math.round(x)}, ${Math.round(y)})`);
      }
      
      function createRackAtPosition(x, y) {
        const timestamp = Date.now();
        const newId = `rack-${timestamp}`;
        
        NODE_DATA[newId] = {
          name: "New Rack",
          ip: "",
          shape: "server",
          role: "rack",
          tags: [],
          notes: "",
          layer: "physical",
          isRack: true,
          rackCapacity: 42
        };
        
        savedPositions[newId] = { x, y };
        savedSizes[newId] = 55;
        
        pushUndo("create rack");
        populateRackDropdown();
        forgeTheTopology();
        claimTheImmortal(newId);
        
        logAuditEvent("rack", `Created rack at (${Math.round(x)}, ${Math.round(y)})`);
      }
      
      document.addEventListener("keydown", handleKeyDown);
      
      document.getElementById("save-file-btn").addEventListener("click", becomeImmortal);
      const addNodeBtn = document.getElementById("add-node-btn");
      const addNodeModal = document.getElementById("add-node-modal");
      const addNodeCancel = document.getElementById("add-node-cancel");
      const addNodeSave = document.getElementById("add-node-save");
      
      const undoBtn = document.getElementById("undo-btn");
      const redoBtn = document.getElementById("redo-btn");
      if (undoBtn) undoBtn.addEventListener("click", undo);
      if (redoBtn) redoBtn.addEventListener("click", redo);
      
      const backToTopologyBtn = document.getElementById("back-to-topology-btn");
      if (backToTopologyBtn) {
       backToTopologyBtn.addEventListener("click", exitRack);
      }
      
      const canvasViewport = document.getElementById("canvas-viewport");
      if (canvasViewport) {
       canvasViewport.addEventListener("dblclick", (e) => {
        if (currentView.mode === "rack" && e.target.id === "map") {
         exitRack();
        }
       });
      }
      
      const layersBtn = document.getElementById("layers-btn");
      const layerModal = document.getElementById("layer-modal");
      const layerModalClose = document.getElementById("layer-modal-close");
      if (layersBtn && layerModal) {
       layersBtn.addEventListener("click", () => {
        layerModal.classList.add("active");
       });
      }
      if (layerModalClose && layerModal) {
       layerModalClose.addEventListener("click", () => {
        layerModal.classList.remove("active");
       });
      }
      if (layerModal) {
       layerModal.addEventListener("click", (e) => {
        if (e.target === layerModal) {
         layerModal.classList.remove("active");
        }
       });
      }
      
      ["physical", "logical", "security", "application"].forEach(layer => {
       const checkbox = document.getElementById(`layer-${layer}`);
       if (checkbox) {
        checkbox.addEventListener("change", applyLayerFilter);
       }
      });
            
      const tabsBtn = document.getElementById("tabs-btn");
      const tabsModal = document.getElementById("tabs-modal");
      const tabsModalClose = document.getElementById("tabs-modal-close");
      
      if (tabsBtn && tabsModal) {
        tabsBtn.addEventListener("click", () => {
          displayTabs();
          tabsModal.classList.add("active");
        });
      }
      
      if (tabsModalClose && tabsModal) {
        tabsModalClose.addEventListener("click", () => {
          tabsModal.classList.remove("active");
        });
      }
      
      if (tabsModal) {
        tabsModal.addEventListener("click", (e) => {
          if (e.target === tabsModal) {
            tabsModal.classList.remove("active");
          }
        });
      }
      
      const rollbackBtn = document.getElementById("rollback-btn");
      const rollbackModal = document.getElementById("rollback-modal");
      const rollbackModalClose = document.getElementById("rollback-modal-close");
      
      if (rollbackBtn && rollbackModal) {
        rollbackBtn.addEventListener("click", () => {
          loadRollbackVersions();
          rollbackModal.classList.add("active");
        });
      }
      
      if (rollbackModalClose && rollbackModal) {
        rollbackModalClose.addEventListener("click", () => {
          rollbackModal.classList.remove("active");
        });
      }
      
      if (rollbackModal) {
        rollbackModal.addEventListener("click", (e) => {
          if (e.target === rollbackModal) {
            rollbackModal.classList.remove("active");
          }
        });
      }
      
      const auditLogBtn = document.getElementById("audit-log-btn");
      const auditLogModal = document.getElementById("audit-log-modal");
      const auditLogModalClose = document.getElementById("audit-log-modal-close");
      const auditFilter = document.getElementById("audit-filter");
      
      if (auditLogBtn && auditLogModal) {
        auditLogBtn.addEventListener("click", () => {
          loadAuditLog();
          displayAuditLog();
          auditLogModal.classList.add("active");
        });
      }
      
      if (auditFilter) {
        auditFilter.addEventListener("change", (e) => {
          displayAuditLog(e.target.value);
        });
      }
      
      if (auditLogModalClose && auditLogModal) {
        auditLogModalClose.addEventListener("click", () => {
          auditLogModal.classList.remove("active");
        });
      }
      
      if (auditLogModal) {
        auditLogModal.addEventListener("click", (e) => {
          if (e.target === auditLogModal) {
            auditLogModal.classList.remove("active");
          }
        });
      }
      
      const secretsBtn = document.getElementById("secrets-btn");
      const secretsModal = document.getElementById("secrets-modal");
      const secretsModalClose = document.getElementById("secrets-modal-close");
      const secretEditorModal = document.getElementById("secret-editor-modal");
      
      if (secretsBtn && secretsModal) {
        secretsBtn.addEventListener("click", () => {
          displaySecrets();
          secretsModal.classList.add("active");
        });
      }
      
      if (secretsModalClose && secretsModal) {
        secretsModalClose.addEventListener("click", () => {
          secretsModal.classList.remove("active");
        });
      }
      
      if (secretsModal) {
        secretsModal.addEventListener("click", (e) => {
          if (e.target === secretsModal) {
            secretsModal.classList.remove("active");
          }
        });
      }
      
      if (secretEditorModal) {
        secretEditorModal.addEventListener("click", (e) => {
          if (e.target === secretEditorModal) {
            closeSecretEditor();
          }
        });
      }
      
      loadAuditLog();
      setupDragToCreate();
      
      ["physical", "logical", "security", "application"].forEach(layer => {
       const checkbox = document.getElementById(`layer-${layer}`);
       if (checkbox) {
        checkbox.addEventListener("change", applyLayerFilter);
       }
      });
      
      const layerSelect = document.getElementById("node-layer");
      if (layerSelect) {
       layerSelect.addEventListener("change", (e) => {
        if (currentNodeId) {
         pushUndo("change layer");
         NODE_DATA[currentNodeId].layer = e.target.value;
         forgeTheTopology();
        }
       });
      }
      
       const assignedRackSelect = document.getElementById("node-assigned-rack");
       if (assignedRackSelect) {
      assignedRackSelect.addEventListener("change", (e) => {
      if (currentNodeId) {
      pushUndo("change assigned rack");
      EDGE_DATA.list = EDGE_DATA.list.filter(edge => edge.from !== currentNodeId && edge.to !== currentNodeId);
      NODE_DATA[currentNodeId].assignedRack = e.target.value;
      forgeTheTopology();
      claimTheImmortal(currentNodeId);
      }
      });
       }
      
      const rackCapacitySelect = document.getElementById("node-rack-capacity");
      if (rackCapacitySelect) {
       rackCapacitySelect.addEventListener("change", (e) => {
        if (currentNodeId) {
         pushUndo("change rack capacity");
         NODE_DATA[currentNodeId].rackCapacity = e.target.value;
         forgeTheTopology();
        }
       });
      }
      
      const bulkToolbarClose = document.getElementById("bulk-toolbar-close");
      if (bulkToolbarClose) {
       bulkToolbarClose.addEventListener("click", clearSelection);
      }
      
      const bulkAlignLeft = document.getElementById("bulk-align-left");
      if (bulkAlignLeft) {
       bulkAlignLeft.addEventListener("click", () => alignSelectedNodes("left"));
      }
      
      const bulkAlignRight = document.getElementById("bulk-align-right");
      if (bulkAlignRight) {
       bulkAlignRight.addEventListener("click", () => alignSelectedNodes("right"));
      }
      
      const bulkAlignTop = document.getElementById("bulk-align-top");
      if (bulkAlignTop) {
       bulkAlignTop.addEventListener("click", () => alignSelectedNodes("top"));
      }
      
      const bulkAlignBottom = document.getElementById("bulk-align-bottom");
      if (bulkAlignBottom) {
       bulkAlignBottom.addEventListener("click", () => alignSelectedNodes("bottom"));
      }
      
      const bulkDistributeH = document.getElementById("bulk-distribute-h");
      if (bulkDistributeH) {
       bulkDistributeH.addEventListener("click", () => distributeSelectedNodes("horizontal"));
      }
      
      const bulkDistributeV = document.getElementById("bulk-distribute-v");
      if (bulkDistributeV) {
       bulkDistributeV.addEventListener("click", () => distributeSelectedNodes("vertical"));
      }
      
      const bulkClone = document.getElementById("bulk-clone");
      if (bulkClone) {
       bulkClone.addEventListener("click", () => {
        if (selectedNodes.size === 0) return;
        pushUndo("clone selected");
        const nodesToClone = Array.from(selectedNodes);
        selectedNodes.clear();
        nodesToClone.forEach(id => {
         cloneNode(id);
         selectedNodes.add(currentNodeId);
        });
        updateNodeSelection();
       });
      }
      
      const bulkDelete = document.getElementById("bulk-delete");
      if (bulkDelete) {
       bulkDelete.addEventListener("click", deleteSelected);
      }
      
      const bulkMobileBtn = document.getElementById("bulk-mobile-btn");
      const bulkActionsModal = document.getElementById("bulk-actions-modal");
      const bulkModalClose = document.getElementById("bulk-modal-close");
      
      if (bulkMobileBtn) {
       bulkMobileBtn.addEventListener("click", () => {
        if (bulkActionsModal) bulkActionsModal.style.display = "block";
       });
      }
      
      if (bulkModalClose) {
       bulkModalClose.addEventListener("click", () => {
        if (bulkActionsModal) bulkActionsModal.style.display = "none";
       });
      }
      
      const closeModalAfterAction = () => {
       if (bulkActionsModal) bulkActionsModal.style.display = "none";
      };
      
      const bulkAlignLeftMobile = document.getElementById("bulk-align-left-mobile");
      if (bulkAlignLeftMobile) {
       bulkAlignLeftMobile.addEventListener("click", () => {
        alignSelectedNodes("left");
        closeModalAfterAction();
       });
      }
      
      const bulkAlignRightMobile = document.getElementById("bulk-align-right-mobile");
      if (bulkAlignRightMobile) {
       bulkAlignRightMobile.addEventListener("click", () => {
        alignSelectedNodes("right");
        closeModalAfterAction();
       });
      }
      
      const bulkAlignTopMobile = document.getElementById("bulk-align-top-mobile");
      if (bulkAlignTopMobile) {
       bulkAlignTopMobile.addEventListener("click", () => {
        alignSelectedNodes("top");
        closeModalAfterAction();
       });
      }
      
      const bulkAlignBottomMobile = document.getElementById("bulk-align-bottom-mobile");
      if (bulkAlignBottomMobile) {
       bulkAlignBottomMobile.addEventListener("click", () => {
        alignSelectedNodes("bottom");
        closeModalAfterAction();
       });
      }
      
      const bulkDistributeHMobile = document.getElementById("bulk-distribute-h-mobile");
      if (bulkDistributeHMobile) {
       bulkDistributeHMobile.addEventListener("click", () => {
        distributeSelectedNodes("horizontal");
        closeModalAfterAction();
       });
      }
      
      const bulkDistributeVMobile = document.getElementById("bulk-distribute-v-mobile");
      if (bulkDistributeVMobile) {
       bulkDistributeVMobile.addEventListener("click", () => {
        distributeSelectedNodes("vertical");
        closeModalAfterAction();
       });
      }
      
      const bulkCloneMobile = document.getElementById("bulk-clone-mobile");
      if (bulkCloneMobile) {
       bulkCloneMobile.addEventListener("click", () => {
        if (selectedNodes.size === 0) return;
        pushUndo("clone selected");
        const nodesToClone = Array.from(selectedNodes);
        selectedNodes.clear();
        nodesToClone.forEach(id => {
         cloneNode(id);
         selectedNodes.add(currentNodeId);
        });
        updateNodeSelection();
        closeModalAfterAction();
       });
      }
      
      const bulkDeleteMobile = document.getElementById("bulk-delete-mobile");
      if (bulkDeleteMobile) {
       bulkDeleteMobile.addEventListener("click", () => {
        deleteSelected();
        closeModalAfterAction();
       });
      }
      
      const bulkLockMobile = document.getElementById("bulk-lock-mobile");
      if (bulkLockMobile) {
       bulkLockMobile.addEventListener("click", () => {
        toggleLockSelected();
        closeModalAfterAction();
       });
      }
      
      const bulkGroupMobile = document.getElementById("bulk-group-mobile");
      if (bulkGroupMobile) {
       bulkGroupMobile.addEventListener("click", () => {
        toggleGroupSelected();
        closeModalAfterAction();
       });
      }
      
      const bulkClearMobile = document.getElementById("bulk-clear-mobile");
      if (bulkClearMobile) {
       bulkClearMobile.addEventListener("click", () => {
        clearSelection();
        closeModalAfterAction();
       });
      }
      
      const searchInput = document.getElementById("search-nodes");
      if (searchInput) {
       searchInput.addEventListener("input", (e) => {
        searchNodes(e.target.value);
       });
      }
      
      addNodeBtn.addEventListener("click", () => {
	  if (isViewOnly()) return;
       document.getElementById("new-node-name").value = "";
       document.getElementById("new-node-ip").value = "";
       document.getElementById("new-node-tags").value = "";
       document.getElementById("new-node-shape").value = "circle";
       addNodeModal.classList.add("active");
       document.getElementById("new-node-name").focus();
      });
      
      const addRackBtn = document.getElementById("add-rack-btn");
      const addRackModal = document.getElementById("add-rack-modal");
      const addRackCancel = document.getElementById("add-rack-cancel");
      const addRackSave = document.getElementById("add-rack-save");
      
      if (addRackBtn && addRackModal) {
       addRackBtn.addEventListener("click", () => {
	   if (isViewOnly()) return;
        document.getElementById("new-rack-name").value = "";
        document.getElementById("new-rack-ip").value = "";
        document.getElementById("new-rack-tags").value = "";
        document.getElementById("new-rack-shape").value = "server";
        document.getElementById("new-rack-capacity").value = "42";
        addRackModal.classList.add("active");
        document.getElementById("new-rack-name").focus();
       });
      }
      
      if (addRackCancel && addRackModal) {
       addRackCancel.addEventListener("click", () => {
        addRackModal.classList.remove("active");
       });
      }
      
      if (addRackModal) {
       addRackModal.addEventListener("click", (e) => {
        if (e.target === addRackModal) {
         addRackModal.classList.remove("active");
        }
       });
      }
      
      if (addRackSave && addRackModal) {
       addRackSave.addEventListener("click", () => {
        const name = document.getElementById("new-rack-name").value.trim();
        const ip = document.getElementById("new-rack-ip").value.trim();
        const tagsStr = document.getElementById("new-rack-tags").value.trim();
        const shape = document.getElementById("new-rack-shape").value;
        const capacity = document.getElementById("new-rack-capacity").value;
        
        if (!name) {
         alert("Please enter a rack name.");
         return;
        }
        
        const tags = tagsStr ? tagsStr.split(",").map((t) => t.trim()).filter((t) => t) : [];
        let baseId = name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");
        if (!baseId) baseId = "rack";
        let nodeId = baseId;
        let counter = 1;
        while (NODE_DATA[nodeId]) {
         nodeId = baseId + "-" + counter;
         counter++;
        }
        
        pushUndo("add rack");
        
        NODE_DATA[nodeId] = {
         shape: shape,
         name: name,
         ip: ip || "",
         role: "Rack",
         tags: tags,
         notes: [],
         mac: "",
         rackUnit: "",
         uHeight: "1",
         layer: "physical",
         assignedRack: "",
         rackCapacity: capacity,
         isRack: true,  
         locked: false, 
         groupId: null 
        };
        
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        const centerX = canvasState.panX + (viewWidth / 2);
        const centerY = canvasState.panY + (viewHeight / 2);
        savedPositions[nodeId] = {
         x: centerX,
         y: centerY
        };
        
        addRackModal.classList.remove("active");
        forgeTheTopology();
        claimTheImmortal(nodeId);
       });
       
       ["new-rack-name", "new-rack-ip", "new-rack-tags"].forEach((inputId) => {
        const input = document.getElementById(inputId);
        if (input) {
         input.addEventListener("keypress", (e) => {
          if (e.key === "Enter") {
           addRackSave.click();
          }
         });
        }
       });
      }
      
      addNodeCancel.addEventListener("click", () => {
       addNodeModal.classList.remove("active");
      });
      addNodeModal.addEventListener("click", (e) => {
       if (e.target === addNodeModal) {
        addNodeModal.classList.remove("active");
       }
      });
      addNodeSave.addEventListener("click", () => {
       const name = document.getElementById("new-node-name").value.trim();
       const ip = document.getElementById("new-node-ip").value.trim();
       const tagsStr = document.getElementById("new-node-tags").value.trim();
       const shape = document.getElementById("new-node-shape").value;
       if (!name) {
        alert("Please enter a node name.");
        return;
       }
       const tags = tagsStr ? tagsStr.split(",").map((t) => t.trim()).filter((t) => t) : [];
       let baseId = name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");
       if (!baseId) baseId = "node";
       let nodeId = baseId;
       let counter = 1;
       while (NODE_DATA[nodeId]) {
        nodeId = baseId + "-" + counter;
        counter++;
       }
       NODE_DATA[nodeId] = {
        shape: shape || "circle",
        name: name,
        ip: ip || "0.0.0.0",
        role: "",
        tags: tags,
        notes: [],
        mac: "",
        rackUnit: "",
        uHeight: "1",
        layer: "physical",
        assignedRack: "",  
        rackCapacity: "42",
        isRack: false, 
        locked: false, 
        groupId: null 
       };
       
       if (currentView.mode === "rack" && currentView.rackId) {
        NODE_DATA[nodeId].assignedRack = currentView.rackId;
        NODE_DATA[nodeId].layer = "physical";
        const rackCapacity = getRackCapacity(currentView.rackId);
        const rackUHeight = getRackUHeight(currentView.rackId);
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        const centerY = canvasState.panY + (viewHeight / 2);
        let unit = rackCapacity - Math.round((centerY - RACK_START_Y) / rackUHeight);
        unit = Math.max(1, Math.min(rackCapacity, unit));
        NODE_DATA[nodeId].rackUnit = String(unit);
       }
       
      const viewWidth = CANVAS_WIDTH / canvasState.zoom;
      const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
      const centerX = canvasState.panX + (viewWidth / 2);
      const centerY = canvasState.panY + (viewHeight / 2);
      savedPositions[nodeId] = {
      x: centerX,
      y: centerY
      };
       pushUndo("add node");
       addNodeModal.classList.remove("active");
       forgeTheTopology();
       claimTheImmortal(nodeId);
      });
      ["new-node-name", "new-node-ip", "new-node-tags"].forEach(
       (inputId) => {
        document.getElementById(inputId).addEventListener("keypress", (e) => {
         if (e.key === "Enter") {
          addNodeSave.click();
         }
        });
       }, );
      const clearAllBtn = document.getElementById("clear-all-btn");
      const clearAllModal = document.getElementById("clear-all-modal");
      const clearAllCancel = document.getElementById("clear-all-cancel");
      const clearAllConfirm = document.getElementById("clear-all-confirm");
      clearAllBtn.addEventListener("click", () => {
       clearAllModal.classList.add("active");
      });
      clearAllCancel.addEventListener("click", () => {
       clearAllModal.classList.remove("active");
      });
      clearAllModal.addEventListener("click", (e) => {
       if (e.target === clearAllModal) {
        clearAllModal.classList.remove("active");
       }
      });
      clearAllConfirm.addEventListener("click", () => {
       NODE_DATA = {};
       EDGE_DATA = {
        list: []
       };
       EDGE_LEGEND = {};
       RECT_DATA = { list: [] };
       TEXT_DATA = { list: [] };
       savedPositions = {};
       savedSizes = {};
       savedStyles = {};
       logAuditEvent("clear", "Cleared all data from canvas");
       clearAllModal.classList.remove("active");
       forgeTheTopology();
       document.getElementById("node-panel").style.display = "none";
       document.getElementById("edge-panel").style.display = "none";
       document.getElementById("text-panel").style.display = "none";
       document.getElementById("topology-toolbar").style.display = "none";
       currentNodeId = null;
       currentEdgeId = null;
       currentTextId = null;
      });
      (function addDeleteNodeButton() {
       const nodePanel = document.getElementById("node-panel");
       if (!nodePanel) return;
       let deleteBtn = document.getElementById("delete-node-btn");
       if (!deleteBtn) {
        deleteBtn = document.createElement("button");
        deleteBtn.id = "delete-node-btn";
        deleteBtn.textContent = "Delete Node";
        deleteBtn.style.cssText = "margin-top:15px; padding:10px 16px; background:var(--danger); color:#fff; border:none; border-radius:6px; cursor:pointer; font-size:clamp(14px,1.6vw,18px); font-weight:600; width:100%;";
        nodePanel.appendChild(deleteBtn);
       }
       deleteBtn.addEventListener("click", () => {
        if (!currentNodeId) return;
        const nodeData = NODE_DATA[currentNodeId];
        let confirmMessage;
        let nodesInsideRack = [];
        
        if (nodeData?.isRack) {
         nodesInsideRack = Object.entries(NODE_DATA)
          .filter(([id, n]) => n.assignedRack === currentNodeId)
          .map(([id, n]) => n.name || id);
         if (nodesInsideRack.length > 0) {
          confirmMessage = `Delete rack "${nodeData.name}"?\n\nThis will also delete ${nodesInsideRack.length} node(s) inside:\n• ${nodesInsideRack.join('\n• ')}`;
         } else {
          confirmMessage = `Delete rack "${nodeData.name}"? (empty rack)`;
         }
        } else {
         confirmMessage = `Delete node "${nodeData?.name || currentNodeId}" and all its connections?`;
        }
        
        challengeTheImmortal(confirmMessage, () => {
         pushUndo("delete node");
         if (nodeData?.isRack) {
          Object.keys(NODE_DATA).forEach(id => {
           if (NODE_DATA[id]?.assignedRack === currentNodeId) {
            EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== id && e.to !== id);
            delete NODE_DATA[id];
            delete savedPositions[id];
            delete savedSizes[id];
            delete savedStyles[id];
           }
          });
         }
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== currentNodeId && e.to !== currentNodeId);
         delete NODE_DATA[currentNodeId];
         delete savedPositions[currentNodeId];
         delete savedSizes[currentNodeId];
         delete savedStyles[currentNodeId];
         currentNodeId = null;
         currentEdgeId = null;
         forgeTheTopology();
         const remainingNodes = Object.keys(NODE_DATA);
         if (remainingNodes.length > 0) {
          claimTheImmortal(remainingNodes[0]);
         } else {
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("topology-toolbar").style.display = "none";
         }
        });
       });
      })();
      
      function screenshotCanvas() {
       const svg = document.getElementById("map");
       const svgClone = svg.cloneNode(true);
       const viewBox = svg.getAttribute("viewBox").split(" ").map(Number);
       const [x, y, width, height] = viewBox;
       svgClone.setAttribute("width", width);
       svgClone.setAttribute("height", height);
       svgClone.setAttribute("viewBox", `${x} ${y} ${width} ${height}`);
       const wrapper = document.createElement("div");
       wrapper.style.position = "absolute";
       wrapper.style.left = "-9999px";
       wrapper.appendChild(svgClone);
       document.body.appendChild(wrapper);
      
       function inlineStyles(original, clone) {
        const elements = original.querySelectorAll("*");
        const clonedElements = clone.querySelectorAll("*");
        const rootStyles = getComputedStyle(document.documentElement);
        const bgColor = rootStyles.getPropertyValue("--bg").trim() || "#050608";
        const bgRect = document.createElementNS("http://www.w3.org/2000/svg", "rect", );
        bgRect.setAttribute("x", x);
        bgRect.setAttribute("y", y);
        bgRect.setAttribute("width", width);
        bgRect.setAttribute("height", height);
        bgRect.setAttribute("fill", bgColor);
        clone.insertBefore(bgRect, clone.firstChild);
        elements.forEach((el, index) => {
         const clonedEl = clonedElements[index];
         if (!clonedEl) return;
         const computedStyle = getComputedStyle(el);
         const svgProps = ["fill", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin", "opacity", "font-family", "font-size", "font-weight", "font-style", "text-anchor", "dominant-baseline", "marker-start", "marker-end", ];
         svgProps.forEach((prop) => {
          const value = computedStyle.getPropertyValue(prop);
          if (value && value !== "none" && value !== "normal") {
           clonedEl.style[prop] = value;
          }
         });
         clonedEl.removeAttribute("class");
        });
       }
       inlineStyles(svg, svgClone);
       const svgData = new XMLSerializer().serializeToString(svgClone);
       document.body.removeChild(wrapper);
       const svgBlob = new Blob([svgData], {
        type: "image/svg+xml;charset=utf-8",
       });
       const url = URL.createObjectURL(svgBlob);
       const img = new Image();
       img.onload = function() {
        const canvas = document.createElement("canvas");
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext("2d");
        ctx.drawImage(img, 0, 0);
        canvas.toBlob(function(blob) {
         const link = document.createElement("a");
         const timestamp = new Date().toISOString().slice(0, 10);
         link.download = `topology-${timestamp}.png`;
         link.href = URL.createObjectURL(blob);
         link.click();
         URL.revokeObjectURL(url);
         URL.revokeObjectURL(link.href);
        }, "image/png");
       };
       img.onerror = function() {
        console.error("Failed to load SVG image");
        alert("Screenshot failed. Please try again.");
        URL.revokeObjectURL(url);
       };
       img.src = url;
      }
      
      function exportCanvasSVG() {
       const svg = document.getElementById("map");
       const svgClone = svg.cloneNode(true);
       const viewBox = svg.getAttribute("viewBox").split(" ").map(Number);
       const [x, y, width, height] = viewBox;
       svgClone.setAttribute("width", width);
       svgClone.setAttribute("height", height);
       const rootStyles = getComputedStyle(document.documentElement);
       const bgColor = rootStyles.getPropertyValue("--bg").trim() || "#050608";
       const bgRect = document.createElementNS("http://www.w3.org/2000/svg", "rect", );
       bgRect.setAttribute("x", x);
       bgRect.setAttribute("y", y);
       bgRect.setAttribute("width", width);
       bgRect.setAttribute("height", height);
       bgRect.setAttribute("fill", bgColor);
       svgClone.insertBefore(bgRect, svgClone.firstChild);
       const wrapper = document.createElement("div");
       wrapper.style.position = "absolute";
       wrapper.style.left = "-9999px";
       wrapper.appendChild(svgClone);
       document.body.appendChild(wrapper);
       const elements = svg.querySelectorAll("*");
       const clonedElements = svgClone.querySelectorAll("*");
       elements.forEach((el, index) => {
        const clonedEl = clonedElements[index];
        if (!clonedEl) return;
        const computedStyle = getComputedStyle(el);
        const svgProps = ["fill", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin", "opacity", "font-family", "font-size", "font-weight", "font-style", "text-anchor", "dominant-baseline", "marker-start", "marker-end", ];
        svgProps.forEach((prop) => {
         const value = computedStyle.getPropertyValue(prop);
         if (value && value !== "none" && value !== "normal") {
          clonedEl.setAttribute(prop, value);
         }
        });
        clonedEl.removeAttribute("class");
       });
       const svgData = new XMLSerializer().serializeToString(svgClone);
       document.body.removeChild(wrapper);
       const blob = new Blob([svgData], {
        type: "image/svg+xml;charset=utf-8",
       });
       const url = URL.createObjectURL(blob);
       const link = document.createElement("a");
       const timestamp = new Date().toISOString().slice(0, 10);
       link.download = `topology-${timestamp}.svg`;
       link.href = url;
       link.click();
       URL.revokeObjectURL(url);
      }
      let resizeTimeout;
       window.addEventListener('resize', () => {
       clearTimeout(resizeTimeout);
       resizeTimeout = setTimeout(() => {
       updateDrawToolbarVisibility();
       updateTopologyToolbarVisibility();
       }, 100);
      });
    </script>
  
</body></html>