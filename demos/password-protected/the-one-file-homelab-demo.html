<!DOCTYPE html> 
 <html lang="en" style="--panel: #2f0e0e; --panel-alt: #10141b; --sidebar-bg: #10141b; --btn-bg: #0b0e13; --accent: #a75252; --danger: #f56565; --text-main: #e2e8f0; --text-soft: #94a3b8; --topbar-bg: rgba(9, 12, 20, 0.9); --topbar-border: #1f2533; --topbar-height: 112px; --sidebar-width: 350px; --mobile-footer-height: 40vh; --draw-toolbar-height: 0px; --btn-text: #e2e8f0; --tag-fill: #1e293b; --tag-text: #e2e8f0; --tag-border: #475569; --input-bg: #0b0e13; --input-text: #e2e8f0; --input-border: #1f2937; --input-font: Inter, system-ui, sans-serif; --input-font-size: 14px; --toolbar-bg: #441215; --toolbar-border: #1f2937; --toolbar-text: #94a3b8; --toolbar-btn-bg: #0b0e13; --toolbar-btn-text: #e2e8f0; --minimap-dots: #94a3b8; --canvas-hint-bg: #0f172a; --canvas-hint-color: #94a3b8; --node-fill: #1e293b; --node-stroke: #475569; --node-title: #e2e8f0; --node-sub: #94a3b8; --node-title-size: 18px; --node-sub-size: 13px; --node-font: Inter, system-ui, sans-serif; --default-edge: #475569; --selection-handle: #f59e0b; --selection-handle-size: 8px; --group-indicator: #4fd1c5;"><head>
    <meta charset="UTF-8">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>The One File</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- 
      * ====================================================================================
      * THE ONE FILE
      * "There can be only one". A all in one file topology maker for enterprise or homelab
      * 
      * This is your last backup when all others fail. A completely self-contained
      * network topology visualization tool that works as a single HTML file.
      * Open it anywhere, anytime and the idea lives forever.
      * ====================================================================================
      -->
    <style>
      :root {
      color-scheme: dark;
      --bg: #050608;
      --panel: #0b0e13;
      --panel-alt: #10141b;
      --accent: #4fd1c5;
      --danger: #f56565;
      --text-main: #e2e8f0;
      --text-soft: #94a3b8;
      --edge-main: #475569;
      --node-min: 35px;
      --node-max: 70px;
      --topbar-bg: rgba(9, 12, 20, 0.9);
      --topbar-border: #1f2533;
      }
	  html, body, svg, .map-container {
      touch-action: none;
      }
      * {
      box-sizing: border-box;
      user-select: none;
      }
      input,
      textarea,
      [contenteditable="true"] {
      user-select: text;
      -webkit-user-select: text;
      }
      body {
      margin: 0;
      font-family: system-ui, sans-serif;
      background: radial-gradient(circle at top, #1e2532 0, #050608 70%);
      color: var(--text-main);
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
      }
      header {
      padding: 0 20px;
      height: var(--topbar-height, 52px);
      min-height: var(--topbar-height, 52px);
      background: var(--topbar-bg);
      backdrop-filter: blur(6px);
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid var(--topbar-border);
      gap: 16px;
      }
      .title-block {
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-width: 0;
      }
      header h1 {
      font-size: clamp(22px, 3vw, 32px);
      margin: 0;
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
      }
      .editable-page-title {
      cursor: pointer;
      transition: opacity 0.2s;
      }
      .editable-page-title:hover {
      opacity: 0.7;
      }
      .save-row {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      }
      .save-btn {
      padding: 6px 12px;
      background: var(--accent);
      color: var(--bg);
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      white-space: nowrap;
      }
      .save-btn:hover {
      opacity: 0.9;
      }
      .help-icon {
      width: 22px;
      height: 22px;
      border-radius: 50%;
      border: 1px solid var(--edge-main);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      cursor: pointer;
      color: var(--text-soft);
      background: rgba(15, 23, 42, 0.9);
      flex-shrink: 0;
      }
      .help-icon:hover {
      color: var(--accent);
      border-color: var(--accent);
      }
      #settings-btn {
      background: var(--btn-bg, var(--panel));
      color: var(--btn-text, var(--text-main));
      border: 1px solid var(--edge-main);
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 16px;
      flex-shrink: 0;
      }
      #settings-btn:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .header-resizer {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 6px;
      background: transparent;
      cursor: row-resize;
      z-index: 1000;
      transition: background 0.2s;
      }
      .header-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .header-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      .sidebar-resizer {
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 6px;
      background: transparent;
      cursor: col-resize;
      z-index: 1000;
      transition: background 0.2s;
      }
      .sidebar-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .sidebar-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      .mobile-footer-resizer {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 6px;
      background: transparent;
      cursor: row-resize;
      z-index: 1000;
      transition: background 0.2s;
      display: none;
      }
      .mobile-footer-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .mobile-footer-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      @media (max-width: 900px) {
      .mobile-footer-resizer {
      display: block;
      height: 12px;
      }
      .sidebar-resizer {
      display: none;
      }
      .header-resizer {
      height: 12px;
      }
      }
      @media (pointer: coarse) {
      .header-resizer {
      height: 16px;
      }
      .mobile-footer-resizer {
      height: 16px;
      }
      .sidebar-resizer {
      width: 16px;
      }
      }
      .resizer-icon {
      position: absolute;
      opacity: 0.5;
      transition: opacity 0.2s, transform 0.2s;
      pointer-events: none;
      fill: var(--accent);
      }
      .header-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .sidebar-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .mobile-footer-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .header-resizer:hover .resizer-icon,
      .sidebar-resizer:hover .resizer-icon,
      .mobile-footer-resizer:hover .resizer-icon {
      opacity: 1;
      }
      .header-resizer.resizing .resizer-icon,
      .sidebar-resizer.resizing .resizer-icon,
      .mobile-footer-resizer.resizing .resizer-icon {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1.2);
      }
      body.resizing {
      user-select: none;
      }
      body.resizing * {
      cursor: inherit !important;
      pointer-events: none;
      }
      header {
      position: relative;
      }
      .details-panel {
      position: relative;
      }
      main {
      display: grid;
      grid-template-columns: 1fr var(--sidebar-width, 350px);
      flex: 1;
      }
      main.sidebar-collapsed {
      grid-template-columns: 1fr 0;
      }
      @media (max-width: 900px) {
      main {
      grid-template-columns: 1fr;
      grid-template-rows: calc(100vh - var(--topbar-height, 52px) - var(--mobile-footer-height, 40vh)) var(--mobile-footer-height, 40vh);
      }
      main.sidebar-collapsed {
      grid-template-rows: 1fr 0;
      }
      .details-panel {
      max-height: var(--mobile-footer-height, 40vh);
      height: 100%;
      }
      }
      .topology-panel {
      background: var(--panel);
      border-right: 1px solid #111827;
      position: relative;
      overflow: hidden;
      }
      .topology-toolbar {
      position: absolute;
      top: 10px;
      right: 10px;
      display: none;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      z-index: 99;
      font-size: 13px;
      color: var(--toolbar-text, #94a3b8);
      }
      .topology-toolbar label {
      color: var(--toolbar-text, var(--text-soft));
      }
      .topology-toolbar select {
      padding: 4px 6px;
      background: var(--toolbar-btn-bg, var(--panel));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 13px;
      cursor: pointer;
      }
      .topology-toolbar button {
      padding: 4px 10px;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      }
      .topology-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .bulk-toolbar-desktop,
      .bulk-toolbar-mobile {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 9999;
      }
      .bulk-toolbar-desktop {
      position: absolute;
      top: 10px;
      right: 10px;
      bottom: auto;
      left: auto;
      transform: none;
      }
      @media (min-width: 768px) {
      .bulk-toolbar-mobile {
      display: none !important;
      }
      }	  
      .bulk-action-btn {
      padding: 16px;
      background: var(--panel-main);
      border: 1px solid var(--edge-main);
      border-radius: 8px;
      color: var(--text-main);
      font-size: 24px;
      cursor: pointer;
      text-align: center;
      line-height: 1.2;
      }
      .bulk-action-btn:active {
      transform: scale(0.95);
      background: var(--accent);
      }
      .draw-toolbar {
      position: absolute;
      top: 10px;
      left: 10px;
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 8px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      z-index: 99;
      font-size: 13px;
      pointer-events: auto;
      color: var(--toolbar-text, #94a3b8);
      }
      .draw-toolbar button {
      padding: 4px 8px;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      }
      .draw-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .draw-toolbar input[type="color"] {
      width: 30px;
      height: 22px;
      border-radius: 4px;
      border: 1px solid var(--edge-main);
      padding: 0;
      background: transparent;
      cursor: pointer;
      }
      .draw-toolbar select {
      padding: 4px 6px;
      background: var(--toolbar-btn-bg, var(--panel));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 13px;
      cursor: pointer;
      }
      .legend-container {
      position: absolute;
      left: 10px;
      bottom: 10px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      padding: 8px 10px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      font-size: 12px;
      z-index: 20;
      max-width: 260px;
      pointer-events: auto;
      color: var(--toolbar-text, #94a3b8);
      }
      .legend-container {
      padding-right: 22px;
      }
      @media (max-width: 900px) {
      .legend-container {
      height:250px;
      overflow-y: auto;
      z-index:99;
      }
      }
      @media (max-width: 900px) {
      .bulk-toolbar-desktop,
      .topology-toolbar {
      display: none !important;
      }
      }
      .legend-close-btn {
      position: absolute;
      top: 5px;
      right: 5px;
      width: 18px;
      height: 18px;
      border-radius: 999px;
      border: 1px solid var(--edge-main);
      background: var(--panel-alt);
      color: var(--text-soft);
      font-size: 11px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      }
      .legend-close-btn:hover {
      background: var(--danger);
      color: #fff;
      }
      .legend-mini-btn {
      position: absolute;
      left: 10px;
      padding: 4px 8px;
      border-radius: 4px;
      border: 1px solid var(--toolbar-border, #1f2937);
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 11px;
      cursor: pointer;
      z-index: 20;
      display: none;
      transition: all 0.2s;
      }
      .legend-mini-btn:hover,
      .legend-mini-btn:active {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
      }
      .legend-title {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: var(--toolbar-text, var(--text-soft));
      margin-bottom: 2px;
      }
      .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      }
      .legend-swatch {
      width: 14px;
      height: 14px;
      border-radius: 3px;
      border: 1px solid #020617;
      flex-shrink: 0;
      }
      .legend-label {
      outline: none;
      cursor: text;
      flex: 1;
      min-width: 60px;
      user-select: text;
      -webkit-user-select: text;
      }
      .legend-label.editing {
      border-bottom: 1px dashed var(--accent);
      }
      .canvas-viewport {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      overflow: hidden;
      }
      .canvas-viewport.panning {
      cursor: grabbing !important;
      }
      .canvas-viewport.panning * {
      cursor: grabbing !important;
      }
      .canvas-viewport svg {
      width: 100%;
      height: 100%;
      display: block;
      background: linear-gradient(rgba(71, 85, 105, 0.1) 1px,
      transparent 1px),
      linear-gradient(90deg,
      rgba(71, 85, 105, 0.1) 1px,
      transparent 1px),
      linear-gradient(rgba(71, 85, 105, 0.05) 1px, transparent 1px),
      linear-gradient(90deg,
      rgba(71, 85, 105, 0.05) 1px,
      transparent 1px);
      background-size:
      100px 100px,
      100px 100px,
      20px 20px,
      20px 20px;
      background-position:
      -1px -1px,
      -1px -1px,
      -1px -1px,
      -1px -1px;
      }
      .zoom-toolbar {
      display: flex;
      gap: 4px;
      padding: 6px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      }
      .zoom-toolbar button {
      width: 32px;
      height: 32px;
      padding: 0;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 18px;
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
      }
      .zoom-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .zoom-toolbar .zoom-level {
      font-size: 11px;
      color: var(--toolbar-text, var(--text-soft));
      text-align: center;
      padding: 2px 0;
      min-width: 32px;
      }
      .zoom-toolbar .divider {
      height: 1px;
      background: var(--toolbar-border, var(--edge-main));
      margin: 2px 0;
      }
      .minimap-zoom-wrapper {
      position: absolute;
      bottom: 10px;
      right: 10px;
      z-index: 99;
      }
      .minimap-container {
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      overflow: hidden;
      margin-bottom: 4px;
      }
      .minimap-container svg {
      width: 100%;
      height: 100%;
      }
      .minimap-viewport {
      fill: rgba(79, 209, 197, 0.2);
      stroke: var(--accent);
      stroke-width: 2;
      cursor: move;
      }
      .minimap-node {
      fill: var(--minimap-dots, var(--text-soft));
      }
      .minimap-edge {
      stroke: var(--edge-main);
      stroke-width: 1;
      }
      .minimap-close-btn {
      position: absolute;
      top: 2px;
      right: 2px;
      width: 18px;
      height: 18px;
      background: var(--toolbar-btn-bg, rgba(15, 23, 42, 0.9));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 3px;
      color: var(--toolbar-text, var(--text-soft));
      font-size: 11px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
      padding: 0;
      line-height: 1;
      }
      .minimap-close-btn:hover {
      background: var(--danger);
      color: white;
      border-color: var(--danger);
      }
      .toolbar-close-btn {
      width: 24px;
      height: 24px;
      background: var(--toolbar-btn-bg, rgba(15, 23, 42, 0.9));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-text, var(--text-soft));
      font-size: 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      line-height: 1;
      flex-shrink: 0;
      }
      .toolbar-close-btn:hover {
      background: var(--danger);
      color: white;
      border-color: var(--danger);
      }
      .canvas-hint {
      position: absolute;
      top: 50px;
      left: 50%;
      transform: translateX(-50%);
      padding: 8px 16px;
      background: rgba(15, 23, 42, 0.92);
      border: 1px solid #1f2937;
      border-radius: 6px;
      font-size: 12px;
      color: var(--text-soft);
      z-index: 18;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
      }
      .canvas-hint.visible {
      opacity: 1;
      }
      .edge {
      stroke: var(--edge-main);
      stroke-width: 4;
      opacity: 0.75;
      transition: 0.25s ease-in-out;
      cursor: pointer;
      }
      .edge.backup {
      stroke: var(--danger);
      stroke-width: 5;
      }
      .edge.active {
      opacity: 1;
      stroke-width: 7;
      filter: drop-shadow(0 0 8px var(--accent, #4fd1c5));
      }
      .rect-group.active .rect-shape {
      filter: drop-shadow(0 0 10px var(--accent, #4fd1c5));
      animation: pulse 1.2s infinite ease-in-out;
      }
      .text-element.active {
      filter: drop-shadow(0 0 10px var(--accent, #4fd1c5));
      animation: pulse 1.2s infinite ease-in-out;
      }
      .free-preview {
      fill: none;
      stroke-dasharray: 4 4;
      pointer-events: none;
      }
      .free-point {
      fill: #e5e7eb;
      stroke: #0f172a;
      stroke-width: 1.5;
      cursor: grab;
      }
      .node-circle {
      fill: var(--node-fill, #1e293b);
      stroke: var(--node-stroke, #475569);
      stroke-width: 2;
      transition: 0.25s ease;
      transform-origin: center center;
      }
      .node-hit-area {
      cursor: grab;
      pointer-events: all;
      }
      .node-group:hover .node-circle {
      filter: drop-shadow(0 0 10px rgba(79, 209, 197, 0.45));
      }
      .node-group.active .node-circle {
      stroke: var(--accent);
      animation: pulse 1.2s infinite ease-in-out;
      }
      .node-group.selected .node-circle {
      stroke: var(--selection-handle, #f59e0b);
      stroke-width: 3;
      }
      .node-group.search-highlight .node-circle {
      stroke: #10b981;
      stroke-width: 3;
      filter: drop-shadow(0 0 8px #10b981);
      }
      @keyframes pulse {
      0% {
      filter: drop-shadow(0 0 4px #4fd1c5);
      }
      50% {
      filter: drop-shadow(0 0 14px #4fd1c5);
      }
      100% {
      filter: drop-shadow(0 0 4px #4fd1c5);
      }
      }
      .node-label {
      fill: var(--text-main);
      font-size: 18px;
      text-anchor: middle;
      font-weight: 600;
      }
      .node-sub {
      fill: var(--text-soft);
      font-size: 13px;
      text-anchor: middle;
      }
      @media (max-width: 1024px) {
      .node-label {
      font-size: 28px;
      }
      .node-sub {
      font-size: 20px;
      }
      }
      @media (max-width: 768px) {
      .node-label {
      font-size: 70px;
      }
      .node-sub {
      font-size: 50px;
      }
      }
      @media (max-width: 380px) {
      .node-label {
      font-size: 60px;
      }
      .node-sub {
      font-size: 42px;
      }
      }
      .details-panel {
      background: var(--sidebar-bg, var(--panel-alt));
      padding: 22px;
      padding-bottom: 80px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 15px;
      position: relative;
      transition:
      width 0.3s ease,
      min-width 0.3s ease,
      padding 0.3s ease,
      opacity 0.3s ease;
      }
      .details-panel {
      min-width: 260px !important;
      }
      .details-panel {
      overflow-y: auto !important;
      overflow-x: hidden;
      }
      .details-panel.collapsed {
      width: 0 !important;
      min-width: 0 !important;
      padding: 0 !important;
      overflow: hidden;
      opacity: 0;
      }
      body {
      overflow-x: hidden;
      overflow-y: hidden;
      }
      main {
      overflow-x: hidden;
      overflow-y: visible;
      }
      .details-panel {
      overflow-y: auto !important;
      overflow-x: hidden;
      }
      .details-panel.collapsed {
      min-width: 0 !important;
      }
      .sidebar-toggle {
      position: absolute;
      left: -16px;
      top: 50%;
      transform: translateY(-50%);
      width: 16px;
      height: 60px;
      background: var(--sidebar-bg, var(--panel-alt));
      border: 1px solid var(--edge-main);
      border-right: none;
      border-radius: 8px 0 0 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text-soft);
      font-size: 10px;
      z-index: 25;
      transition:
      background 0.2s,
      color 0.2s;
      }
      .sidebar-toggle:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .sidebar-toggle.collapsed {
      left: 0;
      border-right: 1px solid var(--edge-main);
      border-radius: 0 8px 8px 0;
      position: fixed;
      right: 0;
      left: auto;
      }
      .details-name {
      font-size: clamp(22px, 2.5vw, 30px);
      font-weight: 700;
      }
      .details-ip {
      font-size: clamp(16px, 2vw, 22px);
      color: var(--text-soft);
      }
      .details-role {
      font-size: clamp(16px, 2vw, 22px);
      color: var(--accent);
      }
      .details-info-row {
      display: flex;
      align-items: center;
      margin: 6px 0;
      }
      .size-controls {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-top: 10px;
      }
      .size-controls label {
      font-size: clamp(14px, 1.6vw, 18px);
      color: var(--text-soft);
      }
      .size-controls input[type="range"] {
      flex: 1;
      accent-color: var(--accent);
      }
      .size-controls button {
      padding: 6px 12px;
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      font-size: clamp(12px, 1.4vw, 16px);
      }
      .size-controls button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .style-section {
      margin-top: 15px;
      padding-top: 15px;
      border-top: 1px solid var(--edge-main);
      }
      .style-section summary {
      cursor: pointer;
      font-size: clamp(14px, 1.6vw, 20px);
      text-transform: uppercase;
      color: var(--text-soft);
      list-style: none;
      display: flex;
      justify-content: space-between;
      align-items: center;
      user-select: none;
      }
      .style-section summary::-webkit-details-marker {
      display: none;
      }
      .password-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #ffffff;
      z-index: 9999;
      }
      .style-section summary::after {
      content: "▼";
      transition: transform 0.2s;
      }
      .style-section[open] summary::after {
      transform: rotate(180deg);
      }
      .style-content {
      margin-top: 10px;
      }
      .style-row {
      display: flex;
      gap: 10px;
      align-items: center;
      margin: 8px 0;
      }
      .style-row label {
      font-size: clamp(13px, 1.5vw, 17px);
      color: var(--text-soft);
      min-width: 80px;
      }
      .style-row input[type="color"] {
      width: 50px;
      height: 30px;
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      background: transparent;
      }
      .style-row input[type="number"] {
      width: 70px;
      padding: 4px 8px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(12px, 1.4vw, 16px);
      }
      .style-row select {
      flex: 1;
      padding: 4px 8px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(12px, 1.4vw, 16px);
      cursor: pointer;
      }
      .editable-text {
      cursor: pointer;
      transition: opacity 0.2s;
      }
      .editable-text:hover {
      opacity: 0.7;
      }
      .modal {
	  display: none;
	  position: fixed;
	  top: 0;
	  left: 0;
	  width: 100%;
	  height: 100%;
	  z-index: 999999;
	  justify-content: center;
	  align-items: center;
	  overflow: auto;
	  }
	  .modal.active {
	  display: inline-grid;
	  }
	  .modal-content {
	  background: var(--panel-alt);
	  padding: 25px;
	  border-radius: 8px;
	  border: 1px solid var(--edge-main);
	  min-width: 300px;
	  max-width: 90%;
	  }
      .modal-content h3 {
      margin: 0 0 15px 0;
      color: var(--text-main);
      font-size: clamp(18px, 2vw, 24px);
      }
      .modal-content p {
      color: var(--text-soft);
      font-size: clamp(14px, 1.6vw, 18px);
      margin: 0 0 20px 0;
      }
      .modal-content input:not([type="color"]),
      .modal-content select {
      width: 100%;
      padding: 10px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(14px, 1.6vw, 18px);
      margin-bottom: 15px;
      user-select: text;
      -webkit-user-select: text;
      }
      .modal-content input[type="color"] {
      width: 60px;
      height: 36px;
      padding: 2px;
      border: 2px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      background: none;
      -webkit-appearance: none;
      appearance: none;
      }
      .modal-content input[type="color"]::-webkit-color-swatch-wrapper {
      padding: 0;
      }
      .modal-content input[type="color"]::-webkit-color-swatch {
      border: none;
      border-radius: 4px;
      }
      .modal-buttons {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
      margin-top: 10px;
      }
      .modal-buttons button {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: clamp(14px, 1.6vw, 18px);
      font-weight: 600;
      }
      .modal-buttons .btn-cancel {
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      }
      .modal-buttons .btn-save {
      background: var(--accent);
      color: var(--bg);
      }
      .modal-buttons .btn-delete {
      background: var(--danger);
      color: white;
      }
      .confirm-modal p {
      color: var(--text-soft);
      font-size: clamp(14px, 1.6vw, 18px);
      margin: 0 0 20px 0;
      }
      .context-menu-item {
      transition: background 0.15s;
      }
      .context-menu-item:hover {
      background: var(--panel);
      }
      .badge-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      }
      .badge {
      background: var(--tag-fill, #1e293b);
      color: var(--tag-text, #e2e8f0);
      border: 1px solid var(--tag-border, var(--edge-main));
      padding: 5px 12px;
      border-radius: 22px;
      font-size: clamp(12px, 1.4vw, 18px);
      }
      .badge.wg {
      color: var(--accent);
      border-color: var(--accent);
      }
      input[type="text"],
      input[type="number"],
      input[type="password"],
      textarea,
      select {
      background: var(--input-bg, #0b0e13) !important;
      color: var(--input-text, #e2e8f0) !important;
      border-color: var(--input-border, #1f2937) !important;
      font-family: var(--input-font, Inter, system-ui, sans-serif) !important;
      font-size: var(--input-font-size, 14px) !important;
      }
      .section-label {
      margin-top: 8px;
      font-size: clamp(14px, 1.6vw, 20px);
      text-transform: uppercase;
      color: var(--text-soft);
      }
      .list li {
      margin: 6px 0;
      font-size: clamp(14px, 1.6vw, 20px);
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      }
      .list li:hover {
      color: var(--accent);
      }
      .delete-note {
      color: var(--danger);
      font-size: 18px;
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.2s;
      flex-shrink: 0;
      }
      .list li:hover .delete-note {
      opacity: 1;
      }
      .editing {
      outline: 2px solid var(--accent);
      background: #0d141f;
      padding: 4px;
      border-radius: 6px;
      user-select: text;
      -webkit-user-select: text;
      }
      .version-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .version-item:hover {
      background: var(--panel-alt);
      border-color: var(--accent);
      }
      .version-item.current {
      border-color: var(--accent);
      background: rgba(79, 209, 197, 0.1);
      }
      .version-info {
      flex: 1;
      }
      .version-info .timestamp {
      font-size: 13px;
      color: var(--text-main);
      font-weight: 600;
      }
      .version-info .details {
      font-size: 11px;
      color: var(--text-soft);
      margin-top: 4px;
      }
      .version-actions {
      display: flex;
      gap: 6px;
      }
      .audit-entry {
      padding: 8px 12px;
      background: var(--panel);
      border-left: 3px solid var(--edge-main);
      border-radius: 4px;
      font-size: 12px;
      }
      .audit-entry.node { border-left-color: #4fd1c5; }
      .audit-entry.connection { border-left-color: #9f7aea; }
      .audit-entry.style { border-left-color: #ed8936; }
      .audit-entry.rack { border-left-color: #48bb78; }
      .audit-entry.layer { border-left-color: #4299e1; }
      .audit-entry .time {
      color: var(--text-soft);
      font-size: 10px;
      }
      .audit-entry .action {
      color: var(--text-main);
      font-weight: 500;
      }
      .tab-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .tab-item:hover {
      background: var(--panel-alt);
      }
      .tab-item.active {
      border-color: var(--accent);
      background: rgba(79, 209, 197, 0.1);
      }
      .tab-item .tab-name {
      font-weight: 600;
      color: var(--text-main);
      flex: 1;
      }
      .tab-item .tab-stats {
      font-size: 11px;
      color: var(--text-soft);
      margin-right: 10px;
      }
      .tab-actions {
      display: flex;
      gap: 6px;
      }    
      .secret-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      border-left: 3px solid var(--danger);
      }
      .secret-item .secret-name {
      font-weight: 600;
      color: var(--text-main);
      flex: 1;
      }
      .secret-item .secret-status {
      font-size: 11px;
      color: var(--text-soft);
      margin-right: 10px;
      }    
      .mobile-menu-btn {
      display: none;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      color: var(--text-main);
      font-size: 22px;
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      }
      #topbar-menu {
      gap: 8px;
      }
      @media (min-width: 721px) {
      #topbar-menu {
      display: flex !important;
      }
      }
      @media (max-width: 720px) {
      #topbar-menu {
      display: none;
      }
      #topbar-menu.open {
      display: flex;
      }
      }
      @media (max-width: 720px) {
      .mobile-menu-btn {
      display: block;
      }
      #topbar-menu {
      position: absolute;
      top: var(--topbar-height);
      right: 0;
      background: var(--panel-alt);
      border-left: 1px solid var(--topbar-border);
      border-bottom: 1px solid var(--topbar-border);
      padding: 12px;
      display: none;
      flex-direction: column;
      width: 180px;
      z-index: 999;
      }
      #topbar-menu.open {
      display: flex;
      }
      header {
      position: relative;
      z-index: 9999;
      }
      }
      @media (max-width: 720px) {
      .draw-toolbar {
      position: absolute;
      top: auto;
      bottom: auto;
      left: 10px !important;
      right: auto !important;
      width: auto;
      gap: 6px;
      padding: 8px;
      }
      .topology-toolbar {
      position: absolute;
      top: auto;
      bottom: auto;
      width: auto;
      gap: 6px;
      padding: 8px;
      }
      .draw-toolbar {
      top: 10px !important;
      z-index:99;
      }
      .topology-toolbar {
      z-index:99;
      top: calc(10px + var(--draw-toolbar-height, 50px)) !important;
      }
      .canvas-hint {
      top: calc(10px + 120px);
      }
      #search-input {
      width: 100%;
      }
      }
	  body.view-only-mode:not(.view-only-inspect) #node-panel,
      body.view-only-mode:not(.view-only-inspect) #edge-panel,
      body.view-only-mode:not(.view-only-inspect) #text-panel,
      body.view-only-mode:not(.view-only-inspect) #rect-panel {
        display: none !important;
      }
      body.view-only-mode .node-group,
      body.view-only-mode .edge,
      body.view-only-mode .rect-group,
      body.view-only-mode .text-element {
        cursor: default !important;
      }
      body.view-only-mode #bulk-toolbar,
      body.view-only-mode #bulk-toolbar-mobile,
      body.view-only-mode #bulk-actions-modal {
        display: none !important;
      }
      body.view-only-mode::after {
        content: "VIEW ONLY • tap 5× to inspect";
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(245, 101, 101, 0.9);
        color: white;
        padding: 6px 16px;
        border-radius: 20px;
        font-size: 12px;
        font-weight: 600;
        letter-spacing: 1px;
        z-index: 9999;
        pointer-events: none;
      }
    </style>
  </head>
  <body style="background: radial-gradient(circle at center top, rgb(30, 37, 50) 0px, rgb(5, 6, 8) 70%);" class="">
    <div class="modal" id="edit-modal">
      <div class="modal-content">
        <h3 id="modal-title">Edit Title</h3>
        <input type="text" id="modal-input">
        <div class="modal-buttons">
          <button class="btn-cancel" id="modal-cancel">Cancel</button>
          <button class="btn-save" id="modal-save">Save</button>
        </div>
      </div>
    </div>
    <div class="modal confirm-modal" id="confirm-modal">
      <div class="modal-content">
        <h3>Confirm</h3>
        <p id="confirm-message"> Are you sure you want to delete this line? </p>
        <div class="modal-buttons">
          <button class="btn-cancel" id="confirm-cancel">Cancel</button>
          <button class="btn-delete" id="confirm-delete">Delete</button>
        </div>
      </div>
    </div>
    <div class="modal" id="save-info-modal">
      <div class="modal-content" style="max-width: 700px; max-height: 80vh; overflow-y: auto;">
        <h3 style="margin-bottom: 16px;">Help</h3>
        <div style="display: flex; gap: 8px; margin-bottom: 16px; flex-wrap: wrap;">
          <button class="help-tab active" data-tab="general" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--accent); color: var(--bg); border-radius: 6px; cursor: pointer; font-weight: 600;">General</button>
          <button class="help-tab" data-tab="desktop" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--panel); color: var(--text-main); border-radius: 6px; cursor: pointer; font-weight: 600;">Desktop</button>
          <button class="help-tab" data-tab="mobile" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--panel); color: var(--text-main); border-radius: 6px; cursor: pointer; font-weight: 600;">Mobile</button>
        </div>
        <div id="help-tab-general" class="help-tab-content" style="display: block;">
          <ul style="margin-left: 20px; margin-bottom: 12px; line-height: 1.8;">
            <li><strong>Add Nodes:</strong> Click "+ Node" or "+ Rack" in the top menu</li>
            <li><strong>Connect Nodes:</strong> Select a node, then use "Add Connection" in the panel</li>
            <li><strong>Move Nodes:</strong> Drag nodes to reposition them</li>
            <li><strong>Enter Rack View:</strong> Double click on desktop or Long press on mobile</li>
            <li><strong>Multi Select:</strong> Right click (desktop) or double tap (mobile)</li>
            <li><strong>Pan Canvas:</strong> Drag empty space or hold Space + drag</li>
            <li><strong>Zoom:</strong> Scroll wheel or pinch gesture</li>
            <li><strong>Free Draw:</strong> Use draw toolbar for drawing lines, boxes/zones , and text</li>
          </ul>
          <h4 style="color: var(--accent); margin-bottom: 8px;">Saving &amp; Encryption</h4>
          <p style="margin-bottom: 8px;">Browsers cannot overwrite local files. Click <strong>Save File</strong> to download an updated HTML with all changes. Replace your old file to keep edits.</p>
          <p style="margin-bottom: 8px;"><strong>Encryption of data:</strong> Check "Encrypt" before saving to password protect your data. Beware! No recovery possible without password!!</p>
          <p><strong>Decryption of data:</strong> Export via JSON in top settings menu after successful password validation to decrypt your data. You can then reimport back into the same file and save!</p>
        </div>
        <div id="help-tab-desktop" class="help-tab-content" style="display: none;">
          <h4 style="color: var(--accent); margin-bottom: 12px;">Navigation</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Arrow Keys</code></td>
              <td style="padding: 8px;">Move selected 1px</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Shift + Arrows</code></td>
              <td style="padding: 8px;">Move selected 10px</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Tab / Shift+Tab</code></td>
              <td style="padding: 8px;">Cycle through nodes</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">F</code></td>
              <td style="padding: 8px;">Focus on selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Space + Drag</code></td>
              <td style="padding: 8px;">Pan canvas</td>
            </tr>
          </tbody></table>
          <h4 style="color: var(--accent); margin-bottom: 12px;">Management</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">L</code></td>
              <td style="padding: 8px;">Lock/unlock selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">G</code></td>
              <td style="padding: 8px;">Group/ungroup selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+C / Ctrl+V</code></td>
              <td style="padding: 8px;">Copy / Paste</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+D</code></td>
              <td style="padding: 8px;">Duplicate</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+A</code></td>
              <td style="padding: 8px;">Select all</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Delete</code></td>
              <td style="padding: 8px;">Delete selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Escape</code></td>
              <td style="padding: 8px;">Clear selection</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+Z / Ctrl+Y</code></td>
              <td style="padding: 8px;">Undo / Redo</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Right Click</code></td>
              <td style="padding: 8px;">Multi select toggle</td>
            </tr>
          </tbody></table>
        </div>
        <div id="help-tab-mobile" class="help-tab-content" style="display: none;">
          <h4 style="color: var(--accent); margin-bottom: 12px;">Basic Gestures</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Tap node</strong></td>
              <td style="padding: 8px;">Select &amp; open properties</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Tap empty</strong></td>
              <td style="padding: 8px;">Deselect all</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Drag node</strong></td>
              <td style="padding: 8px;">Move node</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Drag empty</strong></td>
              <td style="padding: 8px;">Pan canvas</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Pinch</strong></td>
              <td style="padding: 8px;">Zoom in/out</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Double-tap node</strong></td>
              <td style="padding: 8px;">Add/remove from selection</td>
            </tr>
          </tbody></table>
          <h4 style="color: var(--accent); margin-bottom: 12px;">Rack View</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Long-press rack</strong></td>
              <td style="padding: 8px;">Enter rack view</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Double-tap empty</strong></td>
              <td style="padding: 8px;">Exit rack view</td>
            </tr>
          </tbody></table>
        </div>
        <div class="modal-buttons" style="margin-top: 16px;">
          <button class="btn-cancel" id="save-info-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="settings-modal">
      <div class="modal-content">
        <h2>Settings</h2>
		<details class="style-section">
          <summary>View Only Mode</summary>
          <div class="style-content">
            <div class="style-row">
              <label>View Only (disable editing)</label>
              <input type="checkbox" id="view-only-mode" style="width:auto;">
            </div>
            <p style="margin-top:4px;font-size:12px;color:var(--text-soft);">When enabled, all editing of the canvas is disabled. Pan and zoom still work.</p>
          </div>
        </details>
        <details class="style-section">
          <summary>General Theme</summary>
          <div class="style-content">
		    <div class="style-row">
              <label>Main Background</label>
              <input type="color" id="panel-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Modal Window (popup) Background</label>
              <input type="color" id="panel-alt-color" value="#10141b">
            </div>
            <div class="style-row">
              <label>Accent Buttons</label>
              <input type="color" id="accent-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Danger Buttons</label>
              <input type="color" id="danger-color" value="#f56565">
            </div>
            <div class="style-row">
              <label>Primary Text</label>
              <input type="color" id="text-main-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Secondary Text</label>
              <input type="color" id="text-soft-color" value="#94a3b8">
            </div>
          </div>
        </details>
		<details class="style-section">
          <summary>Top Bar</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="topbar-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="topbar-border-color" value="#1f2533">
            </div>
          </div>
		  <div class="style-content">
            <div class="style-row">
              <label>Button Fill</label>
              <input type="color" id="btn-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Button Text</label>
              <input type="color" id="btn-text-color" value="#e2e8f0">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Main Canvas</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="canvas-border-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Grid Lines</label>
              <input type="color" id="canvas-grid-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Grid Size</label>
              <input type="number" id="canvas-grid-size" value="50" min="20" max="200" style="width:60px;">
            </div>
			<div class="style-row">
              <label>Background Top</label>
              <input type="color" id="canvas-gradient-top" value="#1e2532">
            </div>
            <div class="style-row">
              <label>Background Bottom</label>
              <input type="color" id="canvas-gradient-bottom" value="#050608">
            </div>
            <div class="style-row">
              <label>Solid Background</label>
              <input type="color" id="page-bg-color" value="#050608">
            </div>
            <p style="margin-top:4px;font-size:12px;color:var(--text-soft);">Set solid background to override gradient.</p>
          </div>
			</details>
		  <details class="style-section">
          <summary>Rack Canvas</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Frame Fill</label>
              <input type="color" id="rack-frame-fill" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Frame Border</label>
              <input type="color" id="rack-frame-stroke" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Grid Lines</label>
              <input type="color" id="rack-line-color" value="#475569">
            </div>
            <div class="style-row">
              <label>U Labels</label>
              <input type="color" id="rack-text-color" value="#4fd1c5">
            </div>
          </div>
        </details>
		        <details class="style-section">
          <summary>Canvas Toolbars</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="toolbar-bg-color" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="toolbar-border-color" value="#1f2937">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="toolbar-text-color" value="#94a3b8">
            </div>
            <div class="style-row">
              <label>Button Fill</label>
              <input type="color" id="toolbar-btn-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Button Text</label>
              <input type="color" id="toolbar-btn-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Minimap Dots</label>
              <input type="color" id="minimap-dots-color" value="#94a3b8">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Nodes</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Fill</label>
              <input type="color" id="node-fill-color" value="#1e293b">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="node-stroke-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Title Color</label>
              <input type="color" id="node-title-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Title Size</label>
              <input type="number" id="node-title-size" value="18" min="8" max="48" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Subtitle Color</label>
              <input type="color" id="node-sub-color" value="#94a3b8">
            </div>
            <div class="style-row">
              <label>Subtitle Size</label>
              <input type="number" id="node-sub-size" value="13" min="8" max="48" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Font</label>
              <select id="node-font-family" style="flex:1;padding:4px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;">
                <option value="Inter, system-ui, sans-serif">Inter</option>
                <option value="Arial, sans-serif">Arial</option>
                <option value="Helvetica, sans-serif">Helvetica</option>
                <option value="Georgia, serif">Georgia</option>
                <option value="monospace">Monospace</option>
              </select>
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Connections</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Default Color</label>
              <input type="color" id="default-edge-color" value="#475569">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Groups &amp; Editing</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Resize handle Color</label>
              <input type="color" id="selection-handle-color" value="#f59e0b">
            </div>
            <div class="style-row">
              <label>Resize Handle Size</label>
              <input type="number" id="selection-handle-size" value="8" min="4" max="16" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Grouped Icon Outline</label>
              <input type="color" id="group-indicator-color" value="#4fd1c5">
            </div>
          </div>
		   <div class="style-content">
            <div class="style-row">
              <label>Multiselect Fill Color (Desktop)</label>
              <input type="color" id="selection-fill-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Multiselect Fill Opacity (Desktop)</label>
              <input type="range" id="selection-fill-opacity" min="0" max="1" step="0.05" value="0.1">
              <span id="selection-fill-opacity-val" style="min-width:35px;text-align:right;">10%</span>
            </div>
            <div class="style-row">
              <label>Multiselect Border Color (Desktop)</label>
              <input type="color" id="selection-stroke-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Multiselect Border Width (Desktop)</label>
              <input type="number" id="selection-stroke-width" min="1" max="10" value="2">
            </div>
            <div class="style-row">
              <label>Multiselect Border Style (Desktop)</label>
              <select id="selection-stroke-style">
                <option value="5,5">Dashed</option>
                <option value="2,4">Dotted</option>
                <option value="none">Solid</option>
              </select>
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Inputs &amp; Dropdowns</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="input-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="input-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="input-border-color" value="#1f2937">
            </div>
            <div class="style-row">
              <label>Font</label>
              <select id="input-font-family" style="flex:1;padding:4px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;">
                <option value="Inter, system-ui, sans-serif">Inter</option>
                <option value="Arial, sans-serif">Arial</option>
                <option value="Helvetica, sans-serif">Helvetica</option>
                <option value="Georgia, serif">Georgia</option>
                <option value="monospace">Monospace</option>
              </select>
            </div>
            <div class="style-row">
              <label>Font Size</label>
              <input type="number" id="input-font-size" value="14" min="10" max="24" style="width:60px;">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Welcome Message</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Enabled</label>
              <input type="checkbox" id="canvas-hint-enabled" checked="" style="width:auto;">
            </div>
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="canvas-hint-bg-color" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Text Color</label>
              <input type="color" id="canvas-hint-text-color" value="#94a3b8">
            </div>
            <div class="style-row" style="flex-direction:column;align-items:stretch;">
              <label>Custom Text (HTML)</label>
              <textarea id="canvas-hint-text" rows="4" style="width:100%;margin-top:4px;padding:6px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;font-size:12px;resize:vertical;" placeholder="Leave empty for default"></textarea>
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Sidebar / Mobile Footer</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="sidebar-bg-color" value="#10141b">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Tags</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Fill</label>
              <input type="color" id="tag-fill-color" value="#1e293b">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="tag-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="tag-border-color" value="#475569">
            </div>
          </div>
        </details>
        <details class="style-section" open="">
          <summary>Import / Export / Upgrade JSON</summary>
          <div class="style-content">
            <button id="export-data-btn" style="width:100%;margin-bottom:10px;padding:10px;background:var(--accent);color:var(--bg);border:none;border-radius:6px;cursor:pointer;font-size:14px;font-weight:600;">Export JSON</button>
            <button id="import-data-btn" style="width:100%;padding:10px;background:var(--panel);color:var(--text-main);border:1px solid var(--edge-main);border-radius:6px;cursor:pointer;font-size:14px;font-weight:600;">Import JSON</button>
            <input type="file" id="import-data-file" accept=".json" style="display:none">
          </div>
        </details>
        <details class="style-section" open="">
          <summary>Danger Zone</summary>
          <div class="style-content">
            <p style="margin-bottom:12px;font-size:13px;color:var(--text-soft);">Permanently delete everything on the canvas.</p>
            <button id="clear-all-btn" title="Clear all nodes" style="padding:6px 12px;background:var(--danger);color:#fff;border:none;border-radius:6px;cursor:pointer;font-size:14px;font-weight:600;">Clear All</button>
            <input type="file" id="import-data-file" accept=".json" style="display:none">
          </div>
        </details>
        <div class="modal-buttons">
          <button class="btn-cancel" id="settings-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="add-node-modal">
      <div class="modal-content">
        <h3>Add New Node</h3>
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Name</label>
        <input type="text" id="new-node-name" placeholder="e.g. web-server">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">IP / Subtitle</label>
        <input type="text" id="new-node-ip" placeholder="e.g. 192.168.1.100">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Tags (comma separated)</label>
        <input type="text" id="new-node-tags" placeholder="e.g. Docker, nginx, WG: vpn">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Shape</label>
        <select id="new-node-shape">
                  <optgroup label="Basic Shapes">
				  <option value="circle">Circle</option>
				  <option value="square">Square</option>
				  <option value="rectangle">Rectangle</option>
				  <option value="triangle">Triangle</option>
				  <option value="hexagon">Hexagon</option>
				  <option value="diamond">Diamond</option>
				  <option value="star">Star</option>
				  <option value="stop-sign">Stop Sign</option>
				  <option value="octagon">Octagon</option>
				  <option value="pentagon">Pentagon</option>
				  <option value="cross">Cross</option>
				  <option value="rounded-square">Rounded Square</option>
				  <option value="pill">Pill</option>
				  <option value="parallelogram">Parallelogram</option>
				  <option value="trapezoid">Trapezoid</option>
				</optgroup>
			  <optgroup label="Computers &amp; Devices">
			      <option value="server">Server</option>
				  <option value="pc">PC / Desktop</option>
				  <option value="laptop">Laptop</option>
				  <option value="phone">Phone / Mobile</option>
				  <option value="printer">Printer</option>
				  <option value="pi">Raspberry Pi</option>
				  <option value="sensor">Sensor / IoT</option>
			  </optgroup>
			  <optgroup label="Network Equipment">
				  <option value="router">Router</option>
				  <option value="switch">Switch</option>
				  <option value="firewall">Firewall</option>
				  <option value="access-point">Access Point</option>
				  <option value="load-balancer">Load Balancer</option>
				  <option value="gateway">Gateway</option>
				  <option value="vpn">VPN / Tunnel</option>
				  <option value="nas">NAS / Storage</option>
			  </optgroup>
			  <optgroup label="Cloud &amp; Services">
			      <option value="cloud">Cloud</option>
				  <option value="database">Database</option>
				  <option value="docker">Docker</option>
				  <option value="container">Container</option>
				  <option value="vm">Virtual Machine</option>
				  <option value="kubernetes">Kubernetes</option>
				  <option value="api">API / Endpoint</option>
				  <option value="queue">Queue / Message</option>
				  <option value="lambda">Lambda / Function</option>
				  <option value="bucket">Bucket / S3</option>
			  </optgroup>
			  <optgroup label="Security &amp; Monitoring">
				  <option value="shield">Shield</option>
				  <option value="camera">Camera / CCTV</option>
				  <option value="monitor">Monitor / Dashboard</option>
			  </optgroup>
        </select>
        <div class="modal-buttons">
          <button class="btn-cancel" id="add-node-cancel">Cancel</button>
          <button class="btn-save" id="add-node-save">Add Node</button>
        </div>
      </div>
    </div>
    <div class="modal" id="add-rack-modal">
      <div class="modal-content">
        <h3>Add New Rack</h3>
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Rack Name</label>
        <input type="text" id="new-rack-name" placeholder="e.g. Rack-A, DC1-R01">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">IP / Network Range (optional)</label>
        <input type="text" id="new-rack-ip" placeholder="e.g. 192.168.1.0/24">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Tags (comma separated)</label>
        <input type="text" id="new-rack-tags" placeholder="e.g. Production, Data Center 1">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Icon / Shape</label>
        <select id="new-rack-shape">
                  <optgroup label="Basic Shapes">
				  <option value="circle">Circle</option>
				  <option value="square">Square</option>
				  <option value="rectangle">Rectangle</option>
				  <option value="triangle">Triangle</option>
				  <option value="hexagon">Hexagon</option>
				  <option value="diamond">Diamond</option>
				  <option value="star">Star</option>
				  <option value="stop-sign">Stop Sign</option>
				  <option value="octagon">Octagon</option>
				  <option value="pentagon">Pentagon</option>
				  <option value="cross">Cross</option>
				  <option value="rounded-square">Rounded Square</option>
				  <option value="pill">Pill</option>
				  <option value="parallelogram">Parallelogram</option>
				  <option value="trapezoid">Trapezoid</option>
				</optgroup>
			  <optgroup label="Computers &amp; Devices">
			      <option value="server">Server</option>
				  <option value="pc">PC / Desktop</option>
				  <option value="laptop">Laptop</option>
				  <option value="phone">Phone / Mobile</option>
				  <option value="printer">Printer</option>
				  <option value="pi">Raspberry Pi</option>
				  <option value="sensor">Sensor / IoT</option>
			  </optgroup>
			  <optgroup label="Network Equipment">
				  <option value="router">Router</option>
				  <option value="switch">Switch</option>
				  <option value="firewall">Firewall</option>
				  <option value="access-point">Access Point</option>
				  <option value="load-balancer">Load Balancer</option>
				  <option value="gateway">Gateway</option>
				  <option value="vpn">VPN / Tunnel</option>
				  <option value="nas">NAS / Storage</option>
			  </optgroup>
			  <optgroup label="Cloud &amp; Services">
			      <option value="cloud">Cloud</option>
				  <option value="database">Database</option>
				  <option value="docker">Docker</option>
				  <option value="container">Container</option>
				  <option value="vm">Virtual Machine</option>
				  <option value="kubernetes">Kubernetes</option>
				  <option value="api">API / Endpoint</option>
				  <option value="queue">Queue / Message</option>
				  <option value="lambda">Lambda / Function</option>
				  <option value="bucket">Bucket / S3</option>
			  </optgroup>
			  <optgroup label="Security &amp; Monitoring">
				  <option value="shield">Shield</option>
				  <option value="camera">Camera / CCTV</option>
				  <option value="monitor">Monitor / Dashboard</option>
			  </optgroup>
        </select>
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Rack Capacity</label>
        <select id="new-rack-capacity">
          <option value="42" selected="">42U (Standard Full Rack)</option>
          <option value="48">48U (Large Rack)</option>
          <option value="24">24U (Half Rack)</option>
          <option value="12">12U (Small/Wall Mount)</option>
          <option value="6">6U (Mini Rack)</option>
        </select>
        <div class="modal-buttons">
          <button class="btn-cancel" id="add-rack-cancel">Cancel</button>
          <button class="btn-save" id="add-rack-save">Add Rack</button>
        </div>
      </div>
    </div>
    <div class="modal confirm-modal" id="clear-all-modal">
      <div class="modal-content">
        <h3>Clear All Nodes</h3>
        <p> This will remove ALL nodes and connections. This cannot be undone until you reload without saving. Are you sure? </p>
        <div class="modal-buttons">
          <button class="btn-cancel" id="clear-all-cancel">Cancel</button>
          <button class="btn-delete" id="clear-all-confirm">Clear Everything</button>
        </div>
      </div>
    </div>
    <div class="modal" id="layer-modal">
      <div class="modal-content" style="max-width: 400px;">
        <h3>Layer Visibility</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Toggle which layers are visible on the canvas</p>
        <div style="display: flex; flex-direction: column; gap: 10px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-physical" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Physical Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-logical" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Logical Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-security" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Security Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-application" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Application Layer</span>
          </label>
        </div>
        <div style="margin-top: 15px; display: flex; gap: 8px;">
          <button class="btn-cancel" style="flex: 1;" onclick="document.querySelectorAll('#layer-modal input[type=checkbox]').forEach(cb =&gt; cb.checked = false); applyLayerFilter();">Hide All</button>
          <button class="btn-save" style="flex: 1;" onclick="document.querySelectorAll('#layer-modal input[type=checkbox]').forEach(cb =&gt; cb.checked = true); applyLayerFilter();">Show All</button>
        </div>
        <div class="modal-buttons" style="margin-top: 10px;">
          <button class="btn-cancel" id="layer-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="tabs-modal">
      <div class="modal-content" style="max-width: 600px;">
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Manage multiple topologies</p>
        <div id="tabs-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 400px; overflow-y: auto; margin-bottom: 15px;">
            <div class="tab-item " onclick="switchTab(0)">
              <div class="tab-name">Corporate Site B</div>
              <div class="tab-stats">105 nodes • 64 connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(0)" title="Rename tab">✏️</button>
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(${index})" title="Delete tab">🗑️</button>
              </div>
            </div>
          
            <div class="tab-item active" onclick="switchTab(1)">
              <div class="tab-name">Homelab 2</div>
              <div class="tab-stats">11 nodes • 10 connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(1)" title="Rename tab">✏️</button>
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(${index})" title="Delete tab">🗑️</button>
              </div>
            </div>
          </div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="new-tab-name" placeholder="New tab name..." style="flex: 1; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <button class="btn-save" onclick="createNewTab()">+ Add Tab</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="tabs-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="rollback-modal">
      <div class="modal-content" style="max-width: 700px;">
        <h3>Version History</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Limit: Snapshots</p>
        <div id="rollback-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 450px; overflow-y: auto; margin-bottom: 15px;">
          <div style="text-align: center; padding: 40px; color: var(--text-soft);">No version history yet. Versions are saved automatically when you save the file.</div>
        </div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <button class="btn-cancel" onclick="clearRollbackHistory()">Clear History</button>
          <button class="btn-save" onclick="createManualSnapshot()">Create Snapshot</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="rollback-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="audit-log-modal">
      <div class="modal-content" style="max-width: 800px;">
        <h3>Audit Log</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Track all changes made to your topology</p>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <select id="audit-filter" style="padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
            <option value="all">All Events</option>
            <option value="node">Node Operations</option>
            <option value="connection">Connections</option>
            <option value="style">Style Changes</option>
            <option value="rack">Rack Operations</option>
            <option value="layer">Layer Changes</option>
          </select>
          <button class="btn-save" onclick="exportAuditLog()">Export</button>
        </div>
        <div id="audit-log-list" style="display: flex; flex-direction: column; gap: 4px; max-height: 450px; overflow-y: auto; margin-bottom: 15px; font-family: monospace; font-size: 12px;">
          <div style="text-align: center; padding: 40px; color: var(--text-soft);">No audit entries yet</div>
        </div>
        <div style="display: flex; gap: 8px;">
          <button class="btn-cancel" onclick="clearAuditLog()">Clear Log</button>
          <button class="btn-cancel" id="audit-log-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="secrets-modal">
      <div class="modal-content" style="max-width: 600px;">
        <h3>Notes</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Notes can also be stored with AES 256 encryption</p>
        <div id="secrets-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 350px; overflow-y: auto; margin-bottom: 15px;">
        </div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="new-secret-name" placeholder="Note name (e.g., 'Root Passwords')..." style="flex: 1; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <button class="btn-save" onclick="createNewSecret()">+ Add Note</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="secrets-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="secret-editor-modal">
      <div class="modal-content" style="max-width: 600px;">
        <h3 id="secret-editor-title">Edit Note</h3>
        <textarea id="secret-editor-content" placeholder="Enter sensitive information here..." style="width: 100%; height: 200px; padding: 12px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main); font-family: monospace; resize: vertical; margin-bottom: 15px;"></textarea>
        <div style="margin-bottom: 15px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
          <input type="checkbox" id="secret-auto-encrypt" checked="" style="cursor: pointer;">
          <span>Encrypt Note</span>
          </label>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" onclick="closeSecretEditor()">Cancel</button>
          <button class="btn-save" onclick="saveSecret()">Save</button>
        </div>
      </div>
    </div>
    <div id="context-menu" style="display: none !important;">
    </div>
    <header>
      <div class="title-block">
        <h1 id="page-title" class="editable-page-title">The One File</h1>
        <div class="save-row">
          <button id="save-file-btn" class="save-btn" type="button">Save File</button>
          <label style="display: flex;align-items: center;gap: 4px;font-size: 12px;color: var(--text-soft);cursor: pointer;user-select: none;">
          <input type="checkbox" id="encrypt-toggle" style="cursor: pointer">
          <span title="Encrypt data with password">Encrypt</span>
          </label>
          <span id="save-help-btn" class="help-icon" title="Why save?">?</span>
        </div>
      </div>
      <div id="topbar-menu">
        <button id="back-to-topology-btn" title="Exit rack view and return to topology" style="padding: 6px 12px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;display: none;">← Back to Topology</button>
        <button id="add-node-btn" class="save-btn" title="Add new node" style="background: var(--accent)" draggable="true">+ Node</button>
        <button id="add-rack-btn" class="save-btn" title="Add new rack" style="background: var(--accent); margin-left: 8px;" draggable="true">+ Rack</button>
        <button id="undo-btn" title="Undo (Ctrl+Z)" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;" disabled="">↶</button>
        <button id="redo-btn" title="Redo (Ctrl+Y)" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;" disabled="">↷</button>
        <input type="text" id="search-nodes" placeholder="Search nodes..." title="Search by name, IP, MAC, role, or tag" style="padding: 6px 12px;background: var(--input-bg);color: var(--input-text);border: 1px solid var(--input-border);border-radius: 6px;font-family: var(--input-font);font-size: var(--input-font-size);width: 180px;">
        <button id="layers-btn" title="Toggle layer visibility" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Layers</button>
        <button id="tabs-btn" title="Manage document tabs" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Tabs</button>
        <button id="rollback-btn" title="View version history" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Snapshots</button>
        <button id="audit-log-btn" title="View audit log" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Audit</button>
        <button id="secrets-btn" title="Manage encrypted notes" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Notes</button>
        <button onclick="screenshotCanvas()" title="Export canvas as PNG image" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">PNG</button>
        <button onclick="exportCanvasSVG()" title="Export canvas as SVG vector" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">SVG</button>
        <button id="settings-btn" title="Page settings">⚙️</button>
      </div>
      <button id="mobile-menu-toggle" class="mobile-menu-btn">☰</button>
      <div class="header-resizer" id="header-resizer">
        <svg class="resizer-icon" width="40" height="6" viewBox="0 0 40 6" xmlns="http://www.w3.org/2000/svg">
          <circle cx="14" cy="3" r="2"></circle>
          <circle cx="20" cy="3" r="2"></circle>
          <circle cx="26" cy="3" r="2"></circle>
        </svg>
      </div>
    </header>
    <main>
      <section class="topology-panel">
        <div class="draw-toolbar" id="draw-toolbar" style="display: flex !important;">
          <button type="button" class="toolbar-close-btn" id="draw-toolbar-close-btn" title="Hide draw toolbar">✕</button>
          <button id="draw-toggle" title="Draw custom line">✏️</button>
          <button id="rect-toggle" title="Draw zone">▭</button>
          <button id="text-toggle" title="Add text">T</button>
          <select id="rect-style" title="zone style">
            <option value="filled">Filled</option>
            <option value="outlined">Outlined</option>
          </select>
          <input type="color" id="draw-color" value="#f97316" title="Line color">
          <select id="draw-style" title="Line style">
            <option value="solid">Solid</option>
            <option value="dashed">Dashed</option>
            <option value="dotted">Dotted</option>
          </select>
          <select id="draw-arrow" title="Arrow direction">
            <option value="none">No arrows</option>
            <option value="forward">→ Right</option>
            <option value="backward">← Left</option>
            <option value="both">↔ Both</option>
          </select>
          <button id="draw-undo" style="display: none" title="Undo last point">Undo</button>
        </div>
        <div class="topology-toolbar" id="topology-toolbar" style="display: flex !important;">
          <button type="button" class="toolbar-close-btn" id="topology-toolbar-close-btn" title="Hide add line toolbar">✕</button>
          <label for="add-line-select">Add line to:</label>
          <select id="add-line-select"><option value="core-router-2">Core Router 2</option><option value="fw-external-1">External FW 1</option><option value="fw-external-2">External FW 2</option><option value="fw-internal">Internal FW</option><option value="core-switch-1">Core Switch 1</option><option value="core-switch-2">Core Switch 2</option><option value="dc-rack-a1">DC Rack A1</option><option value="dc-rack-a2">DC Rack A2</option><option value="dc-rack-b1">DC Rack B1</option><option value="dc-rack-b2">DC Rack B2</option><option value="dmz-rack">DMZ Rack</option><option value="mgmt-rack">Management Rack</option><option value="wlc-primary">WLC Primary</option><option value="wlc-secondary">WLC Secondary</option><option value="mobile-zone-hq">HQ Mobile Zone</option><option value="mobile-zone-guest">Guest WiFi Zone</option><option value="mobile-zone-iot">IoT Device Zone</option><option value="branch-router-ny">NYC Branch Router</option><option value="branch-router-la">LA Branch Router</option><option value="branch-router-chi">Chicago Branch Router</option><option value="branch-router-lon">London Branch Router</option><option value="branch-router-tokyo">Tokyo Branch Router</option><option value="cloud-aws">AWS Cloud</option><option value="cloud-azure">Azure Cloud</option><option value="cloud-gcp">GCP Cloud</option><option value="isp-primary">ISP Primary</option><option value="isp-secondary">ISP Secondary</option><option value="proxy-server-1">Proxy Server 1</option><option value="proxy-server-2">Proxy Server 2</option><option value="vpn-concentrator">VPN Concentrator</option><option value="nac-server">NAC Server</option><option value="voip-cluster">VoIP Cluster</option><option value="video-conf">Video Conference</option><option value="security-cameras">Security Cameras</option><option value="dev-server-1">Dev Server 1</option><option value="dev-server-2">Dev Server 2</option><option value="test-environment">Test Environment</option><option value="erp-system">ERP System</option><option value="crm-system">CRM System</option><option value="endpoint-1000">Corporate Endpoints</option><option value="dist-switch-floor1">Floor 1 Switch</option><option value="dist-switch-floor2">Floor 2 Switch</option><option value="dist-switch-floor3">Floor 3 Switch</option><option value="dist-switch-floor4">Floor 4 Switch</option><option value="ap-floor1-zone1">AP Floor 1 Zone 1</option><option value="ap-floor2-zone1">AP Floor 2 Zone 1</option><option value="ap-floor3-zone1">AP Floor 3 Zone 1</option><option value="ap-floor4-zone1">AP Floor 4 Zone 1</option><option value="ups-dc-1">UPS DC-1</option><option value="ups-dc-2">UPS DC-2</option><option value="cooling-1">CRAC Unit 1</option><option value="cooling-2">CRAC Unit 2</option></select>
          <input type="color" id="add-line-color" value="#475569" title="Line color" style="width: 30px;height: 24px;border: 1px solid var(--toolbar-border);border-radius: 4px;cursor: pointer;background: transparent;padding: 0;">     
          <select id="add-line-direction" title="Line direction">
            <option value="none">No arrows</option>
            <option value="forward">→ Forward</option>
            <option value="backward">← Backward</option>
            <option value="both">↔ Both</option>
          </select>
          <button id="add-line-btn">Add</button>
        </div>
        <div class="topology-toolbar bulk-toolbar-desktop" id="bulk-toolbar" style="display: none">
          <button type="button" class="toolbar-close-btn" id="bulk-toolbar-close" title="Clear selection">✕</button>
          <label style="font-weight: 600; color: var(--accent)">Selected: <span id="bulk-count">0</span></label>
          <button id="bulk-align-left" title="Align left">⬅ Left</button>
          <button id="bulk-align-right" title="Align right">➡ Right</button>
          <button id="bulk-align-top" title="Align top">⬆ Top</button>
          <button id="bulk-align-bottom" title="Align bottom">⬇ Bottom</button>
          <button id="bulk-distribute-h" title="Distribute horizontally">↔ Distribute H</button>
          <button id="bulk-distribute-v" title="Distribute vertically">↕ Distribute V</button>
          <button id="bulk-clone" title="Clone selected">📋 Clone</button>
          <button id="bulk-delete" title="Delete selected" style="background: var(--danger); color: white;">Delete</button>
        </div>
        <div class="bulk-toolbar-mobile" id="bulk-toolbar-mobile" style="">
          <button type="button" id="bulk-mobile-btn" style="background: var(--accent);color: white;padding: 12px 20px;border-radius: 25px;font-weight: 600;font-size: 16px;box-shadow: 0 4px 12px rgba(0,0,0,0.3);border: none;cursor: pointer;display: flex;align-items: center;gap: 8px;">
          <span id="bulk-count-mobile">0</span>Selected</button>
        </div>
        <div id="bulk-actions-modal" style="display: none;position: fixed;bottom: 0;left: 0;right: 0;background: var(--panel-alt);border-top-left-radius: 20px;border-top-right-radius: 20px;padding: 20px;padding-bottom: env(safe-area-inset-bottom, 20px);box-shadow: 0 -4px 20px rgba(0,0,0,0.5);z-index: 10000;max-height: calc(100vh - 80px);overflow-y: auto;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            <h3 style="margin: 0; color: var(--accent); font-size: 20px;">
              <span id="bulk-count-modal">0</span> Nodes Selected
            </h3>
            <button id="bulk-modal-close" style="background: none;border: none;font-size: 24px;cursor: pointer;color: var(--text-main);padding: 0;width: 32px;height: 32px;">✕</button>
          </div>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
            <button id="bulk-align-left-mobile" class="bulk-action-btn">⬅<br><span style="font-size: 12px;">Align Left</span></button>
            <button id="bulk-align-right-mobile" class="bulk-action-btn">➡<br><span style="font-size: 12px;">Align Right</span></button>
            <button id="bulk-align-top-mobile" class="bulk-action-btn">⬆<br><span style="font-size: 12px;">Align Top</span></button>
            <button id="bulk-align-bottom-mobile" class="bulk-action-btn">⬇<br><span style="font-size: 12px;">Align Bottom</span></button>
            <button id="bulk-distribute-h-mobile" class="bulk-action-btn">↔<br><span style="font-size: 12px;">Distribute H</span></button>
            <button id="bulk-distribute-v-mobile" class="bulk-action-btn">↕<br><span style="font-size: 12px;">Distribute V</span></button>
            <button id="bulk-lock-mobile" class="bulk-action-btn">🔒<br><span style="font-size: 12px;">Lock Toggle</span></button>
            <button id="bulk-group-mobile" class="bulk-action-btn">⭕<br><span style="font-size: 12px;">Group Toggle</span></button>
            <button id="bulk-clone-mobile" class="bulk-action-btn">📋<br><span style="font-size: 12px;">Clone All</span></button>
            <button id="bulk-delete-mobile" class="bulk-action-btn" style="background: var(--danger); color: white;">🗑<br><span style="font-size: 12px;">Delete All</span></button>
          </div>
          <button id="bulk-clear-mobile" style="width: 100%;margin-top: 16px;padding: 14px;background: var(--panel-main);border: 1px solid var(--edge-main);border-radius: 8px;color: var(--text-main);font-size: 16px;cursor: pointer;">Clear Selection</button>
        </div>
        <div class="canvas-hint" id="canvas-hint">
          <ul>
            <li>Scroll to zoom</li>
            <li>Drag to pan</li>
            <li>Right click to clone and align</li>
            <li>Right click to select multiple</li>
			<li>Hold Shift + drag mouse for marquee selection</li>
            <li>You have the power</li>
            <li>Your time is NOW!</li>
          </ul>
        </div>
        <div class="legend-container" id="edge-legend" style="display: flex;"><div class="legend-title">Line Legend</div><button type="button" class="legend-close-btn">✕</button><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(85, 226, 8); cursor: pointer;"></span><span class="legend-label" contenteditable="true">ISP LINE</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(76, 0, 255); cursor: pointer;"></span><span class="legend-label" contenteditable="true">MY Guest NETWORK</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(128, 255, 0); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(251, 0, 255); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(255, 0, 208); cursor: pointer;"></span><span class="legend-label" contenteditable="true">iPhone (always guest iPhone)</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(249, 115, 22); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div></div>
        <div class="canvas-viewport" id="canvas-viewport">
          <svg id="map" viewBox="-74.99705309342698 -7.395887697909075 4069.861183597212 3052.395887697909" style=""><defs><marker id="arrow-forward" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto" markerUnits="strokeWidth"><path d="M0,0 L0,6 L9,3 z" fill="context-stroke"></path></marker><marker id="arrow-backward" markerWidth="10" markerHeight="10" refX="0" refY="3" orient="auto" markerUnits="strokeWidth"><path d="M9,0 L9,6 L0,3 z" fill="context-stroke"></path></marker></defs><rect x="100" y="100" width="3800" height="2800" fill="none" stroke="#4755694D" stroke-width="20" stroke-dasharray="10 5" rx="8"></rect><g id="canvas-grid"><line x1="100" y1="100" x2="100" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="150" y1="100" x2="150" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="200" y1="100" x2="200" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="250" y1="100" x2="250" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="300" y1="100" x2="300" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="350" y1="100" x2="350" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="400" y1="100" x2="400" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="450" y1="100" x2="450" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="500" y1="100" x2="500" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="550" y1="100" x2="550" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="600" y1="100" x2="600" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="650" y1="100" x2="650" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="700" y1="100" x2="700" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="750" y1="100" x2="750" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="800" y1="100" x2="800" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="850" y1="100" x2="850" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="900" y1="100" x2="900" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="950" y1="100" x2="950" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1000" y1="100" x2="1000" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1050" y1="100" x2="1050" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1100" y1="100" x2="1100" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="1150" y1="100" x2="1150" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1200" y1="100" x2="1200" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1250" y1="100" x2="1250" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1300" y1="100" x2="1300" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1350" y1="100" x2="1350" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="1400" y1="100" x2="1400" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1450" y1="100" x2="1450" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1500" y1="100" x2="1500" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1550" y1="100" x2="1550" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1600" y1="100" x2="1600" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="1650" y1="100" x2="1650" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1700" y1="100" x2="1700" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1750" y1="100" x2="1750" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1800" y1="100" x2="1800" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1850" y1="100" x2="1850" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="1900" y1="100" x2="1900" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1950" y1="100" x2="1950" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2000" y1="100" x2="2000" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2050" y1="100" x2="2050" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2100" y1="100" x2="2100" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="2150" y1="100" x2="2150" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2200" y1="100" x2="2200" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2250" y1="100" x2="2250" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2300" y1="100" x2="2300" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2350" y1="100" x2="2350" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="2400" y1="100" x2="2400" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2450" y1="100" x2="2450" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2500" y1="100" x2="2500" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2550" y1="100" x2="2550" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2600" y1="100" x2="2600" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="2650" y1="100" x2="2650" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2700" y1="100" x2="2700" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2750" y1="100" x2="2750" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2800" y1="100" x2="2800" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2850" y1="100" x2="2850" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="2900" y1="100" x2="2900" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2950" y1="100" x2="2950" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3000" y1="100" x2="3000" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3050" y1="100" x2="3050" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3100" y1="100" x2="3100" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="3150" y1="100" x2="3150" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3200" y1="100" x2="3200" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3250" y1="100" x2="3250" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3300" y1="100" x2="3300" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3350" y1="100" x2="3350" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="3400" y1="100" x2="3400" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3450" y1="100" x2="3450" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3500" y1="100" x2="3500" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3550" y1="100" x2="3550" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3600" y1="100" x2="3600" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="3650" y1="100" x2="3650" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3700" y1="100" x2="3700" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3750" y1="100" x2="3750" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3800" y1="100" x2="3800" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3850" y1="100" x2="3850" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="3900" y1="100" x2="3900" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="100" x2="3900" y2="100" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="150" x2="3900" y2="150" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="200" x2="3900" y2="200" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="250" x2="3900" y2="250" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="300" x2="3900" y2="300" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="350" x2="3900" y2="350" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="400" x2="3900" y2="400" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="450" x2="3900" y2="450" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="500" x2="3900" y2="500" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="550" x2="3900" y2="550" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="600" x2="3900" y2="600" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="650" x2="3900" y2="650" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="700" x2="3900" y2="700" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="750" x2="3900" y2="750" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="800" x2="3900" y2="800" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="850" x2="3900" y2="850" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="900" x2="3900" y2="900" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="950" x2="3900" y2="950" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1000" x2="3900" y2="1000" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1050" x2="3900" y2="1050" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1100" x2="3900" y2="1100" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="1150" x2="3900" y2="1150" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1200" x2="3900" y2="1200" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1250" x2="3900" y2="1250" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1300" x2="3900" y2="1300" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1350" x2="3900" y2="1350" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="1400" x2="3900" y2="1400" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1450" x2="3900" y2="1450" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1500" x2="3900" y2="1500" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1550" x2="3900" y2="1550" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1600" x2="3900" y2="1600" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="1650" x2="3900" y2="1650" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1700" x2="3900" y2="1700" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1750" x2="3900" y2="1750" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1800" x2="3900" y2="1800" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1850" x2="3900" y2="1850" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="1900" x2="3900" y2="1900" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1950" x2="3900" y2="1950" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2000" x2="3900" y2="2000" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2050" x2="3900" y2="2050" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2100" x2="3900" y2="2100" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="2150" x2="3900" y2="2150" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2200" x2="3900" y2="2200" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2250" x2="3900" y2="2250" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2300" x2="3900" y2="2300" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2350" x2="3900" y2="2350" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="2400" x2="3900" y2="2400" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2450" x2="3900" y2="2450" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2500" x2="3900" y2="2500" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2550" x2="3900" y2="2550" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2600" x2="3900" y2="2600" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="2650" x2="3900" y2="2650" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2700" x2="3900" y2="2700" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2750" x2="3900" y2="2750" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2800" x2="3900" y2="2800" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2850" x2="3900" y2="2850" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="2900" x2="3900" y2="2900" stroke="#47556933" stroke-width="1"></line></g><g class="rect-group" data-rect-id="rect-1765238219615"><rect class="rect-shape" x="2680.053955078125" y="251.44879150390625" width="814.10400390625" height="389.26678466796875" style="fill: rgb(236, 9, 153); fill-opacity: 0.3; stroke: rgb(236, 9, 153); stroke-width: 2px; stroke-dasharray: none; cursor: move;"></rect><g class="rect-delete-btn" style="cursor: pointer; display: none;"><circle cx="3484.157958984375" cy="261.44879150390625" r="12" style="fill: rgb(245, 101, 101); stroke: white; stroke-width: 2;"></circle><text x="3484.157958984375" y="261.44879150390625" text-anchor="middle" dominant-baseline="middle" style="fill: white; font-size: 16px; font-weight: bold; pointer-events: none;">×</text></g></g><path d="M 2071.640165880771 218.24354238566275 Q 2069.3039587352528 345.82772790170964 2066.9677515897347 473.4119134177565" fill="none" class="edge" data-edge-id="internet-internet-copy-1765238145151" data-from="internet" data-to="internet-copy" style="stroke: rgb(85, 226, 8); stroke-width: 4;"></path><path d="M 2071.640165880771 218.24354238566275 Q 2069.3039587352528 345.82772790170964 2066.9677515897347 473.4119134177565" fill="none" data-edge-id="internet-internet-copy-1765238145151" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 1921.3019190702034 570.8918786277175 1775.6360865506722 668.3718438376784" fill="none" class="edge" data-edge-id="internet-copy-opnsense-copy-1765238187451" data-from="internet-copy" data-to="opnsense-copy" style="stroke: rgb(76, 0, 255); stroke-width: 4;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 1921.3019190702034 570.8918786277175 1775.6360865506722 668.3718438376784" fill="none" data-edge-id="internet-copy-opnsense-copy-1765238187451" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2000.8787827715962 627.8447547749242 1934.7898139534577 782.2775961320921" fill="none" class="edge" data-edge-id="internet-copy-docker-copy-1765238242477" data-from="internet-copy" data-to="docker-copy" style="stroke: rgb(76, 0, 255); stroke-width: 4;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2000.8787827715962 627.8447547749242 1934.7898139534577 782.2775961320921" fill="none" data-edge-id="internet-copy-docker-copy-1765238242477" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2112.546995662221 620.5620704487524 2158.1262397347077 767.7122274797483" fill="none" class="edge" data-edge-id="internet-copy-docker-copy-1-1765238244637" data-from="internet-copy" data-to="docker-copy-1" style="stroke: rgb(76, 0, 255); stroke-width: 4;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2112.546995662221 620.5620704487524 2158.1262397347077 767.7122274797483" fill="none" data-edge-id="internet-copy-docker-copy-1-1765238244637" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2206.4130845294085 552.590055067893 2345.8584174690827 631.7681967180296" fill="none" class="edge" data-edge-id="internet-copy-docker-copy-2-1765238246233" data-from="internet-copy" data-to="docker-copy-2" style="stroke: rgb(76, 0, 255); stroke-width: 4;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2206.4130845294085 552.590055067893 2345.8584174690827 631.7681967180296" fill="none" data-edge-id="internet-copy-docker-copy-2-1765238246233" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2071.640165880771 218.24354238566275 Q 2414.759822984287 262.92762699742593 2757.879480087803 307.6117116091891" fill="none" class="edge" data-edge-id="internet-opnsense-copy-1-1765238266117" data-from="internet" data-to="opnsense-copy-1" style="stroke: rgb(128, 255, 0); stroke-width: 4;"></path><path d="M 2071.640165880771 218.24354238566275 Q 2414.759822984287 262.92762699742593 2757.879480087803 307.6117116091891" fill="none" data-edge-id="internet-opnsense-copy-1-1765238266117" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2757.879480087803 307.6117116091891 Q 2979.171899521397 314.04065142852505 3200.4643189549906 320.469591247861" fill="none" class="edge" data-edge-id="opnsense-copy-1-dns-1765238347996" data-from="opnsense-copy-1" data-to="dns" style="stroke: rgb(251, 0, 255); stroke-width: 4;"></path><path d="M 2757.879480087803 307.6117116091891 Q 2979.171899521397 314.04065142852505 3200.4643189549906 320.469591247861" fill="none" data-edge-id="opnsense-copy-1-dns-1765238347996" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 3200.4643189549906 320.469591247861 Q 3094.0802247167094 404.02690325957974 2987.696130478428 487.5842152712985" fill="none" class="edge" data-edge-id="dns-desktop-1765238386101" data-from="dns" data-to="desktop" style="stroke: rgb(255, 0, 208); stroke-width: 4;"></path><path d="M 3200.4643189549906 320.469591247861 Q 3094.0802247167094 404.02690325957974 2987.696130478428 487.5842152712985" fill="none" data-edge-id="dns-desktop-1765238386101" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 3312.857751572178 502.58220111114224 Q 3256.6610352635844 411.5258961795016 3200.4643189549906 320.469591247861" fill="none" class="edge" data-edge-id="phone-dns-1765238391156" data-from="phone" data-to="dns" style="stroke: rgb(255, 0, 208); stroke-width: 4;"></path><path d="M 3312.857751572178 502.58220111114224 Q 3256.6610352635844 411.5258961795016 3200.4643189549906 320.469591247861" fill="none" data-edge-id="phone-dns-1765238391156" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><polyline class="edge" data-edge-id="custom-1765238841477" fill="none" marker-start="url(#arrow-backward)" marker-end="url(#arrow-forward)" points="2905.255615234375,805.3433837890625 3189.95556640625,1005.8710327148438 2788.900390625,1008.3466796875" style="stroke: rgb(249, 115, 22); stroke-width: 4; stroke-dasharray: none;"></polyline><polyline points="2905.255615234375,805.3433837890625 3189.95556640625,1005.8710327148438 2788.900390625,1008.3466796875" data-edge-id="custom-1765238841477" style="fill: none; stroke: transparent; stroke-width: 20; cursor: pointer;"></polyline><g class="node-group" data-node-id="internet" transform="translate(2071.640165880771,218.24354238566275)" style="cursor: grab;"><circle r="127.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><rect x="-85" y="-85" width="170" height="170" rx="4" class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"></rect><text class="node-label" x="0" y="-23.8" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Internet</text><text class="node-sub" x="0" y="34" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="internet-copy" transform="translate(2066.9677515897347,473.4119134177565)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-55" y="-44" width="110" height="88" rx="4"></rect><line x1="-46.75" y1="-27.5" x2="46.75" y2="-27.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="-2.75" x2="46.75" y2="-2.75" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="22" x2="46.75" y2="22" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="-44" x2="-27.5" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="-44" x2="11" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="-19.25" x2="-8.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="-19.25" x2="30.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="5.5" x2="-27.5" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="5.5" x2="11" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="30.25" x2="-8.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="30.25" x2="30.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">OPNSENSE</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="opnsense-copy" transform="translate(1775.6360865506722,668.3718438376784)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-55" y="-44" width="110" height="88" rx="4"></rect><line x1="-46.75" y1="-27.5" x2="46.75" y2="-27.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="-2.75" x2="46.75" y2="-2.75" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="22" x2="46.75" y2="22" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="-44" x2="-27.5" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="-44" x2="11" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="-19.25" x2="-8.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="-19.25" x2="30.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="5.5" x2="-27.5" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="5.5" x2="11" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="30.25" x2="-8.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="30.25" x2="30.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Docker</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="docker-copy" transform="translate(1934.7898139534577,782.2775961320921)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-55" y="-44" width="110" height="88" rx="4"></rect><line x1="-46.75" y1="-27.5" x2="46.75" y2="-27.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="-2.75" x2="46.75" y2="-2.75" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="22" x2="46.75" y2="22" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="-44" x2="-27.5" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="-44" x2="11" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="-19.25" x2="-8.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="-19.25" x2="30.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="5.5" x2="-27.5" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="5.5" x2="11" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="30.25" x2="-8.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="30.25" x2="30.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Docker2</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="docker-copy-1" transform="translate(2158.1262397347077,767.7122274797483)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-55" y="-44" width="110" height="88" rx="4"></rect><line x1="-46.75" y1="-27.5" x2="46.75" y2="-27.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="-2.75" x2="46.75" y2="-2.75" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="22" x2="46.75" y2="22" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="-44" x2="-27.5" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="-44" x2="11" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="-19.25" x2="-8.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="-19.25" x2="30.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="5.5" x2="-27.5" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="5.5" x2="11" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="30.25" x2="-8.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="30.25" x2="30.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Docker3</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="docker-copy-2" transform="translate(2345.8584174690827,631.7681967180296)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-55" y="-44" width="110" height="88" rx="4"></rect><line x1="-46.75" y1="-27.5" x2="46.75" y2="-27.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="-2.75" x2="46.75" y2="-2.75" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="22" x2="46.75" y2="22" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="-44" x2="-27.5" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="-44" x2="11" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="-19.25" x2="-8.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="-19.25" x2="30.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="5.5" x2="-27.5" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="5.5" x2="11" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="30.25" x2="-8.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="30.25" x2="30.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Docker 4</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="opnsense-copy-1" transform="translate(2757.879480087803,307.6117116091891)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-55" y="-44" width="110" height="88" rx="4"></rect><line x1="-46.75" y1="-27.5" x2="46.75" y2="-27.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="-2.75" x2="46.75" y2="-2.75" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="22" x2="46.75" y2="22" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="-44" x2="-27.5" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="-44" x2="11" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="-19.25" x2="-8.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="-19.25" x2="30.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="5.5" x2="-27.5" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="5.5" x2="11" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="30.25" x2="-8.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="30.25" x2="30.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">OPNSENSE GUEST</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="phone" transform="translate(3312.857751572178,502.58220111114224)" style="cursor: grab;"><circle r="181.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-54.45" y="-121" width="108.9" height="242" rx="8"></rect><rect x="-45.980000000000004" y="-102.85" width="91.96000000000001" height="193.60000000000002" rx="4" style="fill: rgb(30, 41, 59);"></rect><rect x="-18.15" y="99.22" width="36.3" height="7.26" rx="2" style="fill: rgb(71, 85, 105);"></rect></g><text class="node-label" x="0" y="-33.88" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Phone</text><text class="node-sub" x="0" y="48.400000000000006" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="desktop" transform="translate(2987.696130478428,487.5842152712985)" style="cursor: grab;"><circle r="220.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-132.3" y="-117.60000000000001" width="264.6" height="176.4" rx="4"></rect><rect x="-110.25" y="-95.55" width="220.5" height="132.3" rx="2" style="fill: rgb(30, 41, 59);"></rect><rect x="-22.05" y="58.800000000000004" width="44.1" height="44.1"></rect><rect x="-73.5" y="102.89999999999999" width="147" height="22.05" rx="2"></rect></g><text class="node-label" x="0" y="-41.160000000000004" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Desktop</text><text class="node-sub" x="0" y="58.800000000000004" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="dns" transform="translate(3200.4643189549906,320.469591247861)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><path d="
             M -44 11
             Q -60.50000000000001 11 -60.50000000000001 -5.5
             Q -60.50000000000001 -27.5 -38.5 -27.5
             Q -38.5 -49.5 -11 -49.5
             Q 5.5 -60.50000000000001 27.5 -44
             Q 55 -44 60.50000000000001 -16.5
             Q 71.5 -5.5 60.50000000000001 11
             Q 60.50000000000001 27.5 38.5 27.5
             L -27.5 27.5
             Q -49.5 27.5 -49.5 11
             Z
            " class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"></path><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">DNS</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="racked" transform="translate(2600.8697010779656,975.5665527522032)" style="cursor: grab;"><circle r="205.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-164.4" y="-82.2" width="328.8" height="164.4" rx="4"></rect><line x1="-123.3" y1="-41.1" x2="-123.3" y2="41.1" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="-54.8" y1="-41.1" x2="-54.8" y2="41.1" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="13.700000000000003" y1="-41.1" x2="13.700000000000003" y2="41.1" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><circle cx="123.3" cy="0" r="13.700000000000001" style="fill: rgb(74, 222, 128);"></circle></g><text class="node-label" x="0" y="-38.36000000000001" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Racked</text><text class="node-sub" x="0" y="54.800000000000004" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;"></text></g><g class="text-group" data-text-id="text-1765238422602"><text class="text-element" x="2402.130859375" y="736.7828979492188" dominant-baseline="middle" style="fill: rgb(226, 232, 240); font-size: 48px; font-weight: normal; font-style: normal; text-anchor: start; text-decoration: none; opacity: 1; cursor: move; user-select: none;"><tspan x="2402.130859375" dy="0">Double click on desktop</tspan><tspan x="2402.130859375" dy="57.599999999999994">or long press on mobile</tspan><tspan x="2402.130859375" dy="57.599999999999994">to enter rack canvas view</tspan></text><g class="text-delete-btn" style="cursor: pointer; display: none;"><circle cx="2422.130859375" cy="688.7828979492188" r="12" style="fill: rgb(245, 101, 101); stroke: white; stroke-width: 2;"></circle><text x="2422.130859375" y="688.7828979492188" text-anchor="middle" dominant-baseline="middle" style="fill: white; font-size: 16px; font-weight: bold; pointer-events: none;">×</text></g></g></svg>
        </div>
        <div class="minimap-zoom-wrapper" id="minimap-zoom-wrapper" style="display: block;">
          <button type="button" class="minimap-close-btn" id="minimap-close-btn" title="Hide map &amp; zoom">✕</button>
          <div class="minimap-container" id="minimap-container">
            <svg id="minimap" viewBox="0 0 4000 3000">
              <line x1="2071.640165880771" y1="218.24354238566275" x2="2066.9677515897347" y2="473.4119134177565" class="minimap-edge"></line><line x1="2066.9677515897347" y1="473.4119134177565" x2="1775.6360865506722" y2="668.3718438376784" class="minimap-edge"></line><line x1="2066.9677515897347" y1="473.4119134177565" x2="1934.7898139534577" y2="782.2775961320921" class="minimap-edge"></line><line x1="2066.9677515897347" y1="473.4119134177565" x2="2158.1262397347077" y2="767.7122274797483" class="minimap-edge"></line><line x1="2066.9677515897347" y1="473.4119134177565" x2="2345.8584174690827" y2="631.7681967180296" class="minimap-edge"></line><line x1="2071.640165880771" y1="218.24354238566275" x2="2757.879480087803" y2="307.6117116091891" class="minimap-edge"></line><line x1="2757.879480087803" y1="307.6117116091891" x2="3200.4643189549906" y2="320.469591247861" class="minimap-edge"></line><line x1="3200.4643189549906" y1="320.469591247861" x2="2987.696130478428" y2="487.5842152712985" class="minimap-edge"></line><line x1="3312.857751572178" y1="502.58220111114224" x2="3200.4643189549906" y2="320.469591247861" class="minimap-edge"></line><circle cx="2071.640165880771" cy="218.24354238566275" r="40" class="minimap-node"></circle><circle cx="2066.9677515897347" cy="473.4119134177565" r="40" class="minimap-node"></circle><circle cx="1775.6360865506722" cy="668.3718438376784" r="40" class="minimap-node"></circle><circle cx="1934.7898139534577" cy="782.2775961320921" r="40" class="minimap-node"></circle><circle cx="2158.1262397347077" cy="767.7122274797483" r="40" class="minimap-node"></circle><circle cx="2345.8584174690827" cy="631.7681967180296" r="40" class="minimap-node"></circle><circle cx="2757.879480087803" cy="307.6117116091891" r="40" class="minimap-node"></circle><circle cx="3312.857751572178" cy="502.58220111114224" r="40" class="minimap-node"></circle><circle cx="2987.696130478428" cy="487.5842152712985" r="40" class="minimap-node"></circle><circle cx="3200.4643189549906" cy="320.469591247861" r="40" class="minimap-node"></circle><circle cx="2600.8697010779656" cy="975.5665527522032" r="40" class="minimap-node"></circle><rect class="minimap-viewport" id="minimap-viewport" x="-74.99705309342698" y="-7.395887697909075" width="4069.861183597212" height="3052.395887697909"></rect>
            </svg>
          </div>
          <div class="zoom-toolbar" id="zoom-toolbar">
            <button id="zoom-in-btn" title="Zoom in">+</button>
            <div class="zoom-level" id="zoom-level">98%</div>
            <button id="zoom-out-btn" title="Zoom out">-</button>
            <div class="divider"></div>
            <button id="zoom-fit-btn" title="Fit to view">[ ]</button>
            <button id="zoom-reset-btn" title="Reset view">R</button>
          </div>
        </div>
        <button type="button" id="edge-legend-mini" class="legend-mini-btn" style="bottom: 10px; display: none;">Line Legend</button>
        <button type="button" id="minimap-mini" class="legend-mini-btn" style="right: 10px; left: auto; bottom: 10px; display: none;">Map</button>
        <button type="button" id="draw-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: 10px; right: auto;">Draw</button>
        <button type="button" id="topology-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: auto; right: 40px;">Add Line</button></section>
      <aside class="details-panel" id="details-panel">
        <div class="sidebar-resizer" id="sidebar-resizer">
          <svg class="resizer-icon" width="6" height="40" viewBox="0 0 6 40" xmlns="http://www.w3.org/2000/svg">
            <circle cx="3" cy="14" r="2"></circle>
            <circle cx="3" cy="20" r="2"></circle>
            <circle cx="3" cy="26" r="2"></circle>
          </svg>
        </div>
        <div class="mobile-footer-resizer" id="mobile-footer-resizer">
          <svg class="resizer-icon" width="40" height="6" viewBox="0 0 40 6" xmlns="http://www.w3.org/2000/svg">
            <circle cx="14" cy="3" r="2"></circle>
            <circle cx="20" cy="3" r="2"></circle>
            <circle cx="26" cy="3" r="2"></circle>
          </svg>
        </div>
        <div id="node-panel" style="display: none;">
          <div class="details-name editable-text" id="node-name">Core Router 1</div>
          <div class="details-ip editable-text" id="node-ip">10.0.0.1</div>
          <div class="details-role" id="node-role">Core Routing</div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px;">MAC:</span>
            <span class="editable-text" id="node-mac" style="margin-left: 8px; font-size: 14px;">00:1A:2B:3C:4D:01</span>
          </div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px;">Rack Unit:</span>
            <span class="editable-text" id="node-rack" style="margin-left: 8px; font-size: 14px;">--</span>
          </div>
          <div class="details-info-row" id="uheight-row" style="display: none;">
            <span style="color: var(--text-soft); font-size: 14px;">U Height:</span>
            <span class="editable-text" id="node-uheight" style="margin-left: 8px; font-size: 14px;">2U</span>
          </div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px;">Layer:</span>
            <select id="node-layer" style="margin-left: 8px; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;">
              <option value="physical">Physical</option>
              <option value="logical">Logical</option>
              <option value="security">Security</option>
              <option value="application">Application</option>
            </select>
          </div>
          <div class="details-info-row" id="assigned-rack-row" style="display: flex;">
            <span style="color: var(--text-soft); font-size: 14px;">Assigned Rack:</span>
            <select id="node-assigned-rack" style="margin-left: 8px; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;"><option value="">None</option><option value="racked">Racked</option></select>
          </div>
          <div class="details-info-row" id="rack-capacity-row" style="display: none;">
            <span style="color: var(--text-soft); font-size: 14px;">Rack Capacity:</span>
            <select id="node-rack-capacity" style="margin-left: 8px; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;">
              <option value="42">42U</option>
              <option value="48">48U</option>
              <option value="24">24U</option>
              <option value="12">12U</option>
			  <option value="6">6U</option>
            </select>
          </div>
		  <details id="rack-contents-section" style="display: none; margin-top: 12px; margin-bottom: 12px; padding: 10px; background: var(--panel-alt); border-radius: 6px;" open="">
            <summary style="color: var(--accent); font-weight: 600; font-size: 14px; cursor: pointer;">Nodes in Rack (<span id="rack-contents-count">0</span>)</summary>
            <div id="rack-contents-list" style="max-height: 200px; overflow-y: auto; margin-top: 8px;"></div>
          </details>
          <div class="badge-row" id="node-tags"><span class="badge" style="cursor: pointer; position: relative;"><span>core</span><span style="opacity: 0.6; margin-left: 4px; font-size: 10px;"> ✕</span></span><span class="badge" style="cursor: pointer; position: relative;"><span>tier-1</span><span style="opacity: 0.6; margin-left: 4px; font-size: 10px;"> ✕</span></span><span class="badge" style="cursor: pointer; position: relative;"><span>redundant</span><span style="opacity: 0.6; margin-left: 4px; font-size: 10px;"> ✕</span></span><span class="badge" style="cursor: pointer; opacity: 0.6; border-style: dashed;">+ Add Tag</span></div>
          <div class="size-controls">
            <label>Size:</label>
            <input type="range" id="size-slider" min="20" max="200" value="55">
            <span id="size-value">55</span>
            <button id="reset-size">Reset</button>
          </div>
          <details class="style-section">
            <summary>Styling</summary>
            <div class="style-content">
              <div class="style-row">
                <label>Screen:</label>
                <select id="style-scope">
                  <option value="all">All</option>
                  <option value="desktop">Desktop</option>
                  <option value="tablet">Tablet</option>
                  <option value="mobile">Mobile</option>
                  <option value="fold">Fold</option>
                </select>
              </div>
              <div class="style-row">
                <label>Shape:</label>
                <select id="shape-select">
                  <optgroup label="Basic Shapes">
				  <option value="circle">Circle</option>
				  <option value="square">Square</option>
				  <option value="rectangle">Rectangle</option>
				  <option value="triangle">Triangle</option>
				  <option value="hexagon">Hexagon</option>
				  <option value="diamond">Diamond</option>
				  <option value="star">Star</option>
				  <option value="stop-sign">Stop Sign</option>
				  <option value="octagon">Octagon</option>
				  <option value="pentagon">Pentagon</option>
				  <option value="cross">Cross</option>
				  <option value="rounded-square">Rounded Square</option>
				  <option value="pill">Pill</option>
				  <option value="parallelogram">Parallelogram</option>
				  <option value="trapezoid">Trapezoid</option>
				</optgroup>
			  <optgroup label="Computers &amp; Devices">
			      <option value="server">Server</option>
				  <option value="pc">PC / Desktop</option>
				  <option value="laptop">Laptop</option>
				  <option value="phone">Phone / Mobile</option>
				  <option value="printer">Printer</option>
				  <option value="pi">Raspberry Pi</option>
				  <option value="sensor">Sensor / IoT</option>
			  </optgroup>
			  <optgroup label="Network Equipment">
				  <option value="router">Router</option>
				  <option value="switch">Switch</option>
				  <option value="firewall">Firewall</option>
				  <option value="access-point">Access Point</option>
				  <option value="load-balancer">Load Balancer</option>
				  <option value="gateway">Gateway</option>
				  <option value="vpn">VPN / Tunnel</option>
				  <option value="nas">NAS / Storage</option>
			  </optgroup>
			  <optgroup label="Cloud &amp; Services">
			      <option value="cloud">Cloud</option>
				  <option value="database">Database</option>
				  <option value="docker">Docker</option>
				  <option value="container">Container</option>
				  <option value="vm">Virtual Machine</option>
				  <option value="kubernetes">Kubernetes</option>
				  <option value="api">API / Endpoint</option>
				  <option value="queue">Queue / Message</option>
				  <option value="lambda">Lambda / Function</option>
				  <option value="bucket">Bucket / S3</option>
			  </optgroup>
			  <optgroup label="Security &amp; Monitoring">
				  <option value="shield">Shield</option>
				  <option value="camera">Camera / CCTV</option>
				  <option value="monitor">Monitor / Dashboard</option>
			  </optgroup>
             </select>
              </div>
              <div class="style-row">
                <label>Fill Color:</label>
                <input type="color" id="circle-color" value="#1e293b">
              </div>
              <div class="style-row">
                <label>Border Color:</label>
                <input type="color" id="circle-border" value="#475569">
              </div>
              <div class="style-row">
                <label>Title Color:</label>
                <input type="color" id="title-color" value="#e2e8f0">
              </div>
              <div class="style-row">
                <label>Title Font:</label>
                <select id="title-font">
                  <option value="system-ui, sans-serif"> System UI </option>
                  <option value="monospace">Monospace</option>
                  <option value="serif">Serif</option>
                  <option value="cursive">Cursive</option>
                  <option value="'Courier New', monospace"> Courier </option>
                  <option value="Arial, sans-serif">Arial</option>
                  <option value="'Times New Roman', serif"> Times </option>
                </select>
              </div>
              <div class="style-row">
                <label>Title Size:</label>
                <input type="number" id="title-size" min="8" max="100" value="18">
              </div>
              <div class="style-row">
                <label>Sub Color:</label>
                <input type="color" id="sub-color" value="#94a3b8">
              </div>
              <div class="style-row">
                <label>Sub Font:</label>
                <select id="sub-font">
                  <option value="system-ui, sans-serif"> System UI </option>
                  <option value="monospace">Monospace</option>
                  <option value="serif">Serif</option>
                  <option value="cursive">Cursive</option>
                  <option value="'Courier New', monospace"> Courier </option>
                  <option value="Arial, sans-serif">Arial</option>
                  <option value="'Times New Roman', serif"> Times </option>
                </select>
              </div>
              <div class="style-row">
                <label>Sub Size:</label>
                <input type="number" id="sub-size" min="6" max="80" value="13">
              </div>
              <div style="margin-top: 12px;padding-top: 10px;border-top: 1px solid var(--edge-main);">
                <div style="
                  font-size: 12px;
                  color: var(--text-soft);
                  margin-bottom: 8px;
                  text-transform: uppercase;
                  "> Text Position </div>
                <div class="style-row">
                  <label>Name Y:</label>
                  <input type="number" id="title-offset-y" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>Name X:</label>
                  <input type="number" id="title-offset-x" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>IP Y:</label>
                  <input type="number" id="sub-offset-y" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>IP X:</label>
                  <input type="number" id="sub-offset-x" min="-100" max="100" value="0" style="width: 60px">
                </div>
              </div>
              <button id="reset-styles" style="width: 100%;margin-top: 10px;padding: 8px;background: var(--panel);color: var(--text-main);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: clamp(13px, 1.5vw, 17px);">Reset Styles</button>
            </div>
          </details>
          <div class="section-label">Notes</div>
          <ul class="list" id="node-notes"><li><span style="flex: 1 1 0%;">Primary core router</span><span class="delete-note">✕</span></li><li><span style="flex: 1 1 0%;">BGP peering enabled</span><span class="delete-note">✕</span></li></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-note-input" placeholder="Type new note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-note-btn" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-node-btn" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: rgb(255, 255, 255);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;width: 100%;">Delete Node</button>
        </div>
        <div id="edge-panel" style="display: none">
          <div class="details-name" id="edge-title">Custom line</div>
          <div class="style-row" style="margin-top: 10px">
            <label>Width:</label>
            <input type="number" id="edge-width" min="1" max="20" value="4">
          </div>
          <div class="style-row">
            <label>Color:</label>
            <input type="color" id="edge-color" value="#475569">
          </div>
          <div class="style-row">
            <label>Line Style:</label>
            <select id="edge-line-style">
              <option value="solid">Solid</option>
              <option value="dashed">Dashed</option>
              <option value="dotted">Dotted</option>
            </select>
          </div>
          <div class="style-row">
            <label>Direction:</label>
            <select id="edge-direction">
              <option value="none">No arrows</option>
              <option value="forward">→ Forward</option>
              <option value="backward">← Backward</option>
              <option value="both">↔ Bidirectional</option>
            </select>
          </div>
          <div class="style-row" id="edge-from-port-row" style="display: none;">
            <label>From Port:</label>
            <input type="text" id="edge-from-port" placeholder="e.g. eth0, gi0/1" style="flex: 1;">
          </div>
          <div class="style-row" id="edge-to-port-row" style="display: none;">
            <label>To Port:</label>
            <input type="text" id="edge-to-port" placeholder="e.g. eth1, gi0/2" style="flex: 1;">
          </div>
          <div class="section-label">Line Notes</div>
          <ul class="list" id="edge-notes"></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-edge-note" placeholder="Add note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-edge-note" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-edge" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Delete Line</button>
        </div>
        <div id="rect-panel" style="display: none">
          <div class="details-name" id="rect-title">Zone</div>
          <div class="style-row" id="rect-fill-row" style="margin-top: 10px">
            <label>Fill Color:</label>
            <input type="color" id="rect-color" value="#f97316">
          </div>
          <div class="style-row">
            <label>Border Color:</label>
            <input type="color" id="rect-border-color" value="#f97316">
          </div>
          <div class="style-row">
            <label>Border Width:</label>
            <input type="number" id="rect-border-width" min="0" max="20" value="2">
          </div>
          <div class="style-row">
            <label>Style:</label>
            <select id="rect-style-select">
              <option value="filled">Filled</option>
              <option value="outlined">Outlined</option>
            </select>
          </div>
          <div class="style-row">
            <label>Line Style:</label>
            <select id="rect-line-style">
              <option value="solid">Solid</option>
              <option value="dashed">Dashed</option>
              <option value="dotted">Dotted</option>
            </select>
          </div>
          <div class="section-label">Zone Notes</div>
          <ul class="list" id="rect-notes"></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-rect-note" placeholder="Add note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-rect-note" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-rect" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Delete Zone</button>
        </div>
        <div id="text-panel" style="display: none">
          <div class="details-name" id="text-title">Text Element</div>
          <div class="style-row" style="margin-top: 10px">
            <label>Content:</label>
            <textarea id="text-content" placeholder="Enter text..." style="width: 100%;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: 14px;min-height: 80px;resize: vertical;font-family: inherit;"></textarea>
          </div>
          <div class="style-row">
            <label>Font Size:</label>
            <input type="number" id="text-font-size" min="8" max="200" value="18" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);">
          </div>
          <div class="style-row">
            <label>Color:</label>
            <input type="color" id="text-color" value="#e2e8f0">
          </div>
          <div class="style-row">
            <label>Font Weight:</label>
            <select id="text-font-weight" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="normal">Normal</option>
              <option value="bold">Bold</option>
              <option value="600">Semi-Bold</option>
              <option value="300">Light</option>
            </select>
          </div>
          <div class="style-row">
            <label>Font Style:</label>
            <select id="text-font-style" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="normal">Normal</option>
              <option value="italic">Italic</option>
            </select>
          </div>
          <div class="style-row">
            <label>Text Align:</label>
            <select id="text-align" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="start">Left</option>
              <option value="middle">Center</option>
              <option value="end">Right</option>
            </select>
          </div>
          <div class="style-row">
            <label>Text Decoration:</label>
            <select id="text-decoration" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="none">None</option>
              <option value="underline">Underline</option>
              <option value="line-through">Strike Through</option>
            </select>
          </div>
          <div class="style-row">
            <label>Background:</label>
            <input type="color" id="text-bg-color" value="#000000">
            <label style="margin-left: 10px; display: flex; align-items: center; gap: 6px;">
            <input type="checkbox" id="text-bg-enabled" style="cursor: pointer;">
            <span style="font-size: 13px;">Enable</span>
            </label>
          </div>
          <div class="style-row">
            <label>Opacity:</label>
            <input type="range" id="text-opacity" min="0" max="1" step="0.1" value="1" style="flex: 1">
            <span id="text-opacity-val" style="min-width: 35px; text-align: right">100%</span>
          </div>
          <button id="delete-text" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;width: 100%;"> Delete Text </button>
        </div>
        <details class="style-section" open="">
          <summary>Page Layout</summary>
          <div class="style-content">
            <div style="padding: 12px; background: var(--panel-alt); border-radius: 6px; color: var(--text-soft); font-size: 13px; line-height: 1.6;">
              <strong style="color: var(--accent); display: block; margin-bottom: 8px;">Drag to Resize:</strong>
              • <strong>Header:</strong> Drag the bottom edge of the header bar<br>
              • <strong>Sidebar:</strong> Drag the left edge of the sidebar panel<br>
              • <strong>Mobile:</strong> Drag the top edge of the footer panel<br>
              <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--edge-main); font-size: 12px;">
                Hover over panel edges to see resize handles
              </div>
            </div>
          </div>
        </details>
      </aside>
    </main>
    <script id="nodes-json" type="application/json">{}</script>
    <script id="topology-state" type="application/json">ENCRYPTED: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</script>
    <script>
      const BASE_NODE_DATA = JSON.parse(document.getElementById("nodes-json").textContent, );
      let currentNodeId = "host";
      let textDrawMode = false;
      let currentEdgeId = null;
      let currentStyleScope = "all";
      let NODE_DATA = {};
      let EDGE_DATA = {
       list: []
      };
      let currentRectId = null;
      let currentTextId = null;
      let rectDrawMode = false;
      let RECT_DATA = {
       list: []
      };
      let TEXT_DATA = {
       list: []
      };
      let EDGE_LEGEND = {};
      let freeDrawMode = false;
      let savedPositions = {};
      let savedSizes = {};
      let savedStyles = {};
      let legendCollapsed = false;
      let minimapCollapsed = false;
      let drawToolbarCollapsed = false;
      let activeLayers = new Set(["physical", "logical", "security", "application"]);
      let currentView = {
       mode: "topology",  
       rackId: null      
      };
      let savedTopologyView = null; 
      let topologyToolbarCollapsed = false;
      let legendMiniBtn = null;
      let minimapMiniBtn = null;
      let drawToolbarMiniBtn = null;
      let topologyToolbarMiniBtn = null;
      
      let undoStack = [];
      let redoStack = [];
      const MAX_UNDO_STACK = 50;
      
      let selectedNodes = new Set();
      let selectedEdges = new Set();
      let selectedRects = new Set();
      let selectedTexts = new Set();
      let isSelecting = false;
      let selectionStart = null;
      let preDragSelectedNodes = new Set();
      let preDragSelectedEdges = new Set();
      let preDragSelectedRects = new Set();
      let preDragSelectedTexts = new Set();
      let selectionRect = null;
      let selectionBoxStyle = {
       fillColor: "#4fd1c5",
       fillOpacity: 0.1,
       strokeColor: "#4fd1c5",
       strokeWidth: 2,
       strokeDasharray: "5,5"
      };
      let isDraggingSelection = false;
      let dragSelectionStart = null;
      
      let clipboard = null;
      
      const ROLLBACK_STORAGE_KEY = "theonefile_rollbacks";
      const MAX_ROLLBACK_VERSIONS = 50;
      let rollbackVersions = [];
      let currentRollbackIndex = -1;
      
      const AUDIT_STORAGE_KEY = "theonefile_audit_log";
      let auditLog = [];
      const MAX_AUDIT_ENTRIES = 1000;
      
      let documentTabs = [{
        id: "main",
        name: "Main Topology",
        nodes: {},
        edges: { list: [] },
        positions: {},
        sizes: {},
        styles: {},
        legend: {},
        rects: { list: [] },
        texts: { list: [] },
      pageState: null
      }];
      let currentTabIndex = 0;
      
      let encryptedSections = {}; 
      
      let performanceMode = "auto"; 
      let cullOffscreenNodes = true;
      let minimapNeedsUpdate = true;
      let lastMinimapUpdate = 0;
      
      const MobileManager = {
        isMobile: false,
        detect() {
          if (navigator.userAgentData?.mobile === true) {
            this.isMobile = true;
            return true;
          }
          const coarse = matchMedia("(pointer: coarse)").matches;
          const width = window.innerWidth <= 900;
          const portrait = matchMedia("(orientation: portrait)").matches;
          this.isMobile = coarse && (width || portrait);
          return this.isMobile;
        },
        applyInitialCollapse() {
          if (!this.isMobile) return;
          legendCollapsed = true;
          minimapCollapsed = true;
          drawToolbarCollapsed = true;
          topologyToolbarCollapsed = true;
          if (typeof updateLegendVisibility === "function") updateLegendVisibility();
          if (typeof updateMinimapVisibility === "function") updateMinimapVisibility();
          if (typeof updateDrawToolbarVisibility === "function") updateDrawToolbarVisibility();
          if (typeof updateTopologyToolbarVisibility === "function") updateTopologyToolbarVisibility();
        },
        updateBulkToolbar() {
          const desktop = document.getElementById("bulk-toolbar");
          const mobile = document.getElementById("bulk-toolbar-mobile");
          if (!desktop || !mobile) return;
          
          if (typeof selectedNodes === 'undefined' || selectedNodes.size === 0) {
           desktop.style.display = "none";
           mobile.style.display = "none";
           return;
          }
      
          const isVisible = desktop.style.display !== "none" || mobile.style.display !== "none";
          
          if (this.isMobile) {
            desktop.style.display = "none";
            if (isVisible) {
              mobile.style.display = "flex";
            }
          } else {
            mobile.style.display = "none";
            if (isVisible) {
              desktop.style.display = "flex";
            }
          }
        },
        updateLayout() {
          const main = document.querySelector("main");
          if (!main) return;
        },
        updateCanvasHint() {
      const hint = document.getElementById("canvas-hint");
      if (!hint) return;
      
      if (PAGE_STATE.canvasHintText !== undefined && PAGE_STATE.canvasHintText !== "") {
        hint.innerHTML = PAGE_STATE.canvasHintText;
        return;
      }
      
      const items = this.isMobile
      ? [
        "Pinch to zoom",
        "Drag to pan",
        "Add node from top menu",
        "Double tap to clone and align",
        "Double tap to select multiple",
        "You have the power",	
        "Your time is NOW!",
      ]
      : [
        "Scroll to zoom",
        "Drag to pan",
        "Right click to clone and align",
        "Right click to select multiple",
	    "Hold Shift + drag mouse for marquee selection",
        "You have the power",
        "Your time is NOW!",
      ];
      
      const list = document.createElement("ul");
      for (const item of items) {
      const li = document.createElement("li");
      li.textContent = item;
      list.appendChild(li);
      }
      
      hint.replaceChildren(list);
      },
        autoSelectStyleScope() {
          const scope = document.getElementById("style-scope");
          if (!scope) return;
          if (this.isMobile) scope.value = "mobile";
        },
        updateToolbarStack() {
          if (!this.isMobile) return;
          const draw = document.getElementById("draw-toolbar");
          const topo = document.getElementById("topology-toolbar");
          if (!draw || !topo) return;
          const h = draw.getBoundingClientRect().height;
          document.documentElement.style.setProperty("--draw-toolbar-height", h + "px");
        },
        updateLayoutControls() {
          const sidebarRow = document.getElementById("sidebar-width-row");
          const footerRow = document.getElementById("mobile-footer-row");
          if (sidebarRow && footerRow) {
            if (this.isMobile) {
              sidebarRow.style.display = "none";
              footerRow.style.display = "flex";
            } else {
              sidebarRow.style.display = "flex";
              footerRow.style.display = "none";
            }
          }
        },
        applyAll() {
          this.detect();
          this.applyInitialCollapse();
          this.updateBulkToolbar();
          this.updateLayout();
          this.updateCanvasHint();
          this.autoSelectStyleScope();
          this.updateToolbarStack();
          this.updateLayoutControls();
        }
      };
      
      function isMobileDevice() {
        return MobileManager.isMobile;
      }
      
      function u8ToBase64(u8) {
      let binary = "";
      for (let i = 0; i < u8.length; i++) binary += String.fromCharCode(u8[i]);
      return btoa(binary);
      }
      
      function base64ToU8(base64) {
      const binary = atob(base64);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
      return bytes;
      }
      
      function ensureLegendMiniButton() {
       if (legendMiniBtn) return legendMiniBtn;
	   const existing = document.getElementById("edge-legend-mini");
       if (existing) { legendMiniBtn = existing; return existing; }
       const panel = document.querySelector(".topology-panel");
       if (!panel) return null;
       const btn = document.createElement("button");
       btn.type = "button";
       btn.id = "edge-legend-mini";
       btn.className = "legend-mini-btn";
       btn.textContent = "Legend";
       btn.style.bottom = "10px";
       const handleClick = (e) => {
        e.stopPropagation();
        e.preventDefault();
        legendCollapsed = false;
        updateLegendVisibility();
       };
       btn.addEventListener("click", handleClick);
       btn.addEventListener("touchend", handleClick);
       panel.appendChild(btn);
       legendMiniBtn = btn;
       return btn;
      }
      
      function ensureMinimapMiniButton() {
       if (minimapMiniBtn) return minimapMiniBtn;
	   const existing = document.getElementById("minimap-mini");
       if (existing) { minimapMiniBtn = existing; return existing; }
       const panel = document.querySelector(".topology-panel");
       if (!panel) return null;
       const btn = document.createElement("button");
       btn.type = "button";
       btn.id = "minimap-mini";
       btn.className = "legend-mini-btn";
       btn.textContent = "Map";
       btn.style.right = "10px";
       btn.style.left = "auto";
       btn.style.bottom = "10px";
       const handleClick = (e) => {
        e.stopPropagation();
        e.preventDefault();
        minimapCollapsed = false;
        updateMinimapVisibility();
       };
       btn.addEventListener("click", handleClick);
       btn.addEventListener("touchend", handleClick);
       panel.appendChild(btn);
       minimapMiniBtn = btn;
       return btn;
      }
      
      function ensureDrawToolbarMiniButton() {
       if (drawToolbarMiniBtn) return drawToolbarMiniBtn;
	   const existing = document.getElementById("draw-toolbar-mini");
       if (existing) { drawToolbarMiniBtn = existing; return existing; }
       const panel = document.querySelector(".topology-panel");
       if (!panel) return null;
       const btn = document.createElement("button");
       btn.type = "button";
       btn.id = "draw-toolbar-mini";
       btn.className = "legend-mini-btn";
       btn.textContent = "Draw";
       btn.style.top = "10px";
       btn.style.left = "10px";
       btn.style.right = "auto";
       const handleClick = (e) => {
        e.stopPropagation();
        e.preventDefault();
        drawToolbarCollapsed = false;
        updateDrawToolbarVisibility();
       };
       btn.addEventListener("click", handleClick);
       btn.addEventListener("touchend", handleClick);
       panel.appendChild(btn);
       drawToolbarMiniBtn = btn;
       return btn;
      }
      
      function ensureTopologyToolbarMiniButton() {
       if (topologyToolbarMiniBtn) return topologyToolbarMiniBtn;
	   const existing = document.getElementById("topology-toolbar-mini");
       if (existing) { topologyToolbarMiniBtn = existing; return existing; }
       const panel = document.querySelector(".topology-panel");
       if (!panel) return null;
       const btn = document.createElement("button");
       btn.type = "button";
       btn.id = "topology-toolbar-mini";
       btn.className = "legend-mini-btn";
       btn.textContent = "Add Line";
       btn.style.top = "10px";
       btn.style.left = "auto";
       btn.style.right = "40px";
       const handleClick = (e) => {
        e.stopPropagation();
        e.preventDefault();
        topologyToolbarCollapsed = false;
        updateTopologyToolbarVisibility();
       };
       btn.addEventListener("click", handleClick);
       btn.addEventListener("touchend", handleClick);
       panel.appendChild(btn);
       topologyToolbarMiniBtn = btn;
       return btn;
      }
      
      function updateToolbarStack() {
       if (!isMobileDevice()) return;
       const draw = document.getElementById("draw-toolbar");
       const topo = document.getElementById("topology-toolbar");
       if (!draw || !topo) return;
       const h = draw.getBoundingClientRect().height;
       document.documentElement.style.setProperty("--draw-toolbar-height", h + "px");
      }
      window.addEventListener("resize", updateToolbarStack);
      window.addEventListener("DOMContentLoaded", updateToolbarStack);
      updateToolbarStack();
      
      function updateLegendVisibility() {
       const legend = document.getElementById("edge-legend");
       const mini = ensureLegendMiniButton();
       if (!legend || !mini) return;
       const hasItems = legend.querySelectorAll(".legend-item").length > 0;
       if (!hasItems) {
        legend.style.display = "none";
        mini.style.display = "none";
        return;
       }
       if (legendCollapsed) {
        legend.style.display = "none";
        mini.style.display = "inline-flex";
       } else {
        legend.style.display = "flex";
        mini.style.display = "none";
       }
      }
      
      function updateMinimapVisibility() {
       const wrapper = document.getElementById("minimap-zoom-wrapper");
       const mini = ensureMinimapMiniButton();
       if (!wrapper || !mini) return;
       if (minimapCollapsed) {
        wrapper.style.display = "none";
        mini.style.display = "inline-flex";
       } else {
        wrapper.style.display = "block";
        mini.style.display = "none";
       }
      }
      
      function updateDrawToolbarVisibility() {
       const toolbar = document.getElementById("draw-toolbar");
       const mini = ensureDrawToolbarMiniButton();
       if (isViewOnly()) {
        if (toolbar) toolbar.style.setProperty('display', 'none', 'important');
        if (mini) mini.style.display = "none";
        return;
       }
       if (!toolbar || !mini) return;
       if (drawToolbarCollapsed) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "inline-flex";
       } else {
      if (isMobileDevice()) {    	   
        toolbar.style.setProperty('display', 'grid', 'important');
        mini.style.display = "none";
      } else {   
        toolbar.style.setProperty('display', 'flex', 'important');
        mini.style.display = "none";	  
      }
       }
      }
      
      function updateTopologyToolbarVisibility() {
       const toolbar = document.getElementById("topology-toolbar");
       const mini = ensureTopologyToolbarMiniButton();
       if (isViewOnly()) {
        if (toolbar) toolbar.style.setProperty('display', 'none', 'important');
        if (mini) mini.style.display = "none";
        return;
       }
       if (!toolbar || !mini) return;
       const hasSelectedNode = currentNodeId !== null;
       if (!hasSelectedNode) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "none";
       } else if (topologyToolbarCollapsed) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "inline-flex";
       } else {   
      if (isMobileDevice()) {    	   
        toolbar.style.setProperty('display', 'grid', 'important');
        mini.style.display = "none";
        } else {   
        toolbar.style.setProperty('display', 'flex', 'important');
        mini.style.display = "none";	  
      }
       }
      }
      const DEFAULT_CANVAS_HINT = document.getElementById("canvas-hint")?.innerHTML || "";
      const DEFAULT_PAGE_STATE = {
       title: "The One File",
       background: "",
       topbarBg: "rgba(9, 12, 20, 0.9)",
       topbarBorder: "#1f2533",
       panel: "#0b0e13",
       panelAlt: "#10141b",
       accent: "#4fd1c5",
       sidebarBg: "#10141b",
       btnBg: "#0b0e13",
       btnText: "#e2e8f0",
       tagFill: "#1e293b",
       tagText: "#e2e8f0",
       tagBorder: "#475569",
       inputBg: "#0b0e13",
       inputText: "#e2e8f0",
       inputBorder: "#1f2937",
       inputFont: "Inter, system-ui, sans-serif",
       inputFontSize: 14,
       toolbarBg: "#0f172a",
       toolbarBorder: "#1f2937",
       toolbarText: "#94a3b8",
       toolbarBtnBg: "#0b0e13",
       toolbarBtnText: "#e2e8f0",
       minimapDots: "#94a3b8",
       canvasHintEnabled: true,
       canvasHintText: "",
       canvasHintBg: "#0f172a",
       canvasHintColor: "#94a3b8",
       danger: "#f56565",
       textMain: "#e2e8f0",
       textSoft: "#94a3b8",
       topbarHeight: 52,
       sidebarWidth: 350,
       mobileFooterHeight: 40,
       sidebarCollapsed: false,
       nodeFill: "#1e293b",
       nodeStroke: "#475569",
       nodeTitle: "#e2e8f0",
       nodeSub: "#94a3b8",
       nodeTitleSize: 18,
       nodeSubSize: 13,
       nodeFont: "Inter, system-ui, sans-serif",
       defaultEdge: "#475569",
       selectionHandle: "#f59e0b",
       selectionHandleSize: 8,
       groupIndicator: "#4fd1c5",
      canvasGradientTop: "#1e2532",
       canvasGradientBottom: "#050608",
       canvasBorder: "#475569",
       canvasGrid: "#475569",
       canvasGridSize: 50,
       rackFrameFill: "#0f172a",
       rackFrameStroke: "#4fd1c5",
       rackLineColor: "#475569",
       rackTextColor: "#4fd1c5",
	   viewOnly: false,
      };
      let PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE);
	  function isViewOnly() {
       return PAGE_STATE.viewOnly === true;
      }
	  let viewOnlyClickCount = 0;
      let viewOnlyClickTimer = null;
      let viewOnlyClickTarget = null;
      
      function handleViewOnlyClick(id, type) {
       if (!isViewOnly()) return false;
       
       if (viewOnlyClickTarget !== id) {
        viewOnlyClickCount = 0;
        viewOnlyClickTarget = id;
       }
       
       viewOnlyClickCount++;
       
       clearTimeout(viewOnlyClickTimer);
       viewOnlyClickTimer = setTimeout(() => {
        viewOnlyClickCount = 0;
        viewOnlyClickTarget = null;
       }, 2000);
       
       if (viewOnlyClickCount >= 5) {
        viewOnlyClickCount = 0;
        viewOnlyClickTarget = null;
        
        document.body.classList.add("view-only-inspect");
        
        if (type === 'node') {
         currentNodeId = id;
         const data = NODE_DATA[id];
         if (data) {
          document.querySelectorAll(".node-group").forEach((n) => {
           n.classList.toggle("active", n.dataset.nodeId === id);
          });
          document.getElementById("node-panel").style.display = "block";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("node-name").textContent = data.name;
          document.getElementById("node-ip").textContent = data.ip;
          document.getElementById("node-role").textContent = data.role;
          document.getElementById("node-mac").textContent = data.mac || "--";
          document.getElementById("node-rack").textContent = data.rackUnit || "--";
          document.getElementById("node-uheight").textContent = (data.uHeight || "1") + "U";
          
          const tagList = document.getElementById("node-tags");
          if (tagList) {
           tagList.innerHTML = "";
           if (data.tags && data.tags.length > 0) {
            data.tags.forEach((tag) => {
             const li = document.createElement("li");
             li.textContent = tag;
             tagList.appendChild(li);
            });
           }
          }
          
          const noteList = document.getElementById("node-notes");
          if (noteList) {
           noteList.innerHTML = "";
           if (data.notes && data.notes.length > 0) {
            data.notes.forEach((note) => {
             const li = document.createElement("li");
             li.textContent = note;
             noteList.appendChild(li);
            });
           }
          }
         }
        } else if (type === 'edge') {
         currentEdgeId = id;
         const edge = EDGE_DATA.list.find(e => e.id === id);
         if (edge) {
          document.querySelectorAll(".edge").forEach((e) => {
           e.classList.toggle("active", e.dataset.edgeId === id);
          });
          document.getElementById("edge-panel").style.display = "block";
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-from").textContent = NODE_DATA[edge.from]?.name || edge.from;
          document.getElementById("edge-to").textContent = NODE_DATA[edge.to]?.name || edge.to;
          document.getElementById("edge-label").value = edge.label || "";
         }
        }
        return true;
       }
       return false;
      }
	  
      const CANVAS_WIDTH = 4000;
      let CANVAS_HEIGHT = 3000;
      const BASE_CANVAS_HEIGHT = 3000;
      const CANVAS_PADDING = 100;
      
      const RACK_U_HEIGHT = 70; 
      const RACK_WIDTH = 600;
      const RACK_START_X = CANVAS_WIDTH / 2; 
      const RACK_START_Y = CANVAS_PADDING + 100;
      function getRackUHeight(rackId) {
      const capacity = getRackCapacity(rackId);
      const availableHeight = CANVAS_HEIGHT - RACK_START_Y - 200;
      return Math.floor(availableHeight / capacity);
      }
      let canvasState = {
       zoom: 1,
       panX: 0,
       panY: 0,
       minZoom: 0.25,
       maxZoom: 4,
       isPanning: false,
       panStartX: 0,
       panStartY: 0,
       spacePressed: false,
      };
      
      function getViewBox() {
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       return {
        x: canvasState.panX,
        y: canvasState.panY,
        width: viewWidth,
        height: viewHeight,
       };
      }
      
      function updateViewBox() {
       const svg = document.getElementById("map");
       const vb = getViewBox();
       svg.setAttribute("viewBox", `${vb.x} ${vb.y} ${vb.width} ${vb.height}`, );
       const zoomLevel = document.getElementById("zoom-level");
       if (zoomLevel) {
        zoomLevel.textContent = Math.round(canvasState.zoom * 100) + "%";
       }
       updateMinimap();
       populateRackDropdown();
      }
      
      function updateMinimap() {
       const minimapViewport = document.getElementById("minimap-viewport");
       const minimapSvg = document.getElementById("minimap");
       if (!minimapViewport || !minimapSvg) return;
       const vb = getViewBox();
       minimapViewport.setAttribute("x", vb.x);
       minimapViewport.setAttribute("y", vb.y);
       minimapViewport.setAttribute("width", vb.width);
       minimapViewport.setAttribute("height", vb.height);
       const minimapNodes = minimapSvg.querySelectorAll(".minimap-node");
       minimapNodes.forEach((n) => n.remove());
       const minimapEdges = minimapSvg.querySelectorAll(".minimap-edge");
       minimapEdges.forEach((e) => e.remove());
       
       EDGE_DATA.list.forEach((edge) => {
        if (edge.type === "custom") return;
        
        const fromNode = NODE_DATA[edge.from];
        const toNode = NODE_DATA[edge.to];
        if (!fromNode || !toNode) return;
        
        if (currentView.mode === "rack") {
         if (fromNode.assignedRack !== currentView.rackId || 
             toNode.assignedRack !== currentView.rackId) {
          return;
         }
        } else {
         if (fromNode.assignedRack || toNode.assignedRack) {
          return;
         }
        }
        
        const p1 = savedPositions[edge.from];
        const p2 = savedPositions[edge.to];
        if (!p1 || !p2) return;
        const line = document.createElementNS("http://www.w3.org/2000/svg", "line", );
        line.setAttribute("x1", p1.x);
        line.setAttribute("y1", p1.y);
        line.setAttribute("x2", p2.x);
        line.setAttribute("y2", p2.y);
        line.classList.add("minimap-edge");
        minimapSvg.insertBefore(line, minimapViewport);
       });
       
       Object.entries(savedPositions).forEach(([id, pos]) => {
        const node = NODE_DATA[id];
        if (!node) return;
        
        if (currentView.mode === "rack") {
         if (node.assignedRack !== currentView.rackId) {
          return; 
         }
        } else {
         if (node.assignedRack) {
          return; 
         }
        }
        
        const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle", );
        circle.setAttribute("cx", pos.x);
        circle.setAttribute("cy", pos.y);
        circle.setAttribute("r", 40);
        circle.classList.add("minimap-node");
        minimapSvg.insertBefore(circle, minimapViewport);
       });
      }
      
      function zoomTo(newZoom, centerX, centerY) {
       const oldZoom = canvasState.zoom;
       newZoom = Math.max(canvasState.minZoom, Math.min(canvasState.maxZoom, newZoom), );
       if (centerX !== undefined && centerY !== undefined) {
        const oldWidth = CANVAS_WIDTH / oldZoom;
        const oldHeight = CANVAS_HEIGHT / oldZoom;
        const newWidth = CANVAS_WIDTH / newZoom;
        const newHeight = CANVAS_HEIGHT / newZoom;
        const pointX = canvasState.panX + centerX * oldWidth;
        const pointY = canvasState.panY + centerY * oldHeight;
        canvasState.panX = pointX - centerX * newWidth;
        canvasState.panY = pointY - centerY * newHeight;
       }
       canvasState.zoom = newZoom;
       constrainPan();
       updateViewBox();
      }
      
      function constrainPan() {
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       const minVisiblePortion = 0.1;
       const maxPanX = CANVAS_WIDTH - viewWidth * minVisiblePortion;
       const maxPanY = CANVAS_HEIGHT - viewHeight * minVisiblePortion;
       const minPanX = -viewWidth * (1 - minVisiblePortion);
       const minPanY = -viewHeight * (1 - minVisiblePortion);
       canvasState.panX = Math.max(minPanX, Math.min(maxPanX, canvasState.panX), );
       canvasState.panY = Math.max(minPanY, Math.min(maxPanY, canvasState.panY), );
      }
      
      function fitToContent() {
       const positions = Object.values(savedPositions);
       if (positions.length === 0) {
        resetView();
        return;
       }
       let minX = Infinity,
        minY = Infinity,
        maxX = -Infinity,
        maxY = -Infinity;
       positions.forEach((pos) => {
        minX = Math.min(minX, pos.x - 100);
        minY = Math.min(minY, pos.y - 100);
        maxX = Math.max(maxX, pos.x + 100);
        maxY = Math.max(maxY, pos.y + 100);
       });
       const contentWidth = maxX - minX + 200;
       const contentHeight = maxY - minY + 200;
       const viewport = document.getElementById("canvas-viewport");
       const vpRect = viewport.getBoundingClientRect();
       const aspectRatio = vpRect.width / vpRect.height;
       const contentAspect = contentWidth / contentHeight;
       let newZoom;
       if (contentAspect > aspectRatio) {
        newZoom = (vpRect.width / contentWidth) * (CANVAS_WIDTH / vpRect.width);
       } else {
        newZoom = (vpRect.height / contentHeight) * (CANVAS_HEIGHT / vpRect.height);
       }
       newZoom = Math.max(canvasState.minZoom, Math.min(2, newZoom));
       const viewWidth = CANVAS_WIDTH / newZoom;
       const viewHeight = CANVAS_HEIGHT / newZoom;
       canvasState.zoom = newZoom;
       canvasState.panX = minX - 100 - (viewWidth - contentWidth) / 2;
       canvasState.panY = minY - 100 - (viewHeight - contentHeight) / 2;
       constrainPan();
       updateViewBox();
      }
      
      function resetView() {
       canvasState.zoom = 1;
       canvasState.panX = 0;
       canvasState.panY = 0;
       updateViewBox();
      }
      window.addEventListener("DOMContentLoaded", () => {
       const toggle = document.getElementById("mobile-menu-toggle");
       const menu = document.getElementById("topbar-menu");
       if (!toggle || !menu) return;
       toggle.addEventListener("click", () => {
        menu.classList.toggle("open");
       });
       menu.addEventListener("click", (e) => {
        const target = e.target.closest("a, button");
        if (!target) return;
        if (isMobileDevice()) {
       menu.classList.remove("open");
      }
       });
       const minimapCloseBtn = document.getElementById("minimap-close-btn");
       if (minimapCloseBtn) {
        const handleMinimapClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         minimapCollapsed = true;
         updateMinimapVisibility();
        };
        minimapCloseBtn.addEventListener("click", handleMinimapClose);
        minimapCloseBtn.addEventListener("touchend", handleMinimapClose);
       }
       const drawToolbarCloseBtn = document.getElementById("draw-toolbar-close-btn");
       if (drawToolbarCloseBtn) {
        const handleDrawClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         drawToolbarCollapsed = true;
         updateDrawToolbarVisibility();
        };
        drawToolbarCloseBtn.addEventListener("click", handleDrawClose);
        drawToolbarCloseBtn.addEventListener("touchend", handleDrawClose);
       }
       const topologyToolbarCloseBtn = document.getElementById("topology-toolbar-close-btn");
       if (topologyToolbarCloseBtn) {
        const handleTopologyClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         topologyToolbarCollapsed = true;
         updateTopologyToolbarVisibility();
        };
        topologyToolbarCloseBtn.addEventListener("click", handleTopologyClose);
        topologyToolbarCloseBtn.addEventListener("touchstart", (e) => e.preventDefault(), {
         passive: false
        });
        topologyToolbarCloseBtn.addEventListener("touchend", handleTopologyClose);
       }
      
       updateMinimapVisibility();
       updateDrawToolbarVisibility();
       updateTopologyToolbarVisibility();
      });
      
      function applyLayerFilter() {
       activeLayers.clear();
       if (document.getElementById("layer-physical").checked) activeLayers.add("physical");
       if (document.getElementById("layer-logical").checked) activeLayers.add("logical");
       if (document.getElementById("layer-security").checked) activeLayers.add("security");
       if (document.getElementById("layer-application").checked) activeLayers.add("application");
       forgeTheTopology();
      }
      
      function isNodeVisible(nodeId) {
       const node = NODE_DATA[nodeId];
       if (!node) return false;
       const nodeLayer = node.layer || "physical";
       return activeLayers.has(nodeLayer);
      }
      
      function enterRack(rackId) {
      if (!NODE_DATA[rackId] || !NODE_DATA[rackId].isRack) return;
      const rackCapacity = getRackCapacity(rackId);
      const neededHeight = RACK_START_Y + (rackCapacity * RACK_U_HEIGHT) + 200;
      if (neededHeight > BASE_CANVAS_HEIGHT) {
      CANVAS_HEIGHT = neededHeight;
      }
       
       savedTopologyView = {
        zoom: canvasState.zoom,
        panX: canvasState.panX,
        panY: canvasState.panY
       };
       
       currentView.mode = "rack";
       currentView.rackId = rackId;
       
       const backBtn = document.getElementById("back-to-topology-btn");
       if (backBtn) backBtn.style.display = "inline-block";
       
       const hint = document.getElementById("canvas-hint");
       if (hint) {
        hint.textContent = `Viewing: ${NODE_DATA[rackId].name} | Double click empty space to exit`;
        hint.classList.add("visible");
       }
       
      
      const rackUHeight = getRackUHeight(rackId);
      const rackHeight = rackCapacity * rackUHeight;
      const rackCenterX = RACK_START_X;
      const rackCenterY = RACK_START_Y + (rackHeight / 2);
       
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       
       canvasState.panX = rackCenterX - (viewWidth / 2);
       canvasState.panY = rackCenterY - (viewHeight / 2);
       
       constrainPan();
       updateViewBox();
       
       forgeTheTopology();
      }
      
      function exitRack() {
      CANVAS_HEIGHT = BASE_CANVAS_HEIGHT;
      currentView.mode = "topology";
      currentView.rackId = null;
       
       const backBtn = document.getElementById("back-to-topology-btn");
       if (backBtn) backBtn.style.display = "none";
       
       const hint = document.getElementById("canvas-hint");
       if (hint) {
        hint.classList.remove("visible");
       }
       
       if (savedTopologyView) {
        canvasState.zoom = savedTopologyView.zoom;
        canvasState.panX = savedTopologyView.panX;
        canvasState.panY = savedTopologyView.panY;
        updateViewBox();
       }
       
       forgeTheTopology();
      }
      
      function getRackCapacity(rackId) {
       const node = NODE_DATA[rackId];
       return node && node.rackCapacity ? parseInt(node.rackCapacity) : 42;
      }
      
      function populateRackDropdown() {
       const dropdown = document.getElementById("node-assigned-rack");
       if (!dropdown) return;
       
       dropdown.innerHTML = '<option value="">None</option>';
       
       Object.keys(NODE_DATA).forEach(id => {
        if (NODE_DATA[id].isRack) {
         const option = document.createElement("option");
         option.value = id;
         option.textContent = NODE_DATA[id].name;
         dropdown.appendChild(option);
        }
       });
      }
      
      function wieldThePower() {
       const root = document.documentElement;
       root.style.setProperty("--panel", PAGE_STATE.panel);
       root.style.setProperty("--panel-alt", PAGE_STATE.panelAlt);
       root.style.setProperty("--sidebar-bg", PAGE_STATE.sidebarBg || PAGE_STATE.panelAlt);
       root.style.setProperty("--btn-bg", PAGE_STATE.btnBg || PAGE_STATE.panel);
       root.style.setProperty("--btn-text", PAGE_STATE.btnText || "#e2e8f0");
       root.style.setProperty("--tag-fill", PAGE_STATE.tagFill || "#1e293b");
       root.style.setProperty("--tag-text", PAGE_STATE.tagText || "#e2e8f0");
       root.style.setProperty("--tag-border", PAGE_STATE.tagBorder || "#475569");
       root.style.setProperty("--input-bg", PAGE_STATE.inputBg || "#0b0e13");
       root.style.setProperty("--input-text", PAGE_STATE.inputText || "#e2e8f0");
       root.style.setProperty("--input-border", PAGE_STATE.inputBorder || "#1f2937");
       root.style.setProperty("--input-font", PAGE_STATE.inputFont || "Inter, system-ui, sans-serif");
       root.style.setProperty("--input-font-size", (PAGE_STATE.inputFontSize || 14) + "px");
       root.style.setProperty("--toolbar-bg", PAGE_STATE.toolbarBg || "#0f172a");
       root.style.setProperty("--toolbar-border", PAGE_STATE.toolbarBorder || "#1f2937");
       root.style.setProperty("--toolbar-text", PAGE_STATE.toolbarText || "#94a3b8");
       root.style.setProperty("--toolbar-btn-bg", PAGE_STATE.toolbarBtnBg || "#0b0e13");
       root.style.setProperty("--toolbar-btn-text", PAGE_STATE.toolbarBtnText || "#e2e8f0");
       root.style.setProperty("--minimap-dots", PAGE_STATE.minimapDots || "#94a3b8");
       root.style.setProperty("--canvas-hint-bg", PAGE_STATE.canvasHintBg || "#0f172a");
       root.style.setProperty("--canvas-hint-color", PAGE_STATE.canvasHintColor || "#94a3b8");
       
       const canvasHint = document.getElementById("canvas-hint");
       if (canvasHint) {
        canvasHint.style.display = PAGE_STATE.canvasHintEnabled === false ? "none" : "";
        if (PAGE_STATE.canvasHintText !== undefined && PAGE_STATE.canvasHintText !== "") {
         canvasHint.innerHTML = PAGE_STATE.canvasHintText;
        } else {
         canvasHint.innerHTML = DEFAULT_CANVAS_HINT;
        }
       }
       root.style.setProperty("--accent", PAGE_STATE.accent);
       root.style.setProperty("--danger", PAGE_STATE.danger);
       root.style.setProperty("--text-main", PAGE_STATE.textMain);
       root.style.setProperty("--text-soft", PAGE_STATE.textSoft);
       root.style.setProperty("--topbar-bg", PAGE_STATE.topbarBg);
       root.style.setProperty("--topbar-border", PAGE_STATE.topbarBorder);
       root.style.setProperty("--node-fill", PAGE_STATE.nodeFill || "#1e293b");
       root.style.setProperty("--node-stroke", PAGE_STATE.nodeStroke || "#475569");
       root.style.setProperty("--node-title", PAGE_STATE.nodeTitle || "#e2e8f0");
       root.style.setProperty("--node-sub", PAGE_STATE.nodeSub || "#94a3b8");
       root.style.setProperty("--node-title-size", (PAGE_STATE.nodeTitleSize || 18) + "px");
       root.style.setProperty("--node-sub-size", (PAGE_STATE.nodeSubSize || 13) + "px");
       root.style.setProperty("--node-font", PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif");
       root.style.setProperty("--default-edge", PAGE_STATE.defaultEdge || "#475569");
       root.style.setProperty("--selection-handle", PAGE_STATE.selectionHandle || "#f59e0b");
       root.style.setProperty("--selection-handle-size", (PAGE_STATE.selectionHandleSize || 8) + "px");
       root.style.setProperty("--group-indicator", PAGE_STATE.groupIndicator || "#4fd1c5");
       const topbarHeight = PAGE_STATE.topbarHeight || 52;
       const sidebarWidth = PAGE_STATE.sidebarWidth || 350;
       const mobileFooterHeight = PAGE_STATE.mobileFooterHeight || 40;
       root.style.setProperty("--topbar-height", topbarHeight + "px");
       root.style.setProperty("--sidebar-width", sidebarWidth + "px");
       root.style.setProperty("--mobile-footer-height", mobileFooterHeight + "vh", );
       const mainEl = document.querySelector("main");
       const detailsPanel = document.getElementById("details-panel");
       const sidebarToggle = document.getElementById("sidebar-toggle");
       if (PAGE_STATE.sidebarCollapsed) {
        if (mainEl) mainEl.classList.add("sidebar-collapsed");
        if (detailsPanel) detailsPanel.classList.add("collapsed");
        if (sidebarToggle) {
         sidebarToggle.classList.add("collapsed");
         sidebarToggle.textContent = "▶";
        }
       } else {
        if (mainEl) mainEl.classList.remove("sidebar-collapsed");
        if (detailsPanel) detailsPanel.classList.remove("collapsed");
        if (sidebarToggle) {
         sidebarToggle.classList.remove("collapsed");
         sidebarToggle.textContent = "◀";
        }
       }
       if (PAGE_STATE.background) {
        document.body.style.background = PAGE_STATE.background;
       } else {
        document.body.style.background = `radial-gradient(circle at top, ${PAGE_STATE.canvasGradientTop || "#1e2532"} 0, ${PAGE_STATE.canvasGradientBottom || "#050608"} 70%)`;
       }
       document.title = PAGE_STATE.title || DEFAULT_PAGE_STATE.title;
       const titleEl = document.getElementById("page-title");
       if (titleEl) {
        titleEl.textContent = PAGE_STATE.title || DEFAULT_PAGE_STATE.title;
       }
       
       const sidebarToggleEl = document.getElementById("sidebar-toggle");
       const isMobile = isMobileDevice();
       if (sidebarToggleEl) {
        sidebarToggleEl.style.display = isMobile ? "none" : "flex";
       }
       const viewOnlyMode = PAGE_STATE.viewOnly === true;
       const addNodeBtn = document.getElementById("add-node-btn");
       const addRackBtn = document.getElementById("add-rack-btn");
       const drawToolbar = document.getElementById("draw-toolbar");
       const topologyToolbar = document.getElementById("topology-toolbar");
       const bulkToolbar = document.getElementById("bulk-toolbar");
       
       if (addNodeBtn) addNodeBtn.style.display = viewOnlyMode ? "none" : "";
       if (addRackBtn) addRackBtn.style.display = viewOnlyMode ? "none" : "";
       if (viewOnlyMode) {
        if (drawToolbar) drawToolbar.style.setProperty('display', 'none', 'important');
        if (topologyToolbar) topologyToolbar.style.setProperty('display', 'none', 'important');
        if (bulkToolbar) bulkToolbar.style.display = "none";
        const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
       }
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       if (bulkToolbarMobile) bulkToolbarMobile.style.display = viewOnlyMode ? "none" : "";
       ["draw-toolbar-mini", "topology-toolbar-mini"].forEach(id => {
        const el = document.getElementById(id);
        if (el) el.style.display = viewOnlyMode ? "none" : "";
       });
       
       document.body.classList.toggle("view-only-mode", viewOnlyMode);
      }
      (async function awakeTheImmortal() {
       let initialState = {};
       let decryptionCancelled = false;
       const stateEl = document.getElementById("topology-state");
       if (stateEl && stateEl.textContent.trim()) {
        try {
         let stateText = stateEl.textContent.trim();
         if (isEncrypted(stateText)) {
          let decrypted = false;
          let attempts = 0;
          const maxAttempts = 3;
          while (!decrypted && attempts < maxAttempts) {
           const password = prompt("This file is encrypted. Enter password to decrypt:\n(Attempt " + (attempts + 1) + " of " + maxAttempts + ")", );
           if (!password) {
            alert("Decryption cancelled. The file will not be loaded.", );
            decryptionCancelled = true;
            break;
           }
           try {
            stateText = await decryptData(stateText, password);
            decrypted = true;
           } catch (e) {
            attempts++;
            if (attempts < maxAttempts) {
             alert("Incorrect password. Please try again.");
            } else {
             alert("Maximum attempts reached. The file will not be loaded.", );
             decryptionCancelled = true;
            }
           }
          }
          if (!decrypted) {
           stateText = "{}";
          }
         }
         initialState = JSON.parse(stateText);
        } catch (e) {
         console.error("Failed to load state:", e);
         initialState = {};
        }
       }
       if (decryptionCancelled) {
        NODE_DATA = {};
        EDGE_DATA = {
         list: []
        };
        RECT_DATA = { list: [] };
        TEXT_DATA = { list: [] };
        EDGE_LEGEND = {};
        savedPositions = {};
        savedSizes = {};
        savedStyles = {};
       } else {
        NODE_DATA = initialState.nodeData ? initialState.nodeData : BASE_NODE_DATA;
        EDGE_DATA = initialState.edgeData ? initialState.edgeData : {
         list: [],
        };
        RECT_DATA = initialState.rectData ? initialState.rectData : { list: [] };
        TEXT_DATA = initialState.textData ? initialState.textData : { list: [] };
        EDGE_LEGEND = initialState.edgeLegend || {};
        savedPositions = initialState.nodePositions || {};
        savedSizes = initialState.nodeSizes || {};
        savedStyles = initialState.nodeStyles || {};
       }
       if (initialState.page) {
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, initialState.page, );
       }
       if (initialState.canvas) {
        canvasState.zoom = initialState.canvas.zoom || 1;
        canvasState.panX = initialState.canvas.panX || 0;
        canvasState.panY = initialState.canvas.panY || 0;
       }
       
       if (initialState.savedTopologyView) {
        savedTopologyView = initialState.savedTopologyView;
       }
       
       if (initialState.documentTabs) {
        documentTabs = initialState.documentTabs;
        currentTabIndex = initialState.currentTabIndex || 0;
        
        const currentTab = documentTabs[currentTabIndex];
        if (currentTab) {
          NODE_DATA = currentTab.nodes || NODE_DATA;
          EDGE_DATA = currentTab.edges || EDGE_DATA;
          savedPositions = currentTab.positions || savedPositions;
          savedSizes = currentTab.sizes || savedSizes;
          savedStyles = currentTab.styles || savedStyles;
          EDGE_LEGEND = currentTab.legend || EDGE_LEGEND;
          RECT_DATA = currentTab.rects || RECT_DATA;
          TEXT_DATA = currentTab.texts || TEXT_DATA;
      if (currentTab.pageState) PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, currentTab.pageState);
        }
       }
           
       if (initialState.encryptedSections) {
        encryptedSections = initialState.encryptedSections;
       }
       
       wieldThePower();
       forgeTheTopology();
       updateViewBox();
       
       MobileManager.applyAll();
       
       const initialNodes = Object.keys(NODE_DATA);
       if (initialNodes.length > 0) {
        claimTheImmortal(initialNodes.includes("host") ? "host" : initialNodes[0], );
       } else {
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.display = "none";
       }
      })();
      
      let resizeDebounceTimer = null;
      window.addEventListener("resize", () => {
        clearTimeout(resizeDebounceTimer);
        resizeDebounceTimer = setTimeout(() => {
          MobileManager.applyAll();
          if (typeof updateDrawToolbarVisibility === 'function') updateDrawToolbarVisibility();
          if (typeof updateTopologyToolbarVisibility === 'function') updateTopologyToolbarVisibility();
        }, 100);
      });
      
      function getBreakpointKey() {
       const w = window.innerWidth;
       if (w <= 380) return "fold";
       if (w <= 768) return "mobile";
       if (w <= 1024) return "tablet";
       return "desktop";
      }
      
      function resolveStylesEntry(styleEntry) {
       if (!styleEntry) return {};
       if (styleEntry.circleColor || styleEntry.titleColor || styleEntry.titleFont || styleEntry.titleSize || styleEntry.subColor || styleEntry.subFont || styleEntry.subSize) {
        return styleEntry;
       }
       const bp = getBreakpointKey();
       const base = styleEntry.all || {};
       const bpStyles = styleEntry[bp] || {};
       return Object.assign({}, base, bpStyles);
      }
      
      function resolveStylesForNode(id) {
       const styleEntry = savedStyles[id];
       if (!styleEntry) return {};
       return resolveStylesEntry(styleEntry);
      }
      
      function ensureStyleEntry(id) {
       if (!savedStyles[id]) savedStyles[id] = {};
       const entry = savedStyles[id];
       const flatProps = ["circleColor", "circleBorder", "titleColor", "titleFont", "titleSize", "subColor", "subFont", "subSize", ];
       const isFlat = flatProps.some((p) => Object.prototype.hasOwnProperty.call(entry, p), );
       if (isFlat) {
        const all = entry.all || {};
        flatProps.forEach((p) => {
         if (entry[p] !== undefined) {
          all[p] = entry[p];
          delete entry[p];
         }
        });
        entry.all = all;
       }
       return entry;
      }
      
      function getDefaultSize() {
       if (window.innerWidth <= 380) return 120;
       if (window.innerWidth <= 768) return 140;
       if (window.innerWidth <= 1024) return 70;
       return 55;
      }
      
      function createShapeElement(shape, size) {
       const ns = "http://www.w3.org/2000/svg";
       if (shape === "circle") {
        const c = document.createElementNS(ns, "circle");
        c.setAttribute("r", size);
        return c;
       }
       if (shape === "square") {
        const r = document.createElementNS(ns, "rect");
        const s = size * 2;
        r.setAttribute("x", -size);
        r.setAttribute("y", -size);
        r.setAttribute("width", s);
        r.setAttribute("height", s);
        r.setAttribute("rx", 4);
        return r;
       }
       if (shape === "rectangle") {
        const r = document.createElementNS(ns, "rect");
        r.setAttribute("x", -size * 1.4);
        r.setAttribute("y", -size * 0.8);
        r.setAttribute("width", size * 2.8);
        r.setAttribute("height", size * 1.6);
        r.setAttribute("rx", 6);
        return r;
       }
       if (shape === "triangle") {
        const p = document.createElementNS(ns, "polygon");
        const h = size * 1.8;
        const w = size * 2;
        p.setAttribute("points", `0,${-h} ${w / 2},${h / 2} ${-w / 2},${h / 2}`, );
        return p;
       }
       if (shape === "hexagon") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        const pts = [
         [0, -s],
         [s * 0.86, -s * 0.5],
         [s * 0.86, s * 0.5],
         [0, s],
         [-s * 0.86, s * 0.5],
         [-s * 0.86, -s * 0.5],
        ].map((pt) => pt.join(",")).join(" ");
        p.setAttribute("points", pts);
        return p;
       }
       if (shape === "stop-sign") {
        const p = document.createElementNS(ns, "polygon");
        const r = size;
        const ptsArr = [];
        for (let i = 0; i < 8; i++) {
         const a = (Math.PI / 4) * i + Math.PI / 8;
         ptsArr.push([Math.cos(a) * r, Math.sin(a) * r]);
        }
        const pts = ptsArr.map((pt) => pt.join(",")).join(" ");
        p.setAttribute("points", pts);
        return p;
       }
       if (shape === "star") {
        const p = document.createElementNS(ns, "polygon");
        const outer = size;
        const inner = size * 0.45;
        let pts = "";
        for (let i = 0; i < 10; i++) {
         const a = (Math.PI / 5) * i - Math.PI / 2;
         const r = i % 2 === 0 ? outer : inner;
         pts += `${Math.cos(a) * r},${Math.sin(a) * r} `;
        }
        p.setAttribute("points", pts.trim());
        return p;
       }
       if (shape === "diamond") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `0,${-s} ${s},0 0,${s} ${-s},0`);
        return p;
       }
       if (shape === "server") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.2);
        body.setAttribute("y", -size * 0.6);
        body.setAttribute("width", size * 2.4);
        body.setAttribute("height", size * 1.2);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 3; i++) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", -size * 0.9 + i * size * 0.5);
         line.setAttribute("y1", -size * 0.3);
         line.setAttribute("x2", -size * 0.9 + i * size * 0.5);
         line.setAttribute("y2", size * 0.3);
         line.style.stroke = "currentColor";
         line.style.strokeWidth = "2";
         line.style.opacity = "0.5";
         g.appendChild(line);
        }
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", size * 0.9);
        led.setAttribute("cy", 0);
        led.setAttribute("r", size * 0.1);
        led.style.fill = "#4ade80";
        g.appendChild(led);
        return g;
       }
       if (shape === "pc" || shape === "desktop") {
        const g = document.createElementNS(ns, "g");
        const monitor = document.createElementNS(ns, "rect");
        monitor.setAttribute("x", -size * 0.9);
        monitor.setAttribute("y", -size * 0.8);
        monitor.setAttribute("width", size * 1.8);
        monitor.setAttribute("height", size * 1.2);
        monitor.setAttribute("rx", 4);
        g.appendChild(monitor);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.75);
        screen.setAttribute("y", -size * 0.65);
        screen.setAttribute("width", size * 1.5);
        screen.setAttribute("height", size * 0.9);
        screen.setAttribute("rx", 2);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        const neck = document.createElementNS(ns, "rect");
        neck.setAttribute("x", -size * 0.15);
        neck.setAttribute("y", size * 0.4);
        neck.setAttribute("width", size * 0.3);
        neck.setAttribute("height", size * 0.3);
        g.appendChild(neck);
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.5);
        base.setAttribute("y", size * 0.7);
        base.setAttribute("width", size * 1);
        base.setAttribute("height", size * 0.15);
        base.setAttribute("rx", 2);
        g.appendChild(base);
        return g;
       }
       if (shape === "laptop") {
        const g = document.createElementNS(ns, "g");
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.8);
        screen.setAttribute("y", -size * 0.9);
        screen.setAttribute("width", size * 1.6);
        screen.setAttribute("height", size * 1.1);
        screen.setAttribute("rx", 4);
        g.appendChild(screen);
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.9);
        base.setAttribute("y", size * 0.25);
        base.setAttribute("width", size * 1.8);
        base.setAttribute("height", size * 0.6);
        base.setAttribute("rx", 4);
        g.appendChild(base);
        const pad = document.createElementNS(ns, "rect");
        pad.setAttribute("x", -size * 0.25);
        pad.setAttribute("y", size * 0.45);
        pad.setAttribute("width", size * 0.5);
        pad.setAttribute("height", size * 0.25);
        pad.setAttribute("rx", 2);
        pad.style.fill = "#1e293b";
        g.appendChild(pad);
        return g;
       }
       if (shape === "phone" || shape === "mobile") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.45);
        body.setAttribute("y", -size);
        body.setAttribute("width", size * 0.9);
        body.setAttribute("height", size * 2);
        body.setAttribute("rx", 8);
        g.appendChild(body);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.38);
        screen.setAttribute("y", -size * 0.85);
        screen.setAttribute("width", size * 0.76);
        screen.setAttribute("height", size * 1.6);
        screen.setAttribute("rx", 4);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        const btn = document.createElementNS(ns, "rect");
        btn.setAttribute("x", -size * 0.15);
        btn.setAttribute("y", size * 0.82);
        btn.setAttribute("width", size * 0.3);
        btn.setAttribute("height", size * 0.06);
        btn.setAttribute("rx", 2);
        btn.style.fill = "#475569";
        g.appendChild(btn);
        return g;
       }
       if (shape === "router") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.1);
        body.setAttribute("y", -size * 0.3);
        body.setAttribute("width", size * 2.2);
        body.setAttribute("height", size * 0.8);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        for (let i = -1; i <= 1; i++) {
         const ant = document.createElementNS(ns, "rect");
         ant.setAttribute("x", i * size * 0.6 - size * 0.05);
         ant.setAttribute("y", -size * 0.9);
         ant.setAttribute("width", size * 0.1);
         ant.setAttribute("height", size * 0.6);
         ant.setAttribute("rx", 2);
         g.appendChild(ant);
         const tip = document.createElementNS(ns, "circle");
         tip.setAttribute("cx", i * size * 0.6);
         tip.setAttribute("cy", -size * 0.95);
         tip.setAttribute("r", size * 0.08);
         g.appendChild(tip);
        }
        for (let i = 0; i < 4; i++) {
         const led = document.createElementNS(ns, "circle");
         led.setAttribute("cx", -size * 0.7 + i * size * 0.35);
         led.setAttribute("cy", size * 0.1);
         led.setAttribute("r", size * 0.06);
         led.style.fill = i < 2 ? "#4ade80" : "#facc15";
         g.appendChild(led);
        }
        return g;
       }
       if (shape === "switch") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.4);
        body.setAttribute("y", -size * 0.4);
        body.setAttribute("width", size * 2.8);
        body.setAttribute("height", size * 0.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 8; i++) {
         const port = document.createElementNS(ns, "rect");
         port.setAttribute("x", -size * 1.2 + i * size * 0.32);
         port.setAttribute("y", -size * 0.15);
         port.setAttribute("width", size * 0.22);
         port.setAttribute("height", size * 0.3);
         port.setAttribute("rx", 1);
         port.style.fill = "#1e293b";
         g.appendChild(port);
        }
        return g;
       }
       if (shape === "firewall") {
        const g = document.createElementNS(ns, "g");
        const wall = document.createElementNS(ns, "rect");
        wall.setAttribute("x", -size);
        wall.setAttribute("y", -size * 0.8);
        wall.setAttribute("width", size * 2);
        wall.setAttribute("height", size * 1.6);
        wall.setAttribute("rx", 4);
        g.appendChild(wall);
        for (let row = 0; row < 3; row++) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", -size * 0.85);
         line.setAttribute("y1", -size * 0.5 + row * size * 0.45);
         line.setAttribute("x2", size * 0.85);
         line.setAttribute("y2", -size * 0.5 + row * size * 0.45);
         line.style.stroke = "#475569";
         line.style.strokeWidth = "2";
         g.appendChild(line);
        }
        for (let row = 0; row < 4; row++) {
         const offset = row % 2 === 0 ? 0 : size * 0.35;
         for (let col = 0; col < 3; col++) {
          const line = document.createElementNS(ns, "line");
          const x = -size * 0.5 + col * size * 0.7 + offset;
          if (x > -size * 0.85 && x < size * 0.85) {
           line.setAttribute("x1", x);
           line.setAttribute("y1", -size * 0.8 + row * size * 0.45, );
           line.setAttribute("x2", x);
           line.setAttribute("y2", -size * 0.8 + row * size * 0.45 + size * 0.45, );
           line.style.stroke = "#475569";
           line.style.strokeWidth = "2";
           g.appendChild(line);
          }
         }
        }
        return g;
       }
       if (shape === "cloud") {
        const p = document.createElementNS(ns, "path");
        const s = size;
        p.setAttribute("d", `
             M ${-s * 0.8} ${s * 0.2}
             Q ${-s * 1.1} ${s * 0.2} ${-s * 1.1} ${-s * 0.1}
             Q ${-s * 1.1} ${-s * 0.5} ${-s * 0.7} ${-s * 0.5}
             Q ${-s * 0.7} ${-s * 0.9} ${-s * 0.2} ${-s * 0.9}
             Q ${s * 0.1} ${-s * 1.1} ${s * 0.5} ${-s * 0.8}
             Q ${s * 1} ${-s * 0.8} ${s * 1.1} ${-s * 0.3}
             Q ${s * 1.3} ${-s * 0.1} ${s * 1.1} ${s * 0.2}
             Q ${s * 1.1} ${s * 0.5} ${s * 0.7} ${s * 0.5}
             L ${-s * 0.5} ${s * 0.5}
             Q ${-s * 0.9} ${s * 0.5} ${-s * 0.9} ${s * 0.2}
             Z
            `, );
        return p;
       }
       if (shape === "database") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.7);
        body.setAttribute("y", -size * 0.6);
        body.setAttribute("width", size * 1.4);
        body.setAttribute("height", size * 1.4);
        g.appendChild(body);
        const top = document.createElementNS(ns, "ellipse");
        top.setAttribute("cx", 0);
        top.setAttribute("cy", -size * 0.6);
        top.setAttribute("rx", size * 0.7);
        top.setAttribute("ry", size * 0.25);
        g.appendChild(top);
        const bottom = document.createElementNS(ns, "ellipse");
        bottom.setAttribute("cx", 0);
        bottom.setAttribute("cy", size * 0.8);
        bottom.setAttribute("rx", size * 0.7);
        bottom.setAttribute("ry", size * 0.25);
        g.appendChild(bottom);
        const mid1 = document.createElementNS(ns, "ellipse");
        mid1.setAttribute("cx", 0);
        mid1.setAttribute("cy", -size * 0.15);
        mid1.setAttribute("rx", size * 0.7);
        mid1.setAttribute("ry", size * 0.2);
        mid1.style.fill = "none";
        mid1.style.stroke = "#475569";
        mid1.style.strokeWidth = "2";
        g.appendChild(mid1);
        const mid2 = document.createElementNS(ns, "ellipse");
        mid2.setAttribute("cx", 0);
        mid2.setAttribute("cy", size * 0.35);
        mid2.setAttribute("rx", size * 0.7);
        mid2.setAttribute("ry", size * 0.2);
        mid2.style.fill = "none";
        mid2.style.stroke = "#475569";
        mid2.style.strokeWidth = "2";
        g.appendChild(mid2);
        return g;
       }
       if (shape === "printer") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.4);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size * 0.9);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const trayTop = document.createElementNS(ns, "rect");
        trayTop.setAttribute("x", -size * 0.7);
        trayTop.setAttribute("y", -size * 0.8);
        trayTop.setAttribute("width", size * 1.4);
        trayTop.setAttribute("height", size * 0.4);
        trayTop.setAttribute("rx", 2);
        trayTop.style.fill = "#1e293b";
        g.appendChild(trayTop);
        const trayOut = document.createElementNS(ns, "rect");
        trayOut.setAttribute("x", -size * 0.6);
        trayOut.setAttribute("y", size * 0.5);
        trayOut.setAttribute("width", size * 1.2);
        trayOut.setAttribute("height", size * 0.35);
        trayOut.setAttribute("rx", 2);
        g.appendChild(trayOut);
        const paper = document.createElementNS(ns, "rect");
        paper.setAttribute("x", -size * 0.5);
        paper.setAttribute("y", size * 0.3);
        paper.setAttribute("width", size * 1);
        paper.setAttribute("height", size * 0.5);
        paper.style.fill = "#e2e8f0";
        g.appendChild(paper);
        return g;
       }
       if (shape === "access-point" || shape === "wifi") {
        const g = document.createElementNS(ns, "g");
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.3);
        base.setAttribute("y", size * 0.2);
        base.setAttribute("width", size * 0.6);
        base.setAttribute("height", size * 0.3);
        base.setAttribute("rx", 3);
        g.appendChild(base);
        for (let i = 1; i <= 3; i++) {
         const arc = document.createElementNS(ns, "path");
         const r = size * 0.3 * i;
         arc.setAttribute("d", `M ${-r * 0.7} ${size * 0.1 - r * 0.5} A ${r} ${r} 0 0 1 ${r * 0.7} ${size * 0.1 - r * 0.5}`);
         arc.style.fill = "none";
         arc.style.stroke = "currentColor";
         arc.style.strokeWidth = "2";
         arc.style.opacity = 1 - (i * 0.2);
         g.appendChild(arc);
        }
        return g;
       }
       if (shape === "load-balancer") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.5);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        const bar = document.createElementNS(ns, "line");
        bar.setAttribute("x1", -size * 0.6);
        bar.setAttribute("y1", 0);
        bar.setAttribute("x2", size * 0.6);
        bar.setAttribute("y2", 0);
        bar.style.stroke = "#4ade80";
        bar.style.strokeWidth = "3";
        g.appendChild(bar);
        [-1, 1].forEach(dir => {
         const arrow = document.createElementNS(ns, "path");
         arrow.setAttribute("d", `M ${dir * size * 0.3} ${-size * 0.2} L ${dir * size * 0.6} 0 L ${dir * size * 0.3} ${size * 0.2}`);
         arrow.style.fill = "none";
         arrow.style.stroke = "#4ade80";
         arrow.style.strokeWidth = "2";
         g.appendChild(arrow);
        });
        return g;
       }
       if (shape === "nas" || shape === "storage") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.8);
        body.setAttribute("y", -size * 0.9);
        body.setAttribute("width", size * 1.6);
        body.setAttribute("height", size * 1.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 4; i++) {
         const bay = document.createElementNS(ns, "rect");
         bay.setAttribute("x", -size * 0.6);
         bay.setAttribute("y", -size * 0.7 + i * size * 0.4);
         bay.setAttribute("width", size * 1.2);
         bay.setAttribute("height", size * 0.3);
         bay.setAttribute("rx", 2);
         bay.style.fill = "#1e293b";
         g.appendChild(bay);
        }
        return g;
       }
       if (shape === "gateway" || shape === "modem") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.5);
        body.setAttribute("y", -size * 0.9);
        body.setAttribute("width", size);
        body.setAttribute("height", size * 1.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 4; i++) {
         const led = document.createElementNS(ns, "circle");
         led.setAttribute("cx", 0);
         led.setAttribute("cy", -size * 0.6 + i * size * 0.35);
         led.setAttribute("r", size * 0.08);
         led.style.fill = ["#4ade80", "#4ade80", "#facc15", "#60a5fa"][i];
         g.appendChild(led);
        }
        return g;
       }
       if (shape === "vpn" || shape === "tunnel") {
        const g = document.createElementNS(ns, "g");
        const outer = document.createElementNS(ns, "ellipse");
        outer.setAttribute("cx", 0);
        outer.setAttribute("cy", 0);
        outer.setAttribute("rx", size);
        outer.setAttribute("ry", size * 0.6);
        g.appendChild(outer);
        const inner = document.createElementNS(ns, "ellipse");
        inner.setAttribute("cx", 0);
        inner.setAttribute("cy", 0);
        inner.setAttribute("rx", size * 0.5);
        inner.setAttribute("ry", size * 0.3);
        inner.style.fill = "#1e293b";
        g.appendChild(inner);
        const lock = document.createElementNS(ns, "rect");
        lock.setAttribute("x", -size * 0.15);
        lock.setAttribute("y", -size * 0.1);
        lock.setAttribute("width", size * 0.3);
        lock.setAttribute("height", size * 0.25);
        lock.setAttribute("rx", 2);
        lock.style.fill = "#4ade80";
        g.appendChild(lock);
        return g;
       }
       if (shape === "container") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.5);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 3; i++) {
         const block = document.createElementNS(ns, "rect");
         block.setAttribute("x", -size * 0.8 + i * size * 0.55);
         block.setAttribute("y", -size * 0.3);
         block.setAttribute("width", size * 0.45);
         block.setAttribute("height", size * 0.6);
         block.setAttribute("rx", 2);
         block.style.fill = "#1e293b";
         g.appendChild(block);
        }
        return g;
       }
       if (shape === "vm" || shape === "virtual") {
        const g = document.createElementNS(ns, "g");
        const shadow = document.createElementNS(ns, "rect");
        shadow.setAttribute("x", -size * 0.85 + 4);
        shadow.setAttribute("y", -size * 0.65 + 4);
        shadow.setAttribute("width", size * 1.7);
        shadow.setAttribute("height", size * 1.3);
        shadow.setAttribute("rx", 4);
        shadow.style.opacity = "0.3";
        g.appendChild(shadow);
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.85);
        body.setAttribute("y", -size * 0.65);
        body.setAttribute("width", size * 1.7);
        body.setAttribute("height", size * 1.3);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.65);
        screen.setAttribute("y", -size * 0.45);
        screen.setAttribute("width", size * 1.3);
        screen.setAttribute("height", size * 0.7);
        screen.setAttribute("rx", 2);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        return g;
       }
       if (shape === "kubernetes" || shape === "k8s") {
        const g = document.createElementNS(ns, "g");
        const outer = document.createElementNS(ns, "circle");
        outer.setAttribute("cx", 0);
        outer.setAttribute("cy", 0);
        outer.setAttribute("r", size);
        g.appendChild(outer);
        const inner = document.createElementNS(ns, "circle");
        inner.setAttribute("cx", 0);
        inner.setAttribute("cy", 0);
        inner.setAttribute("r", size * 0.4);
        inner.style.fill = "#1e293b";
        g.appendChild(inner);
        for (let i = 0; i < 7; i++) {
         const angle = (Math.PI * 2 / 7) * i - Math.PI / 2;
         const spoke = document.createElementNS(ns, "line");
         spoke.setAttribute("x1", Math.cos(angle) * size * 0.4);
         spoke.setAttribute("y1", Math.sin(angle) * size * 0.4);
         spoke.setAttribute("x2", Math.cos(angle) * size * 0.85);
         spoke.setAttribute("y2", Math.sin(angle) * size * 0.85);
         spoke.style.stroke = "#326ce5";
         spoke.style.strokeWidth = "3";
         g.appendChild(spoke);
        }
        return g;
       }
       
       if (shape === "shield" || shape === "security") {
        const p = document.createElementNS(ns, "path");
        const s = size;
        p.setAttribute("d", `M 0 ${-s} L ${s * 0.85} ${-s * 0.5} L ${s * 0.85} ${s * 0.2} Q ${s * 0.7} ${s * 0.9} 0 ${s} Q ${-s * 0.7} ${s * 0.9} ${-s * 0.85} ${s * 0.2} L ${-s * 0.85} ${-s * 0.5} Z`);
        return p;
       }
       if (shape === "camera" || shape === "cctv") {
        const g = document.createElementNS(ns, "g");
        const mount = document.createElementNS(ns, "rect");
        mount.setAttribute("x", -size * 1.1);
        mount.setAttribute("y", -size * 0.5);
        mount.setAttribute("width", size * 0.25);
        mount.setAttribute("height", size * 0.6);
        mount.setAttribute("rx", 2);
        g.appendChild(mount);
        const arm = document.createElementNS(ns, "rect");
        arm.setAttribute("x", -size * 0.9);
        arm.setAttribute("y", -size * 0.15);
        arm.setAttribute("width", size * 0.5);
        arm.setAttribute("height", size * 0.15);
        g.appendChild(arm);
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.45);
        body.setAttribute("y", -size * 0.35);
        body.setAttribute("width", size * 1.1);
        body.setAttribute("height", size * 0.7);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const lensHousing = document.createElementNS(ns, "circle");
        lensHousing.setAttribute("cx", size * 0.85);
        lensHousing.setAttribute("cy", 0);
        lensHousing.setAttribute("r", size * 0.4);
        g.appendChild(lensHousing);
        const lensOuter = document.createElementNS(ns, "circle");
        lensOuter.setAttribute("cx", size * 0.85);
        lensOuter.setAttribute("cy", 0);
        lensOuter.setAttribute("r", size * 0.28);
        lensOuter.style.fill = "#1e293b";
        g.appendChild(lensOuter);
        const lensInner = document.createElementNS(ns, "circle");
        lensInner.setAttribute("cx", size * 0.85);
        lensInner.setAttribute("cy", 0);
        lensInner.setAttribute("r", size * 0.15);
        lensInner.style.fill = "#3b82f6";
        g.appendChild(lensInner);
        const reflection = document.createElementNS(ns, "circle");
        reflection.setAttribute("cx", size * 0.8);
        reflection.setAttribute("cy", -size * 0.05);
        reflection.setAttribute("r", size * 0.05);
        reflection.style.fill = "#93c5fd";
        g.appendChild(reflection);
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", -size * 0.2);
        led.setAttribute("cy", -size * 0.15);
        led.setAttribute("r", size * 0.06);
        led.style.fill = "#ef4444";
        g.appendChild(led);
        return g;
       }
       if (shape === "monitor" || shape === "dashboard") {
        const g = document.createElementNS(ns, "g");
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size);
        screen.setAttribute("y", -size * 0.7);
        screen.setAttribute("width", size * 2);
        screen.setAttribute("height", size * 1.2);
        screen.setAttribute("rx", 4);
        g.appendChild(screen);
        const graph = document.createElementNS(ns, "polyline");
        graph.setAttribute("points", `${-size * 0.8},${size * 0.2} ${-size * 0.3},${-size * 0.2} ${size * 0.2},${size * 0.1} ${size * 0.7},${-size * 0.3}`);
        graph.style.fill = "none";
        graph.style.stroke = "#4ade80";
        graph.style.strokeWidth = "3";
        g.appendChild(graph);
        return g;
       }
       if (shape === "docker" || shape === "whale") {
        const g = document.createElementNS(ns, "g");
        const s = size;
        const body = document.createElementNS(ns, "path");
        body.setAttribute("d", `
         M ${-s * 0.9} ${s * 0.2}
         Q ${-s * 1.1} ${s * 0.5} ${-s * 0.7} ${s * 0.7}
         Q ${-s * 0.3} ${s * 0.85} ${s * 0.3} ${s * 0.75}
         Q ${s * 0.8} ${s * 0.6} ${s * 1.0} ${s * 0.3}
         Q ${s * 1.1} ${s * 0.1} ${s * 1.0} ${-s * 0.1}
         L ${s * 0.85} ${-s * 0.1}
         Q ${s * 0.7} ${-s * 0.15} ${s * 0.4} ${-s * 0.2}
         L ${-s * 0.5} ${-s * 0.2}
         Q ${-s * 0.8} ${-s * 0.1} ${-s * 0.9} ${s * 0.2}
         Z
        `);
        body.style.fill = "#0db7ed";
        g.appendChild(body);
        const tail = document.createElementNS(ns, "path");
        tail.setAttribute("d", `
         M ${-s * 0.85} ${s * 0.1}
         Q ${-s * 1.2} ${-s * 0.2} ${-s * 1.0} ${-s * 0.55}
         Q ${-s * 0.95} ${-s * 0.35} ${-s * 0.8} ${-s * 0.15}
         Z
        `);
        tail.style.fill = "#0db7ed";
        g.appendChild(tail);
        const belly = document.createElementNS(ns, "path");
        belly.setAttribute("d", `
         M ${-s * 0.5} ${s * 0.65}
         Q ${s * 0.1} ${s * 0.75} ${s * 0.6} ${s * 0.55}
         Q ${s * 0.8} ${s * 0.45} ${s * 0.9} ${s * 0.25}
         Q ${s * 0.7} ${s * 0.5} ${s * 0.3} ${s * 0.6}
         Q ${-s * 0.1} ${s * 0.7} ${-s * 0.5} ${s * 0.65}
         Z
        `);
        belly.style.fill = "#ffffff";
        belly.style.opacity = "0.3";
        g.appendChild(belly);
        for (let row = 0; row < 2; row++) {
         for (let col = 0; col < 3; col++) {
          const container = document.createElementNS(ns, "rect");
          container.setAttribute("x", -s * 0.45 + col * s * 0.35);
          container.setAttribute("y", -s * 0.7 + row * s * 0.28);
          container.setAttribute("width", s * 0.3);
          container.setAttribute("height", s * 0.23);
          container.setAttribute("rx", 2);
          container.style.fill = "#0db7ed";
          container.style.stroke = "#0a9ed8";
          container.style.strokeWidth = "1.5";
          g.appendChild(container);
         }
        }
        const topContainer = document.createElementNS(ns, "rect");
        topContainer.setAttribute("x", -s * 0.1);
        topContainer.setAttribute("y", -s * 0.95);
        topContainer.setAttribute("width", s * 0.3);
        topContainer.setAttribute("height", s * 0.23);
        topContainer.setAttribute("rx", 2);
        topContainer.style.fill = "#0db7ed";
        topContainer.style.stroke = "#0a9ed8";
        topContainer.style.strokeWidth = "1.5";
        g.appendChild(topContainer);
        const eye = document.createElementNS(ns, "circle");
        eye.setAttribute("cx", s * 0.65);
        eye.setAttribute("cy", s * 0.25);
        eye.setAttribute("r", s * 0.08);
        eye.style.fill = "#0a5f7a";
        g.appendChild(eye);
        
        return g;
       }
       if (shape === "rounded-square") {
        const r = document.createElementNS(ns, "rect");
        const s = size * 1.6;
        r.setAttribute("x", -s / 2);
        r.setAttribute("y", -s / 2);
        r.setAttribute("width", s);
        r.setAttribute("height", s);
        r.setAttribute("rx", size * 0.4);
        return r;
       }
       if (shape === "pill" || shape === "capsule") {
        const r = document.createElementNS(ns, "rect");
        r.setAttribute("x", -size * 1.2);
        r.setAttribute("y", -size * 0.5);
        r.setAttribute("width", size * 2.4);
        r.setAttribute("height", size);
        r.setAttribute("rx", size * 0.5);
        return r;
       }
       if (shape === "octagon") {
        const p = document.createElementNS(ns, "polygon");
        const r = size;
        const pts = [];
        for (let i = 0; i < 8; i++) {
         const a = (Math.PI / 4) * i - Math.PI / 8;
         pts.push([Math.cos(a) * r, Math.sin(a) * r]);
        }
        p.setAttribute("points", pts.map(pt => pt.join(",")).join(" "));
        return p;
       }
       if (shape === "pentagon") {
        const p = document.createElementNS(ns, "polygon");
        const pts = [];
        for (let i = 0; i < 5; i++) {
         const a = (Math.PI * 2 / 5) * i - Math.PI / 2;
         pts.push([Math.cos(a) * size, Math.sin(a) * size]);
        }
        p.setAttribute("points", pts.map(pt => pt.join(",")).join(" "));
        return p;
       }
       if (shape === "cross" || shape === "plus") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        const t = size * 0.35;
        p.setAttribute("points", `${-t},${-s} ${t},${-s} ${t},${-t} ${s},${-t} ${s},${t} ${t},${t} ${t},${s} ${-t},${s} ${-t},${t} ${-s},${t} ${-s},${-t} ${-t},${-t}`);
        return p;
       }
       if (shape === "parallelogram") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `${-s * 0.6},${-s * 0.6} ${s * 1.2},${-s * 0.6} ${s * 0.6},${s * 0.6} ${-s * 1.2},${s * 0.6}`);
        return p;
       }
       if (shape === "trapezoid") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `${-s * 0.6},${-s * 0.6} ${s * 0.6},${-s * 0.6} ${s},${s * 0.6} ${-s},${s * 0.6}`);
        return p;
       }
       if (shape === "sensor" || shape === "iot") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "circle");
        body.setAttribute("cx", 0);
        body.setAttribute("cy", 0);
        body.setAttribute("r", size * 0.7);
        g.appendChild(body);
        const ant = document.createElementNS(ns, "line");
        ant.setAttribute("x1", 0);
        ant.setAttribute("y1", -size * 0.7);
        ant.setAttribute("x2", 0);
        ant.setAttribute("y2", -size);
        ant.style.stroke = "currentColor";
        ant.style.strokeWidth = "2";
        g.appendChild(ant);
        const tip = document.createElementNS(ns, "circle");
        tip.setAttribute("cx", 0);
        tip.setAttribute("cy", -size);
        tip.setAttribute("r", size * 0.1);
        tip.style.fill = "#4ade80";
        g.appendChild(tip);
        return g;
       }
       if (shape === "pi" || shape === "sbc" || shape === "raspberry") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.65);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size * 1.3);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 10; i++) {
         const pin = document.createElementNS(ns, "rect");
         pin.setAttribute("x", -size * 0.85 + i * size * 0.19);
         pin.setAttribute("y", -size * 0.8);
         pin.setAttribute("width", size * 0.08);
         pin.setAttribute("height", size * 0.15);
         pin.style.fill = "#facc15";
         g.appendChild(pin);
        }
        const port = document.createElementNS(ns, "rect");
        port.setAttribute("x", size * 0.6);
        port.setAttribute("y", -size * 0.2);
        port.setAttribute("width", size * 0.35);
        port.setAttribute("height", size * 0.4);
        port.style.fill = "#1e293b";
        g.appendChild(port);
        return g;
       }
       if (shape === "api" || shape === "endpoint") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.9);
        body.setAttribute("y", -size * 0.7);
        body.setAttribute("width", size * 1.8);
        body.setAttribute("height", size * 1.4);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        const left = document.createElementNS(ns, "text");
        left.setAttribute("x", -size * 0.5);
        left.setAttribute("y", size * 0.15);
        left.setAttribute("font-size", size * 0.9);
        left.setAttribute("fill", "#4ade80");
        left.setAttribute("font-family", "monospace");
        left.textContent = "{";
        g.appendChild(left);
        const right = document.createElementNS(ns, "text");
        right.setAttribute("x", size * 0.15);
        right.setAttribute("y", size * 0.15);
        right.setAttribute("font-size", size * 0.9);
        right.setAttribute("fill", "#4ade80");
        right.setAttribute("font-family", "monospace");
        right.textContent = "}";
        g.appendChild(right);
        return g;
       }
       if (shape === "queue" || shape === "message") {
        const g = document.createElementNS(ns, "g");
        for (let i = 2; i >= 0; i--) {
         const card = document.createElementNS(ns, "rect");
         card.setAttribute("x", -size * 0.7 + i * 4);
         card.setAttribute("y", -size * 0.5 + i * 4);
         card.setAttribute("width", size * 1.4);
         card.setAttribute("height", size * 0.8);
         card.setAttribute("rx", 3);
         card.style.opacity = 1 - i * 0.25;
         g.appendChild(card);
        }
        return g;
       }
       if (shape === "lambda" || shape === "function") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.8);
        body.setAttribute("y", -size * 0.8);
        body.setAttribute("width", size * 1.6);
        body.setAttribute("height", size * 1.6);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const lambda = document.createElementNS(ns, "text");
        lambda.setAttribute("x", 0);
        lambda.setAttribute("y", size * 0.2);
        lambda.setAttribute("font-size", size * 1.2);
        lambda.setAttribute("fill", "#f59e0b");
        lambda.setAttribute("text-anchor", "middle");
        lambda.setAttribute("font-family", "serif");
        lambda.textContent = "λ";
        g.appendChild(lambda);
        return g;
       }
       if (shape === "bucket" || shape === "s3") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "path");
        body.setAttribute("d", `M ${-size * 0.8} ${-size * 0.7} L ${-size * 0.6} ${size * 0.8} Q ${-size * 0.5} ${size} 0 ${size} Q ${size * 0.5} ${size} ${size * 0.6} ${size * 0.8} L ${size * 0.8} ${-size * 0.7} Z`);
        g.appendChild(body);
        const rim = document.createElementNS(ns, "ellipse");
        rim.setAttribute("cx", 0);
        rim.setAttribute("cy", -size * 0.7);
        rim.setAttribute("rx", size * 0.8);
        rim.setAttribute("ry", size * 0.25);
        g.appendChild(rim);
        return g;
       }   
       const c = document.createElementNS(ns, "circle");
       c.setAttribute("r", size);
       return c;
      }
      
      function createNodeShape(id, size) {
       const shapeType = (NODE_DATA[id] && NODE_DATA[id].shape) || "circle";
       const shapeEl = createShapeElement(shapeType, size);
       shapeEl.classList.add("node-circle");
       const styles = resolveStylesForNode(id);
       shapeEl.style.fill = styles.circleColor || PAGE_STATE.nodeFill || "#1e293b";
       shapeEl.style.stroke = styles.circleBorder || PAGE_STATE.nodeStroke || "#475569";
       return shapeEl;
      }
      
      function forgeTheLegend() {
       const container = document.getElementById("edge-legend");
       if (!container) return;
       container.innerHTML = "";
       const title = document.createElement("div");
       title.className = "legend-title";
       title.textContent = "Line Legend";
       container.appendChild(title);
       const closeBtn = document.createElement("button");
       closeBtn.type = "button";
       closeBtn.className = "legend-close-btn";
       closeBtn.textContent = "✕";
       closeBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        legendCollapsed = true;
        updateLegendVisibility();
       });
       container.appendChild(closeBtn);
       const colors = [...new Set(EDGE_DATA.list.map((e) => e.color).filter(Boolean))];
       if (colors.length === 0) {
        updateLegendVisibility();
        return;
       }
       colors.forEach((color) => {
        if (!EDGE_LEGEND[color]) {
         EDGE_LEGEND[color] = "you can edit me too";
        }
        const item = document.createElement("div");
        item.className = "legend-item";
        item.addEventListener("mousedown", (e) => e.stopPropagation());
        item.addEventListener("click", (e) => e.stopPropagation());
        const swatch = document.createElement("span");
        swatch.className = "legend-swatch";
        swatch.style.backgroundColor = color;
        swatch.style.cursor = "pointer";
        swatch.addEventListener("click", (e) => {
         e.stopPropagation();
         const edgeWithColor = EDGE_DATA.list.find(edge => edge.color === color);
         if (edgeWithColor) {
          selectTheConnection(edgeWithColor.id);
         }
        });
        let swatchTouchStart = null;
        let swatchTouchMoved = false;
        swatch.addEventListener("touchstart", (e) => {
         swatchTouchStart = Date.now();
         swatchTouchMoved = false;
         if (e.touches[0]) {
          swatchTouchStartX = e.touches[0].clientX;
          swatchTouchStartY = e.touches[0].clientY;
         }
        }, {
         passive: false
        });
        let swatchTouchStartX = 0, swatchTouchStartY = 0;
        swatch.addEventListener("touchmove", (e) => {
         if (e.touches[0]) {
          const dx = Math.abs(e.touches[0].clientX - swatchTouchStartX);
          const dy = Math.abs(e.touches[0].clientY - swatchTouchStartY);
          if (dx > 10 || dy > 10) swatchTouchMoved = true;
         }
        }, {
         passive: false
        });
        swatch.addEventListener("touchend", (e) => {
         if (swatchTouchStart && !swatchTouchMoved && Date.now() - swatchTouchStart < 400) {
          e.stopPropagation();
          e.preventDefault();
          const edgeWithColor = EDGE_DATA.list.find(edge => edge.color === color);
          if (edgeWithColor) {
           selectTheConnection(edgeWithColor.id);
          }
         }
         swatchTouchStart = null;
         swatchTouchMoved = false;
        }, {
         passive: false
        });
        const label = document.createElement("span");
        label.className = "legend-label";
        label.textContent = EDGE_LEGEND[color];
        if (isMobileDevice()) {
         label.style.cursor = "pointer";
         let labelTapStart = null;
         let labelTapMoved = false;
         label.addEventListener("touchstart", (e) => {
          labelTapStart = Date.now();
          labelTapMoved = false;
          if (e.touches[0]) {
           labelTapStartX = e.touches[0].clientX;
           labelTapStartY = e.touches[0].clientY;
          }
          e.stopPropagation();
         });
         let labelTapStartX = 0, labelTapStartY = 0;
         label.addEventListener("touchmove", (e) => {
          if (e.touches[0]) {
           const dx = Math.abs(e.touches[0].clientX - labelTapStartX);
           const dy = Math.abs(e.touches[0].clientY - labelTapStartY);
           if (dx > 10 || dy > 10) labelTapMoved = true;
          }
         });
         label.addEventListener("touchend", (e) => {
          if (labelTapStart && !labelTapMoved && Date.now() - labelTapStart < 400) {
           e.preventDefault();
           e.stopPropagation();
           const currentText = label.textContent;
           const newText = prompt("Edit legend label:", currentText);
           if (newText !== null && newText.trim()) {
            label.textContent = newText.trim();
            EDGE_LEGEND[color] = newText.trim();
            
           }
          }
          labelTapStart = null;
          labelTapMoved = false;
         });
        } else {
         label.contentEditable = true;
         label.addEventListener("focus", () => {
          label.classList.add("editing");
         });
         label.addEventListener("blur", () => {
          label.classList.remove("editing");
          const text = label.textContent.trim() || "you can edit me too";
          EDGE_LEGEND[color] = text;
          
         });
         label.addEventListener("keydown", (e) => {
          if (e.key === "Enter") {
           e.preventDefault();
           label.blur();
          }
         });
        }
        item.append(swatch, label);
        container.appendChild(item);
       });
       updateLegendVisibility();
      }
      
       function deleteRectangle(rectId) {
      pushUndo("delete zone");
        RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== rectId);
        forgeTheTopology();
       }
      
       function updateRectangleDeleteButtons() {
        const deleteButtons = document.querySelectorAll('.rect-delete-btn');
        deleteButtons.forEach(btn => {
         btn.style.display = rectDrawMode ? 'block' : 'none';
        });
       }
      
      function forgeTheTopology() {
       if (!NODE_DATA || !EDGE_DATA) {
        console.warn("forgeTheTopology called before data initialized");
        return;
       }
       const svg = document.getElementById("map");
       svg.innerHTML = "";
       const ns = "http://www.w3.org/2000/svg";
       const defs = document.createElementNS(ns, "defs");
       const markerForward = document.createElementNS(ns, "marker");
       markerForward.id = "arrow-forward";
       markerForward.setAttribute("markerWidth", "10");
       markerForward.setAttribute("markerHeight", "10");
       markerForward.setAttribute("refX", "9");
       markerForward.setAttribute("refY", "3");
       markerForward.setAttribute("orient", "auto");
       markerForward.setAttribute("markerUnits", "strokeWidth");
       const pathForward = document.createElementNS(ns, "path");
       pathForward.setAttribute("d", "M0,0 L0,6 L9,3 z");
       pathForward.setAttribute("fill", "context-stroke");
       markerForward.appendChild(pathForward);
       defs.appendChild(markerForward);
       const markerBackward = document.createElementNS(ns, "marker");
       markerBackward.id = "arrow-backward";
       markerBackward.setAttribute("markerWidth", "10");
       markerBackward.setAttribute("markerHeight", "10");
       markerBackward.setAttribute("refX", "0");
       markerBackward.setAttribute("refY", "3");
       markerBackward.setAttribute("orient", "auto");
       markerBackward.setAttribute("markerUnits", "strokeWidth");
       const pathBackward = document.createElementNS(ns, "path");
       pathBackward.setAttribute("d", "M9,0 L9,6 L0,3 z");
       pathBackward.setAttribute("fill", "context-stroke");
       markerBackward.appendChild(pathBackward);
       defs.appendChild(markerBackward);
       svg.appendChild(defs);
       const boundary = document.createElementNS(ns, "rect");
       boundary.setAttribute("x", CANVAS_PADDING);
       boundary.setAttribute("y", CANVAS_PADDING);
       boundary.setAttribute("width", CANVAS_WIDTH - CANVAS_PADDING * 2);
       boundary.setAttribute("height", CANVAS_HEIGHT - CANVAS_PADDING * 2);
       boundary.setAttribute("fill", "none");
       boundary.setAttribute("stroke", (PAGE_STATE.canvasBorder || "#475569") + "4D");
       boundary.setAttribute("stroke-width", "20");
       boundary.setAttribute("stroke-dasharray", "10 5");
       boundary.setAttribute("rx", "8");
       svg.appendChild(boundary);
       
       if (currentView.mode !== "rack") {
        const gridGroup = document.createElementNS(ns, "g");
        gridGroup.id = "canvas-grid";
        const gridSize = PAGE_STATE.canvasGridSize || 50;
        const gridColor = (PAGE_STATE.canvasGrid || "#475569") + "33";
        const majorGridColor = (PAGE_STATE.canvasGrid || "#475569") + "66";
        
        for (let x = CANVAS_PADDING; x <= CANVAS_WIDTH - CANVAS_PADDING; x += gridSize) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", x);
         line.setAttribute("y1", CANVAS_PADDING);
         line.setAttribute("x2", x);
         line.setAttribute("y2", CANVAS_HEIGHT - CANVAS_PADDING);
         line.setAttribute("stroke", (x - CANVAS_PADDING) % (gridSize * 5) === 0 ? majorGridColor : gridColor);
         line.setAttribute("stroke-width", (x - CANVAS_PADDING) % (gridSize * 5) === 0 ? "2" : "1");
         gridGroup.appendChild(line);
        }
        
        for (let y = CANVAS_PADDING; y <= CANVAS_HEIGHT - CANVAS_PADDING; y += gridSize) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", CANVAS_PADDING);
         line.setAttribute("y1", y);
         line.setAttribute("x2", CANVAS_WIDTH - CANVAS_PADDING);
         line.setAttribute("y2", y);
         line.setAttribute("stroke", (y - CANVAS_PADDING) % (gridSize * 5) === 0 ? majorGridColor : gridColor);
         line.setAttribute("stroke-width", (y - CANVAS_PADDING) % (gridSize * 5) === 0 ? "2" : "1");
         gridGroup.appendChild(line);
        }
        
        svg.appendChild(gridGroup);
       }
       
       if (currentView.mode === "rack" && currentView.rackId) {
        const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
        const rackGroup = document.createElementNS(ns, "g");
        rackGroup.id = "rack-visualization";
        
        const rackFrame = document.createElementNS(ns, "rect");
        rackFrame.setAttribute("x", RACK_START_X - RACK_WIDTH / 2);
        rackFrame.setAttribute("y", RACK_START_Y);
        rackFrame.setAttribute("width", RACK_WIDTH);
      
      rackFrame.setAttribute("height", rackCapacity * rackUHeight);
      
        rackFrame.setAttribute("fill", (PAGE_STATE.rackFrameFill || "#0f172a") + "4D");
        rackFrame.setAttribute("stroke", PAGE_STATE.rackFrameStroke || "#4fd1c5");
        rackFrame.setAttribute("stroke-width", "3");
        rackFrame.setAttribute("rx", "4");
        rackGroup.appendChild(rackFrame);
        
        for (let u = 0; u <= rackCapacity; u++) {
         const y = RACK_START_Y + u * rackUHeight;
      
         
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", RACK_START_X - RACK_WIDTH / 2);
         line.setAttribute("y1", y);
         line.setAttribute("x2", RACK_START_X + RACK_WIDTH / 2);
         line.setAttribute("y2", y);
         line.setAttribute("stroke", (PAGE_STATE.rackLineColor || "#475569") + "66");
         line.setAttribute("stroke-width", u % 5 === 0 ? "2" : "1");
         line.setAttribute("stroke-dasharray", u % 5 === 0 ? "none" : "5,5");
         rackGroup.appendChild(line);
         
         if (u < rackCapacity) {
          const uNumber = rackCapacity - u; 
          const text = document.createElementNS(ns, "text");
          text.setAttribute("x", RACK_START_X - RACK_WIDTH / 2 - 30);
          text.setAttribute("y", y + rackUHeight / 2);
      
          text.setAttribute("text-anchor", "middle");
          text.setAttribute("dominant-baseline", "middle");
          text.style.fill = PAGE_STATE.rackTextColor || "#4fd1c5";
          text.style.fontSize = "14px";
          text.style.fontWeight = "bold";
          text.textContent = `U${uNumber}`;
          rackGroup.appendChild(text);
          
          const textRight = document.createElementNS(ns, "text");
          textRight.setAttribute("x", RACK_START_X + RACK_WIDTH / 2 + 30);
          textRight.setAttribute("y", y + rackUHeight / 2);
      
          textRight.setAttribute("text-anchor", "middle");
          textRight.setAttribute("dominant-baseline", "middle");
          textRight.style.fill = PAGE_STATE.rackTextColor || "#4fd1c5";
          textRight.style.fontSize = "14px";
          textRight.style.fontWeight = "bold";
          textRight.textContent = `U${uNumber}`;
          rackGroup.appendChild(textRight);
         }
        }
        
        svg.appendChild(rackGroup);
       }
       
        if (RECT_DATA && RECT_DATA.list) {
         RECT_DATA.list.forEach((rect) => {
          if (currentView.mode === "rack") return;
          
          if (rect.style === "filled") {
           const g = document.createElementNS(ns, "g");
           g.classList.add("rect-group");
           g.dataset.rectId = rect.id;
           
           const rectEl = document.createElementNS(ns, "rect");
           rectEl.classList.add("rect-shape");
           rectEl.setAttribute("x", rect.x);
           rectEl.setAttribute("y", rect.y);
           rectEl.setAttribute("width", rect.width);
           rectEl.setAttribute("height", rect.height);
           rectEl.style.fill = rect.color;
           rectEl.style.fillOpacity = "0.3";
           rectEl.style.stroke = rect.borderColor || rect.color;
           rectEl.style.strokeWidth = (rect.borderWidth !== undefined ? rect.borderWidth : 2) + "px";
           if (rect.lineStyle === "dashed") { rectEl.style.strokeDasharray = "10,5"; }
           else if (rect.lineStyle === "dotted") { rectEl.style.strokeDasharray = "2,4"; }
           else { rectEl.style.strokeDasharray = "none"; }
           rectEl.style.cursor = "move";
           
          rectEl.addEventListener("click", (e) => {
		  if (isViewOnly()) return;
             if (rectDrawMode) return;
             e.stopPropagation();
             currentRectId = rect.id;
             selectTheRect(rect.id);
           });
           
           rectEl.addEventListener("contextmenu", (e) => {
		   if (isViewOnly()) return;
             e.preventDefault();
             e.stopPropagation();
             if (selectedRects.has(rect.id)) {
               selectedRects.delete(rect.id);
             } else {
               selectedRects.add(rect.id);
             }
             updateAllSelections();
           });
           
           let rectLastTap = 0;
           rectEl.addEventListener("touchend", (e) => {
             const now = Date.now();
             if (now - rectLastTap < 300) {
               e.preventDefault();
               if (selectedRects.has(rect.id)) {
                 selectedRects.delete(rect.id);
               } else {
                 selectedRects.add(rect.id);
               }
               updateAllSelections();
               if (navigator.vibrate) navigator.vibrate(50);
               rectLastTap = 0;
             } else {
               rectLastTap = now;
             }
           }, { passive: false });
      
           const deleteBtn = document.createElementNS(ns, "g");
           deleteBtn.classList.add("rect-delete-btn");
           deleteBtn.style.cursor = "pointer";
           deleteBtn.style.display = rectDrawMode ? "block" : "none";
           
           const deleteBg = document.createElementNS(ns, "circle");
           deleteBg.setAttribute("cx", rect.x + rect.width - 10);
           deleteBg.setAttribute("cy", rect.y + 10);
           deleteBg.setAttribute("r", 12);
           deleteBg.style.fill = "#f56565";
           deleteBg.style.stroke = "white";
           deleteBg.style.strokeWidth = "2";
           
           const deleteX = document.createElementNS(ns, "text");
           deleteX.setAttribute("x", rect.x + rect.width - 10);
           deleteX.setAttribute("y", rect.y + 10);
           deleteX.setAttribute("text-anchor", "middle");
           deleteX.setAttribute("dominant-baseline", "middle");
           deleteX.style.fill = "white";
           deleteX.style.fontSize = "16px";
           deleteX.style.fontWeight = "bold";
           deleteX.style.pointerEvents = "none";
           deleteX.textContent = "×";
           
           deleteBtn.appendChild(deleteBg);
           deleteBtn.appendChild(deleteX);
           
           deleteBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            e.preventDefault();
            deleteRectangle(rect.id);
           });
      
           deleteBtn.addEventListener("touchend", (e) => {
      e.stopPropagation();
           e.preventDefault();
           deleteRectangle(rect.id);
           });
           
           let isDragging = false;
           let dragStartX, dragStartY;
           let rectStartX, rectStartY;
           
         rectEl.addEventListener("mousedown", (e) => {
		 if (isViewOnly()) return;
      if (rectDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      rectStartX = rect.x;
      rectStartY = rect.y;
      rectEl.style.cursor = "grabbing";
      
      if (selectedRects.has(rect.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
           
           const moveHandler = (e) => {
      if (!isDragging || rectDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      
      rect.x = rectStartX + dx;
      rect.y = rectStartY + dy;
      
      if (selectedRects.has(rect.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       const newX = initialPositions[nodeId].x + dx;
       const newY = initialPositions[nodeId].y + dy;
       savedPositions[nodeId] = { x: newX, y: newY };
      }
      });
      selectedRects.forEach(rectId => {
      if (rectId === rect.id) return;
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      
      forgeTheTopology();
      };
           
           const upHandler = () => {
            if (isDragging) {
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           };
           
           document.addEventListener("mousemove", moveHandler);
           document.addEventListener("mouseup", upHandler);
           
           let touchStartX, touchStartY;
           let touchRectStartX, touchRectStartY;
           
           rectEl.addEventListener("touchstart", (e) => {
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchRectStartX = rect.x;
            touchRectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           }, { passive: false });
           
           rectEl.addEventListener("touchmove", (e) => {
            if (!isDragging || rectDrawMode) return;
            if (!e.touches[0]) return;
            e.preventDefault();
            e.stopPropagation();
            
            const svgEl = svg;
            const pt1 = svgEl.createSVGPoint();
            pt1.x = touchStartX;
            pt1.y = touchStartY;
            const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
            
            const touch = e.touches[0];
            const pt2 = svgEl.createSVGPoint();
            pt2.x = touch.clientX;
            pt2.y = touch.clientY;
            const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
            
            const dx = svgP2.x - svgP1.x;
            const dy = svgP2.y - svgP1.y;
            
            rect.x = touchRectStartX + dx;
            rect.y = touchRectStartY + dy;
            
            forgeTheTopology();
           }, { passive: false });
           
           rectEl.addEventListener("touchend", (e) => {
            if (isDragging) {
             e.preventDefault();
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           }, { passive: false });
            if (currentRectId === rect.id) {
      const corners = [
      { cx: rect.x, cy: rect.y, cursor: 'nwse-resize', dx: -1, dy: -1 },
      { cx: rect.x + rect.width, cy: rect.y, cursor: 'nesw-resize', dx: 1, dy: -1 },
      { cx: rect.x, cy: rect.y + rect.height, cursor: 'nesw-resize', dx: -1, dy: 1 },
      { cx: rect.x + rect.width, cy: rect.y + rect.height, cursor: 'nwse-resize', dx: 1, dy: 1 }
      ];
      corners.forEach((corner, idx) => {
      const handle = document.createElementNS(ns, "circle");
      handle.setAttribute("cx", corner.cx);
      handle.setAttribute("cy", corner.cy);
      handle.setAttribute("r", PAGE_STATE.selectionHandleSize || 8);
      handle.style.fill = PAGE_STATE.selectionHandle || "#f59e0b";
      handle.style.stroke = "#fff";
      handle.style.strokeWidth = "2";
      handle.style.cursor = corner.cursor;
      handle.addEventListener("mousedown", (e) => {
      e.preventDefault();
      e.stopPropagation();
      let dragging = true;
      const startX = e.clientX, startY = e.clientY;
      const origX = rect.x, origY = rect.y, origW = rect.width, origH = rect.height;
      const moveHandler = (ev) => {
        if (!dragging) return;
        const pt1 = svg.createSVGPoint(); pt1.x = startX; pt1.y = startY;
        const pt2 = svg.createSVGPoint(); pt2.x = ev.clientX; pt2.y = ev.clientY;
        const svgP1 = pt1.matrixTransform(svg.getScreenCTM().inverse());
        const svgP2 = pt2.matrixTransform(svg.getScreenCTM().inverse());
        const dx = svgP2.x - svgP1.x, dy = svgP2.y - svgP1.y;
        if (corner.dx < 0) { rect.x = origX + dx; rect.width = origW - dx; }
        else { rect.width = origW + dx; }
        if (corner.dy < 0) { rect.y = origY + dy; rect.height = origH - dy; }
        else { rect.height = origH + dy; }
        if (rect.width < 20) rect.width = 20;
        if (rect.height < 20) rect.height = 20;
        forgeTheTopology();
      };
      const upHandler = () => { dragging = false; document.removeEventListener("mousemove", moveHandler); document.removeEventListener("mouseup", upHandler); };
      document.addEventListener("mousemove", moveHandler);
      document.addEventListener("mouseup", upHandler);
      });
      g.appendChild(handle);
      });
      }
          if (rect.groupId) {
      const groupIndicator = document.createElementNS(ns, "rect");
      groupIndicator.setAttribute("x", rect.x - 4);
      groupIndicator.setAttribute("y", rect.y - 4);
      groupIndicator.setAttribute("width", rect.width + 8);
      groupIndicator.setAttribute("height", rect.height + 8);
      groupIndicator.style.fill = "none";
      groupIndicator.style.stroke = "#4fd1c5";
      groupIndicator.style.strokeWidth = "3";
      groupIndicator.style.strokeDasharray = "5,5";
      groupIndicator.style.pointerEvents = "none";
      g.insertBefore(groupIndicator, g.firstChild);
      }
      g.appendChild(rectEl);
      g.appendChild(deleteBtn);
      svg.appendChild(g);
          }
         });
        }
       const centerX = CANVAS_WIDTH / 2;
       const centerY = CANVAS_HEIGHT / 2;
       let positions = {};
              Object.keys(NODE_DATA).forEach((id) => {
        if (currentView.mode === "rack") {
         const node = NODE_DATA[id];
         if (!node || node.assignedRack !== currentView.rackId) {
          return; 
         }
        }
        
        positions[id] = savedPositions[id] || {
         x: centerX,
         y: centerY
        };
       });
       if (Object.keys(savedPositions).length === 0) {
        const nodeIds = Object.keys(NODE_DATA).filter(id => {
         if (currentView.mode === "rack") {
          const node = NODE_DATA[id];
          return node && node.assignedRack === currentView.rackId;
         }
         return true;
        });
        
        const baseY = centerY - 300;
        if (nodeIds.length > 0) {
         positions[nodeIds[0]] = {
          x: centerX,
          y: baseY
         };
         const remaining = nodeIds.slice(1);
         const radius = 350;
         const startAngle = Math.PI * 0.3;
         const endAngle = Math.PI * 0.7;
         remaining.forEach((id, i) => {
          const angle = startAngle + (endAngle - startAngle) * (i / Math.max(1, remaining.length - 1));
          positions[id] = {
           x: centerX + Math.cos(angle) * radius * (i % 2 === 0 ? 1 : 1.3),
           y: baseY + 200 + Math.sin(angle) * radius * 0.8 + i * 80,
          };
         });
        }
       }
       Object.keys(positions).forEach((id) => {
        let pos = savedPositions[id] || positions[id];
        const nodeSize = savedSizes[id] || 55;
        pos.x = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, pos.x), );
        pos.y = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, pos.y), );
        positions[id] = {
         x: pos.x,
         y: pos.y
        };
        savedPositions[id] = {
         x: pos.x,
         y: pos.y
        };
       });
       const edgePairCount = {};
       const edgePairIndex = {};
       EDGE_DATA.list.forEach((edge) => {
        if (edge.type === "custom") return;
        const key = [edge.from, edge.to].sort().join("||");
        edgePairCount[key] = (edgePairCount[key] || 0) + 1;
       });
       EDGE_DATA.list.forEach((edge) => {
        if (edge.type === "custom") return;
        const key = [edge.from, edge.to].sort().join("||");
        if (!edgePairIndex[key]) edgePairIndex[key] = 0;
        edge._pairIndex = edgePairIndex[key];
        edge._pairTotal = edgePairCount[key];
        edgePairIndex[key]++;
       });
       EDGE_DATA.list.forEach((edge) => {
        if (edge.type === "custom" && Array.isArray(edge.points) && edge.points.length >= 2) {
         const poly = document.createElementNS(ns, "polyline");
         poly.classList.add("edge");
         poly.dataset.edgeId = edge.id;
         poly.style.stroke = edge.color || PAGE_STATE.defaultEdge || "#475569";
         poly.style.strokeWidth = edge.width || 4;
         poly.setAttribute("fill", "none");
         const lineStyle = edge.lineStyle || "solid";
         if (lineStyle === "dashed") {
          poly.style.strokeDasharray = "10,5";
         } else if (lineStyle === "dotted") {
          poly.style.strokeDasharray = "2,4";
         } else {
          poly.style.strokeDasharray = "none";
         }
         const direction = edge.direction || "none";
         if (direction === "forward") {
          poly.setAttribute("marker-end", "url(#arrow-forward)");
         } else if (direction === "backward") {
          poly.setAttribute("marker-start", "url(#arrow-backward)");
         } else if (direction === "both") {
          poly.setAttribute("marker-start", "url(#arrow-backward)");
          poly.setAttribute("marker-end", "url(#arrow-forward)");
         }
         const ptsStr = edge.points.map((p) => `${p.x},${p.y}`).join(" ");
         poly.setAttribute("points", ptsStr);
         const polyHit = document.createElementNS(ns, "polyline");
         polyHit.setAttribute("points", ptsStr);
         polyHit.style.fill = "none";
         polyHit.style.stroke = "transparent";
         polyHit.style.strokeWidth = "20";
         polyHit.style.cursor = "pointer";
         polyHit.dataset.edgeId = edge.id;
         polyHit.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         let edgeTouchStart = null;
         let edgeTouchMoved = false;
         polyHit.addEventListener("touchstart", (e) => {
          edgeTouchStart = Date.now();
          edgeTouchMoved = false;
          if (e.touches[0]) {
           edgeTouchStartX = e.touches[0].clientX;
           edgeTouchStartY = e.touches[0].clientY;
          }
         }, {
          passive: false
         });
         let edgeTouchStartX = 0, edgeTouchStartY = 0;
         polyHit.addEventListener("touchmove", (e) => {
          if (e.touches[0]) {
           const dx = Math.abs(e.touches[0].clientX - edgeTouchStartX);
           const dy = Math.abs(e.touches[0].clientY - edgeTouchStartY);
           if (dx > 10 || dy > 10) edgeTouchMoved = true;
          }
         }, {
          passive: false
         });
         polyHit.addEventListener("touchend", (e) => {
          if (edgeTouchStart && !edgeTouchMoved && Date.now() - edgeTouchStart < 400) {
           e.stopPropagation();
           e.preventDefault();
           selectTheConnection(edge.id);
          }
          edgeTouchStart = null;
          edgeTouchMoved = false;
         }, {
          passive: false
         });
         poly.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         
         polyHit.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (selectedEdges.has(edge.id)) {
           selectedEdges.delete(edge.id);
          } else {
           selectedEdges.add(edge.id);
          }
          updateAllSelections();
         });
         
         let customEdgeLastTap = 0;
         polyHit.addEventListener("touchend", (e) => {
          const now = Date.now();
          if (now - customEdgeLastTap < 300) {
           e.preventDefault();
           if (selectedEdges.has(edge.id)) {
            selectedEdges.delete(edge.id);
           } else {
            selectedEdges.add(edge.id);
           }
           updateAllSelections();
           if (navigator.vibrate) navigator.vibrate(50);
           customEdgeLastTap = 0;
          } else {
           customEdgeLastTap = now;
          }
         }, { passive: false });   
         poly.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (selectedEdges.has(edge.id)) {
           selectedEdges.delete(edge.id);
          } else {
           selectedEdges.add(edge.id);
          }
          updateAllSelections();
         });
         
         let edgeLastTap = 0;
         poly.addEventListener("touchend", (e) => {
          const now = Date.now();
          if (now - edgeLastTap < 300) {
           e.preventDefault();
           if (selectedEdges.has(edge.id)) {
            selectedEdges.delete(edge.id);
           } else {
            selectedEdges.add(edge.id);
           }
           updateAllSelections();
           if (navigator.vibrate) navigator.vibrate(50);
           edgeLastTap = 0;
          } else {
           edgeLastTap = now;
          }
         });
         
         if (currentView.mode === "rack") {
          return;
         }
         if (edge.groupId) {
      const bounds = edge.points.reduce((acc, p) => ({ minX: Math.min(acc.minX, p.x), minY: Math.min(acc.minY, p.y), maxX: Math.max(acc.maxX, p.x), maxY: Math.max(acc.maxY, p.y) }), { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity });
      const groupIndicator = document.createElementNS(ns, "rect");
      groupIndicator.setAttribute("x", bounds.minX - 8);
      groupIndicator.setAttribute("y", bounds.minY - 8);
      groupIndicator.setAttribute("width", bounds.maxX - bounds.minX + 16);
      groupIndicator.setAttribute("height", bounds.maxY - bounds.minY + 16);
      groupIndicator.setAttribute("rx", "4");
      groupIndicator.style.fill = "none";
      groupIndicator.style.stroke = "#4fd1c5";
      groupIndicator.style.strokeWidth = "3";
      groupIndicator.style.strokeDasharray = "5,5";
      groupIndicator.style.pointerEvents = "none";
      svg.appendChild(groupIndicator);
      }
         let lineDragging = false;
      let lineDragStartX, lineDragStartY;
      let linePointsStart = [];
      
      polyHit.addEventListener("mousedown", (e) => {
      if (freeDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      lineDragging = true;
      lineDragStartX = e.clientX;
      lineDragStartY = e.clientY;
      linePointsStart = edge.points.map(p => ({x: p.x, y: p.y}));
      
      if (selectedEdges.has(edge.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
      
      const lineMoveHandler = (e) => {
      if (!lineDragging || freeDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = lineDragStartX;
      pt1.y = lineDragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      
      edge.points.forEach((p, i) => { p.x = linePointsStart[i].x + dx; p.y = linePointsStart[i].y + dy; });
      
      if (selectedEdges.has(edge.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       savedPositions[nodeId] = { x: initialPositions[nodeId].x + dx, y: initialPositions[nodeId].y + dy };
      }
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      if (edgeId === edge.id) return;
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      forgeTheTopology();
      };
      
      const lineUpHandler = () => { lineDragging = false; };
      document.addEventListener("mousemove", lineMoveHandler);
      document.addEventListener("mouseup", lineUpHandler);
      
      svg.appendChild(poly);
      svg.appendChild(polyHit);
         
         if (currentEdgeId === edge.id) {
          edge.points.forEach((p, idx) => {
           const c = document.createElementNS(ns, "circle");
           c.classList.add("edge-edit-point");
           c.setAttribute("cx", p.x);
           c.setAttribute("cy", p.y);
      c.setAttribute("r", PAGE_STATE.selectionHandleSize || 8);
           c.style.fill = PAGE_STATE.selectionHandle || "#f59e0b";
           c.style.stroke = "#fff";
           c.style.strokeWidth = "2";
           c.style.cursor = "move";
           c.dataset.edgeId = edge.id;
           c.dataset.pointIndex = String(idx);
           
           c.addEventListener("mousedown", (e) => {
		   if (isViewOnly()) return;
            e.preventDefault();
            e.stopPropagation();
            let dragging = true;
            const svgEl = svg;
            const moveHandler = (ev) => {
             if (!dragging) return;
             const pt = svgEl.createSVGPoint();
             pt.x = ev.clientX;
             pt.y = ev.clientY;
             const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
             edge.points[idx].x = svgP.x;
             edge.points[idx].y = svgP.y;
             forgeTheTopology();
            };
            const upHandler = () => {
             dragging = false;
             document.removeEventListener("mousemove", moveHandler);
             document.removeEventListener("mouseup", upHandler);
            };
            document.addEventListener("mousemove", moveHandler);
            document.addEventListener("mouseup", upHandler);
           });
           
           c.addEventListener("touchstart", (e) => {
            e.preventDefault();
            e.stopPropagation();
            let dragging = true;
            const svgEl = svg;
            const touchMoveHandler = (ev) => {
             if (!dragging || !ev.touches[0]) return;
             const pt = svgEl.createSVGPoint();
             pt.x = ev.touches[0].clientX;
             pt.y = ev.touches[0].clientY;
             const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
             edge.points[idx].x = svgP.x;
             edge.points[idx].y = svgP.y;
             forgeTheTopology();
            };
            const touchUpHandler = () => {
             dragging = false;
             document.removeEventListener("touchmove", touchMoveHandler);
             document.removeEventListener("touchend", touchUpHandler);
            };
            document.addEventListener("touchmove", touchMoveHandler);
            document.addEventListener("touchend", touchUpHandler);
           }, { passive: false });
           
           svg.appendChild(c);
          });
         }
         
         return;
        }
        const p1 = positions[edge.from];
        const p2 = positions[edge.to];
        if (!p1 || !p2) return;
        const pairTotal = edge._pairTotal || 1;
        const pairIndex = edge._pairIndex || 0;
        const midX = (p1.x + p2.x) / 2;
        const midY = (p1.y + p2.y) / 2;
        const dx = p2.x - p1.x;
        const dy = p2.y - p1.y;
        const len = Math.sqrt(dx * dx + dy * dy) || 1;
        const perpX = -dy / len;
        const perpY = dx / len;
        let offsetAmount = 0;
        if (pairTotal > 1) {
         offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
        }
        const ctrlX = midX + perpX * offsetAmount;
        const ctrlY = midY + perpY * offsetAmount;
        const path = document.createElementNS(ns, "path");
        path.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
        path.setAttribute("fill", "none");
        path.classList.add("edge");
        if (edge.type === "backup") path.classList.add("backup");
        path.dataset.edgeId = edge.id;
        path.dataset.from = edge.from;
        path.dataset.to = edge.to;
        path.style.stroke = edge.color;
        path.style.strokeWidth = edge.width;
        const pathHit = document.createElementNS(ns, "path");
        pathHit.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
        pathHit.setAttribute("fill", "none");
        pathHit.style.stroke = "transparent";
        pathHit.style.strokeWidth = "20";
        pathHit.style.cursor = "pointer";
        pathHit.dataset.edgeId = edge.id;
        pathHit.addEventListener("click", (e) => {
         e.stopPropagation();
         selectTheConnection(edge.id);
        });
        let pathTouchStart = null;
        let pathTouchMoved = false;
        pathHit.addEventListener("touchstart", (e) => {
         pathTouchStart = Date.now();
         pathTouchMoved = false;
         if (e.touches[0]) {
          pathTouchStartX = e.touches[0].clientX;
          pathTouchStartY = e.touches[0].clientY;
         }
        }, {
         passive: false
        });
        let pathTouchStartX = 0, pathTouchStartY = 0;
        pathHit.addEventListener("touchmove", (e) => {
         if (e.touches[0]) {
          const dx = Math.abs(e.touches[0].clientX - pathTouchStartX);
          const dy = Math.abs(e.touches[0].clientY - pathTouchStartY);
          if (dx > 10 || dy > 10) pathTouchMoved = true;
         }
        }, {
         passive: false
        });
        pathHit.addEventListener("touchend", (e) => {
         if (pathTouchStart && !pathTouchMoved && Date.now() - pathTouchStart < 400) {
          e.stopPropagation();
          e.preventDefault();
          selectTheConnection(edge.id);
         }
         pathTouchStart = null;
         pathTouchMoved = false;
        }, {
         passive: false
        });
        path.addEventListener("click", (e) => {
         e.stopPropagation();
         selectTheConnection(edge.id);
        });
        
        if (currentView.mode === "rack") {
         const fromNode = NODE_DATA[edge.from];
         const toNode = NODE_DATA[edge.to];
         if (!fromNode || !toNode || 
             fromNode.assignedRack !== currentView.rackId || 
             toNode.assignedRack !== currentView.rackId) {
          return; 
         }
        }
        
        const fromVisible = isNodeVisible(edge.from);
        const toVisible = isNodeVisible(edge.to);
        if (!fromVisible || !toVisible) {
         path.style.opacity = "0.1";
         path.style.pointerEvents = "none";
         pathHit.style.pointerEvents = "none";
        }
        
        svg.appendChild(path);
        svg.appendChild(pathHit);
        
        if (edge.fromPort || edge.toPort) {
         const ns = "http://www.w3.org/2000/svg";
         
         if (edge.fromPort) {
          const fromLabel = document.createElementNS(ns, "text");
          fromLabel.textContent = edge.fromPort;
          fromLabel.setAttribute("x", p1.x);
          fromLabel.setAttribute("y", p1.y - 10);
          fromLabel.setAttribute("text-anchor", "middle");
          fromLabel.style.fill = "#94a3b8";
          fromLabel.style.fontSize = "12px";
          fromLabel.style.fontWeight = "600";
          fromLabel.style.pointerEvents = "none";
          fromLabel.classList.add("port-label");
          svg.appendChild(fromLabel);
         }
         
         if (edge.toPort) {
          const toLabel = document.createElementNS(ns, "text");
          toLabel.textContent = edge.toPort;
          toLabel.setAttribute("x", p2.x);
          toLabel.setAttribute("y", p2.y - 10);
          toLabel.setAttribute("text-anchor", "middle");
          toLabel.style.fill = "#94a3b8";
          toLabel.style.fontSize = "12px";
          toLabel.style.fontWeight = "600";
          toLabel.style.pointerEvents = "none";
          toLabel.classList.add("port-label");
          svg.appendChild(toLabel);
         }
        }
       });
       Object.entries(positions).forEach(([id, pos]) => {
        const node = NODE_DATA[id];
        if (!node) return;
        
        if (currentView.mode === "rack") {
         if (node.assignedRack !== currentView.rackId) return;
         
         const rackUnit = parseInt(node.rackUnit) || 1;
      const uHeight = parseInt(node.uHeight) || 1;
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      pos.x = RACK_START_X;
      pos.y = RACK_START_Y + (rackCapacity - rackUnit - uHeight + 1) * rackUHeight + (uHeight * rackUHeight) / 2;
      
        } else {
         if (node.assignedRack) return;
        }
        
        const g = document.createElementNS("http://www.w3.org/2000/svg", "g", );
        g.classList.add("node-group");
        g.dataset.nodeId = id;
        g.setAttribute("transform", `translate(${pos.x},${pos.y})`);
        let r = savedSizes[id] || 55;
        if (!savedSizes[id]) {
         if (window.innerWidth <= 380) r = 120;
         else if (window.innerWidth <= 768) r = 140;
         else if (window.innerWidth <= 1024) r = 70;
        }
        const styles = resolveStylesForNode(id);
        const ns = "http://www.w3.org/2000/svg";
        const hitArea = document.createElementNS(ns, "circle");
        hitArea.setAttribute("r", r * 1.5);
        hitArea.style.fill = "transparent";
        hitArea.style.stroke = "none";
        hitArea.style.cursor = "grab";
        hitArea.classList.add("node-hit-area");
        const shapeEl = createNodeShape(id, r);
        const titleOffsetX = styles.titleOffsetX || 0;
        const titleOffsetY = styles.titleOffsetY || 0;
        const subOffsetX = styles.subOffsetX || 0;
        const subOffsetY = styles.subOffsetY || 0;
        const label = document.createElementNS("http://www.w3.org/2000/svg", "text", );
        label.classList.add("node-label");
        label.setAttribute("x", titleOffsetX);
        label.setAttribute("y", -r * 0.28 + titleOffsetY);
      const labelFontSize = styles.titleSize || PAGE_STATE.nodeTitleSize || r * 0.33;
        label.style.fontSize = labelFontSize + "px";
        label.textContent = NODE_DATA[id].name;
      label.style.fill = styles.titleColor || PAGE_STATE.nodeTitle || "#e2e8f0";
        label.style.fontFamily = styles.titleFont || PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
        label.style.pointerEvents = "none";
        const sub = document.createElementNS("http://www.w3.org/2000/svg", "text", );
        sub.classList.add("node-sub");
        sub.setAttribute("x", subOffsetX);
        sub.setAttribute("y", r * 0.4 + subOffsetY);
      const subFontSize = styles.subSize || PAGE_STATE.nodeSubSize || r * 0.24;
        sub.style.fontSize = subFontSize + "px";
        sub.textContent = NODE_DATA[id].ip;
      sub.style.fill = styles.subColor || PAGE_STATE.nodeSub || "#94a3b8";
        sub.style.fontFamily = styles.subFont || PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
        sub.style.pointerEvents = "none";
        g.append(hitArea, shapeEl, label, sub);
        
        if (NODE_DATA[id]?.locked) {
          const lockIcon = document.createElementNS(ns, "text");
          lockIcon.textContent = "🔒";
          lockIcon.setAttribute("x", r * 0.6);
          lockIcon.setAttribute("y", -r * 0.6);
          lockIcon.style.fontSize = (r * 0.4) + "px";
          lockIcon.style.pointerEvents = "none";
          lockIcon.style.userSelect = "none";
          lockIcon.classList.add("lock-indicator");
          g.appendChild(lockIcon);
        }
        
        if (NODE_DATA[id]?.groupId) {
          const groupIndicator = document.createElementNS(ns, "circle");
          groupIndicator.setAttribute("r", r + 4);
          groupIndicator.style.fill = "none";
      groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
          groupIndicator.style.strokeWidth = "3";
          groupIndicator.style.strokeDasharray = "5,5";
          groupIndicator.style.pointerEvents = "none";
          groupIndicator.classList.add("group-indicator");
          g.insertBefore(groupIndicator, g.firstChild);
        }
        
        let isDragging = false;
        let startX, startY;
        let initialPositions = {};
        let longPressTimer = null;
        let longPressTriggered = false;
        
        g.addEventListener("contextmenu", (e) => {
         e.preventDefault();
         e.stopPropagation();
         if (isViewOnly()) return;
         
         if (selectedNodes.has(id)) {
          selectedNodes.delete(id);
         } else {
          selectedNodes.add(id);
         }
         updateNodeSelection();
         return false;
        });
        
        g.addEventListener("touchstart", (e) => {
         if (NODE_DATA[id].isRack) {
          const touch = e.touches[0];
          longPressStartX = touch.clientX;
          longPressStartY = touch.clientY;
          longPressTimer = setTimeout(() => {
           longPressTriggered = true;
           if (navigator.vibrate) {
            navigator.vibrate(100);
           }
           enterRack(id);
          }, 500); 
         }
        }, { passive: true });
        
        let lastTapTime = 0;
        let lastTapNode = null;
        
        g.addEventListener("touchend", (e) => {
         const currentTime = new Date().getTime();
         const tapLength = currentTime - lastTapTime;
         
         if (tapLength < 300 && tapLength > 0 && lastTapNode === id) {
          e.preventDefault();
          e.stopPropagation();
          if (isViewOnly()) return;
          
          if (selectedNodes.has(id)) {
           selectedNodes.delete(id);
          } else {
           selectedNodes.add(id);
          }
          updateNodeSelection();
          
          if (navigator.vibrate) {
           navigator.vibrate(50);
          }
          
          lastTapTime = 0;
          lastTapNode = null;
         } else {
          lastTapTime = currentTime;
          lastTapNode = id;
         }
        });
        
        g.addEventListener("touchend", (e) => {
         if (longPressTimer) {
          clearTimeout(longPressTimer);
          longPressTimer = null;
         }
         if (longPressTriggered) {
          e.preventDefault();
          e.stopPropagation();
          longPressTriggered = false;
         }
        });
        
        let longPressStartX = 0;
        let longPressStartY = 0;
        g.addEventListener("touchmove", (e) => {
         if (longPressTimer) {
          const touch = e.touches[0];
          const dx = Math.abs(touch.clientX - longPressStartX);
          const dy = Math.abs(touch.clientY - longPressStartY);
          if (dx > 15 || dy > 15) {
           clearTimeout(longPressTimer);
           longPressTimer = null;
           longPressTriggered = false;
          }
         }
        });
        
        g.addEventListener("mousedown", (e) => {
		 if (isViewOnly()) return;
         if (e.button === 2) {
          return;
         }
         
         if (NODE_DATA[id]?.locked) {
          return;
         }
         
         e.preventDefault();
         isDragging = true;
         const svgEl = document.getElementById("map");
         const pt = svgEl.createSVGPoint();
         pt.x = e.clientX;
         pt.y = e.clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
         startX = svgP.x;
         startY = svgP.y;
      if (selectedNodes.has(id)) {
      initialPositions = {};
      const allSelectedRects = Array.from(selectedRects);
      const allSelectedTexts = Array.from(selectedTexts);
      const allSelectedEdges = Array.from(selectedEdges).map(eid => EDGE_DATA.list.find(e => e.id === eid)).filter(Boolean);   
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) {
      initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      }
      });
      Array.from(selectedRects).forEach(rectId => {
        const rect = RECT_DATA.list.find(r => r.id === rectId);
        if (rect) { rect._dragStartX = rect.x; rect._dragStartY = rect.y; }
      });
      Array.from(selectedTexts).forEach(textId => {
        const text = TEXT_DATA.list.find(t => t.id === textId);
        if (text) { text._dragStartX = text.x; text._dragStartY = text.y; }
      });
      Array.from(selectedEdges).forEach(edgeId => {
        const edge = EDGE_DATA.list.find(e => e.id === edgeId);
        if (edge && edge.points) { edge._dragStartPoints = edge.points.map(p => ({x: p.x, y: p.y})); }
      });
      
      
      
      
      } else {
      initialPositions = { [id]: { x: pos.x, y: pos.y } };
      }
      if (currentView.mode === "rack") {
      initialPositions[id] = { x: pos.x, y: pos.y };
      }
         
         g.style.cursor = "grabbing";
         hitArea.style.cursor = "grabbing";
         e.stopPropagation();
        });
        const handleMouseMove = (e) => {
         if (!isDragging) return;
         e.preventDefault();
         const svgEl = document.getElementById("map");
         const pt = svgEl.createSVGPoint();
         pt.x = e.clientX;
         pt.y = e.clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
         const dx = svgP.x - startX;
         const dy = svgP.y - startY;
         
         let nodesToMove = selectedNodes.has(id) ? Array.from(selectedNodes) : [id];
         
         const groupIds = new Set();
         nodesToMove.forEach(nodeId => {
          const groupId = NODE_DATA[nodeId]?.groupId;
          if (groupId) {
            groupIds.add(groupId);
          }
         });
         
         if (groupIds.size > 0) {
          Object.keys(NODE_DATA).forEach(nodeId => {
            const nodeGroupId = NODE_DATA[nodeId]?.groupId;
            if (nodeGroupId && groupIds.has(nodeGroupId)) {
              if (!nodesToMove.includes(nodeId)) {
                nodesToMove.push(nodeId);
                if (!initialPositions[nodeId]) {
                  const nodePos = savedPositions[nodeId];
                  if (nodePos) {
                    initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
                  }
                }
              }
            }
          });
         }
         
         nodesToMove = nodesToMove.filter(nodeId => !NODE_DATA[nodeId]?.locked);
         
         nodesToMove.forEach(nodeId => {
          if (!initialPositions[nodeId]) return;
          const initialPos = initialPositions[nodeId];
          let newX = initialPos.x + dx;
          let newY = initialPos.y + dy;
          const nodeSize = savedSizes[nodeId] || 55;
          newX = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, newX), );
          newY = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, newY), );
          
          savedPositions[nodeId] = { x: newX, y: newY };
          positions[nodeId] = { x: newX, y: newY };
          
          if (nodeId === id) {
           pos.x = newX;
           pos.y = newY;
          }
          
          const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
          if (nodeGroup) {
           nodeGroup.setAttribute("transform", `translate(${newX},${newY})`);
          }
         });
         
         Array.from(selectedRects).forEach(rectId => {
           const rect = RECT_DATA.list.find(r => r.id === rectId);
           if (rect && rect._dragStartX !== undefined) {
             rect.x = rect._dragStartX + dx;
             rect.y = rect._dragStartY + dy;
           }
         });
         Array.from(selectedTexts).forEach(textId => {
           const text = TEXT_DATA.list.find(t => t.id === textId);
           if (text && text._dragStartX !== undefined) {
             text.x = text._dragStartX + dx;
             text.y = text._dragStartY + dy;
           }
         });
         Array.from(selectedEdges).forEach(edgeId => {
           const edge = EDGE_DATA.list.find(e => e.id === edgeId);
           if (edge && edge._dragStartPoints) {
             edge.points.forEach((p, i) => {
               p.x = edge._dragStartPoints[i].x + dx;
               p.y = edge._dragStartPoints[i].y + dy;
             });
           }
         });
         forgeTheTopology();
         
         updateMinimap();
         document.querySelectorAll(".edge").forEach((edgeEl) => {
          const fromId = edgeEl.dataset.from;
          const toId = edgeEl.dataset.to;
          if (nodesToMove.includes(fromId) || nodesToMove.includes(toId)) {
           const p1 = savedPositions[fromId] || positions[fromId] || {
            x: 600,
            y: 350
           };
           const p2 = savedPositions[toId] || positions[toId] || {
            x: 600,
            y: 350
           };
           if (edgeEl.tagName === "line") {
            edgeEl.setAttribute("x1", p1.x);
            edgeEl.setAttribute("y1", p1.y);
            edgeEl.setAttribute("x2", p2.x);
            edgeEl.setAttribute("y2", p2.y);
           } else if (edgeEl.tagName === "path") {
            const edgeId = edgeEl.dataset.edgeId;
            const edge = EDGE_DATA.list.find(
             (e) => e.id === edgeId, );
            if (edge) {
             const pairTotal = edge._pairTotal || 1;
             const pairIndex = edge._pairIndex || 0;
             const midX = (p1.x + p2.x) / 2;
             const midY = (p1.y + p2.y) / 2;
             const dx = p2.x - p1.x;
             const dy = p2.y - p1.y;
             const len = Math.sqrt(dx * dx + dy * dy) || 1;
             const perpX = -dy / len;
             const perpY = dx / len;
             let offsetAmount = 0;
             if (pairTotal > 1) {
              offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
             }
             const ctrlX = midX + perpX * offsetAmount;
             const ctrlY = midY + perpY * offsetAmount;
             edgeEl.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
            }
           }
          }
         });
        };
      const handleMouseUp = () => {
      if (isDragging) {
      pushUndo("move nodes");
      isDragging = false;
      g.style.cursor = "grab";
      hitArea.style.cursor = "grab";
      if (currentView.mode === "rack" && NODE_DATA[id]?.assignedRack === currentView.rackId) {
      const draggedY = savedPositions[id]?.y || pos.y;
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      let newUnit = rackCapacity - Math.round((draggedY - RACK_START_Y) / rackUHeight);
      newUnit = Math.max(1, Math.min(newUnit, rackCapacity));
      NODE_DATA[id].rackUnit = newUnit;
      
      forgeTheTopology();
      claimTheImmortal(id);
      }
      }
      };
        document.addEventListener("mousemove", handleMouseMove);
        document.addEventListener("mouseup", handleMouseUp);
        let touchStartTime = 0;
        let touchStartX = 0;
        let touchStartY = 0;
        let touchMoved = false;
        g.addEventListener("touchstart",
         (e) => {
          if (isViewOnly()) {
           touchStartTime = Date.now();
           touchMoved = false;
           e.stopPropagation();
           return;
          }
          if (NODE_DATA[id]?.locked) {
           return;
          }
          
          e.preventDefault();
          touchStartTime = Date.now();
          touchMoved = false;
          const svgEl = document.getElementById("map");
          const pt = svgEl.createSVGPoint();
          const touch = e.touches[0];
          pt.x = touch.clientX;
          pt.y = touch.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          touchStartX = svgP.x;
          touchStartY = svgP.y;
          startX = svgP.x;
          startY = svgP.y;
          
          if (selectedNodes.has(id)) {
           initialPositions = {};
           selectedNodes.forEach(nodeId => {
            const nodePos = savedPositions[nodeId];
            if (nodePos) {
             initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
            }
           });
          } else {
           initialPositions = { [id]: { x: pos.x, y: pos.y } };
          }
          
          e.stopPropagation();
         }, {
          passive: false
         }, );
        g.addEventListener("touchmove", (e) => {
         e.preventDefault();
         const svgEl = document.getElementById("map");
         const pt = svgEl.createSVGPoint();
         const touch = e.touches[0];
         pt.x = touch.clientX;
         pt.y = touch.clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
         const dx = Math.abs(svgP.x - touchStartX);
         const dy = Math.abs(svgP.y - touchStartY);
         if (dx > (isMobileDevice() ? 4 : 10) || dy > (isMobileDevice() ? 4 : 10)) {
      touchMoved = true;
      isDragging = true;
      }
         if (!isDragging) return;
         
         const deltaX = svgP.x - startX;
         const deltaY = svgP.y - startY;
         
         let nodesToMove = selectedNodes.has(id) ? Array.from(selectedNodes) : [id];
         
         const groupIds = new Set();
         nodesToMove.forEach(nodeId => {
          const groupId = NODE_DATA[nodeId]?.groupId;
          if (groupId) {
            groupIds.add(groupId);
          }
         });
         
         if (groupIds.size > 0) {
          Object.keys(NODE_DATA).forEach(nodeId => {
            const nodeGroupId = NODE_DATA[nodeId]?.groupId;
            if (nodeGroupId && groupIds.has(nodeGroupId)) {
              if (!nodesToMove.includes(nodeId)) {
                nodesToMove.push(nodeId);
                if (!initialPositions[nodeId]) {
                  const nodePos = savedPositions[nodeId];
                  if (nodePos) {
                    initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
                  }
                }
              }
            }
          });
         }
         
         nodesToMove = nodesToMove.filter(nodeId => !NODE_DATA[nodeId]?.locked);
         
         nodesToMove.forEach(nodeId => {
          if (!initialPositions[nodeId]) return;
          const initialPos = initialPositions[nodeId];
          let newX = initialPos.x + deltaX;
          let newY = initialPos.y + deltaY;
          const nodeSize = savedSizes[nodeId] || 55;
          newX = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, newX), );
          newY = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, newY), );
          
          savedPositions[nodeId] = { x: newX, y: newY };
          positions[nodeId] = { x: newX, y: newY };
          
          if (nodeId === id) {
           pos.x = newX;
           pos.y = newY;
          }
          
          const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
          if (nodeGroup) {
           nodeGroup.setAttribute("transform", `translate(${newX},${newY})`);
          }
         });
         
         updateMinimap();
         document.querySelectorAll(".edge").forEach((edgeEl) => {
          const fromId = edgeEl.dataset.from;
          const toId = edgeEl.dataset.to;
          if (nodesToMove.includes(fromId) || nodesToMove.includes(toId)) {
           const p1 = savedPositions[fromId] || positions[fromId] || {
            x: 600,
            y: 350
           };
           const p2 = savedPositions[toId] || positions[toId] || {
            x: 600,
            y: 350
           };
           if (edgeEl.tagName === "line") {
            edgeEl.setAttribute("x1", p1.x);
            edgeEl.setAttribute("y1", p1.y);
            edgeEl.setAttribute("x2", p2.x);
            edgeEl.setAttribute("y2", p2.y);
           } else if (edgeEl.tagName === "path") {
            const edgeId = edgeEl.dataset.edgeId;
            const edge = EDGE_DATA.list.find(
             (e) => e.id === edgeId, );
            if (edge) {
             const pairTotal = edge._pairTotal || 1;
             const pairIndex = edge._pairIndex || 0;
             const midX = (p1.x + p2.x) / 2;
             const midY = (p1.y + p2.y) / 2;
             const dx = p2.x - p1.x;
             const dy = p2.y - p1.y;
             const len = Math.sqrt(dx * dx + dy * dy) || 1;
             const perpX = -dy / len;
             const perpY = dx / len;
             let offsetAmount = 0;
             if (pairTotal > 1) {
              offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
             }
             const ctrlX = midX + perpX * offsetAmount;
             const ctrlY = midY + perpY * offsetAmount;
             edgeEl.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
            }
           }
          }
         });
        }, {
         passive: false
        });
      g.addEventListener("touchend", (e) => {
      const touchDuration = Date.now() - touchStartTime;
      if (!touchMoved && touchDuration < 400) {
       if (isViewOnly()) {
        handleViewOnlyClick(id, 'node');
        return;
       }
       claimTheImmortal(id);
      }
      if (isDragging) {
      const draggedY = pos.y;
      isDragging = false;
      savedPositions[id] = {
      x: pos.x,
      y: pos.y
      };
      if (currentView.mode === "rack" && NODE_DATA[id]?.assignedRack === currentView.rackId) {
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      let newUnit = rackCapacity - Math.round((draggedY - RACK_START_Y) / rackUHeight);
      
      newUnit = Math.max(1, Math.min(newUnit, rackCapacity));
      NODE_DATA[id].rackUnit = newUnit;
      forgeTheTopology();
      claimTheImmortal(id);
      }
      }
      touchMoved = false;
      });
        g.style.cursor = "grab";
        g.addEventListener("click", (e) => {
         if (!isDragging) {
          if (isViewOnly()) {
           handleViewOnlyClick(id, 'node');
           return;
          }
          claimTheImmortal(id);
         }
        });
        
        g.addEventListener("dblclick", (e) => {
         e.preventDefault();
         e.stopPropagation();
         if (NODE_DATA[id].isRack) {
          enterRack(id);
         }
        });
        
        if (!isNodeVisible(id)) {
         g.style.opacity = "0.1";
         g.style.pointerEvents = "none";
        }
        
        svg.appendChild(g);
       });
        if (RECT_DATA && RECT_DATA.list) {
         RECT_DATA.list.forEach((rect) => {
          if (currentView.mode === "rack") return;
          if (rect.style === "outlined") {
           const g = document.createElementNS(ns, "g");
           g.classList.add("rect-group");
           g.dataset.rectId = rect.id;
           
           const rectEl = document.createElementNS(ns, "rect");
           rectEl.classList.add("rect-shape");
           rectEl.setAttribute("x", rect.x);
           rectEl.setAttribute("y", rect.y);
           rectEl.setAttribute("width", rect.width);
           rectEl.setAttribute("height", rect.height);
           rectEl.style.fill = "none";
           rectEl.style.stroke = rect.borderColor || rect.color;
           rectEl.style.strokeWidth = (rect.borderWidth !== undefined ? rect.borderWidth : 3) + "px";
           if (rect.lineStyle === "dashed") { rectEl.style.strokeDasharray = "10,5"; }
           else if (rect.lineStyle === "dotted") { rectEl.style.strokeDasharray = "2,4"; }
           else { rectEl.style.strokeDasharray = "none"; }
           rectEl.style.cursor = "move";
           
           rectEl.addEventListener("click", (e) => {
             if (rectDrawMode) return;
             e.stopPropagation();
             currentRectId = rect.id;
             selectTheRect(rect.id);
           });
           
           rectEl.addEventListener("contextmenu", (e) => {
		   if (isViewOnly()) return;
             e.preventDefault();
             e.stopPropagation();
             if (selectedRects.has(rect.id)) {
               selectedRects.delete(rect.id);
             } else {
               selectedRects.add(rect.id);
             }
             updateAllSelections();
           });
           
           let rectLastTap = 0;
           rectEl.addEventListener("touchend", (e) => {
             const now = Date.now();
             if (now - rectLastTap < 300) {
               e.preventDefault();
               if (selectedRects.has(rect.id)) {
                 selectedRects.delete(rect.id);
               } else {
                 selectedRects.add(rect.id);
               }
               updateAllSelections();
               if (navigator.vibrate) navigator.vibrate(50);
               rectLastTap = 0;
             } else {
               rectLastTap = now;
             }
           }, { passive: false });
           
           const deleteBtn = document.createElementNS(ns, "g");
           deleteBtn.classList.add("rect-delete-btn");
           deleteBtn.style.cursor = "pointer";
           deleteBtn.style.display = rectDrawMode ? "block" : "none";
           
           const deleteBg = document.createElementNS(ns, "circle");
           deleteBg.setAttribute("cx", rect.x + rect.width - 10);
           deleteBg.setAttribute("cy", rect.y + 10);
           deleteBg.setAttribute("r", 12);
           deleteBg.style.fill = "#f56565";
           deleteBg.style.stroke = "white";
           deleteBg.style.strokeWidth = "2";
           
           const deleteX = document.createElementNS(ns, "text");
           deleteX.setAttribute("x", rect.x + rect.width - 10);
           deleteX.setAttribute("y", rect.y + 10);
           deleteX.setAttribute("text-anchor", "middle");
           deleteX.setAttribute("dominant-baseline", "middle");
           deleteX.style.fill = "white";
           deleteX.style.fontSize = "16px";
           deleteX.style.fontWeight = "bold";
           deleteX.style.pointerEvents = "none";
           deleteX.textContent = "×";
           
           deleteBtn.appendChild(deleteBg);
           deleteBtn.appendChild(deleteX);
           
           deleteBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            e.preventDefault();
            deleteRectangle(rect.id);
           });
           
           let isDragging = false;
           let dragStartX, dragStartY;
           let rectStartX, rectStartY;
           
           rectEl.addEventListener("mousedown", (e) => {
		   if (isViewOnly()) return;
      if (rectDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      rectStartX = rect.x;
      rectStartY = rect.y;
      rectEl.style.cursor = "grabbing";
      
      if (selectedRects.has(rect.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
           
           const moveHandler = (e) => {
      if (!isDragging || rectDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      
      rect.x = rectStartX + dx;
      rect.y = rectStartY + dy;
      
      if (selectedRects.has(rect.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       const newX = initialPositions[nodeId].x + dx;
       const newY = initialPositions[nodeId].y + dy;
       savedPositions[nodeId] = { x: newX, y: newY };
      }
      });
      selectedRects.forEach(rectId => {
      if (rectId === rect.id) return;
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      
      forgeTheTopology();
      };
           
           const upHandler = () => {
            if (isDragging) {
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           };
           
           document.addEventListener("mousemove", moveHandler);
           document.addEventListener("mouseup", upHandler);
           
           let touchStartX, touchStartY;
           let touchRectStartX, touchRectStartY;
           
           rectEl.addEventListener("touchstart", (e) => {
		   if (isViewOnly()) return;
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchRectStartX = rect.x;
            touchRectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           }, { passive: false });
           
           rectEl.addEventListener("touchmove", (e) => {
            if (!isDragging || rectDrawMode) return;
            if (!e.touches[0]) return;
            e.preventDefault();
            e.stopPropagation();
            
            const svgEl = svg;
            const pt1 = svgEl.createSVGPoint();
            pt1.x = touchStartX;
            pt1.y = touchStartY;
            const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
            
            const touch = e.touches[0];
            const pt2 = svgEl.createSVGPoint();
            pt2.x = touch.clientX;
            pt2.y = touch.clientY;
            const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
            
            const dx = svgP2.x - svgP1.x;
            const dy = svgP2.y - svgP1.y;
            
            rect.x = touchRectStartX + dx;
            rect.y = touchRectStartY + dy;
            
            forgeTheTopology();
           }, { passive: false });
           
           rectEl.addEventListener("touchend", (e) => {
            if (isDragging) {
             e.preventDefault();
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           }, { passive: false });
           
           if (rect.groupId) {
             const groupIndicator = document.createElementNS(ns, "rect");
             groupIndicator.setAttribute("x", rect.x - 4);
             groupIndicator.setAttribute("y", rect.y - 4);
             groupIndicator.setAttribute("width", rect.width + 8);
             groupIndicator.setAttribute("height", rect.height + 8);
             groupIndicator.style.fill = "none";
             groupIndicator.style.stroke = "#4fd1c5";
             groupIndicator.style.strokeWidth = "3";
             groupIndicator.style.strokeDasharray = "5,5";
             groupIndicator.style.pointerEvents = "none";
             g.insertBefore(groupIndicator, g.firstChild);
           }
           g.appendChild(rectEl);
           g.appendChild(deleteBtn);
           svg.appendChild(g);
          }
         });
        }
        
        if (TEXT_DATA && TEXT_DATA.list) {
         TEXT_DATA.list.forEach((textItem) => {
          if (currentView.mode === "rack") return;
          
          const g = document.createElementNS(ns, "g");
          g.classList.add("text-group");
          g.dataset.textId = textItem.id;
          
          if (textItem.bgEnabled) {
           const bgRect = document.createElementNS(ns, "rect");
           bgRect.classList.add("text-bg");
           
           bgRect.setAttribute("x", textItem.x - 5);
           bgRect.setAttribute("y", textItem.y - textItem.fontSize - 2);
           bgRect.setAttribute("width", 100);
           bgRect.setAttribute("height", textItem.fontSize + 10);
           bgRect.style.fill = textItem.bgColor;
           bgRect.style.opacity = "0.7";
           bgRect.style.rx = "4";
           g.appendChild(bgRect);
          }
          
          const textEl = document.createElementNS(ns, "text");
          textEl.classList.add("text-element");
          textEl.setAttribute("x", textItem.x);
          textEl.setAttribute("y", textItem.y);
          textEl.style.fill = textItem.color;
          textEl.style.fontSize = textItem.fontSize + "px";
          textEl.style.fontWeight = textItem.fontWeight;
          textEl.style.fontStyle = textItem.fontStyle;
          textEl.style.textAnchor = textItem.textAlign;
          textEl.style.textDecoration = textItem.textDecoration;
          textEl.style.opacity = textItem.opacity;
          textEl.style.cursor = "move";
          textEl.style.userSelect = "none";
          textEl.setAttribute("dominant-baseline", "middle");
          
          const lines = textItem.content.split('\n');
          if (lines.length === 1) {
           textEl.textContent = textItem.content;
          } else {
           lines.forEach((line, i) => {
            const tspan = document.createElementNS(ns, "tspan");
            tspan.textContent = line;
            tspan.setAttribute("x", textItem.x);
            tspan.setAttribute("dy", i === 0 ? 0 : textItem.fontSize * 1.2);
            textEl.appendChild(tspan);
           });
          }
          
          g.appendChild(textEl);
          
          if (textItem.bgEnabled) {
           setTimeout(() => {
            try {
             const bbox = textEl.getBBox();
             const bgRect = g.querySelector('.text-bg');
             if (bgRect && bbox) {
              bgRect.setAttribute("x", bbox.x - 5);
              bgRect.setAttribute("y", bbox.y - 2);
              bgRect.setAttribute("width", bbox.width + 10);
              bgRect.setAttribute("height", bbox.height + 4);
             }
            } catch (e) {
            }
           }, 0);
          }
          
          const deleteBtn = document.createElementNS(ns, "g");
          deleteBtn.classList.add("text-delete-btn");
          deleteBtn.style.cursor = "pointer";
          deleteBtn.style.display = textDrawMode ? "block" : "none";
          
          const deleteBg = document.createElementNS(ns, "circle");
          deleteBg.setAttribute("cx", textItem.x + 20);
          deleteBg.setAttribute("cy", textItem.y - textItem.fontSize);
          deleteBg.setAttribute("r", 12);
          deleteBg.style.fill = "#f56565";
          deleteBg.style.stroke = "white";
          deleteBg.style.strokeWidth = "2";
          
          const deleteX = document.createElementNS(ns, "text");
          deleteX.setAttribute("x", textItem.x + 20);
          deleteX.setAttribute("y", textItem.y - textItem.fontSize);
          deleteX.setAttribute("text-anchor", "middle");
          deleteX.setAttribute("dominant-baseline", "middle");
          deleteX.style.fill = "white";
          deleteX.style.fontSize = "16px";
          deleteX.style.fontWeight = "bold";
          deleteX.style.pointerEvents = "none";
          deleteX.textContent = "×";
          
          deleteBtn.appendChild(deleteBg);
          deleteBtn.appendChild(deleteX);
          
          deleteBtn.addEventListener("click", (e) => {
           e.stopPropagation();
           e.preventDefault();
           deleteText(textItem.id);
          });
          
          let isDragging = false;
          let dragStartX, dragStartY;
          let textStartX, textStartY;
          
          textEl.addEventListener("mousedown", (e) => {
		  if (isViewOnly()) return;
      if (textDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      textStartX = textItem.x;
      textStartY = textItem.y;
      textEl.style.cursor = "grabbing";
      
      showTextPanel(textItem.id);
      
      if (selectedTexts.has(textItem.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
          
          const moveHandler = (e) => {
      if (!isDragging || textDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      
      textItem.x = textStartX + dx;
      textItem.y = textStartY + dy;
      
      if (selectedTexts.has(textItem.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       const newX = initialPositions[nodeId].x + dx;
       const newY = initialPositions[nodeId].y + dy;
       savedPositions[nodeId] = { x: newX, y: newY };
      }
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      if (textId === textItem.id) return;
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      
      forgeTheTopology();
      };
          
          const upHandler = () => {
           if (isDragging) {
            isDragging = false;
            textEl.style.cursor = "move";
           }
          };
          
          document.addEventListener("mousemove", moveHandler);
          document.addEventListener("mouseup", upHandler);
          
          let touchStartX = 0, touchStartY = 0;
          let textTouchStartX = 0, textTouchStartY = 0;
          
          textEl.addEventListener("touchstart", (e) => {
		   if (isViewOnly()) return;
           if (textDrawMode) return;
           if (e.touches.length !== 1) return;
           
           e.preventDefault();
           e.stopPropagation();
           const touch = e.touches[0];
           isDragging = true;
           touchStartX = touch.clientX;
           touchStartY = touch.clientY;
           textTouchStartX = textItem.x;
           textTouchStartY = textItem.y;
           
           showTextPanel(textItem.id);
          }, { passive: false });
          
          textEl.addEventListener("touchmove", (e) => {
           if (!isDragging || textDrawMode) return;
           if (e.touches.length !== 1) return;
           
           e.preventDefault();
           const touch = e.touches[0];
           const svgEl = svg;
           
           const pt1 = svgEl.createSVGPoint();
           pt1.x = touchStartX;
           pt1.y = touchStartY;
           const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
           
           const pt2 = svgEl.createSVGPoint();
           pt2.x = touch.clientX;
           pt2.y = touch.clientY;
           const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
           
           const dx = svgP2.x - svgP1.x;
           const dy = svgP2.y - svgP1.y;
           
           textItem.x = textTouchStartX + dx;
           textItem.y = textTouchStartY + dy;
           
           forgeTheTopology();
          }, { passive: false });
          
          textEl.addEventListener("touchend", () => {
           if (isDragging) {
            isDragging = false;
           }
          }, { passive: false });
          
          textEl.addEventListener("contextmenu", (e) => {
		  if (isViewOnly()) return;
           e.preventDefault();
           e.stopPropagation();
           if (selectedTexts.has(textItem.id)) {
            selectedTexts.delete(textItem.id);
           } else {
            selectedTexts.add(textItem.id);
           }
           updateAllSelections();
          });
          
          let textLastTap = 0;
          g.addEventListener("touchend", (e) => {
           const now = Date.now();
           if (now - textLastTap < 300) {
            e.preventDefault();
            if (selectedTexts.has(textItem.id)) {
             selectedTexts.delete(textItem.id);
            } else {
             selectedTexts.add(textItem.id);
            }
            updateAllSelections();
            if (navigator.vibrate) navigator.vibrate(50);
            textLastTap = 0;
           } else {
            textLastTap = now;
           }
          }, { passive: false });
          
          if (textItem.groupId) {
            const groupIndicator = document.createElementNS(ns, "rect");
            groupIndicator.setAttribute("x", textItem.x - 54);
            groupIndicator.setAttribute("y", textItem.y - 24);
            groupIndicator.setAttribute("width", 108);
            groupIndicator.setAttribute("height", 48);
            groupIndicator.setAttribute("rx", "8");
            groupIndicator.style.fill = "none";
            groupIndicator.style.stroke = "#4fd1c5";
            groupIndicator.style.strokeWidth = "3";
            groupIndicator.style.strokeDasharray = "5,5";
            groupIndicator.style.pointerEvents = "none";
            g.insertBefore(groupIndicator, g.firstChild);
          }
          g.appendChild(deleteBtn);
          svg.appendChild(g);
         });
        }
        
       forgeTheLegend();
       updateMinimap();
       populateRackDropdown();
      }
      
      function showEditModal(title, currentValue, onSave) {
       const modal = document.getElementById("edit-modal");
       const input = document.getElementById("modal-input");
       const titleEl = document.getElementById("modal-title");
       const saveBtn = document.getElementById("modal-save");
       const cancelBtn = document.getElementById("modal-cancel");
       titleEl.textContent = title;
       input.value = currentValue;
       modal.classList.add("active");
       input.focus();
       input.select();
       const handleSave = () => {
        if (input.value.trim()) {
         onSave(input.value.trim());
        }
        modal.classList.remove("active");
        saveBtn.removeEventListener("click", handleSave);
        cancelBtn.removeEventListener("click", handleCancel);
        input.removeEventListener("keypress", handleEnter);
       };
       const handleCancel = () => {
        modal.classList.remove("active");
        saveBtn.removeEventListener("click", handleSave);
        cancelBtn.removeEventListener("click", handleCancel);
        input.removeEventListener("keypress", handleEnter);
       };
       const handleEnter = (e) => {
        if (e.key === "Enter") handleSave();
       };
       saveBtn.addEventListener("click", handleSave);
       cancelBtn.addEventListener("click", handleCancel);
       input.addEventListener("keypress", handleEnter);
       modal.addEventListener("click", function bgHandler(e) {
        if (e.target === modal) {
         handleCancel();
         modal.removeEventListener("click", bgHandler);
        }
       });
      }
      
      function challengeTheImmortal(message, onConfirm) {
       const modal = document.getElementById("confirm-modal");
       const messageEl = document.getElementById("confirm-message");
       const deleteBtn = document.getElementById("confirm-delete");
       const cancelBtn = document.getElementById("confirm-cancel");
       messageEl.textContent = message;
       modal.classList.add("active");
       const handleConfirm = () => {
        onConfirm();
        modal.classList.remove("active");
        deleteBtn.removeEventListener("click", handleConfirm);
        cancelBtn.removeEventListener("click", handleCancel);
       };
       const handleCancel = () => {
        modal.classList.remove("active");
        deleteBtn.removeEventListener("click", handleConfirm);
        cancelBtn.removeEventListener("click", handleCancel);
       };
       deleteBtn.addEventListener("click", handleConfirm);
       cancelBtn.addEventListener("click", handleCancel);
       modal.addEventListener("click", function bgHandler(e) {
        if (e.target === modal) {
         handleCancel();
         modal.removeEventListener("click", bgHandler);
        }
       });
      }
      const pageTitleEl = document.getElementById("page-title");
      if (pageTitleEl) {
       pageTitleEl.addEventListener("click", () => {
        showEditModal("Edit Title", PAGE_STATE.title || DEFAULT_PAGE_STATE.title,
         (newTitle) => {
          PAGE_STATE.title = newTitle;
          wieldThePower();
         }, );
       });
      }
      
      function editNodeName(id) {
       showEditModal("Edit Name", NODE_DATA[id].name, (newName) => {
        NODE_DATA[id].name = newName;
        const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`, );
        if (nodeGroup) {
         const label = nodeGroup.querySelector(".node-label");
         if (label) label.textContent = newName;
        }
        if (currentNodeId === id) {
         document.getElementById("node-name").textContent = newName;
        }
       });
      }
      
      function editNodeIp(id) {
       showEditModal("Edit IP/Subtitle", NODE_DATA[id].ip, (newIp) => {
        NODE_DATA[id].ip = newIp;
        const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`, );
        if (nodeGroup) {
         const sub = nodeGroup.querySelector(".node-sub");
         if (sub) sub.textContent = newIp;
        }
        if (currentNodeId === id) {
         document.getElementById("node-ip").textContent = newIp;
        }
       });
      }
      
      function claimTheImmortal(id) {
	   if (isViewOnly()) return;
	   if (!NODE_DATA[id]) return;
       currentNodeId = id;
       currentEdgeId = null;
       currentRectId = null;
       currentTextId = null;
       
       if (isMobileDevice()) {
        const currentHeight = PAGE_STATE.mobileFooterHeight || 40;
        if (currentHeight <= 20) {
         PAGE_STATE.mobileFooterHeight = 80;
         const root = document.documentElement;
         root.style.setProperty("--mobile-footer-height", "80vh");
         const mobileFooterHeightInput = document.getElementById("mobile-footer-height");
         const mobileFooterHeightVal = document.getElementById("mobile-footer-height-val");
         if (mobileFooterHeightInput) mobileFooterHeightInput.value = 80;
         if (mobileFooterHeightVal) mobileFooterHeightVal.textContent = "80%";
        }
       }
       
       const data = NODE_DATA[id];
       document.querySelectorAll(".node-group").forEach((n) => {
        n.classList.toggle("active", n.dataset.nodeId === id);
       });
       document.querySelectorAll(".edge").forEach((e) => {
        const active = e.dataset.from === id || e.dataset.to === id;
        e.classList.toggle("active", active);
       });
       document.querySelectorAll(".rect-group").forEach((r) => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach((t) => t.classList.remove("active"));
       document.getElementById("node-panel").style.display = "block";
       document.getElementById("edge-panel").style.display = "none";
       document.getElementById("text-panel").style.display = "none";
       const toolbar = document.getElementById("topology-toolbar");
       if (!topologyToolbarCollapsed) {
        toolbar.style.display = "flex";
       }
       updateTopologyToolbarVisibility();
       document.getElementById("node-name").textContent = data.name;
       document.getElementById("node-ip").textContent = data.ip;
       document.getElementById("node-role").textContent = data.role;
       document.getElementById("node-mac").textContent = data.mac || "--";
       document.getElementById("node-rack").textContent = data.rackUnit || "--";
       document.getElementById("node-uheight").textContent = (data.uHeight || "1") + "U";
       document.getElementById("node-layer").value = data.layer || "physical";
       
       populateRackDropdown();
       const assignedRackSelect = document.getElementById("node-assigned-rack");
       if (assignedRackSelect) {
        assignedRackSelect.value = data.assignedRack || "";
       }
       
       const rackCapacitySelect = document.getElementById("node-rack-capacity");
       if (rackCapacitySelect) {
        rackCapacitySelect.value = data.rackCapacity || "42";
       }
       
       const isRack = data.isRack === true;
       const isAssignedToRack = !!data.assignedRack;
       const assignedRackRow = document.getElementById("assigned-rack-row");
       const rackCapacityRow = document.getElementById("rack-capacity-row");
       const uheightRow = document.getElementById("uheight-row");
       if (assignedRackRow) assignedRackRow.style.display = isRack ? "none" : "flex";
       if (rackCapacityRow) rackCapacityRow.style.display = isRack ? "flex" : "none";
       if (uheightRow) uheightRow.style.display = isAssignedToRack ? "flex" : "none";
       const rackContentsSection = document.getElementById("rack-contents-section");
       const rackContentsList = document.getElementById("rack-contents-list");
       if (rackContentsSection && rackContentsList) {
        if (isRack) {
         const nodesInRack = Object.entries(NODE_DATA).filter(([nid, n]) => n.assignedRack === id);
         if (nodesInRack.length > 0) {
          rackContentsList.innerHTML = nodesInRack.map(([nid, n]) => {
           const tags = (n.tags || []).map(t => `<span style="background: var(--accent); color: var(--bg); padding: 2px 6px; border-radius: 4px; font-size: 11px; margin-left: 4px;">${t}</span>`).join('');
           return `<div style="padding: 6px 0; border-bottom: 1px solid var(--edge-main); cursor: pointer;" onclick="claimTheImmortal('${nid}')">
            <span style="color: var(--text-main);">${n.name}</span>${tags}
           </div>`;
          }).join('');
          rackContentsSection.style.display = "block";
         } else {
          rackContentsList.innerHTML = '<div style="color: var(--text-soft); font-style: italic;">No nodes assigned</div>';
          rackContentsSection.style.display = "block";
         }
        } else {
         rackContentsSection.style.display = "none";
        }
       }
       document.getElementById("node-name").onclick = () => editNodeName(id);
       document.getElementById("node-ip").onclick = () => editNodeIp(id);
       document.getElementById("node-mac").onclick = () => editNodeMac(id);
       document.getElementById("node-rack").onclick = () => editNodeRack(id);
       document.getElementById("node-uheight").onclick = () => editNodeUHeight(id);
       const currentSize = savedSizes[id] || getDefaultSize();
       document.getElementById("size-slider").value = currentSize;
       document.getElementById("size-value").textContent = currentSize;
       const styleEntry = savedStyles[id] || {};
       const resolvedStyles = resolveStylesEntry(styleEntry);
       const scopeKey = currentStyleScope || "all";
       const flatProps = ["circleColor", "circleBorder", "titleColor", "titleFont", "titleSize", "subColor", "subFont", "subSize", ];
       const isFlat = flatProps.some((p) => Object.prototype.hasOwnProperty.call(styleEntry, p), );
       const scopedStyles = isFlat ? styleEntry : styleEntry[scopeKey] || {};
       const circleColorInput = document.getElementById("circle-color");
       const titleColorInput = document.getElementById("title-color");
       const titleFontSelect = document.getElementById("title-font");
       const titleSizeInput = document.getElementById("title-size");
       const subColorInput = document.getElementById("sub-color");
       const subFontSelect = document.getElementById("sub-font");
       const subSizeInput = document.getElementById("sub-size");
       const shapeSelect = document.getElementById("shape-select");
       const scopeSelect = document.getElementById("style-scope");
      circleColorInput.value = scopedStyles.circleColor || resolvedStyles.circleColor || PAGE_STATE.nodeFill || "#1e293b";
       const circleBorderInput = document.getElementById("circle-border");
       circleBorderInput.value = scopedStyles.circleBorder || resolvedStyles.circleBorder || PAGE_STATE.nodeStroke || "#475569";
        titleColorInput.value = scopedStyles.titleColor || resolvedStyles.titleColor || PAGE_STATE.textMain || "#e2e8f0";
        titleFontSelect.value = scopedStyles.titleFont || resolvedStyles.titleFont || "system-ui, sans-serif";
        titleSizeInput.value = scopedStyles.titleSize || resolvedStyles.titleSize || 18;
        subColorInput.value = scopedStyles.subColor || resolvedStyles.subColor || PAGE_STATE.textSoft || "#94a3b8";
       subFontSelect.value = scopedStyles.subFont || resolvedStyles.subFont || "system-ui, sans-serif";
       subSizeInput.value = scopedStyles.subSize || resolvedStyles.subSize || 13;
       shapeSelect.value = data.shape || "circle";
       scopeSelect.value = currentStyleScope || "all";
       document.getElementById("title-offset-y").value = scopedStyles.titleOffsetY || resolvedStyles.titleOffsetY || 0;
       document.getElementById("title-offset-x").value = scopedStyles.titleOffsetX || resolvedStyles.titleOffsetX || 0;
       document.getElementById("sub-offset-y").value = scopedStyles.subOffsetY || resolvedStyles.subOffsetY || 0;
       document.getElementById("sub-offset-x").value = scopedStyles.subOffsetX || resolvedStyles.subOffsetX || 0;
       const tagEl = document.getElementById("node-tags");
       tagEl.innerHTML = "";
       data.tags.forEach((tag, i) => {
        const b = document.createElement("span");
        b.className = "badge";
        if (tag.toLowerCase().includes("wg")) b.classList.add("wg");
        b.style.cursor = "pointer";
        b.style.position = "relative";
        const tagText = document.createElement("span");
        tagText.textContent = tag;
        tagText.addEventListener("click", (e) => {
         e.stopPropagation();
         showEditModal("Edit Tag", tag, (newTag) => {
          if (newTag) {
           data.tags[i] = newTag;
           claimTheImmortal(id);
          }
         });
        });
        const deleteTag = document.createElement("span");
        deleteTag.textContent = " ✕";
        deleteTag.style.opacity = "0.6";
        deleteTag.style.marginLeft = "4px";
        deleteTag.style.fontSize = "10px";
        deleteTag.addEventListener("click", (e) => {
         e.stopPropagation();
         data.tags.splice(i, 1);
         claimTheImmortal(id);
        });
        b.append(tagText, deleteTag);
        tagEl.append(b);
       });
       const addTagBtn = document.createElement("span");
       addTagBtn.className = "badge";
       addTagBtn.style.cursor = "pointer";
       addTagBtn.style.opacity = "0.6";
       addTagBtn.style.borderStyle = "dashed";
       addTagBtn.textContent = "+ Add Tag";
       addTagBtn.addEventListener("click", () => {
        showEditModal("Add Tag(s) : comma separated", "",
         (newTagStr) => {
          if (newTagStr) {
           const newTags = newTagStr.split(",").map((t) => t.trim()).filter((t) => t);
           newTags.forEach((t) => data.tags.push(t));
           claimTheImmortal(id);
          }
         }, );
       });
       tagEl.append(addTagBtn);
       const notesEl = document.getElementById("node-notes");
       notesEl.innerHTML = "";
       data.notes.forEach((note, i) => {
        const li = document.createElement("li");
        const noteText = document.createElement("span");
        noteText.textContent = note;
        noteText.style.flex = "1";
        const deleteBtn = document.createElement("span");
        deleteBtn.className = "delete-note";
        deleteBtn.textContent = "✕";
        deleteBtn.addEventListener("click", (e) => {
         e.stopPropagation();
         challengeTheImmortal("Are you sure you want to delete this note?",
          () => {
           data.notes.splice(i, 1);
           claimTheImmortal(id);
          }, );
        });
        li.append(noteText, deleteBtn);
        noteText.addEventListener("dblclick", () => {
         noteText.classList.add("editing");
         noteText.contentEditable = true;
         noteText.focus();
        });
        noteText.addEventListener("blur", () => {
         noteText.classList.remove("editing");
         noteText.contentEditable = false;
         data.notes[i] = noteText.textContent;
        });
        notesEl.append(li);
       });
      const addLineSelect = document.getElementById("add-line-select");
      addLineSelect.innerHTML = "";
      const currentRack = data.assignedRack || "";
      Object.entries(NODE_DATA).forEach(([nodeId, node]) => {
      if (nodeId !== id) {
      const nodeRack = node.assignedRack || "";
      if (currentRack === nodeRack) {
      const opt = document.createElement("option");
      opt.value = nodeId;
      opt.textContent = node.name;
      addLineSelect.appendChild(opt);
      }
      }
      });
      }
      
      function selectTheConnection(id) {
	   if (isViewOnly()) return;
       currentEdgeId = id;
       currentNodeId = null;
       currentRectId = null;
       currentTextId = null;
       
       if (isMobileDevice()) {
        const currentHeight = PAGE_STATE.mobileFooterHeight || 40;
        if (currentHeight <= 20) {
         PAGE_STATE.mobileFooterHeight = 80;
         const root = document.documentElement;
         root.style.setProperty("--mobile-footer-height", "80vh");
         const mobileFooterHeightInput = document.getElementById("mobile-footer-height");
         const mobileFooterHeightVal = document.getElementById("mobile-footer-height-val");
         if (mobileFooterHeightInput) mobileFooterHeightInput.value = 80;
         if (mobileFooterHeightVal) mobileFooterHeightVal.textContent = "80%";
        }
       }
       
       document.getElementById("node-panel").style.display = "none";
       document.getElementById("edge-panel").style.display = "block";
       document.getElementById("text-panel").style.display = "none";
       document.getElementById("rect-panel").style.display = "none";
       document.getElementById("topology-toolbar").style.display = "none";
       document.querySelectorAll(".node-group").forEach((n) => n.classList.remove("active"));
       document.querySelectorAll(".rect-group").forEach((r) => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach((t) => t.classList.remove("active"));
       document.querySelectorAll(".edge").forEach((e) => {
        e.classList.toggle("active", e.dataset.edgeId === id);
       });
       const edge = EDGE_DATA.list.find((e) => e.id === id);
       if (!edge) return;
       const directionSymbols = {
        none: "⇄",
        forward: "→",
        backward: "←",
        both: "↔",
       };
       const dirSymbol = directionSymbols[edge.direction] || "⇄";
       let titleText = "Custom line";
       if (edge.from || edge.to) {
        const fromName = edge.from ? NODE_DATA[edge.from]?.name || edge.from : "";
        const toName = edge.to ? NODE_DATA[edge.to]?.name || edge.to : "";
        titleText = `${fromName || "?"} ${dirSymbol} ${toName || "?"}`;
       }
       document.getElementById("edge-title").textContent = titleText;
       const widthInput = document.getElementById("edge-width");
       const colorInput = document.getElementById("edge-color");
       const directionSelect = document.getElementById("edge-direction");
       const lineStyleSelect = document.getElementById("edge-line-style");
       widthInput.value = edge.width;
       colorInput.value = edge.color;
       directionSelect.value = edge.direction || "none";
       lineStyleSelect.value = edge.lineStyle || "solid";
       
       const fromPortRow = document.getElementById("edge-from-port-row");
       const toPortRow = document.getElementById("edge-to-port-row");
       const fromPortInput = document.getElementById("edge-from-port");
       const toPortInput = document.getElementById("edge-to-port");
       
       if (edge.type === "custom") {
        fromPortRow.style.display = "none";
        toPortRow.style.display = "none";
       } else {
        fromPortRow.style.display = "flex";
        toPortRow.style.display = "flex";
        fromPortInput.value = edge.fromPort || "";
        toPortInput.value = edge.toPort || "";
        
        fromPortInput.onchange = () => updateEdgePortLabels(id);
        toPortInput.onchange = () => updateEdgePortLabels(id);
       }
       
       const list = document.getElementById("edge-notes");
       list.innerHTML = "";
       edge.notes.forEach((note, i) => {
        const li = document.createElement("li");
        const txt = document.createElement("span");
        txt.textContent = note;
        txt.style.flex = "1";
        const del = document.createElement("span");
        del.className = "delete-note";
        del.textContent = "✕";
        del.addEventListener("click", (e) => {
         e.stopPropagation();
         challengeTheImmortal("Delete this line note?", () => {
          edge.notes.splice(i, 1);
          
          selectTheConnection(id);
         });
        });
        txt.addEventListener("dblclick", () => {
         txt.classList.add("editing");
         txt.contentEditable = true;
         txt.focus();
        });
        txt.addEventListener("blur", () => {
         txt.classList.remove("editing");
         txt.contentEditable = false;
         edge.notes[i] = txt.textContent;
         
        });
        li.append(txt, del);
        list.appendChild(li);
       });
       
       if (edge.type === "custom" && Array.isArray(edge.points)) {
        forgeTheTopology();
       }
      }
      window.addEventListener("resize", () => {
       forgeTheTopology();
       if (currentEdgeId) {
        selectTheConnection(currentEdgeId);
       } else if (currentNodeId && NODE_DATA[currentNodeId]) {
        claimTheImmortal(currentNodeId);
       } else {
        const availableNodes = Object.keys(NODE_DATA);
        if (availableNodes.length > 0) {
         claimTheImmortal(availableNodes[0]);
        }
       }
      });
      (function initZoomPan() {
       const viewport = document.getElementById("canvas-viewport");
       const svg = document.getElementById("map");
       const hint = document.getElementById("canvas-hint");
       setTimeout(() => {
        hint.classList.add("visible");
        setTimeout(() => hint.classList.remove("visible"), 4000);
       }, 1000);
       viewport.addEventListener("wheel",
        (e) => {
         e.preventDefault();
         const rect = viewport.getBoundingClientRect();
         const mouseX = (e.clientX - rect.left) / rect.width;
         const mouseY = (e.clientY - rect.top) / rect.height;
         const delta = e.deltaY > 0 ? 0.9 : 1.1;
         zoomTo(canvasState.zoom * delta, mouseX, mouseY);
        }, {
         passive: false
        }, );
       let initialPinchDistance = 0;
       let initialPinchZoom = 1;
       let pinchCenter = {
        x: 0.5,
        y: 0.5
       };
       viewport.addEventListener("touchstart",
        (e) => {
         if (e.touches.length === 2) {
          e.preventDefault();
          const touch1 = e.touches[0];
          const touch2 = e.touches[1];
          initialPinchDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY, );
          initialPinchZoom = canvasState.zoom;
          const rect = viewport.getBoundingClientRect();
          const centerX = (touch1.clientX + touch2.clientX) / 2;
          const centerY = (touch1.clientY + touch2.clientY) / 2;
          pinchCenter.x = (centerX - rect.left) / rect.width;
          pinchCenter.y = (centerY - rect.top) / rect.height;
         }
        }, {
         passive: false
        }, );
       viewport.addEventListener("touchmove",
        (e) => {
         if (e.touches.length === 2) {
          e.preventDefault();
          const touch1 = e.touches[0];
          const touch2 = e.touches[1];
          const currentDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY, );
          if (initialPinchDistance > 0) {
           const scale = currentDistance / initialPinchDistance;
           const newZoom = initialPinchZoom * scale;
           zoomTo(newZoom, pinchCenter.x, pinchCenter.y);
          }
         }
        }, {
         passive: false
        }, );
       let panStartViewX = 0;
       let panStartViewY = 0;
       
       let lastEmptyTapTime = 0;
       let emptyTapTimeout = null;
       let emptyTapMoved = false;
       let emptyTapStartX = 0;
       let emptyTapStartY = 0;
       
       viewport.addEventListener("touchend", (e) => {
         if (currentView.mode !== "rack") return;
         
         if (e.changedTouches.length !== 1) return;
         
      const isNodeOrEdge = e.target.closest(".node-group") || e.target.closest(".edge-group");
         if (isNodeOrEdge) return;
         
         if (emptyTapMoved) {
           emptyTapMoved = false;
           return;
         }
         
         const currentTime = new Date().getTime();
         const tapGap = currentTime - lastEmptyTapTime;
         
         if (tapGap < 300 && tapGap > 0) {
           e.preventDefault();
           
           exitRack();
           
           if (navigator.vibrate) {
             navigator.vibrate(50);
           }
           
           lastEmptyTapTime = 0;
           if (emptyTapTimeout) {
             clearTimeout(emptyTapTimeout);
             emptyTapTimeout = null;
           }
         } else {
           lastEmptyTapTime = currentTime;
           
           if (emptyTapTimeout) clearTimeout(emptyTapTimeout);
           emptyTapTimeout = setTimeout(() => {
             lastEmptyTapTime = 0;
           }, 300);
         }
       }, { passive: false });
       
       viewport.addEventListener("mousedown", (e) => {
        if (e.target.closest(".draw-toolbar") || e.target.closest(".topology-toolbar") || e.target.closest(".legend-container")) {
         return;
        }
      
        if (freeDrawMode || rectDrawMode) {
         return;
        }
      const isEmptySpace = e.target === svg || e.target === viewport || e.target.tagName === "svg";
      const isEdgeElement = e.target.closest('.edge') || e.target.classList.contains('edge-edit-point');
      const isTextElement = e.target.closest('.text-group') || e.target.closest('.text-element');
      const isRectElement = e.target.closest('.rect-group');
      if (!isEdgeElement && !isTextElement && !isRectElement && currentEdgeId) {
      currentEdgeId = null;
      forgeTheTopology();
      }
      if (!isRectElement && currentRectId) {
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      }
	  if (isViewOnly()) {
         document.body.classList.remove("view-only-inspect");
         document.getElementById("node-panel").style.display = "none";
         document.getElementById("edge-panel").style.display = "none";
        }
        if (isEmptySpace && e.shiftKey && e.button === 0) {
         if (isViewOnly()) return;
         e.preventDefault();
         startSelection(e);
         return;
        }
        if (isEmptySpace || e.button === 2 || e.button === 1) {
         e.preventDefault();
         canvasState.isPanning = true;
         canvasState.panStartX = e.clientX;
         canvasState.panStartY = e.clientY;
         panStartViewX = canvasState.panX;
         panStartViewY = canvasState.panY;
         viewport.classList.add("panning");
        }
       });
       viewport.addEventListener("touchstart",
        (e) => {
         if (e.target.closest(".draw-toolbar") || e.target.closest(".topology-toolbar") || e.target.closest(".legend-container")) {
          return;
         }
      
         if (freeDrawMode || rectDrawMode) {
          return;
         }
      const isEmptySpace = e.target === svg || e.target === viewport || e.target.tagName === "svg";
      const isEdgeElement = e.target.closest('.edge') || e.target.classList.contains('edge-edit-point');
      const isTextElement = e.target.closest('.text-group') || e.target.closest('.text-element');
      const isRectElement = e.target.closest('.rect-group');
      if (!isEdgeElement && !isTextElement && !isRectElement && currentEdgeId) {
      currentEdgeId = null;
      forgeTheTopology();
      }
      if (!isRectElement && currentRectId) {
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      }
          if (isEmptySpace && e.touches.length === 1) {
           e.preventDefault();
           emptyTapMoved = false;
           emptyTapStartX = e.touches[0].clientX;
           emptyTapStartY = e.touches[0].clientY;
           canvasState.isPanning = true;
           canvasState.panStartX = e.touches[0].clientX;
           canvasState.panStartY = e.touches[0].clientY;
           panStartViewX = canvasState.panX;
           panStartViewY = canvasState.panY;
           viewport.classList.add("panning");
         }
        }, {
         passive: false
        }, );
       document.addEventListener("mousemove", (e) => {
        if (isSelecting) {
         updateSelection(e);
         return;
        }
        if (!canvasState.isPanning) return;
        const dx = e.clientX - canvasState.panStartX;
        const dy = e.clientY - canvasState.panStartY;
        const rect = viewport.getBoundingClientRect();
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        const canvasDx = (dx / rect.width) * viewWidth;
        const canvasDy = (dy / rect.height) * viewHeight;
        canvasState.panX = panStartViewX - canvasDx;
        canvasState.panY = panStartViewY - canvasDy;
        constrainPan();
        updateViewBox();
       });
       document.addEventListener("touchmove", (e) => {
        if (!canvasState.isPanning || !e.touches[0]) return;
        const moveDx = Math.abs(e.touches[0].clientX - emptyTapStartX);
        const moveDy = Math.abs(e.touches[0].clientY - emptyTapStartY);
        if (moveDx > 15 || moveDy > 15) {
         emptyTapMoved = true;
        }
        const dx = e.touches[0].clientX - canvasState.panStartX;
        const dy = e.touches[0].clientY - canvasState.panStartY;
        const rect = viewport.getBoundingClientRect();
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        const canvasDx = (dx / rect.width) * viewWidth;
        const canvasDy = (dy / rect.height) * viewHeight;
        canvasState.panX = panStartViewX - canvasDx;
        canvasState.panY = panStartViewY - canvasDy;
        constrainPan();
        updateViewBox();
       });
       document.addEventListener("mouseup", () => {
        if (isSelecting) {
         endSelection();
        }
        if (canvasState.isPanning) {
         canvasState.isPanning = false;
         viewport.classList.remove("panning");
        }
       });
       document.addEventListener("touchend", () => {
        if (canvasState.isPanning) {
         canvasState.isPanning = false;
         viewport.classList.remove("panning");
        }
       });
       document.addEventListener("keydown", (e) => {
        const isEditing = document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "TEXTAREA" || document.activeElement.isContentEditable;
        if (e.code === "Space" && !e.repeat && !isEditing) {
         e.preventDefault();
         canvasState.spacePressed = true;
         viewport.style.cursor = "grab";
        }
       });
       document.addEventListener("keyup", (e) => {
        if (e.code === "Space") {
         canvasState.spacePressed = false;
         viewport.style.cursor = "";
        }
       });
       document.getElementById("zoom-in-btn").addEventListener("click", () => {
        zoomTo(canvasState.zoom * 1.25, 0.5, 0.5);
       });
       document.getElementById("zoom-out-btn").addEventListener("click", () => {
        zoomTo(canvasState.zoom * 0.8, 0.5, 0.5);
       });
       document.getElementById("zoom-fit-btn").addEventListener("click", fitToContent);
       document.getElementById("zoom-reset-btn").addEventListener("click", resetView);
       const minimapContainer = document.getElementById("minimap-container");
       const minimapSvg = document.getElementById("minimap");
       let minimapDragging = false;
       minimapContainer.addEventListener("mousedown", (e) => {
        e.preventDefault();
        minimapDragging = true;
        updatePanFromMinimap(e);
       });
       minimapContainer.addEventListener("touchstart",
        (e) => {
         e.preventDefault();
         minimapDragging = true;
         updatePanFromMinimapTouch(e);
        }, {
         passive: false
        }, );
       document.addEventListener("mousemove", (e) => {
        if (minimapDragging) {
         updatePanFromMinimap(e);
        }
       });
       document.addEventListener("touchmove", (e) => {
        if (minimapDragging && e.touches[0]) {
         updatePanFromMinimapTouch(e);
        }
       });
       document.addEventListener("mouseup", () => {
        minimapDragging = false;
       });
       document.addEventListener("touchend", () => {
        minimapDragging = false;
       });
      
       function updatePanFromMinimap(e) {
        const rect = minimapContainer.getBoundingClientRect();
        const x = (e.clientX - rect.left) / rect.width;
        const y = (e.clientY - rect.top) / rect.height;
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        canvasState.panX = x * CANVAS_WIDTH - viewWidth / 2;
        canvasState.panY = y * CANVAS_HEIGHT - viewHeight / 2;
        constrainPan();
        updateViewBox();
       }
      
       function updatePanFromMinimapTouch(e) {
        const rect = minimapContainer.getBoundingClientRect();
        const touch = e.touches[0];
        const x = (touch.clientX - rect.left) / rect.width;
        const y = (touch.clientY - rect.top) / rect.height;
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        canvasState.panX = x * CANVAS_WIDTH - viewWidth / 2;
        canvasState.panY = y * CANVAS_HEIGHT - viewHeight / 2;
        constrainPan();
        updateViewBox();
       }
       document.addEventListener("keydown", (e) => {
        if (document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "TEXTAREA") return;
        if (
         (e.key === "+" || e.key === "=") && (e.ctrlKey || e.metaKey)) {
         e.preventDefault();
         zoomTo(canvasState.zoom * 1.25, 0.5, 0.5);
        } else if (e.key === "-" && (e.ctrlKey || e.metaKey)) {
         e.preventDefault();
         zoomTo(canvasState.zoom * 0.8, 0.5, 0.5);
        } else if (e.key === "0" && (e.ctrlKey || e.metaKey)) {
         e.preventDefault();
         resetView();
        }
       });
       setTimeout(() => {
        fitToContent();
       }, 100);
      })();
      const sizeSlider = document.getElementById("size-slider");
      const sizeValue = document.getElementById("size-value");
      const resetSizeBtn = document.getElementById("reset-size");
      sizeSlider.addEventListener("input", () => {
       const newSize = parseInt(sizeSlider.value, 10);
       sizeValue.textContent = newSize;
       savedSizes[currentNodeId] = newSize;
       const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
       if (nodeGroup) {
        const oldShape = nodeGroup.querySelector(".node-circle");
        if (oldShape) oldShape.remove();
        const shapeType = (NODE_DATA[currentNodeId] && NODE_DATA[currentNodeId].shape) || "circle";
        const newShape = createShapeElement(shapeType, newSize);
        newShape.classList.add("node-circle");
        const styles = resolveStylesForNode(currentNodeId);
        if (styles.circleColor) newShape.style.fill = styles.circleColor;
        if (styles.circleBorder) newShape.style.stroke = styles.circleBorder;
        nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
        const label = nodeGroup.querySelector(".node-label");
        const sub = nodeGroup.querySelector(".node-sub");
        if (label) {
         label.setAttribute("y", -newSize * 0.28);
         const labelSize = styles.titleSize || newSize * 0.33;
         label.style.fontSize = labelSize + "px";
        }
        if (sub) {
         sub.setAttribute("y", newSize * 0.4);
         const subSize = styles.subSize || newSize * 0.24;
         sub.style.fontSize = subSize + "px";
        }
       }
      });
      resetSizeBtn.addEventListener("click", () => {
       delete savedSizes[currentNodeId];
       const defaultSize = getDefaultSize();
       sizeSlider.value = defaultSize;
       sizeValue.textContent = defaultSize;
       const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
       if (nodeGroup) {
        const oldShape = nodeGroup.querySelector(".node-circle");
        if (oldShape) oldShape.remove();
        const shapeType = (NODE_DATA[currentNodeId] && NODE_DATA[currentNodeId].shape) || "circle";
        const newShape = createNodeShape(currentNodeId, defaultSize);
        nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
        const styles = resolveStylesForNode(currentNodeId);
        if (styles.circleColor) newShape.style.fill = styles.circleColor;
        if (styles.circleBorder) newShape.style.stroke = styles.circleBorder;
        const label = nodeGroup.querySelector(".node-label");
        const sub = nodeGroup.querySelector(".node-sub");
        if (label) {
         label.setAttribute("y", -defaultSize * 0.28);
         const labelSize = styles.titleSize || defaultSize * 0.33;
         label.style.fontSize = labelSize + "px";
        }
        if (sub) {
         sub.setAttribute("y", defaultSize * 0.4);
         const subSize = styles.subSize || defaultSize * 0.24;
         sub.style.fontSize = subSize + "px";
        }
       }
      });
      const applyStyle = (property, value) => {
       const styleEntry = ensureStyleEntry(currentNodeId);
       const scopeKey = currentStyleScope || "all";
       if (!styleEntry[scopeKey]) styleEntry[scopeKey] = {};
       styleEntry[scopeKey][property] = value;
       const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
       if (!nodeGroup) return;
       const shapeEl = nodeGroup.querySelector(".node-circle");
       const label = nodeGroup.querySelector(".node-label");
       const sub = nodeGroup.querySelector(".node-sub");
       if (property === "circleColor" && shapeEl) shapeEl.style.fill = value;
      else if (property === "circleBorder" && shapeEl) shapeEl.style.stroke = value;
       else if (property === "titleColor" && label) label.style.fill = value;
       else if (property === "titleFont" && label) label.style.fontFamily = value;
       else if (property === "titleSize" && label) label.style.fontSize = value + "px";
       else if (property === "subColor" && sub) sub.style.fill = value;
       else if (property === "subFont" && sub) sub.style.fontFamily = value;
       else if (property === "subSize" && sub) sub.style.fontSize = value + "px";
      };
      document.getElementById("circle-color").addEventListener("input", (e) => applyStyle("circleColor", e.target.value), );
      document.getElementById("circle-border").addEventListener("input", (e) => applyStyle("circleBorder", e.target.value), );
      document.getElementById("title-color").addEventListener("input", (e) => applyStyle("titleColor", e.target.value), );
      document.getElementById("title-font").addEventListener("change", (e) => applyStyle("titleFont", e.target.value), );
      document.getElementById("title-size").addEventListener("input", (e) => applyStyle("titleSize", parseInt(e.target.value, 10)), );
      document.getElementById("sub-color").addEventListener("input", (e) => applyStyle("subColor", e.target.value), );
      document.getElementById("sub-font").addEventListener("change", (e) => applyStyle("subFont", e.target.value), );
      document.getElementById("sub-size").addEventListener("input", (e) => applyStyle("subSize", parseInt(e.target.value, 10)), );
      document.getElementById("title-offset-y").addEventListener("input", (e) => {
       applyStyle("titleOffsetY", parseInt(e.target.value, 10) || 0);
       forgeTheTopology();
       if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      document.getElementById("title-offset-x").addEventListener("input", (e) => {
       applyStyle("titleOffsetX", parseInt(e.target.value, 10) || 0);
       forgeTheTopology();
       if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      document.getElementById("sub-offset-y").addEventListener("input", (e) => {
       applyStyle("subOffsetY", parseInt(e.target.value, 10) || 0);
       forgeTheTopology();
       if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      document.getElementById("sub-offset-x").addEventListener("input", (e) => {
       applyStyle("subOffsetX", parseInt(e.target.value, 10) || 0);
       forgeTheTopology();
       if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      document.getElementById("reset-styles").addEventListener("click", () => {
       delete savedStyles[currentNodeId];
       forgeTheTopology();
       claimTheImmortal(currentNodeId);
      });
      document.getElementById("style-scope").addEventListener("change", (e) => {
       currentStyleScope = e.target.value || "all";
       claimTheImmortal(currentNodeId);
      });
      document.getElementById("shape-select").addEventListener("change", (e) => {
       const shape = e.target.value || "circle";
       NODE_DATA[currentNodeId].shape = shape;
       const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
       if (!nodeGroup) return;
       const oldShape = nodeGroup.querySelector(".node-circle");
       if (oldShape) oldShape.remove();
       const size = savedSizes[currentNodeId] || getDefaultSize();
       const newShape = createNodeShape(currentNodeId, size);
       nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
      });
      const addNoteBtn = document.getElementById("add-note-btn");
      const noteInput = document.getElementById("new-note-input");
      addNoteBtn.addEventListener("click", () => {
       const newNote = noteInput.value.trim();
       if (newNote && currentNodeId) {
        NODE_DATA[currentNodeId].notes.push(newNote);
        claimTheImmortal(currentNodeId);
        noteInput.value = "";
       }
      });
      noteInput.addEventListener("keypress", (e) => {
       if (e.key === "Enter") {
        addNoteBtn.click();
       }
      });
      document.getElementById("edge-width").addEventListener("input", () => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       const v = parseInt(document.getElementById("edge-width").value, 10);
       if (Number.isNaN(v) || v <= 0) return;
       edge.width = v;
       
       const el = document.querySelector(`.edge[data-edge-id="${currentEdgeId}"]`, );
       if (el) el.style.strokeWidth = v;
      });
      document.getElementById("edge-color").addEventListener("input", () => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       const color = document.getElementById("edge-color").value;
       edge.color = color;
       
       const el = document.querySelector(`.edge[data-edge-id="${currentEdgeId}"]`, );
       if (el) el.style.stroke = color;
       forgeTheLegend();
      });
      document.getElementById("edge-direction").addEventListener("change", () => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       edge.direction = document.getElementById("edge-direction").value;
       
       forgeTheTopology();
       selectTheConnection(currentEdgeId);
      });
      document.getElementById("edge-line-style").addEventListener("change", () => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       edge.lineStyle = document.getElementById("edge-line-style").value;
       
       forgeTheTopology();
       selectTheConnection(currentEdgeId);
      });
      const addEdgeNoteBtn = document.getElementById("add-edge-note");
      const newEdgeNoteInput = document.getElementById("new-edge-note");
      addEdgeNoteBtn.addEventListener("click", () => {
       const txt = newEdgeNoteInput.value.trim();
       if (!txt || !currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       edge.notes.push(txt);
       
       newEdgeNoteInput.value = "";
       selectTheConnection(currentEdgeId);
      });
      newEdgeNoteInput.addEventListener("keypress", (e) => {
       if (e.key === "Enter") {
        addEdgeNoteBtn.click();
       }
      });
	  
      function selectTheRect(id) {
	  if (isViewOnly()) return;
      currentRectId = id;
      currentNodeId = null;
      currentEdgeId = null;
      currentTextId = null;
      document.getElementById("node-panel").style.display = "none";
      document.getElementById("edge-panel").style.display = "none";
      document.getElementById("text-panel").style.display = "none";
      document.getElementById("rect-panel").style.display = "block";
      document.getElementById("topology-toolbar").style.display = "none";
      document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active"));
      document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
      document.querySelectorAll(".text-element").forEach(t => t.classList.remove("active"));
      document.querySelectorAll(".rect-group").forEach(r => r.classList.toggle("active", r.dataset.rectId === id));
      
      const rect = RECT_DATA.list.find(r => r.id === id);
      if (!rect) return;
      
      document.getElementById("rect-title").textContent = "";
      document.getElementById("rect-color").value = rect.color || "#f97316";
      document.getElementById("rect-border-color").value = rect.borderColor || rect.color || "#f97316";
      document.getElementById("rect-border-width").value = rect.borderWidth !== undefined ? rect.borderWidth : 2;
      document.getElementById("rect-style-select").value = rect.style || "filled";
      document.getElementById("rect-line-style").value = rect.lineStyle || "solid";
      document.getElementById("rect-fill-row").style.display = (rect.style === "outlined") ? "none" : "flex";
      
      const list = document.getElementById("rect-notes");
      list.innerHTML = "";
      (rect.notes || []).forEach((note, i) => {
      const li = document.createElement("li");
      const txt = document.createElement("span");
      txt.textContent = note;
      txt.style.flex = "1";
      const del = document.createElement("span");
      del.className = "delete-note";
      del.textContent = "✕";
      del.addEventListener("click", (e) => {
      e.stopPropagation();
      challengeTheImmortal("Delete this note?", () => {
        rect.notes.splice(i, 1);
        selectTheRect(id);
      });
      });
      li.appendChild(txt);
      li.appendChild(del);
      list.appendChild(li);
      });
      
      forgeTheTopology();
      }
      
      document.getElementById("rect-color").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      rect.color = document.getElementById("rect-color").value;
      forgeTheTopology();
      });
      
      document.getElementById("rect-border-color").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      rect.borderColor = document.getElementById("rect-border-color").value;
      forgeTheTopology();
      });
      
      document.getElementById("rect-border-width").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      rect.borderWidth = parseInt(document.getElementById("rect-border-width").value) || 2;
      forgeTheTopology();
      });
      
      document.getElementById("rect-style-select").addEventListener("change", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      rect.style = document.getElementById("rect-style-select").value;
      forgeTheTopology();
      selectTheRect(currentRectId);
      });
      
      document.getElementById("rect-line-style").addEventListener("change", () => {
      if (!currentRectId) return;
      pushUndo("change zone line style");
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      rect.lineStyle = document.getElementById("rect-line-style").value;
      forgeTheTopology();
      });
      
      document.getElementById("add-rect-note").addEventListener("click", () => {
      const input = document.getElementById("new-rect-note");
      const txt = input.value.trim();
      if (!txt || !currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      if (!rect.notes) rect.notes = [];
      rect.notes.push(txt);
      input.value = "";
      selectTheRect(currentRectId);
      });
      
      document.getElementById("new-rect-note").addEventListener("keypress", (e) => {
      if (e.key === "Enter") {
      document.getElementById("add-rect-note").click();
      }
      });
      
      document.getElementById("delete-rect").addEventListener("click", () => {
      if (!currentRectId) return;
      challengeTheImmortal("Delete this zone?", () => {
      RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== currentRectId);
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      });
      });
      document.getElementById("delete-edge").addEventListener("click", () => {
       if (!currentEdgeId) return;
       challengeTheImmortal("Are you sure you want to delete this line?",
        () => {
         EDGE_DATA.list = EDGE_DATA.list.filter(
          (e) => e.id !== currentEdgeId, );
         
         currentEdgeId = null;
         forgeTheTopology();
         const availableNodes = Object.keys(NODE_DATA);
         if (availableNodes.length > 0) {
          claimTheImmortal(availableNodes[0]);
         } else {
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("topology-toolbar", ).style.display = "none";
         }
        }, );
      });
      document.getElementById("add-line-btn").addEventListener("click", () => {
       if (!currentNodeId) return;
       const select = document.getElementById("add-line-select");
       const directionSelect = document.getElementById("add-line-direction");
       const colorInput = document.getElementById("add-line-color");
       const targetId = select.value;
       if (!targetId || targetId === currentNodeId) return;
       const direction = directionSelect.value || "none";
       const lineColor = colorInput.value || "#475569";
       const newId = `${currentNodeId}-${targetId}-${Date.now()}`;
       const newEdge = {
        id: newId,
        from: currentNodeId,
        to: targetId,
        width: 4,
        color: lineColor,
        direction: direction,
        type: "main",
        notes: [],
        fromPort: "",
        toPort: "",
        lineStyle: "solid",
       };
       EDGE_DATA.list.push(newEdge);
       
       forgeTheTopology();
       claimTheImmortal(currentNodeId);
      });
      let freeDrawPoints = [];
      let freeDrawPolylineEl = null;
      let freeDrawPointEls = [];
    
       let rectStartPoint = null;
       let rectPreviewEl = null;
       let rectStyle = "filled";
      const drawToggleBtn = document.getElementById("draw-toggle");
      const drawUndoBtn = document.getElementById("draw-undo");
      const drawColorInput = document.getElementById("draw-color");
      const drawStyleSelect = document.getElementById("draw-style");
      const drawArrowSelect = document.getElementById("draw-arrow");
      const svgMap = document.getElementById("map");
      
      function updateFreeDrawGraphics() {
       const ns = "http://www.w3.org/2000/svg";
       const svg = svgMap;
       if (!freeDrawPolylineEl && freeDrawPoints.length > 0) {
        freeDrawPolylineEl = document.createElementNS(ns, "polyline");
        freeDrawPolylineEl.classList.add("edge", "free-preview");
        freeDrawPolylineEl.setAttribute("fill", "none");
        svg.appendChild(freeDrawPolylineEl);
       }
       if (freeDrawPolylineEl) {
        if (freeDrawPoints.length === 0) {
         freeDrawPolylineEl.remove();
         freeDrawPolylineEl = null;
        } else {
         const ptsStr = freeDrawPoints.map((p) => `${p.x},${p.y}`).join(" ");
         freeDrawPolylineEl.setAttribute("points", ptsStr);
         freeDrawPolylineEl.style.stroke = drawColorInput.value || "#475569";
         freeDrawPolylineEl.style.strokeWidth = 3;
         const lineStyle = drawStyleSelect.value || "solid";
         if (lineStyle === "dashed") {
          freeDrawPolylineEl.style.strokeDasharray = "10,5";
         } else if (lineStyle === "dotted") {
          freeDrawPolylineEl.style.strokeDasharray = "2,4";
         } else {
          freeDrawPolylineEl.style.strokeDasharray = "none";
         }
        }
       }
       freeDrawPointEls.forEach((el) => el.remove());
       freeDrawPointEls = [];
       freeDrawPoints.forEach((p, idx) => {
        const c = document.createElementNS(ns, "circle");
        c.classList.add("free-point");
        c.setAttribute("cx", p.x);
        c.setAttribute("cy", p.y);
        c.setAttribute("r", 5);
        c.dataset.index = String(idx);
        c.addEventListener("mousedown", (e) => {
         if (!freeDrawMode) return;
         e.preventDefault();
         e.stopPropagation();
         let dragging = true;
         const svgEl = svgMap;
         const moveHandler = (ev) => {
          if (!dragging) return;
          const pt = svgEl.createSVGPoint();
          pt.x = ev.clientX;
          pt.y = ev.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          const i = parseInt(c.dataset.index, 10);
          if (Number.isNaN(i) || !freeDrawPoints[i]) return;
          freeDrawPoints[i].x = svgP.x;
          freeDrawPoints[i].y = svgP.y;
          updateFreeDrawGraphics();
         };
         const upHandler = () => {
          dragging = false;
          document.removeEventListener("mousemove", moveHandler);
          document.removeEventListener("mouseup", upHandler);
         };
         document.addEventListener("mousemove", moveHandler);
         document.addEventListener("mouseup", upHandler);
        });
        c.addEventListener("touchstart",
         (e) => {
          if (!freeDrawMode) return;
          e.preventDefault();
          e.stopPropagation();
          let dragging = true;
          const svgEl = svgMap;
          const touchMoveHandler = (ev) => {
           if (!dragging || !ev.touches[0]) return;
           const pt = svgEl.createSVGPoint();
           pt.x = ev.touches[0].clientX;
           pt.y = ev.touches[0].clientY;
           const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
           const i = parseInt(c.dataset.index, 10);
           if (Number.isNaN(i) || !freeDrawPoints[i]) return;
           freeDrawPoints[i].x = svgP.x;
           freeDrawPoints[i].y = svgP.y;
           updateFreeDrawGraphics();
          };
          const touchUpHandler = () => {
           dragging = false;
           document.removeEventListener("touchmove", touchMoveHandler, );
           document.removeEventListener("touchend", touchUpHandler, );
          };
          document.addEventListener("touchmove", touchMoveHandler);
          document.addEventListener("touchend", touchUpHandler);
         }, {
          passive: false
         }, );
        svg.appendChild(c);
        freeDrawPointEls.push(c);
       });
       drawUndoBtn.style.display = freeDrawPoints.length ? "inline-block" : "none";
      }
      
      function addFreeDrawPoint(x, y) {
       freeDrawPoints.push({
        x,
        y
       });
       updateFreeDrawGraphics();
      }
      
      function startFreeDraw() {
       freeDrawMode = true;
       freeDrawPoints = [];
       if (freeDrawPolylineEl) {
        freeDrawPolylineEl.remove();
        freeDrawPolylineEl = null;
       }
       freeDrawPointEls.forEach((el) => el.remove());
       freeDrawPointEls = [];
       svgMap.style.cursor = "crosshair";
       drawToggleBtn.textContent = "Done";
       drawUndoBtn.style.display = "none";
      }
      
      function finishFreeDraw() {
       freeDrawMode = false;
       svgMap.style.cursor = "";
       drawToggleBtn.textContent = "✏️";
       if (freeDrawPoints.length >= 2) {
        const color = drawColorInput.value || "#475569";
        const lineStyle = drawStyleSelect.value || "solid";
        const arrowDir = drawArrowSelect.value || "none";
        const newId = "custom-" + Date.now();
        const pointsCopy = freeDrawPoints.map((p) => ({
         x: p.x,
         y: p.y,
        }));
        EDGE_DATA.list.push({
         id: newId,
         type: "custom",
         color,
         width: 4,
         lineStyle: lineStyle,
         direction: arrowDir,
         points: pointsCopy,
         notes: [],
        });
        
        freeDrawPoints = [];
        if (freeDrawPolylineEl) {
         freeDrawPolylineEl.remove();
         freeDrawPolylineEl = null;
        }
        freeDrawPointEls.forEach((el) => el.remove());
        freeDrawPointEls = [];
        forgeTheTopology();
        selectTheConnection(newId);
       } else {
        freeDrawPoints = [];
        if (freeDrawPolylineEl) {
         freeDrawPolylineEl.remove();
         freeDrawPolylineEl = null;
        }
        freeDrawPointEls.forEach((el) => el.remove());
        freeDrawPointEls = [];
        forgeTheLegend();
       }
       drawUndoBtn.style.display = "none";
      }
      drawToggleBtn.addEventListener("click", () => {
       if (currentView.mode === "rack") {
        alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
        return;
       }
       
       if (freeDrawMode) {
        finishFreeDraw();
       } else {
        startFreeDraw();
       }
      });
      drawUndoBtn.addEventListener("click", () => {
       if (!freeDrawMode || !freeDrawPoints.length) return;
       freeDrawPoints.pop();
       updateFreeDrawGraphics();
      });
      const drawToolbar = document.getElementById("draw-toolbar");
      drawToolbar.addEventListener("mousedown", (e) => {
       e.stopPropagation();
      });
      drawToolbar.addEventListener("click", (e) => {
       if (e.target !== drawToggleBtn && e.target !== drawUndoBtn) {
        e.stopPropagation();
       }
      });
      drawStyleSelect.addEventListener("change", () => {
       if (freeDrawMode) {
        updateFreeDrawGraphics();
       }
      });
      drawArrowSelect.addEventListener("change", () => {
       if (freeDrawMode) {
        updateFreeDrawGraphics();
       }
      });
      drawColorInput.addEventListener("input", () => {
       if (freeDrawMode) {
        updateFreeDrawGraphics();
       }
      });
      drawStyleSelect.addEventListener("mousedown", (e) => {
       e.stopPropagation();
      });
      drawStyleSelect.addEventListener("click", (e) => {
       e.stopPropagation();
      });
      drawArrowSelect.addEventListener("mousedown", (e) => {
       e.stopPropagation();
      });
      drawArrowSelect.addEventListener("click", (e) => {
       e.stopPropagation();
      });
      drawColorInput.addEventListener("mousedown", (e) => {
       e.stopPropagation();
      });
      drawColorInput.addEventListener("click", (e) => {
       e.stopPropagation();
      });
      
      svgMap.addEventListener("click", (e) => {
       if (!freeDrawMode) return;
       if (e.button !== 0) return;
       const target = e.target;
       if (target && target.classList && target.classList.contains("free-point")) return;
       const svgEl = svgMap;
       const pt = svgEl.createSVGPoint();
       pt.x = e.clientX;
       pt.y = e.clientY;
       const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
       addFreeDrawPoint(svgP.x, svgP.y);
      });
      svgMap.addEventListener("touchend",
       (e) => {
        if (!freeDrawMode) return;
        const target = e.target;
        if (target && target.classList && target.classList.contains("free-point")) return;
        if (e.changedTouches && e.changedTouches[0]) {
         e.preventDefault();
         const svgEl = svgMap;
         const pt = svgEl.createSVGPoint();
         pt.x = e.changedTouches[0].clientX;
         pt.y = e.changedTouches[0].clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
         addFreeDrawPoint(svgP.x, svgP.y);
        }
       }, {
        passive: false
       }, );
      
       const rectToggleBtn = document.getElementById("rect-toggle");
       const rectStyleSelect = document.getElementById("rect-style");
      
       function startRectDraw() {
        rectDrawMode = true;
        rectStartPoint = null;
        rectPreviewEl = null;
        svgMap.style.cursor = "crosshair";
        rectToggleBtn.textContent = "Done";
        rectStyle = rectStyleSelect.value || "filled";
        
        if (freeDrawMode) {
         finishFreeDraw();
        }
        updateRectangleDeleteButtons();
       }
      
       function finishRectDraw() {
        rectDrawMode = false;
        svgMap.style.cursor = "";
        rectToggleBtn.textContent = "▭";
        
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
        updateRectangleDeleteButtons();
       }
      
       rectToggleBtn.addEventListener("click", () => {
        if (currentView.mode === "rack") {
         alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
         return;
        }
        
        if (rectDrawMode) {
         finishRectDraw();
        } else {
         startRectDraw();
        }
       });
      
       rectStyleSelect.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       rectStyleSelect.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       rectStyleSelect.addEventListener("change", () => {
        if (rectDrawMode) {
         rectStyle = rectStyleSelect.value || "filled";
        }
       });
      
       svgMap.addEventListener("mousedown", (e) => {
        if (!rectDrawMode) return;
        if (e.button !== 0) return;
        e.preventDefault();
        e.stopPropagation();
        
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        rectStartPoint = { x: svgP.x, y: svgP.y };
        
        const ns = "http://www.w3.org/2000/svg";
        rectPreviewEl = document.createElementNS(ns, "rect");
        rectPreviewEl.classList.add("rect-preview");
        rectPreviewEl.setAttribute("x", svgP.x);
        rectPreviewEl.setAttribute("y", svgP.y);
        rectPreviewEl.setAttribute("width", 0);
        rectPreviewEl.setAttribute("height", 0);
        
        const color = drawColorInput.value || "#f97316";
        rectPreviewEl.style.stroke = color;
        rectPreviewEl.style.strokeWidth = 2;
        rectPreviewEl.style.strokeDasharray = "5,5";
        
        if (rectStyle === "filled") {
         rectPreviewEl.style.fill = color;
         rectPreviewEl.style.fillOpacity = "0.3";
        } else {
         rectPreviewEl.style.fill = "none";
        }
        
        svgEl.appendChild(rectPreviewEl);
       });
      
       svgMap.addEventListener("mousemove", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        
        rectPreviewEl.setAttribute("x", x);
        rectPreviewEl.setAttribute("y", y);
        rectPreviewEl.setAttribute("width", width);
        rectPreviewEl.setAttribute("height", height);
       });
      
       svgMap.addEventListener("mouseup", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        
        if (width > 10 && height > 10) {
      pushUndo("draw zone");
         const color = drawColorInput.value || "#f97316";
         const newId = "rect-" + Date.now();
         
          const lineStyle = document.getElementById("draw-style").value || "solid";
         RECT_DATA.list.push({
          id: newId,
          x: x,
          y: y,
          width: width,
          height: height,
          color: color,
          style: rectStyle,
          lineStyle: lineStyle,
          notes: []
         });
         
         forgeTheTopology();
        }
        
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
       });
      
       let rectTouchStart = null;
       
       svgMap.addEventListener("touchstart", (e) => {
        if (!rectDrawMode) return;
        if (e.touches.length !== 1) return;
        
        e.preventDefault();
        const touch = e.touches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        rectStartPoint = { x: svgP.x, y: svgP.y };
        rectTouchStart = { x: svgP.x, y: svgP.y };
        
        const ns = "http://www.w3.org/2000/svg";
        rectPreviewEl = document.createElementNS(ns, "rect");
        rectPreviewEl.classList.add("rect-preview");
        rectPreviewEl.setAttribute("x", svgP.x);
        rectPreviewEl.setAttribute("y", svgP.y);
        rectPreviewEl.setAttribute("width", 0);
        rectPreviewEl.setAttribute("height", 0);
        
        const color = drawColorInput.value || "#f97316";
        rectPreviewEl.style.stroke = color;
        rectPreviewEl.style.strokeWidth = 2;
        rectPreviewEl.style.strokeDasharray = "5,5";
        
        if (rectStyle === "filled") {
         rectPreviewEl.style.fill = color;
         rectPreviewEl.style.fillOpacity = "0.3";
        } else {
         rectPreviewEl.style.fill = "none";
        }
        
        svgEl.appendChild(rectPreviewEl);
       }, { passive: false });
      
       svgMap.addEventListener("touchmove", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        if (e.touches.length !== 1) return;
        
        e.preventDefault();
        const touch = e.touches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        
        rectPreviewEl.setAttribute("x", x);
        rectPreviewEl.setAttribute("y", y);
        rectPreviewEl.setAttribute("width", width);
        rectPreviewEl.setAttribute("height", height);
       }, { passive: false });
      
       svgMap.addEventListener("touchend", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        if (!rectTouchStart) return;
        
        e.preventDefault();
        const touch = e.changedTouches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        
        if (width > 10 && height > 10) {
      pushUndo("draw zone");
         const color = drawColorInput.value || "#f97316";
         const newId = "rect-" + Date.now();
         
        const lineStyle = document.getElementById("draw-style").value || "solid";
         RECT_DATA.list.push({
          id: newId,
          x: x,
          y: y,
          width: width,
          height: height,
          color: color,
          style: rectStyle,
          lineStyle: lineStyle,
          notes: []
         });
         
         forgeTheTopology();
        }
        
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
        rectTouchStart = null;
       }, { passive: false });
      
      const textToggleBtn = document.getElementById("text-toggle");
      
      function startTextMode() {
       textDrawMode = true;
       svgMap.style.cursor = "crosshair";
       textToggleBtn.textContent = "Done";
       textToggleBtn.style.background = "var(--accent)";
       textToggleBtn.style.color = "var(--bg)";
       
       if (freeDrawMode) {
        finishFreeDraw();
       }
       if (rectDrawMode) {
        finishRectDraw();
       }
       
       updateTextDeleteButtons();
      }
      
      function finishTextMode() {
       textDrawMode = false;
       svgMap.style.cursor = "";
       textToggleBtn.textContent = "T";
       textToggleBtn.style.background = "";
       textToggleBtn.style.color = "";
       updateTextDeleteButtons();
      }
      
      textToggleBtn.addEventListener("click", () => {
       if (currentView.mode === "rack") {
        alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
        return;
       }
       
       if (textDrawMode) {
        finishTextMode();
       } else {
        startTextMode();
       }
      });
      
      function handleTextPlacement(e) {
       if (!textDrawMode) return;
       
       const svgEl = svgMap;
       const pt = svgEl.createSVGPoint();
       pt.x = e.clientX;
       pt.y = e.clientY;
       const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
       
       const newId = "text-" + Date.now();
      pushUndo("add text");
       TEXT_DATA.list.push({
        id: newId,
        x: svgP.x,
        y: svgP.y,
        content: "New Text",
        fontSize: 18,
        color: "#e2e8f0",
        fontWeight: "normal",
        fontStyle: "normal",
        textAlign: "start",
        textDecoration: "none",
        bgColor: "#000000",
        bgEnabled: false,
        opacity: 1
       });
       
       forgeTheTopology();
       
       showTextPanel(newId);
      }
      
      svgMap.addEventListener("click", (e) => {
       if (!textDrawMode) return;
       if (e.target.closest('.text-delete-btn')) return;
       if (e.target.closest('.text-group')) return;
       
       e.preventDefault();
       e.stopPropagation();
       handleTextPlacement(e);
      });
      
      svgMap.addEventListener("touchend", (e) => {
       if (!textDrawMode) return;
       if (e.target.closest('.text-delete-btn')) return;
       if (e.target.closest('.text-group')) return;
       if (e.touches.length > 0) return;
       
       e.preventDefault();
       const touch = e.changedTouches[0];
       const fakeEvent = {
        clientX: touch.clientX,
        clientY: touch.clientY,
        preventDefault: () => {},
        stopPropagation: () => {}
       };
       handleTextPlacement(fakeEvent);
      }, { passive: false });
      
      function showTextPanel(textId) {
	  if (isViewOnly()) return;
       currentTextId = textId;
       currentNodeId = null;
       currentEdgeId = null;
       currentRectId = null;
       const textItem = TEXT_DATA.list.find(t => t.id === textId);
       if (!textItem) return;
       
       document.getElementById("node-panel").style.display = "none";
       document.getElementById("edge-panel").style.display = "none";
       document.getElementById("rect-panel").style.display = "none";
       
       const textPanel = document.getElementById("text-panel");
       textPanel.style.display = "block";
       document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active"));
       document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
       document.querySelectorAll(".rect-group").forEach(r => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach(t => t.classList.toggle("active", t.dataset.textId === textId));
       
       document.getElementById("text-content").value = textItem.content;
       document.getElementById("text-font-size").value = textItem.fontSize;
       document.getElementById("text-color").value = textItem.color;
       document.getElementById("text-font-weight").value = textItem.fontWeight;
       document.getElementById("text-font-style").value = textItem.fontStyle;
       document.getElementById("text-align").value = textItem.textAlign;
       document.getElementById("text-decoration").value = textItem.textDecoration;
       document.getElementById("text-bg-color").value = textItem.bgColor;
       document.getElementById("text-bg-enabled").checked = textItem.bgEnabled;
       document.getElementById("text-opacity").value = textItem.opacity;
       document.getElementById("text-opacity-val").textContent = Math.round(textItem.opacity * 100) + "%";
      }
      
      function updateTextDeleteButtons() {
       const deleteButtons = document.querySelectorAll('.text-delete-btn');
       deleteButtons.forEach(btn => {
        btn.style.display = textDrawMode ? 'block' : 'none';
       });
      }
      
      function deleteText(textId) {
      pushUndo("delete text");
       TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== textId);
       forgeTheTopology();
       
       if (currentTextId === textId) {
        document.getElementById("text-panel").style.display = "none";
        currentTextId = null;
       }
      }
      
      document.getElementById("text-content").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
      pushUndo("edit text");
        textItem.content = e.target.value;
        forgeTheTopology();
       }
      });
      
      document.getElementById("text-font-size").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        textItem.fontSize = parseInt(e.target.value);
        forgeTheTopology();
       }
      });
      
      document.getElementById("text-color").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        textItem.color = e.target.value;
        forgeTheTopology();
       }
      });
      
      document.getElementById("text-font-weight").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        textItem.fontWeight = e.target.value;
        forgeTheTopology();
       }
      });
      
      document.getElementById("text-font-style").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        textItem.fontStyle = e.target.value;
        forgeTheTopology();
       }
      });
      
      document.getElementById("text-align").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        textItem.textAlign = e.target.value;
        forgeTheTopology();
       }
      });
      
      document.getElementById("text-decoration").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        textItem.textDecoration = e.target.value;
        forgeTheTopology();
       }
      });
      
      document.getElementById("text-bg-color").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        textItem.bgColor = e.target.value;
        forgeTheTopology();
       }
      });
      
      document.getElementById("text-bg-enabled").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        textItem.bgEnabled = e.target.checked;
        forgeTheTopology();
       }
      });
      
      document.getElementById("text-opacity").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        textItem.opacity = parseFloat(e.target.value);
        document.getElementById("text-opacity-val").textContent = Math.round(textItem.opacity * 100) + "%";
        forgeTheTopology();
       }
      });
      
      document.getElementById("delete-text").addEventListener("click", () => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        challengeTheImmortal(`Delete text "${textItem.content.substring(0, 30)}..."?`, () => {
         deleteText(currentTextId);
        });
       }
      });
      
      const settingsBtn = document.getElementById("settings-btn");
      const settingsModal = document.getElementById("settings-modal");
      const settingsClose = document.getElementById("settings-close");
      settingsBtn.addEventListener("click", () => {
       document.getElementById("page-bg-color").value = PAGE_STATE.background || "#050608";
       document.getElementById("topbar-bg-color").value = PAGE_STATE.topbarBg || "#0b0e13";
       document.getElementById("topbar-border-color").value = PAGE_STATE.topbarBorder || "#1f2533";
       document.getElementById("panel-color").value = PAGE_STATE.panel || "#0b0e13";
       document.getElementById("panel-alt-color").value = PAGE_STATE.panelAlt || "#10141b";
       document.getElementById("sidebar-bg-color").value = PAGE_STATE.sidebarBg || "#10141b";
       document.getElementById("btn-bg-color").value = PAGE_STATE.btnBg || "#0b0e13";
       document.getElementById("btn-text-color").value = PAGE_STATE.btnText || "#e2e8f0";
       document.getElementById("tag-fill-color").value = PAGE_STATE.tagFill || "#1e293b";
       document.getElementById("tag-text-color").value = PAGE_STATE.tagText || "#e2e8f0";
       document.getElementById("tag-border-color").value = PAGE_STATE.tagBorder || "#475569";
       document.getElementById("input-bg-color").value = PAGE_STATE.inputBg || "#0b0e13";
       document.getElementById("input-text-color").value = PAGE_STATE.inputText || "#e2e8f0";
       document.getElementById("input-border-color").value = PAGE_STATE.inputBorder || "#1f2937";
       document.getElementById("input-font-family").value = PAGE_STATE.inputFont || "Inter, system-ui, sans-serif";
       document.getElementById("input-font-size").value = PAGE_STATE.inputFontSize || 14;
       document.getElementById("toolbar-bg-color").value = PAGE_STATE.toolbarBg || "#0f172a";
       document.getElementById("toolbar-border-color").value = PAGE_STATE.toolbarBorder || "#1f2937";
       document.getElementById("toolbar-text-color").value = PAGE_STATE.toolbarText || "#94a3b8";
       document.getElementById("toolbar-btn-bg-color").value = PAGE_STATE.toolbarBtnBg || "#0b0e13";
       document.getElementById("toolbar-btn-text-color").value = PAGE_STATE.toolbarBtnText || "#e2e8f0";
       document.getElementById("minimap-dots-color").value = PAGE_STATE.minimapDots || "#94a3b8";
       document.getElementById("canvas-hint-enabled").checked = PAGE_STATE.canvasHintEnabled !== false;
       document.getElementById("canvas-hint-bg-color").value = PAGE_STATE.canvasHintBg || "#0f172a";
       document.getElementById("canvas-hint-text-color").value = PAGE_STATE.canvasHintColor || "#94a3b8";
       document.getElementById("canvas-hint-text").value = PAGE_STATE.canvasHintText || "";
       document.getElementById("accent-color").value = PAGE_STATE.accent || "#4fd1c5";
       document.getElementById("danger-color").value = PAGE_STATE.danger || "#f56565";
       document.getElementById("text-main-color").value = PAGE_STATE.textMain || "#e2e8f0";
       document.getElementById("text-soft-color").value = PAGE_STATE.textSoft || "#94a3b8";
       document.getElementById("node-fill-color").value = PAGE_STATE.nodeFill || "#1e293b";
       document.getElementById("node-stroke-color").value = PAGE_STATE.nodeStroke || "#475569";
       document.getElementById("node-title-color").value = PAGE_STATE.nodeTitle || "#e2e8f0";
       document.getElementById("node-sub-color").value = PAGE_STATE.nodeSub || "#94a3b8";
       document.getElementById("node-title-size").value = PAGE_STATE.nodeTitleSize || 18;
       document.getElementById("node-sub-size").value = PAGE_STATE.nodeSubSize || 13;
       document.getElementById("node-font-family").value = PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
       document.getElementById("default-edge-color").value = PAGE_STATE.defaultEdge || "#475569";
       document.getElementById("selection-handle-color").value = PAGE_STATE.selectionHandle || "#f59e0b";
       document.getElementById("selection-handle-size").value = PAGE_STATE.selectionHandleSize || 8;
       document.getElementById("group-indicator-color").value = PAGE_STATE.groupIndicator || "#4fd1c5";
       document.getElementById("canvas-gradient-top").value = PAGE_STATE.canvasGradientTop || "#1e2532";
       document.getElementById("canvas-gradient-bottom").value = PAGE_STATE.canvasGradientBottom || "#050608";
       document.getElementById("canvas-border-color").value = PAGE_STATE.canvasBorder || "#475569";
       document.getElementById("canvas-grid-color").value = PAGE_STATE.canvasGrid || "#475569";
       document.getElementById("canvas-grid-size").value = PAGE_STATE.canvasGridSize || 50;
       document.getElementById("rack-frame-fill").value = PAGE_STATE.rackFrameFill || "#0f172a";
       document.getElementById("rack-frame-stroke").value = PAGE_STATE.rackFrameStroke || "#4fd1c5";
       document.getElementById("rack-line-color").value = PAGE_STATE.rackLineColor || "#475569";
       document.getElementById("rack-text-color").value = PAGE_STATE.rackTextColor || "#4fd1c5";
	   document.getElementById("view-only-mode").checked = PAGE_STATE.viewOnly === true;
       settingsModal.classList.add("active");
      });
      settingsClose.addEventListener("click", () => {
       settingsModal.classList.remove("active");
      });
	  document.getElementById("view-only-mode").addEventListener("change", (e) => {
       PAGE_STATE.viewOnly = e.target.checked;
       
       if (e.target.checked) {
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        document.getElementById("rect-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.setProperty('display', 'none', 'important');
        document.getElementById("draw-toolbar").style.setProperty('display', 'none', 'important');      
        currentNodeId = null;
        currentEdgeId = null;
        currentRectId = null;
        currentTextId = null;
        selectedNodes.clear();
        selectedRects.clear();
        selectedTexts.clear();
        selectedEdges.clear();   
        const bulkToolbar = document.getElementById("bulk-toolbar");
        const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active", "selected"));
        document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
        document.querySelectorAll(".rect-group").forEach(r => r.classList.remove("active"));
        document.querySelectorAll(".text-element").forEach(t => t.classList.remove("active"));
       }
       
       wieldThePower();
       if (!e.target.checked) {
        updateDrawToolbarVisibility();
        updateTopologyToolbarVisibility();
       }
       forgeTheTopology();
      });
      settingsModal.addEventListener("click", (e) => {
       if (e.target === settingsModal) {
        settingsModal.classList.remove("active");
       }
      });
      document.getElementById("page-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.background = e.target.value;
       wieldThePower();
      });
      document.getElementById("topbar-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.topbarBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("topbar-border-color").addEventListener("input", (e) => {
       PAGE_STATE.topbarBorder = e.target.value;
       wieldThePower();
      });
      document.getElementById("panel-color").addEventListener("input", (e) => {
       PAGE_STATE.panel = e.target.value;
       wieldThePower();
      });
      document.getElementById("panel-alt-color").addEventListener("input", (e) => {
       PAGE_STATE.panelAlt = e.target.value;
       wieldThePower();
      });
      document.getElementById("sidebar-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.sidebarBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("btn-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.btnBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("btn-text-color").addEventListener("input", (e) => {
       PAGE_STATE.btnText = e.target.value;
       wieldThePower();
      });
      document.getElementById("tag-fill-color").addEventListener("input", (e) => {
       PAGE_STATE.tagFill = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("tag-text-color").addEventListener("input", (e) => {
       PAGE_STATE.tagText = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("tag-border-color").addEventListener("input", (e) => {
       PAGE_STATE.tagBorder = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
	  document.getElementById("selection-fill-color").addEventListener("input", function() {
       selectionBoxStyle.fillColor = this.value;
      });
      document.getElementById("selection-fill-opacity").addEventListener("input", function() {
       selectionBoxStyle.fillOpacity = parseFloat(this.value);
       document.getElementById("selection-fill-opacity-val").textContent = Math.round(this.value * 100) + "%";
      });
      document.getElementById("selection-stroke-color").addEventListener("input", function() {
       selectionBoxStyle.strokeColor = this.value;
      });
      document.getElementById("selection-stroke-width").addEventListener("input", function() {
       selectionBoxStyle.strokeWidth = parseInt(this.value) || 2;
      });
      document.getElementById("selection-stroke-style").addEventListener("change", function() {
       selectionBoxStyle.strokeDasharray = this.value;
      });
      document.getElementById("input-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.inputBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-text-color").addEventListener("input", (e) => {
       PAGE_STATE.inputText = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-border-color").addEventListener("input", (e) => {
       PAGE_STATE.inputBorder = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-font-family").addEventListener("change", (e) => {
       PAGE_STATE.inputFont = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-font-size").addEventListener("input", (e) => {
       PAGE_STATE.inputFontSize = parseInt(e.target.value) || 14;
       wieldThePower();
      });
      document.getElementById("toolbar-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-border-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBorder = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-text-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarText = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-btn-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBtnBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-btn-text-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBtnText = e.target.value;
       wieldThePower();
      });
      document.getElementById("minimap-dots-color").addEventListener("input", (e) => {
       PAGE_STATE.minimapDots = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("canvas-hint-enabled").addEventListener("change", (e) => {
       PAGE_STATE.canvasHintEnabled = e.target.checked;
       wieldThePower();
      });
      document.getElementById("canvas-hint-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-hint-text-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintColor = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-hint-text").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintText = e.target.value;
       wieldThePower();
      });
      document.getElementById("accent-color").addEventListener("input", (e) => {
       PAGE_STATE.accent = e.target.value;
       wieldThePower();
      });
      document.getElementById("danger-color").addEventListener("input", (e) => {
       PAGE_STATE.danger = e.target.value;
       wieldThePower();
      });
      document.getElementById("text-main-color").addEventListener("input", (e) => {
       PAGE_STATE.textMain = e.target.value;
       wieldThePower();
      });
      document.getElementById("text-soft-color").addEventListener("input", (e) => {
       PAGE_STATE.textSoft = e.target.value;
       wieldThePower();
      });
      document.getElementById("node-fill-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeFill = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-stroke-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeStroke = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-title-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeTitle = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-sub-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeSub = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-title-size").addEventListener("input", (e) => {
       PAGE_STATE.nodeTitleSize = parseInt(e.target.value) || 18;
       forgeTheTopology();
      });
      document.getElementById("node-sub-size").addEventListener("input", (e) => {
       PAGE_STATE.nodeSubSize = parseInt(e.target.value) || 13;
       forgeTheTopology();
      });
      document.getElementById("node-font-family").addEventListener("change", (e) => {
       PAGE_STATE.nodeFont = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("default-edge-color").addEventListener("input", (e) => {
       PAGE_STATE.defaultEdge = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("selection-handle-color").addEventListener("input", (e) => {
       PAGE_STATE.selectionHandle = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("selection-handle-size").addEventListener("input", (e) => {
       PAGE_STATE.selectionHandleSize = parseInt(e.target.value) || 8;
       forgeTheTopology();
      });
      document.getElementById("group-indicator-color").addEventListener("input", (e) => {
       PAGE_STATE.groupIndicator = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-gradient-top").addEventListener("input", (e) => {
       PAGE_STATE.canvasGradientTop = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-gradient-bottom").addEventListener("input", (e) => {
       PAGE_STATE.canvasGradientBottom = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-border-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasBorder = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-grid-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasGrid = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-grid-size").addEventListener("input", (e) => {
       PAGE_STATE.canvasGridSize = parseInt(e.target.value) || 50;
       forgeTheTopology();
      });
      document.getElementById("rack-frame-fill").addEventListener("input", (e) => {
       PAGE_STATE.rackFrameFill = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-frame-stroke").addEventListener("input", (e) => {
       PAGE_STATE.rackFrameStroke = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-line-color").addEventListener("input", (e) => {
       PAGE_STATE.rackLineColor = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-text-color").addEventListener("input", (e) => {
       PAGE_STATE.rackTextColor = e.target.value;
       forgeTheTopology();
      });
      
      (function initializeResizers() {
        const headerResizer = document.getElementById('header-resizer');
        const sidebarResizer = document.getElementById('sidebar-resizer');
        const mobileFooterResizer = document.getElementById('mobile-footer-resizer');
        
        let isResizing = false;
        let currentResizer = null;
        let startY = 0;
        let startX = 0;
        let startHeight = 0;
        let startWidth = 0;
        
        function getClientPos(e) {
          if (e.touches && e.touches.length > 0) {
            return { x: e.touches[0].clientX, y: e.touches[0].clientY };
          }
          return { x: e.clientX, y: e.clientY };
        }
        
        function startResize(resizer, type, e) {
          isResizing = true;
          currentResizer = type;
          const pos = getClientPos(e);
          
          if (type === 'header') {
            startY = pos.y;
            startHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--topbar-height'));
          } else if (type === 'sidebar') {
            startX = pos.x;
            startWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width'));
          } else if (type === 'mobile-footer') {
            startY = pos.y;
            const currentVh = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--mobile-footer-height'));
            startHeight = (currentVh / 100) * window.innerHeight;
          }
          
          resizer.classList.add('resizing');
          document.body.classList.add('resizing');
          document.body.style.cursor = (type === 'sidebar') ? 'col-resize' : 'row-resize';
          e.preventDefault();
        }
        
        if (headerResizer) {
          headerResizer.addEventListener('mousedown', (e) => startResize(headerResizer, 'header', e));
          headerResizer.addEventListener('touchstart', (e) => startResize(headerResizer, 'header', e), { passive: false });
        }
        
        if (sidebarResizer) {
          sidebarResizer.addEventListener('mousedown', (e) => startResize(sidebarResizer, 'sidebar', e));
          sidebarResizer.addEventListener('touchstart', (e) => startResize(sidebarResizer, 'sidebar', e), { passive: false });
        }
        
        if (mobileFooterResizer) {
          mobileFooterResizer.addEventListener('mousedown', (e) => startResize(mobileFooterResizer, 'mobile-footer', e));
          mobileFooterResizer.addEventListener('touchstart', (e) => startResize(mobileFooterResizer, 'mobile-footer', e), { passive: false });
        }
        
        function handleMove(e) {
          if (!isResizing) return;
          
          const pos = getClientPos(e);
          
          if (currentResizer === 'header') {
            const deltaY = pos.y - startY;
            const newHeight = Math.max(40, Math.min(150, startHeight + deltaY));
            document.documentElement.style.setProperty('--topbar-height', newHeight + 'px');
          } else if (currentResizer === 'sidebar') {
            const deltaX = startX - pos.x;
            const newWidth = Math.max(200, Math.min(800, startWidth + deltaX));
            document.documentElement.style.setProperty('--sidebar-width', newWidth + 'px');
          } else if (currentResizer === 'mobile-footer') {
            const deltaY = startY - pos.y;
            const newHeight = startHeight + deltaY;
            const newVh = Math.max(15, Math.min(80, (newHeight / window.innerHeight) * 100));
            document.documentElement.style.setProperty('--mobile-footer-height', newVh + 'vh');
          }
          
          e.preventDefault();
        }
        
        document.addEventListener('mousemove', handleMove);
        document.addEventListener('touchmove', handleMove, { passive: false });
        
        function handleEnd() {
          if (isResizing) {
            isResizing = false;
            
            if (currentResizer === 'header') {
              PAGE_STATE.topbarHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--topbar-height'));
              headerResizer.classList.remove('resizing');
            } else if (currentResizer === 'sidebar') {
              PAGE_STATE.sidebarWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width'));
              sidebarResizer.classList.remove('resizing');
            } else if (currentResizer === 'mobile-footer') {
              PAGE_STATE.mobileFooterHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--mobile-footer-height'));
              mobileFooterResizer.classList.remove('resizing');
            }
            
            document.body.classList.remove('resizing');
            document.body.style.cursor = '';
            currentResizer = null;
          }
        }
        
        document.addEventListener('mouseup', handleEnd);
        document.addEventListener('touchend', handleEnd);
        document.addEventListener('touchcancel', handleEnd);
      })();
      
      document.getElementById("export-data-btn").addEventListener("click", () => {
       const data = captureTheQuickening();
       const jsonStr = JSON.stringify(data, null, 2);
       const blob = new Blob([jsonStr], {
        type: "application/json"
       });
       const url = URL.createObjectURL(blob);
       const a = document.createElement("a");
       a.href = url;
       const safeTitle = (PAGE_STATE.title || "network-topology").toLowerCase().replace(/[^a-z0-9\-]+/g, "-");
       const timestamp = new Date().toISOString().split("T")[0];
       a.download = `${safeTitle}-data-${timestamp}.json`;
       document.body.appendChild(a);
       a.click();
       document.body.removeChild(a);
       URL.revokeObjectURL(url);
       logAuditEvent("export", `Exported JSON: ${a.download}`);
      });
      document.getElementById("import-data-btn").addEventListener("click", () => {
       document.getElementById("import-data-file").click();
      });
      document.getElementById("import-data-file").addEventListener("change", async (e) => {
       const file = e.target.files[0];
       if (!file) return;
       try {
        const text = await file.text();
        const data = JSON.parse(text);
        if (!data.nodeData || !data.edgeData) {
         alert("Invalid data file. Missing required fields.");
         return;
        }
        const confirmMsg = `This will replace all current data with the imported data.\n\nImporting:\n- ${Object.keys(data.nodeData).length} nodes\n- ${data.edgeData.list?.length || 0} connections\n- ${data.documentTabs?.length || 1} tab(s)\n\nContinue?`;
        if (!confirm(confirmMsg)) {
         e.target.value = "";
         return;
        }
        NODE_DATA = data.nodeData || {};
        EDGE_DATA = data.edgeData || {
         list: []
        };
        EDGE_LEGEND = data.edgeLegend || {};
        RECT_DATA = data.rectData || { list: [] };
        TEXT_DATA = data.textData || { list: [] };
        savedPositions = data.nodePositions || {};
        savedSizes = data.nodeSizes || {};
        savedStyles = data.nodeStyles || {};
        if (data.page) {
         PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, data.page, );
         wieldThePower();
        }
        if (data.canvas) {
         canvasState.zoom = data.canvas.zoom || 1;
         canvasState.panX = data.canvas.panX || 0;
         canvasState.panY = data.canvas.panY || 0;
        }
        if (data.page?.title) {
         document.title = data.page.title;
         document.querySelector(".editable-page-title", ).textContent = data.page.title;
        }
        if (data.documentTabs) {
         documentTabs = data.documentTabs;
         currentTabIndex = data.currentTabIndex || 0;
        }
        if (data.savedTopologyView) {
         savedTopologyView = data.savedTopologyView;
        }
        if (data.encryptedSections) {
         encryptedSections = data.encryptedSections;
        }
        if (data.auditLog && Array.isArray(data.auditLog)) {
         auditLog = data.auditLog;
         try {
           localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
         } catch (e) {
           console.warn("Failed to sync audit log to localStorage:", e);
         }
        }
        forgeTheTopology();
        forgeTheLegend();
		logAuditEvent("import", `Imported JSON: ${file.name} (${Object.keys(data.nodeData).length} nodes, ${data.edgeData.list?.length || 0} connections)`);
        updateViewBox();
        const nodeIds = Object.keys(NODE_DATA);
        if (nodeIds.length > 0) {
         claimTheImmortal(nodeIds[0]);
        } else {
         document.getElementById("node-panel").style.display = "none";
         document.getElementById("edge-panel").style.display = "none";
         document.getElementById("topology-toolbar").style.display = "none";
        }
        e.target.value = "";
       } catch (err) {
        console.error("Import error:", err);
        alert(`Failed to import data: ${err.message}`);
        e.target.value = "";
       }
      });
      const saveHelpBtn = document.getElementById("save-help-btn");
      const saveInfoModal = document.getElementById("save-info-modal");
      const saveInfoClose = document.getElementById("save-info-close");
      saveHelpBtn.addEventListener("click", () => {
       saveInfoModal.classList.add("active");
      });
      saveInfoClose.addEventListener("click", () => {
       saveInfoModal.classList.remove("active");
      });
      saveInfoModal.addEventListener("click", (e) => {
       if (e.target === saveInfoModal) {
        saveInfoModal.classList.remove("active");
       }
      });
      document.querySelectorAll(".help-tab").forEach(tab => {
        tab.addEventListener("click", () => {
          document.querySelectorAll(".help-tab").forEach(t => { t.style.background = "var(--panel)"; t.style.color = "var(--text-main)"; });
          tab.style.background = "var(--accent)"; tab.style.color = "var(--bg)";
          document.querySelectorAll(".help-tab-content").forEach(c => c.style.display = "none");
          document.getElementById("help-tab-" + tab.dataset.tab).style.display = "block";
        });
      });
      async function deriveKey(password, salt) {
      const encoder = new TextEncoder();
      
      const keyMaterial = await crypto.subtle.importKey(
      "raw",
      encoder.encode(password),
      "PBKDF2",
      false,
      ["deriveKey"]
      );
      
      return crypto.subtle.deriveKey(
      {
      name: "PBKDF2",
      salt: salt,
      iterations: 200000,
      hash: "SHA-256"
      },
      keyMaterial,
      {
      name: "AES-GCM",
      length: 256
      },
      false,
      ["encrypt", "decrypt"]
      );
      }
      
      async function encryptData(data, password) {
      const encoder = new TextEncoder();
      const salt = crypto.getRandomValues(new Uint8Array(16));
      const iv   = crypto.getRandomValues(new Uint8Array(12));
      
      const key = await deriveKey(password, salt);
      const encrypted = await crypto.subtle.encrypt(
      { name: "AES-GCM", iv },
      key,
      encoder.encode(data)
      );
      
      const encryptedU8 = new Uint8Array(encrypted);
      
      const result = new Uint8Array(salt.length + iv.length + encryptedU8.length);
      result.set(salt, 0);
      result.set(iv, salt.length);
      result.set(encryptedU8, salt.length + iv.length);
      
      return "ENCRYPTED:" + u8ToBase64(result);
      }
      
      async function decryptData(encryptedData, password) {
      const base64Data = encryptedData.replace("ENCRYPTED:", "");
      const fullData   = base64ToU8(base64Data);
      
      const salt      = fullData.slice(0, 16);
      const iv        = fullData.slice(16, 28);
      const encrypted = fullData.slice(28);
      
      const key = await deriveKey(password, salt);
      
      const decrypted = await crypto.subtle.decrypt(
      { name: "AES-GCM", iv },
      key,
      encrypted
      );
      
      const decoder = new TextDecoder();
      return decoder.decode(decrypted);
      }
      
      
      function isEncrypted(data) {
       return typeof data === "string" && data.startsWith("ENCRYPTED:");
      }
      
      function captureTheQuickening() {
       const currentTab = documentTabs[currentTabIndex];
       currentTab.nodes = JSON.parse(JSON.stringify(NODE_DATA));
       currentTab.edges = JSON.parse(JSON.stringify(EDGE_DATA));
       currentTab.positions = JSON.parse(JSON.stringify(savedPositions));
       currentTab.sizes = JSON.parse(JSON.stringify(savedSizes));
       currentTab.styles = JSON.parse(JSON.stringify(savedStyles));
       currentTab.legend = JSON.parse(JSON.stringify(EDGE_LEGEND));
       currentTab.rects = JSON.parse(JSON.stringify(RECT_DATA));
       currentTab.texts = JSON.parse(JSON.stringify(TEXT_DATA));
       currentTab.pageState = JSON.parse(JSON.stringify(PAGE_STATE));
       
       return {
        nodeData: NODE_DATA,
        edgeData: EDGE_DATA,
        rectData: RECT_DATA,
        textData: TEXT_DATA,
        edgeLegend: EDGE_LEGEND,
        nodePositions: savedPositions,
        nodeSizes: savedSizes,
        nodeStyles: savedStyles,
        page: PAGE_STATE,
        canvas: {
         zoom: canvasState.zoom,
         panX: canvasState.panX,
         panY: canvasState.panY,
        },
        savedTopologyView: savedTopologyView,
        documentTabs: documentTabs,
        currentTabIndex: currentTabIndex,
        encryptedSections: encryptedSections,
        auditLog: auditLog,
       };
      }
      
      function assembleTheImmortalForm() {
      const canvasHintEl = document.getElementById("canvas-hint");
       const savedHintHTML = canvasHintEl ? canvasHintEl.innerHTML : "";
       if (canvasHintEl) canvasHintEl.innerHTML = DEFAULT_CANVAS_HINT;
       const clone = document.documentElement.cloneNode(true);
       ["edge-legend-mini", "minimap-mini", "draw-toolbar-mini", "topology-toolbar-mini"].forEach(id => {
        const all = clone.querySelectorAll("#" + id);
        for (let i = 1; i < all.length; i++) {
         all[i].remove();
        }
       });
       const nodeScript = clone.querySelector("#nodes-json");
       if (nodeScript) {
        nodeScript.textContent = JSON.stringify(NODE_DATA, null, 2);
       }
       let stateScript = clone.querySelector("#topology-state");
       if (!stateScript) {
        stateScript = document.createElement("script");
        stateScript.id = "topology-state";
        stateScript.type = "application/json";
        const body = clone.querySelector("body") || clone;
        body.appendChild(stateScript);
       }
       stateScript.textContent = JSON.stringify(captureTheQuickening(), null, 2, );
       return "<!DOCTYPE html> \n " + clone.outerHTML;
      }
      async function becomeImmortal() {
       saveRollbackVersion("Auto-save");
       
       const encryptEnabled = document.getElementById("encrypt-toggle").checked;
       let stateData = JSON.stringify(captureTheQuickening(), null, 2);
       if (encryptEnabled) {
        const password = prompt("Enter a password to encrypt your data:\n(Remember this password! You will need it to open this file and its non recoverable!)", );
        if (!password) {
         alert("Encryption cancelled. File not saved.");
         return;
        }
        const confirmPassword = prompt("Confirm your password:");
        if (password !== confirmPassword) {
         alert("Passwords do not match. File not saved.");
         return;
        }
        try {
         stateData = await encryptData(stateData, password);
        } catch (e) {
         alert("Encryption failed: " + e.message);
         return;
        }
       }
       const canvasHintEl = document.getElementById("canvas-hint");
       const savedHintHTML = canvasHintEl ? canvasHintEl.innerHTML : "";
       if (canvasHintEl) canvasHintEl.innerHTML = DEFAULT_CANVAS_HINT;    
       const clone = document.documentElement.cloneNode(true);
       ["edge-legend-mini", "minimap-mini", "draw-toolbar-mini", "topology-toolbar-mini"].forEach(id => {
        const all = clone.querySelectorAll("#" + id);
        for (let i = 1; i < all.length; i++) {
         all[i].remove();
        }
       });
       
       const nodeScript = clone.querySelector("#nodes-json");
       if (nodeScript) {
        if (encryptEnabled) {
         nodeScript.textContent = JSON.stringify({}, null, 2);
        } else {
         nodeScript.textContent = JSON.stringify(NODE_DATA, null, 2);
        }
       }
       let stateScript = clone.querySelector("#topology-state");
       if (!stateScript) {
        stateScript = document.createElement("script");
        stateScript.id = "topology-state";
        stateScript.type = "application/json";
        const body = clone.querySelector("body") || clone;
        body.appendChild(stateScript);
       }
       stateScript.textContent = stateData;
       const html = "<!DOCTYPE html> \n " + clone.outerHTML;
       const blob = new Blob([html], {
        type: "text/html"
       });
       const url = URL.createObjectURL(blob);
       const a = document.createElement("a");
       a.href = url;
       const safeTitle = (PAGE_STATE.title || document.title || "network-topology").toLowerCase().replace(/[^a-z0-9\-]+/g, "-");
       a.download = safeTitle + ".html";
       document.body.appendChild(a);
       a.click();
       document.body.removeChild(a);
       URL.revokeObjectURL(url);
       if (canvasHintEl) canvasHintEl.innerHTML = savedHintHTML;
       logAuditEvent("save", `File saved: ${safeTitle}.html`);
      }
      
      function captureState() {
      return {
       nodes: JSON.parse(JSON.stringify(NODE_DATA)),
       edges: JSON.parse(JSON.stringify(EDGE_DATA)),
       positions: JSON.parse(JSON.stringify(savedPositions)),
       sizes: JSON.parse(JSON.stringify(savedSizes)),
       styles: JSON.parse(JSON.stringify(savedStyles)),
       legend: JSON.parse(JSON.stringify(EDGE_LEGEND)),
       rects: JSON.parse(JSON.stringify(RECT_DATA)),
       texts: JSON.parse(JSON.stringify(TEXT_DATA))
       };
      }
      
      function pushUndo(action = "") {
       const state = captureState();
       undoStack.push(state);
       if (undoStack.length > MAX_UNDO_STACK) {
        undoStack.shift();
       }
       redoStack = [];
       updateUndoButtons();
       
       if (action) {
        const actionTypeMap = {
  "create node": "node",
  "delete node": "node",
  "add node": "node",
  "edit": "node",
  "clone node": "node",
  "paste node": "node",
  "move nodes": "node",
  "nudge": "node",
  "align nodes": "node",
  "distribute nodes": "node",
  "snap to grid": "node",
  "toggle group": "node",
  "toggle lock": "node",
  "create rack": "rack",
  "add rack": "rack",
  "edit rack": "rack",
  "edit mac": "rack",
  "edit U height": "rack",
  "change rack capacity": "rack",
  "change assigned rack": "rack",
  "add connection": "connection",
  "delete connection": "connection",
  "delete edge": "connection",
  "clone edge": "connection",
  "paste edge": "connection",
  "style change": "style",
  "change layer": "layer",
  "add text": "text",
  "edit text": "text",
  "delete text": "text",
  "clone text": "text",
  "paste text": "text",
  "draw zone": "zone",
  "delete zone": "zone",
  "delete rect": "zone",
  "clone rect": "zone",
  "paste rect": "zone",
  "change zone line style": "zone",
  "delete selected": "bulk",
  "clone selected": "bulk",
};
        
        const type = actionTypeMap[action] || "node";
        logAuditEvent(type, action);
       }
      }
      
      function undo() {
       if (undoStack.length === 0) return;
       const currentState = captureState();
       redoStack.push(currentState);
       const previousState = undoStack.pop();
       restoreState(previousState);
       updateUndoButtons();
       logAuditEvent("undo", "Undo action performed");
      }
      
      function redo() {
       if (redoStack.length === 0) return;
       logAuditEvent("redo", "Redo action performed");
       const currentState = captureState();
       undoStack.push(currentState);
       const nextState = redoStack.pop();
       restoreState(nextState);
       updateUndoButtons();
      }
      
      function restoreState(state) {
      NODE_DATA = state.nodes;
      EDGE_DATA = state.edges;
      savedPositions = state.positions;
      savedSizes = state.sizes;
      savedStyles = state.styles;
      EDGE_LEGEND = state.legend;
      RECT_DATA = state.rects || { list: [] };
      TEXT_DATA = state.texts || { list: [] };
      forgeTheTopology();
      if (currentNodeId && NODE_DATA[currentNodeId]) {
       claimTheImmortal(currentNodeId);
      } else if (currentEdgeId) {
       selectTheConnection(currentEdgeId);
       }
      }
      
      function updateUndoButtons() {
       const undoBtn = document.getElementById("undo-btn");
       const redoBtn = document.getElementById("redo-btn");
       if (undoBtn) {
        undoBtn.disabled = undoStack.length === 0;
        undoBtn.style.opacity = undoStack.length === 0 ? "0.5" : "1";
       }
       if (redoBtn) {
        redoBtn.disabled = redoStack.length === 0;
        redoBtn.style.opacity = redoStack.length === 0 ? "0.5" : "1";
       }
      }
      
      function editNodeMac(id) {
       const currentMac = NODE_DATA[id].mac || "";
       showEditModal("Edit MAC Address", currentMac, (newMac) => {
        pushUndo("edit mac");
        NODE_DATA[id].mac = newMac;
        if (currentNodeId === id) {
         document.getElementById("node-mac").textContent = newMac || "--";
        }
       });
      }
      
      function editNodeRack(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       
       document.getElementById("modal-title").textContent = "Edit Rack Unit";
       document.getElementById("modal-input").value = node.rackUnit || "";
       document.getElementById("edit-modal").style.display = "flex";
       document.getElementById("modal-input").focus();
       
       const saveHandler = () => {
        pushUndo("edit rack");
        const value = document.getElementById("modal-input").value.trim();
        node.rackUnit = value;
        document.getElementById("edit-modal").style.display = "none";
        claimTheImmortal(id);
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       
       const cancelHandler = () => {
        document.getElementById("edit-modal").style.display = "none";
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       
       document.getElementById("edit-modal").addEventListener("click", function bgHandler(e) {
        if (e.target === document.getElementById("edit-modal")) {
         cancelHandler();
         document.getElementById("edit-modal").removeEventListener("click", bgHandler);
        }
       });
      }
      
      function editNodeUHeight(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       
       document.getElementById("modal-title").textContent = "Edit U Height";
       document.getElementById("modal-input").value = node.uHeight || "1";
       document.getElementById("edit-modal").style.display = "flex";
       document.getElementById("modal-input").focus();
       
       const saveHandler = () => {
        pushUndo("edit U height");
        const value = document.getElementById("modal-input").value.trim();
        node.uHeight = value;
        document.getElementById("edit-modal").style.display = "none";
        claimTheImmortal(id);
        forgeTheTopology();
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       
       const cancelHandler = () => {
        document.getElementById("edit-modal").style.display = "none";
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       
       document.getElementById("edit-modal").addEventListener("click", function bgHandler(e) {
        if (e.target === document.getElementById("edit-modal")) {
         cancelHandler();
         document.getElementById("edit-modal").removeEventListener("click", bgHandler);
        }
       });
      }
      
      function updateEdgePortLabels(edgeId) {
       const edge = EDGE_DATA.list.find(e => e.id === edgeId);
       if (!edge || edge.type === "custom") return;
       
       const fromPortInput = document.getElementById("edge-from-port");
       const toPortInput = document.getElementById("edge-to-port");
       
       if (fromPortInput && toPortInput) {
        edge.fromPort = fromPortInput.value || "";
        edge.toPort = toPortInput.value || "";
        
        forgeTheTopology();
       }
      }
      
      function clearSelection() {
       selectedNodes.clear();
       selectedEdges.clear();
       selectedRects.clear();
       selectedTexts.clear();
       updateAllSelections();
      }
      
      function updateAllSelections() {
      updateNodeSelection();
      
      document.querySelectorAll(".edge").forEach(el => {
      const edgeId = el.dataset.edgeId;
      if (selectedEdges.has(edgeId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      
      document.querySelectorAll(".rect-group").forEach(el => {
      const rectId = el.dataset.rectId;
      if (selectedRects.has(rectId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      
      document.querySelectorAll(".text-group").forEach(el => {
      const textId = el.dataset.textId;
      if (selectedTexts.has(textId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      
      const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
      const bulkToolbar = document.getElementById("bulk-toolbar");
      const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
      const bulkCount = document.getElementById("bulk-count");
      const bulkCountMobile = document.getElementById("bulk-count-mobile");
      
      if (total > 0) {
      if (bulkToolbar) bulkToolbar.style.display = "flex";
      if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
      if (bulkCount) bulkCount.textContent = total;
      if (bulkCountMobile) bulkCountMobile.textContent = total;
      } else {
      if (bulkToolbar) bulkToolbar.style.display = "none";
      if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
      }
      }
      
      function updateNodeSelection() {
       if (isViewOnly()) {
        selectedNodes.clear();
        selectedRects.clear();
        selectedTexts.clear();
        const bulkToolbar = document.getElementById("bulk-toolbar");
        const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        return;
       }
       document.querySelectorAll(".node-group").forEach(node => {
        const nodeId = node.dataset.nodeId;
        if (selectedNodes.has(nodeId)) {
         node.classList.add("selected");
        } else {
         node.classList.remove("selected");
        }
       });
       
       const bulkToolbar = document.getElementById("bulk-toolbar");
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       const bulkCount = document.getElementById("bulk-count");
       const bulkCountMobile = document.getElementById("bulk-count-mobile");
       const bulkCountModal = document.getElementById("bulk-count-modal");
       
       if (selectedNodes.size > 0) {
        if (bulkToolbar) bulkToolbar.style.display = "flex";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
        if (bulkCount) bulkCount.textContent = selectedNodes.size;
        if (bulkCountMobile) bulkCountMobile.textContent = selectedNodes.size;
        if (bulkCountModal) bulkCountModal.textContent = selectedNodes.size;
       } else {
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        const modal = document.getElementById("bulk-actions-modal");
        if (modal) modal.style.display = "none";
       }
      }
      
      function deleteSelected() {
       const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
       if (total === 0) return;
       
       let nodesInsideRacks = [];
       selectedNodes.forEach(nodeId => {
        if (NODE_DATA[nodeId]?.isRack) {
         Object.entries(NODE_DATA).forEach(([id, n]) => {
          if (n.assignedRack === nodeId) nodesInsideRacks.push(n.name || id);
         });
        }
       });
       
       let message = `Delete ${total} selected item(s)?`;
       if (nodesInsideRacks.length > 0) {
        message += `\n\nThis will also delete ${nodesInsideRacks.length} node(s) inside rack(s):\n• ${nodesInsideRacks.join('\n• ')}`;
       }
       
       challengeTheImmortal(message, () => {
        pushUndo("delete selected");
        selectedNodes.forEach(nodeId => {
         if (NODE_DATA[nodeId]?.isRack) {
          Object.keys(NODE_DATA).forEach(id => {
           if (NODE_DATA[id]?.assignedRack === nodeId) {
            EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== id && e.to !== id);
            delete NODE_DATA[id];
            delete savedPositions[id];
            delete savedSizes[id];
            delete savedStyles[id];
           }
          });
         }
         delete NODE_DATA[nodeId];
         delete savedPositions[nodeId];
         delete savedSizes[nodeId];
         delete savedStyles[nodeId];
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== nodeId && e.to !== nodeId);
        });
        selectedEdges.forEach(edgeId => {
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.id !== edgeId);
        });
        selectedRects.forEach(rectId => {
         RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== rectId);
        });
        selectedTexts.forEach(textId => {
         TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== textId);
        });
        clearSelection();
        
        forgeTheTopology();
       });
      }
      
      function startSelection(event) {
       if (event.button !== 0) return;
       if (event.target.closest(".node-group")) return;
       
       isSelecting = true;
       const svg = document.getElementById("map");
       const pt = svg.createSVGPoint();
       pt.x = event.clientX;
       pt.y = event.clientY;
       const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
       selectionStart = { x: svgP.x, y: svgP.y };
       
       if (!event.shiftKey) {
        clearSelection();
       }
       
       preDragSelectedNodes = new Set(selectedNodes);
       preDragSelectedEdges = new Set(selectedEdges);
       preDragSelectedRects = new Set(selectedRects);
       preDragSelectedTexts = new Set(selectedTexts);
       
       if (!selectionRect || !selectionRect.parentNode) {
        selectionRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        selectionRect.setAttribute("fill", selectionBoxStyle.fillColor);
        selectionRect.setAttribute("fill-opacity", selectionBoxStyle.fillOpacity);
        selectionRect.setAttribute("stroke", selectionBoxStyle.strokeColor);
        selectionRect.setAttribute("stroke-width", selectionBoxStyle.strokeWidth);
        selectionRect.setAttribute("stroke-dasharray", selectionBoxStyle.strokeDasharray);
        svg.appendChild(selectionRect);
       }
       selectionRect.style.display = "block";
      }
      
      function updateSelection(event) {
       if (!isSelecting || !selectionStart) return;
       
       const svg = document.getElementById("map");
       const pt = svg.createSVGPoint();
       pt.x = event.clientX;
       pt.y = event.clientY;
       const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
       
       const x = Math.min(selectionStart.x, svgP.x);
       const y = Math.min(selectionStart.y, svgP.y);
       const width = Math.abs(svgP.x - selectionStart.x);
       const height = Math.abs(svgP.y - selectionStart.y);
       
       selectionRect.setAttribute("x", x);
       selectionRect.setAttribute("y", y);
       selectionRect.setAttribute("width", width);
       selectionRect.setAttribute("height", height);
       
       const box = { x, y, width, height };
       
       Object.entries(savedPositions).forEach(([nodeId, pos]) => {
        const size = savedSizes[nodeId] || 50;
        const halfSize = size / 2;
        const nodeBox = { x: pos.x - halfSize, y: pos.y - halfSize, width: size, height: size };
        if (boxesIntersect(box, nodeBox)) {
         selectedNodes.add(nodeId);
        } else if (!preDragSelectedNodes.has(nodeId)) {
         selectedNodes.delete(nodeId);
        }
       });
       
      EDGE_DATA.list.forEach(edge => {
        if (!edge.points || edge.points.length === 0) return;
        for (let i = 0; i < edge.points.length - 1; i++) {
         const p1 = edge.points[i];
         const p2 = edge.points[i + 1];
         if (lineIntersectsBox(p1.x, p1.y, p2.x, p2.y, box)) {
          selectedEdges.add(edge.id);
          return;
         }
        }
        if (!preDragSelectedEdges.has(edge.id)) {
         selectedEdges.delete(edge.id);
        }
       });
       
       RECT_DATA.list.forEach(rect => {
        const rectBox = { x: rect.x, y: rect.y, width: rect.width, height: rect.height };
        if (boxesIntersect(box, rectBox)) {
         selectedRects.add(rect.id);
        } else if (!preDragSelectedRects.has(rect.id)) {
         selectedRects.delete(rect.id);
        }
       });
       
       TEXT_DATA.list.forEach(text => {
        const fontSize = text.fontSize || 18;
        const textBox = { x: text.x - 50, y: text.y - fontSize, width: 100, height: fontSize * 1.5 };
        if (boxesIntersect(box, textBox)) {
         selectedTexts.add(text.id);
        } else if (!preDragSelectedTexts.has(text.id)) {
         selectedTexts.delete(text.id);
        }
       });
       
       updateAllSelectionVisuals();
      }
      
      function endSelection() {
       isSelecting = false;
       if (selectionRect) {
        selectionRect.style.display = "none";
       }
      }
      
      function boxesIntersect(a, b) {
       return !(a.x + a.width < b.x || b.x + b.width < a.x || a.y + a.height < b.y || b.y + b.height < a.y);
      }
      
      function lineIntersectsBox(x1, y1, x2, y2, box) {
       if (pointInBox(x1, y1, box) || pointInBox(x2, y2, box)) return true;
       const lines = [
        [box.x, box.y, box.x + box.width, box.y],
        [box.x + box.width, box.y, box.x + box.width, box.y + box.height],
        [box.x + box.width, box.y + box.height, box.x, box.y + box.height],
        [box.x, box.y + box.height, box.x, box.y]
       ];
       for (const [bx1, by1, bx2, by2] of lines) {
        if (linesIntersect(x1, y1, x2, y2, bx1, by1, bx2, by2)) return true;
       }
       return false;
      }
      
      function pointInBox(x, y, box) {
       return x >= box.x && x <= box.x + box.width && y >= box.y && y <= box.y + box.height;
      }
      
      function linesIntersect(x1, y1, x2, y2, x3, y3, x4, y4) {
       const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
       if (Math.abs(denom) < 0.0001) return false;
       const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom;
       const ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denom;
       return ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1;
      }
      
      function updateAllSelectionVisuals() {
       document.querySelectorAll(".node-group").forEach(node => {
        const nodeId = node.dataset.nodeId;
        if (selectedNodes.has(nodeId)) {
         node.classList.add("selected");
        } else {
         node.classList.remove("selected");
        }
       });
       
       document.querySelectorAll(".edge").forEach(edge => {
        const edgeId = edge.dataset.edgeId;
        if (selectedEdges.has(edgeId)) {
         edge.style.filter = "drop-shadow(0 0 6px #4fd1c5)";
        } else {
         edge.style.filter = "";
        }
       });
       
       document.querySelectorAll(".rect-group rect").forEach(el => {
        const rectId = el.closest(".rect-group")?.dataset?.rectId;
        if (selectedRects.has(rectId)) {
         el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
        } else {
         el.style.filter = "";
        }
       });
       
       document.querySelectorAll(".text-group, .text-element").forEach(el => {
        const textId = el.dataset?.textId;
        if (selectedTexts.has(textId)) {
         el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
        } else {
         el.style.filter = "";
        }
       });
       
       const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
       const bulkToolbar = document.getElementById("bulk-toolbar");
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       const bulkCount = document.getElementById("bulk-count");
       const bulkCountMobile = document.getElementById("bulk-count-mobile");
       
       if (total > 0) {
        if (bulkToolbar) bulkToolbar.style.display = "flex";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
        if (bulkCount) bulkCount.textContent = total;
        if (bulkCountMobile) bulkCountMobile.textContent = total;
       } else {
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
       }
      }
      
      function cloneNode(sourceId) {
       if (!NODE_DATA[sourceId]) return;
       
       pushUndo("clone node");
       const source = NODE_DATA[sourceId];
       const baseName = source.name + " copy";
       let newName = baseName;
       let counter = 1;
       while (Object.values(NODE_DATA).some(n => n.name === newName)) {
        newName = `${baseName} ${counter}`;
        counter++;
       }
       
       const baseId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
       let newId = baseId;
       counter = 1;
       while (NODE_DATA[newId]) {
        newId = `${baseId}-${counter}`;
        counter++;
       }
       
       NODE_DATA[newId] = {
        shape: source.shape,
        name: newName,
        ip: source.ip,
        role: source.role,
        tags: [...source.tags],
        notes: [...source.notes],
        mac: source.mac || "",
        rackUnit: source.rackUnit || "",
        uHeight: source.uHeight || "1",
        layer: source.layer || "physical",
        assignedRack: source.assignedRack || "",
        rackCapacity: source.rackCapacity || "42",
        isRack: source.isRack || false
       }; 
	   
       if (source.isRack) {
        const childNodes = Object.entries(NODE_DATA).filter(([id, n]) => 
         id !== newId && n.assignedRack === sourceId
        );
        childNodes.forEach(([childId, childNode]) => {
         const childBaseName = childNode.name + " copy";
         let childNewName = childBaseName;
         let c = 1;
         while (Object.values(NODE_DATA).some(n => n.name === childNewName)) {
          childNewName = `${childBaseName} ${c}`;
          c++;
         }
         const childBaseId = childNewName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
         let childNewId = childBaseId;
         c = 1;
         while (NODE_DATA[childNewId]) {
          childNewId = `${childBaseId}-${c}`;
          c++;
         }
         NODE_DATA[childNewId] = {
          ...JSON.parse(JSON.stringify(childNode)),
          name: childNewName,
          assignedRack: newId
         };
         if (savedPositions[childId]) {
          savedPositions[childNewId] = { ...savedPositions[childId] };
         }
         if (savedSizes[childId]) {
          savedSizes[childNewId] = savedSizes[childId];
         }
         if (savedStyles[childId]) {
          savedStyles[childNewId] = JSON.parse(JSON.stringify(savedStyles[childId]));
         }
        });
       }
       
       if (currentView.mode === "rack" && currentView.rackId) {
        NODE_DATA[newId].assignedRack = currentView.rackId;
       }
       
       const sourcePos = savedPositions[sourceId];
       savedPositions[newId] = {
        x: sourcePos.x + 100,
        y: sourcePos.y + 100
       };
       
       if (savedSizes[sourceId]) {
        savedSizes[newId] = savedSizes[sourceId];
       }
       
       if (savedStyles[sourceId]) {
        savedStyles[newId] = JSON.parse(JSON.stringify(savedStyles[sourceId]));
       }
       
       forgeTheTopology();
       claimTheImmortal(newId);
      }
      
      function alignSelectedNodes(direction) {
       if (selectedNodes.size < 2) return;
       
       pushUndo("align nodes");
       const nodes = Array.from(selectedNodes).map(id => ({
        id,
        pos: savedPositions[id]
       }));
       
       switch(direction) {
        case "left":
         const minX = Math.min(...nodes.map(n => n.pos.x));
         nodes.forEach(n => savedPositions[n.id].x = minX);
         break;
        case "right":
         const maxX = Math.max(...nodes.map(n => n.pos.x));
         nodes.forEach(n => savedPositions[n.id].x = maxX);
         break;
        case "top":
         const minY = Math.min(...nodes.map(n => n.pos.y));
         nodes.forEach(n => savedPositions[n.id].y = minY);
         break;
        case "bottom":
         const maxY = Math.max(...nodes.map(n => n.pos.y));
         nodes.forEach(n => savedPositions[n.id].y = maxY);
         break;
        case "center-h":
         const avgX = nodes.reduce((sum, n) => sum + n.pos.x, 0) / nodes.length;
         nodes.forEach(n => savedPositions[n.id].x = avgX);
         break;
        case "center-v":
         const avgY = nodes.reduce((sum, n) => sum + n.pos.y, 0) / nodes.length;
         nodes.forEach(n => savedPositions[n.id].y = avgY);
         break;
       }
       
       forgeTheTopology();
      }
      
      function distributeSelectedNodes(direction) {
       if (selectedNodes.size < 3) return;
       
       pushUndo("distribute nodes");
       const nodes = Array.from(selectedNodes).map(id => ({
        id,
        pos: savedPositions[id]
       }));
       
       if (direction === "horizontal") {
        nodes.sort((a, b) => a.pos.x - b.pos.x);
        const minX = nodes[0].pos.x;
        const maxX = nodes[nodes.length - 1].pos.x;
        const gap = (maxX - minX) / (nodes.length - 1);
        nodes.forEach((n, i) => {
         savedPositions[n.id].x = minX + (gap * i);
        });
       } else {
        nodes.sort((a, b) => a.pos.y - b.pos.y);
        const minY = nodes[0].pos.y;
        const maxY = nodes[nodes.length - 1].pos.y;
        const gap = (maxY - minY) / (nodes.length - 1);
        nodes.forEach((n, i) => {
         savedPositions[n.id].y = minY + (gap * i);
        });
       }
       
       forgeTheTopology();
      }
      
      function snapToGrid(nodeId, gridSize = 50) {
       if (!savedPositions[nodeId]) return;
       
       pushUndo("snap to grid");
       const pos = savedPositions[nodeId];
       pos.x = Math.round(pos.x / gridSize) * gridSize;
       pos.y = Math.round(pos.y / gridSize) * gridSize;
       forgeTheTopology();
      }
      
      function searchNodes(query) {
       if (!query) {
        clearSearchHighlight();
        return [];
       }
       
       query = query.toLowerCase();
       const results = [];
       
       Object.entries(NODE_DATA).forEach(([id, data]) => {
        if (data.name.toLowerCase().includes(query) ||
            data.ip.toLowerCase().includes(query) ||
            data.role.toLowerCase().includes(query) ||
            data.tags.some(tag => tag.toLowerCase().includes(query)) ||
            (data.mac && data.mac.toLowerCase().includes(query)) ||
            (data.rackUnit && data.rackUnit.toLowerCase().includes(query))) {
         results.push(id);
        }
       });
       
       highlightSearchResults(results);
       return results;
      }
      
      function highlightSearchResults(nodeIds) {
       document.querySelectorAll(".node-group").forEach(node => {
        const nodeId = node.dataset.nodeId;
        if (nodeIds.includes(nodeId)) {
         node.classList.add("search-highlight");
        } else {
         node.classList.remove("search-highlight");
        }
       });
      }
      
      function clearSearchHighlight() {
       document.querySelectorAll(".search-highlight").forEach(node => {
        node.classList.remove("search-highlight");
       });
      }
      
      function nudgeSelectedNodes(direction, distance) {
        const nodesToNudge = selectedNodes.size > 0 
          ? Array.from(selectedNodes) 
          : (currentNodeId ? [currentNodeId] : []);
        const rectsToNudge = selectedRects.size > 0 
          ? Array.from(selectedRects) 
          : (currentRectId ? [currentRectId] : []);
        const textsToNudge = selectedTexts.size > 0 
          ? Array.from(selectedTexts) 
          : (currentTextId ? [currentTextId] : []);
        
        if (nodesToNudge.length === 0 && rectsToNudge.length === 0 && textsToNudge.length === 0) return;
        
        const unlockedNodes = nodesToNudge.filter(id => !NODE_DATA[id]?.locked);
        const unlockedRects = rectsToNudge.filter(id => { const r = RECT_DATA.list.find(x => x.id === id); return r && !r.locked; });
        const unlockedTexts = textsToNudge.filter(id => { const t = TEXT_DATA.list.find(x => x.id === id); return t && !t.locked; });
        
        if (unlockedNodes.length === 0 && unlockedRects.length === 0 && unlockedTexts.length === 0) return;
        
        pushUndo("nudge");
        
        const dx = direction === "ArrowLeft" ? -distance : direction === "ArrowRight" ? distance : 0;
        const dy = direction === "ArrowUp" ? -distance : direction === "ArrowDown" ? distance : 0;
        
        unlockedNodes.forEach(id => {
          if (!savedPositions[id]) savedPositions[id] = { x: 0, y: 0 };
          savedPositions[id].x += dx;
          savedPositions[id].y += dy;
        });
        
        unlockedRects.forEach(id => {
          const r = RECT_DATA.list.find(x => x.id === id);
          if (r) { r.x += dx; r.y += dy; }
        });
        
        unlockedTexts.forEach(id => {
          const t = TEXT_DATA.list.find(x => x.id === id);
          if (t) { t.x += dx; t.y += dy; }
        });
        
        forgeTheTopology();
      }
      
      function cycleNodes(reverse = false) {
        const nodeIds = Object.keys(NODE_DATA).filter(id => {
          if (currentView.mode === "rack" && currentView.rackId) {
            return NODE_DATA[id].assignedRack === currentView.rackId;
          }
          return !NODE_DATA[id].assignedRack;
        });
        
        if (nodeIds.length === 0) return;
        
        let currentIndex = nodeIds.indexOf(currentNodeId);
        
        if (reverse) {
          currentIndex = currentIndex <= 0 ? nodeIds.length - 1 : currentIndex - 1;
        } else {
          currentIndex = currentIndex >= nodeIds.length - 1 ? 0 : currentIndex + 1;
        }
        
        const nextNodeId = nodeIds[currentIndex];
        claimTheImmortal(nextNodeId);
        
        selectedNodes.clear();
        updateNodeSelection();
      }
      
      function focusOnSelected() {
        let minX = Infinity, minY = Infinity;
        let maxX = -Infinity, maxY = -Infinity;
        let hasItems = false;

        const nodesToFocus = selectedNodes.size > 0 
          ? Array.from(selectedNodes) 
          : (currentNodeId ? [currentNodeId] : []);
        nodesToFocus.forEach(id => {
          const pos = savedPositions[id];
          if (pos) {
            hasItems = true;
            const size = savedSizes[id] || 50;
            minX = Math.min(minX, pos.x - size/2);
            minY = Math.min(minY, pos.y - size/2);
            maxX = Math.max(maxX, pos.x + size/2);
            maxY = Math.max(maxY, pos.y + size/2);
          }
        });
        
        const rectsToFocus = selectedRects.size > 0 ? Array.from(selectedRects) : (currentRectId ? [currentRectId] : []);
        rectsToFocus.forEach(id => {
          const r = RECT_DATA.list.find(x => x.id === id);
          if (r) {
            hasItems = true;
            minX = Math.min(minX, r.x);
            minY = Math.min(minY, r.y);
            maxX = Math.max(maxX, r.x + r.width);
            maxY = Math.max(maxY, r.y + r.height);
          }
        });
        
        const textsToFocus = selectedTexts.size > 0 ? Array.from(selectedTexts) : (currentTextId ? [currentTextId] : []);
        textsToFocus.forEach(id => {
          const t = TEXT_DATA.list.find(x => x.id === id);
          if (t) {
            hasItems = true;
            minX = Math.min(minX, t.x - 50);
            minY = Math.min(minY, t.y - 20);
            maxX = Math.max(maxX, t.x + 50);
            maxY = Math.max(maxY, t.y + 20);
          }
        });
        
        const edgesToFocus = selectedEdges.size > 0 ? Array.from(selectedEdges) : (currentEdgeId ? [currentEdgeId] : []);
        edgesToFocus.forEach(id => {
          const e = EDGE_DATA.list.find(x => x.id === id);
          if (e) {
            const fromPos = savedPositions[e.from];
            const toPos = savedPositions[e.to];
            if (fromPos && toPos) {
              hasItems = true;
              minX = Math.min(minX, fromPos.x, toPos.x);
              minY = Math.min(minY, fromPos.y, toPos.y);
              maxX = Math.max(maxX, fromPos.x, toPos.x);
              maxY = Math.max(maxY, fromPos.y, toPos.y);
            }
          }
        });
        
        if (!hasItems || !isFinite(minX)) return;
        
        const padding = 100;
        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;
        const width = maxX - minX + padding * 2;
        const height = maxY - minY + padding * 2;
        
        const zoomX = CANVAS_WIDTH / width;
        const zoomY = CANVAS_HEIGHT / height;
        const targetZoom = Math.min(zoomX, zoomY, 2); 
        
        canvasState.zoom = targetZoom;
        canvasState.panX = centerX - (CANVAS_WIDTH / targetZoom) / 2;
        canvasState.panY = centerY - (CANVAS_HEIGHT / targetZoom) / 2;
        
        forgeTheTopology();
      }
      
      function toggleLockSelected() {
        const nodesToToggle = selectedNodes.size > 0 
          ? Array.from(selectedNodes) 
          : (currentNodeId ? [currentNodeId] : []);
        const rectsToToggle = selectedRects.size > 0 
          ? Array.from(selectedRects) 
          : (currentRectId ? [currentRectId] : []);
        const textsToToggle = selectedTexts.size > 0 
          ? Array.from(selectedTexts) 
          : (currentTextId ? [currentTextId] : []);
        
        if (nodesToToggle.length === 0 && rectsToToggle.length === 0 && textsToToggle.length === 0) return;
        
        pushUndo("toggle lock");
        
        let hasUnlocked = nodesToToggle.some(id => !NODE_DATA[id]?.locked);
        hasUnlocked = hasUnlocked || rectsToToggle.some(id => { const r = RECT_DATA.list.find(x => x.id === id); return r && !r.locked; });
        hasUnlocked = hasUnlocked || textsToToggle.some(id => { const t = TEXT_DATA.list.find(x => x.id === id); return t && !t.locked; });
        
        nodesToToggle.forEach(id => {
          if (NODE_DATA[id]) NODE_DATA[id].locked = hasUnlocked;
        });
        rectsToToggle.forEach(id => {
          const r = RECT_DATA.list.find(x => x.id === id);
          if (r) r.locked = hasUnlocked;
        });
        textsToToggle.forEach(id => {
          const t = TEXT_DATA.list.find(x => x.id === id);
          if (t) t.locked = hasUnlocked;
        });
        
        forgeTheTopology();
      }
      
      function toggleGroupSelected() {
      const nodesToGroup = Array.from(selectedNodes);
      const rectsToGroup = Array.from(selectedRects);
      const textsToGroup = Array.from(selectedTexts);
      const edgesToGroup = Array.from(selectedEdges);
      const totalItems = nodesToGroup.length + rectsToGroup.length + textsToGroup.length + edgesToGroup.length;
      if (totalItems < 2) return;
      
      pushUndo("toggle group");
      
      const allGroupIds = [];
      nodesToGroup.forEach(id => { if (NODE_DATA[id]?.groupId) allGroupIds.push(NODE_DATA[id].groupId); });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r?.groupId) allGroupIds.push(r.groupId); });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t?.groupId) allGroupIds.push(t.groupId); });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e?.groupId) allGroupIds.push(e.groupId); });
      const uniqueGroups = [...new Set(allGroupIds)];
      
      if (uniqueGroups.length === 1 && allGroupIds.length === totalItems) {
      nodesToGroup.forEach(id => { if (NODE_DATA[id]) NODE_DATA[id].groupId = null; });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r) r.groupId = null; });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t) t.groupId = null; });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e) e.groupId = null; });
      } else {
      const newGroupId = "group-" + Date.now();
      nodesToGroup.forEach(id => { if (NODE_DATA[id]) NODE_DATA[id].groupId = newGroupId; });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r) r.groupId = newGroupId; });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t) t.groupId = newGroupId; });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e) e.groupId = newGroupId; });
      }
      
      forgeTheTopology();
      }
      
      function handleKeyDown(event) {
       if (event.target.tagName === "INPUT" || event.target.tagName === "TEXTAREA" || event.target.isContentEditable) {
        return;
       }
       
       if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(event.key)) {
        event.preventDefault();
        const distance = event.shiftKey ? 10 : 1;
        nudgeSelectedNodes(event.key, distance);
       }
       
       if (event.key === "Tab") {
        event.preventDefault();
        cycleNodes(event.shiftKey);
       }
       
       if (event.key === "f" || event.key === "F") {
        event.preventDefault();
        focusOnSelected();
       }
       
       if (event.key === "l" || event.key === "L") {
        event.preventDefault();
        toggleLockSelected();
       }
       
       if (event.key === "g" || event.key === "G") {
        event.preventDefault();
        toggleGroupSelected();
       }
       
       if (event.ctrlKey && event.key === "z") {
        event.preventDefault();
        undo();
       }
       
       if ((event.ctrlKey && event.key === "y") || (event.ctrlKey && event.shiftKey && event.key === "z")) {
        event.preventDefault();
        redo();
       }
       
 if (event.ctrlKey && event.key === "c") {
        event.preventDefault();
        clipboard = null;
        if (currentNodeId && NODE_DATA[currentNodeId]) {
         clipboard = {
          type: "node",
          data: JSON.parse(JSON.stringify(NODE_DATA[currentNodeId])),
          size: savedSizes[currentNodeId],
          style: savedStyles[currentNodeId] ? JSON.parse(JSON.stringify(savedStyles[currentNodeId])) : null
         };
        } else if (currentEdgeId) {
         const edge = EDGE_DATA.list.find(e => e.id === currentEdgeId);
         if (edge) clipboard = { type: "edge", data: JSON.parse(JSON.stringify(edge)) };
        } else if (currentRectId) {
         const rect = RECT_DATA.list.find(r => r.id === currentRectId);
         if (rect) clipboard = { type: "rect", data: JSON.parse(JSON.stringify(rect)) };
        } else if (currentTextId) {
         const text = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (text) clipboard = { type: "text", data: JSON.parse(JSON.stringify(text)) };
        }
       }
       
       if (event.ctrlKey && event.key === "v") {
        event.preventDefault();
        if (!clipboard) return;
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        const centerX = canvasState.panX + (viewWidth / 2);
        const centerY = canvasState.panY + (viewHeight / 2);
        
        if (clipboard.type === "node") {
         const data = clipboard.data;
         let newName = data.name + " copy";
         let counter = 1;
         while (Object.values(NODE_DATA).some(n => n.name === newName)) {
          newName = data.name + " copy " + counter;
          counter++;
         }
         let newId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
         counter = 1;
         while (NODE_DATA[newId]) {
          newId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-") + "-" + counter;
          counter++;
         }
         pushUndo("paste node");
         NODE_DATA[newId] = { ...data, name: newName };
         savedPositions[newId] = { x: centerX, y: centerY };
         if (clipboard.size) savedSizes[newId] = clipboard.size;
         if (clipboard.style) savedStyles[newId] = JSON.parse(JSON.stringify(clipboard.style));
         forgeTheTopology();
         claimTheImmortal(newId);
        } else if (clipboard.type === "edge") {
         pushUndo("paste edge");
         const newEdge = { ...clipboard.data, id: "edge-" + Date.now() };
         EDGE_DATA.list.push(newEdge);
         
         forgeTheTopology();
         selectTheConnection(newEdge.id);
        } else if (clipboard.type === "rect") {
         pushUndo("paste rect");
         const newRect = { ...clipboard.data, id: "rect-" + Date.now(), x: centerX - (clipboard.data.width || 100) / 2, y: centerY - (clipboard.data.height || 100) / 2 };
         RECT_DATA.list.push(newRect);
         forgeTheTopology();
         selectTheRect(newRect.id);
        } else if (clipboard.type === "text") {
         pushUndo("paste text");
         const newText = { ...clipboard.data, id: "text-" + Date.now(), x: centerX, y: centerY };
         TEXT_DATA.list.push(newText);
         forgeTheTopology();
         showTextPanel(newText.id);
        }
       }
       
       if (event.key === "Delete") {
        event.preventDefault();
        const totalSelected = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
        if (totalSelected > 0) {
         deleteSelected();
        } else if (currentNodeId && NODE_DATA[currentNodeId]) {
         challengeTheImmortal(`Delete node "${NODE_DATA[currentNodeId].name}"?`, () => {
          pushUndo("delete node");
          delete NODE_DATA[currentNodeId];
          delete savedPositions[currentNodeId];
          delete savedSizes[currentNodeId];
          delete savedStyles[currentNodeId];
          EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== currentNodeId && e.to !== currentNodeId);
          currentNodeId = null;
          
          forgeTheTopology();
          document.getElementById("node-panel").style.display = "none";
         });
        } else if (currentEdgeId) {
         challengeTheImmortal("Delete this line?", () => {
          pushUndo("delete edge");
          EDGE_DATA.list = EDGE_DATA.list.filter(e => e.id !== currentEdgeId);
          currentEdgeId = null;
          
          forgeTheTopology();
          document.getElementById("edge-panel").style.display = "none";
         });
        } else if (currentRectId) {
         challengeTheImmortal("Delete this zone?", () => {
          pushUndo("delete rect");
          RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== currentRectId);
          currentRectId = null;
          forgeTheTopology();
          document.getElementById("rect-panel").style.display = "none";
         });
        } else if (currentTextId) {
         const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (textItem) {
          challengeTheImmortal(`Delete text "${textItem.content.substring(0, 30)}..."?`, () => {
           pushUndo("delete text");
           TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== currentTextId);
           currentTextId = null;
           forgeTheTopology();
           document.getElementById("text-panel").style.display = "none";
          });
         }
        }
       }
      
       if (event.ctrlKey && event.key === "a") {
        event.preventDefault();
        Object.keys(NODE_DATA).forEach(id => selectedNodes.add(id));
        EDGE_DATA.list.forEach(e => selectedEdges.add(e.id));
        RECT_DATA.list.forEach(r => selectedRects.add(r.id));
        TEXT_DATA.list.forEach(t => selectedTexts.add(t.id));
        updateNodeSelection();
       }
       
       if (event.key === "Escape") {
        clearSelection();
        clearSearchHighlight();
       }
      
       if (event.ctrlKey && event.key === "d") {
        event.preventDefault();
        if (currentNodeId && NODE_DATA[currentNodeId]) {
         cloneNode(currentNodeId);
        } else if (currentEdgeId) {
         const edge = EDGE_DATA.list.find(e => e.id === currentEdgeId);
         if (edge) {
          pushUndo("clone edge");
          const newEdge = { ...JSON.parse(JSON.stringify(edge)), id: "edge-" + Date.now() };
          EDGE_DATA.list.push(newEdge);
          
          forgeTheTopology();
          selectTheConnection(newEdge.id);
         }
        } else if (currentRectId) {
         const rect = RECT_DATA.list.find(r => r.id === currentRectId);
         if (rect) {
          pushUndo("clone rect");
          const newRect = { ...JSON.parse(JSON.stringify(rect)), id: "rect-" + Date.now(), x: rect.x + 50, y: rect.y + 50 };
          RECT_DATA.list.push(newRect);
          forgeTheTopology();
          selectTheRect(newRect.id);
         }
        } else if (currentTextId) {
         const text = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (text) {
          pushUndo("clone text");
          const newText = { ...JSON.parse(JSON.stringify(text)), id: "text-" + Date.now(), x: text.x + 50, y: text.y + 50 };
          TEXT_DATA.list.push(newText);
          forgeTheTopology();
          showTextPanel(newText.id);
         }
        }
       }
      }
      
      function saveRollbackVersion(description = "Auto-save") {
        const version = {
          timestamp: Date.now(),
          description,
          data: captureTheQuickening()
        };
        
        try {
          const stored = localStorage.getItem(ROLLBACK_STORAGE_KEY);
          rollbackVersions = stored ? JSON.parse(stored) : [];
        } catch (e) {
          rollbackVersions = [];
        }
        
        rollbackVersions.unshift(version);
        
        if (rollbackVersions.length > MAX_ROLLBACK_VERSIONS) {
          rollbackVersions = rollbackVersions.slice(0, MAX_ROLLBACK_VERSIONS);
        }
        
        try {
          localStorage.setItem(ROLLBACK_STORAGE_KEY, JSON.stringify(rollbackVersions));
        } catch (e) {
          console.warn("Failed to save rollback version:", e);
        }
      }
      
      function loadRollbackVersions() {
        try {
          const stored = localStorage.getItem(ROLLBACK_STORAGE_KEY);
          rollbackVersions = stored ? JSON.parse(stored) : [];
          displayRollbackVersions();
        } catch (e) {
          console.warn("Failed to load rollback versions:", e);
          rollbackVersions = [];
        }
      }
      
      function displayRollbackVersions() {
        const listEl = document.getElementById("rollback-list");
        if (!listEl) return;
        
        if (rollbackVersions.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No version history yet. Versions are saved automatically when you save the file.</div>';
          return;
        }
        
        listEl.innerHTML = rollbackVersions.map((version, index) => {
          const date = new Date(version.timestamp);
          const timeStr = date.toLocaleString();
          const nodeCount = Object.keys(version.data.nodeData || {}).length;
          const edgeCount = (version.data.edgeData?.list || []).length;
          
          return `
            <div class="version-item" onclick="restoreRollbackVersion(${index})">
              <div class="version-info">
                <div class="timestamp">${timeStr}</div>
                <div class="details">${version.description} • ${nodeCount} nodes • ${edgeCount} connections</div>
              </div>
              <div class="version-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteRollbackVersion(${index})" title="Delete this version">🗑️</button>
              </div>
            </div>
          `;
        }).join('');
      }
      
      function restoreRollbackVersion(index) {
        if (!confirm(`Restore version from ${new Date(rollbackVersions[index].timestamp).toLocaleString()}?\n\nYour current work will be lost unless you save first.`)) {
          return;
        }
        
        const version = rollbackVersions[index];
        const data = version.data;
        
        NODE_DATA = data.nodeData || {};
        EDGE_DATA = data.edgeData || { list: [] };
        RECT_DATA = data.rectData || { list: [] };
        TEXT_DATA = data.textData || { list: [] };
        EDGE_LEGEND = data.edgeLegend || {};
        savedPositions = data.nodePositions || {};
        savedSizes = data.nodeSizes || {};
        savedStyles = data.nodeStyles || {};
        PAGE_STATE = data.page || PAGE_STATE;
        
        if (data.canvas) {
          canvasState.zoom = data.canvas.zoom;
          canvasState.panX = data.canvas.panX;
          canvasState.panY = data.canvas.panY;
        }
        
        wieldThePower();
        forgeTheTopology();
        
        document.getElementById("rollback-modal").classList.remove("active");
        
        logAuditEvent("rollback", `Restored version from ${new Date(version.timestamp).toLocaleString()}`);
      }
      
      function deleteRollbackVersion(index) {
        if (!confirm("Delete this version from history?")) return;
        
        rollbackVersions.splice(index, 1);
        try {
          localStorage.setItem(ROLLBACK_STORAGE_KEY, JSON.stringify(rollbackVersions));
        } catch (e) {
          console.warn("Failed to delete version:", e);
        }
        displayRollbackVersions();
      }
      
      function clearRollbackHistory() {
        if (!confirm("Clear all version history?\n\nThis cannot be undone.")) return;
        
        rollbackVersions = [];
        localStorage.removeItem(ROLLBACK_STORAGE_KEY);
        displayRollbackVersions();
      }
      
      function createManualSnapshot() {
        const description = prompt("Enter a description for this snapshot:", "Manual snapshot");
        if (!description) return;
        
        saveRollbackVersion(description);
        displayRollbackVersions();
      }
      
      function switchTab(index) {
        if (index === currentTabIndex) return;
        
        const currentTab = documentTabs[currentTabIndex];
        currentTab.nodes = JSON.parse(JSON.stringify(NODE_DATA));
        currentTab.edges = JSON.parse(JSON.stringify(EDGE_DATA));
        currentTab.positions = JSON.parse(JSON.stringify(savedPositions));
        currentTab.sizes = JSON.parse(JSON.stringify(savedSizes));
        currentTab.styles = JSON.parse(JSON.stringify(savedStyles));
        currentTab.legend = JSON.parse(JSON.stringify(EDGE_LEGEND));
        currentTab.rects = JSON.parse(JSON.stringify(RECT_DATA));
        currentTab.texts = JSON.parse(JSON.stringify(TEXT_DATA));
        currentTab.pageState = JSON.parse(JSON.stringify(PAGE_STATE));
      
        currentTabIndex = index;
        const newTab = documentTabs[index];
        NODE_DATA = JSON.parse(JSON.stringify(newTab.nodes));
        EDGE_DATA = JSON.parse(JSON.stringify(newTab.edges));
        savedPositions = JSON.parse(JSON.stringify(newTab.positions));
        savedSizes = JSON.parse(JSON.stringify(newTab.sizes));
        savedStyles = JSON.parse(JSON.stringify(newTab.styles));
        EDGE_LEGEND = JSON.parse(JSON.stringify(newTab.legend));
        RECT_DATA = JSON.parse(JSON.stringify(newTab.rects));
        TEXT_DATA = JSON.parse(JSON.stringify(newTab.texts));
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, newTab.pageState || {});
        wieldThePower();
        document.title = PAGE_STATE.title || newTab.name;
        document.getElementById("page-title").textContent = PAGE_STATE.title || newTab.name;
        forgeTheTopology();
        currentNodeId = null;
        currentEdgeId = null;
        currentTextId = null;
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        displayTabs();
        
        logAuditEvent("tab", `Switched to tab: ${newTab.name}`);
      }
      
      function createNewTab() {
        const nameInput = document.getElementById("new-tab-name");
        const name = nameInput.value.trim();
        
        if (!name) {
          alert("Please enter a tab name");
          return;
        }
        
        const newTab = {
          id: `tab-${Date.now()}`,
          name,
          nodes: {},
          edges: { list: [] },
          positions: {},
          sizes: {},
          styles: {},
          legend: {},
          rects: { list: [] },
          texts: { list: [] },
      pageState: null
        };
        
        documentTabs.push(newTab);
        nameInput.value = "";
        displayTabs();
        
        logAuditEvent("tab", `Created new tab: ${name}`);
      }
      
      function renameTab(index) {
        const tab = documentTabs[index];
        const newName = prompt("Enter new name:", tab.name);
        if (!newName || newName === tab.name) return;
        
        tab.name = newName;
        displayTabs();
        
        logAuditEvent("tab", `Renamed tab to: ${newName}`);
      }
      
      function deleteTab(index) {
        if (documentTabs.length === 1) {
          alert("Cannot delete the last tab");
          return;
        }
        
        if (!confirm(`Delete tab "${documentTabs[index].name}"?`)) return;
        
        documentTabs.splice(index, 1);
        
        if (currentTabIndex >= documentTabs.length) {
          currentTabIndex = documentTabs.length - 1;
        }
        
        if (currentTabIndex === index) {
          switchTab(currentTabIndex);
        }
        
        displayTabs();
      }
      
      function displayTabs() {
        const listEl = document.getElementById("tabs-list");
        if (!listEl) return;
        
        listEl.innerHTML = documentTabs.map((tab, index) => {
          const nodeCount = Object.keys(tab.nodes).length;
          const edgeCount = tab.edges.list.length;
          const isActive = index === currentTabIndex;
          
          return `
            <div class="tab-item ${isActive ? 'active' : ''}" onclick="switchTab(${index})">
              <div class="tab-name">${tab.name}</div>
              <div class="tab-stats">${nodeCount} nodes • ${edgeCount} connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(${index})" title="Rename tab">✏️</button>
                ${documentTabs.length > 1 ? '<button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(${index})" title="Delete tab">🗑️</button>' : ''}
              </div>
            </div>
          `;
        }).join('');
      }
      
      function logAuditEvent(type, description, details = {}) {
        const event = {
          timestamp: Date.now(),
          type,
          description,
          details,
          tab: documentTabs[currentTabIndex]?.name || "Main"
        };
        
        auditLog.unshift(event);
        
        if (auditLog.length > MAX_AUDIT_ENTRIES) {
          auditLog = auditLog.slice(0, MAX_AUDIT_ENTRIES);
        }
      
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to save audit log:", e);
        }
      }
      
      function loadAuditLog() {
        let embeddedLog = [];
        let localLog = [];
        try {
          const stateScript = document.getElementById("topology-state");
          if (stateScript) {
            const stateData = JSON.parse(stateScript.textContent);
            if (stateData.auditLog && Array.isArray(stateData.auditLog)) {
              embeddedLog = stateData.auditLog;
            }
          }
        } catch (e) {
          console.warn("Failed to load embedded audit log:", e);
        }
        try {
          const stored = localStorage.getItem(AUDIT_STORAGE_KEY);
          if (stored) {
            localLog = JSON.parse(stored);
          }
        } catch (e) {
          console.warn("Failed to load localStorage audit log:", e);
        }
        const merged = [...embeddedLog, ...localLog];
        const seen = new Set();
        auditLog = merged.filter(entry => {
          const key = entry.timestamp + entry.description;
          if (seen.has(key)) return false;
          seen.add(key);
          return true;
        }).sort((a, b) => b.timestamp - a.timestamp);
        if (auditLog.length > MAX_AUDIT_ENTRIES) {
          auditLog = auditLog.slice(0, MAX_AUDIT_ENTRIES);
        }
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to sync audit log:", e);
        }
      }
      
      function displayAuditLog(filter = "all") {
        const listEl = document.getElementById("audit-log-list");
        if (!listEl) return;
        
        const filtered = filter === "all" ? auditLog : auditLog.filter(e => e.type === filter);
        
        if (filtered.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No audit entries yet</div>';
          return;
        }
        
        listEl.innerHTML = filtered.map(event => {
          const date = new Date(event.timestamp);
          const timeStr = date.toLocaleString();
          
          return `
            <div class="audit-entry ${event.type}">
              <div class="time">[${timeStr}] ${event.tab}</div>
              <div class="action">[${event.type.toUpperCase()}] ${event.description}</div>
            </div>
          `;
        }).join('');
      }
      
      function clearAuditLog() {
        if (!confirm("Clear all audit log entries?\n\nThis cannot be undone.")) return;
        
        auditLog = [];
        localStorage.removeItem(AUDIT_STORAGE_KEY);
        displayAuditLog();
      }
      
      function exportAuditLog() {
        if (auditLog.length === 0) {
          alert("No audit entries to export");
          return;
        }
        
        const csv = [
          ["Timestamp", "Tab", "Type", "Description"],
          ...auditLog.map(e => [
            new Date(e.timestamp).toISOString(),
            e.tab,
            e.type,
            e.description
          ])
        ].map(row => row.map(cell => `"${cell}"`).join(",")).join("\n");
        
        const blob = new Blob([csv], { type: "text/csv" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `audit-log-${Date.now()}.csv`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }
      
      let currentSecretName = null;
      
      function createNewSecret() {
        const nameInput = document.getElementById("new-secret-name");
        const name = nameInput.value.trim();
        
        if (!name) {
          alert("Please enter a note name");
          return;
        }
        
        if (encryptedSections[name]) {
          alert("A note with this name already exists");
          return;
        }
        
        currentSecretName = name;
        encryptedSections[name] = { encrypted: false, data: "" };
        nameInput.value = "";
        
        document.getElementById("secret-editor-title").textContent = `New note: ${name}`;
        document.getElementById("secret-editor-content").value = "";
        document.getElementById("secrets-modal").classList.remove("active");
        document.getElementById("secret-editor-modal").classList.add("active");
        
        displaySecrets();
      }
      
      function editSecret(name) {
        currentSecretName = name;
        const section = encryptedSections[name];
        
        if (section.encrypted) {
          const password = prompt(`Enter password to decrypt "${name}":`);
          if (!password) return;
          
          try {
            decryptData(section.data, password).then(decrypted => {
              document.getElementById("secret-editor-title").textContent = `Edit note: ${name}`;
              document.getElementById("secret-editor-content").value = decrypted;
              document.getElementById("secrets-modal").classList.remove("active");
              document.getElementById("secret-editor-modal").classList.add("active");
            }).catch(e => {
              alert("Failed to decrypt. Wrong password?");
            });
          } catch (e) {
            alert("Failed to decrypt. Wrong password?");
          }
        } else {
          document.getElementById("secret-editor-title").textContent = `Edit note: ${name}`;
          document.getElementById("secret-editor-content").value = section.data;
          document.getElementById("secrets-modal").classList.remove("active");
          document.getElementById("secret-editor-modal").classList.add("active");
        }
      }
      
      async function saveSecret() {
        if (!currentSecretName) return;
        
        const content = document.getElementById("secret-editor-content").value;
        const autoEncrypt = document.getElementById("secret-auto-encrypt").checked;
        
        if (autoEncrypt) {
          const password = prompt(`Enter password to encrypt "${currentSecretName}":`);
          if (!password) return;
          
          const confirmPassword = prompt("Confirm password:");
          if (password !== confirmPassword) {
            alert("Passwords do not match");
            return;
          }
          
          try {
            const encrypted = await encryptData(content, password);
            encryptedSections[currentSecretName] = { encrypted: true, data: encrypted };
          } catch (e) {
            alert("Encryption failed: " + e.message);
            return;
          }
        } else {
          encryptedSections[currentSecretName] = { encrypted: false, data: content };
        }
        
        closeSecretEditor();
        displaySecrets();
        
        logAuditEvent("secret", `Saved note: ${currentSecretName}`);
      }
      
      function closeSecretEditor() {
        document.getElementById("secret-editor-modal").classList.remove("active");
        document.getElementById("secrets-modal").classList.add("active");
        currentSecretName = null;
      }
      
      function deleteSecret(name) {
        if (!confirm(`Delete note "${name}"?`)) return;
        
        delete encryptedSections[name];
        displaySecrets();
        
        logAuditEvent("secret", `Deleted note: ${name}`);
      }
      
      function displaySecrets() {
        const listEl = document.getElementById("secrets-list");
        if (!listEl) return;
        
        const secrets = Object.keys(encryptedSections);
        
        if (secrets.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No notes yet</div>';
          return;
        }
        
        listEl.innerHTML = secrets.map(name => {
          const section = encryptedSections[name];
          const status = section.encrypted ? "🔒 Encrypted" : "🔓 Plaintext";
          
          return `
            <div class="secret-item">
              <div class="secret-name">${name}</div>
              <div class="secret-status">${status}</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="editSecret('${name}')" title="Edit note">✏️</button>
                <button class="btn-cancel" onclick="deleteSecret('${name}')" title="Delete note">🗑️</button>
              </div>
            </div>
          `;
        }).join('');
      }
      
      let rafId = null;
      let lastRender = 0;
      const RENDER_THROTTLE = 16;
      
      function setupDragToCreate() {
        const addNodeBtn = document.getElementById("add-node-btn");
        const addRackBtn = document.getElementById("add-rack-btn");
        const canvas = document.getElementById("map");
        
        if (!addNodeBtn || !addRackBtn || !canvas) return;
        
        let dragType = null;
        
        [addNodeBtn, addRackBtn].forEach(btn => {
          btn.setAttribute("draggable", "true");
          
          btn.addEventListener("dragstart", e => {
            dragType = btn.id === "add-node-btn" ? "node" : "rack";
            e.dataTransfer.effectAllowed = "copy";
            e.dataTransfer.setData("text/plain", dragType);
          });
        });
        
        canvas.addEventListener("dragover", e => {
          if (dragType) {
            e.preventDefault();
            e.dataTransfer.dropEffect = "copy";
          }
        });
        
        canvas.addEventListener("drop", e => {
          if (!dragType) return;
          
          e.preventDefault();
          
          const rect = canvas.getBoundingClientRect();
          const x = (e.clientX - rect.left) / canvasState.zoom + canvasState.panX;
          const y = (e.clientY - rect.top) / canvasState.zoom + canvasState.panY;
          
          if (dragType === "node") {
            createNodeAtPosition(x, y);
          } else if (dragType === "rack") {
            createRackAtPosition(x, y);
          }
          
          dragType = null;
        });
      }
      
      function createNodeAtPosition(x, y) {
        const timestamp = Date.now();
        const newId = `host-${timestamp}`;
        
        NODE_DATA[newId] = {
          name: "New Node",
          ip: "0.0.0.0",
          shape: "server",
          role: "",
          tags: [],
          notes: "",
          layer: "physical",
          isRack: false
        };
        
        savedPositions[newId] = { x, y };
        savedSizes[newId] = 55;
        
        pushUndo("create node");
        forgeTheTopology();
        claimTheImmortal(newId);
        
        logAuditEvent("node", `Created node at (${Math.round(x)}, ${Math.round(y)})`);
      }
      
      function createRackAtPosition(x, y) {
        const timestamp = Date.now();
        const newId = `rack-${timestamp}`;
        
        NODE_DATA[newId] = {
          name: "New Rack",
          ip: "",
          shape: "server",
          role: "rack",
          tags: [],
          notes: "",
          layer: "physical",
          isRack: true,
          rackCapacity: 42
        };
        
        savedPositions[newId] = { x, y };
        savedSizes[newId] = 55;
        
        pushUndo("create rack");
        populateRackDropdown();
        forgeTheTopology();
        claimTheImmortal(newId);
        
        logAuditEvent("rack", `Created rack at (${Math.round(x)}, ${Math.round(y)})`);
      }
      
      document.addEventListener("keydown", handleKeyDown);
      
      document.getElementById("save-file-btn").addEventListener("click", becomeImmortal);
      const addNodeBtn = document.getElementById("add-node-btn");
      const addNodeModal = document.getElementById("add-node-modal");
      const addNodeCancel = document.getElementById("add-node-cancel");
      const addNodeSave = document.getElementById("add-node-save");
      
      const undoBtn = document.getElementById("undo-btn");
      const redoBtn = document.getElementById("redo-btn");
      if (undoBtn) undoBtn.addEventListener("click", undo);
      if (redoBtn) redoBtn.addEventListener("click", redo);
      
      const backToTopologyBtn = document.getElementById("back-to-topology-btn");
      if (backToTopologyBtn) {
       backToTopologyBtn.addEventListener("click", exitRack);
      }
      
      const canvasViewport = document.getElementById("canvas-viewport");
      if (canvasViewport) {
       canvasViewport.addEventListener("dblclick", (e) => {
        if (currentView.mode === "rack" && e.target.id === "map") {
         exitRack();
        }
       });
      }
      
      const layersBtn = document.getElementById("layers-btn");
      const layerModal = document.getElementById("layer-modal");
      const layerModalClose = document.getElementById("layer-modal-close");
      if (layersBtn && layerModal) {
       layersBtn.addEventListener("click", () => {
        layerModal.classList.add("active");
       });
      }
      if (layerModalClose && layerModal) {
       layerModalClose.addEventListener("click", () => {
        layerModal.classList.remove("active");
       });
      }
      if (layerModal) {
       layerModal.addEventListener("click", (e) => {
        if (e.target === layerModal) {
         layerModal.classList.remove("active");
        }
       });
      }
      
      ["physical", "logical", "security", "application"].forEach(layer => {
       const checkbox = document.getElementById(`layer-${layer}`);
       if (checkbox) {
        checkbox.addEventListener("change", applyLayerFilter);
       }
      });
            
      const tabsBtn = document.getElementById("tabs-btn");
      const tabsModal = document.getElementById("tabs-modal");
      const tabsModalClose = document.getElementById("tabs-modal-close");
      
      if (tabsBtn && tabsModal) {
        tabsBtn.addEventListener("click", () => {
          displayTabs();
          tabsModal.classList.add("active");
        });
      }
      
      if (tabsModalClose && tabsModal) {
        tabsModalClose.addEventListener("click", () => {
          tabsModal.classList.remove("active");
        });
      }
      
      if (tabsModal) {
        tabsModal.addEventListener("click", (e) => {
          if (e.target === tabsModal) {
            tabsModal.classList.remove("active");
          }
        });
      }
      
      const rollbackBtn = document.getElementById("rollback-btn");
      const rollbackModal = document.getElementById("rollback-modal");
      const rollbackModalClose = document.getElementById("rollback-modal-close");
      
      if (rollbackBtn && rollbackModal) {
        rollbackBtn.addEventListener("click", () => {
          loadRollbackVersions();
          rollbackModal.classList.add("active");
        });
      }
      
      if (rollbackModalClose && rollbackModal) {
        rollbackModalClose.addEventListener("click", () => {
          rollbackModal.classList.remove("active");
        });
      }
      
      if (rollbackModal) {
        rollbackModal.addEventListener("click", (e) => {
          if (e.target === rollbackModal) {
            rollbackModal.classList.remove("active");
          }
        });
      }
      
      const auditLogBtn = document.getElementById("audit-log-btn");
      const auditLogModal = document.getElementById("audit-log-modal");
      const auditLogModalClose = document.getElementById("audit-log-modal-close");
      const auditFilter = document.getElementById("audit-filter");
      
      if (auditLogBtn && auditLogModal) {
        auditLogBtn.addEventListener("click", () => {
          loadAuditLog();
          displayAuditLog();
          auditLogModal.classList.add("active");
        });
      }
      
      if (auditFilter) {
        auditFilter.addEventListener("change", (e) => {
          displayAuditLog(e.target.value);
        });
      }
      
      if (auditLogModalClose && auditLogModal) {
        auditLogModalClose.addEventListener("click", () => {
          auditLogModal.classList.remove("active");
        });
      }
      
      if (auditLogModal) {
        auditLogModal.addEventListener("click", (e) => {
          if (e.target === auditLogModal) {
            auditLogModal.classList.remove("active");
          }
        });
      }
      
      const secretsBtn = document.getElementById("secrets-btn");
      const secretsModal = document.getElementById("secrets-modal");
      const secretsModalClose = document.getElementById("secrets-modal-close");
      const secretEditorModal = document.getElementById("secret-editor-modal");
      
      if (secretsBtn && secretsModal) {
        secretsBtn.addEventListener("click", () => {
          displaySecrets();
          secretsModal.classList.add("active");
        });
      }
      
      if (secretsModalClose && secretsModal) {
        secretsModalClose.addEventListener("click", () => {
          secretsModal.classList.remove("active");
        });
      }
      
      if (secretsModal) {
        secretsModal.addEventListener("click", (e) => {
          if (e.target === secretsModal) {
            secretsModal.classList.remove("active");
          }
        });
      }
      
      if (secretEditorModal) {
        secretEditorModal.addEventListener("click", (e) => {
          if (e.target === secretEditorModal) {
            closeSecretEditor();
          }
        });
      }
      
      loadAuditLog();
      setupDragToCreate();
      
      ["physical", "logical", "security", "application"].forEach(layer => {
       const checkbox = document.getElementById(`layer-${layer}`);
       if (checkbox) {
        checkbox.addEventListener("change", applyLayerFilter);
       }
      });
      
      const layerSelect = document.getElementById("node-layer");
      if (layerSelect) {
       layerSelect.addEventListener("change", (e) => {
        if (currentNodeId) {
         pushUndo("change layer");
         NODE_DATA[currentNodeId].layer = e.target.value;
         forgeTheTopology();
        }
       });
      }
      
       const assignedRackSelect = document.getElementById("node-assigned-rack");
       if (assignedRackSelect) {
      assignedRackSelect.addEventListener("change", (e) => {
      if (currentNodeId) {
      pushUndo("change assigned rack");
      EDGE_DATA.list = EDGE_DATA.list.filter(edge => edge.from !== currentNodeId && edge.to !== currentNodeId);
      NODE_DATA[currentNodeId].assignedRack = e.target.value;
      forgeTheTopology();
      claimTheImmortal(currentNodeId);
      }
      });
       }
      
      const rackCapacitySelect = document.getElementById("node-rack-capacity");
      if (rackCapacitySelect) {
       rackCapacitySelect.addEventListener("change", (e) => {
        if (currentNodeId) {
         pushUndo("change rack capacity");
         NODE_DATA[currentNodeId].rackCapacity = e.target.value;
         forgeTheTopology();
        }
       });
      }
      
      const bulkToolbarClose = document.getElementById("bulk-toolbar-close");
      if (bulkToolbarClose) {
       bulkToolbarClose.addEventListener("click", clearSelection);
      }
      
      const bulkAlignLeft = document.getElementById("bulk-align-left");
      if (bulkAlignLeft) {
       bulkAlignLeft.addEventListener("click", () => alignSelectedNodes("left"));
      }
      
      const bulkAlignRight = document.getElementById("bulk-align-right");
      if (bulkAlignRight) {
       bulkAlignRight.addEventListener("click", () => alignSelectedNodes("right"));
      }
      
      const bulkAlignTop = document.getElementById("bulk-align-top");
      if (bulkAlignTop) {
       bulkAlignTop.addEventListener("click", () => alignSelectedNodes("top"));
      }
      
      const bulkAlignBottom = document.getElementById("bulk-align-bottom");
      if (bulkAlignBottom) {
       bulkAlignBottom.addEventListener("click", () => alignSelectedNodes("bottom"));
      }
      
      const bulkDistributeH = document.getElementById("bulk-distribute-h");
      if (bulkDistributeH) {
       bulkDistributeH.addEventListener("click", () => distributeSelectedNodes("horizontal"));
      }
      
      const bulkDistributeV = document.getElementById("bulk-distribute-v");
      if (bulkDistributeV) {
       bulkDistributeV.addEventListener("click", () => distributeSelectedNodes("vertical"));
      }
      
      const bulkClone = document.getElementById("bulk-clone");
      if (bulkClone) {
       bulkClone.addEventListener("click", () => {
        if (selectedNodes.size === 0) return;
        pushUndo("clone selected");
        const nodesToClone = Array.from(selectedNodes);
        selectedNodes.clear();
        nodesToClone.forEach(id => {
         cloneNode(id);
         selectedNodes.add(currentNodeId);
        });
        updateNodeSelection();
       });
      }
      
      const bulkDelete = document.getElementById("bulk-delete");
      if (bulkDelete) {
       bulkDelete.addEventListener("click", deleteSelected);
      }
      
      const bulkMobileBtn = document.getElementById("bulk-mobile-btn");
      const bulkActionsModal = document.getElementById("bulk-actions-modal");
      const bulkModalClose = document.getElementById("bulk-modal-close");
      
      if (bulkMobileBtn) {
       bulkMobileBtn.addEventListener("click", () => {
        if (bulkActionsModal) bulkActionsModal.style.display = "block";
       });
      }
      
      if (bulkModalClose) {
       bulkModalClose.addEventListener("click", () => {
        if (bulkActionsModal) bulkActionsModal.style.display = "none";
       });
      }
      
      const closeModalAfterAction = () => {
       if (bulkActionsModal) bulkActionsModal.style.display = "none";
      };
      
      const bulkAlignLeftMobile = document.getElementById("bulk-align-left-mobile");
      if (bulkAlignLeftMobile) {
       bulkAlignLeftMobile.addEventListener("click", () => {
        alignSelectedNodes("left");
        closeModalAfterAction();
       });
      }
      
      const bulkAlignRightMobile = document.getElementById("bulk-align-right-mobile");
      if (bulkAlignRightMobile) {
       bulkAlignRightMobile.addEventListener("click", () => {
        alignSelectedNodes("right");
        closeModalAfterAction();
       });
      }
      
      const bulkAlignTopMobile = document.getElementById("bulk-align-top-mobile");
      if (bulkAlignTopMobile) {
       bulkAlignTopMobile.addEventListener("click", () => {
        alignSelectedNodes("top");
        closeModalAfterAction();
       });
      }
      
      const bulkAlignBottomMobile = document.getElementById("bulk-align-bottom-mobile");
      if (bulkAlignBottomMobile) {
       bulkAlignBottomMobile.addEventListener("click", () => {
        alignSelectedNodes("bottom");
        closeModalAfterAction();
       });
      }
      
      const bulkDistributeHMobile = document.getElementById("bulk-distribute-h-mobile");
      if (bulkDistributeHMobile) {
       bulkDistributeHMobile.addEventListener("click", () => {
        distributeSelectedNodes("horizontal");
        closeModalAfterAction();
       });
      }
      
      const bulkDistributeVMobile = document.getElementById("bulk-distribute-v-mobile");
      if (bulkDistributeVMobile) {
       bulkDistributeVMobile.addEventListener("click", () => {
        distributeSelectedNodes("vertical");
        closeModalAfterAction();
       });
      }
      
      const bulkCloneMobile = document.getElementById("bulk-clone-mobile");
      if (bulkCloneMobile) {
       bulkCloneMobile.addEventListener("click", () => {
        if (selectedNodes.size === 0) return;
        pushUndo("clone selected");
        const nodesToClone = Array.from(selectedNodes);
        selectedNodes.clear();
        nodesToClone.forEach(id => {
         cloneNode(id);
         selectedNodes.add(currentNodeId);
        });
        updateNodeSelection();
        closeModalAfterAction();
       });
      }
      
      const bulkDeleteMobile = document.getElementById("bulk-delete-mobile");
      if (bulkDeleteMobile) {
       bulkDeleteMobile.addEventListener("click", () => {
        deleteSelected();
        closeModalAfterAction();
       });
      }
      
      const bulkLockMobile = document.getElementById("bulk-lock-mobile");
      if (bulkLockMobile) {
       bulkLockMobile.addEventListener("click", () => {
        toggleLockSelected();
        closeModalAfterAction();
       });
      }
      
      const bulkGroupMobile = document.getElementById("bulk-group-mobile");
      if (bulkGroupMobile) {
       bulkGroupMobile.addEventListener("click", () => {
        toggleGroupSelected();
        closeModalAfterAction();
       });
      }
      
      const bulkClearMobile = document.getElementById("bulk-clear-mobile");
      if (bulkClearMobile) {
       bulkClearMobile.addEventListener("click", () => {
        clearSelection();
        closeModalAfterAction();
       });
      }
      
      const searchInput = document.getElementById("search-nodes");
      if (searchInput) {
       searchInput.addEventListener("input", (e) => {
        searchNodes(e.target.value);
       });
      }
      
      addNodeBtn.addEventListener("click", () => {
	  if (isViewOnly()) return;
       document.getElementById("new-node-name").value = "";
       document.getElementById("new-node-ip").value = "";
       document.getElementById("new-node-tags").value = "";
       document.getElementById("new-node-shape").value = "circle";
       addNodeModal.classList.add("active");
       document.getElementById("new-node-name").focus();
      });
      
      const addRackBtn = document.getElementById("add-rack-btn");
      const addRackModal = document.getElementById("add-rack-modal");
      const addRackCancel = document.getElementById("add-rack-cancel");
      const addRackSave = document.getElementById("add-rack-save");
      
      if (addRackBtn && addRackModal) {
       addRackBtn.addEventListener("click", () => {
	   if (isViewOnly()) return;
        document.getElementById("new-rack-name").value = "";
        document.getElementById("new-rack-ip").value = "";
        document.getElementById("new-rack-tags").value = "";
        document.getElementById("new-rack-shape").value = "server";
        document.getElementById("new-rack-capacity").value = "42";
        addRackModal.classList.add("active");
        document.getElementById("new-rack-name").focus();
       });
      }
      
      if (addRackCancel && addRackModal) {
       addRackCancel.addEventListener("click", () => {
        addRackModal.classList.remove("active");
       });
      }
      
      if (addRackModal) {
       addRackModal.addEventListener("click", (e) => {
        if (e.target === addRackModal) {
         addRackModal.classList.remove("active");
        }
       });
      }
      
      if (addRackSave && addRackModal) {
       addRackSave.addEventListener("click", () => {
        const name = document.getElementById("new-rack-name").value.trim();
        const ip = document.getElementById("new-rack-ip").value.trim();
        const tagsStr = document.getElementById("new-rack-tags").value.trim();
        const shape = document.getElementById("new-rack-shape").value;
        const capacity = document.getElementById("new-rack-capacity").value;
        
        if (!name) {
         alert("Please enter a rack name.");
         return;
        }
        
        const tags = tagsStr ? tagsStr.split(",").map((t) => t.trim()).filter((t) => t) : [];
        let baseId = name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");
        if (!baseId) baseId = "rack";
        let nodeId = baseId;
        let counter = 1;
        while (NODE_DATA[nodeId]) {
         nodeId = baseId + "-" + counter;
         counter++;
        }
        
        pushUndo("add rack");
        
        NODE_DATA[nodeId] = {
         shape: shape,
         name: name,
         ip: ip || "",
         role: "Rack",
         tags: tags,
         notes: [],
         mac: "",
         rackUnit: "",
         uHeight: "1",
         layer: "physical",
         assignedRack: "",
         rackCapacity: capacity,
         isRack: true,  
         locked: false, 
         groupId: null 
        };
        
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        const centerX = canvasState.panX + (viewWidth / 2);
        const centerY = canvasState.panY + (viewHeight / 2);
        savedPositions[nodeId] = {
         x: centerX,
         y: centerY
        };
        
        addRackModal.classList.remove("active");
        forgeTheTopology();
        claimTheImmortal(nodeId);
       });
       
       ["new-rack-name", "new-rack-ip", "new-rack-tags"].forEach((inputId) => {
        const input = document.getElementById(inputId);
        if (input) {
         input.addEventListener("keypress", (e) => {
          if (e.key === "Enter") {
           addRackSave.click();
          }
         });
        }
       });
      }
      
      addNodeCancel.addEventListener("click", () => {
       addNodeModal.classList.remove("active");
      });
      addNodeModal.addEventListener("click", (e) => {
       if (e.target === addNodeModal) {
        addNodeModal.classList.remove("active");
       }
      });
      addNodeSave.addEventListener("click", () => {
       const name = document.getElementById("new-node-name").value.trim();
       const ip = document.getElementById("new-node-ip").value.trim();
       const tagsStr = document.getElementById("new-node-tags").value.trim();
       const shape = document.getElementById("new-node-shape").value;
       if (!name) {
        alert("Please enter a node name.");
        return;
       }
       const tags = tagsStr ? tagsStr.split(",").map((t) => t.trim()).filter((t) => t) : [];
       let baseId = name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");
       if (!baseId) baseId = "node";
       let nodeId = baseId;
       let counter = 1;
       while (NODE_DATA[nodeId]) {
        nodeId = baseId + "-" + counter;
        counter++;
       }
       NODE_DATA[nodeId] = {
        shape: shape || "circle",
        name: name,
        ip: ip || "0.0.0.0",
        role: "",
        tags: tags,
        notes: [],
        mac: "",
        rackUnit: "",
        uHeight: "1",
        layer: "physical",
        assignedRack: "",  
        rackCapacity: "42",
        isRack: false, 
        locked: false, 
        groupId: null 
       };
       
       if (currentView.mode === "rack" && currentView.rackId) {
        NODE_DATA[nodeId].assignedRack = currentView.rackId;
        NODE_DATA[nodeId].layer = "physical";
        const rackCapacity = getRackCapacity(currentView.rackId);
        const rackUHeight = getRackUHeight(currentView.rackId);
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        const centerY = canvasState.panY + (viewHeight / 2);
        let unit = rackCapacity - Math.round((centerY - RACK_START_Y) / rackUHeight);
        unit = Math.max(1, Math.min(rackCapacity, unit));
        NODE_DATA[nodeId].rackUnit = String(unit);
       }
       
      const viewWidth = CANVAS_WIDTH / canvasState.zoom;
      const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
      const centerX = canvasState.panX + (viewWidth / 2);
      const centerY = canvasState.panY + (viewHeight / 2);
      savedPositions[nodeId] = {
      x: centerX,
      y: centerY
      };
       pushUndo("add node");
       addNodeModal.classList.remove("active");
       forgeTheTopology();
       claimTheImmortal(nodeId);
      });
      ["new-node-name", "new-node-ip", "new-node-tags"].forEach(
       (inputId) => {
        document.getElementById(inputId).addEventListener("keypress", (e) => {
         if (e.key === "Enter") {
          addNodeSave.click();
         }
        });
       }, );
      const clearAllBtn = document.getElementById("clear-all-btn");
      const clearAllModal = document.getElementById("clear-all-modal");
      const clearAllCancel = document.getElementById("clear-all-cancel");
      const clearAllConfirm = document.getElementById("clear-all-confirm");
      clearAllBtn.addEventListener("click", () => {
       clearAllModal.classList.add("active");
      });
      clearAllCancel.addEventListener("click", () => {
       clearAllModal.classList.remove("active");
      });
      clearAllModal.addEventListener("click", (e) => {
       if (e.target === clearAllModal) {
        clearAllModal.classList.remove("active");
       }
      });
      clearAllConfirm.addEventListener("click", () => {
       NODE_DATA = {};
       EDGE_DATA = {
        list: []
       };
       EDGE_LEGEND = {};
       RECT_DATA = { list: [] };
       TEXT_DATA = { list: [] };
       savedPositions = {};
       savedSizes = {};
       savedStyles = {};
       logAuditEvent("clear", "Cleared all data from canvas");
       clearAllModal.classList.remove("active");
       forgeTheTopology();
       document.getElementById("node-panel").style.display = "none";
       document.getElementById("edge-panel").style.display = "none";
       document.getElementById("text-panel").style.display = "none";
       document.getElementById("topology-toolbar").style.display = "none";
       currentNodeId = null;
       currentEdgeId = null;
       currentTextId = null;
      });
      (function addDeleteNodeButton() {
       const nodePanel = document.getElementById("node-panel");
       if (!nodePanel) return;
       let deleteBtn = document.getElementById("delete-node-btn");
       if (!deleteBtn) {
        deleteBtn = document.createElement("button");
        deleteBtn.id = "delete-node-btn";
        deleteBtn.textContent = "Delete Node";
        deleteBtn.style.cssText = "margin-top:15px; padding:10px 16px; background:var(--danger); color:#fff; border:none; border-radius:6px; cursor:pointer; font-size:clamp(14px,1.6vw,18px); font-weight:600; width:100%;";
        nodePanel.appendChild(deleteBtn);
       }
       deleteBtn.addEventListener("click", () => {
        if (!currentNodeId) return;
        const nodeData = NODE_DATA[currentNodeId];
        let confirmMessage;
        let nodesInsideRack = [];
        
        if (nodeData?.isRack) {
         nodesInsideRack = Object.entries(NODE_DATA)
          .filter(([id, n]) => n.assignedRack === currentNodeId)
          .map(([id, n]) => n.name || id);
         if (nodesInsideRack.length > 0) {
          confirmMessage = `Delete rack "${nodeData.name}"?\n\nThis will also delete ${nodesInsideRack.length} node(s) inside:\n• ${nodesInsideRack.join('\n• ')}`;
         } else {
          confirmMessage = `Delete rack "${nodeData.name}"? (empty rack)`;
         }
        } else {
         confirmMessage = `Delete node "${nodeData?.name || currentNodeId}" and all its connections?`;
        }
        
        challengeTheImmortal(confirmMessage, () => {
         pushUndo("delete node");
         if (nodeData?.isRack) {
          Object.keys(NODE_DATA).forEach(id => {
           if (NODE_DATA[id]?.assignedRack === currentNodeId) {
            EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== id && e.to !== id);
            delete NODE_DATA[id];
            delete savedPositions[id];
            delete savedSizes[id];
            delete savedStyles[id];
           }
          });
         }
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== currentNodeId && e.to !== currentNodeId);
         delete NODE_DATA[currentNodeId];
         delete savedPositions[currentNodeId];
         delete savedSizes[currentNodeId];
         delete savedStyles[currentNodeId];
         currentNodeId = null;
         currentEdgeId = null;
         forgeTheTopology();
         const remainingNodes = Object.keys(NODE_DATA);
         if (remainingNodes.length > 0) {
          claimTheImmortal(remainingNodes[0]);
         } else {
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("topology-toolbar").style.display = "none";
         }
        });
       });
      })();
      
      function screenshotCanvas() {
       const svg = document.getElementById("map");
       const svgClone = svg.cloneNode(true);
       const viewBox = svg.getAttribute("viewBox").split(" ").map(Number);
       const [x, y, width, height] = viewBox;
       svgClone.setAttribute("width", width);
       svgClone.setAttribute("height", height);
       svgClone.setAttribute("viewBox", `${x} ${y} ${width} ${height}`);
       const wrapper = document.createElement("div");
       wrapper.style.position = "absolute";
       wrapper.style.left = "-9999px";
       wrapper.appendChild(svgClone);
       document.body.appendChild(wrapper);
      
       function inlineStyles(original, clone) {
        const elements = original.querySelectorAll("*");
        const clonedElements = clone.querySelectorAll("*");
        const rootStyles = getComputedStyle(document.documentElement);
        const bgColor = rootStyles.getPropertyValue("--bg").trim() || "#050608";
        const bgRect = document.createElementNS("http://www.w3.org/2000/svg", "rect", );
        bgRect.setAttribute("x", x);
        bgRect.setAttribute("y", y);
        bgRect.setAttribute("width", width);
        bgRect.setAttribute("height", height);
        bgRect.setAttribute("fill", bgColor);
        clone.insertBefore(bgRect, clone.firstChild);
        elements.forEach((el, index) => {
         const clonedEl = clonedElements[index];
         if (!clonedEl) return;
         const computedStyle = getComputedStyle(el);
         const svgProps = ["fill", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin", "opacity", "font-family", "font-size", "font-weight", "font-style", "text-anchor", "dominant-baseline", "marker-start", "marker-end", ];
         svgProps.forEach((prop) => {
          const value = computedStyle.getPropertyValue(prop);
          if (value && value !== "none" && value !== "normal") {
           clonedEl.style[prop] = value;
          }
         });
         clonedEl.removeAttribute("class");
        });
       }
       inlineStyles(svg, svgClone);
       const svgData = new XMLSerializer().serializeToString(svgClone);
       document.body.removeChild(wrapper);
       const svgBlob = new Blob([svgData], {
        type: "image/svg+xml;charset=utf-8",
       });
       const url = URL.createObjectURL(svgBlob);
       const img = new Image();
       img.onload = function() {
        const canvas = document.createElement("canvas");
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext("2d");
        ctx.drawImage(img, 0, 0);
        canvas.toBlob(function(blob) {
         const link = document.createElement("a");
         const timestamp = new Date().toISOString().slice(0, 10);
         link.download = `topology-${timestamp}.png`;
         link.href = URL.createObjectURL(blob);
         link.click();
         URL.revokeObjectURL(url);
         URL.revokeObjectURL(link.href);
        }, "image/png");
       };
       img.onerror = function() {
        console.error("Failed to load SVG image");
        alert("Screenshot failed. Please try again.");
        URL.revokeObjectURL(url);
       };
       img.src = url;
      }
      
      function exportCanvasSVG() {
       const svg = document.getElementById("map");
       const svgClone = svg.cloneNode(true);
       const viewBox = svg.getAttribute("viewBox").split(" ").map(Number);
       const [x, y, width, height] = viewBox;
       svgClone.setAttribute("width", width);
       svgClone.setAttribute("height", height);
       const rootStyles = getComputedStyle(document.documentElement);
       const bgColor = rootStyles.getPropertyValue("--bg").trim() || "#050608";
       const bgRect = document.createElementNS("http://www.w3.org/2000/svg", "rect", );
       bgRect.setAttribute("x", x);
       bgRect.setAttribute("y", y);
       bgRect.setAttribute("width", width);
       bgRect.setAttribute("height", height);
       bgRect.setAttribute("fill", bgColor);
       svgClone.insertBefore(bgRect, svgClone.firstChild);
       const wrapper = document.createElement("div");
       wrapper.style.position = "absolute";
       wrapper.style.left = "-9999px";
       wrapper.appendChild(svgClone);
       document.body.appendChild(wrapper);
       const elements = svg.querySelectorAll("*");
       const clonedElements = svgClone.querySelectorAll("*");
       elements.forEach((el, index) => {
        const clonedEl = clonedElements[index];
        if (!clonedEl) return;
        const computedStyle = getComputedStyle(el);
        const svgProps = ["fill", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin", "opacity", "font-family", "font-size", "font-weight", "font-style", "text-anchor", "dominant-baseline", "marker-start", "marker-end", ];
        svgProps.forEach((prop) => {
         const value = computedStyle.getPropertyValue(prop);
         if (value && value !== "none" && value !== "normal") {
          clonedEl.setAttribute(prop, value);
         }
        });
        clonedEl.removeAttribute("class");
       });
       const svgData = new XMLSerializer().serializeToString(svgClone);
       document.body.removeChild(wrapper);
       const blob = new Blob([svgData], {
        type: "image/svg+xml;charset=utf-8",
       });
       const url = URL.createObjectURL(blob);
       const link = document.createElement("a");
       const timestamp = new Date().toISOString().slice(0, 10);
       link.download = `topology-${timestamp}.svg`;
       link.href = url;
       link.click();
       URL.revokeObjectURL(url);
      }
      let resizeTimeout;
       window.addEventListener('resize', () => {
       clearTimeout(resizeTimeout);
       resizeTimeout = setTimeout(() => {
       updateDrawToolbarVisibility();
       updateTopologyToolbarVisibility();
       }, 100);
      });
    </script>
  
</body></html>