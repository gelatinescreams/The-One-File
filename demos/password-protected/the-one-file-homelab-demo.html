<!DOCTYPE html> 
 <html lang="en" style="--panel: #2f0e0e; --panel-alt: #10141b; --sidebar-bg: #10141b; --btn-bg: #0b0e13; --accent: #a75252; --danger: #f56565; --text-main: #e2e8f0; --text-soft: #94a3b8; --topbar-bg: rgba(9, 12, 20, 0.9); --topbar-border: #1f2533; --topbar-height: 112px; --sidebar-width: 350px; --mobile-footer-height: 40vh; --draw-toolbar-height: 0px; --btn-text: #e2e8f0; --tag-fill: #1e293b; --tag-text: #e2e8f0; --tag-border: #475569; --input-bg: #0b0e13; --input-text: #e2e8f0; --input-border: #1f2937; --input-font: Inter, system-ui, sans-serif; --input-font-size: 14px; --toolbar-bg: #441215; --toolbar-border: #1f2937; --toolbar-text: #94a3b8; --toolbar-btn-bg: #0b0e13; --toolbar-btn-text: #e2e8f0; --minimap-dots: #94a3b8; --canvas-hint-bg: #0f172a; --canvas-hint-color: #94a3b8; --node-fill: #1e293b; --node-stroke: #475569; --node-title: #e2e8f0; --node-sub: #94a3b8; --node-title-size: 18px; --node-sub-size: 13px; --node-font: Inter, system-ui, sans-serif; --default-edge: #475569; --selection-handle: #f59e0b; --selection-handle-size: 8px; --group-indicator: #4fd1c5;"><head>
    <meta charset="UTF-8">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>The One File</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- 
      * ====================================================================================
      * THE ONE FILE
      * "There can be only one". A all in one file topology maker for enterprise or homelab
      * 
      * This is your last backup when all others fail. A completely self-contained
      * network topology visualization tool that works as a single HTML file.
      * Open it anywhere, anytime and the idea lives forever.
      * ====================================================================================
      -->
    <style>
      :root {
      color-scheme: dark;
      --bg: #050608;
      --panel: #0b0e13;
      --panel-alt: #10141b;
      --accent: #4fd1c5;
      --danger: #f56565;
      --text-main: #e2e8f0;
      --text-soft: #94a3b8;
      --edge-main: #475569;
      --node-min: 35px;
      --node-max: 70px;
      --topbar-bg: rgba(9, 12, 20, 0.9);
      --topbar-border: #1f2533;
      }
	  html, body, svg, .map-container {
      touch-action: none;
      }
      * {
      box-sizing: border-box;
      user-select: none;
      }
      input,
      textarea,
      [contenteditable="true"] {
      user-select: text;
      -webkit-user-select: text;
      }
      body {
      margin: 0;
      font-family: system-ui, sans-serif;
      background: radial-gradient(circle at top, #1e2532 0, #050608 70%);
      color: var(--text-main);
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
      }
      header {
      padding: 0 20px;
      height: var(--topbar-height, 52px);
      min-height: var(--topbar-height, 52px);
      background: var(--topbar-bg);
      backdrop-filter: blur(6px);
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid var(--topbar-border);
      gap: 16px;
      }
      .title-block {
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-width: 0;
      }
      header h1 {
      font-size: clamp(22px, 3vw, 32px);
      margin: 0;
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
      }
      .editable-page-title {
      cursor: pointer;
      transition: opacity 0.2s;
      }
      .editable-page-title:hover {
      opacity: 0.7;
      }
      .save-row {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      }
      .save-btn {
      padding: 6px 12px;
      background: var(--accent);
      color: var(--bg);
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      white-space: nowrap;
      }
      .save-btn:hover {
      opacity: 0.9;
      }
      .help-icon {
      width: 22px;
      height: 22px;
      border-radius: 50%;
      border: 1px solid var(--edge-main);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      cursor: pointer;
      color: var(--text-soft);
      background: rgba(15, 23, 42, 0.9);
      flex-shrink: 0;
      }
      .help-icon:hover {
      color: var(--accent);
      border-color: var(--accent);
      }
      #settings-btn {
      background: var(--btn-bg, var(--panel));
      color: var(--btn-text, var(--text-main));
      border: 1px solid var(--edge-main);
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 16px;
      flex-shrink: 0;
      }
      #settings-btn:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .header-resizer {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 6px;
      background: transparent;
      cursor: row-resize;
      z-index: 1000;
      transition: background 0.2s;
      }
      .header-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .header-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      .sidebar-resizer {
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 6px;
      background: transparent;
      cursor: col-resize;
      z-index: 1000;
      transition: background 0.2s;
      }
      .sidebar-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .sidebar-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      .mobile-footer-resizer {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 6px;
      background: transparent;
      cursor: row-resize;
      z-index: 1000;
      transition: background 0.2s;
      display: none;
      }
      .mobile-footer-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .mobile-footer-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      @media (max-width: 900px) {
      .mobile-footer-resizer {
      display: block;
      height: 12px;
      }
      .sidebar-resizer {
      display: none;
      }
      .header-resizer {
      height: 12px;
      }
      }
      @media (pointer: coarse) {
      .header-resizer {
      height: 16px;
      }
      .mobile-footer-resizer {
      height: 16px;
      }
      .sidebar-resizer {
      width: 16px;
      }
      }
      .resizer-icon {
      position: absolute;
      opacity: 0.5;
      transition: opacity 0.2s, transform 0.2s;
      pointer-events: none;
      fill: var(--accent);
      }
      .header-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .sidebar-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .mobile-footer-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .header-resizer:hover .resizer-icon,
      .sidebar-resizer:hover .resizer-icon,
      .mobile-footer-resizer:hover .resizer-icon {
      opacity: 1;
      }
      .header-resizer.resizing .resizer-icon,
      .sidebar-resizer.resizing .resizer-icon,
      .mobile-footer-resizer.resizing .resizer-icon {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1.2);
      }
      body.resizing {
      user-select: none;
      }
      body.resizing * {
      cursor: inherit !important;
      pointer-events: none;
      }
      header {
      position: relative;
      }
      .details-panel {
      position: relative;
      }
      main {
      display: grid;
      grid-template-columns: 1fr var(--sidebar-width, 350px);
      flex: 1;
      }
      main.sidebar-collapsed {
      grid-template-columns: 1fr 0;
      }
      @media (max-width: 900px) {
      main {
      grid-template-columns: 1fr;
      grid-template-rows: calc(100vh - var(--topbar-height, 52px) - var(--mobile-footer-height, 40vh)) var(--mobile-footer-height, 40vh);
      }
      main.sidebar-collapsed {
      grid-template-rows: 1fr 0;
      }
      .details-panel {
      max-height: var(--mobile-footer-height, 40vh);
      height: 100%;
      }
      }
      .topology-panel {
      background: var(--panel);
      border-right: 1px solid #111827;
      position: relative;
      overflow: hidden;
      }
      .topology-toolbar {
      position: absolute;
      top: 10px;
      right: 10px;
      display: none;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      z-index: 99;
      font-size: 13px;
      color: var(--toolbar-text, #94a3b8);
      }
      .topology-toolbar label {
      color: var(--toolbar-text, var(--text-soft));
      }
      .topology-toolbar select {
      padding: 4px 6px;
      background: var(--toolbar-btn-bg, var(--panel));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 13px;
      cursor: pointer;
      }
      .topology-toolbar button {
      padding: 4px 10px;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      }
      .topology-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .bulk-toolbar-desktop,
      .bulk-toolbar-mobile {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 9999;
      }
      .bulk-toolbar-desktop {
      position: absolute;
      top: 10px;
      right: 10px;
      bottom: auto;
      left: auto;
      transform: none;
      }
      @media (min-width: 768px) {
      .bulk-toolbar-mobile {
      display: none !important;
      }
      }	  
      .bulk-action-btn {
      padding: 16px;
      background: var(--panel-main);
      border: 1px solid var(--edge-main);
      border-radius: 8px;
      color: var(--text-main);
      font-size: 24px;
      cursor: pointer;
      text-align: center;
      line-height: 1.2;
      }
      .bulk-action-btn:active {
      transform: scale(0.95);
      background: var(--accent);
      }
      .draw-toolbar {
      position: absolute;
      top: 10px;
      left: 10px;
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 8px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      z-index: 99;
      font-size: 13px;
      pointer-events: auto;
      color: var(--toolbar-text, #94a3b8);
      }
      .draw-toolbar button {
      padding: 4px 8px;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      }
      .draw-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .draw-toolbar input[type="color"] {
      width: 30px;
      height: 22px;
      border-radius: 4px;
      border: 1px solid var(--edge-main);
      padding: 0;
      background: transparent;
      cursor: pointer;
      }
      .draw-toolbar select {
      padding: 4px 6px;
      background: var(--toolbar-btn-bg, var(--panel));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 13px;
      cursor: pointer;
      }
      .legend-container {
      position: absolute;
      left: 10px;
      bottom: 10px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      padding: 8px 10px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      font-size: 12px;
      z-index: 20;
      max-width: 260px;
      pointer-events: auto;
      color: var(--toolbar-text, #94a3b8);
      }
      .legend-container {
      padding-right: 22px;
      }
      @media (max-width: 900px) {
      .legend-container {
      height:250px;
      overflow-y: auto;
      z-index:99;
      }
      }
      @media (max-width: 900px) {
      .bulk-toolbar-desktop,
      .topology-toolbar {
      display: none !important;
      }
      }
      .legend-close-btn {
      position: absolute;
      top: 5px;
      right: 5px;
      width: 18px;
      height: 18px;
      border-radius: 999px;
      border: 1px solid var(--edge-main);
      background: var(--panel-alt);
      color: var(--text-soft);
      font-size: 11px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      }
      .legend-close-btn:hover {
      background: var(--danger);
      color: #fff;
      }
      .legend-mini-btn {
      position: absolute;
      left: 10px;
      padding: 4px 8px;
      border-radius: 4px;
      border: 1px solid var(--toolbar-border, #1f2937);
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 11px;
      cursor: pointer;
      z-index: 20;
      display: none;
      transition: all 0.2s;
      }
      .legend-mini-btn:hover,
      .legend-mini-btn:active {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
      }
      .legend-title {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: var(--toolbar-text, var(--text-soft));
      margin-bottom: 2px;
      }
      .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      }
      .legend-swatch {
      width: 14px;
      height: 14px;
      border-radius: 3px;
      border: 1px solid #020617;
      flex-shrink: 0;
      }
      .legend-label {
      outline: none;
      cursor: text;
      flex: 1;
      min-width: 60px;
      user-select: text;
      -webkit-user-select: text;
      }
      .legend-label.editing {
      border-bottom: 1px dashed var(--accent);
      }
      .canvas-viewport {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      overflow: hidden;
      }
      .canvas-viewport.panning {
      cursor: grabbing !important;
      }
      .canvas-viewport.panning * {
      cursor: grabbing !important;
      }
      .canvas-viewport svg {
      width: 100%;
      height: 100%;
      display: block;
      background: linear-gradient(rgba(71, 85, 105, 0.1) 1px,
      transparent 1px),
      linear-gradient(90deg,
      rgba(71, 85, 105, 0.1) 1px,
      transparent 1px),
      linear-gradient(rgba(71, 85, 105, 0.05) 1px, transparent 1px),
      linear-gradient(90deg,
      rgba(71, 85, 105, 0.05) 1px,
      transparent 1px);
      background-size:
      100px 100px,
      100px 100px,
      20px 20px,
      20px 20px;
      background-position:
      -1px -1px,
      -1px -1px,
      -1px -1px,
      -1px -1px;
      }
      .zoom-toolbar {
      display: flex;
      gap: 4px;
      padding: 6px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      }
      .zoom-toolbar button {
      width: 32px;
      height: 32px;
      padding: 0;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 18px;
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
      }
      .zoom-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .zoom-toolbar .zoom-level {
      font-size: 11px;
      color: var(--toolbar-text, var(--text-soft));
      text-align: center;
      padding: 2px 0;
      min-width: 32px;
      }
      .zoom-toolbar .divider {
      height: 1px;
      background: var(--toolbar-border, var(--edge-main));
      margin: 2px 0;
      }
      .minimap-zoom-wrapper {
      position: absolute;
      bottom: 10px;
      right: 10px;
      z-index: 99;
      }
      .minimap-container {
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      overflow: hidden;
      margin-bottom: 4px;
      }
      .minimap-container svg {
      width: 100%;
      height: 100%;
      }
      .minimap-viewport {
      fill: rgba(79, 209, 197, 0.2);
      stroke: var(--accent);
      stroke-width: 2;
      cursor: move;
      }
      .minimap-node {
      fill: var(--minimap-dots, var(--text-soft));
      }
      .minimap-edge {
      stroke: var(--edge-main);
      stroke-width: 1;
      }
      .minimap-close-btn {
      position: absolute;
      top: 2px;
      right: 2px;
      width: 18px;
      height: 18px;
      background: var(--toolbar-btn-bg, rgba(15, 23, 42, 0.9));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 3px;
      color: var(--toolbar-text, var(--text-soft));
      font-size: 11px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
      padding: 0;
      line-height: 1;
      }
      .minimap-close-btn:hover {
      background: var(--danger);
      color: white;
      border-color: var(--danger);
      }
      .toolbar-close-btn {
      width: 24px;
      height: 24px;
      background: var(--toolbar-btn-bg, rgba(15, 23, 42, 0.9));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-text, var(--text-soft));
      font-size: 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      line-height: 1;
      flex-shrink: 0;
      }
      .toolbar-close-btn:hover {
      background: var(--danger);
      color: white;
      border-color: var(--danger);
      }
      .canvas-hint {
      position: absolute;
      top: 50px;
      left: 50%;
      transform: translateX(-50%);
      padding: 8px 16px;
      background: rgba(15, 23, 42, 0.92);
      border: 1px solid #1f2937;
      border-radius: 6px;
      font-size: 12px;
      color: var(--text-soft);
      z-index: 18;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
      }
      .canvas-hint.visible {
      opacity: 1;
      }
      .edge {
      stroke: var(--edge-main);
      stroke-width: 4;
      opacity: 0.75;
      transition: 0.25s ease-in-out;
      cursor: pointer;
      }
      .edge.backup {
      stroke: var(--danger);
      stroke-width: 5;
      }
      .edge.active {
      opacity: 1;
      stroke-width: 7;
      filter: drop-shadow(0 0 8px var(--accent, #4fd1c5));
      }
      .rect-group.active .rect-shape {
      filter: drop-shadow(0 0 10px var(--accent, #4fd1c5));
      animation: pulse 1.2s infinite ease-in-out;
      }
      .text-element.active {
      filter: drop-shadow(0 0 10px var(--accent, #4fd1c5));
      animation: pulse 1.2s infinite ease-in-out;
      }
      .free-preview {
      fill: none;
      stroke-dasharray: 4 4;
      pointer-events: none;
      }
      .free-point {
      fill: #e5e7eb;
      stroke: #0f172a;
      stroke-width: 1.5;
      cursor: grab;
      }
      .node-circle {
      fill: var(--node-fill, #1e293b);
      stroke: var(--node-stroke, #475569);
      stroke-width: 2;
      transition: 0.25s ease;
      transform-origin: center center;
      }
      .node-hit-area {
      cursor: grab;
      pointer-events: all;
      }
      .node-group:hover .node-circle {
      filter: drop-shadow(0 0 10px rgba(79, 209, 197, 0.45));
      }
      .node-group.active .node-circle {
      stroke: var(--accent);
      animation: pulse 1.2s infinite ease-in-out;
      }
      .node-group.selected .node-circle {
      stroke: var(--selection-handle, #f59e0b);
      stroke-width: 3;
      }
      .node-group.search-highlight .node-circle {
      stroke: #10b981;
      stroke-width: 3;
      filter: drop-shadow(0 0 8px #10b981);
      }
      @keyframes pulse {
      0% {
      filter: drop-shadow(0 0 4px #4fd1c5);
      }
      50% {
      filter: drop-shadow(0 0 14px #4fd1c5);
      }
      100% {
      filter: drop-shadow(0 0 4px #4fd1c5);
      }
      }
      .node-label {
      fill: var(--text-main);
      font-size: 18px;
      text-anchor: middle;
      font-weight: 600;
      }
      .node-sub {
      fill: var(--text-soft);
      font-size: 13px;
      text-anchor: middle;
      }
      @media (max-width: 1024px) {
      .node-label {
      font-size: 28px;
      }
      .node-sub {
      font-size: 20px;
      }
      }
      @media (max-width: 768px) {
      .node-label {
      font-size: 70px;
      }
      .node-sub {
      font-size: 50px;
      }
      }
      @media (max-width: 380px) {
      .node-label {
      font-size: 60px;
      }
      .node-sub {
      font-size: 42px;
      }
      }
      .details-panel {
      background: var(--sidebar-bg, var(--panel-alt));
      padding: 22px;
      padding-bottom: 80px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 15px;
      position: relative;
      transition:
      width 0.3s ease,
      min-width 0.3s ease,
      padding 0.3s ease,
      opacity 0.3s ease;
      }
      .details-panel {
      min-width: 260px !important;
      }
      .details-panel {
      overflow-y: auto !important;
      overflow-x: hidden;
      }
      .details-panel.collapsed {
      width: 0 !important;
      min-width: 0 !important;
      padding: 0 !important;
      overflow: hidden;
      opacity: 0;
      }
      body {
      overflow-x: hidden;
      overflow-y: hidden;
      }
      main {
      overflow-x: hidden;
      overflow-y: visible;
      }
      .details-panel {
      overflow-y: auto !important;
      overflow-x: hidden;
      }
      .details-panel.collapsed {
      min-width: 0 !important;
      }
      .sidebar-toggle {
      position: absolute;
      left: -16px;
      top: 50%;
      transform: translateY(-50%);
      width: 16px;
      height: 60px;
      background: var(--sidebar-bg, var(--panel-alt));
      border: 1px solid var(--edge-main);
      border-right: none;
      border-radius: 8px 0 0 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text-soft);
      font-size: 10px;
      z-index: 25;
      transition:
      background 0.2s,
      color 0.2s;
      }
      .sidebar-toggle:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .sidebar-toggle.collapsed {
      left: 0;
      border-right: 1px solid var(--edge-main);
      border-radius: 0 8px 8px 0;
      position: fixed;
      right: 0;
      left: auto;
      }
      .details-name {
      font-size: clamp(22px, 2.5vw, 30px);
      font-weight: 700;
      }
      .details-ip {
      font-size: clamp(16px, 2vw, 22px);
      color: var(--text-soft);
      }
      .details-role {
      font-size: clamp(16px, 2vw, 22px);
      color: var(--accent);
      }
      .details-info-row {
      display: flex;
      align-items: center;
      margin: 6px 0;
      }
      .size-controls {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-top: 10px;
      }
      .size-controls label {
      font-size: clamp(14px, 1.6vw, 18px);
      color: var(--text-soft);
      }
      .size-controls input[type="range"] {
      flex: 1;
      accent-color: var(--accent);
      }
      .size-controls button {
      padding: 6px 12px;
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      font-size: clamp(12px, 1.4vw, 16px);
      }
      .size-controls button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .style-section {
      margin-top: 15px;
      padding-top: 15px;
      border-top: 1px solid var(--edge-main);
      }
      .style-section summary {
      cursor: pointer;
      font-size: clamp(14px, 1.6vw, 20px);
      text-transform: uppercase;
      color: var(--text-soft);
      list-style: none;
      display: flex;
      justify-content: space-between;
      align-items: center;
      user-select: none;
      }
      .style-section summary::-webkit-details-marker {
      display: none;
      }
      .password-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #ffffff;
      z-index: 9999;
      }
      .style-section summary::after {
      content: "▼";
      transition: transform 0.2s;
      }
      .style-section[open] summary::after {
      transform: rotate(180deg);
      }
      .style-content {
      margin-top: 10px;
      }
      .style-row {
      display: flex;
      gap: 10px;
      align-items: center;
      margin: 8px 0;
      }
      .style-row label {
      font-size: clamp(13px, 1.5vw, 17px);
      color: var(--text-soft);
      min-width: 80px;
      }
      .style-row input[type="color"] {
      width: 50px;
      height: 30px;
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      background: transparent;
      }
      .style-row input[type="number"] {
      width: 70px;
      padding: 4px 8px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(12px, 1.4vw, 16px);
      }
      .style-row select {
      flex: 1;
      padding: 4px 8px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(12px, 1.4vw, 16px);
      cursor: pointer;
      }
      .editable-text {
      cursor: pointer;
      transition: opacity 0.2s;
      }
      .editable-text:hover {
      opacity: 0.7;
      }
      .modal {
	  display: none;
	  position: fixed;
	  top: 0;
	  left: 0;
	  width: 100%;
	  height: 100%;
	  z-index: 999999;
	  justify-content: center;
	  align-items: center;
	  overflow: auto;
	  }
	  .modal.active {
	  display: inline-grid;
	  }
	  .modal-content {
	  background: var(--panel-alt);
	  padding: 25px;
	  border-radius: 8px;
	  border: 1px solid var(--edge-main);
	  min-width: 300px;
	  max-width: 90%;
	  }
      .modal-content h3 {
      margin: 0 0 15px 0;
      color: var(--text-main);
      font-size: clamp(18px, 2vw, 24px);
      }
      .modal-content p {
      color: var(--text-soft);
      font-size: clamp(14px, 1.6vw, 18px);
      margin: 0 0 20px 0;
      }
      .modal-content input:not([type="color"]),
      .modal-content select {
      width: 100%;
      padding: 10px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(14px, 1.6vw, 18px);
      margin-bottom: 15px;
      user-select: text;
      -webkit-user-select: text;
      }
      .modal-content input[type="color"] {
      width: 60px;
      height: 36px;
      padding: 2px;
      border: 2px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      background: none;
      -webkit-appearance: none;
      appearance: none;
      }
      .modal-content input[type="color"]::-webkit-color-swatch-wrapper {
      padding: 0;
      }
      .modal-content input[type="color"]::-webkit-color-swatch {
      border: none;
      border-radius: 4px;
      }
      .modal-buttons {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
      margin-top: 10px;
      }
      .modal-buttons button {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: clamp(14px, 1.6vw, 18px);
      font-weight: 600;
      }
      .modal-buttons .btn-cancel {
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      }
      .modal-buttons .btn-save {
      background: var(--accent);
      color: var(--bg);
      }
      .modal-buttons .btn-delete {
      background: var(--danger);
      color: white;
      }
      .confirm-modal p {
      color: var(--text-soft);
      font-size: clamp(14px, 1.6vw, 18px);
      margin: 0 0 20px 0;
      }
      .context-menu-item {
      transition: background 0.15s;
      }
      .context-menu-item:hover {
      background: var(--panel);
      }
      .badge-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      }
      .badge {
      background: var(--tag-fill, #1e293b);
      color: var(--tag-text, #e2e8f0);
      border: 1px solid var(--tag-border, var(--edge-main));
      padding: 5px 12px;
      border-radius: 22px;
      font-size: clamp(12px, 1.4vw, 18px);
      }
      .badge.wg {
      color: var(--accent);
      border-color: var(--accent);
      }
      input[type="text"],
      input[type="number"],
      input[type="password"],
      textarea,
      select {
      background: var(--input-bg, #0b0e13) !important;
      color: var(--input-text, #e2e8f0) !important;
      border-color: var(--input-border, #1f2937) !important;
      font-family: var(--input-font, Inter, system-ui, sans-serif) !important;
      font-size: var(--input-font-size, 14px) !important;
      }
      .section-label {
      margin-top: 8px;
      font-size: clamp(14px, 1.6vw, 20px);
      text-transform: uppercase;
      color: var(--text-soft);
      }
      .list li {
      margin: 6px 0;
      font-size: clamp(14px, 1.6vw, 20px);
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      }
      .list li:hover {
      color: var(--accent);
      }
      .delete-note {
      color: var(--danger);
      font-size: 18px;
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.2s;
      flex-shrink: 0;
      }
      .list li:hover .delete-note {
      opacity: 1;
      }
      .editing {
      outline: 2px solid var(--accent);
      background: #0d141f;
      padding: 4px;
      border-radius: 6px;
      user-select: text;
      -webkit-user-select: text;
      }
      .version-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .version-item:hover {
      background: var(--panel-alt);
      border-color: var(--accent);
      }
      .version-item.current {
      border-color: var(--accent);
      background: rgba(79, 209, 197, 0.1);
      }
      .version-info {
      flex: 1;
      }
      .version-info .timestamp {
      font-size: 13px;
      color: var(--text-main);
      font-weight: 600;
      }
      .version-info .details {
      font-size: 11px;
      color: var(--text-soft);
      margin-top: 4px;
      }
      .version-actions {
      display: flex;
      gap: 6px;
      }
      .audit-entry {
      padding: 8px 12px;
      background: var(--panel);
      border-left: 3px solid var(--edge-main);
      border-radius: 4px;
      font-size: 12px;
      }
      .audit-entry.node { border-left-color: #4fd1c5; }
      .audit-entry.connection { border-left-color: #9f7aea; }
      .audit-entry.style { border-left-color: #ed8936; }
      .audit-entry.rack { border-left-color: #48bb78; }
      .audit-entry.layer { border-left-color: #4299e1; }
      .audit-entry .time {
      color: var(--text-soft);
      font-size: 10px;
      }
      .audit-entry .action {
      color: var(--text-main);
      font-weight: 500;
      }
      .tab-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .tab-item:hover {
      background: var(--panel-alt);
      }
      .tab-item.active {
      border-color: var(--accent);
      background: rgba(79, 209, 197, 0.1);
      }
      .tab-item .tab-name {
      font-weight: 600;
      color: var(--text-main);
      flex: 1;
      }
      .tab-item .tab-stats {
      font-size: 11px;
      color: var(--text-soft);
      margin-right: 10px;
      }
      .tab-actions {
      display: flex;
      gap: 6px;
      }    
      .secret-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      border-left: 3px solid var(--danger);
      }
      .secret-item .secret-name {
      font-weight: 600;
      color: var(--text-main);
      flex: 1;
      }
      .secret-item .secret-status {
      font-size: 11px;
      color: var(--text-soft);
      margin-right: 10px;
      }    
      .mobile-menu-btn {
      display: none;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      color: var(--text-main);
      font-size: 22px;
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      }
      #topbar-menu {
      gap: 8px;
      }
      @media (min-width: 721px) {
      #topbar-menu {
      display: flex !important;
      }
      }
      @media (max-width: 720px) {
      #topbar-menu {
      display: none;
      }
      #topbar-menu.open {
      display: flex;
      }
      }
      @media (max-width: 720px) {
      .mobile-menu-btn {
      display: block;
      }
      #topbar-menu {
      position: absolute;
      top: var(--topbar-height);
      right: 0;
      background: var(--panel-alt);
      border-left: 1px solid var(--topbar-border);
      border-bottom: 1px solid var(--topbar-border);
      padding: 12px;
      display: none;
      flex-direction: column;
      width: 180px;
      z-index: 999;
      }
      #topbar-menu.open {
      display: flex;
      }
      header {
      position: relative;
      z-index: 9999;
      }
      }
      @media (max-width: 720px) {
      .draw-toolbar {
      position: absolute;
      top: auto;
      bottom: auto;
      left: 10px !important;
      right: auto !important;
      width: auto;
      gap: 6px;
      padding: 8px;
      }
      .topology-toolbar {
      position: absolute;
      top: auto;
      bottom: auto;
      width: auto;
      gap: 6px;
      padding: 8px;
      }
      .draw-toolbar {
      top: 10px !important;
      z-index:99;
      }
      .topology-toolbar {
      z-index:99;
      top: calc(10px + var(--draw-toolbar-height, 50px)) !important;
      }
      .canvas-hint {
      top: calc(10px + 120px);
      }
      #search-input {
      width: 100%;
      }
      }
	  body.view-only-mode:not(.view-only-inspect) #node-panel,
      body.view-only-mode:not(.view-only-inspect) #edge-panel,
      body.view-only-mode:not(.view-only-inspect) #text-panel,
      body.view-only-mode:not(.view-only-inspect) #rect-panel {
        display: none !important;
      }
      body.view-only-mode .node-group,
      body.view-only-mode .edge,
      body.view-only-mode .rect-group,
      body.view-only-mode .text-element {
        cursor: default !important;
      }
      body.view-only-mode #bulk-toolbar,
      body.view-only-mode #bulk-toolbar-mobile,
      body.view-only-mode #bulk-actions-modal {
        display: none !important;
      }
      body.view-only-mode::after {
        content: "VIEW ONLY • tap 5× to inspect";
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(245, 101, 101, 0.9);
        color: white;
        padding: 6px 16px;
        border-radius: 20px;
        font-size: 12px;
        font-weight: 600;
        letter-spacing: 1px;
        z-index: 9999;
        pointer-events: none;
      }
    </style>
  </head>
  <body style="background: radial-gradient(circle at center top, rgb(30, 37, 50) 0px, rgb(5, 6, 8) 70%);" class="">
    <div class="modal" id="edit-modal">
      <div class="modal-content">
        <h3 id="modal-title">Edit Title</h3>
        <input type="text" id="modal-input">
        <div class="modal-buttons">
          <button class="btn-cancel" id="modal-cancel">Cancel</button>
          <button class="btn-save" id="modal-save">Save</button>
        </div>
      </div>
    </div>
    <div class="modal confirm-modal" id="confirm-modal">
      <div class="modal-content">
        <h3>Confirm</h3>
        <p id="confirm-message"> Are you sure you want to delete this line? </p>
        <div class="modal-buttons">
          <button class="btn-cancel" id="confirm-cancel">Cancel</button>
          <button class="btn-delete" id="confirm-delete">Delete</button>
        </div>
      </div>
    </div>
    <div class="modal" id="save-info-modal">
      <div class="modal-content" style="max-width: 700px; max-height: 80vh; overflow-y: auto;">
        <h3 style="margin-bottom: 16px;">Help</h3>
        <div style="display: flex; gap: 8px; margin-bottom: 16px; flex-wrap: wrap;">
          <button class="help-tab active" data-tab="general" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--accent); color: var(--bg); border-radius: 6px; cursor: pointer; font-weight: 600;">General</button>
          <button class="help-tab" data-tab="desktop" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--panel); color: var(--text-main); border-radius: 6px; cursor: pointer; font-weight: 600;">Desktop</button>
          <button class="help-tab" data-tab="mobile" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--panel); color: var(--text-main); border-radius: 6px; cursor: pointer; font-weight: 600;">Mobile</button>
        </div>
        <div id="help-tab-general" class="help-tab-content" style="display: block;">
          <ul style="margin-left: 20px; margin-bottom: 12px; line-height: 1.8;">
            <li><strong>Add Nodes:</strong> Click "+ Node" or "+ Rack" in the top menu</li>
            <li><strong>Connect Nodes:</strong> Select a node, then use "Add Connection" in the panel</li>
            <li><strong>Move Nodes:</strong> Drag nodes to reposition them</li>
            <li><strong>Enter Rack View:</strong> Double click on desktop or Long press on mobile</li>
            <li><strong>Multi Select:</strong> Right click (desktop) or double tap (mobile)</li>
            <li><strong>Pan Canvas:</strong> Drag empty space or hold Space + drag</li>
            <li><strong>Zoom:</strong> Scroll wheel or pinch gesture</li>
            <li><strong>Free Draw:</strong> Use draw toolbar for drawing lines, boxes/zones , and text</li>
          </ul>
          <h4 style="color: var(--accent); margin-bottom: 8px;">Saving &amp; Encryption</h4>
          <p style="margin-bottom: 8px;">Browsers cannot overwrite local files. Click <strong>Save File</strong> to download an updated HTML with all changes. Replace your old file to keep edits.</p>
          <p style="margin-bottom: 8px;"><strong>Encryption of data:</strong> Check "Encrypt" before saving to password protect your data. Beware! No recovery possible without password!!</p>
          <p><strong>Decryption of data:</strong> Export via JSON in top settings menu after successful password validation to decrypt your data. You can then reimport back into the same file and save!</p>
        </div>
        <div id="help-tab-desktop" class="help-tab-content" style="display: none;">
          <h4 style="color: var(--accent); margin-bottom: 12px;">Navigation</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Arrow Keys</code></td>
              <td style="padding: 8px;">Move selected 1px</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Shift + Arrows</code></td>
              <td style="padding: 8px;">Move selected 10px</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Tab / Shift+Tab</code></td>
              <td style="padding: 8px;">Cycle through nodes</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">F</code></td>
              <td style="padding: 8px;">Focus on selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Space + Drag</code></td>
              <td style="padding: 8px;">Pan canvas</td>
            </tr>
          </tbody></table>
          <h4 style="color: var(--accent); margin-bottom: 12px;">Management</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">L</code></td>
              <td style="padding: 8px;">Lock/unlock selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">G</code></td>
              <td style="padding: 8px;">Group/ungroup selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+C / Ctrl+V</code></td>
              <td style="padding: 8px;">Copy / Paste</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+D</code></td>
              <td style="padding: 8px;">Duplicate</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+A</code></td>
              <td style="padding: 8px;">Select all</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Delete</code></td>
              <td style="padding: 8px;">Delete selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Escape</code></td>
              <td style="padding: 8px;">Clear selection</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+Z / Ctrl+Y</code></td>
              <td style="padding: 8px;">Undo / Redo</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Right Click</code></td>
              <td style="padding: 8px;">Multi select toggle</td>
            </tr>
          </tbody></table>
        </div>
        <div id="help-tab-mobile" class="help-tab-content" style="display: none;">
          <h4 style="color: var(--accent); margin-bottom: 12px;">Basic Gestures</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Tap node</strong></td>
              <td style="padding: 8px;">Select &amp; open properties</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Tap empty</strong></td>
              <td style="padding: 8px;">Deselect all</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Drag node</strong></td>
              <td style="padding: 8px;">Move node</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Drag empty</strong></td>
              <td style="padding: 8px;">Pan canvas</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Pinch</strong></td>
              <td style="padding: 8px;">Zoom in/out</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Double-tap node</strong></td>
              <td style="padding: 8px;">Add/remove from selection</td>
            </tr>
          </tbody></table>
          <h4 style="color: var(--accent); margin-bottom: 12px;">Rack View</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Long-press rack</strong></td>
              <td style="padding: 8px;">Enter rack view</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Double-tap empty</strong></td>
              <td style="padding: 8px;">Exit rack view</td>
            </tr>
          </tbody></table>
        </div>
        <div class="modal-buttons" style="margin-top: 16px;">
          <button class="btn-cancel" id="save-info-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="settings-modal">
      <div class="modal-content">
        <h2>Settings</h2>
		<details class="style-section">
          <summary>View Only Mode</summary>
          <div class="style-content">
            <div class="style-row">
              <label>View Only (disable editing)</label>
              <input type="checkbox" id="view-only-mode" style="width:auto;">
            </div>
            <p style="margin-top:4px;font-size:12px;color:var(--text-soft);">When enabled, all editing of the canvas is disabled. Pan and zoom still work.</p>
          </div>
        </details>
        <details class="style-section">
          <summary>General Theme</summary>
          <div class="style-content">
		    <div class="style-row">
              <label>Main Background</label>
              <input type="color" id="panel-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Modal Window (popup) Background</label>
              <input type="color" id="panel-alt-color" value="#10141b">
            </div>
            <div class="style-row">
              <label>Accent Buttons</label>
              <input type="color" id="accent-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Danger Buttons</label>
              <input type="color" id="danger-color" value="#f56565">
            </div>
            <div class="style-row">
              <label>Primary Text</label>
              <input type="color" id="text-main-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Secondary Text</label>
              <input type="color" id="text-soft-color" value="#94a3b8">
            </div>
          </div>
        </details>
		<details class="style-section">
          <summary>Top Bar</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="topbar-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="topbar-border-color" value="#1f2533">
            </div>
          </div>
		  <div class="style-content">
            <div class="style-row">
              <label>Button Fill</label>
              <input type="color" id="btn-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Button Text</label>
              <input type="color" id="btn-text-color" value="#e2e8f0">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Main Canvas</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="canvas-border-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Grid Lines</label>
              <input type="color" id="canvas-grid-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Grid Size</label>
              <input type="number" id="canvas-grid-size" value="50" min="20" max="200" style="width:60px;">
            </div>
			<div class="style-row">
              <label>Background Top</label>
              <input type="color" id="canvas-gradient-top" value="#1e2532">
            </div>
            <div class="style-row">
              <label>Background Bottom</label>
              <input type="color" id="canvas-gradient-bottom" value="#050608">
            </div>
            <div class="style-row">
              <label>Solid Background</label>
              <input type="color" id="page-bg-color" value="#050608">
            </div>
            <p style="margin-top:4px;font-size:12px;color:var(--text-soft);">Set solid background to override gradient.</p>
          </div>
			</details>
		  <details class="style-section">
          <summary>Rack Canvas</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Frame Fill</label>
              <input type="color" id="rack-frame-fill" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Frame Border</label>
              <input type="color" id="rack-frame-stroke" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Grid Lines</label>
              <input type="color" id="rack-line-color" value="#475569">
            </div>
            <div class="style-row">
              <label>U Labels</label>
              <input type="color" id="rack-text-color" value="#4fd1c5">
            </div>
          </div>
        </details>
		        <details class="style-section">
          <summary>Canvas Toolbars</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="toolbar-bg-color" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="toolbar-border-color" value="#1f2937">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="toolbar-text-color" value="#94a3b8">
            </div>
            <div class="style-row">
              <label>Button Fill</label>
              <input type="color" id="toolbar-btn-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Button Text</label>
              <input type="color" id="toolbar-btn-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Minimap Dots</label>
              <input type="color" id="minimap-dots-color" value="#94a3b8">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Nodes</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Fill</label>
              <input type="color" id="node-fill-color" value="#1e293b">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="node-stroke-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Title Color</label>
              <input type="color" id="node-title-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Title Size</label>
              <input type="number" id="node-title-size" value="18" min="8" max="48" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Subtitle Color</label>
              <input type="color" id="node-sub-color" value="#94a3b8">
            </div>
            <div class="style-row">
              <label>Subtitle Size</label>
              <input type="number" id="node-sub-size" value="13" min="8" max="48" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Font</label>
              <select id="node-font-family" style="flex:1;padding:4px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;">
                <option value="Inter, system-ui, sans-serif">Inter</option>
                <option value="Arial, sans-serif">Arial</option>
                <option value="Helvetica, sans-serif">Helvetica</option>
                <option value="Georgia, serif">Georgia</option>
                <option value="monospace">Monospace</option>
              </select>
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Connections</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Default Color</label>
              <input type="color" id="default-edge-color" value="#475569">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Groups &amp; Editing</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Resize handle Color</label>
              <input type="color" id="selection-handle-color" value="#f59e0b">
            </div>
            <div class="style-row">
              <label>Resize Handle Size</label>
              <input type="number" id="selection-handle-size" value="8" min="4" max="16" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Grouped Icon Outline</label>
              <input type="color" id="group-indicator-color" value="#4fd1c5">
            </div>
          </div>
		   <div class="style-content">
            <div class="style-row">
              <label>Multiselect Fill Color (Desktop)</label>
              <input type="color" id="selection-fill-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Multiselect Fill Opacity (Desktop)</label>
              <input type="range" id="selection-fill-opacity" min="0" max="1" step="0.05" value="0.1">
              <span id="selection-fill-opacity-val" style="min-width:35px;text-align:right;">10%</span>
            </div>
            <div class="style-row">
              <label>Multiselect Border Color (Desktop)</label>
              <input type="color" id="selection-stroke-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Multiselect Border Width (Desktop)</label>
              <input type="number" id="selection-stroke-width" min="1" max="10" value="2">
            </div>
            <div class="style-row">
              <label>Multiselect Border Style (Desktop)</label>
              <select id="selection-stroke-style">
                <option value="5,5">Dashed</option>
                <option value="2,4">Dotted</option>
                <option value="none">Solid</option>
              </select>
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Inputs &amp; Dropdowns</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="input-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="input-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="input-border-color" value="#1f2937">
            </div>
            <div class="style-row">
              <label>Font</label>
              <select id="input-font-family" style="flex:1;padding:4px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;">
                <option value="Inter, system-ui, sans-serif">Inter</option>
                <option value="Arial, sans-serif">Arial</option>
                <option value="Helvetica, sans-serif">Helvetica</option>
                <option value="Georgia, serif">Georgia</option>
                <option value="monospace">Monospace</option>
              </select>
            </div>
            <div class="style-row">
              <label>Font Size</label>
              <input type="number" id="input-font-size" value="14" min="10" max="24" style="width:60px;">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Welcome Message</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Enabled</label>
              <input type="checkbox" id="canvas-hint-enabled" checked="" style="width:auto;">
            </div>
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="canvas-hint-bg-color" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Text Color</label>
              <input type="color" id="canvas-hint-text-color" value="#94a3b8">
            </div>
            <div class="style-row" style="flex-direction:column;align-items:stretch;">
              <label>Custom Text (HTML)</label>
              <textarea id="canvas-hint-text" rows="4" style="width:100%;margin-top:4px;padding:6px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;font-size:12px;resize:vertical;" placeholder="Leave empty for default"></textarea>
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Sidebar / Mobile Footer</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="sidebar-bg-color" value="#10141b">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Tags</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Fill</label>
              <input type="color" id="tag-fill-color" value="#1e293b">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="tag-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="tag-border-color" value="#475569">
            </div>
          </div>
        </details>
        <details class="style-section" open="">
          <summary>Import / Export / Upgrade JSON</summary>
          <div class="style-content">
            <button id="export-data-btn" style="width:100%;margin-bottom:10px;padding:10px;background:var(--accent);color:var(--bg);border:none;border-radius:6px;cursor:pointer;font-size:14px;font-weight:600;">Export JSON</button>
            <button id="import-data-btn" style="width:100%;padding:10px;background:var(--panel);color:var(--text-main);border:1px solid var(--edge-main);border-radius:6px;cursor:pointer;font-size:14px;font-weight:600;">Import JSON</button>
            <input type="file" id="import-data-file" accept=".json" style="display:none">
          </div>
        </details>
        <details class="style-section" open="">
          <summary>Danger Zone</summary>
          <div class="style-content">
            <p style="margin-bottom:12px;font-size:13px;color:var(--text-soft);">Permanently delete everything on the canvas.</p>
            <button id="clear-all-btn" title="Clear all nodes" style="padding:6px 12px;background:var(--danger);color:#fff;border:none;border-radius:6px;cursor:pointer;font-size:14px;font-weight:600;">Clear All</button>
            <input type="file" id="import-data-file" accept=".json" style="display:none">
          </div>
        </details>
        <div class="modal-buttons">
          <button class="btn-cancel" id="settings-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="add-node-modal">
      <div class="modal-content">
        <h3>Add New Node</h3>
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Name</label>
        <input type="text" id="new-node-name" placeholder="e.g. web-server">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">IP / Subtitle</label>
        <input type="text" id="new-node-ip" placeholder="e.g. 192.168.1.100">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Tags (comma separated)</label>
        <input type="text" id="new-node-tags" placeholder="e.g. Docker, nginx, WG: vpn">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Shape</label>
        <select id="new-node-shape">
                  <optgroup label="Basic Shapes">
				  <option value="circle">Circle</option>
				  <option value="square">Square</option>
				  <option value="rectangle">Rectangle</option>
				  <option value="triangle">Triangle</option>
				  <option value="hexagon">Hexagon</option>
				  <option value="diamond">Diamond</option>
				  <option value="star">Star</option>
				  <option value="stop-sign">Stop Sign</option>
				  <option value="octagon">Octagon</option>
				  <option value="pentagon">Pentagon</option>
				  <option value="cross">Cross</option>
				  <option value="rounded-square">Rounded Square</option>
				  <option value="pill">Pill</option>
				  <option value="parallelogram">Parallelogram</option>
				  <option value="trapezoid">Trapezoid</option>
				</optgroup>
			  <optgroup label="Computers &amp; Devices">
			      <option value="server">Server</option>
				  <option value="pc">PC / Desktop</option>
				  <option value="laptop">Laptop</option>
				  <option value="phone">Phone / Mobile</option>
				  <option value="printer">Printer</option>
				  <option value="pi">Raspberry Pi</option>
				  <option value="sensor">Sensor / IoT</option>
			  </optgroup>
			  <optgroup label="Network Equipment">
				  <option value="router">Router</option>
				  <option value="switch">Switch</option>
				  <option value="firewall">Firewall</option>
				  <option value="access-point">Access Point</option>
				  <option value="load-balancer">Load Balancer</option>
				  <option value="gateway">Gateway</option>
				  <option value="vpn">VPN / Tunnel</option>
				  <option value="nas">NAS / Storage</option>
			  </optgroup>
			  <optgroup label="Cloud &amp; Services">
			      <option value="cloud">Cloud</option>
				  <option value="database">Database</option>
				  <option value="docker">Docker</option>
				  <option value="container">Container</option>
				  <option value="vm">Virtual Machine</option>
				  <option value="kubernetes">Kubernetes</option>
				  <option value="api">API / Endpoint</option>
				  <option value="queue">Queue / Message</option>
				  <option value="lambda">Lambda / Function</option>
				  <option value="bucket">Bucket / S3</option>
			  </optgroup>
			  <optgroup label="Security &amp; Monitoring">
				  <option value="shield">Shield</option>
				  <option value="camera">Camera / CCTV</option>
				  <option value="monitor">Monitor / Dashboard</option>
			  </optgroup>
        </select>
        <div class="modal-buttons">
          <button class="btn-cancel" id="add-node-cancel">Cancel</button>
          <button class="btn-save" id="add-node-save">Add Node</button>
        </div>
      </div>
    </div>
    <div class="modal" id="add-rack-modal">
      <div class="modal-content">
        <h3>Add New Rack</h3>
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Rack Name</label>
        <input type="text" id="new-rack-name" placeholder="e.g. Rack-A, DC1-R01">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">IP / Network Range (optional)</label>
        <input type="text" id="new-rack-ip" placeholder="e.g. 192.168.1.0/24">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Tags (comma separated)</label>
        <input type="text" id="new-rack-tags" placeholder="e.g. Production, Data Center 1">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Icon / Shape</label>
        <select id="new-rack-shape">
                  <optgroup label="Basic Shapes">
				  <option value="circle">Circle</option>
				  <option value="square">Square</option>
				  <option value="rectangle">Rectangle</option>
				  <option value="triangle">Triangle</option>
				  <option value="hexagon">Hexagon</option>
				  <option value="diamond">Diamond</option>
				  <option value="star">Star</option>
				  <option value="stop-sign">Stop Sign</option>
				  <option value="octagon">Octagon</option>
				  <option value="pentagon">Pentagon</option>
				  <option value="cross">Cross</option>
				  <option value="rounded-square">Rounded Square</option>
				  <option value="pill">Pill</option>
				  <option value="parallelogram">Parallelogram</option>
				  <option value="trapezoid">Trapezoid</option>
				</optgroup>
			  <optgroup label="Computers &amp; Devices">
			      <option value="server">Server</option>
				  <option value="pc">PC / Desktop</option>
				  <option value="laptop">Laptop</option>
				  <option value="phone">Phone / Mobile</option>
				  <option value="printer">Printer</option>
				  <option value="pi">Raspberry Pi</option>
				  <option value="sensor">Sensor / IoT</option>
			  </optgroup>
			  <optgroup label="Network Equipment">
				  <option value="router">Router</option>
				  <option value="switch">Switch</option>
				  <option value="firewall">Firewall</option>
				  <option value="access-point">Access Point</option>
				  <option value="load-balancer">Load Balancer</option>
				  <option value="gateway">Gateway</option>
				  <option value="vpn">VPN / Tunnel</option>
				  <option value="nas">NAS / Storage</option>
			  </optgroup>
			  <optgroup label="Cloud &amp; Services">
			      <option value="cloud">Cloud</option>
				  <option value="database">Database</option>
				  <option value="docker">Docker</option>
				  <option value="container">Container</option>
				  <option value="vm">Virtual Machine</option>
				  <option value="kubernetes">Kubernetes</option>
				  <option value="api">API / Endpoint</option>
				  <option value="queue">Queue / Message</option>
				  <option value="lambda">Lambda / Function</option>
				  <option value="bucket">Bucket / S3</option>
			  </optgroup>
			  <optgroup label="Security &amp; Monitoring">
				  <option value="shield">Shield</option>
				  <option value="camera">Camera / CCTV</option>
				  <option value="monitor">Monitor / Dashboard</option>
			  </optgroup>
        </select>
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Rack Capacity</label>
        <select id="new-rack-capacity">
          <option value="42" selected="">42U (Standard Full Rack)</option>
          <option value="48">48U (Large Rack)</option>
          <option value="24">24U (Half Rack)</option>
          <option value="12">12U (Small/Wall Mount)</option>
          <option value="6">6U (Mini Rack)</option>
        </select>
        <div class="modal-buttons">
          <button class="btn-cancel" id="add-rack-cancel">Cancel</button>
          <button class="btn-save" id="add-rack-save">Add Rack</button>
        </div>
      </div>
    </div>
    <div class="modal confirm-modal" id="clear-all-modal">
      <div class="modal-content">
        <h3>Clear All Nodes</h3>
        <p> This will remove ALL nodes and connections. This cannot be undone until you reload without saving. Are you sure? </p>
        <div class="modal-buttons">
          <button class="btn-cancel" id="clear-all-cancel">Cancel</button>
          <button class="btn-delete" id="clear-all-confirm">Clear Everything</button>
        </div>
      </div>
    </div>
    <div class="modal" id="layer-modal">
      <div class="modal-content" style="max-width: 400px;">
        <h3>Layer Visibility</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Toggle which layers are visible on the canvas</p>
        <div style="display: flex; flex-direction: column; gap: 10px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-physical" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Physical Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-logical" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Logical Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-security" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Security Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-application" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Application Layer</span>
          </label>
        </div>
        <div style="margin-top: 15px; display: flex; gap: 8px;">
          <button class="btn-cancel" style="flex: 1;" onclick="document.querySelectorAll('#layer-modal input[type=checkbox]').forEach(cb =&gt; cb.checked = false); applyLayerFilter();">Hide All</button>
          <button class="btn-save" style="flex: 1;" onclick="document.querySelectorAll('#layer-modal input[type=checkbox]').forEach(cb =&gt; cb.checked = true); applyLayerFilter();">Show All</button>
        </div>
        <div class="modal-buttons" style="margin-top: 10px;">
          <button class="btn-cancel" id="layer-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="tabs-modal">
      <div class="modal-content" style="max-width: 600px;">
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Manage multiple topologies</p>
        <div id="tabs-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 400px; overflow-y: auto; margin-bottom: 15px;">
            <div class="tab-item " onclick="switchTab(0)">
              <div class="tab-name">Corporate Site B</div>
              <div class="tab-stats">105 nodes • 64 connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(0)" title="Rename tab">✏️</button>
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(${index})" title="Delete tab">🗑️</button>
              </div>
            </div>
          
            <div class="tab-item active" onclick="switchTab(1)">
              <div class="tab-name">Homelab 2</div>
              <div class="tab-stats">11 nodes • 10 connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(1)" title="Rename tab">✏️</button>
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(${index})" title="Delete tab">🗑️</button>
              </div>
            </div>
          </div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="new-tab-name" placeholder="New tab name..." style="flex: 1; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <button class="btn-save" onclick="createNewTab()">+ Add Tab</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="tabs-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="rollback-modal">
      <div class="modal-content" style="max-width: 700px;">
        <h3>Version History</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Limit: Snapshots</p>
        <div id="rollback-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 450px; overflow-y: auto; margin-bottom: 15px;">
          <div style="text-align: center; padding: 40px; color: var(--text-soft);">No version history yet. Versions are saved automatically when you save the file.</div>
        </div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <button class="btn-cancel" onclick="clearRollbackHistory()">Clear History</button>
          <button class="btn-save" onclick="createManualSnapshot()">Create Snapshot</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="rollback-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="audit-log-modal">
      <div class="modal-content" style="max-width: 800px;">
        <h3>Audit Log</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Track all changes made to your topology</p>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <select id="audit-filter" style="padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
            <option value="all">All Events</option>
            <option value="node">Node Operations</option>
            <option value="connection">Connections</option>
            <option value="style">Style Changes</option>
            <option value="rack">Rack Operations</option>
            <option value="layer">Layer Changes</option>
          </select>
          <button class="btn-save" onclick="exportAuditLog()">Export</button>
        </div>
        <div id="audit-log-list" style="display: flex; flex-direction: column; gap: 4px; max-height: 450px; overflow-y: auto; margin-bottom: 15px; font-family: monospace; font-size: 12px;">
          <div style="text-align: center; padding: 40px; color: var(--text-soft);">No audit entries yet</div>
        </div>
        <div style="display: flex; gap: 8px;">
          <button class="btn-cancel" onclick="clearAuditLog()">Clear Log</button>
          <button class="btn-cancel" id="audit-log-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="secrets-modal">
      <div class="modal-content" style="max-width: 600px;">
        <h3>Notes</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Notes can also be stored with AES 256 encryption</p>
        <div id="secrets-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 350px; overflow-y: auto; margin-bottom: 15px;">
        </div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="new-secret-name" placeholder="Note name (e.g., 'Root Passwords')..." style="flex: 1; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <button class="btn-save" onclick="createNewSecret()">+ Add Note</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="secrets-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="secret-editor-modal">
      <div class="modal-content" style="max-width: 600px;">
        <h3 id="secret-editor-title">Edit Note</h3>
        <textarea id="secret-editor-content" placeholder="Enter sensitive information here..." style="width: 100%; height: 200px; padding: 12px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main); font-family: monospace; resize: vertical; margin-bottom: 15px;"></textarea>
        <div style="margin-bottom: 15px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
          <input type="checkbox" id="secret-auto-encrypt" checked="" style="cursor: pointer;">
          <span>Encrypt Note</span>
          </label>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" onclick="closeSecretEditor()">Cancel</button>
          <button class="btn-save" onclick="saveSecret()">Save</button>
        </div>
      </div>
    </div>
    <div id="context-menu" style="display: none !important;">
    </div>
    <header>
      <div class="title-block">
        <h1 id="page-title" class="editable-page-title">The One File</h1>
        <div class="save-row">
          <button id="save-file-btn" class="save-btn" type="button">Save File</button>
          <label style="display: flex;align-items: center;gap: 4px;font-size: 12px;color: var(--text-soft);cursor: pointer;user-select: none;">
          <input type="checkbox" id="encrypt-toggle" style="cursor: pointer">
          <span title="Encrypt data with password">Encrypt</span>
          </label>
          <span id="save-help-btn" class="help-icon" title="Why save?">?</span>
        </div>
      </div>
      <div id="topbar-menu">
        <button id="back-to-topology-btn" title="Exit rack view and return to topology" style="padding: 6px 12px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;display: none;">← Back to Topology</button>
        <button id="add-node-btn" class="save-btn" title="Add new node" style="background: var(--accent)" draggable="true">+ Node</button>
        <button id="add-rack-btn" class="save-btn" title="Add new rack" style="background: var(--accent); margin-left: 8px;" draggable="true">+ Rack</button>
        <button id="undo-btn" title="Undo (Ctrl+Z)" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;" disabled="">↶</button>
        <button id="redo-btn" title="Redo (Ctrl+Y)" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;" disabled="">↷</button>
        <input type="text" id="search-nodes" placeholder="Search nodes..." title="Search by name, IP, MAC, role, or tag" style="padding: 6px 12px;background: var(--input-bg);color: var(--input-text);border: 1px solid var(--input-border);border-radius: 6px;font-family: var(--input-font);font-size: var(--input-font-size);width: 180px;">
        <button id="layers-btn" title="Toggle layer visibility" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Layers</button>
        <button id="tabs-btn" title="Manage document tabs" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Tabs</button>
        <button id="rollback-btn" title="View version history" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Snapshots</button>
        <button id="audit-log-btn" title="View audit log" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Audit</button>
        <button id="secrets-btn" title="Manage encrypted notes" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Notes</button>
        <button onclick="screenshotCanvas()" title="Export canvas as PNG image" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">PNG</button>
        <button onclick="exportCanvasSVG()" title="Export canvas as SVG vector" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">SVG</button>
        <button id="settings-btn" title="Page settings">⚙️</button>
      </div>
      <button id="mobile-menu-toggle" class="mobile-menu-btn">☰</button>
      <div class="header-resizer" id="header-resizer">
        <svg class="resizer-icon" width="40" height="6" viewBox="0 0 40 6" xmlns="http://www.w3.org/2000/svg">
          <circle cx="14" cy="3" r="2"></circle>
          <circle cx="20" cy="3" r="2"></circle>
          <circle cx="26" cy="3" r="2"></circle>
        </svg>
      </div>
    </header>
    <main>
      <section class="topology-panel">
        <div class="draw-toolbar" id="draw-toolbar" style="display: flex !important;">
          <button type="button" class="toolbar-close-btn" id="draw-toolbar-close-btn" title="Hide draw toolbar">✕</button>
          <button id="draw-toggle" title="Draw custom line">✏️</button>
          <button id="rect-toggle" title="Draw zone">▭</button>
          <button id="text-toggle" title="Add text">T</button>
          <select id="rect-style" title="zone style">
            <option value="filled">Filled</option>
            <option value="outlined">Outlined</option>
          </select>
          <input type="color" id="draw-color" value="#f97316" title="Line color">
          <select id="draw-style" title="Line style">
            <option value="solid">Solid</option>
            <option value="dashed">Dashed</option>
            <option value="dotted">Dotted</option>
          </select>
          <select id="draw-arrow" title="Arrow direction">
            <option value="none">No arrows</option>
            <option value="forward">→ Right</option>
            <option value="backward">← Left</option>
            <option value="both">↔ Both</option>
          </select>
          <button id="draw-undo" style="display: none" title="Undo last point">Undo</button>
        </div>
        <div class="topology-toolbar" id="topology-toolbar" style="display: flex !important;">
          <button type="button" class="toolbar-close-btn" id="topology-toolbar-close-btn" title="Hide add line toolbar">✕</button>
          <label for="add-line-select">Add line to:</label>
          <select id="add-line-select"><option value="core-router-2">Core Router 2</option><option value="fw-external-1">External FW 1</option><option value="fw-external-2">External FW 2</option><option value="fw-internal">Internal FW</option><option value="core-switch-1">Core Switch 1</option><option value="core-switch-2">Core Switch 2</option><option value="dc-rack-a1">DC Rack A1</option><option value="dc-rack-a2">DC Rack A2</option><option value="dc-rack-b1">DC Rack B1</option><option value="dc-rack-b2">DC Rack B2</option><option value="dmz-rack">DMZ Rack</option><option value="mgmt-rack">Management Rack</option><option value="wlc-primary">WLC Primary</option><option value="wlc-secondary">WLC Secondary</option><option value="mobile-zone-hq">HQ Mobile Zone</option><option value="mobile-zone-guest">Guest WiFi Zone</option><option value="mobile-zone-iot">IoT Device Zone</option><option value="branch-router-ny">NYC Branch Router</option><option value="branch-router-la">LA Branch Router</option><option value="branch-router-chi">Chicago Branch Router</option><option value="branch-router-lon">London Branch Router</option><option value="branch-router-tokyo">Tokyo Branch Router</option><option value="cloud-aws">AWS Cloud</option><option value="cloud-azure">Azure Cloud</option><option value="cloud-gcp">GCP Cloud</option><option value="isp-primary">ISP Primary</option><option value="isp-secondary">ISP Secondary</option><option value="proxy-server-1">Proxy Server 1</option><option value="proxy-server-2">Proxy Server 2</option><option value="vpn-concentrator">VPN Concentrator</option><option value="nac-server">NAC Server</option><option value="voip-cluster">VoIP Cluster</option><option value="video-conf">Video Conference</option><option value="security-cameras">Security Cameras</option><option value="dev-server-1">Dev Server 1</option><option value="dev-server-2">Dev Server 2</option><option value="test-environment">Test Environment</option><option value="erp-system">ERP System</option><option value="crm-system">CRM System</option><option value="endpoint-1000">Corporate Endpoints</option><option value="dist-switch-floor1">Floor 1 Switch</option><option value="dist-switch-floor2">Floor 2 Switch</option><option value="dist-switch-floor3">Floor 3 Switch</option><option value="dist-switch-floor4">Floor 4 Switch</option><option value="ap-floor1-zone1">AP Floor 1 Zone 1</option><option value="ap-floor2-zone1">AP Floor 2 Zone 1</option><option value="ap-floor3-zone1">AP Floor 3 Zone 1</option><option value="ap-floor4-zone1">AP Floor 4 Zone 1</option><option value="ups-dc-1">UPS DC-1</option><option value="ups-dc-2">UPS DC-2</option><option value="cooling-1">CRAC Unit 1</option><option value="cooling-2">CRAC Unit 2</option></select>
          <input type="color" id="add-line-color" value="#475569" title="Line color" style="width: 30px;height: 24px;border: 1px solid var(--toolbar-border);border-radius: 4px;cursor: pointer;background: transparent;padding: 0;">     
          <select id="add-line-direction" title="Line direction">
            <option value="none">No arrows</option>
            <option value="forward">→ Forward</option>
            <option value="backward">← Backward</option>
            <option value="both">↔ Both</option>
          </select>
          <button id="add-line-btn">Add</button>
        </div>
        <div class="topology-toolbar bulk-toolbar-desktop" id="bulk-toolbar" style="display: none">
          <button type="button" class="toolbar-close-btn" id="bulk-toolbar-close" title="Clear selection">✕</button>
          <label style="font-weight: 600; color: var(--accent)">Selected: <span id="bulk-count">0</span></label>
          <button id="bulk-align-left" title="Align left">⬅ Left</button>
          <button id="bulk-align-right" title="Align right">➡ Right</button>
          <button id="bulk-align-top" title="Align top">⬆ Top</button>
          <button id="bulk-align-bottom" title="Align bottom">⬇ Bottom</button>
          <button id="bulk-distribute-h" title="Distribute horizontally">↔ Distribute H</button>
          <button id="bulk-distribute-v" title="Distribute vertically">↕ Distribute V</button>
          <button id="bulk-clone" title="Clone selected">📋 Clone</button>
          <button id="bulk-delete" title="Delete selected" style="background: var(--danger); color: white;">Delete</button>
        </div>
        <div class="bulk-toolbar-mobile" id="bulk-toolbar-mobile" style="">
          <button type="button" id="bulk-mobile-btn" style="background: var(--accent);color: white;padding: 12px 20px;border-radius: 25px;font-weight: 600;font-size: 16px;box-shadow: 0 4px 12px rgba(0,0,0,0.3);border: none;cursor: pointer;display: flex;align-items: center;gap: 8px;">
          <span id="bulk-count-mobile">0</span>Selected</button>
        </div>
        <div id="bulk-actions-modal" style="display: none;position: fixed;bottom: 0;left: 0;right: 0;background: var(--panel-alt);border-top-left-radius: 20px;border-top-right-radius: 20px;padding: 20px;padding-bottom: env(safe-area-inset-bottom, 20px);box-shadow: 0 -4px 20px rgba(0,0,0,0.5);z-index: 10000;max-height: calc(100vh - 80px);overflow-y: auto;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            <h3 style="margin: 0; color: var(--accent); font-size: 20px;">
              <span id="bulk-count-modal">0</span> Nodes Selected
            </h3>
            <button id="bulk-modal-close" style="background: none;border: none;font-size: 24px;cursor: pointer;color: var(--text-main);padding: 0;width: 32px;height: 32px;">✕</button>
          </div>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
            <button id="bulk-align-left-mobile" class="bulk-action-btn">⬅<br><span style="font-size: 12px;">Align Left</span></button>
            <button id="bulk-align-right-mobile" class="bulk-action-btn">➡<br><span style="font-size: 12px;">Align Right</span></button>
            <button id="bulk-align-top-mobile" class="bulk-action-btn">⬆<br><span style="font-size: 12px;">Align Top</span></button>
            <button id="bulk-align-bottom-mobile" class="bulk-action-btn">⬇<br><span style="font-size: 12px;">Align Bottom</span></button>
            <button id="bulk-distribute-h-mobile" class="bulk-action-btn">↔<br><span style="font-size: 12px;">Distribute H</span></button>
            <button id="bulk-distribute-v-mobile" class="bulk-action-btn">↕<br><span style="font-size: 12px;">Distribute V</span></button>
            <button id="bulk-lock-mobile" class="bulk-action-btn">🔒<br><span style="font-size: 12px;">Lock Toggle</span></button>
            <button id="bulk-group-mobile" class="bulk-action-btn">⭕<br><span style="font-size: 12px;">Group Toggle</span></button>
            <button id="bulk-clone-mobile" class="bulk-action-btn">📋<br><span style="font-size: 12px;">Clone All</span></button>
            <button id="bulk-delete-mobile" class="bulk-action-btn" style="background: var(--danger); color: white;">🗑<br><span style="font-size: 12px;">Delete All</span></button>
          </div>
          <button id="bulk-clear-mobile" style="width: 100%;margin-top: 16px;padding: 14px;background: var(--panel-main);border: 1px solid var(--edge-main);border-radius: 8px;color: var(--text-main);font-size: 16px;cursor: pointer;">Clear Selection</button>
        </div>
        <div class="canvas-hint" id="canvas-hint">
          <ul>
            <li>Scroll to zoom</li>
            <li>Drag to pan</li>
            <li>Right click to clone and align</li>
            <li>Right click to select multiple</li>
			<li>Hold Shift + drag mouse for marquee selection</li>
            <li>You have the power</li>
            <li>Your time is NOW!</li>
          </ul>
        </div>
        <div class="legend-container" id="edge-legend" style="display: flex;"><div class="legend-title">Line Legend</div><button type="button" class="legend-close-btn">✕</button><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(85, 226, 8); cursor: pointer;"></span><span class="legend-label" contenteditable="true">ISP LINE</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(76, 0, 255); cursor: pointer;"></span><span class="legend-label" contenteditable="true">MY Guest NETWORK</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(128, 255, 0); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(251, 0, 255); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(255, 0, 208); cursor: pointer;"></span><span class="legend-label" contenteditable="true">iPhone (always guest iPhone)</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(249, 115, 22); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div></div>
        <div class="canvas-viewport" id="canvas-viewport">
          <svg id="map" viewBox="-74.99705309342698 -7.395887697909075 4069.861183597212 3052.395887697909" style=""><defs><marker id="arrow-forward" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto" markerUnits="strokeWidth"><path d="M0,0 L0,6 L9,3 z" fill="context-stroke"></path></marker><marker id="arrow-backward" markerWidth="10" markerHeight="10" refX="0" refY="3" orient="auto" markerUnits="strokeWidth"><path d="M9,0 L9,6 L0,3 z" fill="context-stroke"></path></marker></defs><rect x="100" y="100" width="3800" height="2800" fill="none" stroke="#4755694D" stroke-width="20" stroke-dasharray="10 5" rx="8"></rect><g id="canvas-grid"><line x1="100" y1="100" x2="100" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="150" y1="100" x2="150" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="200" y1="100" x2="200" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="250" y1="100" x2="250" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="300" y1="100" x2="300" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="350" y1="100" x2="350" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="400" y1="100" x2="400" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="450" y1="100" x2="450" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="500" y1="100" x2="500" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="550" y1="100" x2="550" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="600" y1="100" x2="600" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="650" y1="100" x2="650" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="700" y1="100" x2="700" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="750" y1="100" x2="750" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="800" y1="100" x2="800" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="850" y1="100" x2="850" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="900" y1="100" x2="900" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="950" y1="100" x2="950" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1000" y1="100" x2="1000" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1050" y1="100" x2="1050" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1100" y1="100" x2="1100" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="1150" y1="100" x2="1150" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1200" y1="100" x2="1200" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1250" y1="100" x2="1250" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1300" y1="100" x2="1300" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1350" y1="100" x2="1350" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="1400" y1="100" x2="1400" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1450" y1="100" x2="1450" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1500" y1="100" x2="1500" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1550" y1="100" x2="1550" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1600" y1="100" x2="1600" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="1650" y1="100" x2="1650" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1700" y1="100" x2="1700" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1750" y1="100" x2="1750" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1800" y1="100" x2="1800" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1850" y1="100" x2="1850" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="1900" y1="100" x2="1900" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1950" y1="100" x2="1950" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2000" y1="100" x2="2000" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2050" y1="100" x2="2050" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2100" y1="100" x2="2100" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="2150" y1="100" x2="2150" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2200" y1="100" x2="2200" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2250" y1="100" x2="2250" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2300" y1="100" x2="2300" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2350" y1="100" x2="2350" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="2400" y1="100" x2="2400" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2450" y1="100" x2="2450" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2500" y1="100" x2="2500" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2550" y1="100" x2="2550" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2600" y1="100" x2="2600" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="2650" y1="100" x2="2650" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2700" y1="100" x2="2700" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2750" y1="100" x2="2750" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2800" y1="100" x2="2800" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2850" y1="100" x2="2850" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="2900" y1="100" x2="2900" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2950" y1="100" x2="2950" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3000" y1="100" x2="3000" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3050" y1="100" x2="3050" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3100" y1="100" x2="3100" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="3150" y1="100" x2="3150" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3200" y1="100" x2="3200" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3250" y1="100" x2="3250" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3300" y1="100" x2="3300" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3350" y1="100" x2="3350" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="3400" y1="100" x2="3400" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3450" y1="100" x2="3450" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3500" y1="100" x2="3500" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3550" y1="100" x2="3550" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3600" y1="100" x2="3600" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="3650" y1="100" x2="3650" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3700" y1="100" x2="3700" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3750" y1="100" x2="3750" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3800" y1="100" x2="3800" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3850" y1="100" x2="3850" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="3900" y1="100" x2="3900" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="100" x2="3900" y2="100" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="150" x2="3900" y2="150" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="200" x2="3900" y2="200" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="250" x2="3900" y2="250" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="300" x2="3900" y2="300" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="350" x2="3900" y2="350" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="400" x2="3900" y2="400" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="450" x2="3900" y2="450" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="500" x2="3900" y2="500" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="550" x2="3900" y2="550" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="600" x2="3900" y2="600" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="650" x2="3900" y2="650" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="700" x2="3900" y2="700" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="750" x2="3900" y2="750" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="800" x2="3900" y2="800" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="850" x2="3900" y2="850" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="900" x2="3900" y2="900" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="950" x2="3900" y2="950" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1000" x2="3900" y2="1000" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1050" x2="3900" y2="1050" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1100" x2="3900" y2="1100" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="1150" x2="3900" y2="1150" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1200" x2="3900" y2="1200" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1250" x2="3900" y2="1250" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1300" x2="3900" y2="1300" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1350" x2="3900" y2="1350" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="1400" x2="3900" y2="1400" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1450" x2="3900" y2="1450" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1500" x2="3900" y2="1500" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1550" x2="3900" y2="1550" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1600" x2="3900" y2="1600" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="1650" x2="3900" y2="1650" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1700" x2="3900" y2="1700" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1750" x2="3900" y2="1750" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1800" x2="3900" y2="1800" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1850" x2="3900" y2="1850" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="1900" x2="3900" y2="1900" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1950" x2="3900" y2="1950" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2000" x2="3900" y2="2000" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2050" x2="3900" y2="2050" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2100" x2="3900" y2="2100" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="2150" x2="3900" y2="2150" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2200" x2="3900" y2="2200" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2250" x2="3900" y2="2250" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2300" x2="3900" y2="2300" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2350" x2="3900" y2="2350" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="2400" x2="3900" y2="2400" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2450" x2="3900" y2="2450" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2500" x2="3900" y2="2500" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2550" x2="3900" y2="2550" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2600" x2="3900" y2="2600" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="2650" x2="3900" y2="2650" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2700" x2="3900" y2="2700" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2750" x2="3900" y2="2750" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2800" x2="3900" y2="2800" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2850" x2="3900" y2="2850" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="2900" x2="3900" y2="2900" stroke="#47556933" stroke-width="1"></line></g><g class="rect-group" data-rect-id="rect-1765238219615"><rect class="rect-shape" x="2680.053955078125" y="251.44879150390625" width="814.10400390625" height="389.26678466796875" style="fill: rgb(236, 9, 153); fill-opacity: 0.3; stroke: rgb(236, 9, 153); stroke-width: 2px; stroke-dasharray: none; cursor: move;"></rect><g class="rect-delete-btn" style="cursor: pointer; display: none;"><circle cx="3484.157958984375" cy="261.44879150390625" r="12" style="fill: rgb(245, 101, 101); stroke: white; stroke-width: 2;"></circle><text x="3484.157958984375" y="261.44879150390625" text-anchor="middle" dominant-baseline="middle" style="fill: white; font-size: 16px; font-weight: bold; pointer-events: none;">×</text></g></g><path d="M 2071.640165880771 218.24354238566275 Q 2069.3039587352528 345.82772790170964 2066.9677515897347 473.4119134177565" fill="none" class="edge" data-edge-id="internet-internet-copy-1765238145151" data-from="internet" data-to="internet-copy" style="stroke: rgb(85, 226, 8); stroke-width: 4;"></path><path d="M 2071.640165880771 218.24354238566275 Q 2069.3039587352528 345.82772790170964 2066.9677515897347 473.4119134177565" fill="none" data-edge-id="internet-internet-copy-1765238145151" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 1921.3019190702034 570.8918786277175 1775.6360865506722 668.3718438376784" fill="none" class="edge" data-edge-id="internet-copy-opnsense-copy-1765238187451" data-from="internet-copy" data-to="opnsense-copy" style="stroke: rgb(76, 0, 255); stroke-width: 4;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 1921.3019190702034 570.8918786277175 1775.6360865506722 668.3718438376784" fill="none" data-edge-id="internet-copy-opnsense-copy-1765238187451" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2000.8787827715962 627.8447547749242 1934.7898139534577 782.2775961320921" fill="none" class="edge" data-edge-id="internet-copy-docker-copy-1765238242477" data-from="internet-copy" data-to="docker-copy" style="stroke: rgb(76, 0, 255); stroke-width: 4;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2000.8787827715962 627.8447547749242 1934.7898139534577 782.2775961320921" fill="none" data-edge-id="internet-copy-docker-copy-1765238242477" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2112.546995662221 620.5620704487524 2158.1262397347077 767.7122274797483" fill="none" class="edge" data-edge-id="internet-copy-docker-copy-1-1765238244637" data-from="internet-copy" data-to="docker-copy-1" style="stroke: rgb(76, 0, 255); stroke-width: 4;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2112.546995662221 620.5620704487524 2158.1262397347077 767.7122274797483" fill="none" data-edge-id="internet-copy-docker-copy-1-1765238244637" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2206.4130845294085 552.590055067893 2345.8584174690827 631.7681967180296" fill="none" class="edge" data-edge-id="internet-copy-docker-copy-2-1765238246233" data-from="internet-copy" data-to="docker-copy-2" style="stroke: rgb(76, 0, 255); stroke-width: 4;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2206.4130845294085 552.590055067893 2345.8584174690827 631.7681967180296" fill="none" data-edge-id="internet-copy-docker-copy-2-1765238246233" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2071.640165880771 218.24354238566275 Q 2414.759822984287 262.92762699742593 2757.879480087803 307.6117116091891" fill="none" class="edge" data-edge-id="internet-opnsense-copy-1-1765238266117" data-from="internet" data-to="opnsense-copy-1" style="stroke: rgb(128, 255, 0); stroke-width: 4;"></path><path d="M 2071.640165880771 218.24354238566275 Q 2414.759822984287 262.92762699742593 2757.879480087803 307.6117116091891" fill="none" data-edge-id="internet-opnsense-copy-1-1765238266117" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2757.879480087803 307.6117116091891 Q 2979.171899521397 314.04065142852505 3200.4643189549906 320.469591247861" fill="none" class="edge" data-edge-id="opnsense-copy-1-dns-1765238347996" data-from="opnsense-copy-1" data-to="dns" style="stroke: rgb(251, 0, 255); stroke-width: 4;"></path><path d="M 2757.879480087803 307.6117116091891 Q 2979.171899521397 314.04065142852505 3200.4643189549906 320.469591247861" fill="none" data-edge-id="opnsense-copy-1-dns-1765238347996" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 3200.4643189549906 320.469591247861 Q 3094.0802247167094 404.02690325957974 2987.696130478428 487.5842152712985" fill="none" class="edge" data-edge-id="dns-desktop-1765238386101" data-from="dns" data-to="desktop" style="stroke: rgb(255, 0, 208); stroke-width: 4;"></path><path d="M 3200.4643189549906 320.469591247861 Q 3094.0802247167094 404.02690325957974 2987.696130478428 487.5842152712985" fill="none" data-edge-id="dns-desktop-1765238386101" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 3312.857751572178 502.58220111114224 Q 3256.6610352635844 411.5258961795016 3200.4643189549906 320.469591247861" fill="none" class="edge" data-edge-id="phone-dns-1765238391156" data-from="phone" data-to="dns" style="stroke: rgb(255, 0, 208); stroke-width: 4;"></path><path d="M 3312.857751572178 502.58220111114224 Q 3256.6610352635844 411.5258961795016 3200.4643189549906 320.469591247861" fill="none" data-edge-id="phone-dns-1765238391156" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><polyline class="edge" data-edge-id="custom-1765238841477" fill="none" marker-start="url(#arrow-backward)" marker-end="url(#arrow-forward)" points="2905.255615234375,805.3433837890625 3189.95556640625,1005.8710327148438 2788.900390625,1008.3466796875" style="stroke: rgb(249, 115, 22); stroke-width: 4; stroke-dasharray: none;"></polyline><polyline points="2905.255615234375,805.3433837890625 3189.95556640625,1005.8710327148438 2788.900390625,1008.3466796875" data-edge-id="custom-1765238841477" style="fill: none; stroke: transparent; stroke-width: 20; cursor: pointer;"></polyline><g class="node-group" data-node-id="internet" transform="translate(2071.640165880771,218.24354238566275)" style="cursor: grab;"><circle r="127.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><rect x="-85" y="-85" width="170" height="170" rx="4" class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"></rect><text class="node-label" x="0" y="-23.8" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Internet</text><text class="node-sub" x="0" y="34" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="internet-copy" transform="translate(2066.9677515897347,473.4119134177565)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-55" y="-44" width="110" height="88" rx="4"></rect><line x1="-46.75" y1="-27.5" x2="46.75" y2="-27.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="-2.75" x2="46.75" y2="-2.75" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="22" x2="46.75" y2="22" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="-44" x2="-27.5" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="-44" x2="11" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="-19.25" x2="-8.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="-19.25" x2="30.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="5.5" x2="-27.5" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="5.5" x2="11" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="30.25" x2="-8.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="30.25" x2="30.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">OPNSENSE</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="opnsense-copy" transform="translate(1775.6360865506722,668.3718438376784)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-55" y="-44" width="110" height="88" rx="4"></rect><line x1="-46.75" y1="-27.5" x2="46.75" y2="-27.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="-2.75" x2="46.75" y2="-2.75" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="22" x2="46.75" y2="22" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="-44" x2="-27.5" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="-44" x2="11" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="-19.25" x2="-8.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="-19.25" x2="30.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="5.5" x2="-27.5" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="5.5" x2="11" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="30.25" x2="-8.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="30.25" x2="30.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Docker</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="docker-copy" transform="translate(1934.7898139534577,782.2775961320921)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-55" y="-44" width="110" height="88" rx="4"></rect><line x1="-46.75" y1="-27.5" x2="46.75" y2="-27.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="-2.75" x2="46.75" y2="-2.75" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="22" x2="46.75" y2="22" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="-44" x2="-27.5" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="-44" x2="11" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="-19.25" x2="-8.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="-19.25" x2="30.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="5.5" x2="-27.5" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="5.5" x2="11" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="30.25" x2="-8.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="30.25" x2="30.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Docker2</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="docker-copy-1" transform="translate(2158.1262397347077,767.7122274797483)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-55" y="-44" width="110" height="88" rx="4"></rect><line x1="-46.75" y1="-27.5" x2="46.75" y2="-27.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="-2.75" x2="46.75" y2="-2.75" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="22" x2="46.75" y2="22" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="-44" x2="-27.5" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="-44" x2="11" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="-19.25" x2="-8.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="-19.25" x2="30.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="5.5" x2="-27.5" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="5.5" x2="11" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="30.25" x2="-8.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="30.25" x2="30.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Docker3</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="docker-copy-2" transform="translate(2345.8584174690827,631.7681967180296)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-55" y="-44" width="110" height="88" rx="4"></rect><line x1="-46.75" y1="-27.5" x2="46.75" y2="-27.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="-2.75" x2="46.75" y2="-2.75" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="22" x2="46.75" y2="22" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="-44" x2="-27.5" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="-44" x2="11" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="-19.25" x2="-8.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="-19.25" x2="30.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="5.5" x2="-27.5" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="5.5" x2="11" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="30.25" x2="-8.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="30.25" x2="30.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Docker 4</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="opnsense-copy-1" transform="translate(2757.879480087803,307.6117116091891)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-55" y="-44" width="110" height="88" rx="4"></rect><line x1="-46.75" y1="-27.5" x2="46.75" y2="-27.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="-2.75" x2="46.75" y2="-2.75" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="22" x2="46.75" y2="22" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="-44" x2="-27.5" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="-44" x2="11" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="-19.25" x2="-8.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="-19.25" x2="30.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="5.5" x2="-27.5" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="5.5" x2="11" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="30.25" x2="-8.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="30.25" x2="30.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">OPNSENSE GUEST</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="phone" transform="translate(3312.857751572178,502.58220111114224)" style="cursor: grab;"><circle r="181.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-54.45" y="-121" width="108.9" height="242" rx="8"></rect><rect x="-45.980000000000004" y="-102.85" width="91.96000000000001" height="193.60000000000002" rx="4" style="fill: rgb(30, 41, 59);"></rect><rect x="-18.15" y="99.22" width="36.3" height="7.26" rx="2" style="fill: rgb(71, 85, 105);"></rect></g><text class="node-label" x="0" y="-33.88" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Phone</text><text class="node-sub" x="0" y="48.400000000000006" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="desktop" transform="translate(2987.696130478428,487.5842152712985)" style="cursor: grab;"><circle r="220.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-132.3" y="-117.60000000000001" width="264.6" height="176.4" rx="4"></rect><rect x="-110.25" y="-95.55" width="220.5" height="132.3" rx="2" style="fill: rgb(30, 41, 59);"></rect><rect x="-22.05" y="58.800000000000004" width="44.1" height="44.1"></rect><rect x="-73.5" y="102.89999999999999" width="147" height="22.05" rx="2"></rect></g><text class="node-label" x="0" y="-41.160000000000004" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Desktop</text><text class="node-sub" x="0" y="58.800000000000004" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="dns" transform="translate(3200.4643189549906,320.469591247861)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><path d="
             M -44 11
             Q -60.50000000000001 11 -60.50000000000001 -5.5
             Q -60.50000000000001 -27.5 -38.5 -27.5
             Q -38.5 -49.5 -11 -49.5
             Q 5.5 -60.50000000000001 27.5 -44
             Q 55 -44 60.50000000000001 -16.5
             Q 71.5 -5.5 60.50000000000001 11
             Q 60.50000000000001 27.5 38.5 27.5
             L -27.5 27.5
             Q -49.5 27.5 -49.5 11
             Z
            " class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"></path><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">DNS</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="racked" transform="translate(2600.8697010779656,975.5665527522032)" style="cursor: grab;"><circle r="205.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-164.4" y="-82.2" width="328.8" height="164.4" rx="4"></rect><line x1="-123.3" y1="-41.1" x2="-123.3" y2="41.1" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="-54.8" y1="-41.1" x2="-54.8" y2="41.1" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="13.700000000000003" y1="-41.1" x2="13.700000000000003" y2="41.1" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><circle cx="123.3" cy="0" r="13.700000000000001" style="fill: rgb(74, 222, 128);"></circle></g><text class="node-label" x="0" y="-38.36000000000001" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Racked</text><text class="node-sub" x="0" y="54.800000000000004" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;"></text></g><g class="text-group" data-text-id="text-1765238422602"><text class="text-element" x="2402.130859375" y="736.7828979492188" dominant-baseline="middle" style="fill: rgb(226, 232, 240); font-size: 48px; font-weight: normal; font-style: normal; text-anchor: start; text-decoration: none; opacity: 1; cursor: move; user-select: none;"><tspan x="2402.130859375" dy="0">Double click on desktop</tspan><tspan x="2402.130859375" dy="57.599999999999994">or long press on mobile</tspan><tspan x="2402.130859375" dy="57.599999999999994">to enter rack canvas view</tspan></text><g class="text-delete-btn" style="cursor: pointer; display: none;"><circle cx="2422.130859375" cy="688.7828979492188" r="12" style="fill: rgb(245, 101, 101); stroke: white; stroke-width: 2;"></circle><text x="2422.130859375" y="688.7828979492188" text-anchor="middle" dominant-baseline="middle" style="fill: white; font-size: 16px; font-weight: bold; pointer-events: none;">×</text></g></g></svg>
        </div>
        <div class="minimap-zoom-wrapper" id="minimap-zoom-wrapper" style="display: block;">
          <button type="button" class="minimap-close-btn" id="minimap-close-btn" title="Hide map &amp; zoom">✕</button>
          <div class="minimap-container" id="minimap-container">
            <svg id="minimap" viewBox="0 0 4000 3000">
              <line x1="2071.640165880771" y1="218.24354238566275" x2="2066.9677515897347" y2="473.4119134177565" class="minimap-edge"></line><line x1="2066.9677515897347" y1="473.4119134177565" x2="1775.6360865506722" y2="668.3718438376784" class="minimap-edge"></line><line x1="2066.9677515897347" y1="473.4119134177565" x2="1934.7898139534577" y2="782.2775961320921" class="minimap-edge"></line><line x1="2066.9677515897347" y1="473.4119134177565" x2="2158.1262397347077" y2="767.7122274797483" class="minimap-edge"></line><line x1="2066.9677515897347" y1="473.4119134177565" x2="2345.8584174690827" y2="631.7681967180296" class="minimap-edge"></line><line x1="2071.640165880771" y1="218.24354238566275" x2="2757.879480087803" y2="307.6117116091891" class="minimap-edge"></line><line x1="2757.879480087803" y1="307.6117116091891" x2="3200.4643189549906" y2="320.469591247861" class="minimap-edge"></line><line x1="3200.4643189549906" y1="320.469591247861" x2="2987.696130478428" y2="487.5842152712985" class="minimap-edge"></line><line x1="3312.857751572178" y1="502.58220111114224" x2="3200.4643189549906" y2="320.469591247861" class="minimap-edge"></line><circle cx="2071.640165880771" cy="218.24354238566275" r="40" class="minimap-node"></circle><circle cx="2066.9677515897347" cy="473.4119134177565" r="40" class="minimap-node"></circle><circle cx="1775.6360865506722" cy="668.3718438376784" r="40" class="minimap-node"></circle><circle cx="1934.7898139534577" cy="782.2775961320921" r="40" class="minimap-node"></circle><circle cx="2158.1262397347077" cy="767.7122274797483" r="40" class="minimap-node"></circle><circle cx="2345.8584174690827" cy="631.7681967180296" r="40" class="minimap-node"></circle><circle cx="2757.879480087803" cy="307.6117116091891" r="40" class="minimap-node"></circle><circle cx="3312.857751572178" cy="502.58220111114224" r="40" class="minimap-node"></circle><circle cx="2987.696130478428" cy="487.5842152712985" r="40" class="minimap-node"></circle><circle cx="3200.4643189549906" cy="320.469591247861" r="40" class="minimap-node"></circle><circle cx="2600.8697010779656" cy="975.5665527522032" r="40" class="minimap-node"></circle><rect class="minimap-viewport" id="minimap-viewport" x="-74.99705309342698" y="-7.395887697909075" width="4069.861183597212" height="3052.395887697909"></rect>
            </svg>
          </div>
          <div class="zoom-toolbar" id="zoom-toolbar">
            <button id="zoom-in-btn" title="Zoom in">+</button>
            <div class="zoom-level" id="zoom-level">98%</div>
            <button id="zoom-out-btn" title="Zoom out">-</button>
            <div class="divider"></div>
            <button id="zoom-fit-btn" title="Fit to view">[ ]</button>
            <button id="zoom-reset-btn" title="Reset view">R</button>
          </div>
        </div>
        <button type="button" id="edge-legend-mini" class="legend-mini-btn" style="bottom: 10px; display: none;">Line Legend</button>
        <button type="button" id="minimap-mini" class="legend-mini-btn" style="right: 10px; left: auto; bottom: 10px; display: none;">Map</button>
        <button type="button" id="draw-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: 10px; right: auto;">Draw</button>
        <button type="button" id="topology-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: auto; right: 40px;">Add Line</button></section>
      <aside class="details-panel" id="details-panel">
        <div class="sidebar-resizer" id="sidebar-resizer">
          <svg class="resizer-icon" width="6" height="40" viewBox="0 0 6 40" xmlns="http://www.w3.org/2000/svg">
            <circle cx="3" cy="14" r="2"></circle>
            <circle cx="3" cy="20" r="2"></circle>
            <circle cx="3" cy="26" r="2"></circle>
          </svg>
        </div>
        <div class="mobile-footer-resizer" id="mobile-footer-resizer">
          <svg class="resizer-icon" width="40" height="6" viewBox="0 0 40 6" xmlns="http://www.w3.org/2000/svg">
            <circle cx="14" cy="3" r="2"></circle>
            <circle cx="20" cy="3" r="2"></circle>
            <circle cx="26" cy="3" r="2"></circle>
          </svg>
        </div>
        <div id="node-panel" style="display: none;">
          <div class="details-name editable-text" id="node-name">Core Router 1</div>
          <div class="details-ip editable-text" id="node-ip">10.0.0.1</div>
          <div class="details-role" id="node-role">Core Routing</div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px;">MAC:</span>
            <span class="editable-text" id="node-mac" style="margin-left: 8px; font-size: 14px;">00:1A:2B:3C:4D:01</span>
          </div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px;">Rack Unit:</span>
            <span class="editable-text" id="node-rack" style="margin-left: 8px; font-size: 14px;">--</span>
          </div>
          <div class="details-info-row" id="uheight-row" style="display: none;">
            <span style="color: var(--text-soft); font-size: 14px;">U Height:</span>
            <span class="editable-text" id="node-uheight" style="margin-left: 8px; font-size: 14px;">2U</span>
          </div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px;">Layer:</span>
            <select id="node-layer" style="margin-left: 8px; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;">
              <option value="physical">Physical</option>
              <option value="logical">Logical</option>
              <option value="security">Security</option>
              <option value="application">Application</option>
            </select>
          </div>
          <div class="details-info-row" id="assigned-rack-row" style="display: flex;">
            <span style="color: var(--text-soft); font-size: 14px;">Assigned Rack:</span>
            <select id="node-assigned-rack" style="margin-left: 8px; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;"><option value="">None</option><option value="racked">Racked</option></select>
          </div>
          <div class="details-info-row" id="rack-capacity-row" style="display: none;">
            <span style="color: var(--text-soft); font-size: 14px;">Rack Capacity:</span>
            <select id="node-rack-capacity" style="margin-left: 8px; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;">
              <option value="42">42U</option>
              <option value="48">48U</option>
              <option value="24">24U</option>
              <option value="12">12U</option>
			  <option value="6">6U</option>
            </select>
          </div>
		  <details id="rack-contents-section" style="display: none; margin-top: 12px; margin-bottom: 12px; padding: 10px; background: var(--panel-alt); border-radius: 6px;" open="">
            <summary style="color: var(--accent); font-weight: 600; font-size: 14px; cursor: pointer;">Nodes in Rack (<span id="rack-contents-count">0</span>)</summary>
            <div id="rack-contents-list" style="max-height: 200px; overflow-y: auto; margin-top: 8px;"></div>
          </details>
          <div class="badge-row" id="node-tags"><span class="badge" style="cursor: pointer; position: relative;"><span>core</span><span style="opacity: 0.6; margin-left: 4px; font-size: 10px;"> ✕</span></span><span class="badge" style="cursor: pointer; position: relative;"><span>tier-1</span><span style="opacity: 0.6; margin-left: 4px; font-size: 10px;"> ✕</span></span><span class="badge" style="cursor: pointer; position: relative;"><span>redundant</span><span style="opacity: 0.6; margin-left: 4px; font-size: 10px;"> ✕</span></span><span class="badge" style="cursor: pointer; opacity: 0.6; border-style: dashed;">+ Add Tag</span></div>
          <div class="size-controls">
            <label>Size:</label>
            <input type="range" id="size-slider" min="20" max="200" value="55">
            <span id="size-value">55</span>
            <button id="reset-size">Reset</button>
          </div>
          <details class="style-section">
            <summary>Styling</summary>
            <div class="style-content">
              <div class="style-row">
                <label>Screen:</label>
                <select id="style-scope">
                  <option value="all">All</option>
                  <option value="desktop">Desktop</option>
                  <option value="tablet">Tablet</option>
                  <option value="mobile">Mobile</option>
                  <option value="fold">Fold</option>
                </select>
              </div>
              <div class="style-row">
                <label>Shape:</label>
                <select id="shape-select">
                  <optgroup label="Basic Shapes">
				  <option value="circle">Circle</option>
				  <option value="square">Square</option>
				  <option value="rectangle">Rectangle</option>
				  <option value="triangle">Triangle</option>
				  <option value="hexagon">Hexagon</option>
				  <option value="diamond">Diamond</option>
				  <option value="star">Star</option>
				  <option value="stop-sign">Stop Sign</option>
				  <option value="octagon">Octagon</option>
				  <option value="pentagon">Pentagon</option>
				  <option value="cross">Cross</option>
				  <option value="rounded-square">Rounded Square</option>
				  <option value="pill">Pill</option>
				  <option value="parallelogram">Parallelogram</option>
				  <option value="trapezoid">Trapezoid</option>
				</optgroup>
			  <optgroup label="Computers &amp; Devices">
			      <option value="server">Server</option>
				  <option value="pc">PC / Desktop</option>
				  <option value="laptop">Laptop</option>
				  <option value="phone">Phone / Mobile</option>
				  <option value="printer">Printer</option>
				  <option value="pi">Raspberry Pi</option>
				  <option value="sensor">Sensor / IoT</option>
			  </optgroup>
			  <optgroup label="Network Equipment">
				  <option value="router">Router</option>
				  <option value="switch">Switch</option>
				  <option value="firewall">Firewall</option>
				  <option value="access-point">Access Point</option>
				  <option value="load-balancer">Load Balancer</option>
				  <option value="gateway">Gateway</option>
				  <option value="vpn">VPN / Tunnel</option>
				  <option value="nas">NAS / Storage</option>
			  </optgroup>
			  <optgroup label="Cloud &amp; Services">
			      <option value="cloud">Cloud</option>
				  <option value="database">Database</option>
				  <option value="docker">Docker</option>
				  <option value="container">Container</option>
				  <option value="vm">Virtual Machine</option>
				  <option value="kubernetes">Kubernetes</option>
				  <option value="api">API / Endpoint</option>
				  <option value="queue">Queue / Message</option>
				  <option value="lambda">Lambda / Function</option>
				  <option value="bucket">Bucket / S3</option>
			  </optgroup>
			  <optgroup label="Security &amp; Monitoring">
				  <option value="shield">Shield</option>
				  <option value="camera">Camera / CCTV</option>
				  <option value="monitor">Monitor / Dashboard</option>
			  </optgroup>
             </select>
              </div>
              <div class="style-row">
                <label>Fill Color:</label>
                <input type="color" id="circle-color" value="#1e293b">
              </div>
              <div class="style-row">
                <label>Border Color:</label>
                <input type="color" id="circle-border" value="#475569">
              </div>
              <div class="style-row">
                <label>Title Color:</label>
                <input type="color" id="title-color" value="#e2e8f0">
              </div>
              <div class="style-row">
                <label>Title Font:</label>
                <select id="title-font">
                  <option value="system-ui, sans-serif"> System UI </option>
                  <option value="monospace">Monospace</option>
                  <option value="serif">Serif</option>
                  <option value="cursive">Cursive</option>
                  <option value="'Courier New', monospace"> Courier </option>
                  <option value="Arial, sans-serif">Arial</option>
                  <option value="'Times New Roman', serif"> Times </option>
                </select>
              </div>
              <div class="style-row">
                <label>Title Size:</label>
                <input type="number" id="title-size" min="8" max="100" value="18">
              </div>
              <div class="style-row">
                <label>Sub Color:</label>
                <input type="color" id="sub-color" value="#94a3b8">
              </div>
              <div class="style-row">
                <label>Sub Font:</label>
                <select id="sub-font">
                  <option value="system-ui, sans-serif"> System UI </option>
                  <option value="monospace">Monospace</option>
                  <option value="serif">Serif</option>
                  <option value="cursive">Cursive</option>
                  <option value="'Courier New', monospace"> Courier </option>
                  <option value="Arial, sans-serif">Arial</option>
                  <option value="'Times New Roman', serif"> Times </option>
                </select>
              </div>
              <div class="style-row">
                <label>Sub Size:</label>
                <input type="number" id="sub-size" min="6" max="80" value="13">
              </div>
              <div style="margin-top: 12px;padding-top: 10px;border-top: 1px solid var(--edge-main);">
                <div style="
                  font-size: 12px;
                  color: var(--text-soft);
                  margin-bottom: 8px;
                  text-transform: uppercase;
                  "> Text Position </div>
                <div class="style-row">
                  <label>Name Y:</label>
                  <input type="number" id="title-offset-y" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>Name X:</label>
                  <input type="number" id="title-offset-x" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>IP Y:</label>
                  <input type="number" id="sub-offset-y" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>IP X:</label>
                  <input type="number" id="sub-offset-x" min="-100" max="100" value="0" style="width: 60px">
                </div>
              </div>
              <button id="reset-styles" style="width: 100%;margin-top: 10px;padding: 8px;background: var(--panel);color: var(--text-main);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: clamp(13px, 1.5vw, 17px);">Reset Styles</button>
            </div>
          </details>
          <div class="section-label">Notes</div>
          <ul class="list" id="node-notes"><li><span style="flex: 1 1 0%;">Primary core router</span><span class="delete-note">✕</span></li><li><span style="flex: 1 1 0%;">BGP peering enabled</span><span class="delete-note">✕</span></li></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-note-input" placeholder="Type new note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-note-btn" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-node-btn" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: rgb(255, 255, 255);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;width: 100%;">Delete Node</button>
        </div>
        <div id="edge-panel" style="display: none">
          <div class="details-name" id="edge-title">Custom line</div>
          <div class="style-row" style="margin-top: 10px">
            <label>Width:</label>
            <input type="number" id="edge-width" min="1" max="20" value="4">
          </div>
          <div class="style-row">
            <label>Color:</label>
            <input type="color" id="edge-color" value="#475569">
          </div>
          <div class="style-row">
            <label>Line Style:</label>
            <select id="edge-line-style">
              <option value="solid">Solid</option>
              <option value="dashed">Dashed</option>
              <option value="dotted">Dotted</option>
            </select>
          </div>
          <div class="style-row">
            <label>Direction:</label>
            <select id="edge-direction">
              <option value="none">No arrows</option>
              <option value="forward">→ Forward</option>
              <option value="backward">← Backward</option>
              <option value="both">↔ Bidirectional</option>
            </select>
          </div>
          <div class="style-row" id="edge-from-port-row" style="display: none;">
            <label>From Port:</label>
            <input type="text" id="edge-from-port" placeholder="e.g. eth0, gi0/1" style="flex: 1;">
          </div>
          <div class="style-row" id="edge-to-port-row" style="display: none;">
            <label>To Port:</label>
            <input type="text" id="edge-to-port" placeholder="e.g. eth1, gi0/2" style="flex: 1;">
          </div>
          <div class="section-label">Line Notes</div>
          <ul class="list" id="edge-notes"></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-edge-note" placeholder="Add note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-edge-note" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-edge" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Delete Line</button>
        </div>
        <div id="rect-panel" style="display: none">
          <div class="details-name" id="rect-title">Zone</div>
          <div class="style-row" id="rect-fill-row" style="margin-top: 10px">
            <label>Fill Color:</label>
            <input type="color" id="rect-color" value="#f97316">
          </div>
          <div class="style-row">
            <label>Border Color:</label>
            <input type="color" id="rect-border-color" value="#f97316">
          </div>
          <div class="style-row">
            <label>Border Width:</label>
            <input type="number" id="rect-border-width" min="0" max="20" value="2">
          </div>
          <div class="style-row">
            <label>Style:</label>
            <select id="rect-style-select">
              <option value="filled">Filled</option>
              <option value="outlined">Outlined</option>
            </select>
          </div>
          <div class="style-row">
            <label>Line Style:</label>
            <select id="rect-line-style">
              <option value="solid">Solid</option>
              <option value="dashed">Dashed</option>
              <option value="dotted">Dotted</option>
            </select>
          </div>
          <div class="section-label">Zone Notes</div>
          <ul class="list" id="rect-notes"></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-rect-note" placeholder="Add note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-rect-note" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-rect" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Delete Zone</button>
        </div>
        <div id="text-panel" style="display: none">
          <div class="details-name" id="text-title">Text Element</div>
          <div class="style-row" style="margin-top: 10px">
            <label>Content:</label>
            <textarea id="text-content" placeholder="Enter text..." style="width: 100%;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: 14px;min-height: 80px;resize: vertical;font-family: inherit;"></textarea>
          </div>
          <div class="style-row">
            <label>Font Size:</label>
            <input type="number" id="text-font-size" min="8" max="200" value="18" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);">
          </div>
          <div class="style-row">
            <label>Color:</label>
            <input type="color" id="text-color" value="#e2e8f0">
          </div>
          <div class="style-row">
            <label>Font Weight:</label>
            <select id="text-font-weight" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="normal">Normal</option>
              <option value="bold">Bold</option>
              <option value="600">Semi-Bold</option>
              <option value="300">Light</option>
            </select>
          </div>
          <div class="style-row">
            <label>Font Style:</label>
            <select id="text-font-style" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="normal">Normal</option>
              <option value="italic">Italic</option>
            </select>
          </div>
          <div class="style-row">
            <label>Text Align:</label>
            <select id="text-align" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="start">Left</option>
              <option value="middle">Center</option>
              <option value="end">Right</option>
            </select>
          </div>
          <div class="style-row">
            <label>Text Decoration:</label>
            <select id="text-decoration" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="none">None</option>
              <option value="underline">Underline</option>
              <option value="line-through">Strike Through</option>
            </select>
          </div>
          <div class="style-row">
            <label>Background:</label>
            <input type="color" id="text-bg-color" value="#000000">
            <label style="margin-left: 10px; display: flex; align-items: center; gap: 6px;">
            <input type="checkbox" id="text-bg-enabled" style="cursor: pointer;">
            <span style="font-size: 13px;">Enable</span>
            </label>
          </div>
          <div class="style-row">
            <label>Opacity:</label>
            <input type="range" id="text-opacity" min="0" max="1" step="0.1" value="1" style="flex: 1">
            <span id="text-opacity-val" style="min-width: 35px; text-align: right">100%</span>
          </div>
          <button id="delete-text" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;width: 100%;"> Delete Text </button>
        </div>
        <details class="style-section" open="">
          <summary>Page Layout</summary>
          <div class="style-content">
            <div style="padding: 12px; background: var(--panel-alt); border-radius: 6px; color: var(--text-soft); font-size: 13px; line-height: 1.6;">
              <strong style="color: var(--accent); display: block; margin-bottom: 8px;">Drag to Resize:</strong>
              • <strong>Header:</strong> Drag the bottom edge of the header bar<br>
              • <strong>Sidebar:</strong> Drag the left edge of the sidebar panel<br>
              • <strong>Mobile:</strong> Drag the top edge of the footer panel<br>
              <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--edge-main); font-size: 12px;">
                Hover over panel edges to see resize handles
              </div>
            </div>
          </div>
        </details>
      </aside>
    </main>
    <script id="nodes-json" type="application/json">{}</script>
    <script id="topology-state" type="application/json">ENCRYPTED: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</script>
    <script>
      const BASE_NODE_DATA = JSON.parse(document.getElementById("nodes-json").textContent, );
      let currentNodeId = "host";
      let textDrawMode = false;
      let currentEdgeId = null;
      let currentStyleScope = "all";
      let NODE_DATA = {};
      let EDGE_DATA = {
       list: []
      };
      let currentRectId = null;
      let currentTextId = null;
      let rectDrawMode = false;
      let RECT_DATA = {
       list: []
      };
      let TEXT_DATA = {
       list: []
      };
      let EDGE_LEGEND = {};
      let freeDrawMode = false;
      let savedPositions = {};
      let savedSizes = {};
      let savedStyles = {};
      let legendCollapsed = false;
      let minimapCollapsed = false;
      let drawToolbarCollapsed = false;
      let activeLayers = new Set(["physical", "logical", "security", "application"]);
      let currentView = {
       mode: "topology",  
       rackId: null      
      };
      let savedTopologyView = null; 
      let topologyToolbarCollapsed = false;
      let legendMiniBtn = null;
      let minimapMiniBtn = null;
      let drawToolbarMiniBtn = null;
      let topologyToolbarMiniBtn = null;
      
      let undoStack = [];
      let redoStack = [];
      const MAX_UNDO_STACK = 50;
      
      let selectedNodes = new Set();
      let selectedEdges = new Set();
      let selectedRects = new Set();
      let selectedTexts = new Set();
      let isSelecting = false;
      let selectionStart = null;
      let selectionRect = null;
      let selectionBoxStyle = {
       fillColor: "#4fd1c5",
       fillOpacity: 0.1,
       strokeColor: "#4fd1c5",
       strokeWidth: 2,
       strokeDasharray: "5,5"
      };
      let isDraggingSelection = false;
      let dragSelectionStart = null;
      
      let clipboard = null;
      
      const ROLLBACK_STORAGE_KEY = "theonefile_rollbacks";
      const MAX_ROLLBACK_VERSIONS = 50;
      let rollbackVersions = [];
      let currentRollbackIndex = -1;
      
      const AUDIT_STORAGE_KEY = "theonefile_audit_log";
      let auditLog = [];
      const MAX_AUDIT_ENTRIES = 1000;
      
      let documentTabs = [{
        id: "main",
        name: "Main Topology",
        nodes: {},
        edges: { list: [] },
        positions: {},
        sizes: {},
        styles: {},
        legend: {},
        rects: { list: [] },
        texts: { list: [] },
      pageState: null
      }];
      let currentTabIndex = 0;
      
      let encryptedSections = {}; 
      
      let performanceMode = "auto"; 
      let cullOffscreenNodes = true;
      let minimapNeedsUpdate = true;
      let lastMinimapUpdate = 0;
      
      const MobileManager = {
        isMobile: false,
        detect() {
          if (navigator.userAgentData?.mobile === true) {
            this.isMobile = true;
            return true;
          }
          const coarse = matchMedia("(pointer: coarse)").matches;
          const width = window.innerWidth <= 900;
          const portrait = matchMedia("(orientation: portrait)").matches;
          this.isMobile = coarse && (width || portrait);
          return this.isMobile;
        },
        applyInitialCollapse() {
          if (!this.isMobile) return;
          legendCollapsed = true;
          minimapCollapsed = true;
          drawToolbarCollapsed = true;
          topologyToolbarCollapsed = true;
          if (typeof updateLegendVisibility === "function") updateLegendVisibility();
          if (typeof updateMinimapVisibility === "function") updateMinimapVisibility();
          if (typeof updateDrawToolbarVisibility === "function") updateDrawToolbarVisibility();
          if (typeof updateTopologyToolbarVisibility === "function") updateTopologyToolbarVisibility();
        },
        updateBulkToolbar() {
          const desktop = document.getElementById("bulk-toolbar");
          const mobile = document.getElementById("bulk-toolbar-mobile");
          if (!desktop || !mobile) return;
          
          if (typeof selectedNodes === 'undefined' || selectedNodes.size === 0) {
           desktop.style.display = "none";
           mobile.style.display = "none";
           return;
          }
      
          const isVisible = desktop.style.display !== "none" || mobile.style.display !== "none";
          
          if (this.isMobile) {
            desktop.style.display = "none";
            if (isVisible) {
              mobile.style.display = "flex";
            }
          } else {
            mobile.style.display = "none";
            if (isVisible) {
              desktop.style.display = "flex";
            }
          }
        },
        updateLayout() {
          const main = document.querySelector("main");
          if (!main) return;
        },
        updateCanvasHint() {
      const hint = document.getElementById("canvas-hint");
      if (!hint) return;
      
      if (PAGE_STATE.canvasHintText !== undefined && PAGE_STATE.canvasHintText !== "") {
        hint.innerHTML = PAGE_STATE.canvasHintText;
        return;
      }
      
      const items = this.isMobile
      ? [
        "Pinch to zoom",
        "Drag to pan",
        "Add node from top menu",
        "Double tap to clone and align",
        "Double tap to select multiple",
        "You have the power",	
        "Your time is NOW!",
      ]
      : [
        "Scroll to zoom",
        "Drag to pan",
        "Right click to clone and align",
        "Right click to select multiple",
	    "Hold Shift + drag mouse for marquee selection",
        "You have the power",
        "Your time is NOW!",
      ];
      
      const list = document.createElement("ul");
      for (const item of items) {
      const li = document.createElement("li");
      li.textContent = item;
      list.appendChild(li);
      }
      
      hint.replaceChildren(list);
      },
        autoSelectStyleScope() {
          const scope = document.getElementById("style-scope");
          if (!scope) return;
          if (this.isMobile) scope.value = "mobile";
        },
        updateToolbarStack() {
          if (!this.isMobile) return;
          const draw = document.getElementById("draw-toolbar");
          const topo = document.getElementById("topology-toolbar");
          if (!draw || !topo) return;
          const h = draw.getBoundingClientRect().height;
          document.documentElement.style.setProperty("--draw-toolbar-height", h + "px");
        },
        updateLayoutControls() {
          const sidebarRow = document.getElementById("sidebar-width-row");
          const footerRow = document.getElementById("mobile-footer-row");
          if (sidebarRow && footerRow) {
            if (this.isMobile) {
              sidebarRow.style.display = "none";
              footerRow.style.display = "flex";
            } else {
              sidebarRow.style.display = "flex";
              footerRow.style.display = "none";
            }
          }
        },
        applyAll() {
          this.detect();
          this.applyInitialCollapse();
          this.updateBulkToolbar();
          this.updateLayout();
          this.updateCanvasHint();
          this.autoSelectStyleScope();
          this.updateToolbarStack();
          this.updateLayoutControls();
        }
      };
      
      function isMobileDevice() {
        return MobileManager.isMobile;
      }
      
      function u8ToBase64(u8) {
      let binary = "";
      for (let i = 0; i < u8.length; i++) binary += String.fromCharCode(u8[i]);
      return btoa(binary);
      }
      
      function base64ToU8(base64) {
      const binary = atob(base64);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
      return bytes;
      }
      
      function ensureLegendMiniButton() {
       if (legendMiniBtn) return legendMiniBtn;
	   const existing = document.getElementById("edge-legend-mini");
       if (existing) { legendMiniBtn = existing; return existing; }
       const panel = document.querySelector(".topology-panel");
       if (!panel) return null;
       const btn = document.createElement("button");
       btn.type = "button";
       btn.id = "edge-legend-mini";
       btn.className = "legend-mini-btn";
       btn.textContent = "Legend";
       btn.style.bottom = "10px";
       const handleClick = (e) => {
        e.stopPropagation();
        e.preventDefault();
        legendCollapsed = false;
        updateLegendVisibility();
       };
       btn.addEventListener("click", handleClick);
       btn.addEventListener("touchend", handleClick);
       panel.appendChild(btn);
       legendMiniBtn = btn;
       return btn;
      }
      
      function ensureMinimapMiniButton() {
       if (minimapMiniBtn) return minimapMiniBtn;
	   const existing = document.getElementById("minimap-mini");
       if (existing) { minimapMiniBtn = existing; return existing; }
       const panel = document.querySelector(".topology-panel");
       if (!panel) return null;
       const btn = document.createElement("button");
       btn.type = "button";
       btn.id = "minimap-mini";
       btn.className = "legend-mini-btn";
       btn.textContent = "Map";
       btn.style.right = "10px";
       btn.style.left = "auto";
       btn.style.bottom = "10px";
       const handleClick = (e) => {
        e.stopPropagation();
        e.preventDefault();
        minimapCollapsed = false;
        updateMinimapVisibility();
       };
       btn.addEventListener("click", handleClick);
       btn.addEventListener("touchend", handleClick);
       panel.appendChild(btn);
       minimapMiniBtn = btn;
       return btn;
      }
      
      function ensureDrawToolbarMiniButton() {
       if (drawToolbarMiniBtn) return drawToolbarMiniBtn;
	   const existing = document.getElementById("draw-toolbar-mini");
       if (existing) { drawToolbarMiniBtn = existing; return existing; }
       const panel = document.querySelector(".topology-panel");
       if (!panel) return null;
       const btn = document.createElement("button");
       btn.type = "button";
       btn.id = "draw-toolbar-mini";
       btn.className = "legend-mini-btn";
       btn.textContent = "Draw";
       btn.style.top = "10px";
       btn.style.left = "10px";
       btn.style.right = "auto";
       const handleClick = (e) => {
        e.stopPropagation();
        e.preventDefault();
        drawToolbarCollapsed = false;
        updateDrawToolbarVisibility();
       };
       btn.addEventListener("click", handleClick);
       btn.addEventListener("touchend", handleClick);
       panel.appendChild(btn);
       drawToolbarMiniBtn = btn;
       return btn;
      }
      
      function ensureTopologyToolbarMiniButton() {
       if (topologyToolbarMiniBtn) return topologyToolbarMiniBtn;
	   const existing = document.getElementById("topology-toolbar-mini");
       if (existing) { topologyToolbarMiniBtn = existing; return existing; }
       const panel = document.querySelector(".topology-panel");
       if (!panel) return null;
       const btn = document.createElement("button");
       btn.type = "button";
       btn.id = "topology-toolbar-mini";
       btn.className = "legend-mini-btn";
       btn.textContent = "Add Line";
       btn.style.top = "10px";
       btn.style.left = "auto";
       btn.style.right = "40px";
       const handleClick = (e) => {
        e.stopPropagation();
        e.preventDefault();
        topologyToolbarCollapsed = false;
        updateTopologyToolbarVisibility();
       };
       btn.addEventListener("click", handleClick);
       btn.addEventListener("touchend", handleClick);
       panel.appendChild(btn);
       topologyToolbarMiniBtn = btn;
       return btn;
      }
      
      function updateToolbarStack() {
       if (!isMobileDevice()) return;
       const draw = document.getElementById("draw-toolbar");
       const topo = document.getElementById("topology-toolbar");
       if (!draw || !topo) return;
       const h = draw.getBoundingClientRect().height;
       document.documentElement.style.setProperty("--draw-toolbar-height", h + "px");
      }
      window.addEventListener("resize", updateToolbarStack);
      window.addEventListener("DOMContentLoaded", updateToolbarStack);
      updateToolbarStack();
      
      function updateLegendVisibility() {
       const legend = document.getElementById("edge-legend");
       const mini = ensureLegendMiniButton();
       if (!legend || !mini) return;
       const hasItems = legend.querySelectorAll(".legend-item").length > 0;
       if (!hasItems) {
        legend.style.display = "none";
        mini.style.display = "none";
        return;
       }
       if (legendCollapsed) {
        legend.style.display = "none";
        mini.style.display = "inline-flex";
       } else {
        legend.style.display = "flex";
        mini.style.display = "none";
       }
      }
      
      function updateMinimapVisibility() {
       const wrapper = document.getElementById("minimap-zoom-wrapper");
       const mini = ensureMinimapMiniButton();
       if (!wrapper || !mini) return;
       if (minimapCollapsed) {
        wrapper.style.display = "none";
        mini.style.display = "inline-flex";
       } else {
        wrapper.style.display = "block";
        mini.style.display = "none";
       }
      }
      
      function updateDrawToolbarVisibility() {
       const toolbar = document.getElementById("draw-toolbar");
       const mini = ensureDrawToolbarMiniButton();
       if (isViewOnly()) {
        if (toolbar) toolbar.style.setProperty('display', 'none', 'important');
        if (mini) mini.style.display = "none";
        return;
       }
       if (!toolbar || !mini) return;
       if (drawToolbarCollapsed) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "inline-flex";
       } else {
      if (isMobileDevice()) {    	   
        toolbar.style.setProperty('display', 'grid', 'important');
        mini.style.display = "none";
      } else {   
        toolbar.style.setProperty('display', 'flex', 'important');
        mini.style.display = "none";	  
      }
       }
      }
      
      function updateTopologyToolbarVisibility() {
       const toolbar = document.getElementById("topology-toolbar");
       const mini = ensureTopologyToolbarMiniButton();
       if (isViewOnly()) {
        if (toolbar) toolbar.style.setProperty('display', 'none', 'important');
        if (mini) mini.style.display = "none";
        return;
       }
       if (!toolbar || !mini) return;
       const hasSelectedNode = currentNodeId !== null;
       if (!hasSelectedNode) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "none";
       } else if (topologyToolbarCollapsed) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "inline-flex";
       } else {   
      if (isMobileDevice()) {    	   
        toolbar.style.setProperty('display', 'grid', 'important');
        mini.style.display = "none";
        } else {   
        toolbar.style.setProperty('display', 'flex', 'important');
        mini.style.display = "none";	  
      }
       }
      }
      const DEFAULT_CANVAS_HINT = document.getElementById("canvas-hint")?.innerHTML || "";
      const DEFAULT_PAGE_STATE = {
       title: "The One File",
       background: "",
       topbarBg: "rgba(9, 12, 20, 0.9)",
       topbarBorder: "#1f2533",
       panel: "#0b0e13",
       panelAlt: "#10141b",
       accent: "#4fd1c5",
       sidebarBg: "#10141b",
       btnBg: "#0b0e13",
       btnText: "#e2e8f0",
       tagFill: "#1e293b",
       tagText: "#e2e8f0",
       tagBorder: "#475569",
       inputBg: "#0b0e13",
       inputText: "#e2e8f0",
       inputBorder: "#1f2937",
       inputFont: "Inter, system-ui, sans-serif",
       inputFontSize: 14,
       toolbarBg: "#0f172a",
       toolbarBorder: "#1f2937",
       toolbarText: "#94a3b8",
       toolbarBtnBg: "#0b0e13",
       toolbarBtnText: "#e2e8f0",
       minimapDots: "#94a3b8",
       canvasHintEnabled: true,
       canvasHintText: "",
       canvasHintBg: "#0f172a",
       canvasHintColor: "#94a3b8",
       danger: "#f56565",
       textMain: "#e2e8f0",
       textSoft: "#94a3b8",
       topbarHeight: 52,
       sidebarWidth: 350,
       mobileFooterHeight: 40,
       sidebarCollapsed: false,
       nodeFill: "#1e293b",
       nodeStroke: "#475569",
       nodeTitle: "#e2e8f0",
       nodeSub: "#94a3b8",
       nodeTitleSize: 18,
       nodeSubSize: 13,
       nodeFont: "Inter, system-ui, sans-serif",
       defaultEdge: "#475569",
       selectionHandle: "#f59e0b",
       selectionHandleSize: 8,
       groupIndicator: "#4fd1c5",
      canvasGradientTop: "#1e2532",
       canvasGradientBottom: "#050608",
       canvasBorder: "#475569",
       canvasGrid: "#475569",
       canvasGridSize: 50,
       rackFrameFill: "#0f172a",
       rackFrameStroke: "#4fd1c5",
       rackLineColor: "#475569",
       rackTextColor: "#4fd1c5",
	   viewOnly: false,
      };
      let PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE);
	  function isViewOnly() {
       return PAGE_STATE.viewOnly === true;
      }
	  let viewOnlyClickCount = 0;
      let viewOnlyClickTimer = null;
      let viewOnlyClickTarget = null;
      
      function handleViewOnlyClick(id, type) {
       if (!isViewOnly()) return false;
       
       if (viewOnlyClickTarget !== id) {
        viewOnlyClickCount = 0;
        viewOnlyClickTarget = id;
       }
       
       viewOnlyClickCount++;
       
       clearTimeout(viewOnlyClickTimer);
       viewOnlyClickTimer = setTimeout(() => {
        viewOnlyClickCount = 0;
        viewOnlyClickTarget = null;
       }, 2000);
       
       if (viewOnlyClickCount >= 5) {
        viewOnlyClickCount = 0;
        viewOnlyClickTarget = null;
        
        document.body.classList.add("view-only-inspect");
        
        if (type === 'node') {
         currentNodeId = id;
         const data = NODE_DATA[id];
         if (data) {
          document.querySelectorAll(".node-group").forEach((n) => {
           n.classList.toggle("active", n.dataset.nodeId === id);
          });
          document.getElementById("node-panel").style.display = "block";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("node-name").textContent = data.name;
          document.getElementById("node-ip").textContent = data.ip;
          document.getElementById("node-role").textContent = data.role;
          document.getElementById("node-mac").textContent = data.mac || "--";
          document.getElementById("node-rack").textContent = data.rackUnit || "--";
          document.getElementById("node-uheight").textContent = (data.uHeight || "1") + "U";
          
          const tagList = document.getElementById("node-tags");
          if (tagList) {
           tagList.innerHTML = "";
           if (data.tags && data.tags.length > 0) {
            data.tags.forEach((tag) => {
             const li = document.createElement("li");
             li.textContent = tag;
             tagList.appendChild(li);
            });
           }
          }
          
          const noteList = document.getElementById("node-notes");
          if (noteList) {
           noteList.innerHTML = "";
           if (data.notes && data.notes.length > 0) {
            data.notes.forEach((note) => {
             const li = document.createElement("li");
             li.textContent = note;
             noteList.appendChild(li);
            });
           }
          }
         }
        } else if (type === 'edge') {
         currentEdgeId = id;
         const edge = EDGE_DATA.list.find(e => e.id === id);
         if (edge) {
          document.querySelectorAll(".edge").forEach((e) => {
           e.classList.toggle("active", e.dataset.edgeId === id);
          });
          document.getElementById("edge-panel").style.display = "block";
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-from").textContent = NODE_DATA[edge.from]?.name || edge.from;
          document.getElementById("edge-to").textContent = NODE_DATA[edge.to]?.name || edge.to;
          document.getElementById("edge-label").value = edge.label || "";
         }
        }
        return true;
       }
       return false;
      }
	  
      const CANVAS_WIDTH = 4000;
      let CANVAS_HEIGHT = 3000;
      const BASE_CANVAS_HEIGHT = 3000;
      const CANVAS_PADDING = 100;
      
      const RACK_U_HEIGHT = 70; 
      const RACK_WIDTH = 600;
      const RACK_START_X = CANVAS_WIDTH / 2; 
      const RACK_START_Y = CANVAS_PADDING + 100;
      function getRackUHeight(rackId) {
      const capacity = getRackCapacity(rackId);
      const availableHeight = CANVAS_HEIGHT - RACK_START_Y - 200;
      return Math.floor(availableHeight / capacity);
      }
      let canvasState = {
       zoom: 1,
       panX: 0,
       panY: 0,
       minZoom: 0.25,
       maxZoom: 4,
       isPanning: false,
       panStartX: 0,
       panStartY: 0,
       spacePressed: false,
      };
      
      function getViewBox() {
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       return {
        x: canvasState.panX,
        y: canvasState.panY,
        width: viewWidth,
        height: viewHeight,
       };
      }
      
      function updateViewBox() {
       const svg = document.getElementById("map");
       const vb = getViewBox();
       svg.setAttribute("viewBox", `${vb.x} ${vb.y} ${vb.width} ${vb.height}`, );
       const zoomLevel = document.getElementById("zoom-level");
       if (zoomLevel) {
        zoomLevel.textContent = Math.round(canvasState.zoom * 100) + "%";
       }
       updateMinimap();
       populateRackDropdown();
      }
      
      function updateMinimap() {
       const minimapViewport = document.getElementById("minimap-viewport");
       const minimapSvg = document.getElementById("minimap");
       if (!minimapViewport || !minimapSvg) return;
       const vb = getViewBox();
       minimapViewport.setAttribute("x", vb.x);
       minimapViewport.setAttribute("y", vb.y);
       minimapViewport.setAttribute("width", vb.width);
       minimapViewport.setAttribute("height", vb.height);
       const minimapNodes = minimapSvg.querySelectorAll(".minimap-node");
       minimapNodes.forEach((n) => n.remove());
       const minimapEdges = minimapSvg.querySelectorAll(".minimap-edge");
       minimapEdges.forEach((e) => e.remove());
       
       EDGE_DATA.list.forEach((edge) => {
        if (edge.type === "custom") return;
        
        const fromNode = NODE_DATA[edge.from];
        const toNode = NODE_DATA[edge.to];
        if (!fromNode || !toNode) return;
        
        if (currentView.mode === "rack") {
         if (fromNode.assignedRack !== currentView.rackId || 
             toNode.assignedRack !== currentView.rackId) {
          return;
         }
        } else {
         if (fromNode.assignedRack || toNode.assignedRack) {
          return;
         }
        }
        
        const p1 = savedPositions[edge.from];
        const p2 = savedPositions[edge.to];
        if (!p1 || !p2) return;
        const line = document.createElementNS("http://www.w3.org/2000/svg", "line", );
        line.setAttribute("x1", p1.x);
        line.setAttribute("y1", p1.y);
        line.setAttribute("x2", p2.x);
        line.setAttribute("y2", p2.y);
        line.classList.add("minimap-edge");
        minimapSvg.insertBefore(line, minimapViewport);
       });
       
       Object.entries(savedPositions).forEach(([id, pos]) => {
        const node = NODE_DATA[id];
        if (!node) return;
        
        if (currentView.mode === "rack") {
         if (node.assignedRack !== currentView.rackId) {
          return; 
         }
        } else {
         if (node.assignedRack) {
          return; 
         }
        }
        
        const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle", );
        circle.setAttribute("cx", pos.x);
        circle.setAttribute("cy", pos.y);
        circle.setAttribute("r", 40);
        circle.classList.add("minimap-node");
        minimapSvg.insertBefore(circle, minimapViewport);
       });
      }
      
      function zoomTo(newZoom, centerX, centerY) {
       const oldZoom = canvasState.zoom;
       newZoom = Math.max(canvasState.minZoom, Math.min(canvasState.maxZoom, newZoom), );
       if (centerX !== undefined && centerY !== undefined) {
        const oldWidth = CANVAS_WIDTH / oldZoom;
        const oldHeight = CANVAS_HEIGHT / oldZoom;
        const newWidth = CANVAS_WIDTH / newZoom;
        const newHeight = CANVAS_HEIGHT / newZoom;
        const pointX = canvasState.panX + centerX * oldWidth;
        const pointY = canvasState.panY + centerY * oldHeight;
        canvasState.panX = pointX - centerX * newWidth;
        canvasState.panY = pointY - centerY * newHeight;
       }
       canvasState.zoom = newZoom;
       constrainPan();
       updateViewBox();
      }
      
      function constrainPan() {
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       const minVisiblePortion = 0.1;
       const maxPanX = CANVAS_WIDTH - viewWidth * minVisiblePortion;
       const maxPanY = CANVAS_HEIGHT - viewHeight * minVisiblePortion;
       const minPanX = -viewWidth * (1 - minVisiblePortion);
       const minPanY = -viewHeight * (1 - minVisiblePortion);
       canvasState.panX = Math.max(minPanX, Math.min(maxPanX, canvasState.panX), );
       canvasState.panY = Math.max(minPanY, Math.min(maxPanY, canvasState.panY), );
      }
      
      function fitToContent() {
       const positions = Object.values(savedPositions);
       if (positions.length === 0) {
        resetView();
        return;
       }
       let minX = Infinity,
        minY = Infinity,
        maxX = -Infinity,
        maxY = -Infinity;
       positions.forEach((pos) => {
        minX = Math.min(minX, pos.x - 100);
        minY = Math.min(minY, pos.y - 100);
        maxX = Math.max(maxX, pos.x + 100);
        maxY = Math.max(maxY, pos.y + 100);
       });
       const contentWidth = maxX - minX + 200;
       const contentHeight = maxY - minY + 200;
       const viewport = document.getElementById("canvas-viewport");
       const vpRect = viewport.getBoundingClientRect();
       const aspectRatio = vpRect.width / vpRect.height;
       const contentAspect = contentWidth / contentHeight;
       let newZoom;
       if (contentAspect > aspectRatio) {
        newZoom = (vpRect.width / contentWidth) * (CANVAS_WIDTH / vpRect.width);
       } else {
        newZoom = (vpRect.height / contentHeight) * (CANVAS_HEIGHT / vpRect.height);
       }
       newZoom = Math.max(canvasState.minZoom, Math.min(2, newZoom));
       const viewWidth = CANVAS_WIDTH / newZoom;
       const viewHeight = CANVAS_HEIGHT / newZoom;
       canvasState.zoom = newZoom;
       canvasState.panX = minX - 100 - (viewWidth - contentWidth) / 2;
       canvasState.panY = minY - 100 - (viewHeight - contentHeight) / 2;
       constrainPan();
       updateViewBox();
      }
      
      function resetView() {
       canvasState.zoom = 1;
       canvasState.panX = 0;
       canvasState.panY = 0;
       updateViewBox();
      }
      window.addEventListener("DOMContentLoaded", () => {
       const toggle = document.getElementById("mobile-menu-toggle");
       const menu = document.getElementById("topbar-menu");
       if (!toggle || !menu) return;
       toggle.addEventListener("click", () => {
        menu.classList.toggle("open");
       });
       menu.addEventListener("click", (e) => {
        const target = e.target.closest("a, button");
        if (!target) return;
        if (isMobileDevice()) {
       menu.classList.remove("open");
      }
       });
       const minimapCloseBtn = document.getElementById("minimap-close-btn");
       if (minimapCloseBtn) {
        const handleMinimapClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         minimapCollapsed = true;
         updateMinimapVisibility();
        };
        minimapCloseBtn.addEventListener("click", handleMinimapClose);
        minimapCloseBtn.addEventListener("touchend", handleMinimapClose);
       }
       const drawToolbarCloseBtn = document.getElementById("draw-toolbar-close-btn");
       if (drawToolbarCloseBtn) {
        const handleDrawClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         drawToolbarCollapsed = true;
         updateDrawToolbarVisibility();
        };
        drawToolbarCloseBtn.addEventListener("click", handleDrawClose);
        drawToolbarCloseBtn.addEventListener("touchend", handleDrawClose);
       }
       const topologyToolbarCloseBtn = document.getElementById("topology-toolbar-close-btn");
       if (topologyToolbarCloseBtn) {
        const handleTopologyClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         topologyToolbarCollapsed = true;
         updateTopologyToolbarVisibility();
        };
        topologyToolbarCloseBtn.addEventListener("click", handleTopologyClose);
        topologyToolbarCloseBtn.addEventListener("touchstart", (e) => e.preventDefault(), {
         passive: false
        });
        topologyToolbarCloseBtn.addEventListener("touchend", handleTopologyClose);
       }
      
       updateMinimapVisibility();
       updateDrawToolbarVisibility();
       updateTopologyToolbarVisibility();
      });
      
      function applyLayerFilter() {
       activeLayers.clear();
       if (document.getElementById("layer-physical").checked) activeLayers.add("physical");
       if (document.getElementById("layer-logical").checked) activeLayers.add("logical");
       if (document.getElementById("layer-security").checked) activeLayers.add("security");
       if (document.getElementById("layer-application").checked) activeLayers.add("application");
       forgeTheTopology();
      }
      
      function isNodeVisible(nodeId) {
       const node = NODE_DATA[nodeId];
       if (!node) return false;
       const nodeLayer = node.layer || "physical";
       return activeLayers.has(nodeLayer);
      }
      
      function enterRack(rackId) {
      if (!NODE_DATA[rackId] || !NODE_DATA[rackId].isRack) return;
      const rackCapacity = getRackCapacity(rackId);
      const neededHeight = RACK_START_Y + (rackCapacity * RACK_U_HEIGHT) + 200;
      if (neededHeight > BASE_CANVAS_HEIGHT) {
      CANVAS_HEIGHT = neededHeight;
      }
       
       savedTopologyView = {
        zoom: canvasState.zoom,
        panX: canvasState.panX,
        panY: canvasState.panY
       };
       
       currentView.mode = "rack";
       currentView.rackId = rackId;
       
       const backBtn = document.getElementById("back-to-topology-btn");
       if (backBtn) backBtn.style.display = "inline-block";
       
       const hint = document.getElementById("canvas-hint");
       if (hint) {
        hint.textContent = `Viewing: ${NODE_DATA[rackId].name} | Double click empty space to exit`;
        hint.classList.add("visible");
       }
       
      
      const rackUHeight = getRackUHeight(rackId);
      const rackHeight = rackCapacity * rackUHeight;
      const rackCenterX = RACK_START_X;
      const rackCenterY = RACK_START_Y + (rackHeight / 2);
       
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       
       canvasState.panX = rackCenterX - (viewWidth / 2);
       canvasState.panY = rackCenterY - (viewHeight / 2);
       
       constrainPan();
       updateViewBox();
       
       forgeTheTopology();
      }
      
      function exitRack() {
      CANVAS_HEIGHT = BASE_CANVAS_HEIGHT;
      currentView.mode = "topology";
      currentView.rackId = null;
       
       const backBtn = document.getElementById("back-to-topology-btn");
       if (backBtn) backBtn.style.display = "none";
       
       const hint = document.getElementById("canvas-hint");
       if (hint) {
        hint.classList.remove("visible");
       }
       
       if (savedTopologyView) {
        canvasState.zoom = savedTopologyView.zoom;
        canvasState.panX = savedTopologyView.panX;
        canvasState.panY = savedTopologyView.panY;
        updateViewBox();
       }
       
       forgeTheTopology();
      }
      
      function getRackCapacity(rackId) {
       const node = NODE_DATA[rackId];
       return node && node.rackCapacity ? parseInt(node.rackCapacity) : 42;
      }
      
      function populateRackDropdown() {
       const dropdown = document.getElementById("node-assigned-rack");
       if (!dropdown) return;
       
       dropdown.innerHTML = '<option value="">None</option>';
       
       Object.keys(NODE_DATA).forEach(id => {
        if (NODE_DATA[id].isRack) {
         const option = document.createElement("option");
         option.value = id;
         option.textContent = NODE_DATA[id].name;
         dropdown.appendChild(option);
        }
       });
      }
      
      function wieldThePower() {
       const root = document.documentElement;
       root.style.setProperty("--panel", PAGE_STATE.panel);
       root.style.setProperty("--panel-alt", PAGE_STATE.panelAlt);
       root.style.setProperty("--sidebar-bg", PAGE_STATE.sidebarBg || PAGE_STATE.panelAlt);
       root.style.setProperty("--btn-bg", PAGE_STATE.btnBg || PAGE_STATE.panel);
       root.style.setProperty("--btn-text", PAGE_STATE.btnText || "#e2e8f0");
       root.style.setProperty("--tag-fill", PAGE_STATE.tagFill || "#1e293b");
       root.style.setProperty("--tag-text", PAGE_STATE.tagText || "#e2e8f0");
       root.style.setProperty("--tag-border", PAGE_STATE.tagBorder || "#475569");
       root.style.setProperty("--input-bg", PAGE_STATE.inputBg || "#0b0e13");
       root.style.setProperty("--input-text", PAGE_STATE.inputText || "#e2e8f0");
       root.style.setProperty("--input-border", PAGE_STATE.inputBorder || "#1f2937");
       root.style.setProperty("--input-font", PAGE_STATE.inputFont || "Inter, system-ui, sans-serif");
       root.style.setProperty("--input-font-size", (PAGE_STATE.inputFontSize || 14) + "px");
       root.style.setProperty("--toolbar-bg", PAGE_STATE.toolbarBg || "#0f172a");
       root.style.setProperty("--toolbar-border", PAGE_STATE.toolbarBorder || "#1f2937");
       root.style.setProperty("--toolbar-text", PAGE_STATE.toolbarText || "#94a3b8");
       root.style.setProperty("--toolbar-btn-bg", PAGE_STATE.toolbarBtnBg || "#0b0e13");
       root.style.setProperty("--toolbar-btn-text", PAGE_STATE.toolbarBtnText || "#e2e8f0");
       root.style.setProperty("--minimap-dots", PAGE_STATE.minimapDots || "#94a3b8");
       root.style.setProperty("--canvas-hint-bg", PAGE_STATE.canvasHintBg || "#0f172a");
       root.style.setProperty("--canvas-hint-color", PAGE_STATE.canvasHintColor || "#94a3b8");
       
       const canvasHint = document.getElementById("canvas-hint");
       if (canvasHint) {
        canvasHint.style.display = PAGE_STATE.canvasHintEnabled === false ? "none" : "";
        if (PAGE_STATE.canvasHintText !== undefined && PAGE_STATE.canvasHintText !== "") {
         canvasHint.innerHTML = PAGE_STATE.canvasHintText;
        } else {
         canvasHint.innerHTML = DEFAULT_CANVAS_HINT;
        }
       }
       root.style.setProperty("--accent", PAGE_STATE.accent);
       root.style.setProperty("--danger", PAGE_STATE.danger);
       root.style.setProperty("--text-main", PAGE_STATE.textMain);
       root.style.setProperty("--text-soft", PAGE_STATE.textSoft);
       root.style.setProperty("--topbar-bg", PAGE_STATE.topbarBg);
       root.style.setProperty("--topbar-border", PAGE_STATE.topbarBorder);
       root.style.setProperty("--node-fill", PAGE_STATE.nodeFill || "#1e293b");
       root.style.setProperty("--node-stroke", PAGE_STATE.nodeStroke || "#475569");
       root.style.setProperty("--node-title", PAGE_STATE.nodeTitle || "#e2e8f0");
       root.style.setProperty("--node-sub", PAGE_STATE.nodeSub || "#94a3b8");
       root.style.setProperty("--node-title-size", (PAGE_STATE.nodeTitleSize || 18) + "px");
       root.style.setProperty("--node-sub-size", (PAGE_STATE.nodeSubSize || 13) + "px");
       root.style.setProperty("--node-font", PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif");
       root.style.setProperty("--default-edge", PAGE_STATE.defaultEdge || "#475569");
       root.style.setProperty("--selection-handle", PAGE_STATE.selectionHandle || "#f59e0b");
       root.style.setProperty("--selection-handle-size", (PAGE_STATE.selectionHandleSize || 8) + "px");
       root.style.setProperty("--group-indicator", PAGE_STATE.groupIndicator || "#4fd1c5");
       const topbarHeight = PAGE_STATE.topbarHeight || 52;
       const sidebarWidth = PAGE_STATE.sidebarWidth || 350;
       const mobileFooterHeight = PAGE_STATE.mobileFooterHeight || 40;
       root.style.setProperty("--topbar-height", topbarHeight + "px");
       root.style.setProperty("--sidebar-width", sidebarWidth + "px");
       root.style.setProperty("--mobile-footer-height", mobileFooterHeight + "vh", );
       const mainEl = document.querySelector("main");
       const detailsPanel = document.getElementById("details-panel");
       const sidebarToggle = document.getElementById("sidebar-toggle");
       if (PAGE_STATE.sidebarCollapsed) {
        if (mainEl) mainEl.classList.add("sidebar-collapsed");
        if (detailsPanel) detailsPanel.classList.add("collapsed");
        if (sidebarToggle) {
         sidebarToggle.classList.add("collapsed");
         sidebarToggle.textContent = "▶";
        }
       } else {
        if (mainEl) mainEl.classList.remove("sidebar-collapsed");
        if (detailsPanel) detailsPanel.classList.remove("collapsed");
        if (sidebarToggle) {
         sidebarToggle.classList.remove("collapsed");
         sidebarToggle.textContent = "◀";
        }
       }
       if (PAGE_STATE.background) {
        document.body.style.background = PAGE_STATE.background;
       } else {
        document.body.style.background = `radial-gradient(circle at top, ${PAGE_STATE.canvasGradientTop || "#1e2532"} 0, ${PAGE_STATE.canvasGradientBottom || "#050608"} 70%)`;
       }
       document.title = PAGE_STATE.title || DEFAULT_PAGE_STATE.title;
       const titleEl = document.getElementById("page-title");
       if (titleEl) {
        titleEl.textContent = PAGE_STATE.title || DEFAULT_PAGE_STATE.title;
       }
       
       const sidebarToggleEl = document.getElementById("sidebar-toggle");
       const isMobile = isMobileDevice();
       if (sidebarToggleEl) {
        sidebarToggleEl.style.display = isMobile ? "none" : "flex";
       }
       const viewOnlyMode = PAGE_STATE.viewOnly === true;
       const addNodeBtn = document.getElementById("add-node-btn");
       const addRackBtn = document.getElementById("add-rack-btn");
       const drawToolbar = document.getElementById("draw-toolbar");
       const topologyToolbar = document.getElementById("topology-toolbar");
       const bulkToolbar = document.getElementById("bulk-toolbar");
       
       if (addNodeBtn) addNodeBtn.style.display = viewOnlyMode ? "none" : "";
       if (addRackBtn) addRackBtn.style.display = viewOnlyMode ? "none" : "";
       if (viewOnlyMode) {
        if (drawToolbar) drawToolbar.style.setProperty('display', 'none', 'important');
        if (topologyToolbar) topologyToolbar.style.setProperty('display', 'none', 'important');
        if (bulkToolbar) bulkToolbar.style.display = "none";
        const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
       }
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       if (bulkToolbarMobile) bulkToolbarMobile.style.display = viewOnlyMode ? "none" : "";
       ["draw-toolbar-mini", "topology-toolbar-mini"].forEach(id => {
        const el = document.getElementById(id);
        if (el) el.style.display = viewOnlyMode ? "none" : "";
       });
       
       document.body.classList.toggle("view-only-mode", viewOnlyMode);
      }
      (async function awakeTheImmortal() {
       let initialState = {};
       let decryptionCancelled = false;
       const stateEl = document.getElementById("topology-state");
       if (stateEl && stateEl.textContent.trim()) {
        try {
         let stateText = stateEl.textContent.trim();
         if (isEncrypted(stateText)) {
          let decrypted = false;
          let attempts = 0;
          const maxAttempts = 3;
          while (!decrypted && attempts < maxAttempts) {
           const password = prompt("This file is encrypted. Enter password to decrypt:\n(Attempt " + (attempts + 1) + " of " + maxAttempts + ")", );
           if (!password) {
            alert("Decryption cancelled. The file will not be loaded.", );
            decryptionCancelled = true;
            break;
           }
           try {
            stateText = await decryptData(stateText, password);
            decrypted = true;
           } catch (e) {
            attempts++;
            if (attempts < maxAttempts) {
             alert("Incorrect password. Please try again.");
            } else {
             alert("Maximum attempts reached. The file will not be loaded.", );
             decryptionCancelled = true;
            }
           }
          }
          if (!decrypted) {
           stateText = "{}";
          }
         }
         initialState = JSON.parse(stateText);
        } catch (e) {
         console.error("Failed to load state:", e);
         initialState = {};
        }
       }
       if (decryptionCancelled) {
        NODE_DATA = {};
        EDGE_DATA = {
         list: []
        };
        RECT_DATA = { list: [] };
        TEXT_DATA = { list: [] };
        EDGE_LEGEND = {};
        savedPositions = {};
        savedSizes = {};
        savedStyles = {};
       } else {
        NODE_DATA = initialState.nodeData ? initialState.nodeData : BASE_NODE_DATA;
        EDGE_DATA = initialState.edgeData ? initialState.edgeData : {
         list: [],
        };
        RECT_DATA = initialState.rectData ? initialState.rectData : { list: [] };
        TEXT_DATA = initialState.textData ? initialState.textData : { list: [] };
        EDGE_LEGEND = initialState.edgeLegend || {};
        savedPositions = initialState.nodePositions || {};
        savedSizes = initialState.nodeSizes || {};
        savedStyles = initialState.nodeStyles || {};
       }
       if (initialState.page) {
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, initialState.page, );
       }
       if (initialState.canvas) {
        canvasState.zoom = initialState.canvas.zoom || 1;
        canvasState.panX = initialState.canvas.panX || 0;
        canvasState.panY = initialState.canvas.panY || 0;
       }
       
       if (initialState.savedTopologyView) {
        savedTopologyView = initialState.savedTopologyView;
       }
       
       if (initialState.documentTabs) {
        documentTabs = initialState.documentTabs;
        currentTabIndex = initialState.currentTabIndex || 0;
        
        const currentTab = documentTabs[currentTabIndex];
        if (currentTab) {
          NODE_DATA = currentTab.nodes || NODE_DATA;
          EDGE_DATA = currentTab.edges || EDGE_DATA;
          savedPositions = currentTab.positions || savedPositions;
          savedSizes = currentTab.sizes || savedSizes;
          savedStyles = currentTab.styles || savedStyles;
          EDGE_LEGEND = currentTab.legend || EDGE_LEGEND;
          RECT_DATA = currentTab.rects || RECT_DATA;
          TEXT_DATA = currentTab.texts || TEXT_DATA;
      if (currentTab.pageState) PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, currentTab.pageState);
        }
       }
           
       if (initialState.encryptedSections) {
        encryptedSections = initialState.encryptedSections;
       }
       
       wieldThePower();
       forgeTheTopology();
       updateViewBox();
       
       MobileManager.applyAll();
       
       const initialNodes = Object.keys(NODE_DATA);
       if (initialNodes.length > 0) {
        claimTheImmortal(initialNodes.includes("host") ? "host" : initialNodes[0], );
       } else {
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.display = "none";
       }
      })();
      
      let resizeDebounceTimer = null;
      window.addEventListener("resize", () => {
        clearTimeout(resizeDebounceTimer);
        resizeDebounceTimer = setTimeout(() => {
          MobileManager.applyAll();
          if (typeof updateDrawToolbarVisibility === 'function') updateDrawToolbarVisibility();
          if (typeof updateTopologyToolbarVisibility === 'function') updateTopologyToolbarVisibility();
        }, 100);
      });
      
      function getBreakpointKey() {
       const w = window.innerWidth;
       if (w <= 380) return "fold";
       if (w <= 768) return "mobile";
       if (w <= 1024) return "tablet";
       return "desktop";
      }
      
      function resolveStylesEntry(styleEntry) {
       if (!styleEntry) return {};
       if (styleEntry.circleColor || styleEntry.titleColor || styleEntry.titleFont || styleEntry.titleSize || styleEntry.subColor || styleEntry.subFont || styleEntry.subSize) {
        return styleEntry;
       }
       const bp = getBreakpointKey();
       const base = styleEntry.all || {};
       const bpStyles = styleEntry[bp] || {};
       return Object.assign({}, base, bpStyles);
      }
      
      function resolveStylesForNode(id) {
       const styleEntry = savedStyles[id];
       if (!styleEntry) return {};
       return resolveStylesEntry(styleEntry);
      }
      
      function ensureStyleEntry(id) {
       if (!savedStyles[id]) savedStyles[id] = {};
       const entry = savedStyles[id];
       const flatProps = ["circleColor", "circleBorder", "titleColor", "titleFont", "titleSize", "subColor", "subFont", "subSize", ];
       const isFlat = flatProps.some((p) => Object.prototype.hasOwnProperty.call(entry, p), );
       if (isFlat) {
        const all = entry.all || {};
        flatProps.forEach((p) => {
         if (entry[p] !== undefined) {
          all[p] = entry[p];
          delete entry[p];
         }
        });
        entry.all = all;
       }
       return entry;
      }
      
      function getDefaultSize() {
       if (window.innerWidth <= 380) return 120;
       if (window.innerWidth <= 768) return 140;
       if (window.innerWidth <= 1024) return 70;
       return 55;
      }
      
      function createShapeElement(shape, size) {
       const ns = "http://www.w3.org/2000/svg";
       if (shape === "circle") {
        const c = document.createElementNS(ns, "circle");
        c.setAttribute("r", size);
        return c;
       }
       if (shape === "square") {
        const r = document.createElementNS(ns, "rect");
        const s = size * 2;
        r.setAttribute("x", -size);
        r.setAttribute("y", -size);
        r.setAttribute("width", s);
        r.setAttribute("height", s);
        r.setAttribute("rx", 4);
        return r;
       }
       if (shape === "rectangle") {
        const r = document.createElementNS(ns, "rect");
        r.setAttribute("x", -size * 1.4);
        r.setAttribute("y", -size * 0.8);
        r.setAttribute("width", size * 2.8);
        r.setAttribute("height", size * 1.6);
        r.setAttribute("rx", 6);
        return r;
       }
       if (shape === "triangle") {
        const p = document.createElementNS(ns, "polygon");
        const h = size * 1.8;
        const w = size * 2;
        p.setAttribute("points", `0,${-h} ${w / 2},${h / 2} ${-w / 2},${h / 2}`, );
        return p;
       }
       if (shape === "hexagon") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        const pts = [
         [0, -s],
         [s * 0.86, -s * 0.5],
         [s * 0.86, s * 0.5],
         [0, s],
         [-s * 0.86, s * 0.5],
         [-s * 0.86, -s * 0.5],
        ].map((pt) => pt.join(",")).join(" ");
        p.setAttribute("points", pts);
        return p;
       }
       if (shape === "stop-sign") {
        const p = document.createElementNS(ns, "polygon");
        const r = size;
        const ptsArr = [];
        for (let i = 0; i < 8; i++) {
         const a = (Math.PI / 4) * i + Math.PI / 8;
         ptsArr.push([Math.cos(a) * r, Math.sin(a) * r]);
        }
        const pts = ptsArr.map((pt) => pt.join(",")).join(" ");
        p.setAttribute("points", pts);
        return p;
       }
       if (shape === "star") {
        const p = document.createElementNS(ns, "polygon");
        const outer = size;
        const inner = size * 0.45;
        let pts = "";
        for (let i = 0; i < 10; i++) {
         const a = (Math.PI / 5) * i - Math.PI / 2;
         const r = i % 2 === 0 ? outer : inner;
         pts += `${Math.cos(a) * r},${Math.sin(a) * r} `;
        }
        p.setAttribute("points", pts.trim());
        return p;
       }
       if (shape === "diamond") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `0,${-s} ${s},0 0,${s} ${-s},0`);
        return p;
       }
       if (shape === "server") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.2);
        body.setAttribute("y", -size * 0.6);
        body.setAttribute("width", size * 2.4);
        body.setAttribute("height", size * 1.2);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 3; i++) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", -size * 0.9 + i * size * 0.5);
         line.setAttribute("y1", -size * 0.3);
         line.setAttribute("x2", -size * 0.9 + i * size * 0.5);
         line.setAttribute("y2", size * 0.3);
         line.style.stroke = "currentColor";
         line.style.strokeWidth = "2";
         line.style.opacity = "0.5";
         g.appendChild(line);
        }
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", size * 0.9);
        led.setAttribute("cy", 0);
        led.setAttribute("r", size * 0.1);
        led.style.fill = "#4ade80";
        g.appendChild(led);
        return g;
       }
       if (shape === "pc" || shape === "desktop") {
        const g = document.createElementNS(ns, "g");
        const monitor = document.createElementNS(ns, "rect");
        monitor.setAttribute("x", -size * 0.9);
        monitor.setAttribute("y", -size * 0.8);
        monitor.setAttribute("width", size * 1.8);
        monitor.setAttribute("height", size * 1.2);
        monitor.setAttribute("rx", 4);
        g.appendChild(monitor);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.75);
        screen.setAttribute("y", -size * 0.65);
        screen.setAttribute("width", size * 1.5);
        screen.setAttribute("height", size * 0.9);
        screen.setAttribute("rx", 2);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        const neck = document.createElementNS(ns, "rect");
        neck.setAttribute("x", -size * 0.15);
        neck.setAttribute("y", size * 0.4);
        neck.setAttribute("width", size * 0.3);
        neck.setAttribute("height", size * 0.3);
        g.appendChild(neck);
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.5);
        base.setAttribute("y", size * 0.7);
        base.setAttribute("width", size * 1);
        base.setAttribute("height", size * 0.15);
        base.setAttribute("rx", 2);
        g.appendChild(base);
        return g;
       }
       if (shape === "laptop") {
        const g = document.createElementNS(ns, "g");
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.8);
        screen.setAttribute("y", -size * 0.9);
        screen.setAttribute("width", size * 1.6);
        screen.setAttribute("height", size * 1.1);
        screen.setAttribute("rx", 4);
        g.appendChild(screen);
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.9);
        base.setAttribute("y", size * 0.25);
        base.setAttribute("width", size * 1.8);
        base.setAttribute("height", size * 0.6);
        base.setAttribute("rx", 4);
        g.appendChild(base);
        const pad = document.createElementNS(ns, "rect");
        pad.setAttribute("x", -size * 0.25);
        pad.setAttribute("y", size * 0.45);
        pad.setAttribute("width", size * 0.5);
        pad.setAttribute("height", size * 0.25);
        pad.setAttribute("rx", 2);
        pad.style.fill = "#1e293b";
        g.appendChild(pad);
        return g;
       }
       if (shape === "phone" || shape === "mobile") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.45);
        body.setAttribute("y", -size);
        body.setAttribute("width", size * 0.9);
        body.setAttribute("height", size * 2);
        body.setAttribute("rx", 8);
        g.appendChild(body);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.38);
        screen.setAttribute("y", -size * 0.85);
        screen.setAttribute("width", size * 0.76);
        screen.setAttribute("height", size * 1.6);
        screen.setAttribute("rx", 4);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        const btn = document.createElementNS(ns, "rect");
        btn.setAttribute("x", -size * 0.15);
        btn.setAttribute("y", size * 0.82);
        btn.setAttribute("width", size * 0.3);
        btn.setAttribute("height", size * 0.06);
        btn.setAttribute("rx", 2);
        btn.style.fill = "#475569";
        g.appendChild(btn);
        return g;
       }
       if (shape === "router") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.1);
        body.setAttribute("y", -size * 0.3);
        body.setAttribute("width", size * 2.2);
        body.setAttribute("height", size * 0.8);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        for (let i = -1; i <= 1; i++) {
         const ant = document.createElementNS(ns, "rect");
         ant.setAttribute("x", i * size * 0.6 - size * 0.05);
         ant.setAttribute("y", -size * 0.9);
         ant.setAttribute("width", size * 0.1);
         ant.setAttribute("height", size * 0.6);
         ant.setAttribute("rx", 2);
         g.appendChild(ant);
         const tip = document.createElementNS(ns, "circle");
         tip.setAttribute("cx", i * size * 0.6);
         tip.setAttribute("cy", -size * 0.95);
         tip.setAttribute("r", size * 0.08);
         g.appendChild(tip);
        }
        for (let i = 0; i < 4; i++) {
         const led = document.createElementNS(ns, "circle");
         led.setAttribute("cx", -size * 0.7 + i * size * 0.35);
         led.setAttribute("cy", size * 0.1);
         led.setAttribute("r", size * 0.06);
         led.style.fill = i < 2 ? "#4ade80" : "#facc15";
         g.appendChild(led);
        }
        return g;
       }
       if (shape === "switch") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.4);
        body.setAttribute("y", -size * 0.4);
        body.setAttribute("width", size * 2.8);
        body.setAttribute("height", size * 0.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 8; i++) {
         const port = document.createElementNS(ns, "rect");
         port.setAttribute("x", -size * 1.2 + i * size * 0.32);
         port.setAttribute("y", -size * 0.15);
         port.setAttribute("width", size * 0.22);
         port.setAttribute("height", size * 0.3);
         port.setAttribute("rx", 1);
         port.style.fill = "#1e293b";
         g.appendChild(port);
        }
        return g;
       }
       if (shape === "firewall") {
        const g = document.createElementNS(ns, "g");
        const wall = document.createElementNS(ns, "rect");
        wall.setAttribute("x", -size);
        wall.setAttribute("y", -size * 0.8);
        wall.setAttribute("width", size * 2);
        wall.setAttribute("height", size * 1.6);
        wall.setAttribute("rx", 4);
        g.appendChild(wall);
        for (let row = 0; row < 3; row++) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", -size * 0.85);
         line.setAttribute("y1", -size * 0.5 + row * size * 0.45);
         line.setAttribute("x2", size * 0.85);
         line.setAttribute("y2", -size * 0.5 + row * size * 0.45);
         line.style.stroke = "#475569";
         line.style.strokeWidth = "2";
         g.appendChild(line);
        }
        for (let row = 0; row < 4; row++) {
         const offset = row % 2 === 0 ? 0 : size * 0.35;
         for (let col = 0; col < 3; col++) {
          const line = document.createElementNS(ns, "line");
          const x = -size * 0.5 + col * size * 0.7 + offset;
          if (x > -size * 0.85 && x < size * 0.85) {
           line.setAttribute("x1", x);
           line.setAttribute("y1", -size * 0.8 + row * size * 0.45, );
           line.setAttribute("x2", x);
           line.setAttribute("y2", -size * 0.8 + row * size * 0.45 + size * 0.45, );
           line.style.stroke = "#475569";
           line.style.strokeWidth = "2";
           g.appendChild(line);
          }
         }
        }
        return g;
       }
       if (shape === "cloud") {
        const p = document.createElementNS(ns, "path");
        const s = size;
        p.setAttribute("d", `
             M ${-s * 0.8} ${s * 0.2}
             Q ${-s * 1.1} ${s * 0.2} ${-s * 1.1} ${-s * 0.1}
             Q ${-s * 1.1} ${-s * 0.5} ${-s * 0.7} ${-s * 0.5}
             Q ${-s * 0.7} ${-s * 0.9} ${-s * 0.2} ${-s * 0.9}
             Q ${s * 0.1} ${-s * 1.1} ${s * 0.5} ${-s * 0.8}
             Q ${s * 1} ${-s * 0.8} ${s * 1.1} ${-s * 0.3}
             Q ${s * 1.3} ${-s * 0.1} ${s * 1.1} ${s * 0.2}
             Q ${s * 1.1} ${s * 0.5} ${s * 0.7} ${s * 0.5}
             L ${-s * 0.5} ${s * 0.5}
             Q ${-s * 0.9} ${s * 0.5} ${-s * 0.9} ${s * 0.2}
             Z
            `, );
        return p;
       }
       if (shape === "database") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.7);
        body.setAttribute("y", -size * 0.6);
        body.setAttribute("width", size * 1.4);
        body.setAttribute("height", size * 1.4);
        g.appendChild(body);
        const top = document.createElementNS(ns, "ellipse");
        top.setAttribute("cx", 0);
        top.setAttribute("cy", -size * 0.6);
        top.setAttribute("rx", size * 0.7);
        top.setAttribute("ry", size * 0.25);
        g.appendChild(top);
        const bottom = document.createElementNS(ns, "ellipse");
        bottom.setAttribute("cx", 0);
        bottom.setAttribute("cy", size * 0.8);
        bottom.setAttribute("rx", size * 0.7);
        bottom.setAttribute("ry", size * 0.25);
        g.appendChild(bottom);
        const mid1 = document.createElementNS(ns, "ellipse");
        mid1.setAttribute("cx", 0);
        mid1.setAttribute("cy", -size * 0.15);
        mid1.setAttribute("rx", size * 0.7);
        mid1.setAttribute("ry", size * 0.2);
        mid1.style.fill = "none";
        mid1.style.stroke = "#475569";
        mid1.style.strokeWidth = "2";
        g.appendChild(mid1);
        const mid2 = document.createElementNS(ns, "ellipse");
        mid2.setAttribute("cx", 0);
        mid2.setAttribute("cy", size * 0.35);
        mid2.setAttribute("rx", size * 0.7);
        mid2.setAttribute("ry", size * 0.2);
        mid2.style.fill = "none";
        mid2.style.stroke = "#475569";
        mid2.style.strokeWidth = "2";
        g.appendChild(mid2);
        return g;
       }
       if (shape === "printer") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.4);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size * 0.9);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const trayTop = document.createElementNS(ns, "rect");
        trayTop.setAttribute("x", -size * 0.7);
        trayTop.setAttribute("y", -size * 0.8);
        trayTop.setAttribute("width", size * 1.4);
        trayTop.setAttribute("height", size * 0.4);
        trayTop.setAttribute("rx", 2);
        trayTop.style.fill = "#1e293b";
        g.appendChild(trayTop);
        const trayOut = document.createElementNS(ns, "rect");
        trayOut.setAttribute("x", -size * 0.6);
        trayOut.setAttribute("y", size * 0.5);
        trayOut.setAttribute("width", size * 1.2);
        trayOut.setAttribute("height", size * 0.35);
        trayOut.setAttribute("rx", 2);
        g.appendChild(trayOut);
        const paper = document.createElementNS(ns, "rect");
        paper.setAttribute("x", -size * 0.5);
        paper.setAttribute("y", size * 0.3);
        paper.setAttribute("width", size * 1);
        paper.setAttribute("height", size * 0.5);
        paper.style.fill = "#e2e8f0";
        g.appendChild(paper);
        return g;
       }
       if (shape === "access-point" || shape === "wifi") {
        const g = document.createElementNS(ns, "g");
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.3);
        base.setAttribute("y", size * 0.2);
        base.setAttribute("width", size * 0.6);
        base.setAttribute("height", size * 0.3);
        base.setAttribute("rx", 3);
        g.appendChild(base);
        for (let i = 1; i <= 3; i++) {
         const arc = document.createElementNS(ns, "path");
         const r = size * 0.3 * i;
         arc.setAttribute("d", `M ${-r * 0.7} ${size * 0.1 - r * 0.5} A ${r} ${r} 0 0 1 ${r * 0.7} ${size * 0.1 - r * 0.5}`);
         arc.style.fill = "none";
         arc.style.stroke = "currentColor";
         arc.style.strokeWidth = "2";
         arc.style.opacity = 1 - (i * 0.2);
         g.appendChild(arc);
        }
        return g;
       }
       if (shape === "load-balancer") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.5);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        const bar = document.createElementNS(ns, "line");
        bar.setAttribute("x1", -size * 0.6);
        bar.setAttribute("y1", 0);
        bar.setAttribute("x2", size * 0.6);
        bar.setAttribute("y2", 0);
        bar.style.stroke = "#4ade80";
        bar.style.strokeWidth = "3";
        g.appendChild(bar);
        [-1, 1].forEach(dir => {
         const arrow = document.createElementNS(ns, "path");
         arrow.setAttribute("d", `M ${dir * size * 0.3} ${-size * 0.2} L ${dir * size * 0.6} 0 L ${dir * size * 0.3} ${size * 0.2}`);
         arrow.style.fill = "none";
         arrow.style.stroke = "#4ade80";
         arrow.style.strokeWidth = "2";
         g.appendChild(arrow);
        });
        return g;
       }
       if (shape === "nas" || shape === "storage") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.8);
        body.setAttribute("y", -size * 0.9);
        body.setAttribute("width", size * 1.6);
        body.setAttribute("height", size * 1.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 4; i++) {
         const bay = document.createElementNS(ns, "rect");
         bay.setAttribute("x", -size * 0.6);
         bay.setAttribute("y", -size * 0.7 + i * size * 0.4);
         bay.setAttribute("width", size * 1.2);
         bay.setAttribute("height", size * 0.3);
         bay.setAttribute("rx", 2);
         bay.style.fill = "#1e293b";
         g.appendChild(bay);
        }
        return g;
       }
       if (shape === "gateway" || shape === "modem") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.5);
        body.setAttribute("y", -size * 0.9);
        body.setAttribute("width", size);
        body.setAttribute("height", size * 1.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 4; i++) {
         const led = document.createElementNS(ns, "circle");
         led.setAttribute("cx", 0);
         led.setAttribute("cy", -size * 0.6 + i * size * 0.35);
         led.setAttribute("r", size * 0.08);
         led.style.fill = ["#4ade80", "#4ade80", "#facc15", "#60a5fa"][i];
         g.appendChild(led);
        }
        return g;
       }
       if (shape === "vpn" || shape === "tunnel") {
        const g = document.createElementNS(ns, "g");
        const outer = document.createElementNS(ns, "ellipse");
        outer.setAttribute("cx", 0);
        outer.setAttribute("cy", 0);
        outer.setAttribute("rx", size);
        outer.setAttribute("ry", size * 0.6);
        g.appendChild(outer);
        const inner = document.createElementNS(ns, "ellipse");
        inner.setAttribute("cx", 0);
        inner.setAttribute("cy", 0);
        inner.setAttribute("rx", size * 0.5);
        inner.setAttribute("ry", size * 0.3);
        inner.style.fill = "#1e293b";
        g.appendChild(inner);
        const lock = document.createElementNS(ns, "rect");
        lock.setAttribute("x", -size * 0.15);
        lock.setAttribute("y", -size * 0.1);
        lock.setAttribute("width", size * 0.3);
        lock.setAttribute("height", size * 0.25);
        lock.setAttribute("rx", 2);
        lock.style.fill = "#4ade80";
        g.appendChild(lock);
        return g;
       }
       if (shape === "container") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.5);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 3; i++) {
         const block = document.createElementNS(ns, "rect");
         block.setAttribute("x", -size * 0.8 + i * size * 0.55);
         block.setAttribute("y", -size * 0.3);
         block.setAttribute("width", size * 0.45);
         block.setAttribute("height", size * 0.6);
         block.setAttribute("rx", 2);
         block.style.fill = "#1e293b";
         g.appendChild(block);
        }
        return g;
       }
       if (shape === "vm" || shape === "virtual") {
        const g = document.createElementNS(ns, "g");
        const shadow = document.createElementNS(ns, "rect");
        shadow.setAttribute("x", -size * 0.85 + 4);
        shadow.setAttribute("y", -size * 0.65 + 4);
        shadow.setAttribute("width", size * 1.7);
        shadow.setAttribute("height", size * 1.3);
        shadow.setAttribute("rx", 4);
        shadow.style.opacity = "0.3";
        g.appendChild(shadow);
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.85);
        body.setAttribute("y", -size * 0.65);
        body.setAttribute("width", size * 1.7);
        body.setAttribute("height", size * 1.3);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.65);
        screen.setAttribute("y", -size * 0.45);
        screen.setAttribute("width", size * 1.3);
        screen.setAttribute("height", size * 0.7);
        screen.setAttribute("rx", 2);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        return g;
       }
       if (shape === "kubernetes" || shape === "k8s") {
        const g = document.createElementNS(ns, "g");
        const outer = document.createElementNS(ns, "circle");
        outer.setAttribute("cx", 0);
        outer.setAttribute("cy", 0);
        outer.setAttribute("r", size);
        g.appendChild(outer);
        const inner = document.createElementNS(ns, "circle");
        inner.setAttribute("cx", 0);
        inner.setAttribute("cy", 0);
        inner.setAttribute("r", size * 0.4);
        inner.style.fill = "#1e293b";
        g.appendChild(inner);
        for (let i = 0; i < 7; i++) {
         const angle = (Math.PI * 2 / 7) * i - Math.PI / 2;
         const spoke = document.createElementNS(ns, "line");
         spoke.setAttribute("x1", Math.cos(angle) * size * 0.4);
         spoke.setAttribute("y1", Math.sin(angle) * size * 0.4);
         spoke.setAttribute("x2", Math.cos(angle) * size * 0.85);
         spoke.setAttribute("y2", Math.sin(angle) * size * 0.85);
         spoke.style.stroke = "#326ce5";
         spoke.style.strokeWidth = "3";
         g.appendChild(spoke);
        }
        return g;
       }
       
       if (shape === "shield" || shape === "security") {
        const p = document.createElementNS(ns, "path");
        const s = size;
        p.setAttribute("d", `M 0 ${-s} L ${s * 0.85} ${-s * 0.5} L ${s * 0.85} ${s * 0.2} Q ${s * 0.7} ${s * 0.9} 0 ${s} Q ${-s * 0.7} ${s * 0.9} ${-s * 0.85} ${s * 0.2} L ${-s * 0.85} ${-s * 0.5} Z`);
        return p;
       }
       if (shape === "camera" || shape === "cctv") {
        const g = document.createElementNS(ns, "g");
        const mount = document.createElementNS(ns, "rect");
        mount.setAttribute("x", -size * 1.1);
        mount.setAttribute("y", -size * 0.5);
        mount.setAttribute("width", size * 0.25);
        mount.setAttribute("height", size * 0.6);
        mount.setAttribute("rx", 2);
        g.appendChild(mount);
        const arm = document.createElementNS(ns, "rect");
        arm.setAttribute("x", -size * 0.9);
        arm.setAttribute("y", -size * 0.15);
        arm.setAttribute("width", size * 0.5);
        arm.setAttribute("height", size * 0.15);
        g.appendChild(arm);
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.45);
        body.setAttribute("y", -size * 0.35);
        body.setAttribute("width", size * 1.1);
        body.setAttribute("height", size * 0.7);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const lensHousing = document.createElementNS(ns, "circle");
        lensHousing.setAttribute("cx", size * 0.85);
        lensHousing.setAttribute("cy", 0);
        lensHousing.setAttribute("r", size * 0.4);
        g.appendChild(lensHousing);
        const lensOuter = document.createElementNS(ns, "circle");
        lensOuter.setAttribute("cx", size * 0.85);
        lensOuter.setAttribute("cy", 0);
        lensOuter.setAttribute("r", size * 0.28);
        lensOuter.style.fill = "#1e293b";
        g.appendChild(lensOuter);
        const lensInner = document.createElementNS(ns, "circle");
        lensInner.setAttribute("cx", size * 0.85);
        lensInner.setAttribute("cy", 0);
        lensInner.setAttribute("r", size * 0.15);
        lensInner.style.fill = "#3b82f6";
        g.appendChild(lensInner);
        const reflection = document.createElementNS(ns, "circle");
        reflection.setAttribute("cx", size * 0.8);
        reflection.setAttribute("cy", -size * 0.05);
        reflection.setAttribute("r", size * 0.05);
        reflection.style.fill = "#93c5fd";
        g.appendChild(reflection);
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", -size * 0.2);
        led.setAttribute("cy", -size * 0.15);
        led.setAttribute("r", size * 0.06);
        led.style.fill = "#ef4444";
        g.appendChild(led);
        return g;
       }
       if (shape === "monitor" || shape === "dashboard") {
        const g = document.createElementNS(ns, "g");
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size);
        screen.setAttribute("y", -size * 0.7);
        screen.setAttribute("width", size * 2);
        screen.setAttribute("height", size * 1.2);
        screen.setAttribute("rx", 4);
        g.appendChild(screen);
        const graph = document.createElementNS(ns, "polyline");
        graph.setAttribute("points", `${-size * 0.8},${size * 0.2} ${-size * 0.3},${-size * 0.2} ${size * 0.2},${size * 0.1} ${size * 0.7},${-size * 0.3}`);
        graph.style.fill = "none";
        graph.style.stroke = "#4ade80";
        graph.style.strokeWidth = "3";
        g.appendChild(graph);
        return g;
       }
       if (shape === "docker" || shape === "whale") {
        const g = document.createElementNS(ns, "g");
        const s = size;
        const body = document.createElementNS(ns, "path");
        body.setAttribute("d", `
         M ${-s * 0.9} ${s * 0.2}
         Q ${-s * 1.1} ${s * 0.5} ${-s * 0.7} ${s * 0.7}
         Q ${-s * 0.3} ${s * 0.85} ${s * 0.3} ${s * 0.75}
         Q ${s * 0.8} ${s * 0.6} ${s * 1.0} ${s * 0.3}
         Q ${s * 1.1} ${s * 0.1} ${s * 1.0} ${-s * 0.1}
         L ${s * 0.85} ${-s * 0.1}
         Q ${s * 0.7} ${-s * 0.15} ${s * 0.4} ${-s * 0.2}
         L ${-s * 0.5} ${-s * 0.2}
         Q ${-s * 0.8} ${-s * 0.1} ${-s * 0.9} ${s * 0.2}
         Z
        `);
        body.style.fill = "#0db7ed";
        g.appendChild(body);
        const tail = document.createElementNS(ns, "path");
        tail.setAttribute("d", `
         M ${-s * 0.85} ${s * 0.1}
         Q ${-s * 1.2} ${-s * 0.2} ${-s * 1.0} ${-s * 0.55}
         Q ${-s * 0.95} ${-s * 0.35} ${-s * 0.8} ${-s * 0.15}
         Z
        `);
        tail.style.fill = "#0db7ed";
        g.appendChild(tail);
        const belly = document.createElementNS(ns, "path");
        belly.setAttribute("d", `
         M ${-s * 0.5} ${s * 0.65}
         Q ${s * 0.1} ${s * 0.75} ${s * 0.6} ${s * 0.55}
         Q ${s * 0.8} ${s * 0.45} ${s * 0.9} ${s * 0.25}
         Q ${s * 0.7} ${s * 0.5} ${s * 0.3} ${s * 0.6}
         Q ${-s * 0.1} ${s * 0.7} ${-s * 0.5} ${s * 0.65}
         Z
        `);
        belly.style.fill = "#ffffff";
        belly.style.opacity = "0.3";
        g.appendChild(belly);
        for (let row = 0; row < 2; row++) {
         for (let col = 0; col < 3; col++) {
          const container = document.createElementNS(ns, "rect");
          container.setAttribute("x", -s * 0.45 + col * s * 0.35);
          container.setAttribute("y", -s * 0.7 + row * s * 0.28);
          container.setAttribute("width", s * 0.3);
          container.setAttribute("height", s * 0.23);
          container.setAttribute("rx", 2);
          container.style.fill = "#0db7ed";
          container.style.stroke = "#0a9ed8";
          container.style.strokeWidth = "1.5";
          g.appendChild(container);
         }
        }
        const topContainer = document.createElementNS(ns, "rect");
        topContainer.setAttribute("x", -s * 0.1);
        topContainer.setAttribute("y", -s * 0.95);
        topContainer.setAttribute("width", s * 0.3);
        topContainer.setAttribute("height", s * 0.23);
        topContainer.setAttribute("rx", 2);
        topContainer.style.fill = "#0db7ed";
        topContainer.style.stroke = "#0a9ed8";
        topContainer.style.strokeWidth = "1.5";
        g.appendChild(topContainer);
        const eye = document.createElementNS(ns, "circle");
        eye.setAttribute("cx", s * 0.65);
        eye.setAttribute("cy", s * 0.25);
        eye.setAttribute("r", s * 0.08);
        eye.style.fill = "#0a5f7a";
        g.appendChild(eye);
        
        return g;
       }
       if (shape === "rounded-square") {
        const r = document.createElementNS(ns, "rect");
        const s = size * 1.6;
        r.setAttribute("x", -s / 2);
        r.setAttribute("y", -s / 2);
        r.setAttribute("width", s);
        r.setAttribute("height", s);
        r.setAttribute("rx", size * 0.4);
        return r;
       }
       if (shape === "pill" || shape === "capsule") {
        const r = document.createElementNS(ns, "rect");
        r.setAttribute("x", -size * 1.2);
        r.setAttribute("y", -size * 0.5);
        r.setAttribute("width", size * 2.4);
        r.setAttribute("height", size);
        r.setAttribute("rx", size * 0.5);
        return r;
       }
       if (shape === "octagon") {
        const p = document.createElementNS(ns, "polygon");
        const r = size;
        const pts = [];
        for (let i = 0; i < 8; i++) {
         const a = (Math.PI / 4) * i - Math.PI / 8;
         pts.push([Math.cos(a) * r, Math.sin(a) * r]);
        }
        p.setAttribute("points", pts.map(pt => pt.join(",")).join(" "));
        return p;
       }
       if (shape === "pentagon") {
        const p = document.createElementNS(ns, "polygon");
        const pts = [];
        for (let i = 0; i < 5; i++) {
         const a = (Math.PI * 2 / 5) * i - Math.PI / 2;
         pts.push([Math.cos(a) * size, Math.sin(a) * size]);
        }
        p.setAttribute("points", pts.map(pt => pt.join(",")).join(" "));
        return p;
       }
       if (shape === "cross" || shape === "plus") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        const t = size * 0.35;
        p.setAttribute("points", `${-t},${-s} ${t},${-s} ${t},${-t} ${s},${-t} ${s},${t} ${t},${t} ${t},${s} ${-t},${s} ${-t},${t} ${-s},${t} ${-s},${-t} ${-t},${-t}`);
        return p;
       }
       if (shape === "parallelogram") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `${-s * 0.6},${-s * 0.6} ${s * 1.2},${-s * 0.6} ${s * 0.6},${s * 0.6} ${-s * 1.2},${s * 0.6}`);
        return p;
       }
       if (shape === "trapezoid") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `${-s * 0.6},${-s * 0.6} ${s * 0.6},${-s * 0.6} ${s},${s * 0.6} ${-s},${s * 0.6}`);
        return p;
       }
       if (shape === "sensor" || shape === "iot") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "circle");
        body.setAttribute("cx", 0);
        body.setAttribute("cy", 0);
        body.setAttribute("r", size * 0.7);
        g.appendChild(body);
        const ant = document.createElementNS(ns, "line");
        ant.setAttribute("x1", 0);
        ant.setAttribute("y1", -size * 0.7);
        ant.setAttribute("x2", 0);
        ant.setAttribute("y2", -size);
        ant.style.stroke = "currentColor";
        ant.style.strokeWidth = "2";
        g.appendChild(ant);
        const tip = document.createElementNS(ns, "circle");
        tip.setAttribute("cx", 0);
        tip.setAttribute("cy", -size);
        tip.setAttribute("r", size * 0.1);
        tip.style.fill = "#4ade80";
        g.appendChild(tip);
        return g;
       }
       if (shape === "pi" || shape === "sbc" || shape === "raspberry") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.65);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size * 1.3);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 10; i++) {
         const pin = document.createElementNS(ns, "rect");
         pin.setAttribute("x", -size * 0.85 + i * size * 0.19);
         pin.setAttribute("y", -size * 0.8);
         pin.setAttribute("width", size * 0.08);
         pin.setAttribute("height", size * 0.15);
         pin.style.fill = "#facc15";
         g.appendChild(pin);
        }
        const port = document.createElementNS(ns, "rect");
        port.setAttribute("x", size * 0.6);
        port.setAttribute("y", -size * 0.2);
        port.setAttribute("width", size * 0.35);
        port.setAttribute("height", size * 0.4);
        port.style.fill = "#1e293b";
        g.appendChild(port);
        return g;
       }
       if (shape === "api" || shape === "endpoint") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.9);
        body.setAttribute("y", -size * 0.7);
        body.setAttribute("width", size * 1.8);
        body.setAttribute("height", size * 1.4);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        const left = document.createElementNS(ns, "text");
        left.setAttribute("x", -size * 0.5);
        left.setAttribute("y", size * 0.15);
        left.setAttribute("font-size", size * 0.9);
        left.setAttribute("fill", "#4ade80");
        left.setAttribute("font-family", "monospace");
        left.textContent = "{";
        g.appendChild(left);
        const right = document.createElementNS(ns, "text");
        right.setAttribute("x", size * 0.15);
        right.setAttribute("y", size * 0.15);
        right.setAttribute("font-size", size * 0.9);
        right.setAttribute("fill", "#4ade80");
        right.setAttribute("font-family", "monospace");
        right.textContent = "}";
        g.appendChild(right);
        return g;
       }
       if (shape === "queue" || shape === "message") {
        const g = document.createElementNS(ns, "g");
        for (let i = 2; i >= 0; i--) {
         const card = document.createElementNS(ns, "rect");
         card.setAttribute("x", -size * 0.7 + i * 4);
         card.setAttribute("y", -size * 0.5 + i * 4);
         card.setAttribute("width", size * 1.4);
         card.setAttribute("height", size * 0.8);
         card.setAttribute("rx", 3);
         card.style.opacity = 1 - i * 0.25;
         g.appendChild(card);
        }
        return g;
       }
       if (shape === "lambda" || shape === "function") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.8);
        body.setAttribute("y", -size * 0.8);
        body.setAttribute("width", size * 1.6);
        body.setAttribute("height", size * 1.6);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const lambda = document.createElementNS(ns, "text");
        lambda.setAttribute("x", 0);
        lambda.setAttribute("y", size * 0.2);
        lambda.setAttribute("font-size", size * 1.2);
        lambda.setAttribute("fill", "#f59e0b");
        lambda.setAttribute("text-anchor", "middle");
        lambda.setAttribute("font-family", "serif");
        lambda.textContent = "λ";
        g.appendChild(lambda);
        return g;
       }
       if (shape === "bucket" || shape === "s3") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "path");
        body.setAttribute("d", `M ${-size * 0.8} ${-size * 0.7} L ${-size * 0.6} ${size * 0.8} Q ${-size * 0.5} ${size} 0 ${size} Q ${size * 0.5} ${size} ${size * 0.6} ${size * 0.8} L ${size * 0.8} ${-size * 0.7} Z`);
        g.appendChild(body);
        const rim = document.createElementNS(ns, "ellipse");
        rim.setAttribute("cx", 0);
        rim.setAttribute("cy", -size * 0.7);
        rim.setAttribute("rx", size * 0.8);
        rim.setAttribute("ry", size * 0.25);
        g.appendChild(rim);
        return g;
       }   
       const c = document.createElementNS(ns, "circle");
       c.setAttribute("r", size);
       return c;
      }
      
      function createNodeShape(id, size) {
       const shapeType = (NODE_DATA[id] && NODE_DATA[id].shape) || "circle";
       const shapeEl = createShapeElement(shapeType, size);
       shapeEl.classList.add("node-circle");
       const styles = resolveStylesForNode(id);
       shapeEl.style.fill = styles.circleColor || PAGE_STATE.nodeFill || "#1e293b";
       shapeEl.style.stroke = styles.circleBorder || PAGE_STATE.nodeStroke || "#475569";
       return shapeEl;
      }
      
      function forgeTheLegend() {
       const container = document.getElementById("edge-legend");
       if (!container) return;
       container.innerHTML = "";
       const title = document.createElement("div");
       title.className = "legend-title";
       title.textContent = "Line Legend";
       container.appendChild(title);
       const closeBtn = document.createElement("button");
       closeBtn.type = "button";
       closeBtn.className = "legend-close-btn";
       closeBtn.textContent = "✕";
       closeBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        legendCollapsed = true;
        updateLegendVisibility();
       });
       container.appendChild(closeBtn);
       const colors = [...new Set(EDGE_DATA.list.map((e) => e.color).filter(Boolean))];
       if (colors.length === 0) {
        updateLegendVisibility();
        return;
       }
       colors.forEach((color) => {
        if (!EDGE_LEGEND[color]) {
         EDGE_LEGEND[color] = "you can edit me too";
        }
        const item = document.createElement("div");
        item.className = "legend-item";
        item.addEventListener("mousedown", (e) => e.stopPropagation());
        item.addEventListener("click", (e) => e.stopPropagation());
        const swatch = document.createElement("span");
        swatch.className = "legend-swatch";
        swatch.style.backgroundColor = color;
        swatch.style.cursor = "pointer";
        swatch.addEventListener("click", (e) => {
         e.stopPropagation();
         const edgeWithColor = EDGE_DATA.list.find(edge => edge.color === color);
         if (edgeWithColor) {
          selectTheConnection(edgeWithColor.id);
         }
        });
        let swatchTouchStart = null;
        let swatchTouchMoved = false;
        swatch.addEventListener("touchstart", (e) => {
         swatchTouchStart = Date.now();
         swatchTouchMoved = false;
         if (e.touches[0]) {
          swatchTouchStartX = e.touches[0].clientX;
          swatchTouchStartY = e.touches[0].clientY;
         }
        }, {
         passive: false
        });
        let swatchTouchStartX = 0, swatchTouchStartY = 0;
        swatch.addEventListener("touchmove", (e) => {
         if (e.touches[0]) {
          const dx = Math.abs(e.touches[0].clientX - swatchTouchStartX);
          const dy = Math.abs(e.touches[0].clientY - swatchTouchStartY);
          if (dx > 10 || dy > 10) swatchTouchMoved = true;
         }
        }, {
         passive: false
        });
        swatch.addEventListener("touchend", (e) => {
         if (swatchTouchStart && !swatchTouchMoved && Date.now() - swatchTouchStart < 400) {
          e.stopPropagation();
          e.preventDefault();
          const edgeWithColor = EDGE_DATA.list.find(edge => edge.color === color);
          if (edgeWithColor) {
           selectTheConnection(edgeWithColor.id);
          }
         }
         swatchTouchStart = null;
         swatchTouchMoved = false;
        }, {
         passive: false
        });
        const label = document.createElement("span");
        label.className = "legend-label";
        label.textContent = EDGE_LEGEND[color];
        if (isMobileDevice()) {
         label.style.cursor = "pointer";
         let labelTapStart = null;
         let labelTapMoved = false;
         label.addEventListener("touchstart", (e) => {
          labelTapStart = Date.now();
          labelTapMoved = false;
          if (e.touches[0]) {
           labelTapStartX = e.touches[0].clientX;
           labelTapStartY = e.touches[0].clientY;
          }
          e.stopPropagation();
         });
         let labelTapStartX = 0, labelTapStartY = 0;
         label.addEventListener("touchmove", (e) => {
          if (e.touches[0]) {
           const dx = Math.abs(e.touches[0].clientX - labelTapStartX);
           const dy = Math.abs(e.touches[0].clientY - labelTapStartY);
           if (dx > 10 || dy > 10) labelTapMoved = true;
          }
         });
         label.addEventListener("touchend", (e) => {
          if (labelTapStart && !labelTapMoved && Date.now() - labelTapStart < 400) {
           e.preventDefault();
           e.stopPropagation();
           const currentText = label.textContent;
           const newText = prompt("Edit legend label:", currentText);
           if (newText !== null && newText.trim()) {
            label.textContent = newText.trim();
            EDGE_LEGEND[color] = newText.trim();
            
           }
          }
          labelTapStart = null;
          labelTapMoved = false;
         });
        } else {
         label.contentEditable = true;
         label.addEventListener("focus", () => {
          label.classList.add("editing");
         });
         label.addEventListener("blur", () => {
          label.classList.remove("editing");
          const text = label.textContent.trim() || "you can edit me too";
          EDGE_LEGEND[color] = text;
          
         });
         label.addEventListener("keydown", (e) => {
          if (e.key === "Enter") {
           e.preventDefault();
           label.blur();
          }
         });
        }
        item.append(swatch, label);
        container.appendChild(item);
       });
       updateLegendVisibility();
      }
      
       function deleteRectangle(rectId) {
      pushUndo("delete zone");
        RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== rectId);
        forgeTheTopology();
       }
      
       function updateRectangleDeleteButtons() {
        const deleteButtons = document.querySelectorAll('.rect-delete-btn');
        deleteButtons.forEach(btn => {
         btn.style.display = rectDrawMode ? 'block' : 'none';
        });
       }
      
      function forgeTheTopology() {
       if (!NODE_DATA || !EDGE_DATA) {
        console.warn("forgeTheTopology called before data initialized");
        return;
       }
       const svg = document.getElementById("map");
       svg.innerHTML = "";
       const ns = "http://www.w3.org/2000/svg";
       const defs = document.createElementNS(ns, "defs");
       const markerForward = document.createElementNS(ns, "marker");
       markerForward.id = "arrow-forward";
       markerForward.setAttribute("markerWidth", "10");
       markerForward.setAttribute("markerHeight", "10");
       markerForward.setAttribute("refX", "9");
       markerForward.setAttribute("refY", "3");
       markerForward.setAttribute("orient", "auto");
       markerForward.setAttribute("markerUnits", "strokeWidth");
       const pathForward = document.createElementNS(ns, "path");
       pathForward.setAttribute("d", "M0,0 L0,6 L9,3 z");
       pathForward.setAttribute("fill", "context-stroke");
       markerForward.appendChild(pathForward);
       defs.appendChild(markerForward);
       const markerBackward = document.createElementNS(ns, "marker");
       markerBackward.id = "arrow-backward";
       markerBackward.setAttribute("markerWidth", "10");
       markerBackward.setAttribute("markerHeight", "10");
       markerBackward.setAttribute("refX", "0");
       markerBackward.setAttribute("refY", "3");
       markerBackward.setAttribute("orient", "auto");
       markerBackward.setAttribute("markerUnits", "strokeWidth");
       const pathBackward = document.createElementNS(ns, "path");
       pathBackward.setAttribute("d", "M9,0 L9,6 L0,3 z");
       pathBackward.setAttribute("fill", "context-stroke");
       markerBackward.appendChild(pathBackward);
       defs.appendChild(markerBackward);
       svg.appendChild(defs);
       const boundary = document.createElementNS(ns, "rect");
       boundary.setAttribute("x", CANVAS_PADDING);
       boundary.setAttribute("y", CANVAS_PADDING);
       boundary.setAttribute("width", CANVAS_WIDTH - CANVAS_PADDING * 2);
       boundary.setAttribute("height", CANVAS_HEIGHT - CANVAS_PADDING * 2);
       boundary.setAttribute("fill", "none");
       boundary.setAttribute("stroke", (PAGE_STATE.canvasBorder || "#475569") + "4D");
       boundary.setAttribute("stroke-width", "20");
       boundary.setAttribute("stroke-dasharray", "10 5");
       boundary.setAttribute("rx", "8");
       svg.appendChild(boundary);
       
       if (currentView.mode !== "rack") {
        const gridGroup = document.createElementNS(ns, "g");
        gridGroup.id = "canvas-grid";
        const gridSize = PAGE_STATE.canvasGridSize || 50;
        const gridColor = (PAGE_STATE.canvasGrid || "#475569") + "33";
        const majorGridColor = (PAGE_STATE.canvasGrid || "#475569") + "66";
        
        for (let x = CANVAS_PADDING; x <= CANVAS_WIDTH - CANVAS_PADDING; x += gridSize) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", x);
         line.setAttribute("y1", CANVAS_PADDING);
         line.setAttribute("x2", x);
         line.setAttribute("y2", CANVAS_HEIGHT - CANVAS_PADDING);
         line.setAttribute("stroke", (x - CANVAS_PADDING) % (gridSize * 5) === 0 ? majorGridColor : gridColor);
         line.setAttribute("stroke-width", (x - CANVAS_PADDING) % (gridSize * 5) === 0 ? "2" : "1");
         gridGroup.appendChild(line);
        }
        
        for (let y = CANVAS_PADDING; y <= CANVAS_HEIGHT - CANVAS_PADDING; y += gridSize) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", CANVAS_PADDING);
         line.setAttribute("y1", y);
         line.setAttribute("x2", CANVAS_WIDTH - CANVAS_PADDING);
         line.setAttribute("y2", y);
         line.setAttribute("stroke", (y - CANVAS_PADDING) % (gridSize * 5) === 0 ? majorGridColor : gridColor);
         line.setAttribute("stroke-width", (y - CANVAS_PADDING) % (gridSize * 5) === 0 ? "2" : "1");
         gridGroup.appendChild(line);
        }
        
        svg.appendChild(gridGroup);
       }
       
       if (currentView.mode === "rack" && currentView.rackId) {
        const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
        const rackGroup = document.createElementNS(ns, "g");
        rackGroup.id = "rack-visualization";
        
        const rackFrame = document.createElementNS(ns, "rect");
        rackFrame.setAttribute("x", RACK_START_X - RACK_WIDTH / 2);
        rackFrame.setAttribute("y", RACK_START_Y);
        rackFrame.setAttribute("width", RACK_WIDTH);
      
      rackFrame.setAttribute("height", rackCapacity * rackUHeight);
      
        rackFrame.setAttribute("fill", (PAGE_STATE.rackFrameFill || "#0f172a") + "4D");
        rackFrame.setAttribute("stroke", PAGE_STATE.rackFrameStroke || "#4fd1c5");
        rackFrame.setAttribute("stroke-width", "3");
        rackFrame.setAttribute("rx", "4");
        rackGroup.appendChild(rackFrame);
        
        for (let u = 0; u <= rackCapacity; u++) {
         const y = RACK_START_Y + u * rackUHeight;
      
         
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", RACK_START_X - RACK_WIDTH / 2);
         line.setAttribute("y1", y);
         line.setAttribute("x2", RACK_START_X + RACK_WIDTH / 2);
         line.setAttribute("y2", y);
         line.setAttribute("stroke", (PAGE_STATE.rackLineColor || "#475569") + "66");
         line.setAttribute("stroke-width", u % 5 === 0 ? "2" : "1");
         line.setAttribute("stroke-dasharray", u % 5 === 0 ? "none" : "5,5");
         rackGroup.appendChild(line);
         
         if (u < rackCapacity) {
          const uNumber = rackCapacity - u; 
          const text = document.createElementNS(ns, "text");
          text.setAttribute("x", RACK_START_X - RACK_WIDTH / 2 - 30);
          text.setAttribute("y", y + rackUHeight / 2);
      
          text.setAttribute("text-anchor", "middle");
          text.setAttribute("dominant-baseline", "middle");
          text.style.fill = PAGE_STATE.rackTextColor || "#4fd1c5";
          text.style.fontSize = "14px";
          text.style.fontWeight = "bold";
          text.textContent = `U${uNumber}`;
          rackGroup.appendChild(text);
          
          const textRight = document.createElementNS(ns, "text");
          textRight.setAttribute("x", RACK_START_X + RACK_WIDTH / 2 + 30);
          textRight.setAttribute("y", y + rackUHeight / 2);
      
          textRight.setAttribute("text-anchor", "middle");
          textRight.setAttribute("dominant-baseline", "middle");
          textRight.style.fill = PAGE_STATE.rackTextColor || "#4fd1c5";
          textRight.style.fontSize = "14px";
          textRight.style.fontWeight = "bold";
          textRight.textContent = `U${uNumber}`;
          rackGroup.appendChild(textRight);
         }
        }
        
        svg.appendChild(rackGroup);
       }
       
        if (RECT_DATA && RECT_DATA.list) {
         RECT_DATA.list.forEach((rect) => {
          if (currentView.mode === "rack") return;
          
          if (rect.style === "filled") {
           const g = document.createElementNS(ns, "g");
           g.classList.add("rect-group");
           g.dataset.rectId = rect.id;
           
           const rectEl = document.createElementNS(ns, "rect");
           rectEl.classList.add("rect-shape");
           rectEl.setAttribute("x", rect.x);
           rectEl.setAttribute("y", rect.y);
           rectEl.setAttribute("width", rect.width);
           rectEl.setAttribute("height", rect.height);
           rectEl.style.fill = rect.color;
           rectEl.style.fillOpacity = "0.3";
           rectEl.style.stroke = rect.borderColor || rect.color;
           rectEl.style.strokeWidth = (rect.borderWidth !== undefined ? rect.borderWidth : 2) + "px";
           if (rect.lineStyle === "dashed") { rectEl.style.strokeDasharray = "10,5"; }
           else if (rect.lineStyle === "dotted") { rectEl.style.strokeDasharray = "2,4"; }
           else { rectEl.style.strokeDasharray = "none"; }
           rectEl.style.cursor = "move";
           
          rectEl.addEventListener("click", (e) => {
		  if (isViewOnly()) return;
             if (rectDrawMode) return;
             e.stopPropagation();
             currentRectId = rect.id;
             selectTheRect(rect.id);
           });
           
           rectEl.addEventListener("contextmenu", (e) => {
		   if (isViewOnly()) return;
             e.preventDefault();
             e.stopPropagation();
             if (selectedRects.has(rect.id)) {
               selectedRects.delete(rect.id);
             } else {
               selectedRects.add(rect.id);
             }
             updateAllSelections();
           });
           
           let rectLastTap = 0;
           rectEl.addEventListener("touchend", (e) => {
             const now = Date.now();
             if (now - rectLastTap < 300) {
               e.preventDefault();
               if (selectedRects.has(rect.id)) {
                 selectedRects.delete(rect.id);
               } else {
                 selectedRects.add(rect.id);
               }
               updateAllSelections();
               if (navigator.vibrate) navigator.vibrate(50);
               rectLastTap = 0;
             } else {
               rectLastTap = now;
             }
           }, { passive: false });
      
           const deleteBtn = document.createElementNS(ns, "g");
           deleteBtn.classList.add("rect-delete-btn");
           deleteBtn.style.cursor = "pointer";
           deleteBtn.style.display = rectDrawMode ? "block" : "none";
           
           const deleteBg = document.createElementNS(ns, "circle");
           deleteBg.setAttribute("cx", rect.x + rect.width - 10);
           deleteBg.setAttribute("cy", rect.y + 10);
           deleteBg.setAttribute("r", 12);
           deleteBg.style.fill = "#f56565";
           deleteBg.style.stroke = "white";
           deleteBg.style.strokeWidth = "2";
           
           const deleteX = document.createElementNS(ns, "text");
           deleteX.setAttribute("x", rect.x + rect.width - 10);
           deleteX.setAttribute("y", rect.y + 10);
           deleteX.setAttribute("text-anchor", "middle");
           deleteX.setAttribute("dominant-baseline", "middle");
           deleteX.style.fill = "white";
           deleteX.style.fontSize = "16px";
           deleteX.style.fontWeight = "bold";
           deleteX.style.pointerEvents = "none";
           deleteX.textContent = "×";
           
           deleteBtn.appendChild(deleteBg);
           deleteBtn.appendChild(deleteX);
           
           deleteBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            e.preventDefault();
            deleteRectangle(rect.id);
           });
      
           deleteBtn.addEventListener("touchend", (e) => {
      e.stopPropagation();
           e.preventDefault();
           deleteRectangle(rect.id);
           });
           
           let isDragging = false;
           let dragStartX, dragStartY;
           let rectStartX, rectStartY;
           
         rectEl.addEventListener("mousedown", (e) => {
		 if (isViewOnly()) return;
      if (rectDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      rectStartX = rect.x;
      rectStartY = rect.y;
      rectEl.style.cursor = "grabbing";
      
      if (selectedRects.has(rect.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
           
           const moveHandler = (e) => {
      if (!isDragging || rectDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      
      rect.x = rectStartX + dx;
      rect.y = rectStartY + dy;
      
      if (selectedRects.has(rect.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       const newX = initialPositions[nodeId].x + dx;
       const newY = initialPositions[nodeId].y + dy;
       savedPositions[nodeId] = { x: newX, y: newY };
      }
      });
      selectedRects.forEach(rectId => {
      if (rectId === rect.id) return;
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      
      forgeTheTopology();
      };
           
           const upHandler = () => {
            if (isDragging) {
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           };
           
           document.addEventListener("mousemove", moveHandler);
           document.addEventListener("mouseup", upHandler);
           
           let touchStartX, touchStartY;
           let touchRectStartX, touchRectStartY;
           
           rectEl.addEventListener("touchstart", (e) => {
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchRectStartX = rect.x;
            touchRectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           }, { passive: false });
           
           rectEl.addEventListener("touchmove", (e) => {
            if (!isDragging || rectDrawMode) return;
            if (!e.touches[0]) return;
            e.preventDefault();
            e.stopPropagation();
            
            const svgEl = svg;
            const pt1 = svgEl.createSVGPoint();
            pt1.x = touchStartX;
            pt1.y = touchStartY;
            const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
            
            const touch = e.touches[0];
            const pt2 = svgEl.createSVGPoint();
            pt2.x = touch.clientX;
            pt2.y = touch.clientY;
            const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
            
            const dx = svgP2.x - svgP1.x;
            const dy = svgP2.y - svgP1.y;
            
            rect.x = touchRectStartX + dx;
            rect.y = touchRectStartY + dy;
            
            forgeTheTopology();
           }, { passive: false });
           
           rectEl.addEventListener("touchend", (e) => {
            if (isDragging) {
             e.preventDefault();
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           }, { passive: false });
            if (currentRectId === rect.id) {
      const corners = [
      { cx: rect.x, cy: rect.y, cursor: 'nwse-resize', dx: -1, dy: -1 },
      { cx: rect.x + rect.width, cy: rect.y, cursor: 'nesw-resize', dx: 1, dy: -1 },
      { cx: rect.x, cy: rect.y + rect.height, cursor: 'nesw-resize', dx: -1, dy: 1 },
      { cx: rect.x + rect.width, cy: rect.y + rect.height, cursor: 'nwse-resize', dx: 1, dy: 1 }
      ];
      corners.forEach((corner, idx) => {
      const handle = document.createElementNS(ns, "circle");
      handle.setAttribute("cx", corner.cx);
      handle.setAttribute("cy", corner.cy);
      handle.setAttribute("r", PAGE_STATE.selectionHandleSize || 8);
      handle.style.fill = PAGE_STATE.selectionHandle || "#f59e0b";
      handle.style.stroke = "#fff";
      handle.style.strokeWidth = "2";
      handle.style.cursor = corner.cursor;
      handle.addEventListener("mousedown", (e) => {
      e.preventDefault();
      e.stopPropagation();
      let dragging = true;
      const startX = e.clientX, startY = e.clientY;
      const origX = rect.x, origY = rect.y, origW = rect.width, origH = rect.height;
      const moveHandler = (ev) => {
        if (!dragging) return;
        const pt1 = svg.createSVGPoint(); pt1.x = startX; pt1.y = startY;
        const pt2 = svg.createSVGPoint(); pt2.x = ev.clientX; pt2.y = ev.clientY;
        const svgP1 = pt1.matrixTransform(svg.getScreenCTM().inverse());
        const svgP2 = pt2.matrixTransform(svg.getScreenCTM().inverse());
        const dx = svgP2.x - svgP1.x, dy = svgP2.y - svgP1.y;
        if (corner.dx < 0) { rect.x = origX + dx; rect.width = origW - dx; }
        else { rect.width = origW + dx; }
        if (corner.dy < 0) { rect.y = origY + dy; rect.height = origH - dy; }
        else { rect.height = origH + dy; }
        if (rect.width < 20) rect.width = 20;
        if (rect.height < 20) rect.height = 20;
        forgeTheTopology();
      };
      const upHandler = () => { dragging = false; document.removeEventListener("mousemove", moveHandler); document.removeEventListener("mouseup", upHandler); };
      document.addEventListener("mousemove", moveHandler);
      document.addEventListener("mouseup", upHandler);
      });
      g.appendChild(handle);
      });
      }
          if (rect.groupId) {
      const groupIndicator = document.createElementNS(ns, "rect");
      groupIndicator.setAttribute("x", rect.x - 4);
      groupIndicator.setAttribute("y", rect.y - 4);
      groupIndicator.setAttribute("width", rect.width + 8);
      groupIndicator.setAttribute("height", rect.height + 8);
      groupIndicator.style.fill = "none";
      groupIndicator.style.stroke = "#4fd1c5";
      groupIndicator.style.strokeWidth = "3";
      groupIndicator.style.strokeDasharray = "5,5";
      groupIndicator.style.pointerEvents = "none";
      g.insertBefore(groupIndicator, g.firstChild);
      }
      g.appendChild(rectEl);
      g.appendChild(deleteBtn);
      svg.appendChild(g);
          }
         });
        }
       const centerX = CANVAS_WIDTH / 2;
       const centerY = CANVAS_HEIGHT / 2;
       let positions = {};
              Object.keys(NODE_DATA).forEach((id) => {
        if (currentView.mode === "rack") {
         const node = NODE_DATA[id];
         if (!node || node.assignedRack !== currentView.rackId) {
          return; 
         }
        }
        
        positions[id] = savedPositions[id] || {
         x: centerX,
         y: centerY
        };
       });
       if (Object.keys(savedPositions).length === 0) {
        const nodeIds = Object.keys(NODE_DATA).filter(id => {
         if (currentView.mode === "rack") {
          const node = NODE_DATA[id];
          return node && node.assignedRack === currentView.rackId;
         }
         return true;
        });
        
        const baseY = centerY - 300;
        if (nodeIds.length > 0) {
         positions[nodeIds[0]] = {
          x: centerX,
          y: baseY
         };
         const remaining = nodeIds.slice(1);
         const radius = 350;
         const startAngle = Math.PI * 0.3;
         const endAngle = Math.PI * 0.7;
         remaining.forEach((id, i) => {
          const angle = startAngle + (endAngle - startAngle) * (i / Math.max(1, remaining.length - 1));
          positions[id] = {
           x: centerX + Math.cos(angle) * radius * (i % 2 === 0 ? 1 : 1.3),
           y: baseY + 200 + Math.sin(angle) * radius * 0.8 + i * 80,
          };
         });
        }
       }
       Object.keys(positions).forEach((id) => {
        let pos = savedPositions[id] || positions[id];
        const nodeSize = savedSizes[id] || 55;
        pos.x = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, pos.x), );
        pos.y = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, pos.y), );
        positions[id] = {
         x: pos.x,
         y: pos.y
        };
        savedPositions[id] = {
         x: pos.x,
         y: pos.y
        };
       });
       const edgePairCount = {};
       const edgePairIndex = {};
       EDGE_DATA.list.forEach((edge) => {
        if (edge.type === "custom") return;
        const key = [edge.from, edge.to].sort().join("||");
        edgePairCount[key] = (edgePairCount[key] || 0) + 1;
       });
       EDGE_DATA.list.forEach((edge) => {
        if (edge.type === "custom") return;
        const key = [edge.from, edge.to].sort().join("||");
        if (!edgePairIndex[key]) edgePairIndex[key] = 0;
        edge._pairIndex = edgePairIndex[key];
        edge._pairTotal = edgePairCount[key];
        edgePairIndex[key]++;
       });
       EDGE_DATA.list.forEach((edge) => {
        if (edge.type === "custom" && Array.isArray(edge.points) && edge.points.length >= 2) {
         const poly = document.createElementNS(ns, "polyline");
         poly.classList.add("edge");
         poly.dataset.edgeId = edge.id;
         poly.style.stroke = edge.color || PAGE_STATE.defaultEdge || "#475569";
         poly.style.strokeWidth = edge.width || 4;
         poly.setAttribute("fill", "none");
         const lineStyle = edge.lineStyle || "solid";
         if (lineStyle === "dashed") {
          poly.style.strokeDasharray = "10,5";
         } else if (lineStyle === "dotted") {
          poly.style.strokeDasharray = "2,4";
         } else {
          poly.style.strokeDasharray = "none";
         }
         const direction = edge.direction || "none";
         if (direction === "forward") {
          poly.setAttribute("marker-end", "url(#arrow-forward)");
         } else if (direction === "backward") {
          poly.setAttribute("marker-start", "url(#arrow-backward)");
         } else if (direction === "both") {
          poly.setAttribute("marker-start", "url(#arrow-backward)");
          poly.setAttribute("marker-end", "url(#arrow-forward)");
         }
         const ptsStr = edge.points.map((p) => `${p.x},${p.y}`).join(" ");
         poly.setAttribute("points", ptsStr);
         const polyHit = document.createElementNS(ns, "polyline");
         polyHit.setAttribute("points", ptsStr);
         polyHit.style.fill = "none";
         polyHit.style.stroke = "transparent";
         polyHit.style.strokeWidth = "20";
         polyHit.style.cursor = "pointer";
         polyHit.dataset.edgeId = edge.id;
         polyHit.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         let edgeTouchStart = null;
         let edgeTouchMoved = false;
         polyHit.addEventListener("touchstart", (e) => {
          edgeTouchStart = Date.now();
          edgeTouchMoved = false;
          if (e.touches[0]) {
           edgeTouchStartX = e.touches[0].clientX;
           edgeTouchStartY = e.touches[0].clientY;
          }
         }, {
          passive: false
         });
         let edgeTouchStartX = 0, edgeTouchStartY = 0;
         polyHit.addEventListener("touchmove", (e) => {
          if (e.touches[0]) {
           const dx = Math.abs(e.touches[0].clientX - edgeTouchStartX);
           const dy = Math.abs(e.touches[0].clientY - edgeTouchStartY);
           if (dx > 10 || dy > 10) edgeTouchMoved = true;
          }
         }, {
          passive: false
         });
         polyHit.addEventListener("touchend", (e) => {
          if (edgeTouchStart && !edgeTouchMoved && Date.now() - edgeTouchStart < 400) {
           e.stopPropagation();
           e.preventDefault();
           selectTheConnection(edge.id);
          }
          edgeTouchStart = null;
          edgeTouchMoved = false;
         }, {
          passive: false
         });
         poly.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         
         polyHit.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (selectedEdges.has(edge.id)) {
           selectedEdges.delete(edge.id);
          } else {
           selectedEdges.add(edge.id);
          }
          updateAllSelections();
         });
         
         let customEdgeLastTap = 0;
         polyHit.addEventListener("touchend", (e) => {
          const now = Date.now();
          if (now - customEdgeLastTap < 300) {
           e.preventDefault();
           if (selectedEdges.has(edge.id)) {
            selectedEdges.delete(edge.id);
           } else {
            selectedEdges.add(edge.id);
           }
           updateAllSelections();
           if (navigator.vibrate) navigator.vibrate(50);
           customEdgeLastTap = 0;
          } else {
           customEdgeLastTap = now;
          }
         }, { passive: false });   
         poly.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (selectedEdges.has(edge.id)) {
           selectedEdges.delete(edge.id);
          } else {
           selectedEdges.add(edge.id);
          }
          updateAllSelections();
         });
         
         let edgeLastTap = 0;
         poly.addEventListener("touchend", (e) => {
          const now = Date.now();
          if (now - edgeLastTap < 300) {
           e.preventDefault();
           if (selectedEdges.has(edge.id)) {
            selectedEdges.delete(edge.id);
           } else {
            selectedEdges.add(edge.id);
           }
           updateAllSelections();
           if (navigator.vibrate) navigator.vibrate(50);
           edgeLastTap = 0;
          } else {
           edgeLastTap = now;
          }
         });
         
         if (currentView.mode === "rack") {
          return;
         }
         if (edge.groupId) {
      const bounds = edge.points.reduce((acc, p) => ({ minX: Math.min(acc.minX, p.x), minY: Math.min(acc.minY, p.y), maxX: Math.max(acc.maxX, p.x), maxY: Math.max(acc.maxY, p.y) }), { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity });
      const groupIndicator = document.createElementNS(ns, "rect");
      groupIndicator.setAttribute("x", bounds.minX - 8);
      groupIndicator.setAttribute("y", bounds.minY - 8);
      groupIndicator.setAttribute("width", bounds.maxX - bounds.minX + 16);
      groupIndicator.setAttribute("height", bounds.maxY - bounds.minY + 16);
      groupIndicator.setAttribute("rx", "4");
      groupIndicator.style.fill = "none";
      groupIndicator.style.stroke = "#4fd1c5";
      groupIndicator.style.strokeWidth = "3";
      groupIndicator.style.strokeDasharray = "5,5";
      groupIndicator.style.pointerEvents = "none";
      svg.appendChild(groupIndicator);
      }
         let lineDragging = false;
      let lineDragStartX, lineDragStartY;
      let linePointsStart = [];
      
      polyHit.addEventListener("mousedown", (e) => {
      if (freeDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      lineDragging = true;
      lineDragStartX = e.clientX;
      lineDragStartY = e.clientY;
      linePointsStart = edge.points.map(p => ({x: p.x, y: p.y}));
      
      if (selectedEdges.has(edge.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
      
      const lineMoveHandler = (e) => {
      if (!lineDragging || freeDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = lineDragStartX;
      pt1.y = lineDragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      
      edge.points.forEach((p, i) => { p.x = linePointsStart[i].x + dx; p.y = linePointsStart[i].y + dy; });
      
      if (selectedEdges.has(edge.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       savedPositions[nodeId] = { x: initialPositions[nodeId].x + dx, y: initialPositions[nodeId].y + dy };
      }
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      if (edgeId === edge.id) return;
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      forgeTheTopology();
      };
      
      const lineUpHandler = () => { lineDragging = false; };
      document.addEventListener("mousemove", lineMoveHandler);
      document.addEventListener("mouseup", lineUpHandler);
      
      svg.appendChild(poly);
      svg.appendChild(polyHit);
         
         if (currentEdgeId === edge.id) {
          edge.points.forEach((p, idx) => {
           const c = document.createElementNS(ns, "circle");
           c.classList.add("edge-edit-point");
           c.setAttribute("cx", p.x);
           c.setAttribute("cy", p.y);
      c.setAttribute("r", PAGE_STATE.selectionHandleSize || 8);
           c.style.fill = PAGE_STATE.selectionHandle || "#f59e0b";
           c.style.stroke = "#fff";
           c.style.strokeWidth = "2";
           c.style.cursor = "move";
           c.dataset.edgeId = edge.id;
           c.dataset.pointIndex = String(idx);
           
           c.addEventListener("mousedown", (e) => {
		   if (isViewOnly()) return;
            e.preventDefault();
            e.stopPropagation();
            let dragging = true;
            const svgEl = svg;
            const moveHandler = (ev) => {
             if (!dragging) return;
             const pt = svgEl.createSVGPoint();
             pt.x = ev.clientX;
             pt.y = ev.clientY;
             const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
             edge.points[idx].x = svgP.x;
             edge.points[idx].y = svgP.y;
             forgeTheTopology();
            };
            const upHandler = () => {
             dragging = false;
             document.removeEventListener("mousemove", moveHandler);
             document.removeEventListener("mouseup", upHandler);
            };
            document.addEventListener("mousemove", moveHandler);
            document.addEventListener("mouseup", upHandler);
           });
           
           c.addEventListener("touchstart", (e) => {
            e.preventDefault();
            e.stopPropagation();
            let dragging = true;
            const svgEl = svg;
            const touchMoveHandler = (ev) => {
             if (!dragging || !ev.touches[0]) return;
             const pt = svgEl.createSVGPoint();
             pt.x = ev.touches[0].clientX;
             pt.y = ev.touches[0].clientY;
             const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
             edge.points[idx].x = svgP.x;
             edge.points[idx].y = svgP.y;
             forgeTheTopology();
            };
            const touchUpHandler = () => {
             dragging = false;
             document.removeEventListener("touchmove", touchMoveHandler);
             document.removeEventListener("touchend", touchUpHandler);
            };
            document.addEventListener("touchmove", touchMoveHandler);
            document.addEventListener("touchend", touchUpHandler);
           }, { passive: false });
           
           svg.appendChild(c);
          });
         }
         
         return;
        }
        const p1 = positions[edge.from];
        const p2 = positions[edge.to];
        if (!p1 || !p2) return;
        const pairTotal = edge._pairTotal || 1;
        const pairIndex = edge._pairIndex || 0;
        const midX = (p1.x + p2.x) / 2;
        const midY = (p1.y + p2.y) / 2;
        const dx = p2.x - p1.x;
        const dy = p2.y - p1.y;
        const len = Math.sqrt(dx * dx + dy * dy) || 1;
        const perpX = -dy / len;
        const perpY = dx / len;
        let offsetAmount = 0;
        if (pairTotal > 1) {
         offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
        }
        const ctrlX = midX + perpX * offsetAmount;
        const ctrlY = midY + perpY * offsetAmount;
        const path = document.createElementNS(ns, "path");
        path.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
        path.setAttribute("fill", "none");
        path.classList.add("edge");
        if (edge.type === "backup") path.classList.add("backup");
        path.dataset.edgeId = edge.id;
        path.dataset.from = edge.from;
        path.dataset.to = edge.to;
        path.style.stroke = edge.color;
        path.style.strokeWidth = edge.width;
        const pathHit = document.createElementNS(ns, "path");
        pathHit.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
        pathHit.setAttribute("fill", "none");
        pathHit.style.stroke = "transparent";
        pathHit.style.strokeWidth = "20";
        pathHit.style.cursor = "pointer";
        pathHit.dataset.edgeId = edge.id;
        pathHit.addEventListener("click", (e) => {
         e.stopPropagation();
         selectTheConnection(edge.id);
        });
        let pathTouchStart = null;
        let pathTouchMoved = false;
        pathHit.addEventListener("touchstart", (e) => {
         pathTouchStart = Date.now();
         pathTouchMoved = false;
         if (e.touches[0]) {
          pathTouchStartX = e.touches[0].clientX;
          pathTouchStartY = e.touches[0].clientY;
         }
        }, {
         passive: false
        });
        let pathTouchStartX = 0, pathTouchStartY = 0;
        pathHit.addEventListener("touchmove", (e) => {
         if (e.touches[0]) {
          const dx = Math.abs(e.touches[0].clientX - pathTouchStartX);
          const dy = Math.abs(e.touches[0].clientY - pathTouchStartY);
          if (dx > 10 || dy > 10) pathTouchMoved = true;
         }
        }, {
         passive: false
        });
        pathHit.addEventListener("touchend", (e) => {
         if (pathTouchStart && !pathTouchMoved && Date.now() - pathTouchStart < 400) {
          e.stopPropagation();
          e.preventDefault();
          selectTheConnection(edge.id);
         }
         pathTouchStart = null;
         pathTouchMoved = false;
        }, {
         passive: false
        });
        path.addEventListener("click", (e) => {
         e.stopPropagation();
         selectTheConnection(edge.id);
        });
        
        if (currentView.mode === "rack") {
         const fromNode = NODE_DATA[edge.from];
         const toNode = NODE_DATA[edge.to];
         if (!fromNode || !toNode || 
             fromNode.assignedRack !== currentView.rackId || 
             toNode.assignedRack !== currentView.rackId) {
          return; 
         }
        }
        
        const fromVisible = isNodeVisible(edge.from);
        const toVisible = isNodeVisible(edge.to);
        if (!fromVisible || !toVisible) {
         path.style.opacity = "0.1";
         path.style.pointerEvents = "none";
         pathHit.style.pointerEvents = "none";
        }
        
        svg.appendChild(path);
        svg.appendChild(pathHit);
        
        if (edge.fromPort || edge.toPort) {
         const ns = "http://www.w3.org/2000/svg";
         
         if (edge.fromPort) {
          const fromLabel = document.createElementNS(ns, "text");
          fromLabel.textContent = edge.fromPort;
          fromLabel.setAttribute("x", p1.x);
          fromLabel.setAttribute("y", p1.y - 10);
          fromLabel.setAttribute("text-anchor", "middle");
          fromLabel.style.fill = "#94a3b8";
          fromLabel.style.fontSize = "12px";
          fromLabel.style.fontWeight = "600";
          fromLabel.style.pointerEvents = "none";
          fromLabel.classList.add("port-label");
          svg.appendChild(fromLabel);
         }
         
         if (edge.toPort) {
          const toLabel = document.createElementNS(ns, "text");
          toLabel.textContent = edge.toPort;
          toLabel.setAttribute("x", p2.x);
          toLabel.setAttribute("y", p2.y - 10);
          toLabel.setAttribute("text-anchor", "middle");
          toLabel.style.fill = "#94a3b8";
          toLabel.style.fontSize = "12px";
          toLabel.style.fontWeight = "600";
          toLabel.style.pointerEvents = "none";
          toLabel.classList.add("port-label");
          svg.appendChild(toLabel);
         }
        }
       });
       Object.entries(positions).forEach(([id, pos]) => {
        const node = NODE_DATA[id];
        if (!node) return;
        
        if (currentView.mode === "rack") {
         if (node.assignedRack !== currentView.rackId) return;
         
         const rackUnit = parseInt(node.rackUnit) || 1;
      const uHeight = parseInt(node.uHeight) || 1;
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      pos.x = RACK_START_X;
      pos.y = RACK_START_Y + (rackCapacity - rackUnit - uHeight + 1) * rackUHeight + (uHeight * rackUHeight) / 2;
      
        } else {
         if (node.assignedRack) return;
        }
        
        const g = document.createElementNS("http://www.w3.org/2000/svg", "g", );
        g.classList.add("node-group");
        g.dataset.nodeId = id;
        g.setAttribute("transform", `translate(${pos.x},${pos.y})`);
        let r = savedSizes[id] || 55;
        if (!savedSizes[id]) {
         if (window.innerWidth <= 380) r = 120;
         else if (window.innerWidth <= 768) r = 140;
         else if (window.innerWidth <= 1024) r = 70;
        }
        const styles = resolveStylesForNode(id);
        const ns = "http://www.w3.org/2000/svg";
        const hitArea = document.createElementNS(ns, "circle");
        hitArea.setAttribute("r", r * 1.5);
        hitArea.style.fill = "transparent";
        hitArea.style.stroke = "none";
        hitArea.style.cursor = "grab";
        hitArea.classList.add("node-hit-area");
        const shapeEl = createNodeShape(id, r);
        const titleOffsetX = styles.titleOffsetX || 0;
        const titleOffsetY = styles.titleOffsetY || 0;
        const subOffsetX = styles.subOffsetX || 0;
        const subOffsetY = styles.subOffsetY || 0;
        const label = document.createElementNS("http://www.w3.org/2000/svg", "text", );
        label.classList.add("node-label");
        label.setAttribute("x", titleOffsetX);
        label.setAttribute("y", -r * 0.28 + titleOffsetY);
      const labelFontSize = styles.titleSize || PAGE_STATE.nodeTitleSize || r * 0.33;
        label.style.fontSize = labelFontSize + "px";
        label.textContent = NODE_DATA[id].name;
      label.style.fill = styles.titleColor || PAGE_STATE.nodeTitle || "#e2e8f0";
        label.style.fontFamily = styles.titleFont || PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
        label.style.pointerEvents = "none";
        const sub = document.createElementNS("http://www.w3.org/2000/svg", "text", );
        sub.classList.add("node-sub");
        sub.setAttribute("x", subOffsetX);
        sub.setAttribute("y", r * 0.4 + subOffsetY);
      const subFontSize = styles.subSize || PAGE_STATE.nodeSubSize || r * 0.24;
        sub.style.fontSize = subFontSize + "px";
        sub.textContent = NODE_DATA[id].ip;
      sub.style.fill = styles.subColor || PAGE_STATE.nodeSub || "#94a3b8";
        sub.style.fontFamily = styles.subFont || PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
        sub.style.pointerEvents = "none";
        g.append(hitArea, shapeEl, label, sub);
        
        if (NODE_DATA[id]?.locked) {
          const lockIcon = document.createElementNS(ns, "text");
          lockIcon.textContent = "🔒";
          lockIcon.setAttribute("x", r * 0.6);
          lockIcon.setAttribute("y", -r * 0.6);
          lockIcon.style.fontSize = (r * 0.4) + "px";
          lockIcon.style.pointerEvents = "none";
          lockIcon.style.userSelect = "none";
          lockIcon.classList.add("lock-indicator");
          g.appendChild(lockIcon);
        }
        
        if (NODE_DATA[id]?.groupId) {
          const groupIndicator = document.createElementNS(ns, "circle");
          groupIndicator.setAttribute("r", r + 4);
          groupIndicator.style.fill = "none";
      groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
          groupIndicator.style.strokeWidth = "3";
          groupIndicator.style.strokeDasharray = "5,5";
          groupIndicator.style.pointerEvents = "none";
          groupIndicator.classList.add("group-indicator");
          g.insertBefore(groupIndicator, g.firstChild);
        }
        
        let isDragging = false;
        let startX, startY;
        let initialPositions = {};
        let longPressTimer = null;
        let longPressTriggered = false;
        
        g.addEventListener("contextmenu", (e) => {
         e.preventDefault();
         e.stopPropagation();
         if (isViewOnly()) return;
         
         if (selectedNodes.has(id)) {
          selectedNodes.delete(id);
         } else {
          selectedNodes.add(id);
         }
         updateNodeSelection();
         return false;
        });
        
        g.addEventListener("touchstart", (e) => {
         if (NODE_DATA[id].isRack) {
          const touch = e.touches[0];
          longPressStartX = touch.clientX;
          longPressStartY = touch.clientY;
          longPressTimer = setTimeout(() => {
           longPressTriggered = true;
           if (navigator.vibrate) {
            navigator.vibrate(100);
           }
           enterRack(id);
          }, 500); 
         }
        }, { passive: true });
        
        let lastTapTime = 0;
        let lastTapNode = null;
        
        g.addEventListener("touchend", (e) => {
         const currentTime = new Date().getTime();
         const tapLength = currentTime - lastTapTime;
         
         if (tapLength < 300 && tapLength > 0 && lastTapNode === id) {
          e.preventDefault();
          e.stopPropagation();
          if (isViewOnly()) return;
          
          if (selectedNodes.has(id)) {
           selectedNodes.delete(id);
          } else {
           selectedNodes.add(id);
          }
          updateNodeSelection();
          
          if (navigator.vibrate) {
           navigator.vibrate(50);
          }
          
          lastTapTime = 0;
          lastTapNode = null;
         } else {
          lastTapTime = currentTime;
          lastTapNode = id;
         }
        });
        
        g.addEventListener("touchend", (e) => {
         if (longPressTimer) {
          clearTimeout(longPressTimer);
          longPressTimer = null;
         }
         if (longPressTriggered) {
          e.preventDefault();
          e.stopPropagation();
          longPressTriggered = false;
         }
        });
        
        let longPressStartX = 0;
        let longPressStartY = 0;
        g.addEventListener("touchmove", (e) => {
         if (longPressTimer) {
          const touch = e.touches[0];
          const dx = Math.abs(touch.clientX - longPressStartX);
          const dy = Math.abs(touch.clientY - longPressStartY);
          if (dx > 15 || dy > 15) {
           clearTimeout(longPressTimer);
           longPressTimer = null;
           longPressTriggered = false;
          }
         }
        });
        
        g.addEventListener("mousedown", (e) => {
		 if (isViewOnly()) return;
         if (e.button === 2) {
          return;
         }
         
         if (NODE_DATA[id]?.locked) {
          return;
         }
         
         e.preventDefault();
         isDragging = true;
         const svgEl = document.getElementById("map");
         const pt = svgEl.createSVGPoint();
         pt.x = e.clientX;
         pt.y = e.clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
         startX = svgP.x;
         startY = svgP.y;
      if (selectedNodes.has(id)) {
      initialPositions = {};
      const allSelectedRects = Array.from(selectedRects);
      const allSelectedTexts = Array.from(selectedTexts);
      const allSelectedEdges = Array.from(selectedEdges).map(eid => EDGE_DATA.list.find(e => e.id === eid)).filter(Boolean);   
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) {
      initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      }
      });
      Array.from(selectedRects).forEach(rectId => {
        const rect = RECT_DATA.list.find(r => r.id === rectId);
        if (rect) { rect._dragStartX = rect.x; rect._dragStartY = rect.y; }
      });
      Array.from(selectedTexts).forEach(textId => {
        const text = TEXT_DATA.list.find(t => t.id === textId);
        if (text) { text._dragStartX = text.x; text._dragStartY = text.y; }
      });
      Array.from(selectedEdges).forEach(edgeId => {
        const edge = EDGE_DATA.list.find(e => e.id === edgeId);
        if (edge && edge.points) { edge._dragStartPoints = edge.points.map(p => ({x: p.x, y: p.y})); }
      });
      
      
      
      
      } else {
      initialPositions = { [id]: { x: pos.x, y: pos.y } };
      }
      if (currentView.mode === "rack") {
      initialPositions[id] = { x: pos.x, y: pos.y };
      }
         
         g.style.cursor = "grabbing";
         hitArea.style.cursor = "grabbing";
         e.stopPropagation();
        });
        const handleMouseMove = (e) => {
         if (!isDragging) return;
         e.preventDefault();
         const svgEl = document.getElementById("map");
         const pt = svgEl.createSVGPoint();
         pt.x = e.clientX;
         pt.y = e.clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
         const dx = svgP.x - startX;
         const dy = svgP.y - startY;
         
         let nodesToMove = selectedNodes.has(id) ? Array.from(selectedNodes) : [id];
         
         const groupIds = new Set();
         nodesToMove.forEach(nodeId => {
          const groupId = NODE_DATA[nodeId]?.groupId;
          if (groupId) {
            groupIds.add(groupId);
          }
         });
         
         if (groupIds.size > 0) {
          Object.keys(NODE_DATA).forEach(nodeId => {
            const nodeGroupId = NODE_DATA[nodeId]?.groupId;
            if (nodeGroupId && groupIds.has(nodeGroupId)) {
              if (!nodesToMove.includes(nodeId)) {
                nodesToMove.push(nodeId);
                if (!initialPositions[nodeId]) {
                  const nodePos = savedPositions[nodeId];
                  if (nodePos) {
                    initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
                  }
                }
              }
            }
          });
         }
         
         nodesToMove = nodesToMove.filter(nodeId => !NODE_DATA[nodeId]?.locked);
         
         nodesToMove.forEach(nodeId => {
          if (!initialPositions[nodeId]) return;
          const initialPos = initialPositions[nodeId];
          let newX = initialPos.x + dx;
          let newY = initialPos.y + dy;
          const nodeSize = savedSizes[nodeId] || 55;
          newX = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, newX), );
          newY = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, newY), );
          
          savedPositions[nodeId] = { x: newX, y: newY };
          positions[nodeId] = { x: newX, y: newY };
          
          if (nodeId === id) {
           pos.x = newX;
           pos.y = newY;
          }
          
          const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
          if (nodeGroup) {
           nodeGroup.setAttribute("transform", `translate(${newX},${newY})`);
          }
         });
         
         Array.from(selectedRects).forEach(rectId => {
           const rect = RECT_DATA.list.find(r => r.id === rectId);
           if (rect && rect._dragStartX !== undefined) {
             rect.x = rect._dragStartX + dx;
             rect.y = rect._dragStartY + dy;
           }
         });
         Array.from(selectedTexts).forEach(textId => {
           const text = TEXT_DATA.list.find(t => t.id === textId);
           if (text && text._dragStartX !== undefined) {
             text.x = text._dragStartX + dx;
             text.y = text._dragStartY + dy;
           }
         });
         Array.from(selectedEdges).forEach(edgeId => {
           const edge = EDGE_DATA.list.find(e => e.id === edgeId);
           if (edge && edge._dragStartPoints) {
             edge.points.forEach((p, i) => {
               p.x = edge._dragStartPoints[i].x + dx;
               p.y = edge._dragStartPoints[i].y + dy;
             });
           }
         });
         forgeTheTopology();
         
         updateMinimap();
         document.querySelectorAll(".edge").forEach((edgeEl) => {
          const fromId = edgeEl.dataset.from;
          const toId = edgeEl.dataset.to;
          if (nodesToMove.includes(fromId) || nodesToMove.includes(toId)) {
           const p1 = savedPositions[fromId] || positions[fromId] || {
            x: 600,
            y: 350
           };
           const p2 = savedPositions[toId] || positions[toId] || {
            x: 600,
            y: 350
           };
           if (edgeEl.tagName === "line") {
            edgeEl.setAttribute("x1", p1.x);
            edgeEl.setAttribute("y1", p1.y);
            edgeEl.setAttribute("x2", p2.x);
            edgeEl.setAttribute("y2", p2.y);
           } else if (edgeEl.tagName === "path") {
            const edgeId = edgeEl.dataset.edgeId;
            const edge = EDGE_DATA.list.find(
             (e) => e.id === edgeId, );
            if (edge) {
             const pairTotal = edge._pairTotal || 1;
             const pairIndex = edge._pairIndex || 0;
             const midX = (p1.x + p2.x) / 2;
             const midY = (p1.y + p2.y) / 2;
             const dx = p2.x - p1.x;
             const dy = p2.y - p1.y;
             const len = Math.sqrt(dx * dx + dy * dy) || 1;
             const perpX = -dy / len;
             const perpY = dx / len;
             let offsetAmount = 0;
             if (pairTotal > 1) {
              offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
             }
             const ctrlX = midX + perpX * offsetAmount;
             const ctrlY = midY + perpY * offsetAmount;
             edgeEl.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
            }
           }
          }
         });
        };
      const handleMouseUp = () => {
      if (isDragging) {
      pushUndo("move nodes");
      isDragging = false;
      g.style.cursor = "grab";
      hitArea.style.cursor = "grab";
      if (currentView.mode === "rack" && NODE_DATA[id]?.assignedRack === currentView.rackId) {
      const draggedY = savedPositions[id]?.y || pos.y;
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      let newUnit = rackCapacity - Math.round((draggedY - RACK_START_Y) / rackUHeight);
      newUnit = Math.max(1, Math.min(newUnit, rackCapacity));
      NODE_DATA[id].rackUnit = newUnit;
      
      forgeTheTopology();
      claimTheImmortal(id);
      }
      }
      };
        document.addEventListener("mousemove", handleMouseMove);
        document.addEventListener("mouseup", handleMouseUp);
        let touchStartTime = 0;
        let touchStartX = 0;
        let touchStartY = 0;
        let touchMoved = false;
        g.addEventListener("touchstart",
         (e) => {
          if (isViewOnly()) {
           touchStartTime = Date.now();
           touchMoved = false;
           e.stopPropagation();
           return;
          }
          if (NODE_DATA[id]?.locked) {
           return;
          }
          
          e.preventDefault();
          touchStartTime = Date.now();
          touchMoved = false;
          const svgEl = document.getElementById("map");
          const pt = svgEl.createSVGPoint();
          const touch = e.touches[0];
          pt.x = touch.clientX;
          pt.y = touch.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          touchStartX = svgP.x;
          touchStartY = svgP.y;
          startX = svgP.x;
          startY = svgP.y;
          
          if (selectedNodes.has(id)) {
           initialPositions = {};
           selectedNodes.forEach(nodeId => {
            const nodePos = savedPositions[nodeId];
            if (nodePos) {
             initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
            }
           });
          } else {
           initialPositions = { [id]: { x: pos.x, y: pos.y } };
          }
          
          e.stopPropagation();
         }, {
          passive: false
         }, );
        g.addEventListener("touchmove", (e) => {
         e.preventDefault();
         const svgEl = document.getElementById("map");
         const pt = svgEl.createSVGPoint();
         const touch = e.touches[0];
         pt.x = touch.clientX;
         pt.y = touch.clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
         const dx = Math.abs(svgP.x - touchStartX);
         const dy = Math.abs(svgP.y - touchStartY);
         if (dx > (isMobileDevice() ? 4 : 10) || dy > (isMobileDevice() ? 4 : 10)) {
      touchMoved = true;
      isDragging = true;
      }
         if (!isDragging) return;
         
         const deltaX = svgP.x - startX;
         const deltaY = svgP.y - startY;
         
         let nodesToMove = selectedNodes.has(id) ? Array.from(selectedNodes) : [id];
         
         const groupIds = new Set();
         nodesToMove.forEach(nodeId => {
          const groupId = NODE_DATA[nodeId]?.groupId;
          if (groupId) {
            groupIds.add(groupId);
          }
         });
         
         if (groupIds.size > 0) {
          Object.keys(NODE_DATA).forEach(nodeId => {
            const nodeGroupId = NODE_DATA[nodeId]?.groupId;
            if (nodeGroupId && groupIds.has(nodeGroupId)) {
              if (!nodesToMove.includes(nodeId)) {
                nodesToMove.push(nodeId);
                if (!initialPositions[nodeId]) {
                  const nodePos = savedPositions[nodeId];
                  if (nodePos) {
                    initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
                  }
                }
              }
            }
          });
         }
         
         nodesToMove = nodesToMove.filter(nodeId => !NODE_DATA[nodeId]?.locked);
         
         nodesToMove.forEach(nodeId => {
          if (!initialPositions[nodeId]) return;
          const initialPos = initialPositions[nodeId];
          let newX = initialPos.x + deltaX;
          let newY = initialPos.y + deltaY;
          const nodeSize = savedSizes[nodeId] || 55;
          newX = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, newX), );
          newY = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, newY), );
          
          savedPositions[nodeId] = { x: newX, y: newY };
          positions[nodeId] = { x: newX, y: newY };
          
          if (nodeId === id) {
           pos.x = newX;
           pos.y = newY;
          }
          
          const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
          if (nodeGroup) {
           nodeGroup.setAttribute("transform", `translate(${newX},${newY})`);
          }
         });
         
         updateMinimap();
         document.querySelectorAll(".edge").forEach((edgeEl) => {
          const fromId = edgeEl.dataset.from;
          const toId = edgeEl.dataset.to;
          if (nodesToMove.includes(fromId) || nodesToMove.includes(toId)) {
           const p1 = savedPositions[fromId] || positions[fromId] || {
            x: 600,
            y: 350
           };
           const p2 = savedPositions[toId] || positions[toId] || {
            x: 600,
            y: 350
           };
           if (edgeEl.tagName === "line") {
            edgeEl.setAttribute("x1", p1.x);
            edgeEl.setAttribute("y1", p1.y);
            edgeEl.setAttribute("x2", p2.x);
            edgeEl.setAttribute("y2", p2.y);
           } else if (edgeEl.tagName === "path") {
            const edgeId = edgeEl.dataset.edgeId;
            const edge = EDGE_DATA.list.find(
             (e) => e.id === edgeId, );
            if (edge) {
             const pairTotal = edge._pairTotal || 1;
             const pairIndex = edge._pairIndex || 0;
             const midX = (p1.x + p2.x) / 2;
             const midY = (p1.y + p2.y) / 2;
             const dx = p2.x - p1.x;
             const dy = p2.y - p1.y;
             const len = Math.sqrt(dx * dx + dy * dy) || 1;
             const perpX = -dy / len;
             const perpY = dx / len;
             let offsetAmount = 0;
             if (pairTotal > 1) {
              offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
             }
             const ctrlX = midX + perpX * offsetAmount;
             const ctrlY = midY + perpY * offsetAmount;
             edgeEl.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
            }
           }
          }
         });
        }, {
         passive: false
        });
      g.addEventListener("touchend", (e) => {
      const touchDuration = Date.now() - touchStartTime;
      if (!touchMoved && touchDuration < 400) {
       if (isViewOnly()) {
        handleViewOnlyClick(id, 'node');
        return;
       }
       claimTheImmortal(id);
      }
      if (isDragging) {
      const draggedY = pos.y;
      isDragging = false;
      savedPositions[id] = {
      x: pos.x,
      y: pos.y
      };
      if (currentView.mode === "rack" && NODE_DATA[id]?.assignedRack === currentView.rackId) {
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      let newUnit = rackCapacity - Math.round((draggedY - RACK_START_Y) / rackUHeight);
      
      newUnit = Math.max(1, Math.min(newUnit, rackCapacity));
      NODE_DATA[id].rackUnit = newUnit;
      forgeTheTopology();
      claimTheImmortal(id);
      }
      }
      touchMoved = false;
      });
        g.style.cursor = "grab";
        g.addEventListener("click", (e) => {
         if (!isDragging) {
          if (isViewOnly()) {
           handleViewOnlyClick(id, 'node');
           return;
          }
          claimTheImmortal(id);
         }
        });
        
        g.addEventListener("dblclick", (e) => {
         e.preventDefault();
         e.stopPropagation();
         if (NODE_DATA[id].isRack) {
          enterRack(id);
         }
        });
        
        if (!isNodeVisible(id)) {
         g.style.opacity = "0.1";
         g.style.pointerEvents = "none";
        }
        
        svg.appendChild(g);
       });
        if (RECT_DATA && RECT_DATA.list) {
         RECT_DATA.list.forEach((rect) => {
          if (currentView.mode === "rack") return;
          if (rect.style === "outlined") {
           const g = document.createElementNS(ns, "g");
           g.classList.add("rect-group");
           g.dataset.rectId = rect.id;
           
           const rectEl = document.createElementNS(ns, "rect");
           rectEl.classList.add("rect-shape");
           rectEl.setAttribute("x", rect.x);
           rectEl.setAttribute("y", rect.y);
           rectEl.setAttribute("width", rect.width);
           rectEl.setAttribute("height", rect.height);
           rectEl.style.fill = "none";
           rectEl.style.stroke = rect.borderColor || rect.color;
           rectEl.style.strokeWidth = (rect.borderWidth !== undefined ? rect.borderWidth : 3) + "px";
           if (rect.lineStyle === "dashed") { rectEl.style.strokeDasharray = "10,5"; }
           else if (rect.lineStyle === "dotted") { rectEl.style.strokeDasharray = "2,4"; }
           else { rectEl.style.strokeDasharray = "none"; }
           rectEl.style.cursor = "move";
           
           rectEl.addEventListener("click", (e) => {
             if (rectDrawMode) return;
             e.stopPropagation();
             currentRectId = rect.id;
             selectTheRect(rect.id);
           });
           
           rectEl.addEventListener("contextmenu", (e) => {
		   if (isViewOnly()) return;
             e.preventDefault();
             e.stopPropagation();
             if (selectedRects.has(rect.id)) {
               selectedRects.delete(rect.id);
             } else {
               selectedRects.add(rect.id);
             }
             updateAllSelections();
           });
           
           let rectLastTap = 0;
           rectEl.addEventListener("touchend", (e) => {
             const now = Date.now();
             if (now - rectLastTap < 300) {
               e.preventDefault();
               if (selectedRects.has(rect.id)) {
                 selectedRects.delete(rect.id);
               } else {
                 selectedRects.add(rect.id);
               }
               updateAllSelections();
               if (navigator.vibrate) navigator.vibrate(50);
               rectLastTap = 0;
             } else {
               rectLastTap = now;
             }
           }, { passive: false });
           
           const deleteBtn = document.createElementNS(ns, "g");
           deleteBtn.classList.add("rect-delete-btn");
           deleteBtn.style.cursor = "pointer";
           deleteBtn.style.display = rectDrawMode ? "block" : "none";
           
           const deleteBg = document.createElementNS(ns, "circle");
           deleteBg.setAttribute("cx", rect.x + rect.width - 10);
           deleteBg.setAttribute("cy", rect.y + 10);
           deleteBg.setAttribute("r", 12);
           deleteBg.style.fill = "#f56565";
           deleteBg.style.stroke = "white";
           deleteBg.style.strokeWidth = "2";
           
           const deleteX = document.createElementNS(ns, "text");
           deleteX.setAttribute("x", rect.x + rect.width - 10);
           deleteX.setAttribute("y", rect.y + 10);
           deleteX.setAttribute("text-anchor", "middle");
           deleteX.setAttribute("dominant-baseline", "middle");
           deleteX.style.fill = "white";
           deleteX.style.fontSize = "16px";
           deleteX.style.fontWeight = "bold";
           deleteX.style.pointerEvents = "none";
           deleteX.textContent = "×";
           
           deleteBtn.appendChild(deleteBg);
           deleteBtn.appendChild(deleteX);
           
           deleteBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            e.preventDefault();
            deleteRectangle(rect.id);
           });
           
           let isDragging = false;
           let dragStartX, dragStartY;
           let rectStartX, rectStartY;
           
           rectEl.addEventListener("mousedown", (e) => {
		   if (isViewOnly()) return;
      if (rectDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      rectStartX = rect.x;
      rectStartY = rect.y;
      rectEl.style.cursor = "grabbing";
      
      if (selectedRects.has(rect.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
           
           const moveHandler = (e) => {
      if (!isDragging || rectDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      
      rect.x = rectStartX + dx;
      rect.y = rectStartY + dy;
      
      if (selectedRects.has(rect.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       const newX = initialPositions[nodeId].x + dx;
       const newY = initialPositions[nodeId].y + dy;
       savedPositions[nodeId] = { x: newX, y: newY };
      }
      });
      selectedRects.forEach(rectId => {
      if (rectId === rect.id) return;
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      
      forgeTheTopology();
      };
           
           const upHandler = () => {
            if (isDragging) {
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           };
           
           document.addEventListener("mousemove", moveHandler);
           document.addEventListener("mouseup", upHandler);
           
           let touchStartX, touchStartY;
           let touchRectStartX, touchRectStartY;
           
           rectEl.addEventListener("touchstart", (e) => {
		   if (isViewOnly()) return;
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchRectStartX = rect.x;
            touchRectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           }, { passive: false });
           
           rectEl.addEventListener("touchmove", (e) => {
            if (!isDragging || rectDrawMode) return;
            if (!e.touches[0]) return;
            e.preventDefault();
            e.stopPropagation();
            
            const svgEl = svg;
            const pt1 = svgEl.createSVGPoint();
            pt1.x = touchStartX;
            pt1.y = touchStartY;
            const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
            
            const touch = e.touches[0];
            const pt2 = svgEl.createSVGPoint();
            pt2.x = touch.clientX;
            pt2.y = touch.clientY;
            const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
            
            const dx = svgP2.x - svgP1.x;
            const dy = svgP2.y - svgP1.y;
            
            rect.x = touchRectStartX + dx;
            rect.y = touchRectStartY + dy;
            
            forgeTheTopology();
           }, { passive: false });
           
           rectEl.addEventListener("touchend", (e) => {
            if (isDragging) {
             e.preventDefault();
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           }, { passive: false });
           
           if (rect.groupId) {
             const groupIndicator = document.createElementNS(ns, "rect");
             groupIndicator.setAttribute("x", rect.x - 4);
             groupIndicator.setAttribute("y", rect.y - 4);
             groupIndicator.setAttribute("width", rect.width + 8);
             groupIndicator.setAttribute("height", rect.height + 8);
             groupIndicator.style.fill = "none";
             groupIndicator.style.stroke = "#4fd1c5";
             groupIndicator.style.strokeWidth = "3";
             groupIndicator.style.strokeDasharray = "5,5";
             groupIndicator.style.pointerEvents = "none";
             g.insertBefore(groupIndicator, g.firstChild);
           }
           g.appendChild(rectEl);
           g.appendChild(deleteBtn);
           svg.appendChild(g);
          }
         });
        }
        
        if (TEXT_DATA && TEXT_DATA.list) {
         TEXT_DATA.list.forEach((textItem) => {
          if (currentView.mode === "rack") return;
          
          const g = document.createElementNS(ns, "g");
          g.classList.add("text-group");
          g.dataset.textId = textItem.id;
          
          if (textItem.bgEnabled) {
           const bgRect = document.createElementNS(ns, "rect");
           bgRect.classList.add("text-bg");
           
           bgRect.setAttribute("x", textItem.x - 5);
           bgRect.setAttribute("y", textItem.y - textItem.fontSize - 2);
           bgRect.setAttribute("width", 100);
           bgRect.setAttribute("height", textItem.fontSize + 10);
           bgRect.style.fill = textItem.bgColor;
           bgRect.style.opacity = "0.7";
           bgRect.style.rx = "4";
           g.appendChild(bgRect);
          }
          
          const textEl = document.createElementNS(ns, "text");
          textEl.classList.add("text-element");
          textEl.setAttribute("x", textItem.x);
          textEl.setAttribute("y", textItem.y);
          textEl.style.fill = textItem.color;
          textEl.style.fontSize = textItem.fontSize + "px";
          textEl.style.fontWeight = textItem.fontWeight;
          textEl.style.fontStyle = textItem.fontStyle;
          textEl.style.textAnchor = textItem.textAlign;
          textEl.style.textDecoration = textItem.textDecoration;
          textEl.style.opacity = textItem.opacity;
          textEl.style.cursor = "move";
          textEl.style.userSelect = "none";
          textEl.setAttribute("dominant-baseline", "middle");
          
          const lines = textItem.content.split('\n');
          if (lines.length === 1) {
           textEl.textContent = textItem.content;
          } else {
           lines.forEach((line, i) => {
            const tspan = document.createElementNS(ns, "tspan");
            tspan.textContent = line;
            tspan.setAttribute("x", textItem.x);
            tspan.setAttribute("dy", i === 0 ? 0 : textItem.fontSize * 1.2);
            textEl.appendChild(tspan);
           });
          }
          
          g.appendChild(textEl);
          
          if (textItem.bgEnabled) {
           setTimeout(() => {
            try {
             const bbox = textEl.getBBox();
             const bgRect = g.querySelector('.text-bg');
             if (bgRect && bbox) {
              bgRect.setAttribute("x", bbox.x - 5);
              bgRect.setAttribute("y", bbox.y - 2);
              bgRect.setAttribute("width", bbox.width + 10);
              bgRect.setAttribute("height", bbox.height + 4);
             }
            } catch (e) {
            }
           }, 0);
          }
          
          const deleteBtn = document.createElementNS(ns, "g");
          deleteBtn.classList.add("text-delete-btn");
          deleteBtn.style.cursor = "pointer";
          deleteBtn.style.display = textDrawMode ? "block" : "none";
          
          const deleteBg = document.createElementNS(ns, "circle");
          deleteBg.setAttribute("cx", textItem.x + 20);
          deleteBg.setAttribute("cy", textItem.y - textItem.fontSize);
          deleteBg.setAttribute("r", 12);
          deleteBg.style.fill = "#f56565";
          deleteBg.style.stroke = "white";
          deleteBg.style.strokeWidth = "2";
          
          const deleteX = document.createElementNS(ns, "text");
          deleteX.setAttribute("x", textItem.x + 20);
          deleteX.setAttribute("y", textItem.y - textItem.fontSize);
          deleteX.setAttribute("text-anchor", "middle");
          deleteX.setAttribute("dominant-baseline", "middle");
          deleteX.style.fill = "white";
          deleteX.style.fontSize = "16px";
          deleteX.style.fontWeight = "bold";
          deleteX.style.pointerEvents = "none";
          deleteX.textContent = "×";
          
          deleteBtn.appendChild(deleteBg);
          deleteBtn.appendChild(deleteX);
          
          deleteBtn.addEventListener("click", (e) => {
           e.stopPropagation();
           e.preventDefault();
           deleteText(textItem.id);
          });
          
          let isDragging = false;
          let dragStartX, dragStartY;
          let textStartX, textStartY;
          
          textEl.addEventListener("mousedown", (e) => {
		  if (isViewOnly()) return;
      if (textDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      textStartX = textItem.x;
      textStartY = textItem.y;
      textEl.style.cursor = "grabbing";
      
      showTextPanel(textItem.id);
      
      if (selectedTexts.has(textItem.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
          
          const moveHandler = (e) => {
      if (!isDragging || textDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      
      textItem.x = textStartX + dx;
      textItem.y = textStartY + dy;
      
      if (selectedTexts.has(textItem.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       const newX = initialPositions[nodeId].x + dx;
       const newY = initialPositions[nodeId].y + dy;
       savedPositions[nodeId] = { x: newX, y: newY };
      }
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      if (textId === textItem.id) return;
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      
      forgeTheTopology();
      };
          
          const upHandler = () => {
           if (isDragging) {
            isDragging = false;
            textEl.style.cursor = "move";
           }
          };
          
          document.addEventListener("mousemove", moveHandler);
          document.addEventListener("mouseup", upHandler);
          
          let touchStartX = 0, touchStartY = 0;
          let textTouchStartX = 0, textTouchStartY = 0;
          
          textEl.addEventListener("touchstart", (e) => {
		   if (isViewOnly()) return;
           if (textDrawMode) return;
           if (e.touches.length !== 1) return;
           
           e.preventDefault();
           e.stopPropagation();
           const touch = e.touches[0];
           isDragging = true;
           touchStartX = touch.clientX;
           touchStartY = touch.clientY;
           textTouchStartX = textItem.x;
           textTouchStartY = textItem.y;
           
           showTextPanel(textItem.id);
          }, { passive: false });
          
          textEl.addEventListener("touchmove", (e) => {
           if (!isDragging || textDrawMode) return;
           if (e.touches.length !== 1) return;
           
           e.preventDefault();
           const touch = e.touches[0];
           const svgEl = svg;
           
           const pt1 = svgEl.createSVGPoint();
           pt1.x = touchStartX;
           pt1.y = touchStartY;
           const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
           
           const pt2 = svgEl.createSVGPoint();
           pt2.x = touch.clientX;
           pt2.y = touch.clientY;
           const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
           
           const dx = svgP2.x - svgP1.x;
           const dy = svgP2.y - svgP1.y;
           
           textItem.x = textTouchStartX + dx;
           textItem.y = textTouchStartY + dy;
           
           forgeTheTopology();
          }, { passive: false });
          
          textEl.addEventListener("touchend", () => {
           if (isDragging) {
            isDragging = false;
           }
          }, { passive: false });
          
          textEl.addEventListener("contextmenu", (e) => {
		  if (isViewOnly()) return;
           e.preventDefault();
           e.stopPropagation();
           if (selectedTexts.has(textItem.id)) {
            selectedTexts.delete(textItem.id);
           } else {
            selectedTexts.add(textItem.id);
           }
           updateAllSelections();
          });
          
          let textLastTap = 0;
          g.addEventListener("touchend", (e) => {
           const now = Date.now();
           if (now - textLastTap < 300) {
            e.preventDefault();
            if (selectedTexts.has(textItem.id)) {
             selectedTexts.delete(textItem.id);
            } else {
             selectedTexts.add(textItem.id);
            }
            updateAllSelections();
            if (navigator.vibrate) navigator.vibrate(50);
            textLastTap = 0;
           } else {
            textLastTap = now;
           }
          }, { passive: false });
          
          if (textItem.groupId) {
            const groupIndicator = document.createElementNS(ns, "rect");
            groupIndicator.setAttribute("x", textItem.x - 54);
            groupIndicator.setAttribute("y", textItem.y - 24);
            groupIndicator.setAttribute("width", 108);
            groupIndicator.setAttribute("height", 48);
            groupIndicator.setAttribute("rx", "8");
            groupIndicator.style.fill = "none";
            groupIndicator.style.stroke = "#4fd1c5";
            groupIndicator.style.strokeWidth = "3";
            groupIndicator.style.strokeDasharray = "5,5";
            groupIndicator.style.pointerEvents = "none";
            g.insertBefore(groupIndicator, g.firstChild);
          }
          g.appendChild(deleteBtn);
          svg.appendChild(g);
         });
        }
        
       forgeTheLegend();
       updateMinimap();
       populateRackDropdown();
      }
      
      function showEditModal(title, currentValue, onSave) {
       const modal = document.getElementById("edit-modal");
       const input = document.getElementById("modal-input");
       const titleEl = document.getElementById("modal-title");
       const saveBtn = document.getElementById("modal-save");
       const cancelBtn = document.getElementById("modal-cancel");
       titleEl.textContent = title;
       input.value = currentValue;
       modal.classList.add("active");
       input.focus();
       input.select();
       const handleSave = () => {
        if (input.value.trim()) {
         onSave(input.value.trim());
        }
        modal.classList.remove("active");
        saveBtn.removeEventListener("click", handleSave);
        cancelBtn.removeEventListener("click", handleCancel);
        input.removeEventListener("keypress", handleEnter);
       };
       const handleCancel = () => {
        modal.classList.remove("active");
        saveBtn.removeEventListener("click", handleSave);
        cancelBtn.removeEventListener("click", handleCancel);
        input.removeEventListener("keypress", handleEnter);
       };
       const handleEnter = (e) => {
        if (e.key === "Enter") handleSave();
       };
       saveBtn.addEventListener("click", handleSave);
       cancelBtn.addEventListener("click", handleCancel);
       input.addEventListener("keypress", handleEnter);
       modal.addEventListener("click", function bgHandler(e) {
        if (e.target === modal) {
         handleCancel();
         modal.removeEventListener("click", bgHandler);
        }
       });
      }
      
      function challengeTheImmortal(message, onConfirm) {
       const modal = document.getElementById("confirm-modal");
       const messageEl = document.getElementById("confirm-message");
       const deleteBtn = document.getElementById("confirm-delete");
       const cancelBtn = document.getElementById("confirm-cancel");
       messageEl.textContent = message;
       modal.classList.add("active");
       const handleConfirm = () => {
        onConfirm();
        modal.classList.remove("active");
        deleteBtn.removeEventListener("click", handleConfirm);
        cancelBtn.removeEventListener("click", handleCancel);
       };
       const handleCancel = () => {
        modal.classList.remove("active");
        deleteBtn.removeEventListener("click", handleConfirm);
        cancelBtn.removeEventListener("click", handleCancel);
       };
       deleteBtn.addEventListener("click", handleConfirm);
       cancelBtn.addEventListener("click", handleCancel);
       modal.addEventListener("click", function bgHandler(e) {
        if (e.target === modal) {
         handleCancel();
         modal.removeEventListener("click", bgHandler);
        }
       });
      }
      const pageTitleEl = document.getElementById("page-title");
      if (pageTitleEl) {
       pageTitleEl.addEventListener("click", () => {
        showEditModal("Edit Title", PAGE_STATE.title || DEFAULT_PAGE_STATE.title,
         (newTitle) => {
          PAGE_STATE.title = newTitle;
          wieldThePower();
         }, );
       });
      }
      
      function editNodeName(id) {
       showEditModal("Edit Name", NODE_DATA[id].name, (newName) => {
        NODE_DATA[id].name = newName;
        const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`, );
        if (nodeGroup) {
         const label = nodeGroup.querySelector(".node-label");
         if (label) label.textContent = newName;
        }
        if (currentNodeId === id) {
         document.getElementById("node-name").textContent = newName;
        }
       });
      }
      
      function editNodeIp(id) {
       showEditModal("Edit IP/Subtitle", NODE_DATA[id].ip, (newIp) => {
        NODE_DATA[id].ip = newIp;
        const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`, );
        if (nodeGroup) {
         const sub = nodeGroup.querySelector(".node-sub");
         if (sub) sub.textContent = newIp;
        }
        if (currentNodeId === id) {
         document.getElementById("node-ip").textContent = newIp;
        }
       });
      }
      
      function claimTheImmortal(id) {
	   if (isViewOnly()) return;
	   if (!NODE_DATA[id]) return;
       currentNodeId = id;
       currentEdgeId = null;
       currentRectId = null;
       currentTextId = null;
       
       if (isMobileDevice()) {
        const currentHeight = PAGE_STATE.mobileFooterHeight || 40;
        if (currentHeight <= 20) {
         PAGE_STATE.mobileFooterHeight = 80;
         const root = document.documentElement;
         root.style.setProperty("--mobile-footer-height", "80vh");
         const mobileFooterHeightInput = document.getElementById("mobile-footer-height");
         const mobileFooterHeightVal = document.getElementById("mobile-footer-height-val");
         if (mobileFooterHeightInput) mobileFooterHeightInput.value = 80;
         if (mobileFooterHeightVal) mobileFooterHeightVal.textContent = "80%";
        }
       }
       
       const data = NODE_DATA[id];
       document.querySelectorAll(".node-group").forEach((n) => {
        n.classList.toggle("active", n.dataset.nodeId === id);
       });
       document.querySelectorAll(".edge").forEach((e) => {
        const active = e.dataset.from === id || e.dataset.to === id;
        e.classList.toggle("active", active);
       });
       document.querySelectorAll(".rect-group").forEach((r) => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach((t) => t.classList.remove("active"));
       document.getElementById("node-panel").style.display = "block";
       document.getElementById("edge-panel").style.display = "none";
       document.getElementById("text-panel").style.display = "none";
       const toolbar = document.getElementById("topology-toolbar");
       if (!topologyToolbarCollapsed) {
        toolbar.style.display = "flex";
       }
       updateTopologyToolbarVisibility();
       document.getElementById("node-name").textContent = data.name;
       document.getElementById("node-ip").textContent = data.ip;
       document.getElementById("node-role").textContent = data.role;
       document.getElementById("node-mac").textContent = data.mac || "--";
       document.getElementById("node-rack").textContent = data.rackUnit || "--";
       document.getElementById("node-uheight").textContent = (data.uHeight || "1") + "U";
       document.getElementById("node-layer").value = data.layer || "physical";
       
       populateRackDropdown();
       const assignedRackSelect = document.getElementById("node-assigned-rack");
       if (assignedRackSelect) {
        assignedRackSelect.value = data.assignedRack || "";
       }
       
       const rackCapacitySelect = document.getElementById("node-rack-capacity");
       if (rackCapacitySelect) {
        rackCapacitySelect.value = data.rackCapacity || "42";
       }
       
       const isRack = data.isRack === true;
       const isAssignedToRack = !!data.assignedRack;
       const assignedRackRow = document.getElementById("assigned-rack-row");
       const rackCapacityRow = document.getElementById("rack-capacity-row");
       const uheightRow = document.getElementById("uheight-row");
       if (assignedRackRow) assignedRackRow.style.display = isRack ? "none" : "flex";
       if (rackCapacityRow) rackCapacityRow.style.display = isRack ? "flex" : "none";
       if (uheightRow) uheightRow.style.display = isAssignedToRack ? "flex" : "none";
       const rackContentsSection = document.getElementById("rack-contents-section");
       const rackContentsList = document.getElementById("rack-contents-list");
       if (rackContentsSection && rackContentsList) {
        if (isRack) {
         const nodesInRack = Object.entries(NODE_DATA).filter(([nid, n]) => n.assignedRack === id);
         if (nodesInRack.length > 0) {
          rackContentsList.innerHTML = nodesInRack.map(([nid, n]) => {
           const tags = (n.tags || []).map(t => `<span style="background: var(--accent); color: var(--bg); padding: 2px 6px; border-radius: 4px; font-size: 11px; margin-left: 4px;">${t}</span>`).join('');
           return `<div style="padding: 6px 0; border-bottom: 1px solid var(--edge-main); cursor: pointer;" onclick="claimTheImmortal('${nid}')">
            <span style="color: var(--text-main);">${n.name}</span>${tags}
           </div>`;
          }).join('');
          rackContentsSection.style.display = "block";
         } else {
          rackContentsList.innerHTML = '<div style="color: var(--text-soft); font-style: italic;">No nodes assigned</div>';
          rackContentsSection.style.display = "block";
         }
        } else {
         rackContentsSection.style.display = "none";
        }
       }
       document.getElementById("node-name").onclick = () => editNodeName(id);
       document.getElementById("node-ip").onclick = () => editNodeIp(id);
       document.getElementById("node-mac").onclick = () => editNodeMac(id);
       document.getElementById("node-rack").onclick = () => editNodeRack(id);
       document.getElementById("node-uheight").onclick = () => editNodeUHeight(id);
       const currentSize = savedSizes[id] || getDefaultSize();
       document.getElementById("size-slider").value = currentSize;
       document.getElementById("size-value").textContent = currentSize;
       const styleEntry = savedStyles[id] || {};
       const resolvedStyles = resolveStylesEntry(styleEntry);
       const scopeKey = currentStyleScope || "all";
       const flatProps = ["circleColor", "circleBorder", "titleColor", "titleFont", "titleSize", "subColor", "subFont", "subSize", ];
       const isFlat = flatProps.some((p) => Object.prototype.hasOwnProperty.call(styleEntry, p), );
       const scopedStyles = isFlat ? styleEntry : styleEntry[scopeKey] || {};
       const circleColorInput = document.getElementById("circle-color");
       const titleColorInput = document.getElementById("title-color");
       const titleFontSelect = document.getElementById("title-font");
       const titleSizeInput = document.getElementById("title-size");
       const subColorInput = document.getElementById("sub-color");
       const subFontSelect = document.getElementById("sub-font");
       const subSizeInput = document.getElementById("sub-size");
       const shapeSelect = document.getElementById("shape-select");
       const scopeSelect = document.getElementById("style-scope");
      circleColorInput.value = scopedStyles.circleColor || resolvedStyles.circleColor || PAGE_STATE.nodeFill || "#1e293b";
       const circleBorderInput = document.getElementById("circle-border");
       circleBorderInput.value = scopedStyles.circleBorder || resolvedStyles.circleBorder || PAGE_STATE.nodeStroke || "#475569";
        titleColorInput.value = scopedStyles.titleColor || resolvedStyles.titleColor || PAGE_STATE.textMain || "#e2e8f0";
        titleFontSelect.value = scopedStyles.titleFont || resolvedStyles.titleFont || "system-ui, sans-serif";
        titleSizeInput.value = scopedStyles.titleSize || resolvedStyles.titleSize || 18;
        subColorInput.value = scopedStyles.subColor || resolvedStyles.subColor || PAGE_STATE.textSoft || "#94a3b8";
       subFontSelect.value = scopedStyles.subFont || resolvedStyles.subFont || "system-ui, sans-serif";
       subSizeInput.value = scopedStyles.subSize || resolvedStyles.subSize || 13;
       shapeSelect.value = data.shape || "circle";
       scopeSelect.value = currentStyleScope || "all";
       document.getElementById("title-offset-y").value = scopedStyles.titleOffsetY || resolvedStyles.titleOffsetY || 0;
       document.getElementById("title-offset-x").value = scopedStyles.titleOffsetX || resolvedStyles.titleOffsetX || 0;
       document.getElementById("sub-offset-y").value = scopedStyles.subOffsetY || resolvedStyles.subOffsetY || 0;
       document.getElementById("sub-offset-x").value = scopedStyles.subOffsetX || resolvedStyles.subOffsetX || 0;
       const tagEl = document.getElementById("node-tags");
       tagEl.innerHTML = "";
       data.tags.forEach((tag, i) => {
        const b = document.createElement("span");
        b.className = "badge";
        if (tag.toLowerCase().includes("wg")) b.classList.add("wg");
        b.style.cursor = "pointer";
        b.style.position = "relative";
        const tagText = document.createElement("span");
        tagText.textContent = tag;
        tagText.addEventListener("click", (e) => {
         e.stopPropagation();
         showEditModal("Edit Tag", tag, (newTag) => {
          if (newTag) {
           data.tags[i] = newTag;
           claimTheImmortal(id);
          }
         });
        });
        const deleteTag = document.createElement("span");
        deleteTag.textContent = " ✕";
        deleteTag.style.opacity = "0.6";
        deleteTag.style.marginLeft = "4px";
        deleteTag.style.fontSize = "10px";
        deleteTag.addEventListener("click", (e) => {
         e.stopPropagation();
         data.tags.splice(i, 1);
         claimTheImmortal(id);
        });
        b.append(tagText, deleteTag);
        tagEl.append(b);
       });
       const addTagBtn = document.createElement("span");
       addTagBtn.className = "badge";
       addTagBtn.style.cursor = "pointer";
       addTagBtn.style.opacity = "0.6";
       addTagBtn.style.borderStyle = "dashed";
       addTagBtn.textContent = "+ Add Tag";
       addTagBtn.addEventListener("click", () => {
        showEditModal("Add Tag(s) : comma separated", "",
         (newTagStr) => {
          if (newTagStr) {
           const newTags = newTagStr.split(",").map((t) => t.trim()).filter((t) => t);
           newTags.forEach((t) => data.tags.push(t));
           claimTheImmortal(id);
          }
         }, );
       });
       tagEl.append(addTagBtn);
       const notesEl = document.getElementById("node-notes");
       notesEl.innerHTML = "";
       data.notes.forEach((note, i) => {
        const li = document.createElement("li");
        const noteText = document.createElement("span");
        noteText.textContent = note;
        noteText.style.flex = "1";
        const deleteBtn = document.createElement("span");
        deleteBtn.className = "delete-note";
        deleteBtn.textContent = "✕";
        deleteBtn.addEventListener("click", (e) => {
         e.stopPropagation();
         challengeTheImmortal("Are you sure you want to delete this note?",
          () => {
           data.notes.splice(i, 1);
           claimTheImmortal(id);
          }, );
        });
        li.append(noteText, deleteBtn);
        noteText.addEventListener("dblclick", () => {
         noteText.classList.add("editing");
         noteText.contentEditable = true;
         noteText.focus();
        });
        noteText.addEventListener("blur", () => {
         noteText.classList.remove("editing");
         noteText.contentEditable = false;
         data.notes[i] = noteText.textContent;
        });
        notesEl.append(li);
       });
      const addLineSelect = document.getElementById("add-line-select");
      addLineSelect.innerHTML = "";
      const currentRack = data.assignedRack || "";
      Object.entries(NODE_DATA).forEach(([nodeId, node]) => {
      if (nodeId !== id) {
      const nodeRack = node.assignedRack || "";
      if (currentRack === nodeRack) {
      const opt = document.createElement("option");
      opt.value = nodeId;
      opt.textContent = node.name;
      addLineSelect.appendChild(opt);
      }
      }
      });
      }
      
      function selectTheConnection(id) {
	   if (isViewOnly()) return;
       currentEdgeId = id;
       currentNodeId = null;
       currentRectId = null;
       currentTextId = null;
       
       if (isMobileDevice()) {
        const currentHeight = PAGE_STATE.mobileFooterHeight || 40;
        if (currentHeight <= 20) {
         PAGE_STATE.mobileFooterHeight = 80;
         const root = document.documentElement;
         root.style.setProperty("--mobile-footer-height", "80vh");
         const mobileFooterHeightInput = document.getElementById("mobile-footer-height");
         const mobileFooterHeightVal = document.getElementById("mobile-footer-height-val");
         if (mobileFooterHeightInput) mobileFooterHeightInput.value = 80;
         if (mobileFooterHeightVal) mobileFooterHeightVal.textContent = "80%";
        }
       }
       
       document.getElementById("node-panel").style.display = "none";
       document.getElementById("edge-panel").style.display = "block";
       document.getElementById("text-panel").style.display = "none";
       document.getElementById("rect-panel").style.display = "none";
       document.getElementById("topology-toolbar").style.display = "none";
       document.querySelectorAll(".node-group").forEach((n) => n.classList.remove("active"));
       document.querySelectorAll(".rect-group").forEach((r) => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach((t) => t.classList.remove("active"));
       document.querySelectorAll(".edge").forEach((e) => {
        e.classList.toggle("active", e.dataset.edgeId === id);
       });
       const edge = EDGE_DATA.list.find((e) => e.id === id);
       if (!edge) return;
       const directionSymbols = {
        none: "⇄",
        forward: "→",
        backward: "←",
        both: "↔",
       };
       const dirSymbol = directionSymbols[edge.direction] || "⇄";
       let titleText = "Custom line";
       if (edge.from || edge.to) {
        const fromName = edge.from ? NODE_DATA[edge.from]?.name || edge.from : "";
        const toName = edge.to ? NODE_DATA[edge.to]?.name || edge.to : "";
        titleText = `${fromName || "?"} ${dirSymbol} ${toName || "?"}`;
       }
       document.getElementById("edge-title").textContent = titleText;
       const widthInput = document.getElementById("edge-width");
       const colorInput = document.getElementById("edge-color");
       const directionSelect = document.getElementById("edge-direction");
       const lineStyleSelect = document.getElementById("edge-line-style");
       widthInput.value = edge.width;
       colorInput.value = edge.color;
       directionSelect.value = edge.direction || "none";
       lineStyleSelect.value = edge.lineStyle || "solid";
       
       const fromPortRow = document.getElementById("edge-from-port-row");
       const toPortRow = document.getElementById("edge-to-port-row");
       const fromPortInput = document.getElementById("edge-from-port");
       const toPortInput = document.getElementById("edge-to-port");
       
       if (edge.type === "custom") {
        fromPortRow.style.display = "none";
        toPortRow.style.display = "none";
       } else {
        fromPortRow.style.display = "flex";
        toPortRow.style.display = "flex";
        fromPortInput.value = edge.fromPort || "";
        toPortInput.value = edge.toPort || "";
        
        fromPortInput.onchange = () => updateEdgePortLabels(id);
        toPortInput.onchange = () => updateEdgePortLabels(id);
       }
       
       const list = document.getElementById("edge-notes");
       list.innerHTML = "";
       edge.notes.forEach((note, i) => {
        const li = document.createElement("li");
        const txt = document.createElement("span");
        txt.textContent = note;
        txt.style.flex = "1";
        const del = document.createElement("span");
        del.className = "delete-note";
        del.textContent = "✕";
        del.addEventListener("click", (e) => {
         e.stopPropagation();
         challengeTheImmortal("Delete this line note?", () => {
          edge.notes.splice(i, 1);
          
          selectTheConnection(id);
         });
        });
        txt.addEventListener("dblclick", () => {
         txt.classList.add("editing");
         txt.contentEditable = true;
         txt.focus();
        });
        txt.addEventListener("blur", () => {
         txt.classList.remove("editing");
         txt.contentEditable = false;
         edge.notes[i] = txt.textContent;
         
        });
        li.append(txt, del);
        list.appendChild(li);
       });
       
       if (edge.type === "custom" && Array.isArray(edge.points)) {
        forgeTheTopology();
       }
      }
      window.addEventListener("resize", () => {
       forgeTheTopology();
       if (currentEdgeId) {
        selectTheConnection(currentEdgeId);
       } else if (currentNodeId && NODE_DATA[currentNodeId]) {
        claimTheImmortal(currentNodeId);
       } else {
        const availableNodes = Object.keys(NODE_DATA);
        if (availableNodes.length > 0) {
         claimTheImmortal(availableNodes[0]);
        }
       }
      });
      (function initZoomPan() {
       const viewport = document.getElementById("canvas-viewport");
       const svg = document.getElementById("map");
       const hint = document.getElementById("canvas-hint");
       setTimeout(() => {
        hint.classList.add("visible");
        setTimeout(() => hint.classList.remove("visible"), 4000);
       }, 1000);
       viewport.addEventListener("wheel",
        (e) => {
         e.preventDefault();
         const rect = viewport.getBoundingClientRect();
         const mouseX = (e.clientX - rect.left) / rect.width;
         const mouseY = (e.clientY - rect.top) / rect.height;
         const delta = e.deltaY > 0 ? 0.9 : 1.1;
         zoomTo(canvasState.zoom * delta, mouseX, mouseY);
        }, {
         passive: false
        }, );
       let initialPinchDistance = 0;
       let initialPinchZoom = 1;
       let pinchCenter = {
        x: 0.5,
        y: 0.5
       };
       viewport.addEventListener("touchstart",
        (e) => {
         if (e.touches.length === 2) {
          e.preventDefault();
          const touch1 = e.touches[0];
          const touch2 = e.touches[1];
          initialPinchDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY, );
          initialPinchZoom = canvasState.zoom;
          const rect = viewport.getBoundingClientRect();
          const centerX = (touch1.clientX + touch2.clientX) / 2;
          const centerY = (touch1.clientY + touch2.clientY) / 2;
          pinchCenter.x = (centerX - rect.left) / rect.width;
          pinchCenter.y = (centerY - rect.top) / rect.height;
         }
        }, {
         passive: false
        }, );
       viewport.addEventListener("touchmove",
        (e) => {
         if (e.touches.length === 2) {
          e.preventDefault();
          const touch1 = e.touches[0];
          const touch2 = e.touches[1];
          const currentDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY, );
          if (initialPinchDistance > 0) {
           const scale = currentDistance / initialPinchDistance;
           const newZoom = initialPinchZoom * scale;
           zoomTo(newZoom, pinchCenter.x, pinchCenter.y);
          }
         }
        }, {
         passive: false
        }, );
       let panStartViewX = 0;
       let panStartViewY = 0;
       
       let lastEmptyTapTime = 0;
       let emptyTapTimeout = null;
       let emptyTapMoved = false;
       let emptyTapStartX = 0;
       let emptyTapStartY = 0;
       
       viewport.addEventListener("touchend", (e) => {
         if (currentView.mode !== "rack") return;
         
         if (e.changedTouches.length !== 1) return;
         
      const isNodeOrEdge = e.target.closest(".node-group") || e.target.closest(".edge-group");
         if (isNodeOrEdge) return;
         
         if (emptyTapMoved) {
           emptyTapMoved = false;
           return;
         }
         
         const currentTime = new Date().getTime();
         const tapGap = currentTime - lastEmptyTapTime;
         
         if (tapGap < 300 && tapGap > 0) {
           e.preventDefault();
           
           exitRack();
           
           if (navigator.vibrate) {
             navigator.vibrate(50);
           }
           
           lastEmptyTapTime = 0;
           if (emptyTapTimeout) {
             clearTimeout(emptyTapTimeout);
             emptyTapTimeout = null;
           }
         } else {
           lastEmptyTapTime = currentTime;
           
           if (emptyTapTimeout) clearTimeout(emptyTapTimeout);
           emptyTapTimeout = setTimeout(() => {
             lastEmptyTapTime = 0;
           }, 300);
         }
       }, { passive: false });
       
       viewport.addEventListener("mousedown", (e) => {
        if (e.target.closest(".draw-toolbar") || e.target.closest(".topology-toolbar") || e.target.closest(".legend-container")) {
         return;
        }
      
        if (freeDrawMode || rectDrawMode) {
         return;
        }
      const isEmptySpace = e.target === svg || e.target === viewport || e.target.tagName === "svg";
      const isEdgeElement = e.target.closest('.edge') || e.target.classList.contains('edge-edit-point');
      const isTextElement = e.target.closest('.text-group') || e.target.closest('.text-element');
      const isRectElement = e.target.closest('.rect-group');
      if (!isEdgeElement && !isTextElement && !isRectElement && currentEdgeId) {
      currentEdgeId = null;
      forgeTheTopology();
      }
      if (!isRectElement && currentRectId) {
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      }
	  if (isViewOnly()) {
         document.body.classList.remove("view-only-inspect");
         document.getElementById("node-panel").style.display = "none";
         document.getElementById("edge-panel").style.display = "none";
        }
        if (isEmptySpace && e.shiftKey && e.button === 0) {
         if (isViewOnly()) return;
         e.preventDefault();
         startSelection(e);
         return;
        }
        if (isEmptySpace || e.button === 2 || e.button === 1) {
         e.preventDefault();
         canvasState.isPanning = true;
         canvasState.panStartX = e.clientX;
         canvasState.panStartY = e.clientY;
         panStartViewX = canvasState.panX;
         panStartViewY = canvasState.panY;
         viewport.classList.add("panning");
        }
       });
       viewport.addEventListener("touchstart",
        (e) => {
         if (e.target.closest(".draw-toolbar") || e.target.closest(".topology-toolbar") || e.target.closest(".legend-container")) {
          return;
         }
      
         if (freeDrawMode || rectDrawMode) {
          return;
         }
      const isEmptySpace = e.target === svg || e.target === viewport || e.target.tagName === "svg";
      const isEdgeElement = e.target.closest('.edge') || e.target.classList.contains('edge-edit-point');
      const isTextElement = e.target.closest('.text-group') || e.target.closest('.text-element');
      const isRectElement = e.target.closest('.rect-group');
      if (!isEdgeElement && !isTextElement && !isRectElement && currentEdgeId) {
      currentEdgeId = null;
      forgeTheTopology();
      }
      if (!isRectElement && currentRectId) {
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      }
          if (isEmptySpace && e.touches.length === 1) {
           e.preventDefault();
           emptyTapMoved = false;
           emptyTapStartX = e.touches[0].clientX;
           emptyTapStartY = e.touches[0].clientY;
           canvasState.isPanning = true;
           canvasState.panStartX = e.touches[0].clientX;
           canvasState.panStartY = e.touches[0].clientY;
           panStartViewX = canvasState.panX;
           panStartViewY = canvasState.panY;
           viewport.classList.add("panning");
         }
        }, {
         passive: false
        }, );
       document.addEventListener("mousemove", (e) => {
        if (isSelecting) {
         updateSelection(e);
         return;
        }
        if (!canvasState.isPanning) return;
        const dx = e.clientX - canvasState.panStartX;
        const dy = e.clientY - canvasState.panStartY;
        const rect = viewport.getBoundingClientRect();
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        const canvasDx = (dx / rect.width) * viewWidth;
        const canvasDy = (dy / rect.height) * viewHeight;
        canvasState.panX = panStartViewX - canvasDx;
        canvasState.panY = panStartViewY - canvasDy;
        constrainPan();
        updateViewBox();
       });
       document.addEventListener("touchmove", (e) => {
        if (!canvasState.isPanning || !e.touches[0]) return;
        const moveDx = Math.abs(e.touches[0].clientX - emptyTapStartX);
        const moveDy = Math.abs(e.touches[0].clientY - emptyTapStartY);
        if (moveDx > 15 || moveDy > 15) {
         emptyTapMoved = true;
        }
        const dx = e.touches[0].clientX - canvasState.panStartX;
        const dy = e.touches[0].clientY - canvasState.panStartY;
        const rect = viewport.getBoundingClientRect();
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        const canvasDx = (dx / rect.width) * viewWidth;
        const canvasDy = (dy / rect.height) * viewHeight;
        canvasState.panX = panStartViewX - canvasDx;
        canvasState.panY = panStartViewY - canvasDy;
        constrainPan();
        updateViewBox();
       });
       document.addEventListener("mouseup", () => {
        if (isSelecting) {
         endSelection();
        }
        if (canvasState.isPanning) {
         canvasState.isPanning = false;
         viewport.classList.remove("panning");
        }
       });
       document.addEventListener("touchend", () => {
        if (canvasState.isPanning) {
         canvasState.isPanning = false;
         viewport.classList.remove("panning");
        }
       });
       document.addEventListener("keydown", (e) => {
        const isEditing = document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "TEXTAREA" || document.activeElement.isContentEditable;
        if (e.code === "Space" && !e.repeat && !isEditing) {
         e.preventDefault();
         canvasState.spacePressed = true;
         viewport.style.cursor = "grab";
        }
       });
       document.addEventListener("keyup", (e) => {
        if (e.code === "Space") {
         canvasState.spacePressed = false;
         viewport.style.cursor = "";
        }
       });
       document.getElementById("zoom-in-btn").addEventListener("click", () => {
        zoomTo(canvasState.zoom * 1.25, 0.5, 0.5);
       });
       document.getElementById("zoom-out-btn").addEventListener("click", () => {
        zoomTo(canvasState.zoom * 0.8, 0.5, 0.5);
       });
       document.getElementById("zoom-fit-btn").addEventListener("click", fitToContent);
       document.getElementById("zoom-reset-btn").addEventListener("click", resetView);
       const minimapContainer = document.getElementById("minimap-container");
       const minimapSvg = document.getElementById("minimap");
       let minimapDragging = false;
       minimapContainer.addEventListener("mousedown", (e) => {
        e.preventDefault();
        minimapDragging = true;
        updatePanFromMinimap(e);
       });
       minimapContainer.addEventListener("touchstart",
        (e) => {
         e.preventDefault();
         minimapDragging = true;
         updatePanFromMinimapTouch(e);
        }, {
         passive: false
        }, );
       document.addEventListener("mousemove", (e) => {
        if (minimapDragging) {
         updatePanFromMinimap(e);
        }
       });
       document.addEventListener("touchmove", (e) => {
        if (minimapDragging && e.touches[0]) {
         updatePanFromMinimapTouch(e);
        }
       });
       document.addEventListener("mouseup", () => {
        minimapDragging = false;
       });
       document.addEventListener("touchend", () => {
        minimapDragging = false;
       });
      
       function updatePanFromMinimap(e) {
        const rect = minimapContainer.getBoundingClientRect();
        const x = (e.clientX - rect.left) / rect.width;
        const y = (e.clientY - rect.top) / rect.height;
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        canvasState.panX = x * CANVAS_WIDTH - viewWidth / 2;
        canvasState.panY = y * CANVAS_HEIGHT - viewHeight / 2;
        constrainPan();
        updateViewBox();
       }
      
       function updatePanFromMinimapTouch(e) {
        const rect = minimapContainer.getBoundingClientRect();
        const touch = e.touches[0];
        const x = (touch.clientX - rect.left) / rect.width;
        const y = (touch.clientY - rect.top) / rect.height;
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        canvasState.panX = x * CANVAS_WIDTH - viewWidth / 2;
        canvasState.panY = y * CANVAS_HEIGHT - viewHeight / 2;
        constrainPan();
        updateViewBox();
       }
       document.addEventListener("keydown", (e) => {
        if (document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "TEXTAREA") return;
        if (
         (e.key === "+" || e.key === "=") && (e.ctrlKey || e.metaKey)) {
         e.preventDefault();
         zoomTo(canvasState.zoom * 1.25, 0.5, 0.5);
        } else if (e.key === "-" && (e.ctrlKey || e.metaKey)) {
         e.preventDefault();
         zoomTo(canvasState.zoom * 0.8, 0.5, 0.5);
        } else if (e.key === "0" && (e.ctrlKey || e.metaKey)) {
         e.preventDefault();
         resetView();
        }
       });
       setTimeout(() => {
        fitToContent();
       }, 100);
      })();
      const sizeSlider = document.getElementById("size-slider");
      const sizeValue = document.getElementById("size-value");
      const resetSizeBtn = document.getElementById("reset-size");
      sizeSlider.addEventListener("input", () => {
       const newSize = parseInt(sizeSlider.value, 10);
       sizeValue.textContent = newSize;
       savedSizes[currentNodeId] = newSize;
       const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
       if (nodeGroup) {
        const oldShape = nodeGroup.querySelector(".node-circle");
        if (oldShape) oldShape.remove();
        const shapeType = (NODE_DATA[currentNodeId] && NODE_DATA[currentNodeId].shape) || "circle";
        const newShape = createShapeElement(shapeType, newSize);
        newShape.classList.add("node-circle");
        const styles = resolveStylesForNode(currentNodeId);
        if (styles.circleColor) newShape.style.fill = styles.circleColor;
        if (styles.circleBorder) newShape.style.stroke = styles.circleBorder;
        nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
        const label = nodeGroup.querySelector(".node-label");
        const sub = nodeGroup.querySelector(".node-sub");
        if (label) {
         label.setAttribute("y", -newSize * 0.28);
         const labelSize = styles.titleSize || newSize * 0.33;
         label.style.fontSize = labelSize + "px";
        }
        if (sub) {
         sub.setAttribute("y", newSize * 0.4);
         const subSize = styles.subSize || newSize * 0.24;
         sub.style.fontSize = subSize + "px";
        }
       }
      });
      resetSizeBtn.addEventListener("click", () => {
       delete savedSizes[currentNodeId];
       const defaultSize = getDefaultSize();
       sizeSlider.value = defaultSize;
       sizeValue.textContent = defaultSize;
       const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
       if (nodeGroup) {
        const oldShape = nodeGroup.querySelector(".node-circle");
        if (oldShape) oldShape.remove();
        const shapeType = (NODE_DATA[currentNodeId] && NODE_DATA[currentNodeId].shape) || "circle";
        const newShape = createNodeShape(currentNodeId, defaultSize);
        nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
        const styles = resolveStylesForNode(currentNodeId);
        if (styles.circleColor) newShape.style.fill = styles.circleColor;
        if (styles.circleBorder) newShape.style.stroke = styles.circleBorder;
        const label = nodeGroup.querySelector(".node-label");
        const sub = nodeGroup.querySelector(".node-sub");
        if (label) {
         label.setAttribute("y", -defaultSize * 0.28);
         const labelSize = styles.titleSize || defaultSize * 0.33;
         label.style.fontSize = labelSize + "px";
        }
        if (sub) {
         sub.setAttribute("y", defaultSize * 0.4);
         const subSize = styles.subSize || defaultSize * 0.24;
         sub.style.fontSize = subSize + "px";
        }
       }
      });
      const applyStyle = (property, value) => {
       const styleEntry = ensureStyleEntry(currentNodeId);
       const scopeKey = currentStyleScope || "all";
       if (!styleEntry[scopeKey]) styleEntry[scopeKey] = {};
       styleEntry[scopeKey][property] = value;
       const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
       if (!nodeGroup) return;
       const shapeEl = nodeGroup.querySelector(".node-circle");
       const label = nodeGroup.querySelector(".node-label");
       const sub = nodeGroup.querySelector(".node-sub");
       if (property === "circleColor" && shapeEl) shapeEl.style.fill = value;
      else if (property === "circleBorder" && shapeEl) shapeEl.style.stroke = value;
       else if (property === "titleColor" && label) label.style.fill = value;
       else if (property === "titleFont" && label) label.style.fontFamily = value;
       else if (property === "titleSize" && label) label.style.fontSize = value + "px";
       else if (property === "subColor" && sub) sub.style.fill = value;
       else if (property === "subFont" && sub) sub.style.fontFamily = value;
       else if (property === "subSize" && sub) sub.style.fontSize = value + "px";
      };
      document.getElementById("circle-color").addEventListener("input", (e) => applyStyle("circleColor", e.target.value), );
      document.getElementById("circle-border").addEventListener("input", (e) => applyStyle("circleBorder", e.target.value), );
      document.getElementById("title-color").addEventListener("input", (e) => applyStyle("titleColor", e.target.value), );
      document.getElementById("title-font").addEventListener("change", (e) => applyStyle("titleFont", e.target.value), );
      document.getElementById("title-size").addEventListener("input", (e) => applyStyle("titleSize", parseInt(e.target.value, 10)), );
      document.getElementById("sub-color").addEventListener("input", (e) => applyStyle("subColor", e.target.value), );
      document.getElementById("sub-font").addEventListener("change", (e) => applyStyle("subFont", e.target.value), );
      document.getElementById("sub-size").addEventListener("input", (e) => applyStyle("subSize", parseInt(e.target.value, 10)), );
      document.getElementById("title-offset-y").addEventListener("input", (e) => {
       applyStyle("titleOffsetY", parseInt(e.target.value, 10) || 0);
       forgeTheTopology();
       if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      document.getElementById("title-offset-x").addEventListener("input", (e) => {
       applyStyle("titleOffsetX", parseInt(e.target.value, 10) || 0);
       forgeTheTopology();
       if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      document.getElementById("sub-offset-y").addEventListener("input", (e) => {
       applyStyle("subOffsetY", parseInt(e.target.value, 10) || 0);
       forgeTheTopology();
       if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      document.getElementById("sub-offset-x").addEventListener("input", (e) => {
       applyStyle("subOffsetX", parseInt(e.target.value, 10) || 0);
       forgeTheTopology();
       if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      document.getElementById("reset-styles").addEventListener("click", () => {
       delete savedStyles[currentNodeId];
       forgeTheTopology();
       claimTheImmortal(currentNodeId);
      });
      document.getElementById("style-scope").addEventListener("change", (e) => {
       currentStyleScope = e.target.value || "all";
       claimTheImmortal(currentNodeId);
      });
      document.getElementById("shape-select").addEventListener("change", (e) => {
       const shape = e.target.value || "circle";
       NODE_DATA[currentNodeId].shape = shape;
       const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
       if (!nodeGroup) return;
       const oldShape = nodeGroup.querySelector(".node-circle");
       if (oldShape) oldShape.remove();
       const size = savedSizes[currentNodeId] || getDefaultSize();
       const newShape = createNodeShape(currentNodeId, size);
       nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
      });
      const addNoteBtn = document.getElementById("add-note-btn");
      const noteInput = document.getElementById("new-note-input");
      addNoteBtn.addEventListener("click", () => {
       const newNote = noteInput.value.trim();
       if (newNote && currentNodeId) {
        NODE_DATA[currentNodeId].notes.push(newNote);
        claimTheImmortal(currentNodeId);
        noteInput.value = "";
       }
      });
      noteInput.addEventListener("keypress", (e) => {
       if (e.key === "Enter") {
        addNoteBtn.click();
       }
      });
      document.getElementById("edge-width").addEventListener("input", () => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       const v = parseInt(document.getElementById("edge-width").value, 10);
       if (Number.isNaN(v) || v <= 0) return;
       edge.width = v;
       
       const el = document.querySelector(`.edge[data-edge-id="${currentEdgeId}"]`, );
       if (el) el.style.strokeWidth = v;
      });
      document.getElementById("edge-color").addEventListener("input", () => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       const color = document.getElementById("edge-color").value;
       edge.color = color;
       
       const el = document.querySelector(`.edge[data-edge-id="${currentEdgeId}"]`, );
       if (el) el.style.stroke = color;
       forgeTheLegend();
      });
      document.getElementById("edge-direction").addEventListener("change", () => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       edge.direction = document.getElementById("edge-direction").value;
       
       forgeTheTopology();
       selectTheConnection(currentEdgeId);
      });
      document.getElementById("edge-line-style").addEventListener("change", () => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       edge.lineStyle = document.getElementById("edge-line-style").value;
       
       forgeTheTopology();
       selectTheConnection(currentEdgeId);
      });
      const addEdgeNoteBtn = document.getElementById("add-edge-note");
      const newEdgeNoteInput = document.getElementById("new-edge-note");
      addEdgeNoteBtn.addEventListener("click", () => {
       const txt = newEdgeNoteInput.value.trim();
       if (!txt || !currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       edge.notes.push(txt);
       
       newEdgeNoteInput.value = "";
       selectTheConnection(currentEdgeId);
      });
      newEdgeNoteInput.addEventListener("keypress", (e) => {
       if (e.key === "Enter") {
        addEdgeNoteBtn.click();
       }
      });
	  
      function selectTheRect(id) {
	  if (isViewOnly()) return;
      currentRectId = id;
      currentNodeId = null;
      currentEdgeId = null;
      currentTextId = null;
      document.getElementById("node-panel").style.display = "none";
      document.getElementById("edge-panel").style.display = "none";
      document.getElementById("text-panel").style.display = "none";
      document.getElementById("rect-panel").style.display = "block";
      document.getElementById("topology-toolbar").style.display = "none";
      document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active"));
      document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
      document.querySelectorAll(".text-element").forEach(t => t.classList.remove("active"));
      document.querySelectorAll(".rect-group").forEach(r => r.classList.toggle("active", r.dataset.rectId === id));
      
      const rect = RECT_DATA.list.find(r => r.id === id);
      if (!rect) return;
      
      document.getElementById("rect-title").textContent = "";
      document.getElementById("rect-color").value = rect.color || "#f97316";
      document.getElementById("rect-border-color").value = rect.borderColor || rect.color || "#f97316";
      document.getElementById("rect-border-width").value = rect.borderWidth !== undefined ? rect.borderWidth : 2;
      document.getElementById("rect-style-select").value = rect.style || "filled";
      document.getElementById("rect-line-style").value = rect.lineStyle || "solid";
      document.getElementById("rect-fill-row").style.display = (rect.style === "outlined") ? "none" : "flex";
      
      const list = document.getElementById("rect-notes");
      list.innerHTML = "";
      (rect.notes || []).forEach((note, i) => {
      const li = document.createElement("li");
      const txt = document.createElement("span");
      txt.textContent = note;
      txt.style.flex = "1";
      const del = document.createElement("span");
      del.className = "delete-note";
      del.textContent = "✕";
      del.addEventListener("click", (e) => {
      e.stopPropagation();
      challengeTheImmortal("Delete this note?", () => {
        rect.notes.splice(i, 1);
        selectTheRect(id);
      });
      });
      li.appendChild(txt);
      li.appendChild(del);
      list.appendChild(li);
      });
      
      forgeTheTopology();
      }
      
      document.getElementById("rect-color").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      rect.color = document.getElementById("rect-color").value;
      forgeTheTopology();
      });
      
      document.getElementById("rect-border-color").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      rect.borderColor = document.getElementById("rect-border-color").value;
      forgeTheTopology();
      });
      
      document.getElementById("rect-border-width").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      rect.borderWidth = parseInt(document.getElementById("rect-border-width").value) || 2;
      forgeTheTopology();
      });
      
      document.getElementById("rect-style-select").addEventListener("change", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      rect.style = document.getElementById("rect-style-select").value;
      forgeTheTopology();
      selectTheRect(currentRectId);
      });
      
      document.getElementById("rect-line-style").addEventListener("change", () => {
      if (!currentRectId) return;
      pushUndo("change zone line style");
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      rect.lineStyle = document.getElementById("rect-line-style").value;
      forgeTheTopology();
      });
      
      document.getElementById("add-rect-note").addEventListener("click", () => {
      const input = document.getElementById("new-rect-note");
      const txt = input.value.trim();
      if (!txt || !currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      if (!rect.notes) rect.notes = [];
      rect.notes.push(txt);
      input.value = "";
      selectTheRect(currentRectId);
      });
      
      document.getElementById("new-rect-note").addEventListener("keypress", (e) => {
      if (e.key === "Enter") {
      document.getElementById("add-rect-note").click();
      }
      });
      
      document.getElementById("delete-rect").addEventListener("click", () => {
      if (!currentRectId) return;
      challengeTheImmortal("Delete this zone?", () => {
      RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== currentRectId);
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      });
      });
      document.getElementById("delete-edge").addEventListener("click", () => {
       if (!currentEdgeId) return;
       challengeTheImmortal("Are you sure you want to delete this line?",
        () => {
         EDGE_DATA.list = EDGE_DATA.list.filter(
          (e) => e.id !== currentEdgeId, );
         
         currentEdgeId = null;
         forgeTheTopology();
         const availableNodes = Object.keys(NODE_DATA);
         if (availableNodes.length > 0) {
          claimTheImmortal(availableNodes[0]);
         } else {
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("topology-toolbar", ).style.display = "none";
         }
        }, );
      });
      document.getElementById("add-line-btn").addEventListener("click", () => {
       if (!currentNodeId) return;
       const select = document.getElementById("add-line-select");
       const directionSelect = document.getElementById("add-line-direction");
       const colorInput = document.getElementById("add-line-color");
       const targetId = select.value;
       if (!targetId || targetId === currentNodeId) return;
       const direction = directionSelect.value || "none";
       const lineColor = colorInput.value || "#475569";
       const newId = `${currentNodeId}-${targetId}-${Date.now()}`;
       const newEdge = {
        id: newId,
        from: currentNodeId,
        to: targetId,
        width: 4,
        color: lineColor,
        direction: direction,
        type: "main",
        notes: [],
        fromPort: "",
        toPort: "",
        lineStyle: "solid",
       };
       EDGE_DATA.list.push(newEdge);
       
       forgeTheTopology();
       claimTheImmortal(currentNodeId);
      });
      let freeDrawPoints = [];
      let freeDrawPolylineEl = null;
      let freeDrawPointEls = [];
    
       let rectStartPoint = null;
       let rectPreviewEl = null;
       let rectStyle = "filled";
      const drawToggleBtn = document.getElementById("draw-toggle");
      const drawUndoBtn = document.getElementById("draw-undo");
      const drawColorInput = document.getElementById("draw-color");
      const drawStyleSelect = document.getElementById("draw-style");
      const drawArrowSelect = document.getElementById("draw-arrow");
      const svgMap = document.getElementById("map");
      
      function updateFreeDrawGraphics() {
       const ns = "http://www.w3.org/2000/svg";
       const svg = svgMap;
       if (!freeDrawPolylineEl && freeDrawPoints.length > 0) {
        freeDrawPolylineEl = document.createElementNS(ns, "polyline");
        freeDrawPolylineEl.classList.add("edge", "free-preview");
        freeDrawPolylineEl.setAttribute("fill", "none");
        svg.appendChild(freeDrawPolylineEl);
       }
       if (freeDrawPolylineEl) {
        if (freeDrawPoints.length === 0) {
         freeDrawPolylineEl.remove();
         freeDrawPolylineEl = null;
        } else {
         const ptsStr = freeDrawPoints.map((p) => `${p.x},${p.y}`).join(" ");
         freeDrawPolylineEl.setAttribute("points", ptsStr);
         freeDrawPolylineEl.style.stroke = drawColorInput.value || "#475569";
         freeDrawPolylineEl.style.strokeWidth = 3;
         const lineStyle = drawStyleSelect.value || "solid";
         if (lineStyle === "dashed") {
          freeDrawPolylineEl.style.strokeDasharray = "10,5";
         } else if (lineStyle === "dotted") {
          freeDrawPolylineEl.style.strokeDasharray = "2,4";
         } else {
          freeDrawPolylineEl.style.strokeDasharray = "none";
         }
        }
       }
       freeDrawPointEls.forEach((el) => el.remove());
       freeDrawPointEls = [];
       freeDrawPoints.forEach((p, idx) => {
        const c = document.createElementNS(ns, "circle");
        c.classList.add("free-point");
        c.setAttribute("cx", p.x);
        c.setAttribute("cy", p.y);
        c.setAttribute("r", 5);
        c.dataset.index = String(idx);
        c.addEventListener("mousedown", (e) => {
         if (!freeDrawMode) return;
         e.preventDefault();
         e.stopPropagation();
         let dragging = true;
         const svgEl = svgMap;
         const moveHandler = (ev) => {
          if (!dragging) return;
          const pt = svgEl.createSVGPoint();
          pt.x = ev.clientX;
          pt.y = ev.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          const i = parseInt(c.dataset.index, 10);
          if (Number.isNaN(i) || !freeDrawPoints[i]) return;
          freeDrawPoints[i].x = svgP.x;
          freeDrawPoints[i].y = svgP.y;
          updateFreeDrawGraphics();
         };
         const upHandler = () => {
          dragging = false;
          document.removeEventListener("mousemove", moveHandler);
          document.removeEventListener("mouseup", upHandler);
         };
         document.addEventListener("mousemove", moveHandler);
         document.addEventListener("mouseup", upHandler);
        });
        c.addEventListener("touchstart",
         (e) => {
          if (!freeDrawMode) return;
          e.preventDefault();
          e.stopPropagation();
          let dragging = true;
          const svgEl = svgMap;
          const touchMoveHandler = (ev) => {
           if (!dragging || !ev.touches[0]) return;
           const pt = svgEl.createSVGPoint();
           pt.x = ev.touches[0].clientX;
           pt.y = ev.touches[0].clientY;
           const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
           const i = parseInt(c.dataset.index, 10);
           if (Number.isNaN(i) || !freeDrawPoints[i]) return;
           freeDrawPoints[i].x = svgP.x;
           freeDrawPoints[i].y = svgP.y;
           updateFreeDrawGraphics();
          };
          const touchUpHandler = () => {
           dragging = false;
           document.removeEventListener("touchmove", touchMoveHandler, );
           document.removeEventListener("touchend", touchUpHandler, );
          };
          document.addEventListener("touchmove", touchMoveHandler);
          document.addEventListener("touchend", touchUpHandler);
         }, {
          passive: false
         }, );
        svg.appendChild(c);
        freeDrawPointEls.push(c);
       });
       drawUndoBtn.style.display = freeDrawPoints.length ? "inline-block" : "none";
      }
      
      function addFreeDrawPoint(x, y) {
       freeDrawPoints.push({
        x,
        y
       });
       updateFreeDrawGraphics();
      }
      
      function startFreeDraw() {
       freeDrawMode = true;
       freeDrawPoints = [];
       if (freeDrawPolylineEl) {
        freeDrawPolylineEl.remove();
        freeDrawPolylineEl = null;
       }
       freeDrawPointEls.forEach((el) => el.remove());
       freeDrawPointEls = [];
       svgMap.style.cursor = "crosshair";
       drawToggleBtn.textContent = "Done";
       drawUndoBtn.style.display = "none";
      }
      
      function finishFreeDraw() {
       freeDrawMode = false;
       svgMap.style.cursor = "";
       drawToggleBtn.textContent = "✏️";
       if (freeDrawPoints.length >= 2) {
        const color = drawColorInput.value || "#475569";
        const lineStyle = drawStyleSelect.value || "solid";
        const arrowDir = drawArrowSelect.value || "none";
        const newId = "custom-" + Date.now();
        const pointsCopy = freeDrawPoints.map((p) => ({
         x: p.x,
         y: p.y,
        }));
        EDGE_DATA.list.push({
         id: newId,
         type: "custom",
         color,
         width: 4,
         lineStyle: lineStyle,
         direction: arrowDir,
         points: pointsCopy,
         notes: [],
        });
        
        freeDrawPoints = [];
        if (freeDrawPolylineEl) {
         freeDrawPolylineEl.remove();
         freeDrawPolylineEl = null;
        }
        freeDrawPointEls.forEach((el) => el.remove());
        freeDrawPointEls = [];
        forgeTheTopology();
        selectTheConnection(newId);
       } else {
        freeDrawPoints = [];
        if (freeDrawPolylineEl) {
         freeDrawPolylineEl.remove();
         freeDrawPolylineEl = null;
        }
        freeDrawPointEls.forEach((el) => el.remove());
        freeDrawPointEls = [];
        forgeTheLegend();
       }
       drawUndoBtn.style.display = "none";
      }
      drawToggleBtn.addEventListener("click", () => {
       if (currentView.mode === "rack") {
        alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
        return;
       }
       
       if (freeDrawMode) {
        finishFreeDraw();
       } else {
        startFreeDraw();
       }
      });
      drawUndoBtn.addEventListener("click", () => {
       if (!freeDrawMode || !freeDrawPoints.length) return;
       freeDrawPoints.pop();
       updateFreeDrawGraphics();
      });
      const drawToolbar = document.getElementById("draw-toolbar");
      drawToolbar.addEventListener("mousedown", (e) => {
       e.stopPropagation();
      });
      drawToolbar.addEventListener("click", (e) => {
       if (e.target !== drawToggleBtn && e.target !== drawUndoBtn) {
        e.stopPropagation();
       }
      });
      drawStyleSelect.addEventListener("change", () => {
       if (freeDrawMode) {
        updateFreeDrawGraphics();
       }
      });
      drawArrowSelect.addEventListener("change", () => {
       if (freeDrawMode) {
        updateFreeDrawGraphics();
       }
      });
      drawColorInput.addEventListener("input", () => {
       if (freeDrawMode) {
        updateFreeDrawGraphics();
       }
      });
      drawStyleSelect.addEventListener("mousedown", (e) => {
       e.stopPropagation();
      });
      drawStyleSelect.addEventListener("click", (e) => {
       e.stopPropagation();
      });
      drawArrowSelect.addEventListener("mousedown", (e) => {
       e.stopPropagation();
      });
      drawArrowSelect.addEventListener("click", (e) => {
       e.stopPropagation();
      });
      drawColorInput.addEventListener("mousedown", (e) => {
       e.stopPropagation();
      });
      drawColorInput.addEventListener("click", (e) => {
       e.stopPropagation();
      });
      
      svgMap.addEventListener("click", (e) => {
       if (!freeDrawMode) return;
       if (e.button !== 0) return;
       const target = e.target;
       if (target && target.classList && target.classList.contains("free-point")) return;
       const svgEl = svgMap;
       const pt = svgEl.createSVGPoint();
       pt.x = e.clientX;
       pt.y = e.clientY;
       const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
       addFreeDrawPoint(svgP.x, svgP.y);
      });
      svgMap.addEventListener("touchend",
       (e) => {
        if (!freeDrawMode) return;
        const target = e.target;
        if (target && target.classList && target.classList.contains("free-point")) return;
        if (e.changedTouches && e.changedTouches[0]) {
         e.preventDefault();
         const svgEl = svgMap;
         const pt = svgEl.createSVGPoint();
         pt.x = e.changedTouches[0].clientX;
         pt.y = e.changedTouches[0].clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
         addFreeDrawPoint(svgP.x, svgP.y);
        }
       }, {
        passive: false
       }, );
      
       const rectToggleBtn = document.getElementById("rect-toggle");
       const rectStyleSelect = document.getElementById("rect-style");
      
       function startRectDraw() {
        rectDrawMode = true;
        rectStartPoint = null;
        rectPreviewEl = null;
        svgMap.style.cursor = "crosshair";
        rectToggleBtn.textContent = "Done";
        rectStyle = rectStyleSelect.value || "filled";
        
        if (freeDrawMode) {
         finishFreeDraw();
        }
        updateRectangleDeleteButtons();
       }
      
       function finishRectDraw() {
        rectDrawMode = false;
        svgMap.style.cursor = "";
        rectToggleBtn.textContent = "▭";
        
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
        updateRectangleDeleteButtons();
       }
      
       rectToggleBtn.addEventListener("click", () => {
        if (currentView.mode === "rack") {
         alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
         return;
        }
        
        if (rectDrawMode) {
         finishRectDraw();
        } else {
         startRectDraw();
        }
       });
      
       rectStyleSelect.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       rectStyleSelect.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       rectStyleSelect.addEventListener("change", () => {
        if (rectDrawMode) {
         rectStyle = rectStyleSelect.value || "filled";
        }
       });
      
       svgMap.addEventListener("mousedown", (e) => {
        if (!rectDrawMode) return;
        if (e.button !== 0) return;
        e.preventDefault();
        e.stopPropagation();
        
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        rectStartPoint = { x: svgP.x, y: svgP.y };
        
        const ns = "http://www.w3.org/2000/svg";
        rectPreviewEl = document.createElementNS(ns, "rect");
        rectPreviewEl.classList.add("rect-preview");
        rectPreviewEl.setAttribute("x", svgP.x);
        rectPreviewEl.setAttribute("y", svgP.y);
        rectPreviewEl.setAttribute("width", 0);
        rectPreviewEl.setAttribute("height", 0);
        
        const color = drawColorInput.value || "#f97316";
        rectPreviewEl.style.stroke = color;
        rectPreviewEl.style.strokeWidth = 2;
        rectPreviewEl.style.strokeDasharray = "5,5";
        
        if (rectStyle === "filled") {
         rectPreviewEl.style.fill = color;
         rectPreviewEl.style.fillOpacity = "0.3";
        } else {
         rectPreviewEl.style.fill = "none";
        }
        
        svgEl.appendChild(rectPreviewEl);
       });
      
       svgMap.addEventListener("mousemove", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        
        rectPreviewEl.setAttribute("x", x);
        rectPreviewEl.setAttribute("y", y);
        rectPreviewEl.setAttribute("width", width);
        rectPreviewEl.setAttribute("height", height);
       });
      
       svgMap.addEventListener("mouseup", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        
        if (width > 10 && height > 10) {
      pushUndo("draw zone");
         const color = drawColorInput.value || "#f97316";
         const newId = "rect-" + Date.now();
         
          const lineStyle = document.getElementById("draw-style").value || "solid";
         RECT_DATA.list.push({
          id: newId,
          x: x,
          y: y,
          width: width,
          height: height,
          color: color,
          style: rectStyle,
          lineStyle: lineStyle,
          notes: []
         });
         
         forgeTheTopology();
        }
        
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
       });
      
       let rectTouchStart = null;
       
       svgMap.addEventListener("touchstart", (e) => {
        if (!rectDrawMode) return;
        if (e.touches.length !== 1) return;
        
        e.preventDefault();
        const touch = e.touches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        rectStartPoint = { x: svgP.x, y: svgP.y };
        rectTouchStart = { x: svgP.x, y: svgP.y };
        
        const ns = "http://www.w3.org/2000/svg";
        rectPreviewEl = document.createElementNS(ns, "rect");
        rectPreviewEl.classList.add("rect-preview");
        rectPreviewEl.setAttribute("x", svgP.x);
        rectPreviewEl.setAttribute("y", svgP.y);
        rectPreviewEl.setAttribute("width", 0);
        rectPreviewEl.setAttribute("height", 0);
        
        const color = drawColorInput.value || "#f97316";
        rectPreviewEl.style.stroke = color;
        rectPreviewEl.style.strokeWidth = 2;
        rectPreviewEl.style.strokeDasharray = "5,5";
        
        if (rectStyle === "filled") {
         rectPreviewEl.style.fill = color;
         rectPreviewEl.style.fillOpacity = "0.3";
        } else {
         rectPreviewEl.style.fill = "none";
        }
        
        svgEl.appendChild(rectPreviewEl);
       }, { passive: false });
      
       svgMap.addEventListener("touchmove", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        if (e.touches.length !== 1) return;
        
        e.preventDefault();
        const touch = e.touches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        
        rectPreviewEl.setAttribute("x", x);
        rectPreviewEl.setAttribute("y", y);
        rectPreviewEl.setAttribute("width", width);
        rectPreviewEl.setAttribute("height", height);
       }, { passive: false });
      
       svgMap.addEventListener("touchend", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        if (!rectTouchStart) return;
        
        e.preventDefault();
        const touch = e.changedTouches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        
        if (width > 10 && height > 10) {
      pushUndo("draw zone");
         const color = drawColorInput.value || "#f97316";
         const newId = "rect-" + Date.now();
         
        const lineStyle = document.getElementById("draw-style").value || "solid";
         RECT_DATA.list.push({
          id: newId,
          x: x,
          y: y,
          width: width,
          height: height,
          color: color,
          style: rectStyle,
          lineStyle: lineStyle,
          notes: []
         });
         
         forgeTheTopology();
        }
        
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
        rectTouchStart = null;
       }, { passive: false });
      
      const textToggleBtn = document.getElementById("text-toggle");
      
      function startTextMode() {
       textDrawMode = true;
       svgMap.style.cursor = "crosshair";
       textToggleBtn.textContent = "Done";
       textToggleBtn.style.background = "var(--accent)";
       textToggleBtn.style.color = "var(--bg)";
       
       if (freeDrawMode) {
        finishFreeDraw();
       }
       if (rectDrawMode) {
        finishRectDraw();
       }
       
       updateTextDeleteButtons();
      }
      
      function finishTextMode() {
       textDrawMode = false;
       svgMap.style.cursor = "";
       textToggleBtn.textContent = "T";
       textToggleBtn.style.background = "";
       textToggleBtn.style.color = "";
       updateTextDeleteButtons();
      }
      
      textToggleBtn.addEventListener("click", () => {
       if (currentView.mode === "rack") {
        alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
        return;
       }
       
       if (textDrawMode) {
        finishTextMode();
       } else {
        startTextMode();
       }
      });
      
      function handleTextPlacement(e) {
       if (!textDrawMode) return;
       
       const svgEl = svgMap;
       const pt = svgEl.createSVGPoint();
       pt.x = e.clientX;
       pt.y = e.clientY;
       const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
       
       const newId = "text-" + Date.now();
      pushUndo("add text");
       TEXT_DATA.list.push({
        id: newId,
        x: svgP.x,
        y: svgP.y,
        content: "New Text",
        fontSize: 18,
        color: "#e2e8f0",
        fontWeight: "normal",
        fontStyle: "normal",
        textAlign: "start",
        textDecoration: "none",
        bgColor: "#000000",
        bgEnabled: false,
        opacity: 1
       });
       
       forgeTheTopology();
       
       showTextPanel(newId);
      }
      
      svgMap.addEventListener("click", (e) => {
       if (!textDrawMode) return;
       if (e.target.closest('.text-delete-btn')) return;
       if (e.target.closest('.text-group')) return;
       
       e.preventDefault();
       e.stopPropagation();
       handleTextPlacement(e);
      });
      
      svgMap.addEventListener("touchend", (e) => {
       if (!textDrawMode) return;
       if (e.target.closest('.text-delete-btn')) return;
       if (e.target.closest('.text-group')) return;
       if (e.touches.length > 0) return;
       
       e.preventDefault();
       const touch = e.changedTouches[0];
       const fakeEvent = {
        clientX: touch.clientX,
        clientY: touch.clientY,
        preventDefault: () => {},
        stopPropagation: () => {}
       };
       handleTextPlacement(fakeEvent);
      }, { passive: false });
      
      function showTextPanel(textId) {
	  if (isViewOnly()) return;
       currentTextId = textId;
       currentNodeId = null;
       currentEdgeId = null;
       currentRectId = null;
       const textItem = TEXT_DATA.list.find(t => t.id === textId);
       if (!textItem) return;
       
       document.getElementById("node-panel").style.display = "none";
       document.getElementById("edge-panel").style.display = "none";
       document.getElementById("rect-panel").style.display = "none";
       
       const textPanel = document.getElementById("text-panel");
       textPanel.style.display = "block";
       document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active"));
       document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
       document.querySelectorAll(".rect-group").forEach(r => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach(t => t.classList.toggle("active", t.dataset.textId === textId));
       
       document.getElementById("text-content").value = textItem.content;
       document.getElementById("text-font-size").value = textItem.fontSize;
       document.getElementById("text-color").value = textItem.color;
       document.getElementById("text-font-weight").value = textItem.fontWeight;
       document.getElementById("text-font-style").value = textItem.fontStyle;
       document.getElementById("text-align").value = textItem.textAlign;
       document.getElementById("text-decoration").value = textItem.textDecoration;
       document.getElementById("text-bg-color").value = textItem.bgColor;
       document.getElementById("text-bg-enabled").checked = textItem.bgEnabled;
       document.getElementById("text-opacity").value = textItem.opacity;
       document.getElementById("text-opacity-val").textContent = Math.round(textItem.opacity * 100) + "%";
      }
      
      function updateTextDeleteButtons() {
       const deleteButtons = document.querySelectorAll('.text-delete-btn');
       deleteButtons.forEach(btn => {
        btn.style.display = textDrawMode ? 'block' : 'none';
       });
      }
      
      function deleteText(textId) {
      pushUndo("delete text");
       TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== textId);
       forgeTheTopology();
       
       if (currentTextId === textId) {
        document.getElementById("text-panel").style.display = "none";
        currentTextId = null;
       }
      }
      
      document.getElementById("text-content").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
      pushUndo("edit text");
        textItem.content = e.target.value;
        forgeTheTopology();
       }
      });
      
      document.getElementById("text-font-size").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        textItem.fontSize = parseInt(e.target.value);
        forgeTheTopology();
       }
      });
      
      document.getElementById("text-color").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        textItem.color = e.target.value;
        forgeTheTopology();
       }
      });
      
      document.getElementById("text-font-weight").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        textItem.fontWeight = e.target.value;
        forgeTheTopology();
       }
      });
      
      document.getElementById("text-font-style").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        textItem.fontStyle = e.target.value;
        forgeTheTopology();
       }
      });
      
      document.getElementById("text-align").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        textItem.textAlign = e.target.value;
        forgeTheTopology();
       }
      });
      
      document.getElementById("text-decoration").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        textItem.textDecoration = e.target.value;
        forgeTheTopology();
       }
      });
      
      document.getElementById("text-bg-color").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        textItem.bgColor = e.target.value;
        forgeTheTopology();
       }
      });
      
      document.getElementById("text-bg-enabled").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        textItem.bgEnabled = e.target.checked;
        forgeTheTopology();
       }
      });
      
      document.getElementById("text-opacity").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        textItem.opacity = parseFloat(e.target.value);
        document.getElementById("text-opacity-val").textContent = Math.round(textItem.opacity * 100) + "%";
        forgeTheTopology();
       }
      });
      
      document.getElementById("delete-text").addEventListener("click", () => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        challengeTheImmortal(`Delete text "${textItem.content.substring(0, 30)}..."?`, () => {
         deleteText(currentTextId);
        });
       }
      });
      
      const settingsBtn = document.getElementById("settings-btn");
      const settingsModal = document.getElementById("settings-modal");
      const settingsClose = document.getElementById("settings-close");
      settingsBtn.addEventListener("click", () => {
       document.getElementById("page-bg-color").value = PAGE_STATE.background || "#050608";
       document.getElementById("topbar-bg-color").value = PAGE_STATE.topbarBg || "#0b0e13";
       document.getElementById("topbar-border-color").value = PAGE_STATE.topbarBorder || "#1f2533";
       document.getElementById("panel-color").value = PAGE_STATE.panel || "#0b0e13";
       document.getElementById("panel-alt-color").value = PAGE_STATE.panelAlt || "#10141b";
       document.getElementById("sidebar-bg-color").value = PAGE_STATE.sidebarBg || "#10141b";
       document.getElementById("btn-bg-color").value = PAGE_STATE.btnBg || "#0b0e13";
       document.getElementById("btn-text-color").value = PAGE_STATE.btnText || "#e2e8f0";
       document.getElementById("tag-fill-color").value = PAGE_STATE.tagFill || "#1e293b";
       document.getElementById("tag-text-color").value = PAGE_STATE.tagText || "#e2e8f0";
       document.getElementById("tag-border-color").value = PAGE_STATE.tagBorder || "#475569";
       document.getElementById("input-bg-color").value = PAGE_STATE.inputBg || "#0b0e13";
       document.getElementById("input-text-color").value = PAGE_STATE.inputText || "#e2e8f0";
       document.getElementById("input-border-color").value = PAGE_STATE.inputBorder || "#1f2937";
       document.getElementById("input-font-family").value = PAGE_STATE.inputFont || "Inter, system-ui, sans-serif";
       document.getElementById("input-font-size").value = PAGE_STATE.inputFontSize || 14;
       document.getElementById("toolbar-bg-color").value = PAGE_STATE.toolbarBg || "#0f172a";
       document.getElementById("toolbar-border-color").value = PAGE_STATE.toolbarBorder || "#1f2937";
       document.getElementById("toolbar-text-color").value = PAGE_STATE.toolbarText || "#94a3b8";
       document.getElementById("toolbar-btn-bg-color").value = PAGE_STATE.toolbarBtnBg || "#0b0e13";
       document.getElementById("toolbar-btn-text-color").value = PAGE_STATE.toolbarBtnText || "#e2e8f0";
       document.getElementById("minimap-dots-color").value = PAGE_STATE.minimapDots || "#94a3b8";
       document.getElementById("canvas-hint-enabled").checked = PAGE_STATE.canvasHintEnabled !== false;
       document.getElementById("canvas-hint-bg-color").value = PAGE_STATE.canvasHintBg || "#0f172a";
       document.getElementById("canvas-hint-text-color").value = PAGE_STATE.canvasHintColor || "#94a3b8";
       document.getElementById("canvas-hint-text").value = PAGE_STATE.canvasHintText || "";
       document.getElementById("accent-color").value = PAGE_STATE.accent || "#4fd1c5";
       document.getElementById("danger-color").value = PAGE_STATE.danger || "#f56565";
       document.getElementById("text-main-color").value = PAGE_STATE.textMain || "#e2e8f0";
       document.getElementById("text-soft-color").value = PAGE_STATE.textSoft || "#94a3b8";
       document.getElementById("node-fill-color").value = PAGE_STATE.nodeFill || "#1e293b";
       document.getElementById("node-stroke-color").value = PAGE_STATE.nodeStroke || "#475569";
       document.getElementById("node-title-color").value = PAGE_STATE.nodeTitle || "#e2e8f0";
       document.getElementById("node-sub-color").value = PAGE_STATE.nodeSub || "#94a3b8";
       document.getElementById("node-title-size").value = PAGE_STATE.nodeTitleSize || 18;
       document.getElementById("node-sub-size").value = PAGE_STATE.nodeSubSize || 13;
       document.getElementById("node-font-family").value = PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
       document.getElementById("default-edge-color").value = PAGE_STATE.defaultEdge || "#475569";
       document.getElementById("selection-handle-color").value = PAGE_STATE.selectionHandle || "#f59e0b";
       document.getElementById("selection-handle-size").value = PAGE_STATE.selectionHandleSize || 8;
       document.getElementById("group-indicator-color").value = PAGE_STATE.groupIndicator || "#4fd1c5";
       document.getElementById("canvas-gradient-top").value = PAGE_STATE.canvasGradientTop || "#1e2532";
       document.getElementById("canvas-gradient-bottom").value = PAGE_STATE.canvasGradientBottom || "#050608";
       document.getElementById("canvas-border-color").value = PAGE_STATE.canvasBorder || "#475569";
       document.getElementById("canvas-grid-color").value = PAGE_STATE.canvasGrid || "#475569";
       document.getElementById("canvas-grid-size").value = PAGE_STATE.canvasGridSize || 50;
       document.getElementById("rack-frame-fill").value = PAGE_STATE.rackFrameFill || "#0f172a";
       document.getElementById("rack-frame-stroke").value = PAGE_STATE.rackFrameStroke || "#4fd1c5";
       document.getElementById("rack-line-color").value = PAGE_STATE.rackLineColor || "#475569";
       document.getElementById("rack-text-color").value = PAGE_STATE.rackTextColor || "#4fd1c5";
	   document.getElementById("view-only-mode").checked = PAGE_STATE.viewOnly === true;
       settingsModal.classList.add("active");
      });
      settingsClose.addEventListener("click", () => {
       settingsModal.classList.remove("active");
      });
	  document.getElementById("view-only-mode").addEventListener("change", (e) => {
       PAGE_STATE.viewOnly = e.target.checked;
       
       if (e.target.checked) {
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        document.getElementById("rect-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.setProperty('display', 'none', 'important');
        document.getElementById("draw-toolbar").style.setProperty('display', 'none', 'important');      
        currentNodeId = null;
        currentEdgeId = null;
        currentRectId = null;
        currentTextId = null;
        selectedNodes.clear();
        selectedRects.clear();
        selectedTexts.clear();
        selectedEdges.clear();   
        const bulkToolbar = document.getElementById("bulk-toolbar");
        const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active", "selected"));
        document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
        document.querySelectorAll(".rect-group").forEach(r => r.classList.remove("active"));
        document.querySelectorAll(".text-element").forEach(t => t.classList.remove("active"));
       }
       
       wieldThePower();
       if (!e.target.checked) {
        updateDrawToolbarVisibility();
        updateTopologyToolbarVisibility();
       }
       forgeTheTopology();
      });
      settingsModal.addEventListener("click", (e) => {
       if (e.target === settingsModal) {
        settingsModal.classList.remove("active");
       }
      });
      document.getElementById("page-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.background = e.target.value;
       wieldThePower();
      });
      document.getElementById("topbar-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.topbarBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("topbar-border-color").addEventListener("input", (e) => {
       PAGE_STATE.topbarBorder = e.target.value;
       wieldThePower();
      });
      document.getElementById("panel-color").addEventListener("input", (e) => {
       PAGE_STATE.panel = e.target.value;
       wieldThePower();
      });
      document.getElementById("panel-alt-color").addEventListener("input", (e) => {
       PAGE_STATE.panelAlt = e.target.value;
       wieldThePower();
      });
      document.getElementById("sidebar-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.sidebarBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("btn-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.btnBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("btn-text-color").addEventListener("input", (e) => {
       PAGE_STATE.btnText = e.target.value;
       wieldThePower();
      });
      document.getElementById("tag-fill-color").addEventListener("input", (e) => {
       PAGE_STATE.tagFill = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("tag-text-color").addEventListener("input", (e) => {
       PAGE_STATE.tagText = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("tag-border-color").addEventListener("input", (e) => {
       PAGE_STATE.tagBorder = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
	  document.getElementById("selection-fill-color").addEventListener("input", function() {
       selectionBoxStyle.fillColor = this.value;
      });
      document.getElementById("selection-fill-opacity").addEventListener("input", function() {
       selectionBoxStyle.fillOpacity = parseFloat(this.value);
       document.getElementById("selection-fill-opacity-val").textContent = Math.round(this.value * 100) + "%";
      });
      document.getElementById("selection-stroke-color").addEventListener("input", function() {
       selectionBoxStyle.strokeColor = this.value;
      });
      document.getElementById("selection-stroke-width").addEventListener("input", function() {
       selectionBoxStyle.strokeWidth = parseInt(this.value) || 2;
      });
      document.getElementById("selection-stroke-style").addEventListener("change", function() {
       selectionBoxStyle.strokeDasharray = this.value;
      });
      document.getElementById("input-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.inputBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-text-color").addEventListener("input", (e) => {
       PAGE_STATE.inputText = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-border-color").addEventListener("input", (e) => {
       PAGE_STATE.inputBorder = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-font-family").addEventListener("change", (e) => {
       PAGE_STATE.inputFont = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-font-size").addEventListener("input", (e) => {
       PAGE_STATE.inputFontSize = parseInt(e.target.value) || 14;
       wieldThePower();
      });
      document.getElementById("toolbar-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-border-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBorder = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-text-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarText = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-btn-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBtnBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-btn-text-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBtnText = e.target.value;
       wieldThePower();
      });
      document.getElementById("minimap-dots-color").addEventListener("input", (e) => {
       PAGE_STATE.minimapDots = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("canvas-hint-enabled").addEventListener("change", (e) => {
       PAGE_STATE.canvasHintEnabled = e.target.checked;
       wieldThePower();
      });
      document.getElementById("canvas-hint-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-hint-text-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintColor = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-hint-text").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintText = e.target.value;
       wieldThePower();
      });
      document.getElementById("accent-color").addEventListener("input", (e) => {
       PAGE_STATE.accent = e.target.value;
       wieldThePower();
      });
      document.getElementById("danger-color").addEventListener("input", (e) => {
       PAGE_STATE.danger = e.target.value;
       wieldThePower();
      });
      document.getElementById("text-main-color").addEventListener("input", (e) => {
       PAGE_STATE.textMain = e.target.value;
       wieldThePower();
      });
      document.getElementById("text-soft-color").addEventListener("input", (e) => {
       PAGE_STATE.textSoft = e.target.value;
       wieldThePower();
      });
      document.getElementById("node-fill-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeFill = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-stroke-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeStroke = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-title-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeTitle = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-sub-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeSub = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-title-size").addEventListener("input", (e) => {
       PAGE_STATE.nodeTitleSize = parseInt(e.target.value) || 18;
       forgeTheTopology();
      });
      document.getElementById("node-sub-size").addEventListener("input", (e) => {
       PAGE_STATE.nodeSubSize = parseInt(e.target.value) || 13;
       forgeTheTopology();
      });
      document.getElementById("node-font-family").addEventListener("change", (e) => {
       PAGE_STATE.nodeFont = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("default-edge-color").addEventListener("input", (e) => {
       PAGE_STATE.defaultEdge = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("selection-handle-color").addEventListener("input", (e) => {
       PAGE_STATE.selectionHandle = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("selection-handle-size").addEventListener("input", (e) => {
       PAGE_STATE.selectionHandleSize = parseInt(e.target.value) || 8;
       forgeTheTopology();
      });
      document.getElementById("group-indicator-color").addEventListener("input", (e) => {
       PAGE_STATE.groupIndicator = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-gradient-top").addEventListener("input", (e) => {
       PAGE_STATE.canvasGradientTop = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-gradient-bottom").addEventListener("input", (e) => {
       PAGE_STATE.canvasGradientBottom = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-border-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasBorder = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-grid-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasGrid = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-grid-size").addEventListener("input", (e) => {
       PAGE_STATE.canvasGridSize = parseInt(e.target.value) || 50;
       forgeTheTopology();
      });
      document.getElementById("rack-frame-fill").addEventListener("input", (e) => {
       PAGE_STATE.rackFrameFill = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-frame-stroke").addEventListener("input", (e) => {
       PAGE_STATE.rackFrameStroke = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-line-color").addEventListener("input", (e) => {
       PAGE_STATE.rackLineColor = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-text-color").addEventListener("input", (e) => {
       PAGE_STATE.rackTextColor = e.target.value;
       forgeTheTopology();
      });
      
      (function initializeResizers() {
        const headerResizer = document.getElementById('header-resizer');
        const sidebarResizer = document.getElementById('sidebar-resizer');
        const mobileFooterResizer = document.getElementById('mobile-footer-resizer');
        
        let isResizing = false;
        let currentResizer = null;
        let startY = 0;
        let startX = 0;
        let startHeight = 0;
        let startWidth = 0;
        
        function getClientPos(e) {
          if (e.touches && e.touches.length > 0) {
            return { x: e.touches[0].clientX, y: e.touches[0].clientY };
          }
          return { x: e.clientX, y: e.clientY };
        }
        
        function startResize(resizer, type, e) {
          isResizing = true;
          currentResizer = type;
          const pos = getClientPos(e);
          
          if (type === 'header') {
            startY = pos.y;
            startHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--topbar-height'));
          } else if (type === 'sidebar') {
            startX = pos.x;
            startWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width'));
          } else if (type === 'mobile-footer') {
            startY = pos.y;
            const currentVh = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--mobile-footer-height'));
            startHeight = (currentVh / 100) * window.innerHeight;
          }
          
          resizer.classList.add('resizing');
          document.body.classList.add('resizing');
          document.body.style.cursor = (type === 'sidebar') ? 'col-resize' : 'row-resize';
          e.preventDefault();
        }
        
        if (headerResizer) {
          headerResizer.addEventListener('mousedown', (e) => startResize(headerResizer, 'header', e));
          headerResizer.addEventListener('touchstart', (e) => startResize(headerResizer, 'header', e), { passive: false });
        }
        
        if (sidebarResizer) {
          sidebarResizer.addEventListener('mousedown', (e) => startResize(sidebarResizer, 'sidebar', e));
          sidebarResizer.addEventListener('touchstart', (e) => startResize(sidebarResizer, 'sidebar', e), { passive: false });
        }
        
        if (mobileFooterResizer) {
          mobileFooterResizer.addEventListener('mousedown', (e) => startResize(mobileFooterResizer, 'mobile-footer', e));
          mobileFooterResizer.addEventListener('touchstart', (e) => startResize(mobileFooterResizer, 'mobile-footer', e), { passive: false });
        }
        
        function handleMove(e) {
          if (!isResizing) return;
          
          const pos = getClientPos(e);
          
          if (currentResizer === 'header') {
            const deltaY = pos.y - startY;
            const newHeight = Math.max(40, Math.min(150, startHeight + deltaY));
            document.documentElement.style.setProperty('--topbar-height', newHeight + 'px');
          } else if (currentResizer === 'sidebar') {
            const deltaX = startX - pos.x;
            const newWidth = Math.max(200, Math.min(800, startWidth + deltaX));
            document.documentElement.style.setProperty('--sidebar-width', newWidth + 'px');
          } else if (currentResizer === 'mobile-footer') {
            const deltaY = startY - pos.y;
            const newHeight = startHeight + deltaY;
            const newVh = Math.max(15, Math.min(80, (newHeight / window.innerHeight) * 100));
            document.documentElement.style.setProperty('--mobile-footer-height', newVh + 'vh');
          }
          
          e.preventDefault();
        }
        
        document.addEventListener('mousemove', handleMove);
        document.addEventListener('touchmove', handleMove, { passive: false });
        
        function handleEnd() {
          if (isResizing) {
            isResizing = false;
            
            if (currentResizer === 'header') {
              PAGE_STATE.topbarHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--topbar-height'));
              headerResizer.classList.remove('resizing');
            } else if (currentResizer === 'sidebar') {
              PAGE_STATE.sidebarWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width'));
              sidebarResizer.classList.remove('resizing');
            } else if (currentResizer === 'mobile-footer') {
              PAGE_STATE.mobileFooterHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--mobile-footer-height'));
              mobileFooterResizer.classList.remove('resizing');
            }
            
            document.body.classList.remove('resizing');
            document.body.style.cursor = '';
            currentResizer = null;
          }
        }
        
        document.addEventListener('mouseup', handleEnd);
        document.addEventListener('touchend', handleEnd);
        document.addEventListener('touchcancel', handleEnd);
      })();
      
      document.getElementById("export-data-btn").addEventListener("click", () => {
       const data = captureTheQuickening();
       const jsonStr = JSON.stringify(data, null, 2);
       const blob = new Blob([jsonStr], {
        type: "application/json"
       });
       const url = URL.createObjectURL(blob);
       const a = document.createElement("a");
       a.href = url;
       const safeTitle = (PAGE_STATE.title || "network-topology").toLowerCase().replace(/[^a-z0-9\-]+/g, "-");
       const timestamp = new Date().toISOString().split("T")[0];
       a.download = `${safeTitle}-data-${timestamp}.json`;
       document.body.appendChild(a);
       a.click();
       document.body.removeChild(a);
       URL.revokeObjectURL(url);
       logAuditEvent("export", `Exported JSON: ${a.download}`);
      });
      document.getElementById("import-data-btn").addEventListener("click", () => {
       document.getElementById("import-data-file").click();
      });
      document.getElementById("import-data-file").addEventListener("change", async (e) => {
       const file = e.target.files[0];
       if (!file) return;
       try {
        const text = await file.text();
        const data = JSON.parse(text);
        if (!data.nodeData || !data.edgeData) {
         alert("Invalid data file. Missing required fields.");
         return;
        }
        const confirmMsg = `This will replace all current data with the imported data.\n\nImporting:\n- ${Object.keys(data.nodeData).length} nodes\n- ${data.edgeData.list?.length || 0} connections\n- ${data.documentTabs?.length || 1} tab(s)\n\nContinue?`;
        if (!confirm(confirmMsg)) {
         e.target.value = "";
         return;
        }
        NODE_DATA = data.nodeData || {};
        EDGE_DATA = data.edgeData || {
         list: []
        };
        EDGE_LEGEND = data.edgeLegend || {};
        RECT_DATA = data.rectData || { list: [] };
        TEXT_DATA = data.textData || { list: [] };
        savedPositions = data.nodePositions || {};
        savedSizes = data.nodeSizes || {};
        savedStyles = data.nodeStyles || {};
        if (data.page) {
         PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, data.page, );
         wieldThePower();
        }
        if (data.canvas) {
         canvasState.zoom = data.canvas.zoom || 1;
         canvasState.panX = data.canvas.panX || 0;
         canvasState.panY = data.canvas.panY || 0;
        }
        if (data.page?.title) {
         document.title = data.page.title;
         document.querySelector(".editable-page-title", ).textContent = data.page.title;
        }
        if (data.documentTabs) {
         documentTabs = data.documentTabs;
         currentTabIndex = data.currentTabIndex || 0;
        }
        if (data.savedTopologyView) {
         savedTopologyView = data.savedTopologyView;
        }
        if (data.encryptedSections) {
         encryptedSections = data.encryptedSections;
        }
        if (data.auditLog && Array.isArray(data.auditLog)) {
         auditLog = data.auditLog;
         try {
           localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
         } catch (e) {
           console.warn("Failed to sync audit log to localStorage:", e);
         }
        }
        forgeTheTopology();
        forgeTheLegend();
		logAuditEvent("import", `Imported JSON: ${file.name} (${Object.keys(data.nodeData).length} nodes, ${data.edgeData.list?.length || 0} connections)`);
        updateViewBox();
        const nodeIds = Object.keys(NODE_DATA);
        if (nodeIds.length > 0) {
         claimTheImmortal(nodeIds[0]);
        } else {
         document.getElementById("node-panel").style.display = "none";
         document.getElementById("edge-panel").style.display = "none";
         document.getElementById("topology-toolbar").style.display = "none";
        }
        e.target.value = "";
       } catch (err) {
        console.error("Import error:", err);
        alert(`Failed to import data: ${err.message}`);
        e.target.value = "";
       }
      });
      const saveHelpBtn = document.getElementById("save-help-btn");
      const saveInfoModal = document.getElementById("save-info-modal");
      const saveInfoClose = document.getElementById("save-info-close");
      saveHelpBtn.addEventListener("click", () => {
       saveInfoModal.classList.add("active");
      });
      saveInfoClose.addEventListener("click", () => {
       saveInfoModal.classList.remove("active");
      });
      saveInfoModal.addEventListener("click", (e) => {
       if (e.target === saveInfoModal) {
        saveInfoModal.classList.remove("active");
       }
      });
      document.querySelectorAll(".help-tab").forEach(tab => {
        tab.addEventListener("click", () => {
          document.querySelectorAll(".help-tab").forEach(t => { t.style.background = "var(--panel)"; t.style.color = "var(--text-main)"; });
          tab.style.background = "var(--accent)"; tab.style.color = "var(--bg)";
          document.querySelectorAll(".help-tab-content").forEach(c => c.style.display = "none");
          document.getElementById("help-tab-" + tab.dataset.tab).style.display = "block";
        });
      });
      async function deriveKey(password, salt) {
      const encoder = new TextEncoder();
      
      const keyMaterial = await crypto.subtle.importKey(
      "raw",
      encoder.encode(password),
      "PBKDF2",
      false,
      ["deriveKey"]
      );
      
      return crypto.subtle.deriveKey(
      {
      name: "PBKDF2",
      salt: salt,
      iterations: 200000,
      hash: "SHA-256"
      },
      keyMaterial,
      {
      name: "AES-GCM",
      length: 256
      },
      false,
      ["encrypt", "decrypt"]
      );
      }
      
      async function encryptData(data, password) {
      const encoder = new TextEncoder();
      const salt = crypto.getRandomValues(new Uint8Array(16));
      const iv   = crypto.getRandomValues(new Uint8Array(12));
      
      const key = await deriveKey(password, salt);
      const encrypted = await crypto.subtle.encrypt(
      { name: "AES-GCM", iv },
      key,
      encoder.encode(data)
      );
      
      const encryptedU8 = new Uint8Array(encrypted);
      
      const result = new Uint8Array(salt.length + iv.length + encryptedU8.length);
      result.set(salt, 0);
      result.set(iv, salt.length);
      result.set(encryptedU8, salt.length + iv.length);
      
      return "ENCRYPTED:" + u8ToBase64(result);
      }
      
      async function decryptData(encryptedData, password) {
      const base64Data = encryptedData.replace("ENCRYPTED:", "");
      const fullData   = base64ToU8(base64Data);
      
      const salt      = fullData.slice(0, 16);
      const iv        = fullData.slice(16, 28);
      const encrypted = fullData.slice(28);
      
      const key = await deriveKey(password, salt);
      
      const decrypted = await crypto.subtle.decrypt(
      { name: "AES-GCM", iv },
      key,
      encrypted
      );
      
      const decoder = new TextDecoder();
      return decoder.decode(decrypted);
      }
      
      
      function isEncrypted(data) {
       return typeof data === "string" && data.startsWith("ENCRYPTED:");
      }
      
      function captureTheQuickening() {
       const currentTab = documentTabs[currentTabIndex];
       currentTab.nodes = JSON.parse(JSON.stringify(NODE_DATA));
       currentTab.edges = JSON.parse(JSON.stringify(EDGE_DATA));
       currentTab.positions = JSON.parse(JSON.stringify(savedPositions));
       currentTab.sizes = JSON.parse(JSON.stringify(savedSizes));
       currentTab.styles = JSON.parse(JSON.stringify(savedStyles));
       currentTab.legend = JSON.parse(JSON.stringify(EDGE_LEGEND));
       currentTab.rects = JSON.parse(JSON.stringify(RECT_DATA));
       currentTab.texts = JSON.parse(JSON.stringify(TEXT_DATA));
       currentTab.pageState = JSON.parse(JSON.stringify(PAGE_STATE));
       
       return {
        nodeData: NODE_DATA,
        edgeData: EDGE_DATA,
        rectData: RECT_DATA,
        textData: TEXT_DATA,
        edgeLegend: EDGE_LEGEND,
        nodePositions: savedPositions,
        nodeSizes: savedSizes,
        nodeStyles: savedStyles,
        page: PAGE_STATE,
        canvas: {
         zoom: canvasState.zoom,
         panX: canvasState.panX,
         panY: canvasState.panY,
        },
        savedTopologyView: savedTopologyView,
        documentTabs: documentTabs,
        currentTabIndex: currentTabIndex,
        encryptedSections: encryptedSections,
        auditLog: auditLog,
       };
      }
      
      function assembleTheImmortalForm() {
      const canvasHintEl = document.getElementById("canvas-hint");
       const savedHintHTML = canvasHintEl ? canvasHintEl.innerHTML : "";
       if (canvasHintEl) canvasHintEl.innerHTML = DEFAULT_CANVAS_HINT;
       const clone = document.documentElement.cloneNode(true);
       ["edge-legend-mini", "minimap-mini", "draw-toolbar-mini", "topology-toolbar-mini"].forEach(id => {
        const all = clone.querySelectorAll("#" + id);
        for (let i = 1; i < all.length; i++) {
         all[i].remove();
        }
       });
       const nodeScript = clone.querySelector("#nodes-json");
       if (nodeScript) {
        nodeScript.textContent = JSON.stringify(NODE_DATA, null, 2);
       }
       let stateScript = clone.querySelector("#topology-state");
       if (!stateScript) {
        stateScript = document.createElement("script");
        stateScript.id = "topology-state";
        stateScript.type = "application/json";
        const body = clone.querySelector("body") || clone;
        body.appendChild(stateScript);
       }
       stateScript.textContent = JSON.stringify(captureTheQuickening(), null, 2, );
       return "<!DOCTYPE html> \n " + clone.outerHTML;
      }
      async function becomeImmortal() {
       saveRollbackVersion("Auto-save");
       
       const encryptEnabled = document.getElementById("encrypt-toggle").checked;
       let stateData = JSON.stringify(captureTheQuickening(), null, 2);
       if (encryptEnabled) {
        const password = prompt("Enter a password to encrypt your data:\n(Remember this password! You will need it to open this file and its non recoverable!)", );
        if (!password) {
         alert("Encryption cancelled. File not saved.");
         return;
        }
        const confirmPassword = prompt("Confirm your password:");
        if (password !== confirmPassword) {
         alert("Passwords do not match. File not saved.");
         return;
        }
        try {
         stateData = await encryptData(stateData, password);
        } catch (e) {
         alert("Encryption failed: " + e.message);
         return;
        }
       }
       const canvasHintEl = document.getElementById("canvas-hint");
       const savedHintHTML = canvasHintEl ? canvasHintEl.innerHTML : "";
       if (canvasHintEl) canvasHintEl.innerHTML = DEFAULT_CANVAS_HINT;    
       const clone = document.documentElement.cloneNode(true);
       ["edge-legend-mini", "minimap-mini", "draw-toolbar-mini", "topology-toolbar-mini"].forEach(id => {
        const all = clone.querySelectorAll("#" + id);
        for (let i = 1; i < all.length; i++) {
         all[i].remove();
        }
       });
       
       const nodeScript = clone.querySelector("#nodes-json");
       if (nodeScript) {
        if (encryptEnabled) {
         nodeScript.textContent = JSON.stringify({}, null, 2);
        } else {
         nodeScript.textContent = JSON.stringify(NODE_DATA, null, 2);
        }
       }
       let stateScript = clone.querySelector("#topology-state");
       if (!stateScript) {
        stateScript = document.createElement("script");
        stateScript.id = "topology-state";
        stateScript.type = "application/json";
        const body = clone.querySelector("body") || clone;
        body.appendChild(stateScript);
       }
       stateScript.textContent = stateData;
       const html = "<!DOCTYPE html> \n " + clone.outerHTML;
       const blob = new Blob([html], {
        type: "text/html"
       });
       const url = URL.createObjectURL(blob);
       const a = document.createElement("a");
       a.href = url;
       const safeTitle = (PAGE_STATE.title || document.title || "network-topology").toLowerCase().replace(/[^a-z0-9\-]+/g, "-");
       a.download = safeTitle + ".html";
       document.body.appendChild(a);
       a.click();
       document.body.removeChild(a);
       URL.revokeObjectURL(url);
       if (canvasHintEl) canvasHintEl.innerHTML = savedHintHTML;
       logAuditEvent("save", `File saved: ${safeTitle}.html`);
      }
      
      function captureState() {
      return {
       nodes: JSON.parse(JSON.stringify(NODE_DATA)),
       edges: JSON.parse(JSON.stringify(EDGE_DATA)),
       positions: JSON.parse(JSON.stringify(savedPositions)),
       sizes: JSON.parse(JSON.stringify(savedSizes)),
       styles: JSON.parse(JSON.stringify(savedStyles)),
       legend: JSON.parse(JSON.stringify(EDGE_LEGEND)),
       rects: JSON.parse(JSON.stringify(RECT_DATA)),
       texts: JSON.parse(JSON.stringify(TEXT_DATA))
       };
      }
      
      function pushUndo(action = "") {
       const state = captureState();
       undoStack.push(state);
       if (undoStack.length > MAX_UNDO_STACK) {
        undoStack.shift();
       }
       redoStack = [];
       updateUndoButtons();
       
       if (action) {
        const actionTypeMap = {
  "create node": "node",
  "delete node": "node",
  "add node": "node",
  "edit": "node",
  "clone node": "node",
  "paste node": "node",
  "move nodes": "node",
  "nudge": "node",
  "align nodes": "node",
  "distribute nodes": "node",
  "snap to grid": "node",
  "toggle group": "node",
  "toggle lock": "node",
  "create rack": "rack",
  "add rack": "rack",
  "edit rack": "rack",
  "edit mac": "rack",
  "edit U height": "rack",
  "change rack capacity": "rack",
  "change assigned rack": "rack",
  "add connection": "connection",
  "delete connection": "connection",
  "delete edge": "connection",
  "clone edge": "connection",
  "paste edge": "connection",
  "style change": "style",
  "change layer": "layer",
  "add text": "text",
  "edit text": "text",
  "delete text": "text",
  "clone text": "text",
  "paste text": "text",
  "draw zone": "zone",
  "delete zone": "zone",
  "delete rect": "zone",
  "clone rect": "zone",
  "paste rect": "zone",
  "change zone line style": "zone",
  "delete selected": "bulk",
  "clone selected": "bulk",
};
        
        const type = actionTypeMap[action] || "node";
        logAuditEvent(type, action);
       }
      }
      
      function undo() {
       if (undoStack.length === 0) return;
       const currentState = captureState();
       redoStack.push(currentState);
       const previousState = undoStack.pop();
       restoreState(previousState);
       updateUndoButtons();
       logAuditEvent("undo", "Undo action performed");
      }
      
      function redo() {
       if (redoStack.length === 0) return;
       logAuditEvent("redo", "Redo action performed");
       const currentState = captureState();
       undoStack.push(currentState);
       const nextState = redoStack.pop();
       restoreState(nextState);
       updateUndoButtons();
      }
      
      function restoreState(state) {
      NODE_DATA = state.nodes;
      EDGE_DATA = state.edges;
      savedPositions = state.positions;
      savedSizes = state.sizes;
      savedStyles = state.styles;
      EDGE_LEGEND = state.legend;
      RECT_DATA = state.rects || { list: [] };
      TEXT_DATA = state.texts || { list: [] };
      forgeTheTopology();
      if (currentNodeId && NODE_DATA[currentNodeId]) {
       claimTheImmortal(currentNodeId);
      } else if (currentEdgeId) {
       selectTheConnection(currentEdgeId);
       }
      }
      
      function updateUndoButtons() {
       const undoBtn = document.getElementById("undo-btn");
       const redoBtn = document.getElementById("redo-btn");
       if (undoBtn) {
        undoBtn.disabled = undoStack.length === 0;
        undoBtn.style.opacity = undoStack.length === 0 ? "0.5" : "1";
       }
       if (redoBtn) {
        redoBtn.disabled = redoStack.length === 0;
        redoBtn.style.opacity = redoStack.length === 0 ? "0.5" : "1";
       }
      }
      
      function editNodeMac(id) {
       const currentMac = NODE_DATA[id].mac || "";
       showEditModal("Edit MAC Address", currentMac, (newMac) => {
        pushUndo("edit mac");
        NODE_DATA[id].mac = newMac;
        if (currentNodeId === id) {
         document.getElementById("node-mac").textContent = newMac || "--";
        }
       });
      }
      
      function editNodeRack(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       
       document.getElementById("modal-title").textContent = "Edit Rack Unit";
       document.getElementById("modal-input").value = node.rackUnit || "";
       document.getElementById("edit-modal").style.display = "flex";
       document.getElementById("modal-input").focus();
       
       const saveHandler = () => {
        pushUndo("edit rack");
        const value = document.getElementById("modal-input").value.trim();
        node.rackUnit = value;
        document.getElementById("edit-modal").style.display = "none";
        claimTheImmortal(id);
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       
       const cancelHandler = () => {
        document.getElementById("edit-modal").style.display = "none";
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       
       document.getElementById("edit-modal").addEventListener("click", function bgHandler(e) {
        if (e.target === document.getElementById("edit-modal")) {
         cancelHandler();
         document.getElementById("edit-modal").removeEventListener("click", bgHandler);
        }
       });
      }
      
      function editNodeUHeight(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       
       document.getElementById("modal-title").textContent = "Edit U Height";
       document.getElementById("modal-input").value = node.uHeight || "1";
       document.getElementById("edit-modal").style.display = "flex";
       document.getElementById("modal-input").focus();
       
       const saveHandler = () => {
        pushUndo("edit U height");
        const value = document.getElementById("modal-input").value.trim();
        node.uHeight = value;
        document.getElementById("edit-modal").style.display = "none";
        claimTheImmortal(id);
        forgeTheTopology();
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       
       const cancelHandler = () => {
        document.getElementById("edit-modal").style.display = "none";
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       
       document.getElementById("edit-modal").addEventListener("click", function bgHandler(e) {
        if (e.target === document.getElementById("edit-modal")) {
         cancelHandler();
         document.getElementById("edit-modal").removeEventListener("click", bgHandler);
        }
       });
      }
      
      function updateEdgePortLabels(edgeId) {
       const edge = EDGE_DATA.list.find(e => e.id === edgeId);
       if (!edge || edge.type === "custom") return;
       
       const fromPortInput = document.getElementById("edge-from-port");
       const toPortInput = document.getElementById("edge-to-port");
       
       if (fromPortInput && toPortInput) {
        edge.fromPort = fromPortInput.value || "";
        edge.toPort = toPortInput.value || "";
        
        forgeTheTopology();
       }
      }
      
      function clearSelection() {
       selectedNodes.clear();
       selectedEdges.clear();
       selectedRects.clear();
       selectedTexts.clear();
       updateAllSelections();
      }
      
      function updateAllSelections() {
      updateNodeSelection();
      
      document.querySelectorAll(".edge").forEach(el => {
      const edgeId = el.dataset.edgeId;
      if (selectedEdges.has(edgeId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      
      document.querySelectorAll(".rect-group").forEach(el => {
      const rectId = el.dataset.rectId;
      if (selectedRects.has(rectId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      
      document.querySelectorAll(".text-group").forEach(el => {
      const textId = el.dataset.textId;
      if (selectedTexts.has(textId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      
      const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
      const bulkToolbar = document.getElementById("bulk-toolbar");
      const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
      const bulkCount = document.getElementById("bulk-count");
      const bulkCountMobile = document.getElementById("bulk-count-mobile");
      
      if (total > 0) {
      if (bulkToolbar) bulkToolbar.style.display = "flex";
      if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
      if (bulkCount) bulkCount.textContent = total;
      if (bulkCountMobile) bulkCountMobile.textContent = total;
      } else {
      if (bulkToolbar) bulkToolbar.style.display = "none";
      if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
      }
      }
      
      function updateNodeSelection() {
       if (isViewOnly()) {
        selectedNodes.clear();
        selectedRects.clear();
        selectedTexts.clear();
        const bulkToolbar = document.getElementById("bulk-toolbar");
        const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        return;
       }
       document.querySelectorAll(".node-group").forEach(node => {
        const nodeId = node.dataset.nodeId;
        if (selectedNodes.has(nodeId)) {
         node.classList.add("selected");
        } else {
         node.classList.remove("selected");
        }
       });
       
       const bulkToolbar = document.getElementById("bulk-toolbar");
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       const bulkCount = document.getElementById("bulk-count");
       const bulkCountMobile = document.getElementById("bulk-count-mobile");
       const bulkCountModal = document.getElementById("bulk-count-modal");
       
       if (selectedNodes.size > 0) {
        if (bulkToolbar) bulkToolbar.style.display = "flex";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
        if (bulkCount) bulkCount.textContent = selectedNodes.size;
        if (bulkCountMobile) bulkCountMobile.textContent = selectedNodes.size;
        if (bulkCountModal) bulkCountModal.textContent = selectedNodes.size;
       } else {
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        const modal = document.getElementById("bulk-actions-modal");
        if (modal) modal.style.display = "none";
       }
      }
      
      function deleteSelected() {
       const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
       if (total === 0) return;
       
       let nodesInsideRacks = [];
       selectedNodes.forEach(nodeId => {
        if (NODE_DATA[nodeId]?.isRack) {
         Object.entries(NODE_DATA).forEach(([id, n]) => {
          if (n.assignedRack === nodeId) nodesInsideRacks.push(n.name || id);
         });
        }
       });
       
       let message = `Delete ${total} selected item(s)?`;
       if (nodesInsideRacks.length > 0) {
        message += `\n\nThis will also delete ${nodesInsideRacks.length} node(s) inside rack(s):\n• ${nodesInsideRacks.join('\n• ')}`;
       }
       
       challengeTheImmortal(message, () => {
        pushUndo("delete selected");
        selectedNodes.forEach(nodeId => {
         if (NODE_DATA[nodeId]?.isRack) {
          Object.keys(NODE_DATA).forEach(id => {
           if (NODE_DATA[id]?.assignedRack === nodeId) {
            EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== id && e.to !== id);
            delete NODE_DATA[id];
            delete savedPositions[id];
            delete savedSizes[id];
            delete savedStyles[id];
           }
          });
         }
         delete NODE_DATA[nodeId];
         delete savedPositions[nodeId];
         delete savedSizes[nodeId];
         delete savedStyles[nodeId];
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== nodeId && e.to !== nodeId);
        });
        selectedEdges.forEach(edgeId => {
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.id !== edgeId);
        });
        selectedRects.forEach(rectId => {
         RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== rectId);
        });
        selectedTexts.forEach(textId => {
         TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== textId);
        });
        clearSelection();
        
        forgeTheTopology();
       });
      }
      
      function startSelection(event) {
       if (event.button !== 0) return;
       if (event.target.closest(".node-group")) return;
       
       isSelecting = true;
       const svg = document.getElementById("map");
       const pt = svg.createSVGPoint();
       pt.x = event.clientX;
       pt.y = event.clientY;
       const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
       selectionStart = { x: svgP.x, y: svgP.y };
       
       if (!event.shiftKey) {
        clearSelection();
       }
       
       if (!selectionRect || !selectionRect.parentNode) {
        selectionRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        selectionRect.setAttribute("fill", selectionBoxStyle.fillColor);
        selectionRect.setAttribute("fill-opacity", selectionBoxStyle.fillOpacity);
        selectionRect.setAttribute("stroke", selectionBoxStyle.strokeColor);
        selectionRect.setAttribute("stroke-width", selectionBoxStyle.strokeWidth);
        selectionRect.setAttribute("stroke-dasharray", selectionBoxStyle.strokeDasharray);
        svg.appendChild(selectionRect);
       }
       selectionRect.style.display = "block";
      }
      
      function updateSelection(event) {
       if (!isSelecting || !selectionStart) return;
       
       const svg = document.getElementById("map");
       const pt = svg.createSVGPoint();
       pt.x = event.clientX;
       pt.y = event.clientY;
       const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
       
       const x = Math.min(selectionStart.x, svgP.x);
       const y = Math.min(selectionStart.y, svgP.y);
       const width = Math.abs(svgP.x - selectionStart.x);
       const height = Math.abs(svgP.y - selectionStart.y);
       
       selectionRect.setAttribute("x", x);
       selectionRect.setAttribute("y", y);
       selectionRect.setAttribute("width", width);
       selectionRect.setAttribute("height", height);
       
       const box = { x, y, width, height };
       
       Object.entries(savedPositions).forEach(([nodeId, pos]) => {
        const size = savedSizes[nodeId] || 50;
        const halfSize = size / 2;
        const nodeBox = { x: pos.x - halfSize, y: pos.y - halfSize, width: size, height: size };
        if (boxesIntersect(box, nodeBox)) {
         selectedNodes.add(nodeId);
        } else if (!event.shiftKey) {
         selectedNodes.delete(nodeId);
        }
       });
       
      EDGE_DATA.list.forEach(edge => {
        if (!edge.points || edge.points.length === 0) return;
        for (let i = 0; i < edge.points.length - 1; i++) {
         const p1 = edge.points[i];
         const p2 = edge.points[i + 1];
         if (lineIntersectsBox(p1.x, p1.y, p2.x, p2.y, box)) {
          selectedEdges.add(edge.id);
          return;
         }
        }
        if (!event.shiftKey) {
         selectedEdges.delete(edge.id);
        }
       });
       
       RECT_DATA.list.forEach(rect => {
        const rectBox = { x: rect.x, y: rect.y, width: rect.width, height: rect.height };
        if (boxesIntersect(box, rectBox)) {
         selectedRects.add(rect.id);
        } else if (!event.shiftKey) {
         selectedRects.delete(rect.id);
        }
       });
       
       TEXT_DATA.list.forEach(text => {
        const fontSize = text.fontSize || 18;
        const textBox = { x: text.x - 50, y: text.y - fontSize, width: 100, height: fontSize * 1.5 };
        if (boxesIntersect(box, textBox)) {
         selectedTexts.add(text.id);
        } else if (!event.shiftKey) {
         selectedTexts.delete(text.id);
        }
       });
       
       updateAllSelectionVisuals();
      }
      
      function endSelection() {
       isSelecting = false;
       if (selectionRect) {
        selectionRect.style.display = "none";
       }
      }
      
      function boxesIntersect(a, b) {
       return !(a.x + a.width < b.x || b.x + b.width < a.x || a.y + a.height < b.y || b.y + b.height < a.y);
      }
      
      function lineIntersectsBox(x1, y1, x2, y2, box) {
       if (pointInBox(x1, y1, box) || pointInBox(x2, y2, box)) return true;
       const lines = [
        [box.x, box.y, box.x + box.width, box.y],
        [box.x + box.width, box.y, box.x + box.width, box.y + box.height],
        [box.x + box.width, box.y + box.height, box.x, box.y + box.height],
        [box.x, box.y + box.height, box.x, box.y]
       ];
       for (const [bx1, by1, bx2, by2] of lines) {
        if (linesIntersect(x1, y1, x2, y2, bx1, by1, bx2, by2)) return true;
       }
       return false;
      }
      
      function pointInBox(x, y, box) {
       return x >= box.x && x <= box.x + box.width && y >= box.y && y <= box.y + box.height;
      }
      
      function linesIntersect(x1, y1, x2, y2, x3, y3, x4, y4) {
       const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
       if (Math.abs(denom) < 0.0001) return false;
       const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom;
       const ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denom;
       return ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1;
      }
      
      function updateAllSelectionVisuals() {
       document.querySelectorAll(".node-group").forEach(node => {
        const nodeId = node.dataset.nodeId;
        if (selectedNodes.has(nodeId)) {
         node.classList.add("selected");
        } else {
         node.classList.remove("selected");
        }
       });
       
       document.querySelectorAll(".edge").forEach(edge => {
        const edgeId = edge.dataset.edgeId;
        if (selectedEdges.has(edgeId)) {
         edge.style.filter = "drop-shadow(0 0 6px #4fd1c5)";
        } else {
         edge.style.filter = "";
        }
       });
       
       document.querySelectorAll(".rect-group rect").forEach(el => {
        const rectId = el.closest(".rect-group")?.dataset?.rectId;
        if (selectedRects.has(rectId)) {
         el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
        } else {
         el.style.filter = "";
        }
       });
       
       document.querySelectorAll(".text-group, .text-element").forEach(el => {
        const textId = el.dataset?.textId;
        if (selectedTexts.has(textId)) {
         el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
        } else {
         el.style.filter = "";
        }
       });
       
       const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
       const bulkToolbar = document.getElementById("bulk-toolbar");
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       const bulkCount = document.getElementById("bulk-count");
       const bulkCountMobile = document.getElementById("bulk-count-mobile");
       
       if (total > 0) {
        if (bulkToolbar) bulkToolbar.style.display = "flex";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
        if (bulkCount) bulkCount.textContent = total;
        if (bulkCountMobile) bulkCountMobile.textContent = total;
       } else {
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
       }
      }
      
      function cloneNode(sourceId) {
       if (!NODE_DATA[sourceId]) return;
       
       pushUndo("clone node");
       const source = NODE_DATA[sourceId];
       const baseName = source.name + " copy";
       let newName = baseName;
       let counter = 1;
       while (Object.values(NODE_DATA).some(n => n.name === newName)) {
        newName = `${baseName} ${counter}`;
        counter++;
       }
       
       const baseId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
       let newId = baseId;
       counter = 1;
       while (NODE_DATA[newId]) {
        newId = `${baseId}-${counter}`;
        counter++;
       }
       
       NODE_DATA[newId] = {
        shape: source.shape,
        name: newName,
        ip: source.ip,
        role: source.role,
        tags: [...source.tags],
        notes: [...source.notes],
        mac: source.mac || "",
        rackUnit: source.rackUnit || "",
        uHeight: source.uHeight || "1",
        layer: source.layer || "physical",
        assignedRack: source.assignedRack || "",
        rackCapacity: source.rackCapacity || "42",
        isRack: source.isRack || false
       }; 
	   
       if (source.isRack) {
        const childNodes = Object.entries(NODE_DATA).filter(([id, n]) => 
         id !== newId && n.assignedRack === sourceId
        );
        childNodes.forEach(([childId, childNode]) => {
         const childBaseName = childNode.name + " copy";
         let childNewName = childBaseName;
         let c = 1;
         while (Object.values(NODE_DATA).some(n => n.name === childNewName)) {
          childNewName = `${childBaseName} ${c}`;
          c++;
         }
         const childBaseId = childNewName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
         let childNewId = childBaseId;
         c = 1;
         while (NODE_DATA[childNewId]) {
          childNewId = `${childBaseId}-${c}`;
          c++;
         }
         NODE_DATA[childNewId] = {
          ...JSON.parse(JSON.stringify(childNode)),
          name: childNewName,
          assignedRack: newId
         };
         if (savedPositions[childId]) {
          savedPositions[childNewId] = { ...savedPositions[childId] };
         }
         if (savedSizes[childId]) {
          savedSizes[childNewId] = savedSizes[childId];
         }
         if (savedStyles[childId]) {
          savedStyles[childNewId] = JSON.parse(JSON.stringify(savedStyles[childId]));
         }
        });
       }
       
       if (currentView.mode === "rack" && currentView.rackId) {
        NODE_DATA[newId].assignedRack = currentView.rackId;
       }
       
       const sourcePos = savedPositions[sourceId];
       savedPositions[newId] = {
        x: sourcePos.x + 100,
        y: sourcePos.y + 100
       };
       
       if (savedSizes[sourceId]) {
        savedSizes[newId] = savedSizes[sourceId];
       }
       
       if (savedStyles[sourceId]) {
        savedStyles[newId] = JSON.parse(JSON.stringify(savedStyles[sourceId]));
       }
       
       forgeTheTopology();
       claimTheImmortal(newId);
      }
      
      function alignSelectedNodes(direction) {
       if (selectedNodes.size < 2) return;
       
       pushUndo("align nodes");
       const nodes = Array.from(selectedNodes).map(id => ({
        id,
        pos: savedPositions[id]
       }));
       
       switch(direction) {
        case "left":
         const minX = Math.min(...nodes.map(n => n.pos.x));
         nodes.forEach(n => savedPositions[n.id].x = minX);
         break;
        case "right":
         const maxX = Math.max(...nodes.map(n => n.pos.x));
         nodes.forEach(n => savedPositions[n.id].x = maxX);
         break;
        case "top":
         const minY = Math.min(...nodes.map(n => n.pos.y));
         nodes.forEach(n => savedPositions[n.id].y = minY);
         break;
        case "bottom":
         const maxY = Math.max(...nodes.map(n => n.pos.y));
         nodes.forEach(n => savedPositions[n.id].y = maxY);
         break;
        case "center-h":
         const avgX = nodes.reduce((sum, n) => sum + n.pos.x, 0) / nodes.length;
         nodes.forEach(n => savedPositions[n.id].x = avgX);
         break;
        case "center-v":
         const avgY = nodes.reduce((sum, n) => sum + n.pos.y, 0) / nodes.length;
         nodes.forEach(n => savedPositions[n.id].y = avgY);
         break;
       }
       
       forgeTheTopology();
      }
      
      function distributeSelectedNodes(direction) {
       if (selectedNodes.size < 3) return;
       
       pushUndo("distribute nodes");
       const nodes = Array.from(selectedNodes).map(id => ({
        id,
        pos: savedPositions[id]
       }));
       
       if (direction === "horizontal") {
        nodes.sort((a, b) => a.pos.x - b.pos.x);
        const minX = nodes[0].pos.x;
        const maxX = nodes[nodes.length - 1].pos.x;
        const gap = (maxX - minX) / (nodes.length - 1);
        nodes.forEach((n, i) => {
         savedPositions[n.id].x = minX + (gap * i);
        });
       } else {
        nodes.sort((a, b) => a.pos.y - b.pos.y);
        const minY = nodes[0].pos.y;
        const maxY = nodes[nodes.length - 1].pos.y;
        const gap = (maxY - minY) / (nodes.length - 1);
        nodes.forEach((n, i) => {
         savedPositions[n.id].y = minY + (gap * i);
        });
       }
       
       forgeTheTopology();
      }
      
      function snapToGrid(nodeId, gridSize = 50) {
       if (!savedPositions[nodeId]) return;
       
       pushUndo("snap to grid");
       const pos = savedPositions[nodeId];
       pos.x = Math.round(pos.x / gridSize) * gridSize;
       pos.y = Math.round(pos.y / gridSize) * gridSize;
       forgeTheTopology();
      }
      
      function searchNodes(query) {
       if (!query) {
        clearSearchHighlight();
        return [];
       }
       
       query = query.toLowerCase();
       const results = [];
       
       Object.entries(NODE_DATA).forEach(([id, data]) => {
        if (data.name.toLowerCase().includes(query) ||
            data.ip.toLowerCase().includes(query) ||
            data.role.toLowerCase().includes(query) ||
            data.tags.some(tag => tag.toLowerCase().includes(query)) ||
            (data.mac && data.mac.toLowerCase().includes(query)) ||
            (data.rackUnit && data.rackUnit.toLowerCase().includes(query))) {
         results.push(id);
        }
       });
       
       highlightSearchResults(results);
       return results;
      }
      
      function highlightSearchResults(nodeIds) {
       document.querySelectorAll(".node-group").forEach(node => {
        const nodeId = node.dataset.nodeId;
        if (nodeIds.includes(nodeId)) {
         node.classList.add("search-highlight");
        } else {
         node.classList.remove("search-highlight");
        }
       });
      }
      
      function clearSearchHighlight() {
       document.querySelectorAll(".search-highlight").forEach(node => {
        node.classList.remove("search-highlight");
       });
      }
      
      function nudgeSelectedNodes(direction, distance) {
        const nodesToNudge = selectedNodes.size > 0 
          ? Array.from(selectedNodes) 
          : (currentNodeId ? [currentNodeId] : []);
        const rectsToNudge = selectedRects.size > 0 
          ? Array.from(selectedRects) 
          : (currentRectId ? [currentRectId] : []);
        const textsToNudge = selectedTexts.size > 0 
          ? Array.from(selectedTexts) 
          : (currentTextId ? [currentTextId] : []);
        
        if (nodesToNudge.length === 0 && rectsToNudge.length === 0 && textsToNudge.length === 0) return;
        
        const unlockedNodes = nodesToNudge.filter(id => !NODE_DATA[id]?.locked);
        const unlockedRects = rectsToNudge.filter(id => { const r = RECT_DATA.list.find(x => x.id === id); return r && !r.locked; });
        const unlockedTexts = textsToNudge.filter(id => { const t = TEXT_DATA.list.find(x => x.id === id); return t && !t.locked; });
        
        if (unlockedNodes.length === 0 && unlockedRects.length === 0 && unlockedTexts.length === 0) return;
        
        pushUndo("nudge");
        
        const dx = direction === "ArrowLeft" ? -distance : direction === "ArrowRight" ? distance : 0;
        const dy = direction === "ArrowUp" ? -distance : direction === "ArrowDown" ? distance : 0;
        
        unlockedNodes.forEach(id => {
          if (!savedPositions[id]) savedPositions[id] = { x: 0, y: 0 };
          savedPositions[id].x += dx;
          savedPositions[id].y += dy;
        });
        
        unlockedRects.forEach(id => {
          const r = RECT_DATA.list.find(x => x.id === id);
          if (r) { r.x += dx; r.y += dy; }
        });
        
        unlockedTexts.forEach(id => {
          const t = TEXT_DATA.list.find(x => x.id === id);
          if (t) { t.x += dx; t.y += dy; }
        });
        
        forgeTheTopology();
      }
      
      function cycleNodes(reverse = false) {
        const nodeIds = Object.keys(NODE_DATA).filter(id => {
          if (currentView.mode === "rack" && currentView.rackId) {
            return NODE_DATA[id].assignedRack === currentView.rackId;
          }
          return !NODE_DATA[id].assignedRack;
        });
        
        if (nodeIds.length === 0) return;
        
        let currentIndex = nodeIds.indexOf(currentNodeId);
        
        if (reverse) {
          currentIndex = currentIndex <= 0 ? nodeIds.length - 1 : currentIndex - 1;
        } else {
          currentIndex = currentIndex >= nodeIds.length - 1 ? 0 : currentIndex + 1;
        }
        
        const nextNodeId = nodeIds[currentIndex];
        claimTheImmortal(nextNodeId);
        
        selectedNodes.clear();
        updateNodeSelection();
      }
      
      function focusOnSelected() {
        let minX = Infinity, minY = Infinity;
        let maxX = -Infinity, maxY = -Infinity;
        let hasItems = false;

        const nodesToFocus = selectedNodes.size > 0 
          ? Array.from(selectedNodes) 
          : (currentNodeId ? [currentNodeId] : []);
        nodesToFocus.forEach(id => {
          const pos = savedPositions[id];
          if (pos) {
            hasItems = true;
            const size = savedSizes[id] || 50;
            minX = Math.min(minX, pos.x - size/2);
            minY = Math.min(minY, pos.y - size/2);
            maxX = Math.max(maxX, pos.x + size/2);
            maxY = Math.max(maxY, pos.y + size/2);
          }
        });
        
        const rectsToFocus = selectedRects.size > 0 ? Array.from(selectedRects) : (currentRectId ? [currentRectId] : []);
        rectsToFocus.forEach(id => {
          const r = RECT_DATA.list.find(x => x.id === id);
          if (r) {
            hasItems = true;
            minX = Math.min(minX, r.x);
            minY = Math.min(minY, r.y);
            maxX = Math.max(maxX, r.x + r.width);
            maxY = Math.max(maxY, r.y + r.height);
          }
        });
        
        const textsToFocus = selectedTexts.size > 0 ? Array.from(selectedTexts) : (currentTextId ? [currentTextId] : []);
        textsToFocus.forEach(id => {
          const t = TEXT_DATA.list.find(x => x.id === id);
          if (t) {
            hasItems = true;
            minX = Math.min(minX, t.x - 50);
            minY = Math.min(minY, t.y - 20);
            maxX = Math.max(maxX, t.x + 50);
            maxY = Math.max(maxY, t.y + 20);
          }
        });
        
        const edgesToFocus = selectedEdges.size > 0 ? Array.from(selectedEdges) : (currentEdgeId ? [currentEdgeId] : []);
        edgesToFocus.forEach(id => {
          const e = EDGE_DATA.list.find(x => x.id === id);
          if (e) {
            const fromPos = savedPositions[e.from];
            const toPos = savedPositions[e.to];
            if (fromPos && toPos) {
              hasItems = true;
              minX = Math.min(minX, fromPos.x, toPos.x);
              minY = Math.min(minY, fromPos.y, toPos.y);
              maxX = Math.max(maxX, fromPos.x, toPos.x);
              maxY = Math.max(maxY, fromPos.y, toPos.y);
            }
          }
        });
        
        if (!hasItems || !isFinite(minX)) return;
        
        const padding = 100;
        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;
        const width = maxX - minX + padding * 2;
        const height = maxY - minY + padding * 2;
        
        const zoomX = CANVAS_WIDTH / width;
        const zoomY = CANVAS_HEIGHT / height;
        const targetZoom = Math.min(zoomX, zoomY, 2); 
        
        canvasState.zoom = targetZoom;
        canvasState.panX = centerX - (CANVAS_WIDTH / targetZoom) / 2;
        canvasState.panY = centerY - (CANVAS_HEIGHT / targetZoom) / 2;
        
        forgeTheTopology();
      }
      
      function toggleLockSelected() {
        const nodesToToggle = selectedNodes.size > 0 
          ? Array.from(selectedNodes) 
          : (currentNodeId ? [currentNodeId] : []);
        const rectsToToggle = selectedRects.size > 0 
          ? Array.from(selectedRects) 
          : (currentRectId ? [currentRectId] : []);
        const textsToToggle = selectedTexts.size > 0 
          ? Array.from(selectedTexts) 
          : (currentTextId ? [currentTextId] : []);
        
        if (nodesToToggle.length === 0 && rectsToToggle.length === 0 && textsToToggle.length === 0) return;
        
        pushUndo("toggle lock");
        
        let hasUnlocked = nodesToToggle.some(id => !NODE_DATA[id]?.locked);
        hasUnlocked = hasUnlocked || rectsToToggle.some(id => { const r = RECT_DATA.list.find(x => x.id === id); return r && !r.locked; });
        hasUnlocked = hasUnlocked || textsToToggle.some(id => { const t = TEXT_DATA.list.find(x => x.id === id); return t && !t.locked; });
        
        nodesToToggle.forEach(id => {
          if (NODE_DATA[id]) NODE_DATA[id].locked = hasUnlocked;
        });
        rectsToToggle.forEach(id => {
          const r = RECT_DATA.list.find(x => x.id === id);
          if (r) r.locked = hasUnlocked;
        });
        textsToToggle.forEach(id => {
          const t = TEXT_DATA.list.find(x => x.id === id);
          if (t) t.locked = hasUnlocked;
        });
        
        forgeTheTopology();
      }
      
      function toggleGroupSelected() {
      const nodesToGroup = Array.from(selectedNodes);
      const rectsToGroup = Array.from(selectedRects);
      const textsToGroup = Array.from(selectedTexts);
      const edgesToGroup = Array.from(selectedEdges);
      const totalItems = nodesToGroup.length + rectsToGroup.length + textsToGroup.length + edgesToGroup.length;
      if (totalItems < 2) return;
      
      pushUndo("toggle group");
      
      const allGroupIds = [];
      nodesToGroup.forEach(id => { if (NODE_DATA[id]?.groupId) allGroupIds.push(NODE_DATA[id].groupId); });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r?.groupId) allGroupIds.push(r.groupId); });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t?.groupId) allGroupIds.push(t.groupId); });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e?.groupId) allGroupIds.push(e.groupId); });
      const uniqueGroups = [...new Set(allGroupIds)];
      
      if (uniqueGroups.length === 1 && allGroupIds.length === totalItems) {
      nodesToGroup.forEach(id => { if (NODE_DATA[id]) NODE_DATA[id].groupId = null; });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r) r.groupId = null; });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t) t.groupId = null; });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e) e.groupId = null; });
      } else {
      const newGroupId = "group-" + Date.now();
      nodesToGroup.forEach(id => { if (NODE_DATA[id]) NODE_DATA[id].groupId = newGroupId; });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r) r.groupId = newGroupId; });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t) t.groupId = newGroupId; });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e) e.groupId = newGroupId; });
      }
      
      forgeTheTopology();
      }
      
      function handleKeyDown(event) {
       if (event.target.tagName === "INPUT" || event.target.tagName === "TEXTAREA" || event.target.isContentEditable) {
        return;
       }
       
       if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(event.key)) {
        event.preventDefault();
        const distance = event.shiftKey ? 10 : 1;
        nudgeSelectedNodes(event.key, distance);
       }
       
       if (event.key === "Tab") {
        event.preventDefault();
        cycleNodes(event.shiftKey);
       }
       
       if (event.key === "f" || event.key === "F") {
        event.preventDefault();
        focusOnSelected();
       }
       
       if (event.key === "l" || event.key === "L") {
        event.preventDefault();
        toggleLockSelected();
       }
       
       if (event.key === "g" || event.key === "G") {
        event.preventDefault();
        toggleGroupSelected();
       }
       
       if (event.ctrlKey && event.key === "z") {
        event.preventDefault();
        undo();
       }
       
       if ((event.ctrlKey && event.key === "y") || (event.ctrlKey && event.shiftKey && event.key === "z")) {
        event.preventDefault();
        redo();
       }
       
 if (event.ctrlKey && event.key === "c") {
        event.preventDefault();
        clipboard = null;
        if (currentNodeId && NODE_DATA[currentNodeId]) {
         clipboard = {
          type: "node",
          data: JSON.parse(JSON.stringify(NODE_DATA[currentNodeId])),
          size: savedSizes[currentNodeId],
          style: savedStyles[currentNodeId] ? JSON.parse(JSON.stringify(savedStyles[currentNodeId])) : null
         };
        } else if (currentEdgeId) {
         const edge = EDGE_DATA.list.find(e => e.id === currentEdgeId);
         if (edge) clipboard = { type: "edge", data: JSON.parse(JSON.stringify(edge)) };
        } else if (currentRectId) {
         const rect = RECT_DATA.list.find(r => r.id === currentRectId);
         if (rect) clipboard = { type: "rect", data: JSON.parse(JSON.stringify(rect)) };
        } else if (currentTextId) {
         const text = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (text) clipboard = { type: "text", data: JSON.parse(JSON.stringify(text)) };
        }
       }
       
       if (event.ctrlKey && event.key === "v") {
        event.preventDefault();
        if (!clipboard) return;
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        const centerX = canvasState.panX + (viewWidth / 2);
        const centerY = canvasState.panY + (viewHeight / 2);
        
        if (clipboard.type === "node") {
         const data = clipboard.data;
         let newName = data.name + " copy";
         let counter = 1;
         while (Object.values(NODE_DATA).some(n => n.name === newName)) {
          newName = data.name + " copy " + counter;
          counter++;
         }
         let newId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
         counter = 1;
         while (NODE_DATA[newId]) {
          newId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-") + "-" + counter;
          counter++;
         }
         pushUndo("paste node");
         NODE_DATA[newId] = { ...data, name: newName };
         savedPositions[newId] = { x: centerX, y: centerY };
         if (clipboard.size) savedSizes[newId] = clipboard.size;
         if (clipboard.style) savedStyles[newId] = JSON.parse(JSON.stringify(clipboard.style));
         forgeTheTopology();
         claimTheImmortal(newId);
        } else if (clipboard.type === "edge") {
         pushUndo("paste edge");
         const newEdge = { ...clipboard.data, id: "edge-" + Date.now() };
         EDGE_DATA.list.push(newEdge);
         
         forgeTheTopology();
         selectTheConnection(newEdge.id);
        } else if (clipboard.type === "rect") {
         pushUndo("paste rect");
         const newRect = { ...clipboard.data, id: "rect-" + Date.now(), x: centerX - (clipboard.data.width || 100) / 2, y: centerY - (clipboard.data.height || 100) / 2 };
         RECT_DATA.list.push(newRect);
         forgeTheTopology();
         selectTheRect(newRect.id);
        } else if (clipboard.type === "text") {
         pushUndo("paste text");
         const newText = { ...clipboard.data, id: "text-" + Date.now(), x: centerX, y: centerY };
         TEXT_DATA.list.push(newText);
         forgeTheTopology();
         showTextPanel(newText.id);
        }
       }
       
       if (event.key === "Delete") {
        event.preventDefault();
        const totalSelected = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
        if (totalSelected > 0) {
         deleteSelected();
        } else if (currentNodeId && NODE_DATA[currentNodeId]) {
         challengeTheImmortal(`Delete node "${NODE_DATA[currentNodeId].name}"?`, () => {
          pushUndo("delete node");
          delete NODE_DATA[currentNodeId];
          delete savedPositions[currentNodeId];
          delete savedSizes[currentNodeId];
          delete savedStyles[currentNodeId];
          EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== currentNodeId && e.to !== currentNodeId);
          currentNodeId = null;
          
          forgeTheTopology();
          document.getElementById("node-panel").style.display = "none";
         });
        } else if (currentEdgeId) {
         challengeTheImmortal("Delete this line?", () => {
          pushUndo("delete edge");
          EDGE_DATA.list = EDGE_DATA.list.filter(e => e.id !== currentEdgeId);
          currentEdgeId = null;
          
          forgeTheTopology();
          document.getElementById("edge-panel").style.display = "none";
         });
        } else if (currentRectId) {
         challengeTheImmortal("Delete this zone?", () => {
          pushUndo("delete rect");
          RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== currentRectId);
          currentRectId = null;
          forgeTheTopology();
          document.getElementById("rect-panel").style.display = "none";
         });
        } else if (currentTextId) {
         const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (textItem) {
          challengeTheImmortal(`Delete text "${textItem.content.substring(0, 30)}..."?`, () => {
           pushUndo("delete text");
           TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== currentTextId);
           currentTextId = null;
           forgeTheTopology();
           document.getElementById("text-panel").style.display = "none";
          });
         }
        }
       }
      
       if (event.ctrlKey && event.key === "a") {
        event.preventDefault();
        Object.keys(NODE_DATA).forEach(id => selectedNodes.add(id));
        EDGE_DATA.list.forEach(e => selectedEdges.add(e.id));
        RECT_DATA.list.forEach(r => selectedRects.add(r.id));
        TEXT_DATA.list.forEach(t => selectedTexts.add(t.id));
        updateNodeSelection();
       }
       
       if (event.key === "Escape") {
        clearSelection();
        clearSearchHighlight();
       }
      
       if (event.ctrlKey && event.key === "d") {
        event.preventDefault();
        if (currentNodeId && NODE_DATA[currentNodeId]) {
         cloneNode(currentNodeId);
        } else if (currentEdgeId) {
         const edge = EDGE_DATA.list.find(e => e.id === currentEdgeId);
         if (edge) {
          pushUndo("clone edge");
          const newEdge = { ...JSON.parse(JSON.stringify(edge)), id: "edge-" + Date.now() };
          EDGE_DATA.list.push(newEdge);
          
          forgeTheTopology();
          selectTheConnection(newEdge.id);
         }
        } else if (currentRectId) {
         const rect = RECT_DATA.list.find(r => r.id === currentRectId);
         if (rect) {
          pushUndo("clone rect");
          const newRect = { ...JSON.parse(JSON.stringify(rect)), id: "rect-" + Date.now(), x: rect.x + 50, y: rect.y + 50 };
          RECT_DATA.list.push(newRect);
          forgeTheTopology();
          selectTheRect(newRect.id);
         }
        } else if (currentTextId) {
         const text = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (text) {
          pushUndo("clone text");
          const newText = { ...JSON.parse(JSON.stringify(text)), id: "text-" + Date.now(), x: text.x + 50, y: text.y + 50 };
          TEXT_DATA.list.push(newText);
          forgeTheTopology();
          showTextPanel(newText.id);
         }
        }
       }
      }
      
      function saveRollbackVersion(description = "Auto-save") {
        const version = {
          timestamp: Date.now(),
          description,
          data: captureTheQuickening()
        };
        
        try {
          const stored = localStorage.getItem(ROLLBACK_STORAGE_KEY);
          rollbackVersions = stored ? JSON.parse(stored) : [];
        } catch (e) {
          rollbackVersions = [];
        }
        
        rollbackVersions.unshift(version);
        
        if (rollbackVersions.length > MAX_ROLLBACK_VERSIONS) {
          rollbackVersions = rollbackVersions.slice(0, MAX_ROLLBACK_VERSIONS);
        }
        
        try {
          localStorage.setItem(ROLLBACK_STORAGE_KEY, JSON.stringify(rollbackVersions));
        } catch (e) {
          console.warn("Failed to save rollback version:", e);
        }
      }
      
      function loadRollbackVersions() {
        try {
          const stored = localStorage.getItem(ROLLBACK_STORAGE_KEY);
          rollbackVersions = stored ? JSON.parse(stored) : [];
          displayRollbackVersions();
        } catch (e) {
          console.warn("Failed to load rollback versions:", e);
          rollbackVersions = [];
        }
      }
      
      function displayRollbackVersions() {
        const listEl = document.getElementById("rollback-list");
        if (!listEl) return;
        
        if (rollbackVersions.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No version history yet. Versions are saved automatically when you save the file.</div>';
          return;
        }
        
        listEl.innerHTML = rollbackVersions.map((version, index) => {
          const date = new Date(version.timestamp);
          const timeStr = date.toLocaleString();
          const nodeCount = Object.keys(version.data.nodeData || {}).length;
          const edgeCount = (version.data.edgeData?.list || []).length;
          
          return `
            <div class="version-item" onclick="restoreRollbackVersion(${index})">
              <div class="version-info">
                <div class="timestamp">${timeStr}</div>
                <div class="details">${version.description} • ${nodeCount} nodes • ${edgeCount} connections</div>
              </div>
              <div class="version-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteRollbackVersion(${index})" title="Delete this version">🗑️</button>
              </div>
            </div>
          `;
        }).join('');
      }
      
      function restoreRollbackVersion(index) {
        if (!confirm(`Restore version from ${new Date(rollbackVersions[index].timestamp).toLocaleString()}?\n\nYour current work will be lost unless you save first.`)) {
          return;
        }
        
        const version = rollbackVersions[index];
        const data = version.data;
        
        NODE_DATA = data.nodeData || {};
        EDGE_DATA = data.edgeData || { list: [] };
        RECT_DATA = data.rectData || { list: [] };
        TEXT_DATA = data.textData || { list: [] };
        EDGE_LEGEND = data.edgeLegend || {};
        savedPositions = data.nodePositions || {};
        savedSizes = data.nodeSizes || {};
        savedStyles = data.nodeStyles || {};
        PAGE_STATE = data.page || PAGE_STATE;
        
        if (data.canvas) {
          canvasState.zoom = data.canvas.zoom;
          canvasState.panX = data.canvas.panX;
          canvasState.panY = data.canvas.panY;
        }
        
        wieldThePower();
        forgeTheTopology();
        
        document.getElementById("rollback-modal").classList.remove("active");
        
        logAuditEvent("rollback", `Restored version from ${new Date(version.timestamp).toLocaleString()}`);
      }
      
      function deleteRollbackVersion(index) {
        if (!confirm("Delete this version from history?")) return;
        
        rollbackVersions.splice(index, 1);
        try {
          localStorage.setItem(ROLLBACK_STORAGE_KEY, JSON.stringify(rollbackVersions));
        } catch (e) {
          console.warn("Failed to delete version:", e);
        }
        displayRollbackVersions();
      }
      
      function clearRollbackHistory() {
        if (!confirm("Clear all version history?\n\nThis cannot be undone.")) return;
        
        rollbackVersions = [];
        localStorage.removeItem(ROLLBACK_STORAGE_KEY);
        displayRollbackVersions();
      }
      
      function createManualSnapshot() {
        const description = prompt("Enter a description for this snapshot:", "Manual snapshot");
        if (!description) return;
        
        saveRollbackVersion(description);
        displayRollbackVersions();
      }
      
      function switchTab(index) {
        if (index === currentTabIndex) return;
        
        const currentTab = documentTabs[currentTabIndex];
        currentTab.nodes = JSON.parse(JSON.stringify(NODE_DATA));
        currentTab.edges = JSON.parse(JSON.stringify(EDGE_DATA));
        currentTab.positions = JSON.parse(JSON.stringify(savedPositions));
        currentTab.sizes = JSON.parse(JSON.stringify(savedSizes));
        currentTab.styles = JSON.parse(JSON.stringify(savedStyles));
        currentTab.legend = JSON.parse(JSON.stringify(EDGE_LEGEND));
        currentTab.rects = JSON.parse(JSON.stringify(RECT_DATA));
        currentTab.texts = JSON.parse(JSON.stringify(TEXT_DATA));
        currentTab.pageState = JSON.parse(JSON.stringify(PAGE_STATE));
      
        currentTabIndex = index;
        const newTab = documentTabs[index];
        NODE_DATA = JSON.parse(JSON.stringify(newTab.nodes));
        EDGE_DATA = JSON.parse(JSON.stringify(newTab.edges));
        savedPositions = JSON.parse(JSON.stringify(newTab.positions));
        savedSizes = JSON.parse(JSON.stringify(newTab.sizes));
        savedStyles = JSON.parse(JSON.stringify(newTab.styles));
        EDGE_LEGEND = JSON.parse(JSON.stringify(newTab.legend));
        RECT_DATA = JSON.parse(JSON.stringify(newTab.rects));
        TEXT_DATA = JSON.parse(JSON.stringify(newTab.texts));
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, newTab.pageState || {});
        wieldThePower();
        document.title = PAGE_STATE.title || newTab.name;
        document.getElementById("page-title").textContent = PAGE_STATE.title || newTab.name;
        forgeTheTopology();
        currentNodeId = null;
        currentEdgeId = null;
        currentTextId = null;
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        displayTabs();
        
        logAuditEvent("tab", `Switched to tab: ${newTab.name}`);
      }
      
      function createNewTab() {
        const nameInput = document.getElementById("new-tab-name");
        const name = nameInput.value.trim();
        
        if (!name) {
          alert("Please enter a tab name");
          return;
        }
        
        const newTab = {
          id: `tab-${Date.now()}`,
          name,
          nodes: {},
          edges: { list: [] },
          positions: {},
          sizes: {},
          styles: {},
          legend: {},
          rects: { list: [] },
          texts: { list: [] },
      pageState: null
        };
        
        documentTabs.push(newTab);
        nameInput.value = "";
        displayTabs();
        
        logAuditEvent("tab", `Created new tab: ${name}`);
      }
      
      function renameTab(index) {
        const tab = documentTabs[index];
        const newName = prompt("Enter new name:", tab.name);
        if (!newName || newName === tab.name) return;
        
        tab.name = newName;
        displayTabs();
        
        logAuditEvent("tab", `Renamed tab to: ${newName}`);
      }
      
      function deleteTab(index) {
        if (documentTabs.length === 1) {
          alert("Cannot delete the last tab");
          return;
        }
        
        if (!confirm(`Delete tab "${documentTabs[index].name}"?`)) return;
        
        documentTabs.splice(index, 1);
        
        if (currentTabIndex >= documentTabs.length) {
          currentTabIndex = documentTabs.length - 1;
        }
        
        if (currentTabIndex === index) {
          switchTab(currentTabIndex);
        }
        
        displayTabs();
      }
      
      function displayTabs() {
        const listEl = document.getElementById("tabs-list");
        if (!listEl) return;
        
        listEl.innerHTML = documentTabs.map((tab, index) => {
          const nodeCount = Object.keys(tab.nodes).length;
          const edgeCount = tab.edges.list.length;
          const isActive = index === currentTabIndex;
          
          return `
            <div class="tab-item ${isActive ? 'active' : ''}" onclick="switchTab(${index})">
              <div class="tab-name">${tab.name}</div>
              <div class="tab-stats">${nodeCount} nodes • ${edgeCount} connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(${index})" title="Rename tab">✏️</button>
                ${documentTabs.length > 1 ? '<button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(${index})" title="Delete tab">🗑️</button>' : ''}
              </div>
            </div>
          `;
        }).join('');
      }
      
      function logAuditEvent(type, description, details = {}) {
        const event = {
          timestamp: Date.now(),
          type,
          description,
          details,
          tab: documentTabs[currentTabIndex]?.name || "Main"
        };
        
        auditLog.unshift(event);
        
        if (auditLog.length > MAX_AUDIT_ENTRIES) {
          auditLog = auditLog.slice(0, MAX_AUDIT_ENTRIES);
        }
      
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to save audit log:", e);
        }
      }
      
      function loadAuditLog() {
        let embeddedLog = [];
        let localLog = [];
        try {
          const stateScript = document.getElementById("topology-state");
          if (stateScript) {
            const stateData = JSON.parse(stateScript.textContent);
            if (stateData.auditLog && Array.isArray(stateData.auditLog)) {
              embeddedLog = stateData.auditLog;
            }
          }
        } catch (e) {
          console.warn("Failed to load embedded audit log:", e);
        }
        try {
          const stored = localStorage.getItem(AUDIT_STORAGE_KEY);
          if (stored) {
            localLog = JSON.parse(stored);
          }
        } catch (e) {
          console.warn("Failed to load localStorage audit log:", e);
        }
        const merged = [...embeddedLog, ...localLog];
        const seen = new Set();
        auditLog = merged.filter(entry => {
          const key = entry.timestamp + entry.description;
          if (seen.has(key)) return false;
          seen.add(key);
          return true;
        }).sort((a, b) => b.timestamp - a.timestamp);
        if (auditLog.length > MAX_AUDIT_ENTRIES) {
          auditLog = auditLog.slice(0, MAX_AUDIT_ENTRIES);
        }
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to sync audit log:", e);
        }
      }
      
      function displayAuditLog(filter = "all") {
        const listEl = document.getElementById("audit-log-list");
        if (!listEl) return;
        
        const filtered = filter === "all" ? auditLog : auditLog.filter(e => e.type === filter);
        
        if (filtered.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No audit entries yet</div>';
          return;
        }
        
        listEl.innerHTML = filtered.map(event => {
          const date = new Date(event.timestamp);
          const timeStr = date.toLocaleString();
          
          return `
            <div class="audit-entry ${event.type}">
              <div class="time">[${timeStr}] ${event.tab}</div>
              <div class="action">[${event.type.toUpperCase()}] ${event.description}</div>
            </div>
          `;
        }).join('');
      }
      
      function clearAuditLog() {
        if (!confirm("Clear all audit log entries?\n\nThis cannot be undone.")) return;
        
        auditLog = [];
        localStorage.removeItem(AUDIT_STORAGE_KEY);
        displayAuditLog();
      }
      
      function exportAuditLog() {
        if (auditLog.length === 0) {
          alert("No audit entries to export");
          return;
        }
        
        const csv = [
          ["Timestamp", "Tab", "Type", "Description"],
          ...auditLog.map(e => [
            new Date(e.timestamp).toISOString(),
            e.tab,
            e.type,
            e.description
          ])
        ].map(row => row.map(cell => `"${cell}"`).join(",")).join("\n");
        
        const blob = new Blob([csv], { type: "text/csv" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `audit-log-${Date.now()}.csv`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }
      
      let currentSecretName = null;
      
      function createNewSecret() {
        const nameInput = document.getElementById("new-secret-name");
        const name = nameInput.value.trim();
        
        if (!name) {
          alert("Please enter a note name");
          return;
        }
        
        if (encryptedSections[name]) {
          alert("A note with this name already exists");
          return;
        }
        
        currentSecretName = name;
        encryptedSections[name] = { encrypted: false, data: "" };
        nameInput.value = "";
        
        document.getElementById("secret-editor-title").textContent = `New note: ${name}`;
        document.getElementById("secret-editor-content").value = "";
        document.getElementById("secrets-modal").classList.remove("active");
        document.getElementById("secret-editor-modal").classList.add("active");
        
        displaySecrets();
      }
      
      function editSecret(name) {
        currentSecretName = name;
        const section = encryptedSections[name];
        
        if (section.encrypted) {
          const password = prompt(`Enter password to decrypt "${name}":`);
          if (!password) return;
          
          try {
            decryptData(section.data, password).then(decrypted => {
              document.getElementById("secret-editor-title").textContent = `Edit note: ${name}`;
              document.getElementById("secret-editor-content").value = decrypted;
              document.getElementById("secrets-modal").classList.remove("active");
              document.getElementById("secret-editor-modal").classList.add("active");
            }).catch(e => {
              alert("Failed to decrypt. Wrong password?");
            });
          } catch (e) {
            alert("Failed to decrypt. Wrong password?");
          }
        } else {
          document.getElementById("secret-editor-title").textContent = `Edit note: ${name}`;
          document.getElementById("secret-editor-content").value = section.data;
          document.getElementById("secrets-modal").classList.remove("active");
          document.getElementById("secret-editor-modal").classList.add("active");
        }
      }
      
      async function saveSecret() {
        if (!currentSecretName) return;
        
        const content = document.getElementById("secret-editor-content").value;
        const autoEncrypt = document.getElementById("secret-auto-encrypt").checked;
        
        if (autoEncrypt) {
          const password = prompt(`Enter password to encrypt "${currentSecretName}":`);
          if (!password) return;
          
          const confirmPassword = prompt("Confirm password:");
          if (password !== confirmPassword) {
            alert("Passwords do not match");
            return;
          }
          
          try {
            const encrypted = await encryptData(content, password);
            encryptedSections[currentSecretName] = { encrypted: true, data: encrypted };
          } catch (e) {
            alert("Encryption failed: " + e.message);
            return;
          }
        } else {
          encryptedSections[currentSecretName] = { encrypted: false, data: content };
        }
        
        closeSecretEditor();
        displaySecrets();
        
        logAuditEvent("secret", `Saved note: ${currentSecretName}`);
      }
      
      function closeSecretEditor() {
        document.getElementById("secret-editor-modal").classList.remove("active");
        document.getElementById("secrets-modal").classList.add("active");
        currentSecretName = null;
      }
      
      function deleteSecret(name) {
        if (!confirm(`Delete note "${name}"?`)) return;
        
        delete encryptedSections[name];
        displaySecrets();
        
        logAuditEvent("secret", `Deleted note: ${name}`);
      }
      
      function displaySecrets() {
        const listEl = document.getElementById("secrets-list");
        if (!listEl) return;
        
        const secrets = Object.keys(encryptedSections);
        
        if (secrets.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No notes yet</div>';
          return;
        }
        
        listEl.innerHTML = secrets.map(name => {
          const section = encryptedSections[name];
          const status = section.encrypted ? "🔒 Encrypted" : "🔓 Plaintext";
          
          return `
            <div class="secret-item">
              <div class="secret-name">${name}</div>
              <div class="secret-status">${status}</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="editSecret('${name}')" title="Edit note">✏️</button>
                <button class="btn-cancel" onclick="deleteSecret('${name}')" title="Delete note">🗑️</button>
              </div>
            </div>
          `;
        }).join('');
      }
      
      let rafId = null;
      let lastRender = 0;
      const RENDER_THROTTLE = 16;
      
      function setupDragToCreate() {
        const addNodeBtn = document.getElementById("add-node-btn");
        const addRackBtn = document.getElementById("add-rack-btn");
        const canvas = document.getElementById("map");
        
        if (!addNodeBtn || !addRackBtn || !canvas) return;
        
        let dragType = null;
        
        [addNodeBtn, addRackBtn].forEach(btn => {
          btn.setAttribute("draggable", "true");
          
          btn.addEventListener("dragstart", e => {
            dragType = btn.id === "add-node-btn" ? "node" : "rack";
            e.dataTransfer.effectAllowed = "copy";
            e.dataTransfer.setData("text/plain", dragType);
          });
        });
        
        canvas.addEventListener("dragover", e => {
          if (dragType) {
            e.preventDefault();
            e.dataTransfer.dropEffect = "copy";
          }
        });
        
        canvas.addEventListener("drop", e => {
          if (!dragType) return;
          
          e.preventDefault();
          
          const rect = canvas.getBoundingClientRect();
          const x = (e.clientX - rect.left) / canvasState.zoom + canvasState.panX;
          const y = (e.clientY - rect.top) / canvasState.zoom + canvasState.panY;
          
          if (dragType === "node") {
            createNodeAtPosition(x, y);
          } else if (dragType === "rack") {
            createRackAtPosition(x, y);
          }
          
          dragType = null;
        });
      }
      
      function createNodeAtPosition(x, y) {
        const timestamp = Date.now();
        const newId = `host-${timestamp}`;
        
        NODE_DATA[newId] = {
          name: "New Node",
          ip: "0.0.0.0",
          shape: "server",
          role: "",
          tags: [],
          notes: "",
          layer: "physical",
          isRack: false
        };
        
        savedPositions[newId] = { x, y };
        savedSizes[newId] = 55;
        
        pushUndo("create node");
        forgeTheTopology();
        claimTheImmortal(newId);
        
        logAuditEvent("node", `Created node at (${Math.round(x)}, ${Math.round(y)})`);
      }
      
      function createRackAtPosition(x, y) {
        const timestamp = Date.now();
        const newId = `rack-${timestamp}`;
        
        NODE_DATA[newId] = {
          name: "New Rack",
          ip: "",
          shape: "server",
          role: "rack",
          tags: [],
          notes: "",
          layer: "physical",
          isRack: true,
          rackCapacity: 42
        };
        
        savedPositions[newId] = { x, y };
        savedSizes[newId] = 55;
        
        pushUndo("create rack");
        populateRackDropdown();
        forgeTheTopology();
        claimTheImmortal(newId);
        
        logAuditEvent("rack", `Created rack at (${Math.round(x)}, ${Math.round(y)})`);
      }
      
      document.addEventListener("keydown", handleKeyDown);
      
      document.getElementById("save-file-btn").addEventListener("click", becomeImmortal);
      const addNodeBtn = document.getElementById("add-node-btn");
      const addNodeModal = document.getElementById("add-node-modal");
      const addNodeCancel = document.getElementById("add-node-cancel");
      const addNodeSave = document.getElementById("add-node-save");
      
      const undoBtn = document.getElementById("undo-btn");
      const redoBtn = document.getElementById("redo-btn");
      if (undoBtn) undoBtn.addEventListener("click", undo);
      if (redoBtn) redoBtn.addEventListener("click", redo);
      
      const backToTopologyBtn = document.getElementById("back-to-topology-btn");
      if (backToTopologyBtn) {
       backToTopologyBtn.addEventListener("click", exitRack);
      }
      
      const canvasViewport = document.getElementById("canvas-viewport");
      if (canvasViewport) {
       canvasViewport.addEventListener("dblclick", (e) => {
        if (currentView.mode === "rack" && e.target.id === "map") {
         exitRack();
        }
       });
      }
      
      const layersBtn = document.getElementById("layers-btn");
      const layerModal = document.getElementById("layer-modal");
      const layerModalClose = document.getElementById("layer-modal-close");
      if (layersBtn && layerModal) {
       layersBtn.addEventListener("click", () => {
        layerModal.classList.add("active");
       });
      }
      if (layerModalClose && layerModal) {
       layerModalClose.addEventListener("click", () => {
        layerModal.classList.remove("active");
       });
      }
      if (layerModal) {
       layerModal.addEventListener("click", (e) => {
        if (e.target === layerModal) {
         layerModal.classList.remove("active");
        }
       });
      }
      
      ["physical", "logical", "security", "application"].forEach(layer => {
       const checkbox = document.getElementById(`layer-${layer}`);
       if (checkbox) {
        checkbox.addEventListener("change", applyLayerFilter);
       }
      });
            
      const tabsBtn = document.getElementById("tabs-btn");
      const tabsModal = document.getElementById("tabs-modal");
      const tabsModalClose = document.getElementById("tabs-modal-close");
      
      if (tabsBtn && tabsModal) {
        tabsBtn.addEventListener("click", () => {
          displayTabs();
          tabsModal.classList.add("active");
        });
      }
      
      if (tabsModalClose && tabsModal) {
        tabsModalClose.addEventListener("click", () => {
          tabsModal.classList.remove("active");
        });
      }
      
      if (tabsModal) {
        tabsModal.addEventListener("click", (e) => {
          if (e.target === tabsModal) {
            tabsModal.classList.remove("active");
          }
        });
      }
      
      const rollbackBtn = document.getElementById("rollback-btn");
      const rollbackModal = document.getElementById("rollback-modal");
      const rollbackModalClose = document.getElementById("rollback-modal-close");
      
      if (rollbackBtn && rollbackModal) {
        rollbackBtn.addEventListener("click", () => {
          loadRollbackVersions();
          rollbackModal.classList.add("active");
        });
      }
      
      if (rollbackModalClose && rollbackModal) {
        rollbackModalClose.addEventListener("click", () => {
          rollbackModal.classList.remove("active");
        });
      }
      
      if (rollbackModal) {
        rollbackModal.addEventListener("click", (e) => {
          if (e.target === rollbackModal) {
            rollbackModal.classList.remove("active");
          }
        });
      }
      
      const auditLogBtn = document.getElementById("audit-log-btn");
      const auditLogModal = document.getElementById("audit-log-modal");
      const auditLogModalClose = document.getElementById("audit-log-modal-close");
      const auditFilter = document.getElementById("audit-filter");
      
      if (auditLogBtn && auditLogModal) {
        auditLogBtn.addEventListener("click", () => {
          loadAuditLog();
          displayAuditLog();
          auditLogModal.classList.add("active");
        });
      }
      
      if (auditFilter) {
        auditFilter.addEventListener("change", (e) => {
          displayAuditLog(e.target.value);
        });
      }
      
      if (auditLogModalClose && auditLogModal) {
        auditLogModalClose.addEventListener("click", () => {
          auditLogModal.classList.remove("active");
        });
      }
      
      if (auditLogModal) {
        auditLogModal.addEventListener("click", (e) => {
          if (e.target === auditLogModal) {
            auditLogModal.classList.remove("active");
          }
        });
      }
      
      const secretsBtn = document.getElementById("secrets-btn");
      const secretsModal = document.getElementById("secrets-modal");
      const secretsModalClose = document.getElementById("secrets-modal-close");
      const secretEditorModal = document.getElementById("secret-editor-modal");
      
      if (secretsBtn && secretsModal) {
        secretsBtn.addEventListener("click", () => {
          displaySecrets();
          secretsModal.classList.add("active");
        });
      }
      
      if (secretsModalClose && secretsModal) {
        secretsModalClose.addEventListener("click", () => {
          secretsModal.classList.remove("active");
        });
      }
      
      if (secretsModal) {
        secretsModal.addEventListener("click", (e) => {
          if (e.target === secretsModal) {
            secretsModal.classList.remove("active");
          }
        });
      }
      
      if (secretEditorModal) {
        secretEditorModal.addEventListener("click", (e) => {
          if (e.target === secretEditorModal) {
            closeSecretEditor();
          }
        });
      }
      
      loadAuditLog();
      setupDragToCreate();
      
      ["physical", "logical", "security", "application"].forEach(layer => {
       const checkbox = document.getElementById(`layer-${layer}`);
       if (checkbox) {
        checkbox.addEventListener("change", applyLayerFilter);
       }
      });
      
      const layerSelect = document.getElementById("node-layer");
      if (layerSelect) {
       layerSelect.addEventListener("change", (e) => {
        if (currentNodeId) {
         pushUndo("change layer");
         NODE_DATA[currentNodeId].layer = e.target.value;
         forgeTheTopology();
        }
       });
      }
      
       const assignedRackSelect = document.getElementById("node-assigned-rack");
       if (assignedRackSelect) {
      assignedRackSelect.addEventListener("change", (e) => {
      if (currentNodeId) {
      pushUndo("change assigned rack");
      EDGE_DATA.list = EDGE_DATA.list.filter(edge => edge.from !== currentNodeId && edge.to !== currentNodeId);
      NODE_DATA[currentNodeId].assignedRack = e.target.value;
      forgeTheTopology();
      claimTheImmortal(currentNodeId);
      }
      });
       }
      
      const rackCapacitySelect = document.getElementById("node-rack-capacity");
      if (rackCapacitySelect) {
       rackCapacitySelect.addEventListener("change", (e) => {
        if (currentNodeId) {
         pushUndo("change rack capacity");
         NODE_DATA[currentNodeId].rackCapacity = e.target.value;
         forgeTheTopology();
        }
       });
      }
      
      const bulkToolbarClose = document.getElementById("bulk-toolbar-close");
      if (bulkToolbarClose) {
       bulkToolbarClose.addEventListener("click", clearSelection);
      }
      
      const bulkAlignLeft = document.getElementById("bulk-align-left");
      if (bulkAlignLeft) {
       bulkAlignLeft.addEventListener("click", () => alignSelectedNodes("left"));
      }
      
      const bulkAlignRight = document.getElementById("bulk-align-right");
      if (bulkAlignRight) {
       bulkAlignRight.addEventListener("click", () => alignSelectedNodes("right"));
      }
      
      const bulkAlignTop = document.getElementById("bulk-align-top");
      if (bulkAlignTop) {
       bulkAlignTop.addEventListener("click", () => alignSelectedNodes("top"));
      }
      
      const bulkAlignBottom = document.getElementById("bulk-align-bottom");
      if (bulkAlignBottom) {
       bulkAlignBottom.addEventListener("click", () => alignSelectedNodes("bottom"));
      }
      
      const bulkDistributeH = document.getElementById("bulk-distribute-h");
      if (bulkDistributeH) {
       bulkDistributeH.addEventListener("click", () => distributeSelectedNodes("horizontal"));
      }
      
      const bulkDistributeV = document.getElementById("bulk-distribute-v");
      if (bulkDistributeV) {
       bulkDistributeV.addEventListener("click", () => distributeSelectedNodes("vertical"));
      }
      
      const bulkClone = document.getElementById("bulk-clone");
      if (bulkClone) {
       bulkClone.addEventListener("click", () => {
        if (selectedNodes.size === 0) return;
        pushUndo("clone selected");
        const nodesToClone = Array.from(selectedNodes);
        selectedNodes.clear();
        nodesToClone.forEach(id => {
         cloneNode(id);
         selectedNodes.add(currentNodeId);
        });
        updateNodeSelection();
       });
      }
      
      const bulkDelete = document.getElementById("bulk-delete");
      if (bulkDelete) {
       bulkDelete.addEventListener("click", deleteSelected);
      }
      
      const bulkMobileBtn = document.getElementById("bulk-mobile-btn");
      const bulkActionsModal = document.getElementById("bulk-actions-modal");
      const bulkModalClose = document.getElementById("bulk-modal-close");
      
      if (bulkMobileBtn) {
       bulkMobileBtn.addEventListener("click", () => {
        if (bulkActionsModal) bulkActionsModal.style.display = "block";
       });
      }
      
      if (bulkModalClose) {
       bulkModalClose.addEventListener("click", () => {
        if (bulkActionsModal) bulkActionsModal.style.display = "none";
       });
      }
      
      const closeModalAfterAction = () => {
       if (bulkActionsModal) bulkActionsModal.style.display = "none";
      };
      
      const bulkAlignLeftMobile = document.getElementById("bulk-align-left-mobile");
      if (bulkAlignLeftMobile) {
       bulkAlignLeftMobile.addEventListener("click", () => {
        alignSelectedNodes("left");
        closeModalAfterAction();
       });
      }
      
      const bulkAlignRightMobile = document.getElementById("bulk-align-right-mobile");
      if (bulkAlignRightMobile) {
       bulkAlignRightMobile.addEventListener("click", () => {
        alignSelectedNodes("right");
        closeModalAfterAction();
       });
      }
      
      const bulkAlignTopMobile = document.getElementById("bulk-align-top-mobile");
      if (bulkAlignTopMobile) {
       bulkAlignTopMobile.addEventListener("click", () => {
        alignSelectedNodes("top");
        closeModalAfterAction();
       });
      }
      
      const bulkAlignBottomMobile = document.getElementById("bulk-align-bottom-mobile");
      if (bulkAlignBottomMobile) {
       bulkAlignBottomMobile.addEventListener("click", () => {
        alignSelectedNodes("bottom");
        closeModalAfterAction();
       });
      }
      
      const bulkDistributeHMobile = document.getElementById("bulk-distribute-h-mobile");
      if (bulkDistributeHMobile) {
       bulkDistributeHMobile.addEventListener("click", () => {
        distributeSelectedNodes("horizontal");
        closeModalAfterAction();
       });
      }
      
      const bulkDistributeVMobile = document.getElementById("bulk-distribute-v-mobile");
      if (bulkDistributeVMobile) {
       bulkDistributeVMobile.addEventListener("click", () => {
        distributeSelectedNodes("vertical");
        closeModalAfterAction();
       });
      }
      
      const bulkCloneMobile = document.getElementById("bulk-clone-mobile");
      if (bulkCloneMobile) {
       bulkCloneMobile.addEventListener("click", () => {
        if (selectedNodes.size === 0) return;
        pushUndo("clone selected");
        const nodesToClone = Array.from(selectedNodes);
        selectedNodes.clear();
        nodesToClone.forEach(id => {
         cloneNode(id);
         selectedNodes.add(currentNodeId);
        });
        updateNodeSelection();
        closeModalAfterAction();
       });
      }
      
      const bulkDeleteMobile = document.getElementById("bulk-delete-mobile");
      if (bulkDeleteMobile) {
       bulkDeleteMobile.addEventListener("click", () => {
        deleteSelected();
        closeModalAfterAction();
       });
      }
      
      const bulkLockMobile = document.getElementById("bulk-lock-mobile");
      if (bulkLockMobile) {
       bulkLockMobile.addEventListener("click", () => {
        toggleLockSelected();
        closeModalAfterAction();
       });
      }
      
      const bulkGroupMobile = document.getElementById("bulk-group-mobile");
      if (bulkGroupMobile) {
       bulkGroupMobile.addEventListener("click", () => {
        toggleGroupSelected();
        closeModalAfterAction();
       });
      }
      
      const bulkClearMobile = document.getElementById("bulk-clear-mobile");
      if (bulkClearMobile) {
       bulkClearMobile.addEventListener("click", () => {
        clearSelection();
        closeModalAfterAction();
       });
      }
      
      const searchInput = document.getElementById("search-nodes");
      if (searchInput) {
       searchInput.addEventListener("input", (e) => {
        searchNodes(e.target.value);
       });
      }
      
      addNodeBtn.addEventListener("click", () => {
	  if (isViewOnly()) return;
       document.getElementById("new-node-name").value = "";
       document.getElementById("new-node-ip").value = "";
       document.getElementById("new-node-tags").value = "";
       document.getElementById("new-node-shape").value = "circle";
       addNodeModal.classList.add("active");
       document.getElementById("new-node-name").focus();
      });
      
      const addRackBtn = document.getElementById("add-rack-btn");
      const addRackModal = document.getElementById("add-rack-modal");
      const addRackCancel = document.getElementById("add-rack-cancel");
      const addRackSave = document.getElementById("add-rack-save");
      
      if (addRackBtn && addRackModal) {
       addRackBtn.addEventListener("click", () => {
	   if (isViewOnly()) return;
        document.getElementById("new-rack-name").value = "";
        document.getElementById("new-rack-ip").value = "";
        document.getElementById("new-rack-tags").value = "";
        document.getElementById("new-rack-shape").value = "server";
        document.getElementById("new-rack-capacity").value = "42";
        addRackModal.classList.add("active");
        document.getElementById("new-rack-name").focus();
       });
      }
      
      if (addRackCancel && addRackModal) {
       addRackCancel.addEventListener("click", () => {
        addRackModal.classList.remove("active");
       });
      }
      
      if (addRackModal) {
       addRackModal.addEventListener("click", (e) => {
        if (e.target === addRackModal) {
         addRackModal.classList.remove("active");
        }
       });
      }
      
      if (addRackSave && addRackModal) {
       addRackSave.addEventListener("click", () => {
        const name = document.getElementById("new-rack-name").value.trim();
        const ip = document.getElementById("new-rack-ip").value.trim();
        const tagsStr = document.getElementById("new-rack-tags").value.trim();
        const shape = document.getElementById("new-rack-shape").value;
        const capacity = document.getElementById("new-rack-capacity").value;
        
        if (!name) {
         alert("Please enter a rack name.");
         return;
        }
        
        const tags = tagsStr ? tagsStr.split(",").map((t) => t.trim()).filter((t) => t) : [];
        let baseId = name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");
        if (!baseId) baseId = "rack";
        let nodeId = baseId;
        let counter = 1;
        while (NODE_DATA[nodeId]) {
         nodeId = baseId + "-" + counter;
         counter++;
        }
        
        pushUndo("add rack");
        
        NODE_DATA[nodeId] = {
         shape: shape,
         name: name,
         ip: ip || "",
         role: "Rack",
         tags: tags,
         notes: [],
         mac: "",
         rackUnit: "",
         uHeight: "1",
         layer: "physical",
         assignedRack: "",
         rackCapacity: capacity,
         isRack: true,  
         locked: false, 
         groupId: null 
        };
        
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        const centerX = canvasState.panX + (viewWidth / 2);
        const centerY = canvasState.panY + (viewHeight / 2);
        savedPositions[nodeId] = {
         x: centerX,
         y: centerY
        };
        
        addRackModal.classList.remove("active");
        forgeTheTopology();
        claimTheImmortal(nodeId);
       });
       
       ["new-rack-name", "new-rack-ip", "new-rack-tags"].forEach((inputId) => {
        const input = document.getElementById(inputId);
        if (input) {
         input.addEventListener("keypress", (e) => {
          if (e.key === "Enter") {
           addRackSave.click();
          }
         });
        }
       });
      }
      
      addNodeCancel.addEventListener("click", () => {
       addNodeModal.classList.remove("active");
      });
      addNodeModal.addEventListener("click", (e) => {
       if (e.target === addNodeModal) {
        addNodeModal.classList.remove("active");
       }
      });
      addNodeSave.addEventListener("click", () => {
       const name = document.getElementById("new-node-name").value.trim();
       const ip = document.getElementById("new-node-ip").value.trim();
       const tagsStr = document.getElementById("new-node-tags").value.trim();
       const shape = document.getElementById("new-node-shape").value;
       if (!name) {
        alert("Please enter a node name.");
        return;
       }
       const tags = tagsStr ? tagsStr.split(",").map((t) => t.trim()).filter((t) => t) : [];
       let baseId = name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");
       if (!baseId) baseId = "node";
       let nodeId = baseId;
       let counter = 1;
       while (NODE_DATA[nodeId]) {
        nodeId = baseId + "-" + counter;
        counter++;
       }
       NODE_DATA[nodeId] = {
        shape: shape || "circle",
        name: name,
        ip: ip || "0.0.0.0",
        role: "",
        tags: tags,
        notes: [],
        mac: "",
        rackUnit: "",
        uHeight: "1",
        layer: "physical",
        assignedRack: "",  
        rackCapacity: "42",
        isRack: false, 
        locked: false, 
        groupId: null 
       };
       
       if (currentView.mode === "rack" && currentView.rackId) {
        NODE_DATA[nodeId].assignedRack = currentView.rackId;
        NODE_DATA[nodeId].layer = "physical";
        const rackCapacity = getRackCapacity(currentView.rackId);
        const rackUHeight = getRackUHeight(currentView.rackId);
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        const centerY = canvasState.panY + (viewHeight / 2);
        let unit = rackCapacity - Math.round((centerY - RACK_START_Y) / rackUHeight);
        unit = Math.max(1, Math.min(rackCapacity, unit));
        NODE_DATA[nodeId].rackUnit = String(unit);
       }
       
      const viewWidth = CANVAS_WIDTH / canvasState.zoom;
      const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
      const centerX = canvasState.panX + (viewWidth / 2);
      const centerY = canvasState.panY + (viewHeight / 2);
      savedPositions[nodeId] = {
      x: centerX,
      y: centerY
      };
       pushUndo("add node");
       addNodeModal.classList.remove("active");
       forgeTheTopology();
       claimTheImmortal(nodeId);
      });
      ["new-node-name", "new-node-ip", "new-node-tags"].forEach(
       (inputId) => {
        document.getElementById(inputId).addEventListener("keypress", (e) => {
         if (e.key === "Enter") {
          addNodeSave.click();
         }
        });
       }, );
      const clearAllBtn = document.getElementById("clear-all-btn");
      const clearAllModal = document.getElementById("clear-all-modal");
      const clearAllCancel = document.getElementById("clear-all-cancel");
      const clearAllConfirm = document.getElementById("clear-all-confirm");
      clearAllBtn.addEventListener("click", () => {
       clearAllModal.classList.add("active");
      });
      clearAllCancel.addEventListener("click", () => {
       clearAllModal.classList.remove("active");
      });
      clearAllModal.addEventListener("click", (e) => {
       if (e.target === clearAllModal) {
        clearAllModal.classList.remove("active");
       }
      });
      clearAllConfirm.addEventListener("click", () => {
       NODE_DATA = {};
       EDGE_DATA = {
        list: []
       };
       EDGE_LEGEND = {};
       RECT_DATA = { list: [] };
       TEXT_DATA = { list: [] };
       savedPositions = {};
       savedSizes = {};
       savedStyles = {};
       logAuditEvent("clear", "Cleared all data from canvas");
       clearAllModal.classList.remove("active");
       forgeTheTopology();
       document.getElementById("node-panel").style.display = "none";
       document.getElementById("edge-panel").style.display = "none";
       document.getElementById("text-panel").style.display = "none";
       document.getElementById("topology-toolbar").style.display = "none";
       currentNodeId = null;
       currentEdgeId = null;
       currentTextId = null;
      });
      (function addDeleteNodeButton() {
       const nodePanel = document.getElementById("node-panel");
       if (!nodePanel) return;
       let deleteBtn = document.getElementById("delete-node-btn");
       if (!deleteBtn) {
        deleteBtn = document.createElement("button");
        deleteBtn.id = "delete-node-btn";
        deleteBtn.textContent = "Delete Node";
        deleteBtn.style.cssText = "margin-top:15px; padding:10px 16px; background:var(--danger); color:#fff; border:none; border-radius:6px; cursor:pointer; font-size:clamp(14px,1.6vw,18px); font-weight:600; width:100%;";
        nodePanel.appendChild(deleteBtn);
       }
       deleteBtn.addEventListener("click", () => {
        if (!currentNodeId) return;
        const nodeData = NODE_DATA[currentNodeId];
        let confirmMessage;
        let nodesInsideRack = [];
        
        if (nodeData?.isRack) {
         nodesInsideRack = Object.entries(NODE_DATA)
          .filter(([id, n]) => n.assignedRack === currentNodeId)
          .map(([id, n]) => n.name || id);
         if (nodesInsideRack.length > 0) {
          confirmMessage = `Delete rack "${nodeData.name}"?\n\nThis will also delete ${nodesInsideRack.length} node(s) inside:\n• ${nodesInsideRack.join('\n• ')}`;
         } else {
          confirmMessage = `Delete rack "${nodeData.name}"? (empty rack)`;
         }
        } else {
         confirmMessage = `Delete node "${nodeData?.name || currentNodeId}" and all its connections?`;
        }
        
        challengeTheImmortal(confirmMessage, () => {
         pushUndo("delete node");
         if (nodeData?.isRack) {
          Object.keys(NODE_DATA).forEach(id => {
           if (NODE_DATA[id]?.assignedRack === currentNodeId) {
            EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== id && e.to !== id);
            delete NODE_DATA[id];
            delete savedPositions[id];
            delete savedSizes[id];
            delete savedStyles[id];
           }
          });
         }
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== currentNodeId && e.to !== currentNodeId);
         delete NODE_DATA[currentNodeId];
         delete savedPositions[currentNodeId];
         delete savedSizes[currentNodeId];
         delete savedStyles[currentNodeId];
         currentNodeId = null;
         currentEdgeId = null;
         forgeTheTopology();
         const remainingNodes = Object.keys(NODE_DATA);
         if (remainingNodes.length > 0) {
          claimTheImmortal(remainingNodes[0]);
         } else {
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("topology-toolbar").style.display = "none";
         }
        });
       });
      })();
      
      function screenshotCanvas() {
       const svg = document.getElementById("map");
       const svgClone = svg.cloneNode(true);
       const viewBox = svg.getAttribute("viewBox").split(" ").map(Number);
       const [x, y, width, height] = viewBox;
       svgClone.setAttribute("width", width);
       svgClone.setAttribute("height", height);
       svgClone.setAttribute("viewBox", `${x} ${y} ${width} ${height}`);
       const wrapper = document.createElement("div");
       wrapper.style.position = "absolute";
       wrapper.style.left = "-9999px";
       wrapper.appendChild(svgClone);
       document.body.appendChild(wrapper);
      
       function inlineStyles(original, clone) {
        const elements = original.querySelectorAll("*");
        const clonedElements = clone.querySelectorAll("*");
        const rootStyles = getComputedStyle(document.documentElement);
        const bgColor = rootStyles.getPropertyValue("--bg").trim() || "#050608";
        const bgRect = document.createElementNS("http://www.w3.org/2000/svg", "rect", );
        bgRect.setAttribute("x", x);
        bgRect.setAttribute("y", y);
        bgRect.setAttribute("width", width);
        bgRect.setAttribute("height", height);
        bgRect.setAttribute("fill", bgColor);
        clone.insertBefore(bgRect, clone.firstChild);
        elements.forEach((el, index) => {
         const clonedEl = clonedElements[index];
         if (!clonedEl) return;
         const computedStyle = getComputedStyle(el);
         const svgProps = ["fill", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin", "opacity", "font-family", "font-size", "font-weight", "font-style", "text-anchor", "dominant-baseline", "marker-start", "marker-end", ];
         svgProps.forEach((prop) => {
          const value = computedStyle.getPropertyValue(prop);
          if (value && value !== "none" && value !== "normal") {
           clonedEl.style[prop] = value;
          }
         });
         clonedEl.removeAttribute("class");
        });
       }
       inlineStyles(svg, svgClone);
       const svgData = new XMLSerializer().serializeToString(svgClone);
       document.body.removeChild(wrapper);
       const svgBlob = new Blob([svgData], {
        type: "image/svg+xml;charset=utf-8",
       });
       const url = URL.createObjectURL(svgBlob);
       const img = new Image();
       img.onload = function() {
        const canvas = document.createElement("canvas");
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext("2d");
        ctx.drawImage(img, 0, 0);
        canvas.toBlob(function(blob) {
         const link = document.createElement("a");
         const timestamp = new Date().toISOString().slice(0, 10);
         link.download = `topology-${timestamp}.png`;
         link.href = URL.createObjectURL(blob);
         link.click();
         URL.revokeObjectURL(url);
         URL.revokeObjectURL(link.href);
        }, "image/png");
       };
       img.onerror = function() {
        console.error("Failed to load SVG image");
        alert("Screenshot failed. Please try again.");
        URL.revokeObjectURL(url);
       };
       img.src = url;
      }
      
      function exportCanvasSVG() {
       const svg = document.getElementById("map");
       const svgClone = svg.cloneNode(true);
       const viewBox = svg.getAttribute("viewBox").split(" ").map(Number);
       const [x, y, width, height] = viewBox;
       svgClone.setAttribute("width", width);
       svgClone.setAttribute("height", height);
       const rootStyles = getComputedStyle(document.documentElement);
       const bgColor = rootStyles.getPropertyValue("--bg").trim() || "#050608";
       const bgRect = document.createElementNS("http://www.w3.org/2000/svg", "rect", );
       bgRect.setAttribute("x", x);
       bgRect.setAttribute("y", y);
       bgRect.setAttribute("width", width);
       bgRect.setAttribute("height", height);
       bgRect.setAttribute("fill", bgColor);
       svgClone.insertBefore(bgRect, svgClone.firstChild);
       const wrapper = document.createElement("div");
       wrapper.style.position = "absolute";
       wrapper.style.left = "-9999px";
       wrapper.appendChild(svgClone);
       document.body.appendChild(wrapper);
       const elements = svg.querySelectorAll("*");
       const clonedElements = svgClone.querySelectorAll("*");
       elements.forEach((el, index) => {
        const clonedEl = clonedElements[index];
        if (!clonedEl) return;
        const computedStyle = getComputedStyle(el);
        const svgProps = ["fill", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin", "opacity", "font-family", "font-size", "font-weight", "font-style", "text-anchor", "dominant-baseline", "marker-start", "marker-end", ];
        svgProps.forEach((prop) => {
         const value = computedStyle.getPropertyValue(prop);
         if (value && value !== "none" && value !== "normal") {
          clonedEl.setAttribute(prop, value);
         }
        });
        clonedEl.removeAttribute("class");
       });
       const svgData = new XMLSerializer().serializeToString(svgClone);
       document.body.removeChild(wrapper);
       const blob = new Blob([svgData], {
        type: "image/svg+xml;charset=utf-8",
       });
       const url = URL.createObjectURL(blob);
       const link = document.createElement("a");
       const timestamp = new Date().toISOString().slice(0, 10);
       link.download = `topology-${timestamp}.svg`;
       link.href = url;
       link.click();
       URL.revokeObjectURL(url);
      }
      let resizeTimeout;
       window.addEventListener('resize', () => {
       clearTimeout(resizeTimeout);
       resizeTimeout = setTimeout(() => {
       updateDrawToolbarVisibility();
       updateTopologyToolbarVisibility();
       }, 100);
      });
    </script>
  
</body></html>