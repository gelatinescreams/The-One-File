<!DOCTYPE html> 
 <html lang="en" style="--panel: #2f0e0e; --panel-alt: #10141b; --sidebar-bg: #10141b; --btn-bg: #0b0e13; --accent: #a75252; --danger: #f56565; --text-main: #e2e8f0; --text-soft: #94a3b8; --topbar-bg: rgba(9, 12, 20, 0.9); --topbar-border: #1f2533; --topbar-height: 112px; --sidebar-width: 350px; --mobile-footer-height: 40vh; --draw-toolbar-height: 0px; --btn-text: #e2e8f0; --tag-fill: #1e293b; --tag-text: #e2e8f0; --tag-border: #475569; --input-bg: #0b0e13; --input-text: #e2e8f0; --input-border: #1f2937; --input-font: Inter, system-ui, sans-serif; --input-font-size: 14px; --toolbar-bg: #441215; --toolbar-border: #1f2937; --toolbar-text: #94a3b8; --toolbar-btn-bg: #0b0e13; --toolbar-btn-text: #e2e8f0; --minimap-dots: #94a3b8; --canvas-hint-bg: #0f172a; --canvas-hint-color: #94a3b8; --node-fill: #1e293b; --node-stroke: #475569; --node-title: #e2e8f0; --node-sub: #94a3b8; --node-title-size: 18px; --node-sub-size: 13px; --node-font: Inter, system-ui, sans-serif; --default-edge: #475569; --selection-handle: #f59e0b; --selection-handle-size: 8px; --group-indicator: #4fd1c5;"><head>
    <meta charset="UTF-8">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>The One File</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!--
      * ====================================================================================
      * THE ONE FILE
      * "There can be only one". A all in one file topology maker for enterprise or homelab
      *
      * This is your last backup when all others fail. A completely self-contained
      * network topology visualization tool that works as a single HTML file.
      * Open it anywhere, anytime and the idea lives forever.
      * ====================================================================================
      -->
    <style>
      :root {
      color-scheme: dark;
      --bg: #050608;
      --panel: #0b0e13;
      --panel-alt: #10141b;
      --accent: #4fd1c5;
      --danger: #f56565;
      --text-main: #e2e8f0;
      --text-soft: #94a3b8;
      --edge-main: #475569;
      --node-min: 35px;
      --node-max: 70px;
      --topbar-bg: rgba(9, 12, 20, 0.9);
      --topbar-border: #1f2533;
      }
	  html, body, svg, .map-container {
      touch-action: none;
      }
      * {
      box-sizing: border-box;
      user-select: none;
      }
      input,
      textarea,
      [contenteditable="true"] {
      user-select: text;
      -webkit-user-select: text;
      }
      body {
      margin: 0;
      font-family: system-ui, sans-serif;
      background: radial-gradient(circle at top, #1e2532 0, #050608 70%);
      color: var(--text-main);
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
      }
      header {
      padding: 0 20px;
      height: var(--topbar-height, 52px);
      min-height: var(--topbar-height, 52px);
      background: var(--topbar-bg);
      backdrop-filter: blur(6px);
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid var(--topbar-border);
      gap: 16px;
      }
      .title-block {
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-width: 0;
      }
      header h1 {
      font-size: clamp(22px, 3vw, 32px);
      margin: 0;
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
      }
      .editable-page-title {
      cursor: pointer;
      transition: opacity 0.2s;
      }
      .editable-page-title:hover {
      opacity: 0.7;
      }
      .save-row {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      }
      .save-btn {
      padding: 6px 12px;
      background: var(--accent);
      color: var(--bg);
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      white-space: nowrap;
      }
      .save-btn:hover {
      opacity: 0.9;
      }
      .help-icon {
      width: 22px;
      height: 22px;
      border-radius: 50%;
      border: 1px solid var(--edge-main);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      cursor: pointer;
      color: var(--text-soft);
      background: rgba(15, 23, 42, 0.9);
      flex-shrink: 0;
      }
      .help-icon:hover {
      color: var(--accent);
      border-color: var(--accent);
      }
      #settings-btn {
      background: var(--btn-bg, var(--panel));
      color: var(--btn-text, var(--text-main));
      border: 1px solid var(--edge-main);
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 16px;
      flex-shrink: 0;
      }
      #settings-btn:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .header-resizer {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 6px;
      background: transparent;
      cursor: row-resize;
      z-index: 1000;
      transition: background 0.2s;
      }
      .header-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .header-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      .sidebar-resizer {
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 6px;
      background: transparent;
      cursor: col-resize;
      z-index: 1000;
      transition: background 0.2s;
      }
      .sidebar-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .sidebar-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      .mobile-footer-resizer {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 6px;
      background: transparent;
      cursor: row-resize;
      z-index: 1000;
      transition: background 0.2s;
      display: none;
      }
      .mobile-footer-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .mobile-footer-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      @media (max-width: 900px) {
      .mobile-footer-resizer {
      display: block;
      height: 12px;
      }
      .sidebar-resizer {
      display: none;
      }
      .header-resizer {
      height: 12px;
      }
      }
      @media (pointer: coarse) {
      .header-resizer {
      height: 16px;
      }
      .mobile-footer-resizer {
      height: 16px;
      }
      .sidebar-resizer {
      width: 16px;
      }
      }
      .resizer-icon {
      position: absolute;
      opacity: 0.5;
      transition: opacity 0.2s, transform 0.2s;
      pointer-events: none;
      fill: var(--accent);
      }
      .header-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .sidebar-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .mobile-footer-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .header-resizer:hover .resizer-icon,
      .sidebar-resizer:hover .resizer-icon,
      .mobile-footer-resizer:hover .resizer-icon {
      opacity: 1;
      }
      .header-resizer.resizing .resizer-icon,
      .sidebar-resizer.resizing .resizer-icon,
      .mobile-footer-resizer.resizing .resizer-icon {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1.2);
      }
      body.resizing {
      user-select: none;
      }
      body.resizing * {
      cursor: inherit !important;
      pointer-events: none;
      }
      header {
      position: relative;
      }
      .details-panel {
      position: relative;
      }
      main {
      display: grid;
      grid-template-columns: 1fr var(--sidebar-width, 350px);
      flex: 1;
      }
      main.sidebar-collapsed {
      grid-template-columns: 1fr 0;
      }
      @media (max-width: 900px) {
      main {
      grid-template-columns: 1fr;
      grid-template-rows: calc(100vh - var(--topbar-height, 52px) - var(--mobile-footer-height, 40vh)) var(--mobile-footer-height, 40vh);
      }
      main.sidebar-collapsed {
      grid-template-rows: 1fr 0;
      }
      .details-panel {
      max-height: var(--mobile-footer-height, 40vh);
      height: 100%;
      }
      }
      .topology-panel {
      background: var(--panel);
      border-right: 1px solid #111827;
      position: relative;
      overflow: hidden;
      }
      .topology-toolbar {
      position: absolute;
      top: 10px;
      right: 10px;
      display: none;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      z-index: 99;
      font-size: 13px;
      color: var(--toolbar-text, #94a3b8);
      }
      .topology-toolbar label {
      color: var(--toolbar-text, var(--text-soft));
      }
      .topology-toolbar select {
      padding: 4px 6px;
      background: var(--toolbar-btn-bg, var(--panel));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 13px;
      cursor: pointer;
      }
      .topology-toolbar button {
      padding: 4px 10px;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      }
      .topology-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .bulk-toolbar-desktop,
      .bulk-toolbar-mobile {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 9999;
      }
      .bulk-toolbar-desktop {
      position: absolute;
      top: 10px;
      right: 10px;
      bottom: auto;
      left: auto;
      transform: none;
      }
      @media (min-width: 768px) {
      .bulk-toolbar-mobile {
      display: none !important;
      }
      }
      .bulk-action-btn {
      padding: 16px;
      background: var(--panel-main);
      border: 1px solid var(--edge-main);
      border-radius: 8px;
      color: var(--text-main);
      font-size: 24px;
      cursor: pointer;
      text-align: center;
      line-height: 1.2;
      }
      .bulk-action-btn:active {
      transform: scale(0.95);
      background: var(--accent);
      }
      .draw-toolbar {
      position: absolute;
      top: 10px;
      left: 10px;
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 8px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      z-index: 99;
      font-size: 13px;
      pointer-events: auto;
      color: var(--toolbar-text, #94a3b8);
      }
      .draw-toolbar button {
      padding: 4px 8px;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      }
      .draw-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .draw-toolbar input[type="color"] {
      width: 30px;
      height: 22px;
      border-radius: 4px;
      border: 1px solid var(--edge-main);
      padding: 0;
      background: transparent;
      cursor: pointer;
      }
      .draw-toolbar select {
      padding: 4px 6px;
      background: var(--toolbar-btn-bg, var(--panel));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 13px;
      cursor: pointer;
      }
      .legend-container {
      position: absolute;
      left: 10px;
      bottom: 10px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      padding: 8px 10px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      font-size: 12px;
      z-index: 20;
      max-width: 260px;
      pointer-events: auto;
      color: var(--toolbar-text, #94a3b8);
      }
      .legend-container {
      padding-right: 22px;
      }
      @media (max-width: 900px) {
      .legend-container {
      height:250px;
      overflow-y: auto;
      z-index:99;
      }
      }
      @media (max-width: 900px) {
      .bulk-toolbar-desktop,
      .topology-toolbar {
      display: none !important;
      }
      }
      .legend-close-btn {
      position: absolute;
      top: 5px;
      right: 5px;
      width: 18px;
      height: 18px;
      border-radius: 999px;
      border: 1px solid var(--edge-main);
      background: var(--panel-alt);
      color: var(--text-soft);
      font-size: 11px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      }
      .legend-close-btn:hover {
      background: var(--danger);
      color: #fff;
      }
      .legend-mini-btn {
      position: absolute;
      left: 10px;
      padding: 4px 8px;
      border-radius: 4px;
      border: 1px solid var(--toolbar-border, #1f2937);
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 11px;
      cursor: pointer;
      z-index: 20;
      display: none;
      transition: all 0.2s;
      }
      .legend-mini-btn:hover,
      .legend-mini-btn:active {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
      }
      .legend-title {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: var(--toolbar-text, var(--text-soft));
      margin-bottom: 2px;
      }
      .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      }
      .legend-swatch {
      width: 14px;
      height: 14px;
      border-radius: 3px;
      border: 1px solid #020617;
      flex-shrink: 0;
      }
      .legend-label {
      outline: none;
      cursor: text;
      flex: 1;
      min-width: 60px;
      user-select: text;
      -webkit-user-select: text;
      }
      .legend-label.editing {
      border-bottom: 1px dashed var(--accent);
      }
      .canvas-viewport {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      overflow: hidden;
      }
      .canvas-viewport.panning {
      cursor: grabbing !important;
      }
      .canvas-viewport.panning * {
      cursor: grabbing !important;
      }
      .canvas-viewport svg {
      width: 100%;
      height: 100%;
      display: block;
      background: linear-gradient(rgba(71, 85, 105, 0.1) 1px,
      transparent 1px),
      linear-gradient(90deg,
      rgba(71, 85, 105, 0.1) 1px,
      transparent 1px),
      linear-gradient(rgba(71, 85, 105, 0.05) 1px, transparent 1px),
      linear-gradient(90deg,
      rgba(71, 85, 105, 0.05) 1px,
      transparent 1px);
      background-size:
      100px 100px,
      100px 100px,
      20px 20px,
      20px 20px;
      background-position:
      -1px -1px,
      -1px -1px,
      -1px -1px,
      -1px -1px;
      }
      .zoom-toolbar {
      display: flex;
      gap: 4px;
      padding: 6px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      }
      .zoom-toolbar button {
      width: 32px;
      height: 32px;
      padding: 0;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 18px;
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
      }
      .zoom-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .zoom-toolbar .zoom-level {
      font-size: 11px;
      color: var(--toolbar-text, var(--text-soft));
      text-align: center;
      padding: 2px 0;
      min-width: 32px;
      }
      .zoom-toolbar .divider {
      height: 1px;
      background: var(--toolbar-border, var(--edge-main));
      margin: 2px 0;
      }
      .minimap-zoom-wrapper {
      position: absolute;
      bottom: 10px;
      right: 10px;
      z-index: 99;
      }
      .minimap-container {
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      overflow: hidden;
      margin-bottom: 4px;
      }
      .minimap-container svg {
      width: 100%;
      height: 100%;
      }
      .minimap-viewport {
      fill: rgba(79, 209, 197, 0.2);
      stroke: var(--accent);
      stroke-width: 2;
      cursor: move;
      }
      .minimap-node {
      fill: var(--minimap-dots, var(--text-soft));
      }
      .minimap-edge {
      stroke: var(--edge-main);
      stroke-width: 1;
      }
      .minimap-close-btn {
      position: absolute;
      top: 2px;
      right: 2px;
      width: 18px;
      height: 18px;
      background: var(--toolbar-btn-bg, rgba(15, 23, 42, 0.9));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 3px;
      color: var(--toolbar-text, var(--text-soft));
      font-size: 11px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
      padding: 0;
      line-height: 1;
      }
      .minimap-close-btn:hover {
      background: var(--danger);
      color: white;
      border-color: var(--danger);
      }
      .toolbar-close-btn {
      width: 24px;
      height: 24px;
      background: var(--toolbar-btn-bg, rgba(15, 23, 42, 0.9));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-text, var(--text-soft));
      font-size: 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      line-height: 1;
      flex-shrink: 0;
      }
      .toolbar-close-btn:hover {
      background: var(--danger);
      color: white;
      border-color: var(--danger);
      }
      .canvas-hint {
      position: absolute;
      top: 50px;
      left: 50%;
      transform: translateX(-50%);
      padding: 8px 16px;
      background: rgba(15, 23, 42, 0.92);
      border: 1px solid #1f2937;
      border-radius: 6px;
      font-size: 12px;
      color: var(--text-soft);
      z-index: 18;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
      }
      .canvas-hint.visible {
      opacity: 1;
      }
      .edge {
      stroke: var(--edge-main);
      stroke-width: 4;
      opacity: 0.75;
      transition: 0.25s ease-in-out;
      cursor: pointer;
      }
      .edge.backup {
      stroke: var(--danger);
      stroke-width: 5;
      }
      .edge.active {
      opacity: 1;
      stroke-width: 7;
      filter: drop-shadow(0 0 8px var(--accent, #4fd1c5));
      }
      .rect-group.active .rect-shape {
      filter: drop-shadow(0 0 10px var(--accent, #4fd1c5));
      animation: pulse 1.2s infinite ease-in-out;
      }
      .text-element.active {
      filter: drop-shadow(0 0 10px var(--accent, #4fd1c5));
      animation: pulse 1.2s infinite ease-in-out;
      }
      .free-preview {
      fill: none;
      stroke-dasharray: 4 4;
      pointer-events: none;
      }
      .free-point {
      fill: #e5e7eb;
      stroke: #0f172a;
      stroke-width: 1.5;
      cursor: grab;
      }
      .node-circle {
      fill: var(--node-fill, #1e293b);
      stroke: var(--node-stroke, #475569);
      stroke-width: 2;
      transition: 0.25s ease;
      transform-origin: center center;
      }
      .node-hit-area {
      cursor: grab;
      pointer-events: all;
      }
      .node-group:hover .node-circle {
      filter: drop-shadow(0 0 10px rgba(79, 209, 197, 0.45));
      }
      .node-group.active .node-circle {
      stroke: var(--accent);
      animation: pulse 1.2s infinite ease-in-out;
      }
      .node-group.selected .node-circle {
      stroke: var(--selection-handle, #f59e0b);
      stroke-width: 3;
      }
      .node-group.search-highlight .node-circle {
      stroke: #10b981;
      stroke-width: 3;
      filter: drop-shadow(0 0 8px #10b981);
      }
	  .node-group.search-faded {
		opacity: 0.15;
		pointer-events: none;
		}
		.edge-group.search-faded {
		opacity: 0.1;
		}
	  .node-group.search-faded {
      opacity: 0.15;
      pointer-events: none;
      }
      .edge-group.search-faded {
      opacity: 0.1;
      }
      @keyframes pulse {
      0% {
      filter: drop-shadow(0 0 4px #4fd1c5);
      }
      50% {
      filter: drop-shadow(0 0 14px #4fd1c5);
      }
      100% {
      filter: drop-shadow(0 0 4px #4fd1c5);
      }
      }
      .node-label {
      fill: var(--text-main);
      font-size: 18px;
      text-anchor: middle;
      font-weight: 600;
      }
      .node-sub {
      fill: var(--text-soft);
      font-size: 13px;
      text-anchor: middle;
      }
      @media (max-width: 1024px) {
      .node-label {
      font-size: 28px;
      }
      .node-sub {
      font-size: 20px;
      }
      }
      @media (max-width: 768px) {
      .node-label {
      font-size: 70px;
      }
      .node-sub {
      font-size: 50px;
      }
      }
      @media (max-width: 380px) {
      .node-label {
      font-size: 60px;
      }
      .node-sub {
      font-size: 42px;
      }
      }
      .details-panel {
      background: var(--sidebar-bg, var(--panel-alt));
      padding: 22px;
      padding-bottom: 80px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 15px;
      position: relative;
      transition:
      width 0.3s ease,
      min-width 0.3s ease,
      padding 0.3s ease,
      opacity 0.3s ease;
      }
      .details-panel {
      min-width: 260px !important;
      }
      .details-panel {
      overflow-y: auto !important;
      overflow-x: hidden;
      }
      .details-panel.collapsed {
      width: 0 !important;
      min-width: 0 !important;
      padding: 0 !important;
      overflow: hidden;
      opacity: 0;
      }
      body {
      overflow-x: hidden;
      overflow-y: hidden;
      }
      main {
      overflow-x: hidden;
      overflow-y: visible;
      }
      .details-panel {
      overflow-y: auto !important;
      overflow-x: hidden;
      }
      .details-panel.collapsed {
      min-width: 0 !important;
      }
      .sidebar-toggle {
      position: absolute;
      left: -16px;
      top: 50%;
      transform: translateY(-50%);
      width: 16px;
      height: 60px;
      background: var(--sidebar-bg, var(--panel-alt));
      border: 1px solid var(--edge-main);
      border-right: none;
      border-radius: 8px 0 0 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text-soft);
      font-size: 10px;
      z-index: 25;
      transition:
      background 0.2s,
      color 0.2s;
      }
      .sidebar-toggle:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .sidebar-toggle.collapsed {
      left: 0;
      border-right: 1px solid var(--edge-main);
      border-radius: 0 8px 8px 0;
      position: fixed;
      right: 0;
      left: auto;
      }
      .details-name {
      font-size: clamp(22px, 2.5vw, 30px);
      font-weight: 700;
      }
      .details-ip {
      font-size: clamp(16px, 2vw, 22px);
      color: var(--text-soft);
      }
      .details-role {
      font-size: clamp(16px, 2vw, 22px);
      color: var(--accent);
      }
      .details-info-row {
      display: flex;
      align-items: center;
      margin: 6px 0;
      }
      .size-controls {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-top: 10px;
      }
      .size-controls label {
      font-size: clamp(14px, 1.6vw, 18px);
      color: var(--text-soft);
      }
      .size-controls input[type="range"] {
      flex: 1;
      accent-color: var(--accent);
      }
      .size-controls button {
      padding: 6px 12px;
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      font-size: clamp(12px, 1.4vw, 16px);
      }
      .size-controls button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .style-section {
      margin-top: 15px;
      padding-top: 15px;
      border-top: 1px solid var(--edge-main);
      }
      .style-section summary {
      cursor: pointer;
      font-size: clamp(14px, 1.6vw, 20px);
      text-transform: uppercase;
      color: var(--text-soft);
      list-style: none;
      display: flex;
      justify-content: space-between;
      align-items: center;
      user-select: none;
      }
      .style-section summary::-webkit-details-marker {
      display: none;
      }
      .password-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #ffffff;
      z-index: 9999;
      }
      .style-section summary::after {
      content: "▼";
      transition: transform 0.2s;
      }
      .style-section[open] summary::after {
      transform: rotate(180deg);
      }
      .style-content {
      margin-top: 10px;
      }
      .style-row {
      display: flex;
      gap: 10px;
      align-items: center;
      margin: 8px 0;
      }
      .style-row label {
      font-size: clamp(13px, 1.5vw, 17px);
      color: var(--text-soft);
      min-width: 80px;
      }
      .style-row input[type="color"] {
      width: 50px;
      height: 30px;
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      background: transparent;
      }
      .style-row input[type="number"] {
      width: 70px;
      padding: 4px 8px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(12px, 1.4vw, 16px);
      }
      .style-row select {
      flex: 1;
      padding: 4px 8px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(12px, 1.4vw, 16px);
      cursor: pointer;
      }
      .editable-text {
      cursor: pointer;
      transition: opacity 0.2s;
      }
      .editable-text:hover {
      opacity: 0.7;
      }
      .modal {
	  display: none;
	  position: fixed;
	  top: 0;
	  left: 0;
	  width: 100%;
	  height: 100%;
	  z-index: 999999;
	  justify-content: center;
	  align-items: center;
	  overflow: auto;
	  }
	  .modal.active {
	  display: inline-grid;
	  }
	  .modal-content {
	  background: var(--panel-alt);
	  padding: 25px;
	  border-radius: 8px;
	  border: 1px solid var(--edge-main);
	  min-width: 300px;
	  max-width: 90%;
	  }
      .modal-content h3 {
      margin: 0 0 15px 0;
      color: var(--text-main);
      font-size: clamp(18px, 2vw, 24px);
      }
      .modal-content p {
      color: var(--text-soft);
      font-size: clamp(14px, 1.6vw, 18px);
      margin: 0 0 20px 0;
      }
      .modal-content input:not([type="color"]),
      .modal-content select {
      width: 100%;
      padding: 10px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(14px, 1.6vw, 18px);
      margin-bottom: 15px;
      user-select: text;
      -webkit-user-select: text;
      }
      .modal-content input[type="color"] {
      width: 60px;
      height: 36px;
      padding: 2px;
      border: 2px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      background: none;
      -webkit-appearance: none;
      appearance: none;
      }
      .modal-content input[type="color"]::-webkit-color-swatch-wrapper {
      padding: 0;
      }
      .modal-content input[type="color"]::-webkit-color-swatch {
      border: none;
      border-radius: 4px;
      }
      .modal-buttons {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
      margin-top: 10px;
      }
      .modal-buttons button {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: clamp(14px, 1.6vw, 18px);
      font-weight: 600;
      }
      .modal-buttons .btn-cancel {
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      }
      .modal-buttons .btn-save {
      background: var(--accent);
      color: var(--bg);
      }
      .modal-buttons .btn-delete {
      background: var(--danger);
      color: white;
      }
      .confirm-modal p {
      color: var(--text-soft);
      font-size: clamp(14px, 1.6vw, 18px);
      margin: 0 0 20px 0;
      }
      .context-menu-item {
      transition: background 0.15s;
      }
      .context-menu-item:hover {
      background: var(--panel);
      }
      .badge-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      }
      .badge {
      background: var(--tag-fill, #1e293b);
      color: var(--tag-text, #e2e8f0);
      border: 1px solid var(--tag-border, var(--edge-main));
      padding: 5px 12px;
      border-radius: 22px;
      font-size: clamp(12px, 1.4vw, 18px);
      }
      .badge.wg {
      color: var(--accent);
      border-color: var(--accent);
      }
      input[type="text"],
      input[type="number"],
      input[type="password"],
      textarea,
      select {
      background: var(--input-bg, #0b0e13) !important;
      color: var(--input-text, #e2e8f0) !important;
      border-color: var(--input-border, #1f2937) !important;
      font-family: var(--input-font, Inter, system-ui, sans-serif) !important;
      font-size: var(--input-font-size, 14px) !important;
      }
      .section-label {
      margin-top: 8px;
      font-size: clamp(14px, 1.6vw, 20px);
      text-transform: uppercase;
      color: var(--text-soft);
      }
      .list li {
      margin: 6px 0;
      font-size: clamp(14px, 1.6vw, 20px);
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      }
      .list li:hover {
      color: var(--accent);
      }
      .delete-note {
      color: var(--danger);
      font-size: 18px;
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.2s;
      flex-shrink: 0;
      }
      .list li:hover .delete-note {
      opacity: 1;
      }
      .editing {
      outline: 2px solid var(--accent);
      background: #0d141f;
      padding: 4px;
      border-radius: 6px;
      user-select: text;
      -webkit-user-select: text;
      }
      .version-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .version-item:hover {
      background: var(--panel-alt);
      border-color: var(--accent);
      }
      .version-item.current {
      border-color: var(--accent);
      background: rgba(79, 209, 197, 0.1);
      }
      .version-info {
      flex: 1;
      }
      .version-info .timestamp {
      font-size: 13px;
      color: var(--text-main);
      font-weight: 600;
      }
      .version-info .details {
      font-size: 11px;
      color: var(--text-soft);
      margin-top: 4px;
      }
      .version-actions {
      display: flex;
      gap: 6px;
      }
      .audit-entry {
      padding: 8px 12px;
      background: var(--panel);
      border-left: 3px solid var(--edge-main);
      border-radius: 4px;
      font-size: 12px;
      }
      .audit-entry.node { border-left-color: #4fd1c5; }
      .audit-entry.connection { border-left-color: #9f7aea; }
      .audit-entry.style { border-left-color: #ed8936; }
      .audit-entry.rack { border-left-color: #48bb78; }
      .audit-entry.layer { border-left-color: #4299e1; }
      .audit-entry .time {
      color: var(--text-soft);
      font-size: 10px;
      }
      .audit-entry .action {
      color: var(--text-main);
      font-weight: 500;
      }
      .tab-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .tab-item:hover {
      background: var(--panel-alt);
      }
      .tab-item.active {
      border-color: var(--accent);
      background: rgba(79, 209, 197, 0.1);
      }
      .tab-item .tab-name {
      font-weight: 600;
      color: var(--text-main);
      flex: 1;
      }
      .tab-item .tab-stats {
      font-size: 11px;
      color: var(--text-soft);
      margin-right: 10px;
      }
      .tab-actions {
      display: flex;
      gap: 6px;
      }
      .secret-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      border-left: 3px solid var(--danger);
      }
      .secret-item .secret-name {
      font-weight: 600;
      color: var(--text-main);
      flex: 1;
      }
      .secret-item .secret-status {
      font-size: 11px;
      color: var(--text-soft);
      margin-right: 10px;
      }
      .mobile-menu-btn {
      display: none;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      color: var(--text-main);
      font-size: 22px;
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      }
      #topbar-menu {
      gap: 8px;
      }
      @media (min-width: 721px) {
      #topbar-menu {
      display: flex !important;
      }
      }
      @media (max-width: 720px) {
      #topbar-menu {
      display: none;
      }
      #topbar-menu.open {
      display: flex;
      }
      }
      @media (max-width: 720px) {
      .mobile-menu-btn {
      display: block;
      }
      #topbar-menu {
      position: absolute;
      top: var(--topbar-height);
      right: 0;
      background: var(--panel-alt);
      border-left: 1px solid var(--topbar-border);
      border-bottom: 1px solid var(--topbar-border);
      padding: 12px;
      display: none;
      flex-direction: column;
      width: 180px;
      z-index: 999;
      }
      #topbar-menu.open {
      display: flex;
      }
      header {
      position: relative;
      z-index: 9999;
      }
      }
      @media (max-width: 720px) {
      .draw-toolbar {
      position: absolute;
      top: auto;
      bottom: auto;
      left: 10px !important;
      right: auto !important;
      width: auto;
      gap: 6px;
      padding: 8px;
      }
      .topology-toolbar {
      position: absolute;
      top: auto;
      bottom: auto;
      width: auto;
      gap: 6px;
      padding: 8px;
      }
      .draw-toolbar {
      top: 10px !important;
      z-index:99;
      }
      .topology-toolbar {
      z-index:99;
      top: calc(10px + var(--draw-toolbar-height, 50px)) !important;
      }
      .canvas-hint {
      top: calc(10px + 120px);
      }
      #search-input {
      width: 100%;
      }
      }
	  body.view-only-mode:not(.view-only-inspect) #node-panel,
      body.view-only-mode:not(.view-only-inspect) #edge-panel,
      body.view-only-mode:not(.view-only-inspect) #text-panel,
      body.view-only-mode:not(.view-only-inspect) #rect-panel {
        display: none !important;
      }
      body.view-only-mode .node-group,
      body.view-only-mode .edge,
      body.view-only-mode .rect-group,
      body.view-only-mode .text-element {
        cursor: default !important;
      }
      body.view-only-mode #bulk-toolbar,
      body.view-only-mode #bulk-toolbar-mobile,
      body.view-only-mode #bulk-actions-modal {
        display: none !important;
      }
      body.view-only-mode::after {
        content: "VIEW ONLY • tap 5× to inspect";
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(245, 101, 101, 0.9);
        color: white;
        padding: 6px 16px;
        border-radius: 20px;
        font-size: 12px;
        font-weight: 600;
        letter-spacing: 1px;
        z-index: 9999;
        pointer-events: none;
      }
    </style>
  </head>
  <body style="background: radial-gradient(circle at center top, rgb(30, 37, 50) 0px, rgb(5, 6, 8) 70%);" class="">
    <div class="modal" id="edit-modal">
      <div class="modal-content">
        <h3 id="modal-title">Add Tag(s) : comma separated</h3>
        <input type="text" id="modal-input">
        <div class="modal-buttons">
          <button class="btn-cancel" id="modal-cancel">Cancel</button>
          <button class="btn-save" id="modal-save">Save</button>
        </div>
      </div>
    </div>
    <div class="modal confirm-modal" id="confirm-modal">
      <div class="modal-content">
        <h3>Confirm</h3>
        <p id="confirm-message"> Are you sure you want to delete this line? </p>
        <div class="modal-buttons">
          <button class="btn-cancel" id="confirm-cancel">Cancel</button>
          <button class="btn-delete" id="confirm-delete">Delete</button>
        </div>
      </div>
    </div>
    <div class="modal" id="save-info-modal">
      <div class="modal-content" style="max-width: 700px; max-height: 80vh; overflow-y: auto;">
        <h3 style="margin-bottom: 16px;">Help</h3>
        <div style="display: flex; gap: 8px; margin-bottom: 16px; flex-wrap: wrap;">
          <button class="help-tab active" data-tab="general" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--accent); color: var(--bg); border-radius: 6px; cursor: pointer; font-weight: 600;">General</button>
          <button class="help-tab" data-tab="desktop" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--panel); color: var(--text-main); border-radius: 6px; cursor: pointer; font-weight: 600;">Desktop</button>
          <button class="help-tab" data-tab="mobile" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--panel); color: var(--text-main); border-radius: 6px; cursor: pointer; font-weight: 600;">Mobile</button>
        </div>
        <div id="help-tab-general" class="help-tab-content" style="display: block;">
          <ul style="margin-left: 20px; margin-bottom: 12px; line-height: 1.8;">
            <li><strong>Add Nodes:</strong> Click "+ Node" or "+ Rack" in the top menu</li>
            <li><strong>Connect Nodes:</strong> Select a node, then use "Add Connection" in the panel</li>
            <li><strong>Move Nodes:</strong> Drag nodes to reposition them</li>
            <li><strong>Enter Rack View:</strong> Double click on desktop or Long press on mobile</li>
            <li><strong>Multi Select:</strong> Right click (desktop) or double tap (mobile)</li>
            <li><strong>Pan Canvas:</strong> Drag empty space or hold Space + drag</li>
            <li><strong>Zoom:</strong> Scroll wheel or pinch gesture</li>
            <li><strong>Free Draw:</strong> Use draw toolbar for drawing lines, boxes/zones , and text</li>
          </ul>
          <h4 style="color: var(--accent); margin-bottom: 8px;">Saving &amp; Encryption</h4>
          <p style="margin-bottom: 8px;">Browsers cannot overwrite local files. Click <strong>Save File</strong> to download an updated HTML with all changes. Replace your old file to keep edits.</p>
          <p style="margin-bottom: 8px;"><strong>Encryption of data:</strong> Check "Encrypt" before saving to password protect your data. Beware! No recovery possible without password!!</p>
          <p><strong>Decryption of data:</strong> Export via JSON in top settings menu after successful password validation to decrypt your data. You can then reimport back into the same file and save!</p>
        </div>
        <div id="help-tab-desktop" class="help-tab-content" style="display: none;">
          <h4 style="color: var(--accent); margin-bottom: 12px;">Navigation</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Arrow Keys</code></td>
              <td style="padding: 8px;">Move selected 1px</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Shift + Arrows</code></td>
              <td style="padding: 8px;">Move selected 10px</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Tab / Shift+Tab</code></td>
              <td style="padding: 8px;">Cycle through nodes</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">F</code></td>
              <td style="padding: 8px;">Focus on selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Space + Drag</code></td>
              <td style="padding: 8px;">Pan canvas</td>
            </tr>
          </tbody></table>
          <h4 style="color: var(--accent); margin-bottom: 12px;">Management</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">L</code></td>
              <td style="padding: 8px;">Lock/unlock selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">G</code></td>
              <td style="padding: 8px;">Group/ungroup selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+C / Ctrl+V</code></td>
              <td style="padding: 8px;">Copy / Paste</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+D</code></td>
              <td style="padding: 8px;">Duplicate</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+A</code></td>
              <td style="padding: 8px;">Select all</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Delete</code></td>
              <td style="padding: 8px;">Delete selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Escape</code></td>
              <td style="padding: 8px;">Clear selection</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+Z / Ctrl+Y</code></td>
              <td style="padding: 8px;">Undo / Redo</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Right Click</code></td>
              <td style="padding: 8px;">Multi select toggle</td>
            </tr>
          </tbody></table>
        </div>
        <div id="help-tab-mobile" class="help-tab-content" style="display: none;">
          <h4 style="color: var(--accent); margin-bottom: 12px;">Basic Gestures</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Tap node</strong></td>
              <td style="padding: 8px;">Select &amp; open properties</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Tap empty</strong></td>
              <td style="padding: 8px;">Deselect all</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Drag node</strong></td>
              <td style="padding: 8px;">Move node</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Drag empty</strong></td>
              <td style="padding: 8px;">Pan canvas</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Pinch</strong></td>
              <td style="padding: 8px;">Zoom in/out</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Double-tap node</strong></td>
              <td style="padding: 8px;">Add/remove from selection</td>
            </tr>
          </tbody></table>
          <h4 style="color: var(--accent); margin-bottom: 12px;">Rack View</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Long-press rack</strong></td>
              <td style="padding: 8px;">Enter rack view</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Double-tap empty</strong></td>
              <td style="padding: 8px;">Exit rack view</td>
            </tr>
          </tbody></table>
        </div>
        <div class="modal-buttons" style="margin-top: 16px;">
          <button class="btn-cancel" id="save-info-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="settings-modal">
      <div class="modal-content">
        <h2>Settings</h2>
		<details class="style-section">
          <summary>View Only Mode</summary>
          <div class="style-content">
            <div class="style-row">
              <label>View Only (disable editing)</label>
              <input type="checkbox" id="view-only-mode" style="width:auto;">
            </div>
            <p style="margin-top:4px;font-size:12px;color:var(--text-soft);">When enabled, all editing of the canvas is disabled. Pan and zoom still work.</p>
          </div>
        </details>
        <details class="style-section">
          <summary>General Theme</summary>
          <div class="style-content">
		    <div class="style-row">
              <label>Main Background</label>
              <input type="color" id="panel-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Modal Window (popup) Background</label>
              <input type="color" id="panel-alt-color" value="#10141b">
            </div>
            <div class="style-row">
              <label>Accent Buttons</label>
              <input type="color" id="accent-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Danger Buttons</label>
              <input type="color" id="danger-color" value="#f56565">
            </div>
            <div class="style-row">
              <label>Primary Text</label>
              <input type="color" id="text-main-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Secondary Text</label>
              <input type="color" id="text-soft-color" value="#94a3b8">
            </div>
          </div>
        </details>
		<details class="style-section">
          <summary>Top Bar</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="topbar-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="topbar-border-color" value="#1f2533">
            </div>
          </div>
		  <div class="style-content">
            <div class="style-row">
              <label>Button Fill</label>
              <input type="color" id="btn-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Button Text</label>
              <input type="color" id="btn-text-color" value="#e2e8f0">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Main Canvas</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="canvas-border-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Grid Lines</label>
              <input type="color" id="canvas-grid-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Grid Size</label>
              <input type="number" id="canvas-grid-size" value="50" min="20" max="200" style="width:60px;">
            </div>
			<div class="style-row">
              <label>Background Top</label>
              <input type="color" id="canvas-gradient-top" value="#1e2532">
            </div>
            <div class="style-row">
              <label>Background Bottom</label>
              <input type="color" id="canvas-gradient-bottom" value="#050608">
            </div>
            <div class="style-row">
              <label>Solid Background</label>
              <input type="color" id="page-bg-color" value="#050608">
            </div>
            <p style="margin-top:4px;font-size:12px;color:var(--text-soft);">Set solid background to override gradient.</p>
          </div>
			</details>
		  <details class="style-section">
          <summary>Rack Canvas</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Frame Fill</label>
              <input type="color" id="rack-frame-fill" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Frame Border</label>
              <input type="color" id="rack-frame-stroke" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Grid Lines</label>
              <input type="color" id="rack-line-color" value="#475569">
            </div>
            <div class="style-row">
              <label>U Labels</label>
              <input type="color" id="rack-text-color" value="#4fd1c5">
            </div>
          </div>
        </details>
		        <details class="style-section">
          <summary>Canvas Toolbars</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="toolbar-bg-color" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="toolbar-border-color" value="#1f2937">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="toolbar-text-color" value="#94a3b8">
            </div>
            <div class="style-row">
              <label>Button Fill</label>
              <input type="color" id="toolbar-btn-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Button Text</label>
              <input type="color" id="toolbar-btn-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Minimap Dots</label>
              <input type="color" id="minimap-dots-color" value="#94a3b8">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Nodes</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Fill</label>
              <input type="color" id="node-fill-color" value="#1e293b">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="node-stroke-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Title Color</label>
              <input type="color" id="node-title-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Title Size</label>
              <input type="number" id="node-title-size" value="18" min="8" max="48" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Subtitle Color</label>
              <input type="color" id="node-sub-color" value="#94a3b8">
            </div>
            <div class="style-row">
              <label>Subtitle Size</label>
              <input type="number" id="node-sub-size" value="13" min="8" max="48" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Font</label>
              <select id="node-font-family" style="flex:1;padding:4px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;">
                <option value="Inter, system-ui, sans-serif">Inter</option>
                <option value="Arial, sans-serif">Arial</option>
                <option value="Helvetica, sans-serif">Helvetica</option>
                <option value="Georgia, serif">Georgia</option>
                <option value="monospace">Monospace</option>
              </select>
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Connections</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Default Color</label>
              <input type="color" id="default-edge-color" value="#475569">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Groups &amp; Editing</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Resize handle Color</label>
              <input type="color" id="selection-handle-color" value="#f59e0b">
            </div>
            <div class="style-row">
              <label>Resize Handle Size</label>
              <input type="number" id="selection-handle-size" value="8" min="4" max="16" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Grouped Icon Outline</label>
              <input type="color" id="group-indicator-color" value="#4fd1c5">
            </div>
          </div>
		   <div class="style-content">
            <div class="style-row">
              <label>Multiselect Fill Color (Desktop)</label>
              <input type="color" id="selection-fill-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Multiselect Fill Opacity (Desktop)</label>
              <input type="range" id="selection-fill-opacity" min="0" max="1" step="0.05" value="0.1">
              <span id="selection-fill-opacity-val" style="min-width:35px;text-align:right;">10%</span>
            </div>
            <div class="style-row">
              <label>Multiselect Border Color (Desktop)</label>
              <input type="color" id="selection-stroke-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Multiselect Border Width (Desktop)</label>
              <input type="number" id="selection-stroke-width" min="1" max="10" value="2">
            </div>
            <div class="style-row">
              <label>Multiselect Border Style (Desktop)</label>
              <select id="selection-stroke-style">
                <option value="5,5">Dashed</option>
                <option value="2,4">Dotted</option>
                <option value="none">Solid</option>
              </select>
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Inputs &amp; Dropdowns</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="input-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="input-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="input-border-color" value="#1f2937">
            </div>
            <div class="style-row">
              <label>Font</label>
              <select id="input-font-family" style="flex:1;padding:4px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;">
                <option value="Inter, system-ui, sans-serif">Inter</option>
                <option value="Arial, sans-serif">Arial</option>
                <option value="Helvetica, sans-serif">Helvetica</option>
                <option value="Georgia, serif">Georgia</option>
                <option value="monospace">Monospace</option>
              </select>
            </div>
            <div class="style-row">
              <label>Font Size</label>
              <input type="number" id="input-font-size" value="14" min="10" max="24" style="width:60px;">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Welcome Message</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Enabled</label>
              <input type="checkbox" id="canvas-hint-enabled" checked="" style="width:auto;">
            </div>
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="canvas-hint-bg-color" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Text Color</label>
              <input type="color" id="canvas-hint-text-color" value="#94a3b8">
            </div>
            <div class="style-row" style="flex-direction:column;align-items:stretch;">
              <label>Custom Text (HTML)</label>
              <textarea id="canvas-hint-text" rows="4" style="width:100%;margin-top:4px;padding:6px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;font-size:12px;resize:vertical;" placeholder="Leave empty for default"></textarea>
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Sidebar / Mobile Footer</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="sidebar-bg-color" value="#10141b">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Tags</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Fill</label>
              <input type="color" id="tag-fill-color" value="#1e293b">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="tag-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="tag-border-color" value="#475569">
            </div>
          </div>
        </details>
        <details class="style-section" open="">
          <summary>Import / Export / Upgrade JSON</summary>
          <div class="style-content">
            <button id="export-data-btn" style="width:100%;margin-bottom:10px;padding:10px;background:var(--accent);color:var(--bg);border:none;border-radius:6px;cursor:pointer;font-size:14px;font-weight:600;">Export JSON</button>
            <button id="import-data-btn" style="width:100%;padding:10px;background:var(--panel);color:var(--text-main);border:1px solid var(--edge-main);border-radius:6px;cursor:pointer;font-size:14px;font-weight:600;">Import JSON</button>
            <input type="file" id="import-data-file" accept=".json" style="display:none">
          </div>
        </details>
        <details class="style-section" open="">
          <summary>Danger Zone</summary>
          <div class="style-content">
            <p style="margin-bottom:12px;font-size:13px;color:var(--text-soft);">Permanently delete everything on the canvas.</p>
            <button id="clear-all-btn" title="Clear all nodes" style="padding:6px 12px;background:var(--danger);color:#fff;border:none;border-radius:6px;cursor:pointer;font-size:14px;font-weight:600;">Clear All</button>
            <input type="file" id="import-data-file" accept=".json" style="display:none">
          </div>
        </details>
        <div class="modal-buttons">
          <button class="btn-cancel" id="settings-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="add-node-modal">
      <div class="modal-content">
        <h3>Add New Node</h3>
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Name</label>
        <input type="text" id="new-node-name" placeholder="e.g. web-server">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">IP / Subtitle</label>
        <input type="text" id="new-node-ip" placeholder="e.g. 192.168.1.100">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Tags (comma separated)</label>
        <input type="text" id="new-node-tags" placeholder="e.g. Docker, nginx, WG: vpn">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Shape</label>
        <select id="new-node-shape">
                  <optgroup label="Basic Shapes">
				  <option value="circle">Circle</option>
				  <option value="square">Square</option>
				  <option value="rectangle">Rectangle</option>
				  <option value="triangle">Triangle</option>
				  <option value="hexagon">Hexagon</option>
				  <option value="diamond">Diamond</option>
				  <option value="star">Star</option>
				  <option value="stop-sign">Stop Sign</option>
				  <option value="octagon">Octagon</option>
				  <option value="pentagon">Pentagon</option>
				  <option value="cross">Cross</option>
				  <option value="rounded-square">Rounded Square</option>
				  <option value="pill">Pill</option>
				  <option value="parallelogram">Parallelogram</option>
				  <option value="trapezoid">Trapezoid</option>
				</optgroup>
			  <optgroup label="Computers &amp; Devices">
			      <option value="server">Server</option>
				  <option value="pc">PC / Desktop</option>
				  <option value="laptop">Laptop</option>
				  <option value="phone">Phone / Mobile</option>
				  <option value="printer">Printer</option>
				  <option value="pi">Raspberry Pi</option>
				  <option value="sensor">Sensor / IoT</option>
			  </optgroup>
			  <optgroup label="Network Equipment">
				  <option value="router">Router</option>
				  <option value="switch">Switch</option>
				  <option value="firewall">Firewall</option>
				  <option value="access-point">Access Point</option>
				  <option value="load-balancer">Load Balancer</option>
				  <option value="gateway">Gateway</option>
				  <option value="vpn">VPN / Tunnel</option>
				  <option value="nas">NAS / Storage</option>
			  </optgroup>
			  <optgroup label="Cloud &amp; Services">
			      <option value="cloud">Cloud</option>
				  <option value="database">Database</option>
				  <option value="docker">Docker</option>
				  <option value="container">Container</option>
				  <option value="vm">Virtual Machine</option>
				  <option value="kubernetes">Kubernetes</option>
				  <option value="api">API / Endpoint</option>
				  <option value="queue">Queue / Message</option>
				  <option value="lambda">Lambda / Function</option>
				  <option value="bucket">Bucket / S3</option>
			  </optgroup>
			  <optgroup label="Security &amp; Monitoring">
				  <option value="shield">Shield</option>
				  <option value="camera">Camera / CCTV</option>
				  <option value="monitor">Monitor / Dashboard</option>
			  </optgroup>
        </select>
        <div class="modal-buttons">
          <button class="btn-cancel" id="add-node-cancel">Cancel</button>
          <button class="btn-save" id="add-node-save">Add Node</button>
        </div>
      </div>
    </div>
    <div class="modal" id="add-rack-modal">
      <div class="modal-content">
        <h3>Add New Rack</h3>
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Rack Name</label>
        <input type="text" id="new-rack-name" placeholder="e.g. Rack-A, DC1-R01">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">IP / Network Range (optional)</label>
        <input type="text" id="new-rack-ip" placeholder="e.g. 192.168.1.0/24">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Tags (comma separated)</label>
        <input type="text" id="new-rack-tags" placeholder="e.g. Production, Data Center 1">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Icon / Shape</label>
        <select id="new-rack-shape">
                  <optgroup label="Basic Shapes">
				  <option value="circle">Circle</option>
				  <option value="square">Square</option>
				  <option value="rectangle">Rectangle</option>
				  <option value="triangle">Triangle</option>
				  <option value="hexagon">Hexagon</option>
				  <option value="diamond">Diamond</option>
				  <option value="star">Star</option>
				  <option value="stop-sign">Stop Sign</option>
				  <option value="octagon">Octagon</option>
				  <option value="pentagon">Pentagon</option>
				  <option value="cross">Cross</option>
				  <option value="rounded-square">Rounded Square</option>
				  <option value="pill">Pill</option>
				  <option value="parallelogram">Parallelogram</option>
				  <option value="trapezoid">Trapezoid</option>
				</optgroup>
			  <optgroup label="Computers &amp; Devices">
			      <option value="server">Server</option>
				  <option value="pc">PC / Desktop</option>
				  <option value="laptop">Laptop</option>
				  <option value="phone">Phone / Mobile</option>
				  <option value="printer">Printer</option>
				  <option value="pi">Raspberry Pi</option>
				  <option value="sensor">Sensor / IoT</option>
			  </optgroup>
			  <optgroup label="Network Equipment">
				  <option value="router">Router</option>
				  <option value="switch">Switch</option>
				  <option value="firewall">Firewall</option>
				  <option value="access-point">Access Point</option>
				  <option value="load-balancer">Load Balancer</option>
				  <option value="gateway">Gateway</option>
				  <option value="vpn">VPN / Tunnel</option>
				  <option value="nas">NAS / Storage</option>
			  </optgroup>
			  <optgroup label="Cloud &amp; Services">
			      <option value="cloud">Cloud</option>
				  <option value="database">Database</option>
				  <option value="docker">Docker</option>
				  <option value="container">Container</option>
				  <option value="vm">Virtual Machine</option>
				  <option value="kubernetes">Kubernetes</option>
				  <option value="api">API / Endpoint</option>
				  <option value="queue">Queue / Message</option>
				  <option value="lambda">Lambda / Function</option>
				  <option value="bucket">Bucket / S3</option>
			  </optgroup>
			  <optgroup label="Security &amp; Monitoring">
				  <option value="shield">Shield</option>
				  <option value="camera">Camera / CCTV</option>
				  <option value="monitor">Monitor / Dashboard</option>
			  </optgroup>
        </select>
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Rack Capacity</label>
        <select id="new-rack-capacity">
          <option value="42" selected="">42U (Standard Full Rack)</option>
          <option value="48">48U (Large Rack)</option>
          <option value="24">24U (Half Rack)</option>
          <option value="12">12U (Small/Wall Mount)</option>
          <option value="6">6U (Mini Rack)</option>
        </select>
        <div class="modal-buttons">
          <button class="btn-cancel" id="add-rack-cancel">Cancel</button>
          <button class="btn-save" id="add-rack-save">Add Rack</button>
        </div>
      </div>
    </div>
    <div class="modal confirm-modal" id="clear-all-modal">
      <div class="modal-content">
        <h3>Clear All Nodes</h3>
        <p> This will remove ALL nodes and connections. This cannot be undone until you reload without saving. Are you sure? </p>
        <div class="modal-buttons">
          <button class="btn-cancel" id="clear-all-cancel">Cancel</button>
          <button class="btn-delete" id="clear-all-confirm">Clear Everything</button>
        </div>
      </div>
    </div>
    <div class="modal" id="layer-modal">
      <div class="modal-content" style="max-width: 400px;">
        <h3>Layer Visibility</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Toggle which layers are visible on the canvas</p>
        <div style="display: flex; flex-direction: column; gap: 10px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-physical" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Physical Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-logical" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Logical Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-security" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Security Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-application" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Application Layer</span>
          </label>
        </div>
        <div style="margin-top: 15px; display: flex; gap: 8px;">
          <button class="btn-cancel" style="flex: 1;" onclick="document.querySelectorAll('#layer-modal input[type=checkbox]').forEach(cb =&gt; cb.checked = false); applyLayerFilter();">Hide All</button>
          <button class="btn-save" style="flex: 1;" onclick="document.querySelectorAll('#layer-modal input[type=checkbox]').forEach(cb =&gt; cb.checked = true); applyLayerFilter();">Show All</button>
        </div>
        <div class="modal-buttons" style="margin-top: 10px;">
          <button class="btn-cancel" id="layer-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="tabs-modal">
      <div class="modal-content" style="max-width: 600px;">
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Manage multiple topologies</p>
        <div id="tabs-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 400px; overflow-y: auto; margin-bottom: 15px;">
            <div class="tab-item " onclick="switchTab(0)">
              <div class="tab-name">Corporate Site B</div>
              <div class="tab-stats">106 nodes • 64 connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(0)" title="Rename tab">✏️</button>
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(0)" title="Delete tab">🗑️</button>
              </div>
            </div>
          
            <div class="tab-item active" onclick="switchTab(1)">
              <div class="tab-name">Homelab 2</div>
              <div class="tab-stats">11 nodes • 10 connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(1)" title="Rename tab">✏️</button>
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(1)" title="Delete tab">🗑️</button>
              </div>
            </div>
          </div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="new-tab-name" placeholder="New tab name..." style="flex: 1; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <button class="btn-save" onclick="createNewTab()">+ Add Tab</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="tabs-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="rollback-modal">
      <div class="modal-content" style="max-width: 700px;">
        <h3>Version History</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Limit: Snapshots</p>
        <div id="rollback-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 450px; overflow-y: auto; margin-bottom: 15px;"><div style="text-align: center; padding: 40px; color: var(--text-soft);">No version history yet. Versions are saved automatically when you save the file.</div></div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <button class="btn-cancel" onclick="clearRollbackHistory()">Clear History</button>
          <button class="btn-save" onclick="createManualSnapshot()">Create Snapshot</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="rollback-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="audit-log-modal">
      <div class="modal-content" style="max-width: 800px;">
        <h3>Audit Log</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Track all changes made to your topology</p>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <select id="audit-filter" style="padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
            <option value="all">All Events</option>
            <option value="node">Node Operations</option>
            <option value="connection">Connections</option>
            <option value="style">Style Changes</option>
            <option value="rack">Rack Operations</option>
            <option value="layer">Layer Changes</option>
          </select>
          <button class="btn-save" onclick="exportAuditLog()">Export</button>
        </div>
        <div id="audit-log-list" style="display: flex; flex-direction: column; gap: 4px; max-height: 450px; overflow-y: auto; margin-bottom: 15px; font-family: monospace; font-size: 12px;"><div style="text-align: center; padding: 40px; color: var(--text-soft);">No audit entries yet</div></div>
        <div style="display: flex; gap: 8px;">
          <button class="btn-cancel" onclick="clearAuditLog()">Clear Log</button>
          <button class="btn-cancel" id="audit-log-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="port-map-modal">
      <div class="modal-content" style="max-width: 900px;">
        <h3>Port Map</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">All connections with port assignments</p>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="port-map-search" placeholder="Search devices or ports..." style="flex: 1; min-width: 200px; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <select id="port-map-filter" style="padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
            <option value="all">All Connections</option>
            <option value="with-ports">With Ports Only</option>
            <option value="without-ports">Missing Ports</option>
          </select>
        </div>
        <div id="port-map-table" style="max-height: 450px; overflow-y: auto; margin-bottom: 15px;"><div style="text-align: center; padding: 40px; color: var(--text-soft);">No connections found</div></div>
        <div style="display: flex; gap: 8px;">
          <button class="btn-save" onclick="exportPortMap()">Export CSV</button>
          <button class="btn-cancel" id="port-map-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="secrets-modal">
      <div class="modal-content" style="max-width: 600px;">
        <h3>Notes</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Notes can also be stored with AES 256 encryption</p>
        <div id="secrets-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 350px; overflow-y: auto; margin-bottom: 15px;"><div style="text-align: center; padding: 40px; color: var(--text-soft);">No notes yet</div></div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="new-secret-name" placeholder="Note name (e.g., 'Root Passwords')..." style="flex: 1; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <button class="btn-save" onclick="createNewSecret()">+ Add Note</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="secrets-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="secret-editor-modal">
      <div class="modal-content" style="max-width: 600px;">
        <h3 id="secret-editor-title">Edit Note</h3>
        <textarea id="secret-editor-content" placeholder="Enter sensitive information here..." style="width: 100%; height: 200px; padding: 12px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main); font-family: monospace; resize: vertical; margin-bottom: 15px;"></textarea>
        <div style="margin-bottom: 15px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
          <input type="checkbox" id="secret-auto-encrypt" checked="" style="cursor: pointer;">
          <span>Encrypt Note</span>
          </label>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" onclick="closeSecretEditor()">Cancel</button>
          <button class="btn-save" onclick="saveSecret()">Save</button>
        </div>
      </div>
    </div>
    <div id="context-menu" style="display: none !important;">
    </div>
    <header>
      <div class="title-block">
        <h1 id="page-title" class="editable-page-title">The One File</h1>
        <div class="save-row">
          <button id="save-file-btn" class="save-btn" type="button">Save File</button>
          <label style="display: flex;align-items: center;gap: 4px;font-size: 12px;color: var(--text-soft);cursor: pointer;user-select: none;">
          <input type="checkbox" id="encrypt-toggle" style="cursor: pointer">
          <span title="Encrypt data with password">Encrypt</span>
          </label>
          <span id="save-help-btn" class="help-icon" title="Why save?">?</span>
        </div>
      </div>
      <div id="topbar-menu">
        <button id="back-to-topology-btn" title="Exit rack view and return to topology" style="padding: 6px 12px; background: var(--accent); color: var(--bg); border: none; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600; display: none;">← Back to Topology</button>
        <button id="add-node-btn" class="save-btn" title="Add new node" style="background: var(--accent)" draggable="true">+ Node</button>
        <button id="add-rack-btn" class="save-btn" title="Add new rack" style="background: var(--accent); margin-left: 8px;" draggable="true">+ Rack</button>
        <button id="undo-btn" title="Undo (Ctrl+Z)" style="padding: 6px 12px; background: var(--btn-bg); color: var(--btn-text); border: 1px solid var(--edge-main); border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600; opacity: 1;">↶</button>
        <button id="redo-btn" title="Redo (Ctrl+Y)" style="padding: 6px 12px; background: var(--btn-bg); color: var(--btn-text); border: 1px solid var(--edge-main); border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600; opacity: 0.5;" disabled="">↷</button>
        <input type="text" id="search-nodes" placeholder="Search nodes..." title="Search by name, IP, MAC, role, or tag" style="padding: 6px 12px;background: var(--input-bg);color: var(--input-text);border: 1px solid var(--input-border);border-radius: 6px;font-family: var(--input-font);font-size: var(--input-font-size);width: 180px;">
        <button id="layers-btn" title="Toggle layer visibility" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Layers</button>
        <button id="tabs-btn" title="Manage document tabs" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Tabs</button>
        <button id="rollback-btn" title="View version history" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Snapshots</button>
        <button id="audit-log-btn" title="View audit log" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Audit</button>
        <button id="port-map-btn" title="View all port connections" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Ports</button>
        <button id="secrets-btn" title="Manage encrypted notes" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Notes</button>
        <button onclick="screenshotCanvas()" title="Export canvas as PNG image" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">PNG</button>
        <button onclick="exportCanvasSVG()" title="Export canvas as SVG vector" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">SVG</button>
        <button id="settings-btn" title="Page settings">⚙️</button>
      </div>
      <button id="mobile-menu-toggle" class="mobile-menu-btn">☰</button>
      <div class="header-resizer" id="header-resizer">
        <svg class="resizer-icon" width="40" height="6" viewBox="0 0 40 6" xmlns="http://www.w3.org/2000/svg">
          <circle cx="14" cy="3" r="2"></circle>
          <circle cx="20" cy="3" r="2"></circle>
          <circle cx="26" cy="3" r="2"></circle>
        </svg>
      </div>
    </header>
    <main>
      <section class="topology-panel">
        <div class="draw-toolbar" id="draw-toolbar" style="display: flex !important;">
          <button type="button" class="toolbar-close-btn" id="draw-toolbar-close-btn" title="Hide draw toolbar">✕</button>
          <button id="draw-toggle" title="Draw custom line">✏️</button>
          <button id="rect-toggle" title="Draw zone">▭</button>
          <button id="text-toggle" title="Add text">T</button>
          <select id="rect-style" title="zone style">
            <option value="filled">Filled</option>
            <option value="outlined">Outlined</option>
          </select>
          <input type="color" id="draw-color" value="#f97316" title="Line color">
          <select id="draw-style" title="Line style">
            <option value="solid">Solid</option>
            <option value="dashed">Dashed</option>
            <option value="dotted">Dotted</option>
          </select>
          <select id="draw-arrow" title="Arrow direction">
            <option value="none">No arrows</option>
            <option value="forward">→ Right</option>
            <option value="backward">← Left</option>
            <option value="both">↔ Both</option>
          </select>
          <button id="draw-undo" style="display: none" title="Undo last point">Undo</button>
        </div>
        <div class="topology-toolbar" id="topology-toolbar" style="display: flex !important;">
          <button type="button" class="toolbar-close-btn" id="topology-toolbar-close-btn" title="Hide add line toolbar">✕</button>
          <label for="add-line-select">Add line to:</label>
          <select id="add-line-select"><option value="san-primary">SAN Primary</option><option value="fc-switch-1">FC Switch 1</option><option value="fc-switch-2">FC Switch 2</option><option value="tor-switch-b1">ToR Switch B1</option></select>
          <input type="color" id="add-line-color" value="#475569" title="Line color" style="width: 30px;height: 24px;border: 1px solid var(--toolbar-border);border-radius: 4px;cursor: pointer;background: transparent;padding: 0;">
          <select id="add-line-direction" title="Line direction">
            <option value="none">No arrows</option>
            <option value="forward">→ Forward</option>
            <option value="backward">← Backward</option>
            <option value="both">↔ Both</option>
          </select>
          <button id="add-line-btn">Add</button>
        </div>
        <div class="topology-toolbar bulk-toolbar-desktop" id="bulk-toolbar" style="display: none">
          <button type="button" class="toolbar-close-btn" id="bulk-toolbar-close" title="Clear selection">✕</button>
          <label style="font-weight: 600; color: var(--accent)">Selected: <span id="bulk-count">0</span></label>
          <button id="bulk-align-left" title="Align left">⬅ Left</button>
          <button id="bulk-align-right" title="Align right">➡ Right</button>
          <button id="bulk-align-top" title="Align top">⬆ Top</button>
          <button id="bulk-align-bottom" title="Align bottom">⬇ Bottom</button>
          <button id="bulk-distribute-h" title="Distribute horizontally">↔ Distribute H</button>
          <button id="bulk-distribute-v" title="Distribute vertically">↕ Distribute V</button>
          <button id="bulk-clone" title="Clone selected">📋 Clone</button>
          <button id="bulk-delete" title="Delete selected" style="background: var(--danger); color: white;">Delete</button>
        </div>
        <div class="bulk-toolbar-mobile" id="bulk-toolbar-mobile" style="">
          <button type="button" id="bulk-mobile-btn" style="background: var(--accent);color: white;padding: 12px 20px;border-radius: 25px;font-weight: 600;font-size: 16px;box-shadow: 0 4px 12px rgba(0,0,0,0.3);border: none;cursor: pointer;display: flex;align-items: center;gap: 8px;">
          <span id="bulk-count-mobile">0</span>Selected</button>
        </div>
        <div id="bulk-actions-modal" style="display: none;position: fixed;bottom: 0;left: 0;right: 0;background: var(--panel-alt);border-top-left-radius: 20px;border-top-right-radius: 20px;padding: 20px;padding-bottom: env(safe-area-inset-bottom, 20px);box-shadow: 0 -4px 20px rgba(0,0,0,0.5);z-index: 10000;max-height: calc(100vh - 80px);overflow-y: auto;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            <h3 style="margin: 0; color: var(--accent); font-size: 20px;">
              <span id="bulk-count-modal">0</span> Nodes Selected
            </h3>
            <button id="bulk-modal-close" style="background: none;border: none;font-size: 24px;cursor: pointer;color: var(--text-main);padding: 0;width: 32px;height: 32px;">✕</button>
          </div>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
            <button id="bulk-align-left-mobile" class="bulk-action-btn">⬅<br><span style="font-size: 12px;">Align Left</span></button>
            <button id="bulk-align-right-mobile" class="bulk-action-btn">➡<br><span style="font-size: 12px;">Align Right</span></button>
            <button id="bulk-align-top-mobile" class="bulk-action-btn">⬆<br><span style="font-size: 12px;">Align Top</span></button>
            <button id="bulk-align-bottom-mobile" class="bulk-action-btn">⬇<br><span style="font-size: 12px;">Align Bottom</span></button>
            <button id="bulk-distribute-h-mobile" class="bulk-action-btn">↔<br><span style="font-size: 12px;">Distribute H</span></button>
            <button id="bulk-distribute-v-mobile" class="bulk-action-btn">↕<br><span style="font-size: 12px;">Distribute V</span></button>
            <button id="bulk-lock-mobile" class="bulk-action-btn">🔒<br><span style="font-size: 12px;">Lock Toggle</span></button>
            <button id="bulk-group-mobile" class="bulk-action-btn">⭕<br><span style="font-size: 12px;">Group Toggle</span></button>
            <button id="bulk-clone-mobile" class="bulk-action-btn">📋<br><span style="font-size: 12px;">Clone All</span></button>
            <button id="bulk-delete-mobile" class="bulk-action-btn" style="background: var(--danger); color: white;">🗑<br><span style="font-size: 12px;">Delete All</span></button>
          </div>
          <button id="bulk-clear-mobile" style="width: 100%;margin-top: 16px;padding: 14px;background: var(--panel-main);border: 1px solid var(--edge-main);border-radius: 8px;color: var(--text-main);font-size: 16px;cursor: pointer;">Clear Selection</button>
        </div>
        <div class="canvas-hint" id="canvas-hint">
          <ul>
            <li>Scroll to zoom</li>
            <li>Drag to pan</li>
            <li>Right click to clone and align</li>
            <li>Right click to select multiple</li>
			<li>Hold Shift + drag mouse for marquee selection</li>
            <li>You have the power</li>
            <li>Your time is NOW!</li>
          </ul>
        </div>
        <div class="legend-container" id="edge-legend" style="display: flex;"><div class="legend-title">Line Legend</div><button type="button" class="legend-close-btn">✕</button><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(85, 226, 8); cursor: pointer;"></span><span class="legend-label" contenteditable="true">ISP LINE</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(76, 0, 255); cursor: pointer;"></span><span class="legend-label" contenteditable="true">MY Guest NETWORK</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(128, 255, 0); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(251, 0, 255); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(255, 0, 208); cursor: pointer;"></span><span class="legend-label" contenteditable="true">iPhone (always guest iPhone)</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(249, 115, 22); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div></div>
        <div class="canvas-viewport" id="canvas-viewport">
          <svg id="map" viewBox="1067.236760240865 -403.93815895549926 2864.859130912127 2148.644348184095" style=""><defs><marker id="arrow-forward" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto" markerUnits="strokeWidth"><path d="M0,0 L0,6 L9,3 z" fill="context-stroke"></path></marker><marker id="arrow-backward" markerWidth="10" markerHeight="10" refX="0" refY="3" orient="auto" markerUnits="strokeWidth"><path d="M9,0 L9,6 L0,3 z" fill="context-stroke"></path></marker></defs><rect x="100" y="100" width="3800" height="2800" fill="none" stroke="#4755694D" stroke-width="20" stroke-dasharray="10 5" rx="8"></rect><g id="canvas-grid"><line x1="100" y1="100" x2="100" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="150" y1="100" x2="150" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="200" y1="100" x2="200" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="250" y1="100" x2="250" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="300" y1="100" x2="300" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="350" y1="100" x2="350" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="400" y1="100" x2="400" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="450" y1="100" x2="450" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="500" y1="100" x2="500" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="550" y1="100" x2="550" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="600" y1="100" x2="600" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="650" y1="100" x2="650" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="700" y1="100" x2="700" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="750" y1="100" x2="750" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="800" y1="100" x2="800" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="850" y1="100" x2="850" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="900" y1="100" x2="900" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="950" y1="100" x2="950" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1000" y1="100" x2="1000" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1050" y1="100" x2="1050" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1100" y1="100" x2="1100" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="1150" y1="100" x2="1150" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1200" y1="100" x2="1200" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1250" y1="100" x2="1250" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1300" y1="100" x2="1300" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1350" y1="100" x2="1350" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="1400" y1="100" x2="1400" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1450" y1="100" x2="1450" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1500" y1="100" x2="1500" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1550" y1="100" x2="1550" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1600" y1="100" x2="1600" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="1650" y1="100" x2="1650" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1700" y1="100" x2="1700" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1750" y1="100" x2="1750" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1800" y1="100" x2="1800" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1850" y1="100" x2="1850" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="1900" y1="100" x2="1900" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1950" y1="100" x2="1950" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2000" y1="100" x2="2000" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2050" y1="100" x2="2050" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2100" y1="100" x2="2100" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="2150" y1="100" x2="2150" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2200" y1="100" x2="2200" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2250" y1="100" x2="2250" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2300" y1="100" x2="2300" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2350" y1="100" x2="2350" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="2400" y1="100" x2="2400" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2450" y1="100" x2="2450" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2500" y1="100" x2="2500" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2550" y1="100" x2="2550" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2600" y1="100" x2="2600" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="2650" y1="100" x2="2650" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2700" y1="100" x2="2700" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2750" y1="100" x2="2750" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2800" y1="100" x2="2800" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2850" y1="100" x2="2850" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="2900" y1="100" x2="2900" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2950" y1="100" x2="2950" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3000" y1="100" x2="3000" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3050" y1="100" x2="3050" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3100" y1="100" x2="3100" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="3150" y1="100" x2="3150" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3200" y1="100" x2="3200" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3250" y1="100" x2="3250" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3300" y1="100" x2="3300" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3350" y1="100" x2="3350" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="3400" y1="100" x2="3400" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3450" y1="100" x2="3450" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3500" y1="100" x2="3500" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3550" y1="100" x2="3550" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3600" y1="100" x2="3600" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="3650" y1="100" x2="3650" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3700" y1="100" x2="3700" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3750" y1="100" x2="3750" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3800" y1="100" x2="3800" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3850" y1="100" x2="3850" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="3900" y1="100" x2="3900" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="100" x2="3900" y2="100" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="150" x2="3900" y2="150" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="200" x2="3900" y2="200" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="250" x2="3900" y2="250" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="300" x2="3900" y2="300" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="350" x2="3900" y2="350" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="400" x2="3900" y2="400" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="450" x2="3900" y2="450" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="500" x2="3900" y2="500" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="550" x2="3900" y2="550" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="600" x2="3900" y2="600" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="650" x2="3900" y2="650" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="700" x2="3900" y2="700" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="750" x2="3900" y2="750" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="800" x2="3900" y2="800" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="850" x2="3900" y2="850" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="900" x2="3900" y2="900" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="950" x2="3900" y2="950" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1000" x2="3900" y2="1000" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1050" x2="3900" y2="1050" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1100" x2="3900" y2="1100" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="1150" x2="3900" y2="1150" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1200" x2="3900" y2="1200" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1250" x2="3900" y2="1250" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1300" x2="3900" y2="1300" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1350" x2="3900" y2="1350" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="1400" x2="3900" y2="1400" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1450" x2="3900" y2="1450" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1500" x2="3900" y2="1500" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1550" x2="3900" y2="1550" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1600" x2="3900" y2="1600" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="1650" x2="3900" y2="1650" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1700" x2="3900" y2="1700" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1750" x2="3900" y2="1750" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1800" x2="3900" y2="1800" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1850" x2="3900" y2="1850" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="1900" x2="3900" y2="1900" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1950" x2="3900" y2="1950" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2000" x2="3900" y2="2000" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2050" x2="3900" y2="2050" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2100" x2="3900" y2="2100" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="2150" x2="3900" y2="2150" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2200" x2="3900" y2="2200" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2250" x2="3900" y2="2250" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2300" x2="3900" y2="2300" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2350" x2="3900" y2="2350" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="2400" x2="3900" y2="2400" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2450" x2="3900" y2="2450" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2500" x2="3900" y2="2500" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2550" x2="3900" y2="2550" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2600" x2="3900" y2="2600" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="2650" x2="3900" y2="2650" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2700" x2="3900" y2="2700" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2750" x2="3900" y2="2750" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2800" x2="3900" y2="2800" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2850" x2="3900" y2="2850" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="2900" x2="3900" y2="2900" stroke="#47556933" stroke-width="1"></line></g><g class="rect-group" data-rect-id="rect-1765238219615"><rect class="rect-shape" x="2680.053955078125" y="251.44879150390625" width="814.10400390625" height="389.26678466796875" style="fill: rgb(236, 9, 153); fill-opacity: 0.3; stroke: rgb(236, 9, 153); stroke-width: 2px; stroke-dasharray: none; cursor: move;"></rect><g class="rect-delete-btn" style="cursor: pointer; display: none;"><circle cx="3484.157958984375" cy="261.44879150390625" r="12" style="fill: rgb(245, 101, 101); stroke: white; stroke-width: 2;"></circle><text x="3484.157958984375" y="261.44879150390625" text-anchor="middle" dominant-baseline="middle" style="fill: white; font-size: 16px; font-weight: bold; pointer-events: none;">×</text></g></g><path d="M 2071.640165880771 218.24354238566275 Q 2069.3039587352528 345.82772790170964 2066.9677515897347 473.4119134177565" fill="none" class="edge" data-edge-id="internet-internet-copy-1765238145151" data-from="internet" data-to="internet-copy" style="stroke: rgb(85, 226, 8); stroke-width: 4;"></path><path d="M 2071.640165880771 218.24354238566275 Q 2069.3039587352528 345.82772790170964 2066.9677515897347 473.4119134177565" fill="none" data-edge-id="internet-internet-copy-1765238145151" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 1921.3019190702034 570.8918786277175 1775.6360865506722 668.3718438376784" fill="none" class="edge" data-edge-id="internet-copy-opnsense-copy-1765238187451" data-from="internet-copy" data-to="opnsense-copy" style="stroke: rgb(76, 0, 255); stroke-width: 4;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 1921.3019190702034 570.8918786277175 1775.6360865506722 668.3718438376784" fill="none" data-edge-id="internet-copy-opnsense-copy-1765238187451" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2000.8787827715962 627.8447547749242 1934.7898139534577 782.2775961320921" fill="none" class="edge" data-edge-id="internet-copy-docker-copy-1765238242477" data-from="internet-copy" data-to="docker-copy" style="stroke: rgb(76, 0, 255); stroke-width: 4;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2000.8787827715962 627.8447547749242 1934.7898139534577 782.2775961320921" fill="none" data-edge-id="internet-copy-docker-copy-1765238242477" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2112.546995662221 620.5620704487524 2158.1262397347077 767.7122274797483" fill="none" class="edge" data-edge-id="internet-copy-docker-copy-1-1765238244637" data-from="internet-copy" data-to="docker-copy-1" style="stroke: rgb(76, 0, 255); stroke-width: 4;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2112.546995662221 620.5620704487524 2158.1262397347077 767.7122274797483" fill="none" data-edge-id="internet-copy-docker-copy-1-1765238244637" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2206.4130845294085 552.590055067893 2345.8584174690827 631.7681967180296" fill="none" class="edge" data-edge-id="internet-copy-docker-copy-2-1765238246233" data-from="internet-copy" data-to="docker-copy-2" style="stroke: rgb(76, 0, 255); stroke-width: 4;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2206.4130845294085 552.590055067893 2345.8584174690827 631.7681967180296" fill="none" data-edge-id="internet-copy-docker-copy-2-1765238246233" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2071.640165880771 218.24354238566275 Q 2414.759822984287 262.92762699742593 2757.879480087803 307.6117116091891" fill="none" class="edge" data-edge-id="internet-opnsense-copy-1-1765238266117" data-from="internet" data-to="opnsense-copy-1" style="stroke: rgb(128, 255, 0); stroke-width: 4;"></path><path d="M 2071.640165880771 218.24354238566275 Q 2414.759822984287 262.92762699742593 2757.879480087803 307.6117116091891" fill="none" data-edge-id="internet-opnsense-copy-1-1765238266117" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2757.879480087803 307.6117116091891 Q 2979.171899521397 314.04065142852505 3200.4643189549906 320.469591247861" fill="none" class="edge" data-edge-id="opnsense-copy-1-dns-1765238347996" data-from="opnsense-copy-1" data-to="dns" style="stroke: rgb(251, 0, 255); stroke-width: 4;"></path><path d="M 2757.879480087803 307.6117116091891 Q 2979.171899521397 314.04065142852505 3200.4643189549906 320.469591247861" fill="none" data-edge-id="opnsense-copy-1-dns-1765238347996" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 3200.4643189549906 320.469591247861 Q 3094.0802247167094 404.02690325957974 2987.696130478428 487.5842152712985" fill="none" class="edge" data-edge-id="dns-desktop-1765238386101" data-from="dns" data-to="desktop" style="stroke: rgb(255, 0, 208); stroke-width: 4;"></path><path d="M 3200.4643189549906 320.469591247861 Q 3094.0802247167094 404.02690325957974 2987.696130478428 487.5842152712985" fill="none" data-edge-id="dns-desktop-1765238386101" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 3312.857751572178 502.58220111114224 Q 3256.6610352635844 411.5258961795016 3200.4643189549906 320.469591247861" fill="none" class="edge" data-edge-id="phone-dns-1765238391156" data-from="phone" data-to="dns" style="stroke: rgb(255, 0, 208); stroke-width: 4;"></path><path d="M 3312.857751572178 502.58220111114224 Q 3256.6610352635844 411.5258961795016 3200.4643189549906 320.469591247861" fill="none" data-edge-id="phone-dns-1765238391156" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><polyline class="edge" data-edge-id="custom-1765238841477" fill="none" marker-start="url(#arrow-backward)" marker-end="url(#arrow-forward)" points="2905.255615234375,805.3433837890625 3189.95556640625,1005.8710327148438 2788.900390625,1008.3466796875" style="stroke: rgb(249, 115, 22); stroke-width: 4; stroke-dasharray: none;"></polyline><polyline points="2905.255615234375,805.3433837890625 3189.95556640625,1005.8710327148438 2788.900390625,1008.3466796875" data-edge-id="custom-1765238841477" style="fill: none; stroke: transparent; stroke-width: 20; cursor: pointer;"></polyline><g class="node-group" data-node-id="internet" transform="translate(2071.640165880771,218.24354238566275)" style="cursor: grab;"><circle r="127.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><rect x="-85" y="-85" width="170" height="170" rx="4" class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"></rect><text class="node-label" x="0" y="-23.8" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Internet</text><text class="node-sub" x="0" y="34" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="internet-copy" transform="translate(2066.9677515897347,473.4119134177565)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-55" y="-44" width="110" height="88" rx="4"></rect><line x1="-46.75" y1="-27.5" x2="46.75" y2="-27.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="-2.75" x2="46.75" y2="-2.75" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="22" x2="46.75" y2="22" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="-44" x2="-27.5" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="-44" x2="11" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="-19.25" x2="-8.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="-19.25" x2="30.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="5.5" x2="-27.5" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="5.5" x2="11" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="30.25" x2="-8.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="30.25" x2="30.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">OPNSENSE</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="opnsense-copy" transform="translate(1775.6360865506722,668.3718438376784)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-55" y="-44" width="110" height="88" rx="4"></rect><line x1="-46.75" y1="-27.5" x2="46.75" y2="-27.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="-2.75" x2="46.75" y2="-2.75" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="22" x2="46.75" y2="22" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="-44" x2="-27.5" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="-44" x2="11" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="-19.25" x2="-8.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="-19.25" x2="30.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="5.5" x2="-27.5" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="5.5" x2="11" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="30.25" x2="-8.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="30.25" x2="30.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Docker</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="docker-copy" transform="translate(1934.7898139534577,782.2775961320921)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-55" y="-44" width="110" height="88" rx="4"></rect><line x1="-46.75" y1="-27.5" x2="46.75" y2="-27.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="-2.75" x2="46.75" y2="-2.75" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="22" x2="46.75" y2="22" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="-44" x2="-27.5" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="-44" x2="11" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="-19.25" x2="-8.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="-19.25" x2="30.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="5.5" x2="-27.5" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="5.5" x2="11" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="30.25" x2="-8.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="30.25" x2="30.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Docker2</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="docker-copy-1" transform="translate(2158.1262397347077,767.7122274797483)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-55" y="-44" width="110" height="88" rx="4"></rect><line x1="-46.75" y1="-27.5" x2="46.75" y2="-27.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="-2.75" x2="46.75" y2="-2.75" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="22" x2="46.75" y2="22" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="-44" x2="-27.5" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="-44" x2="11" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="-19.25" x2="-8.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="-19.25" x2="30.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="5.5" x2="-27.5" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="5.5" x2="11" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="30.25" x2="-8.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="30.25" x2="30.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Docker3</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="docker-copy-2" transform="translate(2345.8584174690827,631.7681967180296)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-55" y="-44" width="110" height="88" rx="4"></rect><line x1="-46.75" y1="-27.5" x2="46.75" y2="-27.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="-2.75" x2="46.75" y2="-2.75" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="22" x2="46.75" y2="22" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="-44" x2="-27.5" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="-44" x2="11" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="-19.25" x2="-8.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="-19.25" x2="30.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="5.5" x2="-27.5" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="5.5" x2="11" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="30.25" x2="-8.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="30.25" x2="30.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Docker 4</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="opnsense-copy-1" transform="translate(2757.879480087803,307.6117116091891)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-55" y="-44" width="110" height="88" rx="4"></rect><line x1="-46.75" y1="-27.5" x2="46.75" y2="-27.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="-2.75" x2="46.75" y2="-2.75" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="22" x2="46.75" y2="22" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="-44" x2="-27.5" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="-44" x2="11" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="-19.25" x2="-8.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="-19.25" x2="30.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="5.5" x2="-27.5" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="5.5" x2="11" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="30.25" x2="-8.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="30.25" x2="30.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">OPNSENSE GUEST</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="phone" transform="translate(3312.857751572178,502.58220111114224)" style="cursor: grab;"><circle r="181.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-54.45" y="-121" width="108.9" height="242" rx="8"></rect><rect x="-45.980000000000004" y="-102.85" width="91.96000000000001" height="193.60000000000002" rx="4" style="fill: rgb(30, 41, 59);"></rect><rect x="-18.15" y="99.22" width="36.3" height="7.26" rx="2" style="fill: rgb(71, 85, 105);"></rect></g><text class="node-label" x="0" y="-33.88" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Phone</text><text class="node-sub" x="0" y="48.400000000000006" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="desktop" transform="translate(2987.696130478428,487.5842152712985)" style="cursor: grab;"><circle r="220.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-132.3" y="-117.60000000000001" width="264.6" height="176.4" rx="4"></rect><rect x="-110.25" y="-95.55" width="220.5" height="132.3" rx="2" style="fill: rgb(30, 41, 59);"></rect><rect x="-22.05" y="58.800000000000004" width="44.1" height="44.1"></rect><rect x="-73.5" y="102.89999999999999" width="147" height="22.05" rx="2"></rect></g><text class="node-label" x="0" y="-41.160000000000004" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Desktop</text><text class="node-sub" x="0" y="58.800000000000004" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="dns" transform="translate(3200.4643189549906,320.469591247861)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><path d="
             M -44 11
             Q -60.50000000000001 11 -60.50000000000001 -5.5
             Q -60.50000000000001 -27.5 -38.5 -27.5
             Q -38.5 -49.5 -11 -49.5
             Q 5.5 -60.50000000000001 27.5 -44
             Q 55 -44 60.50000000000001 -16.5
             Q 71.5 -5.5 60.50000000000001 11
             Q 60.50000000000001 27.5 38.5 27.5
             L -27.5 27.5
             Q -49.5 27.5 -49.5 11
             Z
            " class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"></path><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">DNS</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="racked" transform="translate(2600.8697010779656,975.5665527522032)" style="cursor: grab;"><circle r="205.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-164.4" y="-82.2" width="328.8" height="164.4" rx="4"></rect><line x1="-123.3" y1="-41.1" x2="-123.3" y2="41.1" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="-54.8" y1="-41.1" x2="-54.8" y2="41.1" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="13.700000000000003" y1="-41.1" x2="13.700000000000003" y2="41.1" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><circle cx="123.3" cy="0" r="13.700000000000001" style="fill: rgb(74, 222, 128);"></circle></g><text class="node-label" x="0" y="-38.36000000000001" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Racked</text><text class="node-sub" x="0" y="54.800000000000004" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;"></text></g><g class="text-group" data-text-id="text-1765238422602"><text class="text-element" x="2402.130859375" y="736.7828979492188" dominant-baseline="middle" style="fill: rgb(226, 232, 240); font-size: 48px; font-weight: normal; font-style: normal; text-anchor: start; text-decoration: none; opacity: 1; cursor: move; user-select: none;"><tspan x="2402.130859375" dy="0">Double click on desktop</tspan><tspan x="2402.130859375" dy="57.599999999999994">or long press on mobile</tspan><tspan x="2402.130859375" dy="57.599999999999994">to enter rack canvas view</tspan></text><g class="text-delete-btn" style="cursor: pointer; display: none;"><circle cx="2422.130859375" cy="688.7828979492188" r="12" style="fill: rgb(245, 101, 101); stroke: white; stroke-width: 2;"></circle><text x="2422.130859375" y="688.7828979492188" text-anchor="middle" dominant-baseline="middle" style="fill: white; font-size: 16px; font-weight: bold; pointer-events: none;">×</text></g></g></svg>
        </div>
        <div class="minimap-zoom-wrapper" id="minimap-zoom-wrapper" style="display: block;">
          <button type="button" class="minimap-close-btn" id="minimap-close-btn" title="Hide map &amp; zoom">✕</button>
          <div class="minimap-container" id="minimap-container">
            <svg id="minimap" viewBox="0 0 4000 3000">
              <line x1="2071.640165880771" y1="218.24354238566275" x2="2066.9677515897347" y2="473.4119134177565" class="minimap-edge"></line><line x1="2066.9677515897347" y1="473.4119134177565" x2="1775.6360865506722" y2="668.3718438376784" class="minimap-edge"></line><line x1="2066.9677515897347" y1="473.4119134177565" x2="1934.7898139534577" y2="782.2775961320921" class="minimap-edge"></line><line x1="2066.9677515897347" y1="473.4119134177565" x2="2158.1262397347077" y2="767.7122274797483" class="minimap-edge"></line><line x1="2066.9677515897347" y1="473.4119134177565" x2="2345.8584174690827" y2="631.7681967180296" class="minimap-edge"></line><line x1="2071.640165880771" y1="218.24354238566275" x2="2757.879480087803" y2="307.6117116091891" class="minimap-edge"></line><line x1="2757.879480087803" y1="307.6117116091891" x2="3200.4643189549906" y2="320.469591247861" class="minimap-edge"></line><line x1="3200.4643189549906" y1="320.469591247861" x2="2987.696130478428" y2="487.5842152712985" class="minimap-edge"></line><line x1="3312.857751572178" y1="502.58220111114224" x2="3200.4643189549906" y2="320.469591247861" class="minimap-edge"></line><circle cx="2071.640165880771" cy="218.24354238566275" r="40" class="minimap-node"></circle><circle cx="2066.9677515897347" cy="473.4119134177565" r="40" class="minimap-node"></circle><circle cx="1775.6360865506722" cy="668.3718438376784" r="40" class="minimap-node"></circle><circle cx="1934.7898139534577" cy="782.2775961320921" r="40" class="minimap-node"></circle><circle cx="2158.1262397347077" cy="767.7122274797483" r="40" class="minimap-node"></circle><circle cx="2345.8584174690827" cy="631.7681967180296" r="40" class="minimap-node"></circle><circle cx="2757.879480087803" cy="307.6117116091891" r="40" class="minimap-node"></circle><circle cx="3312.857751572178" cy="502.58220111114224" r="40" class="minimap-node"></circle><circle cx="2987.696130478428" cy="487.5842152712985" r="40" class="minimap-node"></circle><circle cx="3200.4643189549906" cy="320.469591247861" r="40" class="minimap-node"></circle><circle cx="2600.8697010779656" cy="975.5665527522032" r="40" class="minimap-node"></circle><rect class="minimap-viewport" id="minimap-viewport" x="1067.236760240865" y="-403.93815895549926" width="2864.859130912127" height="2148.644348184095"></rect>
            </svg>
          </div>
          <div class="zoom-toolbar" id="zoom-toolbar">
            <button id="zoom-in-btn" title="Zoom in">+</button>
            <div class="zoom-level" id="zoom-level">140%</div>
            <button id="zoom-out-btn" title="Zoom out">-</button>
            <div class="divider"></div>
            <button id="zoom-fit-btn" title="Fit to view">[ ]</button>
            <button id="zoom-reset-btn" title="Reset view">R</button>
          </div>
        </div>
        <button type="button" id="edge-legend-mini" class="legend-mini-btn" style="bottom: 10px; display: none;">Line Legend</button>
        <button type="button" id="minimap-mini" class="legend-mini-btn" style="right: 10px; left: auto; bottom: 10px; display: none;">Map</button>
        <button type="button" id="draw-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: 10px; right: auto;">Draw</button>
        <button type="button" id="topology-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: auto; right: 40px;">Add Line</button></section>
      <aside class="details-panel" id="details-panel">
        <div class="sidebar-resizer" id="sidebar-resizer">
          <svg class="resizer-icon" width="6" height="40" viewBox="0 0 6 40" xmlns="http://www.w3.org/2000/svg">
            <circle cx="3" cy="14" r="2"></circle>
            <circle cx="3" cy="20" r="2"></circle>
            <circle cx="3" cy="26" r="2"></circle>
          </svg>
        </div>
        <div class="mobile-footer-resizer" id="mobile-footer-resizer">
          <svg class="resizer-icon" width="40" height="6" viewBox="0 0 40 6" xmlns="http://www.w3.org/2000/svg">
            <circle cx="14" cy="3" r="2"></circle>
            <circle cx="20" cy="3" r="2"></circle>
            <circle cx="26" cy="3" r="2"></circle>
          </svg>
        </div>
        <div id="node-panel" style="display: none;">
          <div class="details-name editable-text" id="node-name">SAN Secondary</div>
          <div class="details-ip editable-text" id="node-ip">10.10.2.11</div>
          <div class="details-role" id="node-role">Secondary Storage</div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px;">MAC:</span>
            <span class="editable-text" id="node-mac" style="margin-left: 8px; font-size: 14px;">00:A0:98:AA:01:02</span>
          </div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px;">Rack Unit:</span>
            <span class="editable-text" id="node-rack" style="margin-left: 8px; font-size: 14px;">22</span>
          </div>
          <div class="details-info-row" id="uheight-row" style="display: flex;">
            <span style="color: var(--text-soft); font-size: 14px;">U Height:</span>
            <span class="editable-text" id="node-uheight" style="margin-left: 8px; font-size: 14px;">6U</span>
          </div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px;">Layer:</span>
            <select id="node-layer" style="margin-left: 8px; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;">
              <option value="physical">Physical</option>
              <option value="logical">Logical</option>
              <option value="security">Security</option>
              <option value="application">Application</option>
            </select>
          </div>
          <div class="details-info-row" id="assigned-rack-row" style="display: flex;">
            <span style="color: var(--text-soft); font-size: 14px;">Assigned Rack:</span>
            <select id="node-assigned-rack" style="margin-left: 8px; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;"><option value="">None</option><option value="racked">Racked</option></select>
          </div>
          <div class="details-info-row" id="rack-capacity-row" style="display: none;">
            <span style="color: var(--text-soft); font-size: 14px;">Rack Capacity:</span>
            <select id="node-rack-capacity" style="margin-left: 8px; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;">
              <option value="42">42U</option>
              <option value="48">48U</option>
              <option value="24">24U</option>
              <option value="12">12U</option>
			  <option value="6">6U</option>
            </select>
          </div>
		  <details id="rack-contents-section" style="display: none; margin-top: 12px; margin-bottom: 12px; padding: 10px; background: var(--panel-alt); border-radius: 6px;" open="">
            <summary style="color: var(--accent); font-weight: 600; font-size: 14px; cursor: pointer;">Nodes in Rack (<span id="rack-contents-count">0</span>)</summary>
            <div id="rack-contents-list" style="max-height: 200px; overflow-y: auto; margin-top: 8px;"><div style="padding: 6px 0; border-bottom: 1px solid var(--edge-main); cursor: pointer;" onclick="claimTheImmortal('san-primary')">
            <span style="color: var(--text-main);">SAN Primary</span><span style="background: var(--accent); color: var(--bg); padding: 2px 6px; border-radius: 4px; font-size: 11px; margin-left: 4px;">storage</span><span style="background: var(--accent); color: var(--bg); padding: 2px 6px; border-radius: 4px; font-size: 11px; margin-left: 4px;">san</span><span style="background: var(--accent); color: var(--bg); padding: 2px 6px; border-radius: 4px; font-size: 11px; margin-left: 4px;">netapp</span>
           </div><div style="padding: 6px 0; border-bottom: 1px solid var(--edge-main); cursor: pointer;" onclick="claimTheImmortal('san-secondary')">
            <span style="color: var(--text-main);">SAN Secondary</span><span style="background: var(--accent); color: var(--bg); padding: 2px 6px; border-radius: 4px; font-size: 11px; margin-left: 4px;">storage</span><span style="background: var(--accent); color: var(--bg); padding: 2px 6px; border-radius: 4px; font-size: 11px; margin-left: 4px;">san</span><span style="background: var(--accent); color: var(--bg); padding: 2px 6px; border-radius: 4px; font-size: 11px; margin-left: 4px;">netapp</span>
           </div><div style="padding: 6px 0; border-bottom: 1px solid var(--edge-main); cursor: pointer;" onclick="claimTheImmortal('fc-switch-1')">
            <span style="color: var(--text-main);">FC Switch 1</span><span style="background: var(--accent); color: var(--bg); padding: 2px 6px; border-radius: 4px; font-size: 11px; margin-left: 4px;">storage</span><span style="background: var(--accent); color: var(--bg); padding: 2px 6px; border-radius: 4px; font-size: 11px; margin-left: 4px;">fc</span><span style="background: var(--accent); color: var(--bg); padding: 2px 6px; border-radius: 4px; font-size: 11px; margin-left: 4px;">fabric-a</span>
           </div><div style="padding: 6px 0; border-bottom: 1px solid var(--edge-main); cursor: pointer;" onclick="claimTheImmortal('fc-switch-2')">
            <span style="color: var(--text-main);">FC Switch 2</span><span style="background: var(--accent); color: var(--bg); padding: 2px 6px; border-radius: 4px; font-size: 11px; margin-left: 4px;">storage</span><span style="background: var(--accent); color: var(--bg); padding: 2px 6px; border-radius: 4px; font-size: 11px; margin-left: 4px;">fc</span><span style="background: var(--accent); color: var(--bg); padding: 2px 6px; border-radius: 4px; font-size: 11px; margin-left: 4px;">fabric-b</span>
           </div><div style="padding: 6px 0; border-bottom: 1px solid var(--edge-main); cursor: pointer;" onclick="claimTheImmortal('tor-switch-b1')">
            <span style="color: var(--text-main);">ToR Switch B1</span><span style="background: var(--accent); color: var(--bg); padding: 2px 6px; border-radius: 4px; font-size: 11px; margin-left: 4px;">tor</span><span style="background: var(--accent); color: var(--bg); padding: 2px 6px; border-radius: 4px; font-size: 11px; margin-left: 4px;">access</span><span style="background: var(--accent); color: var(--bg); padding: 2px 6px; border-radius: 4px; font-size: 11px; margin-left: 4px;">rack-b1</span>
           </div></div>
          </details>
          <div class="badge-row" id="node-tags"><span class="badge" style="cursor: pointer; position: relative;"><span>storage</span><span style="opacity: 0.6; margin-left: 4px; font-size: 10px;"> ✕</span></span><span class="badge" style="cursor: pointer; position: relative;"><span>san</span><span style="opacity: 0.6; margin-left: 4px; font-size: 10px;"> ✕</span></span><span class="badge" style="cursor: pointer; position: relative;"><span>netapp</span><span style="opacity: 0.6; margin-left: 4px; font-size: 10px;"> ✕</span></span><span class="badge" style="cursor: pointer; opacity: 0.6; border-style: dashed;">+ Add Tag</span></div>
          <div class="size-controls">
            <label>Size:</label>
            <input type="range" id="size-slider" min="20" max="200" value="55">
            <span id="size-value">55</span>
            <button id="reset-size">Reset</button>
          </div>
          <details class="style-section">
            <summary>Styling</summary>
            <div class="style-content">
              <div class="style-row">
                <label>Screen:</label>
                <select id="style-scope">
                  <option value="all">All</option>
                  <option value="desktop">Desktop</option>
                  <option value="tablet">Tablet</option>
                  <option value="mobile">Mobile</option>
                  <option value="fold">Fold</option>
                </select>
              </div>
              <div class="style-row">
                <label>Shape:</label>
                <select id="shape-select">
                  <optgroup label="Basic Shapes">
				  <option value="circle">Circle</option>
				  <option value="square">Square</option>
				  <option value="rectangle">Rectangle</option>
				  <option value="triangle">Triangle</option>
				  <option value="hexagon">Hexagon</option>
				  <option value="diamond">Diamond</option>
				  <option value="star">Star</option>
				  <option value="stop-sign">Stop Sign</option>
				  <option value="octagon">Octagon</option>
				  <option value="pentagon">Pentagon</option>
				  <option value="cross">Cross</option>
				  <option value="rounded-square">Rounded Square</option>
				  <option value="pill">Pill</option>
				  <option value="parallelogram">Parallelogram</option>
				  <option value="trapezoid">Trapezoid</option>
				</optgroup>
			  <optgroup label="Computers &amp; Devices">
			      <option value="server">Server</option>
				  <option value="pc">PC / Desktop</option>
				  <option value="laptop">Laptop</option>
				  <option value="phone">Phone / Mobile</option>
				  <option value="printer">Printer</option>
				  <option value="pi">Raspberry Pi</option>
				  <option value="sensor">Sensor / IoT</option>
			  </optgroup>
			  <optgroup label="Network Equipment">
				  <option value="router">Router</option>
				  <option value="switch">Switch</option>
				  <option value="firewall">Firewall</option>
				  <option value="access-point">Access Point</option>
				  <option value="load-balancer">Load Balancer</option>
				  <option value="gateway">Gateway</option>
				  <option value="vpn">VPN / Tunnel</option>
				  <option value="nas">NAS / Storage</option>
			  </optgroup>
			  <optgroup label="Cloud &amp; Services">
			      <option value="cloud">Cloud</option>
				  <option value="database">Database</option>
				  <option value="docker">Docker</option>
				  <option value="container">Container</option>
				  <option value="vm">Virtual Machine</option>
				  <option value="kubernetes">Kubernetes</option>
				  <option value="api">API / Endpoint</option>
				  <option value="queue">Queue / Message</option>
				  <option value="lambda">Lambda / Function</option>
				  <option value="bucket">Bucket / S3</option>
			  </optgroup>
			  <optgroup label="Security &amp; Monitoring">
				  <option value="shield">Shield</option>
				  <option value="camera">Camera / CCTV</option>
				  <option value="monitor">Monitor / Dashboard</option>
			  </optgroup>
             </select>
              </div>
              <div class="style-row">
                <label>Fill Color:</label>
                <input type="color" id="circle-color" value="#1e293b">
              </div>
              <div class="style-row">
                <label>Border Color:</label>
                <input type="color" id="circle-border" value="#475569">
              </div>
              <div class="style-row">
                <label>Title Color:</label>
                <input type="color" id="title-color" value="#e2e8f0">
              </div>
              <div class="style-row">
                <label>Title Font:</label>
                <select id="title-font">
                  <option value="system-ui, sans-serif"> System UI </option>
                  <option value="monospace">Monospace</option>
                  <option value="serif">Serif</option>
                  <option value="cursive">Cursive</option>
                  <option value="'Courier New', monospace"> Courier </option>
                  <option value="Arial, sans-serif">Arial</option>
                  <option value="'Times New Roman', serif"> Times </option>
                </select>
              </div>
              <div class="style-row">
                <label>Title Size:</label>
                <input type="number" id="title-size" min="8" max="100" value="18">
              </div>
              <div class="style-row">
                <label>Sub Color:</label>
                <input type="color" id="sub-color" value="#94a3b8">
              </div>
              <div class="style-row">
                <label>Sub Font:</label>
                <select id="sub-font">
                  <option value="system-ui, sans-serif"> System UI </option>
                  <option value="monospace">Monospace</option>
                  <option value="serif">Serif</option>
                  <option value="cursive">Cursive</option>
                  <option value="'Courier New', monospace"> Courier </option>
                  <option value="Arial, sans-serif">Arial</option>
                  <option value="'Times New Roman', serif"> Times </option>
                </select>
              </div>
              <div class="style-row">
                <label>Sub Size:</label>
                <input type="number" id="sub-size" min="6" max="80" value="13">
              </div>
              <div style="margin-top: 12px;padding-top: 10px;border-top: 1px solid var(--edge-main);">
                <div style="
                  font-size: 12px;
                  color: var(--text-soft);
                  margin-bottom: 8px;
                  text-transform: uppercase;
                  "> Text Position </div>
                <div class="style-row">
                  <label>Name Y:</label>
                  <input type="number" id="title-offset-y" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>Name X:</label>
                  <input type="number" id="title-offset-x" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>IP Y:</label>
                  <input type="number" id="sub-offset-y" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>IP X:</label>
                  <input type="number" id="sub-offset-x" min="-100" max="100" value="0" style="width: 60px">
                </div>
              </div>
              <button id="reset-styles" style="width: 100%;margin-top: 10px;padding: 8px;background: var(--panel);color: var(--text-main);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: clamp(13px, 1.5vw, 17px);">Reset Styles</button>
            </div>
          </details>
          <div class="section-label">Notes</div>
          <ul class="list" id="node-notes"><li><span style="flex: 1 1 0%;">NetApp AFF A400</span><span class="delete-note">✕</span></li><li><span style="flex: 1 1 0%;">500TB Raw</span><span class="delete-note">✕</span></li><li><span style="flex: 1 1 0%;">FC 32Gb</span><span class="delete-note">✕</span></li></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-note-input" placeholder="Type new note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-note-btn" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-node-btn" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: rgb(255, 255, 255);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;width: 100%;">Delete Node</button>
        </div>
        <div id="edge-panel" style="display: none">
          <div class="details-name" id="edge-title">Custom line</div>
          <div class="style-row" style="margin-top: 10px">
            <label>Width:</label>
            <input type="number" id="edge-width" min="1" max="20" value="4">
          </div>
          <div class="style-row">
            <label>Color:</label>
            <input type="color" id="edge-color" value="#475569">
          </div>
          <div class="style-row">
            <label>Line Style:</label>
            <select id="edge-line-style">
              <option value="solid">Solid</option>
              <option value="dashed">Dashed</option>
              <option value="dotted">Dotted</option>
            </select>
          </div>
          <div class="style-row">
            <label>Direction:</label>
            <select id="edge-direction">
              <option value="none">No arrows</option>
              <option value="forward">→ Forward</option>
              <option value="backward">← Backward</option>
              <option value="both">↔ Bidirectional</option>
            </select>
          </div>
          <div class="style-row" id="edge-from-port-row" style="display: none;">
            <label>From Port:</label>
            <input type="text" id="edge-from-port" placeholder="e.g. eth0, gi0/1" style="flex: 1;">
          </div>
          <div class="style-row" id="edge-to-port-row" style="display: none;">
            <label>To Port:</label>
            <input type="text" id="edge-to-port" placeholder="e.g. eth1, gi0/2" style="flex: 1;">
          </div>
          <div class="section-label">Line Notes</div>
          <ul class="list" id="edge-notes"></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-edge-note" placeholder="Add note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-edge-note" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-edge" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Delete Line</button>
        </div>
        <div id="rect-panel" style="display: none">
          <div class="details-name" id="rect-title">Zone</div>
          <div class="style-row" id="rect-fill-row" style="margin-top: 10px">
            <label>Fill Color:</label>
            <input type="color" id="rect-color" value="#f97316">
          </div>
          <div class="style-row">
            <label>Border Color:</label>
            <input type="color" id="rect-border-color" value="#f97316">
          </div>
          <div class="style-row">
            <label>Border Width:</label>
            <input type="number" id="rect-border-width" min="0" max="20" value="2">
          </div>
          <div class="style-row">
            <label>Style:</label>
            <select id="rect-style-select">
              <option value="filled">Filled</option>
              <option value="outlined">Outlined</option>
            </select>
          </div>
          <div class="style-row">
            <label>Line Style:</label>
            <select id="rect-line-style">
              <option value="solid">Solid</option>
              <option value="dashed">Dashed</option>
              <option value="dotted">Dotted</option>
            </select>
          </div>
          <div class="section-label">Zone Notes</div>
          <ul class="list" id="rect-notes"></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-rect-note" placeholder="Add note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-rect-note" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-rect" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Delete Zone</button>
        </div>
        <div id="text-panel" style="display: none">
          <div class="details-name" id="text-title">Text Element</div>
          <div class="style-row" style="margin-top: 10px">
            <label>Content:</label>
            <textarea id="text-content" placeholder="Enter text..." style="width: 100%;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: 14px;min-height: 80px;resize: vertical;font-family: inherit;"></textarea>
          </div>
          <div class="style-row">
            <label>Font Size:</label>
            <input type="number" id="text-font-size" min="8" max="200" value="18" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);">
          </div>
          <div class="style-row">
            <label>Color:</label>
            <input type="color" id="text-color" value="#e2e8f0">
          </div>
          <div class="style-row">
            <label>Font Weight:</label>
            <select id="text-font-weight" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="normal">Normal</option>
              <option value="bold">Bold</option>
              <option value="600">Semi-Bold</option>
              <option value="300">Light</option>
            </select>
          </div>
          <div class="style-row">
            <label>Font Style:</label>
            <select id="text-font-style" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="normal">Normal</option>
              <option value="italic">Italic</option>
            </select>
          </div>
          <div class="style-row">
            <label>Text Align:</label>
            <select id="text-align" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="start">Left</option>
              <option value="middle">Center</option>
              <option value="end">Right</option>
            </select>
          </div>
          <div class="style-row">
            <label>Text Decoration:</label>
            <select id="text-decoration" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="none">None</option>
              <option value="underline">Underline</option>
              <option value="line-through">Strike Through</option>
            </select>
          </div>
          <div class="style-row">
            <label>Background:</label>
            <input type="color" id="text-bg-color" value="#000000">
            <label style="margin-left: 10px; display: flex; align-items: center; gap: 6px;">
            <input type="checkbox" id="text-bg-enabled" style="cursor: pointer;">
            <span style="font-size: 13px;">Enable</span>
            </label>
          </div>
          <div class="style-row">
            <label>Opacity:</label>
            <input type="range" id="text-opacity" min="0" max="1" step="0.1" value="1" style="flex: 1">
            <span id="text-opacity-val" style="min-width: 35px; text-align: right">100%</span>
          </div>
          <button id="delete-text" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;width: 100%;"> Delete Text </button>
        </div>
        <details class="style-section" open="">
          <summary>Page Layout</summary>
          <div class="style-content">
            <div style="padding: 12px; background: var(--panel-alt); border-radius: 6px; color: var(--text-soft); font-size: 13px; line-height: 1.6;">
              <strong style="color: var(--accent); display: block; margin-bottom: 8px;">Drag to Resize:</strong>
              • <strong>Header:</strong> Drag the bottom edge of the header bar<br>
              • <strong>Sidebar:</strong> Drag the left edge of the sidebar panel<br>
              • <strong>Mobile:</strong> Drag the top edge of the footer panel<br>
              <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--edge-main); font-size: 12px;">
                Hover over panel edges to see resize handles
              </div>
            </div>
          </div>
        </details>
      </aside>
    </main>
    <script id="nodes-json" type="application/json">{}</script>
    <script id="topology-state" type="application/json">ENCRYPTED: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</script>
    <script>
      const BASE_NODE_DATA = JSON.parse(document.getElementById("nodes-json").textContent, );
      let currentNodeId = "host";
      let textDrawMode = false;
      let currentEdgeId = null;
      let currentStyleScope = "all";
      let NODE_DATA = {};
      let EDGE_DATA = {
       list: []
      };
      let currentRectId = null;
      let currentTextId = null;
      let rectDrawMode = false;
      let RECT_DATA = {
       list: []
      };
      let TEXT_DATA = {
       list: []
      };
      let EDGE_LEGEND = {};
      let freeDrawMode = false;
      let savedPositions = {};
      let savedSizes = {};
      let savedStyles = {};
      let legendCollapsed = false;
      let minimapCollapsed = false;
      let drawToolbarCollapsed = false;
      let activeLayers = new Set(["physical", "logical", "security", "application"]);
      let currentView = {
       mode: "topology",
       rackId: null
      };
      let savedTopologyView = null;
      let topologyToolbarCollapsed = false;
      let legendMiniBtn = null;
      let minimapMiniBtn = null;
      let drawToolbarMiniBtn = null;
      let topologyToolbarMiniBtn = null;
      let undoStack = [];
      let redoStack = [];
      const MAX_UNDO_STACK = 50;
      let selectedNodes = new Set();
      let selectedEdges = new Set();
      let selectedRects = new Set();
      let selectedTexts = new Set();
      let isSelecting = false;
      let selectionStart = null;
      let preDragSelectedNodes = new Set();
      let preDragSelectedEdges = new Set();
      let preDragSelectedRects = new Set();
      let preDragSelectedTexts = new Set();
      let selectionRect = null;
      let selectionBoxStyle = {
       fillColor: "#4fd1c5",
       fillOpacity: 0.1,
       strokeColor: "#4fd1c5",
       strokeWidth: 2,
       strokeDasharray: "5,5"
      };
      let isDraggingSelection = false;
      let dragSelectionStart = null;
      let clipboard = null;
      const ROLLBACK_STORAGE_KEY = "theonefile_rollbacks";
      const MAX_ROLLBACK_VERSIONS = 50;
      let rollbackVersions = [];
      let currentRollbackIndex = -1;
      const AUDIT_STORAGE_KEY = "theonefile_audit_log";
      let auditLog = [];
      const MAX_AUDIT_ENTRIES = 1000;
      let documentTabs = [{
        id: "main",
        name: "Main Topology",
        nodes: {},
        edges: { list: [] },
        positions: {},
        sizes: {},
        styles: {},
        legend: {},
        rects: { list: [] },
        texts: { list: [] },
      pageState: null
      }];
      let currentTabIndex = 0;
      let encryptedSections = {};
      let performanceMode = "auto";
      let cullOffscreenNodes = true;
      let minimapNeedsUpdate = true;
      let lastMinimapUpdate = 0;
      const MobileManager = {
        isMobile: false,
        detect() {
          if (navigator.userAgentData?.mobile === true) {
            this.isMobile = true;
            return true;
          }
          const coarse = matchMedia("(pointer: coarse)").matches;
          const width = window.innerWidth <= 900;
          const portrait = matchMedia("(orientation: portrait)").matches;
          this.isMobile = coarse;
          return this.isMobile;
        },
        applyInitialCollapse() {
          if (!this.isMobile) return;
          legendCollapsed = true;
          minimapCollapsed = true;
          drawToolbarCollapsed = true;
          topologyToolbarCollapsed = true;
          if (typeof updateLegendVisibility === "function") updateLegendVisibility();
          if (typeof updateMinimapVisibility === "function") updateMinimapVisibility();
          if (typeof updateDrawToolbarVisibility === "function") updateDrawToolbarVisibility();
          if (typeof updateTopologyToolbarVisibility === "function") updateTopologyToolbarVisibility();
        },
        updateBulkToolbar() {
          const desktop = document.getElementById("bulk-toolbar");
          const mobile = document.getElementById("bulk-toolbar-mobile");
          if (!desktop || !mobile) return;
          if (typeof selectedNodes === 'undefined' || selectedNodes.size === 0) {
           desktop.style.display = "none";
           mobile.style.display = "none";
           return;
          }
          const isVisible = desktop.style.display !== "none" || mobile.style.display !== "none";
          if (this.isMobile) {
            desktop.style.display = "none";
            if (isVisible) {
              mobile.style.display = "flex";
            }
          } else {
            mobile.style.display = "none";
            if (isVisible) {
              desktop.style.display = "flex";
            }
          }
        },
        updateLayout() {
          const main = document.querySelector("main");
          if (!main) return;
        },
        updateCanvasHint() {
      const hint = document.getElementById("canvas-hint");
      if (!hint) return;
      if (PAGE_STATE.canvasHintText !== undefined && PAGE_STATE.canvasHintText !== "") {
        hint.innerHTML = PAGE_STATE.canvasHintText;
        return;
      }
      const items = this.isMobile
      ? [
        "Pinch to zoom",
        "Drag to pan",
        "Add node from top menu",
        "Double tap to clone and align",
        "Double tap to select multiple",
        "You have the power",
        "Your time is NOW!",
      ]
      : [
        "Scroll to zoom",
        "Drag to pan",
        "Right click to clone and align",
        "Right click to select multiple",
	    "Hold Shift + drag mouse for marquee selection",
        "You have the power",
        "Your time is NOW!",
      ];
      const list = document.createElement("ul");
      for (const item of items) {
      const li = document.createElement("li");
      li.textContent = item;
      list.appendChild(li);
      }
      hint.replaceChildren(list);
      },
        autoSelectStyleScope() {
          const scope = document.getElementById("style-scope");
          if (!scope) return;
          if (this.isMobile) scope.value = "mobile";
        },
        updateToolbarStack() {
          if (!this.isMobile) return;
          const draw = document.getElementById("draw-toolbar");
          const topo = document.getElementById("topology-toolbar");
          if (!draw || !topo) return;
          const h = draw.getBoundingClientRect().height;
          document.documentElement.style.setProperty("--draw-toolbar-height", h + "px");
        },
        updateLayoutControls() {
          const sidebarRow = document.getElementById("sidebar-width-row");
          const footerRow = document.getElementById("mobile-footer-row");
          if (sidebarRow && footerRow) {
            if (this.isMobile) {
              sidebarRow.style.display = "none";
              footerRow.style.display = "flex";
            } else {
              sidebarRow.style.display = "flex";
              footerRow.style.display = "none";
            }
          }
        },
        applyAll() {
          this.detect();
          this.applyInitialCollapse();
          this.updateBulkToolbar();
          this.updateLayout();
          this.updateCanvasHint();
          this.autoSelectStyleScope();
          this.updateToolbarStack();
          this.updateLayoutControls();
        }
      };
      function isMobileDevice() {
        return MobileManager.isMobile;
      }
      function u8ToBase64(u8) {
      let binary = "";
      for (let i = 0; i < u8.length; i++) binary += String.fromCharCode(u8[i]);
      return btoa(binary);
      }
      function base64ToU8(base64) {
      const binary = atob(base64);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
      return bytes;
      }
			  function ensureLegendMiniButton() {
		   if (legendMiniBtn) return legendMiniBtn;
		   const handleClick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			legendCollapsed = false;
			updateLegendVisibility();
		   };
		   const preventTouch = (e) => { e.preventDefault(); };
		   const existing = document.getElementById("edge-legend-mini");
		   if (existing) {
			existing.addEventListener("click", handleClick);
			existing.addEventListener("touchstart", preventTouch, { passive: false });
			existing.addEventListener("touchend", handleClick);
			legendMiniBtn = existing;
			return existing;
		   }
		   const panel = document.querySelector(".topology-panel");
		   if (!panel) return null;
		   const btn = document.createElement("button");
		   btn.type = "button";
		   btn.id = "edge-legend-mini";
		   btn.className = "legend-mini-btn";
		   btn.textContent = "Legend";
		   btn.style.bottom = "10px";
		   btn.addEventListener("click", handleClick);
		   btn.addEventListener("touchstart", preventTouch, { passive: false });
		   btn.addEventListener("touchend", handleClick);
		   panel.appendChild(btn);
		   legendMiniBtn = btn;
		   return btn;
		}
			  function ensureMinimapMiniButton() {
		   if (minimapMiniBtn) return minimapMiniBtn;
		   const handleClick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			minimapCollapsed = false;
			updateMinimapVisibility();
		   };
		   const preventTouch = (e) => { e.preventDefault(); };
		   const existing = document.getElementById("minimap-mini");
		   if (existing) {
			existing.addEventListener("click", handleClick);
			existing.addEventListener("touchstart", preventTouch, { passive: false });
			existing.addEventListener("touchend", handleClick);
			minimapMiniBtn = existing;
			return existing;
		   }
		   const panel = document.querySelector(".topology-panel");
		   if (!panel) return null;
		   const btn = document.createElement("button");
		   btn.type = "button";
		   btn.id = "minimap-mini";
		   btn.className = "legend-mini-btn";
		   btn.textContent = "Map";
		   btn.style.right = "10px";
		   btn.style.left = "auto";
		   btn.style.bottom = "10px";
		   btn.addEventListener("click", handleClick);
		   btn.addEventListener("touchstart", preventTouch, { passive: false });
		   btn.addEventListener("touchend", handleClick);
		   panel.appendChild(btn);
		   minimapMiniBtn = btn;
		   return btn;
		}
			  function ensureDrawToolbarMiniButton() {
		   if (drawToolbarMiniBtn) return drawToolbarMiniBtn;
		   const handleClick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			drawToolbarCollapsed = false;
			updateDrawToolbarVisibility();
		   };
		   const preventTouch = (e) => { e.preventDefault(); };
		   const existing = document.getElementById("draw-toolbar-mini");
		   if (existing) {
			existing.addEventListener("click", handleClick);
			existing.addEventListener("touchstart", preventTouch, { passive: false });
			existing.addEventListener("touchend", handleClick);
			drawToolbarMiniBtn = existing;
			return existing;
		   }
		   const panel = document.querySelector(".topology-panel");
		   if (!panel) return null;
		   const btn = document.createElement("button");
		   btn.type = "button";
		   btn.id = "draw-toolbar-mini";
		   btn.className = "legend-mini-btn";
		   btn.textContent = "Draw";
		   btn.style.top = "10px";
		   btn.style.left = "10px";
		   btn.style.right = "auto";
		   btn.addEventListener("click", handleClick);
		   btn.addEventListener("touchstart", preventTouch, { passive: false });
		   btn.addEventListener("touchend", handleClick);
		   panel.appendChild(btn);
		   drawToolbarMiniBtn = btn;
		   return btn;
		}
			  function ensureTopologyToolbarMiniButton() {
		   if (topologyToolbarMiniBtn) return topologyToolbarMiniBtn;
		   const handleClick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			topologyToolbarCollapsed = false;
			updateTopologyToolbarVisibility();
		   };
		   const preventTouch = (e) => { e.preventDefault(); };
		   const existing = document.getElementById("topology-toolbar-mini");
		   if (existing) {
			existing.addEventListener("click", handleClick);
			existing.addEventListener("touchstart", preventTouch, { passive: false });
			existing.addEventListener("touchend", handleClick);
			topologyToolbarMiniBtn = existing;
			return existing;
		   }
		   const panel = document.querySelector(".topology-panel");
		   if (!panel) return null;
		   const btn = document.createElement("button");
		   btn.type = "button";
		   btn.id = "topology-toolbar-mini";
		   btn.className = "legend-mini-btn";
		   btn.textContent = "Add Line";
		   btn.style.top = "10px";
		   btn.style.left = "auto";
		   btn.style.right = "40px";
		   btn.addEventListener("click", handleClick);
		   btn.addEventListener("touchstart", preventTouch, { passive: false });
		   btn.addEventListener("touchend", handleClick);
		   panel.appendChild(btn);
		   topologyToolbarMiniBtn = btn;
		   return btn;
		}
      function updateToolbarStack() {
       if (!isMobileDevice()) return;
       const draw = document.getElementById("draw-toolbar");
       const topo = document.getElementById("topology-toolbar");
       if (!draw || !topo) return;
       const h = draw.getBoundingClientRect().height;
       document.documentElement.style.setProperty("--draw-toolbar-height", h + "px");
      }
      window.addEventListener("resize", updateToolbarStack);
      window.addEventListener("DOMContentLoaded", updateToolbarStack);
      updateToolbarStack();
      function updateLegendVisibility() {
       const legend = document.getElementById("edge-legend");
       const mini = ensureLegendMiniButton();
       if (!legend || !mini) return;
       const hasItems = legend.querySelectorAll(".legend-item").length > 0;
       if (!hasItems) {
        legend.style.display = "none";
        mini.style.display = "none";
        return;
       }
       if (legendCollapsed) {
        legend.style.display = "none";
        mini.style.display = "inline-flex";
       } else {
        legend.style.display = "flex";
        mini.style.display = "none";
       }
      }
      function updateMinimapVisibility() {
       const wrapper = document.getElementById("minimap-zoom-wrapper");
       const mini = ensureMinimapMiniButton();
       if (!wrapper || !mini) return;
       if (minimapCollapsed) {
        wrapper.style.display = "none";
        mini.style.display = "inline-flex";
       } else {
        wrapper.style.display = "block";
        mini.style.display = "none";
       }
      }
      function updateDrawToolbarVisibility() {
       const toolbar = document.getElementById("draw-toolbar");
       const mini = ensureDrawToolbarMiniButton();
       if (isViewOnly()) {
        if (toolbar) toolbar.style.setProperty('display', 'none', 'important');
        if (mini) mini.style.display = "none";
        return;
       }
       if (!toolbar || !mini) return;
       if (drawToolbarCollapsed) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "inline-flex";
       } else {
      if (isMobileDevice()) {
        toolbar.style.setProperty('display', 'grid', 'important');
        mini.style.display = "none";
      } else {
        toolbar.style.setProperty('display', 'flex', 'important');
        mini.style.display = "none";
      }
       }
      }
      function updateTopologyToolbarVisibility() {
       const toolbar = document.getElementById("topology-toolbar");
       const mini = ensureTopologyToolbarMiniButton();
       if (isViewOnly()) {
        if (toolbar) toolbar.style.setProperty('display', 'none', 'important');
        if (mini) mini.style.display = "none";
        return;
       }
       if (!toolbar || !mini) return;
       const hasSelectedNode = currentNodeId !== null;
       if (!hasSelectedNode) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "none";
       } else if (topologyToolbarCollapsed) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "inline-flex";
       } else {
      if (isMobileDevice()) {
        toolbar.style.setProperty('display', 'grid', 'important');
        mini.style.display = "none";
        } else {
        toolbar.style.setProperty('display', 'flex', 'important');
        mini.style.display = "none";
      }
       }
      }
      const DEFAULT_CANVAS_HINT = document.getElementById("canvas-hint")?.innerHTML || "";
      const DEFAULT_PAGE_STATE = {
       title: "The One File",
       background: "",
       topbarBg: "rgba(9, 12, 20, 0.9)",
       topbarBorder: "#1f2533",
       panel: "#0b0e13",
       panelAlt: "#10141b",
       accent: "#4fd1c5",
       sidebarBg: "#10141b",
       btnBg: "#0b0e13",
       btnText: "#e2e8f0",
       tagFill: "#1e293b",
       tagText: "#e2e8f0",
       tagBorder: "#475569",
       inputBg: "#0b0e13",
       inputText: "#e2e8f0",
       inputBorder: "#1f2937",
       inputFont: "Inter, system-ui, sans-serif",
       inputFontSize: 14,
       toolbarBg: "#0f172a",
       toolbarBorder: "#1f2937",
       toolbarText: "#94a3b8",
       toolbarBtnBg: "#0b0e13",
       toolbarBtnText: "#e2e8f0",
       minimapDots: "#94a3b8",
       canvasHintEnabled: true,
       canvasHintText: "",
       canvasHintBg: "#0f172a",
       canvasHintColor: "#94a3b8",
       danger: "#f56565",
       textMain: "#e2e8f0",
       textSoft: "#94a3b8",
       topbarHeight: 52,
       sidebarWidth: 350,
       mobileFooterHeight: 40,
       sidebarCollapsed: false,
       nodeFill: "#1e293b",
       nodeStroke: "#475569",
       nodeTitle: "#e2e8f0",
       nodeSub: "#94a3b8",
       nodeTitleSize: 18,
       nodeSubSize: 13,
       nodeFont: "Inter, system-ui, sans-serif",
       defaultEdge: "#475569",
       selectionHandle: "#f59e0b",
       selectionHandleSize: 8,
       groupIndicator: "#4fd1c5",
      canvasGradientTop: "#1e2532",
       canvasGradientBottom: "#050608",
       canvasBorder: "#475569",
       canvasGrid: "#475569",
       canvasGridSize: 50,
       rackFrameFill: "#0f172a",
       rackFrameStroke: "#4fd1c5",
       rackLineColor: "#475569",
       rackTextColor: "#4fd1c5",
	   viewOnly: false,
      };
      let PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE);
	  function isViewOnly() {
       return PAGE_STATE.viewOnly === true;
      }
	  let viewOnlyClickCount = 0;
      let viewOnlyClickTimer = null;
      let viewOnlyClickTarget = null;
      function handleViewOnlyClick(id, type) {
       if (!isViewOnly()) return false;
       if (viewOnlyClickTarget !== id) {
        viewOnlyClickCount = 0;
        viewOnlyClickTarget = id;
       }
       viewOnlyClickCount++;
       clearTimeout(viewOnlyClickTimer);
       viewOnlyClickTimer = setTimeout(() => {
        viewOnlyClickCount = 0;
        viewOnlyClickTarget = null;
       }, 2000);
       if (viewOnlyClickCount >= 5) {
        viewOnlyClickCount = 0;
        viewOnlyClickTarget = null;
        document.body.classList.add("view-only-inspect");
        if (type === 'node') {
         currentNodeId = id;
         const data = NODE_DATA[id];
         if (data) {
          document.querySelectorAll(".node-group").forEach((n) => {
           n.classList.toggle("active", n.dataset.nodeId === id);
          });
          document.getElementById("node-panel").style.display = "block";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("node-name").textContent = data.name;
          document.getElementById("node-ip").textContent = data.ip;
          document.getElementById("node-role").textContent = data.role;
          document.getElementById("node-mac").textContent = data.mac || "--";
          document.getElementById("node-rack").textContent = data.rackUnit || "--";
          document.getElementById("node-uheight").textContent = (data.uHeight || "1") + "U";
          const tagList = document.getElementById("node-tags");
          if (tagList) {
           tagList.innerHTML = "";
           if (data.tags && data.tags.length > 0) {
            data.tags.forEach((tag) => {
             const li = document.createElement("li");
             li.textContent = tag;
             tagList.appendChild(li);
            });
           }
          }
          const noteList = document.getElementById("node-notes");
          if (noteList) {
           noteList.innerHTML = "";
           if (data.notes && data.notes.length > 0) {
            data.notes.forEach((note) => {
             const li = document.createElement("li");
             li.textContent = note;
             noteList.appendChild(li);
            });
           }
          }
         }
        } else if (type === 'edge') {
         currentEdgeId = id;
         const edge = EDGE_DATA.list.find(e => e.id === id);
         if (edge) {
          document.querySelectorAll(".edge").forEach((e) => {
           e.classList.toggle("active", e.dataset.edgeId === id);
          });
          document.getElementById("edge-panel").style.display = "block";
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-from").textContent = NODE_DATA[edge.from]?.name || edge.from;
          document.getElementById("edge-to").textContent = NODE_DATA[edge.to]?.name || edge.to;
          document.getElementById("edge-label").value = edge.label || "";
         }
        }
        return true;
       }
       return false;
      }
      const CANVAS_WIDTH = 4000;
      let CANVAS_HEIGHT = 3000;
      const BASE_CANVAS_HEIGHT = 3000;
      const CANVAS_PADDING = 100;
      const RACK_U_HEIGHT = 70;
      const RACK_WIDTH = 600;
      const RACK_START_X = CANVAS_WIDTH / 2;
      const RACK_START_Y = CANVAS_PADDING + 100;
      function getRackUHeight(rackId) {
      const capacity = getRackCapacity(rackId);
      const availableHeight = CANVAS_HEIGHT - RACK_START_Y - 200;
      return Math.floor(availableHeight / capacity);
      }
      let canvasState = {
       zoom: 1,
       panX: 0,
       panY: 0,
       minZoom: 0.25,
       maxZoom: 4,
       isPanning: false,
       panStartX: 0,
       panStartY: 0,
       spacePressed: false,
      };
      function getViewBox() {
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       return {
        x: canvasState.panX,
        y: canvasState.panY,
        width: viewWidth,
        height: viewHeight,
       };
      }
      function updateViewBox() {
       const svg = document.getElementById("map");
       const vb = getViewBox();
       svg.setAttribute("viewBox", `${vb.x} ${vb.y} ${vb.width} ${vb.height}`, );
       const zoomLevel = document.getElementById("zoom-level");
       if (zoomLevel) {
        zoomLevel.textContent = Math.round(canvasState.zoom * 100) + "%";
       }
       updateMinimap();
       populateRackDropdown();
      }
      function updateMinimap() {
       const minimapViewport = document.getElementById("minimap-viewport");
       const minimapSvg = document.getElementById("minimap");
       if (!minimapViewport || !minimapSvg) return;
       const vb = getViewBox();
       minimapViewport.setAttribute("x", vb.x);
       minimapViewport.setAttribute("y", vb.y);
       minimapViewport.setAttribute("width", vb.width);
       minimapViewport.setAttribute("height", vb.height);
       const minimapNodes = minimapSvg.querySelectorAll(".minimap-node");
       minimapNodes.forEach((n) => n.remove());
       const minimapEdges = minimapSvg.querySelectorAll(".minimap-edge");
       minimapEdges.forEach((e) => e.remove());
       EDGE_DATA.list.forEach((edge) => {
        if (edge.type === "custom") return;
        const fromNode = NODE_DATA[edge.from];
        const toNode = NODE_DATA[edge.to];
        if (!fromNode || !toNode) return;
        if (currentView.mode === "rack") {
         if (fromNode.assignedRack !== currentView.rackId ||
             toNode.assignedRack !== currentView.rackId) {
          return;
         }
        } else {
         if (fromNode.assignedRack || toNode.assignedRack) {
          return;
         }
        }
        const p1 = savedPositions[edge.from];
        const p2 = savedPositions[edge.to];
        if (!p1 || !p2) return;
        const line = document.createElementNS("http://www.w3.org/2000/svg", "line", );
        line.setAttribute("x1", p1.x);
        line.setAttribute("y1", p1.y);
        line.setAttribute("x2", p2.x);
        line.setAttribute("y2", p2.y);
        line.classList.add("minimap-edge");
        minimapSvg.insertBefore(line, minimapViewport);
       });
       Object.entries(savedPositions).forEach(([id, pos]) => {
        const node = NODE_DATA[id];
        if (!node) return;
        if (currentView.mode === "rack") {
         if (node.assignedRack !== currentView.rackId) {
          return;
         }
        } else {
         if (node.assignedRack) {
          return;
         }
        }
        const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle", );
        circle.setAttribute("cx", pos.x);
        circle.setAttribute("cy", pos.y);
        circle.setAttribute("r", 40);
        circle.classList.add("minimap-node");
        minimapSvg.insertBefore(circle, minimapViewport);
       });
      }
      function zoomTo(newZoom, centerX, centerY) {
       const oldZoom = canvasState.zoom;
       newZoom = Math.max(canvasState.minZoom, Math.min(canvasState.maxZoom, newZoom), );
       if (centerX !== undefined && centerY !== undefined) {
        const oldWidth = CANVAS_WIDTH / oldZoom;
        const oldHeight = CANVAS_HEIGHT / oldZoom;
        const newWidth = CANVAS_WIDTH / newZoom;
        const newHeight = CANVAS_HEIGHT / newZoom;
        const pointX = canvasState.panX + centerX * oldWidth;
        const pointY = canvasState.panY + centerY * oldHeight;
        canvasState.panX = pointX - centerX * newWidth;
        canvasState.panY = pointY - centerY * newHeight;
       }
       canvasState.zoom = newZoom;
       constrainPan();
       updateViewBox();
      }
      function constrainPan() {
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       const minVisiblePortion = 0.1;
       const maxPanX = CANVAS_WIDTH - viewWidth * minVisiblePortion;
       const maxPanY = CANVAS_HEIGHT - viewHeight * minVisiblePortion;
       const minPanX = -viewWidth * (1 - minVisiblePortion);
       const minPanY = -viewHeight * (1 - minVisiblePortion);
       canvasState.panX = Math.max(minPanX, Math.min(maxPanX, canvasState.panX), );
       canvasState.panY = Math.max(minPanY, Math.min(maxPanY, canvasState.panY), );
      }
      function fitToContent() {
       const positions = Object.values(savedPositions);
       if (positions.length === 0) {
        resetView();
        return;
       }
       let minX = Infinity,
        minY = Infinity,
        maxX = -Infinity,
        maxY = -Infinity;
       positions.forEach((pos) => {
        minX = Math.min(minX, pos.x - 100);
        minY = Math.min(minY, pos.y - 100);
        maxX = Math.max(maxX, pos.x + 100);
        maxY = Math.max(maxY, pos.y + 100);
       });
       const contentWidth = maxX - minX + 200;
       const contentHeight = maxY - minY + 200;
       const viewport = document.getElementById("canvas-viewport");
       const vpRect = viewport.getBoundingClientRect();
       const aspectRatio = vpRect.width / vpRect.height;
       const contentAspect = contentWidth / contentHeight;
       let newZoom;
       if (contentAspect > aspectRatio) {
        newZoom = (vpRect.width / contentWidth) * (CANVAS_WIDTH / vpRect.width);
       } else {
        newZoom = (vpRect.height / contentHeight) * (CANVAS_HEIGHT / vpRect.height);
       }
       newZoom = Math.max(canvasState.minZoom, Math.min(2, newZoom));
       const viewWidth = CANVAS_WIDTH / newZoom;
       const viewHeight = CANVAS_HEIGHT / newZoom;
       canvasState.zoom = newZoom;
       canvasState.panX = minX - 100 - (viewWidth - contentWidth) / 2;
       canvasState.panY = minY - 100 - (viewHeight - contentHeight) / 2;
       constrainPan();
       updateViewBox();
      }
      function resetView() {
       canvasState.zoom = 1;
       canvasState.panX = 0;
       canvasState.panY = 0;
       updateViewBox();
      }
      window.addEventListener("DOMContentLoaded", () => {
       const toggle = document.getElementById("mobile-menu-toggle");
       const menu = document.getElementById("topbar-menu");
       if (!toggle || !menu) return;
       toggle.addEventListener("click", () => {
        menu.classList.toggle("open");
       });
       menu.addEventListener("click", (e) => {
        const target = e.target.closest("a, button");
        if (!target) return;
        if (isMobileDevice()) {
       menu.classList.remove("open");
      }
       });
       const minimapCloseBtn = document.getElementById("minimap-close-btn");
       if (minimapCloseBtn) {
        const handleMinimapClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         minimapCollapsed = true;
         updateMinimapVisibility();
        };
        minimapCloseBtn.addEventListener("click", handleMinimapClose);
        minimapCloseBtn.addEventListener("touchend", handleMinimapClose);
       }
       const drawToolbarCloseBtn = document.getElementById("draw-toolbar-close-btn");
       if (drawToolbarCloseBtn) {
        const handleDrawClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         drawToolbarCollapsed = true;
         updateDrawToolbarVisibility();
        };
        drawToolbarCloseBtn.addEventListener("click", handleDrawClose);
        drawToolbarCloseBtn.addEventListener("touchend", handleDrawClose);
       }
       const topologyToolbarCloseBtn = document.getElementById("topology-toolbar-close-btn");
       if (topologyToolbarCloseBtn) {
        const handleTopologyClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         topologyToolbarCollapsed = true;
         updateTopologyToolbarVisibility();
        };
        topologyToolbarCloseBtn.addEventListener("click", handleTopologyClose);
        topologyToolbarCloseBtn.addEventListener("touchstart", (e) => e.preventDefault(), {
         passive: false
        });
        topologyToolbarCloseBtn.addEventListener("touchend", handleTopologyClose);
       }
       updateMinimapVisibility();
       updateDrawToolbarVisibility();
       updateTopologyToolbarVisibility();
      });
      function applyLayerFilter() {
       activeLayers.clear();
       if (document.getElementById("layer-physical").checked) activeLayers.add("physical");
       if (document.getElementById("layer-logical").checked) activeLayers.add("logical");
       if (document.getElementById("layer-security").checked) activeLayers.add("security");
       if (document.getElementById("layer-application").checked) activeLayers.add("application");
       forgeTheTopology();
      }
      function isNodeVisible(nodeId) {
       const node = NODE_DATA[nodeId];
       if (!node) return false;
       const nodeLayer = node.layer || "physical";
       return activeLayers.has(nodeLayer);
      }
      function enterRack(rackId) {
      if (!NODE_DATA[rackId] || !NODE_DATA[rackId].isRack) return;
      const rackCapacity = getRackCapacity(rackId);
      const neededHeight = RACK_START_Y + (rackCapacity * RACK_U_HEIGHT) + 200;
      if (neededHeight > BASE_CANVAS_HEIGHT) {
      CANVAS_HEIGHT = neededHeight;
      }
       savedTopologyView = {
        zoom: canvasState.zoom,
        panX: canvasState.panX,
        panY: canvasState.panY
       };
       currentView.mode = "rack";
       currentView.rackId = rackId;
       const backBtn = document.getElementById("back-to-topology-btn");
       if (backBtn) backBtn.style.display = "inline-block";
       const hint = document.getElementById("canvas-hint");
       if (hint) {
        hint.textContent = `Viewing: ${NODE_DATA[rackId].name} | Double click empty space to exit`;
        hint.classList.add("visible");
       }
      const rackUHeight = getRackUHeight(rackId);
      const rackHeight = rackCapacity * rackUHeight;
      const rackCenterX = RACK_START_X;
      const rackCenterY = RACK_START_Y + (rackHeight / 2);
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       canvasState.panX = rackCenterX - (viewWidth / 2);
       canvasState.panY = rackCenterY - (viewHeight / 2);
       constrainPan();
       updateViewBox();
       forgeTheTopology();
      }
      function exitRack() {
      CANVAS_HEIGHT = BASE_CANVAS_HEIGHT;
      currentView.mode = "topology";
      currentView.rackId = null;
       const backBtn = document.getElementById("back-to-topology-btn");
       if (backBtn) backBtn.style.display = "none";
       const hint = document.getElementById("canvas-hint");
       if (hint) {
        hint.classList.remove("visible");
       }
       if (savedTopologyView) {
        canvasState.zoom = savedTopologyView.zoom;
        canvasState.panX = savedTopologyView.panX;
        canvasState.panY = savedTopologyView.panY;
        updateViewBox();
       }
       forgeTheTopology();
      }
      function getRackCapacity(rackId) {
       const node = NODE_DATA[rackId];
       return node && node.rackCapacity ? parseInt(node.rackCapacity) : 42;
      }
      function populateRackDropdown() {
       const dropdown = document.getElementById("node-assigned-rack");
       if (!dropdown) return;
       dropdown.innerHTML = '<option value="">None</option>';
       Object.keys(NODE_DATA).forEach(id => {
        if (NODE_DATA[id].isRack) {
         const option = document.createElement("option");
         option.value = id;
         option.textContent = NODE_DATA[id].name;
         dropdown.appendChild(option);
        }
       });
      }
      function wieldThePower() {
       const root = document.documentElement;
       root.style.setProperty("--panel", PAGE_STATE.panel);
       root.style.setProperty("--panel-alt", PAGE_STATE.panelAlt);
       root.style.setProperty("--sidebar-bg", PAGE_STATE.sidebarBg || PAGE_STATE.panelAlt);
       root.style.setProperty("--btn-bg", PAGE_STATE.btnBg || PAGE_STATE.panel);
       root.style.setProperty("--btn-text", PAGE_STATE.btnText || "#e2e8f0");
       root.style.setProperty("--tag-fill", PAGE_STATE.tagFill || "#1e293b");
       root.style.setProperty("--tag-text", PAGE_STATE.tagText || "#e2e8f0");
       root.style.setProperty("--tag-border", PAGE_STATE.tagBorder || "#475569");
       root.style.setProperty("--input-bg", PAGE_STATE.inputBg || "#0b0e13");
       root.style.setProperty("--input-text", PAGE_STATE.inputText || "#e2e8f0");
       root.style.setProperty("--input-border", PAGE_STATE.inputBorder || "#1f2937");
       root.style.setProperty("--input-font", PAGE_STATE.inputFont || "Inter, system-ui, sans-serif");
       root.style.setProperty("--input-font-size", (PAGE_STATE.inputFontSize || 14) + "px");
       root.style.setProperty("--toolbar-bg", PAGE_STATE.toolbarBg || "#0f172a");
       root.style.setProperty("--toolbar-border", PAGE_STATE.toolbarBorder || "#1f2937");
       root.style.setProperty("--toolbar-text", PAGE_STATE.toolbarText || "#94a3b8");
       root.style.setProperty("--toolbar-btn-bg", PAGE_STATE.toolbarBtnBg || "#0b0e13");
       root.style.setProperty("--toolbar-btn-text", PAGE_STATE.toolbarBtnText || "#e2e8f0");
       root.style.setProperty("--minimap-dots", PAGE_STATE.minimapDots || "#94a3b8");
       root.style.setProperty("--canvas-hint-bg", PAGE_STATE.canvasHintBg || "#0f172a");
       root.style.setProperty("--canvas-hint-color", PAGE_STATE.canvasHintColor || "#94a3b8");
       const canvasHint = document.getElementById("canvas-hint");
       if (canvasHint) {
        canvasHint.style.display = PAGE_STATE.canvasHintEnabled === false ? "none" : "";
        if (PAGE_STATE.canvasHintText !== undefined && PAGE_STATE.canvasHintText !== "") {
         canvasHint.innerHTML = PAGE_STATE.canvasHintText;
        } else {
         canvasHint.innerHTML = DEFAULT_CANVAS_HINT;
        }
       }
       root.style.setProperty("--accent", PAGE_STATE.accent);
       root.style.setProperty("--danger", PAGE_STATE.danger);
       root.style.setProperty("--text-main", PAGE_STATE.textMain);
       root.style.setProperty("--text-soft", PAGE_STATE.textSoft);
       root.style.setProperty("--topbar-bg", PAGE_STATE.topbarBg);
       root.style.setProperty("--topbar-border", PAGE_STATE.topbarBorder);
       root.style.setProperty("--node-fill", PAGE_STATE.nodeFill || "#1e293b");
       root.style.setProperty("--node-stroke", PAGE_STATE.nodeStroke || "#475569");
       root.style.setProperty("--node-title", PAGE_STATE.nodeTitle || "#e2e8f0");
       root.style.setProperty("--node-sub", PAGE_STATE.nodeSub || "#94a3b8");
       root.style.setProperty("--node-title-size", (PAGE_STATE.nodeTitleSize || 18) + "px");
       root.style.setProperty("--node-sub-size", (PAGE_STATE.nodeSubSize || 13) + "px");
       root.style.setProperty("--node-font", PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif");
       root.style.setProperty("--default-edge", PAGE_STATE.defaultEdge || "#475569");
       root.style.setProperty("--selection-handle", PAGE_STATE.selectionHandle || "#f59e0b");
       root.style.setProperty("--selection-handle-size", (PAGE_STATE.selectionHandleSize || 8) + "px");
       root.style.setProperty("--group-indicator", PAGE_STATE.groupIndicator || "#4fd1c5");
       const topbarHeight = PAGE_STATE.topbarHeight || 52;
       const sidebarWidth = PAGE_STATE.sidebarWidth || 350;
       const mobileFooterHeight = PAGE_STATE.mobileFooterHeight || 40;
       root.style.setProperty("--topbar-height", topbarHeight + "px");
       root.style.setProperty("--sidebar-width", sidebarWidth + "px");
       root.style.setProperty("--mobile-footer-height", mobileFooterHeight + "vh", );
       const mainEl = document.querySelector("main");
       const detailsPanel = document.getElementById("details-panel");
       const sidebarToggle = document.getElementById("sidebar-toggle");
       if (PAGE_STATE.sidebarCollapsed) {
        if (mainEl) mainEl.classList.add("sidebar-collapsed");
        if (detailsPanel) detailsPanel.classList.add("collapsed");
        if (sidebarToggle) {
         sidebarToggle.classList.add("collapsed");
         sidebarToggle.textContent = "▶";
        }
       } else {
        if (mainEl) mainEl.classList.remove("sidebar-collapsed");
        if (detailsPanel) detailsPanel.classList.remove("collapsed");
        if (sidebarToggle) {
         sidebarToggle.classList.remove("collapsed");
         sidebarToggle.textContent = "◀";
        }
       }
       if (PAGE_STATE.background) {
        document.body.style.background = PAGE_STATE.background;
       } else {
        document.body.style.background = `radial-gradient(circle at top, ${PAGE_STATE.canvasGradientTop || "#1e2532"} 0, ${PAGE_STATE.canvasGradientBottom || "#050608"} 70%)`;
       }
       document.title = PAGE_STATE.title || DEFAULT_PAGE_STATE.title;
       const titleEl = document.getElementById("page-title");
       if (titleEl) {
        titleEl.textContent = PAGE_STATE.title || DEFAULT_PAGE_STATE.title;
       }
       const sidebarToggleEl = document.getElementById("sidebar-toggle");
       const isMobile = isMobileDevice();
       if (sidebarToggleEl) {
        sidebarToggleEl.style.display = isMobile ? "none" : "flex";
       }
       const viewOnlyMode = PAGE_STATE.viewOnly === true;
       const addNodeBtn = document.getElementById("add-node-btn");
       const addRackBtn = document.getElementById("add-rack-btn");
       const drawToolbar = document.getElementById("draw-toolbar");
       const topologyToolbar = document.getElementById("topology-toolbar");
       const bulkToolbar = document.getElementById("bulk-toolbar");
       if (addNodeBtn) addNodeBtn.style.display = viewOnlyMode ? "none" : "";
       if (addRackBtn) addRackBtn.style.display = viewOnlyMode ? "none" : "";
       if (viewOnlyMode) {
        if (drawToolbar) drawToolbar.style.setProperty('display', 'none', 'important');
        if (topologyToolbar) topologyToolbar.style.setProperty('display', 'none', 'important');
        if (bulkToolbar) bulkToolbar.style.display = "none";
        const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
       }
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       if (bulkToolbarMobile) bulkToolbarMobile.style.display = viewOnlyMode ? "none" : "";
       ["draw-toolbar-mini", "topology-toolbar-mini"].forEach(id => {
        const el = document.getElementById(id);
        if (el) el.style.display = viewOnlyMode ? "none" : "";
       });
       document.body.classList.toggle("view-only-mode", viewOnlyMode);
      }
      (async function awakeTheImmortal() {
       let initialState = {};
       let decryptionCancelled = false;
       const stateEl = document.getElementById("topology-state");
       if (stateEl && stateEl.textContent.trim()) {
        try {
         let stateText = stateEl.textContent.trim();
         if (isEncrypted(stateText)) {
          let decrypted = false;
          let attempts = 0;
          const maxAttempts = 3;
          while (!decrypted && attempts < maxAttempts) {
           const password = prompt("This file is encrypted. Enter password to decrypt:\n(Attempt " + (attempts + 1) + " of " + maxAttempts + ")", );
           if (!password) {
            alert("Decryption cancelled. The file will not be loaded.", );
            decryptionCancelled = true;
            break;
           }
           try {
            stateText = await decryptData(stateText, password);
            decrypted = true;
           } catch (e) {
            attempts++;
            if (attempts < maxAttempts) {
             alert("Incorrect password. Please try again.");
            } else {
             alert("Maximum attempts reached. The file will not be loaded.", );
             decryptionCancelled = true;
            }
           }
          }
          if (!decrypted) {
           stateText = "{}";
          }
         }
         initialState = JSON.parse(stateText);
        } catch (e) {
         console.error("Failed to load state:", e);
         initialState = {};
        }
       }
       if (decryptionCancelled) {
        NODE_DATA = {};
        EDGE_DATA = {
         list: []
        };
        RECT_DATA = { list: [] };
        TEXT_DATA = { list: [] };
        EDGE_LEGEND = {};
        savedPositions = {};
        savedSizes = {};
        savedStyles = {};
       } else {
        NODE_DATA = initialState.nodeData ? initialState.nodeData : BASE_NODE_DATA;
        EDGE_DATA = initialState.edgeData ? initialState.edgeData : {
         list: [],
        };
        RECT_DATA = initialState.rectData ? initialState.rectData : { list: [] };
        TEXT_DATA = initialState.textData ? initialState.textData : { list: [] };
        EDGE_LEGEND = initialState.edgeLegend || {};
        savedPositions = initialState.nodePositions || {};
        savedSizes = initialState.nodeSizes || {};
        savedStyles = initialState.nodeStyles || {};
       }
       if (initialState.page) {
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, initialState.page, );
       }
       if (initialState.canvas) {
        canvasState.zoom = initialState.canvas.zoom || 1;
        canvasState.panX = initialState.canvas.panX || 0;
        canvasState.panY = initialState.canvas.panY || 0;
       }
       if (initialState.savedTopologyView) {
        savedTopologyView = initialState.savedTopologyView;
       }
       if (initialState.documentTabs) {
        documentTabs = initialState.documentTabs;
        currentTabIndex = initialState.currentTabIndex || 0;
        const currentTab = documentTabs[currentTabIndex];
        if (currentTab) {
          NODE_DATA = currentTab.nodes || NODE_DATA;
          EDGE_DATA = currentTab.edges || EDGE_DATA;
          savedPositions = currentTab.positions || savedPositions;
          savedSizes = currentTab.sizes || savedSizes;
          savedStyles = currentTab.styles || savedStyles;
          EDGE_LEGEND = currentTab.legend || EDGE_LEGEND;
          RECT_DATA = currentTab.rects || RECT_DATA;
          TEXT_DATA = currentTab.texts || TEXT_DATA;
      if (currentTab.pageState) PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, currentTab.pageState);
        }
       }
       if (initialState.encryptedSections) {
        encryptedSections = initialState.encryptedSections;
       }
       wieldThePower();
       forgeTheTopology();
       updateViewBox();
       MobileManager.applyAll();
       const initialNodes = Object.keys(NODE_DATA);
       if (initialNodes.length > 0) {
        claimTheImmortal(initialNodes.includes("host") ? "host" : initialNodes[0], );
       } else {
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.display = "none";
       }
      })();
      let resizeDebounceTimer = null;
      window.addEventListener("resize", () => {
        clearTimeout(resizeDebounceTimer);
        resizeDebounceTimer = setTimeout(() => {
          MobileManager.applyAll();
          if (typeof updateDrawToolbarVisibility === 'function') updateDrawToolbarVisibility();
          if (typeof updateTopologyToolbarVisibility === 'function') updateTopologyToolbarVisibility();
        }, 100);
      });
      function getBreakpointKey() {
       const w = window.innerWidth;
       if (w <= 380) return "fold";
       if (w <= 768) return "mobile";
       if (w <= 1024) return "tablet";
       return "desktop";
      }
      function resolveStylesEntry(styleEntry) {
       if (!styleEntry) return {};
       if (styleEntry.circleColor || styleEntry.titleColor || styleEntry.titleFont || styleEntry.titleSize || styleEntry.subColor || styleEntry.subFont || styleEntry.subSize) {
        return styleEntry;
       }
       const bp = getBreakpointKey();
       const base = styleEntry.all || {};
       const bpStyles = styleEntry[bp] || {};
       return Object.assign({}, base, bpStyles);
      }
      function resolveStylesForNode(id) {
       const styleEntry = savedStyles[id];
       if (!styleEntry) return {};
       return resolveStylesEntry(styleEntry);
      }
      function ensureStyleEntry(id) {
       if (!savedStyles[id]) savedStyles[id] = {};
       const entry = savedStyles[id];
       const flatProps = ["circleColor", "circleBorder", "titleColor", "titleFont", "titleSize", "subColor", "subFont", "subSize", ];
       const isFlat = flatProps.some((p) => Object.prototype.hasOwnProperty.call(entry, p), );
       if (isFlat) {
        const all = entry.all || {};
        flatProps.forEach((p) => {
         if (entry[p] !== undefined) {
          all[p] = entry[p];
          delete entry[p];
         }
        });
        entry.all = all;
       }
       return entry;
      }
      function getDefaultSize() {
       if (window.innerWidth <= 380) return 120;
       if (window.innerWidth <= 768) return 140;
       if (window.innerWidth <= 1024) return 70;
       return 55;
      }
      function createShapeElement(shape, size) {
       const ns = "http://www.w3.org/2000/svg";
       if (shape === "circle") {
        const c = document.createElementNS(ns, "circle");
        c.setAttribute("r", size);
        return c;
       }
       if (shape === "square") {
        const r = document.createElementNS(ns, "rect");
        const s = size * 2;
        r.setAttribute("x", -size);
        r.setAttribute("y", -size);
        r.setAttribute("width", s);
        r.setAttribute("height", s);
        r.setAttribute("rx", 4);
        return r;
       }
       if (shape === "rectangle") {
        const r = document.createElementNS(ns, "rect");
        r.setAttribute("x", -size * 1.4);
        r.setAttribute("y", -size * 0.8);
        r.setAttribute("width", size * 2.8);
        r.setAttribute("height", size * 1.6);
        r.setAttribute("rx", 6);
        return r;
       }
       if (shape === "triangle") {
        const p = document.createElementNS(ns, "polygon");
        const h = size * 1.8;
        const w = size * 2;
        p.setAttribute("points", `0,${-h} ${w / 2},${h / 2} ${-w / 2},${h / 2}`, );
        return p;
       }
       if (shape === "hexagon") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        const pts = [
         [0, -s],
         [s * 0.86, -s * 0.5],
         [s * 0.86, s * 0.5],
         [0, s],
         [-s * 0.86, s * 0.5],
         [-s * 0.86, -s * 0.5],
        ].map((pt) => pt.join(",")).join(" ");
        p.setAttribute("points", pts);
        return p;
       }
       if (shape === "stop-sign") {
        const p = document.createElementNS(ns, "polygon");
        const r = size;
        const ptsArr = [];
        for (let i = 0; i < 8; i++) {
         const a = (Math.PI / 4) * i + Math.PI / 8;
         ptsArr.push([Math.cos(a) * r, Math.sin(a) * r]);
        }
        const pts = ptsArr.map((pt) => pt.join(",")).join(" ");
        p.setAttribute("points", pts);
        return p;
       }
       if (shape === "star") {
        const p = document.createElementNS(ns, "polygon");
        const outer = size;
        const inner = size * 0.45;
        let pts = "";
        for (let i = 0; i < 10; i++) {
         const a = (Math.PI / 5) * i - Math.PI / 2;
         const r = i % 2 === 0 ? outer : inner;
         pts += `${Math.cos(a) * r},${Math.sin(a) * r} `;
        }
        p.setAttribute("points", pts.trim());
        return p;
       }
       if (shape === "diamond") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `0,${-s} ${s},0 0,${s} ${-s},0`);
        return p;
       }
       if (shape === "server") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.2);
        body.setAttribute("y", -size * 0.6);
        body.setAttribute("width", size * 2.4);
        body.setAttribute("height", size * 1.2);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 3; i++) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", -size * 0.9 + i * size * 0.5);
         line.setAttribute("y1", -size * 0.3);
         line.setAttribute("x2", -size * 0.9 + i * size * 0.5);
         line.setAttribute("y2", size * 0.3);
         line.style.stroke = "currentColor";
         line.style.strokeWidth = "2";
         line.style.opacity = "0.5";
         g.appendChild(line);
        }
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", size * 0.9);
        led.setAttribute("cy", 0);
        led.setAttribute("r", size * 0.1);
        led.style.fill = "#4ade80";
        g.appendChild(led);
        return g;
       }
       if (shape === "pc" || shape === "desktop") {
        const g = document.createElementNS(ns, "g");
        const monitor = document.createElementNS(ns, "rect");
        monitor.setAttribute("x", -size * 0.9);
        monitor.setAttribute("y", -size * 0.8);
        monitor.setAttribute("width", size * 1.8);
        monitor.setAttribute("height", size * 1.2);
        monitor.setAttribute("rx", 4);
        g.appendChild(monitor);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.75);
        screen.setAttribute("y", -size * 0.65);
        screen.setAttribute("width", size * 1.5);
        screen.setAttribute("height", size * 0.9);
        screen.setAttribute("rx", 2);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        const neck = document.createElementNS(ns, "rect");
        neck.setAttribute("x", -size * 0.15);
        neck.setAttribute("y", size * 0.4);
        neck.setAttribute("width", size * 0.3);
        neck.setAttribute("height", size * 0.3);
        g.appendChild(neck);
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.5);
        base.setAttribute("y", size * 0.7);
        base.setAttribute("width", size * 1);
        base.setAttribute("height", size * 0.15);
        base.setAttribute("rx", 2);
        g.appendChild(base);
        return g;
       }
       if (shape === "laptop") {
        const g = document.createElementNS(ns, "g");
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.8);
        screen.setAttribute("y", -size * 0.9);
        screen.setAttribute("width", size * 1.6);
        screen.setAttribute("height", size * 1.1);
        screen.setAttribute("rx", 4);
        g.appendChild(screen);
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.9);
        base.setAttribute("y", size * 0.25);
        base.setAttribute("width", size * 1.8);
        base.setAttribute("height", size * 0.6);
        base.setAttribute("rx", 4);
        g.appendChild(base);
        const pad = document.createElementNS(ns, "rect");
        pad.setAttribute("x", -size * 0.25);
        pad.setAttribute("y", size * 0.45);
        pad.setAttribute("width", size * 0.5);
        pad.setAttribute("height", size * 0.25);
        pad.setAttribute("rx", 2);
        pad.style.fill = "#1e293b";
        g.appendChild(pad);
        return g;
       }
       if (shape === "phone" || shape === "mobile") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.45);
        body.setAttribute("y", -size);
        body.setAttribute("width", size * 0.9);
        body.setAttribute("height", size * 2);
        body.setAttribute("rx", 8);
        g.appendChild(body);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.38);
        screen.setAttribute("y", -size * 0.85);
        screen.setAttribute("width", size * 0.76);
        screen.setAttribute("height", size * 1.6);
        screen.setAttribute("rx", 4);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        const btn = document.createElementNS(ns, "rect");
        btn.setAttribute("x", -size * 0.15);
        btn.setAttribute("y", size * 0.82);
        btn.setAttribute("width", size * 0.3);
        btn.setAttribute("height", size * 0.06);
        btn.setAttribute("rx", 2);
        btn.style.fill = "#475569";
        g.appendChild(btn);
        return g;
       }
       if (shape === "router") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.1);
        body.setAttribute("y", -size * 0.3);
        body.setAttribute("width", size * 2.2);
        body.setAttribute("height", size * 0.8);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        for (let i = -1; i <= 1; i++) {
         const ant = document.createElementNS(ns, "rect");
         ant.setAttribute("x", i * size * 0.6 - size * 0.05);
         ant.setAttribute("y", -size * 0.9);
         ant.setAttribute("width", size * 0.1);
         ant.setAttribute("height", size * 0.6);
         ant.setAttribute("rx", 2);
         g.appendChild(ant);
         const tip = document.createElementNS(ns, "circle");
         tip.setAttribute("cx", i * size * 0.6);
         tip.setAttribute("cy", -size * 0.95);
         tip.setAttribute("r", size * 0.08);
         g.appendChild(tip);
        }
        for (let i = 0; i < 4; i++) {
         const led = document.createElementNS(ns, "circle");
         led.setAttribute("cx", -size * 0.7 + i * size * 0.35);
         led.setAttribute("cy", size * 0.1);
         led.setAttribute("r", size * 0.06);
         led.style.fill = i < 2 ? "#4ade80" : "#facc15";
         g.appendChild(led);
        }
        return g;
       }
       if (shape === "switch") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.4);
        body.setAttribute("y", -size * 0.4);
        body.setAttribute("width", size * 2.8);
        body.setAttribute("height", size * 0.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 8; i++) {
         const port = document.createElementNS(ns, "rect");
         port.setAttribute("x", -size * 1.2 + i * size * 0.32);
         port.setAttribute("y", -size * 0.15);
         port.setAttribute("width", size * 0.22);
         port.setAttribute("height", size * 0.3);
         port.setAttribute("rx", 1);
         port.style.fill = "#1e293b";
         g.appendChild(port);
        }
        return g;
       }
       if (shape === "firewall") {
        const g = document.createElementNS(ns, "g");
        const wall = document.createElementNS(ns, "rect");
        wall.setAttribute("x", -size);
        wall.setAttribute("y", -size * 0.8);
        wall.setAttribute("width", size * 2);
        wall.setAttribute("height", size * 1.6);
        wall.setAttribute("rx", 4);
        g.appendChild(wall);
        for (let row = 0; row < 3; row++) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", -size * 0.85);
         line.setAttribute("y1", -size * 0.5 + row * size * 0.45);
         line.setAttribute("x2", size * 0.85);
         line.setAttribute("y2", -size * 0.5 + row * size * 0.45);
         line.style.stroke = "#475569";
         line.style.strokeWidth = "2";
         g.appendChild(line);
        }
        for (let row = 0; row < 4; row++) {
         const offset = row % 2 === 0 ? 0 : size * 0.35;
         for (let col = 0; col < 3; col++) {
          const line = document.createElementNS(ns, "line");
          const x = -size * 0.5 + col * size * 0.7 + offset;
          if (x > -size * 0.85 && x < size * 0.85) {
           line.setAttribute("x1", x);
           line.setAttribute("y1", -size * 0.8 + row * size * 0.45, );
           line.setAttribute("x2", x);
           line.setAttribute("y2", -size * 0.8 + row * size * 0.45 + size * 0.45, );
           line.style.stroke = "#475569";
           line.style.strokeWidth = "2";
           g.appendChild(line);
          }
         }
        }
        return g;
       }
       if (shape === "cloud") {
        const p = document.createElementNS(ns, "path");
        const s = size;
        p.setAttribute("d", `
             M ${-s * 0.8} ${s * 0.2}
             Q ${-s * 1.1} ${s * 0.2} ${-s * 1.1} ${-s * 0.1}
             Q ${-s * 1.1} ${-s * 0.5} ${-s * 0.7} ${-s * 0.5}
             Q ${-s * 0.7} ${-s * 0.9} ${-s * 0.2} ${-s * 0.9}
             Q ${s * 0.1} ${-s * 1.1} ${s * 0.5} ${-s * 0.8}
             Q ${s * 1} ${-s * 0.8} ${s * 1.1} ${-s * 0.3}
             Q ${s * 1.3} ${-s * 0.1} ${s * 1.1} ${s * 0.2}
             Q ${s * 1.1} ${s * 0.5} ${s * 0.7} ${s * 0.5}
             L ${-s * 0.5} ${s * 0.5}
             Q ${-s * 0.9} ${s * 0.5} ${-s * 0.9} ${s * 0.2}
             Z
            `, );
        return p;
       }
       if (shape === "database") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.7);
        body.setAttribute("y", -size * 0.6);
        body.setAttribute("width", size * 1.4);
        body.setAttribute("height", size * 1.4);
        g.appendChild(body);
        const top = document.createElementNS(ns, "ellipse");
        top.setAttribute("cx", 0);
        top.setAttribute("cy", -size * 0.6);
        top.setAttribute("rx", size * 0.7);
        top.setAttribute("ry", size * 0.25);
        g.appendChild(top);
        const bottom = document.createElementNS(ns, "ellipse");
        bottom.setAttribute("cx", 0);
        bottom.setAttribute("cy", size * 0.8);
        bottom.setAttribute("rx", size * 0.7);
        bottom.setAttribute("ry", size * 0.25);
        g.appendChild(bottom);
        const mid1 = document.createElementNS(ns, "ellipse");
        mid1.setAttribute("cx", 0);
        mid1.setAttribute("cy", -size * 0.15);
        mid1.setAttribute("rx", size * 0.7);
        mid1.setAttribute("ry", size * 0.2);
        mid1.style.fill = "none";
        mid1.style.stroke = "#475569";
        mid1.style.strokeWidth = "2";
        g.appendChild(mid1);
        const mid2 = document.createElementNS(ns, "ellipse");
        mid2.setAttribute("cx", 0);
        mid2.setAttribute("cy", size * 0.35);
        mid2.setAttribute("rx", size * 0.7);
        mid2.setAttribute("ry", size * 0.2);
        mid2.style.fill = "none";
        mid2.style.stroke = "#475569";
        mid2.style.strokeWidth = "2";
        g.appendChild(mid2);
        return g;
       }
       if (shape === "printer") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.4);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size * 0.9);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const trayTop = document.createElementNS(ns, "rect");
        trayTop.setAttribute("x", -size * 0.7);
        trayTop.setAttribute("y", -size * 0.8);
        trayTop.setAttribute("width", size * 1.4);
        trayTop.setAttribute("height", size * 0.4);
        trayTop.setAttribute("rx", 2);
        trayTop.style.fill = "#1e293b";
        g.appendChild(trayTop);
        const trayOut = document.createElementNS(ns, "rect");
        trayOut.setAttribute("x", -size * 0.6);
        trayOut.setAttribute("y", size * 0.5);
        trayOut.setAttribute("width", size * 1.2);
        trayOut.setAttribute("height", size * 0.35);
        trayOut.setAttribute("rx", 2);
        g.appendChild(trayOut);
        const paper = document.createElementNS(ns, "rect");
        paper.setAttribute("x", -size * 0.5);
        paper.setAttribute("y", size * 0.3);
        paper.setAttribute("width", size * 1);
        paper.setAttribute("height", size * 0.5);
        paper.style.fill = "#e2e8f0";
        g.appendChild(paper);
        return g;
       }
       if (shape === "access-point" || shape === "wifi") {
        const g = document.createElementNS(ns, "g");
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.3);
        base.setAttribute("y", size * 0.2);
        base.setAttribute("width", size * 0.6);
        base.setAttribute("height", size * 0.3);
        base.setAttribute("rx", 3);
        g.appendChild(base);
        for (let i = 1; i <= 3; i++) {
         const arc = document.createElementNS(ns, "path");
         const r = size * 0.3 * i;
         arc.setAttribute("d", `M ${-r * 0.7} ${size * 0.1 - r * 0.5} A ${r} ${r} 0 0 1 ${r * 0.7} ${size * 0.1 - r * 0.5}`);
         arc.style.fill = "none";
         arc.style.stroke = "currentColor";
         arc.style.strokeWidth = "2";
         arc.style.opacity = 1 - (i * 0.2);
         g.appendChild(arc);
        }
        return g;
       }
       if (shape === "load-balancer") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.5);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        const bar = document.createElementNS(ns, "line");
        bar.setAttribute("x1", -size * 0.6);
        bar.setAttribute("y1", 0);
        bar.setAttribute("x2", size * 0.6);
        bar.setAttribute("y2", 0);
        bar.style.stroke = "#4ade80";
        bar.style.strokeWidth = "3";
        g.appendChild(bar);
        [-1, 1].forEach(dir => {
         const arrow = document.createElementNS(ns, "path");
         arrow.setAttribute("d", `M ${dir * size * 0.3} ${-size * 0.2} L ${dir * size * 0.6} 0 L ${dir * size * 0.3} ${size * 0.2}`);
         arrow.style.fill = "none";
         arrow.style.stroke = "#4ade80";
         arrow.style.strokeWidth = "2";
         g.appendChild(arrow);
        });
        return g;
       }
       if (shape === "nas" || shape === "storage") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.8);
        body.setAttribute("y", -size * 0.9);
        body.setAttribute("width", size * 1.6);
        body.setAttribute("height", size * 1.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 4; i++) {
         const bay = document.createElementNS(ns, "rect");
         bay.setAttribute("x", -size * 0.6);
         bay.setAttribute("y", -size * 0.7 + i * size * 0.4);
         bay.setAttribute("width", size * 1.2);
         bay.setAttribute("height", size * 0.3);
         bay.setAttribute("rx", 2);
         bay.style.fill = "#1e293b";
         g.appendChild(bay);
        }
        return g;
       }
       if (shape === "gateway" || shape === "modem") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.5);
        body.setAttribute("y", -size * 0.9);
        body.setAttribute("width", size);
        body.setAttribute("height", size * 1.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 4; i++) {
         const led = document.createElementNS(ns, "circle");
         led.setAttribute("cx", 0);
         led.setAttribute("cy", -size * 0.6 + i * size * 0.35);
         led.setAttribute("r", size * 0.08);
         led.style.fill = ["#4ade80", "#4ade80", "#facc15", "#60a5fa"][i];
         g.appendChild(led);
        }
        return g;
       }
       if (shape === "vpn" || shape === "tunnel") {
        const g = document.createElementNS(ns, "g");
        const outer = document.createElementNS(ns, "ellipse");
        outer.setAttribute("cx", 0);
        outer.setAttribute("cy", 0);
        outer.setAttribute("rx", size);
        outer.setAttribute("ry", size * 0.6);
        g.appendChild(outer);
        const inner = document.createElementNS(ns, "ellipse");
        inner.setAttribute("cx", 0);
        inner.setAttribute("cy", 0);
        inner.setAttribute("rx", size * 0.5);
        inner.setAttribute("ry", size * 0.3);
        inner.style.fill = "#1e293b";
        g.appendChild(inner);
        const lock = document.createElementNS(ns, "rect");
        lock.setAttribute("x", -size * 0.15);
        lock.setAttribute("y", -size * 0.1);
        lock.setAttribute("width", size * 0.3);
        lock.setAttribute("height", size * 0.25);
        lock.setAttribute("rx", 2);
        lock.style.fill = "#4ade80";
        g.appendChild(lock);
        return g;
       }
       if (shape === "container") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.5);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 3; i++) {
         const block = document.createElementNS(ns, "rect");
         block.setAttribute("x", -size * 0.8 + i * size * 0.55);
         block.setAttribute("y", -size * 0.3);
         block.setAttribute("width", size * 0.45);
         block.setAttribute("height", size * 0.6);
         block.setAttribute("rx", 2);
         block.style.fill = "#1e293b";
         g.appendChild(block);
        }
        return g;
       }
       if (shape === "vm" || shape === "virtual") {
        const g = document.createElementNS(ns, "g");
        const shadow = document.createElementNS(ns, "rect");
        shadow.setAttribute("x", -size * 0.85 + 4);
        shadow.setAttribute("y", -size * 0.65 + 4);
        shadow.setAttribute("width", size * 1.7);
        shadow.setAttribute("height", size * 1.3);
        shadow.setAttribute("rx", 4);
        shadow.style.opacity = "0.3";
        g.appendChild(shadow);
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.85);
        body.setAttribute("y", -size * 0.65);
        body.setAttribute("width", size * 1.7);
        body.setAttribute("height", size * 1.3);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.65);
        screen.setAttribute("y", -size * 0.45);
        screen.setAttribute("width", size * 1.3);
        screen.setAttribute("height", size * 0.7);
        screen.setAttribute("rx", 2);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        return g;
       }
       if (shape === "kubernetes" || shape === "k8s") {
        const g = document.createElementNS(ns, "g");
        const outer = document.createElementNS(ns, "circle");
        outer.setAttribute("cx", 0);
        outer.setAttribute("cy", 0);
        outer.setAttribute("r", size);
        g.appendChild(outer);
        const inner = document.createElementNS(ns, "circle");
        inner.setAttribute("cx", 0);
        inner.setAttribute("cy", 0);
        inner.setAttribute("r", size * 0.4);
        inner.style.fill = "#1e293b";
        g.appendChild(inner);
        for (let i = 0; i < 7; i++) {
         const angle = (Math.PI * 2 / 7) * i - Math.PI / 2;
         const spoke = document.createElementNS(ns, "line");
         spoke.setAttribute("x1", Math.cos(angle) * size * 0.4);
         spoke.setAttribute("y1", Math.sin(angle) * size * 0.4);
         spoke.setAttribute("x2", Math.cos(angle) * size * 0.85);
         spoke.setAttribute("y2", Math.sin(angle) * size * 0.85);
         spoke.style.stroke = "#326ce5";
         spoke.style.strokeWidth = "3";
         g.appendChild(spoke);
        }
        return g;
       }
       if (shape === "shield" || shape === "security") {
        const p = document.createElementNS(ns, "path");
        const s = size;
        p.setAttribute("d", `M 0 ${-s} L ${s * 0.85} ${-s * 0.5} L ${s * 0.85} ${s * 0.2} Q ${s * 0.7} ${s * 0.9} 0 ${s} Q ${-s * 0.7} ${s * 0.9} ${-s * 0.85} ${s * 0.2} L ${-s * 0.85} ${-s * 0.5} Z`);
        return p;
       }
       if (shape === "camera" || shape === "cctv") {
        const g = document.createElementNS(ns, "g");
        const mount = document.createElementNS(ns, "rect");
        mount.setAttribute("x", -size * 1.1);
        mount.setAttribute("y", -size * 0.5);
        mount.setAttribute("width", size * 0.25);
        mount.setAttribute("height", size * 0.6);
        mount.setAttribute("rx", 2);
        g.appendChild(mount);
        const arm = document.createElementNS(ns, "rect");
        arm.setAttribute("x", -size * 0.9);
        arm.setAttribute("y", -size * 0.15);
        arm.setAttribute("width", size * 0.5);
        arm.setAttribute("height", size * 0.15);
        g.appendChild(arm);
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.45);
        body.setAttribute("y", -size * 0.35);
        body.setAttribute("width", size * 1.1);
        body.setAttribute("height", size * 0.7);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const lensHousing = document.createElementNS(ns, "circle");
        lensHousing.setAttribute("cx", size * 0.85);
        lensHousing.setAttribute("cy", 0);
        lensHousing.setAttribute("r", size * 0.4);
        g.appendChild(lensHousing);
        const lensOuter = document.createElementNS(ns, "circle");
        lensOuter.setAttribute("cx", size * 0.85);
        lensOuter.setAttribute("cy", 0);
        lensOuter.setAttribute("r", size * 0.28);
        lensOuter.style.fill = "#1e293b";
        g.appendChild(lensOuter);
        const lensInner = document.createElementNS(ns, "circle");
        lensInner.setAttribute("cx", size * 0.85);
        lensInner.setAttribute("cy", 0);
        lensInner.setAttribute("r", size * 0.15);
        lensInner.style.fill = "#3b82f6";
        g.appendChild(lensInner);
        const reflection = document.createElementNS(ns, "circle");
        reflection.setAttribute("cx", size * 0.8);
        reflection.setAttribute("cy", -size * 0.05);
        reflection.setAttribute("r", size * 0.05);
        reflection.style.fill = "#93c5fd";
        g.appendChild(reflection);
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", -size * 0.2);
        led.setAttribute("cy", -size * 0.15);
        led.setAttribute("r", size * 0.06);
        led.style.fill = "#ef4444";
        g.appendChild(led);
        return g;
       }
       if (shape === "monitor" || shape === "dashboard") {
        const g = document.createElementNS(ns, "g");
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size);
        screen.setAttribute("y", -size * 0.7);
        screen.setAttribute("width", size * 2);
        screen.setAttribute("height", size * 1.2);
        screen.setAttribute("rx", 4);
        g.appendChild(screen);
        const graph = document.createElementNS(ns, "polyline");
        graph.setAttribute("points", `${-size * 0.8},${size * 0.2} ${-size * 0.3},${-size * 0.2} ${size * 0.2},${size * 0.1} ${size * 0.7},${-size * 0.3}`);
        graph.style.fill = "none";
        graph.style.stroke = "#4ade80";
        graph.style.strokeWidth = "3";
        g.appendChild(graph);
        return g;
       }
       if (shape === "docker" || shape === "whale") {
        const g = document.createElementNS(ns, "g");
        const s = size;
        const body = document.createElementNS(ns, "path");
        body.setAttribute("d", `
         M ${-s * 0.9} ${s * 0.2}
         Q ${-s * 1.1} ${s * 0.5} ${-s * 0.7} ${s * 0.7}
         Q ${-s * 0.3} ${s * 0.85} ${s * 0.3} ${s * 0.75}
         Q ${s * 0.8} ${s * 0.6} ${s * 1.0} ${s * 0.3}
         Q ${s * 1.1} ${s * 0.1} ${s * 1.0} ${-s * 0.1}
         L ${s * 0.85} ${-s * 0.1}
         Q ${s * 0.7} ${-s * 0.15} ${s * 0.4} ${-s * 0.2}
         L ${-s * 0.5} ${-s * 0.2}
         Q ${-s * 0.8} ${-s * 0.1} ${-s * 0.9} ${s * 0.2}
         Z
        `);
        body.style.fill = "#0db7ed";
        g.appendChild(body);
        const tail = document.createElementNS(ns, "path");
        tail.setAttribute("d", `
         M ${-s * 0.85} ${s * 0.1}
         Q ${-s * 1.2} ${-s * 0.2} ${-s * 1.0} ${-s * 0.55}
         Q ${-s * 0.95} ${-s * 0.35} ${-s * 0.8} ${-s * 0.15}
         Z
        `);
        tail.style.fill = "#0db7ed";
        g.appendChild(tail);
        const belly = document.createElementNS(ns, "path");
        belly.setAttribute("d", `
         M ${-s * 0.5} ${s * 0.65}
         Q ${s * 0.1} ${s * 0.75} ${s * 0.6} ${s * 0.55}
         Q ${s * 0.8} ${s * 0.45} ${s * 0.9} ${s * 0.25}
         Q ${s * 0.7} ${s * 0.5} ${s * 0.3} ${s * 0.6}
         Q ${-s * 0.1} ${s * 0.7} ${-s * 0.5} ${s * 0.65}
         Z
        `);
        belly.style.fill = "#ffffff";
        belly.style.opacity = "0.3";
        g.appendChild(belly);
        for (let row = 0; row < 2; row++) {
         for (let col = 0; col < 3; col++) {
          const container = document.createElementNS(ns, "rect");
          container.setAttribute("x", -s * 0.45 + col * s * 0.35);
          container.setAttribute("y", -s * 0.7 + row * s * 0.28);
          container.setAttribute("width", s * 0.3);
          container.setAttribute("height", s * 0.23);
          container.setAttribute("rx", 2);
          container.style.fill = "#0db7ed";
          container.style.stroke = "#0a9ed8";
          container.style.strokeWidth = "1.5";
          g.appendChild(container);
         }
        }
        const topContainer = document.createElementNS(ns, "rect");
        topContainer.setAttribute("x", -s * 0.1);
        topContainer.setAttribute("y", -s * 0.95);
        topContainer.setAttribute("width", s * 0.3);
        topContainer.setAttribute("height", s * 0.23);
        topContainer.setAttribute("rx", 2);
        topContainer.style.fill = "#0db7ed";
        topContainer.style.stroke = "#0a9ed8";
        topContainer.style.strokeWidth = "1.5";
        g.appendChild(topContainer);
        const eye = document.createElementNS(ns, "circle");
        eye.setAttribute("cx", s * 0.65);
        eye.setAttribute("cy", s * 0.25);
        eye.setAttribute("r", s * 0.08);
        eye.style.fill = "#0a5f7a";
        g.appendChild(eye);
        return g;
       }
       if (shape === "rounded-square") {
        const r = document.createElementNS(ns, "rect");
        const s = size * 1.6;
        r.setAttribute("x", -s / 2);
        r.setAttribute("y", -s / 2);
        r.setAttribute("width", s);
        r.setAttribute("height", s);
        r.setAttribute("rx", size * 0.4);
        return r;
       }
       if (shape === "pill" || shape === "capsule") {
        const r = document.createElementNS(ns, "rect");
        r.setAttribute("x", -size * 1.2);
        r.setAttribute("y", -size * 0.5);
        r.setAttribute("width", size * 2.4);
        r.setAttribute("height", size);
        r.setAttribute("rx", size * 0.5);
        return r;
       }
       if (shape === "octagon") {
        const p = document.createElementNS(ns, "polygon");
        const r = size;
        const pts = [];
        for (let i = 0; i < 8; i++) {
         const a = (Math.PI / 4) * i - Math.PI / 8;
         pts.push([Math.cos(a) * r, Math.sin(a) * r]);
        }
        p.setAttribute("points", pts.map(pt => pt.join(",")).join(" "));
        return p;
       }
       if (shape === "pentagon") {
        const p = document.createElementNS(ns, "polygon");
        const pts = [];
        for (let i = 0; i < 5; i++) {
         const a = (Math.PI * 2 / 5) * i - Math.PI / 2;
         pts.push([Math.cos(a) * size, Math.sin(a) * size]);
        }
        p.setAttribute("points", pts.map(pt => pt.join(",")).join(" "));
        return p;
       }
       if (shape === "cross" || shape === "plus") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        const t = size * 0.35;
        p.setAttribute("points", `${-t},${-s} ${t},${-s} ${t},${-t} ${s},${-t} ${s},${t} ${t},${t} ${t},${s} ${-t},${s} ${-t},${t} ${-s},${t} ${-s},${-t} ${-t},${-t}`);
        return p;
       }
       if (shape === "parallelogram") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `${-s * 0.6},${-s * 0.6} ${s * 1.2},${-s * 0.6} ${s * 0.6},${s * 0.6} ${-s * 1.2},${s * 0.6}`);
        return p;
       }
       if (shape === "trapezoid") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `${-s * 0.6},${-s * 0.6} ${s * 0.6},${-s * 0.6} ${s},${s * 0.6} ${-s},${s * 0.6}`);
        return p;
       }
       if (shape === "sensor" || shape === "iot") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "circle");
        body.setAttribute("cx", 0);
        body.setAttribute("cy", 0);
        body.setAttribute("r", size * 0.7);
        g.appendChild(body);
        const ant = document.createElementNS(ns, "line");
        ant.setAttribute("x1", 0);
        ant.setAttribute("y1", -size * 0.7);
        ant.setAttribute("x2", 0);
        ant.setAttribute("y2", -size);
        ant.style.stroke = "currentColor";
        ant.style.strokeWidth = "2";
        g.appendChild(ant);
        const tip = document.createElementNS(ns, "circle");
        tip.setAttribute("cx", 0);
        tip.setAttribute("cy", -size);
        tip.setAttribute("r", size * 0.1);
        tip.style.fill = "#4ade80";
        g.appendChild(tip);
        return g;
       }
       if (shape === "pi" || shape === "sbc" || shape === "raspberry") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.65);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size * 1.3);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 10; i++) {
         const pin = document.createElementNS(ns, "rect");
         pin.setAttribute("x", -size * 0.85 + i * size * 0.19);
         pin.setAttribute("y", -size * 0.8);
         pin.setAttribute("width", size * 0.08);
         pin.setAttribute("height", size * 0.15);
         pin.style.fill = "#facc15";
         g.appendChild(pin);
        }
        const port = document.createElementNS(ns, "rect");
        port.setAttribute("x", size * 0.6);
        port.setAttribute("y", -size * 0.2);
        port.setAttribute("width", size * 0.35);
        port.setAttribute("height", size * 0.4);
        port.style.fill = "#1e293b";
        g.appendChild(port);
        return g;
       }
       if (shape === "api" || shape === "endpoint") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.9);
        body.setAttribute("y", -size * 0.7);
        body.setAttribute("width", size * 1.8);
        body.setAttribute("height", size * 1.4);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        const left = document.createElementNS(ns, "text");
        left.setAttribute("x", -size * 0.5);
        left.setAttribute("y", size * 0.15);
        left.setAttribute("font-size", size * 0.9);
        left.setAttribute("fill", "#4ade80");
        left.setAttribute("font-family", "monospace");
        left.textContent = "{";
        g.appendChild(left);
        const right = document.createElementNS(ns, "text");
        right.setAttribute("x", size * 0.15);
        right.setAttribute("y", size * 0.15);
        right.setAttribute("font-size", size * 0.9);
        right.setAttribute("fill", "#4ade80");
        right.setAttribute("font-family", "monospace");
        right.textContent = "}";
        g.appendChild(right);
        return g;
       }
       if (shape === "queue" || shape === "message") {
        const g = document.createElementNS(ns, "g");
        for (let i = 2; i >= 0; i--) {
         const card = document.createElementNS(ns, "rect");
         card.setAttribute("x", -size * 0.7 + i * 4);
         card.setAttribute("y", -size * 0.5 + i * 4);
         card.setAttribute("width", size * 1.4);
         card.setAttribute("height", size * 0.8);
         card.setAttribute("rx", 3);
         card.style.opacity = 1 - i * 0.25;
         g.appendChild(card);
        }
        return g;
       }
       if (shape === "lambda" || shape === "function") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.8);
        body.setAttribute("y", -size * 0.8);
        body.setAttribute("width", size * 1.6);
        body.setAttribute("height", size * 1.6);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const lambda = document.createElementNS(ns, "text");
        lambda.setAttribute("x", 0);
        lambda.setAttribute("y", size * 0.2);
        lambda.setAttribute("font-size", size * 1.2);
        lambda.setAttribute("fill", "#f59e0b");
        lambda.setAttribute("text-anchor", "middle");
        lambda.setAttribute("font-family", "serif");
        lambda.textContent = "λ";
        g.appendChild(lambda);
        return g;
       }
       if (shape === "bucket" || shape === "s3") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "path");
        body.setAttribute("d", `M ${-size * 0.8} ${-size * 0.7} L ${-size * 0.6} ${size * 0.8} Q ${-size * 0.5} ${size} 0 ${size} Q ${size * 0.5} ${size} ${size * 0.6} ${size * 0.8} L ${size * 0.8} ${-size * 0.7} Z`);
        g.appendChild(body);
        const rim = document.createElementNS(ns, "ellipse");
        rim.setAttribute("cx", 0);
        rim.setAttribute("cy", -size * 0.7);
        rim.setAttribute("rx", size * 0.8);
        rim.setAttribute("ry", size * 0.25);
        g.appendChild(rim);
        return g;
       }
       const c = document.createElementNS(ns, "circle");
       c.setAttribute("r", size);
       return c;
      }
      function createNodeShape(id, size) {
       const shapeType = (NODE_DATA[id] && NODE_DATA[id].shape) || "circle";
       const shapeEl = createShapeElement(shapeType, size);
       shapeEl.classList.add("node-circle");
       const styles = resolveStylesForNode(id);
       shapeEl.style.fill = styles.circleColor || PAGE_STATE.nodeFill || "#1e293b";
       shapeEl.style.stroke = styles.circleBorder || PAGE_STATE.nodeStroke || "#475569";
       return shapeEl;
      }
      function forgeTheLegend() {
       const container = document.getElementById("edge-legend");
       if (!container) return;
       container.innerHTML = "";
       const title = document.createElement("div");
       title.className = "legend-title";
       title.textContent = "Line Legend";
       container.appendChild(title);
       const closeBtn = document.createElement("button");
       closeBtn.type = "button";
       closeBtn.className = "legend-close-btn";
       closeBtn.textContent = "✕";
       closeBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        legendCollapsed = true;
        updateLegendVisibility();
       });
       container.appendChild(closeBtn);
       const colors = [...new Set(EDGE_DATA.list.map((e) => e.color).filter(Boolean))];
       if (colors.length === 0) {
        updateLegendVisibility();
        return;
       }
       colors.forEach((color) => {
        if (!EDGE_LEGEND[color]) {
         EDGE_LEGEND[color] = "you can edit me too";
        }
        const item = document.createElement("div");
        item.className = "legend-item";
        item.addEventListener("mousedown", (e) => e.stopPropagation());
        item.addEventListener("click", (e) => e.stopPropagation());
        const swatch = document.createElement("span");
        swatch.className = "legend-swatch";
        swatch.style.backgroundColor = color;
        swatch.style.cursor = "pointer";
        swatch.addEventListener("click", (e) => {
         e.stopPropagation();
         const edgeWithColor = EDGE_DATA.list.find(edge => edge.color === color);
         if (edgeWithColor) {
          selectTheConnection(edgeWithColor.id);
         }
        });
        let swatchTouchStart = null;
        let swatchTouchMoved = false;
        swatch.addEventListener("touchstart", (e) => {
         swatchTouchStart = Date.now();
         swatchTouchMoved = false;
         if (e.touches[0]) {
          swatchTouchStartX = e.touches[0].clientX;
          swatchTouchStartY = e.touches[0].clientY;
         }
        }, {
         passive: false
        });
        let swatchTouchStartX = 0, swatchTouchStartY = 0;
        swatch.addEventListener("touchmove", (e) => {
         if (e.touches[0]) {
          const dx = Math.abs(e.touches[0].clientX - swatchTouchStartX);
          const dy = Math.abs(e.touches[0].clientY - swatchTouchStartY);
          if (dx > 10 || dy > 10) swatchTouchMoved = true;
         }
        }, {
         passive: false
        });
        swatch.addEventListener("touchend", (e) => {
         if (swatchTouchStart && !swatchTouchMoved && Date.now() - swatchTouchStart < 400) {
          e.stopPropagation();
          e.preventDefault();
          const edgeWithColor = EDGE_DATA.list.find(edge => edge.color === color);
          if (edgeWithColor) {
           selectTheConnection(edgeWithColor.id);
          }
         }
         swatchTouchStart = null;
         swatchTouchMoved = false;
        }, {
         passive: false
        });
        const label = document.createElement("span");
        label.className = "legend-label";
        label.textContent = EDGE_LEGEND[color];
        if (isMobileDevice()) {
         label.style.cursor = "pointer";
         let labelTapStart = null;
         let labelTapMoved = false;
         label.addEventListener("touchstart", (e) => {
          labelTapStart = Date.now();
          labelTapMoved = false;
          if (e.touches[0]) {
           labelTapStartX = e.touches[0].clientX;
           labelTapStartY = e.touches[0].clientY;
          }
          e.stopPropagation();
         });
         let labelTapStartX = 0, labelTapStartY = 0;
         label.addEventListener("touchmove", (e) => {
          if (e.touches[0]) {
           const dx = Math.abs(e.touches[0].clientX - labelTapStartX);
           const dy = Math.abs(e.touches[0].clientY - labelTapStartY);
           if (dx > 10 || dy > 10) labelTapMoved = true;
          }
         });
         label.addEventListener("touchend", (e) => {
          if (labelTapStart && !labelTapMoved && Date.now() - labelTapStart < 400) {
           e.preventDefault();
           e.stopPropagation();
           const currentText = label.textContent;
           const newText = prompt("Edit legend label:", currentText);
           if (newText !== null && newText.trim()) {
            label.textContent = newText.trim();
            EDGE_LEGEND[color] = newText.trim();
           }
          }
          labelTapStart = null;
          labelTapMoved = false;
         });
        } else {
         label.contentEditable = true;
         label.addEventListener("focus", () => {
          label.classList.add("editing");
         });
         label.addEventListener("blur", () => {
          label.classList.remove("editing");
          const text = label.textContent.trim() || "you can edit me too";
          EDGE_LEGEND[color] = text;
         });
         label.addEventListener("keydown", (e) => {
          if (e.key === "Enter") {
           e.preventDefault();
           label.blur();
          }
         });
        }
        item.append(swatch, label);
        container.appendChild(item);
       });
       updateLegendVisibility();
      }
       function deleteRectangle(rectId) {
      pushUndo("delete zone");
        RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== rectId);
        forgeTheTopology();
       }
       function updateRectangleDeleteButtons() {
        const deleteButtons = document.querySelectorAll('.rect-delete-btn');
        deleteButtons.forEach(btn => {
         btn.style.display = rectDrawMode ? 'block' : 'none';
        });
       }
      function forgeTheTopology() {
       if (!NODE_DATA || !EDGE_DATA) {
        console.warn("forgeTheTopology called before data initialized");
        return;
       }
       const svg = document.getElementById("map");
       svg.innerHTML = "";
       const ns = "http://www.w3.org/2000/svg";
       const defs = document.createElementNS(ns, "defs");
       const markerForward = document.createElementNS(ns, "marker");
       markerForward.id = "arrow-forward";
       markerForward.setAttribute("markerWidth", "10");
       markerForward.setAttribute("markerHeight", "10");
       markerForward.setAttribute("refX", "9");
       markerForward.setAttribute("refY", "3");
       markerForward.setAttribute("orient", "auto");
       markerForward.setAttribute("markerUnits", "strokeWidth");
       const pathForward = document.createElementNS(ns, "path");
       pathForward.setAttribute("d", "M0,0 L0,6 L9,3 z");
       pathForward.setAttribute("fill", "context-stroke");
       markerForward.appendChild(pathForward);
       defs.appendChild(markerForward);
       const markerBackward = document.createElementNS(ns, "marker");
       markerBackward.id = "arrow-backward";
       markerBackward.setAttribute("markerWidth", "10");
       markerBackward.setAttribute("markerHeight", "10");
       markerBackward.setAttribute("refX", "0");
       markerBackward.setAttribute("refY", "3");
       markerBackward.setAttribute("orient", "auto");
       markerBackward.setAttribute("markerUnits", "strokeWidth");
       const pathBackward = document.createElementNS(ns, "path");
       pathBackward.setAttribute("d", "M9,0 L9,6 L0,3 z");
       pathBackward.setAttribute("fill", "context-stroke");
       markerBackward.appendChild(pathBackward);
       defs.appendChild(markerBackward);
       svg.appendChild(defs);
       const boundary = document.createElementNS(ns, "rect");
       boundary.setAttribute("x", CANVAS_PADDING);
       boundary.setAttribute("y", CANVAS_PADDING);
       boundary.setAttribute("width", CANVAS_WIDTH - CANVAS_PADDING * 2);
       boundary.setAttribute("height", CANVAS_HEIGHT - CANVAS_PADDING * 2);
       boundary.setAttribute("fill", "none");
       boundary.setAttribute("stroke", (PAGE_STATE.canvasBorder || "#475569") + "4D");
       boundary.setAttribute("stroke-width", "20");
       boundary.setAttribute("stroke-dasharray", "10 5");
       boundary.setAttribute("rx", "8");
       svg.appendChild(boundary);
       if (currentView.mode !== "rack") {
        const gridGroup = document.createElementNS(ns, "g");
        gridGroup.id = "canvas-grid";
        const gridSize = PAGE_STATE.canvasGridSize || 50;
        const gridColor = (PAGE_STATE.canvasGrid || "#475569") + "33";
        const majorGridColor = (PAGE_STATE.canvasGrid || "#475569") + "66";
        for (let x = CANVAS_PADDING; x <= CANVAS_WIDTH - CANVAS_PADDING; x += gridSize) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", x);
         line.setAttribute("y1", CANVAS_PADDING);
         line.setAttribute("x2", x);
         line.setAttribute("y2", CANVAS_HEIGHT - CANVAS_PADDING);
         line.setAttribute("stroke", (x - CANVAS_PADDING) % (gridSize * 5) === 0 ? majorGridColor : gridColor);
         line.setAttribute("stroke-width", (x - CANVAS_PADDING) % (gridSize * 5) === 0 ? "2" : "1");
         gridGroup.appendChild(line);
        }
        for (let y = CANVAS_PADDING; y <= CANVAS_HEIGHT - CANVAS_PADDING; y += gridSize) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", CANVAS_PADDING);
         line.setAttribute("y1", y);
         line.setAttribute("x2", CANVAS_WIDTH - CANVAS_PADDING);
         line.setAttribute("y2", y);
         line.setAttribute("stroke", (y - CANVAS_PADDING) % (gridSize * 5) === 0 ? majorGridColor : gridColor);
         line.setAttribute("stroke-width", (y - CANVAS_PADDING) % (gridSize * 5) === 0 ? "2" : "1");
         gridGroup.appendChild(line);
        }
        svg.appendChild(gridGroup);
       }
       if (currentView.mode === "rack" && currentView.rackId) {
        const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
        const rackGroup = document.createElementNS(ns, "g");
        rackGroup.id = "rack-visualization";
        const rackFrame = document.createElementNS(ns, "rect");
        rackFrame.setAttribute("x", RACK_START_X - RACK_WIDTH / 2);
        rackFrame.setAttribute("y", RACK_START_Y);
        rackFrame.setAttribute("width", RACK_WIDTH);
      rackFrame.setAttribute("height", rackCapacity * rackUHeight);
        rackFrame.setAttribute("fill", (PAGE_STATE.rackFrameFill || "#0f172a") + "4D");
        rackFrame.setAttribute("stroke", PAGE_STATE.rackFrameStroke || "#4fd1c5");
        rackFrame.setAttribute("stroke-width", "3");
        rackFrame.setAttribute("rx", "4");
        rackGroup.appendChild(rackFrame);
        for (let u = 0; u <= rackCapacity; u++) {
         const y = RACK_START_Y + u * rackUHeight;
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", RACK_START_X - RACK_WIDTH / 2);
         line.setAttribute("y1", y);
         line.setAttribute("x2", RACK_START_X + RACK_WIDTH / 2);
         line.setAttribute("y2", y);
         line.setAttribute("stroke", (PAGE_STATE.rackLineColor || "#475569") + "66");
         line.setAttribute("stroke-width", u % 5 === 0 ? "2" : "1");
         line.setAttribute("stroke-dasharray", u % 5 === 0 ? "none" : "5,5");
         rackGroup.appendChild(line);
         if (u < rackCapacity) {
          const uNumber = rackCapacity - u;
          const text = document.createElementNS(ns, "text");
          text.setAttribute("x", RACK_START_X - RACK_WIDTH / 2 - 30);
          text.setAttribute("y", y + rackUHeight / 2);
          text.setAttribute("text-anchor", "middle");
          text.setAttribute("dominant-baseline", "middle");
          text.style.fill = PAGE_STATE.rackTextColor || "#4fd1c5";
          text.style.fontSize = "14px";
          text.style.fontWeight = "bold";
          text.textContent = `U${uNumber}`;
          rackGroup.appendChild(text);
          const textRight = document.createElementNS(ns, "text");
          textRight.setAttribute("x", RACK_START_X + RACK_WIDTH / 2 + 30);
          textRight.setAttribute("y", y + rackUHeight / 2);
          textRight.setAttribute("text-anchor", "middle");
          textRight.setAttribute("dominant-baseline", "middle");
          textRight.style.fill = PAGE_STATE.rackTextColor || "#4fd1c5";
          textRight.style.fontSize = "14px";
          textRight.style.fontWeight = "bold";
          textRight.textContent = `U${uNumber}`;
          rackGroup.appendChild(textRight);
         }
        }
        svg.appendChild(rackGroup);
       }
        if (RECT_DATA && RECT_DATA.list) {
         RECT_DATA.list.forEach((rect) => {
          if (currentView.mode === "rack") return;
          if (rect.style === "filled") {
           const g = document.createElementNS(ns, "g");
           g.classList.add("rect-group");
           g.dataset.rectId = rect.id;
           const rectEl = document.createElementNS(ns, "rect");
           rectEl.classList.add("rect-shape");
           rectEl.setAttribute("x", rect.x);
           rectEl.setAttribute("y", rect.y);
           rectEl.setAttribute("width", rect.width);
           rectEl.setAttribute("height", rect.height);
           rectEl.style.fill = rect.color;
           rectEl.style.fillOpacity = "0.3";
           rectEl.style.stroke = rect.borderColor || rect.color;
           rectEl.style.strokeWidth = (rect.borderWidth !== undefined ? rect.borderWidth : 2) + "px";
           if (rect.lineStyle === "dashed") { rectEl.style.strokeDasharray = "10,5"; }
           else if (rect.lineStyle === "dotted") { rectEl.style.strokeDasharray = "2,4"; }
           else { rectEl.style.strokeDasharray = "none"; }
           rectEl.style.cursor = "move";
          rectEl.addEventListener("click", (e) => {
		  if (isViewOnly()) return;
             if (rectDrawMode) return;
             e.stopPropagation();
             currentRectId = rect.id;
             selectTheRect(rect.id);
           });
           rectEl.addEventListener("contextmenu", (e) => {
		   if (isViewOnly()) return;
             e.preventDefault();
             e.stopPropagation();
             if (selectedRects.has(rect.id)) {
               selectedRects.delete(rect.id);
             } else {
               selectedRects.add(rect.id);
             }
             updateAllSelections();
           });
           let rectLastTap = 0;
           rectEl.addEventListener("touchend", (e) => {
             const now = Date.now();
             if (now - rectLastTap < 300) {
               e.preventDefault();
               if (selectedRects.has(rect.id)) {
                 selectedRects.delete(rect.id);
               } else {
                 selectedRects.add(rect.id);
               }
               updateAllSelections();
               if (navigator.vibrate) navigator.vibrate(50);
               rectLastTap = 0;
             } else {
               rectLastTap = now;
             }
           }, { passive: false });
           const deleteBtn = document.createElementNS(ns, "g");
           deleteBtn.classList.add("rect-delete-btn");
           deleteBtn.style.cursor = "pointer";
           deleteBtn.style.display = rectDrawMode ? "block" : "none";
           const deleteBg = document.createElementNS(ns, "circle");
           deleteBg.setAttribute("cx", rect.x + rect.width - 10);
           deleteBg.setAttribute("cy", rect.y + 10);
           deleteBg.setAttribute("r", 12);
           deleteBg.style.fill = "#f56565";
           deleteBg.style.stroke = "white";
           deleteBg.style.strokeWidth = "2";
           const deleteX = document.createElementNS(ns, "text");
           deleteX.setAttribute("x", rect.x + rect.width - 10);
           deleteX.setAttribute("y", rect.y + 10);
           deleteX.setAttribute("text-anchor", "middle");
           deleteX.setAttribute("dominant-baseline", "middle");
           deleteX.style.fill = "white";
           deleteX.style.fontSize = "16px";
           deleteX.style.fontWeight = "bold";
           deleteX.style.pointerEvents = "none";
           deleteX.textContent = "×";
           deleteBtn.appendChild(deleteBg);
           deleteBtn.appendChild(deleteX);
           deleteBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            e.preventDefault();
            deleteRectangle(rect.id);
           });
           deleteBtn.addEventListener("touchend", (e) => {
      e.stopPropagation();
           e.preventDefault();
           deleteRectangle(rect.id);
           });
           let isDragging = false;
           let dragStartX, dragStartY;
           let rectStartX, rectStartY;
         rectEl.addEventListener("mousedown", (e) => {
		 if (isViewOnly()) return;
      if (rectDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      rectStartX = rect.x;
      rectStartY = rect.y;
      rectEl.style.cursor = "grabbing";
      if (selectedRects.has(rect.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
           const moveHandler = (e) => {
      if (!isDragging || rectDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      rect.x = rectStartX + dx;
      rect.y = rectStartY + dy;
      if (selectedRects.has(rect.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       const newX = initialPositions[nodeId].x + dx;
       const newY = initialPositions[nodeId].y + dy;
       savedPositions[nodeId] = { x: newX, y: newY };
      }
      });
      selectedRects.forEach(rectId => {
      if (rectId === rect.id) return;
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      forgeTheTopology();
      };
           const upHandler = () => {
            if (isDragging) {
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           };
           document.addEventListener("mousemove", moveHandler);
           document.addEventListener("mouseup", upHandler);
           let touchStartX, touchStartY;
           let touchRectStartX, touchRectStartY;
           rectEl.addEventListener("touchstart", (e) => {
		   if (isViewOnly()) return;
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchRectStartX = rect.x;
            touchRectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           }, { passive: false });
           rectEl.addEventListener("touchmove", (e) => {
		    if (isViewOnly()) return;
            if (!isDragging || rectDrawMode) return;
            if (!e.touches[0]) return;
            e.preventDefault();
            e.stopPropagation();
            const svgEl = svg;
            const pt1 = svgEl.createSVGPoint();
            pt1.x = touchStartX;
            pt1.y = touchStartY;
            const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
            const touch = e.touches[0];
            const pt2 = svgEl.createSVGPoint();
            pt2.x = touch.clientX;
            pt2.y = touch.clientY;
            const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
            const dx = svgP2.x - svgP1.x;
            const dy = svgP2.y - svgP1.y;
            rect.x = touchRectStartX + dx;
            rect.y = touchRectStartY + dy;
            forgeTheTopology();
           }, { passive: false });
           rectEl.addEventListener("touchend", (e) => {
            if (isDragging) {
             e.preventDefault();
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           }, { passive: false });
            if (currentRectId === rect.id) {
      const corners = [
      { cx: rect.x, cy: rect.y, cursor: 'nwse-resize', dx: -1, dy: -1 },
      { cx: rect.x + rect.width, cy: rect.y, cursor: 'nesw-resize', dx: 1, dy: -1 },
      { cx: rect.x, cy: rect.y + rect.height, cursor: 'nesw-resize', dx: -1, dy: 1 },
      { cx: rect.x + rect.width, cy: rect.y + rect.height, cursor: 'nwse-resize', dx: 1, dy: 1 }
      ];
      corners.forEach((corner, idx) => {
      const handle = document.createElementNS(ns, "circle");
      handle.setAttribute("cx", corner.cx);
      handle.setAttribute("cy", corner.cy);
      handle.setAttribute("r", PAGE_STATE.selectionHandleSize || 8);
      handle.style.fill = PAGE_STATE.selectionHandle || "#f59e0b";
      handle.style.stroke = "#fff";
      handle.style.strokeWidth = "2";
      handle.style.cursor = corner.cursor;
      handle.addEventListener("mousedown", (e) => {
      e.preventDefault();
      e.stopPropagation();
	  pushUndo("resize zone");
      let dragging = true;
      const startX = e.clientX, startY = e.clientY;
      const origX = rect.x, origY = rect.y, origW = rect.width, origH = rect.height;
      const moveHandler = (ev) => {
        if (!dragging) return;
        const pt1 = svg.createSVGPoint(); pt1.x = startX; pt1.y = startY;
        const pt2 = svg.createSVGPoint(); pt2.x = ev.clientX; pt2.y = ev.clientY;
        const svgP1 = pt1.matrixTransform(svg.getScreenCTM().inverse());
        const svgP2 = pt2.matrixTransform(svg.getScreenCTM().inverse());
        const dx = svgP2.x - svgP1.x, dy = svgP2.y - svgP1.y;
        if (corner.dx < 0) { rect.x = origX + dx; rect.width = origW - dx; }
        else { rect.width = origW + dx; }
        if (corner.dy < 0) { rect.y = origY + dy; rect.height = origH - dy; }
        else { rect.height = origH + dy; }
        if (rect.width < 20) rect.width = 20;
        if (rect.height < 20) rect.height = 20;
        forgeTheTopology();
      };
      const upHandler = () => { dragging = false; document.removeEventListener("mousemove", moveHandler); document.removeEventListener("mouseup", upHandler); };
      document.addEventListener("mousemove", moveHandler);
      document.addEventListener("mouseup", upHandler);
      });
      g.appendChild(handle);
      });
      }
          if (rect.groupId) {
      const groupIndicator = document.createElementNS(ns, "rect");
      groupIndicator.setAttribute("x", rect.x - 4);
      groupIndicator.setAttribute("y", rect.y - 4);
      groupIndicator.setAttribute("width", rect.width + 8);
      groupIndicator.setAttribute("height", rect.height + 8);
      groupIndicator.style.fill = "none";
      groupIndicator.style.stroke = "#4fd1c5";
      groupIndicator.style.strokeWidth = "3";
      groupIndicator.style.strokeDasharray = "5,5";
      groupIndicator.style.pointerEvents = "none";
      g.insertBefore(groupIndicator, g.firstChild);
      }
      g.appendChild(rectEl);
      g.appendChild(deleteBtn);
      svg.appendChild(g);
          }
         });
        }
       const centerX = CANVAS_WIDTH / 2;
       const centerY = CANVAS_HEIGHT / 2;
       let positions = {};
              Object.keys(NODE_DATA).forEach((id) => {
        if (currentView.mode === "rack") {
         const node = NODE_DATA[id];
         if (!node || node.assignedRack !== currentView.rackId) {
          return;
         }
        }
        positions[id] = savedPositions[id] || {
         x: centerX,
         y: centerY
        };
       });
       if (Object.keys(savedPositions).length === 0) {
        const nodeIds = Object.keys(NODE_DATA).filter(id => {
         if (currentView.mode === "rack") {
          const node = NODE_DATA[id];
          return node && node.assignedRack === currentView.rackId;
         }
         return true;
        });
        const baseY = centerY - 300;
        if (nodeIds.length > 0) {
         positions[nodeIds[0]] = {
          x: centerX,
          y: baseY
         };
         const remaining = nodeIds.slice(1);
         const radius = 350;
         const startAngle = Math.PI * 0.3;
         const endAngle = Math.PI * 0.7;
         remaining.forEach((id, i) => {
          const angle = startAngle + (endAngle - startAngle) * (i / Math.max(1, remaining.length - 1));
          positions[id] = {
           x: centerX + Math.cos(angle) * radius * (i % 2 === 0 ? 1 : 1.3),
           y: baseY + 200 + Math.sin(angle) * radius * 0.8 + i * 80,
          };
         });
        }
       }
       Object.keys(positions).forEach((id) => {
        let pos = savedPositions[id] || positions[id];
        const nodeSize = savedSizes[id] || 55;
        pos.x = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, pos.x), );
        pos.y = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, pos.y), );
        positions[id] = {
         x: pos.x,
         y: pos.y
        };
        savedPositions[id] = {
         x: pos.x,
         y: pos.y
        };
       });
       const edgePairCount = {};
       const edgePairIndex = {};
       EDGE_DATA.list.forEach((edge) => {
        if (edge.type === "custom") return;
        const key = [edge.from, edge.to].sort().join("||");
        edgePairCount[key] = (edgePairCount[key] || 0) + 1;
       });
       EDGE_DATA.list.forEach((edge) => {
        if (edge.type === "custom") return;
        const key = [edge.from, edge.to].sort().join("||");
        if (!edgePairIndex[key]) edgePairIndex[key] = 0;
        edge._pairIndex = edgePairIndex[key];
        edge._pairTotal = edgePairCount[key];
        edgePairIndex[key]++;
       });
       EDGE_DATA.list.forEach((edge) => {
        if (edge.type === "custom" && Array.isArray(edge.points) && edge.points.length >= 2) {
         const poly = document.createElementNS(ns, "polyline");
         poly.classList.add("edge");
         poly.dataset.edgeId = edge.id;
         poly.style.stroke = edge.color || PAGE_STATE.defaultEdge || "#475569";
         poly.style.strokeWidth = edge.width || 4;
         poly.setAttribute("fill", "none");
         const lineStyle = edge.lineStyle || "solid";
         if (lineStyle === "dashed") {
          poly.style.strokeDasharray = "10,5";
         } else if (lineStyle === "dotted") {
          poly.style.strokeDasharray = "2,4";
         } else {
          poly.style.strokeDasharray = "none";
         }
         const direction = edge.direction || "none";
         if (direction === "forward") {
          poly.setAttribute("marker-end", "url(#arrow-forward)");
         } else if (direction === "backward") {
          poly.setAttribute("marker-start", "url(#arrow-backward)");
         } else if (direction === "both") {
          poly.setAttribute("marker-start", "url(#arrow-backward)");
          poly.setAttribute("marker-end", "url(#arrow-forward)");
         }
         const ptsStr = edge.points.map((p) => `${p.x},${p.y}`).join(" ");
         poly.setAttribute("points", ptsStr);
         const polyHit = document.createElementNS(ns, "polyline");
         polyHit.setAttribute("points", ptsStr);
         polyHit.style.fill = "none";
         polyHit.style.stroke = "transparent";
         polyHit.style.strokeWidth = "20";
         polyHit.style.cursor = "pointer";
         polyHit.dataset.edgeId = edge.id;
         polyHit.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         let edgeTouchStart = null;
         let edgeTouchMoved = false;
         polyHit.addEventListener("touchstart", (e) => {
          edgeTouchStart = Date.now();
          edgeTouchMoved = false;
          if (e.touches[0]) {
           edgeTouchStartX = e.touches[0].clientX;
           edgeTouchStartY = e.touches[0].clientY;
          }
         }, {
          passive: false
         });
         let edgeTouchStartX = 0, edgeTouchStartY = 0;
         polyHit.addEventListener("touchmove", (e) => {
          if (e.touches[0]) {
           const dx = Math.abs(e.touches[0].clientX - edgeTouchStartX);
           const dy = Math.abs(e.touches[0].clientY - edgeTouchStartY);
           if (dx > 10 || dy > 10) edgeTouchMoved = true;
          }
         }, {
          passive: false
         });
         polyHit.addEventListener("touchend", (e) => {
          if (edgeTouchStart && !edgeTouchMoved && Date.now() - edgeTouchStart < 400) {
           e.stopPropagation();
           e.preventDefault();
           selectTheConnection(edge.id);
          }
          edgeTouchStart = null;
          edgeTouchMoved = false;
         }, {
          passive: false
         });
         poly.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         polyHit.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (selectedEdges.has(edge.id)) {
           selectedEdges.delete(edge.id);
          } else {
           selectedEdges.add(edge.id);
          }
          updateAllSelections();
         });
         let customEdgeLastTap = 0;
         polyHit.addEventListener("touchend", (e) => {
          const now = Date.now();
          if (now - customEdgeLastTap < 300) {
           e.preventDefault();
           if (selectedEdges.has(edge.id)) {
            selectedEdges.delete(edge.id);
           } else {
            selectedEdges.add(edge.id);
           }
           updateAllSelections();
           if (navigator.vibrate) navigator.vibrate(50);
           customEdgeLastTap = 0;
          } else {
           customEdgeLastTap = now;
          }
         }, { passive: false });
         poly.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (selectedEdges.has(edge.id)) {
           selectedEdges.delete(edge.id);
          } else {
           selectedEdges.add(edge.id);
          }
          updateAllSelections();
         });
         let edgeLastTap = 0;
         poly.addEventListener("touchend", (e) => {
          const now = Date.now();
          if (now - edgeLastTap < 300) {
           e.preventDefault();
           if (selectedEdges.has(edge.id)) {
            selectedEdges.delete(edge.id);
           } else {
            selectedEdges.add(edge.id);
           }
           updateAllSelections();
           if (navigator.vibrate) navigator.vibrate(50);
           edgeLastTap = 0;
          } else {
           edgeLastTap = now;
          }
         });
         if (currentView.mode === "rack") {
          return;
         }
         if (edge.groupId) {
      const bounds = edge.points.reduce((acc, p) => ({ minX: Math.min(acc.minX, p.x), minY: Math.min(acc.minY, p.y), maxX: Math.max(acc.maxX, p.x), maxY: Math.max(acc.maxY, p.y) }), { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity });
      const groupIndicator = document.createElementNS(ns, "rect");
      groupIndicator.setAttribute("x", bounds.minX - 8);
      groupIndicator.setAttribute("y", bounds.minY - 8);
      groupIndicator.setAttribute("width", bounds.maxX - bounds.minX + 16);
      groupIndicator.setAttribute("height", bounds.maxY - bounds.minY + 16);
      groupIndicator.setAttribute("rx", "4");
      groupIndicator.style.fill = "none";
      groupIndicator.style.stroke = "#4fd1c5";
      groupIndicator.style.strokeWidth = "3";
      groupIndicator.style.strokeDasharray = "5,5";
      groupIndicator.style.pointerEvents = "none";
      svg.appendChild(groupIndicator);
      }
         let lineDragging = false;
      let lineDragStartX, lineDragStartY;
      let linePointsStart = [];
      polyHit.addEventListener("mousedown", (e) => {
      if (freeDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      lineDragging = true;
      lineDragStartX = e.clientX;
      lineDragStartY = e.clientY;
      linePointsStart = edge.points.map(p => ({x: p.x, y: p.y}));
      if (selectedEdges.has(edge.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
      const lineMoveHandler = (e) => {
      if (!lineDragging || freeDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = lineDragStartX;
      pt1.y = lineDragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      edge.points.forEach((p, i) => { p.x = linePointsStart[i].x + dx; p.y = linePointsStart[i].y + dy; });
      if (selectedEdges.has(edge.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       savedPositions[nodeId] = { x: initialPositions[nodeId].x + dx, y: initialPositions[nodeId].y + dy };
      }
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      if (edgeId === edge.id) return;
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      forgeTheTopology();
      };
      const lineUpHandler = () => { lineDragging = false; };
      document.addEventListener("mousemove", lineMoveHandler);
      document.addEventListener("mouseup", lineUpHandler);
      svg.appendChild(poly);
      svg.appendChild(polyHit);
         if (currentEdgeId === edge.id) {
          edge.points.forEach((p, idx) => {
           const c = document.createElementNS(ns, "circle");
           c.classList.add("edge-edit-point");
           c.setAttribute("cx", p.x);
           c.setAttribute("cy", p.y);
      c.setAttribute("r", PAGE_STATE.selectionHandleSize || 8);
           c.style.fill = PAGE_STATE.selectionHandle || "#f59e0b";
           c.style.stroke = "#fff";
           c.style.strokeWidth = "2";
           c.style.cursor = "move";
           c.dataset.edgeId = edge.id;
           c.dataset.pointIndex = String(idx);
           c.addEventListener("mousedown", (e) => {
		   if (isViewOnly()) return;
            e.preventDefault();
            e.stopPropagation();
            pushUndo("edit edge point");
            let dragging = true;
            const svgEl = svg;
            const moveHandler = (ev) => {
             if (!dragging) return;
             const pt = svgEl.createSVGPoint();
             pt.x = ev.clientX;
             pt.y = ev.clientY;
             const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
             edge.points[idx].x = svgP.x;
             edge.points[idx].y = svgP.y;
             forgeTheTopology();
            };
            const upHandler = () => {
             dragging = false;
             document.removeEventListener("mousemove", moveHandler);
             document.removeEventListener("mouseup", upHandler);
            };
            document.addEventListener("mousemove", moveHandler);
            document.addEventListener("mouseup", upHandler);
           });
           c.addEventListener("touchstart", (e) => {
            e.preventDefault();
            e.stopPropagation();
            pushUndo("edit edge point");
            let dragging = true;
            const svgEl = svg;
            const touchMoveHandler = (ev) => {
             if (!dragging || !ev.touches[0]) return;
             const pt = svgEl.createSVGPoint();
             pt.x = ev.touches[0].clientX;
             pt.y = ev.touches[0].clientY;
             const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
             edge.points[idx].x = svgP.x;
             edge.points[idx].y = svgP.y;
             forgeTheTopology();
            };
            const touchUpHandler = () => {
             dragging = false;
             document.removeEventListener("touchmove", touchMoveHandler);
             document.removeEventListener("touchend", touchUpHandler);
            };
            document.addEventListener("touchmove", touchMoveHandler);
            document.addEventListener("touchend", touchUpHandler);
           }, { passive: false });
           svg.appendChild(c);
          });
         }
         return;
        }
        const p1 = positions[edge.from];
        const p2 = positions[edge.to];
        if (!p1 || !p2) return;
        const pairTotal = edge._pairTotal || 1;
        const pairIndex = edge._pairIndex || 0;
        const midX = (p1.x + p2.x) / 2;
        const midY = (p1.y + p2.y) / 2;
        const dx = p2.x - p1.x;
        const dy = p2.y - p1.y;
        const len = Math.sqrt(dx * dx + dy * dy) || 1;
        const perpX = -dy / len;
        const perpY = dx / len;
        let offsetAmount = 0;
        if (pairTotal > 1) {
         offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
        }
        const ctrlX = midX + perpX * offsetAmount;
        const ctrlY = midY + perpY * offsetAmount;
        const path = document.createElementNS(ns, "path");
        path.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
        path.setAttribute("fill", "none");
        path.classList.add("edge");
        if (edge.type === "backup") path.classList.add("backup");
        path.dataset.edgeId = edge.id;
        path.dataset.from = edge.from;
        path.dataset.to = edge.to;
        path.style.stroke = edge.color;
        path.style.strokeWidth = edge.width;
        const pathHit = document.createElementNS(ns, "path");
        pathHit.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
        pathHit.setAttribute("fill", "none");
        pathHit.style.stroke = "transparent";
        pathHit.style.strokeWidth = "20";
        pathHit.style.cursor = "pointer";
        pathHit.dataset.edgeId = edge.id;
        pathHit.addEventListener("click", (e) => {
         e.stopPropagation();
         selectTheConnection(edge.id);
        });
        let pathTouchStart = null;
        let pathTouchMoved = false;
        pathHit.addEventListener("touchstart", (e) => {
         pathTouchStart = Date.now();
         pathTouchMoved = false;
         if (e.touches[0]) {
          pathTouchStartX = e.touches[0].clientX;
          pathTouchStartY = e.touches[0].clientY;
         }
        }, {
         passive: false
        });
        let pathTouchStartX = 0, pathTouchStartY = 0;
        pathHit.addEventListener("touchmove", (e) => {
         if (e.touches[0]) {
          const dx = Math.abs(e.touches[0].clientX - pathTouchStartX);
          const dy = Math.abs(e.touches[0].clientY - pathTouchStartY);
          if (dx > 10 || dy > 10) pathTouchMoved = true;
         }
        }, {
         passive: false
        });
        pathHit.addEventListener("touchend", (e) => {
         if (pathTouchStart && !pathTouchMoved && Date.now() - pathTouchStart < 400) {
          e.stopPropagation();
          e.preventDefault();
          selectTheConnection(edge.id);
         }
         pathTouchStart = null;
         pathTouchMoved = false;
        }, {
         passive: false
        });
        path.addEventListener("click", (e) => {
         e.stopPropagation();
         selectTheConnection(edge.id);
        });
        if (currentView.mode === "rack") {
         const fromNode = NODE_DATA[edge.from];
         const toNode = NODE_DATA[edge.to];
         if (!fromNode || !toNode ||
             fromNode.assignedRack !== currentView.rackId ||
             toNode.assignedRack !== currentView.rackId) {
          return;
         }
        }
        const fromVisible = isNodeVisible(edge.from);
        const toVisible = isNodeVisible(edge.to);
        if (!fromVisible || !toVisible) {
         path.style.opacity = "0.1";
         path.style.pointerEvents = "none";
         pathHit.style.pointerEvents = "none";
        }
        svg.appendChild(path);
        svg.appendChild(pathHit);
        if (edge.fromPort || edge.toPort) {
         const ns = "http://www.w3.org/2000/svg";
         if (edge.fromPort) {
          const fromLabel = document.createElementNS(ns, "text");
          fromLabel.textContent = edge.fromPort;
          fromLabel.setAttribute("x", p1.x);
          fromLabel.setAttribute("y", p1.y - 10);
          fromLabel.setAttribute("text-anchor", "middle");
          fromLabel.style.fill = "#94a3b8";
          fromLabel.style.fontSize = "12px";
          fromLabel.style.fontWeight = "600";
          fromLabel.style.pointerEvents = "none";
          fromLabel.classList.add("port-label");
          svg.appendChild(fromLabel);
         }
         if (edge.toPort) {
          const toLabel = document.createElementNS(ns, "text");
          toLabel.textContent = edge.toPort;
          toLabel.setAttribute("x", p2.x);
          toLabel.setAttribute("y", p2.y - 10);
          toLabel.setAttribute("text-anchor", "middle");
          toLabel.style.fill = "#94a3b8";
          toLabel.style.fontSize = "12px";
          toLabel.style.fontWeight = "600";
          toLabel.style.pointerEvents = "none";
          toLabel.classList.add("port-label");
          svg.appendChild(toLabel);
         }
        }
       });
       Object.entries(positions).forEach(([id, pos]) => {
        const node = NODE_DATA[id];
        if (!node) return;
        if (currentView.mode === "rack") {
         if (node.assignedRack !== currentView.rackId) return;
         const rackUnit = parseInt(node.rackUnit) || 1;
      const uHeight = parseInt(node.uHeight) || 1;
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      pos.x = RACK_START_X;
      pos.y = RACK_START_Y + (rackCapacity - rackUnit - uHeight + 1) * rackUHeight + (uHeight * rackUHeight) / 2;
        } else {
         if (node.assignedRack) return;
        }
        const g = document.createElementNS("http://www.w3.org/2000/svg", "g", );
        g.classList.add("node-group");
        g.dataset.nodeId = id;
        g.setAttribute("transform", `translate(${pos.x},${pos.y})`);
		let r = savedSizes[id] || 55;
		if (!savedSizes[id]) {
		 if (window.innerWidth <= 480) r = 45;
		 else if (window.innerWidth <= 768) r = 50;
		}
        const styles = resolveStylesForNode(id);
        const ns = "http://www.w3.org/2000/svg";
        const hitArea = document.createElementNS(ns, "circle");
        hitArea.setAttribute("r", r * 1.5);
        hitArea.style.fill = "transparent";
        hitArea.style.stroke = "none";
        hitArea.style.cursor = "grab";
        hitArea.classList.add("node-hit-area");
        const shapeEl = createNodeShape(id, r);
        const titleOffsetX = styles.titleOffsetX || 0;
        const titleOffsetY = styles.titleOffsetY || 0;
        const subOffsetX = styles.subOffsetX || 0;
        const subOffsetY = styles.subOffsetY || 0;
        const label = document.createElementNS("http://www.w3.org/2000/svg", "text", );
        label.classList.add("node-label");
        label.setAttribute("x", titleOffsetX);
        label.setAttribute("y", -r * 0.28 + titleOffsetY);
      const labelFontSize = styles.titleSize || PAGE_STATE.nodeTitleSize || r * 0.33;
        label.style.fontSize = labelFontSize + "px";
        label.textContent = NODE_DATA[id].name;
      label.style.fill = styles.titleColor || PAGE_STATE.nodeTitle || "#e2e8f0";
        label.style.fontFamily = styles.titleFont || PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
        label.style.pointerEvents = "none";
        const sub = document.createElementNS("http://www.w3.org/2000/svg", "text", );
        sub.classList.add("node-sub");
        sub.setAttribute("x", subOffsetX);
        sub.setAttribute("y", r * 0.4 + subOffsetY);
      const subFontSize = styles.subSize || PAGE_STATE.nodeSubSize || r * 0.24;
        sub.style.fontSize = subFontSize + "px";
        sub.textContent = NODE_DATA[id].ip;
      sub.style.fill = styles.subColor || PAGE_STATE.nodeSub || "#94a3b8";
        sub.style.fontFamily = styles.subFont || PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
        sub.style.pointerEvents = "none";
        g.append(hitArea, shapeEl, label, sub);
        if (NODE_DATA[id]?.locked) {
          const lockIcon = document.createElementNS(ns, "text");
          lockIcon.textContent = "🔒";
          lockIcon.setAttribute("x", r * 0.6);
          lockIcon.setAttribute("y", -r * 0.6);
          lockIcon.style.fontSize = (r * 0.4) + "px";
          lockIcon.style.pointerEvents = "none";
          lockIcon.style.userSelect = "none";
          lockIcon.classList.add("lock-indicator");
          g.appendChild(lockIcon);
        }
        if (NODE_DATA[id]?.groupId) {
          const groupIndicator = document.createElementNS(ns, "circle");
          groupIndicator.setAttribute("r", r + 4);
          groupIndicator.style.fill = "none";
      groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
          groupIndicator.style.strokeWidth = "3";
          groupIndicator.style.strokeDasharray = "5,5";
          groupIndicator.style.pointerEvents = "none";
          groupIndicator.classList.add("group-indicator");
          g.insertBefore(groupIndicator, g.firstChild);
        }
        let isDragging = false;
        let startX, startY;
        let initialPositions = {};
        let longPressTimer = null;
        let longPressTriggered = false;
        g.addEventListener("contextmenu", (e) => {
         e.preventDefault();
         e.stopPropagation();
         if (isViewOnly()) return;
         if (selectedNodes.has(id)) {
          selectedNodes.delete(id);
         } else {
          selectedNodes.add(id);
         }
         updateNodeSelection();
         return false;
        });
        g.addEventListener("touchstart", (e) => {
         if (NODE_DATA[id].isRack) {
          const touch = e.touches[0];
          longPressStartX = touch.clientX;
          longPressStartY = touch.clientY;
          longPressTimer = setTimeout(() => {
           longPressTriggered = true;
           if (navigator.vibrate) {
            navigator.vibrate(100);
           }
           enterRack(id);
          }, 500);
         }
        }, { passive: true });
        let lastTapTime = 0;
        let lastTapNode = null;
        g.addEventListener("touchend", (e) => {
         const currentTime = new Date().getTime();
         const tapLength = currentTime - lastTapTime;
         if (tapLength < 300 && tapLength > 0 && lastTapNode === id) {
          e.preventDefault();
          e.stopPropagation();
          if (isViewOnly()) return;
          if (selectedNodes.has(id)) {
           selectedNodes.delete(id);
          } else {
           selectedNodes.add(id);
          }
          updateNodeSelection();
          if (navigator.vibrate) {
           navigator.vibrate(50);
          }
          lastTapTime = 0;
          lastTapNode = null;
         } else {
          lastTapTime = currentTime;
          lastTapNode = id;
         }
        });
        g.addEventListener("touchend", (e) => {
         if (longPressTimer) {
          clearTimeout(longPressTimer);
          longPressTimer = null;
         }
         if (longPressTriggered) {
          e.preventDefault();
          e.stopPropagation();
          longPressTriggered = false;
         }
        });
        let longPressStartX = 0;
        let longPressStartY = 0;
        g.addEventListener("touchmove", (e) => {
         if (longPressTimer) {
          const touch = e.touches[0];
          const dx = Math.abs(touch.clientX - longPressStartX);
          const dy = Math.abs(touch.clientY - longPressStartY);
          if (dx > 15 || dy > 15) {
           clearTimeout(longPressTimer);
           longPressTimer = null;
           longPressTriggered = false;
          }
         }
        }, { passive: true });
        g.addEventListener("mousedown", (e) => {
		 if (isViewOnly()) return;
         if (e.button === 2) {
          return;
         }
         if (NODE_DATA[id]?.locked) {
          return;
         }
         e.preventDefault();
         isDragging = true;
         const svgEl = document.getElementById("map");
         const pt = svgEl.createSVGPoint();
         pt.x = e.clientX;
         pt.y = e.clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
         startX = svgP.x;
         startY = svgP.y;
      if (selectedNodes.has(id)) {
      initialPositions = {};
      const allSelectedRects = Array.from(selectedRects);
      const allSelectedTexts = Array.from(selectedTexts);
      const allSelectedEdges = Array.from(selectedEdges).map(eid => EDGE_DATA.list.find(e => e.id === eid)).filter(Boolean);
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) {
      initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      }
      });
      Array.from(selectedRects).forEach(rectId => {
        const rect = RECT_DATA.list.find(r => r.id === rectId);
        if (rect) { rect._dragStartX = rect.x; rect._dragStartY = rect.y; }
      });
      Array.from(selectedTexts).forEach(textId => {
        const text = TEXT_DATA.list.find(t => t.id === textId);
        if (text) { text._dragStartX = text.x; text._dragStartY = text.y; }
      });
      Array.from(selectedEdges).forEach(edgeId => {
        const edge = EDGE_DATA.list.find(e => e.id === edgeId);
        if (edge && edge.points) { edge._dragStartPoints = edge.points.map(p => ({x: p.x, y: p.y})); }
      });
      } else {
      initialPositions = { [id]: { x: pos.x, y: pos.y } };
      }
      if (currentView.mode === "rack") {
      initialPositions[id] = { x: pos.x, y: pos.y };
      }
         g.style.cursor = "grabbing";
         hitArea.style.cursor = "grabbing";
         e.stopPropagation();
        });
        const handleMouseMove = (e) => {
         if (!isDragging) return;
         e.preventDefault();
         const svgEl = document.getElementById("map");
         const pt = svgEl.createSVGPoint();
         pt.x = e.clientX;
         pt.y = e.clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
         const dx = svgP.x - startX;
         const dy = svgP.y - startY;
         let nodesToMove = selectedNodes.has(id) ? Array.from(selectedNodes) : [id];
         const groupIds = new Set();
         nodesToMove.forEach(nodeId => {
          const groupId = NODE_DATA[nodeId]?.groupId;
          if (groupId) {
            groupIds.add(groupId);
          }
         });
         if (groupIds.size > 0) {
          Object.keys(NODE_DATA).forEach(nodeId => {
            const nodeGroupId = NODE_DATA[nodeId]?.groupId;
            if (nodeGroupId && groupIds.has(nodeGroupId)) {
              if (!nodesToMove.includes(nodeId)) {
                nodesToMove.push(nodeId);
                if (!initialPositions[nodeId]) {
                  const nodePos = savedPositions[nodeId];
                  if (nodePos) {
                    initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
                  }
                }
              }
            }
          });
         }
         nodesToMove = nodesToMove.filter(nodeId => !NODE_DATA[nodeId]?.locked);
         nodesToMove.forEach(nodeId => {
          if (!initialPositions[nodeId]) return;
          const initialPos = initialPositions[nodeId];
          let newX = initialPos.x + dx;
          let newY = initialPos.y + dy;
          const nodeSize = savedSizes[nodeId] || 55;
          newX = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, newX), );
          newY = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, newY), );
          savedPositions[nodeId] = { x: newX, y: newY };
          positions[nodeId] = { x: newX, y: newY };
          if (nodeId === id) {
           pos.x = newX;
           pos.y = newY;
          }
          const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
          if (nodeGroup) {
           nodeGroup.setAttribute("transform", `translate(${newX},${newY})`);
          }
         });
         Array.from(selectedRects).forEach(rectId => {
           const rect = RECT_DATA.list.find(r => r.id === rectId);
           if (rect && rect._dragStartX !== undefined) {
             rect.x = rect._dragStartX + dx;
             rect.y = rect._dragStartY + dy;
           }
         });
         Array.from(selectedTexts).forEach(textId => {
           const text = TEXT_DATA.list.find(t => t.id === textId);
           if (text && text._dragStartX !== undefined) {
             text.x = text._dragStartX + dx;
             text.y = text._dragStartY + dy;
           }
         });
         Array.from(selectedEdges).forEach(edgeId => {
           const edge = EDGE_DATA.list.find(e => e.id === edgeId);
           if (edge && edge._dragStartPoints) {
             edge.points.forEach((p, i) => {
               p.x = edge._dragStartPoints[i].x + dx;
               p.y = edge._dragStartPoints[i].y + dy;
             });
           }
         });
         forgeTheTopology();
         updateMinimap();
         document.querySelectorAll(".edge").forEach((edgeEl) => {
          const fromId = edgeEl.dataset.from;
          const toId = edgeEl.dataset.to;
          if (nodesToMove.includes(fromId) || nodesToMove.includes(toId)) {
           const p1 = savedPositions[fromId] || positions[fromId] || {
            x: 600,
            y: 350
           };
           const p2 = savedPositions[toId] || positions[toId] || {
            x: 600,
            y: 350
           };
           if (edgeEl.tagName === "line") {
            edgeEl.setAttribute("x1", p1.x);
            edgeEl.setAttribute("y1", p1.y);
            edgeEl.setAttribute("x2", p2.x);
            edgeEl.setAttribute("y2", p2.y);
           } else if (edgeEl.tagName === "path") {
            const edgeId = edgeEl.dataset.edgeId;
            const edge = EDGE_DATA.list.find(
             (e) => e.id === edgeId, );
            if (edge) {
             const pairTotal = edge._pairTotal || 1;
             const pairIndex = edge._pairIndex || 0;
             const midX = (p1.x + p2.x) / 2;
             const midY = (p1.y + p2.y) / 2;
             const dx = p2.x - p1.x;
             const dy = p2.y - p1.y;
             const len = Math.sqrt(dx * dx + dy * dy) || 1;
             const perpX = -dy / len;
             const perpY = dx / len;
             let offsetAmount = 0;
             if (pairTotal > 1) {
              offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
             }
             const ctrlX = midX + perpX * offsetAmount;
             const ctrlY = midY + perpY * offsetAmount;
             edgeEl.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
            }
           }
          }
         });
        };
      const handleMouseUp = () => {
      if (isDragging) {
      isDragging = false;
      g.style.cursor = "grab";
      hitArea.style.cursor = "grab";
      if (currentView.mode === "rack" && NODE_DATA[id]?.assignedRack === currentView.rackId) {
      const draggedY = savedPositions[id]?.y || pos.y;
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      let newUnit = rackCapacity - Math.round((draggedY - RACK_START_Y) / rackUHeight);
      newUnit = Math.max(1, Math.min(newUnit, rackCapacity));
      NODE_DATA[id].rackUnit = newUnit;
      forgeTheTopology();
      claimTheImmortal(id);
      }
      }
      };
        document.addEventListener("mousemove", handleMouseMove);
        document.addEventListener("mouseup", handleMouseUp);
        let touchStartTime = 0;
        let touchStartX = 0;
        let touchStartY = 0;
        let touchMoved = false;
        g.addEventListener("touchstart",
         (e) => {
          if (isViewOnly()) {
           touchStartTime = Date.now();
           touchMoved = false;
           e.stopPropagation();
           return;
          }
          if (NODE_DATA[id]?.locked) {
           return;
          }
          e.preventDefault();
          touchStartTime = Date.now();
          touchMoved = false;
          const svgEl = document.getElementById("map");
          const pt = svgEl.createSVGPoint();
          const touch = e.touches[0];
          pt.x = touch.clientX;
          pt.y = touch.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          touchStartX = svgP.x;
          touchStartY = svgP.y;
          startX = svgP.x;
          startY = svgP.y;
          if (selectedNodes.has(id)) {
           initialPositions = {};
           selectedNodes.forEach(nodeId => {
            const nodePos = savedPositions[nodeId];
            if (nodePos) {
             initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
            }
           });
          } else {
           initialPositions = { [id]: { x: pos.x, y: pos.y } };
          }
          e.stopPropagation();
         }, {
          passive: false
         }, );
        g.addEventListener("touchmove", (e) => {
		if (isViewOnly()) return;
         e.preventDefault();
         const svgEl = document.getElementById("map");
         const pt = svgEl.createSVGPoint();
         const touch = e.touches[0];
         pt.x = touch.clientX;
         pt.y = touch.clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
         const dx = Math.abs(svgP.x - touchStartX);
         const dy = Math.abs(svgP.y - touchStartY);
         if (dx > (isMobileDevice() ? 4 : 10) || dy > (isMobileDevice() ? 4 : 10)) {
      touchMoved = true;
      isDragging = true;
      }
         if (!isDragging) return;
         const deltaX = svgP.x - startX;
         const deltaY = svgP.y - startY;
         let nodesToMove = selectedNodes.has(id) ? Array.from(selectedNodes) : [id];
         const groupIds = new Set();
         nodesToMove.forEach(nodeId => {
          const groupId = NODE_DATA[nodeId]?.groupId;
          if (groupId) {
            groupIds.add(groupId);
          }
         });
         if (groupIds.size > 0) {
          Object.keys(NODE_DATA).forEach(nodeId => {
            const nodeGroupId = NODE_DATA[nodeId]?.groupId;
            if (nodeGroupId && groupIds.has(nodeGroupId)) {
              if (!nodesToMove.includes(nodeId)) {
                nodesToMove.push(nodeId);
                if (!initialPositions[nodeId]) {
                  const nodePos = savedPositions[nodeId];
                  if (nodePos) {
                    initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
                  }
                }
              }
            }
          });
         }
         nodesToMove = nodesToMove.filter(nodeId => !NODE_DATA[nodeId]?.locked);
         nodesToMove.forEach(nodeId => {
          if (!initialPositions[nodeId]) return;
          const initialPos = initialPositions[nodeId];
          let newX = initialPos.x + deltaX;
          let newY = initialPos.y + deltaY;
          const nodeSize = savedSizes[nodeId] || 55;
          newX = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, newX), );
          newY = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, newY), );
          savedPositions[nodeId] = { x: newX, y: newY };
          positions[nodeId] = { x: newX, y: newY };
          if (nodeId === id) {
           pos.x = newX;
           pos.y = newY;
          }
          const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
          if (nodeGroup) {
           nodeGroup.setAttribute("transform", `translate(${newX},${newY})`);
          }
         });
         updateMinimap();
         document.querySelectorAll(".edge").forEach((edgeEl) => {
          const fromId = edgeEl.dataset.from;
          const toId = edgeEl.dataset.to;
          if (nodesToMove.includes(fromId) || nodesToMove.includes(toId)) {
           const p1 = savedPositions[fromId] || positions[fromId] || {
            x: 600,
            y: 350
           };
           const p2 = savedPositions[toId] || positions[toId] || {
            x: 600,
            y: 350
           };
           if (edgeEl.tagName === "line") {
            edgeEl.setAttribute("x1", p1.x);
            edgeEl.setAttribute("y1", p1.y);
            edgeEl.setAttribute("x2", p2.x);
            edgeEl.setAttribute("y2", p2.y);
           } else if (edgeEl.tagName === "path") {
            const edgeId = edgeEl.dataset.edgeId;
            const edge = EDGE_DATA.list.find(
             (e) => e.id === edgeId, );
            if (edge) {
             const pairTotal = edge._pairTotal || 1;
             const pairIndex = edge._pairIndex || 0;
             const midX = (p1.x + p2.x) / 2;
             const midY = (p1.y + p2.y) / 2;
             const dx = p2.x - p1.x;
             const dy = p2.y - p1.y;
             const len = Math.sqrt(dx * dx + dy * dy) || 1;
             const perpX = -dy / len;
             const perpY = dx / len;
             let offsetAmount = 0;
             if (pairTotal > 1) {
              offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
             }
             const ctrlX = midX + perpX * offsetAmount;
             const ctrlY = midY + perpY * offsetAmount;
             edgeEl.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
            }
           }
          }
         });
        }, {
         passive: false
        });
      g.addEventListener("touchend", (e) => {
      const touchDuration = Date.now() - touchStartTime;
      if (!touchMoved && touchDuration < 400) {
       if (isViewOnly()) {
        handleViewOnlyClick(id, 'node');
        return;
       }
       claimTheImmortal(id);
      }
      if (isDragging) {
      const draggedY = pos.y;
      isDragging = false;
      savedPositions[id] = {
      x: pos.x,
      y: pos.y
      };
      if (currentView.mode === "rack" && NODE_DATA[id]?.assignedRack === currentView.rackId) {
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      let newUnit = rackCapacity - Math.round((draggedY - RACK_START_Y) / rackUHeight);
      newUnit = Math.max(1, Math.min(newUnit, rackCapacity));
      NODE_DATA[id].rackUnit = newUnit;
      forgeTheTopology();
      claimTheImmortal(id);
      }
      }
      touchMoved = false;
      });
        g.style.cursor = "grab";
        g.addEventListener("click", (e) => {
         if (!isDragging) {
          if (isViewOnly()) {
           handleViewOnlyClick(id, 'node');
           return;
          }
          claimTheImmortal(id);
         }
        });
        g.addEventListener("dblclick", (e) => {
         e.preventDefault();
         e.stopPropagation();
         if (NODE_DATA[id].isRack) {
          enterRack(id);
         }
        });
        if (!isNodeVisible(id)) {
         g.style.opacity = "0.1";
         g.style.pointerEvents = "none";
        }
        svg.appendChild(g);
       });
        if (RECT_DATA && RECT_DATA.list) {
         RECT_DATA.list.forEach((rect) => {
          if (currentView.mode === "rack") return;
          if (rect.style === "outlined") {
           const g = document.createElementNS(ns, "g");
           g.classList.add("rect-group");
           g.dataset.rectId = rect.id;
           const rectEl = document.createElementNS(ns, "rect");
           rectEl.classList.add("rect-shape");
           rectEl.setAttribute("x", rect.x);
           rectEl.setAttribute("y", rect.y);
           rectEl.setAttribute("width", rect.width);
           rectEl.setAttribute("height", rect.height);
           rectEl.style.fill = "none";
           rectEl.style.stroke = rect.borderColor || rect.color;
           rectEl.style.strokeWidth = (rect.borderWidth !== undefined ? rect.borderWidth : 3) + "px";
           if (rect.lineStyle === "dashed") { rectEl.style.strokeDasharray = "10,5"; }
           else if (rect.lineStyle === "dotted") { rectEl.style.strokeDasharray = "2,4"; }
           else { rectEl.style.strokeDasharray = "none"; }
           rectEl.style.cursor = "move";
           rectEl.addEventListener("click", (e) => {
             if (rectDrawMode) return;
             e.stopPropagation();
             currentRectId = rect.id;
             selectTheRect(rect.id);
           });
           rectEl.addEventListener("contextmenu", (e) => {
		   if (isViewOnly()) return;
             e.preventDefault();
             e.stopPropagation();
             if (selectedRects.has(rect.id)) {
               selectedRects.delete(rect.id);
             } else {
               selectedRects.add(rect.id);
             }
             updateAllSelections();
           });
           let rectLastTap = 0;
           rectEl.addEventListener("touchend", (e) => {
             const now = Date.now();
             if (now - rectLastTap < 300) {
               e.preventDefault();
               if (selectedRects.has(rect.id)) {
                 selectedRects.delete(rect.id);
               } else {
                 selectedRects.add(rect.id);
               }
               updateAllSelections();
               if (navigator.vibrate) navigator.vibrate(50);
               rectLastTap = 0;
             } else {
               rectLastTap = now;
             }
           }, { passive: false });
           const deleteBtn = document.createElementNS(ns, "g");
           deleteBtn.classList.add("rect-delete-btn");
           deleteBtn.style.cursor = "pointer";
           deleteBtn.style.display = rectDrawMode ? "block" : "none";
           const deleteBg = document.createElementNS(ns, "circle");
           deleteBg.setAttribute("cx", rect.x + rect.width - 10);
           deleteBg.setAttribute("cy", rect.y + 10);
           deleteBg.setAttribute("r", 12);
           deleteBg.style.fill = "#f56565";
           deleteBg.style.stroke = "white";
           deleteBg.style.strokeWidth = "2";
           const deleteX = document.createElementNS(ns, "text");
           deleteX.setAttribute("x", rect.x + rect.width - 10);
           deleteX.setAttribute("y", rect.y + 10);
           deleteX.setAttribute("text-anchor", "middle");
           deleteX.setAttribute("dominant-baseline", "middle");
           deleteX.style.fill = "white";
           deleteX.style.fontSize = "16px";
           deleteX.style.fontWeight = "bold";
           deleteX.style.pointerEvents = "none";
           deleteX.textContent = "×";
           deleteBtn.appendChild(deleteBg);
           deleteBtn.appendChild(deleteX);
           deleteBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            e.preventDefault();
            deleteRectangle(rect.id);
           });
           let isDragging = false;
           let dragStartX, dragStartY;
           let rectStartX, rectStartY;
           rectEl.addEventListener("mousedown", (e) => {
		   if (isViewOnly()) return;
      if (rectDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      rectStartX = rect.x;
      rectStartY = rect.y;
      rectEl.style.cursor = "grabbing";
      if (selectedRects.has(rect.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
           const moveHandler = (e) => {
      if (!isDragging || rectDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      rect.x = rectStartX + dx;
      rect.y = rectStartY + dy;
      if (selectedRects.has(rect.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       const newX = initialPositions[nodeId].x + dx;
       const newY = initialPositions[nodeId].y + dy;
       savedPositions[nodeId] = { x: newX, y: newY };
      }
      });
      selectedRects.forEach(rectId => {
      if (rectId === rect.id) return;
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      forgeTheTopology();
      };
           const upHandler = () => {
            if (isDragging) {
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           };
           document.addEventListener("mousemove", moveHandler);
           document.addEventListener("mouseup", upHandler);
           let touchStartX, touchStartY;
           let touchRectStartX, touchRectStartY;
           rectEl.addEventListener("touchstart", (e) => {
		   if (isViewOnly()) return;
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchRectStartX = rect.x;
            touchRectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           }, { passive: false });
           rectEl.addEventListener("touchmove", (e) => {
		    if (isViewOnly()) return;
            if (!isDragging || rectDrawMode) return;
            if (!e.touches[0]) return;
            e.preventDefault();
            e.stopPropagation();
            const svgEl = svg;
            const pt1 = svgEl.createSVGPoint();
            pt1.x = touchStartX;
            pt1.y = touchStartY;
            const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
            const touch = e.touches[0];
            const pt2 = svgEl.createSVGPoint();
            pt2.x = touch.clientX;
            pt2.y = touch.clientY;
            const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
            const dx = svgP2.x - svgP1.x;
            const dy = svgP2.y - svgP1.y;
            rect.x = touchRectStartX + dx;
            rect.y = touchRectStartY + dy;
            forgeTheTopology();
           }, { passive: false });
           rectEl.addEventListener("touchend", (e) => {
            if (isDragging) {
             e.preventDefault();
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           }, { passive: false });
           if (rect.groupId) {
             const groupIndicator = document.createElementNS(ns, "rect");
             groupIndicator.setAttribute("x", rect.x - 4);
             groupIndicator.setAttribute("y", rect.y - 4);
             groupIndicator.setAttribute("width", rect.width + 8);
             groupIndicator.setAttribute("height", rect.height + 8);
             groupIndicator.style.fill = "none";
             groupIndicator.style.stroke = "#4fd1c5";
             groupIndicator.style.strokeWidth = "3";
             groupIndicator.style.strokeDasharray = "5,5";
             groupIndicator.style.pointerEvents = "none";
             g.insertBefore(groupIndicator, g.firstChild);
           }
           g.appendChild(rectEl);
           g.appendChild(deleteBtn);
           svg.appendChild(g);
          }
         });
        }
        if (TEXT_DATA && TEXT_DATA.list) {
         TEXT_DATA.list.forEach((textItem) => {
          if (currentView.mode === "rack") return;
          const g = document.createElementNS(ns, "g");
          g.classList.add("text-group");
          g.dataset.textId = textItem.id;
          if (textItem.bgEnabled) {
           const bgRect = document.createElementNS(ns, "rect");
           bgRect.classList.add("text-bg");
           bgRect.setAttribute("x", textItem.x - 5);
           bgRect.setAttribute("y", textItem.y - textItem.fontSize - 2);
           bgRect.setAttribute("width", 100);
           bgRect.setAttribute("height", textItem.fontSize + 10);
           bgRect.style.fill = textItem.bgColor;
           bgRect.style.opacity = "0.7";
           bgRect.style.rx = "4";
           g.appendChild(bgRect);
          }
          const textEl = document.createElementNS(ns, "text");
          textEl.classList.add("text-element");
          textEl.setAttribute("x", textItem.x);
          textEl.setAttribute("y", textItem.y);
          textEl.style.fill = textItem.color;
          textEl.style.fontSize = textItem.fontSize + "px";
          textEl.style.fontWeight = textItem.fontWeight;
          textEl.style.fontStyle = textItem.fontStyle;
          textEl.style.textAnchor = textItem.textAlign;
          textEl.style.textDecoration = textItem.textDecoration;
          textEl.style.opacity = textItem.opacity;
          textEl.style.cursor = "move";
          textEl.style.userSelect = "none";
          textEl.setAttribute("dominant-baseline", "middle");
          const lines = textItem.content.split('\n');
          if (lines.length === 1) {
           textEl.textContent = textItem.content;
          } else {
           lines.forEach((line, i) => {
            const tspan = document.createElementNS(ns, "tspan");
            tspan.textContent = line;
            tspan.setAttribute("x", textItem.x);
            tspan.setAttribute("dy", i === 0 ? 0 : textItem.fontSize * 1.2);
            textEl.appendChild(tspan);
           });
          }
          g.appendChild(textEl);
          if (textItem.bgEnabled) {
           setTimeout(() => {
            try {
             const bbox = textEl.getBBox();
             const bgRect = g.querySelector('.text-bg');
             if (bgRect && bbox) {
              bgRect.setAttribute("x", bbox.x - 5);
              bgRect.setAttribute("y", bbox.y - 2);
              bgRect.setAttribute("width", bbox.width + 10);
              bgRect.setAttribute("height", bbox.height + 4);
             }
            } catch (e) {
            }
           }, 0);
          }
          const deleteBtn = document.createElementNS(ns, "g");
          deleteBtn.classList.add("text-delete-btn");
          deleteBtn.style.cursor = "pointer";
          deleteBtn.style.display = textDrawMode ? "block" : "none";
          const deleteBg = document.createElementNS(ns, "circle");
          deleteBg.setAttribute("cx", textItem.x + 20);
          deleteBg.setAttribute("cy", textItem.y - textItem.fontSize);
          deleteBg.setAttribute("r", 12);
          deleteBg.style.fill = "#f56565";
          deleteBg.style.stroke = "white";
          deleteBg.style.strokeWidth = "2";
          const deleteX = document.createElementNS(ns, "text");
          deleteX.setAttribute("x", textItem.x + 20);
          deleteX.setAttribute("y", textItem.y - textItem.fontSize);
          deleteX.setAttribute("text-anchor", "middle");
          deleteX.setAttribute("dominant-baseline", "middle");
          deleteX.style.fill = "white";
          deleteX.style.fontSize = "16px";
          deleteX.style.fontWeight = "bold";
          deleteX.style.pointerEvents = "none";
          deleteX.textContent = "×";
          deleteBtn.appendChild(deleteBg);
          deleteBtn.appendChild(deleteX);
          deleteBtn.addEventListener("click", (e) => {
           e.stopPropagation();
           e.preventDefault();
           deleteText(textItem.id);
          });
          let isDragging = false;
          let dragStartX, dragStartY;
          let textStartX, textStartY;
          textEl.addEventListener("mousedown", (e) => {
		  if (isViewOnly()) return;
      if (textDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      textStartX = textItem.x;
      textStartY = textItem.y;
      textEl.style.cursor = "grabbing";
      showTextPanel(textItem.id);
      if (selectedTexts.has(textItem.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
          const moveHandler = (e) => {
      if (!isDragging || textDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      textItem.x = textStartX + dx;
      textItem.y = textStartY + dy;
      if (selectedTexts.has(textItem.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       const newX = initialPositions[nodeId].x + dx;
       const newY = initialPositions[nodeId].y + dy;
       savedPositions[nodeId] = { x: newX, y: newY };
      }
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      if (textId === textItem.id) return;
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      forgeTheTopology();
      };
          const upHandler = () => {
           if (isDragging) {
            isDragging = false;
            textEl.style.cursor = "move";
           }
          };
          document.addEventListener("mousemove", moveHandler);
          document.addEventListener("mouseup", upHandler);
          let touchStartX = 0, touchStartY = 0;
          let textTouchStartX = 0, textTouchStartY = 0;
          textEl.addEventListener("touchstart", (e) => {
		   if (isViewOnly()) return;
           if (textDrawMode) return;
           if (e.touches.length !== 1) return;
           e.preventDefault();
           e.stopPropagation();
           const touch = e.touches[0];
           isDragging = true;
           touchStartX = touch.clientX;
           touchStartY = touch.clientY;
           textTouchStartX = textItem.x;
           textTouchStartY = textItem.y;
           showTextPanel(textItem.id);
          }, { passive: false });
          textEl.addEventListener("touchmove", (e) => {
           if (!isDragging || textDrawMode) return;
           if (e.touches.length !== 1) return;
           e.preventDefault();
           const touch = e.touches[0];
           const svgEl = svg;
           const pt1 = svgEl.createSVGPoint();
           pt1.x = touchStartX;
           pt1.y = touchStartY;
           const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
           const pt2 = svgEl.createSVGPoint();
           pt2.x = touch.clientX;
           pt2.y = touch.clientY;
           const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
           const dx = svgP2.x - svgP1.x;
           const dy = svgP2.y - svgP1.y;
           textItem.x = textTouchStartX + dx;
           textItem.y = textTouchStartY + dy;
           forgeTheTopology();
          }, { passive: false });
          textEl.addEventListener("touchend", () => {
           if (isDragging) {
            isDragging = false;
           }
          }, { passive: false });
          textEl.addEventListener("contextmenu", (e) => {
		  if (isViewOnly()) return;
           e.preventDefault();
           e.stopPropagation();
           if (selectedTexts.has(textItem.id)) {
            selectedTexts.delete(textItem.id);
           } else {
            selectedTexts.add(textItem.id);
           }
           updateAllSelections();
          });
          let textLastTap = 0;
          g.addEventListener("touchend", (e) => {
           const now = Date.now();
           if (now - textLastTap < 300) {
            e.preventDefault();
            if (selectedTexts.has(textItem.id)) {
             selectedTexts.delete(textItem.id);
            } else {
             selectedTexts.add(textItem.id);
            }
            updateAllSelections();
            if (navigator.vibrate) navigator.vibrate(50);
            textLastTap = 0;
           } else {
            textLastTap = now;
           }
          }, { passive: false });
          if (textItem.groupId) {
            const groupIndicator = document.createElementNS(ns, "rect");
            groupIndicator.setAttribute("x", textItem.x - 54);
            groupIndicator.setAttribute("y", textItem.y - 24);
            groupIndicator.setAttribute("width", 108);
            groupIndicator.setAttribute("height", 48);
            groupIndicator.setAttribute("rx", "8");
            groupIndicator.style.fill = "none";
            groupIndicator.style.stroke = "#4fd1c5";
            groupIndicator.style.strokeWidth = "3";
            groupIndicator.style.strokeDasharray = "5,5";
            groupIndicator.style.pointerEvents = "none";
            g.insertBefore(groupIndicator, g.firstChild);
          }
          g.appendChild(deleteBtn);
          svg.appendChild(g);
         });
        }
       forgeTheLegend();
       updateMinimap();
       populateRackDropdown();
      }
      function showEditModal(title, currentValue, onSave) {
       const modal = document.getElementById("edit-modal");
       const input = document.getElementById("modal-input");
       const titleEl = document.getElementById("modal-title");
       const saveBtn = document.getElementById("modal-save");
       const cancelBtn = document.getElementById("modal-cancel");
       titleEl.textContent = title;
       input.value = currentValue;
       modal.classList.add("active");
       input.focus();
       input.select();
       const cleanup = () => {
        modal.classList.remove("active");
        saveBtn.removeEventListener("click", handleSave);
        cancelBtn.removeEventListener("click", handleCancel);
        input.removeEventListener("keypress", handleEnter);
        modal.removeEventListener("click", bgHandler);
       };
       const handleSave = () => {
        if (input.value.trim()) {
         onSave(input.value.trim());
        }
        cleanup();
       };
       const handleCancel = () => {
        cleanup();
       };
       const handleEnter = (e) => {
        if (e.key === "Enter") handleSave();
       };
       const bgHandler = (e) => {
        if (e.target === modal) handleCancel();
       };
       saveBtn.addEventListener("click", handleSave);
       cancelBtn.addEventListener("click", handleCancel);
       input.addEventListener("keypress", handleEnter);
       modal.addEventListener("click", bgHandler);
      }
      function challengeTheImmortal(message, onConfirm) {
       const modal = document.getElementById("confirm-modal");
       const messageEl = document.getElementById("confirm-message");
       const deleteBtn = document.getElementById("confirm-delete");
       const cancelBtn = document.getElementById("confirm-cancel");
       messageEl.textContent = message;
       modal.classList.add("active");
	   const cleanup = () => {
        modal.classList.remove("active");
        deleteBtn.removeEventListener("click", handleConfirm);
        cancelBtn.removeEventListener("click", handleCancel);
        modal.removeEventListener("click", bgHandler);
       };
       const handleConfirm = () => {
        onConfirm();
        cleanup();
       };
       const handleCancel = () => {
        cleanup();
       };
       const bgHandler = (e) => {
        if (e.target === modal) handleCancel();
       };
       deleteBtn.addEventListener("click", handleConfirm);
       cancelBtn.addEventListener("click", handleCancel);
       modal.addEventListener("click", bgHandler);
      }
      const pageTitleEl = document.getElementById("page-title");
      if (pageTitleEl) {
       pageTitleEl.addEventListener("click", () => {
        showEditModal("Edit Title", PAGE_STATE.title || DEFAULT_PAGE_STATE.title,
         (newTitle) => {
          PAGE_STATE.title = newTitle;
          wieldThePower();
         }, );
       });
      }
      function editNodeName(id) {
       showEditModal("Edit Name", NODE_DATA[id].name, (newName) => {
        pushUndo("edit node name");
        NODE_DATA[id].name = newName;
        const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`, );
        if (nodeGroup) {
         const label = nodeGroup.querySelector(".node-label");
         if (label) label.textContent = newName;
        }
        if (currentNodeId === id) {
         document.getElementById("node-name").textContent = newName;
        }
       });
      }
      function editNodeIp(id) {
       showEditModal("Edit IP/Subtitle", NODE_DATA[id].ip, (newIp) => {
        pushUndo("edit node ip");
        NODE_DATA[id].ip = newIp;
        const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`, );
        if (nodeGroup) {
         const sub = nodeGroup.querySelector(".node-sub");
         if (sub) sub.textContent = newIp;
        }
        if (currentNodeId === id) {
         document.getElementById("node-ip").textContent = newIp;
        }
       });
      }
      function claimTheImmortal(id) {
	   if (isViewOnly()) return;
	   if (!NODE_DATA[id]) return;
       currentNodeId = id;
       currentEdgeId = null;
       currentRectId = null;
       currentTextId = null;
       if (isMobileDevice()) {
        const currentHeight = PAGE_STATE.mobileFooterHeight || 40;
        if (currentHeight <= 20) {
         PAGE_STATE.mobileFooterHeight = 80;
         const root = document.documentElement;
         root.style.setProperty("--mobile-footer-height", "80vh");
         const mobileFooterHeightInput = document.getElementById("mobile-footer-height");
         const mobileFooterHeightVal = document.getElementById("mobile-footer-height-val");
         if (mobileFooterHeightInput) mobileFooterHeightInput.value = 80;
         if (mobileFooterHeightVal) mobileFooterHeightVal.textContent = "80%";
        }
       }
       const data = NODE_DATA[id];
       document.querySelectorAll(".node-group").forEach((n) => {
        n.classList.toggle("active", n.dataset.nodeId === id);
       });
       document.querySelectorAll(".edge").forEach((e) => {
        const active = e.dataset.from === id || e.dataset.to === id;
        e.classList.toggle("active", active);
       });
       document.querySelectorAll(".rect-group").forEach((r) => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach((t) => t.classList.remove("active"));
       document.getElementById("node-panel").style.display = "block";
       document.getElementById("edge-panel").style.display = "none";
       document.getElementById("text-panel").style.display = "none";
       const toolbar = document.getElementById("topology-toolbar");
       if (!topologyToolbarCollapsed) {
        toolbar.style.display = "flex";
       }
       updateTopologyToolbarVisibility();
       document.getElementById("node-name").textContent = data.name;
       document.getElementById("node-ip").textContent = data.ip;
       document.getElementById("node-role").textContent = data.role;
       document.getElementById("node-mac").textContent = data.mac || "--";
       document.getElementById("node-rack").textContent = data.rackUnit || "--";
       document.getElementById("node-uheight").textContent = (data.uHeight || "1") + "U";
       document.getElementById("node-layer").value = data.layer || "physical";
       populateRackDropdown();
       const assignedRackSelect = document.getElementById("node-assigned-rack");
       if (assignedRackSelect) {
        assignedRackSelect.value = data.assignedRack || "";
       }
       const rackCapacitySelect = document.getElementById("node-rack-capacity");
       if (rackCapacitySelect) {
        rackCapacitySelect.value = data.rackCapacity || "42";
       }
       const isRack = data.isRack === true;
       const isAssignedToRack = !!data.assignedRack;
       const assignedRackRow = document.getElementById("assigned-rack-row");
       const rackCapacityRow = document.getElementById("rack-capacity-row");
       const uheightRow = document.getElementById("uheight-row");
       if (assignedRackRow) assignedRackRow.style.display = isRack ? "none" : "flex";
       if (rackCapacityRow) rackCapacityRow.style.display = isRack ? "flex" : "none";
       if (uheightRow) uheightRow.style.display = isAssignedToRack ? "flex" : "none";
       const rackContentsSection = document.getElementById("rack-contents-section");
       const rackContentsList = document.getElementById("rack-contents-list");
       if (rackContentsSection && rackContentsList) {
        if (isRack) {
         const nodesInRack = Object.entries(NODE_DATA).filter(([nid, n]) => n.assignedRack === id);
         if (nodesInRack.length > 0) {
          rackContentsList.innerHTML = nodesInRack.map(([nid, n]) => {
           const tags = (n.tags || []).map(t => `<span style="background: var(--accent); color: var(--bg); padding: 2px 6px; border-radius: 4px; font-size: 11px; margin-left: 4px;">${t}</span>`).join('');
           return `<div style="padding: 6px 0; border-bottom: 1px solid var(--edge-main); cursor: pointer;" onclick="claimTheImmortal('${nid}')">
            <span style="color: var(--text-main);">${n.name}</span>${tags}
           </div>`;
          }).join('');
          rackContentsSection.style.display = "block";
         } else {
          rackContentsList.innerHTML = '<div style="color: var(--text-soft); font-style: italic;">No nodes assigned</div>';
          rackContentsSection.style.display = "block";
         }
        } else {
         rackContentsSection.style.display = "none";
        }
       }
       document.getElementById("node-name").onclick = () => editNodeName(id);
       document.getElementById("node-ip").onclick = () => editNodeIp(id);
       document.getElementById("node-mac").onclick = () => editNodeMac(id);
       document.getElementById("node-rack").onclick = () => editNodeRack(id);
       document.getElementById("node-uheight").onclick = () => editNodeUHeight(id);
       const currentSize = savedSizes[id] || getDefaultSize();
       document.getElementById("size-slider").value = currentSize;
       document.getElementById("size-value").textContent = currentSize;
       const styleEntry = savedStyles[id] || {};
       const resolvedStyles = resolveStylesEntry(styleEntry);
       const scopeKey = currentStyleScope || "all";
       const flatProps = ["circleColor", "circleBorder", "titleColor", "titleFont", "titleSize", "subColor", "subFont", "subSize", ];
       const isFlat = flatProps.some((p) => Object.prototype.hasOwnProperty.call(styleEntry, p), );
       const scopedStyles = isFlat ? styleEntry : styleEntry[scopeKey] || {};
       const circleColorInput = document.getElementById("circle-color");
       const titleColorInput = document.getElementById("title-color");
       const titleFontSelect = document.getElementById("title-font");
       const titleSizeInput = document.getElementById("title-size");
       const subColorInput = document.getElementById("sub-color");
       const subFontSelect = document.getElementById("sub-font");
       const subSizeInput = document.getElementById("sub-size");
       const shapeSelect = document.getElementById("shape-select");
       const scopeSelect = document.getElementById("style-scope");
      circleColorInput.value = scopedStyles.circleColor || resolvedStyles.circleColor || PAGE_STATE.nodeFill || "#1e293b";
       const circleBorderInput = document.getElementById("circle-border");
       circleBorderInput.value = scopedStyles.circleBorder || resolvedStyles.circleBorder || PAGE_STATE.nodeStroke || "#475569";
        titleColorInput.value = scopedStyles.titleColor || resolvedStyles.titleColor || PAGE_STATE.textMain || "#e2e8f0";
        titleFontSelect.value = scopedStyles.titleFont || resolvedStyles.titleFont || "system-ui, sans-serif";
        titleSizeInput.value = scopedStyles.titleSize || resolvedStyles.titleSize || 18;
        subColorInput.value = scopedStyles.subColor || resolvedStyles.subColor || PAGE_STATE.textSoft || "#94a3b8";
       subFontSelect.value = scopedStyles.subFont || resolvedStyles.subFont || "system-ui, sans-serif";
       subSizeInput.value = scopedStyles.subSize || resolvedStyles.subSize || 13;
       shapeSelect.value = data.shape || "circle";
       scopeSelect.value = currentStyleScope || "all";
       document.getElementById("title-offset-y").value = scopedStyles.titleOffsetY || resolvedStyles.titleOffsetY || 0;
       document.getElementById("title-offset-x").value = scopedStyles.titleOffsetX || resolvedStyles.titleOffsetX || 0;
       document.getElementById("sub-offset-y").value = scopedStyles.subOffsetY || resolvedStyles.subOffsetY || 0;
       document.getElementById("sub-offset-x").value = scopedStyles.subOffsetX || resolvedStyles.subOffsetX || 0;
       const tagEl = document.getElementById("node-tags");
       tagEl.innerHTML = "";
       data.tags.forEach((tag, i) => {
        const b = document.createElement("span");
        b.className = "badge";
        if (tag.toLowerCase().includes("wg")) b.classList.add("wg");
        b.style.cursor = "pointer";
        b.style.position = "relative";
        const tagText = document.createElement("span");
        tagText.textContent = tag;
        tagText.addEventListener("click", (e) => {
         e.stopPropagation();
         showEditModal("Edit Tag", tag, (newTag) => {
          if (newTag) {
           pushUndo("edit tag");
           data.tags[i] = newTag;
           claimTheImmortal(id);
          }
         });
        });
        const deleteTag = document.createElement("span");
        deleteTag.textContent = " ✕";
        deleteTag.style.opacity = "0.6";
        deleteTag.style.marginLeft = "4px";
        deleteTag.style.fontSize = "10px";
        deleteTag.addEventListener("click", (e) => {
         e.stopPropagation();
         pushUndo("delete tag");
         data.tags.splice(i, 1);
         claimTheImmortal(id);
        });
        b.append(tagText, deleteTag);
        tagEl.append(b);
       });
       const addTagBtn = document.createElement("span");
       addTagBtn.className = "badge";
       addTagBtn.style.cursor = "pointer";
       addTagBtn.style.opacity = "0.6";
       addTagBtn.style.borderStyle = "dashed";
       addTagBtn.textContent = "+ Add Tag";
       addTagBtn.addEventListener("click", () => {
        showEditModal("Add Tag(s) : comma separated", "",
         (newTagStr) => {
          if (newTagStr) {
           pushUndo("add tags");
           const newTags = newTagStr.split(",").map((t) => t.trim()).filter((t) => t);
           newTags.forEach((t) => data.tags.push(t));
           claimTheImmortal(id);
          }
         }, );
       });
       tagEl.append(addTagBtn);
       const notesEl = document.getElementById("node-notes");
       notesEl.innerHTML = "";
       data.notes.forEach((note, i) => {
        const li = document.createElement("li");
        const noteText = document.createElement("span");
        noteText.textContent = note;
        noteText.style.flex = "1";
        const deleteBtn = document.createElement("span");
        deleteBtn.className = "delete-note";
        deleteBtn.textContent = "✕";
        deleteBtn.addEventListener("click", (e) => {
         e.stopPropagation();
         challengeTheImmortal("Are you sure you want to delete this note?",
          () => {
           pushUndo("delete note");
           data.notes.splice(i, 1);
           claimTheImmortal(id);
          }, );
        });
        li.append(noteText, deleteBtn);
        noteText.addEventListener("dblclick", () => {
         noteText.classList.add("editing");
         noteText.contentEditable = true;
         noteText.focus();
        });
        noteText.addEventListener("blur", () => {
         noteText.classList.remove("editing");
         noteText.contentEditable = false;
         data.notes[i] = noteText.textContent;
        });
        notesEl.append(li);
       });
      const addLineSelect = document.getElementById("add-line-select");
      addLineSelect.innerHTML = "";
      const currentRack = data.assignedRack || "";
      Object.entries(NODE_DATA).forEach(([nodeId, node]) => {
      if (nodeId !== id) {
      const nodeRack = node.assignedRack || "";
      if (currentRack === nodeRack) {
      const opt = document.createElement("option");
      opt.value = nodeId;
      opt.textContent = node.name;
      addLineSelect.appendChild(opt);
      }
      }
      });
      }
      function selectTheConnection(id) {
	   if (isViewOnly()) return;
       currentEdgeId = id;
       currentNodeId = null;
       currentRectId = null;
       currentTextId = null;
       if (isMobileDevice()) {
        const currentHeight = PAGE_STATE.mobileFooterHeight || 40;
        if (currentHeight <= 20) {
         PAGE_STATE.mobileFooterHeight = 80;
         const root = document.documentElement;
         root.style.setProperty("--mobile-footer-height", "80vh");
         const mobileFooterHeightInput = document.getElementById("mobile-footer-height");
         const mobileFooterHeightVal = document.getElementById("mobile-footer-height-val");
         if (mobileFooterHeightInput) mobileFooterHeightInput.value = 80;
         if (mobileFooterHeightVal) mobileFooterHeightVal.textContent = "80%";
        }
       }
       document.getElementById("node-panel").style.display = "none";
       document.getElementById("edge-panel").style.display = "block";
       document.getElementById("text-panel").style.display = "none";
       document.getElementById("rect-panel").style.display = "none";
       document.getElementById("topology-toolbar").style.display = "none";
       document.querySelectorAll(".node-group").forEach((n) => n.classList.remove("active"));
       document.querySelectorAll(".rect-group").forEach((r) => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach((t) => t.classList.remove("active"));
       document.querySelectorAll(".edge").forEach((e) => {
        e.classList.toggle("active", e.dataset.edgeId === id);
       });
       const edge = EDGE_DATA.list.find((e) => e.id === id);
       if (!edge) return;
       const directionSymbols = {
        none: "⇄",
        forward: "→",
        backward: "←",
        both: "↔",
       };
       const dirSymbol = directionSymbols[edge.direction] || "⇄";
       let titleText = "Custom line";
       if (edge.from || edge.to) {
        const fromName = edge.from ? NODE_DATA[edge.from]?.name || edge.from : "";
        const toName = edge.to ? NODE_DATA[edge.to]?.name || edge.to : "";
        titleText = `${fromName || "?"} ${dirSymbol} ${toName || "?"}`;
       }
       document.getElementById("edge-title").textContent = titleText;
       const widthInput = document.getElementById("edge-width");
       const colorInput = document.getElementById("edge-color");
       const directionSelect = document.getElementById("edge-direction");
       const lineStyleSelect = document.getElementById("edge-line-style");
       widthInput.value = edge.width;
       colorInput.value = edge.color;
       directionSelect.value = edge.direction || "none";
       lineStyleSelect.value = edge.lineStyle || "solid";
       const fromPortRow = document.getElementById("edge-from-port-row");
       const toPortRow = document.getElementById("edge-to-port-row");
       const fromPortInput = document.getElementById("edge-from-port");
       const toPortInput = document.getElementById("edge-to-port");
       if (edge.type === "custom") {
        fromPortRow.style.display = "none";
        toPortRow.style.display = "none";
       } else {
        fromPortRow.style.display = "flex";
        toPortRow.style.display = "flex";
        fromPortInput.value = edge.fromPort || "";
        toPortInput.value = edge.toPort || "";
        fromPortInput.onchange = () => updateEdgePortLabels(id);
        toPortInput.onchange = () => updateEdgePortLabels(id);
       }
       const list = document.getElementById("edge-notes");
       list.innerHTML = "";
       edge.notes.forEach((note, i) => {
        const li = document.createElement("li");
        const txt = document.createElement("span");
        txt.textContent = note;
        txt.style.flex = "1";
        const del = document.createElement("span");
        del.className = "delete-note";
        del.textContent = "✕";
        del.addEventListener("click", (e) => {
         e.stopPropagation();
         challengeTheImmortal("Delete this line note?", () => {
          pushUndo("delete edge note");
          edge.notes.splice(i, 1);
          selectTheConnection(id);
         });
        });
        txt.addEventListener("dblclick", () => {
         txt.classList.add("editing");
         txt.contentEditable = true;
         txt.focus();
        });
        txt.addEventListener("blur", () => {
         txt.classList.remove("editing");
         txt.contentEditable = false;
         pushUndo("edit edge note");
         edge.notes[i] = txt.textContent;
        });
        li.append(txt, del);
        list.appendChild(li);
       });
       if (edge.type === "custom" && Array.isArray(edge.points)) {
        forgeTheTopology();
       }
      }
      window.addEventListener("resize", () => {
       forgeTheTopology();
       if (currentEdgeId) {
        selectTheConnection(currentEdgeId);
       } else if (currentNodeId && NODE_DATA[currentNodeId]) {
        claimTheImmortal(currentNodeId);
       } else {
        const availableNodes = Object.keys(NODE_DATA);
        if (availableNodes.length > 0) {
         claimTheImmortal(availableNodes[0]);
        }
       }
      });
      (function initZoomPan() {
       const viewport = document.getElementById("canvas-viewport");
       const svg = document.getElementById("map");
       const hint = document.getElementById("canvas-hint");
       setTimeout(() => {
        hint.classList.add("visible");
        setTimeout(() => hint.classList.remove("visible"), 4000);
       }, 1000);
       viewport.addEventListener("wheel",
        (e) => {
         e.preventDefault();
         const rect = viewport.getBoundingClientRect();
         const mouseX = (e.clientX - rect.left) / rect.width;
         const mouseY = (e.clientY - rect.top) / rect.height;
         const delta = e.deltaY > 0 ? 0.9 : 1.1;
         zoomTo(canvasState.zoom * delta, mouseX, mouseY);
        }, {
         passive: false
        }, );
       let initialPinchDistance = 0;
       let initialPinchZoom = 1;
       let pinchCenter = {
        x: 0.5,
        y: 0.5
       };
       viewport.addEventListener("touchstart",
        (e) => {
         if (e.touches.length === 2) {
          e.preventDefault();
          const touch1 = e.touches[0];
          const touch2 = e.touches[1];
          initialPinchDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY, );
          initialPinchZoom = canvasState.zoom;
          const rect = viewport.getBoundingClientRect();
          const centerX = (touch1.clientX + touch2.clientX) / 2;
          const centerY = (touch1.clientY + touch2.clientY) / 2;
          pinchCenter.x = (centerX - rect.left) / rect.width;
          pinchCenter.y = (centerY - rect.top) / rect.height;
         }
        }, {
         passive: false
        }, );
       viewport.addEventListener("touchmove",
        (e) => {
         if (e.touches.length === 2) {
          e.preventDefault();
          const touch1 = e.touches[0];
          const touch2 = e.touches[1];
          const currentDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY, );
          if (initialPinchDistance > 0) {
           const scale = currentDistance / initialPinchDistance;
           const newZoom = initialPinchZoom * scale;
           zoomTo(newZoom, pinchCenter.x, pinchCenter.y);
          }
         }
        }, {
         passive: false
        }, );
       let panStartViewX = 0;
       let panStartViewY = 0;
       let lastEmptyTapTime = 0;
       let emptyTapTimeout = null;
       let emptyTapMoved = false;
       let emptyTapStartX = 0;
       let emptyTapStartY = 0;
       viewport.addEventListener("touchend", (e) => {
         if (currentView.mode !== "rack") return;
         if (e.changedTouches.length !== 1) return;
      const isNodeOrEdge = e.target.closest(".node-group") || e.target.closest(".edge-group");
         if (isNodeOrEdge) return;
         if (emptyTapMoved) {
           emptyTapMoved = false;
           return;
         }
         const currentTime = new Date().getTime();
         const tapGap = currentTime - lastEmptyTapTime;
         if (tapGap < 300 && tapGap > 0) {
           e.preventDefault();
           exitRack();
           if (navigator.vibrate) {
             navigator.vibrate(50);
           }
           lastEmptyTapTime = 0;
           if (emptyTapTimeout) {
             clearTimeout(emptyTapTimeout);
             emptyTapTimeout = null;
           }
         } else {
           lastEmptyTapTime = currentTime;
           if (emptyTapTimeout) clearTimeout(emptyTapTimeout);
           emptyTapTimeout = setTimeout(() => {
             lastEmptyTapTime = 0;
           }, 300);
         }
       }, { passive: false });
       viewport.addEventListener("mousedown", (e) => {
        if (e.target.closest(".draw-toolbar") || e.target.closest(".topology-toolbar") || e.target.closest(".legend-container")) {
         return;
        }
        if (freeDrawMode || rectDrawMode) {
         return;
        }
      const isEmptySpace = e.target === svg || e.target === viewport || e.target.tagName === "svg";
      const isEdgeElement = e.target.closest('.edge') || e.target.classList.contains('edge-edit-point');
      const isTextElement = e.target.closest('.text-group') || e.target.closest('.text-element');
      const isRectElement = e.target.closest('.rect-group');
      if (!isEdgeElement && !isTextElement && !isRectElement && currentEdgeId) {
      currentEdgeId = null;
      forgeTheTopology();
      }
      if (!isRectElement && currentRectId) {
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      }
	  if (isViewOnly()) {
         document.body.classList.remove("view-only-inspect");
         document.getElementById("node-panel").style.display = "none";
         document.getElementById("edge-panel").style.display = "none";
        }
        if (isEmptySpace && e.shiftKey && e.button === 0) {
         if (isViewOnly()) return;
         e.preventDefault();
         startSelection(e);
         return;
        }
        if (isEmptySpace || e.button === 2 || e.button === 1) {
         e.preventDefault();
         canvasState.isPanning = true;
         canvasState.panStartX = e.clientX;
         canvasState.panStartY = e.clientY;
         panStartViewX = canvasState.panX;
         panStartViewY = canvasState.panY;
         viewport.classList.add("panning");
        }
       });
       viewport.addEventListener("touchstart",
        (e) => {
         if (e.target.closest(".draw-toolbar") || e.target.closest(".topology-toolbar") || e.target.closest(".legend-container")) {
          return;
         }
         if (freeDrawMode || rectDrawMode) {
          return;
         }
      const isEmptySpace = e.target === svg || e.target === viewport || e.target.tagName === "svg";
      const isEdgeElement = e.target.closest('.edge') || e.target.classList.contains('edge-edit-point');
      const isTextElement = e.target.closest('.text-group') || e.target.closest('.text-element');
      const isRectElement = e.target.closest('.rect-group');
      if (!isEdgeElement && !isTextElement && !isRectElement && currentEdgeId) {
      currentEdgeId = null;
      forgeTheTopology();
      }
      if (!isRectElement && currentRectId) {
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      }
          if (isEmptySpace && e.touches.length === 1) {
           e.preventDefault();
           emptyTapMoved = false;
           emptyTapStartX = e.touches[0].clientX;
           emptyTapStartY = e.touches[0].clientY;
           canvasState.isPanning = true;
           canvasState.panStartX = e.touches[0].clientX;
           canvasState.panStartY = e.touches[0].clientY;
           panStartViewX = canvasState.panX;
           panStartViewY = canvasState.panY;
           viewport.classList.add("panning");
         }
        }, {
         passive: false
        }, );
       document.addEventListener("mousemove", (e) => {
        if (isSelecting) {
         updateSelection(e);
         return;
        }
        if (!canvasState.isPanning) return;
        const dx = e.clientX - canvasState.panStartX;
        const dy = e.clientY - canvasState.panStartY;
        const rect = viewport.getBoundingClientRect();
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        const canvasDx = (dx / rect.width) * viewWidth;
        const canvasDy = (dy / rect.height) * viewHeight;
        canvasState.panX = panStartViewX - canvasDx;
        canvasState.panY = panStartViewY - canvasDy;
        constrainPan();
        updateViewBox();
       });
       document.addEventListener("touchmove", (e) => {
        if (!canvasState.isPanning || !e.touches[0]) return;
        const moveDx = Math.abs(e.touches[0].clientX - emptyTapStartX);
        const moveDy = Math.abs(e.touches[0].clientY - emptyTapStartY);
        if (moveDx > 15 || moveDy > 15) {
         emptyTapMoved = true;
        }
        const dx = e.touches[0].clientX - canvasState.panStartX;
        const dy = e.touches[0].clientY - canvasState.panStartY;
        const rect = viewport.getBoundingClientRect();
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        const canvasDx = (dx / rect.width) * viewWidth;
        const canvasDy = (dy / rect.height) * viewHeight;
        canvasState.panX = panStartViewX - canvasDx;
        canvasState.panY = panStartViewY - canvasDy;
        constrainPan();
        updateViewBox();
       });
       document.addEventListener("mouseup", () => {
        if (isSelecting) {
         endSelection();
        }
        if (canvasState.isPanning) {
         canvasState.isPanning = false;
         viewport.classList.remove("panning");
        }
       });
       document.addEventListener("touchend", () => {
        if (canvasState.isPanning) {
         canvasState.isPanning = false;
         viewport.classList.remove("panning");
        }
       });
       document.addEventListener("keydown", (e) => {
        const isEditing = document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "TEXTAREA" || document.activeElement.isContentEditable;
        if (e.code === "Space" && !e.repeat && !isEditing) {
         e.preventDefault();
         canvasState.spacePressed = true;
         viewport.style.cursor = "grab";
        }
       });
       document.addEventListener("keyup", (e) => {
        if (e.code === "Space") {
         canvasState.spacePressed = false;
         viewport.style.cursor = "";
        }
       });
       document.getElementById("zoom-in-btn").addEventListener("click", () => {
        zoomTo(canvasState.zoom * 1.25, 0.5, 0.5);
       });
       document.getElementById("zoom-out-btn").addEventListener("click", () => {
        zoomTo(canvasState.zoom * 0.8, 0.5, 0.5);
       });
       document.getElementById("zoom-fit-btn").addEventListener("click", fitToContent);
       document.getElementById("zoom-reset-btn").addEventListener("click", resetView);
       const minimapContainer = document.getElementById("minimap-container");
       const minimapSvg = document.getElementById("minimap");
       let minimapDragging = false;
       minimapContainer.addEventListener("mousedown", (e) => {
        e.preventDefault();
        minimapDragging = true;
        updatePanFromMinimap(e);
       });
       minimapContainer.addEventListener("touchstart",
        (e) => {
         e.preventDefault();
         minimapDragging = true;
         updatePanFromMinimapTouch(e);
        }, {
         passive: false
        }, );
       document.addEventListener("mousemove", (e) => {
        if (minimapDragging) {
         updatePanFromMinimap(e);
        }
       });
       document.addEventListener("touchmove", (e) => {
        if (minimapDragging && e.touches[0]) {
         updatePanFromMinimapTouch(e);
        }
       });
       document.addEventListener("mouseup", () => {
        minimapDragging = false;
       });
       document.addEventListener("touchend", () => {
        minimapDragging = false;
       });
       function updatePanFromMinimap(e) {
        const rect = minimapContainer.getBoundingClientRect();
        const x = (e.clientX - rect.left) / rect.width;
        const y = (e.clientY - rect.top) / rect.height;
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        canvasState.panX = x * CANVAS_WIDTH - viewWidth / 2;
        canvasState.panY = y * CANVAS_HEIGHT - viewHeight / 2;
        constrainPan();
        updateViewBox();
       }
       function updatePanFromMinimapTouch(e) {
        const rect = minimapContainer.getBoundingClientRect();
        const touch = e.touches[0];
        const x = (touch.clientX - rect.left) / rect.width;
        const y = (touch.clientY - rect.top) / rect.height;
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        canvasState.panX = x * CANVAS_WIDTH - viewWidth / 2;
        canvasState.panY = y * CANVAS_HEIGHT - viewHeight / 2;
        constrainPan();
        updateViewBox();
       }
       document.addEventListener("keydown", (e) => {
        if (document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "TEXTAREA") return;
        if (
         (e.key === "+" || e.key === "=") && (e.ctrlKey || e.metaKey)) {
         e.preventDefault();
         zoomTo(canvasState.zoom * 1.25, 0.5, 0.5);
        } else if (e.key === "-" && (e.ctrlKey || e.metaKey)) {
         e.preventDefault();
         zoomTo(canvasState.zoom * 0.8, 0.5, 0.5);
        } else if (e.key === "0" && (e.ctrlKey || e.metaKey)) {
         e.preventDefault();
         resetView();
        }
       });
       setTimeout(() => {
        fitToContent();
       }, 100);
      })();
      const sizeSlider = document.getElementById("size-slider");
      const sizeValue = document.getElementById("size-value");
      const resetSizeBtn = document.getElementById("reset-size");
      sizeSlider.addEventListener("input", () => {
       const newSize = parseInt(sizeSlider.value, 10);
       sizeValue.textContent = newSize;
       pushUndo("resize node");
       savedSizes[currentNodeId] = newSize;
       const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
       if (nodeGroup) {
        const oldShape = nodeGroup.querySelector(".node-circle");
        if (oldShape) oldShape.remove();
        const shapeType = (NODE_DATA[currentNodeId] && NODE_DATA[currentNodeId].shape) || "circle";
        const newShape = createShapeElement(shapeType, newSize);
        newShape.classList.add("node-circle");
        const styles = resolveStylesForNode(currentNodeId);
        if (styles.circleColor) newShape.style.fill = styles.circleColor;
        if (styles.circleBorder) newShape.style.stroke = styles.circleBorder;
        nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
        const label = nodeGroup.querySelector(".node-label");
        const sub = nodeGroup.querySelector(".node-sub");
        if (label) {
         label.setAttribute("y", -newSize * 0.28);
         const labelSize = styles.titleSize || newSize * 0.33;
         label.style.fontSize = labelSize + "px";
        }
        if (sub) {
         sub.setAttribute("y", newSize * 0.4);
         const subSize = styles.subSize || newSize * 0.24;
         sub.style.fontSize = subSize + "px";
        }
       }
      });
      resetSizeBtn.addEventListener("click", () => {
       pushUndo("reset size");
       delete savedSizes[currentNodeId];
       const defaultSize = getDefaultSize();
       sizeSlider.value = defaultSize;
       sizeValue.textContent = defaultSize;
       const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
       if (nodeGroup) {
        const oldShape = nodeGroup.querySelector(".node-circle");
        if (oldShape) oldShape.remove();
        const shapeType = (NODE_DATA[currentNodeId] && NODE_DATA[currentNodeId].shape) || "circle";
        const newShape = createNodeShape(currentNodeId, defaultSize);
        nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
        const styles = resolveStylesForNode(currentNodeId);
        if (styles.circleColor) newShape.style.fill = styles.circleColor;
        if (styles.circleBorder) newShape.style.stroke = styles.circleBorder;
        const label = nodeGroup.querySelector(".node-label");
        const sub = nodeGroup.querySelector(".node-sub");
        if (label) {
         label.setAttribute("y", -defaultSize * 0.28);
         const labelSize = styles.titleSize || defaultSize * 0.33;
         label.style.fontSize = labelSize + "px";
        }
        if (sub) {
         sub.setAttribute("y", defaultSize * 0.4);
         const subSize = styles.subSize || defaultSize * 0.24;
         sub.style.fontSize = subSize + "px";
        }
       }
      });
      const applyStyle = (property, value) => {
       pushUndo("style change");
       const styleEntry = ensureStyleEntry(currentNodeId);
       const scopeKey = currentStyleScope || "all";
       if (!styleEntry[scopeKey]) styleEntry[scopeKey] = {};
       styleEntry[scopeKey][property] = value;
       const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
       if (!nodeGroup) return;
       const shapeEl = nodeGroup.querySelector(".node-circle");
       const label = nodeGroup.querySelector(".node-label");
       const sub = nodeGroup.querySelector(".node-sub");
       if (property === "circleColor" && shapeEl) shapeEl.style.fill = value;
      else if (property === "circleBorder" && shapeEl) shapeEl.style.stroke = value;
       else if (property === "titleColor" && label) label.style.fill = value;
       else if (property === "titleFont" && label) label.style.fontFamily = value;
       else if (property === "titleSize" && label) label.style.fontSize = value + "px";
       else if (property === "subColor" && sub) sub.style.fill = value;
       else if (property === "subFont" && sub) sub.style.fontFamily = value;
       else if (property === "subSize" && sub) sub.style.fontSize = value + "px";
      };
      document.getElementById("circle-color").addEventListener("input", (e) => applyStyle("circleColor", e.target.value), );
      document.getElementById("circle-border").addEventListener("input", (e) => applyStyle("circleBorder", e.target.value), );
      document.getElementById("title-color").addEventListener("input", (e) => applyStyle("titleColor", e.target.value), );
      document.getElementById("title-font").addEventListener("change", (e) => applyStyle("titleFont", e.target.value), );
      document.getElementById("title-size").addEventListener("input", (e) => applyStyle("titleSize", parseInt(e.target.value, 10)), );
      document.getElementById("sub-color").addEventListener("input", (e) => applyStyle("subColor", e.target.value), );
      document.getElementById("sub-font").addEventListener("change", (e) => applyStyle("subFont", e.target.value), );
      document.getElementById("sub-size").addEventListener("input", (e) => applyStyle("subSize", parseInt(e.target.value, 10)), );
      document.getElementById("title-offset-y").addEventListener("input", (e) => {
       applyStyle("titleOffsetY", parseInt(e.target.value, 10) || 0);
       forgeTheTopology();
       if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      document.getElementById("title-offset-x").addEventListener("input", (e) => {
       applyStyle("titleOffsetX", parseInt(e.target.value, 10) || 0);
       forgeTheTopology();
       if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      document.getElementById("sub-offset-y").addEventListener("input", (e) => {
       applyStyle("subOffsetY", parseInt(e.target.value, 10) || 0);
       forgeTheTopology();
       if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      document.getElementById("sub-offset-x").addEventListener("input", (e) => {
       applyStyle("subOffsetX", parseInt(e.target.value, 10) || 0);
       forgeTheTopology();
       if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      document.getElementById("reset-styles").addEventListener("click", () => {
       delete savedStyles[currentNodeId];
       forgeTheTopology();
       claimTheImmortal(currentNodeId);
      });
      document.getElementById("style-scope").addEventListener("change", (e) => {
       currentStyleScope = e.target.value || "all";
       claimTheImmortal(currentNodeId);
      });
      document.getElementById("shape-select").addEventListener("change", (e) => {
       const shape = e.target.value || "circle";
       pushUndo("change shape");
       NODE_DATA[currentNodeId].shape = shape;
       const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
       if (!nodeGroup) return;
       const oldShape = nodeGroup.querySelector(".node-circle");
       if (oldShape) oldShape.remove();
       const size = savedSizes[currentNodeId] || getDefaultSize();
       const newShape = createNodeShape(currentNodeId, size);
       nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
      });
      const addNoteBtn = document.getElementById("add-note-btn");
      const noteInput = document.getElementById("new-note-input");
      addNoteBtn.addEventListener("click", () => {
       const newNote = noteInput.value.trim();
       if (newNote && currentNodeId) {
	    pushUndo("add note");
        NODE_DATA[currentNodeId].notes.push(newNote);
        claimTheImmortal(currentNodeId);
        noteInput.value = "";
       }
      });
      noteInput.addEventListener("keypress", (e) => {
       if (e.key === "Enter") {
        addNoteBtn.click();
       }
      });
      document.getElementById("edge-width").addEventListener("input", () => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       const v = parseInt(document.getElementById("edge-width").value, 10);
       if (Number.isNaN(v) || v <= 0) return;
       pushUndo("edit edge");
       edge.width = v;
       const el = document.querySelector(`.edge[data-edge-id="${currentEdgeId}"]`, );
       if (el) el.style.strokeWidth = v;
      });
      document.getElementById("edge-color").addEventListener("input", () => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       const color = document.getElementById("edge-color").value;
       pushUndo("edit edge");
       edge.color = color;
       const el = document.querySelector(`.edge[data-edge-id="${currentEdgeId}"]`, );
       if (el) el.style.stroke = color;
       forgeTheLegend();
      });
      document.getElementById("edge-direction").addEventListener("change", () => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       pushUndo("edit edge");
       edge.direction = document.getElementById("edge-direction").value;
       forgeTheTopology();
       selectTheConnection(currentEdgeId);
      });
      document.getElementById("edge-line-style").addEventListener("change", () => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       pushUndo("edit edge");
       edge.lineStyle = document.getElementById("edge-line-style").value;
       forgeTheTopology();
       selectTheConnection(currentEdgeId);
      });
      const addEdgeNoteBtn = document.getElementById("add-edge-note");
      const newEdgeNoteInput = document.getElementById("new-edge-note");
      addEdgeNoteBtn.addEventListener("click", () => {
       const txt = newEdgeNoteInput.value.trim();
       if (!txt || !currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
	   pushUndo("add edge note");
       edge.notes.push(txt);
       newEdgeNoteInput.value = "";
       selectTheConnection(currentEdgeId);
      });
      newEdgeNoteInput.addEventListener("keypress", (e) => {
       if (e.key === "Enter") {
        addEdgeNoteBtn.click();
       }
      });
      function selectTheRect(id) {
	  if (isViewOnly()) return;
      currentRectId = id;
      currentNodeId = null;
      currentEdgeId = null;
      currentTextId = null;
      document.getElementById("node-panel").style.display = "none";
      document.getElementById("edge-panel").style.display = "none";
      document.getElementById("text-panel").style.display = "none";
      document.getElementById("rect-panel").style.display = "block";
      document.getElementById("topology-toolbar").style.display = "none";
      document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active"));
      document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
      document.querySelectorAll(".text-element").forEach(t => t.classList.remove("active"));
      document.querySelectorAll(".rect-group").forEach(r => r.classList.toggle("active", r.dataset.rectId === id));
      const rect = RECT_DATA.list.find(r => r.id === id);
      if (!rect) return;
      document.getElementById("rect-title").textContent = "";
      document.getElementById("rect-color").value = rect.color || "#f97316";
      document.getElementById("rect-border-color").value = rect.borderColor || rect.color || "#f97316";
      document.getElementById("rect-border-width").value = rect.borderWidth !== undefined ? rect.borderWidth : 2;
      document.getElementById("rect-style-select").value = rect.style || "filled";
      document.getElementById("rect-line-style").value = rect.lineStyle || "solid";
      document.getElementById("rect-fill-row").style.display = (rect.style === "outlined") ? "none" : "flex";
      const list = document.getElementById("rect-notes");
      list.innerHTML = "";
      (rect.notes || []).forEach((note, i) => {
      const li = document.createElement("li");
      const txt = document.createElement("span");
      txt.textContent = note;
      txt.style.flex = "1";
      const del = document.createElement("span");
      del.className = "delete-note";
      del.textContent = "✕";
       del.addEventListener("click", (e) => {
      e.stopPropagation();
      challengeTheImmortal("Delete this note?", () => {
        pushUndo("delete zone note");
        rect.notes.splice(i, 1);
        selectTheRect(id);
      });
      });
      li.appendChild(txt);
      li.appendChild(del);
      list.appendChild(li);
      });
      forgeTheTopology();
      }
      document.getElementById("rect-color").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.color = document.getElementById("rect-color").value;
      forgeTheTopology();
      });
      document.getElementById("rect-border-color").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.borderColor = document.getElementById("rect-border-color").value;
      forgeTheTopology();
      });
      document.getElementById("rect-border-width").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.borderWidth = parseInt(document.getElementById("rect-border-width").value) || 2;
      forgeTheTopology();
      });
      document.getElementById("rect-style-select").addEventListener("change", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.style = document.getElementById("rect-style-select").value;
      forgeTheTopology();
      selectTheRect(currentRectId);
      });
      document.getElementById("rect-line-style").addEventListener("change", () => {
      if (!currentRectId) return;
      pushUndo("change zone line style");
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      rect.lineStyle = document.getElementById("rect-line-style").value;
      forgeTheTopology();
      });
      document.getElementById("add-rect-note").addEventListener("click", () => {
      const input = document.getElementById("new-rect-note");
      const txt = input.value.trim();
      if (!txt || !currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      if (!rect.notes) rect.notes = [];
	  pushUndo("add zone note");
      rect.notes.push(txt);
      input.value = "";
      selectTheRect(currentRectId);
      });
      document.getElementById("new-rect-note").addEventListener("keypress", (e) => {
      if (e.key === "Enter") {
      document.getElementById("add-rect-note").click();
      }
      });
      document.getElementById("delete-rect").addEventListener("click", () => {
      if (!currentRectId) return;
      challengeTheImmortal("Delete this zone?", () => {
      pushUndo("delete zone");
      RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== currentRectId);
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      });
      });
      document.getElementById("delete-edge").addEventListener("click", () => {
       if (!currentEdgeId) return;
       challengeTheImmortal("Are you sure you want to delete this line?",
        () => {
         pushUndo("delete edge");
         EDGE_DATA.list = EDGE_DATA.list.filter(
          (e) => e.id !== currentEdgeId, );
         currentEdgeId = null;
         forgeTheTopology();
         const availableNodes = Object.keys(NODE_DATA);
         if (availableNodes.length > 0) {
          claimTheImmortal(availableNodes[0]);
         } else {
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("topology-toolbar", ).style.display = "none";
         }
        }, );
      });
      document.getElementById("add-line-btn").addEventListener("click", () => {
       if (!currentNodeId) return;
       const select = document.getElementById("add-line-select");
       const directionSelect = document.getElementById("add-line-direction");
       const colorInput = document.getElementById("add-line-color");
       const targetId = select.value;
       if (!targetId || targetId === currentNodeId) return;
       const direction = directionSelect.value || "none";
       const lineColor = colorInput.value || "#475569";
       const newId = `${currentNodeId}-${targetId}-${Date.now()}`;
       const newEdge = {
        id: newId,
        from: currentNodeId,
        to: targetId,
        width: 4,
        color: lineColor,
        direction: direction,
        type: "main",
        notes: [],
        fromPort: "",
        toPort: "",
        lineStyle: "solid",
       };
	   pushUndo("add edge");
       EDGE_DATA.list.push(newEdge);
       forgeTheTopology();
       claimTheImmortal(currentNodeId);
      });
      let freeDrawPoints = [];
      let freeDrawPolylineEl = null;
      let freeDrawPointEls = [];
       let rectStartPoint = null;
       let rectPreviewEl = null;
       let rectStyle = "filled";
      const drawToggleBtn = document.getElementById("draw-toggle");
      const drawUndoBtn = document.getElementById("draw-undo");
      const drawColorInput = document.getElementById("draw-color");
      const drawStyleSelect = document.getElementById("draw-style");
      const drawArrowSelect = document.getElementById("draw-arrow");
      const svgMap = document.getElementById("map");
      function updateFreeDrawGraphics() {
       const ns = "http://www.w3.org/2000/svg";
       const svg = svgMap;
       if (!freeDrawPolylineEl && freeDrawPoints.length > 0) {
        freeDrawPolylineEl = document.createElementNS(ns, "polyline");
        freeDrawPolylineEl.classList.add("edge", "free-preview");
        freeDrawPolylineEl.setAttribute("fill", "none");
        svg.appendChild(freeDrawPolylineEl);
       }
       if (freeDrawPolylineEl) {
        if (freeDrawPoints.length === 0) {
         freeDrawPolylineEl.remove();
         freeDrawPolylineEl = null;
        } else {
         const ptsStr = freeDrawPoints.map((p) => `${p.x},${p.y}`).join(" ");
         freeDrawPolylineEl.setAttribute("points", ptsStr);
         freeDrawPolylineEl.style.stroke = drawColorInput.value || "#475569";
         freeDrawPolylineEl.style.strokeWidth = 3;
         const lineStyle = drawStyleSelect.value || "solid";
         if (lineStyle === "dashed") {
          freeDrawPolylineEl.style.strokeDasharray = "10,5";
         } else if (lineStyle === "dotted") {
          freeDrawPolylineEl.style.strokeDasharray = "2,4";
         } else {
          freeDrawPolylineEl.style.strokeDasharray = "none";
         }
        }
       }
       freeDrawPointEls.forEach((el) => el.remove());
       freeDrawPointEls = [];
       freeDrawPoints.forEach((p, idx) => {
        const c = document.createElementNS(ns, "circle");
        c.classList.add("free-point");
        c.setAttribute("cx", p.x);
        c.setAttribute("cy", p.y);
        c.setAttribute("r", 5);
        c.dataset.index = String(idx);
        c.addEventListener("mousedown", (e) => {
         if (!freeDrawMode) return;
         e.preventDefault();
         e.stopPropagation();
         let dragging = true;
         const svgEl = svgMap;
         const moveHandler = (ev) => {
          if (!dragging) return;
          const pt = svgEl.createSVGPoint();
          pt.x = ev.clientX;
          pt.y = ev.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          const i = parseInt(c.dataset.index, 10);
          if (Number.isNaN(i) || !freeDrawPoints[i]) return;
          freeDrawPoints[i].x = svgP.x;
          freeDrawPoints[i].y = svgP.y;
          updateFreeDrawGraphics();
         };
         const upHandler = () => {
          dragging = false;
          document.removeEventListener("mousemove", moveHandler);
          document.removeEventListener("mouseup", upHandler);
         };
         document.addEventListener("mousemove", moveHandler);
         document.addEventListener("mouseup", upHandler);
        });
        c.addEventListener("touchstart",
         (e) => {
          if (!freeDrawMode) return;
          e.preventDefault();
          e.stopPropagation();
          let dragging = true;
          const svgEl = svgMap;
          const touchMoveHandler = (ev) => {
           if (!dragging || !ev.touches[0]) return;
           const pt = svgEl.createSVGPoint();
           pt.x = ev.touches[0].clientX;
           pt.y = ev.touches[0].clientY;
           const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
           const i = parseInt(c.dataset.index, 10);
           if (Number.isNaN(i) || !freeDrawPoints[i]) return;
           freeDrawPoints[i].x = svgP.x;
           freeDrawPoints[i].y = svgP.y;
           updateFreeDrawGraphics();
          };
          const touchUpHandler = () => {
           dragging = false;
           document.removeEventListener("touchmove", touchMoveHandler, );
           document.removeEventListener("touchend", touchUpHandler, );
          };
          document.addEventListener("touchmove", touchMoveHandler);
          document.addEventListener("touchend", touchUpHandler);
         }, {
          passive: false
         }, );
        svg.appendChild(c);
        freeDrawPointEls.push(c);
       });
       drawUndoBtn.style.display = freeDrawPoints.length ? "inline-block" : "none";
      }
      function addFreeDrawPoint(x, y) {
       freeDrawPoints.push({
        x,
        y
       });
       updateFreeDrawGraphics();
      }
      function startFreeDraw() {
       freeDrawMode = true;
       freeDrawPoints = [];
       if (freeDrawPolylineEl) {
        freeDrawPolylineEl.remove();
        freeDrawPolylineEl = null;
       }
       freeDrawPointEls.forEach((el) => el.remove());
       freeDrawPointEls = [];
       svgMap.style.cursor = "crosshair";
       drawToggleBtn.textContent = "Done";
       drawUndoBtn.style.display = "none";
      }
      function finishFreeDraw() {
       freeDrawMode = false;
       svgMap.style.cursor = "";
       drawToggleBtn.textContent = "✏️";
       if (freeDrawPoints.length >= 2) {
        const color = drawColorInput.value || "#475569";
        const lineStyle = drawStyleSelect.value || "solid";
        const arrowDir = drawArrowSelect.value || "none";
        const newId = "custom-" + Date.now();
        const pointsCopy = freeDrawPoints.map((p) => ({
         x: p.x,
         y: p.y,
        }));
        EDGE_DATA.list.push({
         id: newId,
         type: "custom",
         color,
         width: 4,
         lineStyle: lineStyle,
         direction: arrowDir,
         points: pointsCopy,
         notes: [],
        });
        freeDrawPoints = [];
        if (freeDrawPolylineEl) {
         freeDrawPolylineEl.remove();
         freeDrawPolylineEl = null;
        }
        freeDrawPointEls.forEach((el) => el.remove());
        freeDrawPointEls = [];
        forgeTheTopology();
        selectTheConnection(newId);
       } else {
        freeDrawPoints = [];
        if (freeDrawPolylineEl) {
         freeDrawPolylineEl.remove();
         freeDrawPolylineEl = null;
        }
        freeDrawPointEls.forEach((el) => el.remove());
        freeDrawPointEls = [];
        forgeTheLegend();
       }
       drawUndoBtn.style.display = "none";
      }
      drawToggleBtn.addEventListener("click", () => {
       if (currentView.mode === "rack") {
        alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
        return;
       }
       if (freeDrawMode) {
        finishFreeDraw();
       } else {
        startFreeDraw();
       }
      });
      drawUndoBtn.addEventListener("click", () => {
       if (!freeDrawMode || !freeDrawPoints.length) return;
       freeDrawPoints.pop();
       updateFreeDrawGraphics();
      });
      const drawToolbar = document.getElementById("draw-toolbar");
      drawToolbar.addEventListener("mousedown", (e) => {
       e.stopPropagation();
      });
      drawToolbar.addEventListener("click", (e) => {
       if (e.target !== drawToggleBtn && e.target !== drawUndoBtn) {
        e.stopPropagation();
       }
      });
      drawStyleSelect.addEventListener("change", () => {
       if (freeDrawMode) {
        updateFreeDrawGraphics();
       }
      });
      drawArrowSelect.addEventListener("change", () => {
       if (freeDrawMode) {
        updateFreeDrawGraphics();
       }
      });
      drawColorInput.addEventListener("input", () => {
       if (freeDrawMode) {
        updateFreeDrawGraphics();
       }
      });
      drawStyleSelect.addEventListener("mousedown", (e) => {
       e.stopPropagation();
      });
      drawStyleSelect.addEventListener("click", (e) => {
       e.stopPropagation();
      });
      drawArrowSelect.addEventListener("mousedown", (e) => {
       e.stopPropagation();
      });
      drawArrowSelect.addEventListener("click", (e) => {
       e.stopPropagation();
      });
      drawColorInput.addEventListener("mousedown", (e) => {
       e.stopPropagation();
      });
      drawColorInput.addEventListener("click", (e) => {
       e.stopPropagation();
      });
      svgMap.addEventListener("click", (e) => {
       if (!freeDrawMode) return;
       if (e.button !== 0) return;
       const target = e.target;
       if (target && target.classList && target.classList.contains("free-point")) return;
       const svgEl = svgMap;
       const pt = svgEl.createSVGPoint();
       pt.x = e.clientX;
       pt.y = e.clientY;
       const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
       addFreeDrawPoint(svgP.x, svgP.y);
      });
      svgMap.addEventListener("touchend",
       (e) => {
        if (!freeDrawMode) return;
        const target = e.target;
        if (target && target.classList && target.classList.contains("free-point")) return;
        if (e.changedTouches && e.changedTouches[0]) {
         e.preventDefault();
         const svgEl = svgMap;
         const pt = svgEl.createSVGPoint();
         pt.x = e.changedTouches[0].clientX;
         pt.y = e.changedTouches[0].clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
         addFreeDrawPoint(svgP.x, svgP.y);
        }
       }, {
        passive: false
       }, );
       const rectToggleBtn = document.getElementById("rect-toggle");
       const rectStyleSelect = document.getElementById("rect-style");
       function startRectDraw() {
        rectDrawMode = true;
        rectStartPoint = null;
        rectPreviewEl = null;
        svgMap.style.cursor = "crosshair";
        rectToggleBtn.textContent = "Done";
        rectStyle = rectStyleSelect.value || "filled";
        if (freeDrawMode) {
         finishFreeDraw();
        }
        updateRectangleDeleteButtons();
       }
       function finishRectDraw() {
        rectDrawMode = false;
        svgMap.style.cursor = "";
        rectToggleBtn.textContent = "▭";
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
        updateRectangleDeleteButtons();
       }
       rectToggleBtn.addEventListener("click", () => {
        if (currentView.mode === "rack") {
         alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
         return;
        }
        if (rectDrawMode) {
         finishRectDraw();
        } else {
         startRectDraw();
        }
       });
       rectStyleSelect.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       rectStyleSelect.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       rectStyleSelect.addEventListener("change", () => {
        if (rectDrawMode) {
         rectStyle = rectStyleSelect.value || "filled";
        }
       });
       svgMap.addEventListener("mousedown", (e) => {
        if (!rectDrawMode) return;
        if (e.button !== 0) return;
        e.preventDefault();
        e.stopPropagation();
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        rectStartPoint = { x: svgP.x, y: svgP.y };
        const ns = "http://www.w3.org/2000/svg";
        rectPreviewEl = document.createElementNS(ns, "rect");
        rectPreviewEl.classList.add("rect-preview");
        rectPreviewEl.setAttribute("x", svgP.x);
        rectPreviewEl.setAttribute("y", svgP.y);
        rectPreviewEl.setAttribute("width", 0);
        rectPreviewEl.setAttribute("height", 0);
        const color = drawColorInput.value || "#f97316";
        rectPreviewEl.style.stroke = color;
        rectPreviewEl.style.strokeWidth = 2;
        rectPreviewEl.style.strokeDasharray = "5,5";
        if (rectStyle === "filled") {
         rectPreviewEl.style.fill = color;
         rectPreviewEl.style.fillOpacity = "0.3";
        } else {
         rectPreviewEl.style.fill = "none";
        }
        svgEl.appendChild(rectPreviewEl);
       });
       svgMap.addEventListener("mousemove", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        rectPreviewEl.setAttribute("x", x);
        rectPreviewEl.setAttribute("y", y);
        rectPreviewEl.setAttribute("width", width);
        rectPreviewEl.setAttribute("height", height);
       });
       svgMap.addEventListener("mouseup", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        if (width > 10 && height > 10) {
      pushUndo("draw zone");
         const color = drawColorInput.value || "#f97316";
         const newId = "rect-" + Date.now();
          const lineStyle = document.getElementById("draw-style").value || "solid";
         RECT_DATA.list.push({
          id: newId,
          x: x,
          y: y,
          width: width,
          height: height,
          color: color,
          style: rectStyle,
          lineStyle: lineStyle,
          notes: []
         });
         forgeTheTopology();
        }
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
       });
       let rectTouchStart = null;
       svgMap.addEventListener("touchstart", (e) => {
        if (!rectDrawMode) return;
        if (e.touches.length !== 1) return;
        e.preventDefault();
        const touch = e.touches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        rectStartPoint = { x: svgP.x, y: svgP.y };
        rectTouchStart = { x: svgP.x, y: svgP.y };
        const ns = "http://www.w3.org/2000/svg";
        rectPreviewEl = document.createElementNS(ns, "rect");
        rectPreviewEl.classList.add("rect-preview");
        rectPreviewEl.setAttribute("x", svgP.x);
        rectPreviewEl.setAttribute("y", svgP.y);
        rectPreviewEl.setAttribute("width", 0);
        rectPreviewEl.setAttribute("height", 0);
        const color = drawColorInput.value || "#f97316";
        rectPreviewEl.style.stroke = color;
        rectPreviewEl.style.strokeWidth = 2;
        rectPreviewEl.style.strokeDasharray = "5,5";
        if (rectStyle === "filled") {
         rectPreviewEl.style.fill = color;
         rectPreviewEl.style.fillOpacity = "0.3";
        } else {
         rectPreviewEl.style.fill = "none";
        }
        svgEl.appendChild(rectPreviewEl);
       }, { passive: false });
       svgMap.addEventListener("touchmove", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        if (e.touches.length !== 1) return;
        e.preventDefault();
        const touch = e.touches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        rectPreviewEl.setAttribute("x", x);
        rectPreviewEl.setAttribute("y", y);
        rectPreviewEl.setAttribute("width", width);
        rectPreviewEl.setAttribute("height", height);
       }, { passive: false });
       svgMap.addEventListener("touchend", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        if (!rectTouchStart) return;
        e.preventDefault();
        const touch = e.changedTouches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        if (width > 10 && height > 10) {
      pushUndo("draw zone");
         const color = drawColorInput.value || "#f97316";
         const newId = "rect-" + Date.now();
        const lineStyle = document.getElementById("draw-style").value || "solid";
         RECT_DATA.list.push({
          id: newId,
          x: x,
          y: y,
          width: width,
          height: height,
          color: color,
          style: rectStyle,
          lineStyle: lineStyle,
          notes: []
         });
         forgeTheTopology();
        }
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
        rectTouchStart = null;
       }, { passive: false });
      const textToggleBtn = document.getElementById("text-toggle");
      function startTextMode() {
       textDrawMode = true;
       svgMap.style.cursor = "crosshair";
       textToggleBtn.textContent = "Done";
       textToggleBtn.style.background = "var(--accent)";
       textToggleBtn.style.color = "var(--bg)";
       if (freeDrawMode) {
        finishFreeDraw();
       }
       if (rectDrawMode) {
        finishRectDraw();
       }
       updateTextDeleteButtons();
      }
      function finishTextMode() {
       textDrawMode = false;
       svgMap.style.cursor = "";
       textToggleBtn.textContent = "T";
       textToggleBtn.style.background = "";
       textToggleBtn.style.color = "";
       updateTextDeleteButtons();
      }
      textToggleBtn.addEventListener("click", () => {
       if (currentView.mode === "rack") {
        alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
        return;
       }
       if (textDrawMode) {
        finishTextMode();
       } else {
        startTextMode();
       }
      });
      function handleTextPlacement(e) {
       if (!textDrawMode) return;
       const svgEl = svgMap;
       const pt = svgEl.createSVGPoint();
       pt.x = e.clientX;
       pt.y = e.clientY;
       const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
       const newId = "text-" + Date.now();
      pushUndo("add text");
       TEXT_DATA.list.push({
        id: newId,
        x: svgP.x,
        y: svgP.y,
        content: "New Text",
        fontSize: 18,
        color: "#e2e8f0",
        fontWeight: "normal",
        fontStyle: "normal",
        textAlign: "start",
        textDecoration: "none",
        bgColor: "#000000",
        bgEnabled: false,
        opacity: 1
       });
       forgeTheTopology();
       showTextPanel(newId);
      }
      svgMap.addEventListener("click", (e) => {
       if (!textDrawMode) return;
       if (e.target.closest('.text-delete-btn')) return;
       if (e.target.closest('.text-group')) return;
       e.preventDefault();
       e.stopPropagation();
       handleTextPlacement(e);
      });
      svgMap.addEventListener("touchend", (e) => {
       if (!textDrawMode) return;
       if (e.target.closest('.text-delete-btn')) return;
       if (e.target.closest('.text-group')) return;
       if (e.touches.length > 0) return;
       e.preventDefault();
       const touch = e.changedTouches[0];
       const fakeEvent = {
        clientX: touch.clientX,
        clientY: touch.clientY,
        preventDefault: () => {},
        stopPropagation: () => {}
       };
       handleTextPlacement(fakeEvent);
      }, { passive: false });
      function showTextPanel(textId) {
	  if (isViewOnly()) return;
       currentTextId = textId;
       currentNodeId = null;
       currentEdgeId = null;
       currentRectId = null;
       const textItem = TEXT_DATA.list.find(t => t.id === textId);
       if (!textItem) return;
       document.getElementById("node-panel").style.display = "none";
       document.getElementById("edge-panel").style.display = "none";
       document.getElementById("rect-panel").style.display = "none";
       const textPanel = document.getElementById("text-panel");
       textPanel.style.display = "block";
       document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active"));
       document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
       document.querySelectorAll(".rect-group").forEach(r => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach(t => t.classList.toggle("active", t.dataset.textId === textId));
       document.getElementById("text-content").value = textItem.content;
       document.getElementById("text-font-size").value = textItem.fontSize;
       document.getElementById("text-color").value = textItem.color;
       document.getElementById("text-font-weight").value = textItem.fontWeight;
       document.getElementById("text-font-style").value = textItem.fontStyle;
       document.getElementById("text-align").value = textItem.textAlign;
       document.getElementById("text-decoration").value = textItem.textDecoration;
       document.getElementById("text-bg-color").value = textItem.bgColor;
       document.getElementById("text-bg-enabled").checked = textItem.bgEnabled;
       document.getElementById("text-opacity").value = textItem.opacity;
       document.getElementById("text-opacity-val").textContent = Math.round(textItem.opacity * 100) + "%";
      }
      function updateTextDeleteButtons() {
       const deleteButtons = document.querySelectorAll('.text-delete-btn');
       deleteButtons.forEach(btn => {
        btn.style.display = textDrawMode ? 'block' : 'none';
       });
      }
      function deleteText(textId) {
      pushUndo("delete text");
       TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== textId);
       forgeTheTopology();
       if (currentTextId === textId) {
        document.getElementById("text-panel").style.display = "none";
        currentTextId = null;
       }
      }
      document.getElementById("text-content").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
      pushUndo("edit text");
        textItem.content = e.target.value;
        forgeTheTopology();
       }
      });
      document.getElementById("text-font-size").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.fontSize = parseInt(e.target.value);
        forgeTheTopology();
       }
      });
      document.getElementById("text-color").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.color = e.target.value;
        forgeTheTopology();
       }
      });
      document.getElementById("text-font-weight").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.fontWeight = e.target.value;
        forgeTheTopology();
       }
      });
      document.getElementById("text-font-style").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.fontStyle = e.target.value;
        forgeTheTopology();
       }
      });
      document.getElementById("text-align").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.textAlign = e.target.value;
        forgeTheTopology();
       }
      });
      document.getElementById("text-decoration").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.textDecoration = e.target.value;
        forgeTheTopology();
       }
      });
      document.getElementById("text-bg-color").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.bgColor = e.target.value;
        forgeTheTopology();
       }
      });
      document.getElementById("text-bg-enabled").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.bgEnabled = e.target.checked;
        forgeTheTopology();
       }
      });
      document.getElementById("text-opacity").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.opacity = parseFloat(e.target.value);
        document.getElementById("text-opacity-val").textContent = Math.round(textItem.opacity * 100) + "%";
        forgeTheTopology();
       }
      });
      document.getElementById("delete-text").addEventListener("click", () => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        challengeTheImmortal(`Delete text "${textItem.content.substring(0, 30)}..."?`, () => {
         deleteText(currentTextId);
        });
       }
      });
      const settingsBtn = document.getElementById("settings-btn");
      const settingsModal = document.getElementById("settings-modal");
      const settingsClose = document.getElementById("settings-close");
      settingsBtn.addEventListener("click", () => {
       document.getElementById("page-bg-color").value = PAGE_STATE.background || "#050608";
       document.getElementById("topbar-bg-color").value = PAGE_STATE.topbarBg || "#0b0e13";
       document.getElementById("topbar-border-color").value = PAGE_STATE.topbarBorder || "#1f2533";
       document.getElementById("panel-color").value = PAGE_STATE.panel || "#0b0e13";
       document.getElementById("panel-alt-color").value = PAGE_STATE.panelAlt || "#10141b";
       document.getElementById("sidebar-bg-color").value = PAGE_STATE.sidebarBg || "#10141b";
       document.getElementById("btn-bg-color").value = PAGE_STATE.btnBg || "#0b0e13";
       document.getElementById("btn-text-color").value = PAGE_STATE.btnText || "#e2e8f0";
       document.getElementById("tag-fill-color").value = PAGE_STATE.tagFill || "#1e293b";
       document.getElementById("tag-text-color").value = PAGE_STATE.tagText || "#e2e8f0";
       document.getElementById("tag-border-color").value = PAGE_STATE.tagBorder || "#475569";
       document.getElementById("input-bg-color").value = PAGE_STATE.inputBg || "#0b0e13";
       document.getElementById("input-text-color").value = PAGE_STATE.inputText || "#e2e8f0";
       document.getElementById("input-border-color").value = PAGE_STATE.inputBorder || "#1f2937";
       document.getElementById("input-font-family").value = PAGE_STATE.inputFont || "Inter, system-ui, sans-serif";
       document.getElementById("input-font-size").value = PAGE_STATE.inputFontSize || 14;
       document.getElementById("toolbar-bg-color").value = PAGE_STATE.toolbarBg || "#0f172a";
       document.getElementById("toolbar-border-color").value = PAGE_STATE.toolbarBorder || "#1f2937";
       document.getElementById("toolbar-text-color").value = PAGE_STATE.toolbarText || "#94a3b8";
       document.getElementById("toolbar-btn-bg-color").value = PAGE_STATE.toolbarBtnBg || "#0b0e13";
       document.getElementById("toolbar-btn-text-color").value = PAGE_STATE.toolbarBtnText || "#e2e8f0";
       document.getElementById("minimap-dots-color").value = PAGE_STATE.minimapDots || "#94a3b8";
       document.getElementById("canvas-hint-enabled").checked = PAGE_STATE.canvasHintEnabled !== false;
       document.getElementById("canvas-hint-bg-color").value = PAGE_STATE.canvasHintBg || "#0f172a";
       document.getElementById("canvas-hint-text-color").value = PAGE_STATE.canvasHintColor || "#94a3b8";
       document.getElementById("canvas-hint-text").value = PAGE_STATE.canvasHintText || "";
       document.getElementById("accent-color").value = PAGE_STATE.accent || "#4fd1c5";
       document.getElementById("danger-color").value = PAGE_STATE.danger || "#f56565";
       document.getElementById("text-main-color").value = PAGE_STATE.textMain || "#e2e8f0";
       document.getElementById("text-soft-color").value = PAGE_STATE.textSoft || "#94a3b8";
       document.getElementById("node-fill-color").value = PAGE_STATE.nodeFill || "#1e293b";
       document.getElementById("node-stroke-color").value = PAGE_STATE.nodeStroke || "#475569";
       document.getElementById("node-title-color").value = PAGE_STATE.nodeTitle || "#e2e8f0";
       document.getElementById("node-sub-color").value = PAGE_STATE.nodeSub || "#94a3b8";
       document.getElementById("node-title-size").value = PAGE_STATE.nodeTitleSize || 18;
       document.getElementById("node-sub-size").value = PAGE_STATE.nodeSubSize || 13;
       document.getElementById("node-font-family").value = PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
       document.getElementById("default-edge-color").value = PAGE_STATE.defaultEdge || "#475569";
       document.getElementById("selection-handle-color").value = PAGE_STATE.selectionHandle || "#f59e0b";
       document.getElementById("selection-handle-size").value = PAGE_STATE.selectionHandleSize || 8;
       document.getElementById("group-indicator-color").value = PAGE_STATE.groupIndicator || "#4fd1c5";
       document.getElementById("canvas-gradient-top").value = PAGE_STATE.canvasGradientTop || "#1e2532";
       document.getElementById("canvas-gradient-bottom").value = PAGE_STATE.canvasGradientBottom || "#050608";
       document.getElementById("canvas-border-color").value = PAGE_STATE.canvasBorder || "#475569";
       document.getElementById("canvas-grid-color").value = PAGE_STATE.canvasGrid || "#475569";
       document.getElementById("canvas-grid-size").value = PAGE_STATE.canvasGridSize || 50;
       document.getElementById("rack-frame-fill").value = PAGE_STATE.rackFrameFill || "#0f172a";
       document.getElementById("rack-frame-stroke").value = PAGE_STATE.rackFrameStroke || "#4fd1c5";
       document.getElementById("rack-line-color").value = PAGE_STATE.rackLineColor || "#475569";
       document.getElementById("rack-text-color").value = PAGE_STATE.rackTextColor || "#4fd1c5";
	   document.getElementById("view-only-mode").checked = PAGE_STATE.viewOnly === true;
       settingsModal.classList.add("active");
      });
      settingsClose.addEventListener("click", () => {
       settingsModal.classList.remove("active");
      });
	  document.getElementById("view-only-mode").addEventListener("change", (e) => {
       PAGE_STATE.viewOnly = e.target.checked;
       if (e.target.checked) {
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        document.getElementById("rect-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.setProperty('display', 'none', 'important');
        document.getElementById("draw-toolbar").style.setProperty('display', 'none', 'important');
        currentNodeId = null;
        currentEdgeId = null;
        currentRectId = null;
        currentTextId = null;
        selectedNodes.clear();
        selectedRects.clear();
        selectedTexts.clear();
        selectedEdges.clear();
        const bulkToolbar = document.getElementById("bulk-toolbar");
        const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active", "selected"));
        document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
        document.querySelectorAll(".rect-group").forEach(r => r.classList.remove("active"));
        document.querySelectorAll(".text-element").forEach(t => t.classList.remove("active"));
       }
       wieldThePower();
       if (!e.target.checked) {
        updateDrawToolbarVisibility();
        updateTopologyToolbarVisibility();
       }
       forgeTheTopology();
      });
      settingsModal.addEventListener("click", (e) => {
       if (e.target === settingsModal) {
        settingsModal.classList.remove("active");
       }
      });
      document.getElementById("page-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.background = e.target.value;
       wieldThePower();
      });
      document.getElementById("topbar-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.topbarBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("topbar-border-color").addEventListener("input", (e) => {
       PAGE_STATE.topbarBorder = e.target.value;
       wieldThePower();
      });
      document.getElementById("panel-color").addEventListener("input", (e) => {
       PAGE_STATE.panel = e.target.value;
       wieldThePower();
      });
      document.getElementById("panel-alt-color").addEventListener("input", (e) => {
       PAGE_STATE.panelAlt = e.target.value;
       wieldThePower();
      });
      document.getElementById("sidebar-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.sidebarBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("btn-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.btnBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("btn-text-color").addEventListener("input", (e) => {
       PAGE_STATE.btnText = e.target.value;
       wieldThePower();
      });
      document.getElementById("tag-fill-color").addEventListener("input", (e) => {
       PAGE_STATE.tagFill = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("tag-text-color").addEventListener("input", (e) => {
       PAGE_STATE.tagText = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("tag-border-color").addEventListener("input", (e) => {
       PAGE_STATE.tagBorder = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
	  document.getElementById("selection-fill-color").addEventListener("input", function() {
       selectionBoxStyle.fillColor = this.value;
      });
      document.getElementById("selection-fill-opacity").addEventListener("input", function() {
       selectionBoxStyle.fillOpacity = parseFloat(this.value);
       document.getElementById("selection-fill-opacity-val").textContent = Math.round(this.value * 100) + "%";
      });
      document.getElementById("selection-stroke-color").addEventListener("input", function() {
       selectionBoxStyle.strokeColor = this.value;
      });
      document.getElementById("selection-stroke-width").addEventListener("input", function() {
       selectionBoxStyle.strokeWidth = parseInt(this.value) || 2;
      });
      document.getElementById("selection-stroke-style").addEventListener("change", function() {
       selectionBoxStyle.strokeDasharray = this.value;
      });
      document.getElementById("input-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.inputBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-text-color").addEventListener("input", (e) => {
       PAGE_STATE.inputText = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-border-color").addEventListener("input", (e) => {
       PAGE_STATE.inputBorder = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-font-family").addEventListener("change", (e) => {
       PAGE_STATE.inputFont = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-font-size").addEventListener("input", (e) => {
       PAGE_STATE.inputFontSize = parseInt(e.target.value) || 14;
       wieldThePower();
      });
      document.getElementById("toolbar-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-border-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBorder = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-text-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarText = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-btn-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBtnBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-btn-text-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBtnText = e.target.value;
       wieldThePower();
      });
      document.getElementById("minimap-dots-color").addEventListener("input", (e) => {
       PAGE_STATE.minimapDots = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("canvas-hint-enabled").addEventListener("change", (e) => {
       PAGE_STATE.canvasHintEnabled = e.target.checked;
       wieldThePower();
      });
      document.getElementById("canvas-hint-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-hint-text-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintColor = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-hint-text").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintText = e.target.value;
       wieldThePower();
      });
      document.getElementById("accent-color").addEventListener("input", (e) => {
       PAGE_STATE.accent = e.target.value;
       wieldThePower();
      });
      document.getElementById("danger-color").addEventListener("input", (e) => {
       PAGE_STATE.danger = e.target.value;
       wieldThePower();
      });
      document.getElementById("text-main-color").addEventListener("input", (e) => {
       PAGE_STATE.textMain = e.target.value;
       wieldThePower();
      });
      document.getElementById("text-soft-color").addEventListener("input", (e) => {
       PAGE_STATE.textSoft = e.target.value;
       wieldThePower();
      });
      document.getElementById("node-fill-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeFill = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-stroke-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeStroke = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-title-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeTitle = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-sub-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeSub = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-title-size").addEventListener("input", (e) => {
       PAGE_STATE.nodeTitleSize = parseInt(e.target.value) || 18;
       forgeTheTopology();
      });
      document.getElementById("node-sub-size").addEventListener("input", (e) => {
       PAGE_STATE.nodeSubSize = parseInt(e.target.value) || 13;
       forgeTheTopology();
      });
      document.getElementById("node-font-family").addEventListener("change", (e) => {
       PAGE_STATE.nodeFont = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("default-edge-color").addEventListener("input", (e) => {
       PAGE_STATE.defaultEdge = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("selection-handle-color").addEventListener("input", (e) => {
       PAGE_STATE.selectionHandle = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("selection-handle-size").addEventListener("input", (e) => {
       PAGE_STATE.selectionHandleSize = parseInt(e.target.value) || 8;
       forgeTheTopology();
      });
      document.getElementById("group-indicator-color").addEventListener("input", (e) => {
       PAGE_STATE.groupIndicator = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-gradient-top").addEventListener("input", (e) => {
       PAGE_STATE.canvasGradientTop = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-gradient-bottom").addEventListener("input", (e) => {
       PAGE_STATE.canvasGradientBottom = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-border-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasBorder = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-grid-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasGrid = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-grid-size").addEventListener("input", (e) => {
       PAGE_STATE.canvasGridSize = parseInt(e.target.value) || 50;
       forgeTheTopology();
      });
      document.getElementById("rack-frame-fill").addEventListener("input", (e) => {
       PAGE_STATE.rackFrameFill = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-frame-stroke").addEventListener("input", (e) => {
       PAGE_STATE.rackFrameStroke = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-line-color").addEventListener("input", (e) => {
       PAGE_STATE.rackLineColor = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-text-color").addEventListener("input", (e) => {
       PAGE_STATE.rackTextColor = e.target.value;
       forgeTheTopology();
      });
      (function initializeResizers() {
        const headerResizer = document.getElementById('header-resizer');
        const sidebarResizer = document.getElementById('sidebar-resizer');
        const mobileFooterResizer = document.getElementById('mobile-footer-resizer');
        let isResizing = false;
        let currentResizer = null;
        let startY = 0;
        let startX = 0;
        let startHeight = 0;
        let startWidth = 0;
        function getClientPos(e) {
          if (e.touches && e.touches.length > 0) {
            return { x: e.touches[0].clientX, y: e.touches[0].clientY };
          }
          return { x: e.clientX, y: e.clientY };
        }
        function startResize(resizer, type, e) {
          isResizing = true;
          currentResizer = type;
          const pos = getClientPos(e);
          if (type === 'header') {
            startY = pos.y;
            startHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--topbar-height'));
          } else if (type === 'sidebar') {
            startX = pos.x;
            startWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width'));
          } else if (type === 'mobile-footer') {
            startY = pos.y;
            const currentVh = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--mobile-footer-height'));
            startHeight = (currentVh / 100) * window.innerHeight;
          }
          resizer.classList.add('resizing');
          document.body.classList.add('resizing');
          document.body.style.cursor = (type === 'sidebar') ? 'col-resize' : 'row-resize';
          e.preventDefault();
        }
        if (headerResizer) {
          headerResizer.addEventListener('mousedown', (e) => startResize(headerResizer, 'header', e));
          headerResizer.addEventListener('touchstart', (e) => startResize(headerResizer, 'header', e), { passive: false });
        }
        if (sidebarResizer) {
          sidebarResizer.addEventListener('mousedown', (e) => startResize(sidebarResizer, 'sidebar', e));
          sidebarResizer.addEventListener('touchstart', (e) => startResize(sidebarResizer, 'sidebar', e), { passive: false });
        }
        if (mobileFooterResizer) {
          mobileFooterResizer.addEventListener('mousedown', (e) => startResize(mobileFooterResizer, 'mobile-footer', e));
          mobileFooterResizer.addEventListener('touchstart', (e) => startResize(mobileFooterResizer, 'mobile-footer', e), { passive: false });
        }
        function handleMove(e) {
          if (!isResizing) return;
          const pos = getClientPos(e);
          if (currentResizer === 'header') {
            const deltaY = pos.y - startY;
            const newHeight = Math.max(40, Math.min(150, startHeight + deltaY));
            document.documentElement.style.setProperty('--topbar-height', newHeight + 'px');
          } else if (currentResizer === 'sidebar') {
            const deltaX = startX - pos.x;
            const newWidth = Math.max(200, Math.min(800, startWidth + deltaX));
            document.documentElement.style.setProperty('--sidebar-width', newWidth + 'px');
          } else if (currentResizer === 'mobile-footer') {
            const deltaY = startY - pos.y;
            const newHeight = startHeight + deltaY;
            const newVh = Math.max(15, Math.min(80, (newHeight / window.innerHeight) * 100));
            document.documentElement.style.setProperty('--mobile-footer-height', newVh + 'vh');
          }
          e.preventDefault();
        }
        document.addEventListener('mousemove', handleMove);
        document.addEventListener('touchmove', handleMove, { passive: false });
        function handleEnd() {
          if (isResizing) {
            isResizing = false;
            if (currentResizer === 'header') {
              PAGE_STATE.topbarHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--topbar-height'));
              headerResizer.classList.remove('resizing');
            } else if (currentResizer === 'sidebar') {
              PAGE_STATE.sidebarWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width'));
              sidebarResizer.classList.remove('resizing');
            } else if (currentResizer === 'mobile-footer') {
              PAGE_STATE.mobileFooterHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--mobile-footer-height'));
              mobileFooterResizer.classList.remove('resizing');
            }
            document.body.classList.remove('resizing');
            document.body.style.cursor = '';
            currentResizer = null;
          }
        }
        document.addEventListener('mouseup', handleEnd);
        document.addEventListener('touchend', handleEnd);
        document.addEventListener('touchcancel', handleEnd);
      })();
      document.getElementById("export-data-btn").addEventListener("click", () => {
       const data = captureTheQuickening();
       const jsonStr = JSON.stringify(data, null, 2);
       const blob = new Blob([jsonStr], {
        type: "application/json"
       });
       const url = URL.createObjectURL(blob);
       const a = document.createElement("a");
       a.href = url;
       const safeTitle = (PAGE_STATE.title || "network-topology").toLowerCase().replace(/[^a-z0-9\-]+/g, "-");
       const timestamp = new Date().toISOString().split("T")[0];
       a.download = `${safeTitle}-data-${timestamp}.json`;
       document.body.appendChild(a);
       a.click();
       document.body.removeChild(a);
       URL.revokeObjectURL(url);
       logAuditEvent("export", `Exported JSON: ${a.download}`);
      });
      document.getElementById("import-data-btn").addEventListener("click", () => {
       document.getElementById("import-data-file").click();
      });
      document.getElementById("import-data-file").addEventListener("change", async (e) => {
       const file = e.target.files[0];
       if (!file) return;
       try {
        const text = await file.text();
        const data = JSON.parse(text);
        if (!data.nodeData || !data.edgeData) {
         alert("Invalid data file. Missing required fields.");
         return;
        }
        const confirmMsg = `This will replace all current data with the imported data.\n\nImporting:\n- ${Object.keys(data.nodeData).length} nodes\n- ${data.edgeData.list?.length || 0} connections\n- ${data.documentTabs?.length || 1} tab(s)\n\nContinue?`;
        if (!confirm(confirmMsg)) {
         e.target.value = "";
         return;
        }
        NODE_DATA = data.nodeData || {};
        EDGE_DATA = data.edgeData || {
         list: []
        };
        EDGE_LEGEND = data.edgeLegend || {};
        RECT_DATA = data.rectData || { list: [] };
        TEXT_DATA = data.textData || { list: [] };
        savedPositions = data.nodePositions || {};
        savedSizes = data.nodeSizes || {};
        savedStyles = data.nodeStyles || {};
        if (data.page) {
         PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, data.page, );
         wieldThePower();
        }
        if (data.canvas) {
         canvasState.zoom = data.canvas.zoom || 1;
         canvasState.panX = data.canvas.panX || 0;
         canvasState.panY = data.canvas.panY || 0;
        }
        if (data.page?.title) {
         document.title = data.page.title;
         document.querySelector(".editable-page-title", ).textContent = data.page.title;
        }
        if (data.documentTabs) {
         documentTabs = data.documentTabs;
         currentTabIndex = data.currentTabIndex || 0;
        }
        if (data.savedTopologyView) {
         savedTopologyView = data.savedTopologyView;
        }
        if (data.encryptedSections) {
         encryptedSections = data.encryptedSections;
        }
        if (data.auditLog && Array.isArray(data.auditLog)) {
         auditLog = data.auditLog;
         try {
           localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
         } catch (e) {
           console.warn("Failed to sync audit log to localStorage:", e);
         }
        }
        forgeTheTopology();
        forgeTheLegend();
		logAuditEvent("import", `Imported JSON: ${file.name} (${Object.keys(data.nodeData).length} nodes, ${data.edgeData.list?.length || 0} connections)`);
        updateViewBox();
        const nodeIds = Object.keys(NODE_DATA);
        if (nodeIds.length > 0) {
         claimTheImmortal(nodeIds[0]);
        } else {
         document.getElementById("node-panel").style.display = "none";
         document.getElementById("edge-panel").style.display = "none";
         document.getElementById("topology-toolbar").style.display = "none";
        }
        e.target.value = "";
       } catch (err) {
        console.error("Import error:", err);
        alert(`Failed to import data: ${err.message}`);
        e.target.value = "";
       }
      });
      const saveHelpBtn = document.getElementById("save-help-btn");
      const saveInfoModal = document.getElementById("save-info-modal");
      const saveInfoClose = document.getElementById("save-info-close");
      saveHelpBtn.addEventListener("click", () => {
       saveInfoModal.classList.add("active");
      });
      saveInfoClose.addEventListener("click", () => {
       saveInfoModal.classList.remove("active");
      });
      saveInfoModal.addEventListener("click", (e) => {
       if (e.target === saveInfoModal) {
        saveInfoModal.classList.remove("active");
       }
      });
      document.querySelectorAll(".help-tab").forEach(tab => {
        tab.addEventListener("click", () => {
          document.querySelectorAll(".help-tab").forEach(t => { t.style.background = "var(--panel)"; t.style.color = "var(--text-main)"; });
          tab.style.background = "var(--accent)"; tab.style.color = "var(--bg)";
          document.querySelectorAll(".help-tab-content").forEach(c => c.style.display = "none");
          document.getElementById("help-tab-" + tab.dataset.tab).style.display = "block";
        });
      });
      async function deriveKey(password, salt) {
      const encoder = new TextEncoder();
      const keyMaterial = await crypto.subtle.importKey(
      "raw",
      encoder.encode(password),
      "PBKDF2",
      false,
      ["deriveKey"]
      );
      return crypto.subtle.deriveKey(
      {
      name: "PBKDF2",
      salt: salt,
      iterations: 200000,
      hash: "SHA-256"
      },
      keyMaterial,
      {
      name: "AES-GCM",
      length: 256
      },
      false,
      ["encrypt", "decrypt"]
      );
      }
      async function encryptData(data, password) {
      const encoder = new TextEncoder();
      const salt = crypto.getRandomValues(new Uint8Array(16));
      const iv   = crypto.getRandomValues(new Uint8Array(12));
      const key = await deriveKey(password, salt);
      const encrypted = await crypto.subtle.encrypt(
      { name: "AES-GCM", iv },
      key,
      encoder.encode(data)
      );
      const encryptedU8 = new Uint8Array(encrypted);
      const result = new Uint8Array(salt.length + iv.length + encryptedU8.length);
      result.set(salt, 0);
      result.set(iv, salt.length);
      result.set(encryptedU8, salt.length + iv.length);
      return "ENCRYPTED:" + u8ToBase64(result);
      }
      async function decryptData(encryptedData, password) {
      const base64Data = encryptedData.replace("ENCRYPTED:", "");
      const fullData   = base64ToU8(base64Data);
      const salt      = fullData.slice(0, 16);
      const iv        = fullData.slice(16, 28);
      const encrypted = fullData.slice(28);
      const key = await deriveKey(password, salt);
      const decrypted = await crypto.subtle.decrypt(
      { name: "AES-GCM", iv },
      key,
      encrypted
      );
      const decoder = new TextDecoder();
      return decoder.decode(decrypted);
      }
      function isEncrypted(data) {
       return typeof data === "string" && data.startsWith("ENCRYPTED:");
      }
      function captureTheQuickening() {
       const currentTab = documentTabs[currentTabIndex];
       currentTab.nodes = JSON.parse(JSON.stringify(NODE_DATA));
       currentTab.edges = JSON.parse(JSON.stringify(EDGE_DATA));
       currentTab.positions = JSON.parse(JSON.stringify(savedPositions));
       currentTab.sizes = JSON.parse(JSON.stringify(savedSizes));
       currentTab.styles = JSON.parse(JSON.stringify(savedStyles));
       currentTab.legend = JSON.parse(JSON.stringify(EDGE_LEGEND));
       currentTab.rects = JSON.parse(JSON.stringify(RECT_DATA));
       currentTab.texts = JSON.parse(JSON.stringify(TEXT_DATA));
       currentTab.pageState = JSON.parse(JSON.stringify(PAGE_STATE));
       return {
        nodeData: NODE_DATA,
        edgeData: EDGE_DATA,
        rectData: RECT_DATA,
        textData: TEXT_DATA,
        edgeLegend: EDGE_LEGEND,
        nodePositions: savedPositions,
        nodeSizes: savedSizes,
        nodeStyles: savedStyles,
        page: PAGE_STATE,
        canvas: {
         zoom: canvasState.zoom,
         panX: canvasState.panX,
         panY: canvasState.panY,
        },
        savedTopologyView: savedTopologyView,
        documentTabs: documentTabs,
        currentTabIndex: currentTabIndex,
        encryptedSections: encryptedSections,
        auditLog: auditLog,
       };
      }
      function assembleTheImmortalForm() {
      const canvasHintEl = document.getElementById("canvas-hint");
       const savedHintHTML = canvasHintEl ? canvasHintEl.innerHTML : "";
       if (canvasHintEl) canvasHintEl.innerHTML = DEFAULT_CANVAS_HINT;
       const clone = document.documentElement.cloneNode(true);
       ["edge-legend-mini", "minimap-mini", "draw-toolbar-mini", "topology-toolbar-mini"].forEach(id => {
        const all = clone.querySelectorAll("#" + id);
        for (let i = 1; i < all.length; i++) {
         all[i].remove();
        }
       });
       const nodeScript = clone.querySelector("#nodes-json");
       if (nodeScript) {
        nodeScript.textContent = JSON.stringify(NODE_DATA, null, 2);
       }
       let stateScript = clone.querySelector("#topology-state");
       if (!stateScript) {
        stateScript = document.createElement("script");
        stateScript.id = "topology-state";
        stateScript.type = "application/json";
        const body = clone.querySelector("body") || clone;
        body.appendChild(stateScript);
       }
       stateScript.textContent = JSON.stringify(captureTheQuickening(), null, 2, );
       return "<!DOCTYPE html> \n " + clone.outerHTML;
      }
      async function becomeImmortal() {
       saveRollbackVersion("Auto-save");
       const encryptEnabled = document.getElementById("encrypt-toggle").checked;
       let stateData = JSON.stringify(captureTheQuickening(), null, 2);
       if (encryptEnabled) {
        const password = prompt("Enter a password to encrypt your data:\n(Remember this password! You will need it to open this file and its non recoverable!)", );
        if (!password) {
         alert("Encryption cancelled. File not saved.");
         return;
        }
        const confirmPassword = prompt("Confirm your password:");
        if (password !== confirmPassword) {
         alert("Passwords do not match. File not saved.");
         return;
        }
        try {
         stateData = await encryptData(stateData, password);
        } catch (e) {
         alert("Encryption failed: " + e.message);
         return;
        }
       }
       const canvasHintEl = document.getElementById("canvas-hint");
       const savedHintHTML = canvasHintEl ? canvasHintEl.innerHTML : "";
       if (canvasHintEl) canvasHintEl.innerHTML = DEFAULT_CANVAS_HINT;
       const clone = document.documentElement.cloneNode(true);
       ["edge-legend-mini", "minimap-mini", "draw-toolbar-mini", "topology-toolbar-mini"].forEach(id => {
        const all = clone.querySelectorAll("#" + id);
        for (let i = 1; i < all.length; i++) {
         all[i].remove();
        }
       });
       const nodeScript = clone.querySelector("#nodes-json");
       if (nodeScript) {
        if (encryptEnabled) {
         nodeScript.textContent = JSON.stringify({}, null, 2);
        } else {
         nodeScript.textContent = JSON.stringify(NODE_DATA, null, 2);
        }
       }
       let stateScript = clone.querySelector("#topology-state");
       if (!stateScript) {
        stateScript = document.createElement("script");
        stateScript.id = "topology-state";
        stateScript.type = "application/json";
        const body = clone.querySelector("body") || clone;
        body.appendChild(stateScript);
       }
       stateScript.textContent = stateData;
       const html = "<!DOCTYPE html> \n " + clone.outerHTML;
       const blob = new Blob([html], {
        type: "text/html"
       });
       const url = URL.createObjectURL(blob);
       const a = document.createElement("a");
       a.href = url;
       const safeTitle = (PAGE_STATE.title || document.title || "network-topology").toLowerCase().replace(/[^a-z0-9\-]+/g, "-");
       a.download = safeTitle + ".html";
       document.body.appendChild(a);
       a.click();
       document.body.removeChild(a);
       URL.revokeObjectURL(url);
       if (canvasHintEl) canvasHintEl.innerHTML = savedHintHTML;
       logAuditEvent("save", `File saved: ${safeTitle}.html`);
      }
      function captureState() {
      return {
       nodes: JSON.parse(JSON.stringify(NODE_DATA)),
       edges: JSON.parse(JSON.stringify(EDGE_DATA)),
       positions: JSON.parse(JSON.stringify(savedPositions)),
       sizes: JSON.parse(JSON.stringify(savedSizes)),
       styles: JSON.parse(JSON.stringify(savedStyles)),
       legend: JSON.parse(JSON.stringify(EDGE_LEGEND)),
       rects: JSON.parse(JSON.stringify(RECT_DATA)),
       texts: JSON.parse(JSON.stringify(TEXT_DATA))
       };
      }
      function pushUndo(action = "") {
       const state = captureState();
       undoStack.push(state);
       if (undoStack.length > MAX_UNDO_STACK) {
        undoStack.shift();
       }
       redoStack = [];
       updateUndoButtons();
       if (action) {
        const actionTypeMap = {
  "create node": "node",
  "delete node": "node",
  "add node": "node",
  "edit": "node",
  "clone node": "node",
  "paste node": "node",
  "move nodes": "node",
  "nudge": "node",
  "align nodes": "node",
  "distribute nodes": "node",
  "snap to grid": "node",
  "toggle group": "node",
  "toggle lock": "node",
  "create rack": "rack",
  "add rack": "rack",
  "edit rack": "rack",
  "edit mac": "rack",
  "edit U height": "rack",
  "change rack capacity": "rack",
  "change assigned rack": "rack",
  "add connection": "connection",
  "delete connection": "connection",
  "delete edge": "connection",
  "clone edge": "connection",
  "paste edge": "connection",
  "style change": "style",
  "change layer": "layer",
  "add text": "text",
  "edit text": "text",
  "delete text": "text",
  "clone text": "text",
  "paste text": "text",
  "draw zone": "zone",
  "delete zone": "zone",
  "delete rect": "zone",
  "clone rect": "zone",
  "paste rect": "zone",
  "change zone line style": "zone",
  "delete selected": "bulk",
  "clone selected": "bulk",
};
        const type = actionTypeMap[action] || "node";
        logAuditEvent(type, action);
       }
      }
      function undo() {
       if (undoStack.length === 0) return;
       const currentState = captureState();
       redoStack.push(currentState);
       const previousState = undoStack.pop();
       restoreState(previousState);
       updateUndoButtons();
       logAuditEvent("undo", "Undo action performed");
      }
      function redo() {
       if (redoStack.length === 0) return;
       logAuditEvent("redo", "Redo action performed");
       const currentState = captureState();
       undoStack.push(currentState);
       const nextState = redoStack.pop();
       restoreState(nextState);
       updateUndoButtons();
      }
      function restoreState(state) {
      NODE_DATA = state.nodes;
      EDGE_DATA = state.edges;
      savedPositions = state.positions;
      savedSizes = state.sizes;
      savedStyles = state.styles;
      EDGE_LEGEND = state.legend;
      RECT_DATA = state.rects || { list: [] };
      TEXT_DATA = state.texts || { list: [] };
      forgeTheTopology();
      if (currentNodeId && NODE_DATA[currentNodeId]) {
       claimTheImmortal(currentNodeId);
      } else if (currentEdgeId) {
       selectTheConnection(currentEdgeId);
       }
      }
      function updateUndoButtons() {
       const undoBtn = document.getElementById("undo-btn");
       const redoBtn = document.getElementById("redo-btn");
       if (undoBtn) {
        undoBtn.disabled = undoStack.length === 0;
        undoBtn.style.opacity = undoStack.length === 0 ? "0.5" : "1";
       }
       if (redoBtn) {
        redoBtn.disabled = redoStack.length === 0;
        redoBtn.style.opacity = redoStack.length === 0 ? "0.5" : "1";
       }
      }
      function editNodeMac(id) {
       const currentMac = NODE_DATA[id].mac || "";
       showEditModal("Edit MAC Address", currentMac, (newMac) => {
        pushUndo("edit mac");
        NODE_DATA[id].mac = newMac;
        if (currentNodeId === id) {
         document.getElementById("node-mac").textContent = newMac || "--";
        }
       });
      }
      function editNodeRack(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       document.getElementById("modal-title").textContent = "Edit Rack Unit";
       document.getElementById("modal-input").value = node.rackUnit || "";
       document.getElementById("edit-modal").style.display = "";
       document.getElementById("edit-modal").classList.add("active");
       document.getElementById("modal-input").focus();
	   const modal = document.getElementById("edit-modal");
       const cleanup = () => {
        modal.classList.remove("active");
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
        modal.removeEventListener("click", bgHandler);
       };
       const saveHandler = () => {
        pushUndo("edit rack");
        const value = document.getElementById("modal-input").value.trim();
        node.rackUnit = value;
        cleanup();
        claimTheImmortal(id);
       };
       const cancelHandler = () => {
        cleanup();
       };
       const bgHandler = (e) => {
        if (e.target === modal) cancelHandler();
       };
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       modal.addEventListener("click", bgHandler);
      }
      function editNodeUHeight(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       document.getElementById("modal-title").textContent = "Edit U Height";
       document.getElementById("modal-input").value = node.uHeight || "1";
       document.getElementById("edit-modal").style.display = "";
       document.getElementById("edit-modal").classList.add("active");
       document.getElementById("modal-input").focus();
	   const modal = document.getElementById("edit-modal");
       const cleanup = () => {
        modal.classList.remove("active");
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
        modal.removeEventListener("click", bgHandler);
       };
       const saveHandler = () => {
        pushUndo("edit U height");
        const value = document.getElementById("modal-input").value.trim();
        node.uHeight = value;
        cleanup();
        claimTheImmortal(id);
        forgeTheTopology();
       };
       const cancelHandler = () => {
        cleanup();
       };
       const bgHandler = (e) => {
        if (e.target === modal) cancelHandler();
       };
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       modal.addEventListener("click", bgHandler);
      }
      function updateEdgePortLabels(edgeId) {
       const edge = EDGE_DATA.list.find(e => e.id === edgeId);
       if (!edge || edge.type === "custom") return;
       const fromPortInput = document.getElementById("edge-from-port");
       const toPortInput = document.getElementById("edge-to-port");
       if (fromPortInput && toPortInput) {
        edge.fromPort = fromPortInput.value || "";
        edge.toPort = toPortInput.value || "";
        forgeTheTopology();
       }
      }
      function clearSelection() {
       selectedNodes.clear();
       selectedEdges.clear();
       selectedRects.clear();
       selectedTexts.clear();
       updateAllSelections();
      }
      function updateAllSelections() {
      updateNodeSelection();
      document.querySelectorAll(".edge").forEach(el => {
      const edgeId = el.dataset.edgeId;
      if (selectedEdges.has(edgeId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      document.querySelectorAll(".rect-group").forEach(el => {
      const rectId = el.dataset.rectId;
      if (selectedRects.has(rectId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      document.querySelectorAll(".text-group").forEach(el => {
      const textId = el.dataset.textId;
      if (selectedTexts.has(textId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
      const bulkToolbar = document.getElementById("bulk-toolbar");
      const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
      const bulkCount = document.getElementById("bulk-count");
      const bulkCountMobile = document.getElementById("bulk-count-mobile");
      if (total > 0) {
      if (bulkToolbar) bulkToolbar.style.display = "flex";
      if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
      if (bulkCount) bulkCount.textContent = total;
      if (bulkCountMobile) bulkCountMobile.textContent = total;
      } else {
      if (bulkToolbar) bulkToolbar.style.display = "none";
      if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
      }
      }
      function updateNodeSelection() {
       if (isViewOnly()) {
        selectedNodes.clear();
        selectedRects.clear();
        selectedTexts.clear();
        const bulkToolbar = document.getElementById("bulk-toolbar");
        const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        return;
       }
       document.querySelectorAll(".node-group").forEach(node => {
        const nodeId = node.dataset.nodeId;
        if (selectedNodes.has(nodeId)) {
         node.classList.add("selected");
        } else {
         node.classList.remove("selected");
        }
       });
       const bulkToolbar = document.getElementById("bulk-toolbar");
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       const bulkCount = document.getElementById("bulk-count");
       const bulkCountMobile = document.getElementById("bulk-count-mobile");
       const bulkCountModal = document.getElementById("bulk-count-modal");
       if (selectedNodes.size > 0) {
        if (bulkToolbar) bulkToolbar.style.display = "flex";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
        if (bulkCount) bulkCount.textContent = selectedNodes.size;
        if (bulkCountMobile) bulkCountMobile.textContent = selectedNodes.size;
        if (bulkCountModal) bulkCountModal.textContent = selectedNodes.size;
       } else {
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        const modal = document.getElementById("bulk-actions-modal");
        if (modal) modal.style.display = "none";
       }
      }
      function deleteSelected() {
       const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
       if (total === 0) return;
       let nodesInsideRacks = [];
       selectedNodes.forEach(nodeId => {
        if (NODE_DATA[nodeId]?.isRack) {
         Object.entries(NODE_DATA).forEach(([id, n]) => {
          if (n.assignedRack === nodeId) nodesInsideRacks.push(n.name || id);
         });
        }
       });
       let message = `Delete ${total} selected item(s)?`;
       if (nodesInsideRacks.length > 0) {
        message += `\n\nThis will also delete ${nodesInsideRacks.length} node(s) inside rack(s):\n• ${nodesInsideRacks.join('\n• ')}`;
       }
       challengeTheImmortal(message, () => {
        pushUndo("delete selected");
        selectedNodes.forEach(nodeId => {
         if (NODE_DATA[nodeId]?.isRack) {
          Object.keys(NODE_DATA).forEach(id => {
           if (NODE_DATA[id]?.assignedRack === nodeId) {
            EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== id && e.to !== id);
            delete NODE_DATA[id];
            delete savedPositions[id];
            delete savedSizes[id];
            delete savedStyles[id];
           }
          });
         }
         delete NODE_DATA[nodeId];
         delete savedPositions[nodeId];
         delete savedSizes[nodeId];
         delete savedStyles[nodeId];
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== nodeId && e.to !== nodeId);
        });
        selectedEdges.forEach(edgeId => {
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.id !== edgeId);
        });
        selectedRects.forEach(rectId => {
         RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== rectId);
        });
        selectedTexts.forEach(textId => {
         TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== textId);
        });
        clearSelection();
        forgeTheTopology();
       });
      }
      function startSelection(event) {
       if (event.button !== 0) return;
       if (event.target.closest(".node-group")) return;
       isSelecting = true;
       const svg = document.getElementById("map");
       const pt = svg.createSVGPoint();
       pt.x = event.clientX;
       pt.y = event.clientY;
       const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
       selectionStart = { x: svgP.x, y: svgP.y };
       clearSelection();
       preDragSelectedNodes = new Set(selectedNodes);
       preDragSelectedEdges = new Set(selectedEdges);
       preDragSelectedRects = new Set(selectedRects);
       preDragSelectedTexts = new Set(selectedTexts);
       if (!selectionRect || !selectionRect.parentNode) {
        selectionRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        selectionRect.setAttribute("fill", selectionBoxStyle.fillColor);
        selectionRect.setAttribute("fill-opacity", selectionBoxStyle.fillOpacity);
        selectionRect.setAttribute("stroke", selectionBoxStyle.strokeColor);
        selectionRect.setAttribute("stroke-width", selectionBoxStyle.strokeWidth);
        selectionRect.setAttribute("stroke-dasharray", selectionBoxStyle.strokeDasharray);
        svg.appendChild(selectionRect);
       }
       selectionRect.style.display = "block";
      }
      function updateSelection(event) {
       if (!isSelecting || !selectionStart) return;
       const svg = document.getElementById("map");
       const pt = svg.createSVGPoint();
       pt.x = event.clientX;
       pt.y = event.clientY;
       const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
       const x = Math.min(selectionStart.x, svgP.x);
       const y = Math.min(selectionStart.y, svgP.y);
       const width = Math.abs(svgP.x - selectionStart.x);
       const height = Math.abs(svgP.y - selectionStart.y);
       selectionRect.setAttribute("x", x);
       selectionRect.setAttribute("y", y);
       selectionRect.setAttribute("width", width);
       selectionRect.setAttribute("height", height);
       const box = { x, y, width, height };
       Object.entries(savedPositions).forEach(([nodeId, pos]) => {
        const size = savedSizes[nodeId] || 50;
        const halfSize = size / 2;
        const nodeBox = { x: pos.x - halfSize, y: pos.y - halfSize, width: size, height: size };
        if (boxesIntersect(box, nodeBox)) {
         selectedNodes.add(nodeId);
        } else if (!preDragSelectedNodes.has(nodeId)) {
         selectedNodes.delete(nodeId);
        }
       });
      EDGE_DATA.list.forEach(edge => {
        if (!edge.points || edge.points.length === 0) return;
        for (let i = 0; i < edge.points.length - 1; i++) {
         const p1 = edge.points[i];
         const p2 = edge.points[i + 1];
         if (lineIntersectsBox(p1.x, p1.y, p2.x, p2.y, box)) {
          selectedEdges.add(edge.id);
          return;
         }
        }
        if (!preDragSelectedEdges.has(edge.id)) {
         selectedEdges.delete(edge.id);
        }
       });
       RECT_DATA.list.forEach(rect => {
        const rectBox = { x: rect.x, y: rect.y, width: rect.width, height: rect.height };
        if (boxesIntersect(box, rectBox)) {
         selectedRects.add(rect.id);
        } else if (!preDragSelectedRects.has(rect.id)) {
         selectedRects.delete(rect.id);
        }
       });
       TEXT_DATA.list.forEach(text => {
        const fontSize = text.fontSize || 18;
        const textBox = { x: text.x - 50, y: text.y - fontSize, width: 100, height: fontSize * 1.5 };
        if (boxesIntersect(box, textBox)) {
         selectedTexts.add(text.id);
        } else if (!preDragSelectedTexts.has(text.id)) {
         selectedTexts.delete(text.id);
        }
       });
       updateAllSelectionVisuals();
      }
      function endSelection() {
       isSelecting = false;
       if (selectionRect) {
        selectionRect.style.display = "none";
       }
      }
      function boxesIntersect(a, b) {
       return !(a.x + a.width < b.x || b.x + b.width < a.x || a.y + a.height < b.y || b.y + b.height < a.y);
      }
      function lineIntersectsBox(x1, y1, x2, y2, box) {
       if (pointInBox(x1, y1, box) || pointInBox(x2, y2, box)) return true;
       const lines = [
        [box.x, box.y, box.x + box.width, box.y],
        [box.x + box.width, box.y, box.x + box.width, box.y + box.height],
        [box.x + box.width, box.y + box.height, box.x, box.y + box.height],
        [box.x, box.y + box.height, box.x, box.y]
       ];
       for (const [bx1, by1, bx2, by2] of lines) {
        if (linesIntersect(x1, y1, x2, y2, bx1, by1, bx2, by2)) return true;
       }
       return false;
      }
      function pointInBox(x, y, box) {
       return x >= box.x && x <= box.x + box.width && y >= box.y && y <= box.y + box.height;
      }
      function linesIntersect(x1, y1, x2, y2, x3, y3, x4, y4) {
       const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
       if (Math.abs(denom) < 0.0001) return false;
       const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom;
       const ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denom;
       return ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1;
      }
      function updateAllSelectionVisuals() {
       document.querySelectorAll(".node-group").forEach(node => {
        const nodeId = node.dataset.nodeId;
        if (selectedNodes.has(nodeId)) {
         node.classList.add("selected");
        } else {
         node.classList.remove("selected");
        }
       });
       document.querySelectorAll(".edge").forEach(edge => {
        const edgeId = edge.dataset.edgeId;
        if (selectedEdges.has(edgeId)) {
         edge.style.filter = "drop-shadow(0 0 6px #4fd1c5)";
        } else {
         edge.style.filter = "";
        }
       });
       document.querySelectorAll(".rect-group rect").forEach(el => {
        const rectId = el.closest(".rect-group")?.dataset?.rectId;
        if (selectedRects.has(rectId)) {
         el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
        } else {
         el.style.filter = "";
        }
       });
       document.querySelectorAll(".text-group, .text-element").forEach(el => {
        const textId = el.dataset?.textId;
        if (selectedTexts.has(textId)) {
         el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
        } else {
         el.style.filter = "";
        }
       });
       const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
       const bulkToolbar = document.getElementById("bulk-toolbar");
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       const bulkCount = document.getElementById("bulk-count");
       const bulkCountMobile = document.getElementById("bulk-count-mobile");
       if (total > 0) {
        if (bulkToolbar) bulkToolbar.style.display = "flex";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
        if (bulkCount) bulkCount.textContent = total;
        if (bulkCountMobile) bulkCountMobile.textContent = total;
       } else {
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
       }
      }
      function cloneNode(sourceId, skipUndo) {
       if (!NODE_DATA[sourceId]) return;
       if (!skipUndo) pushUndo("clone node");
       const source = NODE_DATA[sourceId];
       const baseName = source.name + " copy";
       let newName = baseName;
       let counter = 1;
       while (Object.values(NODE_DATA).some(n => n.name === newName)) {
        newName = `${baseName} ${counter}`;
        counter++;
       }
       const baseId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
       let newId = baseId;
       counter = 1;
       while (NODE_DATA[newId]) {
        newId = `${baseId}-${counter}`;
        counter++;
       }
       NODE_DATA[newId] = {
        shape: source.shape,
        name: newName,
        ip: source.ip,
        role: source.role,
        tags: [...source.tags],
        notes: [...source.notes],
        mac: source.mac || "",
        rackUnit: source.rackUnit || "",
        uHeight: source.uHeight || "1",
        layer: source.layer || "physical",
        assignedRack: source.assignedRack || "",
        rackCapacity: source.rackCapacity || "42",
        isRack: source.isRack || false
       };
       if (source.isRack) {
        const childNodes = Object.entries(NODE_DATA).filter(([id, n]) =>
         id !== newId && n.assignedRack === sourceId
        );
        childNodes.forEach(([childId, childNode]) => {
         const childBaseName = childNode.name + " copy";
         let childNewName = childBaseName;
         let c = 1;
         while (Object.values(NODE_DATA).some(n => n.name === childNewName)) {
          childNewName = `${childBaseName} ${c}`;
          c++;
         }
         const childBaseId = childNewName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
         let childNewId = childBaseId;
         c = 1;
         while (NODE_DATA[childNewId]) {
          childNewId = `${childBaseId}-${c}`;
          c++;
         }
         NODE_DATA[childNewId] = {
          ...JSON.parse(JSON.stringify(childNode)),
          name: childNewName,
          assignedRack: newId
         };
         if (savedPositions[childId]) {
          savedPositions[childNewId] = { ...savedPositions[childId] };
         }
         if (savedSizes[childId]) {
          savedSizes[childNewId] = savedSizes[childId];
         }
         if (savedStyles[childId]) {
          savedStyles[childNewId] = JSON.parse(JSON.stringify(savedStyles[childId]));
         }
        });
       }
       if (currentView.mode === "rack" && currentView.rackId) {
        NODE_DATA[newId].assignedRack = currentView.rackId;
       }
       const sourcePos = savedPositions[sourceId];
       savedPositions[newId] = {
        x: sourcePos.x + 100,
        y: sourcePos.y + 100
       };
       if (savedSizes[sourceId]) {
        savedSizes[newId] = savedSizes[sourceId];
       }
       if (savedStyles[sourceId]) {
        savedStyles[newId] = JSON.parse(JSON.stringify(savedStyles[sourceId]));
       }
       forgeTheTopology();
       claimTheImmortal(newId);
      }
      function alignSelectedNodes(direction) {
       if (selectedNodes.size < 2) return;
       pushUndo("align nodes");
       const nodes = Array.from(selectedNodes).map(id => ({
        id,
        pos: savedPositions[id]
       }));
       switch(direction) {
        case "left":
         const minX = Math.min(...nodes.map(n => n.pos.x));
         nodes.forEach(n => savedPositions[n.id].x = minX);
         break;
        case "right":
         const maxX = Math.max(...nodes.map(n => n.pos.x));
         nodes.forEach(n => savedPositions[n.id].x = maxX);
         break;
        case "top":
         const minY = Math.min(...nodes.map(n => n.pos.y));
         nodes.forEach(n => savedPositions[n.id].y = minY);
         break;
        case "bottom":
         const maxY = Math.max(...nodes.map(n => n.pos.y));
         nodes.forEach(n => savedPositions[n.id].y = maxY);
         break;
        case "center-h":
         const avgX = nodes.reduce((sum, n) => sum + n.pos.x, 0) / nodes.length;
         nodes.forEach(n => savedPositions[n.id].x = avgX);
         break;
        case "center-v":
         const avgY = nodes.reduce((sum, n) => sum + n.pos.y, 0) / nodes.length;
         nodes.forEach(n => savedPositions[n.id].y = avgY);
         break;
       }
       forgeTheTopology();
      }
      function distributeSelectedNodes(direction) {
       if (selectedNodes.size < 3) return;
       pushUndo("distribute nodes");
       const nodes = Array.from(selectedNodes).map(id => ({
        id,
        pos: savedPositions[id]
       }));
       if (direction === "horizontal") {
        nodes.sort((a, b) => a.pos.x - b.pos.x);
        const minX = nodes[0].pos.x;
        const maxX = nodes[nodes.length - 1].pos.x;
        const gap = (maxX - minX) / (nodes.length - 1);
        nodes.forEach((n, i) => {
         savedPositions[n.id].x = minX + (gap * i);
        });
       } else {
        nodes.sort((a, b) => a.pos.y - b.pos.y);
        const minY = nodes[0].pos.y;
        const maxY = nodes[nodes.length - 1].pos.y;
        const gap = (maxY - minY) / (nodes.length - 1);
        nodes.forEach((n, i) => {
         savedPositions[n.id].y = minY + (gap * i);
        });
       }
       forgeTheTopology();
      }
      function snapToGrid(nodeId, gridSize = 50) {
       if (!savedPositions[nodeId]) return;
       pushUndo("snap to grid");
       const pos = savedPositions[nodeId];
       pos.x = Math.round(pos.x / gridSize) * gridSize;
       pos.y = Math.round(pos.y / gridSize) * gridSize;
       forgeTheTopology();
      }
		function searchNodes(query) {
		   if (!query) {
			clearSearchHighlight();
			return [];
		   }
		   query = query.toLowerCase();
		   const results = [];
		   Object.entries(NODE_DATA).forEach(([id, data]) => {
			try {
			 const nameMatch = data.name && data.name.toLowerCase().includes(query);
			 const ipMatch = data.ip && data.ip.toLowerCase().includes(query);
			 const roleMatch = data.role && data.role.toLowerCase().includes(query);
			 const tagsMatch = data.tags && Array.isArray(data.tags) && data.tags.some(tag => tag && tag.toLowerCase().includes(query));
			 const macMatch = data.mac && data.mac.toLowerCase().includes(query);
			 const rackUnitMatch = data.rackUnit && String(data.rackUnit).toLowerCase().includes(query);
			 if (nameMatch || ipMatch || roleMatch || tagsMatch || macMatch || rackUnitMatch) {
			  results.push(id);
			 }
			} catch (e) {
			 console.warn("Search error for node:", id, e);
			}
		   });
		   highlightSearchResults(results, true);
		   return results;
		}
		function highlightSearchResults(nodeIds, hasQuery = false) {
		   document.querySelectorAll(".node-group").forEach(node => {
			const nodeId = node.dataset.nodeId;
			if (nodeIds.includes(nodeId)) {
			 node.classList.add("search-highlight");
			 node.classList.remove("search-faded");
			} else {
			 node.classList.remove("search-highlight");
			 if (hasQuery) {
			  node.classList.add("search-faded");
			 } else {
			  node.classList.remove("search-faded");
			 }
			}
		   });
		   document.querySelectorAll(".edge-group").forEach(edge => {
			const fromId = edge.dataset.from;
			const toId = edge.dataset.to;
			if (hasQuery && !nodeIds.includes(fromId) && !nodeIds.includes(toId)) {
			 edge.classList.add("search-faded");
			} else {
			 edge.classList.remove("search-faded");
			}
		   });
		}
		function clearSearchHighlight() {
   document.querySelectorAll(".search-highlight").forEach(node => {
    node.classList.remove("search-highlight");
   });
   document.querySelectorAll(".search-faded").forEach(el => {
    el.classList.remove("search-faded");
   });
}
      function nudgeSelectedNodes(direction, distance) {
        const nodesToNudge = selectedNodes.size > 0
          ? Array.from(selectedNodes)
          : (currentNodeId ? [currentNodeId] : []);
        const rectsToNudge = selectedRects.size > 0
          ? Array.from(selectedRects)
          : (currentRectId ? [currentRectId] : []);
        const textsToNudge = selectedTexts.size > 0
          ? Array.from(selectedTexts)
          : (currentTextId ? [currentTextId] : []);
        if (nodesToNudge.length === 0 && rectsToNudge.length === 0 && textsToNudge.length === 0) return;
        const unlockedNodes = nodesToNudge.filter(id => !NODE_DATA[id]?.locked);
        const unlockedRects = rectsToNudge.filter(id => { const r = RECT_DATA.list.find(x => x.id === id); return r && !r.locked; });
        const unlockedTexts = textsToNudge.filter(id => { const t = TEXT_DATA.list.find(x => x.id === id); return t && !t.locked; });
        if (unlockedNodes.length === 0 && unlockedRects.length === 0 && unlockedTexts.length === 0) return;
        pushUndo("nudge");
        const dx = direction === "ArrowLeft" ? -distance : direction === "ArrowRight" ? distance : 0;
        const dy = direction === "ArrowUp" ? -distance : direction === "ArrowDown" ? distance : 0;
        unlockedNodes.forEach(id => {
          if (!savedPositions[id]) savedPositions[id] = { x: 0, y: 0 };
          savedPositions[id].x += dx;
          savedPositions[id].y += dy;
        });
        unlockedRects.forEach(id => {
          const r = RECT_DATA.list.find(x => x.id === id);
          if (r) { r.x += dx; r.y += dy; }
        });
        unlockedTexts.forEach(id => {
          const t = TEXT_DATA.list.find(x => x.id === id);
          if (t) { t.x += dx; t.y += dy; }
        });
        forgeTheTopology();
      }
      function cycleNodes(reverse = false) {
        const nodeIds = Object.keys(NODE_DATA).filter(id => {
          if (currentView.mode === "rack" && currentView.rackId) {
            return NODE_DATA[id].assignedRack === currentView.rackId;
          }
          return !NODE_DATA[id].assignedRack;
        });
        if (nodeIds.length === 0) return;
        let currentIndex = nodeIds.indexOf(currentNodeId);
        if (reverse) {
          currentIndex = currentIndex <= 0 ? nodeIds.length - 1 : currentIndex - 1;
        } else {
          currentIndex = currentIndex >= nodeIds.length - 1 ? 0 : currentIndex + 1;
        }
        const nextNodeId = nodeIds[currentIndex];
        claimTheImmortal(nextNodeId);
        selectedNodes.clear();
        updateNodeSelection();
      }
      function focusOnSelected() {
        let minX = Infinity, minY = Infinity;
        let maxX = -Infinity, maxY = -Infinity;
        let hasItems = false;
        const nodesToFocus = selectedNodes.size > 0
          ? Array.from(selectedNodes)
          : (currentNodeId ? [currentNodeId] : []);
        nodesToFocus.forEach(id => {
          const pos = savedPositions[id];
          if (pos) {
            hasItems = true;
            const size = savedSizes[id] || 50;
            minX = Math.min(minX, pos.x - size/2);
            minY = Math.min(minY, pos.y - size/2);
            maxX = Math.max(maxX, pos.x + size/2);
            maxY = Math.max(maxY, pos.y + size/2);
          }
        });
        const rectsToFocus = selectedRects.size > 0 ? Array.from(selectedRects) : (currentRectId ? [currentRectId] : []);
        rectsToFocus.forEach(id => {
          const r = RECT_DATA.list.find(x => x.id === id);
          if (r) {
            hasItems = true;
            minX = Math.min(minX, r.x);
            minY = Math.min(minY, r.y);
            maxX = Math.max(maxX, r.x + r.width);
            maxY = Math.max(maxY, r.y + r.height);
          }
        });
        const textsToFocus = selectedTexts.size > 0 ? Array.from(selectedTexts) : (currentTextId ? [currentTextId] : []);
        textsToFocus.forEach(id => {
          const t = TEXT_DATA.list.find(x => x.id === id);
          if (t) {
            hasItems = true;
            minX = Math.min(minX, t.x - 50);
            minY = Math.min(minY, t.y - 20);
            maxX = Math.max(maxX, t.x + 50);
            maxY = Math.max(maxY, t.y + 20);
          }
        });
        const edgesToFocus = selectedEdges.size > 0 ? Array.from(selectedEdges) : (currentEdgeId ? [currentEdgeId] : []);
        edgesToFocus.forEach(id => {
          const e = EDGE_DATA.list.find(x => x.id === id);
          if (e) {
            const fromPos = savedPositions[e.from];
            const toPos = savedPositions[e.to];
            if (fromPos && toPos) {
              hasItems = true;
              minX = Math.min(minX, fromPos.x, toPos.x);
              minY = Math.min(minY, fromPos.y, toPos.y);
              maxX = Math.max(maxX, fromPos.x, toPos.x);
              maxY = Math.max(maxY, fromPos.y, toPos.y);
            }
          }
        });
        if (!hasItems || !isFinite(minX)) return;
        const padding = 100;
        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;
        const width = maxX - minX + padding * 2;
        const height = maxY - minY + padding * 2;
        const zoomX = CANVAS_WIDTH / width;
        const zoomY = CANVAS_HEIGHT / height;
        const targetZoom = Math.min(zoomX, zoomY, 2);
        canvasState.zoom = targetZoom;
        canvasState.panX = centerX - (CANVAS_WIDTH / targetZoom) / 2;
        canvasState.panY = centerY - (CANVAS_HEIGHT / targetZoom) / 2;
		// forgeTheTopology(); getting ready to implement new core canvas performance system
		updateViewBox();
      }
      function toggleLockSelected() {
        const nodesToToggle = selectedNodes.size > 0
          ? Array.from(selectedNodes)
          : (currentNodeId ? [currentNodeId] : []);
        const rectsToToggle = selectedRects.size > 0
          ? Array.from(selectedRects)
          : (currentRectId ? [currentRectId] : []);
        const textsToToggle = selectedTexts.size > 0
          ? Array.from(selectedTexts)
          : (currentTextId ? [currentTextId] : []);
        if (nodesToToggle.length === 0 && rectsToToggle.length === 0 && textsToToggle.length === 0) return;
        pushUndo("toggle lock");
        let hasUnlocked = nodesToToggle.some(id => !NODE_DATA[id]?.locked);
        hasUnlocked = hasUnlocked || rectsToToggle.some(id => { const r = RECT_DATA.list.find(x => x.id === id); return r && !r.locked; });
        hasUnlocked = hasUnlocked || textsToToggle.some(id => { const t = TEXT_DATA.list.find(x => x.id === id); return t && !t.locked; });
        nodesToToggle.forEach(id => {
          if (NODE_DATA[id]) NODE_DATA[id].locked = hasUnlocked;
        });
        rectsToToggle.forEach(id => {
          const r = RECT_DATA.list.find(x => x.id === id);
          if (r) r.locked = hasUnlocked;
        });
        textsToToggle.forEach(id => {
          const t = TEXT_DATA.list.find(x => x.id === id);
          if (t) t.locked = hasUnlocked;
        });
        forgeTheTopology();
      }
      function toggleGroupSelected() {
      const nodesToGroup = Array.from(selectedNodes);
      const rectsToGroup = Array.from(selectedRects);
      const textsToGroup = Array.from(selectedTexts);
      const edgesToGroup = Array.from(selectedEdges);
      const totalItems = nodesToGroup.length + rectsToGroup.length + textsToGroup.length + edgesToGroup.length;
      if (totalItems < 2) return;
      pushUndo("toggle group");
      const allGroupIds = [];
      nodesToGroup.forEach(id => { if (NODE_DATA[id]?.groupId) allGroupIds.push(NODE_DATA[id].groupId); });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r?.groupId) allGroupIds.push(r.groupId); });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t?.groupId) allGroupIds.push(t.groupId); });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e?.groupId) allGroupIds.push(e.groupId); });
      const uniqueGroups = [...new Set(allGroupIds)];
      if (uniqueGroups.length === 1 && allGroupIds.length === totalItems) {
      nodesToGroup.forEach(id => { if (NODE_DATA[id]) NODE_DATA[id].groupId = null; });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r) r.groupId = null; });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t) t.groupId = null; });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e) e.groupId = null; });
      } else {
      const newGroupId = "group-" + Date.now();
      nodesToGroup.forEach(id => { if (NODE_DATA[id]) NODE_DATA[id].groupId = newGroupId; });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r) r.groupId = newGroupId; });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t) t.groupId = newGroupId; });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e) e.groupId = newGroupId; });
      }
      forgeTheTopology();
      }
      function handleKeyDown(event) {
       if (event.target.tagName === "INPUT" || event.target.tagName === "TEXTAREA" || event.target.isContentEditable) {
        return;
       }
       if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(event.key)) {
        event.preventDefault();
        const distance = event.shiftKey ? 10 : 1;
        nudgeSelectedNodes(event.key, distance);
       }
       if (event.key === "Tab") {
        event.preventDefault();
        cycleNodes(event.shiftKey);
       }
       if (event.key === "f" || event.key === "F") {
        event.preventDefault();
        focusOnSelected();
       }
       if (event.key === "l" || event.key === "L") {
        event.preventDefault();
        toggleLockSelected();
       }
       if (event.key === "g" || event.key === "G") {
        event.preventDefault();
        toggleGroupSelected();
       }
       if (event.ctrlKey && event.key === "z") {
        event.preventDefault();
        undo();
       }
       if ((event.ctrlKey && event.key === "y") || (event.ctrlKey && event.shiftKey && event.key === "z")) {
        event.preventDefault();
        redo();
       }
 if (event.ctrlKey && event.key === "c") {
        event.preventDefault();
        clipboard = null;
        if (currentNodeId && NODE_DATA[currentNodeId]) {
         clipboard = {
          type: "node",
          data: JSON.parse(JSON.stringify(NODE_DATA[currentNodeId])),
          size: savedSizes[currentNodeId],
          style: savedStyles[currentNodeId] ? JSON.parse(JSON.stringify(savedStyles[currentNodeId])) : null
         };
        } else if (currentEdgeId) {
         const edge = EDGE_DATA.list.find(e => e.id === currentEdgeId);
         if (edge) clipboard = { type: "edge", data: JSON.parse(JSON.stringify(edge)) };
        } else if (currentRectId) {
         const rect = RECT_DATA.list.find(r => r.id === currentRectId);
         if (rect) clipboard = { type: "rect", data: JSON.parse(JSON.stringify(rect)) };
        } else if (currentTextId) {
         const text = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (text) clipboard = { type: "text", data: JSON.parse(JSON.stringify(text)) };
        }
       }
       if (event.ctrlKey && event.key === "v") {
        event.preventDefault();
        if (!clipboard) return;
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        const centerX = canvasState.panX + (viewWidth / 2);
        const centerY = canvasState.panY + (viewHeight / 2);
        if (clipboard.type === "node") {
         const data = clipboard.data;
         let newName = data.name + " copy";
         let counter = 1;
         while (Object.values(NODE_DATA).some(n => n.name === newName)) {
          newName = data.name + " copy " + counter;
          counter++;
         }
         let newId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
         counter = 1;
         while (NODE_DATA[newId]) {
          newId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-") + "-" + counter;
          counter++;
         }
         pushUndo("paste node");
         NODE_DATA[newId] = { ...data, name: newName };
         savedPositions[newId] = { x: centerX, y: centerY };
         if (clipboard.size) savedSizes[newId] = clipboard.size;
         if (clipboard.style) savedStyles[newId] = JSON.parse(JSON.stringify(clipboard.style));
         forgeTheTopology();
         claimTheImmortal(newId);
        } else if (clipboard.type === "edge") {
         pushUndo("paste edge");
         const newEdge = { ...clipboard.data, id: "edge-" + Date.now() };
         EDGE_DATA.list.push(newEdge);
         forgeTheTopology();
         selectTheConnection(newEdge.id);
        } else if (clipboard.type === "rect") {
         pushUndo("paste rect");
         const newRect = { ...clipboard.data, id: "rect-" + Date.now(), x: centerX - (clipboard.data.width || 100) / 2, y: centerY - (clipboard.data.height || 100) / 2 };
         RECT_DATA.list.push(newRect);
         forgeTheTopology();
         selectTheRect(newRect.id);
        } else if (clipboard.type === "text") {
         pushUndo("paste text");
         const newText = { ...clipboard.data, id: "text-" + Date.now(), x: centerX, y: centerY };
         TEXT_DATA.list.push(newText);
         forgeTheTopology();
         showTextPanel(newText.id);
        }
       }
       if (event.key === "Delete") {
        event.preventDefault();
        const totalSelected = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
        if (totalSelected > 0) {
         deleteSelected();
        } else if (currentNodeId && NODE_DATA[currentNodeId]) {
         challengeTheImmortal(`Delete node "${NODE_DATA[currentNodeId].name}"?`, () => {
          pushUndo("delete node");
          delete NODE_DATA[currentNodeId];
          delete savedPositions[currentNodeId];
          delete savedSizes[currentNodeId];
          delete savedStyles[currentNodeId];
          EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== currentNodeId && e.to !== currentNodeId);
          currentNodeId = null;
          forgeTheTopology();
          document.getElementById("node-panel").style.display = "none";
         });
        } else if (currentEdgeId) {
         challengeTheImmortal("Delete this line?", () => {
          pushUndo("delete edge");
          EDGE_DATA.list = EDGE_DATA.list.filter(e => e.id !== currentEdgeId);
          currentEdgeId = null;
          forgeTheTopology();
          document.getElementById("edge-panel").style.display = "none";
         });
        } else if (currentRectId) {
         challengeTheImmortal("Delete this zone?", () => {
          pushUndo("delete rect");
          RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== currentRectId);
          currentRectId = null;
          forgeTheTopology();
          document.getElementById("rect-panel").style.display = "none";
         });
        } else if (currentTextId) {
         const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (textItem) {
          challengeTheImmortal(`Delete text "${textItem.content.substring(0, 30)}..."?`, () => {
           pushUndo("delete text");
           TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== currentTextId);
           currentTextId = null;
           forgeTheTopology();
           document.getElementById("text-panel").style.display = "none";
          });
         }
        }
       }
       if (event.ctrlKey && event.key === "a") {
        event.preventDefault();
        Object.keys(NODE_DATA).forEach(id => selectedNodes.add(id));
        EDGE_DATA.list.forEach(e => selectedEdges.add(e.id));
        RECT_DATA.list.forEach(r => selectedRects.add(r.id));
        TEXT_DATA.list.forEach(t => selectedTexts.add(t.id));
        updateAllSelections();
       }
       if (event.key === "Escape") {
        clearSelection();
        clearSearchHighlight();
       }
       if (event.ctrlKey && event.key === "d") {
        event.preventDefault();
        if (currentNodeId && NODE_DATA[currentNodeId]) {
         cloneNode(currentNodeId);
        } else if (currentEdgeId) {
         const edge = EDGE_DATA.list.find(e => e.id === currentEdgeId);
         if (edge) {
          pushUndo("clone edge");
          const newEdge = { ...JSON.parse(JSON.stringify(edge)), id: "edge-" + Date.now() };
          EDGE_DATA.list.push(newEdge);
          forgeTheTopology();
          selectTheConnection(newEdge.id);
         }
        } else if (currentRectId) {
         const rect = RECT_DATA.list.find(r => r.id === currentRectId);
         if (rect) {
          pushUndo("clone rect");
          const newRect = { ...JSON.parse(JSON.stringify(rect)), id: "rect-" + Date.now(), x: rect.x + 50, y: rect.y + 50 };
          RECT_DATA.list.push(newRect);
          forgeTheTopology();
          selectTheRect(newRect.id);
         }
        } else if (currentTextId) {
         const text = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (text) {
          pushUndo("clone text");
          const newText = { ...JSON.parse(JSON.stringify(text)), id: "text-" + Date.now(), x: text.x + 50, y: text.y + 50 };
          TEXT_DATA.list.push(newText);
          forgeTheTopology();
          showTextPanel(newText.id);
         }
        }
       }
      }
      function saveRollbackVersion(description = "Auto-save") {
        const version = {
          timestamp: Date.now(),
          description,
          data: captureTheQuickening()
        };
        try {
          const stored = localStorage.getItem(ROLLBACK_STORAGE_KEY);
          rollbackVersions = stored ? JSON.parse(stored) : [];
        } catch (e) {
          rollbackVersions = [];
        }
        rollbackVersions.unshift(version);
        if (rollbackVersions.length > MAX_ROLLBACK_VERSIONS) {
          rollbackVersions = rollbackVersions.slice(0, MAX_ROLLBACK_VERSIONS);
        }
        try {
          localStorage.setItem(ROLLBACK_STORAGE_KEY, JSON.stringify(rollbackVersions));
        } catch (e) {
          console.warn("Failed to save rollback version:", e);
        }
      }
      function loadRollbackVersions() {
        try {
          const stored = localStorage.getItem(ROLLBACK_STORAGE_KEY);
          rollbackVersions = stored ? JSON.parse(stored) : [];
          displayRollbackVersions();
        } catch (e) {
          console.warn("Failed to load rollback versions:", e);
          rollbackVersions = [];
        }
      }
      function displayRollbackVersions() {
        const listEl = document.getElementById("rollback-list");
        if (!listEl) return;
        if (rollbackVersions.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No version history yet. Versions are saved automatically when you save the file.</div>';
          return;
        }
        listEl.innerHTML = rollbackVersions.map((version, index) => {
          const date = new Date(version.timestamp);
          const timeStr = date.toLocaleString();
          const nodeCount = Object.keys(version.data.nodeData || {}).length;
          const edgeCount = (version.data.edgeData?.list || []).length;
          return `
            <div class="version-item" onclick="restoreRollbackVersion(${index})">
              <div class="version-info">
                <div class="timestamp">${timeStr}</div>
                <div class="details">${version.description} • ${nodeCount} nodes • ${edgeCount} connections</div>
              </div>
              <div class="version-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteRollbackVersion(${index})" title="Delete this version">🗑️</button>
              </div>
            </div>
          `;
        }).join('');
      }
      function restoreRollbackVersion(index) {
        if (!confirm(`Restore version from ${new Date(rollbackVersions[index].timestamp).toLocaleString()}?\n\nYour current work will be lost unless you save first.`)) {
          return;
        }
        const version = rollbackVersions[index];
        const data = version.data;
        NODE_DATA = data.nodeData || {};
        EDGE_DATA = data.edgeData || { list: [] };
        RECT_DATA = data.rectData || { list: [] };
        TEXT_DATA = data.textData || { list: [] };
        EDGE_LEGEND = data.edgeLegend || {};
        savedPositions = data.nodePositions || {};
        savedSizes = data.nodeSizes || {};
        savedStyles = data.nodeStyles || {};
        PAGE_STATE = data.page || PAGE_STATE;
        if (data.canvas) {
          canvasState.zoom = data.canvas.zoom;
          canvasState.panX = data.canvas.panX;
          canvasState.panY = data.canvas.panY;
        }
        wieldThePower();
        forgeTheTopology();
        document.getElementById("rollback-modal").classList.remove("active");
        logAuditEvent("rollback", `Restored version from ${new Date(version.timestamp).toLocaleString()}`);
      }
      function deleteRollbackVersion(index) {
        if (!confirm("Delete this version from history?")) return;
        rollbackVersions.splice(index, 1);
        try {
          localStorage.setItem(ROLLBACK_STORAGE_KEY, JSON.stringify(rollbackVersions));
        } catch (e) {
          console.warn("Failed to delete version:", e);
        }
        displayRollbackVersions();
      }
      function clearRollbackHistory() {
        if (!confirm("Clear all version history?\n\nThis cannot be undone.")) return;
        rollbackVersions = [];
        localStorage.removeItem(ROLLBACK_STORAGE_KEY);
        displayRollbackVersions();
      }
      function createManualSnapshot() {
        const description = prompt("Enter a description for this snapshot:", "Manual snapshot");
        if (!description) return;
        saveRollbackVersion(description);
        displayRollbackVersions();
      }
      function switchTab(index) {
        if (index === currentTabIndex) return;
        const currentTab = documentTabs[currentTabIndex];
        currentTab.nodes = JSON.parse(JSON.stringify(NODE_DATA));
        currentTab.edges = JSON.parse(JSON.stringify(EDGE_DATA));
        currentTab.positions = JSON.parse(JSON.stringify(savedPositions));
        currentTab.sizes = JSON.parse(JSON.stringify(savedSizes));
        currentTab.styles = JSON.parse(JSON.stringify(savedStyles));
        currentTab.legend = JSON.parse(JSON.stringify(EDGE_LEGEND));
        currentTab.rects = JSON.parse(JSON.stringify(RECT_DATA));
        currentTab.texts = JSON.parse(JSON.stringify(TEXT_DATA));
        currentTab.pageState = JSON.parse(JSON.stringify(PAGE_STATE));
        currentTabIndex = index;
        const newTab = documentTabs[index];
        NODE_DATA = JSON.parse(JSON.stringify(newTab.nodes));
        EDGE_DATA = JSON.parse(JSON.stringify(newTab.edges));
        savedPositions = JSON.parse(JSON.stringify(newTab.positions));
        savedSizes = JSON.parse(JSON.stringify(newTab.sizes));
        savedStyles = JSON.parse(JSON.stringify(newTab.styles));
        EDGE_LEGEND = JSON.parse(JSON.stringify(newTab.legend));
        RECT_DATA = JSON.parse(JSON.stringify(newTab.rects));
        TEXT_DATA = JSON.parse(JSON.stringify(newTab.texts));
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, newTab.pageState || {});
        wieldThePower();
        document.title = PAGE_STATE.title || newTab.name;
        document.getElementById("page-title").textContent = PAGE_STATE.title || newTab.name;
        forgeTheTopology();
        currentNodeId = null;
        currentEdgeId = null;
        currentTextId = null;
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        displayTabs();
        logAuditEvent("tab", `Switched to tab: ${newTab.name}`);
      }
      function createNewTab() {
        const nameInput = document.getElementById("new-tab-name");
        const name = nameInput.value.trim();
        if (!name) {
          alert("Please enter a tab name");
          return;
        }
        const newTab = {
          id: `tab-${Date.now()}`,
          name,
          nodes: {},
          edges: { list: [] },
          positions: {},
          sizes: {},
          styles: {},
          legend: {},
          rects: { list: [] },
          texts: { list: [] },
      pageState: null
        };
        documentTabs.push(newTab);
        nameInput.value = "";
        displayTabs();
        logAuditEvent("tab", `Created new tab: ${name}`);
      }
      function renameTab(index) {
        const tab = documentTabs[index];
        const newName = prompt("Enter new name:", tab.name);
        if (!newName || newName === tab.name) return;
        tab.name = newName;
        displayTabs();
        logAuditEvent("tab", `Renamed tab to: ${newName}`);
      }
      function deleteTab(index) {
        if (documentTabs.length === 1) {
          alert("Cannot delete the last tab");
          return;
        }
        if (!confirm(`Delete tab "${documentTabs[index].name}"?`)) return;
        const wasCurrentTab = (index === currentTabIndex);
        documentTabs.splice(index, 1);
        if (currentTabIndex >= documentTabs.length) {
          currentTabIndex = documentTabs.length - 1;
        } else if (index < currentTabIndex) {
          currentTabIndex--;
        }
        if (wasCurrentTab) {
          const newTab = documentTabs[currentTabIndex];
          NODE_DATA = JSON.parse(JSON.stringify(newTab.nodes));
          EDGE_DATA = JSON.parse(JSON.stringify(newTab.edges));
          savedPositions = JSON.parse(JSON.stringify(newTab.positions));
          savedSizes = JSON.parse(JSON.stringify(newTab.sizes));
          savedStyles = JSON.parse(JSON.stringify(newTab.styles));
          EDGE_LEGEND = JSON.parse(JSON.stringify(newTab.legend));
          RECT_DATA = JSON.parse(JSON.stringify(newTab.rects));
          TEXT_DATA = JSON.parse(JSON.stringify(newTab.texts));
          PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, newTab.pageState || {});
          wieldThePower();
          forgeTheTopology();
          currentNodeId = null;
          currentEdgeId = null;
          currentTextId = null;
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("text-panel").style.display = "none";
        }
        displayTabs();
        logAuditEvent("tab", `Deleted tab`);
      }
      function displayTabs() {
        const listEl = document.getElementById("tabs-list");
        if (!listEl) return;
        listEl.innerHTML = documentTabs.map((tab, index) => {
          const nodeCount = Object.keys(tab.nodes).length;
          const edgeCount = tab.edges.list.length;
          const isActive = index === currentTabIndex;
          return `
            <div class="tab-item ${isActive ? 'active' : ''}" onclick="switchTab(${index})">
              <div class="tab-name">${tab.name}</div>
              <div class="tab-stats">${nodeCount} nodes • ${edgeCount} connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(${index})" title="Rename tab">✏️</button>
                ${documentTabs.length > 1 ? '<button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(' + index + ')" title="Delete tab">🗑️</button>' : ''}
              </div>
            </div>
          `;
        }).join('');
      }
      function logAuditEvent(type, description, details = {}) {
        const event = {
          timestamp: Date.now(),
          type,
          description,
          details,
          tab: documentTabs[currentTabIndex]?.name || "Main"
        };
        auditLog.unshift(event);
        if (auditLog.length > MAX_AUDIT_ENTRIES) {
          auditLog = auditLog.slice(0, MAX_AUDIT_ENTRIES);
        }
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to save audit log:", e);
        }
      }
      function loadAuditLog() {
        let embeddedLog = [];
        let localLog = [];
        try {
          const stateScript = document.getElementById("topology-state");
          if (stateScript) {
            const stateData = JSON.parse(stateScript.textContent);
            if (stateData.auditLog && Array.isArray(stateData.auditLog)) {
              embeddedLog = stateData.auditLog;
            }
          }
        } catch (e) {
          console.warn("Failed to load embedded audit log:", e);
        }
        try {
          const stored = localStorage.getItem(AUDIT_STORAGE_KEY);
          if (stored) {
            localLog = JSON.parse(stored);
          }
        } catch (e) {
          console.warn("Failed to load localStorage audit log:", e);
        }
        const merged = [...embeddedLog, ...localLog];
        const seen = new Set();
        auditLog = merged.filter(entry => {
          const key = entry.timestamp + entry.description;
          if (seen.has(key)) return false;
          seen.add(key);
          return true;
        }).sort((a, b) => b.timestamp - a.timestamp);
        if (auditLog.length > MAX_AUDIT_ENTRIES) {
          auditLog = auditLog.slice(0, MAX_AUDIT_ENTRIES);
        }
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to sync audit log:", e);
        }
      }
      function displayAuditLog(filter = "all") {
        const listEl = document.getElementById("audit-log-list");
        if (!listEl) return;
        const filtered = filter === "all" ? auditLog : auditLog.filter(e => e.type === filter);
        if (filtered.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No audit entries yet</div>';
          return;
        }
        listEl.innerHTML = filtered.map(event => {
          const date = new Date(event.timestamp);
          const timeStr = date.toLocaleString();
          return `
            <div class="audit-entry ${event.type}">
              <div class="time">[${timeStr}] ${event.tab}</div>
              <div class="action">[${event.type.toUpperCase()}] ${event.description}</div>
            </div>
          `;
        }).join('');
      }
      function clearAuditLog() {
        if (!confirm("Clear all audit log entries?\n\nThis cannot be undone.")) return;
        auditLog = [];
        localStorage.removeItem(AUDIT_STORAGE_KEY);
        displayAuditLog();
      }
      function exportAuditLog() {
        if (auditLog.length === 0) {
          alert("No audit entries to export");
          return;
        }
        const csv = [
          ["Timestamp", "Tab", "Type", "Description"],
          ...auditLog.map(e => [
            new Date(e.timestamp).toISOString(),
            e.tab,
            e.type,
            e.description
          ])
        ].map(row => row.map(cell => `"${cell}"`).join(",")).join("\n");
        const blob = new Blob([csv], { type: "text/csv" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `audit-log-${Date.now()}.csv`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }
      let currentSecretName = null;
      function createNewSecret() {
        const nameInput = document.getElementById("new-secret-name");
        const name = nameInput.value.trim();
        if (!name) {
          alert("Please enter a note name");
          return;
        }
        if (encryptedSections[name]) {
          alert("A note with this name already exists");
          return;
        }
        currentSecretName = name;
        encryptedSections[name] = { encrypted: false, data: "" };
        nameInput.value = "";
        document.getElementById("secret-editor-title").textContent = `New note: ${name}`;
        document.getElementById("secret-editor-content").value = "";
        document.getElementById("secrets-modal").classList.remove("active");
        document.getElementById("secret-editor-modal").classList.add("active");
        displaySecrets();
      }
      function editSecret(name) {
        currentSecretName = name;
        const section = encryptedSections[name];
        if (section.encrypted) {
          const password = prompt(`Enter password to decrypt "${name}":`);
          if (!password) return;
          try {
            decryptData(section.data, password).then(decrypted => {
              document.getElementById("secret-editor-title").textContent = `Edit note: ${name}`;
              document.getElementById("secret-editor-content").value = decrypted;
              document.getElementById("secrets-modal").classList.remove("active");
              document.getElementById("secret-editor-modal").classList.add("active");
            }).catch(e => {
              alert("Failed to decrypt. Wrong password?");
            });
          } catch (e) {
            alert("Failed to decrypt. Wrong password?");
          }
        } else {
          document.getElementById("secret-editor-title").textContent = `Edit note: ${name}`;
          document.getElementById("secret-editor-content").value = section.data;
          document.getElementById("secrets-modal").classList.remove("active");
          document.getElementById("secret-editor-modal").classList.add("active");
        }
      }
      async function saveSecret() {
        if (!currentSecretName) return;
        const content = document.getElementById("secret-editor-content").value;
        const autoEncrypt = document.getElementById("secret-auto-encrypt").checked;
        if (autoEncrypt) {
          const password = prompt(`Enter password to encrypt "${currentSecretName}":`);
          if (!password) return;
          const confirmPassword = prompt("Confirm password:");
          if (password !== confirmPassword) {
            alert("Passwords do not match");
            return;
          }
          try {
            const encrypted = await encryptData(content, password);
            encryptedSections[currentSecretName] = { encrypted: true, data: encrypted };
          } catch (e) {
            alert("Encryption failed: " + e.message);
            return;
          }
        } else {
          encryptedSections[currentSecretName] = { encrypted: false, data: content };
        }
        closeSecretEditor();
        displaySecrets();
        logAuditEvent("secret", `Saved note: ${currentSecretName}`);
      }
      function closeSecretEditor() {
        document.getElementById("secret-editor-modal").classList.remove("active");
        document.getElementById("secrets-modal").classList.add("active");
        currentSecretName = null;
      }
      function deleteSecret(name) {
        if (!confirm(`Delete note "${name}"?`)) return;
        delete encryptedSections[name];
        displaySecrets();
        logAuditEvent("secret", `Deleted note: ${name}`);
      }
      function displaySecrets() {
        const listEl = document.getElementById("secrets-list");
        if (!listEl) return;
        const secrets = Object.keys(encryptedSections);
        if (secrets.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No notes yet</div>';
          return;
        }
        listEl.innerHTML = secrets.map(name => {
          const section = encryptedSections[name];
          const status = section.encrypted ? "🔒 Encrypted" : "🔓 Plaintext";
          return `
            <div class="secret-item">
              <div class="secret-name">${name}</div>
              <div class="secret-status">${status}</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="editSecret('${name}')" title="Edit note">✏️</button>
                <button class="btn-cancel" onclick="deleteSecret('${name}')" title="Delete note">🗑️</button>
              </div>
            </div>
          `;
        }).join('');
      }
      let rafId = null;
      let lastRender = 0;
      const RENDER_THROTTLE = 16;
      function setupDragToCreate() {
        const addNodeBtn = document.getElementById("add-node-btn");
        const addRackBtn = document.getElementById("add-rack-btn");
        const canvas = document.getElementById("map");
        if (!addNodeBtn || !addRackBtn || !canvas) return;
        let dragType = null;
        [addNodeBtn, addRackBtn].forEach(btn => {
          btn.setAttribute("draggable", "true");
          btn.addEventListener("dragstart", e => {
            dragType = btn.id === "add-node-btn" ? "node" : "rack";
            e.dataTransfer.effectAllowed = "copy";
            e.dataTransfer.setData("text/plain", dragType);
          });
        });
        canvas.addEventListener("dragover", e => {
          if (dragType) {
            e.preventDefault();
            e.dataTransfer.dropEffect = "copy";
          }
        });
        canvas.addEventListener("drop", e => {
          if (!dragType) return;
          e.preventDefault();
          const rect = canvas.getBoundingClientRect();
          const x = (e.clientX - rect.left) / canvasState.zoom + canvasState.panX;
          const y = (e.clientY - rect.top) / canvasState.zoom + canvasState.panY;
          if (dragType === "node") {
            createNodeAtPosition(x, y);
          } else if (dragType === "rack") {
            createRackAtPosition(x, y);
          }
          dragType = null;
        });
      }
      function createNodeAtPosition(x, y) {
        const timestamp = Date.now();
        const newId = `host-${timestamp}`;
		pushUndo("create node");
        NODE_DATA[newId] = {
          name: "New Node",
          ip: "0.0.0.0",
          shape: "server",
          role: "",
          tags: [],
          notes: "",
          layer: "physical",
          isRack: false
        };
        savedPositions[newId] = { x, y };
        savedSizes[newId] = 55;
        forgeTheTopology();
        claimTheImmortal(newId);
        logAuditEvent("node", `Created node at (${Math.round(x)}, ${Math.round(y)})`);
      }
      function createRackAtPosition(x, y) {
        const timestamp = Date.now();
        const newId = `rack-${timestamp}`;
		pushUndo("create rack");
        NODE_DATA[newId] = {
          name: "New Rack",
          ip: "",
          shape: "server",
          role: "rack",
          tags: [],
          notes: "",
          layer: "physical",
          isRack: true,
          rackCapacity: 42
        };
        savedPositions[newId] = { x, y };
        savedSizes[newId] = 55;
        populateRackDropdown();
        forgeTheTopology();
        claimTheImmortal(newId);
        logAuditEvent("rack", `Created rack at (${Math.round(x)}, ${Math.round(y)})`);
      }
      document.addEventListener("keydown", handleKeyDown);
      document.getElementById("save-file-btn").addEventListener("click", becomeImmortal);
      const addNodeBtn = document.getElementById("add-node-btn");
      const addNodeModal = document.getElementById("add-node-modal");
      const addNodeCancel = document.getElementById("add-node-cancel");
      const addNodeSave = document.getElementById("add-node-save");
      const undoBtn = document.getElementById("undo-btn");
      const redoBtn = document.getElementById("redo-btn");
      if (undoBtn) undoBtn.addEventListener("click", undo);
      if (redoBtn) redoBtn.addEventListener("click", redo);
      const backToTopologyBtn = document.getElementById("back-to-topology-btn");
      if (backToTopologyBtn) {
       backToTopologyBtn.addEventListener("click", exitRack);
      }
      const canvasViewport = document.getElementById("canvas-viewport");
      if (canvasViewport) {
       canvasViewport.addEventListener("dblclick", (e) => {
        if (currentView.mode === "rack" && e.target.id === "map") {
         exitRack();
        }
       });
      }
      const layersBtn = document.getElementById("layers-btn");
      const layerModal = document.getElementById("layer-modal");
      const layerModalClose = document.getElementById("layer-modal-close");
      if (layersBtn && layerModal) {
       layersBtn.addEventListener("click", () => {
        layerModal.classList.add("active");
       });
      }
      if (layerModalClose && layerModal) {
       layerModalClose.addEventListener("click", () => {
        layerModal.classList.remove("active");
       });
      }
      if (layerModal) {
       layerModal.addEventListener("click", (e) => {
        if (e.target === layerModal) {
         layerModal.classList.remove("active");
        }
       });
      }
      ["physical", "logical", "security", "application"].forEach(layer => {
       const checkbox = document.getElementById(`layer-${layer}`);
       if (checkbox) {
        checkbox.addEventListener("change", applyLayerFilter);
       }
      });
      const tabsBtn = document.getElementById("tabs-btn");
      const tabsModal = document.getElementById("tabs-modal");
      const tabsModalClose = document.getElementById("tabs-modal-close");
      if (tabsBtn && tabsModal) {
        tabsBtn.addEventListener("click", () => {
          displayTabs();
          tabsModal.classList.add("active");
        });
      }
      if (tabsModalClose && tabsModal) {
        tabsModalClose.addEventListener("click", () => {
          tabsModal.classList.remove("active");
        });
      }
      if (tabsModal) {
        tabsModal.addEventListener("click", (e) => {
          if (e.target === tabsModal) {
            tabsModal.classList.remove("active");
          }
        });
      }
      const rollbackBtn = document.getElementById("rollback-btn");
      const rollbackModal = document.getElementById("rollback-modal");
      const rollbackModalClose = document.getElementById("rollback-modal-close");
      if (rollbackBtn && rollbackModal) {
        rollbackBtn.addEventListener("click", () => {
          loadRollbackVersions();
          rollbackModal.classList.add("active");
        });
      }
      if (rollbackModalClose && rollbackModal) {
        rollbackModalClose.addEventListener("click", () => {
          rollbackModal.classList.remove("active");
        });
      }
      if (rollbackModal) {
        rollbackModal.addEventListener("click", (e) => {
          if (e.target === rollbackModal) {
            rollbackModal.classList.remove("active");
          }
        });
      }
      const auditLogBtn = document.getElementById("audit-log-btn");
      const auditLogModal = document.getElementById("audit-log-modal");
      const auditLogModalClose = document.getElementById("audit-log-modal-close");
      const auditFilter = document.getElementById("audit-filter");
      if (auditLogBtn && auditLogModal) {
        auditLogBtn.addEventListener("click", () => {
          loadAuditLog();
          displayAuditLog();
          auditLogModal.classList.add("active");
        });
      }
      if (auditFilter) {
        auditFilter.addEventListener("change", (e) => {
          displayAuditLog(e.target.value);
        });
      }
      if (auditLogModalClose && auditLogModal) {
        auditLogModalClose.addEventListener("click", () => {
          auditLogModal.classList.remove("active");
        });
      }
	  const portMapBtn = document.getElementById("port-map-btn");
      const portMapModal = document.getElementById("port-map-modal");
      const portMapClose = document.getElementById("port-map-modal-close");
      const portMapSearch = document.getElementById("port-map-search");
      const portMapFilter = document.getElementById("port-map-filter");
      function renderPortMap() {
        const container = document.getElementById("port-map-table");
        const search = (document.getElementById("port-map-search")?.value || "").toLowerCase();
        const filter = document.getElementById("port-map-filter")?.value || "all";
        let edges = EDGE_DATA.list || [];
        if (filter === "with-ports") edges = edges.filter(e => e.fromPort || e.toPort);
        if (filter === "without-ports") edges = edges.filter(e => !e.fromPort && !e.toPort);
        if (search) {
          edges = edges.filter(e => {
            const fromName = (NODE_DATA[e.from]?.name || e.from || "").toLowerCase();
            const toName = (NODE_DATA[e.to]?.name || e.to || "").toLowerCase();
            return fromName.includes(search) || toName.includes(search) || (e.fromPort || "").toLowerCase().includes(search) || (e.toPort || "").toLowerCase().includes(search) || (e.notes || []).join(" ").toLowerCase().includes(search);
          });
        }
        if (edges.length === 0) {
          container.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No connections found</div>';
          return;
        }
        let html = '<table style="width: 100%; border-collapse: collapse; font-size: 13px;">';
        html += '<thead><tr style="background: var(--panel-alt); position: sticky; top: 0;"><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">From Device</th><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">From Port</th><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">To Device</th><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">To Port</th><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">Notes</th></tr></thead><tbody>';
        edges.forEach(e => {
          const fromName = NODE_DATA[e.from]?.name || e.from;
          const toName = NODE_DATA[e.to]?.name || e.to;
          const notes = (e.notes || []).join(", ");
          html += `<tr style="border-bottom: 1px solid var(--edge-main);"><td style="padding: 10px; cursor: pointer; text-decoration: underline;" onclick="document.getElementById('port-map-modal').classList.remove('active'); claimTheImmortal('${e.from}'); focusOnSelected()">${fromName}</td><td style="padding: 10px; font-family: monospace; color: var(--accent); cursor: pointer;" onclick="document.getElementById('port-map-modal').classList.remove('active'); selectTheConnection('${e.id}'); focusOnSelected()">${e.fromPort || "-"}</td><td style="padding: 10px; cursor: pointer; text-decoration: underline;" onclick="document.getElementById('port-map-modal').classList.remove('active'); claimTheImmortal('${e.to}'); focusOnSelected()">${toName}</td><td style="padding: 10px; font-family: monospace; color: var(--accent); cursor: pointer;" onclick="document.getElementById('port-map-modal').classList.remove('active'); selectTheConnection('${e.id}'); focusOnSelected()">${e.toPort || "-"}</td><td style="padding: 10px; color: var(--text-soft); font-size: 12px;">${notes || "-"}</td></tr>`;
        });
        html += '</tbody></table>';
        container.innerHTML = html;
      }
      window.exportPortMap = function() {
        let csv = "From Device,From Port,To Device,To Port,Notes\n";
        (EDGE_DATA.list || []).forEach(e => {
          const fromName = (NODE_DATA[e.from]?.name || e.from || "").replace(/,/g, ";");
          const toName = (NODE_DATA[e.to]?.name || e.to || "").replace(/,/g, ";");
          const notes = (e.notes || []).join("; ").replace(/,/g, ";");
          csv += `"${fromName}","${e.fromPort || ""}","${toName}","${e.toPort || ""}","${notes}"\n`;
        });
        const blob = new Blob([csv], { type: "text/csv" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "port-map.csv";
        a.click();
        URL.revokeObjectURL(url);
      };
      if (portMapBtn && portMapModal) {
        portMapBtn.addEventListener("click", () => { renderPortMap(); portMapModal.classList.add("active"); });
      }
      if (portMapClose && portMapModal) {
        portMapClose.addEventListener("click", () => { portMapModal.classList.remove("active"); });
      }
      if (portMapSearch) { portMapSearch.addEventListener("input", renderPortMap); }
      if (portMapFilter) { portMapFilter.addEventListener("change", renderPortMap); }
      if (portMapModal) {
        portMapModal.addEventListener("click", (e) => { if (e.target === portMapModal) portMapModal.classList.remove("active"); });
      }
      if (auditLogModal) {
        auditLogModal.addEventListener("click", (e) => {
          if (e.target === auditLogModal) {
            auditLogModal.classList.remove("active");
          }
        });
      }
      const secretsBtn = document.getElementById("secrets-btn");
      const secretsModal = document.getElementById("secrets-modal");
      const secretsModalClose = document.getElementById("secrets-modal-close");
      const secretEditorModal = document.getElementById("secret-editor-modal");
      if (secretsBtn && secretsModal) {
        secretsBtn.addEventListener("click", () => {
          displaySecrets();
          secretsModal.classList.add("active");
        });
      }
      if (secretsModalClose && secretsModal) {
        secretsModalClose.addEventListener("click", () => {
          secretsModal.classList.remove("active");
        });
      }
      if (secretsModal) {
        secretsModal.addEventListener("click", (e) => {
          if (e.target === secretsModal) {
            secretsModal.classList.remove("active");
          }
        });
      }
      if (secretEditorModal) {
        secretEditorModal.addEventListener("click", (e) => {
          if (e.target === secretEditorModal) {
            closeSecretEditor();
          }
        });
      }
      loadAuditLog();
      setupDragToCreate();
      ["physical", "logical", "security", "application"].forEach(layer => {
       const checkbox = document.getElementById(`layer-${layer}`);
       if (checkbox) {
        checkbox.addEventListener("change", applyLayerFilter);
       }
      });
      const layerSelect = document.getElementById("node-layer");
      if (layerSelect) {
       layerSelect.addEventListener("change", (e) => {
        if (currentNodeId) {
         pushUndo("change layer");
         NODE_DATA[currentNodeId].layer = e.target.value;
         forgeTheTopology();
        }
       });
      }
       const assignedRackSelect = document.getElementById("node-assigned-rack");
       if (assignedRackSelect) {
      assignedRackSelect.addEventListener("change", (e) => {
      if (currentNodeId) {
      pushUndo("change assigned rack");
      EDGE_DATA.list = EDGE_DATA.list.filter(edge => edge.from !== currentNodeId && edge.to !== currentNodeId);
      NODE_DATA[currentNodeId].assignedRack = e.target.value;
      forgeTheTopology();
      claimTheImmortal(currentNodeId);
      }
      });
       }
      const rackCapacitySelect = document.getElementById("node-rack-capacity");
      if (rackCapacitySelect) {
       rackCapacitySelect.addEventListener("change", (e) => {
        if (currentNodeId) {
         pushUndo("change rack capacity");
         NODE_DATA[currentNodeId].rackCapacity = e.target.value;
         forgeTheTopology();
        }
       });
      }
      const bulkToolbarClose = document.getElementById("bulk-toolbar-close");
      if (bulkToolbarClose) {
       bulkToolbarClose.addEventListener("click", clearSelection);
      }
      const bulkAlignLeft = document.getElementById("bulk-align-left");
      if (bulkAlignLeft) {
       bulkAlignLeft.addEventListener("click", () => alignSelectedNodes("left"));
      }
      const bulkAlignRight = document.getElementById("bulk-align-right");
      if (bulkAlignRight) {
       bulkAlignRight.addEventListener("click", () => alignSelectedNodes("right"));
      }
      const bulkAlignTop = document.getElementById("bulk-align-top");
      if (bulkAlignTop) {
       bulkAlignTop.addEventListener("click", () => alignSelectedNodes("top"));
      }
      const bulkAlignBottom = document.getElementById("bulk-align-bottom");
      if (bulkAlignBottom) {
       bulkAlignBottom.addEventListener("click", () => alignSelectedNodes("bottom"));
      }
      const bulkDistributeH = document.getElementById("bulk-distribute-h");
      if (bulkDistributeH) {
       bulkDistributeH.addEventListener("click", () => distributeSelectedNodes("horizontal"));
      }
      const bulkDistributeV = document.getElementById("bulk-distribute-v");
      if (bulkDistributeV) {
       bulkDistributeV.addEventListener("click", () => distributeSelectedNodes("vertical"));
      }
      const bulkClone = document.getElementById("bulk-clone");
      if (bulkClone) {
       bulkClone.addEventListener("click", () => {
        if (selectedNodes.size === 0) return;
        pushUndo("clone selected");
        const nodesToClone = Array.from(selectedNodes);
        selectedNodes.clear();
        nodesToClone.forEach(id => {
         cloneNode(id, true);
         selectedNodes.add(currentNodeId);
        });
        updateNodeSelection();
       });
      }
      const bulkDelete = document.getElementById("bulk-delete");
      if (bulkDelete) {
       bulkDelete.addEventListener("click", deleteSelected);
      }
      const bulkMobileBtn = document.getElementById("bulk-mobile-btn");
      const bulkActionsModal = document.getElementById("bulk-actions-modal");
      const bulkModalClose = document.getElementById("bulk-modal-close");
      if (bulkMobileBtn) {
       bulkMobileBtn.addEventListener("click", () => {
        if (bulkActionsModal) bulkActionsModal.style.display = "block";
       });
      }
      if (bulkModalClose) {
       bulkModalClose.addEventListener("click", () => {
        if (bulkActionsModal) bulkActionsModal.style.display = "none";
       });
      }
      const closeModalAfterAction = () => {
       if (bulkActionsModal) bulkActionsModal.style.display = "none";
      };
      const bulkAlignLeftMobile = document.getElementById("bulk-align-left-mobile");
      if (bulkAlignLeftMobile) {
       bulkAlignLeftMobile.addEventListener("click", () => {
        alignSelectedNodes("left");
        closeModalAfterAction();
       });
      }
      const bulkAlignRightMobile = document.getElementById("bulk-align-right-mobile");
      if (bulkAlignRightMobile) {
       bulkAlignRightMobile.addEventListener("click", () => {
        alignSelectedNodes("right");
        closeModalAfterAction();
       });
      }
      const bulkAlignTopMobile = document.getElementById("bulk-align-top-mobile");
      if (bulkAlignTopMobile) {
       bulkAlignTopMobile.addEventListener("click", () => {
        alignSelectedNodes("top");
        closeModalAfterAction();
       });
      }
      const bulkAlignBottomMobile = document.getElementById("bulk-align-bottom-mobile");
      if (bulkAlignBottomMobile) {
       bulkAlignBottomMobile.addEventListener("click", () => {
        alignSelectedNodes("bottom");
        closeModalAfterAction();
       });
      }
      const bulkDistributeHMobile = document.getElementById("bulk-distribute-h-mobile");
      if (bulkDistributeHMobile) {
       bulkDistributeHMobile.addEventListener("click", () => {
        distributeSelectedNodes("horizontal");
        closeModalAfterAction();
       });
      }
      const bulkDistributeVMobile = document.getElementById("bulk-distribute-v-mobile");
      if (bulkDistributeVMobile) {
       bulkDistributeVMobile.addEventListener("click", () => {
        distributeSelectedNodes("vertical");
        closeModalAfterAction();
       });
      }
      const bulkCloneMobile = document.getElementById("bulk-clone-mobile");
      if (bulkCloneMobile) {
       bulkCloneMobile.addEventListener("click", () => {
        if (selectedNodes.size === 0) return;
        pushUndo("clone selected");
        const nodesToClone = Array.from(selectedNodes);
        selectedNodes.clear();
        nodesToClone.forEach(id => {
         cloneNode(id);
         selectedNodes.add(currentNodeId);
        });
        updateNodeSelection();
        closeModalAfterAction();
       });
      }
      const bulkDeleteMobile = document.getElementById("bulk-delete-mobile");
      if (bulkDeleteMobile) {
       bulkDeleteMobile.addEventListener("click", () => {
        deleteSelected();
        closeModalAfterAction();
       });
      }
      const bulkLockMobile = document.getElementById("bulk-lock-mobile");
      if (bulkLockMobile) {
       bulkLockMobile.addEventListener("click", () => {
        toggleLockSelected();
        closeModalAfterAction();
       });
      }
      const bulkGroupMobile = document.getElementById("bulk-group-mobile");
      if (bulkGroupMobile) {
       bulkGroupMobile.addEventListener("click", () => {
        toggleGroupSelected();
        closeModalAfterAction();
       });
      }
      const bulkClearMobile = document.getElementById("bulk-clear-mobile");
      if (bulkClearMobile) {
       bulkClearMobile.addEventListener("click", () => {
        clearSelection();
        closeModalAfterAction();
       });
      }
      const searchInput = document.getElementById("search-nodes");
      if (searchInput) {
       searchInput.addEventListener("input", (e) => {
        searchNodes(e.target.value);
       });
      }
      addNodeBtn.addEventListener("click", () => {
	  if (isViewOnly()) return;
       document.getElementById("new-node-name").value = "";
       document.getElementById("new-node-ip").value = "";
       document.getElementById("new-node-tags").value = "";
       document.getElementById("new-node-shape").value = "circle";
       addNodeModal.classList.add("active");
       document.getElementById("new-node-name").focus();
      });
      const addRackBtn = document.getElementById("add-rack-btn");
      const addRackModal = document.getElementById("add-rack-modal");
      const addRackCancel = document.getElementById("add-rack-cancel");
      const addRackSave = document.getElementById("add-rack-save");
      if (addRackBtn && addRackModal) {
       addRackBtn.addEventListener("click", () => {
	   if (isViewOnly()) return;
        document.getElementById("new-rack-name").value = "";
        document.getElementById("new-rack-ip").value = "";
        document.getElementById("new-rack-tags").value = "";
        document.getElementById("new-rack-shape").value = "server";
        document.getElementById("new-rack-capacity").value = "42";
        addRackModal.classList.add("active");
        document.getElementById("new-rack-name").focus();
       });
      }
      if (addRackCancel && addRackModal) {
       addRackCancel.addEventListener("click", () => {
        addRackModal.classList.remove("active");
       });
      }
      if (addRackModal) {
       addRackModal.addEventListener("click", (e) => {
        if (e.target === addRackModal) {
         addRackModal.classList.remove("active");
        }
       });
      }
      if (addRackSave && addRackModal) {
       addRackSave.addEventListener("click", () => {
        const name = document.getElementById("new-rack-name").value.trim();
        const ip = document.getElementById("new-rack-ip").value.trim();
        const tagsStr = document.getElementById("new-rack-tags").value.trim();
        const shape = document.getElementById("new-rack-shape").value;
        const capacity = document.getElementById("new-rack-capacity").value;
        if (!name) {
         alert("Please enter a rack name.");
         return;
        }
        const tags = tagsStr ? tagsStr.split(",").map((t) => t.trim()).filter((t) => t) : [];
        let baseId = name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");
        if (!baseId) baseId = "rack";
        let nodeId = baseId;
        let counter = 1;
        while (NODE_DATA[nodeId]) {
         nodeId = baseId + "-" + counter;
         counter++;
        }
        pushUndo("add rack");
        NODE_DATA[nodeId] = {
         shape: shape,
         name: name,
         ip: ip || "",
         role: "Rack",
         tags: tags,
         notes: [],
         mac: "",
         rackUnit: "",
         uHeight: "1",
         layer: "physical",
         assignedRack: "",
         rackCapacity: capacity,
         isRack: true,
         locked: false,
         groupId: null
        };
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        const centerX = canvasState.panX + (viewWidth / 2);
        const centerY = canvasState.panY + (viewHeight / 2);
        savedPositions[nodeId] = {
         x: centerX,
         y: centerY
        };
        addRackModal.classList.remove("active");
        forgeTheTopology();
        claimTheImmortal(nodeId);
       });
       ["new-rack-name", "new-rack-ip", "new-rack-tags"].forEach((inputId) => {
        const input = document.getElementById(inputId);
        if (input) {
         input.addEventListener("keypress", (e) => {
          if (e.key === "Enter") {
           addRackSave.click();
          }
         });
        }
       });
      }
      addNodeCancel.addEventListener("click", () => {
       addNodeModal.classList.remove("active");
      });
      addNodeModal.addEventListener("click", (e) => {
       if (e.target === addNodeModal) {
        addNodeModal.classList.remove("active");
       }
      });
      addNodeSave.addEventListener("click", () => {
       const name = document.getElementById("new-node-name").value.trim();
       const ip = document.getElementById("new-node-ip").value.trim();
       const tagsStr = document.getElementById("new-node-tags").value.trim();
       const shape = document.getElementById("new-node-shape").value;
       if (!name) {
        alert("Please enter a node name.");
        return;
       }
       const tags = tagsStr ? tagsStr.split(",").map((t) => t.trim()).filter((t) => t) : [];
       let baseId = name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");
       if (!baseId) baseId = "node";
       let nodeId = baseId;
       let counter = 1;
       while (NODE_DATA[nodeId]) {
        nodeId = baseId + "-" + counter;
        counter++;
       }
	   pushUndo("add node");
       NODE_DATA[nodeId] = {
        shape: shape || "circle",
        name: name,
        ip: ip || "0.0.0.0",
        role: "",
        tags: tags,
        notes: [],
        mac: "",
        rackUnit: "",
        uHeight: "1",
        layer: "physical",
        assignedRack: "",
        rackCapacity: "42",
        isRack: false,
        locked: false,
        groupId: null
       };
       if (currentView.mode === "rack" && currentView.rackId) {
        NODE_DATA[nodeId].assignedRack = currentView.rackId;
        NODE_DATA[nodeId].layer = "physical";
        const rackCapacity = getRackCapacity(currentView.rackId);
        const rackUHeight = getRackUHeight(currentView.rackId);
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        const centerY = canvasState.panY + (viewHeight / 2);
        let unit = rackCapacity - Math.round((centerY - RACK_START_Y) / rackUHeight);
        unit = Math.max(1, Math.min(rackCapacity, unit));
        NODE_DATA[nodeId].rackUnit = String(unit);
       }
      const viewWidth = CANVAS_WIDTH / canvasState.zoom;
      const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
      const centerX = canvasState.panX + (viewWidth / 2);
      const centerY = canvasState.panY + (viewHeight / 2);
      savedPositions[nodeId] = {
      x: centerX,
      y: centerY
      };
       addNodeModal.classList.remove("active");
       forgeTheTopology();
       claimTheImmortal(nodeId);
      });
      ["new-node-name", "new-node-ip", "new-node-tags"].forEach(
       (inputId) => {
        document.getElementById(inputId).addEventListener("keypress", (e) => {
         if (e.key === "Enter") {
          addNodeSave.click();
         }
        });
       }, );
      const clearAllBtn = document.getElementById("clear-all-btn");
      const clearAllModal = document.getElementById("clear-all-modal");
      const clearAllCancel = document.getElementById("clear-all-cancel");
      const clearAllConfirm = document.getElementById("clear-all-confirm");
      clearAllBtn.addEventListener("click", () => {
       clearAllModal.classList.add("active");
      });
      clearAllCancel.addEventListener("click", () => {
       clearAllModal.classList.remove("active");
      });
      clearAllModal.addEventListener("click", (e) => {
       if (e.target === clearAllModal) {
        clearAllModal.classList.remove("active");
       }
      });
      clearAllConfirm.addEventListener("click", () => {
       pushUndo("clear all");
       NODE_DATA = {};
       EDGE_DATA = {
        list: []
       };
       EDGE_LEGEND = {};
       RECT_DATA = { list: [] };
       TEXT_DATA = { list: [] };
       savedPositions = {};
       savedSizes = {};
       savedStyles = {};
       logAuditEvent("clear", "Cleared all data from canvas");
       clearAllModal.classList.remove("active");
       forgeTheTopology();
       document.getElementById("node-panel").style.display = "none";
       document.getElementById("edge-panel").style.display = "none";
       document.getElementById("text-panel").style.display = "none";
       document.getElementById("topology-toolbar").style.display = "none";
       currentNodeId = null;
       currentEdgeId = null;
       currentTextId = null;
      });
      (function addDeleteNodeButton() {
       const nodePanel = document.getElementById("node-panel");
       if (!nodePanel) return;
       let deleteBtn = document.getElementById("delete-node-btn");
       if (!deleteBtn) {
        deleteBtn = document.createElement("button");
        deleteBtn.id = "delete-node-btn";
        deleteBtn.textContent = "Delete Node";
        deleteBtn.style.cssText = "margin-top:15px; padding:10px 16px; background:var(--danger); color:#fff; border:none; border-radius:6px; cursor:pointer; font-size:clamp(14px,1.6vw,18px); font-weight:600; width:100%;";
        nodePanel.appendChild(deleteBtn);
       }
       deleteBtn.addEventListener("click", () => {
        if (!currentNodeId) return;
        const nodeData = NODE_DATA[currentNodeId];
        let confirmMessage;
        let nodesInsideRack = [];
        if (nodeData?.isRack) {
         nodesInsideRack = Object.entries(NODE_DATA)
          .filter(([id, n]) => n.assignedRack === currentNodeId)
          .map(([id, n]) => n.name || id);
         if (nodesInsideRack.length > 0) {
          confirmMessage = `Delete rack "${nodeData.name}"?\n\nThis will also delete ${nodesInsideRack.length} node(s) inside:\n• ${nodesInsideRack.join('\n• ')}`;
         } else {
          confirmMessage = `Delete rack "${nodeData.name}"? (empty rack)`;
         }
        } else {
         confirmMessage = `Delete node "${nodeData?.name || currentNodeId}" and all its connections?`;
        }
        challengeTheImmortal(confirmMessage, () => {
         pushUndo("delete node");
         if (nodeData?.isRack) {
          Object.keys(NODE_DATA).forEach(id => {
           if (NODE_DATA[id]?.assignedRack === currentNodeId) {
            EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== id && e.to !== id);
            delete NODE_DATA[id];
            delete savedPositions[id];
            delete savedSizes[id];
            delete savedStyles[id];
           }
          });
         }
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== currentNodeId && e.to !== currentNodeId);
         delete NODE_DATA[currentNodeId];
         delete savedPositions[currentNodeId];
         delete savedSizes[currentNodeId];
         delete savedStyles[currentNodeId];
         currentNodeId = null;
         currentEdgeId = null;
         forgeTheTopology();
         const remainingNodes = Object.keys(NODE_DATA);
         if (remainingNodes.length > 0) {
          claimTheImmortal(remainingNodes[0]);
         } else {
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("topology-toolbar").style.display = "none";
         }
        });
       });
      })();
      function screenshotCanvas() {
       const svg = document.getElementById("map");
       const svgClone = svg.cloneNode(true);
       const viewBox = svg.getAttribute("viewBox").split(" ").map(Number);
       const [x, y, width, height] = viewBox;
       svgClone.setAttribute("width", width);
       svgClone.setAttribute("height", height);
       svgClone.setAttribute("viewBox", `${x} ${y} ${width} ${height}`);
       const wrapper = document.createElement("div");
       wrapper.style.position = "absolute";
       wrapper.style.left = "-9999px";
       wrapper.appendChild(svgClone);
       document.body.appendChild(wrapper);
       function inlineStyles(original, clone) {
        const elements = original.querySelectorAll("*");
        const clonedElements = clone.querySelectorAll("*");
        const rootStyles = getComputedStyle(document.documentElement);
        const bgColor = rootStyles.getPropertyValue("--bg").trim() || "#050608";
        const bgRect = document.createElementNS("http://www.w3.org/2000/svg", "rect", );
        bgRect.setAttribute("x", x);
        bgRect.setAttribute("y", y);
        bgRect.setAttribute("width", width);
        bgRect.setAttribute("height", height);
        bgRect.setAttribute("fill", bgColor);
        clone.insertBefore(bgRect, clone.firstChild);
        elements.forEach((el, index) => {
         const clonedEl = clonedElements[index];
         if (!clonedEl) return;
         const computedStyle = getComputedStyle(el);
         const svgProps = ["fill", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin", "opacity", "font-family", "font-size", "font-weight", "font-style", "text-anchor", "dominant-baseline", "marker-start", "marker-end", ];
         svgProps.forEach((prop) => {
          const value = computedStyle.getPropertyValue(prop);
          if (value && value !== "none" && value !== "normal") {
           clonedEl.style[prop] = value;
          }
         });
         clonedEl.removeAttribute("class");
        });
       }
       inlineStyles(svg, svgClone);
       const svgData = new XMLSerializer().serializeToString(svgClone);
       document.body.removeChild(wrapper);
       const svgBlob = new Blob([svgData], {
        type: "image/svg+xml;charset=utf-8",
       });
       const url = URL.createObjectURL(svgBlob);
       const img = new Image();
       img.onload = function() {
        const canvas = document.createElement("canvas");
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext("2d");
        ctx.drawImage(img, 0, 0);
        canvas.toBlob(function(blob) {
         const link = document.createElement("a");
         const timestamp = new Date().toISOString().slice(0, 10);
         link.download = `topology-${timestamp}.png`;
         link.href = URL.createObjectURL(blob);
         link.click();
         URL.revokeObjectURL(url);
         URL.revokeObjectURL(link.href);
        }, "image/png");
       };
       img.onerror = function() {
        console.error("Failed to load SVG image");
        alert("Screenshot failed. Please try again.");
        URL.revokeObjectURL(url);
       };
       img.src = url;
      }
      function exportCanvasSVG() {
       const svg = document.getElementById("map");
       const svgClone = svg.cloneNode(true);
       const viewBox = svg.getAttribute("viewBox").split(" ").map(Number);
       const [x, y, width, height] = viewBox;
       svgClone.setAttribute("width", width);
       svgClone.setAttribute("height", height);
       const rootStyles = getComputedStyle(document.documentElement);
       const bgColor = rootStyles.getPropertyValue("--bg").trim() || "#050608";
       const bgRect = document.createElementNS("http://www.w3.org/2000/svg", "rect", );
       bgRect.setAttribute("x", x);
       bgRect.setAttribute("y", y);
       bgRect.setAttribute("width", width);
       bgRect.setAttribute("height", height);
       bgRect.setAttribute("fill", bgColor);
       svgClone.insertBefore(bgRect, svgClone.firstChild);
       const wrapper = document.createElement("div");
       wrapper.style.position = "absolute";
       wrapper.style.left = "-9999px";
       wrapper.appendChild(svgClone);
       document.body.appendChild(wrapper);
       const elements = svg.querySelectorAll("*");
       const clonedElements = svgClone.querySelectorAll("*");
       elements.forEach((el, index) => {
        const clonedEl = clonedElements[index];
        if (!clonedEl) return;
        const computedStyle = getComputedStyle(el);
        const svgProps = ["fill", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin", "opacity", "font-family", "font-size", "font-weight", "font-style", "text-anchor", "dominant-baseline", "marker-start", "marker-end", ];
        svgProps.forEach((prop) => {
         const value = computedStyle.getPropertyValue(prop);
         if (value && value !== "none" && value !== "normal") {
          clonedEl.setAttribute(prop, value);
         }
        });
        clonedEl.removeAttribute("class");
       });
       const svgData = new XMLSerializer().serializeToString(svgClone);
       document.body.removeChild(wrapper);
       const blob = new Blob([svgData], {
        type: "image/svg+xml;charset=utf-8",
       });
       const url = URL.createObjectURL(blob);
       const link = document.createElement("a");
       const timestamp = new Date().toISOString().slice(0, 10);
       link.download = `topology-${timestamp}.svg`;
       link.href = url;
       link.click();
       URL.revokeObjectURL(url);
      }
      let resizeTimeout;
       window.addEventListener('resize', () => {
       clearTimeout(resizeTimeout);
       resizeTimeout = setTimeout(() => {
       updateDrawToolbarVisibility();
       updateTopologyToolbarVisibility();
       }, 100);
      });
    </script>
</body></html>