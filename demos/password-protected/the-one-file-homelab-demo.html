<!DOCTYPE html> 
 <html lang="en" style="--panel: #2f0e0e; --panel-alt: #10141b; --sidebar-bg: #10141b; --btn-bg: #0b0e13; --accent: #a75252; --danger: #f56565; --text-main: #e2e8f0; --text-soft: #94a3b8; --topbar-bg: rgba(9, 12, 20, 0.9); --topbar-border: #1f2533; --topbar-height: 112px; --sidebar-width: 350px; --mobile-footer-height: 40vh; --draw-toolbar-height: 0px; --btn-text: #e2e8f0; --tag-fill: #1e293b; --tag-text: #e2e8f0; --tag-border: #475569; --input-bg: #0b0e13; --input-text: #e2e8f0; --input-border: #1f2937; --input-font: Inter, system-ui, sans-serif; --input-font-size: 14px; --toolbar-bg: #441215; --toolbar-border: #1f2937; --toolbar-text: #94a3b8; --toolbar-btn-bg: #0b0e13; --toolbar-btn-text: #e2e8f0; --minimap-dots: #94a3b8; --canvas-hint-bg: #0f172a; --canvas-hint-color: #94a3b8; --node-fill: #1e293b; --node-stroke: #475569; --node-title: #e2e8f0; --node-sub: #94a3b8; --node-title-size: 18px; --node-sub-size: 13px; --node-font: Inter, system-ui, sans-serif; --default-edge: #475569; --selection-handle: #f59e0b; --selection-handle-size: 8px; --group-indicator: #4fd1c5;"><head>
    <meta charset="UTF-8">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>The One File</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- 
      * ====================================================================================
      * THE ONE FILE
      * "There can be only one". A all in one file topology maker for enterprise or homelab
      * 
      * This is your last backup when all others fail. A completely self-contained
      * network topology visualization tool that works as a single HTML file.
      * Open it anywhere, anytime and the idea lives forever.
      * ====================================================================================
      -->
    <style>
      :root {
      color-scheme: dark;
      --bg: #050608;
      --panel: #0b0e13;
      --panel-alt: #10141b;
      --accent: #4fd1c5;
      --danger: #f56565;
      --text-main: #e2e8f0;
      --text-soft: #94a3b8;
      --edge-main: #475569;
      --node-min: 35px;
      --node-max: 70px;
      --topbar-bg: rgba(9, 12, 20, 0.9);
      --topbar-border: #1f2533;
      }
	  html, body, svg, .map-container {
      touch-action: none;
      }
      * {
      box-sizing: border-box;
      user-select: none;
      }
      input,
      textarea,
      [contenteditable="true"] {
      user-select: text;
      -webkit-user-select: text;
      }
      body {
      margin: 0;
      font-family: system-ui, sans-serif;
      background: radial-gradient(circle at top, #1e2532 0, #050608 70%);
      color: var(--text-main);
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
      }
      header {
      padding: 0 20px;
      height: var(--topbar-height, 52px);
      min-height: var(--topbar-height, 52px);
      background: var(--topbar-bg);
      backdrop-filter: blur(6px);
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid var(--topbar-border);
      gap: 16px;
      }
      .title-block {
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-width: 0;
      }
      header h1 {
      font-size: clamp(22px, 3vw, 32px);
      margin: 0;
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
      }
      .editable-page-title {
      cursor: pointer;
      transition: opacity 0.2s;
      }
      .editable-page-title:hover {
      opacity: 0.7;
      }
      .save-row {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      }
      .save-btn {
      padding: 6px 12px;
      background: var(--accent);
      color: var(--bg);
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      white-space: nowrap;
      }
      .save-btn:hover {
      opacity: 0.9;
      }
      .help-icon {
      width: 22px;
      height: 22px;
      border-radius: 50%;
      border: 1px solid var(--edge-main);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      cursor: pointer;
      color: var(--text-soft);
      background: rgba(15, 23, 42, 0.9);
      flex-shrink: 0;
      }
      .help-icon:hover {
      color: var(--accent);
      border-color: var(--accent);
      }
      #settings-btn {
      background: var(--btn-bg, var(--panel));
      color: var(--btn-text, var(--text-main));
      border: 1px solid var(--edge-main);
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 16px;
      flex-shrink: 0;
      }
      #settings-btn:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .header-resizer {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 6px;
      background: transparent;
      cursor: row-resize;
      z-index: 1000;
      transition: background 0.2s;
      }
      .header-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .header-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      .sidebar-resizer {
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 6px;
      background: transparent;
      cursor: col-resize;
      z-index: 1000;
      transition: background 0.2s;
      }
      .sidebar-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .sidebar-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      .mobile-footer-resizer {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 6px;
      background: transparent;
      cursor: row-resize;
      z-index: 1000;
      transition: background 0.2s;
      display: none;
      }
      .mobile-footer-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .mobile-footer-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      @media (max-width: 900px) {
      .mobile-footer-resizer {
      display: block;
      height: 12px;
      }
      .sidebar-resizer {
      display: none;
      }
      .header-resizer {
      height: 12px;
      }
      }
      @media (pointer: coarse) {
      .header-resizer {
      height: 16px;
      }
      .mobile-footer-resizer {
      height: 16px;
      }
      .sidebar-resizer {
      width: 16px;
      }
      }
      .resizer-icon {
      position: absolute;
      opacity: 0.5;
      transition: opacity 0.2s, transform 0.2s;
      pointer-events: none;
      fill: var(--accent);
      }
      .header-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .sidebar-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .mobile-footer-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .header-resizer:hover .resizer-icon,
      .sidebar-resizer:hover .resizer-icon,
      .mobile-footer-resizer:hover .resizer-icon {
      opacity: 1;
      }
      .header-resizer.resizing .resizer-icon,
      .sidebar-resizer.resizing .resizer-icon,
      .mobile-footer-resizer.resizing .resizer-icon {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1.2);
      }
      body.resizing {
      user-select: none;
      }
      body.resizing * {
      cursor: inherit !important;
      pointer-events: none;
      }
      header {
      position: relative;
      }
      .details-panel {
      position: relative;
      }
      main {
      display: grid;
      grid-template-columns: 1fr var(--sidebar-width, 350px);
      flex: 1;
      }
      main.sidebar-collapsed {
      grid-template-columns: 1fr 0;
      }
      @media (max-width: 900px) {
      main {
      grid-template-columns: 1fr;
      grid-template-rows: calc(100vh - var(--topbar-height, 52px) - var(--mobile-footer-height, 40vh)) var(--mobile-footer-height, 40vh);
      }
      main.sidebar-collapsed {
      grid-template-rows: 1fr 0;
      }
      .details-panel {
      max-height: var(--mobile-footer-height, 40vh);
      height: 100%;
      }
      }
      .topology-panel {
      background: var(--panel);
      border-right: 1px solid #111827;
      position: relative;
      overflow: hidden;
      }
      .topology-toolbar {
      position: absolute;
      top: 10px;
      right: 10px;
      display: none;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      z-index: 99;
      font-size: 13px;
      color: var(--toolbar-text, #94a3b8);
      }
      .topology-toolbar label {
      color: var(--toolbar-text, var(--text-soft));
      }
      .topology-toolbar select {
      padding: 4px 6px;
      background: var(--toolbar-btn-bg, var(--panel));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 13px;
      cursor: pointer;
      }
      .topology-toolbar button {
      padding: 4px 10px;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      }
      .topology-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .bulk-toolbar-desktop,
      .bulk-toolbar-mobile {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 9999;
      }
      .bulk-toolbar-desktop {
      position: absolute;
      top: 10px;
      right: 10px;
      bottom: auto;
      left: auto;
      transform: none;
      }
      @media (min-width: 768px) {
      .bulk-toolbar-mobile {
      display: none !important;
      }
      }	  
      .bulk-action-btn {
      padding: 16px;
      background: var(--panel-main);
      border: 1px solid var(--edge-main);
      border-radius: 8px;
      color: var(--text-main);
      font-size: 24px;
      cursor: pointer;
      text-align: center;
      line-height: 1.2;
      }
      .bulk-action-btn:active {
      transform: scale(0.95);
      background: var(--accent);
      }
      .draw-toolbar {
      position: absolute;
      top: 10px;
      left: 10px;
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 8px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      z-index: 99;
      font-size: 13px;
      pointer-events: auto;
      color: var(--toolbar-text, #94a3b8);
      }
      .draw-toolbar button {
      padding: 4px 8px;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      }
      .draw-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .draw-toolbar input[type="color"] {
      width: 30px;
      height: 22px;
      border-radius: 4px;
      border: 1px solid var(--edge-main);
      padding: 0;
      background: transparent;
      cursor: pointer;
      }
      .draw-toolbar select {
      padding: 4px 6px;
      background: var(--toolbar-btn-bg, var(--panel));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 13px;
      cursor: pointer;
      }
      .legend-container {
      position: absolute;
      left: 10px;
      bottom: 10px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      padding: 8px 10px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      font-size: 12px;
      z-index: 20;
      max-width: 260px;
      pointer-events: auto;
      color: var(--toolbar-text, #94a3b8);
      }
      .legend-container {
      padding-right: 22px;
      }
      @media (max-width: 900px) {
      .legend-container {
      height:250px;
      overflow-y: auto;
      z-index:99;
      }
      }
      @media (max-width: 900px) {
      .bulk-toolbar-desktop,
      .topology-toolbar {
      display: none !important;
      }
      }
      .legend-close-btn {
      position: absolute;
      top: 5px;
      right: 5px;
      width: 18px;
      height: 18px;
      border-radius: 999px;
      border: 1px solid var(--edge-main);
      background: var(--panel-alt);
      color: var(--text-soft);
      font-size: 11px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      }
      .legend-close-btn:hover {
      background: var(--danger);
      color: #fff;
      }
      .legend-mini-btn {
      position: absolute;
      left: 10px;
      padding: 4px 8px;
      border-radius: 4px;
      border: 1px solid var(--toolbar-border, #1f2937);
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 11px;
      cursor: pointer;
      z-index: 20;
      display: none;
      transition: all 0.2s;
      }
      .legend-mini-btn:hover,
      .legend-mini-btn:active {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
      }
      .legend-title {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: var(--toolbar-text, var(--text-soft));
      margin-bottom: 2px;
      }
      .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      }
      .legend-swatch {
      width: 14px;
      height: 14px;
      border-radius: 3px;
      border: 1px solid #020617;
      flex-shrink: 0;
      }
      .legend-label {
      outline: none;
      cursor: text;
      flex: 1;
      min-width: 60px;
      user-select: text;
      -webkit-user-select: text;
      }
      .legend-label.editing {
      border-bottom: 1px dashed var(--accent);
      }
      .canvas-viewport {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      overflow: hidden;
      }
      .canvas-viewport.panning {
      cursor: grabbing !important;
      }
      .canvas-viewport.panning * {
      cursor: grabbing !important;
      }
      .canvas-viewport svg {
      width: 100%;
      height: 100%;
      display: block;
      background: linear-gradient(rgba(71, 85, 105, 0.1) 1px,
      transparent 1px),
      linear-gradient(90deg,
      rgba(71, 85, 105, 0.1) 1px,
      transparent 1px),
      linear-gradient(rgba(71, 85, 105, 0.05) 1px, transparent 1px),
      linear-gradient(90deg,
      rgba(71, 85, 105, 0.05) 1px,
      transparent 1px);
      background-size:
      100px 100px,
      100px 100px,
      20px 20px,
      20px 20px;
      background-position:
      -1px -1px,
      -1px -1px,
      -1px -1px,
      -1px -1px;
      }
      .zoom-toolbar {
      display: flex;
      gap: 4px;
      padding: 6px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      }
      .zoom-toolbar button {
      width: 32px;
      height: 32px;
      padding: 0;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 18px;
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
      }
      .zoom-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .zoom-toolbar .zoom-level {
      font-size: 11px;
      color: var(--toolbar-text, var(--text-soft));
      text-align: center;
      padding: 2px 0;
      min-width: 32px;
      }
      .zoom-toolbar .divider {
      height: 1px;
      background: var(--toolbar-border, var(--edge-main));
      margin: 2px 0;
      }
      .minimap-zoom-wrapper {
      position: absolute;
      bottom: 10px;
      right: 10px;
      z-index: 99;
      }
      .minimap-container {
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      overflow: hidden;
      margin-bottom: 4px;
      }
      .minimap-container svg {
      width: 100%;
      height: 100%;
      }
      .minimap-viewport {
      fill: rgba(79, 209, 197, 0.2);
      stroke: var(--accent);
      stroke-width: 2;
      cursor: move;
      }
      .minimap-node {
      fill: var(--minimap-dots, var(--text-soft));
      }
      .minimap-edge {
      stroke: var(--edge-main);
      stroke-width: 1;
      }
      .minimap-close-btn {
      position: absolute;
      top: 2px;
      right: 2px;
      width: 18px;
      height: 18px;
      background: var(--toolbar-btn-bg, rgba(15, 23, 42, 0.9));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 3px;
      color: var(--toolbar-text, var(--text-soft));
      font-size: 11px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
      padding: 0;
      line-height: 1;
      }
      .minimap-close-btn:hover {
      background: var(--danger);
      color: white;
      border-color: var(--danger);
      }
      .toolbar-close-btn {
      width: 24px;
      height: 24px;
      background: var(--toolbar-btn-bg, rgba(15, 23, 42, 0.9));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-text, var(--text-soft));
      font-size: 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      line-height: 1;
      flex-shrink: 0;
      }
      .toolbar-close-btn:hover {
      background: var(--danger);
      color: white;
      border-color: var(--danger);
      }
      .canvas-hint {
      position: absolute;
      top: 50px;
      left: 50%;
      transform: translateX(-50%);
      padding: 8px 16px;
      background: rgba(15, 23, 42, 0.92);
      border: 1px solid #1f2937;
      border-radius: 6px;
      font-size: 12px;
      color: var(--text-soft);
      z-index: 18;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
      }
      .canvas-hint.visible {
      opacity: 1;
      }
      .edge {
      stroke: var(--edge-main);
      stroke-width: 4;
      opacity: 0.75;
      transition: 0.25s ease-in-out;
      cursor: pointer;
      }
      .edge.backup {
      stroke: var(--danger);
      stroke-width: 5;
      }
      .edge.active {
      opacity: 1;
      stroke-width: 7;
      filter: drop-shadow(0 0 8px var(--accent, #4fd1c5));
      }
      .rect-group.active .rect-shape {
      filter: drop-shadow(0 0 10px var(--accent, #4fd1c5));
      animation: pulse 1.2s infinite ease-in-out;
      }
      .text-element.active {
      filter: drop-shadow(0 0 10px var(--accent, #4fd1c5));
      animation: pulse 1.2s infinite ease-in-out;
      }
      .free-preview {
      fill: none;
      stroke-dasharray: 4 4;
      pointer-events: none;
      }
      .free-point {
      fill: #e5e7eb;
      stroke: #0f172a;
      stroke-width: 1.5;
      cursor: grab;
      }
      .node-circle {
      fill: var(--node-fill, #1e293b);
      stroke: var(--node-stroke, #475569);
      stroke-width: 2;
      transition: 0.25s ease;
      transform-origin: center center;
      }
      .node-hit-area {
      cursor: grab;
      pointer-events: all;
      }
      .node-group:hover .node-circle {
      filter: drop-shadow(0 0 10px rgba(79, 209, 197, 0.45));
      }
      .node-group.active .node-circle {
      stroke: var(--accent);
      animation: pulse 1.2s infinite ease-in-out;
      }
      .node-group.selected .node-circle {
      stroke: var(--selection-handle, #f59e0b);
      stroke-width: 3;
      }
      .node-group.search-highlight .node-circle {
      stroke: #10b981;
      stroke-width: 3;
      filter: drop-shadow(0 0 8px #10b981);
      }
      @keyframes pulse {
      0% {
      filter: drop-shadow(0 0 4px #4fd1c5);
      }
      50% {
      filter: drop-shadow(0 0 14px #4fd1c5);
      }
      100% {
      filter: drop-shadow(0 0 4px #4fd1c5);
      }
      }
      .node-label {
      fill: var(--text-main);
      font-size: 18px;
      text-anchor: middle;
      font-weight: 600;
      }
      .node-sub {
      fill: var(--text-soft);
      font-size: 13px;
      text-anchor: middle;
      }
      @media (max-width: 1024px) {
      .node-label {
      font-size: 28px;
      }
      .node-sub {
      font-size: 20px;
      }
      }
      @media (max-width: 768px) {
      .node-label {
      font-size: 70px;
      }
      .node-sub {
      font-size: 50px;
      }
      }
      @media (max-width: 380px) {
      .node-label {
      font-size: 60px;
      }
      .node-sub {
      font-size: 42px;
      }
      }
      .details-panel {
      background: var(--sidebar-bg, var(--panel-alt));
      padding: 22px;
      padding-bottom: 80px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 15px;
      position: relative;
      transition:
      width 0.3s ease,
      min-width 0.3s ease,
      padding 0.3s ease,
      opacity 0.3s ease;
      }
      .details-panel {
      min-width: 260px !important;
      }
      .details-panel {
      overflow-y: auto !important;
      overflow-x: hidden;
      }
      .details-panel.collapsed {
      width: 0 !important;
      min-width: 0 !important;
      padding: 0 !important;
      overflow: hidden;
      opacity: 0;
      }
      body {
      overflow-x: hidden;
      overflow-y: hidden;
      }
      main {
      overflow-x: hidden;
      overflow-y: visible;
      }
      .details-panel {
      overflow-y: auto !important;
      overflow-x: hidden;
      }
      .details-panel.collapsed {
      min-width: 0 !important;
      }
      .sidebar-toggle {
      position: absolute;
      left: -16px;
      top: 50%;
      transform: translateY(-50%);
      width: 16px;
      height: 60px;
      background: var(--sidebar-bg, var(--panel-alt));
      border: 1px solid var(--edge-main);
      border-right: none;
      border-radius: 8px 0 0 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text-soft);
      font-size: 10px;
      z-index: 25;
      transition:
      background 0.2s,
      color 0.2s;
      }
      .sidebar-toggle:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .sidebar-toggle.collapsed {
      left: 0;
      border-right: 1px solid var(--edge-main);
      border-radius: 0 8px 8px 0;
      position: fixed;
      right: 0;
      left: auto;
      }
      .details-name {
      font-size: clamp(22px, 2.5vw, 30px);
      font-weight: 700;
      }
      .details-ip {
      font-size: clamp(16px, 2vw, 22px);
      color: var(--text-soft);
      }
      .details-role {
      font-size: clamp(16px, 2vw, 22px);
      color: var(--accent);
      }
      .details-info-row {
      display: flex;
      align-items: center;
      margin: 6px 0;
      }
      .size-controls {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-top: 10px;
      }
      .size-controls label {
      font-size: clamp(14px, 1.6vw, 18px);
      color: var(--text-soft);
      }
      .size-controls input[type="range"] {
      flex: 1;
      accent-color: var(--accent);
      }
      .size-controls button {
      padding: 6px 12px;
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      font-size: clamp(12px, 1.4vw, 16px);
      }
      .size-controls button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .style-section {
      margin-top: 15px;
      padding-top: 15px;
      border-top: 1px solid var(--edge-main);
      }
      .style-section summary {
      cursor: pointer;
      font-size: clamp(14px, 1.6vw, 20px);
      text-transform: uppercase;
      color: var(--text-soft);
      list-style: none;
      display: flex;
      justify-content: space-between;
      align-items: center;
      user-select: none;
      }
      .style-section summary::-webkit-details-marker {
      display: none;
      }
      .password-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #ffffff;
      z-index: 9999;
      }
      .style-section summary::after {
      content: "â–¼";
      transition: transform 0.2s;
      }
      .style-section[open] summary::after {
      transform: rotate(180deg);
      }
      .style-content {
      margin-top: 10px;
      }
      .style-row {
      display: flex;
      gap: 10px;
      align-items: center;
      margin: 8px 0;
      }
      .style-row label {
      font-size: clamp(13px, 1.5vw, 17px);
      color: var(--text-soft);
      min-width: 80px;
      }
      .style-row input[type="color"] {
      width: 50px;
      height: 30px;
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      background: transparent;
      }
      .style-row input[type="number"] {
      width: 70px;
      padding: 4px 8px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(12px, 1.4vw, 16px);
      }
      .style-row select {
      flex: 1;
      padding: 4px 8px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(12px, 1.4vw, 16px);
      cursor: pointer;
      }
      .editable-text {
      cursor: pointer;
      transition: opacity 0.2s;
      }
      .editable-text:hover {
      opacity: 0.7;
      }
      .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 999999;
      justify-content: center;
      align-items: center;
      padding-top: var(--topbar-height, 52px);
      }
      .modal.active {
      display: flex;
      }
      .modal-content {
      background: var(--panel-alt);
      padding: 25px;
      border-radius: 8px;
      border: 1px solid var(--edge-main);
      min-width: 300px;
      max-width: 90%;
      max-height: calc(100vh - var(--topbar-height, 52px) - 40px);
      overflow-y: auto;
      }
      .modal-content h3 {
      margin: 0 0 15px 0;
      color: var(--text-main);
      font-size: clamp(18px, 2vw, 24px);
      }
      .modal-content p {
      color: var(--text-soft);
      font-size: clamp(14px, 1.6vw, 18px);
      margin: 0 0 20px 0;
      }
      .modal-content input:not([type="color"]),
      .modal-content select {
      width: 100%;
      padding: 10px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(14px, 1.6vw, 18px);
      margin-bottom: 15px;
      user-select: text;
      -webkit-user-select: text;
      }
      .modal-content input[type="color"] {
      width: 60px;
      height: 36px;
      padding: 2px;
      border: 2px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      background: none;
      -webkit-appearance: none;
      appearance: none;
      }
      .modal-content input[type="color"]::-webkit-color-swatch-wrapper {
      padding: 0;
      }
      .modal-content input[type="color"]::-webkit-color-swatch {
      border: none;
      border-radius: 4px;
      }
      .modal-buttons {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
      margin-top: 10px;
      }
      .modal-buttons button {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: clamp(14px, 1.6vw, 18px);
      font-weight: 600;
      }
      .modal-buttons .btn-cancel {
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      }
      .modal-buttons .btn-save {
      background: var(--accent);
      color: var(--bg);
      }
      .modal-buttons .btn-delete {
      background: var(--danger);
      color: white;
      }
      .confirm-modal p {
      color: var(--text-soft);
      font-size: clamp(14px, 1.6vw, 18px);
      margin: 0 0 20px 0;
      }
      .context-menu-item {
      transition: background 0.15s;
      }
      .context-menu-item:hover {
      background: var(--panel);
      }
      .badge-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      }
      .badge {
      background: var(--tag-fill, #1e293b);
      color: var(--tag-text, #e2e8f0);
      border: 1px solid var(--tag-border, var(--edge-main));
      padding: 5px 12px;
      border-radius: 22px;
      font-size: clamp(12px, 1.4vw, 18px);
      }
      .badge.wg {
      color: var(--accent);
      border-color: var(--accent);
      }
      input[type="text"],
      input[type="number"],
      input[type="password"],
      textarea,
      select {
      background: var(--input-bg, #0b0e13) !important;
      color: var(--input-text, #e2e8f0) !important;
      border-color: var(--input-border, #1f2937) !important;
      font-family: var(--input-font, Inter, system-ui, sans-serif) !important;
      font-size: var(--input-font-size, 14px) !important;
      }
      .section-label {
      margin-top: 8px;
      font-size: clamp(14px, 1.6vw, 20px);
      text-transform: uppercase;
      color: var(--text-soft);
      }
      .list li {
      margin: 6px 0;
      font-size: clamp(14px, 1.6vw, 20px);
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      }
      .list li:hover {
      color: var(--accent);
      }
      .delete-note {
      color: var(--danger);
      font-size: 18px;
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.2s;
      flex-shrink: 0;
      }
      .list li:hover .delete-note {
      opacity: 1;
      }
      .editing {
      outline: 2px solid var(--accent);
      background: #0d141f;
      padding: 4px;
      border-radius: 6px;
      user-select: text;
      -webkit-user-select: text;
      }
      .version-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .version-item:hover {
      background: var(--panel-alt);
      border-color: var(--accent);
      }
      .version-item.current {
      border-color: var(--accent);
      background: rgba(79, 209, 197, 0.1);
      }
      .version-info {
      flex: 1;
      }
      .version-info .timestamp {
      font-size: 13px;
      color: var(--text-main);
      font-weight: 600;
      }
      .version-info .details {
      font-size: 11px;
      color: var(--text-soft);
      margin-top: 4px;
      }
      .version-actions {
      display: flex;
      gap: 6px;
      }
      .audit-entry {
      padding: 8px 12px;
      background: var(--panel);
      border-left: 3px solid var(--edge-main);
      border-radius: 4px;
      font-size: 12px;
      }
      .audit-entry.node { border-left-color: #4fd1c5; }
      .audit-entry.connection { border-left-color: #9f7aea; }
      .audit-entry.style { border-left-color: #ed8936; }
      .audit-entry.rack { border-left-color: #48bb78; }
      .audit-entry.layer { border-left-color: #4299e1; }
      .audit-entry .time {
      color: var(--text-soft);
      font-size: 10px;
      }
      .audit-entry .action {
      color: var(--text-main);
      font-weight: 500;
      }
      .tab-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .tab-item:hover {
      background: var(--panel-alt);
      }
      .tab-item.active {
      border-color: var(--accent);
      background: rgba(79, 209, 197, 0.1);
      }
      .tab-item .tab-name {
      font-weight: 600;
      color: var(--text-main);
      flex: 1;
      }
      .tab-item .tab-stats {
      font-size: 11px;
      color: var(--text-soft);
      margin-right: 10px;
      }
      .tab-actions {
      display: flex;
      gap: 6px;
      }    
      .secret-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      border-left: 3px solid var(--danger);
      }
      .secret-item .secret-name {
      font-weight: 600;
      color: var(--text-main);
      flex: 1;
      }
      .secret-item .secret-status {
      font-size: 11px;
      color: var(--text-soft);
      margin-right: 10px;
      }    
      .mobile-menu-btn {
      display: none;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      color: var(--text-main);
      font-size: 22px;
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      }
      #topbar-menu {
      gap: 8px;
      }
      @media (min-width: 721px) {
      #topbar-menu {
      display: flex !important;
      }
      }
      @media (max-width: 720px) {
      #topbar-menu {
      display: none;
      }
      #topbar-menu.open {
      display: flex;
      }
      }
      @media (max-width: 720px) {
      .mobile-menu-btn {
      display: block;
      }
      #topbar-menu {
      position: absolute;
      top: var(--topbar-height);
      right: 0;
      background: var(--panel-alt);
      border-left: 1px solid var(--topbar-border);
      border-bottom: 1px solid var(--topbar-border);
      padding: 12px;
      display: none;
      flex-direction: column;
      width: 180px;
      z-index: 999;
      }
      #topbar-menu.open {
      display: flex;
      }
      header {
      position: relative;
      z-index: 9999;
      }
      }
      @media (max-width: 720px) {
      .draw-toolbar {
      position: absolute;
      top: auto;
      bottom: auto;
      left: 10px !important;
      right: auto !important;
      width: auto;
      gap: 6px;
      padding: 8px;
      }
      .topology-toolbar {
      position: absolute;
      top: auto;
      bottom: auto;
      width: auto;
      gap: 6px;
      padding: 8px;
      }
      .draw-toolbar {
      top: 10px !important;
      z-index:99;
      }
      .topology-toolbar {
      z-index:99;
      top: calc(10px + var(--draw-toolbar-height, 50px)) !important;
      }
      .canvas-hint {
      top: calc(10px + 120px);
      }
      #search-input {
      width: 100%;
      }
      }
    </style>
  </head>
  <body style="background: radial-gradient(circle at center top, rgb(30, 37, 50) 0px, rgb(5, 6, 8) 70%);" class="">
    <div class="modal" id="edit-modal">
      <div class="modal-content">
        <h3 id="modal-title">Edit Title</h3>
        <input type="text" id="modal-input">
        <div class="modal-buttons">
          <button class="btn-cancel" id="modal-cancel">Cancel</button>
          <button class="btn-save" id="modal-save">Save</button>
        </div>
      </div>
    </div>
    <div class="modal confirm-modal" id="confirm-modal">
      <div class="modal-content">
        <h3>Confirm</h3>
        <p id="confirm-message">Delete node "Noded"?</p>
        <div class="modal-buttons">
          <button class="btn-cancel" id="confirm-cancel">Cancel</button>
          <button class="btn-delete" id="confirm-delete">Delete</button>
        </div>
      </div>
    </div>
    <div class="modal" id="save-info-modal">
      <div class="modal-content" style="max-width: 700px; max-height: 80vh; overflow-y: auto;">
        <h3 style="margin-bottom: 16px;">Help</h3>
        <div style="display: flex; gap: 8px; margin-bottom: 16px; flex-wrap: wrap;">
          <button class="help-tab active" data-tab="general" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--accent); color: var(--bg); border-radius: 6px; cursor: pointer; font-weight: 600;">General</button>
          <button class="help-tab" data-tab="desktop" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--panel); color: var(--text-main); border-radius: 6px; cursor: pointer; font-weight: 600;">Desktop</button>
          <button class="help-tab" data-tab="mobile" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--panel); color: var(--text-main); border-radius: 6px; cursor: pointer; font-weight: 600;">Mobile</button>
        </div>
        <div id="help-tab-general" class="help-tab-content" style="display: block;">
          <ul style="margin-left: 20px; margin-bottom: 12px; line-height: 1.8;">
            <li><strong>Add Nodes:</strong> Click "+ Node" or "+ Rack" in the top menu</li>
            <li><strong>Connect Nodes:</strong> Select a node, then use "Add Connection" in the panel</li>
            <li><strong>Move Nodes:</strong> Drag nodes to reposition them</li>
            <li><strong>Enter Rack View:</strong> Double click on desktop or Long press on mobile</li>
            <li><strong>Multi Select:</strong> Right click (desktop) or double tap (mobile)</li>
            <li><strong>Pan Canvas:</strong> Drag empty space or hold Space + drag</li>
            <li><strong>Zoom:</strong> Scroll wheel or pinch gesture</li>
            <li><strong>Free Draw:</strong> Use draw toolbar for drawing lines, boxes/zones , and text</li>
          </ul>
          <h4 style="color: var(--accent); margin-bottom: 8px;">Saving &amp; Encryption</h4>
          <p style="margin-bottom: 8px;">Browsers cannot overwrite local files. Click <strong>Save File</strong> to download an updated HTML with all changes. Replace your old file to keep edits.</p>
          <p style="margin-bottom: 8px;"><strong>Encryption of data:</strong> Check "Encrypt" before saving to password protect your data. Beware! No recovery possible without password!!</p>
          <p><strong>Decryption of data:</strong> Export via JSON in top settings menu after successful password validation to decrypt your data. You can then reimport back into the same file and save!</p>
        </div>
        <div id="help-tab-desktop" class="help-tab-content" style="display: none;">
          <h4 style="color: var(--accent); margin-bottom: 12px;">Navigation</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Arrow Keys</code></td>
              <td style="padding: 8px;">Move selected 1px</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Shift + Arrows</code></td>
              <td style="padding: 8px;">Move selected 10px</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Tab / Shift+Tab</code></td>
              <td style="padding: 8px;">Cycle through nodes</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">F</code></td>
              <td style="padding: 8px;">Focus on selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Space + Drag</code></td>
              <td style="padding: 8px;">Pan canvas</td>
            </tr>
          </tbody></table>
          <h4 style="color: var(--accent); margin-bottom: 12px;">Management</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">L</code></td>
              <td style="padding: 8px;">Lock/unlock selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">G</code></td>
              <td style="padding: 8px;">Group/ungroup selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+C / Ctrl+V</code></td>
              <td style="padding: 8px;">Copy / Paste</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+D</code></td>
              <td style="padding: 8px;">Duplicate</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+A</code></td>
              <td style="padding: 8px;">Select all</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Delete</code></td>
              <td style="padding: 8px;">Delete selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Escape</code></td>
              <td style="padding: 8px;">Clear selection</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+Z / Ctrl+Y</code></td>
              <td style="padding: 8px;">Undo / Redo</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Right Click</code></td>
              <td style="padding: 8px;">Multi select toggle</td>
            </tr>
          </tbody></table>
        </div>
        <div id="help-tab-mobile" class="help-tab-content" style="display: none;">
          <h4 style="color: var(--accent); margin-bottom: 12px;">Basic Gestures</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Tap node</strong></td>
              <td style="padding: 8px;">Select &amp; open properties</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Tap empty</strong></td>
              <td style="padding: 8px;">Deselect all</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Drag node</strong></td>
              <td style="padding: 8px;">Move node</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Drag empty</strong></td>
              <td style="padding: 8px;">Pan canvas</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Pinch</strong></td>
              <td style="padding: 8px;">Zoom in/out</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Double-tap node</strong></td>
              <td style="padding: 8px;">Add/remove from selection</td>
            </tr>
          </tbody></table>
          <h4 style="color: var(--accent); margin-bottom: 12px;">Rack View</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Long-press rack</strong></td>
              <td style="padding: 8px;">Enter rack view</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Double-tap empty</strong></td>
              <td style="padding: 8px;">Exit rack view</td>
            </tr>
          </tbody></table>
        </div>
        <div class="modal-buttons" style="margin-top: 16px;">
          <button class="btn-cancel" id="save-info-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="settings-modal">
      <div class="modal-content">
        <h2>Settings</h2>
        <details class="style-section">
          <summary>General Theme</summary>
          <div class="style-content">
		    <div class="style-row">
              <label>Main Background</label>
              <input type="color" id="panel-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Modal Window (popup) Background</label>
              <input type="color" id="panel-alt-color" value="#10141b">
            </div>
            <div class="style-row">
              <label>Accent Buttons</label>
              <input type="color" id="accent-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Danger Buttons</label>
              <input type="color" id="danger-color" value="#f56565">
            </div>
            <div class="style-row">
              <label>Primary Text</label>
              <input type="color" id="text-main-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Secondary Text</label>
              <input type="color" id="text-soft-color" value="#94a3b8">
            </div>
          </div>
        </details>
		<details class="style-section">
          <summary>Top Bar</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="topbar-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="topbar-border-color" value="#1f2533">
            </div>
          </div>
		  <div class="style-content">
            <div class="style-row">
              <label>Button Fill</label>
              <input type="color" id="btn-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Button Text</label>
              <input type="color" id="btn-text-color" value="#e2e8f0">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Main Canvas</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="canvas-border-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Grid Lines</label>
              <input type="color" id="canvas-grid-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Grid Size</label>
              <input type="number" id="canvas-grid-size" value="50" min="20" max="200" style="width:60px;">
            </div>
			<div class="style-row">
              <label>Background Top</label>
              <input type="color" id="canvas-gradient-top" value="#1e2532">
            </div>
            <div class="style-row">
              <label>Background Bottom</label>
              <input type="color" id="canvas-gradient-bottom" value="#050608">
            </div>
            <div class="style-row">
              <label>Solid Background</label>
              <input type="color" id="page-bg-color" value="#050608">
            </div>
            <p style="margin-top:4px;font-size:12px;color:var(--text-soft);">Set solid background to override gradient.</p>
          </div>
			</details>
		  <details class="style-section">
          <summary>Rack Canvas</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Frame Fill</label>
              <input type="color" id="rack-frame-fill" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Frame Border</label>
              <input type="color" id="rack-frame-stroke" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Grid Lines</label>
              <input type="color" id="rack-line-color" value="#475569">
            </div>
            <div class="style-row">
              <label>U Labels</label>
              <input type="color" id="rack-text-color" value="#4fd1c5">
            </div>
          </div>
        </details>
		        <details class="style-section">
          <summary>Canvas Toolbars</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="toolbar-bg-color" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="toolbar-border-color" value="#1f2937">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="toolbar-text-color" value="#94a3b8">
            </div>
            <div class="style-row">
              <label>Button Fill</label>
              <input type="color" id="toolbar-btn-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Button Text</label>
              <input type="color" id="toolbar-btn-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Minimap Dots</label>
              <input type="color" id="minimap-dots-color" value="#94a3b8">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Nodes</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Fill</label>
              <input type="color" id="node-fill-color" value="#1e293b">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="node-stroke-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Title Color</label>
              <input type="color" id="node-title-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Title Size</label>
              <input type="number" id="node-title-size" value="18" min="8" max="48" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Subtitle Color</label>
              <input type="color" id="node-sub-color" value="#94a3b8">
            </div>
            <div class="style-row">
              <label>Subtitle Size</label>
              <input type="number" id="node-sub-size" value="13" min="8" max="48" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Font</label>
              <select id="node-font-family" style="flex:1;padding:4px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;">
                <option value="Inter, system-ui, sans-serif">Inter</option>
                <option value="Arial, sans-serif">Arial</option>
                <option value="Helvetica, sans-serif">Helvetica</option>
                <option value="Georgia, serif">Georgia</option>
                <option value="monospace">Monospace</option>
              </select>
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Connections</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Default Color</label>
              <input type="color" id="default-edge-color" value="#475569">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Groups &amp; Editing</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Resize handle Color</label>
              <input type="color" id="selection-handle-color" value="#f59e0b">
            </div>
            <div class="style-row">
              <label>Resize Handle Size</label>
              <input type="number" id="selection-handle-size" value="8" min="4" max="16" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Grouped Icon Outline</label>
              <input type="color" id="group-indicator-color" value="#4fd1c5">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Inputs &amp; Dropdowns</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="input-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="input-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="input-border-color" value="#1f2937">
            </div>
            <div class="style-row">
              <label>Font</label>
              <select id="input-font-family" style="flex:1;padding:4px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;">
                <option value="Inter, system-ui, sans-serif">Inter</option>
                <option value="Arial, sans-serif">Arial</option>
                <option value="Helvetica, sans-serif">Helvetica</option>
                <option value="Georgia, serif">Georgia</option>
                <option value="monospace">Monospace</option>
              </select>
            </div>
            <div class="style-row">
              <label>Font Size</label>
              <input type="number" id="input-font-size" value="14" min="10" max="24" style="width:60px;">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Welcome Message</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Enabled</label>
              <input type="checkbox" id="canvas-hint-enabled" checked="" style="width:auto;">
            </div>
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="canvas-hint-bg-color" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Text Color</label>
              <input type="color" id="canvas-hint-text-color" value="#94a3b8">
            </div>
            <div class="style-row" style="flex-direction:column;align-items:stretch;">
              <label>Custom Text (HTML)</label>
              <textarea id="canvas-hint-text" rows="4" style="width:100%;margin-top:4px;padding:6px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;font-size:12px;resize:vertical;" placeholder="Leave empty for default"></textarea>
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Sidebar / Mobile Footer</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="sidebar-bg-color" value="#10141b">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Tags</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Fill</label>
              <input type="color" id="tag-fill-color" value="#1e293b">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="tag-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="tag-border-color" value="#475569">
            </div>
          </div>
        </details>
        <details class="style-section" open="">
          <summary>Import / Export / Upgrade JSON</summary>
          <div class="style-content">
            <button id="export-data-btn" style="width:100%;margin-bottom:10px;padding:10px;background:var(--accent);color:var(--bg);border:none;border-radius:6px;cursor:pointer;font-size:14px;font-weight:600;">Export JSON</button>
            <button id="import-data-btn" style="width:100%;padding:10px;background:var(--panel);color:var(--text-main);border:1px solid var(--edge-main);border-radius:6px;cursor:pointer;font-size:14px;font-weight:600;">Import JSON</button>
            <input type="file" id="import-data-file" accept=".json" style="display:none">
          </div>
        </details>
        <details class="style-section" open="">
          <summary>Danger Zone</summary>
          <div class="style-content">
            <p style="margin-bottom:12px;font-size:13px;color:var(--text-soft);">Permanently delete everything on the canvas.</p>
            <button id="clear-all-btn" title="Clear all nodes" style="padding:6px 12px;background:var(--danger);color:#fff;border:none;border-radius:6px;cursor:pointer;font-size:14px;font-weight:600;">Clear All</button>
            <input type="file" id="import-data-file" accept=".json" style="display:none">
          </div>
        </details>
        <div class="modal-buttons">
          <button class="btn-cancel" id="settings-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="add-node-modal">
      <div class="modal-content">
        <h3>Add New Node</h3>
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Name</label>
        <input type="text" id="new-node-name" placeholder="e.g. web-server">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">IP / Subtitle</label>
        <input type="text" id="new-node-ip" placeholder="e.g. 192.168.1.100">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Tags (comma separated)</label>
        <input type="text" id="new-node-tags" placeholder="e.g. Docker, nginx, WG: vpn">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Shape</label>
        <select id="new-node-shape">
          <optgroup label="Basic Shapes">
            <option value="circle">Circle</option>
            <option value="square">Square</option>
            <option value="rectangle">Rectangle</option>
            <option value="triangle">Triangle</option>
            <option value="hexagon">Hexagon</option>
            <option value="diamond">Diamond</option>
            <option value="star">Star</option>
            <option value="stop-sign">Stop Sign</option>
          </optgroup>
          <optgroup label="Network Equipment">
            <option value="server">Server</option>
            <option value="pc">PC / Desktop</option>
            <option value="laptop">Laptop</option>
            <option value="phone">Phone / Mobile</option>
            <option value="router">Router</option>
            <option value="switch">Switch</option>
            <option value="firewall">Firewall</option>
            <option value="cloud">Cloud</option>
            <option value="database">Database</option>
            <option value="printer">Printer</option>
          </optgroup>
        </select>
        <div class="modal-buttons">
          <button class="btn-cancel" id="add-node-cancel">Cancel</button>
          <button class="btn-save" id="add-node-save">Add Node</button>
        </div>
      </div>
    </div>
    <div class="modal" id="add-rack-modal">
      <div class="modal-content">
        <h3>Add New Rack</h3>
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Rack Name</label>
        <input type="text" id="new-rack-name" placeholder="e.g. Rack-A, DC1-R01">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">IP / Network Range (optional)</label>
        <input type="text" id="new-rack-ip" placeholder="e.g. 192.168.1.0/24">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Tags (comma separated)</label>
        <input type="text" id="new-rack-tags" placeholder="e.g. Production, Data Center 1">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Icon / Shape</label>
        <select id="new-rack-shape">
          <optgroup label="Basic Shapes">
            <option value="circle">Circle</option>
            <option value="square">Square</option>
            <option value="rectangle">Rectangle</option>
            <option value="triangle">Triangle</option>
            <option value="hexagon">Hexagon</option>
            <option value="diamond">Diamond</option>
            <option value="star">Star</option>
            <option value="stop-sign">Stop Sign</option>
          </optgroup>
          <optgroup label="Network Equipment">
            <option value="server" selected="">Server</option>
            <option value="pc">PC / Desktop</option>
            <option value="laptop">Laptop</option>
            <option value="phone">Phone / Mobile</option>
            <option value="router">Router</option>
            <option value="switch">Switch</option>
            <option value="firewall">Firewall</option>
            <option value="cloud">Cloud</option>
            <option value="database">Database</option>
            <option value="printer">Printer</option>
          </optgroup>
        </select>
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Rack Capacity</label>
        <select id="new-rack-capacity">
          <option value="42" selected="">42U (Standard Full Rack)</option>
          <option value="48">48U (Large Rack)</option>
          <option value="24">24U (Half Rack)</option>
          <option value="12">12U (Small/Wall Mount)</option>
          <option value="6">6U (Mini Rack)</option>
        </select>
        <div class="modal-buttons">
          <button class="btn-cancel" id="add-rack-cancel">Cancel</button>
          <button class="btn-save" id="add-rack-save">Add Rack</button>
        </div>
      </div>
    </div>
    <div class="modal confirm-modal" id="clear-all-modal">
      <div class="modal-content">
        <h3>Clear All Nodes</h3>
        <p> This will remove ALL nodes and connections. This cannot be undone until you reload without saving. Are you sure? </p>
        <div class="modal-buttons">
          <button class="btn-cancel" id="clear-all-cancel">Cancel</button>
          <button class="btn-delete" id="clear-all-confirm">Clear Everything</button>
        </div>
      </div>
    </div>
    <div class="modal" id="layer-modal">
      <div class="modal-content" style="max-width: 400px;">
        <h3>Layer Visibility</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Toggle which layers are visible on the canvas</p>
        <div style="display: flex; flex-direction: column; gap: 10px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-physical" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Physical Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-logical" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Logical Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-security" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Security Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-application" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Application Layer</span>
          </label>
        </div>
        <div style="margin-top: 15px; display: flex; gap: 8px;">
          <button class="btn-cancel" style="flex: 1;" onclick="document.querySelectorAll('#layer-modal input[type=checkbox]').forEach(cb =&gt; cb.checked = false); applyLayerFilter();">Hide All</button>
          <button class="btn-save" style="flex: 1;" onclick="document.querySelectorAll('#layer-modal input[type=checkbox]').forEach(cb =&gt; cb.checked = true); applyLayerFilter();">Show All</button>
        </div>
        <div class="modal-buttons" style="margin-top: 10px;">
          <button class="btn-cancel" id="layer-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="tabs-modal">
      <div class="modal-content" style="max-width: 600px;">
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Manage multiple topologies</p>
        <div id="tabs-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 400px; overflow-y: auto; margin-bottom: 15px;">
            <div class="tab-item " onclick="switchTab(0)">
              <div class="tab-name">Corporate Site B</div>
              <div class="tab-stats">105 nodes â€¢ 64 connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(0)" title="Rename tab">âœï¸</button>
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(${index})" title="Delete tab">ðŸ—‘ï¸</button>
              </div>
            </div>
          
            <div class="tab-item active" onclick="switchTab(1)">
              <div class="tab-name">Homelab 2</div>
              <div class="tab-stats">11 nodes â€¢ 10 connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(1)" title="Rename tab">âœï¸</button>
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(${index})" title="Delete tab">ðŸ—‘ï¸</button>
              </div>
            </div>
          </div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="new-tab-name" placeholder="New tab name..." style="flex: 1; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <button class="btn-save" onclick="createNewTab()">+ Add Tab</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="tabs-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="rollback-modal">
      <div class="modal-content" style="max-width: 700px;">
        <h3>Version History</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Limit: Snapshots</p>
        <div id="rollback-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 450px; overflow-y: auto; margin-bottom: 15px;">
          <div style="text-align: center; padding: 40px; color: var(--text-soft);">No version history yet. Versions are saved automatically when you save the file.</div>
        </div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <button class="btn-cancel" onclick="clearRollbackHistory()">Clear History</button>
          <button class="btn-save" onclick="createManualSnapshot()">Create Snapshot</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="rollback-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="audit-log-modal">
      <div class="modal-content" style="max-width: 800px;">
        <h3>Audit Log</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Track all changes made to your topology</p>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <select id="audit-filter" style="padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
            <option value="all">All Events</option>
            <option value="node">Node Operations</option>
            <option value="connection">Connections</option>
            <option value="style">Style Changes</option>
            <option value="rack">Rack Operations</option>
            <option value="layer">Layer Changes</option>
          </select>
          <button class="btn-save" onclick="exportAuditLog()">Export</button>
        </div>
        <div id="audit-log-list" style="display: flex; flex-direction: column; gap: 4px; max-height: 450px; overflow-y: auto; margin-bottom: 15px; font-family: monospace; font-size: 12px;">
          <div style="text-align: center; padding: 40px; color: var(--text-soft);">No audit entries yet</div>
        </div>
        <div style="display: flex; gap: 8px;">
          <button class="btn-cancel" onclick="clearAuditLog()">Clear Log</button>
          <button class="btn-cancel" id="audit-log-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="secrets-modal">
      <div class="modal-content" style="max-width: 600px;">
        <h3>Notes</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Notes can also be stored with AES 256 encryption</p>
        <div id="secrets-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 350px; overflow-y: auto; margin-bottom: 15px;">
        </div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="new-secret-name" placeholder="Note name (e.g., 'Root Passwords')..." style="flex: 1; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <button class="btn-save" onclick="createNewSecret()">+ Add Note</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="secrets-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="secret-editor-modal">
      <div class="modal-content" style="max-width: 600px;">
        <h3 id="secret-editor-title">Edit Note</h3>
        <textarea id="secret-editor-content" placeholder="Enter sensitive information here..." style="width: 100%; height: 200px; padding: 12px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main); font-family: monospace; resize: vertical; margin-bottom: 15px;"></textarea>
        <div style="margin-bottom: 15px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
          <input type="checkbox" id="secret-auto-encrypt" checked="" style="cursor: pointer;">
          <span>Encrypt Note</span>
          </label>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" onclick="closeSecretEditor()">Cancel</button>
          <button class="btn-save" onclick="saveSecret()">Save</button>
        </div>
      </div>
    </div>
    <div id="context-menu" style="display: none !important;">
    </div>
    <header>
      <div class="title-block">
        <h1 id="page-title" class="editable-page-title">The One File</h1>
        <div class="save-row">
          <button id="save-file-btn" class="save-btn" type="button">Save File</button>
          <label style="display: flex;align-items: center;gap: 4px;font-size: 12px;color: var(--text-soft);cursor: pointer;user-select: none;">
          <input type="checkbox" id="encrypt-toggle" style="cursor: pointer">
          <span title="Encrypt data with password">Encrypt</span>
          </label>
          <span id="save-help-btn" class="help-icon" title="Why save?">?</span>
        </div>
      </div>
      <div id="topbar-menu">
        <button id="back-to-topology-btn" title="Exit rack view and return to topology" style="padding: 6px 12px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;display: none;">â† Back to Topology</button>
        <button id="add-node-btn" class="save-btn" title="Add new node" style="background: var(--accent)" draggable="true">+ Node</button>
        <button id="add-rack-btn" class="save-btn" title="Add new rack" style="background: var(--accent); margin-left: 8px;" draggable="true">+ Rack</button>
        <button id="undo-btn" title="Undo (Ctrl+Z)" style="padding: 6px 12px; background: var(--btn-bg); color: var(--btn-text); border: 1px solid var(--edge-main); border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600; opacity: 1;">â†¶</button>
        <button id="redo-btn" title="Redo (Ctrl+Y)" style="padding: 6px 12px; background: var(--btn-bg); color: var(--btn-text); border: 1px solid var(--edge-main); border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600; opacity: 0.5;" disabled="">â†·</button>
        <input type="text" id="search-nodes" placeholder="Search nodes..." title="Search by name, IP, MAC, role, or tag" style="padding: 6px 12px;background: var(--input-bg);color: var(--input-text);border: 1px solid var(--input-border);border-radius: 6px;font-family: var(--input-font);font-size: var(--input-font-size);width: 180px;">
        <button id="layers-btn" title="Toggle layer visibility" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Layers</button>
        <button id="tabs-btn" title="Manage document tabs" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Tabs</button>
        <button id="rollback-btn" title="View version history" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Snapshots</button>
        <button id="audit-log-btn" title="View audit log" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Audit</button>
        <button id="secrets-btn" title="Manage encrypted notes" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Notes</button>
        <button onclick="screenshotCanvas()" title="Export canvas as PNG image" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">PNG</button>
        <button onclick="exportCanvasSVG()" title="Export canvas as SVG vector" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">SVG</button>
        <button id="settings-btn" title="Page settings">âš™ï¸</button>
      </div>
      <button id="mobile-menu-toggle" class="mobile-menu-btn">â˜°</button>
      <div class="header-resizer" id="header-resizer">
        <svg class="resizer-icon" width="40" height="6" viewBox="0 0 40 6" xmlns="http://www.w3.org/2000/svg">
          <circle cx="14" cy="3" r="2"></circle>
          <circle cx="20" cy="3" r="2"></circle>
          <circle cx="26" cy="3" r="2"></circle>
        </svg>
      </div>
    </header>
    <main>
      <section class="topology-panel">
        <div class="draw-toolbar" id="draw-toolbar" style="display: flex !important;">
          <button type="button" class="toolbar-close-btn" id="draw-toolbar-close-btn" title="Hide draw toolbar">âœ•</button>
          <button id="draw-toggle" title="Draw custom line">âœï¸</button>
          <button id="rect-toggle" title="Draw zone">â–­</button>
          <button id="text-toggle" title="Add text">T</button>
          <select id="rect-style" title="zone style">
            <option value="filled">Filled</option>
            <option value="outlined">Outlined</option>
          </select>
          <input type="color" id="draw-color" value="#f97316" title="Line color">
          <select id="draw-style" title="Line style">
            <option value="solid">Solid</option>
            <option value="dashed">Dashed</option>
            <option value="dotted">Dotted</option>
          </select>
          <select id="draw-arrow" title="Arrow direction">
            <option value="none">No arrows</option>
            <option value="forward">â†’ Right</option>
            <option value="backward">â† Left</option>
            <option value="both">â†” Both</option>
          </select>
          <button id="draw-undo" style="display: none;" title="Undo last point">Undo</button>
        </div>
        <div class="topology-toolbar" id="topology-toolbar" style="display: flex !important;">
          <button type="button" class="toolbar-close-btn" id="topology-toolbar-close-btn" title="Hide add line toolbar">âœ•</button>
          <label for="add-line-select">Add line to:</label>
          <select id="add-line-select"><option value="core-router-2">Core Router 2</option><option value="fw-external-1">External FW 1</option><option value="fw-external-2">External FW 2</option><option value="fw-internal">Internal FW</option><option value="core-switch-1">Core Switch 1</option><option value="core-switch-2">Core Switch 2</option><option value="dc-rack-a1">DC Rack A1</option><option value="dc-rack-a2">DC Rack A2</option><option value="dc-rack-b1">DC Rack B1</option><option value="dc-rack-b2">DC Rack B2</option><option value="dmz-rack">DMZ Rack</option><option value="mgmt-rack">Management Rack</option><option value="wlc-primary">WLC Primary</option><option value="wlc-secondary">WLC Secondary</option><option value="mobile-zone-hq">HQ Mobile Zone</option><option value="mobile-zone-guest">Guest WiFi Zone</option><option value="mobile-zone-iot">IoT Device Zone</option><option value="branch-router-ny">NYC Branch Router</option><option value="branch-router-la">LA Branch Router</option><option value="branch-router-chi">Chicago Branch Router</option><option value="branch-router-lon">London Branch Router</option><option value="branch-router-tokyo">Tokyo Branch Router</option><option value="cloud-aws">AWS Cloud</option><option value="cloud-azure">Azure Cloud</option><option value="cloud-gcp">GCP Cloud</option><option value="isp-primary">ISP Primary</option><option value="isp-secondary">ISP Secondary</option><option value="proxy-server-1">Proxy Server 1</option><option value="proxy-server-2">Proxy Server 2</option><option value="vpn-concentrator">VPN Concentrator</option><option value="nac-server">NAC Server</option><option value="voip-cluster">VoIP Cluster</option><option value="video-conf">Video Conference</option><option value="security-cameras">Security Cameras</option><option value="dev-server-1">Dev Server 1</option><option value="dev-server-2">Dev Server 2</option><option value="test-environment">Test Environment</option><option value="erp-system">ERP System</option><option value="crm-system">CRM System</option><option value="endpoint-1000">Corporate Endpoints</option><option value="dist-switch-floor1">Floor 1 Switch</option><option value="dist-switch-floor2">Floor 2 Switch</option><option value="dist-switch-floor3">Floor 3 Switch</option><option value="dist-switch-floor4">Floor 4 Switch</option><option value="ap-floor1-zone1">AP Floor 1 Zone 1</option><option value="ap-floor2-zone1">AP Floor 2 Zone 1</option><option value="ap-floor3-zone1">AP Floor 3 Zone 1</option><option value="ap-floor4-zone1">AP Floor 4 Zone 1</option><option value="ups-dc-1">UPS DC-1</option><option value="ups-dc-2">UPS DC-2</option><option value="cooling-1">CRAC Unit 1</option><option value="cooling-2">CRAC Unit 2</option></select>
          <input type="color" id="add-line-color" value="#475569" title="Line color" style="width: 30px;height: 24px;border: 1px solid var(--toolbar-border);border-radius: 4px;cursor: pointer;background: transparent;padding: 0;">     
          <select id="add-line-direction" title="Line direction">
            <option value="none">No arrows</option>
            <option value="forward">â†’ Forward</option>
            <option value="backward">â† Backward</option>
            <option value="both">â†” Both</option>
          </select>
          <button id="add-line-btn">Add</button>
        </div>
        <div class="topology-toolbar bulk-toolbar-desktop" id="bulk-toolbar" style="display: none">
          <button type="button" class="toolbar-close-btn" id="bulk-toolbar-close" title="Clear selection">âœ•</button>
          <label style="font-weight: 600; color: var(--accent)">Selected: <span id="bulk-count">0</span></label>
          <button id="bulk-align-left" title="Align left">â¬… Left</button>
          <button id="bulk-align-right" title="Align right">âž¡ Right</button>
          <button id="bulk-align-top" title="Align top">â¬† Top</button>
          <button id="bulk-align-bottom" title="Align bottom">â¬‡ Bottom</button>
          <button id="bulk-distribute-h" title="Distribute horizontally">â†” Distribute H</button>
          <button id="bulk-distribute-v" title="Distribute vertically">â†• Distribute V</button>
          <button id="bulk-clone" title="Clone selected">ðŸ“‹ Clone</button>
          <button id="bulk-delete" title="Delete selected" style="background: var(--danger); color: white;">Delete</button>
        </div>
        <div class="bulk-toolbar-mobile" id="bulk-toolbar-mobile" style="display: none">
          <button type="button" id="bulk-mobile-btn" style="background: var(--accent);color: white;padding: 12px 20px;border-radius: 25px;font-weight: 600;font-size: 16px;box-shadow: 0 4px 12px rgba(0,0,0,0.3);border: none;cursor: pointer;display: flex;align-items: center;gap: 8px;">
          <span id="bulk-count-mobile">0</span>Selected</button>
        </div>
        <div id="bulk-actions-modal" style="display: none;position: fixed;bottom: 0;left: 0;right: 0;background: var(--panel-alt);border-top-left-radius: 20px;border-top-right-radius: 20px;padding: 20px;padding-bottom: env(safe-area-inset-bottom, 20px);box-shadow: 0 -4px 20px rgba(0,0,0,0.5);z-index: 10000;max-height: calc(100vh - 80px);overflow-y: auto;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            <h3 style="margin: 0; color: var(--accent); font-size: 20px;">
              <span id="bulk-count-modal">0</span> Nodes Selected
            </h3>
            <button id="bulk-modal-close" style="background: none;border: none;font-size: 24px;cursor: pointer;color: var(--text-main);padding: 0;width: 32px;height: 32px;">âœ•</button>
          </div>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
            <button id="bulk-align-left-mobile" class="bulk-action-btn">â¬…<br><span style="font-size: 12px;">Align Left</span></button>
            <button id="bulk-align-right-mobile" class="bulk-action-btn">âž¡<br><span style="font-size: 12px;">Align Right</span></button>
            <button id="bulk-align-top-mobile" class="bulk-action-btn">â¬†<br><span style="font-size: 12px;">Align Top</span></button>
            <button id="bulk-align-bottom-mobile" class="bulk-action-btn">â¬‡<br><span style="font-size: 12px;">Align Bottom</span></button>
            <button id="bulk-distribute-h-mobile" class="bulk-action-btn">â†”<br><span style="font-size: 12px;">Distribute H</span></button>
            <button id="bulk-distribute-v-mobile" class="bulk-action-btn">â†•<br><span style="font-size: 12px;">Distribute V</span></button>
            <button id="bulk-lock-mobile" class="bulk-action-btn">ðŸ”’<br><span style="font-size: 12px;">Lock Toggle</span></button>
            <button id="bulk-group-mobile" class="bulk-action-btn">â­•<br><span style="font-size: 12px;">Group Toggle</span></button>
            <button id="bulk-clone-mobile" class="bulk-action-btn">ðŸ“‹<br><span style="font-size: 12px;">Clone All</span></button>
            <button id="bulk-delete-mobile" class="bulk-action-btn" style="background: var(--danger); color: white;">ðŸ—‘<br><span style="font-size: 12px;">Delete All</span></button>
          </div>
          <button id="bulk-clear-mobile" style="width: 100%;margin-top: 16px;padding: 14px;background: var(--panel-main);border: 1px solid var(--edge-main);border-radius: 8px;color: var(--text-main);font-size: 16px;cursor: pointer;">Clear Selection</button>
        </div>
        <div class="canvas-hint" id="canvas-hint">
          <ul>
            <li>Scroll to zoom</li>
            <li>Drag to pan</li>
            <li>Right click to clone and align</li>
            <li>Right click to select multiple</li>
            <li>You have the power</li>
            <li>Your time is NOW!</li>
          </ul>
        </div>
        <div class="legend-container" id="edge-legend" style="display: flex;"><div class="legend-title">Line Legend</div><button type="button" class="legend-close-btn">âœ•</button><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(85, 226, 8); cursor: pointer;"></span><span class="legend-label" contenteditable="true">ISP LINE</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(76, 0, 255); cursor: pointer;"></span><span class="legend-label" contenteditable="true">MY Guest NETWORK</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(128, 255, 0); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(251, 0, 255); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(255, 0, 208); cursor: pointer;"></span><span class="legend-label" contenteditable="true">iPhone (always guest iPhone)</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(249, 115, 22); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div></div>
        <div class="canvas-viewport" id="canvas-viewport">
          <svg id="map" viewBox="-74.99705309342698 -7.395887697909075 4069.861183597212 3052.395887697909" style=""><defs><marker id="arrow-forward" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto" markerUnits="strokeWidth"><path d="M0,0 L0,6 L9,3 z" fill="context-stroke"></path></marker><marker id="arrow-backward" markerWidth="10" markerHeight="10" refX="0" refY="3" orient="auto" markerUnits="strokeWidth"><path d="M9,0 L9,6 L0,3 z" fill="context-stroke"></path></marker></defs><rect x="100" y="100" width="3800" height="2800" fill="none" stroke="#4755694D" stroke-width="20" stroke-dasharray="10 5" rx="8"></rect><g id="canvas-grid"><line x1="100" y1="100" x2="100" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="150" y1="100" x2="150" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="200" y1="100" x2="200" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="250" y1="100" x2="250" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="300" y1="100" x2="300" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="350" y1="100" x2="350" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="400" y1="100" x2="400" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="450" y1="100" x2="450" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="500" y1="100" x2="500" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="550" y1="100" x2="550" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="600" y1="100" x2="600" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="650" y1="100" x2="650" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="700" y1="100" x2="700" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="750" y1="100" x2="750" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="800" y1="100" x2="800" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="850" y1="100" x2="850" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="900" y1="100" x2="900" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="950" y1="100" x2="950" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1000" y1="100" x2="1000" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1050" y1="100" x2="1050" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1100" y1="100" x2="1100" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="1150" y1="100" x2="1150" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1200" y1="100" x2="1200" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1250" y1="100" x2="1250" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1300" y1="100" x2="1300" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1350" y1="100" x2="1350" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="1400" y1="100" x2="1400" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1450" y1="100" x2="1450" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1500" y1="100" x2="1500" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1550" y1="100" x2="1550" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1600" y1="100" x2="1600" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="1650" y1="100" x2="1650" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1700" y1="100" x2="1700" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1750" y1="100" x2="1750" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1800" y1="100" x2="1800" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1850" y1="100" x2="1850" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="1900" y1="100" x2="1900" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1950" y1="100" x2="1950" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2000" y1="100" x2="2000" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2050" y1="100" x2="2050" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2100" y1="100" x2="2100" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="2150" y1="100" x2="2150" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2200" y1="100" x2="2200" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2250" y1="100" x2="2250" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2300" y1="100" x2="2300" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2350" y1="100" x2="2350" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="2400" y1="100" x2="2400" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2450" y1="100" x2="2450" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2500" y1="100" x2="2500" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2550" y1="100" x2="2550" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2600" y1="100" x2="2600" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="2650" y1="100" x2="2650" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2700" y1="100" x2="2700" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2750" y1="100" x2="2750" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2800" y1="100" x2="2800" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2850" y1="100" x2="2850" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="2900" y1="100" x2="2900" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2950" y1="100" x2="2950" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3000" y1="100" x2="3000" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3050" y1="100" x2="3050" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3100" y1="100" x2="3100" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="3150" y1="100" x2="3150" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3200" y1="100" x2="3200" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3250" y1="100" x2="3250" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3300" y1="100" x2="3300" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3350" y1="100" x2="3350" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="3400" y1="100" x2="3400" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3450" y1="100" x2="3450" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3500" y1="100" x2="3500" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3550" y1="100" x2="3550" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3600" y1="100" x2="3600" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="3650" y1="100" x2="3650" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3700" y1="100" x2="3700" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3750" y1="100" x2="3750" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3800" y1="100" x2="3800" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3850" y1="100" x2="3850" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="3900" y1="100" x2="3900" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="100" x2="3900" y2="100" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="150" x2="3900" y2="150" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="200" x2="3900" y2="200" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="250" x2="3900" y2="250" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="300" x2="3900" y2="300" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="350" x2="3900" y2="350" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="400" x2="3900" y2="400" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="450" x2="3900" y2="450" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="500" x2="3900" y2="500" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="550" x2="3900" y2="550" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="600" x2="3900" y2="600" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="650" x2="3900" y2="650" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="700" x2="3900" y2="700" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="750" x2="3900" y2="750" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="800" x2="3900" y2="800" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="850" x2="3900" y2="850" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="900" x2="3900" y2="900" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="950" x2="3900" y2="950" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1000" x2="3900" y2="1000" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1050" x2="3900" y2="1050" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1100" x2="3900" y2="1100" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="1150" x2="3900" y2="1150" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1200" x2="3900" y2="1200" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1250" x2="3900" y2="1250" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1300" x2="3900" y2="1300" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1350" x2="3900" y2="1350" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="1400" x2="3900" y2="1400" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1450" x2="3900" y2="1450" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1500" x2="3900" y2="1500" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1550" x2="3900" y2="1550" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1600" x2="3900" y2="1600" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="1650" x2="3900" y2="1650" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1700" x2="3900" y2="1700" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1750" x2="3900" y2="1750" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1800" x2="3900" y2="1800" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1850" x2="3900" y2="1850" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="1900" x2="3900" y2="1900" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1950" x2="3900" y2="1950" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2000" x2="3900" y2="2000" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2050" x2="3900" y2="2050" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2100" x2="3900" y2="2100" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="2150" x2="3900" y2="2150" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2200" x2="3900" y2="2200" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2250" x2="3900" y2="2250" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2300" x2="3900" y2="2300" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2350" x2="3900" y2="2350" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="2400" x2="3900" y2="2400" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2450" x2="3900" y2="2450" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2500" x2="3900" y2="2500" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2550" x2="3900" y2="2550" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2600" x2="3900" y2="2600" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="2650" x2="3900" y2="2650" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2700" x2="3900" y2="2700" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2750" x2="3900" y2="2750" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2800" x2="3900" y2="2800" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2850" x2="3900" y2="2850" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="2900" x2="3900" y2="2900" stroke="#47556933" stroke-width="1"></line></g><g class="rect-group" data-rect-id="rect-1765238219615"><rect class="rect-shape" x="2680.053955078125" y="251.44879150390625" width="814.10400390625" height="389.26678466796875" style="fill: rgb(236, 9, 153); fill-opacity: 0.3; stroke: rgb(236, 9, 153); stroke-width: 2px; stroke-dasharray: none; cursor: move;"></rect><g class="rect-delete-btn" style="cursor: pointer; display: none;"><circle cx="3484.157958984375" cy="261.44879150390625" r="12" style="fill: rgb(245, 101, 101); stroke: white; stroke-width: 2;"></circle><text x="3484.157958984375" y="261.44879150390625" text-anchor="middle" dominant-baseline="middle" style="fill: white; font-size: 16px; font-weight: bold; pointer-events: none;">Ã—</text></g></g><path d="M 2071.640165880771 218.24354238566275 Q 2069.3039587352528 345.82772790170964 2066.9677515897347 473.4119134177565" fill="none" class="edge" data-edge-id="internet-internet-copy-1765238145151" data-from="internet" data-to="internet-copy" style="stroke: rgb(85, 226, 8); stroke-width: 4;"></path><path d="M 2071.640165880771 218.24354238566275 Q 2069.3039587352528 345.82772790170964 2066.9677515897347 473.4119134177565" fill="none" data-edge-id="internet-internet-copy-1765238145151" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 1921.3019190702034 570.8918786277175 1775.6360865506722 668.3718438376784" fill="none" class="edge" data-edge-id="internet-copy-opnsense-copy-1765238187451" data-from="internet-copy" data-to="opnsense-copy" style="stroke: rgb(76, 0, 255); stroke-width: 4;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 1921.3019190702034 570.8918786277175 1775.6360865506722 668.3718438376784" fill="none" data-edge-id="internet-copy-opnsense-copy-1765238187451" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2000.8787827715962 627.8447547749242 1934.7898139534577 782.2775961320921" fill="none" class="edge" data-edge-id="internet-copy-docker-copy-1765238242477" data-from="internet-copy" data-to="docker-copy" style="stroke: rgb(76, 0, 255); stroke-width: 4;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2000.8787827715962 627.8447547749242 1934.7898139534577 782.2775961320921" fill="none" data-edge-id="internet-copy-docker-copy-1765238242477" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2112.546995662221 620.5620704487524 2158.1262397347077 767.7122274797483" fill="none" class="edge" data-edge-id="internet-copy-docker-copy-1-1765238244637" data-from="internet-copy" data-to="docker-copy-1" style="stroke: rgb(76, 0, 255); stroke-width: 4;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2112.546995662221 620.5620704487524 2158.1262397347077 767.7122274797483" fill="none" data-edge-id="internet-copy-docker-copy-1-1765238244637" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2206.4130845294085 552.590055067893 2345.8584174690827 631.7681967180296" fill="none" class="edge" data-edge-id="internet-copy-docker-copy-2-1765238246233" data-from="internet-copy" data-to="docker-copy-2" style="stroke: rgb(76, 0, 255); stroke-width: 4;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2206.4130845294085 552.590055067893 2345.8584174690827 631.7681967180296" fill="none" data-edge-id="internet-copy-docker-copy-2-1765238246233" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2071.640165880771 218.24354238566275 Q 2414.759822984287 262.92762699742593 2757.879480087803 307.6117116091891" fill="none" class="edge" data-edge-id="internet-opnsense-copy-1-1765238266117" data-from="internet" data-to="opnsense-copy-1" style="stroke: rgb(128, 255, 0); stroke-width: 4;"></path><path d="M 2071.640165880771 218.24354238566275 Q 2414.759822984287 262.92762699742593 2757.879480087803 307.6117116091891" fill="none" data-edge-id="internet-opnsense-copy-1-1765238266117" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2757.879480087803 307.6117116091891 Q 2979.171899521397 314.04065142852505 3200.4643189549906 320.469591247861" fill="none" class="edge" data-edge-id="opnsense-copy-1-dns-1765238347996" data-from="opnsense-copy-1" data-to="dns" style="stroke: rgb(251, 0, 255); stroke-width: 4;"></path><path d="M 2757.879480087803 307.6117116091891 Q 2979.171899521397 314.04065142852505 3200.4643189549906 320.469591247861" fill="none" data-edge-id="opnsense-copy-1-dns-1765238347996" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 3200.4643189549906 320.469591247861 Q 3094.0802247167094 404.02690325957974 2987.696130478428 487.5842152712985" fill="none" class="edge" data-edge-id="dns-desktop-1765238386101" data-from="dns" data-to="desktop" style="stroke: rgb(255, 0, 208); stroke-width: 4;"></path><path d="M 3200.4643189549906 320.469591247861 Q 3094.0802247167094 404.02690325957974 2987.696130478428 487.5842152712985" fill="none" data-edge-id="dns-desktop-1765238386101" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 3312.857751572178 502.58220111114224 Q 3256.6610352635844 411.5258961795016 3200.4643189549906 320.469591247861" fill="none" class="edge" data-edge-id="phone-dns-1765238391156" data-from="phone" data-to="dns" style="stroke: rgb(255, 0, 208); stroke-width: 4;"></path><path d="M 3312.857751572178 502.58220111114224 Q 3256.6610352635844 411.5258961795016 3200.4643189549906 320.469591247861" fill="none" data-edge-id="phone-dns-1765238391156" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><polyline class="edge" data-edge-id="custom-1765238841477" fill="none" marker-start="url(#arrow-backward)" marker-end="url(#arrow-forward)" points="2905.255615234375,805.3433837890625 3189.95556640625,1005.8710327148438 2788.900390625,1008.3466796875" style="stroke: rgb(249, 115, 22); stroke-width: 4; stroke-dasharray: none;"></polyline><polyline points="2905.255615234375,805.3433837890625 3189.95556640625,1005.8710327148438 2788.900390625,1008.3466796875" data-edge-id="custom-1765238841477" style="fill: none; stroke: transparent; stroke-width: 20; cursor: pointer;"></polyline><g class="node-group" data-node-id="internet" transform="translate(2071.640165880771,218.24354238566275)" style="cursor: grab;"><circle r="127.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><rect x="-85" y="-85" width="170" height="170" rx="4" class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"></rect><text class="node-label" x="0" y="-23.8" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Internet</text><text class="node-sub" x="0" y="34" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="internet-copy" transform="translate(2066.9677515897347,473.4119134177565)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-55" y="-44" width="110" height="88" rx="4"></rect><line x1="-46.75" y1="-27.5" x2="46.75" y2="-27.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="-2.75" x2="46.75" y2="-2.75" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="22" x2="46.75" y2="22" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="-44" x2="-27.5" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="-44" x2="11" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="-19.25" x2="-8.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="-19.25" x2="30.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="5.5" x2="-27.5" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="5.5" x2="11" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="30.25" x2="-8.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="30.25" x2="30.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">OPNSENSE</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="opnsense-copy" transform="translate(1775.6360865506722,668.3718438376784)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-55" y="-44" width="110" height="88" rx="4"></rect><line x1="-46.75" y1="-27.5" x2="46.75" y2="-27.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="-2.75" x2="46.75" y2="-2.75" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="22" x2="46.75" y2="22" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="-44" x2="-27.5" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="-44" x2="11" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="-19.25" x2="-8.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="-19.25" x2="30.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="5.5" x2="-27.5" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="5.5" x2="11" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="30.25" x2="-8.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="30.25" x2="30.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Docker</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="docker-copy" transform="translate(1934.7898139534577,782.2775961320921)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-55" y="-44" width="110" height="88" rx="4"></rect><line x1="-46.75" y1="-27.5" x2="46.75" y2="-27.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="-2.75" x2="46.75" y2="-2.75" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="22" x2="46.75" y2="22" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="-44" x2="-27.5" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="-44" x2="11" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="-19.25" x2="-8.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="-19.25" x2="30.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="5.5" x2="-27.5" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="5.5" x2="11" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="30.25" x2="-8.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="30.25" x2="30.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Docker2</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="docker-copy-1" transform="translate(2158.1262397347077,767.7122274797483)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-55" y="-44" width="110" height="88" rx="4"></rect><line x1="-46.75" y1="-27.5" x2="46.75" y2="-27.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="-2.75" x2="46.75" y2="-2.75" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="22" x2="46.75" y2="22" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="-44" x2="-27.5" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="-44" x2="11" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="-19.25" x2="-8.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="-19.25" x2="30.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="5.5" x2="-27.5" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="5.5" x2="11" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="30.25" x2="-8.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="30.25" x2="30.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Docker3</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="docker-copy-2" transform="translate(2345.8584174690827,631.7681967180296)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-55" y="-44" width="110" height="88" rx="4"></rect><line x1="-46.75" y1="-27.5" x2="46.75" y2="-27.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="-2.75" x2="46.75" y2="-2.75" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="22" x2="46.75" y2="22" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="-44" x2="-27.5" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="-44" x2="11" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="-19.25" x2="-8.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="-19.25" x2="30.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="5.5" x2="-27.5" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="5.5" x2="11" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="30.25" x2="-8.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="30.25" x2="30.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Docker 4</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="opnsense-copy-1" transform="translate(2757.879480087803,307.6117116091891)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-55" y="-44" width="110" height="88" rx="4"></rect><line x1="-46.75" y1="-27.5" x2="46.75" y2="-27.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="-2.75" x2="46.75" y2="-2.75" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="22" x2="46.75" y2="22" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="-44" x2="-27.5" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="-44" x2="11" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="-19.25" x2="-8.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="-19.25" x2="30.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="5.5" x2="-27.5" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="5.5" x2="11" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="30.25" x2="-8.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="30.25" x2="30.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">OPNSENSE GUEST</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="phone" transform="translate(3312.857751572178,502.58220111114224)" style="cursor: grab;"><circle r="181.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-54.45" y="-121" width="108.9" height="242" rx="8"></rect><rect x="-45.980000000000004" y="-102.85" width="91.96000000000001" height="193.60000000000002" rx="4" style="fill: rgb(30, 41, 59);"></rect><rect x="-18.15" y="99.22" width="36.3" height="7.26" rx="2" style="fill: rgb(71, 85, 105);"></rect></g><text class="node-label" x="0" y="-33.88" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Phone</text><text class="node-sub" x="0" y="48.400000000000006" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="desktop" transform="translate(2987.696130478428,487.5842152712985)" style="cursor: grab;"><circle r="220.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-132.3" y="-117.60000000000001" width="264.6" height="176.4" rx="4"></rect><rect x="-110.25" y="-95.55" width="220.5" height="132.3" rx="2" style="fill: rgb(30, 41, 59);"></rect><rect x="-22.05" y="58.800000000000004" width="44.1" height="44.1"></rect><rect x="-73.5" y="102.89999999999999" width="147" height="22.05" rx="2"></rect></g><text class="node-label" x="0" y="-41.160000000000004" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Desktop</text><text class="node-sub" x="0" y="58.800000000000004" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="dns" transform="translate(3200.4643189549906,320.469591247861)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><path d="
             M -44 11
             Q -60.50000000000001 11 -60.50000000000001 -5.5
             Q -60.50000000000001 -27.5 -38.5 -27.5
             Q -38.5 -49.5 -11 -49.5
             Q 5.5 -60.50000000000001 27.5 -44
             Q 55 -44 60.50000000000001 -16.5
             Q 71.5 -5.5 60.50000000000001 11
             Q 60.50000000000001 27.5 38.5 27.5
             L -27.5 27.5
             Q -49.5 27.5 -49.5 11
             Z
            " class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"></path><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">DNS</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="racked" transform="translate(2600.8697010779656,975.5665527522032)" style="cursor: grab;"><circle r="205.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-164.4" y="-82.2" width="328.8" height="164.4" rx="4"></rect><line x1="-123.3" y1="-41.1" x2="-123.3" y2="41.1" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="-54.8" y1="-41.1" x2="-54.8" y2="41.1" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="13.700000000000003" y1="-41.1" x2="13.700000000000003" y2="41.1" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><circle cx="123.3" cy="0" r="13.700000000000001" style="fill: rgb(74, 222, 128);"></circle></g><text class="node-label" x="0" y="-38.36000000000001" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Racked</text><text class="node-sub" x="0" y="54.800000000000004" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;"></text></g><g class="text-group" data-text-id="text-1765238422602"><text class="text-element" x="2402.130859375" y="736.7828979492188" dominant-baseline="middle" style="fill: rgb(226, 232, 240); font-size: 48px; font-weight: normal; font-style: normal; text-anchor: start; text-decoration: none; opacity: 1; cursor: move; user-select: none;"><tspan x="2402.130859375" dy="0">Double click on desktop</tspan><tspan x="2402.130859375" dy="57.599999999999994">or long press on mobile</tspan><tspan x="2402.130859375" dy="57.599999999999994">to enter rack canvas view</tspan></text><g class="text-delete-btn" style="cursor: pointer; display: none;"><circle cx="2422.130859375" cy="688.7828979492188" r="12" style="fill: rgb(245, 101, 101); stroke: white; stroke-width: 2;"></circle><text x="2422.130859375" y="688.7828979492188" text-anchor="middle" dominant-baseline="middle" style="fill: white; font-size: 16px; font-weight: bold; pointer-events: none;">Ã—</text></g></g></svg>
        </div>
        <div class="minimap-zoom-wrapper" id="minimap-zoom-wrapper" style="display: block;">
          <button type="button" class="minimap-close-btn" id="minimap-close-btn" title="Hide map &amp; zoom">âœ•</button>
          <div class="minimap-container" id="minimap-container">
            <svg id="minimap" viewBox="0 0 4000 3000">
              <line x1="2071.640165880771" y1="218.24354238566275" x2="2066.9677515897347" y2="473.4119134177565" class="minimap-edge"></line><line x1="2066.9677515897347" y1="473.4119134177565" x2="1775.6360865506722" y2="668.3718438376784" class="minimap-edge"></line><line x1="2066.9677515897347" y1="473.4119134177565" x2="1934.7898139534577" y2="782.2775961320921" class="minimap-edge"></line><line x1="2066.9677515897347" y1="473.4119134177565" x2="2158.1262397347077" y2="767.7122274797483" class="minimap-edge"></line><line x1="2066.9677515897347" y1="473.4119134177565" x2="2345.8584174690827" y2="631.7681967180296" class="minimap-edge"></line><line x1="2071.640165880771" y1="218.24354238566275" x2="2757.879480087803" y2="307.6117116091891" class="minimap-edge"></line><line x1="2757.879480087803" y1="307.6117116091891" x2="3200.4643189549906" y2="320.469591247861" class="minimap-edge"></line><line x1="3200.4643189549906" y1="320.469591247861" x2="2987.696130478428" y2="487.5842152712985" class="minimap-edge"></line><line x1="3312.857751572178" y1="502.58220111114224" x2="3200.4643189549906" y2="320.469591247861" class="minimap-edge"></line><circle cx="2071.640165880771" cy="218.24354238566275" r="40" class="minimap-node"></circle><circle cx="2066.9677515897347" cy="473.4119134177565" r="40" class="minimap-node"></circle><circle cx="1775.6360865506722" cy="668.3718438376784" r="40" class="minimap-node"></circle><circle cx="1934.7898139534577" cy="782.2775961320921" r="40" class="minimap-node"></circle><circle cx="2158.1262397347077" cy="767.7122274797483" r="40" class="minimap-node"></circle><circle cx="2345.8584174690827" cy="631.7681967180296" r="40" class="minimap-node"></circle><circle cx="2757.879480087803" cy="307.6117116091891" r="40" class="minimap-node"></circle><circle cx="3312.857751572178" cy="502.58220111114224" r="40" class="minimap-node"></circle><circle cx="2987.696130478428" cy="487.5842152712985" r="40" class="minimap-node"></circle><circle cx="3200.4643189549906" cy="320.469591247861" r="40" class="minimap-node"></circle><circle cx="2600.8697010779656" cy="975.5665527522032" r="40" class="minimap-node"></circle><rect class="minimap-viewport" id="minimap-viewport" x="-74.99705309342698" y="-7.395887697909075" width="4069.861183597212" height="3052.395887697909"></rect>
            </svg>
          </div>
          <div class="zoom-toolbar" id="zoom-toolbar">
            <button id="zoom-in-btn" title="Zoom in">+</button>
            <div class="zoom-level" id="zoom-level">98%</div>
            <button id="zoom-out-btn" title="Zoom out">-</button>
            <div class="divider"></div>
            <button id="zoom-fit-btn" title="Fit to view">[ ]</button>
            <button id="zoom-reset-btn" title="Reset view">R</button>
          </div>
        </div>
        <button type="button" id="edge-legend-mini" class="legend-mini-btn" style="bottom: 10px; display: none;">Line Legend</button>
        <button type="button" id="minimap-mini" class="legend-mini-btn" style="right: 10px; left: auto; bottom: 10px; display: none;">Map</button>
        <button type="button" id="draw-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: 10px; right: auto; display: none;">Draw</button>
        <button type="button" id="topology-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: auto; right: 40px; display: none;">Add Line</button>
      <button type="button" id="edge-legend-mini" class="legend-mini-btn" style="bottom: 10px; display: none;">Legend</button><button type="button" id="minimap-mini" class="legend-mini-btn" style="right: 10px; left: auto; bottom: 10px; display: none;">Map</button><button type="button" id="draw-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: 10px; right: auto; display: none;">Draw</button><button type="button" id="topology-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: auto; right: 40px; display: none;">Add Line</button><button type="button" id="edge-legend-mini" class="legend-mini-btn" style="bottom: 10px; display: none;">Legend</button><button type="button" id="minimap-mini" class="legend-mini-btn" style="right: 10px; left: auto; bottom: 10px; display: none;">Map</button><button type="button" id="draw-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: 10px; right: auto; display: none;">Draw</button><button type="button" id="topology-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: auto; right: 40px; display: none;">Add Line</button><button type="button" id="edge-legend-mini" class="legend-mini-btn" style="bottom: 10px; display: none;">Legend</button><button type="button" id="topology-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: auto; right: 40px; display: none;">Add Line</button><button type="button" id="minimap-mini" class="legend-mini-btn" style="right: 10px; left: auto; bottom: 10px; display: none;">Map</button><button type="button" id="draw-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: 10px; right: auto; display: none;">Draw</button></section>
      <aside class="details-panel" id="details-panel">
        <div class="sidebar-resizer" id="sidebar-resizer">
          <svg class="resizer-icon" width="6" height="40" viewBox="0 0 6 40" xmlns="http://www.w3.org/2000/svg">
            <circle cx="3" cy="14" r="2"></circle>
            <circle cx="3" cy="20" r="2"></circle>
            <circle cx="3" cy="26" r="2"></circle>
          </svg>
        </div>
        <div class="mobile-footer-resizer" id="mobile-footer-resizer">
          <svg class="resizer-icon" width="40" height="6" viewBox="0 0 40 6" xmlns="http://www.w3.org/2000/svg">
            <circle cx="14" cy="3" r="2"></circle>
            <circle cx="20" cy="3" r="2"></circle>
            <circle cx="26" cy="3" r="2"></circle>
          </svg>
        </div>
        <div id="node-panel" style="display: none;">
          <div class="details-name editable-text" id="node-name">Core Router 1</div>
          <div class="details-ip editable-text" id="node-ip">10.0.0.1</div>
          <div class="details-role" id="node-role">Core Routing</div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px;">MAC:</span>
            <span class="editable-text" id="node-mac" style="margin-left: 8px; font-size: 14px;">00:1A:2B:3C:4D:01</span>
          </div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px;">Rack Unit:</span>
            <span class="editable-text" id="node-rack" style="margin-left: 8px; font-size: 14px;">--</span>
          </div>
          <div class="details-info-row" id="uheight-row" style="display: none;">
            <span style="color: var(--text-soft); font-size: 14px;">U Height:</span>
            <span class="editable-text" id="node-uheight" style="margin-left: 8px; font-size: 14px;">2U</span>
          </div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px;">Layer:</span>
            <select id="node-layer" style="margin-left: 8px; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;">
              <option value="physical">Physical</option>
              <option value="logical">Logical</option>
              <option value="security">Security</option>
              <option value="application">Application</option>
            </select>
          </div>
          <div class="details-info-row" id="assigned-rack-row" style="display: flex;">
            <span style="color: var(--text-soft); font-size: 14px;">Assigned Rack:</span>
            <select id="node-assigned-rack" style="margin-left: 8px; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;"><option value="">None</option><option value="racked">Racked</option></select>
          </div>
          <div class="details-info-row" id="rack-capacity-row" style="display: none;">
            <span style="color: var(--text-soft); font-size: 14px;">Rack Capacity:</span>
            <select id="node-rack-capacity" style="margin-left: 8px; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;">
              <option value="42">42U</option>
              <option value="48">48U</option>
              <option value="24">24U</option>
              <option value="12">12U</option>
			  <option value="6">6U</option>
            </select>
          </div>
		  <details id="rack-contents-section" style="display: none; margin-top: 12px; margin-bottom: 12px; padding: 10px; background: var(--panel-alt); border-radius: 6px;" open="">
            <summary style="color: var(--accent); font-weight: 600; font-size: 14px; cursor: pointer;">Nodes in Rack (<span id="rack-contents-count">0</span>)</summary>
            <div id="rack-contents-list" style="max-height: 200px; overflow-y: auto; margin-top: 8px;"></div>
          </details>
          <div class="badge-row" id="node-tags"><span class="badge" style="cursor: pointer; position: relative;"><span>core</span><span style="opacity: 0.6; margin-left: 4px; font-size: 10px;"> âœ•</span></span><span class="badge" style="cursor: pointer; position: relative;"><span>tier-1</span><span style="opacity: 0.6; margin-left: 4px; font-size: 10px;"> âœ•</span></span><span class="badge" style="cursor: pointer; position: relative;"><span>redundant</span><span style="opacity: 0.6; margin-left: 4px; font-size: 10px;"> âœ•</span></span><span class="badge" style="cursor: pointer; opacity: 0.6; border-style: dashed;">+ Add Tag</span></div>
          <div class="size-controls">
            <label>Size:</label>
            <input type="range" id="size-slider" min="20" max="200" value="55">
            <span id="size-value">55</span>
            <button id="reset-size">Reset</button>
          </div>
          <details class="style-section">
            <summary>Styling</summary>
            <div class="style-content">
              <div class="style-row">
                <label>Screen:</label>
                <select id="style-scope">
                  <option value="all">All</option>
                  <option value="desktop">Desktop</option>
                  <option value="tablet">Tablet</option>
                  <option value="mobile">Mobile</option>
                  <option value="fold">Fold</option>
                </select>
              </div>
              <div class="style-row">
                <label>Shape:</label>
                <select id="shape-select">
                  <optgroup label="Basic Shapes">
                    <option value="circle">Circle</option>
                    <option value="square">Square</option>
                    <option value="rectangle">Rectangle</option>
                    <option value="triangle">Triangle</option>
                    <option value="hexagon">Hexagon</option>
                    <option value="diamond">Diamond</option>
                    <option value="star">Star</option>
                    <option value="stop-sign">Stop Sign</option>
                  </optgroup>
                  <optgroup label="Network Equipment">
                    <option value="server">Server</option>
                    <option value="pc">PC / Desktop</option>
                    <option value="laptop">Laptop</option>
                    <option value="phone">Phone / Mobile</option>
                    <option value="router">Router</option>
                    <option value="switch">Switch</option>
                    <option value="firewall">Firewall</option>
                    <option value="cloud">Cloud</option>
                    <option value="database">Database</option>
                    <option value="printer">Printer</option>
                  </optgroup>
                </select>
              </div>
              <div class="style-row">
                <label>Fill Color:</label>
                <input type="color" id="circle-color" value="#1e293b">
              </div>
              <div class="style-row">
                <label>Border Color:</label>
                <input type="color" id="circle-border" value="#475569">
              </div>
              <div class="style-row">
                <label>Title Color:</label>
                <input type="color" id="title-color" value="#e2e8f0">
              </div>
              <div class="style-row">
                <label>Title Font:</label>
                <select id="title-font">
                  <option value="system-ui, sans-serif"> System UI </option>
                  <option value="monospace">Monospace</option>
                  <option value="serif">Serif</option>
                  <option value="cursive">Cursive</option>
                  <option value="'Courier New', monospace"> Courier </option>
                  <option value="Arial, sans-serif">Arial</option>
                  <option value="'Times New Roman', serif"> Times </option>
                </select>
              </div>
              <div class="style-row">
                <label>Title Size:</label>
                <input type="number" id="title-size" min="8" max="100" value="18">
              </div>
              <div class="style-row">
                <label>Sub Color:</label>
                <input type="color" id="sub-color" value="#94a3b8">
              </div>
              <div class="style-row">
                <label>Sub Font:</label>
                <select id="sub-font">
                  <option value="system-ui, sans-serif"> System UI </option>
                  <option value="monospace">Monospace</option>
                  <option value="serif">Serif</option>
                  <option value="cursive">Cursive</option>
                  <option value="'Courier New', monospace"> Courier </option>
                  <option value="Arial, sans-serif">Arial</option>
                  <option value="'Times New Roman', serif"> Times </option>
                </select>
              </div>
              <div class="style-row">
                <label>Sub Size:</label>
                <input type="number" id="sub-size" min="6" max="80" value="13">
              </div>
              <div style="margin-top: 12px;padding-top: 10px;border-top: 1px solid var(--edge-main);">
                <div style="
                  font-size: 12px;
                  color: var(--text-soft);
                  margin-bottom: 8px;
                  text-transform: uppercase;
                  "> Text Position </div>
                <div class="style-row">
                  <label>Name Y:</label>
                  <input type="number" id="title-offset-y" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>Name X:</label>
                  <input type="number" id="title-offset-x" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>IP Y:</label>
                  <input type="number" id="sub-offset-y" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>IP X:</label>
                  <input type="number" id="sub-offset-x" min="-100" max="100" value="0" style="width: 60px">
                </div>
              </div>
              <button id="reset-styles" style="width: 100%;margin-top: 10px;padding: 8px;background: var(--panel);color: var(--text-main);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: clamp(13px, 1.5vw, 17px);">Reset Styles</button>
            </div>
          </details>
          <div class="section-label">Notes</div>
          <ul class="list" id="node-notes"><li><span style="flex: 1 1 0%;">Primary core router</span><span class="delete-note">âœ•</span></li><li><span style="flex: 1 1 0%;">BGP peering enabled</span><span class="delete-note">âœ•</span></li></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-note-input" placeholder="Type new note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-note-btn" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-node-btn" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: rgb(255, 255, 255);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;width: 100%;">Delete Node</button>
        </div>
        <div id="edge-panel" style="display: none;">
          <div class="details-name" id="edge-title">Custom line</div>
          <div class="style-row" style="margin-top: 10px">
            <label>Width:</label>
            <input type="number" id="edge-width" min="1" max="20" value="4">
          </div>
          <div class="style-row">
            <label>Color:</label>
            <input type="color" id="edge-color" value="#475569">
          </div>
          <div class="style-row">
            <label>Line Style:</label>
            <select id="edge-line-style">
              <option value="solid">Solid</option>
              <option value="dashed">Dashed</option>
              <option value="dotted">Dotted</option>
            </select>
          </div>
          <div class="style-row">
            <label>Direction:</label>
            <select id="edge-direction">
              <option value="none">No arrows</option>
              <option value="forward">â†’ Forward</option>
              <option value="backward">â† Backward</option>
              <option value="both">â†” Bidirectional</option>
            </select>
          </div>
          <div class="style-row" id="edge-from-port-row" style="display: none;">
            <label>From Port:</label>
            <input type="text" id="edge-from-port" placeholder="e.g. eth0, gi0/1" style="flex: 1;">
          </div>
          <div class="style-row" id="edge-to-port-row" style="display: none;">
            <label>To Port:</label>
            <input type="text" id="edge-to-port" placeholder="e.g. eth1, gi0/2" style="flex: 1;">
          </div>
          <div class="section-label">Line Notes</div>
          <ul class="list" id="edge-notes"></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-edge-note" placeholder="Add note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-edge-note" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-edge" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Delete Line</button>
        </div>
        <div id="rect-panel" style="display: none">
          <div class="details-name" id="rect-title">Zone</div>
          <div class="style-row" id="rect-fill-row" style="margin-top: 10px">
            <label>Fill Color:</label>
            <input type="color" id="rect-color" value="#f97316">
          </div>
          <div class="style-row">
            <label>Border Color:</label>
            <input type="color" id="rect-border-color" value="#f97316">
          </div>
          <div class="style-row">
            <label>Border Width:</label>
            <input type="number" id="rect-border-width" min="0" max="20" value="2">
          </div>
          <div class="style-row">
            <label>Style:</label>
            <select id="rect-style-select">
              <option value="filled">Filled</option>
              <option value="outlined">Outlined</option>
            </select>
          </div>
          <div class="section-label">Zone Notes</div>
          <ul class="list" id="rect-notes"></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-rect-note" placeholder="Add note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-rect-note" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-rect" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Delete Zone</button>
        </div>
        <div id="text-panel" style="display: none;">
          <div class="details-name" id="text-title">Text Element</div>
          <div class="style-row" style="margin-top: 10px">
            <label>Content:</label>
            <textarea id="text-content" placeholder="Enter text..." style="width: 100%;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: 14px;min-height: 80px;resize: vertical;font-family: inherit;"></textarea>
          </div>
          <div class="style-row">
            <label>Font Size:</label>
            <input type="number" id="text-font-size" min="8" max="200" value="18" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);">
          </div>
          <div class="style-row">
            <label>Color:</label>
            <input type="color" id="text-color" value="#e2e8f0">
          </div>
          <div class="style-row">
            <label>Font Weight:</label>
            <select id="text-font-weight" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="normal">Normal</option>
              <option value="bold">Bold</option>
              <option value="600">Semi-Bold</option>
              <option value="300">Light</option>
            </select>
          </div>
          <div class="style-row">
            <label>Font Style:</label>
            <select id="text-font-style" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="normal">Normal</option>
              <option value="italic">Italic</option>
            </select>
          </div>
          <div class="style-row">
            <label>Text Align:</label>
            <select id="text-align" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="start">Left</option>
              <option value="middle">Center</option>
              <option value="end">Right</option>
            </select>
          </div>
          <div class="style-row">
            <label>Text Decoration:</label>
            <select id="text-decoration" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="none">None</option>
              <option value="underline">Underline</option>
              <option value="line-through">Strike Through</option>
            </select>
          </div>
          <div class="style-row">
            <label>Background:</label>
            <input type="color" id="text-bg-color" value="#000000">
            <label style="margin-left: 10px; display: flex; align-items: center; gap: 6px;">
            <input type="checkbox" id="text-bg-enabled" style="cursor: pointer;">
            <span style="font-size: 13px;">Enable</span>
            </label>
          </div>
          <div class="style-row">
            <label>Opacity:</label>
            <input type="range" id="text-opacity" min="0" max="1" step="0.1" value="1" style="flex: 1">
            <span id="text-opacity-val" style="min-width: 35px; text-align: right">100%</span>
          </div>
          <button id="delete-text" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;width: 100%;"> Delete Text </button>
        </div>
        <details class="style-section" open="">
          <summary>Page Layout</summary>
          <div class="style-content">
            <div style="padding: 12px; background: var(--panel-alt); border-radius: 6px; color: var(--text-soft); font-size: 13px; line-height: 1.6;">
              <strong style="color: var(--accent); display: block; margin-bottom: 8px;">Drag to Resize:</strong>
              â€¢ <strong>Header:</strong> Drag the bottom edge of the header bar<br>
              â€¢ <strong>Sidebar:</strong> Drag the left edge of the sidebar panel<br>
              â€¢ <strong>Mobile:</strong> Drag the top edge of the footer panel<br>
              <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--edge-main); font-size: 12px;">
                Hover over panel edges to see resize handles
              </div>
            </div>
          </div>
        </details>
      </aside>
    </main>
    <script id="nodes-json" type="application/json">{}</script>
    <script id="topology-state" type="application/json">ENCRYPTED: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</script>
    <script>
      const BASE_NODE_DATA = JSON.parse(document.getElementById("nodes-json").textContent, );
      let currentNodeId = "host";
      let textDrawMode = false;
      let currentEdgeId = null;
      let currentStyleScope = "all";
      let NODE_DATA = {};
      let EDGE_DATA = {
       list: []
      };
      let currentRectId = null;
      let currentTextId = null;
      let rectDrawMode = false;
      let RECT_DATA = {
       list: []
      };
      let TEXT_DATA = {
       list: []
      };
      let EDGE_LEGEND = {};
      let freeDrawMode = false;
      let savedPositions = {};
      let savedSizes = {};
      let savedStyles = {};
      let legendCollapsed = false;
      let minimapCollapsed = false;
      let drawToolbarCollapsed = false;
      let activeLayers = new Set(["physical", "logical", "security", "application"]);
      let currentView = {
       mode: "topology",  
       rackId: null      
      };
      let savedTopologyView = null; 
      let topologyToolbarCollapsed = false;
      let legendMiniBtn = null;
      let minimapMiniBtn = null;
      let drawToolbarMiniBtn = null;
      let topologyToolbarMiniBtn = null;
      
      let undoStack = [];
      let redoStack = [];
      const MAX_UNDO_STACK = 50;
      
      let selectedNodes = new Set();
      let selectedEdges = new Set();
      let selectedRects = new Set();
      let selectedTexts = new Set();
      let isSelecting = false;
      let selectionStart = null;
      let selectionRect = null;
      let isDraggingSelection = false;
      let dragSelectionStart = null;
      
      let clipboard = null;
      
      const ROLLBACK_STORAGE_KEY = "theonefile_rollbacks";
      const MAX_ROLLBACK_VERSIONS = 50;
      let rollbackVersions = [];
      let currentRollbackIndex = -1;
      
      const AUDIT_STORAGE_KEY = "theonefile_audit_log";
      let auditLog = [];
      const MAX_AUDIT_ENTRIES = 1000;
      
      let documentTabs = [{
        id: "main",
        name: "Main Topology",
        nodes: {},
        edges: { list: [] },
        positions: {},
        sizes: {},
        styles: {},
        legend: {},
        rects: { list: [] },
        texts: { list: [] },
      pageState: null
      }];
      let currentTabIndex = 0;
      
      let encryptedSections = {}; 
      
      let performanceMode = "auto"; 
      let cullOffscreenNodes = true;
      let minimapNeedsUpdate = true;
      let lastMinimapUpdate = 0;
      
      const MobileManager = {
        isMobile: false,
        detect() {
          if (navigator.userAgentData?.mobile === true) {
            this.isMobile = true;
            return true;
          }
          const coarse = matchMedia("(pointer: coarse)").matches;
          const width = window.innerWidth <= 900;
          const portrait = matchMedia("(orientation: portrait)").matches;
          this.isMobile = coarse && (width || portrait);
          return this.isMobile;
        },
        applyInitialCollapse() {
          if (!this.isMobile) return;
          legendCollapsed = true;
          minimapCollapsed = true;
          drawToolbarCollapsed = true;
          topologyToolbarCollapsed = true;
          if (typeof updateLegendVisibility === "function") updateLegendVisibility();
          if (typeof updateMinimapVisibility === "function") updateMinimapVisibility();
          if (typeof updateDrawToolbarVisibility === "function") updateDrawToolbarVisibility();
          if (typeof updateTopologyToolbarVisibility === "function") updateTopologyToolbarVisibility();
        },
        updateBulkToolbar() {
          const desktop = document.getElementById("bulk-toolbar");
          const mobile = document.getElementById("bulk-toolbar-mobile");
          if (!desktop || !mobile) return;
      
          const isVisible = desktop.style.display !== "none" || mobile.style.display !== "none";
          
          if (this.isMobile) {
            desktop.style.display = "none";
            if (isVisible) {
              mobile.style.display = "flex";
            }
          } else {
            mobile.style.display = "none";
            if (isVisible) {
              desktop.style.display = "flex";
            }
          }
        },
        updateLayout() {
          const main = document.querySelector("main");
          if (!main) return;
        },
        updateCanvasHint() {
      const hint = document.getElementById("canvas-hint");
      if (!hint) return;
      
      if (PAGE_STATE.canvasHintText !== undefined && PAGE_STATE.canvasHintText !== "") {
        hint.innerHTML = PAGE_STATE.canvasHintText;
        return;
      }
      
      const items = this.isMobile
      ? [
        "Pinch to zoom",
        "Drag to pan",
        "Add node from top menu",
        "Double tap to clone and align",
        "Double tap to select multiple",
        "You have the power",	
        "Your time is NOW!",
      ]
      : [
        "Scroll to zoom",
        "Drag to pan",
        "Right click to clone and align",
        "Right click to select multiple",
        "You have the power",
        "Your time is NOW!",
      ];
      
      const list = document.createElement("ul");
      for (const item of items) {
      const li = document.createElement("li");
      li.textContent = item;
      list.appendChild(li);
      }
      
      hint.replaceChildren(list);
      },
        autoSelectStyleScope() {
          const scope = document.getElementById("style-scope");
          if (!scope) return;
          if (this.isMobile) scope.value = "mobile";
        },
        updateToolbarStack() {
          if (!this.isMobile) return;
          const draw = document.getElementById("draw-toolbar");
          const topo = document.getElementById("topology-toolbar");
          if (!draw || !topo) return;
          const h = draw.getBoundingClientRect().height;
          document.documentElement.style.setProperty("--draw-toolbar-height", h + "px");
        },
        updateLayoutControls() {
          const sidebarRow = document.getElementById("sidebar-width-row");
          const footerRow = document.getElementById("mobile-footer-row");
          if (sidebarRow && footerRow) {
            if (this.isMobile) {
              sidebarRow.style.display = "none";
              footerRow.style.display = "flex";
            } else {
              sidebarRow.style.display = "flex";
              footerRow.style.display = "none";
            }
          }
        },
        applyAll() {
          this.detect();
          this.applyInitialCollapse();
          this.updateBulkToolbar();
          this.updateLayout();
          this.updateCanvasHint();
          this.autoSelectStyleScope();
          this.updateToolbarStack();
          this.updateLayoutControls();
        }
      };
      
      function isMobileDevice() {
        return MobileManager.isMobile;
      }
      
      function u8ToBase64(u8) {
      let binary = "";
      for (let i = 0; i < u8.length; i++) binary += String.fromCharCode(u8[i]);
      return btoa(binary);
      }
      
      function base64ToU8(base64) {
      const binary = atob(base64);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
      return bytes;
      }
      
      function ensureLegendMiniButton() {
       if (legendMiniBtn) return legendMiniBtn;
       const panel = document.querySelector(".topology-panel");
       if (!panel) return null;
       const btn = document.createElement("button");
       btn.type = "button";
       btn.id = "edge-legend-mini";
       btn.className = "legend-mini-btn";
       btn.textContent = "Legend";
       btn.style.bottom = "10px";
       const handleClick = (e) => {
        e.stopPropagation();
        e.preventDefault();
        legendCollapsed = false;
        updateLegendVisibility();
       };
       btn.addEventListener("click", handleClick);
       btn.addEventListener("touchend", handleClick);
       panel.appendChild(btn);
       legendMiniBtn = btn;
       return btn;
      }
      
      function ensureMinimapMiniButton() {
       if (minimapMiniBtn) return minimapMiniBtn;
       const panel = document.querySelector(".topology-panel");
       if (!panel) return null;
       const btn = document.createElement("button");
       btn.type = "button";
       btn.id = "minimap-mini";
       btn.className = "legend-mini-btn";
       btn.textContent = "Map";
       btn.style.right = "10px";
       btn.style.left = "auto";
       btn.style.bottom = "10px";
       const handleClick = (e) => {
        e.stopPropagation();
        e.preventDefault();
        minimapCollapsed = false;
        updateMinimapVisibility();
       };
       btn.addEventListener("click", handleClick);
       btn.addEventListener("touchend", handleClick);
       panel.appendChild(btn);
       minimapMiniBtn = btn;
       return btn;
      }
      
      function ensureDrawToolbarMiniButton() {
       if (drawToolbarMiniBtn) return drawToolbarMiniBtn;
       const panel = document.querySelector(".topology-panel");
       if (!panel) return null;
       const btn = document.createElement("button");
       btn.type = "button";
       btn.id = "draw-toolbar-mini";
       btn.className = "legend-mini-btn";
       btn.textContent = "Draw";
       btn.style.top = "10px";
       btn.style.left = "10px";
       btn.style.right = "auto";
       const handleClick = (e) => {
        e.stopPropagation();
        e.preventDefault();
        drawToolbarCollapsed = false;
        updateDrawToolbarVisibility();
       };
       btn.addEventListener("click", handleClick);
       btn.addEventListener("touchend", handleClick);
       panel.appendChild(btn);
       drawToolbarMiniBtn = btn;
       return btn;
      }
      
      function ensureTopologyToolbarMiniButton() {
       if (topologyToolbarMiniBtn) return topologyToolbarMiniBtn;
       const panel = document.querySelector(".topology-panel");
       if (!panel) return null;
       const btn = document.createElement("button");
       btn.type = "button";
       btn.id = "topology-toolbar-mini";
       btn.className = "legend-mini-btn";
       btn.textContent = "Add Line";
       btn.style.top = "10px";
       btn.style.left = "auto";
       btn.style.right = "40px";
       const handleClick = (e) => {
        e.stopPropagation();
        e.preventDefault();
        topologyToolbarCollapsed = false;
        updateTopologyToolbarVisibility();
       };
       btn.addEventListener("click", handleClick);
       btn.addEventListener("touchend", handleClick);
       panel.appendChild(btn);
       topologyToolbarMiniBtn = btn;
       return btn;
      }
      
      function updateToolbarStack() {
       if (!isMobileDevice()) return;
       const draw = document.getElementById("draw-toolbar");
       const topo = document.getElementById("topology-toolbar");
       if (!draw || !topo) return;
       const h = draw.getBoundingClientRect().height;
       document.documentElement.style.setProperty("--draw-toolbar-height", h + "px");
      }
      window.addEventListener("resize", updateToolbarStack);
      window.addEventListener("DOMContentLoaded", updateToolbarStack);
      updateToolbarStack();
      
      function updateLegendVisibility() {
       const legend = document.getElementById("edge-legend");
       const mini = ensureLegendMiniButton();
       if (!legend || !mini) return;
       const hasItems = legend.querySelectorAll(".legend-item").length > 0;
       if (!hasItems) {
        legend.style.display = "none";
        mini.style.display = "none";
        return;
       }
       if (legendCollapsed) {
        legend.style.display = "none";
        mini.style.display = "inline-flex";
       } else {
        legend.style.display = "flex";
        mini.style.display = "none";
       }
      }
      
      function updateMinimapVisibility() {
       const wrapper = document.getElementById("minimap-zoom-wrapper");
       const mini = ensureMinimapMiniButton();
       if (!wrapper || !mini) return;
       if (minimapCollapsed) {
        wrapper.style.display = "none";
        mini.style.display = "inline-flex";
       } else {
        wrapper.style.display = "block";
        mini.style.display = "none";
       }
      }
      
      function updateDrawToolbarVisibility() {
       const toolbar = document.getElementById("draw-toolbar");
       const mini = ensureDrawToolbarMiniButton();
       if (!toolbar || !mini) return;
       if (drawToolbarCollapsed) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "inline-flex";
       } else {
      if (isMobileDevice()) {    	   
        toolbar.style.setProperty('display', 'grid', 'important');
        mini.style.display = "none";
      } else {   
        toolbar.style.setProperty('display', 'flex', 'important');
        mini.style.display = "none";	  
      }
       }
      }
      
      function updateTopologyToolbarVisibility() {
       const toolbar = document.getElementById("topology-toolbar");
       const mini = ensureTopologyToolbarMiniButton();
       if (!toolbar || !mini) return;
       const hasSelectedNode = currentNodeId !== null;
       if (!hasSelectedNode) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "none";
       } else if (topologyToolbarCollapsed) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "inline-flex";
       } else {   
      if (isMobileDevice()) {    	   
        toolbar.style.setProperty('display', 'grid', 'important');
        mini.style.display = "none";
        } else {   
        toolbar.style.setProperty('display', 'flex', 'important');
        mini.style.display = "none";	  
      }
       }
      }
      const DEFAULT_CANVAS_HINT = document.getElementById("canvas-hint")?.innerHTML || "";
      const DEFAULT_PAGE_STATE = {
       title: "The One File",
       background: "",
       topbarBg: "rgba(9, 12, 20, 0.9)",
       topbarBorder: "#1f2533",
       panel: "#0b0e13",
       panelAlt: "#10141b",
       accent: "#4fd1c5",
       sidebarBg: "#10141b",
       btnBg: "#0b0e13",
       btnText: "#e2e8f0",
       tagFill: "#1e293b",
       tagText: "#e2e8f0",
       tagBorder: "#475569",
       inputBg: "#0b0e13",
       inputText: "#e2e8f0",
       inputBorder: "#1f2937",
       inputFont: "Inter, system-ui, sans-serif",
       inputFontSize: 14,
       toolbarBg: "#0f172a",
       toolbarBorder: "#1f2937",
       toolbarText: "#94a3b8",
       toolbarBtnBg: "#0b0e13",
       toolbarBtnText: "#e2e8f0",
       minimapDots: "#94a3b8",
       canvasHintEnabled: true,
       canvasHintText: "",
       canvasHintBg: "#0f172a",
       canvasHintColor: "#94a3b8",
       danger: "#f56565",
       textMain: "#e2e8f0",
       textSoft: "#94a3b8",
       topbarHeight: 52,
       sidebarWidth: 350,
       mobileFooterHeight: 40,
       sidebarCollapsed: false,
       nodeFill: "#1e293b",
       nodeStroke: "#475569",
       nodeTitle: "#e2e8f0",
       nodeSub: "#94a3b8",
       nodeTitleSize: 18,
       nodeSubSize: 13,
       nodeFont: "Inter, system-ui, sans-serif",
       defaultEdge: "#475569",
       selectionHandle: "#f59e0b",
       selectionHandleSize: 8,
       groupIndicator: "#4fd1c5",
      canvasGradientTop: "#1e2532",
       canvasGradientBottom: "#050608",
       canvasBorder: "#475569",
       canvasGrid: "#475569",
       canvasGridSize: 50,
       rackFrameFill: "#0f172a",
       rackFrameStroke: "#4fd1c5",
       rackLineColor: "#475569",
       rackTextColor: "#4fd1c5",
      };
      let PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE);
      const CANVAS_WIDTH = 4000;
      let CANVAS_HEIGHT = 3000;
      const BASE_CANVAS_HEIGHT = 3000;
      const CANVAS_PADDING = 100;
      
      const RACK_U_HEIGHT = 70; 
      const RACK_WIDTH = 600;
      const RACK_START_X = CANVAS_WIDTH / 2; 
      const RACK_START_Y = CANVAS_PADDING + 100;
      function getRackUHeight(rackId) {
      const capacity = getRackCapacity(rackId);
      const availableHeight = CANVAS_HEIGHT - RACK_START_Y - 200;
      return Math.floor(availableHeight / capacity);
      }
      let canvasState = {
       zoom: 1,
       panX: 0,
       panY: 0,
       minZoom: 0.25,
       maxZoom: 4,
       isPanning: false,
       panStartX: 0,
       panStartY: 0,
       spacePressed: false,
      };
      
      function getViewBox() {
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       return {
        x: canvasState.panX,
        y: canvasState.panY,
        width: viewWidth,
        height: viewHeight,
       };
      }
      
      function updateViewBox() {
       const svg = document.getElementById("map");
       const vb = getViewBox();
       svg.setAttribute("viewBox", `${vb.x} ${vb.y} ${vb.width} ${vb.height}`, );
       const zoomLevel = document.getElementById("zoom-level");
       if (zoomLevel) {
        zoomLevel.textContent = Math.round(canvasState.zoom * 100) + "%";
       }
       updateMinimap();
       populateRackDropdown();
      }
      
      function updateMinimap() {
       const minimapViewport = document.getElementById("minimap-viewport");
       const minimapSvg = document.getElementById("minimap");
       if (!minimapViewport || !minimapSvg) return;
       const vb = getViewBox();
       minimapViewport.setAttribute("x", vb.x);
       minimapViewport.setAttribute("y", vb.y);
       minimapViewport.setAttribute("width", vb.width);
       minimapViewport.setAttribute("height", vb.height);
       const minimapNodes = minimapSvg.querySelectorAll(".minimap-node");
       minimapNodes.forEach((n) => n.remove());
       const minimapEdges = minimapSvg.querySelectorAll(".minimap-edge");
       minimapEdges.forEach((e) => e.remove());
       
       EDGE_DATA.list.forEach((edge) => {
        if (edge.type === "custom") return;
        
        const fromNode = NODE_DATA[edge.from];
        const toNode = NODE_DATA[edge.to];
        if (!fromNode || !toNode) return;
        
        if (currentView.mode === "rack") {
         if (fromNode.assignedRack !== currentView.rackId || 
             toNode.assignedRack !== currentView.rackId) {
          return;
         }
        } else {
         if (fromNode.assignedRack || toNode.assignedRack) {
          return;
         }
        }
        
        const p1 = savedPositions[edge.from];
        const p2 = savedPositions[edge.to];
        if (!p1 || !p2) return;
        const line = document.createElementNS("http://www.w3.org/2000/svg", "line", );
        line.setAttribute("x1", p1.x);
        line.setAttribute("y1", p1.y);
        line.setAttribute("x2", p2.x);
        line.setAttribute("y2", p2.y);
        line.classList.add("minimap-edge");
        minimapSvg.insertBefore(line, minimapViewport);
       });
       
       Object.entries(savedPositions).forEach(([id, pos]) => {
        const node = NODE_DATA[id];
        if (!node) return;
        
        if (currentView.mode === "rack") {
         if (node.assignedRack !== currentView.rackId) {
          return; 
         }
        } else {
         if (node.assignedRack) {
          return; 
         }
        }
        
        const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle", );
        circle.setAttribute("cx", pos.x);
        circle.setAttribute("cy", pos.y);
        circle.setAttribute("r", 40);
        circle.classList.add("minimap-node");
        minimapSvg.insertBefore(circle, minimapViewport);
       });
      }
      
      function zoomTo(newZoom, centerX, centerY) {
       const oldZoom = canvasState.zoom;
       newZoom = Math.max(canvasState.minZoom, Math.min(canvasState.maxZoom, newZoom), );
       if (centerX !== undefined && centerY !== undefined) {
        const oldWidth = CANVAS_WIDTH / oldZoom;
        const oldHeight = CANVAS_HEIGHT / oldZoom;
        const newWidth = CANVAS_WIDTH / newZoom;
        const newHeight = CANVAS_HEIGHT / newZoom;
        const pointX = canvasState.panX + centerX * oldWidth;
        const pointY = canvasState.panY + centerY * oldHeight;
        canvasState.panX = pointX - centerX * newWidth;
        canvasState.panY = pointY - centerY * newHeight;
       }
       canvasState.zoom = newZoom;
       constrainPan();
       updateViewBox();
      }
      
      function constrainPan() {
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       const minVisiblePortion = 0.1;
       const maxPanX = CANVAS_WIDTH - viewWidth * minVisiblePortion;
       const maxPanY = CANVAS_HEIGHT - viewHeight * minVisiblePortion;
       const minPanX = -viewWidth * (1 - minVisiblePortion);
       const minPanY = -viewHeight * (1 - minVisiblePortion);
       canvasState.panX = Math.max(minPanX, Math.min(maxPanX, canvasState.panX), );
       canvasState.panY = Math.max(minPanY, Math.min(maxPanY, canvasState.panY), );
      }
      
      function fitToContent() {
       const positions = Object.values(savedPositions);
       if (positions.length === 0) {
        resetView();
        return;
       }
       let minX = Infinity,
        minY = Infinity,
        maxX = -Infinity,
        maxY = -Infinity;
       positions.forEach((pos) => {
        minX = Math.min(minX, pos.x - 100);
        minY = Math.min(minY, pos.y - 100);
        maxX = Math.max(maxX, pos.x + 100);
        maxY = Math.max(maxY, pos.y + 100);
       });
       const contentWidth = maxX - minX + 200;
       const contentHeight = maxY - minY + 200;
       const viewport = document.getElementById("canvas-viewport");
       const vpRect = viewport.getBoundingClientRect();
       const aspectRatio = vpRect.width / vpRect.height;
       const contentAspect = contentWidth / contentHeight;
       let newZoom;
       if (contentAspect > aspectRatio) {
        newZoom = (vpRect.width / contentWidth) * (CANVAS_WIDTH / vpRect.width);
       } else {
        newZoom = (vpRect.height / contentHeight) * (CANVAS_HEIGHT / vpRect.height);
       }
       newZoom = Math.max(canvasState.minZoom, Math.min(2, newZoom));
       const viewWidth = CANVAS_WIDTH / newZoom;
       const viewHeight = CANVAS_HEIGHT / newZoom;
       canvasState.zoom = newZoom;
       canvasState.panX = minX - 100 - (viewWidth - contentWidth) / 2;
       canvasState.panY = minY - 100 - (viewHeight - contentHeight) / 2;
       constrainPan();
       updateViewBox();
      }
      
      function resetView() {
       canvasState.zoom = 1;
       canvasState.panX = 0;
       canvasState.panY = 0;
       updateViewBox();
      }
      window.addEventListener("DOMContentLoaded", () => {
       const toggle = document.getElementById("mobile-menu-toggle");
       const menu = document.getElementById("topbar-menu");
       if (!toggle || !menu) return;
       toggle.addEventListener("click", () => {
        menu.classList.toggle("open");
       });
       menu.addEventListener("click", (e) => {
        const target = e.target.closest("a, button");
        if (!target) return;
        if (isMobileDevice()) {
       menu.classList.remove("open");
      }
       });
       const minimapCloseBtn = document.getElementById("minimap-close-btn");
       if (minimapCloseBtn) {
        const handleMinimapClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         minimapCollapsed = true;
         updateMinimapVisibility();
        };
        minimapCloseBtn.addEventListener("click", handleMinimapClose);
        minimapCloseBtn.addEventListener("touchend", handleMinimapClose);
       }
       const drawToolbarCloseBtn = document.getElementById("draw-toolbar-close-btn");
       if (drawToolbarCloseBtn) {
        const handleDrawClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         drawToolbarCollapsed = true;
         updateDrawToolbarVisibility();
        };
        drawToolbarCloseBtn.addEventListener("click", handleDrawClose);
        drawToolbarCloseBtn.addEventListener("touchend", handleDrawClose);
       }
       const topologyToolbarCloseBtn = document.getElementById("topology-toolbar-close-btn");
       if (topologyToolbarCloseBtn) {
        const handleTopologyClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         topologyToolbarCollapsed = true;
         updateTopologyToolbarVisibility();
        };
        topologyToolbarCloseBtn.addEventListener("click", handleTopologyClose);
        topologyToolbarCloseBtn.addEventListener("touchstart", (e) => e.preventDefault(), {
         passive: false
        });
        topologyToolbarCloseBtn.addEventListener("touchend", handleTopologyClose);
       }
      
       updateMinimapVisibility();
       updateDrawToolbarVisibility();
       updateTopologyToolbarVisibility();
      });
      
      function applyLayerFilter() {
       activeLayers.clear();
       if (document.getElementById("layer-physical").checked) activeLayers.add("physical");
       if (document.getElementById("layer-logical").checked) activeLayers.add("logical");
       if (document.getElementById("layer-security").checked) activeLayers.add("security");
       if (document.getElementById("layer-application").checked) activeLayers.add("application");
       forgeTheTopology();
      }
      
      function isNodeVisible(nodeId) {
       const node = NODE_DATA[nodeId];
       if (!node) return false;
       const nodeLayer = node.layer || "physical";
       return activeLayers.has(nodeLayer);
      }
      
      function enterRack(rackId) {
      if (!NODE_DATA[rackId] || !NODE_DATA[rackId].isRack) return;
      const rackCapacity = getRackCapacity(rackId);
      const neededHeight = RACK_START_Y + (rackCapacity * RACK_U_HEIGHT) + 200;
      if (neededHeight > BASE_CANVAS_HEIGHT) {
      CANVAS_HEIGHT = neededHeight;
      }
       
       savedTopologyView = {
        zoom: canvasState.zoom,
        panX: canvasState.panX,
        panY: canvasState.panY
       };
       
       currentView.mode = "rack";
       currentView.rackId = rackId;
       
       const backBtn = document.getElementById("back-to-topology-btn");
       if (backBtn) backBtn.style.display = "inline-block";
       
       const hint = document.getElementById("canvas-hint");
       if (hint) {
        hint.textContent = `Viewing: ${NODE_DATA[rackId].name} | Double click empty space to exit`;
        hint.classList.add("visible");
       }
       
      
      const rackUHeight = getRackUHeight(rackId);
      const rackHeight = rackCapacity * rackUHeight;
      const rackCenterX = RACK_START_X;
      const rackCenterY = RACK_START_Y + (rackHeight / 2);
       
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       
       canvasState.panX = rackCenterX - (viewWidth / 2);
       canvasState.panY = rackCenterY - (viewHeight / 2);
       
       constrainPan();
       updateViewBox();
       
       forgeTheTopology();
      }
      
      function exitRack() {
      CANVAS_HEIGHT = BASE_CANVAS_HEIGHT;
      currentView.mode = "topology";
      currentView.rackId = null;
       
       const backBtn = document.getElementById("back-to-topology-btn");
       if (backBtn) backBtn.style.display = "none";
       
       const hint = document.getElementById("canvas-hint");
       if (hint) {
        hint.classList.remove("visible");
       }
       
       if (savedTopologyView) {
        canvasState.zoom = savedTopologyView.zoom;
        canvasState.panX = savedTopologyView.panX;
        canvasState.panY = savedTopologyView.panY;
        updateViewBox();
       }
       
       forgeTheTopology();
      }
      
      function getRackCapacity(rackId) {
       const node = NODE_DATA[rackId];
       return node && node.rackCapacity ? parseInt(node.rackCapacity) : 42;
      }
      
      function populateRackDropdown() {
       const dropdown = document.getElementById("node-assigned-rack");
       if (!dropdown) return;
       
       dropdown.innerHTML = '<option value="">None</option>';
       
       Object.keys(NODE_DATA).forEach(id => {
        if (NODE_DATA[id].isRack) {
         const option = document.createElement("option");
         option.value = id;
         option.textContent = NODE_DATA[id].name;
         dropdown.appendChild(option);
        }
       });
      }
      
      function wieldThePower() {
       const root = document.documentElement;
       root.style.setProperty("--panel", PAGE_STATE.panel);
       root.style.setProperty("--panel-alt", PAGE_STATE.panelAlt);
       root.style.setProperty("--sidebar-bg", PAGE_STATE.sidebarBg || PAGE_STATE.panelAlt);
       root.style.setProperty("--btn-bg", PAGE_STATE.btnBg || PAGE_STATE.panel);
       root.style.setProperty("--btn-text", PAGE_STATE.btnText || "#e2e8f0");
       root.style.setProperty("--tag-fill", PAGE_STATE.tagFill || "#1e293b");
       root.style.setProperty("--tag-text", PAGE_STATE.tagText || "#e2e8f0");
       root.style.setProperty("--tag-border", PAGE_STATE.tagBorder || "#475569");
       root.style.setProperty("--input-bg", PAGE_STATE.inputBg || "#0b0e13");
       root.style.setProperty("--input-text", PAGE_STATE.inputText || "#e2e8f0");
       root.style.setProperty("--input-border", PAGE_STATE.inputBorder || "#1f2937");
       root.style.setProperty("--input-font", PAGE_STATE.inputFont || "Inter, system-ui, sans-serif");
       root.style.setProperty("--input-font-size", (PAGE_STATE.inputFontSize || 14) + "px");
       root.style.setProperty("--toolbar-bg", PAGE_STATE.toolbarBg || "#0f172a");
       root.style.setProperty("--toolbar-border", PAGE_STATE.toolbarBorder || "#1f2937");
       root.style.setProperty("--toolbar-text", PAGE_STATE.toolbarText || "#94a3b8");
       root.style.setProperty("--toolbar-btn-bg", PAGE_STATE.toolbarBtnBg || "#0b0e13");
       root.style.setProperty("--toolbar-btn-text", PAGE_STATE.toolbarBtnText || "#e2e8f0");
       root.style.setProperty("--minimap-dots", PAGE_STATE.minimapDots || "#94a3b8");
       root.style.setProperty("--canvas-hint-bg", PAGE_STATE.canvasHintBg || "#0f172a");
       root.style.setProperty("--canvas-hint-color", PAGE_STATE.canvasHintColor || "#94a3b8");
       
       const canvasHint = document.getElementById("canvas-hint");
       if (canvasHint) {
        canvasHint.style.display = PAGE_STATE.canvasHintEnabled === false ? "none" : "";
        if (PAGE_STATE.canvasHintText !== undefined && PAGE_STATE.canvasHintText !== "") {
         canvasHint.innerHTML = PAGE_STATE.canvasHintText;
        } else {
         canvasHint.innerHTML = DEFAULT_CANVAS_HINT;
        }
       }
       root.style.setProperty("--accent", PAGE_STATE.accent);
       root.style.setProperty("--danger", PAGE_STATE.danger);
       root.style.setProperty("--text-main", PAGE_STATE.textMain);
       root.style.setProperty("--text-soft", PAGE_STATE.textSoft);
       root.style.setProperty("--topbar-bg", PAGE_STATE.topbarBg);
      root.style.setProperty("--topbar-border", PAGE_STATE.topbarBorder);
       root.style.setProperty("--node-fill", PAGE_STATE.nodeFill || "#1e293b");
       root.style.setProperty("--node-stroke", PAGE_STATE.nodeStroke || "#475569");
       root.style.setProperty("--node-title", PAGE_STATE.nodeTitle || "#e2e8f0");
       root.style.setProperty("--node-sub", PAGE_STATE.nodeSub || "#94a3b8");
       root.style.setProperty("--node-title-size", (PAGE_STATE.nodeTitleSize || 18) + "px");
       root.style.setProperty("--node-sub-size", (PAGE_STATE.nodeSubSize || 13) + "px");
       root.style.setProperty("--node-font", PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif");
       root.style.setProperty("--default-edge", PAGE_STATE.defaultEdge || "#475569");
       root.style.setProperty("--selection-handle", PAGE_STATE.selectionHandle || "#f59e0b");
       root.style.setProperty("--selection-handle-size", (PAGE_STATE.selectionHandleSize || 8) + "px");
       root.style.setProperty("--group-indicator", PAGE_STATE.groupIndicator || "#4fd1c5");
       const topbarHeight = PAGE_STATE.topbarHeight || 52;
       const sidebarWidth = PAGE_STATE.sidebarWidth || 350;
       const mobileFooterHeight = PAGE_STATE.mobileFooterHeight || 40;
       root.style.setProperty("--topbar-height", topbarHeight + "px");
       root.style.setProperty("--sidebar-width", sidebarWidth + "px");
       root.style.setProperty("--mobile-footer-height", mobileFooterHeight + "vh", );
       const mainEl = document.querySelector("main");
       const detailsPanel = document.getElementById("details-panel");
       const sidebarToggle = document.getElementById("sidebar-toggle");
       if (PAGE_STATE.sidebarCollapsed) {
        if (mainEl) mainEl.classList.add("sidebar-collapsed");
        if (detailsPanel) detailsPanel.classList.add("collapsed");
        if (sidebarToggle) {
         sidebarToggle.classList.add("collapsed");
         sidebarToggle.textContent = "â–¶";
        }
       } else {
        if (mainEl) mainEl.classList.remove("sidebar-collapsed");
        if (detailsPanel) detailsPanel.classList.remove("collapsed");
        if (sidebarToggle) {
         sidebarToggle.classList.remove("collapsed");
         sidebarToggle.textContent = "â—€";
        }
       }
       if (PAGE_STATE.background) {
        document.body.style.background = PAGE_STATE.background;
       } else {
        document.body.style.background = `radial-gradient(circle at top, ${PAGE_STATE.canvasGradientTop || "#1e2532"} 0, ${PAGE_STATE.canvasGradientBottom || "#050608"} 70%)`;
       }
       document.title = PAGE_STATE.title || DEFAULT_PAGE_STATE.title;
       const titleEl = document.getElementById("page-title");
       if (titleEl) {
        titleEl.textContent = PAGE_STATE.title || DEFAULT_PAGE_STATE.title;
       }
       
       const sidebarToggleEl = document.getElementById("sidebar-toggle");
       const isMobile = isMobileDevice();
       if (sidebarToggleEl) {
        sidebarToggleEl.style.display = isMobile ? "none" : "flex";
       }
      }
      (async function awakeTheImmortal() {
       let initialState = {};
       let decryptionCancelled = false;
       const stateEl = document.getElementById("topology-state");
       if (stateEl && stateEl.textContent.trim()) {
        try {
         let stateText = stateEl.textContent.trim();
         if (isEncrypted(stateText)) {
          let decrypted = false;
          let attempts = 0;
          const maxAttempts = 3;
          while (!decrypted && attempts < maxAttempts) {
           const password = prompt("This file is encrypted. Enter password to decrypt:\n(Attempt " + (attempts + 1) + " of " + maxAttempts + ")", );
           if (!password) {
            alert("Decryption cancelled. The file will not be loaded.", );
            decryptionCancelled = true;
            break;
           }
           try {
            stateText = await decryptData(stateText, password);
            decrypted = true;
           } catch (e) {
            attempts++;
            if (attempts < maxAttempts) {
             alert("Incorrect password. Please try again.");
            } else {
             alert("Maximum attempts reached. The file will not be loaded.", );
             decryptionCancelled = true;
            }
           }
          }
          if (!decrypted) {
           stateText = "{}";
          }
         }
         initialState = JSON.parse(stateText);
        } catch (e) {
         console.error("Failed to load state:", e);
         initialState = {};
        }
       }
       if (decryptionCancelled) {
        NODE_DATA = {};
        EDGE_DATA = {
         list: []
        };
        RECT_DATA = { list: [] };
        TEXT_DATA = { list: [] };
        EDGE_LEGEND = {};
        savedPositions = {};
        savedSizes = {};
        savedStyles = {};
       } else {
        NODE_DATA = initialState.nodeData ? initialState.nodeData : BASE_NODE_DATA;
        EDGE_DATA = initialState.edgeData ? initialState.edgeData : {
         list: [],
        };
        RECT_DATA = initialState.rectData ? initialState.rectData : { list: [] };
        TEXT_DATA = initialState.textData ? initialState.textData : { list: [] };
        EDGE_LEGEND = initialState.edgeLegend || {};
        savedPositions = initialState.nodePositions || {};
        savedSizes = initialState.nodeSizes || {};
        savedStyles = initialState.nodeStyles || {};
       }
       if (initialState.page) {
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, initialState.page, );
       }
       if (initialState.canvas) {
        canvasState.zoom = initialState.canvas.zoom || 1;
        canvasState.panX = initialState.canvas.panX || 0;
        canvasState.panY = initialState.canvas.panY || 0;
       }
       
       if (initialState.savedTopologyView) {
        savedTopologyView = initialState.savedTopologyView;
       }
       
       if (initialState.documentTabs) {
        documentTabs = initialState.documentTabs;
        currentTabIndex = initialState.currentTabIndex || 0;
        
        const currentTab = documentTabs[currentTabIndex];
        if (currentTab) {
          NODE_DATA = currentTab.nodes || NODE_DATA;
          EDGE_DATA = currentTab.edges || EDGE_DATA;
          savedPositions = currentTab.positions || savedPositions;
          savedSizes = currentTab.sizes || savedSizes;
          savedStyles = currentTab.styles || savedStyles;
          EDGE_LEGEND = currentTab.legend || EDGE_LEGEND;
          RECT_DATA = currentTab.rects || RECT_DATA;
          TEXT_DATA = currentTab.texts || TEXT_DATA;
      if (currentTab.pageState) PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, currentTab.pageState);
        }
       }
           
       if (initialState.encryptedSections) {
        encryptedSections = initialState.encryptedSections;
       }
       
       wieldThePower();
       forgeTheTopology();
       updateViewBox();
       
       MobileManager.applyAll();
       
       const initialNodes = Object.keys(NODE_DATA);
       if (initialNodes.length > 0) {
        claimTheImmortal(initialNodes.includes("host") ? "host" : initialNodes[0], );
       } else {
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.display = "none";
       }
      })();
      
      window.addEventListener("resize", () => {
        MobileManager.applyAll();
      });
      
      function saveEdgeData() {}
      
      function saveEdgeLegend() {}
      
      function getBreakpointKey() {
       const w = window.innerWidth;
       if (w <= 380) return "fold";
       if (w <= 768) return "mobile";
       if (w <= 1024) return "tablet";
       return "desktop";
      }
      
      function resolveStylesEntry(styleEntry) {
       if (!styleEntry) return {};
       if (styleEntry.circleColor || styleEntry.titleColor || styleEntry.titleFont || styleEntry.titleSize || styleEntry.subColor || styleEntry.subFont || styleEntry.subSize) {
        return styleEntry;
       }
       const bp = getBreakpointKey();
       const base = styleEntry.all || {};
       const bpStyles = styleEntry[bp] || {};
       return Object.assign({}, base, bpStyles);
      }
      
      function resolveStylesForNode(id) {
       const styleEntry = savedStyles[id];
       if (!styleEntry) return {};
       return resolveStylesEntry(styleEntry);
      }
      
      function ensureStyleEntry(id) {
       if (!savedStyles[id]) savedStyles[id] = {};
       const entry = savedStyles[id];
       const flatProps = ["circleColor", "circleBorder", "titleColor", "titleFont", "titleSize", "subColor", "subFont", "subSize", ];
       const isFlat = flatProps.some((p) => Object.prototype.hasOwnProperty.call(entry, p), );
       if (isFlat) {
        const all = entry.all || {};
        flatProps.forEach((p) => {
         if (entry[p] !== undefined) {
          all[p] = entry[p];
          delete entry[p];
         }
        });
        entry.all = all;
       }
       return entry;
      }
      
      function getDefaultSize() {
       if (window.innerWidth <= 380) return 120;
       if (window.innerWidth <= 768) return 140;
       if (window.innerWidth <= 1024) return 70;
       return 55;
      }
      
      function createShapeElement(shape, size) {
       const ns = "http://www.w3.org/2000/svg";
       if (shape === "circle") {
        const c = document.createElementNS(ns, "circle");
        c.setAttribute("r", size);
        return c;
       }
       if (shape === "square") {
        const r = document.createElementNS(ns, "rect");
        const s = size * 2;
        r.setAttribute("x", -size);
        r.setAttribute("y", -size);
        r.setAttribute("width", s);
        r.setAttribute("height", s);
        r.setAttribute("rx", 4);
        return r;
       }
       if (shape === "rectangle") {
        const r = document.createElementNS(ns, "rect");
        r.setAttribute("x", -size * 1.4);
        r.setAttribute("y", -size * 0.8);
        r.setAttribute("width", size * 2.8);
        r.setAttribute("height", size * 1.6);
        r.setAttribute("rx", 6);
        return r;
       }
       if (shape === "triangle") {
        const p = document.createElementNS(ns, "polygon");
        const h = size * 1.8;
        const w = size * 2;
        p.setAttribute("points", `0,${-h} ${w / 2},${h / 2} ${-w / 2},${h / 2}`, );
        return p;
       }
       if (shape === "hexagon") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        const pts = [
         [0, -s],
         [s * 0.86, -s * 0.5],
         [s * 0.86, s * 0.5],
         [0, s],
         [-s * 0.86, s * 0.5],
         [-s * 0.86, -s * 0.5],
        ].map((pt) => pt.join(",")).join(" ");
        p.setAttribute("points", pts);
        return p;
       }
       if (shape === "stop-sign") {
        const p = document.createElementNS(ns, "polygon");
        const r = size;
        const ptsArr = [];
        for (let i = 0; i < 8; i++) {
         const a = (Math.PI / 4) * i + Math.PI / 8;
         ptsArr.push([Math.cos(a) * r, Math.sin(a) * r]);
        }
        const pts = ptsArr.map((pt) => pt.join(",")).join(" ");
        p.setAttribute("points", pts);
        return p;
       }
       if (shape === "star") {
        const p = document.createElementNS(ns, "polygon");
        const outer = size;
        const inner = size * 0.45;
        let pts = "";
        for (let i = 0; i < 10; i++) {
         const a = (Math.PI / 5) * i - Math.PI / 2;
         const r = i % 2 === 0 ? outer : inner;
         pts += `${Math.cos(a) * r},${Math.sin(a) * r} `;
        }
        p.setAttribute("points", pts.trim());
        return p;
       }
       if (shape === "diamond") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `0,${-s} ${s},0 0,${s} ${-s},0`);
        return p;
       }
       if (shape === "server") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.2);
        body.setAttribute("y", -size * 0.6);
        body.setAttribute("width", size * 2.4);
        body.setAttribute("height", size * 1.2);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 3; i++) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", -size * 0.9 + i * size * 0.5);
         line.setAttribute("y1", -size * 0.3);
         line.setAttribute("x2", -size * 0.9 + i * size * 0.5);
         line.setAttribute("y2", size * 0.3);
         line.style.stroke = "currentColor";
         line.style.strokeWidth = "2";
         line.style.opacity = "0.5";
         g.appendChild(line);
        }
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", size * 0.9);
        led.setAttribute("cy", 0);
        led.setAttribute("r", size * 0.1);
        led.style.fill = "#4ade80";
        g.appendChild(led);
        return g;
       }
       if (shape === "pc" || shape === "desktop") {
        const g = document.createElementNS(ns, "g");
        const monitor = document.createElementNS(ns, "rect");
        monitor.setAttribute("x", -size * 0.9);
        monitor.setAttribute("y", -size * 0.8);
        monitor.setAttribute("width", size * 1.8);
        monitor.setAttribute("height", size * 1.2);
        monitor.setAttribute("rx", 4);
        g.appendChild(monitor);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.75);
        screen.setAttribute("y", -size * 0.65);
        screen.setAttribute("width", size * 1.5);
        screen.setAttribute("height", size * 0.9);
        screen.setAttribute("rx", 2);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        const neck = document.createElementNS(ns, "rect");
        neck.setAttribute("x", -size * 0.15);
        neck.setAttribute("y", size * 0.4);
        neck.setAttribute("width", size * 0.3);
        neck.setAttribute("height", size * 0.3);
        g.appendChild(neck);
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.5);
        base.setAttribute("y", size * 0.7);
        base.setAttribute("width", size * 1);
        base.setAttribute("height", size * 0.15);
        base.setAttribute("rx", 2);
        g.appendChild(base);
        return g;
       }
       if (shape === "laptop") {
        const g = document.createElementNS(ns, "g");
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.8);
        screen.setAttribute("y", -size * 0.9);
        screen.setAttribute("width", size * 1.6);
        screen.setAttribute("height", size * 1.1);
        screen.setAttribute("rx", 4);
        g.appendChild(screen);
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.9);
        base.setAttribute("y", size * 0.25);
        base.setAttribute("width", size * 1.8);
        base.setAttribute("height", size * 0.6);
        base.setAttribute("rx", 4);
        g.appendChild(base);
        const pad = document.createElementNS(ns, "rect");
        pad.setAttribute("x", -size * 0.25);
        pad.setAttribute("y", size * 0.45);
        pad.setAttribute("width", size * 0.5);
        pad.setAttribute("height", size * 0.25);
        pad.setAttribute("rx", 2);
        pad.style.fill = "#1e293b";
        g.appendChild(pad);
        return g;
       }
       if (shape === "phone" || shape === "mobile") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.45);
        body.setAttribute("y", -size);
        body.setAttribute("width", size * 0.9);
        body.setAttribute("height", size * 2);
        body.setAttribute("rx", 8);
        g.appendChild(body);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.38);
        screen.setAttribute("y", -size * 0.85);
        screen.setAttribute("width", size * 0.76);
        screen.setAttribute("height", size * 1.6);
        screen.setAttribute("rx", 4);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        const btn = document.createElementNS(ns, "rect");
        btn.setAttribute("x", -size * 0.15);
        btn.setAttribute("y", size * 0.82);
        btn.setAttribute("width", size * 0.3);
        btn.setAttribute("height", size * 0.06);
        btn.setAttribute("rx", 2);
        btn.style.fill = "#475569";
        g.appendChild(btn);
        return g;
       }
       if (shape === "router") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.1);
        body.setAttribute("y", -size * 0.3);
        body.setAttribute("width", size * 2.2);
        body.setAttribute("height", size * 0.8);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        for (let i = -1; i <= 1; i++) {
         const ant = document.createElementNS(ns, "rect");
         ant.setAttribute("x", i * size * 0.6 - size * 0.05);
         ant.setAttribute("y", -size * 0.9);
         ant.setAttribute("width", size * 0.1);
         ant.setAttribute("height", size * 0.6);
         ant.setAttribute("rx", 2);
         g.appendChild(ant);
         const tip = document.createElementNS(ns, "circle");
         tip.setAttribute("cx", i * size * 0.6);
         tip.setAttribute("cy", -size * 0.95);
         tip.setAttribute("r", size * 0.08);
         g.appendChild(tip);
        }
        for (let i = 0; i < 4; i++) {
         const led = document.createElementNS(ns, "circle");
         led.setAttribute("cx", -size * 0.7 + i * size * 0.35);
         led.setAttribute("cy", size * 0.1);
         led.setAttribute("r", size * 0.06);
         led.style.fill = i < 2 ? "#4ade80" : "#facc15";
         g.appendChild(led);
        }
        return g;
       }
       if (shape === "switch") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.4);
        body.setAttribute("y", -size * 0.4);
        body.setAttribute("width", size * 2.8);
        body.setAttribute("height", size * 0.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 8; i++) {
         const port = document.createElementNS(ns, "rect");
         port.setAttribute("x", -size * 1.2 + i * size * 0.32);
         port.setAttribute("y", -size * 0.15);
         port.setAttribute("width", size * 0.22);
         port.setAttribute("height", size * 0.3);
         port.setAttribute("rx", 1);
         port.style.fill = "#1e293b";
         g.appendChild(port);
        }
        return g;
       }
       if (shape === "firewall") {
        const g = document.createElementNS(ns, "g");
        const wall = document.createElementNS(ns, "rect");
        wall.setAttribute("x", -size);
        wall.setAttribute("y", -size * 0.8);
        wall.setAttribute("width", size * 2);
        wall.setAttribute("height", size * 1.6);
        wall.setAttribute("rx", 4);
        g.appendChild(wall);
        for (let row = 0; row < 3; row++) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", -size * 0.85);
         line.setAttribute("y1", -size * 0.5 + row * size * 0.45);
         line.setAttribute("x2", size * 0.85);
         line.setAttribute("y2", -size * 0.5 + row * size * 0.45);
         line.style.stroke = "#475569";
         line.style.strokeWidth = "2";
         g.appendChild(line);
        }
        for (let row = 0; row < 4; row++) {
         const offset = row % 2 === 0 ? 0 : size * 0.35;
         for (let col = 0; col < 3; col++) {
          const line = document.createElementNS(ns, "line");
          const x = -size * 0.5 + col * size * 0.7 + offset;
          if (x > -size * 0.85 && x < size * 0.85) {
           line.setAttribute("x1", x);
           line.setAttribute("y1", -size * 0.8 + row * size * 0.45, );
           line.setAttribute("x2", x);
           line.setAttribute("y2", -size * 0.8 + row * size * 0.45 + size * 0.45, );
           line.style.stroke = "#475569";
           line.style.strokeWidth = "2";
           g.appendChild(line);
          }
         }
        }
        return g;
       }
       if (shape === "cloud") {
        const p = document.createElementNS(ns, "path");
        const s = size;
        p.setAttribute("d", `
             M ${-s * 0.8} ${s * 0.2}
             Q ${-s * 1.1} ${s * 0.2} ${-s * 1.1} ${-s * 0.1}
             Q ${-s * 1.1} ${-s * 0.5} ${-s * 0.7} ${-s * 0.5}
             Q ${-s * 0.7} ${-s * 0.9} ${-s * 0.2} ${-s * 0.9}
             Q ${s * 0.1} ${-s * 1.1} ${s * 0.5} ${-s * 0.8}
             Q ${s * 1} ${-s * 0.8} ${s * 1.1} ${-s * 0.3}
             Q ${s * 1.3} ${-s * 0.1} ${s * 1.1} ${s * 0.2}
             Q ${s * 1.1} ${s * 0.5} ${s * 0.7} ${s * 0.5}
             L ${-s * 0.5} ${s * 0.5}
             Q ${-s * 0.9} ${s * 0.5} ${-s * 0.9} ${s * 0.2}
             Z
            `, );
        return p;
       }
       if (shape === "database") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.7);
        body.setAttribute("y", -size * 0.6);
        body.setAttribute("width", size * 1.4);
        body.setAttribute("height", size * 1.4);
        g.appendChild(body);
        const top = document.createElementNS(ns, "ellipse");
        top.setAttribute("cx", 0);
        top.setAttribute("cy", -size * 0.6);
        top.setAttribute("rx", size * 0.7);
        top.setAttribute("ry", size * 0.25);
        g.appendChild(top);
        const bottom = document.createElementNS(ns, "ellipse");
        bottom.setAttribute("cx", 0);
        bottom.setAttribute("cy", size * 0.8);
        bottom.setAttribute("rx", size * 0.7);
        bottom.setAttribute("ry", size * 0.25);
        g.appendChild(bottom);
        const mid1 = document.createElementNS(ns, "ellipse");
        mid1.setAttribute("cx", 0);
        mid1.setAttribute("cy", -size * 0.15);
        mid1.setAttribute("rx", size * 0.7);
        mid1.setAttribute("ry", size * 0.2);
        mid1.style.fill = "none";
        mid1.style.stroke = "#475569";
        mid1.style.strokeWidth = "2";
        g.appendChild(mid1);
        const mid2 = document.createElementNS(ns, "ellipse");
        mid2.setAttribute("cx", 0);
        mid2.setAttribute("cy", size * 0.35);
        mid2.setAttribute("rx", size * 0.7);
        mid2.setAttribute("ry", size * 0.2);
        mid2.style.fill = "none";
        mid2.style.stroke = "#475569";
        mid2.style.strokeWidth = "2";
        g.appendChild(mid2);
        return g;
       }
       if (shape === "printer") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.4);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size * 0.9);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const trayTop = document.createElementNS(ns, "rect");
        trayTop.setAttribute("x", -size * 0.7);
        trayTop.setAttribute("y", -size * 0.8);
        trayTop.setAttribute("width", size * 1.4);
        trayTop.setAttribute("height", size * 0.4);
        trayTop.setAttribute("rx", 2);
        trayTop.style.fill = "#1e293b";
        g.appendChild(trayTop);
        const trayOut = document.createElementNS(ns, "rect");
        trayOut.setAttribute("x", -size * 0.6);
        trayOut.setAttribute("y", size * 0.5);
        trayOut.setAttribute("width", size * 1.2);
        trayOut.setAttribute("height", size * 0.35);
        trayOut.setAttribute("rx", 2);
        g.appendChild(trayOut);
        const paper = document.createElementNS(ns, "rect");
        paper.setAttribute("x", -size * 0.5);
        paper.setAttribute("y", size * 0.3);
        paper.setAttribute("width", size * 1);
        paper.setAttribute("height", size * 0.5);
        paper.style.fill = "#e2e8f0";
        g.appendChild(paper);
        return g;
       }
       const c = document.createElementNS(ns, "circle");
       c.setAttribute("r", size);
       return c;
      }
      
      function createNodeShape(id, size) {
       const shapeType = (NODE_DATA[id] && NODE_DATA[id].shape) || "circle";
       const shapeEl = createShapeElement(shapeType, size);
       shapeEl.classList.add("node-circle");
       const styles = resolveStylesForNode(id);
       shapeEl.style.fill = styles.circleColor || PAGE_STATE.nodeFill || "#1e293b";
       shapeEl.style.stroke = styles.circleBorder || PAGE_STATE.nodeStroke || "#475569";
       return shapeEl;
      }
      
      function forgeTheLegend() {
       const container = document.getElementById("edge-legend");
       if (!container) return;
       container.innerHTML = "";
       const title = document.createElement("div");
       title.className = "legend-title";
       title.textContent = "Line Legend";
       container.appendChild(title);
       const closeBtn = document.createElement("button");
       closeBtn.type = "button";
       closeBtn.className = "legend-close-btn";
       closeBtn.textContent = "âœ•";
       closeBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        legendCollapsed = true;
        updateLegendVisibility();
       });
       container.appendChild(closeBtn);
       const colors = [...new Set(EDGE_DATA.list.map((e) => e.color).filter(Boolean))];
       if (colors.length === 0) {
        updateLegendVisibility();
        return;
       }
       colors.forEach((color) => {
        if (!EDGE_LEGEND[color]) {
         EDGE_LEGEND[color] = "you can edit me too";
        }
        const item = document.createElement("div");
        item.className = "legend-item";
        item.addEventListener("mousedown", (e) => e.stopPropagation());
        item.addEventListener("click", (e) => e.stopPropagation());
        const swatch = document.createElement("span");
        swatch.className = "legend-swatch";
        swatch.style.backgroundColor = color;
        swatch.style.cursor = "pointer";
        swatch.addEventListener("click", (e) => {
         e.stopPropagation();
         const edgeWithColor = EDGE_DATA.list.find(edge => edge.color === color);
         if (edgeWithColor) {
          selectTheConnection(edgeWithColor.id);
         }
        });
        let swatchTouchStart = null;
        let swatchTouchMoved = false;
        swatch.addEventListener("touchstart", (e) => {
         swatchTouchStart = Date.now();
         swatchTouchMoved = false;
         if (e.touches[0]) {
          swatchTouchStartX = e.touches[0].clientX;
          swatchTouchStartY = e.touches[0].clientY;
         }
        }, {
         passive: false
        });
        let swatchTouchStartX = 0, swatchTouchStartY = 0;
        swatch.addEventListener("touchmove", (e) => {
         if (e.touches[0]) {
          const dx = Math.abs(e.touches[0].clientX - swatchTouchStartX);
          const dy = Math.abs(e.touches[0].clientY - swatchTouchStartY);
          if (dx > 10 || dy > 10) swatchTouchMoved = true;
         }
        }, {
         passive: false
        });
        swatch.addEventListener("touchend", (e) => {
         if (swatchTouchStart && !swatchTouchMoved && Date.now() - swatchTouchStart < 400) {
          e.stopPropagation();
          e.preventDefault();
          const edgeWithColor = EDGE_DATA.list.find(edge => edge.color === color);
          if (edgeWithColor) {
           selectTheConnection(edgeWithColor.id);
          }
         }
         swatchTouchStart = null;
         swatchTouchMoved = false;
        }, {
         passive: false
        });
        const label = document.createElement("span");
        label.className = "legend-label";
        label.textContent = EDGE_LEGEND[color];
        if (isMobileDevice()) {
         label.style.cursor = "pointer";
         let labelTapStart = null;
         let labelTapMoved = false;
         label.addEventListener("touchstart", (e) => {
          labelTapStart = Date.now();
          labelTapMoved = false;
          if (e.touches[0]) {
           labelTapStartX = e.touches[0].clientX;
           labelTapStartY = e.touches[0].clientY;
          }
          e.stopPropagation();
         });
         let labelTapStartX = 0, labelTapStartY = 0;
         label.addEventListener("touchmove", (e) => {
          if (e.touches[0]) {
           const dx = Math.abs(e.touches[0].clientX - labelTapStartX);
           const dy = Math.abs(e.touches[0].clientY - labelTapStartY);
           if (dx > 10 || dy > 10) labelTapMoved = true;
          }
         });
         label.addEventListener("touchend", (e) => {
          if (labelTapStart && !labelTapMoved && Date.now() - labelTapStart < 400) {
           e.preventDefault();
           e.stopPropagation();
           const currentText = label.textContent;
           const newText = prompt("Edit legend label:", currentText);
           if (newText !== null && newText.trim()) {
            label.textContent = newText.trim();
            EDGE_LEGEND[color] = newText.trim();
            saveEdgeLegend();
           }
          }
          labelTapStart = null;
          labelTapMoved = false;
         });
        } else {
         label.contentEditable = true;
         label.addEventListener("focus", () => {
          label.classList.add("editing");
         });
         label.addEventListener("blur", () => {
          label.classList.remove("editing");
          const text = label.textContent.trim() || "you can edit me too";
          EDGE_LEGEND[color] = text;
          saveEdgeLegend();
         });
         label.addEventListener("keydown", (e) => {
          if (e.key === "Enter") {
           e.preventDefault();
           label.blur();
          }
         });
        }
        item.append(swatch, label);
        container.appendChild(item);
       });
       updateLegendVisibility();
      }
      
       function deleteRectangle(rectId) {
      pushUndo("delete zone");
        RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== rectId);
        forgeTheTopology();
       }
      
       function updateRectangleDeleteButtons() {
        const deleteButtons = document.querySelectorAll('.rect-delete-btn');
        deleteButtons.forEach(btn => {
         btn.style.display = rectDrawMode ? 'block' : 'none';
        });
       }
      
      function forgeTheTopology() {
       if (!NODE_DATA || !EDGE_DATA) {
        console.warn("forgeTheTopology called before data initialized");
        return;
       }
       const svg = document.getElementById("map");
       svg.innerHTML = "";
       const ns = "http://www.w3.org/2000/svg";
       const defs = document.createElementNS(ns, "defs");
       const markerForward = document.createElementNS(ns, "marker");
       markerForward.id = "arrow-forward";
       markerForward.setAttribute("markerWidth", "10");
       markerForward.setAttribute("markerHeight", "10");
       markerForward.setAttribute("refX", "9");
       markerForward.setAttribute("refY", "3");
       markerForward.setAttribute("orient", "auto");
       markerForward.setAttribute("markerUnits", "strokeWidth");
       const pathForward = document.createElementNS(ns, "path");
       pathForward.setAttribute("d", "M0,0 L0,6 L9,3 z");
       pathForward.setAttribute("fill", "context-stroke");
       markerForward.appendChild(pathForward);
       defs.appendChild(markerForward);
       const markerBackward = document.createElementNS(ns, "marker");
       markerBackward.id = "arrow-backward";
       markerBackward.setAttribute("markerWidth", "10");
       markerBackward.setAttribute("markerHeight", "10");
       markerBackward.setAttribute("refX", "0");
       markerBackward.setAttribute("refY", "3");
       markerBackward.setAttribute("orient", "auto");
       markerBackward.setAttribute("markerUnits", "strokeWidth");
       const pathBackward = document.createElementNS(ns, "path");
       pathBackward.setAttribute("d", "M9,0 L9,6 L0,3 z");
       pathBackward.setAttribute("fill", "context-stroke");
       markerBackward.appendChild(pathBackward);
       defs.appendChild(markerBackward);
       svg.appendChild(defs);
       const boundary = document.createElementNS(ns, "rect");
       boundary.setAttribute("x", CANVAS_PADDING);
       boundary.setAttribute("y", CANVAS_PADDING);
       boundary.setAttribute("width", CANVAS_WIDTH - CANVAS_PADDING * 2);
       boundary.setAttribute("height", CANVAS_HEIGHT - CANVAS_PADDING * 2);
       boundary.setAttribute("fill", "none");
       boundary.setAttribute("stroke", (PAGE_STATE.canvasBorder || "#475569") + "4D");
       boundary.setAttribute("stroke-width", "20");
       boundary.setAttribute("stroke-dasharray", "10 5");
       boundary.setAttribute("rx", "8");
       svg.appendChild(boundary);
       
       if (currentView.mode !== "rack") {
        const gridGroup = document.createElementNS(ns, "g");
        gridGroup.id = "canvas-grid";
        const gridSize = PAGE_STATE.canvasGridSize || 50;
        const gridColor = (PAGE_STATE.canvasGrid || "#475569") + "33";
        const majorGridColor = (PAGE_STATE.canvasGrid || "#475569") + "66";
        
        for (let x = CANVAS_PADDING; x <= CANVAS_WIDTH - CANVAS_PADDING; x += gridSize) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", x);
         line.setAttribute("y1", CANVAS_PADDING);
         line.setAttribute("x2", x);
         line.setAttribute("y2", CANVAS_HEIGHT - CANVAS_PADDING);
         line.setAttribute("stroke", (x - CANVAS_PADDING) % (gridSize * 5) === 0 ? majorGridColor : gridColor);
         line.setAttribute("stroke-width", (x - CANVAS_PADDING) % (gridSize * 5) === 0 ? "2" : "1");
         gridGroup.appendChild(line);
        }
        
        for (let y = CANVAS_PADDING; y <= CANVAS_HEIGHT - CANVAS_PADDING; y += gridSize) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", CANVAS_PADDING);
         line.setAttribute("y1", y);
         line.setAttribute("x2", CANVAS_WIDTH - CANVAS_PADDING);
         line.setAttribute("y2", y);
         line.setAttribute("stroke", (y - CANVAS_PADDING) % (gridSize * 5) === 0 ? majorGridColor : gridColor);
         line.setAttribute("stroke-width", (y - CANVAS_PADDING) % (gridSize * 5) === 0 ? "2" : "1");
         gridGroup.appendChild(line);
        }
        
        svg.appendChild(gridGroup);
       }
       
       if (currentView.mode === "rack" && currentView.rackId) {
        const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
        const rackGroup = document.createElementNS(ns, "g");
        rackGroup.id = "rack-visualization";
        
        const rackFrame = document.createElementNS(ns, "rect");
        rackFrame.setAttribute("x", RACK_START_X - RACK_WIDTH / 2);
        rackFrame.setAttribute("y", RACK_START_Y);
        rackFrame.setAttribute("width", RACK_WIDTH);
      
      rackFrame.setAttribute("height", rackCapacity * rackUHeight);
      
        rackFrame.setAttribute("fill", (PAGE_STATE.rackFrameFill || "#0f172a") + "4D");
        rackFrame.setAttribute("stroke", PAGE_STATE.rackFrameStroke || "#4fd1c5");
        rackFrame.setAttribute("stroke-width", "3");
        rackFrame.setAttribute("rx", "4");
        rackGroup.appendChild(rackFrame);
        
        for (let u = 0; u <= rackCapacity; u++) {
         const y = RACK_START_Y + u * rackUHeight;
      
         
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", RACK_START_X - RACK_WIDTH / 2);
         line.setAttribute("y1", y);
         line.setAttribute("x2", RACK_START_X + RACK_WIDTH / 2);
         line.setAttribute("y2", y);
         line.setAttribute("stroke", (PAGE_STATE.rackLineColor || "#475569") + "66");
         line.setAttribute("stroke-width", u % 5 === 0 ? "2" : "1");
         line.setAttribute("stroke-dasharray", u % 5 === 0 ? "none" : "5,5");
         rackGroup.appendChild(line);
         
         if (u < rackCapacity) {
          const uNumber = rackCapacity - u; 
          const text = document.createElementNS(ns, "text");
          text.setAttribute("x", RACK_START_X - RACK_WIDTH / 2 - 30);
          text.setAttribute("y", y + rackUHeight / 2);
      
          text.setAttribute("text-anchor", "middle");
          text.setAttribute("dominant-baseline", "middle");
          text.style.fill = PAGE_STATE.rackTextColor || "#4fd1c5";
          text.style.fontSize = "14px";
          text.style.fontWeight = "bold";
          text.textContent = `U${uNumber}`;
          rackGroup.appendChild(text);
          
          const textRight = document.createElementNS(ns, "text");
          textRight.setAttribute("x", RACK_START_X + RACK_WIDTH / 2 + 30);
          textRight.setAttribute("y", y + rackUHeight / 2);
      
          textRight.setAttribute("text-anchor", "middle");
          textRight.setAttribute("dominant-baseline", "middle");
          textRight.style.fill = PAGE_STATE.rackTextColor || "#4fd1c5";
          textRight.style.fontSize = "14px";
          textRight.style.fontWeight = "bold";
          textRight.textContent = `U${uNumber}`;
          rackGroup.appendChild(textRight);
         }
        }
        
        svg.appendChild(rackGroup);
       }
       
        if (RECT_DATA && RECT_DATA.list) {
         RECT_DATA.list.forEach((rect) => {
          if (currentView.mode === "rack") return;
          
          if (rect.style === "filled") {
           const g = document.createElementNS(ns, "g");
           g.classList.add("rect-group");
           g.dataset.rectId = rect.id;
           
           const rectEl = document.createElementNS(ns, "rect");
           rectEl.classList.add("rect-shape");
           rectEl.setAttribute("x", rect.x);
           rectEl.setAttribute("y", rect.y);
           rectEl.setAttribute("width", rect.width);
           rectEl.setAttribute("height", rect.height);
           rectEl.style.fill = rect.color;
           rectEl.style.fillOpacity = "0.3";
           rectEl.style.stroke = rect.borderColor || rect.color;
           rectEl.style.strokeWidth = (rect.borderWidth !== undefined ? rect.borderWidth : 2) + "px";
           if (rect.lineStyle === "dashed") { rectEl.style.strokeDasharray = "10,5"; }
           else if (rect.lineStyle === "dotted") { rectEl.style.strokeDasharray = "2,4"; }
           else { rectEl.style.strokeDasharray = "none"; }
           rectEl.style.cursor = "move";
           
          rectEl.addEventListener("click", (e) => {
             if (rectDrawMode) return;
             e.stopPropagation();
             currentRectId = rect.id;
             selectTheRect(rect.id);
           });
           
           rectEl.addEventListener("contextmenu", (e) => {
             e.preventDefault();
             e.stopPropagation();
             if (selectedRects.has(rect.id)) {
               selectedRects.delete(rect.id);
             } else {
               selectedRects.add(rect.id);
             }
             updateAllSelections();
           });
           
           let rectLastTap = 0;
           rectEl.addEventListener("touchend", (e) => {
             const now = Date.now();
             if (now - rectLastTap < 300) {
               e.preventDefault();
               if (selectedRects.has(rect.id)) {
                 selectedRects.delete(rect.id);
               } else {
                 selectedRects.add(rect.id);
               }
               updateAllSelections();
               if (navigator.vibrate) navigator.vibrate(50);
               rectLastTap = 0;
             } else {
               rectLastTap = now;
             }
           }, { passive: false });
      
           const deleteBtn = document.createElementNS(ns, "g");
           deleteBtn.classList.add("rect-delete-btn");
           deleteBtn.style.cursor = "pointer";
           deleteBtn.style.display = rectDrawMode ? "block" : "none";
           
           const deleteBg = document.createElementNS(ns, "circle");
           deleteBg.setAttribute("cx", rect.x + rect.width - 10);
           deleteBg.setAttribute("cy", rect.y + 10);
           deleteBg.setAttribute("r", 12);
           deleteBg.style.fill = "#f56565";
           deleteBg.style.stroke = "white";
           deleteBg.style.strokeWidth = "2";
           
           const deleteX = document.createElementNS(ns, "text");
           deleteX.setAttribute("x", rect.x + rect.width - 10);
           deleteX.setAttribute("y", rect.y + 10);
           deleteX.setAttribute("text-anchor", "middle");
           deleteX.setAttribute("dominant-baseline", "middle");
           deleteX.style.fill = "white";
           deleteX.style.fontSize = "16px";
           deleteX.style.fontWeight = "bold";
           deleteX.style.pointerEvents = "none";
           deleteX.textContent = "Ã—";
           
           deleteBtn.appendChild(deleteBg);
           deleteBtn.appendChild(deleteX);
           
           deleteBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            e.preventDefault();
            deleteRectangle(rect.id);
           });
      
           deleteBtn.addEventListener("touchend", (e) => {
      e.stopPropagation();
           e.preventDefault();
           deleteRectangle(rect.id);
           });
           
           let isDragging = false;
           let dragStartX, dragStartY;
           let rectStartX, rectStartY;
           
         rectEl.addEventListener("mousedown", (e) => {
      if (rectDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      rectStartX = rect.x;
      rectStartY = rect.y;
      rectEl.style.cursor = "grabbing";
      
      if (selectedRects.has(rect.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
           
           const moveHandler = (e) => {
      if (!isDragging || rectDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      
      rect.x = rectStartX + dx;
      rect.y = rectStartY + dy;
      
      if (selectedRects.has(rect.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       const newX = initialPositions[nodeId].x + dx;
       const newY = initialPositions[nodeId].y + dy;
       savedPositions[nodeId] = { x: newX, y: newY };
      }
      });
      selectedRects.forEach(rectId => {
      if (rectId === rect.id) return;
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      
      forgeTheTopology();
      };
           
           const upHandler = () => {
            if (isDragging) {
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           };
           
           document.addEventListener("mousemove", moveHandler);
           document.addEventListener("mouseup", upHandler);
           
           let touchStartX, touchStartY;
           let touchRectStartX, touchRectStartY;
           
           rectEl.addEventListener("touchstart", (e) => {
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchRectStartX = rect.x;
            touchRectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           }, { passive: false });
           
           rectEl.addEventListener("touchmove", (e) => {
            if (!isDragging || rectDrawMode) return;
            if (!e.touches[0]) return;
            e.preventDefault();
            e.stopPropagation();
            
            const svgEl = svg;
            const pt1 = svgEl.createSVGPoint();
            pt1.x = touchStartX;
            pt1.y = touchStartY;
            const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
            
            const touch = e.touches[0];
            const pt2 = svgEl.createSVGPoint();
            pt2.x = touch.clientX;
            pt2.y = touch.clientY;
            const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
            
            const dx = svgP2.x - svgP1.x;
            const dy = svgP2.y - svgP1.y;
            
            rect.x = touchRectStartX + dx;
            rect.y = touchRectStartY + dy;
            
            forgeTheTopology();
           }, { passive: false });
           
           rectEl.addEventListener("touchend", (e) => {
            if (isDragging) {
             e.preventDefault();
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           }, { passive: false });
            if (currentRectId === rect.id) {
      const corners = [
      { cx: rect.x, cy: rect.y, cursor: 'nwse-resize', dx: -1, dy: -1 },
      { cx: rect.x + rect.width, cy: rect.y, cursor: 'nesw-resize', dx: 1, dy: -1 },
      { cx: rect.x, cy: rect.y + rect.height, cursor: 'nesw-resize', dx: -1, dy: 1 },
      { cx: rect.x + rect.width, cy: rect.y + rect.height, cursor: 'nwse-resize', dx: 1, dy: 1 }
      ];
      corners.forEach((corner, idx) => {
      const handle = document.createElementNS(ns, "circle");
      handle.setAttribute("cx", corner.cx);
      handle.setAttribute("cy", corner.cy);
      handle.setAttribute("r", PAGE_STATE.selectionHandleSize || 8);
      handle.style.fill = PAGE_STATE.selectionHandle || "#f59e0b";
      handle.style.stroke = "#fff";
      handle.style.strokeWidth = "2";
      handle.style.cursor = corner.cursor;
      handle.addEventListener("mousedown", (e) => {
      e.preventDefault();
      e.stopPropagation();
      let dragging = true;
      const startX = e.clientX, startY = e.clientY;
      const origX = rect.x, origY = rect.y, origW = rect.width, origH = rect.height;
      const moveHandler = (ev) => {
        if (!dragging) return;
        const pt1 = svg.createSVGPoint(); pt1.x = startX; pt1.y = startY;
        const pt2 = svg.createSVGPoint(); pt2.x = ev.clientX; pt2.y = ev.clientY;
        const svgP1 = pt1.matrixTransform(svg.getScreenCTM().inverse());
        const svgP2 = pt2.matrixTransform(svg.getScreenCTM().inverse());
        const dx = svgP2.x - svgP1.x, dy = svgP2.y - svgP1.y;
        if (corner.dx < 0) { rect.x = origX + dx; rect.width = origW - dx; }
        else { rect.width = origW + dx; }
        if (corner.dy < 0) { rect.y = origY + dy; rect.height = origH - dy; }
        else { rect.height = origH + dy; }
        if (rect.width < 20) rect.width = 20;
        if (rect.height < 20) rect.height = 20;
        forgeTheTopology();
      };
      const upHandler = () => { dragging = false; document.removeEventListener("mousemove", moveHandler); document.removeEventListener("mouseup", upHandler); };
      document.addEventListener("mousemove", moveHandler);
      document.addEventListener("mouseup", upHandler);
      });
      g.appendChild(handle);
      });
      }
          if (rect.groupId) {
      const groupIndicator = document.createElementNS(ns, "rect");
      groupIndicator.setAttribute("x", rect.x - 4);
      groupIndicator.setAttribute("y", rect.y - 4);
      groupIndicator.setAttribute("width", rect.width + 8);
      groupIndicator.setAttribute("height", rect.height + 8);
      groupIndicator.style.fill = "none";
      groupIndicator.style.stroke = "#4fd1c5";
      groupIndicator.style.strokeWidth = "3";
      groupIndicator.style.strokeDasharray = "5,5";
      groupIndicator.style.pointerEvents = "none";
      g.insertBefore(groupIndicator, g.firstChild);
      }
      g.appendChild(rectEl);
      g.appendChild(deleteBtn);
      svg.appendChild(g);
          }
         });
        }
       const centerX = CANVAS_WIDTH / 2;
       const centerY = CANVAS_HEIGHT / 2;
       let positions = {};
              Object.keys(NODE_DATA).forEach((id) => {
        if (currentView.mode === "rack") {
         const node = NODE_DATA[id];
         if (!node || node.assignedRack !== currentView.rackId) {
          return; 
         }
        }
        
        positions[id] = savedPositions[id] || {
         x: centerX,
         y: centerY
        };
       });
       if (Object.keys(savedPositions).length === 0) {
        const nodeIds = Object.keys(NODE_DATA).filter(id => {
         if (currentView.mode === "rack") {
          const node = NODE_DATA[id];
          return node && node.assignedRack === currentView.rackId;
         }
         return true;
        });
        
        const baseY = centerY - 300;
        if (nodeIds.length > 0) {
         positions[nodeIds[0]] = {
          x: centerX,
          y: baseY
         };
         const remaining = nodeIds.slice(1);
         const radius = 350;
         const startAngle = Math.PI * 0.3;
         const endAngle = Math.PI * 0.7;
         remaining.forEach((id, i) => {
          const angle = startAngle + (endAngle - startAngle) * (i / Math.max(1, remaining.length - 1));
          positions[id] = {
           x: centerX + Math.cos(angle) * radius * (i % 2 === 0 ? 1 : 1.3),
           y: baseY + 200 + Math.sin(angle) * radius * 0.8 + i * 80,
          };
         });
        }
       }
       Object.keys(positions).forEach((id) => {
        let pos = savedPositions[id] || positions[id];
        const nodeSize = savedSizes[id] || 55;
        pos.x = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, pos.x), );
        pos.y = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, pos.y), );
        positions[id] = {
         x: pos.x,
         y: pos.y
        };
        savedPositions[id] = {
         x: pos.x,
         y: pos.y
        };
       });
       const edgePairCount = {};
       const edgePairIndex = {};
       EDGE_DATA.list.forEach((edge) => {
        if (edge.type === "custom") return;
        const key = [edge.from, edge.to].sort().join("||");
        edgePairCount[key] = (edgePairCount[key] || 0) + 1;
       });
       EDGE_DATA.list.forEach((edge) => {
        if (edge.type === "custom") return;
        const key = [edge.from, edge.to].sort().join("||");
        if (!edgePairIndex[key]) edgePairIndex[key] = 0;
        edge._pairIndex = edgePairIndex[key];
        edge._pairTotal = edgePairCount[key];
        edgePairIndex[key]++;
       });
       EDGE_DATA.list.forEach((edge) => {
        if (edge.type === "custom" && Array.isArray(edge.points) && edge.points.length >= 2) {
         const poly = document.createElementNS(ns, "polyline");
         poly.classList.add("edge");
         poly.dataset.edgeId = edge.id;
         poly.style.stroke = edge.color || PAGE_STATE.defaultEdge || "#475569";
         poly.style.strokeWidth = edge.width || 4;
         poly.setAttribute("fill", "none");
         const lineStyle = edge.lineStyle || "solid";
         if (lineStyle === "dashed") {
          poly.style.strokeDasharray = "10,5";
         } else if (lineStyle === "dotted") {
          poly.style.strokeDasharray = "2,4";
         } else {
          poly.style.strokeDasharray = "none";
         }
         const direction = edge.direction || "none";
         if (direction === "forward") {
          poly.setAttribute("marker-end", "url(#arrow-forward)");
         } else if (direction === "backward") {
          poly.setAttribute("marker-start", "url(#arrow-backward)");
         } else if (direction === "both") {
          poly.setAttribute("marker-start", "url(#arrow-backward)");
          poly.setAttribute("marker-end", "url(#arrow-forward)");
         }
         const ptsStr = edge.points.map((p) => `${p.x},${p.y}`).join(" ");
         poly.setAttribute("points", ptsStr);
         const polyHit = document.createElementNS(ns, "polyline");
         polyHit.setAttribute("points", ptsStr);
         polyHit.style.fill = "none";
         polyHit.style.stroke = "transparent";
         polyHit.style.strokeWidth = "20";
         polyHit.style.cursor = "pointer";
         polyHit.dataset.edgeId = edge.id;
         polyHit.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         let edgeTouchStart = null;
         let edgeTouchMoved = false;
         polyHit.addEventListener("touchstart", (e) => {
          edgeTouchStart = Date.now();
          edgeTouchMoved = false;
          if (e.touches[0]) {
           edgeTouchStartX = e.touches[0].clientX;
           edgeTouchStartY = e.touches[0].clientY;
          }
         }, {
          passive: false
         });
         let edgeTouchStartX = 0, edgeTouchStartY = 0;
         polyHit.addEventListener("touchmove", (e) => {
          if (e.touches[0]) {
           const dx = Math.abs(e.touches[0].clientX - edgeTouchStartX);
           const dy = Math.abs(e.touches[0].clientY - edgeTouchStartY);
           if (dx > 10 || dy > 10) edgeTouchMoved = true;
          }
         }, {
          passive: false
         });
         polyHit.addEventListener("touchend", (e) => {
          if (edgeTouchStart && !edgeTouchMoved && Date.now() - edgeTouchStart < 400) {
           e.stopPropagation();
           e.preventDefault();
           selectTheConnection(edge.id);
          }
          edgeTouchStart = null;
          edgeTouchMoved = false;
         }, {
          passive: false
         });
         poly.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         
         polyHit.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (selectedEdges.has(edge.id)) {
           selectedEdges.delete(edge.id);
          } else {
           selectedEdges.add(edge.id);
          }
          updateAllSelections();
         });
         
         let customEdgeLastTap = 0;
         polyHit.addEventListener("touchend", (e) => {
          const now = Date.now();
          if (now - customEdgeLastTap < 300) {
           e.preventDefault();
           if (selectedEdges.has(edge.id)) {
            selectedEdges.delete(edge.id);
           } else {
            selectedEdges.add(edge.id);
           }
           updateAllSelections();
           if (navigator.vibrate) navigator.vibrate(50);
           customEdgeLastTap = 0;
          } else {
           customEdgeLastTap = now;
          }
         }, { passive: false });   
         poly.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (selectedEdges.has(edge.id)) {
           selectedEdges.delete(edge.id);
          } else {
           selectedEdges.add(edge.id);
          }
          updateAllSelections();
         });
         
         let edgeLastTap = 0;
         poly.addEventListener("touchend", (e) => {
          const now = Date.now();
          if (now - edgeLastTap < 300) {
           e.preventDefault();
           if (selectedEdges.has(edge.id)) {
            selectedEdges.delete(edge.id);
           } else {
            selectedEdges.add(edge.id);
           }
           updateAllSelections();
           if (navigator.vibrate) navigator.vibrate(50);
           edgeLastTap = 0;
          } else {
           edgeLastTap = now;
          }
         });
         
         if (currentView.mode === "rack") {
          return;
         }
         if (edge.groupId) {
      const bounds = edge.points.reduce((acc, p) => ({ minX: Math.min(acc.minX, p.x), minY: Math.min(acc.minY, p.y), maxX: Math.max(acc.maxX, p.x), maxY: Math.max(acc.maxY, p.y) }), { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity });
      const groupIndicator = document.createElementNS(ns, "rect");
      groupIndicator.setAttribute("x", bounds.minX - 8);
      groupIndicator.setAttribute("y", bounds.minY - 8);
      groupIndicator.setAttribute("width", bounds.maxX - bounds.minX + 16);
      groupIndicator.setAttribute("height", bounds.maxY - bounds.minY + 16);
      groupIndicator.setAttribute("rx", "4");
      groupIndicator.style.fill = "none";
      groupIndicator.style.stroke = "#4fd1c5";
      groupIndicator.style.strokeWidth = "3";
      groupIndicator.style.strokeDasharray = "5,5";
      groupIndicator.style.pointerEvents = "none";
      svg.appendChild(groupIndicator);
      }
         let lineDragging = false;
      let lineDragStartX, lineDragStartY;
      let linePointsStart = [];
      
      polyHit.addEventListener("mousedown", (e) => {
      if (freeDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      lineDragging = true;
      lineDragStartX = e.clientX;
      lineDragStartY = e.clientY;
      linePointsStart = edge.points.map(p => ({x: p.x, y: p.y}));
      
      if (selectedEdges.has(edge.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
      
      const lineMoveHandler = (e) => {
      if (!lineDragging || freeDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = lineDragStartX;
      pt1.y = lineDragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      
      edge.points.forEach((p, i) => { p.x = linePointsStart[i].x + dx; p.y = linePointsStart[i].y + dy; });
      
      if (selectedEdges.has(edge.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       savedPositions[nodeId] = { x: initialPositions[nodeId].x + dx, y: initialPositions[nodeId].y + dy };
      }
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      if (edgeId === edge.id) return;
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      forgeTheTopology();
      };
      
      const lineUpHandler = () => { lineDragging = false; };
      document.addEventListener("mousemove", lineMoveHandler);
      document.addEventListener("mouseup", lineUpHandler);
      
      svg.appendChild(poly);
      svg.appendChild(polyHit);
         
         if (currentEdgeId === edge.id) {
          edge.points.forEach((p, idx) => {
           const c = document.createElementNS(ns, "circle");
           c.classList.add("edge-edit-point");
           c.setAttribute("cx", p.x);
           c.setAttribute("cy", p.y);
      c.setAttribute("r", PAGE_STATE.selectionHandleSize || 8);
           c.style.fill = PAGE_STATE.selectionHandle || "#f59e0b";
           c.style.stroke = "#fff";
           c.style.strokeWidth = "2";
           c.style.cursor = "move";
           c.dataset.edgeId = edge.id;
           c.dataset.pointIndex = String(idx);
           
           c.addEventListener("mousedown", (e) => {
            e.preventDefault();
            e.stopPropagation();
            let dragging = true;
            const svgEl = svg;
            const moveHandler = (ev) => {
             if (!dragging) return;
             const pt = svgEl.createSVGPoint();
             pt.x = ev.clientX;
             pt.y = ev.clientY;
             const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
             edge.points[idx].x = svgP.x;
             edge.points[idx].y = svgP.y;
             forgeTheTopology();
            };
            const upHandler = () => {
             dragging = false;
             document.removeEventListener("mousemove", moveHandler);
             document.removeEventListener("mouseup", upHandler);
            };
            document.addEventListener("mousemove", moveHandler);
            document.addEventListener("mouseup", upHandler);
           });
           
           c.addEventListener("touchstart", (e) => {
            e.preventDefault();
            e.stopPropagation();
            let dragging = true;
            const svgEl = svg;
            const touchMoveHandler = (ev) => {
             if (!dragging || !ev.touches[0]) return;
             const pt = svgEl.createSVGPoint();
             pt.x = ev.touches[0].clientX;
             pt.y = ev.touches[0].clientY;
             const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
             edge.points[idx].x = svgP.x;
             edge.points[idx].y = svgP.y;
             forgeTheTopology();
            };
            const touchUpHandler = () => {
             dragging = false;
             document.removeEventListener("touchmove", touchMoveHandler);
             document.removeEventListener("touchend", touchUpHandler);
            };
            document.addEventListener("touchmove", touchMoveHandler);
            document.addEventListener("touchend", touchUpHandler);
           }, { passive: false });
           
           svg.appendChild(c);
          });
         }
         
         return;
        }
        const p1 = positions[edge.from];
        const p2 = positions[edge.to];
        if (!p1 || !p2) return;
        const pairTotal = edge._pairTotal || 1;
        const pairIndex = edge._pairIndex || 0;
        const midX = (p1.x + p2.x) / 2;
        const midY = (p1.y + p2.y) / 2;
        const dx = p2.x - p1.x;
        const dy = p2.y - p1.y;
        const len = Math.sqrt(dx * dx + dy * dy) || 1;
        const perpX = -dy / len;
        const perpY = dx / len;
        let offsetAmount = 0;
        if (pairTotal > 1) {
         offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
        }
        const ctrlX = midX + perpX * offsetAmount;
        const ctrlY = midY + perpY * offsetAmount;
        const path = document.createElementNS(ns, "path");
        path.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
        path.setAttribute("fill", "none");
        path.classList.add("edge");
        if (edge.type === "backup") path.classList.add("backup");
        path.dataset.edgeId = edge.id;
        path.dataset.from = edge.from;
        path.dataset.to = edge.to;
        path.style.stroke = edge.color;
        path.style.strokeWidth = edge.width;
        const pathHit = document.createElementNS(ns, "path");
        pathHit.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
        pathHit.setAttribute("fill", "none");
        pathHit.style.stroke = "transparent";
        pathHit.style.strokeWidth = "20";
        pathHit.style.cursor = "pointer";
        pathHit.dataset.edgeId = edge.id;
        pathHit.addEventListener("click", (e) => {
         e.stopPropagation();
         selectTheConnection(edge.id);
        });
        let pathTouchStart = null;
        let pathTouchMoved = false;
        pathHit.addEventListener("touchstart", (e) => {
         pathTouchStart = Date.now();
         pathTouchMoved = false;
         if (e.touches[0]) {
          pathTouchStartX = e.touches[0].clientX;
          pathTouchStartY = e.touches[0].clientY;
         }
        }, {
         passive: false
        });
        let pathTouchStartX = 0, pathTouchStartY = 0;
        pathHit.addEventListener("touchmove", (e) => {
         if (e.touches[0]) {
          const dx = Math.abs(e.touches[0].clientX - pathTouchStartX);
          const dy = Math.abs(e.touches[0].clientY - pathTouchStartY);
          if (dx > 10 || dy > 10) pathTouchMoved = true;
         }
        }, {
         passive: false
        });
        pathHit.addEventListener("touchend", (e) => {
         if (pathTouchStart && !pathTouchMoved && Date.now() - pathTouchStart < 400) {
          e.stopPropagation();
          e.preventDefault();
          selectTheConnection(edge.id);
         }
         pathTouchStart = null;
         pathTouchMoved = false;
        }, {
         passive: false
        });
        path.addEventListener("click", (e) => {
         e.stopPropagation();
         selectTheConnection(edge.id);
        });
        
        if (currentView.mode === "rack") {
         const fromNode = NODE_DATA[edge.from];
         const toNode = NODE_DATA[edge.to];
         if (!fromNode || !toNode || 
             fromNode.assignedRack !== currentView.rackId || 
             toNode.assignedRack !== currentView.rackId) {
          return; 
         }
        }
        
        const fromVisible = isNodeVisible(edge.from);
        const toVisible = isNodeVisible(edge.to);
        if (!fromVisible || !toVisible) {
         path.style.opacity = "0.1";
         path.style.pointerEvents = "none";
         pathHit.style.pointerEvents = "none";
        }
        
        svg.appendChild(path);
        svg.appendChild(pathHit);
        
        if (edge.fromPort || edge.toPort) {
         const ns = "http://www.w3.org/2000/svg";
         
         if (edge.fromPort) {
          const fromLabel = document.createElementNS(ns, "text");
          fromLabel.textContent = edge.fromPort;
          fromLabel.setAttribute("x", p1.x);
          fromLabel.setAttribute("y", p1.y - 10);
          fromLabel.setAttribute("text-anchor", "middle");
          fromLabel.style.fill = "#94a3b8";
          fromLabel.style.fontSize = "12px";
          fromLabel.style.fontWeight = "600";
          fromLabel.style.pointerEvents = "none";
          fromLabel.classList.add("port-label");
          svg.appendChild(fromLabel);
         }
         
         if (edge.toPort) {
          const toLabel = document.createElementNS(ns, "text");
          toLabel.textContent = edge.toPort;
          toLabel.setAttribute("x", p2.x);
          toLabel.setAttribute("y", p2.y - 10);
          toLabel.setAttribute("text-anchor", "middle");
          toLabel.style.fill = "#94a3b8";
          toLabel.style.fontSize = "12px";
          toLabel.style.fontWeight = "600";
          toLabel.style.pointerEvents = "none";
          toLabel.classList.add("port-label");
          svg.appendChild(toLabel);
         }
        }
       });
       Object.entries(positions).forEach(([id, pos]) => {
        const node = NODE_DATA[id];
        if (!node) return;
        
        if (currentView.mode === "rack") {
         if (node.assignedRack !== currentView.rackId) return;
         
         const rackUnit = parseInt(node.rackUnit) || 1;
      const uHeight = parseInt(node.uHeight) || 1;
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      pos.x = RACK_START_X;
      pos.y = RACK_START_Y + (rackCapacity - rackUnit - uHeight + 1) * rackUHeight + (uHeight * rackUHeight) / 2;
      
        } else {
         if (node.assignedRack) return;
        }
        
        const g = document.createElementNS("http://www.w3.org/2000/svg", "g", );
        g.classList.add("node-group");
        g.dataset.nodeId = id;
        g.setAttribute("transform", `translate(${pos.x},${pos.y})`);
        let r = savedSizes[id] || 55;
        if (!savedSizes[id]) {
         if (window.innerWidth <= 380) r = 120;
         else if (window.innerWidth <= 768) r = 140;
         else if (window.innerWidth <= 1024) r = 70;
        }
        const styles = resolveStylesForNode(id);
        const ns = "http://www.w3.org/2000/svg";
        const hitArea = document.createElementNS(ns, "circle");
        hitArea.setAttribute("r", r * 1.5);
        hitArea.style.fill = "transparent";
        hitArea.style.stroke = "none";
        hitArea.style.cursor = "grab";
        hitArea.classList.add("node-hit-area");
        const shapeEl = createNodeShape(id, r);
        const titleOffsetX = styles.titleOffsetX || 0;
        const titleOffsetY = styles.titleOffsetY || 0;
        const subOffsetX = styles.subOffsetX || 0;
        const subOffsetY = styles.subOffsetY || 0;
        const label = document.createElementNS("http://www.w3.org/2000/svg", "text", );
        label.classList.add("node-label");
        label.setAttribute("x", titleOffsetX);
        label.setAttribute("y", -r * 0.28 + titleOffsetY);
      const labelFontSize = styles.titleSize || PAGE_STATE.nodeTitleSize || r * 0.33;
        label.style.fontSize = labelFontSize + "px";
        label.textContent = NODE_DATA[id].name;
      label.style.fill = styles.titleColor || PAGE_STATE.nodeTitle || "#e2e8f0";
        label.style.fontFamily = styles.titleFont || PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
        label.style.pointerEvents = "none";
        const sub = document.createElementNS("http://www.w3.org/2000/svg", "text", );
        sub.classList.add("node-sub");
        sub.setAttribute("x", subOffsetX);
        sub.setAttribute("y", r * 0.4 + subOffsetY);
      const subFontSize = styles.subSize || PAGE_STATE.nodeSubSize || r * 0.24;
        sub.style.fontSize = subFontSize + "px";
        sub.textContent = NODE_DATA[id].ip;
      sub.style.fill = styles.subColor || PAGE_STATE.nodeSub || "#94a3b8";
        sub.style.fontFamily = styles.subFont || PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
        sub.style.pointerEvents = "none";
        g.append(hitArea, shapeEl, label, sub);
        
        if (NODE_DATA[id]?.locked) {
          const lockIcon = document.createElementNS(ns, "text");
          lockIcon.textContent = "ðŸ”’";
          lockIcon.setAttribute("x", r * 0.6);
          lockIcon.setAttribute("y", -r * 0.6);
          lockIcon.style.fontSize = (r * 0.4) + "px";
          lockIcon.style.pointerEvents = "none";
          lockIcon.style.userSelect = "none";
          lockIcon.classList.add("lock-indicator");
          g.appendChild(lockIcon);
        }
        
        if (NODE_DATA[id]?.groupId) {
          const groupIndicator = document.createElementNS(ns, "circle");
          groupIndicator.setAttribute("r", r + 4);
          groupIndicator.style.fill = "none";
      groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
          groupIndicator.style.strokeWidth = "3";
          groupIndicator.style.strokeDasharray = "5,5";
          groupIndicator.style.pointerEvents = "none";
          groupIndicator.classList.add("group-indicator");
          g.insertBefore(groupIndicator, g.firstChild);
        }
        
        let isDragging = false;
        let startX, startY;
        let initialPositions = {};
        let longPressTimer = null;
        let longPressTriggered = false;
        
        g.addEventListener("contextmenu", (e) => {
         e.preventDefault();
         e.stopPropagation();
         
         if (selectedNodes.has(id)) {
          selectedNodes.delete(id);
         } else {
          selectedNodes.add(id);
         }
         updateNodeSelection();
         return false;
        });
        
        g.addEventListener("touchstart", (e) => {
         if (NODE_DATA[id].isRack) {
          const touch = e.touches[0];
          longPressStartX = touch.clientX;
          longPressStartY = touch.clientY;
          longPressTimer = setTimeout(() => {
           longPressTriggered = true;
           if (navigator.vibrate) {
            navigator.vibrate(100);
           }
           enterRack(id);
          }, 500); 
         }
        }, { passive: true });
        
        let lastTapTime = 0;
        let lastTapNode = null;
        
        g.addEventListener("touchend", (e) => {
         const currentTime = new Date().getTime();
         const tapLength = currentTime - lastTapTime;
         
         if (tapLength < 300 && tapLength > 0 && lastTapNode === id) {
          e.preventDefault();
          e.stopPropagation();
          
          if (selectedNodes.has(id)) {
           selectedNodes.delete(id);
          } else {
           selectedNodes.add(id);
          }
          updateNodeSelection();
          
          if (navigator.vibrate) {
           navigator.vibrate(50);
          }
          
          lastTapTime = 0;
          lastTapNode = null;
         } else {
          lastTapTime = currentTime;
          lastTapNode = id;
         }
        });
        
        g.addEventListener("touchend", (e) => {
         if (longPressTimer) {
          clearTimeout(longPressTimer);
          longPressTimer = null;
         }
         if (longPressTriggered) {
          e.preventDefault();
          e.stopPropagation();
          longPressTriggered = false;
         }
        });
        
        let longPressStartX = 0;
        let longPressStartY = 0;
        g.addEventListener("touchmove", (e) => {
         if (longPressTimer) {
          const touch = e.touches[0];
          const dx = Math.abs(touch.clientX - longPressStartX);
          const dy = Math.abs(touch.clientY - longPressStartY);
          if (dx > 15 || dy > 15) {
           clearTimeout(longPressTimer);
           longPressTimer = null;
           longPressTriggered = false;
          }
         }
        });
        
        g.addEventListener("mousedown", (e) => {
         if (e.button === 2) {
          return;
         }
         
         if (NODE_DATA[id]?.locked) {
          return;
         }
         
         e.preventDefault();
         isDragging = true;
         const svgEl = document.getElementById("map");
         const pt = svgEl.createSVGPoint();
         pt.x = e.clientX;
         pt.y = e.clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
         startX = svgP.x;
         startY = svgP.y;
      if (selectedNodes.has(id)) {
      initialPositions = {};
      const allSelectedRects = Array.from(selectedRects);
      const allSelectedTexts = Array.from(selectedTexts);
      const allSelectedEdges = Array.from(selectedEdges).map(eid => EDGE_DATA.list.find(e => e.id === eid)).filter(Boolean);   
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) {
      initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      }
      });
      Array.from(selectedRects).forEach(rectId => {
        const rect = RECT_DATA.list.find(r => r.id === rectId);
        if (rect) { rect._dragStartX = rect.x; rect._dragStartY = rect.y; }
      });
      Array.from(selectedTexts).forEach(textId => {
        const text = TEXT_DATA.list.find(t => t.id === textId);
        if (text) { text._dragStartX = text.x; text._dragStartY = text.y; }
      });
      Array.from(selectedEdges).forEach(edgeId => {
        const edge = EDGE_DATA.list.find(e => e.id === edgeId);
        if (edge && edge.points) { edge._dragStartPoints = edge.points.map(p => ({x: p.x, y: p.y})); }
      });
      
      
      
      
      } else {
      initialPositions = { [id]: { x: pos.x, y: pos.y } };
      }
      if (currentView.mode === "rack") {
      initialPositions[id] = { x: pos.x, y: pos.y };
      }
         
         g.style.cursor = "grabbing";
         hitArea.style.cursor = "grabbing";
         e.stopPropagation();
        });
        const handleMouseMove = (e) => {
         if (!isDragging) return;
         e.preventDefault();
         const svgEl = document.getElementById("map");
         const pt = svgEl.createSVGPoint();
         pt.x = e.clientX;
         pt.y = e.clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
         const dx = svgP.x - startX;
         const dy = svgP.y - startY;
         
         let nodesToMove = selectedNodes.has(id) ? Array.from(selectedNodes) : [id];
         
         const groupIds = new Set();
         nodesToMove.forEach(nodeId => {
          const groupId = NODE_DATA[nodeId]?.groupId;
          if (groupId) {
            groupIds.add(groupId);
          }
         });
         
         if (groupIds.size > 0) {
          Object.keys(NODE_DATA).forEach(nodeId => {
            const nodeGroupId = NODE_DATA[nodeId]?.groupId;
            if (nodeGroupId && groupIds.has(nodeGroupId)) {
              if (!nodesToMove.includes(nodeId)) {
                nodesToMove.push(nodeId);
                if (!initialPositions[nodeId]) {
                  const nodePos = savedPositions[nodeId];
                  if (nodePos) {
                    initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
                  }
                }
              }
            }
          });
         }
         
         nodesToMove = nodesToMove.filter(nodeId => !NODE_DATA[nodeId]?.locked);
         
         nodesToMove.forEach(nodeId => {
          if (!initialPositions[nodeId]) return;
          const initialPos = initialPositions[nodeId];
          let newX = initialPos.x + dx;
          let newY = initialPos.y + dy;
          const nodeSize = savedSizes[nodeId] || 55;
          newX = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, newX), );
          newY = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, newY), );
          
          savedPositions[nodeId] = { x: newX, y: newY };
          positions[nodeId] = { x: newX, y: newY };
          
          if (nodeId === id) {
           pos.x = newX;
           pos.y = newY;
          }
          
          const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
          if (nodeGroup) {
           nodeGroup.setAttribute("transform", `translate(${newX},${newY})`);
          }
         });
         
         Array.from(selectedRects).forEach(rectId => {
           const rect = RECT_DATA.list.find(r => r.id === rectId);
           if (rect && rect._dragStartX !== undefined) {
             rect.x = rect._dragStartX + dx;
             rect.y = rect._dragStartY + dy;
           }
         });
         Array.from(selectedTexts).forEach(textId => {
           const text = TEXT_DATA.list.find(t => t.id === textId);
           if (text && text._dragStartX !== undefined) {
             text.x = text._dragStartX + dx;
             text.y = text._dragStartY + dy;
           }
         });
         Array.from(selectedEdges).forEach(edgeId => {
           const edge = EDGE_DATA.list.find(e => e.id === edgeId);
           if (edge && edge._dragStartPoints) {
             edge.points.forEach((p, i) => {
               p.x = edge._dragStartPoints[i].x + dx;
               p.y = edge._dragStartPoints[i].y + dy;
             });
           }
         });
         forgeTheTopology();
         
         updateMinimap();
         document.querySelectorAll(".edge").forEach((edgeEl) => {
          const fromId = edgeEl.dataset.from;
          const toId = edgeEl.dataset.to;
          if (nodesToMove.includes(fromId) || nodesToMove.includes(toId)) {
           const p1 = savedPositions[fromId] || positions[fromId] || {
            x: 600,
            y: 350
           };
           const p2 = savedPositions[toId] || positions[toId] || {
            x: 600,
            y: 350
           };
           if (edgeEl.tagName === "line") {
            edgeEl.setAttribute("x1", p1.x);
            edgeEl.setAttribute("y1", p1.y);
            edgeEl.setAttribute("x2", p2.x);
            edgeEl.setAttribute("y2", p2.y);
           } else if (edgeEl.tagName === "path") {
            const edgeId = edgeEl.dataset.edgeId;
            const edge = EDGE_DATA.list.find(
             (e) => e.id === edgeId, );
            if (edge) {
             const pairTotal = edge._pairTotal || 1;
             const pairIndex = edge._pairIndex || 0;
             const midX = (p1.x + p2.x) / 2;
             const midY = (p1.y + p2.y) / 2;
             const dx = p2.x - p1.x;
             const dy = p2.y - p1.y;
             const len = Math.sqrt(dx * dx + dy * dy) || 1;
             const perpX = -dy / len;
             const perpY = dx / len;
             let offsetAmount = 0;
             if (pairTotal > 1) {
              offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
             }
             const ctrlX = midX + perpX * offsetAmount;
             const ctrlY = midY + perpY * offsetAmount;
             edgeEl.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
            }
           }
          }
         });
        };
      const handleMouseUp = () => {
      if (isDragging) {
      pushUndo("move nodes");
      isDragging = false;
      g.style.cursor = "grab";
      hitArea.style.cursor = "grab";
      if (currentView.mode === "rack" && NODE_DATA[id]?.assignedRack === currentView.rackId) {
      const draggedY = savedPositions[id]?.y || pos.y;
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      let newUnit = rackCapacity - Math.round((draggedY - RACK_START_Y) / rackUHeight);
      newUnit = Math.max(1, Math.min(newUnit, rackCapacity));
      NODE_DATA[id].rackUnit = newUnit;
      
      forgeTheTopology();
      claimTheImmortal(id);
      }
      }
      };
        document.addEventListener("mousemove", handleMouseMove);
        document.addEventListener("mouseup", handleMouseUp);
        let touchStartTime = 0;
        let touchStartX = 0;
        let touchStartY = 0;
        let touchMoved = false;
       g.addEventListener("touchstart",
         (e) => {
          if (NODE_DATA[id]?.locked) {
           return;
          }
          
          e.preventDefault();
          touchStartTime = Date.now();
          touchMoved = false;
          const svgEl = document.getElementById("map");
          const pt = svgEl.createSVGPoint();
          const touch = e.touches[0];
          pt.x = touch.clientX;
          pt.y = touch.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          touchStartX = svgP.x;
          touchStartY = svgP.y;
          startX = svgP.x;
          startY = svgP.y;
          
          if (selectedNodes.has(id)) {
           initialPositions = {};
           selectedNodes.forEach(nodeId => {
            const nodePos = savedPositions[nodeId];
            if (nodePos) {
             initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
            }
           });
          } else {
           initialPositions = { [id]: { x: pos.x, y: pos.y } };
          }
          
          e.stopPropagation();
         }, {
          passive: false
         }, );
        g.addEventListener("touchmove", (e) => {
         e.preventDefault();
         const svgEl = document.getElementById("map");
         const pt = svgEl.createSVGPoint();
         const touch = e.touches[0];
         pt.x = touch.clientX;
         pt.y = touch.clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
         const dx = Math.abs(svgP.x - touchStartX);
         const dy = Math.abs(svgP.y - touchStartY);
         if (dx > (isMobileDevice() ? 4 : 10) || dy > (isMobileDevice() ? 4 : 10)) {
      touchMoved = true;
      isDragging = true;
      }
         if (!isDragging) return;
         
         const deltaX = svgP.x - startX;
         const deltaY = svgP.y - startY;
         
         let nodesToMove = selectedNodes.has(id) ? Array.from(selectedNodes) : [id];
         
         const groupIds = new Set();
         nodesToMove.forEach(nodeId => {
          const groupId = NODE_DATA[nodeId]?.groupId;
          if (groupId) {
            groupIds.add(groupId);
          }
         });
         
         if (groupIds.size > 0) {
          Object.keys(NODE_DATA).forEach(nodeId => {
            const nodeGroupId = NODE_DATA[nodeId]?.groupId;
            if (nodeGroupId && groupIds.has(nodeGroupId)) {
              if (!nodesToMove.includes(nodeId)) {
                nodesToMove.push(nodeId);
                if (!initialPositions[nodeId]) {
                  const nodePos = savedPositions[nodeId];
                  if (nodePos) {
                    initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
                  }
                }
              }
            }
          });
         }
         
         nodesToMove = nodesToMove.filter(nodeId => !NODE_DATA[nodeId]?.locked);
         
         nodesToMove.forEach(nodeId => {
          if (!initialPositions[nodeId]) return;
          const initialPos = initialPositions[nodeId];
          let newX = initialPos.x + deltaX;
          let newY = initialPos.y + deltaY;
          const nodeSize = savedSizes[nodeId] || 55;
          newX = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, newX), );
          newY = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, newY), );
          
          savedPositions[nodeId] = { x: newX, y: newY };
          positions[nodeId] = { x: newX, y: newY };
          
          if (nodeId === id) {
           pos.x = newX;
           pos.y = newY;
          }
          
          const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
          if (nodeGroup) {
           nodeGroup.setAttribute("transform", `translate(${newX},${newY})`);
          }
         });
         
         updateMinimap();
         document.querySelectorAll(".edge").forEach((edgeEl) => {
          const fromId = edgeEl.dataset.from;
          const toId = edgeEl.dataset.to;
          if (nodesToMove.includes(fromId) || nodesToMove.includes(toId)) {
           const p1 = savedPositions[fromId] || positions[fromId] || {
            x: 600,
            y: 350
           };
           const p2 = savedPositions[toId] || positions[toId] || {
            x: 600,
            y: 350
           };
           if (edgeEl.tagName === "line") {
            edgeEl.setAttribute("x1", p1.x);
            edgeEl.setAttribute("y1", p1.y);
            edgeEl.setAttribute("x2", p2.x);
            edgeEl.setAttribute("y2", p2.y);
           } else if (edgeEl.tagName === "path") {
            const edgeId = edgeEl.dataset.edgeId;
            const edge = EDGE_DATA.list.find(
             (e) => e.id === edgeId, );
            if (edge) {
             const pairTotal = edge._pairTotal || 1;
             const pairIndex = edge._pairIndex || 0;
             const midX = (p1.x + p2.x) / 2;
             const midY = (p1.y + p2.y) / 2;
             const dx = p2.x - p1.x;
             const dy = p2.y - p1.y;
             const len = Math.sqrt(dx * dx + dy * dy) || 1;
             const perpX = -dy / len;
             const perpY = dx / len;
             let offsetAmount = 0;
             if (pairTotal > 1) {
              offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
             }
             const ctrlX = midX + perpX * offsetAmount;
             const ctrlY = midY + perpY * offsetAmount;
             edgeEl.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
            }
           }
          }
         });
        }, {
         passive: false
        });
      g.addEventListener("touchend", (e) => {
      const touchDuration = Date.now() - touchStartTime;
      if (!touchMoved && touchDuration < 400) {
      claimTheImmortal(id);
      }
      if (isDragging) {
      const draggedY = pos.y;
      isDragging = false;
      savedPositions[id] = {
      x: pos.x,
      y: pos.y
      };
      if (currentView.mode === "rack" && NODE_DATA[id]?.assignedRack === currentView.rackId) {
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      let newUnit = rackCapacity - Math.round((draggedY - RACK_START_Y) / rackUHeight);
      
      newUnit = Math.max(1, Math.min(newUnit, rackCapacity));
      NODE_DATA[id].rackUnit = newUnit;
      forgeTheTopology();
      claimTheImmortal(id);
      }
      }
      touchMoved = false;
      });
        g.style.cursor = "grab";
        g.addEventListener("click", (e) => {
         if (!isDragging) {
          claimTheImmortal(id);
         }
        });
        
        g.addEventListener("dblclick", (e) => {
         e.preventDefault();
         e.stopPropagation();
         if (NODE_DATA[id].isRack) {
          enterRack(id);
         }
        });
        
        if (!isNodeVisible(id)) {
         g.style.opacity = "0.1";
         g.style.pointerEvents = "none";
        }
        
        svg.appendChild(g);
       });
        if (RECT_DATA && RECT_DATA.list) {
         RECT_DATA.list.forEach((rect) => {
          if (currentView.mode === "rack") return;
          if (rect.style === "outlined") {
           const g = document.createElementNS(ns, "g");
           g.classList.add("rect-group");
           g.dataset.rectId = rect.id;
           
           const rectEl = document.createElementNS(ns, "rect");
           rectEl.classList.add("rect-shape");
           rectEl.setAttribute("x", rect.x);
           rectEl.setAttribute("y", rect.y);
           rectEl.setAttribute("width", rect.width);
           rectEl.setAttribute("height", rect.height);
           rectEl.style.fill = "none";
           rectEl.style.stroke = rect.borderColor || rect.color;
           rectEl.style.strokeWidth = (rect.borderWidth !== undefined ? rect.borderWidth : 3) + "px";
           if (rect.lineStyle === "dashed") { rectEl.style.strokeDasharray = "10,5"; }
           else if (rect.lineStyle === "dotted") { rectEl.style.strokeDasharray = "2,4"; }
           else { rectEl.style.strokeDasharray = "none"; }
           rectEl.style.cursor = "move";
           
           rectEl.addEventListener("click", (e) => {
             if (rectDrawMode) return;
             e.stopPropagation();
             currentRectId = rect.id;
             selectTheRect(rect.id);
           });
           
           rectEl.addEventListener("contextmenu", (e) => {
             e.preventDefault();
             e.stopPropagation();
             if (selectedRects.has(rect.id)) {
               selectedRects.delete(rect.id);
             } else {
               selectedRects.add(rect.id);
             }
             updateAllSelections();
           });
           
           let rectLastTap = 0;
           rectEl.addEventListener("touchend", (e) => {
             const now = Date.now();
             if (now - rectLastTap < 300) {
               e.preventDefault();
               if (selectedRects.has(rect.id)) {
                 selectedRects.delete(rect.id);
               } else {
                 selectedRects.add(rect.id);
               }
               updateAllSelections();
               if (navigator.vibrate) navigator.vibrate(50);
               rectLastTap = 0;
             } else {
               rectLastTap = now;
             }
           }, { passive: false });
           
           const deleteBtn = document.createElementNS(ns, "g");
           deleteBtn.classList.add("rect-delete-btn");
           deleteBtn.style.cursor = "pointer";
           deleteBtn.style.display = rectDrawMode ? "block" : "none";
           
           const deleteBg = document.createElementNS(ns, "circle");
           deleteBg.setAttribute("cx", rect.x + rect.width - 10);
           deleteBg.setAttribute("cy", rect.y + 10);
           deleteBg.setAttribute("r", 12);
           deleteBg.style.fill = "#f56565";
           deleteBg.style.stroke = "white";
           deleteBg.style.strokeWidth = "2";
           
           const deleteX = document.createElementNS(ns, "text");
           deleteX.setAttribute("x", rect.x + rect.width - 10);
           deleteX.setAttribute("y", rect.y + 10);
           deleteX.setAttribute("text-anchor", "middle");
           deleteX.setAttribute("dominant-baseline", "middle");
           deleteX.style.fill = "white";
           deleteX.style.fontSize = "16px";
           deleteX.style.fontWeight = "bold";
           deleteX.style.pointerEvents = "none";
           deleteX.textContent = "Ã—";
           
           deleteBtn.appendChild(deleteBg);
           deleteBtn.appendChild(deleteX);
           
           deleteBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            e.preventDefault();
            deleteRectangle(rect.id);
           });
           
           let isDragging = false;
           let dragStartX, dragStartY;
           let rectStartX, rectStartY;
           
           rectEl.addEventListener("mousedown", (e) => {
      if (rectDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      rectStartX = rect.x;
      rectStartY = rect.y;
      rectEl.style.cursor = "grabbing";
      
      if (selectedRects.has(rect.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
           
           const moveHandler = (e) => {
      if (!isDragging || rectDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      
      rect.x = rectStartX + dx;
      rect.y = rectStartY + dy;
      
      if (selectedRects.has(rect.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       const newX = initialPositions[nodeId].x + dx;
       const newY = initialPositions[nodeId].y + dy;
       savedPositions[nodeId] = { x: newX, y: newY };
      }
      });
      selectedRects.forEach(rectId => {
      if (rectId === rect.id) return;
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      
      forgeTheTopology();
      };
           
           const upHandler = () => {
            if (isDragging) {
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           };
           
           document.addEventListener("mousemove", moveHandler);
           document.addEventListener("mouseup", upHandler);
           
           let touchStartX, touchStartY;
           let touchRectStartX, touchRectStartY;
           
           rectEl.addEventListener("touchstart", (e) => {
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchRectStartX = rect.x;
            touchRectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           }, { passive: false });
           
           rectEl.addEventListener("touchmove", (e) => {
            if (!isDragging || rectDrawMode) return;
            if (!e.touches[0]) return;
            e.preventDefault();
            e.stopPropagation();
            
            const svgEl = svg;
            const pt1 = svgEl.createSVGPoint();
            pt1.x = touchStartX;
            pt1.y = touchStartY;
            const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
            
            const touch = e.touches[0];
            const pt2 = svgEl.createSVGPoint();
            pt2.x = touch.clientX;
            pt2.y = touch.clientY;
            const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
            
            const dx = svgP2.x - svgP1.x;
            const dy = svgP2.y - svgP1.y;
            
            rect.x = touchRectStartX + dx;
            rect.y = touchRectStartY + dy;
            
            forgeTheTopology();
           }, { passive: false });
           
           rectEl.addEventListener("touchend", (e) => {
            if (isDragging) {
             e.preventDefault();
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           }, { passive: false });
           
           if (rect.groupId) {
             const groupIndicator = document.createElementNS(ns, "rect");
             groupIndicator.setAttribute("x", rect.x - 4);
             groupIndicator.setAttribute("y", rect.y - 4);
             groupIndicator.setAttribute("width", rect.width + 8);
             groupIndicator.setAttribute("height", rect.height + 8);
             groupIndicator.style.fill = "none";
             groupIndicator.style.stroke = "#4fd1c5";
             groupIndicator.style.strokeWidth = "3";
             groupIndicator.style.strokeDasharray = "5,5";
             groupIndicator.style.pointerEvents = "none";
             g.insertBefore(groupIndicator, g.firstChild);
           }
           g.appendChild(rectEl);
           g.appendChild(deleteBtn);
           svg.appendChild(g);
          }
         });
        }
        
        if (TEXT_DATA && TEXT_DATA.list) {
         TEXT_DATA.list.forEach((textItem) => {
          if (currentView.mode === "rack") return;
          
          const g = document.createElementNS(ns, "g");
          g.classList.add("text-group");
          g.dataset.textId = textItem.id;
          
          if (textItem.bgEnabled) {
           const bgRect = document.createElementNS(ns, "rect");
           bgRect.classList.add("text-bg");
           
           bgRect.setAttribute("x", textItem.x - 5);
           bgRect.setAttribute("y", textItem.y - textItem.fontSize - 2);
           bgRect.setAttribute("width", 100);
           bgRect.setAttribute("height", textItem.fontSize + 10);
           bgRect.style.fill = textItem.bgColor;
           bgRect.style.opacity = "0.7";
           bgRect.style.rx = "4";
           g.appendChild(bgRect);
          }
          
          const textEl = document.createElementNS(ns, "text");
          textEl.classList.add("text-element");
          textEl.setAttribute("x", textItem.x);
          textEl.setAttribute("y", textItem.y);
          textEl.style.fill = textItem.color;
          textEl.style.fontSize = textItem.fontSize + "px";
          textEl.style.fontWeight = textItem.fontWeight;
          textEl.style.fontStyle = textItem.fontStyle;
          textEl.style.textAnchor = textItem.textAlign;
          textEl.style.textDecoration = textItem.textDecoration;
          textEl.style.opacity = textItem.opacity;
          textEl.style.cursor = "move";
          textEl.style.userSelect = "none";
          textEl.setAttribute("dominant-baseline", "middle");
          
          const lines = textItem.content.split('\n');
          if (lines.length === 1) {
           textEl.textContent = textItem.content;
          } else {
           lines.forEach((line, i) => {
            const tspan = document.createElementNS(ns, "tspan");
            tspan.textContent = line;
            tspan.setAttribute("x", textItem.x);
            tspan.setAttribute("dy", i === 0 ? 0 : textItem.fontSize * 1.2);
            textEl.appendChild(tspan);
           });
          }
          
          g.appendChild(textEl);
          
          if (textItem.bgEnabled) {
           setTimeout(() => {
            try {
             const bbox = textEl.getBBox();
             const bgRect = g.querySelector('.text-bg');
             if (bgRect && bbox) {
              bgRect.setAttribute("x", bbox.x - 5);
              bgRect.setAttribute("y", bbox.y - 2);
              bgRect.setAttribute("width", bbox.width + 10);
              bgRect.setAttribute("height", bbox.height + 4);
             }
            } catch (e) {
            }
           }, 0);
          }
          
          const deleteBtn = document.createElementNS(ns, "g");
          deleteBtn.classList.add("text-delete-btn");
          deleteBtn.style.cursor = "pointer";
          deleteBtn.style.display = textDrawMode ? "block" : "none";
          
          const deleteBg = document.createElementNS(ns, "circle");
          deleteBg.setAttribute("cx", textItem.x + 20);
          deleteBg.setAttribute("cy", textItem.y - textItem.fontSize);
          deleteBg.setAttribute("r", 12);
          deleteBg.style.fill = "#f56565";
          deleteBg.style.stroke = "white";
          deleteBg.style.strokeWidth = "2";
          
          const deleteX = document.createElementNS(ns, "text");
          deleteX.setAttribute("x", textItem.x + 20);
          deleteX.setAttribute("y", textItem.y - textItem.fontSize);
          deleteX.setAttribute("text-anchor", "middle");
          deleteX.setAttribute("dominant-baseline", "middle");
          deleteX.style.fill = "white";
          deleteX.style.fontSize = "16px";
          deleteX.style.fontWeight = "bold";
          deleteX.style.pointerEvents = "none";
          deleteX.textContent = "Ã—";
          
          deleteBtn.appendChild(deleteBg);
          deleteBtn.appendChild(deleteX);
          
          deleteBtn.addEventListener("click", (e) => {
           e.stopPropagation();
           e.preventDefault();
           deleteText(textItem.id);
          });
          
          let isDragging = false;
          let dragStartX, dragStartY;
          let textStartX, textStartY;
          
          textEl.addEventListener("mousedown", (e) => {
      if (textDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      textStartX = textItem.x;
      textStartY = textItem.y;
      textEl.style.cursor = "grabbing";
      
      showTextPanel(textItem.id);
      
      if (selectedTexts.has(textItem.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
          
          const moveHandler = (e) => {
      if (!isDragging || textDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      
      textItem.x = textStartX + dx;
      textItem.y = textStartY + dy;
      
      if (selectedTexts.has(textItem.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       const newX = initialPositions[nodeId].x + dx;
       const newY = initialPositions[nodeId].y + dy;
       savedPositions[nodeId] = { x: newX, y: newY };
      }
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      if (textId === textItem.id) return;
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      
      forgeTheTopology();
      };
          
          const upHandler = () => {
           if (isDragging) {
            isDragging = false;
            textEl.style.cursor = "move";
           }
          };
          
          document.addEventListener("mousemove", moveHandler);
          document.addEventListener("mouseup", upHandler);
          
          let touchStartX = 0, touchStartY = 0;
          let textTouchStartX = 0, textTouchStartY = 0;
          
          textEl.addEventListener("touchstart", (e) => {
           if (textDrawMode) return;
           if (e.touches.length !== 1) return;
           
           e.preventDefault();
           e.stopPropagation();
           const touch = e.touches[0];
           isDragging = true;
           touchStartX = touch.clientX;
           touchStartY = touch.clientY;
           textTouchStartX = textItem.x;
           textTouchStartY = textItem.y;
           
           showTextPanel(textItem.id);
          }, { passive: false });
          
          textEl.addEventListener("touchmove", (e) => {
           if (!isDragging || textDrawMode) return;
           if (e.touches.length !== 1) return;
           
           e.preventDefault();
           const touch = e.touches[0];
           const svgEl = svg;
           
           const pt1 = svgEl.createSVGPoint();
           pt1.x = touchStartX;
           pt1.y = touchStartY;
           const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
           
           const pt2 = svgEl.createSVGPoint();
           pt2.x = touch.clientX;
           pt2.y = touch.clientY;
           const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
           
           const dx = svgP2.x - svgP1.x;
           const dy = svgP2.y - svgP1.y;
           
           textItem.x = textTouchStartX + dx;
           textItem.y = textTouchStartY + dy;
           
           forgeTheTopology();
          }, { passive: false });
          
          textEl.addEventListener("touchend", () => {
           if (isDragging) {
            isDragging = false;
           }
          }, { passive: false });
          
          textEl.addEventListener("contextmenu", (e) => {
           e.preventDefault();
           e.stopPropagation();
           if (selectedTexts.has(textItem.id)) {
            selectedTexts.delete(textItem.id);
           } else {
            selectedTexts.add(textItem.id);
           }
           updateAllSelections();
          });
          
          let textLastTap = 0;
          g.addEventListener("touchend", (e) => {
           const now = Date.now();
           if (now - textLastTap < 300) {
            e.preventDefault();
            if (selectedTexts.has(textItem.id)) {
             selectedTexts.delete(textItem.id);
            } else {
             selectedTexts.add(textItem.id);
            }
            updateAllSelections();
            if (navigator.vibrate) navigator.vibrate(50);
            textLastTap = 0;
           } else {
            textLastTap = now;
           }
          }, { passive: false });
          
          if (textItem.groupId) {
            const groupIndicator = document.createElementNS(ns, "rect");
            groupIndicator.setAttribute("x", textItem.x - 54);
            groupIndicator.setAttribute("y", textItem.y - 24);
            groupIndicator.setAttribute("width", 108);
            groupIndicator.setAttribute("height", 48);
            groupIndicator.setAttribute("rx", "8");
            groupIndicator.style.fill = "none";
            groupIndicator.style.stroke = "#4fd1c5";
            groupIndicator.style.strokeWidth = "3";
            groupIndicator.style.strokeDasharray = "5,5";
            groupIndicator.style.pointerEvents = "none";
            g.insertBefore(groupIndicator, g.firstChild);
          }
          g.appendChild(deleteBtn);
          svg.appendChild(g);
         });
        }
        
       forgeTheLegend();
       updateMinimap();
       populateRackDropdown();
      }
      
      function showEditModal(title, currentValue, onSave) {
       const modal = document.getElementById("edit-modal");
       const input = document.getElementById("modal-input");
       const titleEl = document.getElementById("modal-title");
       const saveBtn = document.getElementById("modal-save");
       const cancelBtn = document.getElementById("modal-cancel");
       titleEl.textContent = title;
       input.value = currentValue;
       modal.classList.add("active");
       input.focus();
       input.select();
       const handleSave = () => {
        if (input.value.trim()) {
         onSave(input.value.trim());
        }
        modal.classList.remove("active");
        saveBtn.removeEventListener("click", handleSave);
        cancelBtn.removeEventListener("click", handleCancel);
        input.removeEventListener("keypress", handleEnter);
       };
       const handleCancel = () => {
        modal.classList.remove("active");
        saveBtn.removeEventListener("click", handleSave);
        cancelBtn.removeEventListener("click", handleCancel);
        input.removeEventListener("keypress", handleEnter);
       };
       const handleEnter = (e) => {
        if (e.key === "Enter") handleSave();
       };
       saveBtn.addEventListener("click", handleSave);
       cancelBtn.addEventListener("click", handleCancel);
       input.addEventListener("keypress", handleEnter);
       modal.addEventListener("click", function bgHandler(e) {
        if (e.target === modal) {
         handleCancel();
         modal.removeEventListener("click", bgHandler);
        }
       });
      }
      
      function challengeTheImmortal(message, onConfirm) {
       const modal = document.getElementById("confirm-modal");
       const messageEl = document.getElementById("confirm-message");
       const deleteBtn = document.getElementById("confirm-delete");
       const cancelBtn = document.getElementById("confirm-cancel");
       messageEl.textContent = message;
       modal.classList.add("active");
       const handleConfirm = () => {
        onConfirm();
        modal.classList.remove("active");
        deleteBtn.removeEventListener("click", handleConfirm);
        cancelBtn.removeEventListener("click", handleCancel);
       };
       const handleCancel = () => {
        modal.classList.remove("active");
        deleteBtn.removeEventListener("click", handleConfirm);
        cancelBtn.removeEventListener("click", handleCancel);
       };
       deleteBtn.addEventListener("click", handleConfirm);
       cancelBtn.addEventListener("click", handleCancel);
       modal.addEventListener("click", function bgHandler(e) {
        if (e.target === modal) {
         handleCancel();
         modal.removeEventListener("click", bgHandler);
        }
       });
      }
      const pageTitleEl = document.getElementById("page-title");
      if (pageTitleEl) {
       pageTitleEl.addEventListener("click", () => {
        showEditModal("Edit Title", PAGE_STATE.title || DEFAULT_PAGE_STATE.title,
         (newTitle) => {
          PAGE_STATE.title = newTitle;
          wieldThePower();
         }, );
       });
      }
      
      function editNodeName(id) {
       showEditModal("Edit Name", NODE_DATA[id].name, (newName) => {
        NODE_DATA[id].name = newName;
        const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`, );
        if (nodeGroup) {
         const label = nodeGroup.querySelector(".node-label");
         if (label) label.textContent = newName;
        }
        if (currentNodeId === id) {
         document.getElementById("node-name").textContent = newName;
        }
       });
      }
      
      function editNodeIp(id) {
       showEditModal("Edit IP/Subtitle", NODE_DATA[id].ip, (newIp) => {
        NODE_DATA[id].ip = newIp;
        const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`, );
        if (nodeGroup) {
         const sub = nodeGroup.querySelector(".node-sub");
         if (sub) sub.textContent = newIp;
        }
        if (currentNodeId === id) {
         document.getElementById("node-ip").textContent = newIp;
        }
       });
      }
      
      function claimTheImmortal(id) {
	   if (!NODE_DATA[id]) return;
       currentNodeId = id;
       currentEdgeId = null;
       currentRectId = null;
       currentTextId = null;
       
       if (isMobileDevice()) {
        const currentHeight = PAGE_STATE.mobileFooterHeight || 40;
        if (currentHeight <= 20) {
         PAGE_STATE.mobileFooterHeight = 80;
         const root = document.documentElement;
         root.style.setProperty("--mobile-footer-height", "80vh");
         const mobileFooterHeightInput = document.getElementById("mobile-footer-height");
         const mobileFooterHeightVal = document.getElementById("mobile-footer-height-val");
         if (mobileFooterHeightInput) mobileFooterHeightInput.value = 80;
         if (mobileFooterHeightVal) mobileFooterHeightVal.textContent = "80%";
        }
       }
       
       const data = NODE_DATA[id];
       document.querySelectorAll(".node-group").forEach((n) => {
        n.classList.toggle("active", n.dataset.nodeId === id);
       });
       document.querySelectorAll(".edge").forEach((e) => {
        const active = e.dataset.from === id || e.dataset.to === id;
        e.classList.toggle("active", active);
       });
       document.querySelectorAll(".rect-group").forEach((r) => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach((t) => t.classList.remove("active"));
       document.getElementById("node-panel").style.display = "block";
       document.getElementById("edge-panel").style.display = "none";
       document.getElementById("text-panel").style.display = "none";
       const toolbar = document.getElementById("topology-toolbar");
       if (!topologyToolbarCollapsed) {
        toolbar.style.display = "flex";
       }
       updateTopologyToolbarVisibility();
       document.getElementById("node-name").textContent = data.name;
       document.getElementById("node-ip").textContent = data.ip;
       document.getElementById("node-role").textContent = data.role;
       document.getElementById("node-mac").textContent = data.mac || "--";
       document.getElementById("node-rack").textContent = data.rackUnit || "--";
       document.getElementById("node-uheight").textContent = (data.uHeight || "1") + "U";
       document.getElementById("node-layer").value = data.layer || "physical";
       
       populateRackDropdown();
       const assignedRackSelect = document.getElementById("node-assigned-rack");
       if (assignedRackSelect) {
        assignedRackSelect.value = data.assignedRack || "";
       }
       
       const rackCapacitySelect = document.getElementById("node-rack-capacity");
       if (rackCapacitySelect) {
        rackCapacitySelect.value = data.rackCapacity || "42";
       }
       
       const isRack = data.isRack === true;
       const isAssignedToRack = !!data.assignedRack;
       const assignedRackRow = document.getElementById("assigned-rack-row");
       const rackCapacityRow = document.getElementById("rack-capacity-row");
       const uheightRow = document.getElementById("uheight-row");
       if (assignedRackRow) assignedRackRow.style.display = isRack ? "none" : "flex";
       if (rackCapacityRow) rackCapacityRow.style.display = isRack ? "flex" : "none";
       if (uheightRow) uheightRow.style.display = isAssignedToRack ? "flex" : "none";
       const rackContentsSection = document.getElementById("rack-contents-section");
       const rackContentsList = document.getElementById("rack-contents-list");
       if (rackContentsSection && rackContentsList) {
        if (isRack) {
         const nodesInRack = Object.entries(NODE_DATA).filter(([nid, n]) => n.assignedRack === id);
         if (nodesInRack.length > 0) {
          rackContentsList.innerHTML = nodesInRack.map(([nid, n]) => {
           const tags = (n.tags || []).map(t => `<span style="background: var(--accent); color: var(--bg); padding: 2px 6px; border-radius: 4px; font-size: 11px; margin-left: 4px;">${t}</span>`).join('');
           return `<div style="padding: 6px 0; border-bottom: 1px solid var(--edge-main); cursor: pointer;" onclick="claimTheImmortal('${nid}')">
            <span style="color: var(--text-main);">${n.name}</span>${tags}
           </div>`;
          }).join('');
          rackContentsSection.style.display = "block";
         } else {
          rackContentsList.innerHTML = '<div style="color: var(--text-soft); font-style: italic;">No nodes assigned</div>';
          rackContentsSection.style.display = "block";
         }
        } else {
         rackContentsSection.style.display = "none";
        }
       }
       document.getElementById("node-name").onclick = () => editNodeName(id);
       document.getElementById("node-ip").onclick = () => editNodeIp(id);
       document.getElementById("node-mac").onclick = () => editNodeMac(id);
       document.getElementById("node-rack").onclick = () => editNodeRack(id);
       document.getElementById("node-uheight").onclick = () => editNodeUHeight(id);
       const currentSize = savedSizes[id] || getDefaultSize();
       document.getElementById("size-slider").value = currentSize;
       document.getElementById("size-value").textContent = currentSize;
       const styleEntry = savedStyles[id] || {};
       const resolvedStyles = resolveStylesEntry(styleEntry);
       const scopeKey = currentStyleScope || "all";
       const flatProps = ["circleColor", "circleBorder", "titleColor", "titleFont", "titleSize", "subColor", "subFont", "subSize", ];
       const isFlat = flatProps.some((p) => Object.prototype.hasOwnProperty.call(styleEntry, p), );
       const scopedStyles = isFlat ? styleEntry : styleEntry[scopeKey] || {};
       const circleColorInput = document.getElementById("circle-color");
       const titleColorInput = document.getElementById("title-color");
       const titleFontSelect = document.getElementById("title-font");
       const titleSizeInput = document.getElementById("title-size");
       const subColorInput = document.getElementById("sub-color");
       const subFontSelect = document.getElementById("sub-font");
       const subSizeInput = document.getElementById("sub-size");
       const shapeSelect = document.getElementById("shape-select");
       const scopeSelect = document.getElementById("style-scope");
      circleColorInput.value = scopedStyles.circleColor || resolvedStyles.circleColor || PAGE_STATE.nodeFill || "#1e293b";
       const circleBorderInput = document.getElementById("circle-border");
       circleBorderInput.value = scopedStyles.circleBorder || resolvedStyles.circleBorder || PAGE_STATE.nodeStroke || "#475569";
        titleColorInput.value = scopedStyles.titleColor || resolvedStyles.titleColor || PAGE_STATE.textMain || "#e2e8f0";
        titleFontSelect.value = scopedStyles.titleFont || resolvedStyles.titleFont || "system-ui, sans-serif";
        titleSizeInput.value = scopedStyles.titleSize || resolvedStyles.titleSize || 18;
        subColorInput.value = scopedStyles.subColor || resolvedStyles.subColor || PAGE_STATE.textSoft || "#94a3b8";
       subFontSelect.value = scopedStyles.subFont || resolvedStyles.subFont || "system-ui, sans-serif";
       subSizeInput.value = scopedStyles.subSize || resolvedStyles.subSize || 13;
       shapeSelect.value = data.shape || "circle";
       scopeSelect.value = currentStyleScope || "all";
       document.getElementById("title-offset-y").value = scopedStyles.titleOffsetY || resolvedStyles.titleOffsetY || 0;
       document.getElementById("title-offset-x").value = scopedStyles.titleOffsetX || resolvedStyles.titleOffsetX || 0;
       document.getElementById("sub-offset-y").value = scopedStyles.subOffsetY || resolvedStyles.subOffsetY || 0;
       document.getElementById("sub-offset-x").value = scopedStyles.subOffsetX || resolvedStyles.subOffsetX || 0;
       const tagEl = document.getElementById("node-tags");
       tagEl.innerHTML = "";
       data.tags.forEach((tag, i) => {
        const b = document.createElement("span");
        b.className = "badge";
        if (tag.toLowerCase().includes("wg")) b.classList.add("wg");
        b.style.cursor = "pointer";
        b.style.position = "relative";
        const tagText = document.createElement("span");
        tagText.textContent = tag;
        tagText.addEventListener("click", (e) => {
         e.stopPropagation();
         showEditModal("Edit Tag", tag, (newTag) => {
          if (newTag) {
           data.tags[i] = newTag;
           claimTheImmortal(id);
          }
         });
        });
        const deleteTag = document.createElement("span");
        deleteTag.textContent = " âœ•";
        deleteTag.style.opacity = "0.6";
        deleteTag.style.marginLeft = "4px";
        deleteTag.style.fontSize = "10px";
        deleteTag.addEventListener("click", (e) => {
         e.stopPropagation();
         data.tags.splice(i, 1);
         claimTheImmortal(id);
        });
        b.append(tagText, deleteTag);
        tagEl.append(b);
       });
       const addTagBtn = document.createElement("span");
       addTagBtn.className = "badge";
       addTagBtn.style.cursor = "pointer";
       addTagBtn.style.opacity = "0.6";
       addTagBtn.style.borderStyle = "dashed";
       addTagBtn.textContent = "+ Add Tag";
       addTagBtn.addEventListener("click", () => {
        showEditModal("Add Tag(s) : comma separated", "",
         (newTagStr) => {
          if (newTagStr) {
           const newTags = newTagStr.split(",").map((t) => t.trim()).filter((t) => t);
           newTags.forEach((t) => data.tags.push(t));
           claimTheImmortal(id);
          }
         }, );
       });
       tagEl.append(addTagBtn);
       const notesEl = document.getElementById("node-notes");
       notesEl.innerHTML = "";
       data.notes.forEach((note, i) => {
        const li = document.createElement("li");
        const noteText = document.createElement("span");
        noteText.textContent = note;
        noteText.style.flex = "1";
        const deleteBtn = document.createElement("span");
        deleteBtn.className = "delete-note";
        deleteBtn.textContent = "âœ•";
        deleteBtn.addEventListener("click", (e) => {
         e.stopPropagation();
         challengeTheImmortal("Are you sure you want to delete this note?",
          () => {
           data.notes.splice(i, 1);
           claimTheImmortal(id);
          }, );
        });
        li.append(noteText, deleteBtn);
        noteText.addEventListener("dblclick", () => {
         noteText.classList.add("editing");
         noteText.contentEditable = true;
         noteText.focus();
        });
        noteText.addEventListener("blur", () => {
         noteText.classList.remove("editing");
         noteText.contentEditable = false;
         data.notes[i] = noteText.textContent;
        });
        notesEl.append(li);
       });
      const addLineSelect = document.getElementById("add-line-select");
      addLineSelect.innerHTML = "";
      const currentRack = data.assignedRack || "";
      Object.entries(NODE_DATA).forEach(([nodeId, node]) => {
      if (nodeId !== id) {
      const nodeRack = node.assignedRack || "";
      if (currentRack === nodeRack) {
      const opt = document.createElement("option");
      opt.value = nodeId;
      opt.textContent = node.name;
      addLineSelect.appendChild(opt);
      }
      }
      });
      }
      
      function selectTheConnection(id) {
       currentEdgeId = id;
       currentNodeId = null;
       currentRectId = null;
       currentTextId = null;
       
       if (isMobileDevice()) {
        const currentHeight = PAGE_STATE.mobileFooterHeight || 40;
        if (currentHeight <= 20) {
         PAGE_STATE.mobileFooterHeight = 80;
         const root = document.documentElement;
         root.style.setProperty("--mobile-footer-height", "80vh");
         const mobileFooterHeightInput = document.getElementById("mobile-footer-height");
         const mobileFooterHeightVal = document.getElementById("mobile-footer-height-val");
         if (mobileFooterHeightInput) mobileFooterHeightInput.value = 80;
         if (mobileFooterHeightVal) mobileFooterHeightVal.textContent = "80%";
        }
       }
       
       document.getElementById("node-panel").style.display = "none";
       document.getElementById("edge-panel").style.display = "block";
       document.getElementById("text-panel").style.display = "none";
       document.getElementById("rect-panel").style.display = "none";
       document.getElementById("topology-toolbar").style.display = "none";
       document.querySelectorAll(".node-group").forEach((n) => n.classList.remove("active"));
       document.querySelectorAll(".rect-group").forEach((r) => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach((t) => t.classList.remove("active"));
       document.querySelectorAll(".edge").forEach((e) => {
        e.classList.toggle("active", e.dataset.edgeId === id);
       });
       const edge = EDGE_DATA.list.find((e) => e.id === id);
       if (!edge) return;
       const directionSymbols = {
        none: "â‡„",
        forward: "â†’",
        backward: "â†",
        both: "â†”",
       };
       const dirSymbol = directionSymbols[edge.direction] || "â‡„";
       let titleText = "Custom line";
       if (edge.from || edge.to) {
        const fromName = edge.from ? NODE_DATA[edge.from]?.name || edge.from : "";
        const toName = edge.to ? NODE_DATA[edge.to]?.name || edge.to : "";
        titleText = `${fromName || "?"} ${dirSymbol} ${toName || "?"}`;
       }
       document.getElementById("edge-title").textContent = titleText;
       const widthInput = document.getElementById("edge-width");
       const colorInput = document.getElementById("edge-color");
       const directionSelect = document.getElementById("edge-direction");
       const lineStyleSelect = document.getElementById("edge-line-style");
       widthInput.value = edge.width;
       colorInput.value = edge.color;
       directionSelect.value = edge.direction || "none";
       lineStyleSelect.value = edge.lineStyle || "solid";
       
       const fromPortRow = document.getElementById("edge-from-port-row");
       const toPortRow = document.getElementById("edge-to-port-row");
       const fromPortInput = document.getElementById("edge-from-port");
       const toPortInput = document.getElementById("edge-to-port");
       
       if (edge.type === "custom") {
        fromPortRow.style.display = "none";
        toPortRow.style.display = "none";
       } else {
        fromPortRow.style.display = "flex";
        toPortRow.style.display = "flex";
        fromPortInput.value = edge.fromPort || "";
        toPortInput.value = edge.toPort || "";
        
        fromPortInput.onchange = () => updateEdgePortLabels(id);
        toPortInput.onchange = () => updateEdgePortLabels(id);
       }
       
       const list = document.getElementById("edge-notes");
       list.innerHTML = "";
       edge.notes.forEach((note, i) => {
        const li = document.createElement("li");
        const txt = document.createElement("span");
        txt.textContent = note;
        txt.style.flex = "1";
        const del = document.createElement("span");
        del.className = "delete-note";
        del.textContent = "âœ•";
        del.addEventListener("click", (e) => {
         e.stopPropagation();
         challengeTheImmortal("Delete this line note?", () => {
          edge.notes.splice(i, 1);
          saveEdgeData();
          selectTheConnection(id);
         });
        });
        txt.addEventListener("dblclick", () => {
         txt.classList.add("editing");
         txt.contentEditable = true;
         txt.focus();
        });
        txt.addEventListener("blur", () => {
         txt.classList.remove("editing");
         txt.contentEditable = false;
         edge.notes[i] = txt.textContent;
         saveEdgeData();
        });
        li.append(txt, del);
        list.appendChild(li);
       });
       
       if (edge.type === "custom" && Array.isArray(edge.points)) {
        forgeTheTopology();
       }
      }
      window.addEventListener("resize", () => {
       forgeTheTopology();
       if (currentEdgeId) {
        selectTheConnection(currentEdgeId);
       } else if (currentNodeId && NODE_DATA[currentNodeId]) {
        claimTheImmortal(currentNodeId);
       } else {
        const availableNodes = Object.keys(NODE_DATA);
        if (availableNodes.length > 0) {
         claimTheImmortal(availableNodes[0]);
        }
       }
      });
      (function initZoomPan() {
       const viewport = document.getElementById("canvas-viewport");
       const svg = document.getElementById("map");
       const hint = document.getElementById("canvas-hint");
       setTimeout(() => {
        hint.classList.add("visible");
        setTimeout(() => hint.classList.remove("visible"), 4000);
       }, 1000);
       viewport.addEventListener("wheel",
        (e) => {
         e.preventDefault();
         const rect = viewport.getBoundingClientRect();
         const mouseX = (e.clientX - rect.left) / rect.width;
         const mouseY = (e.clientY - rect.top) / rect.height;
         const delta = e.deltaY > 0 ? 0.9 : 1.1;
         zoomTo(canvasState.zoom * delta, mouseX, mouseY);
        }, {
         passive: false
        }, );
       let initialPinchDistance = 0;
       let initialPinchZoom = 1;
       let pinchCenter = {
        x: 0.5,
        y: 0.5
       };
       viewport.addEventListener("touchstart",
        (e) => {
         if (e.touches.length === 2) {
          e.preventDefault();
          const touch1 = e.touches[0];
          const touch2 = e.touches[1];
          initialPinchDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY, );
          initialPinchZoom = canvasState.zoom;
          const rect = viewport.getBoundingClientRect();
          const centerX = (touch1.clientX + touch2.clientX) / 2;
          const centerY = (touch1.clientY + touch2.clientY) / 2;
          pinchCenter.x = (centerX - rect.left) / rect.width;
          pinchCenter.y = (centerY - rect.top) / rect.height;
         }
        }, {
         passive: false
        }, );
       viewport.addEventListener("touchmove",
        (e) => {
         if (e.touches.length === 2) {
          e.preventDefault();
          const touch1 = e.touches[0];
          const touch2 = e.touches[1];
          const currentDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY, );
          if (initialPinchDistance > 0) {
           const scale = currentDistance / initialPinchDistance;
           const newZoom = initialPinchZoom * scale;
           zoomTo(newZoom, pinchCenter.x, pinchCenter.y);
          }
         }
        }, {
         passive: false
        }, );
       let panStartViewX = 0;
       let panStartViewY = 0;
       
       let lastEmptyTapTime = 0;
       let emptyTapTimeout = null;
       let emptyTapMoved = false;
       let emptyTapStartX = 0;
       let emptyTapStartY = 0;
       
       viewport.addEventListener("touchend", (e) => {
         if (currentView.mode !== "rack") return;
         
         if (e.changedTouches.length !== 1) return;
         
      const isNodeOrEdge = e.target.closest(".node-group") || e.target.closest(".edge-group");
         if (isNodeOrEdge) return;
         
         if (emptyTapMoved) {
           emptyTapMoved = false;
           return;
         }
         
         const currentTime = new Date().getTime();
         const tapGap = currentTime - lastEmptyTapTime;
         
         if (tapGap < 300 && tapGap > 0) {
           e.preventDefault();
           
           exitRack();
           
           if (navigator.vibrate) {
             navigator.vibrate(50);
           }
           
           lastEmptyTapTime = 0;
           if (emptyTapTimeout) {
             clearTimeout(emptyTapTimeout);
             emptyTapTimeout = null;
           }
         } else {
           lastEmptyTapTime = currentTime;
           
           if (emptyTapTimeout) clearTimeout(emptyTapTimeout);
           emptyTapTimeout = setTimeout(() => {
             lastEmptyTapTime = 0;
           }, 300);
         }
       }, { passive: false });
       
       viewport.addEventListener("mousedown", (e) => {
        if (e.target.closest(".draw-toolbar") || e.target.closest(".topology-toolbar") || e.target.closest(".legend-container")) {
         return;
        }
      
        if (freeDrawMode || rectDrawMode) {
         return;
        }
      const isEmptySpace = e.target === svg || e.target === viewport || e.target.tagName === "svg";
      const isEdgeElement = e.target.closest('.edge') || e.target.classList.contains('edge-edit-point');
      const isTextElement = e.target.closest('.text-group') || e.target.closest('.text-element');
      const isRectElement = e.target.closest('.rect-group');
      if (!isEdgeElement && !isTextElement && !isRectElement && currentEdgeId) {
      currentEdgeId = null;
      forgeTheTopology();
      }
      if (!isRectElement && currentRectId) {
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      }
        if (isEmptySpace || e.button === 2 || e.button === 1) {
         e.preventDefault();
         canvasState.isPanning = true;
         canvasState.panStartX = e.clientX;
         canvasState.panStartY = e.clientY;
         panStartViewX = canvasState.panX;
         panStartViewY = canvasState.panY;
         viewport.classList.add("panning");
        }
       });
       viewport.addEventListener("touchstart",
        (e) => {
         if (e.target.closest(".draw-toolbar") || e.target.closest(".topology-toolbar") || e.target.closest(".legend-container")) {
          return;
         }
      
         if (freeDrawMode || rectDrawMode) {
          return;
         }
      const isEmptySpace = e.target === svg || e.target === viewport || e.target.tagName === "svg";
      const isEdgeElement = e.target.closest('.edge') || e.target.classList.contains('edge-edit-point');
      const isTextElement = e.target.closest('.text-group') || e.target.closest('.text-element');
      const isRectElement = e.target.closest('.rect-group');
      if (!isEdgeElement && !isTextElement && !isRectElement && currentEdgeId) {
      currentEdgeId = null;
      forgeTheTopology();
      }
      if (!isRectElement && currentRectId) {
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      }
          if (isEmptySpace && e.touches.length === 1) {
           e.preventDefault();
           emptyTapMoved = false;
           emptyTapStartX = e.touches[0].clientX;
           emptyTapStartY = e.touches[0].clientY;
           canvasState.isPanning = true;
           canvasState.panStartX = e.touches[0].clientX;
           canvasState.panStartY = e.touches[0].clientY;
           panStartViewX = canvasState.panX;
           panStartViewY = canvasState.panY;
           viewport.classList.add("panning");
         }
        }, {
         passive: false
        }, );
       document.addEventListener("mousemove", (e) => {
        if (!canvasState.isPanning) return;
        const dx = e.clientX - canvasState.panStartX;
        const dy = e.clientY - canvasState.panStartY;
        const rect = viewport.getBoundingClientRect();
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        const canvasDx = (dx / rect.width) * viewWidth;
        const canvasDy = (dy / rect.height) * viewHeight;
        canvasState.panX = panStartViewX - canvasDx;
        canvasState.panY = panStartViewY - canvasDy;
        constrainPan();
        updateViewBox();
       });
       document.addEventListener("touchmove", (e) => {
        if (!canvasState.isPanning || !e.touches[0]) return;
        const moveDx = Math.abs(e.touches[0].clientX - emptyTapStartX);
        const moveDy = Math.abs(e.touches[0].clientY - emptyTapStartY);
        if (moveDx > 15 || moveDy > 15) {
         emptyTapMoved = true;
        }
        const dx = e.touches[0].clientX - canvasState.panStartX;
        const dy = e.touches[0].clientY - canvasState.panStartY;
        const rect = viewport.getBoundingClientRect();
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        const canvasDx = (dx / rect.width) * viewWidth;
        const canvasDy = (dy / rect.height) * viewHeight;
        canvasState.panX = panStartViewX - canvasDx;
        canvasState.panY = panStartViewY - canvasDy;
        constrainPan();
        updateViewBox();
       });
       document.addEventListener("mouseup", () => {
        if (canvasState.isPanning) {
         canvasState.isPanning = false;
         viewport.classList.remove("panning");
        }
       });
       document.addEventListener("touchend", () => {
        if (canvasState.isPanning) {
         canvasState.isPanning = false;
         viewport.classList.remove("panning");
        }
       });
       document.addEventListener("keydown", (e) => {
        const isEditing = document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "TEXTAREA" || document.activeElement.isContentEditable;
        if (e.code === "Space" && !e.repeat && !isEditing) {
         e.preventDefault();
         canvasState.spacePressed = true;
         viewport.style.cursor = "grab";
        }
       });
       document.addEventListener("keyup", (e) => {
        if (e.code === "Space") {
         canvasState.spacePressed = false;
         viewport.style.cursor = "";
        }
       });
       document.getElementById("zoom-in-btn").addEventListener("click", () => {
        zoomTo(canvasState.zoom * 1.25, 0.5, 0.5);
       });
       document.getElementById("zoom-out-btn").addEventListener("click", () => {
        zoomTo(canvasState.zoom * 0.8, 0.5, 0.5);
       });
       document.getElementById("zoom-fit-btn").addEventListener("click", fitToContent);
       document.getElementById("zoom-reset-btn").addEventListener("click", resetView);
       const minimapContainer = document.getElementById("minimap-container");
       const minimapSvg = document.getElementById("minimap");
       let minimapDragging = false;
       minimapContainer.addEventListener("mousedown", (e) => {
        e.preventDefault();
        minimapDragging = true;
        updatePanFromMinimap(e);
       });
       minimapContainer.addEventListener("touchstart",
        (e) => {
         e.preventDefault();
         minimapDragging = true;
         updatePanFromMinimapTouch(e);
        }, {
         passive: false
        }, );
       document.addEventListener("mousemove", (e) => {
        if (minimapDragging) {
         updatePanFromMinimap(e);
        }
       });
       document.addEventListener("touchmove", (e) => {
        if (minimapDragging && e.touches[0]) {
         updatePanFromMinimapTouch(e);
        }
       });
       document.addEventListener("mouseup", () => {
        minimapDragging = false;
       });
       document.addEventListener("touchend", () => {
        minimapDragging = false;
       });
      
       function updatePanFromMinimap(e) {
        const rect = minimapContainer.getBoundingClientRect();
        const x = (e.clientX - rect.left) / rect.width;
        const y = (e.clientY - rect.top) / rect.height;
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        canvasState.panX = x * CANVAS_WIDTH - viewWidth / 2;
        canvasState.panY = y * CANVAS_HEIGHT - viewHeight / 2;
        constrainPan();
        updateViewBox();
       }
      
       function updatePanFromMinimapTouch(e) {
        const rect = minimapContainer.getBoundingClientRect();
        const touch = e.touches[0];
        const x = (touch.clientX - rect.left) / rect.width;
        const y = (touch.clientY - rect.top) / rect.height;
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        canvasState.panX = x * CANVAS_WIDTH - viewWidth / 2;
        canvasState.panY = y * CANVAS_HEIGHT - viewHeight / 2;
        constrainPan();
        updateViewBox();
       }
       document.addEventListener("keydown", (e) => {
        if (document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "TEXTAREA") return;
        if (
         (e.key === "+" || e.key === "=") && (e.ctrlKey || e.metaKey)) {
         e.preventDefault();
         zoomTo(canvasState.zoom * 1.25, 0.5, 0.5);
        } else if (e.key === "-" && (e.ctrlKey || e.metaKey)) {
         e.preventDefault();
         zoomTo(canvasState.zoom * 0.8, 0.5, 0.5);
        } else if (e.key === "0" && (e.ctrlKey || e.metaKey)) {
         e.preventDefault();
         resetView();
        }
       });
       setTimeout(() => {
        fitToContent();
       }, 100);
      })();
      const sizeSlider = document.getElementById("size-slider");
      const sizeValue = document.getElementById("size-value");
      const resetSizeBtn = document.getElementById("reset-size");
      sizeSlider.addEventListener("input", () => {
       const newSize = parseInt(sizeSlider.value, 10);
       sizeValue.textContent = newSize;
       savedSizes[currentNodeId] = newSize;
       const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
       if (nodeGroup) {
        const oldShape = nodeGroup.querySelector(".node-circle");
        if (oldShape) oldShape.remove();
        const shapeType = (NODE_DATA[currentNodeId] && NODE_DATA[currentNodeId].shape) || "circle";
        const newShape = createShapeElement(shapeType, newSize);
        newShape.classList.add("node-circle");
        const styles = resolveStylesForNode(currentNodeId);
        if (styles.circleColor) newShape.style.fill = styles.circleColor;
        if (styles.circleBorder) newShape.style.stroke = styles.circleBorder;
        nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
        const label = nodeGroup.querySelector(".node-label");
        const sub = nodeGroup.querySelector(".node-sub");
        if (label) {
         label.setAttribute("y", -newSize * 0.28);
         const labelSize = styles.titleSize || newSize * 0.33;
         label.style.fontSize = labelSize + "px";
        }
        if (sub) {
         sub.setAttribute("y", newSize * 0.4);
         const subSize = styles.subSize || newSize * 0.24;
         sub.style.fontSize = subSize + "px";
        }
       }
      });
      resetSizeBtn.addEventListener("click", () => {
       delete savedSizes[currentNodeId];
       const defaultSize = getDefaultSize();
       sizeSlider.value = defaultSize;
       sizeValue.textContent = defaultSize;
       const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
       if (nodeGroup) {
        const oldShape = nodeGroup.querySelector(".node-circle");
        if (oldShape) oldShape.remove();
        const shapeType = (NODE_DATA[currentNodeId] && NODE_DATA[currentNodeId].shape) || "circle";
        const newShape = createNodeShape(currentNodeId, defaultSize);
        nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
        const styles = resolveStylesForNode(currentNodeId);
        if (styles.circleColor) newShape.style.fill = styles.circleColor;
        if (styles.circleBorder) newShape.style.stroke = styles.circleBorder;
        const label = nodeGroup.querySelector(".node-label");
        const sub = nodeGroup.querySelector(".node-sub");
        if (label) {
         label.setAttribute("y", -defaultSize * 0.28);
         const labelSize = styles.titleSize || defaultSize * 0.33;
         label.style.fontSize = labelSize + "px";
        }
        if (sub) {
         sub.setAttribute("y", defaultSize * 0.4);
         const subSize = styles.subSize || defaultSize * 0.24;
         sub.style.fontSize = subSize + "px";
        }
       }
      });
      const applyStyle = (property, value) => {
       const styleEntry = ensureStyleEntry(currentNodeId);
       const scopeKey = currentStyleScope || "all";
       if (!styleEntry[scopeKey]) styleEntry[scopeKey] = {};
       styleEntry[scopeKey][property] = value;
       const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
       if (!nodeGroup) return;
       const shapeEl = nodeGroup.querySelector(".node-circle");
       const label = nodeGroup.querySelector(".node-label");
       const sub = nodeGroup.querySelector(".node-sub");
       if (property === "circleColor" && shapeEl) shapeEl.style.fill = value;
      else if (property === "circleBorder" && shapeEl) shapeEl.style.stroke = value;
       else if (property === "titleColor" && label) label.style.fill = value;
       else if (property === "titleFont" && label) label.style.fontFamily = value;
       else if (property === "titleSize" && label) label.style.fontSize = value + "px";
       else if (property === "subColor" && sub) sub.style.fill = value;
       else if (property === "subFont" && sub) sub.style.fontFamily = value;
       else if (property === "subSize" && sub) sub.style.fontSize = value + "px";
      };
      document.getElementById("circle-color").addEventListener("input", (e) => applyStyle("circleColor", e.target.value), );
      document.getElementById("circle-border").addEventListener("input", (e) => applyStyle("circleBorder", e.target.value), );
      document.getElementById("title-color").addEventListener("input", (e) => applyStyle("titleColor", e.target.value), );
      document.getElementById("title-font").addEventListener("change", (e) => applyStyle("titleFont", e.target.value), );
      document.getElementById("title-size").addEventListener("input", (e) => applyStyle("titleSize", parseInt(e.target.value, 10)), );
      document.getElementById("sub-color").addEventListener("input", (e) => applyStyle("subColor", e.target.value), );
      document.getElementById("sub-font").addEventListener("change", (e) => applyStyle("subFont", e.target.value), );
      document.getElementById("sub-size").addEventListener("input", (e) => applyStyle("subSize", parseInt(e.target.value, 10)), );
      document.getElementById("title-offset-y").addEventListener("input", (e) => {
       applyStyle("titleOffsetY", parseInt(e.target.value, 10) || 0);
       forgeTheTopology();
       if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      document.getElementById("title-offset-x").addEventListener("input", (e) => {
       applyStyle("titleOffsetX", parseInt(e.target.value, 10) || 0);
       forgeTheTopology();
       if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      document.getElementById("sub-offset-y").addEventListener("input", (e) => {
       applyStyle("subOffsetY", parseInt(e.target.value, 10) || 0);
       forgeTheTopology();
       if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      document.getElementById("sub-offset-x").addEventListener("input", (e) => {
       applyStyle("subOffsetX", parseInt(e.target.value, 10) || 0);
       forgeTheTopology();
       if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      document.getElementById("reset-styles").addEventListener("click", () => {
       delete savedStyles[currentNodeId];
       forgeTheTopology();
       claimTheImmortal(currentNodeId);
      });
      document.getElementById("style-scope").addEventListener("change", (e) => {
       currentStyleScope = e.target.value || "all";
       claimTheImmortal(currentNodeId);
      });
      document.getElementById("shape-select").addEventListener("change", (e) => {
       const shape = e.target.value || "circle";
       NODE_DATA[currentNodeId].shape = shape;
       const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
       if (!nodeGroup) return;
       const oldShape = nodeGroup.querySelector(".node-circle");
       if (oldShape) oldShape.remove();
       const size = savedSizes[currentNodeId] || getDefaultSize();
       const newShape = createNodeShape(currentNodeId, size);
       nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
      });
      const addNoteBtn = document.getElementById("add-note-btn");
      const noteInput = document.getElementById("new-note-input");
      addNoteBtn.addEventListener("click", () => {
       const newNote = noteInput.value.trim();
       if (newNote && currentNodeId) {
        NODE_DATA[currentNodeId].notes.push(newNote);
        claimTheImmortal(currentNodeId);
        noteInput.value = "";
       }
      });
      noteInput.addEventListener("keypress", (e) => {
       if (e.key === "Enter") {
        addNoteBtn.click();
       }
      });
      document.getElementById("edge-width").addEventListener("input", () => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       const v = parseInt(document.getElementById("edge-width").value, 10);
       if (Number.isNaN(v) || v <= 0) return;
       edge.width = v;
       saveEdgeData();
       const el = document.querySelector(`.edge[data-edge-id="${currentEdgeId}"]`, );
       if (el) el.style.strokeWidth = v;
      });
      document.getElementById("edge-color").addEventListener("input", () => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       const color = document.getElementById("edge-color").value;
       edge.color = color;
       saveEdgeData();
       const el = document.querySelector(`.edge[data-edge-id="${currentEdgeId}"]`, );
       if (el) el.style.stroke = color;
       forgeTheLegend();
      });
      document.getElementById("edge-direction").addEventListener("change", () => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       edge.direction = document.getElementById("edge-direction").value;
       saveEdgeData();
       forgeTheTopology();
       selectTheConnection(currentEdgeId);
      });
      document.getElementById("edge-line-style").addEventListener("change", () => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       edge.lineStyle = document.getElementById("edge-line-style").value;
       saveEdgeData();
       forgeTheTopology();
       selectTheConnection(currentEdgeId);
      });
      const addEdgeNoteBtn = document.getElementById("add-edge-note");
      const newEdgeNoteInput = document.getElementById("new-edge-note");
      addEdgeNoteBtn.addEventListener("click", () => {
       const txt = newEdgeNoteInput.value.trim();
       if (!txt || !currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       edge.notes.push(txt);
       saveEdgeData();
       newEdgeNoteInput.value = "";
       selectTheConnection(currentEdgeId);
      });
      newEdgeNoteInput.addEventListener("keypress", (e) => {
       if (e.key === "Enter") {
        addEdgeNoteBtn.click();
       }
      });
	  
      function selectTheRect(id) {
      currentRectId = id;
      currentNodeId = null;
      currentEdgeId = null;
      currentTextId = null;
      document.getElementById("node-panel").style.display = "none";
      document.getElementById("edge-panel").style.display = "none";
      document.getElementById("text-panel").style.display = "none";
      document.getElementById("rect-panel").style.display = "block";
      document.getElementById("topology-toolbar").style.display = "none";
      document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active"));
      document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
      document.querySelectorAll(".text-element").forEach(t => t.classList.remove("active"));
      document.querySelectorAll(".rect-group").forEach(r => r.classList.toggle("active", r.dataset.rectId === id));
      
      const rect = RECT_DATA.list.find(r => r.id === id);
      if (!rect) return;
      
      document.getElementById("rect-title").textContent = "";
      document.getElementById("rect-color").value = rect.color || "#f97316";
      document.getElementById("rect-border-color").value = rect.borderColor || rect.color || "#f97316";
      document.getElementById("rect-border-width").value = rect.borderWidth !== undefined ? rect.borderWidth : 2;
      document.getElementById("rect-style-select").value = rect.style || "filled";
      document.getElementById("rect-fill-row").style.display = (rect.style === "outlined") ? "none" : "flex";
      
      const list = document.getElementById("rect-notes");
      list.innerHTML = "";
      (rect.notes || []).forEach((note, i) => {
      const li = document.createElement("li");
      const txt = document.createElement("span");
      txt.textContent = note;
      txt.style.flex = "1";
      const del = document.createElement("span");
      del.className = "delete-note";
      del.textContent = "âœ•";
      del.addEventListener("click", (e) => {
      e.stopPropagation();
      challengeTheImmortal("Delete this note?", () => {
        rect.notes.splice(i, 1);
        selectTheRect(id);
      });
      });
      li.appendChild(txt);
      li.appendChild(del);
      list.appendChild(li);
      });
      
      forgeTheTopology();
      }
      
      document.getElementById("rect-color").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      rect.color = document.getElementById("rect-color").value;
      forgeTheTopology();
      });
      
      document.getElementById("rect-border-color").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      rect.borderColor = document.getElementById("rect-border-color").value;
      forgeTheTopology();
      });
      
      document.getElementById("rect-border-width").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      rect.borderWidth = parseInt(document.getElementById("rect-border-width").value) || 2;
      forgeTheTopology();
      });
      
      document.getElementById("rect-style-select").addEventListener("change", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      rect.style = document.getElementById("rect-style-select").value;
      forgeTheTopology();
      selectTheRect(currentRectId);
      });
      
      document.getElementById("add-rect-note").addEventListener("click", () => {
      const input = document.getElementById("new-rect-note");
      const txt = input.value.trim();
      if (!txt || !currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      if (!rect.notes) rect.notes = [];
      rect.notes.push(txt);
      input.value = "";
      selectTheRect(currentRectId);
      });
      
      document.getElementById("new-rect-note").addEventListener("keypress", (e) => {
      if (e.key === "Enter") {
      document.getElementById("add-rect-note").click();
      }
      });
      
      document.getElementById("delete-rect").addEventListener("click", () => {
      if (!currentRectId) return;
      challengeTheImmortal("Delete this zone?", () => {
      RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== currentRectId);
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      });
      });
      document.getElementById("delete-edge").addEventListener("click", () => {
       if (!currentEdgeId) return;
       challengeTheImmortal("Are you sure you want to delete this line?",
        () => {
         EDGE_DATA.list = EDGE_DATA.list.filter(
          (e) => e.id !== currentEdgeId, );
         saveEdgeData();
         currentEdgeId = null;
         forgeTheTopology();
         const availableNodes = Object.keys(NODE_DATA);
         if (availableNodes.length > 0) {
          claimTheImmortal(availableNodes[0]);
         } else {
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("topology-toolbar", ).style.display = "none";
         }
        }, );
      });
      document.getElementById("add-line-btn").addEventListener("click", () => {
       if (!currentNodeId) return;
       const select = document.getElementById("add-line-select");
       const directionSelect = document.getElementById("add-line-direction");
       const colorInput = document.getElementById("add-line-color");
       const targetId = select.value;
       if (!targetId || targetId === currentNodeId) return;
       const direction = directionSelect.value || "none";
       const lineColor = colorInput.value || "#475569";
       const newId = `${currentNodeId}-${targetId}-${Date.now()}`;
       const newEdge = {
        id: newId,
        from: currentNodeId,
        to: targetId,
        width: 4,
        color: lineColor,
        direction: direction,
        type: "main",
        notes: [],
        fromPort: "",
        toPort: "",
        lineStyle: "solid",
       };
       EDGE_DATA.list.push(newEdge);
       saveEdgeData();
       forgeTheTopology();
       claimTheImmortal(currentNodeId);
      });
      let freeDrawPoints = [];
      let freeDrawPolylineEl = null;
      let freeDrawPointEls = [];
    
       let rectStartPoint = null;
       let rectPreviewEl = null;
       let rectStyle = "filled";
      const drawToggleBtn = document.getElementById("draw-toggle");
      const drawUndoBtn = document.getElementById("draw-undo");
      const drawColorInput = document.getElementById("draw-color");
      const drawStyleSelect = document.getElementById("draw-style");
      const drawArrowSelect = document.getElementById("draw-arrow");
      const svgMap = document.getElementById("map");
      
      function updateFreeDrawGraphics() {
       const ns = "http://www.w3.org/2000/svg";
       const svg = svgMap;
       if (!freeDrawPolylineEl && freeDrawPoints.length > 0) {
        freeDrawPolylineEl = document.createElementNS(ns, "polyline");
        freeDrawPolylineEl.classList.add("edge", "free-preview");
        freeDrawPolylineEl.setAttribute("fill", "none");
        svg.appendChild(freeDrawPolylineEl);
       }
       if (freeDrawPolylineEl) {
        if (freeDrawPoints.length === 0) {
         freeDrawPolylineEl.remove();
         freeDrawPolylineEl = null;
        } else {
         const ptsStr = freeDrawPoints.map((p) => `${p.x},${p.y}`).join(" ");
         freeDrawPolylineEl.setAttribute("points", ptsStr);
         freeDrawPolylineEl.style.stroke = drawColorInput.value || "#475569";
         freeDrawPolylineEl.style.strokeWidth = 3;
         const lineStyle = drawStyleSelect.value || "solid";
         if (lineStyle === "dashed") {
          freeDrawPolylineEl.style.strokeDasharray = "10,5";
         } else if (lineStyle === "dotted") {
          freeDrawPolylineEl.style.strokeDasharray = "2,4";
         } else {
          freeDrawPolylineEl.style.strokeDasharray = "none";
         }
        }
       }
       freeDrawPointEls.forEach((el) => el.remove());
       freeDrawPointEls = [];
       freeDrawPoints.forEach((p, idx) => {
        const c = document.createElementNS(ns, "circle");
        c.classList.add("free-point");
        c.setAttribute("cx", p.x);
        c.setAttribute("cy", p.y);
        c.setAttribute("r", 5);
        c.dataset.index = String(idx);
        c.addEventListener("mousedown", (e) => {
         if (!freeDrawMode) return;
         e.preventDefault();
         e.stopPropagation();
         let dragging = true;
         const svgEl = svgMap;
         const moveHandler = (ev) => {
          if (!dragging) return;
          const pt = svgEl.createSVGPoint();
          pt.x = ev.clientX;
          pt.y = ev.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          const i = parseInt(c.dataset.index, 10);
          if (Number.isNaN(i) || !freeDrawPoints[i]) return;
          freeDrawPoints[i].x = svgP.x;
          freeDrawPoints[i].y = svgP.y;
          updateFreeDrawGraphics();
         };
         const upHandler = () => {
          dragging = false;
          document.removeEventListener("mousemove", moveHandler);
          document.removeEventListener("mouseup", upHandler);
         };
         document.addEventListener("mousemove", moveHandler);
         document.addEventListener("mouseup", upHandler);
        });
        c.addEventListener("touchstart",
         (e) => {
          if (!freeDrawMode) return;
          e.preventDefault();
          e.stopPropagation();
          let dragging = true;
          const svgEl = svgMap;
          const touchMoveHandler = (ev) => {
           if (!dragging || !ev.touches[0]) return;
           const pt = svgEl.createSVGPoint();
           pt.x = ev.touches[0].clientX;
           pt.y = ev.touches[0].clientY;
           const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
           const i = parseInt(c.dataset.index, 10);
           if (Number.isNaN(i) || !freeDrawPoints[i]) return;
           freeDrawPoints[i].x = svgP.x;
           freeDrawPoints[i].y = svgP.y;
           updateFreeDrawGraphics();
          };
          const touchUpHandler = () => {
           dragging = false;
           document.removeEventListener("touchmove", touchMoveHandler, );
           document.removeEventListener("touchend", touchUpHandler, );
          };
          document.addEventListener("touchmove", touchMoveHandler);
          document.addEventListener("touchend", touchUpHandler);
         }, {
          passive: false
         }, );
        svg.appendChild(c);
        freeDrawPointEls.push(c);
       });
       drawUndoBtn.style.display = freeDrawPoints.length ? "inline-block" : "none";
      }
      
      function addFreeDrawPoint(x, y) {
       freeDrawPoints.push({
        x,
        y
       });
       updateFreeDrawGraphics();
      }
      
      function startFreeDraw() {
       freeDrawMode = true;
       freeDrawPoints = [];
       if (freeDrawPolylineEl) {
        freeDrawPolylineEl.remove();
        freeDrawPolylineEl = null;
       }
       freeDrawPointEls.forEach((el) => el.remove());
       freeDrawPointEls = [];
       svgMap.style.cursor = "crosshair";
       drawToggleBtn.textContent = "Done";
       drawUndoBtn.style.display = "none";
      }
      
      function finishFreeDraw() {
       freeDrawMode = false;
       svgMap.style.cursor = "";
       drawToggleBtn.textContent = "âœï¸";
       if (freeDrawPoints.length >= 2) {
        const color = drawColorInput.value || "#475569";
        const lineStyle = drawStyleSelect.value || "solid";
        const arrowDir = drawArrowSelect.value || "none";
        const newId = "custom-" + Date.now();
        const pointsCopy = freeDrawPoints.map((p) => ({
         x: p.x,
         y: p.y,
        }));
        EDGE_DATA.list.push({
         id: newId,
         type: "custom",
         color,
         width: 4,
         lineStyle: lineStyle,
         direction: arrowDir,
         points: pointsCopy,
         notes: [],
        });
        saveEdgeData();
        freeDrawPoints = [];
        if (freeDrawPolylineEl) {
         freeDrawPolylineEl.remove();
         freeDrawPolylineEl = null;
        }
        freeDrawPointEls.forEach((el) => el.remove());
        freeDrawPointEls = [];
        forgeTheTopology();
        selectTheConnection(newId);
       } else {
        freeDrawPoints = [];
        if (freeDrawPolylineEl) {
         freeDrawPolylineEl.remove();
         freeDrawPolylineEl = null;
        }
        freeDrawPointEls.forEach((el) => el.remove());
        freeDrawPointEls = [];
        forgeTheLegend();
       }
       drawUndoBtn.style.display = "none";
      }
      drawToggleBtn.addEventListener("click", () => {
       if (currentView.mode === "rack") {
        alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
        return;
       }
       
       if (freeDrawMode) {
        finishFreeDraw();
       } else {
        startFreeDraw();
       }
      });
      drawUndoBtn.addEventListener("click", () => {
       if (!freeDrawMode || !freeDrawPoints.length) return;
       freeDrawPoints.pop();
       updateFreeDrawGraphics();
      });
      const drawToolbar = document.getElementById("draw-toolbar");
      drawToolbar.addEventListener("mousedown", (e) => {
       e.stopPropagation();
      });
      drawToolbar.addEventListener("click", (e) => {
       if (e.target !== drawToggleBtn && e.target !== drawUndoBtn) {
        e.stopPropagation();
       }
      });
      drawStyleSelect.addEventListener("change", () => {
       if (freeDrawMode) {
        updateFreeDrawGraphics();
       }
      });
      drawArrowSelect.addEventListener("change", () => {
       if (freeDrawMode) {
        updateFreeDrawGraphics();
       }
      });
      drawColorInput.addEventListener("input", () => {
       if (freeDrawMode) {
        updateFreeDrawGraphics();
       }
      });
      drawStyleSelect.addEventListener("mousedown", (e) => {
       e.stopPropagation();
      });
      drawStyleSelect.addEventListener("click", (e) => {
       e.stopPropagation();
      });
      drawArrowSelect.addEventListener("mousedown", (e) => {
       e.stopPropagation();
      });
      drawArrowSelect.addEventListener("click", (e) => {
       e.stopPropagation();
      });
      drawColorInput.addEventListener("mousedown", (e) => {
       e.stopPropagation();
      });
      drawColorInput.addEventListener("click", (e) => {
       e.stopPropagation();
      });
      
      svgMap.addEventListener("click", (e) => {
       if (!freeDrawMode) return;
       if (e.button !== 0) return;
       const target = e.target;
       if (target && target.classList && target.classList.contains("free-point")) return;
       const svgEl = svgMap;
       const pt = svgEl.createSVGPoint();
       pt.x = e.clientX;
       pt.y = e.clientY;
       const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
       addFreeDrawPoint(svgP.x, svgP.y);
      });
      svgMap.addEventListener("touchend",
       (e) => {
        if (!freeDrawMode) return;
        const target = e.target;
        if (target && target.classList && target.classList.contains("free-point")) return;
        if (e.changedTouches && e.changedTouches[0]) {
         e.preventDefault();
         const svgEl = svgMap;
         const pt = svgEl.createSVGPoint();
         pt.x = e.changedTouches[0].clientX;
         pt.y = e.changedTouches[0].clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
         addFreeDrawPoint(svgP.x, svgP.y);
        }
       }, {
        passive: false
       }, );
      
       const rectToggleBtn = document.getElementById("rect-toggle");
       const rectStyleSelect = document.getElementById("rect-style");
      
       function startRectDraw() {
        rectDrawMode = true;
        rectStartPoint = null;
        rectPreviewEl = null;
        svgMap.style.cursor = "crosshair";
        rectToggleBtn.textContent = "Done";
        rectStyle = rectStyleSelect.value || "filled";
        
        if (freeDrawMode) {
         finishFreeDraw();
        }
        updateRectangleDeleteButtons();
       }
      
       function finishRectDraw() {
        rectDrawMode = false;
        svgMap.style.cursor = "";
        rectToggleBtn.textContent = "â–­";
        
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
        updateRectangleDeleteButtons();
       }
      
       rectToggleBtn.addEventListener("click", () => {
        if (currentView.mode === "rack") {
         alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
         return;
        }
        
        if (rectDrawMode) {
         finishRectDraw();
        } else {
         startRectDraw();
        }
       });
      
       rectStyleSelect.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       rectStyleSelect.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       rectStyleSelect.addEventListener("change", () => {
        if (rectDrawMode) {
         rectStyle = rectStyleSelect.value || "filled";
        }
       });
      
       svgMap.addEventListener("mousedown", (e) => {
        if (!rectDrawMode) return;
        if (e.button !== 0) return;
        e.preventDefault();
        e.stopPropagation();
        
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        rectStartPoint = { x: svgP.x, y: svgP.y };
        
        const ns = "http://www.w3.org/2000/svg";
        rectPreviewEl = document.createElementNS(ns, "rect");
        rectPreviewEl.classList.add("rect-preview");
        rectPreviewEl.setAttribute("x", svgP.x);
        rectPreviewEl.setAttribute("y", svgP.y);
        rectPreviewEl.setAttribute("width", 0);
        rectPreviewEl.setAttribute("height", 0);
        
        const color = drawColorInput.value || "#f97316";
        rectPreviewEl.style.stroke = color;
        rectPreviewEl.style.strokeWidth = 2;
        rectPreviewEl.style.strokeDasharray = "5,5";
        
        if (rectStyle === "filled") {
         rectPreviewEl.style.fill = color;
         rectPreviewEl.style.fillOpacity = "0.3";
        } else {
         rectPreviewEl.style.fill = "none";
        }
        
        svgEl.appendChild(rectPreviewEl);
       });
      
       svgMap.addEventListener("mousemove", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        
        rectPreviewEl.setAttribute("x", x);
        rectPreviewEl.setAttribute("y", y);
        rectPreviewEl.setAttribute("width", width);
        rectPreviewEl.setAttribute("height", height);
       });
      
       svgMap.addEventListener("mouseup", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        
        if (width > 10 && height > 10) {
      pushUndo("draw zone");
         const color = drawColorInput.value || "#f97316";
         const newId = "rect-" + Date.now();
         
          const lineStyle = document.getElementById("draw-style").value || "solid";
         RECT_DATA.list.push({
          id: newId,
          x: x,
          y: y,
          width: width,
          height: height,
          color: color,
          style: rectStyle,
          lineStyle: lineStyle,
          notes: []
         });
         
         forgeTheTopology();
        }
        
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
       });
      
       let rectTouchStart = null;
       
       svgMap.addEventListener("touchstart", (e) => {
        if (!rectDrawMode) return;
        if (e.touches.length !== 1) return;
        
        e.preventDefault();
        const touch = e.touches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        rectStartPoint = { x: svgP.x, y: svgP.y };
        rectTouchStart = { x: svgP.x, y: svgP.y };
        
        const ns = "http://www.w3.org/2000/svg";
        rectPreviewEl = document.createElementNS(ns, "rect");
        rectPreviewEl.classList.add("rect-preview");
        rectPreviewEl.setAttribute("x", svgP.x);
        rectPreviewEl.setAttribute("y", svgP.y);
        rectPreviewEl.setAttribute("width", 0);
        rectPreviewEl.setAttribute("height", 0);
        
        const color = drawColorInput.value || "#f97316";
        rectPreviewEl.style.stroke = color;
        rectPreviewEl.style.strokeWidth = 2;
        rectPreviewEl.style.strokeDasharray = "5,5";
        
        if (rectStyle === "filled") {
         rectPreviewEl.style.fill = color;
         rectPreviewEl.style.fillOpacity = "0.3";
        } else {
         rectPreviewEl.style.fill = "none";
        }
        
        svgEl.appendChild(rectPreviewEl);
       }, { passive: false });
      
       svgMap.addEventListener("touchmove", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        if (e.touches.length !== 1) return;
        
        e.preventDefault();
        const touch = e.touches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        
        rectPreviewEl.setAttribute("x", x);
        rectPreviewEl.setAttribute("y", y);
        rectPreviewEl.setAttribute("width", width);
        rectPreviewEl.setAttribute("height", height);
       }, { passive: false });
      
       svgMap.addEventListener("touchend", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        if (!rectTouchStart) return;
        
        e.preventDefault();
        const touch = e.changedTouches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        
        if (width > 10 && height > 10) {
      pushUndo("draw zone");
         const color = drawColorInput.value || "#f97316";
         const newId = "rect-" + Date.now();
         
        const lineStyle = document.getElementById("draw-style").value || "solid";
         RECT_DATA.list.push({
          id: newId,
          x: x,
          y: y,
          width: width,
          height: height,
          color: color,
          style: rectStyle,
          lineStyle: lineStyle,
          notes: []
         });
         
         forgeTheTopology();
        }
        
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
        rectTouchStart = null;
       }, { passive: false });
      
      const textToggleBtn = document.getElementById("text-toggle");
      
      function startTextMode() {
       textDrawMode = true;
       svgMap.style.cursor = "crosshair";
       textToggleBtn.textContent = "Done";
       textToggleBtn.style.background = "var(--accent)";
       textToggleBtn.style.color = "var(--bg)";
       
       if (freeDrawMode) {
        finishFreeDraw();
       }
       if (rectDrawMode) {
        finishRectDraw();
       }
       
       updateTextDeleteButtons();
      }
      
      function finishTextMode() {
       textDrawMode = false;
       svgMap.style.cursor = "";
       textToggleBtn.textContent = "T";
       textToggleBtn.style.background = "";
       textToggleBtn.style.color = "";
       updateTextDeleteButtons();
      }
      
      textToggleBtn.addEventListener("click", () => {
       if (currentView.mode === "rack") {
        alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
        return;
       }
       
       if (textDrawMode) {
        finishTextMode();
       } else {
        startTextMode();
       }
      });
      
      function handleTextPlacement(e) {
       if (!textDrawMode) return;
       
       const svgEl = svgMap;
       const pt = svgEl.createSVGPoint();
       pt.x = e.clientX;
       pt.y = e.clientY;
       const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
       
       const newId = "text-" + Date.now();
      pushUndo("add text");
       TEXT_DATA.list.push({
        id: newId,
        x: svgP.x,
        y: svgP.y,
        content: "New Text",
        fontSize: 18,
        color: "#e2e8f0",
        fontWeight: "normal",
        fontStyle: "normal",
        textAlign: "start",
        textDecoration: "none",
        bgColor: "#000000",
        bgEnabled: false,
        opacity: 1
       });
       
       forgeTheTopology();
       
       showTextPanel(newId);
      }
      
      svgMap.addEventListener("click", (e) => {
       if (!textDrawMode) return;
       if (e.target.closest('.text-delete-btn')) return;
       if (e.target.closest('.text-group')) return;
       
       e.preventDefault();
       e.stopPropagation();
       handleTextPlacement(e);
      });
      
      svgMap.addEventListener("touchend", (e) => {
       if (!textDrawMode) return;
       if (e.target.closest('.text-delete-btn')) return;
       if (e.target.closest('.text-group')) return;
       if (e.touches.length > 0) return;
       
       e.preventDefault();
       const touch = e.changedTouches[0];
       const fakeEvent = {
        clientX: touch.clientX,
        clientY: touch.clientY,
        preventDefault: () => {},
        stopPropagation: () => {}
       };
       handleTextPlacement(fakeEvent);
      }, { passive: false });
      
      function showTextPanel(textId) {
       currentTextId = textId;
       currentNodeId = null;
       currentEdgeId = null;
       currentRectId = null;
       const textItem = TEXT_DATA.list.find(t => t.id === textId);
       if (!textItem) return;
       
       document.getElementById("node-panel").style.display = "none";
       document.getElementById("edge-panel").style.display = "none";
       document.getElementById("rect-panel").style.display = "none";
       
       const textPanel = document.getElementById("text-panel");
       textPanel.style.display = "block";
       document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active"));
       document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
       document.querySelectorAll(".rect-group").forEach(r => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach(t => t.classList.toggle("active", t.dataset.textId === textId));
       
       document.getElementById("text-content").value = textItem.content;
       document.getElementById("text-font-size").value = textItem.fontSize;
       document.getElementById("text-color").value = textItem.color;
       document.getElementById("text-font-weight").value = textItem.fontWeight;
       document.getElementById("text-font-style").value = textItem.fontStyle;
       document.getElementById("text-align").value = textItem.textAlign;
       document.getElementById("text-decoration").value = textItem.textDecoration;
       document.getElementById("text-bg-color").value = textItem.bgColor;
       document.getElementById("text-bg-enabled").checked = textItem.bgEnabled;
       document.getElementById("text-opacity").value = textItem.opacity;
       document.getElementById("text-opacity-val").textContent = Math.round(textItem.opacity * 100) + "%";
      }
      
      function updateTextDeleteButtons() {
       const deleteButtons = document.querySelectorAll('.text-delete-btn');
       deleteButtons.forEach(btn => {
        btn.style.display = textDrawMode ? 'block' : 'none';
       });
      }
      
      function deleteText(textId) {
      pushUndo("delete text");
       TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== textId);
       forgeTheTopology();
       
       if (currentTextId === textId) {
        document.getElementById("text-panel").style.display = "none";
        currentTextId = null;
       }
      }
      
      document.getElementById("text-content").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
      pushUndo("edit text");
        textItem.content = e.target.value;
        forgeTheTopology();
       }
      });
      
      document.getElementById("text-font-size").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        textItem.fontSize = parseInt(e.target.value);
        forgeTheTopology();
       }
      });
      
      document.getElementById("text-color").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        textItem.color = e.target.value;
        forgeTheTopology();
       }
      });
      
      document.getElementById("text-font-weight").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        textItem.fontWeight = e.target.value;
        forgeTheTopology();
       }
      });
      
      document.getElementById("text-font-style").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        textItem.fontStyle = e.target.value;
        forgeTheTopology();
       }
      });
      
      document.getElementById("text-align").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        textItem.textAlign = e.target.value;
        forgeTheTopology();
       }
      });
      
      document.getElementById("text-decoration").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        textItem.textDecoration = e.target.value;
        forgeTheTopology();
       }
      });
      
      document.getElementById("text-bg-color").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        textItem.bgColor = e.target.value;
        forgeTheTopology();
       }
      });
      
      document.getElementById("text-bg-enabled").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        textItem.bgEnabled = e.target.checked;
        forgeTheTopology();
       }
      });
      
      document.getElementById("text-opacity").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        textItem.opacity = parseFloat(e.target.value);
        document.getElementById("text-opacity-val").textContent = Math.round(textItem.opacity * 100) + "%";
        forgeTheTopology();
       }
      });
      
      document.getElementById("delete-text").addEventListener("click", () => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        challengeTheImmortal(`Delete text "${textItem.content.substring(0, 30)}..."?`, () => {
         deleteText(currentTextId);
        });
       }
      });
      
      const settingsBtn = document.getElementById("settings-btn");
      const settingsModal = document.getElementById("settings-modal");
      const settingsClose = document.getElementById("settings-close");
      settingsBtn.addEventListener("click", () => {
       document.getElementById("page-bg-color").value = PAGE_STATE.background || "#050608";
       document.getElementById("topbar-bg-color").value = PAGE_STATE.topbarBg || "#0b0e13";
       document.getElementById("topbar-border-color").value = PAGE_STATE.topbarBorder || "#1f2533";
       document.getElementById("panel-color").value = PAGE_STATE.panel || "#0b0e13";
       document.getElementById("panel-alt-color").value = PAGE_STATE.panelAlt || "#10141b";
       document.getElementById("sidebar-bg-color").value = PAGE_STATE.sidebarBg || "#10141b";
       document.getElementById("btn-bg-color").value = PAGE_STATE.btnBg || "#0b0e13";
       document.getElementById("btn-text-color").value = PAGE_STATE.btnText || "#e2e8f0";
       document.getElementById("tag-fill-color").value = PAGE_STATE.tagFill || "#1e293b";
       document.getElementById("tag-text-color").value = PAGE_STATE.tagText || "#e2e8f0";
       document.getElementById("tag-border-color").value = PAGE_STATE.tagBorder || "#475569";
       document.getElementById("input-bg-color").value = PAGE_STATE.inputBg || "#0b0e13";
       document.getElementById("input-text-color").value = PAGE_STATE.inputText || "#e2e8f0";
       document.getElementById("input-border-color").value = PAGE_STATE.inputBorder || "#1f2937";
       document.getElementById("input-font-family").value = PAGE_STATE.inputFont || "Inter, system-ui, sans-serif";
       document.getElementById("input-font-size").value = PAGE_STATE.inputFontSize || 14;
       document.getElementById("toolbar-bg-color").value = PAGE_STATE.toolbarBg || "#0f172a";
       document.getElementById("toolbar-border-color").value = PAGE_STATE.toolbarBorder || "#1f2937";
       document.getElementById("toolbar-text-color").value = PAGE_STATE.toolbarText || "#94a3b8";
       document.getElementById("toolbar-btn-bg-color").value = PAGE_STATE.toolbarBtnBg || "#0b0e13";
       document.getElementById("toolbar-btn-text-color").value = PAGE_STATE.toolbarBtnText || "#e2e8f0";
       document.getElementById("minimap-dots-color").value = PAGE_STATE.minimapDots || "#94a3b8";
       document.getElementById("canvas-hint-enabled").checked = PAGE_STATE.canvasHintEnabled !== false;
       document.getElementById("canvas-hint-bg-color").value = PAGE_STATE.canvasHintBg || "#0f172a";
       document.getElementById("canvas-hint-text-color").value = PAGE_STATE.canvasHintColor || "#94a3b8";
       document.getElementById("canvas-hint-text").value = PAGE_STATE.canvasHintText || "";
       document.getElementById("accent-color").value = PAGE_STATE.accent || "#4fd1c5";
       document.getElementById("danger-color").value = PAGE_STATE.danger || "#f56565";
       document.getElementById("text-main-color").value = PAGE_STATE.textMain || "#e2e8f0";
       document.getElementById("text-soft-color").value = PAGE_STATE.textSoft || "#94a3b8";
       document.getElementById("node-fill-color").value = PAGE_STATE.nodeFill || "#1e293b";
       document.getElementById("node-stroke-color").value = PAGE_STATE.nodeStroke || "#475569";
       document.getElementById("node-title-color").value = PAGE_STATE.nodeTitle || "#e2e8f0";
       document.getElementById("node-sub-color").value = PAGE_STATE.nodeSub || "#94a3b8";
       document.getElementById("node-title-size").value = PAGE_STATE.nodeTitleSize || 18;
       document.getElementById("node-sub-size").value = PAGE_STATE.nodeSubSize || 13;
       document.getElementById("node-font-family").value = PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
       document.getElementById("default-edge-color").value = PAGE_STATE.defaultEdge || "#475569";
       document.getElementById("selection-handle-color").value = PAGE_STATE.selectionHandle || "#f59e0b";
       document.getElementById("selection-handle-size").value = PAGE_STATE.selectionHandleSize || 8;
       document.getElementById("group-indicator-color").value = PAGE_STATE.groupIndicator || "#4fd1c5";
       document.getElementById("canvas-gradient-top").value = PAGE_STATE.canvasGradientTop || "#1e2532";
       document.getElementById("canvas-gradient-bottom").value = PAGE_STATE.canvasGradientBottom || "#050608";
       document.getElementById("canvas-border-color").value = PAGE_STATE.canvasBorder || "#475569";
       document.getElementById("canvas-grid-color").value = PAGE_STATE.canvasGrid || "#475569";
       document.getElementById("canvas-grid-size").value = PAGE_STATE.canvasGridSize || 50;
       document.getElementById("rack-frame-fill").value = PAGE_STATE.rackFrameFill || "#0f172a";
       document.getElementById("rack-frame-stroke").value = PAGE_STATE.rackFrameStroke || "#4fd1c5";
       document.getElementById("rack-line-color").value = PAGE_STATE.rackLineColor || "#475569";
       document.getElementById("rack-text-color").value = PAGE_STATE.rackTextColor || "#4fd1c5";
       settingsModal.classList.add("active");
      });
      settingsClose.addEventListener("click", () => {
       settingsModal.classList.remove("active");
      });
      settingsModal.addEventListener("click", (e) => {
       if (e.target === settingsModal) {
        settingsModal.classList.remove("active");
       }
      });
      document.getElementById("page-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.background = e.target.value;
       wieldThePower();
      });
      document.getElementById("topbar-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.topbarBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("topbar-border-color").addEventListener("input", (e) => {
       PAGE_STATE.topbarBorder = e.target.value;
       wieldThePower();
      });
      document.getElementById("panel-color").addEventListener("input", (e) => {
       PAGE_STATE.panel = e.target.value;
       wieldThePower();
      });
      document.getElementById("panel-alt-color").addEventListener("input", (e) => {
       PAGE_STATE.panelAlt = e.target.value;
       wieldThePower();
      });
      document.getElementById("sidebar-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.sidebarBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("btn-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.btnBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("btn-text-color").addEventListener("input", (e) => {
       PAGE_STATE.btnText = e.target.value;
       wieldThePower();
      });
      document.getElementById("tag-fill-color").addEventListener("input", (e) => {
       PAGE_STATE.tagFill = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("tag-text-color").addEventListener("input", (e) => {
       PAGE_STATE.tagText = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("tag-border-color").addEventListener("input", (e) => {
       PAGE_STATE.tagBorder = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("input-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.inputBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-text-color").addEventListener("input", (e) => {
       PAGE_STATE.inputText = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-border-color").addEventListener("input", (e) => {
       PAGE_STATE.inputBorder = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-font-family").addEventListener("change", (e) => {
       PAGE_STATE.inputFont = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-font-size").addEventListener("input", (e) => {
       PAGE_STATE.inputFontSize = parseInt(e.target.value) || 14;
       wieldThePower();
      });
      document.getElementById("toolbar-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-border-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBorder = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-text-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarText = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-btn-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBtnBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-btn-text-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBtnText = e.target.value;
       wieldThePower();
      });
      document.getElementById("minimap-dots-color").addEventListener("input", (e) => {
       PAGE_STATE.minimapDots = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("canvas-hint-enabled").addEventListener("change", (e) => {
       PAGE_STATE.canvasHintEnabled = e.target.checked;
       wieldThePower();
      });
      document.getElementById("canvas-hint-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-hint-text-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintColor = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-hint-text").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintText = e.target.value;
       wieldThePower();
      });
      document.getElementById("accent-color").addEventListener("input", (e) => {
       PAGE_STATE.accent = e.target.value;
       wieldThePower();
      });
      document.getElementById("danger-color").addEventListener("input", (e) => {
       PAGE_STATE.danger = e.target.value;
       wieldThePower();
      });
      document.getElementById("text-main-color").addEventListener("input", (e) => {
       PAGE_STATE.textMain = e.target.value;
       wieldThePower();
      });
      document.getElementById("text-soft-color").addEventListener("input", (e) => {
       PAGE_STATE.textSoft = e.target.value;
       wieldThePower();
      });
      document.getElementById("node-fill-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeFill = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-stroke-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeStroke = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-title-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeTitle = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-sub-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeSub = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-title-size").addEventListener("input", (e) => {
       PAGE_STATE.nodeTitleSize = parseInt(e.target.value) || 18;
       forgeTheTopology();
      });
      document.getElementById("node-sub-size").addEventListener("input", (e) => {
       PAGE_STATE.nodeSubSize = parseInt(e.target.value) || 13;
       forgeTheTopology();
      });
      document.getElementById("node-font-family").addEventListener("change", (e) => {
       PAGE_STATE.nodeFont = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("default-edge-color").addEventListener("input", (e) => {
       PAGE_STATE.defaultEdge = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("selection-handle-color").addEventListener("input", (e) => {
       PAGE_STATE.selectionHandle = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("selection-handle-size").addEventListener("input", (e) => {
       PAGE_STATE.selectionHandleSize = parseInt(e.target.value) || 8;
       forgeTheTopology();
      });
      document.getElementById("group-indicator-color").addEventListener("input", (e) => {
       PAGE_STATE.groupIndicator = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-gradient-top").addEventListener("input", (e) => {
       PAGE_STATE.canvasGradientTop = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-gradient-bottom").addEventListener("input", (e) => {
       PAGE_STATE.canvasGradientBottom = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-border-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasBorder = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-grid-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasGrid = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-grid-size").addEventListener("input", (e) => {
       PAGE_STATE.canvasGridSize = parseInt(e.target.value) || 50;
       forgeTheTopology();
      });
      document.getElementById("rack-frame-fill").addEventListener("input", (e) => {
       PAGE_STATE.rackFrameFill = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-frame-stroke").addEventListener("input", (e) => {
       PAGE_STATE.rackFrameStroke = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-line-color").addEventListener("input", (e) => {
       PAGE_STATE.rackLineColor = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-text-color").addEventListener("input", (e) => {
       PAGE_STATE.rackTextColor = e.target.value;
       forgeTheTopology();
      });
      
      (function initializeResizers() {
        const headerResizer = document.getElementById('header-resizer');
        const sidebarResizer = document.getElementById('sidebar-resizer');
        const mobileFooterResizer = document.getElementById('mobile-footer-resizer');
        
        let isResizing = false;
        let currentResizer = null;
        let startY = 0;
        let startX = 0;
        let startHeight = 0;
        let startWidth = 0;
        
        function getClientPos(e) {
          if (e.touches && e.touches.length > 0) {
            return { x: e.touches[0].clientX, y: e.touches[0].clientY };
          }
          return { x: e.clientX, y: e.clientY };
        }
        
        function startResize(resizer, type, e) {
          isResizing = true;
          currentResizer = type;
          const pos = getClientPos(e);
          
          if (type === 'header') {
            startY = pos.y;
            startHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--topbar-height'));
          } else if (type === 'sidebar') {
            startX = pos.x;
            startWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width'));
          } else if (type === 'mobile-footer') {
            startY = pos.y;
            const currentVh = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--mobile-footer-height'));
            startHeight = (currentVh / 100) * window.innerHeight;
          }
          
          resizer.classList.add('resizing');
          document.body.classList.add('resizing');
          document.body.style.cursor = (type === 'sidebar') ? 'col-resize' : 'row-resize';
          e.preventDefault();
        }
        
        if (headerResizer) {
          headerResizer.addEventListener('mousedown', (e) => startResize(headerResizer, 'header', e));
          headerResizer.addEventListener('touchstart', (e) => startResize(headerResizer, 'header', e), { passive: false });
        }
        
        if (sidebarResizer) {
          sidebarResizer.addEventListener('mousedown', (e) => startResize(sidebarResizer, 'sidebar', e));
          sidebarResizer.addEventListener('touchstart', (e) => startResize(sidebarResizer, 'sidebar', e), { passive: false });
        }
        
        if (mobileFooterResizer) {
          mobileFooterResizer.addEventListener('mousedown', (e) => startResize(mobileFooterResizer, 'mobile-footer', e));
          mobileFooterResizer.addEventListener('touchstart', (e) => startResize(mobileFooterResizer, 'mobile-footer', e), { passive: false });
        }
        
        function handleMove(e) {
          if (!isResizing) return;
          
          const pos = getClientPos(e);
          
          if (currentResizer === 'header') {
            const deltaY = pos.y - startY;
            const newHeight = Math.max(40, Math.min(150, startHeight + deltaY));
            document.documentElement.style.setProperty('--topbar-height', newHeight + 'px');
          } else if (currentResizer === 'sidebar') {
            const deltaX = startX - pos.x;
            const newWidth = Math.max(200, Math.min(800, startWidth + deltaX));
            document.documentElement.style.setProperty('--sidebar-width', newWidth + 'px');
          } else if (currentResizer === 'mobile-footer') {
            const deltaY = startY - pos.y;
            const newHeight = startHeight + deltaY;
            const newVh = Math.max(15, Math.min(80, (newHeight / window.innerHeight) * 100));
            document.documentElement.style.setProperty('--mobile-footer-height', newVh + 'vh');
          }
          
          e.preventDefault();
        }
        
        document.addEventListener('mousemove', handleMove);
        document.addEventListener('touchmove', handleMove, { passive: false });
        
        function handleEnd() {
          if (isResizing) {
            isResizing = false;
            
            if (currentResizer === 'header') {
              PAGE_STATE.topbarHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--topbar-height'));
              headerResizer.classList.remove('resizing');
            } else if (currentResizer === 'sidebar') {
              PAGE_STATE.sidebarWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width'));
              sidebarResizer.classList.remove('resizing');
            } else if (currentResizer === 'mobile-footer') {
              PAGE_STATE.mobileFooterHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--mobile-footer-height'));
              mobileFooterResizer.classList.remove('resizing');
            }
            
            document.body.classList.remove('resizing');
            document.body.style.cursor = '';
            currentResizer = null;
          }
        }
        
        document.addEventListener('mouseup', handleEnd);
        document.addEventListener('touchend', handleEnd);
        document.addEventListener('touchcancel', handleEnd);
      })();
      
      document.getElementById("export-data-btn").addEventListener("click", () => {
       const data = captureTheQuickening();
       const jsonStr = JSON.stringify(data, null, 2);
       const blob = new Blob([jsonStr], {
        type: "application/json"
       });
       const url = URL.createObjectURL(blob);
       const a = document.createElement("a");
       a.href = url;
       const safeTitle = (PAGE_STATE.title || "network-topology").toLowerCase().replace(/[^a-z0-9\-]+/g, "-");
       const timestamp = new Date().toISOString().split("T")[0];
       a.download = `${safeTitle}-data-${timestamp}.json`;
       document.body.appendChild(a);
       a.click();
       document.body.removeChild(a);
       URL.revokeObjectURL(url);
      });
      document.getElementById("import-data-btn").addEventListener("click", () => {
       document.getElementById("import-data-file").click();
      });
      document.getElementById("import-data-file").addEventListener("change", async (e) => {
       const file = e.target.files[0];
       if (!file) return;
       try {
        const text = await file.text();
        const data = JSON.parse(text);
        if (!data.nodeData || !data.edgeData) {
         alert("Invalid data file. Missing required fields.");
         return;
        }
        const confirmMsg = `This will replace all current data with the imported data.\n\nImporting:\n- ${Object.keys(data.nodeData).length} nodes\n- ${data.edgeData.list?.length || 0} connections\n- ${data.documentTabs?.length || 1} tab(s)\n\nContinue?`;
        if (!confirm(confirmMsg)) {
         e.target.value = "";
         return;
        }
        NODE_DATA = data.nodeData || {};
        EDGE_DATA = data.edgeData || {
         list: []
        };
        EDGE_LEGEND = data.edgeLegend || {};
        RECT_DATA = data.rectData || { list: [] };
        TEXT_DATA = data.textData || { list: [] };
        savedPositions = data.nodePositions || {};
        savedSizes = data.nodeSizes || {};
        savedStyles = data.nodeStyles || {};
        if (data.page) {
         PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, data.page, );
         wieldThePower();
        }
        if (data.canvas) {
         canvasState.zoom = data.canvas.zoom || 1;
         canvasState.panX = data.canvas.panX || 0;
         canvasState.panY = data.canvas.panY || 0;
        }
        if (data.page?.title) {
         document.title = data.page.title;
         document.querySelector(".editable-page-title", ).textContent = data.page.title;
        }
        if (data.documentTabs) {
         documentTabs = data.documentTabs;
         currentTabIndex = data.currentTabIndex || 0;
        }
        if (data.savedTopologyView) {
         savedTopologyView = data.savedTopologyView;
        }
        if (data.encryptedSections) {
         encryptedSections = data.encryptedSections;
        }
        forgeTheTopology();
        forgeTheLegend();
        updateViewBox();
        const nodeIds = Object.keys(NODE_DATA);
        if (nodeIds.length > 0) {
         claimTheImmortal(nodeIds[0]);
        } else {
         document.getElementById("node-panel").style.display = "none";
         document.getElementById("edge-panel").style.display = "none";
         document.getElementById("topology-toolbar").style.display = "none";
        }
        e.target.value = "";
       } catch (err) {
        console.error("Import error:", err);
        alert(`Failed to import data: ${err.message}`);
        e.target.value = "";
       }
      });
      const saveHelpBtn = document.getElementById("save-help-btn");
      const saveInfoModal = document.getElementById("save-info-modal");
      const saveInfoClose = document.getElementById("save-info-close");
      saveHelpBtn.addEventListener("click", () => {
       saveInfoModal.classList.add("active");
      });
      saveInfoClose.addEventListener("click", () => {
       saveInfoModal.classList.remove("active");
      });
      saveInfoModal.addEventListener("click", (e) => {
       if (e.target === saveInfoModal) {
        saveInfoModal.classList.remove("active");
       }
      });
      document.querySelectorAll(".help-tab").forEach(tab => {
        tab.addEventListener("click", () => {
          document.querySelectorAll(".help-tab").forEach(t => { t.style.background = "var(--panel)"; t.style.color = "var(--text-main)"; });
          tab.style.background = "var(--accent)"; tab.style.color = "var(--bg)";
          document.querySelectorAll(".help-tab-content").forEach(c => c.style.display = "none");
          document.getElementById("help-tab-" + tab.dataset.tab).style.display = "block";
        });
      });
      async function deriveKey(password, salt) {
      const encoder = new TextEncoder();
      
      const keyMaterial = await crypto.subtle.importKey(
      "raw",
      encoder.encode(password),
      "PBKDF2",
      false,
      ["deriveKey"]
      );
      
      return crypto.subtle.deriveKey(
      {
      name: "PBKDF2",
      salt: salt,
      iterations: 200000,
      hash: "SHA-256"
      },
      keyMaterial,
      {
      name: "AES-GCM",
      length: 256
      },
      false,
      ["encrypt", "decrypt"]
      );
      }
      
      async function encryptData(data, password) {
      const encoder = new TextEncoder();
      const salt = crypto.getRandomValues(new Uint8Array(16));
      const iv   = crypto.getRandomValues(new Uint8Array(12));
      
      const key = await deriveKey(password, salt);
      const encrypted = await crypto.subtle.encrypt(
      { name: "AES-GCM", iv },
      key,
      encoder.encode(data)
      );
      
      const encryptedU8 = new Uint8Array(encrypted);
      
      const result = new Uint8Array(salt.length + iv.length + encryptedU8.length);
      result.set(salt, 0);
      result.set(iv, salt.length);
      result.set(encryptedU8, salt.length + iv.length);
      
      return "ENCRYPTED:" + u8ToBase64(result);
      }
      
      async function decryptData(encryptedData, password) {
      const base64Data = encryptedData.replace("ENCRYPTED:", "");
      const fullData   = base64ToU8(base64Data);
      
      const salt      = fullData.slice(0, 16);
      const iv        = fullData.slice(16, 28);
      const encrypted = fullData.slice(28);
      
      const key = await deriveKey(password, salt);
      
      const decrypted = await crypto.subtle.decrypt(
      { name: "AES-GCM", iv },
      key,
      encrypted
      );
      
      const decoder = new TextDecoder();
      return decoder.decode(decrypted);
      }
      
      
      function isEncrypted(data) {
       return typeof data === "string" && data.startsWith("ENCRYPTED:");
      }
      
      function captureTheQuickening() {
       const currentTab = documentTabs[currentTabIndex];
       currentTab.nodes = JSON.parse(JSON.stringify(NODE_DATA));
       currentTab.edges = JSON.parse(JSON.stringify(EDGE_DATA));
       currentTab.positions = JSON.parse(JSON.stringify(savedPositions));
       currentTab.sizes = JSON.parse(JSON.stringify(savedSizes));
       currentTab.styles = JSON.parse(JSON.stringify(savedStyles));
       currentTab.legend = JSON.parse(JSON.stringify(EDGE_LEGEND));
       currentTab.rects = JSON.parse(JSON.stringify(RECT_DATA));
       currentTab.texts = JSON.parse(JSON.stringify(TEXT_DATA));
       currentTab.pageState = JSON.parse(JSON.stringify(PAGE_STATE));
       
       return {
        nodeData: NODE_DATA,
        edgeData: EDGE_DATA,
        rectData: RECT_DATA,
        textData: TEXT_DATA,
        edgeLegend: EDGE_LEGEND,
        nodePositions: savedPositions,
        nodeSizes: savedSizes,
        nodeStyles: savedStyles,
        page: PAGE_STATE,
        canvas: {
         zoom: canvasState.zoom,
         panX: canvasState.panX,
         panY: canvasState.panY,
        },
        savedTopologyView: savedTopologyView,
        documentTabs: documentTabs,
        currentTabIndex: currentTabIndex,
        encryptedSections: encryptedSections,
       };
      }
      
      function assembleTheImmortalForm() {
      const canvasHintEl = document.getElementById("canvas-hint");
       const savedHintHTML = canvasHintEl ? canvasHintEl.innerHTML : "";
       if (canvasHintEl) canvasHintEl.innerHTML = DEFAULT_CANVAS_HINT;
       const clone = document.documentElement.cloneNode(true);
       const nodeScript = clone.querySelector("#nodes-json");
       if (nodeScript) {
        nodeScript.textContent = JSON.stringify(NODE_DATA, null, 2);
       }
       let stateScript = clone.querySelector("#topology-state");
       if (!stateScript) {
        stateScript = document.createElement("script");
        stateScript.id = "topology-state";
        stateScript.type = "application/json";
        const body = clone.querySelector("body") || clone;
        body.appendChild(stateScript);
       }
       stateScript.textContent = JSON.stringify(captureTheQuickening(), null, 2, );
       return "<!DOCTYPE html> \n " + clone.outerHTML;
      }
      async function becomeImmortal() {
       saveRollbackVersion("Auto-save");
       
       const encryptEnabled = document.getElementById("encrypt-toggle").checked;
       let stateData = JSON.stringify(captureTheQuickening(), null, 2);
       if (encryptEnabled) {
        const password = prompt("Enter a password to encrypt your data:\n(Remember this password! You will need it to open this file and its non recoverable!)", );
        if (!password) {
         alert("Encryption cancelled. File not saved.");
         return;
        }
        const confirmPassword = prompt("Confirm your password:");
        if (password !== confirmPassword) {
         alert("Passwords do not match. File not saved.");
         return;
        }
        try {
         stateData = await encryptData(stateData, password);
        } catch (e) {
         alert("Encryption failed: " + e.message);
         return;
        }
       }
       const canvasHintEl = document.getElementById("canvas-hint");
       const savedHintHTML = canvasHintEl ? canvasHintEl.innerHTML : "";
       if (canvasHintEl) canvasHintEl.innerHTML = DEFAULT_CANVAS_HINT;
       
       const clone = document.documentElement.cloneNode(true);
       const nodeScript = clone.querySelector("#nodes-json");
       if (nodeScript) {
        if (encryptEnabled) {
         nodeScript.textContent = JSON.stringify({}, null, 2);
        } else {
         nodeScript.textContent = JSON.stringify(NODE_DATA, null, 2);
        }
       }
       let stateScript = clone.querySelector("#topology-state");
       if (!stateScript) {
        stateScript = document.createElement("script");
        stateScript.id = "topology-state";
        stateScript.type = "application/json";
        const body = clone.querySelector("body") || clone;
        body.appendChild(stateScript);
       }
       stateScript.textContent = stateData;
       const html = "<!DOCTYPE html> \n " + clone.outerHTML;
       const blob = new Blob([html], {
        type: "text/html"
       });
       const url = URL.createObjectURL(blob);
       const a = document.createElement("a");
       a.href = url;
       const safeTitle = (PAGE_STATE.title || document.title || "network-topology").toLowerCase().replace(/[^a-z0-9\-]+/g, "-");
       a.download = safeTitle + ".html";
       document.body.appendChild(a);
       a.click();
       document.body.removeChild(a);
       URL.revokeObjectURL(url);
       if (canvasHintEl) canvasHintEl.innerHTML = savedHintHTML;
       logAuditEvent("save", `File saved: ${safeTitle}.html`);
      }
      
      function captureState() {
      return {
       nodes: JSON.parse(JSON.stringify(NODE_DATA)),
       edges: JSON.parse(JSON.stringify(EDGE_DATA)),
       positions: JSON.parse(JSON.stringify(savedPositions)),
       sizes: JSON.parse(JSON.stringify(savedSizes)),
       styles: JSON.parse(JSON.stringify(savedStyles)),
       legend: JSON.parse(JSON.stringify(EDGE_LEGEND)),
       rects: JSON.parse(JSON.stringify(RECT_DATA)),
       texts: JSON.parse(JSON.stringify(TEXT_DATA))
       };
      }
      
      function pushUndo(action = "") {
       const state = captureState();
       undoStack.push(state);
       if (undoStack.length > MAX_UNDO_STACK) {
        undoStack.shift();
       }
       redoStack = [];
       updateUndoButtons();
       
       if (action) {
        const actionTypeMap = {
          "create node": "node",
          "delete node": "node",
          "edit": "node",
          "create rack": "rack",
          "add connection": "connection",
          "delete connection": "connection",
          "style change": "style",
          "change layer": "layer",
          "change assigned rack": "rack",
        };
        
        const type = actionTypeMap[action] || "node";
        logAuditEvent(type, action);
       }
      }
      
      function undo() {
       if (undoStack.length === 0) return;
       const currentState = captureState();
       redoStack.push(currentState);
       const previousState = undoStack.pop();
       restoreState(previousState);
       updateUndoButtons();
      }
      
      function redo() {
       if (redoStack.length === 0) return;
       const currentState = captureState();
       undoStack.push(currentState);
       const nextState = redoStack.pop();
       restoreState(nextState);
       updateUndoButtons();
      }
      
      function restoreState(state) {
      NODE_DATA = state.nodes;
      EDGE_DATA = state.edges;
      savedPositions = state.positions;
      savedSizes = state.sizes;
      savedStyles = state.styles;
      EDGE_LEGEND = state.legend;
      RECT_DATA = state.rects || { list: [] };
      TEXT_DATA = state.texts || { list: [] };
      forgeTheTopology();
      if (currentNodeId && NODE_DATA[currentNodeId]) {
       claimTheImmortal(currentNodeId);
      } else if (currentEdgeId) {
       selectTheConnection(currentEdgeId);
       }
      }
      
      function updateUndoButtons() {
       const undoBtn = document.getElementById("undo-btn");
       const redoBtn = document.getElementById("redo-btn");
       if (undoBtn) {
        undoBtn.disabled = undoStack.length === 0;
        undoBtn.style.opacity = undoStack.length === 0 ? "0.5" : "1";
       }
       if (redoBtn) {
        redoBtn.disabled = redoStack.length === 0;
        redoBtn.style.opacity = redoStack.length === 0 ? "0.5" : "1";
       }
      }
      
      function editNodeMac(id) {
       const currentMac = NODE_DATA[id].mac || "";
       showEditModal("Edit MAC Address", currentMac, (newMac) => {
        pushUndo("edit mac");
        NODE_DATA[id].mac = newMac;
        if (currentNodeId === id) {
         document.getElementById("node-mac").textContent = newMac || "--";
        }
       });
      }
      
      function editNodeRack(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       
       document.getElementById("modal-title").textContent = "Edit Rack Unit";
       document.getElementById("modal-input").value = node.rackUnit || "";
       document.getElementById("edit-modal").style.display = "flex";
       document.getElementById("modal-input").focus();
       
       const saveHandler = () => {
        pushUndo("edit rack");
        const value = document.getElementById("modal-input").value.trim();
        node.rackUnit = value;
        document.getElementById("edit-modal").style.display = "none";
        claimTheImmortal(id);
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       
       const cancelHandler = () => {
        document.getElementById("edit-modal").style.display = "none";
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       
       document.getElementById("edit-modal").addEventListener("click", function bgHandler(e) {
        if (e.target === document.getElementById("edit-modal")) {
         cancelHandler();
         document.getElementById("edit-modal").removeEventListener("click", bgHandler);
        }
       });
      }
      
      function editNodeUHeight(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       
       document.getElementById("modal-title").textContent = "Edit U Height";
       document.getElementById("modal-input").value = node.uHeight || "1";
       document.getElementById("edit-modal").style.display = "flex";
       document.getElementById("modal-input").focus();
       
       const saveHandler = () => {
        pushUndo("edit U height");
        const value = document.getElementById("modal-input").value.trim();
        node.uHeight = value;
        document.getElementById("edit-modal").style.display = "none";
        claimTheImmortal(id);
        forgeTheTopology();
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       
       const cancelHandler = () => {
        document.getElementById("edit-modal").style.display = "none";
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       
       document.getElementById("edit-modal").addEventListener("click", function bgHandler(e) {
        if (e.target === document.getElementById("edit-modal")) {
         cancelHandler();
         document.getElementById("edit-modal").removeEventListener("click", bgHandler);
        }
       });
      }
      
      function updateEdgePortLabels(edgeId) {
       const edge = EDGE_DATA.list.find(e => e.id === edgeId);
       if (!edge || edge.type === "custom") return;
       
       const fromPortInput = document.getElementById("edge-from-port");
       const toPortInput = document.getElementById("edge-to-port");
       
       if (fromPortInput && toPortInput) {
        edge.fromPort = fromPortInput.value || "";
        edge.toPort = toPortInput.value || "";
        saveEdgeData();
        forgeTheTopology();
       }
      }
      
      function selectNode(nodeId, addToSelection = false) {
       if (!addToSelection) {
        clearSelection();
       }
       selectedNodes.add(nodeId);
       updateNodeSelection();
      }
      
      function clearSelection() {
       selectedNodes.clear();
       selectedEdges.clear();
       selectedRects.clear();
       selectedTexts.clear();
       updateAllSelections();
      }
      
      function updateAllSelections() {
      updateNodeSelection();
      
      document.querySelectorAll(".edge").forEach(el => {
      const edgeId = el.dataset.edgeId;
      if (selectedEdges.has(edgeId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      
      document.querySelectorAll(".rect-group").forEach(el => {
      const rectId = el.dataset.rectId;
      if (selectedRects.has(rectId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      
      document.querySelectorAll(".text-group").forEach(el => {
      const textId = el.dataset.textId;
      if (selectedTexts.has(textId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      
      const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
      const bulkToolbar = document.getElementById("bulk-toolbar");
      const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
      const bulkCount = document.getElementById("bulk-count");
      const bulkCountMobile = document.getElementById("bulk-count-mobile");
      
      if (total > 0) {
      if (bulkToolbar) bulkToolbar.style.display = "flex";
      if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
      if (bulkCount) bulkCount.textContent = total;
      if (bulkCountMobile) bulkCountMobile.textContent = total;
      } else {
      if (bulkToolbar) bulkToolbar.style.display = "none";
      if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
      }
      }
      
      function updateNodeSelection() {
       document.querySelectorAll(".node-group").forEach(node => {
        const nodeId = node.dataset.nodeId;
        if (selectedNodes.has(nodeId)) {
         node.classList.add("selected");
        } else {
         node.classList.remove("selected");
        }
       });
       
       const bulkToolbar = document.getElementById("bulk-toolbar");
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       const bulkCount = document.getElementById("bulk-count");
       const bulkCountMobile = document.getElementById("bulk-count-mobile");
       const bulkCountModal = document.getElementById("bulk-count-modal");
       
       if (selectedNodes.size > 0) {
        if (bulkToolbar) bulkToolbar.style.display = "flex";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
        if (bulkCount) bulkCount.textContent = selectedNodes.size;
        if (bulkCountMobile) bulkCountMobile.textContent = selectedNodes.size;
        if (bulkCountModal) bulkCountModal.textContent = selectedNodes.size;
       } else {
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        const modal = document.getElementById("bulk-actions-modal");
        if (modal) modal.style.display = "none";
       }
      }
      
      function deleteSelected() {
       const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
       if (total === 0) return;
       
       let nodesInsideRacks = [];
       selectedNodes.forEach(nodeId => {
        if (NODE_DATA[nodeId]?.isRack) {
         Object.entries(NODE_DATA).forEach(([id, n]) => {
          if (n.assignedRack === nodeId) nodesInsideRacks.push(n.name || id);
         });
        }
       });
       
       let message = `Delete ${total} selected item(s)?`;
       if (nodesInsideRacks.length > 0) {
        message += `\n\nThis will also delete ${nodesInsideRacks.length} node(s) inside rack(s):\nâ€¢ ${nodesInsideRacks.join('\nâ€¢ ')}`;
       }
       
       challengeTheImmortal(message, () => {
        pushUndo("delete selected");
        selectedNodes.forEach(nodeId => {
         if (NODE_DATA[nodeId]?.isRack) {
          Object.keys(NODE_DATA).forEach(id => {
           if (NODE_DATA[id]?.assignedRack === nodeId) {
            EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== id && e.to !== id);
            delete NODE_DATA[id];
            delete savedPositions[id];
            delete savedSizes[id];
            delete savedStyles[id];
           }
          });
         }
         delete NODE_DATA[nodeId];
         delete savedPositions[nodeId];
         delete savedSizes[nodeId];
         delete savedStyles[nodeId];
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== nodeId && e.to !== nodeId);
        });
        selectedEdges.forEach(edgeId => {
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.id !== edgeId);
        });
        selectedRects.forEach(rectId => {
         RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== rectId);
        });
        selectedTexts.forEach(textId => {
         TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== textId);
        });
        clearSelection();
        saveEdgeData();
        forgeTheTopology();
       });
      }
      
      function startSelection(event) {
       if (event.button !== 0) return;
       if (event.target.closest(".node-group")) return;
       
       isSelecting = true;
       const svg = document.getElementById("map");
       const pt = svg.createSVGPoint();
       pt.x = event.clientX;
       pt.y = event.clientY;
       const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
       selectionStart = { x: svgP.x, y: svgP.y };
       
       if (!event.shiftKey) {
        clearSelection();
       }
       
       if (!selectionRect) {
        selectionRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        selectionRect.setAttribute("fill", "rgba(79, 209, 197, 0.1)");
        selectionRect.setAttribute("stroke", "#4fd1c5");
        selectionRect.setAttribute("stroke-width", "2");
        selectionRect.setAttribute("stroke-dasharray", "5,5");
        svg.appendChild(selectionRect);
       }
       selectionRect.style.display = "block";
      }
      
      function updateSelection(event) {
       if (!isSelecting || !selectionStart) return;
       
       const svg = document.getElementById("map");
       const pt = svg.createSVGPoint();
       pt.x = event.clientX;
       pt.y = event.clientY;
       const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
       
       const x = Math.min(selectionStart.x, svgP.x);
       const y = Math.min(selectionStart.y, svgP.y);
       const width = Math.abs(svgP.x - selectionStart.x);
       const height = Math.abs(svgP.y - selectionStart.y);
       
       selectionRect.setAttribute("x", x);
       selectionRect.setAttribute("y", y);
       selectionRect.setAttribute("width", width);
       selectionRect.setAttribute("height", height);
       
       Object.entries(savedPositions).forEach(([nodeId, pos]) => {
        if (pos.x >= x && pos.x <= x + width && pos.y >= y && pos.y <= y + height) {
         selectedNodes.add(nodeId);
        } else if (!event.shiftKey) {
         selectedNodes.delete(nodeId);
        }
       });
       updateNodeSelection();
      }
      
      function endSelection() {
       isSelecting = false;
       if (selectionRect) {
        selectionRect.style.display = "none";
       }
      }
      
      function cloneNode(sourceId) {
       if (!NODE_DATA[sourceId]) return;
       
       pushUndo("clone node");
       const source = NODE_DATA[sourceId];
       const baseName = source.name + " copy";
       let newName = baseName;
       let counter = 1;
       while (Object.values(NODE_DATA).some(n => n.name === newName)) {
        newName = `${baseName} ${counter}`;
        counter++;
       }
       
       const baseId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
       let newId = baseId;
       counter = 1;
       while (NODE_DATA[newId]) {
        newId = `${baseId}-${counter}`;
        counter++;
       }
       
       NODE_DATA[newId] = {
        shape: source.shape,
        name: newName,
        ip: source.ip,
        role: source.role,
        tags: [...source.tags],
        notes: [...source.notes],
        mac: source.mac || "",
        rackUnit: source.rackUnit || "",
        uHeight: source.uHeight || "1",
        layer: source.layer || "physical",
        assignedRack: source.assignedRack || "",
        rackCapacity: source.rackCapacity || "42",
        isRack: source.isRack || false
       }; 
	   
       if (source.isRack) {
        const childNodes = Object.entries(NODE_DATA).filter(([id, n]) => 
         id !== newId && n.assignedRack === sourceId
        );
        childNodes.forEach(([childId, childNode]) => {
         const childBaseName = childNode.name + " copy";
         let childNewName = childBaseName;
         let c = 1;
         while (Object.values(NODE_DATA).some(n => n.name === childNewName)) {
          childNewName = `${childBaseName} ${c}`;
          c++;
         }
         const childBaseId = childNewName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
         let childNewId = childBaseId;
         c = 1;
         while (NODE_DATA[childNewId]) {
          childNewId = `${childBaseId}-${c}`;
          c++;
         }
         NODE_DATA[childNewId] = {
          ...JSON.parse(JSON.stringify(childNode)),
          name: childNewName,
          assignedRack: newId
         };
         if (savedPositions[childId]) {
          savedPositions[childNewId] = { ...savedPositions[childId] };
         }
         if (savedSizes[childId]) {
          savedSizes[childNewId] = savedSizes[childId];
         }
         if (savedStyles[childId]) {
          savedStyles[childNewId] = JSON.parse(JSON.stringify(savedStyles[childId]));
         }
        });
       }
       
       if (currentView.mode === "rack" && currentView.rackId) {
        NODE_DATA[newId].assignedRack = currentView.rackId;
       }
       
       const sourcePos = savedPositions[sourceId];
       savedPositions[newId] = {
        x: sourcePos.x + 100,
        y: sourcePos.y + 100
       };
       
       if (savedSizes[sourceId]) {
        savedSizes[newId] = savedSizes[sourceId];
       }
       
       if (savedStyles[sourceId]) {
        savedStyles[newId] = JSON.parse(JSON.stringify(savedStyles[sourceId]));
       }
       
       forgeTheTopology();
       claimTheImmortal(newId);
      }
      
      function alignSelectedNodes(direction) {
       if (selectedNodes.size < 2) return;
       
       pushUndo("align nodes");
       const nodes = Array.from(selectedNodes).map(id => ({
        id,
        pos: savedPositions[id]
       }));
       
       switch(direction) {
        case "left":
         const minX = Math.min(...nodes.map(n => n.pos.x));
         nodes.forEach(n => savedPositions[n.id].x = minX);
         break;
        case "right":
         const maxX = Math.max(...nodes.map(n => n.pos.x));
         nodes.forEach(n => savedPositions[n.id].x = maxX);
         break;
        case "top":
         const minY = Math.min(...nodes.map(n => n.pos.y));
         nodes.forEach(n => savedPositions[n.id].y = minY);
         break;
        case "bottom":
         const maxY = Math.max(...nodes.map(n => n.pos.y));
         nodes.forEach(n => savedPositions[n.id].y = maxY);
         break;
        case "center-h":
         const avgX = nodes.reduce((sum, n) => sum + n.pos.x, 0) / nodes.length;
         nodes.forEach(n => savedPositions[n.id].x = avgX);
         break;
        case "center-v":
         const avgY = nodes.reduce((sum, n) => sum + n.pos.y, 0) / nodes.length;
         nodes.forEach(n => savedPositions[n.id].y = avgY);
         break;
       }
       
       forgeTheTopology();
      }
      
      function distributeSelectedNodes(direction) {
       if (selectedNodes.size < 3) return;
       
       pushUndo("distribute nodes");
       const nodes = Array.from(selectedNodes).map(id => ({
        id,
        pos: savedPositions[id]
       }));
       
       if (direction === "horizontal") {
        nodes.sort((a, b) => a.pos.x - b.pos.x);
        const minX = nodes[0].pos.x;
        const maxX = nodes[nodes.length - 1].pos.x;
        const gap = (maxX - minX) / (nodes.length - 1);
        nodes.forEach((n, i) => {
         savedPositions[n.id].x = minX + (gap * i);
        });
       } else {
        nodes.sort((a, b) => a.pos.y - b.pos.y);
        const minY = nodes[0].pos.y;
        const maxY = nodes[nodes.length - 1].pos.y;
        const gap = (maxY - minY) / (nodes.length - 1);
        nodes.forEach((n, i) => {
         savedPositions[n.id].y = minY + (gap * i);
        });
       }
       
       forgeTheTopology();
      }
      
      function snapToGrid(nodeId, gridSize = 50) {
       if (!savedPositions[nodeId]) return;
       
       pushUndo("snap to grid");
       const pos = savedPositions[nodeId];
       pos.x = Math.round(pos.x / gridSize) * gridSize;
       pos.y = Math.round(pos.y / gridSize) * gridSize;
       forgeTheTopology();
      }
      
      function searchNodes(query) {
       if (!query) {
        clearSearchHighlight();
        return [];
       }
       
       query = query.toLowerCase();
       const results = [];
       
       Object.entries(NODE_DATA).forEach(([id, data]) => {
        if (data.name.toLowerCase().includes(query) ||
            data.ip.toLowerCase().includes(query) ||
            data.role.toLowerCase().includes(query) ||
            data.tags.some(tag => tag.toLowerCase().includes(query)) ||
            (data.mac && data.mac.toLowerCase().includes(query)) ||
            (data.rackUnit && data.rackUnit.toLowerCase().includes(query))) {
         results.push(id);
        }
       });
       
       highlightSearchResults(results);
       return results;
      }
      
      function highlightSearchResults(nodeIds) {
       document.querySelectorAll(".node-group").forEach(node => {
        const nodeId = node.dataset.nodeId;
        if (nodeIds.includes(nodeId)) {
         node.classList.add("search-highlight");
        } else {
         node.classList.remove("search-highlight");
        }
       });
      }
      
      function clearSearchHighlight() {
       document.querySelectorAll(".search-highlight").forEach(node => {
        node.classList.remove("search-highlight");
       });
      }
      
      function nudgeSelectedNodes(direction, distance) {
        const nodesToNudge = selectedNodes.size > 0 
          ? Array.from(selectedNodes) 
          : (currentNodeId ? [currentNodeId] : []);
        const rectsToNudge = selectedRects.size > 0 
          ? Array.from(selectedRects) 
          : (currentRectId ? [currentRectId] : []);
        const textsToNudge = selectedTexts.size > 0 
          ? Array.from(selectedTexts) 
          : (currentTextId ? [currentTextId] : []);
        
        if (nodesToNudge.length === 0 && rectsToNudge.length === 0 && textsToNudge.length === 0) return;
        
        const unlockedNodes = nodesToNudge.filter(id => !NODE_DATA[id]?.locked);
        const unlockedRects = rectsToNudge.filter(id => { const r = RECT_DATA.list.find(x => x.id === id); return r && !r.locked; });
        const unlockedTexts = textsToNudge.filter(id => { const t = TEXT_DATA.list.find(x => x.id === id); return t && !t.locked; });
        
        if (unlockedNodes.length === 0 && unlockedRects.length === 0 && unlockedTexts.length === 0) return;
        
        pushUndo("nudge");
        
        const dx = direction === "ArrowLeft" ? -distance : direction === "ArrowRight" ? distance : 0;
        const dy = direction === "ArrowUp" ? -distance : direction === "ArrowDown" ? distance : 0;
        
        unlockedNodes.forEach(id => {
          if (!savedPositions[id]) savedPositions[id] = { x: 0, y: 0 };
          savedPositions[id].x += dx;
          savedPositions[id].y += dy;
        });
        
        unlockedRects.forEach(id => {
          const r = RECT_DATA.list.find(x => x.id === id);
          if (r) { r.x += dx; r.y += dy; }
        });
        
        unlockedTexts.forEach(id => {
          const t = TEXT_DATA.list.find(x => x.id === id);
          if (t) { t.x += dx; t.y += dy; }
        });
        
        forgeTheTopology();
      }
      
      function cycleNodes(reverse = false) {
        const nodeIds = Object.keys(NODE_DATA).filter(id => {
          if (currentView.mode === "rack" && currentView.rackId) {
            return NODE_DATA[id].assignedRack === currentView.rackId;
          }
          return !NODE_DATA[id].assignedRack;
        });
        
        if (nodeIds.length === 0) return;
        
        let currentIndex = nodeIds.indexOf(currentNodeId);
        
        if (reverse) {
          currentIndex = currentIndex <= 0 ? nodeIds.length - 1 : currentIndex - 1;
        } else {
          currentIndex = currentIndex >= nodeIds.length - 1 ? 0 : currentIndex + 1;
        }
        
        const nextNodeId = nodeIds[currentIndex];
        claimTheImmortal(nextNodeId);
        
        selectedNodes.clear();
        updateNodeSelection();
      }
      
      function focusOnSelected() {
        let minX = Infinity, minY = Infinity;
        let maxX = -Infinity, maxY = -Infinity;
        let hasItems = false;
        
        const nodesToFocus = selectedNodes.size > 0 
          ? Array.from(selectedNodes) 
          : (currentNodeId ? [currentNodeId] : []);
        nodesToFocus.forEach(id => {
          const pos = savedPositions[id];
          if (pos) {
            hasItems = true;
            const size = savedSizes[id] || 50;
            minX = Math.min(minX, pos.x - size/2);
            minY = Math.min(minY, pos.y - size/2);
            maxX = Math.max(maxX, pos.x + size/2);
            maxY = Math.max(maxY, pos.y + size/2);
          }
        });
        
        const rectsToFocus = selectedRects.size > 0 ? Array.from(selectedRects) : (currentRectId ? [currentRectId] : []);
        rectsToFocus.forEach(id => {
          const r = RECT_DATA.list.find(x => x.id === id);
          if (r) {
            hasItems = true;
            minX = Math.min(minX, r.x);
            minY = Math.min(minY, r.y);
            maxX = Math.max(maxX, r.x + r.width);
            maxY = Math.max(maxY, r.y + r.height);
          }
        });
        
        const textsToFocus = selectedTexts.size > 0 ? Array.from(selectedTexts) : (currentTextId ? [currentTextId] : []);
        textsToFocus.forEach(id => {
          const t = TEXT_DATA.list.find(x => x.id === id);
          if (t) {
            hasItems = true;
            minX = Math.min(minX, t.x - 50);
            minY = Math.min(minY, t.y - 20);
            maxX = Math.max(maxX, t.x + 50);
            maxY = Math.max(maxY, t.y + 20);
          }
        });
        
        const edgesToFocus = selectedEdges.size > 0 ? Array.from(selectedEdges) : (currentEdgeId ? [currentEdgeId] : []);
        edgesToFocus.forEach(id => {
          const e = EDGE_DATA.list.find(x => x.id === id);
          if (e) {
            const fromPos = savedPositions[e.from];
            const toPos = savedPositions[e.to];
            if (fromPos && toPos) {
              hasItems = true;
              minX = Math.min(minX, fromPos.x, toPos.x);
              minY = Math.min(minY, fromPos.y, toPos.y);
              maxX = Math.max(maxX, fromPos.x, toPos.x);
              maxY = Math.max(maxY, fromPos.y, toPos.y);
            }
          }
        });
        
        if (!hasItems || !isFinite(minX)) return;
        
        const padding = 100;
        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;
        const width = maxX - minX + padding * 2;
        const height = maxY - minY + padding * 2;
        
        const zoomX = CANVAS_WIDTH / width;
        const zoomY = CANVAS_HEIGHT / height;
        const targetZoom = Math.min(zoomX, zoomY, 2); 
        
        canvasState.zoom = targetZoom;
        canvasState.panX = centerX - (CANVAS_WIDTH / targetZoom) / 2;
        canvasState.panY = centerY - (CANVAS_HEIGHT / targetZoom) / 2;
        
        forgeTheTopology();
      }
      
      function toggleLockSelected() {
        const nodesToToggle = selectedNodes.size > 0 
          ? Array.from(selectedNodes) 
          : (currentNodeId ? [currentNodeId] : []);
        const rectsToToggle = selectedRects.size > 0 
          ? Array.from(selectedRects) 
          : (currentRectId ? [currentRectId] : []);
        const textsToToggle = selectedTexts.size > 0 
          ? Array.from(selectedTexts) 
          : (currentTextId ? [currentTextId] : []);
        
        if (nodesToToggle.length === 0 && rectsToToggle.length === 0 && textsToToggle.length === 0) return;
        
        pushUndo("toggle lock");
        
        let hasUnlocked = nodesToToggle.some(id => !NODE_DATA[id]?.locked);
        hasUnlocked = hasUnlocked || rectsToToggle.some(id => { const r = RECT_DATA.list.find(x => x.id === id); return r && !r.locked; });
        hasUnlocked = hasUnlocked || textsToToggle.some(id => { const t = TEXT_DATA.list.find(x => x.id === id); return t && !t.locked; });
        
        nodesToToggle.forEach(id => {
          if (NODE_DATA[id]) NODE_DATA[id].locked = hasUnlocked;
        });
        rectsToToggle.forEach(id => {
          const r = RECT_DATA.list.find(x => x.id === id);
          if (r) r.locked = hasUnlocked;
        });
        textsToToggle.forEach(id => {
          const t = TEXT_DATA.list.find(x => x.id === id);
          if (t) t.locked = hasUnlocked;
        });
        
        forgeTheTopology();
      }
      
      function toggleGroupSelected() {
      const nodesToGroup = Array.from(selectedNodes);
      const rectsToGroup = Array.from(selectedRects);
      const textsToGroup = Array.from(selectedTexts);
      const edgesToGroup = Array.from(selectedEdges);
      const totalItems = nodesToGroup.length + rectsToGroup.length + textsToGroup.length + edgesToGroup.length;
      if (totalItems < 2) return;
      
      pushUndo("toggle group");
      
      const allGroupIds = [];
      nodesToGroup.forEach(id => { if (NODE_DATA[id]?.groupId) allGroupIds.push(NODE_DATA[id].groupId); });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r?.groupId) allGroupIds.push(r.groupId); });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t?.groupId) allGroupIds.push(t.groupId); });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e?.groupId) allGroupIds.push(e.groupId); });
      const uniqueGroups = [...new Set(allGroupIds)];
      
      if (uniqueGroups.length === 1 && allGroupIds.length === totalItems) {
      nodesToGroup.forEach(id => { if (NODE_DATA[id]) NODE_DATA[id].groupId = null; });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r) r.groupId = null; });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t) t.groupId = null; });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e) e.groupId = null; });
      } else {
      const newGroupId = "group-" + Date.now();
      nodesToGroup.forEach(id => { if (NODE_DATA[id]) NODE_DATA[id].groupId = newGroupId; });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r) r.groupId = newGroupId; });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t) t.groupId = newGroupId; });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e) e.groupId = newGroupId; });
      }
      
      forgeTheTopology();
      }
      
      function handleKeyDown(event) {
       if (event.target.tagName === "INPUT" || event.target.tagName === "TEXTAREA" || event.target.isContentEditable) {
        return;
       }
       
       if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(event.key)) {
        event.preventDefault();
        const distance = event.shiftKey ? 10 : 1;
        nudgeSelectedNodes(event.key, distance);
       }
       
       if (event.key === "Tab") {
        event.preventDefault();
        cycleNodes(event.shiftKey);
       }
       
       if (event.key === "f" || event.key === "F") {
        event.preventDefault();
        focusOnSelected();
       }
       
       if (event.key === "l" || event.key === "L") {
        event.preventDefault();
        toggleLockSelected();
       }
       
       if (event.key === "g" || event.key === "G") {
        event.preventDefault();
        toggleGroupSelected();
       }
       
       if (event.ctrlKey && event.key === "z") {
        event.preventDefault();
        undo();
       }
       
       if ((event.ctrlKey && event.key === "y") || (event.ctrlKey && event.shiftKey && event.key === "z")) {
        event.preventDefault();
        redo();
       }
       
 if (event.ctrlKey && event.key === "c") {
        event.preventDefault();
        clipboard = null;
        if (currentNodeId && NODE_DATA[currentNodeId]) {
         clipboard = {
          type: "node",
          data: JSON.parse(JSON.stringify(NODE_DATA[currentNodeId])),
          size: savedSizes[currentNodeId],
          style: savedStyles[currentNodeId] ? JSON.parse(JSON.stringify(savedStyles[currentNodeId])) : null
         };
        } else if (currentEdgeId) {
         const edge = EDGE_DATA.list.find(e => e.id === currentEdgeId);
         if (edge) clipboard = { type: "edge", data: JSON.parse(JSON.stringify(edge)) };
        } else if (currentRectId) {
         const rect = RECT_DATA.list.find(r => r.id === currentRectId);
         if (rect) clipboard = { type: "rect", data: JSON.parse(JSON.stringify(rect)) };
        } else if (currentTextId) {
         const text = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (text) clipboard = { type: "text", data: JSON.parse(JSON.stringify(text)) };
        }
       }
       
       if (event.ctrlKey && event.key === "v") {
        event.preventDefault();
        if (!clipboard) return;
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        const centerX = canvasState.panX + (viewWidth / 2);
        const centerY = canvasState.panY + (viewHeight / 2);
        
        if (clipboard.type === "node") {
         const data = clipboard.data;
         let newName = data.name + " copy";
         let counter = 1;
         while (Object.values(NODE_DATA).some(n => n.name === newName)) {
          newName = data.name + " copy " + counter;
          counter++;
         }
         let newId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
         counter = 1;
         while (NODE_DATA[newId]) {
          newId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-") + "-" + counter;
          counter++;
         }
         pushUndo("paste node");
         NODE_DATA[newId] = { ...data, name: newName };
         savedPositions[newId] = { x: centerX, y: centerY };
         if (clipboard.size) savedSizes[newId] = clipboard.size;
         if (clipboard.style) savedStyles[newId] = JSON.parse(JSON.stringify(clipboard.style));
         forgeTheTopology();
         claimTheImmortal(newId);
        } else if (clipboard.type === "edge") {
         pushUndo("paste edge");
         const newEdge = { ...clipboard.data, id: "edge-" + Date.now() };
         EDGE_DATA.list.push(newEdge);
         saveEdgeData();
         forgeTheTopology();
         selectTheConnection(newEdge.id);
        } else if (clipboard.type === "rect") {
         pushUndo("paste rect");
         const newRect = { ...clipboard.data, id: "rect-" + Date.now(), x: centerX - (clipboard.data.width || 100) / 2, y: centerY - (clipboard.data.height || 100) / 2 };
         RECT_DATA.list.push(newRect);
         forgeTheTopology();
         selectTheRect(newRect.id);
        } else if (clipboard.type === "text") {
         pushUndo("paste text");
         const newText = { ...clipboard.data, id: "text-" + Date.now(), x: centerX, y: centerY };
         TEXT_DATA.list.push(newText);
         forgeTheTopology();
         showTextPanel(newText.id);
        }
       }
       
       if (event.key === "Delete") {
        event.preventDefault();
        const totalSelected = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
        if (totalSelected > 0) {
         deleteSelected();
        } else if (currentNodeId && NODE_DATA[currentNodeId]) {
         challengeTheImmortal(`Delete node "${NODE_DATA[currentNodeId].name}"?`, () => {
          pushUndo("delete node");
          delete NODE_DATA[currentNodeId];
          delete savedPositions[currentNodeId];
          delete savedSizes[currentNodeId];
          delete savedStyles[currentNodeId];
          EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== currentNodeId && e.to !== currentNodeId);
          currentNodeId = null;
          saveEdgeData();
          forgeTheTopology();
          document.getElementById("node-panel").style.display = "none";
         });
        } else if (currentEdgeId) {
         challengeTheImmortal("Delete this line?", () => {
          pushUndo("delete edge");
          EDGE_DATA.list = EDGE_DATA.list.filter(e => e.id !== currentEdgeId);
          currentEdgeId = null;
          saveEdgeData();
          forgeTheTopology();
          document.getElementById("edge-panel").style.display = "none";
         });
        } else if (currentRectId) {
         challengeTheImmortal("Delete this zone?", () => {
          pushUndo("delete rect");
          RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== currentRectId);
          currentRectId = null;
          forgeTheTopology();
          document.getElementById("rect-panel").style.display = "none";
         });
        } else if (currentTextId) {
         const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (textItem) {
          challengeTheImmortal(`Delete text "${textItem.content.substring(0, 30)}..."?`, () => {
           pushUndo("delete text");
           TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== currentTextId);
           currentTextId = null;
           forgeTheTopology();
           document.getElementById("text-panel").style.display = "none";
          });
         }
        }
       }
      
       if (event.ctrlKey && event.key === "a") {
        event.preventDefault();
        Object.keys(NODE_DATA).forEach(id => selectedNodes.add(id));
        EDGE_DATA.list.forEach(e => selectedEdges.add(e.id));
        RECT_DATA.list.forEach(r => selectedRects.add(r.id));
        TEXT_DATA.list.forEach(t => selectedTexts.add(t.id));
        updateNodeSelection();
       }
       
       if (event.key === "Escape") {
        clearSelection();
        clearSearchHighlight();
       }
      
       if (event.ctrlKey && event.key === "d") {
        event.preventDefault();
        if (currentNodeId && NODE_DATA[currentNodeId]) {
         cloneNode(currentNodeId);
        } else if (currentEdgeId) {
         const edge = EDGE_DATA.list.find(e => e.id === currentEdgeId);
         if (edge) {
          pushUndo("clone edge");
          const newEdge = { ...JSON.parse(JSON.stringify(edge)), id: "edge-" + Date.now() };
          EDGE_DATA.list.push(newEdge);
          saveEdgeData();
          forgeTheTopology();
          selectTheConnection(newEdge.id);
         }
        } else if (currentRectId) {
         const rect = RECT_DATA.list.find(r => r.id === currentRectId);
         if (rect) {
          pushUndo("clone rect");
          const newRect = { ...JSON.parse(JSON.stringify(rect)), id: "rect-" + Date.now(), x: rect.x + 50, y: rect.y + 50 };
          RECT_DATA.list.push(newRect);
          forgeTheTopology();
          selectTheRect(newRect.id);
         }
        } else if (currentTextId) {
         const text = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (text) {
          pushUndo("clone text");
          const newText = { ...JSON.parse(JSON.stringify(text)), id: "text-" + Date.now(), x: text.x + 50, y: text.y + 50 };
          TEXT_DATA.list.push(newText);
          forgeTheTopology();
          showTextPanel(newText.id);
         }
        }
       }
      }
      
      function saveRollbackVersion(description = "Auto-save") {
        const version = {
          timestamp: Date.now(),
          description,
          data: captureTheQuickening()
        };
        
        try {
          const stored = localStorage.getItem(ROLLBACK_STORAGE_KEY);
          rollbackVersions = stored ? JSON.parse(stored) : [];
        } catch (e) {
          rollbackVersions = [];
        }
        
        rollbackVersions.unshift(version);
        
        if (rollbackVersions.length > MAX_ROLLBACK_VERSIONS) {
          rollbackVersions = rollbackVersions.slice(0, MAX_ROLLBACK_VERSIONS);
        }
        
        try {
          localStorage.setItem(ROLLBACK_STORAGE_KEY, JSON.stringify(rollbackVersions));
        } catch (e) {
          console.warn("Failed to save rollback version:", e);
        }
      }
      
      function loadRollbackVersions() {
        try {
          const stored = localStorage.getItem(ROLLBACK_STORAGE_KEY);
          rollbackVersions = stored ? JSON.parse(stored) : [];
          displayRollbackVersions();
        } catch (e) {
          console.warn("Failed to load rollback versions:", e);
          rollbackVersions = [];
        }
      }
      
      function displayRollbackVersions() {
        const listEl = document.getElementById("rollback-list");
        if (!listEl) return;
        
        if (rollbackVersions.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No version history yet. Versions are saved automatically when you save the file.</div>';
          return;
        }
        
        listEl.innerHTML = rollbackVersions.map((version, index) => {
          const date = new Date(version.timestamp);
          const timeStr = date.toLocaleString();
          const nodeCount = Object.keys(version.data.nodeData || {}).length;
          const edgeCount = (version.data.edgeData?.list || []).length;
          
          return `
            <div class="version-item" onclick="restoreRollbackVersion(${index})">
              <div class="version-info">
                <div class="timestamp">${timeStr}</div>
                <div class="details">${version.description} â€¢ ${nodeCount} nodes â€¢ ${edgeCount} connections</div>
              </div>
              <div class="version-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteRollbackVersion(${index})" title="Delete this version">ðŸ—‘ï¸</button>
              </div>
            </div>
          `;
        }).join('');
      }
      
      function restoreRollbackVersion(index) {
        if (!confirm(`Restore version from ${new Date(rollbackVersions[index].timestamp).toLocaleString()}?\n\nYour current work will be lost unless you save first.`)) {
          return;
        }
        
        const version = rollbackVersions[index];
        const data = version.data;
        
        NODE_DATA = data.nodeData || {};
        EDGE_DATA = data.edgeData || { list: [] };
        RECT_DATA = data.rectData || { list: [] };
        TEXT_DATA = data.textData || { list: [] };
        EDGE_LEGEND = data.edgeLegend || {};
        savedPositions = data.nodePositions || {};
        savedSizes = data.nodeSizes || {};
        savedStyles = data.nodeStyles || {};
        PAGE_STATE = data.page || PAGE_STATE;
        
        if (data.canvas) {
          canvasState.zoom = data.canvas.zoom;
          canvasState.panX = data.canvas.panX;
          canvasState.panY = data.canvas.panY;
        }
        
        wieldThePower();
        forgeTheTopology();
        
        document.getElementById("rollback-modal").classList.remove("active");
        
        logAuditEvent("rollback", `Restored version from ${new Date(version.timestamp).toLocaleString()}`);
      }
      
      function deleteRollbackVersion(index) {
        if (!confirm("Delete this version from history?")) return;
        
        rollbackVersions.splice(index, 1);
        try {
          localStorage.setItem(ROLLBACK_STORAGE_KEY, JSON.stringify(rollbackVersions));
        } catch (e) {
          console.warn("Failed to delete version:", e);
        }
        displayRollbackVersions();
      }
      
      function clearRollbackHistory() {
        if (!confirm("Clear all version history?\n\nThis cannot be undone.")) return;
        
        rollbackVersions = [];
        localStorage.removeItem(ROLLBACK_STORAGE_KEY);
        displayRollbackVersions();
      }
      
      function createManualSnapshot() {
        const description = prompt("Enter a description for this snapshot:", "Manual snapshot");
        if (!description) return;
        
        saveRollbackVersion(description);
        displayRollbackVersions();
      }
      
      function switchTab(index) {
        if (index === currentTabIndex) return;
        
        const currentTab = documentTabs[currentTabIndex];
        currentTab.nodes = JSON.parse(JSON.stringify(NODE_DATA));
        currentTab.edges = JSON.parse(JSON.stringify(EDGE_DATA));
        currentTab.positions = JSON.parse(JSON.stringify(savedPositions));
        currentTab.sizes = JSON.parse(JSON.stringify(savedSizes));
        currentTab.styles = JSON.parse(JSON.stringify(savedStyles));
        currentTab.legend = JSON.parse(JSON.stringify(EDGE_LEGEND));
        currentTab.rects = JSON.parse(JSON.stringify(RECT_DATA));
        currentTab.texts = JSON.parse(JSON.stringify(TEXT_DATA));
        currentTab.pageState = JSON.parse(JSON.stringify(PAGE_STATE));
      
        currentTabIndex = index;
        const newTab = documentTabs[index];
        NODE_DATA = JSON.parse(JSON.stringify(newTab.nodes));
        EDGE_DATA = JSON.parse(JSON.stringify(newTab.edges));
        savedPositions = JSON.parse(JSON.stringify(newTab.positions));
        savedSizes = JSON.parse(JSON.stringify(newTab.sizes));
        savedStyles = JSON.parse(JSON.stringify(newTab.styles));
        EDGE_LEGEND = JSON.parse(JSON.stringify(newTab.legend));
        RECT_DATA = JSON.parse(JSON.stringify(newTab.rects));
        TEXT_DATA = JSON.parse(JSON.stringify(newTab.texts));
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, newTab.pageState || {});
        wieldThePower();
        document.getElementById("page-title").textContent = PAGE_STATE.title || newTab.name;
        forgeTheTopology();
        currentNodeId = null;
        currentEdgeId = null;
        currentTextId = null;
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        displayTabs();
        
        logAuditEvent("tab", `Switched to tab: ${newTab.name}`);
      }
      
      function createNewTab() {
        const nameInput = document.getElementById("new-tab-name");
        const name = nameInput.value.trim();
        
        if (!name) {
          alert("Please enter a tab name");
          return;
        }
        
        const newTab = {
          id: `tab-${Date.now()}`,
          name,
          nodes: {},
          edges: { list: [] },
          positions: {},
          sizes: {},
          styles: {},
          legend: {},
          rects: { list: [] },
          texts: { list: [] },
      pageState: null
        };
        
        documentTabs.push(newTab);
        nameInput.value = "";
        displayTabs();
        
        logAuditEvent("tab", `Created new tab: ${name}`);
      }
      
      function renameTab(index) {
        const tab = documentTabs[index];
        const newName = prompt("Enter new name:", tab.name);
        if (!newName || newName === tab.name) return;
        
        tab.name = newName;
        displayTabs();
        
        logAuditEvent("tab", `Renamed tab to: ${newName}`);
      }
      
      function deleteTab(index) {
        if (documentTabs.length === 1) {
          alert("Cannot delete the last tab");
          return;
        }
        
        if (!confirm(`Delete tab "${documentTabs[index].name}"?`)) return;
        
        documentTabs.splice(index, 1);
        
        if (currentTabIndex >= documentTabs.length) {
          currentTabIndex = documentTabs.length - 1;
        }
        
        if (currentTabIndex === index) {
          switchTab(currentTabIndex);
        }
        
        displayTabs();
      }
      
      function displayTabs() {
        const listEl = document.getElementById("tabs-list");
        if (!listEl) return;
        
        listEl.innerHTML = documentTabs.map((tab, index) => {
          const nodeCount = Object.keys(tab.nodes).length;
          const edgeCount = tab.edges.list.length;
          const isActive = index === currentTabIndex;
          
          return `
            <div class="tab-item ${isActive ? 'active' : ''}" onclick="switchTab(${index})">
              <div class="tab-name">${tab.name}</div>
              <div class="tab-stats">${nodeCount} nodes â€¢ ${edgeCount} connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(${index})" title="Rename tab">âœï¸</button>
                ${documentTabs.length > 1 ? '<button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(${index})" title="Delete tab">ðŸ—‘ï¸</button>' : ''}
              </div>
            </div>
          `;
        }).join('');
      }
      
      function logAuditEvent(type, description, details = {}) {
        const event = {
          timestamp: Date.now(),
          type,
          description,
          details,
          tab: documentTabs[currentTabIndex]?.name || "Main"
        };
        
        auditLog.unshift(event);
        
        if (auditLog.length > MAX_AUDIT_ENTRIES) {
          auditLog = auditLog.slice(0, MAX_AUDIT_ENTRIES);
        }
      
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to save audit log:", e);
        }
      }
      
      function loadAuditLog() {
        try {
          const stored = localStorage.getItem(AUDIT_STORAGE_KEY);
          auditLog = stored ? JSON.parse(stored) : [];
        } catch (e) {
          console.warn("Failed to load audit log:", e);
          auditLog = [];
        }
      }
      
      function displayAuditLog(filter = "all") {
        const listEl = document.getElementById("audit-log-list");
        if (!listEl) return;
        
        const filtered = filter === "all" ? auditLog : auditLog.filter(e => e.type === filter);
        
        if (filtered.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No audit entries yet</div>';
          return;
        }
        
        listEl.innerHTML = filtered.map(event => {
          const date = new Date(event.timestamp);
          const timeStr = date.toLocaleString();
          
          return `
            <div class="audit-entry ${event.type}">
              <div class="time">[${timeStr}] ${event.tab}</div>
              <div class="action">[${event.type.toUpperCase()}] ${event.description}</div>
            </div>
          `;
        }).join('');
      }
      
      function clearAuditLog() {
        if (!confirm("Clear all audit log entries?\n\nThis cannot be undone.")) return;
        
        auditLog = [];
        localStorage.removeItem(AUDIT_STORAGE_KEY);
        displayAuditLog();
      }
      
      function exportAuditLog() {
        if (auditLog.length === 0) {
          alert("No audit entries to export");
          return;
        }
        
        const csv = [
          ["Timestamp", "Tab", "Type", "Description"],
          ...auditLog.map(e => [
            new Date(e.timestamp).toISOString(),
            e.tab,
            e.type,
            e.description
          ])
        ].map(row => row.map(cell => `"${cell}"`).join(",")).join("\n");
        
        const blob = new Blob([csv], { type: "text/csv" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `audit-log-${Date.now()}.csv`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }
      
      let currentSecretName = null;
      
      function createNewSecret() {
        const nameInput = document.getElementById("new-secret-name");
        const name = nameInput.value.trim();
        
        if (!name) {
          alert("Please enter a note name");
          return;
        }
        
        if (encryptedSections[name]) {
          alert("A note with this name already exists");
          return;
        }
        
        currentSecretName = name;
        encryptedSections[name] = { encrypted: false, data: "" };
        nameInput.value = "";
        
        document.getElementById("secret-editor-title").textContent = `New note: ${name}`;
        document.getElementById("secret-editor-content").value = "";
        document.getElementById("secrets-modal").classList.remove("active");
        document.getElementById("secret-editor-modal").classList.add("active");
        
        displaySecrets();
      }
      
      function editSecret(name) {
        currentSecretName = name;
        const section = encryptedSections[name];
        
        if (section.encrypted) {
          const password = prompt(`Enter password to decrypt "${name}":`);
          if (!password) return;
          
          try {
            decryptData(section.data, password).then(decrypted => {
              document.getElementById("secret-editor-title").textContent = `Edit note: ${name}`;
              document.getElementById("secret-editor-content").value = decrypted;
              document.getElementById("secrets-modal").classList.remove("active");
              document.getElementById("secret-editor-modal").classList.add("active");
            }).catch(e => {
              alert("Failed to decrypt. Wrong password?");
            });
          } catch (e) {
            alert("Failed to decrypt. Wrong password?");
          }
        } else {
          document.getElementById("secret-editor-title").textContent = `Edit note: ${name}`;
          document.getElementById("secret-editor-content").value = section.data;
          document.getElementById("secrets-modal").classList.remove("active");
          document.getElementById("secret-editor-modal").classList.add("active");
        }
      }
      
      async function saveSecret() {
        if (!currentSecretName) return;
        
        const content = document.getElementById("secret-editor-content").value;
        const autoEncrypt = document.getElementById("secret-auto-encrypt").checked;
        
        if (autoEncrypt) {
          const password = prompt(`Enter password to encrypt "${currentSecretName}":`);
          if (!password) return;
          
          const confirmPassword = prompt("Confirm password:");
          if (password !== confirmPassword) {
            alert("Passwords do not match");
            return;
          }
          
          try {
            const encrypted = await encryptData(content, password);
            encryptedSections[currentSecretName] = { encrypted: true, data: encrypted };
          } catch (e) {
            alert("Encryption failed: " + e.message);
            return;
          }
        } else {
          encryptedSections[currentSecretName] = { encrypted: false, data: content };
        }
        
        closeSecretEditor();
        displaySecrets();
        
        logAuditEvent("secret", `Saved note: ${currentSecretName}`);
      }
      
      function closeSecretEditor() {
        document.getElementById("secret-editor-modal").classList.remove("active");
        document.getElementById("secrets-modal").classList.add("active");
        currentSecretName = null;
      }
      
      function deleteSecret(name) {
        if (!confirm(`Delete note "${name}"?`)) return;
        
        delete encryptedSections[name];
        displaySecrets();
        
        logAuditEvent("secret", `Deleted note: ${name}`);
      }
      
      function displaySecrets() {
        const listEl = document.getElementById("secrets-list");
        if (!listEl) return;
        
        const secrets = Object.keys(encryptedSections);
        
        if (secrets.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No notes yet</div>';
          return;
        }
        
        listEl.innerHTML = secrets.map(name => {
          const section = encryptedSections[name];
          const status = section.encrypted ? "ðŸ”’ Encrypted" : "ðŸ”“ Plaintext";
          
          return `
            <div class="secret-item">
              <div class="secret-name">${name}</div>
              <div class="secret-status">${status}</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="editSecret('${name}')" title="Edit note">âœï¸</button>
                <button class="btn-cancel" onclick="deleteSecret('${name}')" title="Delete note">ðŸ—‘ï¸</button>
              </div>
            </div>
          `;
        }).join('');
      }
      
      let rafId = null;
      let lastRender = 0;
      const RENDER_THROTTLE = 16;
      
      function optimizedForgeTheTopology() {
        if (rafId) return;
        
        rafId = requestAnimationFrame((timestamp) => {
          if (timestamp - lastRender < RENDER_THROTTLE) {
            rafId = requestAnimationFrame(optimizedForgeTheTopology);
            return;
          }
          
          lastRender = timestamp;
          rafId = null;
          
          if (cullOffscreenNodes && Object.keys(NODE_DATA).length > 100) {
            cullOffscreenElements();
          }
          
          forgeTheTopology();
          
          if (Date.now() - lastMinimapUpdate > 500) {
            updateMinimapOptimized();
            lastMinimapUpdate = Date.now();
          }
        });
      }
      
      function cullOffscreenElements() {
        const viewX = canvasState.panX;
        const viewY = canvasState.panY;
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        
        Object.keys(NODE_DATA).forEach(id => {
          const pos = savedPositions[id];
          if (!pos) return;
          
          const nodeEl = document.querySelector(`[data-node-id="${id}"]`);
          if (!nodeEl) return;
          
          const isVisible = (
            pos.x + 100 >= viewX &&
            pos.x - 100 <= viewX + viewWidth &&
            pos.y + 100 >= viewY &&
            pos.y - 100 <= viewY + viewHeight
          );
          
          nodeEl.style.display = isVisible ? "" : "none";
        });
      }
      
      function updateMinimapOptimized() {
        minimapNeedsUpdate = true;
      }
      
      function setupDragToCreate() {
        const addNodeBtn = document.getElementById("add-node-btn");
        const addRackBtn = document.getElementById("add-rack-btn");
        const canvas = document.getElementById("map");
        
        if (!addNodeBtn || !addRackBtn || !canvas) return;
        
        let dragType = null;
        
        [addNodeBtn, addRackBtn].forEach(btn => {
          btn.setAttribute("draggable", "true");
          
          btn.addEventListener("dragstart", e => {
            dragType = btn.id === "add-node-btn" ? "node" : "rack";
            e.dataTransfer.effectAllowed = "copy";
            e.dataTransfer.setData("text/plain", dragType);
          });
        });
        
        canvas.addEventListener("dragover", e => {
          if (dragType) {
            e.preventDefault();
            e.dataTransfer.dropEffect = "copy";
          }
        });
        
        canvas.addEventListener("drop", e => {
          if (!dragType) return;
          
          e.preventDefault();
          
          const rect = canvas.getBoundingClientRect();
          const x = (e.clientX - rect.left) / canvasState.zoom + canvasState.panX;
          const y = (e.clientY - rect.top) / canvasState.zoom + canvasState.panY;
          
          if (dragType === "node") {
            createNodeAtPosition(x, y);
          } else if (dragType === "rack") {
            createRackAtPosition(x, y);
          }
          
          dragType = null;
        });
      }
      
      function createNodeAtPosition(x, y) {
        const timestamp = Date.now();
        const newId = `host-${timestamp}`;
        
        NODE_DATA[newId] = {
          name: "New Node",
          ip: "0.0.0.0",
          shape: "server",
          role: "",
          tags: [],
          notes: "",
          layer: "physical",
          isRack: false
        };
        
        savedPositions[newId] = { x, y };
        savedSizes[newId] = 55;
        
        pushUndo("create node");
        forgeTheTopology();
        claimTheImmortal(newId);
        
        logAuditEvent("node", `Created node at (${Math.round(x)}, ${Math.round(y)})`);
      }
      
      function createRackAtPosition(x, y) {
        const timestamp = Date.now();
        const newId = `rack-${timestamp}`;
        
        NODE_DATA[newId] = {
          name: "New Rack",
          ip: "",
          shape: "server",
          role: "rack",
          tags: [],
          notes: "",
          layer: "physical",
          isRack: true,
          rackCapacity: 42
        };
        
        savedPositions[newId] = { x, y };
        savedSizes[newId] = 55;
        
        pushUndo("create rack");
        populateRackDropdown();
        forgeTheTopology();
        claimTheImmortal(newId);
        
        logAuditEvent("rack", `Created rack at (${Math.round(x)}, ${Math.round(y)})`);
      }
      
      document.addEventListener("keydown", handleKeyDown);
      
      document.getElementById("save-file-btn").addEventListener("click", becomeImmortal);
      const addNodeBtn = document.getElementById("add-node-btn");
      const addNodeModal = document.getElementById("add-node-modal");
      const addNodeCancel = document.getElementById("add-node-cancel");
      const addNodeSave = document.getElementById("add-node-save");
      
      const undoBtn = document.getElementById("undo-btn");
      const redoBtn = document.getElementById("redo-btn");
      if (undoBtn) undoBtn.addEventListener("click", undo);
      if (redoBtn) redoBtn.addEventListener("click", redo);
      
      const backToTopologyBtn = document.getElementById("back-to-topology-btn");
      if (backToTopologyBtn) {
       backToTopologyBtn.addEventListener("click", exitRack);
      }
      
      const canvasViewport = document.getElementById("canvas-viewport");
      if (canvasViewport) {
       canvasViewport.addEventListener("dblclick", (e) => {
        if (currentView.mode === "rack" && e.target.id === "map") {
         exitRack();
        }
       });
      }
      
      const layersBtn = document.getElementById("layers-btn");
      const layerModal = document.getElementById("layer-modal");
      const layerModalClose = document.getElementById("layer-modal-close");
      if (layersBtn && layerModal) {
       layersBtn.addEventListener("click", () => {
        layerModal.classList.add("active");
       });
      }
      if (layerModalClose && layerModal) {
       layerModalClose.addEventListener("click", () => {
        layerModal.classList.remove("active");
       });
      }
      if (layerModal) {
       layerModal.addEventListener("click", (e) => {
        if (e.target === layerModal) {
         layerModal.classList.remove("active");
        }
       });
      }
      
      ["physical", "logical", "security", "application"].forEach(layer => {
       const checkbox = document.getElementById(`layer-${layer}`);
       if (checkbox) {
        checkbox.addEventListener("change", applyLayerFilter);
       }
      });
            
      const tabsBtn = document.getElementById("tabs-btn");
      const tabsModal = document.getElementById("tabs-modal");
      const tabsModalClose = document.getElementById("tabs-modal-close");
      
      if (tabsBtn && tabsModal) {
        tabsBtn.addEventListener("click", () => {
          displayTabs();
          tabsModal.classList.add("active");
        });
      }
      
      if (tabsModalClose && tabsModal) {
        tabsModalClose.addEventListener("click", () => {
          tabsModal.classList.remove("active");
        });
      }
      
      if (tabsModal) {
        tabsModal.addEventListener("click", (e) => {
          if (e.target === tabsModal) {
            tabsModal.classList.remove("active");
          }
        });
      }
      
      const rollbackBtn = document.getElementById("rollback-btn");
      const rollbackModal = document.getElementById("rollback-modal");
      const rollbackModalClose = document.getElementById("rollback-modal-close");
      
      if (rollbackBtn && rollbackModal) {
        rollbackBtn.addEventListener("click", () => {
          loadRollbackVersions();
          rollbackModal.classList.add("active");
        });
      }
      
      if (rollbackModalClose && rollbackModal) {
        rollbackModalClose.addEventListener("click", () => {
          rollbackModal.classList.remove("active");
        });
      }
      
      if (rollbackModal) {
        rollbackModal.addEventListener("click", (e) => {
          if (e.target === rollbackModal) {
            rollbackModal.classList.remove("active");
          }
        });
      }
      
      const auditLogBtn = document.getElementById("audit-log-btn");
      const auditLogModal = document.getElementById("audit-log-modal");
      const auditLogModalClose = document.getElementById("audit-log-modal-close");
      const auditFilter = document.getElementById("audit-filter");
      
      if (auditLogBtn && auditLogModal) {
        auditLogBtn.addEventListener("click", () => {
          loadAuditLog();
          displayAuditLog();
          auditLogModal.classList.add("active");
        });
      }
      
      if (auditFilter) {
        auditFilter.addEventListener("change", (e) => {
          displayAuditLog(e.target.value);
        });
      }
      
      if (auditLogModalClose && auditLogModal) {
        auditLogModalClose.addEventListener("click", () => {
          auditLogModal.classList.remove("active");
        });
      }
      
      if (auditLogModal) {
        auditLogModal.addEventListener("click", (e) => {
          if (e.target === auditLogModal) {
            auditLogModal.classList.remove("active");
          }
        });
      }
      
      const secretsBtn = document.getElementById("secrets-btn");
      const secretsModal = document.getElementById("secrets-modal");
      const secretsModalClose = document.getElementById("secrets-modal-close");
      const secretEditorModal = document.getElementById("secret-editor-modal");
      
      if (secretsBtn && secretsModal) {
        secretsBtn.addEventListener("click", () => {
          displaySecrets();
          secretsModal.classList.add("active");
        });
      }
      
      if (secretsModalClose && secretsModal) {
        secretsModalClose.addEventListener("click", () => {
          secretsModal.classList.remove("active");
        });
      }
      
      if (secretsModal) {
        secretsModal.addEventListener("click", (e) => {
          if (e.target === secretsModal) {
            secretsModal.classList.remove("active");
          }
        });
      }
      
      if (secretEditorModal) {
        secretEditorModal.addEventListener("click", (e) => {
          if (e.target === secretEditorModal) {
            closeSecretEditor();
          }
        });
      }
      
      loadAuditLog();
      setupDragToCreate();
      
      ["physical", "logical", "security", "application"].forEach(layer => {
       const checkbox = document.getElementById(`layer-${layer}`);
       if (checkbox) {
        checkbox.addEventListener("change", applyLayerFilter);
       }
      });
      
      const layerSelect = document.getElementById("node-layer");
      if (layerSelect) {
       layerSelect.addEventListener("change", (e) => {
        if (currentNodeId) {
         pushUndo("change layer");
         NODE_DATA[currentNodeId].layer = e.target.value;
         forgeTheTopology();
        }
       });
      }
      
       const assignedRackSelect = document.getElementById("node-assigned-rack");
       if (assignedRackSelect) {
      assignedRackSelect.addEventListener("change", (e) => {
      if (currentNodeId) {
      pushUndo("change assigned rack");
      EDGE_DATA.list = EDGE_DATA.list.filter(edge => edge.from !== currentNodeId && edge.to !== currentNodeId);
      NODE_DATA[currentNodeId].assignedRack = e.target.value;
      forgeTheTopology();
      claimTheImmortal(currentNodeId);
      }
      });
       }
      
      const rackCapacitySelect = document.getElementById("node-rack-capacity");
      if (rackCapacitySelect) {
       rackCapacitySelect.addEventListener("change", (e) => {
        if (currentNodeId) {
         pushUndo("change rack capacity");
         NODE_DATA[currentNodeId].rackCapacity = e.target.value;
         forgeTheTopology();
        }
       });
      }
      
      const bulkToolbarClose = document.getElementById("bulk-toolbar-close");
      if (bulkToolbarClose) {
       bulkToolbarClose.addEventListener("click", clearSelection);
      }
      
      const bulkAlignLeft = document.getElementById("bulk-align-left");
      if (bulkAlignLeft) {
       bulkAlignLeft.addEventListener("click", () => alignSelectedNodes("left"));
      }
      
      const bulkAlignRight = document.getElementById("bulk-align-right");
      if (bulkAlignRight) {
       bulkAlignRight.addEventListener("click", () => alignSelectedNodes("right"));
      }
      
      const bulkAlignTop = document.getElementById("bulk-align-top");
      if (bulkAlignTop) {
       bulkAlignTop.addEventListener("click", () => alignSelectedNodes("top"));
      }
      
      const bulkAlignBottom = document.getElementById("bulk-align-bottom");
      if (bulkAlignBottom) {
       bulkAlignBottom.addEventListener("click", () => alignSelectedNodes("bottom"));
      }
      
      const bulkDistributeH = document.getElementById("bulk-distribute-h");
      if (bulkDistributeH) {
       bulkDistributeH.addEventListener("click", () => distributeSelectedNodes("horizontal"));
      }
      
      const bulkDistributeV = document.getElementById("bulk-distribute-v");
      if (bulkDistributeV) {
       bulkDistributeV.addEventListener("click", () => distributeSelectedNodes("vertical"));
      }
      
      const bulkClone = document.getElementById("bulk-clone");
      if (bulkClone) {
       bulkClone.addEventListener("click", () => {
        if (selectedNodes.size === 0) return;
        pushUndo("clone selected");
        const nodesToClone = Array.from(selectedNodes);
        selectedNodes.clear();
        nodesToClone.forEach(id => {
         cloneNode(id);
         selectedNodes.add(currentNodeId);
        });
        updateNodeSelection();
       });
      }
      
      const bulkDelete = document.getElementById("bulk-delete");
      if (bulkDelete) {
       bulkDelete.addEventListener("click", deleteSelected);
      }
      
      const bulkMobileBtn = document.getElementById("bulk-mobile-btn");
      const bulkActionsModal = document.getElementById("bulk-actions-modal");
      const bulkModalClose = document.getElementById("bulk-modal-close");
      
      if (bulkMobileBtn) {
       bulkMobileBtn.addEventListener("click", () => {
        if (bulkActionsModal) bulkActionsModal.style.display = "block";
       });
      }
      
      if (bulkModalClose) {
       bulkModalClose.addEventListener("click", () => {
        if (bulkActionsModal) bulkActionsModal.style.display = "none";
       });
      }
      
      const closeModalAfterAction = () => {
       if (bulkActionsModal) bulkActionsModal.style.display = "none";
      };
      
      const bulkAlignLeftMobile = document.getElementById("bulk-align-left-mobile");
      if (bulkAlignLeftMobile) {
       bulkAlignLeftMobile.addEventListener("click", () => {
        alignSelectedNodes("left");
        closeModalAfterAction();
       });
      }
      
      const bulkAlignRightMobile = document.getElementById("bulk-align-right-mobile");
      if (bulkAlignRightMobile) {
       bulkAlignRightMobile.addEventListener("click", () => {
        alignSelectedNodes("right");
        closeModalAfterAction();
       });
      }
      
      const bulkAlignTopMobile = document.getElementById("bulk-align-top-mobile");
      if (bulkAlignTopMobile) {
       bulkAlignTopMobile.addEventListener("click", () => {
        alignSelectedNodes("top");
        closeModalAfterAction();
       });
      }
      
      const bulkAlignBottomMobile = document.getElementById("bulk-align-bottom-mobile");
      if (bulkAlignBottomMobile) {
       bulkAlignBottomMobile.addEventListener("click", () => {
        alignSelectedNodes("bottom");
        closeModalAfterAction();
       });
      }
      
      const bulkDistributeHMobile = document.getElementById("bulk-distribute-h-mobile");
      if (bulkDistributeHMobile) {
       bulkDistributeHMobile.addEventListener("click", () => {
        distributeSelectedNodes("horizontal");
        closeModalAfterAction();
       });
      }
      
      const bulkDistributeVMobile = document.getElementById("bulk-distribute-v-mobile");
      if (bulkDistributeVMobile) {
       bulkDistributeVMobile.addEventListener("click", () => {
        distributeSelectedNodes("vertical");
        closeModalAfterAction();
       });
      }
      
      const bulkCloneMobile = document.getElementById("bulk-clone-mobile");
      if (bulkCloneMobile) {
       bulkCloneMobile.addEventListener("click", () => {
        if (selectedNodes.size === 0) return;
        pushUndo("clone selected");
        const nodesToClone = Array.from(selectedNodes);
        selectedNodes.clear();
        nodesToClone.forEach(id => {
         cloneNode(id);
         selectedNodes.add(currentNodeId);
        });
        updateNodeSelection();
        closeModalAfterAction();
       });
      }
      
      const bulkDeleteMobile = document.getElementById("bulk-delete-mobile");
      if (bulkDeleteMobile) {
       bulkDeleteMobile.addEventListener("click", () => {
        deleteSelected();
        closeModalAfterAction();
       });
      }
      
      const bulkLockMobile = document.getElementById("bulk-lock-mobile");
      if (bulkLockMobile) {
       bulkLockMobile.addEventListener("click", () => {
        toggleLockSelected();
        closeModalAfterAction();
       });
      }
      
      const bulkGroupMobile = document.getElementById("bulk-group-mobile");
      if (bulkGroupMobile) {
       bulkGroupMobile.addEventListener("click", () => {
        toggleGroupSelected();
        closeModalAfterAction();
       });
      }
      
      const bulkClearMobile = document.getElementById("bulk-clear-mobile");
      if (bulkClearMobile) {
       bulkClearMobile.addEventListener("click", () => {
        clearSelection();
        closeModalAfterAction();
       });
      }
      
      const searchInput = document.getElementById("search-nodes");
      if (searchInput) {
       searchInput.addEventListener("input", (e) => {
        searchNodes(e.target.value);
       });
      }
      
      addNodeBtn.addEventListener("click", () => {
       document.getElementById("new-node-name").value = "";
       document.getElementById("new-node-ip").value = "";
       document.getElementById("new-node-tags").value = "";
       document.getElementById("new-node-shape").value = "circle";
       addNodeModal.classList.add("active");
       document.getElementById("new-node-name").focus();
      });
      
      const addRackBtn = document.getElementById("add-rack-btn");
      const addRackModal = document.getElementById("add-rack-modal");
      const addRackCancel = document.getElementById("add-rack-cancel");
      const addRackSave = document.getElementById("add-rack-save");
      
      if (addRackBtn && addRackModal) {
       addRackBtn.addEventListener("click", () => {
        document.getElementById("new-rack-name").value = "";
        document.getElementById("new-rack-ip").value = "";
        document.getElementById("new-rack-tags").value = "";
        document.getElementById("new-rack-shape").value = "server";
        document.getElementById("new-rack-capacity").value = "42";
        addRackModal.classList.add("active");
        document.getElementById("new-rack-name").focus();
       });
      }
      
      if (addRackCancel && addRackModal) {
       addRackCancel.addEventListener("click", () => {
        addRackModal.classList.remove("active");
       });
      }
      
      if (addRackModal) {
       addRackModal.addEventListener("click", (e) => {
        if (e.target === addRackModal) {
         addRackModal.classList.remove("active");
        }
       });
      }
      
      if (addRackSave && addRackModal) {
       addRackSave.addEventListener("click", () => {
        const name = document.getElementById("new-rack-name").value.trim();
        const ip = document.getElementById("new-rack-ip").value.trim();
        const tagsStr = document.getElementById("new-rack-tags").value.trim();
        const shape = document.getElementById("new-rack-shape").value;
        const capacity = document.getElementById("new-rack-capacity").value;
        
        if (!name) {
         alert("Please enter a rack name.");
         return;
        }
        
        const tags = tagsStr ? tagsStr.split(",").map((t) => t.trim()).filter((t) => t) : [];
        let baseId = name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");
        if (!baseId) baseId = "rack";
        let nodeId = baseId;
        let counter = 1;
        while (NODE_DATA[nodeId]) {
         nodeId = baseId + "-" + counter;
         counter++;
        }
        
        pushUndo("add rack");
        
        NODE_DATA[nodeId] = {
         shape: shape,
         name: name,
         ip: ip || "",
         role: "Rack",
         tags: tags,
         notes: [],
         mac: "",
         rackUnit: "",
         uHeight: "1",
         layer: "physical",
         assignedRack: "",
         rackCapacity: capacity,
         isRack: true,  
         locked: false, 
         groupId: null 
        };
        
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        const centerX = canvasState.panX + (viewWidth / 2);
        const centerY = canvasState.panY + (viewHeight / 2);
        savedPositions[nodeId] = {
         x: centerX,
         y: centerY
        };
        
        addRackModal.classList.remove("active");
        forgeTheTopology();
        claimTheImmortal(nodeId);
       });
       
       ["new-rack-name", "new-rack-ip", "new-rack-tags"].forEach((inputId) => {
        const input = document.getElementById(inputId);
        if (input) {
         input.addEventListener("keypress", (e) => {
          if (e.key === "Enter") {
           addRackSave.click();
          }
         });
        }
       });
      }
      
      addNodeCancel.addEventListener("click", () => {
       addNodeModal.classList.remove("active");
      });
      addNodeModal.addEventListener("click", (e) => {
       if (e.target === addNodeModal) {
        addNodeModal.classList.remove("active");
       }
      });
      addNodeSave.addEventListener("click", () => {
       const name = document.getElementById("new-node-name").value.trim();
       const ip = document.getElementById("new-node-ip").value.trim();
       const tagsStr = document.getElementById("new-node-tags").value.trim();
       const shape = document.getElementById("new-node-shape").value;
       if (!name) {
        alert("Please enter a node name.");
        return;
       }
       const tags = tagsStr ? tagsStr.split(",").map((t) => t.trim()).filter((t) => t) : [];
       let baseId = name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");
       if (!baseId) baseId = "node";
       let nodeId = baseId;
       let counter = 1;
       while (NODE_DATA[nodeId]) {
        nodeId = baseId + "-" + counter;
        counter++;
       }
       NODE_DATA[nodeId] = {
        shape: shape || "circle",
        name: name,
        ip: ip || "0.0.0.0",
        role: "",
        tags: tags,
        notes: [],
        mac: "",
        rackUnit: "",
        uHeight: "1",
        layer: "physical",
        assignedRack: "",  
        rackCapacity: "42",
        isRack: false, 
        locked: false, 
        groupId: null 
       };
       
       if (currentView.mode === "rack" && currentView.rackId) {
        NODE_DATA[nodeId].assignedRack = currentView.rackId;
        NODE_DATA[nodeId].layer = "physical";
        const rackCapacity = getRackCapacity(currentView.rackId);
        const rackUHeight = getRackUHeight(currentView.rackId);
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        const centerY = canvasState.panY + (viewHeight / 2);
        let unit = rackCapacity - Math.round((centerY - RACK_START_Y) / rackUHeight);
        unit = Math.max(1, Math.min(rackCapacity, unit));
        NODE_DATA[nodeId].rackUnit = String(unit);
       }
       
      const viewWidth = CANVAS_WIDTH / canvasState.zoom;
      const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
      const centerX = canvasState.panX + (viewWidth / 2);
      const centerY = canvasState.panY + (viewHeight / 2);
      savedPositions[nodeId] = {
      x: centerX,
      y: centerY
      };
       pushUndo("add node");
       addNodeModal.classList.remove("active");
       forgeTheTopology();
       claimTheImmortal(nodeId);
      });
      ["new-node-name", "new-node-ip", "new-node-tags"].forEach(
       (inputId) => {
        document.getElementById(inputId).addEventListener("keypress", (e) => {
         if (e.key === "Enter") {
          addNodeSave.click();
         }
        });
       }, );
      const clearAllBtn = document.getElementById("clear-all-btn");
      const clearAllModal = document.getElementById("clear-all-modal");
      const clearAllCancel = document.getElementById("clear-all-cancel");
      const clearAllConfirm = document.getElementById("clear-all-confirm");
      clearAllBtn.addEventListener("click", () => {
       clearAllModal.classList.add("active");
      });
      clearAllCancel.addEventListener("click", () => {
       clearAllModal.classList.remove("active");
      });
      clearAllModal.addEventListener("click", (e) => {
       if (e.target === clearAllModal) {
        clearAllModal.classList.remove("active");
       }
      });
      clearAllConfirm.addEventListener("click", () => {
       NODE_DATA = {};
       EDGE_DATA = {
        list: []
       };
       EDGE_LEGEND = {};
       RECT_DATA = { list: [] };
       TEXT_DATA = { list: [] };
       savedPositions = {};
       savedSizes = {};
       savedStyles = {};
       clearAllModal.classList.remove("active");
       forgeTheTopology();
       document.getElementById("node-panel").style.display = "none";
       document.getElementById("edge-panel").style.display = "none";
       document.getElementById("text-panel").style.display = "none";
       document.getElementById("topology-toolbar").style.display = "none";
       currentNodeId = null;
       currentEdgeId = null;
       currentTextId = null;
      });
      (function addDeleteNodeButton() {
       const nodePanel = document.getElementById("node-panel");
       if (!nodePanel) return;
       let deleteBtn = document.getElementById("delete-node-btn");
       if (!deleteBtn) {
        deleteBtn = document.createElement("button");
        deleteBtn.id = "delete-node-btn";
        deleteBtn.textContent = "Delete Node";
        deleteBtn.style.cssText = "margin-top:15px; padding:10px 16px; background:var(--danger); color:#fff; border:none; border-radius:6px; cursor:pointer; font-size:clamp(14px,1.6vw,18px); font-weight:600; width:100%;";
        nodePanel.appendChild(deleteBtn);
       }
       deleteBtn.addEventListener("click", () => {
        if (!currentNodeId) return;
        const nodeData = NODE_DATA[currentNodeId];
        let confirmMessage;
        let nodesInsideRack = [];
        
        if (nodeData?.isRack) {
         nodesInsideRack = Object.entries(NODE_DATA)
          .filter(([id, n]) => n.assignedRack === currentNodeId)
          .map(([id, n]) => n.name || id);
         if (nodesInsideRack.length > 0) {
          confirmMessage = `Delete rack "${nodeData.name}"?\n\nThis will also delete ${nodesInsideRack.length} node(s) inside:\nâ€¢ ${nodesInsideRack.join('\nâ€¢ ')}`;
         } else {
          confirmMessage = `Delete rack "${nodeData.name}"? (empty rack)`;
         }
        } else {
         confirmMessage = `Delete node "${nodeData?.name || currentNodeId}" and all its connections?`;
        }
        
        challengeTheImmortal(confirmMessage, () => {
         pushUndo("delete node");
         if (nodeData?.isRack) {
          Object.keys(NODE_DATA).forEach(id => {
           if (NODE_DATA[id]?.assignedRack === currentNodeId) {
            EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== id && e.to !== id);
            delete NODE_DATA[id];
            delete savedPositions[id];
            delete savedSizes[id];
            delete savedStyles[id];
           }
          });
         }
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== currentNodeId && e.to !== currentNodeId);
         delete NODE_DATA[currentNodeId];
         delete savedPositions[currentNodeId];
         delete savedSizes[currentNodeId];
         delete savedStyles[currentNodeId];
         currentNodeId = null;
         currentEdgeId = null;
         forgeTheTopology();
         const remainingNodes = Object.keys(NODE_DATA);
         if (remainingNodes.length > 0) {
          claimTheImmortal(remainingNodes[0]);
         } else {
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("topology-toolbar").style.display = "none";
         }
        });
       });
      })();
      
      function screenshotCanvas() {
       const svg = document.getElementById("map");
       const svgClone = svg.cloneNode(true);
       const viewBox = svg.getAttribute("viewBox").split(" ").map(Number);
       const [x, y, width, height] = viewBox;
       svgClone.setAttribute("width", width);
       svgClone.setAttribute("height", height);
       svgClone.setAttribute("viewBox", `${x} ${y} ${width} ${height}`);
       const wrapper = document.createElement("div");
       wrapper.style.position = "absolute";
       wrapper.style.left = "-9999px";
       wrapper.appendChild(svgClone);
       document.body.appendChild(wrapper);
      
       function inlineStyles(original, clone) {
        const elements = original.querySelectorAll("*");
        const clonedElements = clone.querySelectorAll("*");
        const rootStyles = getComputedStyle(document.documentElement);
        const bgColor = rootStyles.getPropertyValue("--bg").trim() || "#050608";
        const bgRect = document.createElementNS("http://www.w3.org/2000/svg", "rect", );
        bgRect.setAttribute("x", x);
        bgRect.setAttribute("y", y);
        bgRect.setAttribute("width", width);
        bgRect.setAttribute("height", height);
        bgRect.setAttribute("fill", bgColor);
        clone.insertBefore(bgRect, clone.firstChild);
        elements.forEach((el, index) => {
         const clonedEl = clonedElements[index];
         if (!clonedEl) return;
         const computedStyle = getComputedStyle(el);
         const svgProps = ["fill", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin", "opacity", "font-family", "font-size", "font-weight", "font-style", "text-anchor", "dominant-baseline", "marker-start", "marker-end", ];
         svgProps.forEach((prop) => {
          const value = computedStyle.getPropertyValue(prop);
          if (value && value !== "none" && value !== "normal") {
           clonedEl.style[prop] = value;
          }
         });
         clonedEl.removeAttribute("class");
        });
       }
       inlineStyles(svg, svgClone);
       const svgData = new XMLSerializer().serializeToString(svgClone);
       document.body.removeChild(wrapper);
       const svgBlob = new Blob([svgData], {
        type: "image/svg+xml;charset=utf-8",
       });
       const url = URL.createObjectURL(svgBlob);
       const img = new Image();
       img.onload = function() {
        const canvas = document.createElement("canvas");
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext("2d");
        ctx.drawImage(img, 0, 0);
        canvas.toBlob(function(blob) {
         const link = document.createElement("a");
         const timestamp = new Date().toISOString().slice(0, 10);
         link.download = `topology-${timestamp}.png`;
         link.href = URL.createObjectURL(blob);
         link.click();
         URL.revokeObjectURL(url);
         URL.revokeObjectURL(link.href);
        }, "image/png");
       };
       img.onerror = function() {
        console.error("Failed to load SVG image");
        alert("Screenshot failed. Please try again.");
        URL.revokeObjectURL(url);
       };
       img.src = url;
      }
      
      function exportCanvasSVG() {
       const svg = document.getElementById("map");
       const svgClone = svg.cloneNode(true);
       const viewBox = svg.getAttribute("viewBox").split(" ").map(Number);
       const [x, y, width, height] = viewBox;
       svgClone.setAttribute("width", width);
       svgClone.setAttribute("height", height);
       const rootStyles = getComputedStyle(document.documentElement);
       const bgColor = rootStyles.getPropertyValue("--bg").trim() || "#050608";
       const bgRect = document.createElementNS("http://www.w3.org/2000/svg", "rect", );
       bgRect.setAttribute("x", x);
       bgRect.setAttribute("y", y);
       bgRect.setAttribute("width", width);
       bgRect.setAttribute("height", height);
       bgRect.setAttribute("fill", bgColor);
       svgClone.insertBefore(bgRect, svgClone.firstChild);
       const wrapper = document.createElement("div");
       wrapper.style.position = "absolute";
       wrapper.style.left = "-9999px";
       wrapper.appendChild(svgClone);
       document.body.appendChild(wrapper);
       const elements = svg.querySelectorAll("*");
       const clonedElements = svgClone.querySelectorAll("*");
       elements.forEach((el, index) => {
        const clonedEl = clonedElements[index];
        if (!clonedEl) return;
        const computedStyle = getComputedStyle(el);
        const svgProps = ["fill", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin", "opacity", "font-family", "font-size", "font-weight", "font-style", "text-anchor", "dominant-baseline", "marker-start", "marker-end", ];
        svgProps.forEach((prop) => {
         const value = computedStyle.getPropertyValue(prop);
         if (value && value !== "none" && value !== "normal") {
          clonedEl.setAttribute(prop, value);
         }
        });
        clonedEl.removeAttribute("class");
       });
       const svgData = new XMLSerializer().serializeToString(svgClone);
       document.body.removeChild(wrapper);
       const blob = new Blob([svgData], {
        type: "image/svg+xml;charset=utf-8",
       });
       const url = URL.createObjectURL(blob);
       const link = document.createElement("a");
       const timestamp = new Date().toISOString().slice(0, 10);
       link.download = `topology-${timestamp}.svg`;
       link.href = url;
       link.click();
       URL.revokeObjectURL(url);
      }
      let resizeTimeout;
       window.addEventListener('resize', () => {
       clearTimeout(resizeTimeout);
       resizeTimeout = setTimeout(() => {
       updateDrawToolbarVisibility();
       updateTopologyToolbarVisibility();
       }, 100);
      });
    </script>
  
</body></html>