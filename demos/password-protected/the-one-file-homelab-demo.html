<!DOCTYPE html> 
 <html lang="en" style="--panel: #2f0e0e; --panel-alt: #10141b; --sidebar-bg: #10141b; --btn-bg: #0b0e13; --accent: #a75252; --danger: #f56565; --text-main: #e2e8f0; --text-soft: #94a3b8; --topbar-bg: rgba(9, 12, 20, 0.9); --topbar-border: #1f2533; --topbar-height: 112px; --sidebar-width: 350px; --mobile-footer-height: 40vh; --draw-toolbar-height: 0px; --btn-text: #e2e8f0; --tag-fill: #1e293b; --tag-text: #e2e8f0; --tag-border: #475569; --input-bg: #0b0e13; --input-text: #e2e8f0; --input-border: #1f2937; --input-font: Inter, system-ui, sans-serif; --input-font-size: 14px; --toolbar-bg: #441215; --toolbar-border: #1f2937; --toolbar-text: #94a3b8; --toolbar-btn-bg: #0b0e13; --toolbar-btn-text: #e2e8f0; --minimap-dots: #94a3b8; --canvas-hint-bg: #0f172a; --canvas-hint-color: #94a3b8; --node-fill: #1e293b; --node-stroke: #475569; --node-title: #e2e8f0; --node-sub: #94a3b8; --node-title-size: 18px; --node-sub-size: 13px; --node-font: Inter, system-ui, sans-serif; --default-edge: #475569; --selection-handle: #f59e0b; --selection-handle-size: 8px; --group-indicator: #4fd1c5;"><head>
    <meta charset="UTF-8">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>The One File</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!--
      * ====================================================================================
      * THE ONE FILE
      * "There can be only one". A all in one file topology maker for enterprise or homelab
      *
      * This is your last backup when all others fail. A completely self-contained
      * network topology visualization tool that works as a single HTML file.
      * Open it anywhere, anytime and the idea lives forever.
      * ====================================================================================
      -->
    <style>
      :root {
      color-scheme: dark;
      --bg: #050608;
      --panel: #0b0e13;
      --panel-alt: #10141b;
      --accent: #4fd1c5;
      --danger: #f56565;
      --text-main: #e2e8f0;
      --text-soft: #94a3b8;
      --edge-main: #475569;
      --node-min: 35px;
      --node-max: 70px;
      --topbar-bg: rgba(9, 12, 20, 0.9);
      --topbar-border: #1f2533;
      }
	  html, body, svg, .map-container {
      touch-action: none;
      }
      * {
      box-sizing: border-box;
      user-select: none;
      }
      input,
      textarea,
      [contenteditable="true"] {
      user-select: text;
      -webkit-user-select: text;
      }
      body {
      margin: 0;
      font-family: system-ui, sans-serif;
      background: radial-gradient(circle at top, #1e2532 0, #050608 70%);
      color: var(--text-main);
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
      }
      header {
      padding: 0 20px;
      height: var(--topbar-height, 52px);
      min-height: var(--topbar-height, 52px);
      background: var(--topbar-bg);
      backdrop-filter: blur(6px);
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid var(--topbar-border);
      gap: 16px;
      }
      .title-block {
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-width: 0;
      }
      header h1 {
      font-size: clamp(22px, 3vw, 32px);
      margin: 0;
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
      }
      .editable-page-title {
      cursor: pointer;
      transition: opacity 0.2s;
      }
      .editable-page-title:hover {
      opacity: 0.7;
      }
      .save-row {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      }
      .save-btn {
      padding: 6px 12px;
      background: var(--accent);
      color: var(--bg);
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      white-space: nowrap;
      }
      .save-btn:hover {
      opacity: 0.9;
      }
      .help-icon {
      width: 22px;
      height: 22px;
      border-radius: 50%;
      border: 1px solid var(--edge-main);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      cursor: pointer;
      color: var(--text-soft);
      background: rgba(15, 23, 42, 0.9);
      flex-shrink: 0;
      }
      .help-icon:hover {
      color: var(--accent);
      border-color: var(--accent);
      }
      #settings-btn {
      background: var(--btn-bg, var(--panel));
      color: var(--btn-text, var(--text-main));
      border: 1px solid var(--edge-main);
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 16px;
      flex-shrink: 0;
      }
      #settings-btn:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .header-resizer {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 6px;
      background: transparent;
      cursor: row-resize;
      z-index: 1000;
      transition: background 0.2s;
      }
      .header-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .header-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      .sidebar-resizer {
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 6px;
      background: transparent;
      cursor: col-resize;
      z-index: 1000;
      transition: background 0.2s;
      }
      .sidebar-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .sidebar-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      .mobile-footer-resizer {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 6px;
      background: transparent;
      cursor: row-resize;
      z-index: 1000;
      transition: background 0.2s;
      display: none;
      }
      .mobile-footer-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .mobile-footer-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      @media (max-width: 900px) {
      .mobile-footer-resizer {
      display: block;
      height: 12px;
      }
      .sidebar-resizer {
      display: none;
      }
      .header-resizer {
      height: 12px;
      }
      }
      @media (pointer: coarse) {
      .header-resizer {
      height: 16px;
      }
      .mobile-footer-resizer {
      height: 16px;
      }
      .sidebar-resizer {
      width: 16px;
      }
      }
      .resizer-icon {
      position: absolute;
      opacity: 0.5;
      transition: opacity 0.2s, transform 0.2s;
      pointer-events: none;
      fill: var(--accent);
      }
      .header-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .sidebar-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .mobile-footer-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .header-resizer:hover .resizer-icon,
      .sidebar-resizer:hover .resizer-icon,
      .mobile-footer-resizer:hover .resizer-icon {
      opacity: 1;
      }
      .header-resizer.resizing .resizer-icon,
      .sidebar-resizer.resizing .resizer-icon,
      .mobile-footer-resizer.resizing .resizer-icon {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1.2);
      }
      body.resizing {
      user-select: none;
      }
      body.resizing * {
      cursor: inherit !important;
      pointer-events: none;
      }
      header {
      position: relative;
      }
      .details-panel {
      position: relative;
      }
      main {
      display: grid;
      grid-template-columns: 1fr var(--sidebar-width, 350px);
      flex: 1;
      }
      main.sidebar-collapsed {
      grid-template-columns: 1fr 0;
      }
      @media (max-width: 900px) {
      main {
      grid-template-columns: 1fr;
      grid-template-rows: calc(100vh - var(--topbar-height, 52px) - var(--mobile-footer-height, 40vh)) var(--mobile-footer-height, 40vh);
      }
      main.sidebar-collapsed {
      grid-template-rows: 1fr 0;
      }
      .details-panel {
      max-height: var(--mobile-footer-height, 40vh);
      height: 100%;
      }
      }
      .topology-panel {
      background: var(--panel);
      border-right: 1px solid #111827;
      position: relative;
      overflow: hidden;
      }
      .topology-toolbar {
      position: absolute;
      top: 10px;
      right: 10px;
      display: none;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      z-index: 99;
      font-size: 13px;
      color: var(--toolbar-text, #94a3b8);
      }
      .topology-toolbar label {
      color: var(--toolbar-text, var(--text-soft));
      }
      .topology-toolbar select {
      padding: 4px 6px;
      background: var(--toolbar-btn-bg, var(--panel));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 13px;
      cursor: pointer;
      }
      .topology-toolbar button {
      padding: 4px 10px;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      }
      .topology-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .bulk-toolbar-desktop,
      .bulk-toolbar-mobile {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 9999;
      }
      .bulk-toolbar-desktop {
      position: absolute;
      top: 10px;
      right: 10px;
      bottom: auto;
      left: auto;
      transform: none;
      }
      @media (min-width: 768px) {
      .bulk-toolbar-mobile {
      display: none !important;
      }
      }
      .bulk-action-btn {
      padding: 16px;
      background: var(--panel-main);
      border: 1px solid var(--edge-main);
      border-radius: 8px;
      color: var(--text-main);
      font-size: 24px;
      cursor: pointer;
      text-align: center;
      line-height: 1.2;
      }
      .bulk-action-btn:active {
      transform: scale(0.95);
      background: var(--accent);
      }
      .draw-toolbar {
      position: absolute;
      top: 10px;
      left: 10px;
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 8px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      z-index: 99;
      font-size: 13px;
      pointer-events: auto;
      color: var(--toolbar-text, #94a3b8);
      }
      .draw-toolbar button {
      padding: 4px 8px;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      }
      .draw-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .draw-toolbar input[type="color"] {
      width: 30px;
      height: 22px;
      border-radius: 4px;
      border: 1px solid var(--edge-main);
      padding: 0;
      background: transparent;
      cursor: pointer;
      }
      .draw-toolbar select {
      padding: 4px 6px;
      background: var(--toolbar-btn-bg, var(--panel));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 13px;
      cursor: pointer;
      }
      .legend-container {
      position: absolute;
      left: 10px;
      bottom: 10px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      padding: 8px 10px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      font-size: 12px;
      z-index: 20;
      max-width: 260px;
      pointer-events: auto;
      color: var(--toolbar-text, #94a3b8);
      }
      .legend-container {
      padding-right: 22px;
      }
      @media (max-width: 900px) {
      .legend-container {
      height:250px;
      overflow-y: auto;
      z-index:99;
      }
      }
      @media (max-width: 900px) {
      .bulk-toolbar-desktop,
      .topology-toolbar {
      display: none !important;
      }
      }
      .legend-close-btn {
      position: absolute;
      top: 5px;
      right: 5px;
      width: 18px;
      height: 18px;
      border-radius: 999px;
      border: 1px solid var(--edge-main);
      background: var(--panel-alt);
      color: var(--text-soft);
      font-size: 11px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      }
      .legend-close-btn:hover {
      background: var(--danger);
      color: #fff;
      }
      .legend-mini-btn {
      position: absolute;
      left: 10px;
      padding: 4px 8px;
      border-radius: 4px;
      border: 1px solid var(--toolbar-border, #1f2937);
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 11px;
      cursor: pointer;
      z-index: 20;
      display: none;
      transition: all 0.2s;
      }
      .legend-mini-btn:hover,
      .legend-mini-btn:active {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
      }
      .legend-title {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: var(--toolbar-text, var(--text-soft));
      margin-bottom: 2px;
      }
      .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      }
      .legend-swatch {
      width: 14px;
      height: 14px;
      border-radius: 3px;
      border: 1px solid #020617;
      flex-shrink: 0;
      }
      .legend-label {
      outline: none;
      cursor: text;
      flex: 1;
      min-width: 60px;
      user-select: text;
      -webkit-user-select: text;
      }
      .legend-label.editing {
      border-bottom: 1px dashed var(--accent);
      }
      .canvas-viewport {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      overflow: hidden;
      }
      .canvas-viewport.panning {
      cursor: grabbing !important;
      }
      .canvas-viewport.panning * {
      cursor: grabbing !important;
      }
      .canvas-viewport svg {
      width: 100%;
      height: 100%;
      display: block;
      background: linear-gradient(rgba(71, 85, 105, 0.1) 1px,
      transparent 1px),
      linear-gradient(90deg,
      rgba(71, 85, 105, 0.1) 1px,
      transparent 1px),
      linear-gradient(rgba(71, 85, 105, 0.05) 1px, transparent 1px),
      linear-gradient(90deg,
      rgba(71, 85, 105, 0.05) 1px,
      transparent 1px);
      background-size:
      100px 100px,
      100px 100px,
      20px 20px,
      20px 20px;
      background-position:
      -1px -1px,
      -1px -1px,
      -1px -1px,
      -1px -1px;
      }
      .zoom-toolbar {
      display: flex;
      gap: 4px;
      padding: 6px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      }
      .zoom-toolbar button {
      width: 32px;
      height: 32px;
      padding: 0;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 18px;
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
      }
      .zoom-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .zoom-toolbar .zoom-level {
      font-size: 11px;
      color: var(--toolbar-text, var(--text-soft));
      text-align: center;
      padding: 2px 0;
      min-width: 32px;
      }
      .zoom-toolbar .divider {
      height: 1px;
      background: var(--toolbar-border, var(--edge-main));
      margin: 2px 0;
      }
      .minimap-zoom-wrapper {
      position: absolute;
      bottom: 10px;
      right: 10px;
      z-index: 99;
      }
      .minimap-container {
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      overflow: hidden;
      margin-bottom: 4px;
      }
      .minimap-container svg {
      width: 100%;
      height: 100%;
      }
      .minimap-viewport {
      fill: rgba(79, 209, 197, 0.2);
      stroke: var(--accent);
      stroke-width: 2;
      cursor: move;
      }
      .minimap-node {
      fill: var(--minimap-dots, var(--text-soft));
      }
      .minimap-edge {
      stroke: var(--edge-main);
      stroke-width: 1;
      }
      .minimap-close-btn {
      position: absolute;
      top: 2px;
      right: 2px;
      width: 18px;
      height: 18px;
      background: var(--toolbar-btn-bg, rgba(15, 23, 42, 0.9));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 3px;
      color: var(--toolbar-text, var(--text-soft));
      font-size: 11px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
      padding: 0;
      line-height: 1;
      }
      .minimap-close-btn:hover {
      background: var(--danger);
      color: white;
      border-color: var(--danger);
      }
      .toolbar-close-btn {
      width: 24px;
      height: 24px;
      background: var(--toolbar-btn-bg, rgba(15, 23, 42, 0.9));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-text, var(--text-soft));
      font-size: 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      line-height: 1;
      flex-shrink: 0;
      }
      .toolbar-close-btn:hover {
      background: var(--danger);
      color: white;
      border-color: var(--danger);
      }
      .canvas-hint {
      position: absolute;
      top: 50px;
      left: 50%;
      transform: translateX(-50%);
      padding: 8px 16px;
      background: rgba(15, 23, 42, 0.92);
      border: 1px solid #1f2937;
      border-radius: 6px;
      font-size: 12px;
      color: var(--text-soft);
      z-index: 18;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
      }
      .canvas-hint.visible {
      opacity: 1;
      }
      .edge {
      stroke: var(--edge-main);
      stroke-width: 4;
      opacity: 0.75;
      transition: 0.25s ease-in-out;
      cursor: pointer;
      }
      .edge.backup {
      stroke: var(--danger);
      stroke-width: 5;
      }
      .edge.active {
      opacity: 1;
      stroke-width: 7;
      filter: drop-shadow(0 0 8px var(--accent, #4fd1c5));
      }
      .rect-group.active .rect-shape {
      filter: drop-shadow(0 0 10px var(--accent, #4fd1c5));
      animation: pulse 1.2s infinite ease-in-out;
      }
      .text-element.active {
      filter: drop-shadow(0 0 10px var(--accent, #4fd1c5));
      animation: pulse 1.2s infinite ease-in-out;
      }
      .free-preview {
      fill: none;
      stroke-dasharray: 4 4;
      pointer-events: none;
      }
      .free-point {
      fill: #e5e7eb;
      stroke: #0f172a;
      stroke-width: 1.5;
      cursor: grab;
      }
      .node-circle {
      fill: var(--node-fill, #1e293b);
      stroke: var(--node-stroke, #475569);
      stroke-width: 2;
      transition: 0.25s ease;
      transform-origin: center center;
      }
      .node-hit-area {
      cursor: grab;
      pointer-events: all;
      }
      .node-group:hover .node-circle {
      filter: drop-shadow(0 0 10px rgba(79, 209, 197, 0.45));
      }
      .node-group.active .node-circle {
      stroke: var(--accent);
      animation: pulse 1.2s infinite ease-in-out;
      }
      .node-group.selected .node-circle {
      stroke: var(--selection-handle, #f59e0b);
      stroke-width: 3;
      }
      .node-group.search-highlight .node-circle {
      stroke: #10b981;
      stroke-width: 3;
      filter: drop-shadow(0 0 8px #10b981);
      }
	  .node-group.search-faded {
		opacity: 0.15;
		pointer-events: none;
		}
		.edge-group.search-faded {
		opacity: 0.1;
		}
	  .node-group.search-faded {
      opacity: 0.15;
      pointer-events: none;
      }
      .edge-group.search-faded {
      opacity: 0.1;
      }
      @keyframes pulse {
      0% {
      filter: drop-shadow(0 0 4px #4fd1c5);
      }
      50% {
      filter: drop-shadow(0 0 14px #4fd1c5);
      }
      100% {
      filter: drop-shadow(0 0 4px #4fd1c5);
      }
      }
      .node-label {
      fill: var(--text-main);
      font-size: 18px;
      text-anchor: middle;
      font-weight: 600;
      }
      .node-sub {
      fill: var(--text-soft);
      font-size: 13px;
      text-anchor: middle;
      }
      @media (max-width: 1024px) {
      .node-label {
      font-size: 28px;
      }
      .node-sub {
      font-size: 20px;
      }
      }
      @media (max-width: 768px) {
      .node-label {
      font-size: 70px;
      }
      .node-sub {
      font-size: 50px;
      }
      }
      @media (max-width: 380px) {
      .node-label {
      font-size: 60px;
      }
      .node-sub {
      font-size: 42px;
      }
      }
      .details-panel {
      background: var(--sidebar-bg, var(--panel-alt));
      padding: 22px;
      padding-bottom: 80px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 15px;
      position: relative;
      transition:
      width 0.3s ease,
      min-width 0.3s ease,
      padding 0.3s ease,
      opacity 0.3s ease;
      }
      .details-panel {
      min-width: 260px !important;
      }
      .details-panel {
      overflow-y: auto !important;
      overflow-x: hidden;
      }
      .details-panel.collapsed {
      width: 0 !important;
      min-width: 0 !important;
      padding: 0 !important;
      overflow: hidden;
      opacity: 0;
      }
      body {
      overflow-x: hidden;
      overflow-y: hidden;
      }
      main {
      overflow-x: hidden;
      overflow-y: visible;
      }
      .details-panel {
      overflow-y: auto !important;
      overflow-x: hidden;
      }
      .details-panel.collapsed {
      min-width: 0 !important;
      }
      .sidebar-toggle {
      position: absolute;
      left: -16px;
      top: 50%;
      transform: translateY(-50%);
      width: 16px;
      height: 60px;
      background: var(--sidebar-bg, var(--panel-alt));
      border: 1px solid var(--edge-main);
      border-right: none;
      border-radius: 8px 0 0 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text-soft);
      font-size: 10px;
      z-index: 25;
      transition:
      background 0.2s,
      color 0.2s;
      }
      .sidebar-toggle:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .sidebar-toggle.collapsed {
      left: 0;
      border-right: 1px solid var(--edge-main);
      border-radius: 0 8px 8px 0;
      position: fixed;
      right: 0;
      left: auto;
      }
      .details-name {
      font-size: clamp(22px, 2.5vw, 30px);
      font-weight: 700;
      }
      .details-ip {
      font-size: clamp(16px, 2vw, 22px);
      color: var(--text-soft);
      }
      .details-role {
      font-size: clamp(16px, 2vw, 22px);
      color: var(--accent);
      }
      .details-info-row {
      display: flex;
      align-items: center;
      margin: 6px 0;
      }
      .size-controls {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-top: 10px;
      }
      .size-controls label {
      font-size: clamp(14px, 1.6vw, 18px);
      color: var(--text-soft);
      }
      .size-controls input[type="range"] {
      flex: 1;
      accent-color: var(--accent);
      }
      .size-controls button {
      padding: 6px 12px;
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      font-size: clamp(12px, 1.4vw, 16px);
      }
      .size-controls button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .style-section {
      margin-top: 15px;
      padding-top: 15px;
      border-top: 1px solid var(--edge-main);
      }
      .style-section summary {
      cursor: pointer;
      font-size: clamp(14px, 1.6vw, 20px);
      text-transform: uppercase;
      color: var(--text-soft);
      list-style: none;
      display: flex;
      justify-content: space-between;
      align-items: center;
      user-select: none;
      }
      .style-section summary::-webkit-details-marker {
      display: none;
      }
      .password-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #ffffff;
      z-index: 9999;
      }
      .style-section summary::after {
      content: "▼";
      transition: transform 0.2s;
      }
      .style-section[open] summary::after {
      transform: rotate(180deg);
      }
      .style-content {
      margin-top: 10px;
      }
      .style-row {
      display: flex;
      gap: 10px;
      align-items: center;
      margin: 8px 0;
      }
      .style-row label {
      font-size: clamp(13px, 1.5vw, 17px);
      color: var(--text-soft);
      min-width: 80px;
      }
      .style-row input[type="color"] {
      width: 50px;
      height: 30px;
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      background: transparent;
      }
      .style-row input[type="number"] {
      width: 70px;
      padding: 4px 8px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(12px, 1.4vw, 16px);
      }
      .style-row select {
      flex: 1;
      padding: 4px 8px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(12px, 1.4vw, 16px);
      cursor: pointer;
      }
      .editable-text {
      cursor: pointer;
      transition: opacity 0.2s;
      }
      .editable-text:hover {
      opacity: 0.7;
      }
      .modal {
	  display: none;
	  position: fixed;
	  top: 0;
	  left: 0;
	  width: 100%;
	  height: 100%;
	  z-index: 999999;
	  justify-content: center;
	  align-items: center;
	  overflow: auto;
	  }
	  .modal.active {
	  display: inline-grid;
	  }
	  .modal-content {
	  background: var(--panel-alt);
	  padding: 25px;
	  border-radius: 8px;
	  border: 1px solid var(--edge-main);
	  min-width: 300px;
	  max-width: 90%;
	  }
      .modal-content h3 {
      margin: 0 0 15px 0;
      color: var(--text-main);
      font-size: clamp(18px, 2vw, 24px);
      }
      .modal-content p {
      color: var(--text-soft);
      font-size: clamp(14px, 1.6vw, 18px);
      margin: 0 0 20px 0;
      }
      .modal-content input:not([type="color"]),
      .modal-content select {
      width: 100%;
      padding: 10px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(14px, 1.6vw, 18px);
      margin-bottom: 15px;
      user-select: text;
      -webkit-user-select: text;
      }
      .modal-content input[type="color"] {
      width: 60px;
      height: 36px;
      padding: 2px;
      border: 2px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      background: none;
      -webkit-appearance: none;
      appearance: none;
      }
      .modal-content input[type="color"]::-webkit-color-swatch-wrapper {
      padding: 0;
      }
      .modal-content input[type="color"]::-webkit-color-swatch {
      border: none;
      border-radius: 4px;
      }
      .modal-buttons {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
      margin-top: 10px;
      }
      .modal-buttons button {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: clamp(14px, 1.6vw, 18px);
      font-weight: 600;
      }
      .modal-buttons .btn-cancel {
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      }
      .modal-buttons .btn-save {
      background: var(--accent);
      color: var(--bg);
      }
      .modal-buttons .btn-delete {
      background: var(--danger);
      color: white;
      }
      .confirm-modal p {
      color: var(--text-soft);
      font-size: clamp(14px, 1.6vw, 18px);
      margin: 0 0 20px 0;
      }
      .context-menu-item {
      transition: background 0.15s;
      }
      .context-menu-item:hover {
      background: var(--panel);
      }
      .badge-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      }
      .badge {
      background: var(--tag-fill, #1e293b);
      color: var(--tag-text, #e2e8f0);
      border: 1px solid var(--tag-border, var(--edge-main));
      padding: 5px 12px;
      border-radius: 22px;
      font-size: clamp(12px, 1.4vw, 18px);
      }
      .badge.wg {
      color: var(--accent);
      border-color: var(--accent);
      }
      input[type="text"],
      input[type="number"],
      input[type="password"],
      textarea,
      select {
      background: var(--input-bg, #0b0e13) !important;
      color: var(--input-text, #e2e8f0) !important;
      border-color: var(--input-border, #1f2937) !important;
      font-family: var(--input-font, Inter, system-ui, sans-serif) !important;
      font-size: var(--input-font-size, 14px) !important;
      }
      .section-label {
      margin-top: 8px;
      font-size: clamp(14px, 1.6vw, 20px);
      text-transform: uppercase;
      color: var(--text-soft);
      }
      .list li {
      margin: 6px 0;
      font-size: clamp(14px, 1.6vw, 20px);
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      }
      .list li:hover {
      color: var(--accent);
      }
      .delete-note {
      color: var(--danger);
      font-size: 18px;
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.2s;
      flex-shrink: 0;
      }
      .list li:hover .delete-note {
      opacity: 1;
      }
      .editing {
      outline: 2px solid var(--accent);
      background: #0d141f;
      padding: 4px;
      border-radius: 6px;
      user-select: text;
      -webkit-user-select: text;
      }
      .version-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .version-item:hover {
      background: var(--panel-alt);
      border-color: var(--accent);
      }
      .version-item.current {
      border-color: var(--accent);
      background: rgba(79, 209, 197, 0.1);
      }
      .version-info {
      flex: 1;
      }
      .version-info .timestamp {
      font-size: 13px;
      color: var(--text-main);
      font-weight: 600;
      }
      .version-info .details {
      font-size: 11px;
      color: var(--text-soft);
      margin-top: 4px;
      }
      .version-actions {
      display: flex;
      gap: 6px;
      }
      .audit-entry {
      padding: 8px 12px;
      background: var(--panel);
      border-left: 3px solid var(--edge-main);
      border-radius: 4px;
      font-size: 12px;
      }
      .audit-entry.node { border-left-color: #4fd1c5; }
      .audit-entry.connection { border-left-color: #9f7aea; }
      .audit-entry.style { border-left-color: #ed8936; }
      .audit-entry.rack { border-left-color: #48bb78; }
      .audit-entry.layer { border-left-color: #4299e1; }
      .audit-entry .time {
      color: var(--text-soft);
      font-size: 10px;
      }
      .audit-entry .action {
      color: var(--text-main);
      font-weight: 500;
      }
      .tab-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .tab-item:hover {
      background: var(--panel-alt);
      }
      .tab-item.active {
      border-color: var(--accent);
      background: rgba(79, 209, 197, 0.1);
      }
      .tab-item .tab-name {
      font-weight: 600;
      color: var(--text-main);
      flex: 1;
      }
      .tab-item .tab-stats {
      font-size: 11px;
      color: var(--text-soft);
      margin-right: 10px;
      }
      .tab-actions {
      display: flex;
      gap: 6px;
      }
      .secret-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      border-left: 3px solid var(--danger);
      }
      .secret-item .secret-name {
      font-weight: 600;
      color: var(--text-main);
      flex: 1;
      }
      .secret-item .secret-status {
      font-size: 11px;
      color: var(--text-soft);
      margin-right: 10px;
      }
      .mobile-menu-btn {
      display: none;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      color: var(--text-main);
      font-size: 22px;
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      }
      #topbar-menu {
      gap: 8px;
      }
      @media (min-width: 721px) {
      #topbar-menu {
      display: flex !important;
      }
      }
      @media (max-width: 720px) {
      #topbar-menu {
      display: none;
      }
      #topbar-menu.open {
      display: flex;
      }
      }
      @media (max-width: 720px) {
      .mobile-menu-btn {
      display: block;
      }
      #topbar-menu {
      position: absolute;
      top: var(--topbar-height);
      right: 0;
      background: var(--panel-alt);
      border-left: 1px solid var(--topbar-border);
      border-bottom: 1px solid var(--topbar-border);
      padding: 12px;
      display: none;
      flex-direction: column;
      width: 180px;
      z-index: 999;
      }
      #topbar-menu.open {
      display: flex;
      }
      header {
      position: relative;
      z-index: 9999;
      }
      }
      @media (max-width: 720px) {
      .draw-toolbar {
      position: absolute;
      top: auto;
      bottom: auto;
      left: 10px !important;
      right: auto !important;
      width: auto;
      gap: 6px;
      padding: 8px;
      }
      .topology-toolbar {
      position: absolute;
      top: auto;
      bottom: auto;
      width: auto;
      gap: 6px;
      padding: 8px;
      }
      .draw-toolbar {
      top: 10px !important;
      z-index:99;
      }
      .topology-toolbar {
      z-index:99;
      top: calc(10px + var(--draw-toolbar-height, 50px)) !important;
      }
      .canvas-hint {
      top: calc(10px + 120px);
      }
      #search-input {
      width: 100%;
      }
      }
	  body.view-only-mode:not(.view-only-inspect) #node-panel,
      body.view-only-mode:not(.view-only-inspect) #edge-panel,
      body.view-only-mode:not(.view-only-inspect) #text-panel,
      body.view-only-mode:not(.view-only-inspect) #rect-panel {
        display: none !important;
      }
      body.view-only-mode .node-group,
      body.view-only-mode .edge,
      body.view-only-mode .rect-group,
      body.view-only-mode .text-element {
        cursor: default !important;
      }
      body.view-only-mode #bulk-toolbar,
      body.view-only-mode #bulk-toolbar-mobile,
      body.view-only-mode #bulk-actions-modal {
        display: none !important;
      }
      body.view-only-mode::after {
        content: "VIEW ONLY • tap 5× to inspect";
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(245, 101, 101, 0.9);
        color: white;
        padding: 6px 16px;
        border-radius: 20px;
        font-size: 12px;
        font-weight: 600;
        letter-spacing: 1px;
        z-index: 9999;
        pointer-events: none;
      }
    </style>
  </head>
  <body style="background: radial-gradient(circle at center top, rgb(30, 37, 50) 0px, rgb(5, 6, 8) 70%);" class="">
    <div class="modal" id="edit-modal">
      <div class="modal-content">
        <h3 id="modal-title">Edit Title</h3>
        <input type="text" id="modal-input">
        <div class="modal-buttons">
          <button class="btn-cancel" id="modal-cancel">Cancel</button>
          <button class="btn-save" id="modal-save">Save</button>
        </div>
      </div>
    </div>
    <div class="modal confirm-modal" id="confirm-modal">
      <div class="modal-content">
        <h3>Confirm</h3>
        <p id="confirm-message"> Are you sure you want to delete this line? </p>
        <div class="modal-buttons">
          <button class="btn-cancel" id="confirm-cancel">Cancel</button>
          <button class="btn-delete" id="confirm-delete">Delete</button>
        </div>
      </div>
    </div>
    <div class="modal" id="save-info-modal">
      <div class="modal-content" style="max-width: 700px; max-height: 80vh; overflow-y: auto;">
        <h3 style="margin-bottom: 16px;">Help</h3>
        <div style="display: flex; gap: 8px; margin-bottom: 16px; flex-wrap: wrap;">
          <button class="help-tab active" data-tab="general" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--accent); color: var(--bg); border-radius: 6px; cursor: pointer; font-weight: 600;">General</button>
          <button class="help-tab" data-tab="desktop" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--panel); color: var(--text-main); border-radius: 6px; cursor: pointer; font-weight: 600;">Desktop</button>
          <button class="help-tab" data-tab="mobile" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--panel); color: var(--text-main); border-radius: 6px; cursor: pointer; font-weight: 600;">Mobile</button>
        </div>
        <div id="help-tab-general" class="help-tab-content" style="display: block;">
          <ul style="margin-left: 20px; margin-bottom: 12px; line-height: 1.8;">
            <li><strong>Add Nodes:</strong> Click "+ Node" or "+ Rack" in the top menu</li>
            <li><strong>Connect Nodes:</strong> Select a node, then use "Add Connection" in the panel</li>
            <li><strong>Move Nodes:</strong> Drag nodes to reposition them</li>
            <li><strong>Enter Rack View:</strong> Double click on desktop or Long press on mobile</li>
            <li><strong>Multi Select:</strong> Right click (desktop) or double tap (mobile)</li>
            <li><strong>Pan Canvas:</strong> Drag empty space or hold Space + drag</li>
            <li><strong>Zoom:</strong> Scroll wheel or pinch gesture</li>
            <li><strong>Free Draw:</strong> Use draw toolbar for drawing lines, boxes/zones , and text</li>
          </ul>
          <h4 style="color: var(--accent); margin-bottom: 8px;">Saving &amp; Encryption</h4>
          <p style="margin-bottom: 8px;">Browsers cannot overwrite local files. Click <strong>Save File</strong> to download an updated HTML with all changes. Replace your old file to keep edits.</p>
          <p style="margin-bottom: 8px;"><strong>Encryption of data:</strong> Check "Encrypt" before saving to password protect your data. Beware! No recovery possible without password!!</p>
          <p><strong>Decryption of data:</strong> Export via JSON in top settings menu after successful password validation to decrypt your data. You can then reimport back into the same file and save!</p>
        </div>
        <div id="help-tab-desktop" class="help-tab-content" style="display: none;">
          <h4 style="color: var(--accent); margin-bottom: 12px;">Navigation</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Arrow Keys</code></td>
              <td style="padding: 8px;">Move selected 1px</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Shift + Arrows</code></td>
              <td style="padding: 8px;">Move selected 10px</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Tab / Shift+Tab</code></td>
              <td style="padding: 8px;">Cycle through nodes</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">F</code></td>
              <td style="padding: 8px;">Focus on selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Space + Drag</code></td>
              <td style="padding: 8px;">Pan canvas</td>
            </tr>
          </tbody></table>
          <h4 style="color: var(--accent); margin-bottom: 12px;">Management</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">L</code></td>
              <td style="padding: 8px;">Lock/unlock selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">G</code></td>
              <td style="padding: 8px;">Group/ungroup selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+C / Ctrl+V</code></td>
              <td style="padding: 8px;">Copy / Paste</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+D</code></td>
              <td style="padding: 8px;">Duplicate</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+A</code></td>
              <td style="padding: 8px;">Select all</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Delete</code></td>
              <td style="padding: 8px;">Delete selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Escape</code></td>
              <td style="padding: 8px;">Clear selection</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+Z / Ctrl+Y</code></td>
              <td style="padding: 8px;">Undo / Redo</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Right Click</code></td>
              <td style="padding: 8px;">Multi select toggle</td>
            </tr>
          </tbody></table>
        </div>
        <div id="help-tab-mobile" class="help-tab-content" style="display: none;">
          <h4 style="color: var(--accent); margin-bottom: 12px;">Basic Gestures</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Tap node</strong></td>
              <td style="padding: 8px;">Select &amp; open properties</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Tap empty</strong></td>
              <td style="padding: 8px;">Deselect all</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Drag node</strong></td>
              <td style="padding: 8px;">Move node</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Drag empty</strong></td>
              <td style="padding: 8px;">Pan canvas</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Pinch</strong></td>
              <td style="padding: 8px;">Zoom in/out</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Double-tap node</strong></td>
              <td style="padding: 8px;">Add/remove from selection</td>
            </tr>
          </tbody></table>
          <h4 style="color: var(--accent); margin-bottom: 12px;">Rack View</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Long-press rack</strong></td>
              <td style="padding: 8px;">Enter rack view</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Double-tap empty</strong></td>
              <td style="padding: 8px;">Exit rack view</td>
            </tr>
          </tbody></table>
        </div>
        <div class="modal-buttons" style="margin-top: 16px;">
          <button class="btn-cancel" id="save-info-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="settings-modal">
      <div class="modal-content">
        <h2>Settings</h2>
		<details class="style-section">
          <summary>View Only Mode</summary>
          <div class="style-content">
            <div class="style-row">
              <label>View Only (disable editing)</label>
              <input type="checkbox" id="view-only-mode" style="width:auto;">
            </div>
            <p style="margin-top:4px;font-size:12px;color:var(--text-soft);">When enabled, all editing of the canvas is disabled. Pan and zoom still work.</p>
          </div>
        </details>
        <details class="style-section">
          <summary>General Theme</summary>
          <div class="style-content">
		    <div class="style-row">
              <label>Main Background</label>
              <input type="color" id="panel-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Modal Window (popup) Background</label>
              <input type="color" id="panel-alt-color" value="#10141b">
            </div>
            <div class="style-row">
              <label>Accent Buttons</label>
              <input type="color" id="accent-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Danger Buttons</label>
              <input type="color" id="danger-color" value="#f56565">
            </div>
            <div class="style-row">
              <label>Primary Text</label>
              <input type="color" id="text-main-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Secondary Text</label>
              <input type="color" id="text-soft-color" value="#94a3b8">
            </div>
          </div>
        </details>
		<details class="style-section">
          <summary>Top Bar</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="topbar-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="topbar-border-color" value="#1f2533">
            </div>
          </div>
		  <div class="style-content">
            <div class="style-row">
              <label>Button Fill</label>
              <input type="color" id="btn-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Button Text</label>
              <input type="color" id="btn-text-color" value="#e2e8f0">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Main Canvas</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="canvas-border-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Grid Lines</label>
              <input type="color" id="canvas-grid-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Grid Size</label>
              <input type="number" id="canvas-grid-size" value="50" min="20" max="200" style="width:60px;">
            </div>
			<div class="style-row">
              <label>Background Top</label>
              <input type="color" id="canvas-gradient-top" value="#1e2532">
            </div>
            <div class="style-row">
              <label>Background Bottom</label>
              <input type="color" id="canvas-gradient-bottom" value="#050608">
            </div>
            <div class="style-row">
              <label>Solid Background</label>
              <input type="color" id="page-bg-color" value="#050608">
            </div>
            <p style="margin-top:4px;font-size:12px;color:var(--text-soft);">Set solid background to override gradient.</p>
          </div>
			</details>
		  <details class="style-section">
          <summary>Rack Canvas</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Frame Fill</label>
              <input type="color" id="rack-frame-fill" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Frame Border</label>
              <input type="color" id="rack-frame-stroke" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Grid Lines</label>
              <input type="color" id="rack-line-color" value="#475569">
            </div>
            <div class="style-row">
              <label>U Labels</label>
              <input type="color" id="rack-text-color" value="#4fd1c5">
            </div>
          </div>
        </details>
		        <details class="style-section">
          <summary>Canvas Toolbars</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="toolbar-bg-color" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="toolbar-border-color" value="#1f2937">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="toolbar-text-color" value="#94a3b8">
            </div>
            <div class="style-row">
              <label>Button Fill</label>
              <input type="color" id="toolbar-btn-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Button Text</label>
              <input type="color" id="toolbar-btn-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Minimap Dots</label>
              <input type="color" id="minimap-dots-color" value="#94a3b8">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Nodes</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Fill</label>
              <input type="color" id="node-fill-color" value="#1e293b">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="node-stroke-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Title Color</label>
              <input type="color" id="node-title-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Title Size</label>
              <input type="number" id="node-title-size" value="18" min="8" max="48" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Subtitle Color</label>
              <input type="color" id="node-sub-color" value="#94a3b8">
            </div>
            <div class="style-row">
              <label>Subtitle Size</label>
              <input type="number" id="node-sub-size" value="13" min="8" max="48" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Font</label>
              <select id="node-font-family" style="flex:1;padding:4px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;">
                <option value="Inter, system-ui, sans-serif">Inter</option>
                <option value="Arial, sans-serif">Arial</option>
                <option value="Helvetica, sans-serif">Helvetica</option>
                <option value="Georgia, serif">Georgia</option>
                <option value="monospace">Monospace</option>
              </select>
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Connections</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Default Color</label>
              <input type="color" id="default-edge-color" value="#475569">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Groups &amp; Editing</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Resize handle Color</label>
              <input type="color" id="selection-handle-color" value="#f59e0b">
            </div>
            <div class="style-row">
              <label>Resize Handle Size</label>
              <input type="number" id="selection-handle-size" value="8" min="4" max="16" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Grouped Icon Outline</label>
              <input type="color" id="group-indicator-color" value="#4fd1c5">
            </div>
          </div>
		   <div class="style-content">
            <div class="style-row">
              <label>Multiselect Fill Color (Desktop)</label>
              <input type="color" id="selection-fill-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Multiselect Fill Opacity (Desktop)</label>
              <input type="range" id="selection-fill-opacity" min="0" max="1" step="0.05" value="0.1">
              <span id="selection-fill-opacity-val" style="min-width:35px;text-align:right;">10%</span>
            </div>
            <div class="style-row">
              <label>Multiselect Border Color (Desktop)</label>
              <input type="color" id="selection-stroke-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Multiselect Border Width (Desktop)</label>
              <input type="number" id="selection-stroke-width" min="1" max="10" value="2">
            </div>
            <div class="style-row">
              <label>Multiselect Border Style (Desktop)</label>
              <select id="selection-stroke-style">
                <option value="5,5">Dashed</option>
                <option value="2,4">Dotted</option>
                <option value="none">Solid</option>
              </select>
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Inputs &amp; Dropdowns</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="input-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="input-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="input-border-color" value="#1f2937">
            </div>
            <div class="style-row">
              <label>Font</label>
              <select id="input-font-family" style="flex:1;padding:4px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;">
                <option value="Inter, system-ui, sans-serif">Inter</option>
                <option value="Arial, sans-serif">Arial</option>
                <option value="Helvetica, sans-serif">Helvetica</option>
                <option value="Georgia, serif">Georgia</option>
                <option value="monospace">Monospace</option>
              </select>
            </div>
            <div class="style-row">
              <label>Font Size</label>
              <input type="number" id="input-font-size" value="14" min="10" max="24" style="width:60px;">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Welcome Message</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Enabled</label>
              <input type="checkbox" id="canvas-hint-enabled" checked="" style="width:auto;">
            </div>
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="canvas-hint-bg-color" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Text Color</label>
              <input type="color" id="canvas-hint-text-color" value="#94a3b8">
            </div>
            <div class="style-row" style="flex-direction:column;align-items:stretch;">
              <label>Custom Text (HTML)</label>
              <textarea id="canvas-hint-text" rows="4" style="width:100%;margin-top:4px;padding:6px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;font-size:12px;resize:vertical;" placeholder="Leave empty for default"></textarea>
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Sidebar / Mobile Footer</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="sidebar-bg-color" value="#10141b">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Tags</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Fill</label>
              <input type="color" id="tag-fill-color" value="#1e293b">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="tag-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="tag-border-color" value="#475569">
            </div>
          </div>
        </details>
        <details class="style-section" open="">
          <summary>Import / Export / Upgrade JSON</summary>
          <div class="style-content">
            <button id="export-data-btn" style="width:100%;margin-bottom:10px;padding:10px;background:var(--accent);color:var(--bg);border:none;border-radius:6px;cursor:pointer;font-size:14px;font-weight:600;">Export JSON</button>
            <button id="import-data-btn" style="width:100%;padding:10px;background:var(--panel);color:var(--text-main);border:1px solid var(--edge-main);border-radius:6px;cursor:pointer;font-size:14px;font-weight:600;">Import JSON</button>
            <input type="file" id="import-data-file" accept=".json" style="display:none">
          </div>
        </details>
        <details class="style-section" open="">
          <summary>Danger Zone</summary>
          <div class="style-content">
            <p style="margin-bottom:12px;font-size:13px;color:var(--text-soft);">Permanently delete everything on the canvas.</p>
            <button id="clear-all-btn" title="Clear all nodes" style="padding:6px 12px;background:var(--danger);color:#fff;border:none;border-radius:6px;cursor:pointer;font-size:14px;font-weight:600;">Clear All</button>
            <input type="file" id="import-data-file" accept=".json" style="display:none">
          </div>
        </details>
        <div class="modal-buttons">
          <button class="btn-cancel" id="settings-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="add-node-modal">
      <div class="modal-content">
        <h3>Add New Node</h3>
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Name</label>
        <input type="text" id="new-node-name" placeholder="e.g. web-server">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">IP / Subtitle</label>
        <input type="text" id="new-node-ip" placeholder="e.g. 192.168.1.100">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Tags (comma separated)</label>
        <input type="text" id="new-node-tags" placeholder="e.g. Docker, nginx, WG: vpn">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Shape</label>
        <select id="new-node-shape">
                  <optgroup label="Basic Shapes">
				  <option value="circle">Circle</option>
				  <option value="square">Square</option>
				  <option value="rectangle">Rectangle</option>
				  <option value="triangle">Triangle</option>
				  <option value="hexagon">Hexagon</option>
				  <option value="diamond">Diamond</option>
				  <option value="star">Star</option>
				  <option value="stop-sign">Stop Sign</option>
				  <option value="octagon">Octagon</option>
				  <option value="pentagon">Pentagon</option>
				  <option value="cross">Cross</option>
				  <option value="rounded-square">Rounded Square</option>
				  <option value="pill">Pill</option>
				  <option value="parallelogram">Parallelogram</option>
				  <option value="trapezoid">Trapezoid</option>
				</optgroup>
			  <optgroup label="Computers &amp; Devices">
			      <option value="server">Server</option>
				  <option value="pc">PC / Desktop</option>
				  <option value="laptop">Laptop</option>
				  <option value="phone">Phone / Mobile</option>
				  <option value="printer">Printer</option>
				  <option value="pi">Raspberry Pi</option>
				  <option value="sensor">Sensor / IoT</option>
			  </optgroup>
			  <optgroup label="Network Equipment">
				  <option value="router">Router</option>
				  <option value="switch">Switch</option>
				  <option value="firewall">Firewall</option>
				  <option value="access-point">Access Point</option>
				  <option value="load-balancer">Load Balancer</option>
				  <option value="gateway">Gateway</option>
				  <option value="vpn">VPN / Tunnel</option>
				  <option value="nas">NAS / Storage</option>
			  </optgroup>
			  <optgroup label="Cloud &amp; Services">
			      <option value="cloud">Cloud</option>
				  <option value="database">Database</option>
				  <option value="docker">Docker</option>
				  <option value="container">Container</option>
				  <option value="vm">Virtual Machine</option>
				  <option value="kubernetes">Kubernetes</option>
				  <option value="api">API / Endpoint</option>
				  <option value="queue">Queue / Message</option>
				  <option value="lambda">Lambda / Function</option>
				  <option value="bucket">Bucket / S3</option>
			  </optgroup>
			  <optgroup label="Security &amp; Monitoring">
				  <option value="shield">Shield</option>
				  <option value="camera">Camera / CCTV</option>
				  <option value="monitor">Monitor / Dashboard</option>
			  </optgroup>
        </select>
        <div class="modal-buttons">
          <button class="btn-cancel" id="add-node-cancel">Cancel</button>
          <button class="btn-save" id="add-node-save">Add Node</button>
        </div>
      </div>
    </div>
    <div class="modal" id="add-rack-modal">
      <div class="modal-content">
        <h3>Add New Rack</h3>
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Rack Name</label>
        <input type="text" id="new-rack-name" placeholder="e.g. Rack-A, DC1-R01">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">IP / Network Range (optional)</label>
        <input type="text" id="new-rack-ip" placeholder="e.g. 192.168.1.0/24">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Tags (comma separated)</label>
        <input type="text" id="new-rack-tags" placeholder="e.g. Production, Data Center 1">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Icon / Shape</label>
        <select id="new-rack-shape">
                  <optgroup label="Basic Shapes">
				  <option value="circle">Circle</option>
				  <option value="square">Square</option>
				  <option value="rectangle">Rectangle</option>
				  <option value="triangle">Triangle</option>
				  <option value="hexagon">Hexagon</option>
				  <option value="diamond">Diamond</option>
				  <option value="star">Star</option>
				  <option value="stop-sign">Stop Sign</option>
				  <option value="octagon">Octagon</option>
				  <option value="pentagon">Pentagon</option>
				  <option value="cross">Cross</option>
				  <option value="rounded-square">Rounded Square</option>
				  <option value="pill">Pill</option>
				  <option value="parallelogram">Parallelogram</option>
				  <option value="trapezoid">Trapezoid</option>
				</optgroup>
			  <optgroup label="Computers &amp; Devices">
			      <option value="server">Server</option>
				  <option value="pc">PC / Desktop</option>
				  <option value="laptop">Laptop</option>
				  <option value="phone">Phone / Mobile</option>
				  <option value="printer">Printer</option>
				  <option value="pi">Raspberry Pi</option>
				  <option value="sensor">Sensor / IoT</option>
			  </optgroup>
			  <optgroup label="Network Equipment">
				  <option value="router">Router</option>
				  <option value="switch">Switch</option>
				  <option value="firewall">Firewall</option>
				  <option value="access-point">Access Point</option>
				  <option value="load-balancer">Load Balancer</option>
				  <option value="gateway">Gateway</option>
				  <option value="vpn">VPN / Tunnel</option>
				  <option value="nas">NAS / Storage</option>
			  </optgroup>
			  <optgroup label="Cloud &amp; Services">
			      <option value="cloud">Cloud</option>
				  <option value="database">Database</option>
				  <option value="docker">Docker</option>
				  <option value="container">Container</option>
				  <option value="vm">Virtual Machine</option>
				  <option value="kubernetes">Kubernetes</option>
				  <option value="api">API / Endpoint</option>
				  <option value="queue">Queue / Message</option>
				  <option value="lambda">Lambda / Function</option>
				  <option value="bucket">Bucket / S3</option>
			  </optgroup>
			  <optgroup label="Security &amp; Monitoring">
				  <option value="shield">Shield</option>
				  <option value="camera">Camera / CCTV</option>
				  <option value="monitor">Monitor / Dashboard</option>
			  </optgroup>
        </select>
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Rack Capacity</label>
        <select id="new-rack-capacity">
          <option value="42" selected="">42U (Standard Full Rack)</option>
          <option value="48">48U (Large Rack)</option>
          <option value="24">24U (Half Rack)</option>
          <option value="12">12U (Small/Wall Mount)</option>
          <option value="6">6U (Mini Rack)</option>
        </select>
        <div class="modal-buttons">
          <button class="btn-cancel" id="add-rack-cancel">Cancel</button>
          <button class="btn-save" id="add-rack-save">Add Rack</button>
        </div>
      </div>
    </div>
    <div class="modal confirm-modal" id="clear-all-modal">
      <div class="modal-content">
        <h3>Clear All Nodes</h3>
        <p> This will remove ALL nodes and connections. This cannot be undone until you reload without saving. Are you sure? </p>
        <div class="modal-buttons">
          <button class="btn-cancel" id="clear-all-cancel">Cancel</button>
          <button class="btn-delete" id="clear-all-confirm">Clear Everything</button>
        </div>
      </div>
    </div>
    <div class="modal" id="layer-modal">
      <div class="modal-content" style="max-width: 400px;">
        <h3>Layer Visibility</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Toggle which layers are visible on the canvas</p>
        <div style="display: flex; flex-direction: column; gap: 10px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-physical" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Physical Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-logical" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Logical Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-security" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Security Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-application" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Application Layer</span>
          </label>
        </div>
        <div style="margin-top: 15px; display: flex; gap: 8px;">
          <button class="btn-cancel" style="flex: 1;" onclick="document.querySelectorAll('#layer-modal input[type=checkbox]').forEach(cb =&gt; cb.checked = false); applyLayerFilter();">Hide All</button>
          <button class="btn-save" style="flex: 1;" onclick="document.querySelectorAll('#layer-modal input[type=checkbox]').forEach(cb =&gt; cb.checked = true); applyLayerFilter();">Show All</button>
        </div>
        <div class="modal-buttons" style="margin-top: 10px;">
          <button class="btn-cancel" id="layer-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="tabs-modal">
      <div class="modal-content" style="max-width: 600px;">
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Manage multiple topologies</p>
        <div id="tabs-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 400px; overflow-y: auto; margin-bottom: 15px;">
            <div class="tab-item " onclick="switchTab(0)">
              <div class="tab-name">Corporate Site B</div>
              <div class="tab-stats">105 nodes • 64 connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(0)" title="Rename tab">✏️</button>
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(${index})" title="Delete tab">🗑️</button>
              </div>
            </div>
          
            <div class="tab-item active" onclick="switchTab(1)">
              <div class="tab-name">Homelab 2</div>
              <div class="tab-stats">11 nodes • 10 connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(1)" title="Rename tab">✏️</button>
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(${index})" title="Delete tab">🗑️</button>
              </div>
            </div>
          </div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="new-tab-name" placeholder="New tab name..." style="flex: 1; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <button class="btn-save" onclick="createNewTab()">+ Add Tab</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="tabs-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="rollback-modal">
      <div class="modal-content" style="max-width: 700px;">
        <h3>Version History</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Limit: Snapshots</p>
        <div id="rollback-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 450px; overflow-y: auto; margin-bottom: 15px;">
            <div class="version-item" onclick="restoreRollbackVersion(0)">
              <div class="version-info">
                <div class="timestamp">12/10/2025, 6:46:48 PM</div>
                <div class="details">Auto-save • 105 nodes • 64 connections</div>
              </div>
              <div class="version-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteRollbackVersion(0)" title="Delete this version">🗑️</button>
              </div>
            </div>
          
            <div class="version-item" onclick="restoreRollbackVersion(1)">
              <div class="version-info">
                <div class="timestamp">12/10/2025, 5:47:50 PM</div>
                <div class="details">Auto-save • 0 nodes • 0 connections</div>
              </div>
              <div class="version-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteRollbackVersion(1)" title="Delete this version">🗑️</button>
              </div>
            </div>
          
            <div class="version-item" onclick="restoreRollbackVersion(2)">
              <div class="version-info">
                <div class="timestamp">12/10/2025, 5:46:48 PM</div>
                <div class="details">Auto-save • 0 nodes • 0 connections</div>
              </div>
              <div class="version-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteRollbackVersion(2)" title="Delete this version">🗑️</button>
              </div>
            </div>
          </div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <button class="btn-cancel" onclick="clearRollbackHistory()">Clear History</button>
          <button class="btn-save" onclick="createManualSnapshot()">Create Snapshot</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="rollback-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="audit-log-modal">
      <div class="modal-content" style="max-width: 800px;">
        <h3>Audit Log</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Track all changes made to your topology</p>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <select id="audit-filter" style="padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
            <option value="all">All Events</option>
            <option value="node">Node Operations</option>
            <option value="connection">Connections</option>
            <option value="style">Style Changes</option>
            <option value="rack">Rack Operations</option>
            <option value="layer">Layer Changes</option>
          </select>
          <button class="btn-save" onclick="exportAuditLog()">Export</button>
        </div>
        <div id="audit-log-list" style="display: flex; flex-direction: column; gap: 4px; max-height: 450px; overflow-y: auto; margin-bottom: 15px; font-family: monospace; font-size: 12px;">
            <div class="audit-entry save">
              <div class="time">[12/10/2025, 6:46:48 PM] Corporate Site B</div>
              <div class="action">[SAVE] File saved: the-one-file-corporate.html</div>
            </div>
          
            <div class="audit-entry import">
              <div class="time">[12/10/2025, 6:46:46 PM] Corporate Site B</div>
              <div class="action">[IMPORT] Imported JSON: the-one-file-corporate-demo.json (105 nodes, 64 connections)</div>
            </div>
          
            <div class="audit-entry tab">
              <div class="time">[12/10/2025, 1:42:09 PM] Corporate Site B</div>
              <div class="action">[TAB] Switched to tab: Corporate Site B</div>
            </div>
          
            <div class="audit-entry export">
              <div class="time">[12/10/2025, 1:42:02 PM] Homelab 2</div>
              <div class="action">[EXPORT] Exported JSON: the-one-file-data-2025-12-10.json</div>
            </div>
          
            <div class="audit-entry save">
              <div class="time">[12/10/2025, 1:41:54 PM] Homelab 2</div>
              <div class="action">[SAVE] File saved: the-one-file.html</div>
            </div>
          
            <div class="audit-entry tab">
              <div class="time">[12/10/2025, 1:41:50 PM] Homelab 2</div>
              <div class="action">[TAB] Switched to tab: Homelab 2</div>
            </div>
          
            <div class="audit-entry save">
              <div class="time">[12/10/2025, 1:41:44 PM] Corporate Site B</div>
              <div class="action">[SAVE] File saved: the-one-file-corporate.html</div>
            </div>
          
            <div class="audit-entry import">
              <div class="time">[12/10/2025, 1:41:39 PM] Corporate Site B</div>
              <div class="action">[IMPORT] Imported JSON: the-one-file-corporate-demo.json (105 nodes, 64 connections)</div>
            </div>
          
            <div class="audit-entry save">
              <div class="time">[12/10/2025, 1:41:28 PM] Corporate Site B</div>
              <div class="action">[SAVE] File saved: the-one-file-corporate.html</div>
            </div>
          
            <div class="audit-entry tab">
              <div class="time">[12/10/2025, 1:41:24 PM] Corporate Site B</div>
              <div class="action">[TAB] Switched to tab: Corporate Site B</div>
            </div>
          
            <div class="audit-entry save">
              <div class="time">[12/10/2025, 1:41:18 PM] Homelab 2</div>
              <div class="action">[SAVE] File saved: the-one-file.html</div>
            </div>
          
            <div class="audit-entry save">
              <div class="time">[12/10/2025, 1:41:06 PM] Homelab 2</div>
              <div class="action">[SAVE] File saved: the-one-file.html</div>
            </div>
          
            <div class="audit-entry tab">
              <div class="time">[12/10/2025, 1:41:05 PM] Homelab 2</div>
              <div class="action">[TAB] Switched to tab: Homelab 2</div>
            </div>
          
            <div class="audit-entry save">
              <div class="time">[12/10/2025, 1:41:00 PM] Corporate Site B</div>
              <div class="action">[SAVE] File saved: the-one-file-corporate.html</div>
            </div>
          
            <div class="audit-entry import">
              <div class="time">[12/10/2025, 1:40:58 PM] Corporate Site B</div>
              <div class="action">[IMPORT] Imported JSON: theonefile-networkening-corporate-demo.json (105 nodes, 65 connections)</div>
            </div>
          </div>
        <div style="display: flex; gap: 8px;">
          <button class="btn-cancel" onclick="clearAuditLog()">Clear Log</button>
          <button class="btn-cancel" id="audit-log-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="secrets-modal">
      <div class="modal-content" style="max-width: 600px;">
        <h3>Notes</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Notes can also be stored with AES 256 encryption</p>
        <div id="secrets-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 350px; overflow-y: auto; margin-bottom: 15px;"><div style="text-align: center; padding: 40px; color: var(--text-soft);">No notes yet</div></div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="new-secret-name" placeholder="Note name (e.g., 'Root Passwords')..." style="flex: 1; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <button class="btn-save" onclick="createNewSecret()">+ Add Note</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="secrets-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="secret-editor-modal">
      <div class="modal-content" style="max-width: 600px;">
        <h3 id="secret-editor-title">Edit Note</h3>
        <textarea id="secret-editor-content" placeholder="Enter sensitive information here..." style="width: 100%; height: 200px; padding: 12px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main); font-family: monospace; resize: vertical; margin-bottom: 15px;"></textarea>
        <div style="margin-bottom: 15px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
          <input type="checkbox" id="secret-auto-encrypt" checked="" style="cursor: pointer;">
          <span>Encrypt Note</span>
          </label>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" onclick="closeSecretEditor()">Cancel</button>
          <button class="btn-save" onclick="saveSecret()">Save</button>
        </div>
      </div>
    </div>
    <div id="context-menu" style="display: none !important;">
    </div>
    <header>
      <div class="title-block">
        <h1 id="page-title" class="editable-page-title">The One File</h1>
        <div class="save-row">
          <button id="save-file-btn" class="save-btn" type="button">Save File</button>
          <label style="display: flex;align-items: center;gap: 4px;font-size: 12px;color: var(--text-soft);cursor: pointer;user-select: none;">
          <input type="checkbox" id="encrypt-toggle" style="cursor: pointer">
          <span title="Encrypt data with password">Encrypt</span>
          </label>
          <span id="save-help-btn" class="help-icon" title="Why save?">?</span>
        </div>
      </div>
      <div id="topbar-menu">
        <button id="back-to-topology-btn" title="Exit rack view and return to topology" style="padding: 6px 12px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;display: none;">← Back to Topology</button>
        <button id="add-node-btn" class="save-btn" title="Add new node" style="background: var(--accent)" draggable="true">+ Node</button>
        <button id="add-rack-btn" class="save-btn" title="Add new rack" style="background: var(--accent); margin-left: 8px;" draggable="true">+ Rack</button>
        <button id="undo-btn" title="Undo (Ctrl+Z)" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;" disabled="">↶</button>
        <button id="redo-btn" title="Redo (Ctrl+Y)" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;" disabled="">↷</button>
        <input type="text" id="search-nodes" placeholder="Search nodes..." title="Search by name, IP, MAC, role, or tag" style="padding: 6px 12px;background: var(--input-bg);color: var(--input-text);border: 1px solid var(--input-border);border-radius: 6px;font-family: var(--input-font);font-size: var(--input-font-size);width: 180px;">
        <button id="layers-btn" title="Toggle layer visibility" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Layers</button>
        <button id="tabs-btn" title="Manage document tabs" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Tabs</button>
        <button id="rollback-btn" title="View version history" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Snapshots</button>
        <button id="audit-log-btn" title="View audit log" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Audit</button>
        <button id="secrets-btn" title="Manage encrypted notes" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Notes</button>
        <button onclick="screenshotCanvas()" title="Export canvas as PNG image" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">PNG</button>
        <button onclick="exportCanvasSVG()" title="Export canvas as SVG vector" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">SVG</button>
        <button id="settings-btn" title="Page settings">⚙️</button>
      </div>
      <button id="mobile-menu-toggle" class="mobile-menu-btn">☰</button>
      <div class="header-resizer" id="header-resizer">
        <svg class="resizer-icon" width="40" height="6" viewBox="0 0 40 6" xmlns="http://www.w3.org/2000/svg">
          <circle cx="14" cy="3" r="2"></circle>
          <circle cx="20" cy="3" r="2"></circle>
          <circle cx="26" cy="3" r="2"></circle>
        </svg>
      </div>
    </header>
    <main>
      <section class="topology-panel">
        <div class="draw-toolbar" id="draw-toolbar" style="display: flex !important;">
          <button type="button" class="toolbar-close-btn" id="draw-toolbar-close-btn" title="Hide draw toolbar">✕</button>
          <button id="draw-toggle" title="Draw custom line">✏️</button>
          <button id="rect-toggle" title="Draw zone">▭</button>
          <button id="text-toggle" title="Add text">T</button>
          <select id="rect-style" title="zone style">
            <option value="filled">Filled</option>
            <option value="outlined">Outlined</option>
          </select>
          <input type="color" id="draw-color" value="#f97316" title="Line color">
          <select id="draw-style" title="Line style">
            <option value="solid">Solid</option>
            <option value="dashed">Dashed</option>
            <option value="dotted">Dotted</option>
          </select>
          <select id="draw-arrow" title="Arrow direction">
            <option value="none">No arrows</option>
            <option value="forward">→ Right</option>
            <option value="backward">← Left</option>
            <option value="both">↔ Both</option>
          </select>
          <button id="draw-undo" style="display: none" title="Undo last point">Undo</button>
        </div>
        <div class="topology-toolbar" id="topology-toolbar" style="display: flex !important;">
          <button type="button" class="toolbar-close-btn" id="topology-toolbar-close-btn" title="Hide add line toolbar">✕</button>
          <label for="add-line-select">Add line to:</label>
          <select id="add-line-select"><option value="core-router-2">Core Router 2</option><option value="fw-external-1">External FW 1</option><option value="fw-external-2">External FW 2</option><option value="fw-internal">Internal FW</option><option value="core-switch-1">Core Switch 1</option><option value="core-switch-2">Core Switch 2</option><option value="dc-rack-a1">DC Rack A1</option><option value="dc-rack-a2">DC Rack A2</option><option value="dc-rack-b1">DC Rack B1</option><option value="dc-rack-b2">DC Rack B2</option><option value="dmz-rack">DMZ Rack</option><option value="mgmt-rack">Management Rack</option><option value="wlc-primary">WLC Primary</option><option value="wlc-secondary">WLC Secondary</option><option value="mobile-zone-hq">HQ Mobile Zone</option><option value="mobile-zone-guest">Guest WiFi Zone</option><option value="mobile-zone-iot">IoT Device Zone</option><option value="branch-router-ny">NYC Branch Router</option><option value="branch-router-la">LA Branch Router</option><option value="branch-router-chi">Chicago Branch Router</option><option value="branch-router-lon">London Branch Router</option><option value="branch-router-tokyo">Tokyo Branch Router</option><option value="cloud-aws">AWS Cloud</option><option value="cloud-azure">Azure Cloud</option><option value="cloud-gcp">GCP Cloud</option><option value="isp-primary">ISP Primary</option><option value="isp-secondary">ISP Secondary</option><option value="proxy-server-1">Proxy Server 1</option><option value="proxy-server-2">Proxy Server 2</option><option value="vpn-concentrator">VPN Concentrator</option><option value="nac-server">NAC Server</option><option value="voip-cluster">VoIP Cluster</option><option value="video-conf">Video Conference</option><option value="security-cameras">Security Cameras</option><option value="dev-server-1">Dev Server 1</option><option value="dev-server-2">Dev Server 2</option><option value="test-environment">Test Environment</option><option value="erp-system">ERP System</option><option value="crm-system">CRM System</option><option value="endpoint-1000">Corporate Endpoints</option><option value="dist-switch-floor1">Floor 1 Switch</option><option value="dist-switch-floor2">Floor 2 Switch</option><option value="dist-switch-floor3">Floor 3 Switch</option><option value="dist-switch-floor4">Floor 4 Switch</option><option value="ap-floor1-zone1">AP Floor 1 Zone 1</option><option value="ap-floor2-zone1">AP Floor 2 Zone 1</option><option value="ap-floor3-zone1">AP Floor 3 Zone 1</option><option value="ap-floor4-zone1">AP Floor 4 Zone 1</option><option value="ups-dc-1">UPS DC-1</option><option value="ups-dc-2">UPS DC-2</option><option value="cooling-1">CRAC Unit 1</option><option value="cooling-2">CRAC Unit 2</option></select>
          <input type="color" id="add-line-color" value="#475569" title="Line color" style="width: 30px;height: 24px;border: 1px solid var(--toolbar-border);border-radius: 4px;cursor: pointer;background: transparent;padding: 0;">
          <select id="add-line-direction" title="Line direction">
            <option value="none">No arrows</option>
            <option value="forward">→ Forward</option>
            <option value="backward">← Backward</option>
            <option value="both">↔ Both</option>
          </select>
          <button id="add-line-btn">Add</button>
        </div>
        <div class="topology-toolbar bulk-toolbar-desktop" id="bulk-toolbar" style="display: none">
          <button type="button" class="toolbar-close-btn" id="bulk-toolbar-close" title="Clear selection">✕</button>
          <label style="font-weight: 600; color: var(--accent)">Selected: <span id="bulk-count">0</span></label>
          <button id="bulk-align-left" title="Align left">⬅ Left</button>
          <button id="bulk-align-right" title="Align right">➡ Right</button>
          <button id="bulk-align-top" title="Align top">⬆ Top</button>
          <button id="bulk-align-bottom" title="Align bottom">⬇ Bottom</button>
          <button id="bulk-distribute-h" title="Distribute horizontally">↔ Distribute H</button>
          <button id="bulk-distribute-v" title="Distribute vertically">↕ Distribute V</button>
          <button id="bulk-clone" title="Clone selected">📋 Clone</button>
          <button id="bulk-delete" title="Delete selected" style="background: var(--danger); color: white;">Delete</button>
        </div>
        <div class="bulk-toolbar-mobile" id="bulk-toolbar-mobile" style="">
          <button type="button" id="bulk-mobile-btn" style="background: var(--accent);color: white;padding: 12px 20px;border-radius: 25px;font-weight: 600;font-size: 16px;box-shadow: 0 4px 12px rgba(0,0,0,0.3);border: none;cursor: pointer;display: flex;align-items: center;gap: 8px;">
          <span id="bulk-count-mobile">0</span>Selected</button>
        </div>
        <div id="bulk-actions-modal" style="display: none;position: fixed;bottom: 0;left: 0;right: 0;background: var(--panel-alt);border-top-left-radius: 20px;border-top-right-radius: 20px;padding: 20px;padding-bottom: env(safe-area-inset-bottom, 20px);box-shadow: 0 -4px 20px rgba(0,0,0,0.5);z-index: 10000;max-height: calc(100vh - 80px);overflow-y: auto;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            <h3 style="margin: 0; color: var(--accent); font-size: 20px;">
              <span id="bulk-count-modal">0</span> Nodes Selected
            </h3>
            <button id="bulk-modal-close" style="background: none;border: none;font-size: 24px;cursor: pointer;color: var(--text-main);padding: 0;width: 32px;height: 32px;">✕</button>
          </div>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
            <button id="bulk-align-left-mobile" class="bulk-action-btn">⬅<br><span style="font-size: 12px;">Align Left</span></button>
            <button id="bulk-align-right-mobile" class="bulk-action-btn">➡<br><span style="font-size: 12px;">Align Right</span></button>
            <button id="bulk-align-top-mobile" class="bulk-action-btn">⬆<br><span style="font-size: 12px;">Align Top</span></button>
            <button id="bulk-align-bottom-mobile" class="bulk-action-btn">⬇<br><span style="font-size: 12px;">Align Bottom</span></button>
            <button id="bulk-distribute-h-mobile" class="bulk-action-btn">↔<br><span style="font-size: 12px;">Distribute H</span></button>
            <button id="bulk-distribute-v-mobile" class="bulk-action-btn">↕<br><span style="font-size: 12px;">Distribute V</span></button>
            <button id="bulk-lock-mobile" class="bulk-action-btn">🔒<br><span style="font-size: 12px;">Lock Toggle</span></button>
            <button id="bulk-group-mobile" class="bulk-action-btn">⭕<br><span style="font-size: 12px;">Group Toggle</span></button>
            <button id="bulk-clone-mobile" class="bulk-action-btn">📋<br><span style="font-size: 12px;">Clone All</span></button>
            <button id="bulk-delete-mobile" class="bulk-action-btn" style="background: var(--danger); color: white;">🗑<br><span style="font-size: 12px;">Delete All</span></button>
          </div>
          <button id="bulk-clear-mobile" style="width: 100%;margin-top: 16px;padding: 14px;background: var(--panel-main);border: 1px solid var(--edge-main);border-radius: 8px;color: var(--text-main);font-size: 16px;cursor: pointer;">Clear Selection</button>
        </div>
        <div class="canvas-hint" id="canvas-hint">
          <ul>
            <li>Scroll to zoom</li>
            <li>Drag to pan</li>
            <li>Right click to clone and align</li>
            <li>Right click to select multiple</li>
			<li>Hold Shift + drag mouse for marquee selection</li>
            <li>You have the power</li>
            <li>Your time is NOW!</li>
          </ul>
        </div>
        <div class="legend-container" id="edge-legend" style="display: flex;"><div class="legend-title">Line Legend</div><button type="button" class="legend-close-btn">✕</button><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(85, 226, 8); cursor: pointer;"></span><span class="legend-label" contenteditable="true">ISP LINE</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(76, 0, 255); cursor: pointer;"></span><span class="legend-label" contenteditable="true">MY Guest NETWORK</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(128, 255, 0); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(251, 0, 255); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(255, 0, 208); cursor: pointer;"></span><span class="legend-label" contenteditable="true">iPhone (always guest iPhone)</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(249, 115, 22); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div></div>
        <div class="canvas-viewport" id="canvas-viewport">
          <svg id="map" viewBox="-74.99705309342698 -7.395887697909075 4069.861183597212 3052.395887697909" style=""><defs><marker id="arrow-forward" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto" markerUnits="strokeWidth"><path d="M0,0 L0,6 L9,3 z" fill="context-stroke"></path></marker><marker id="arrow-backward" markerWidth="10" markerHeight="10" refX="0" refY="3" orient="auto" markerUnits="strokeWidth"><path d="M9,0 L9,6 L0,3 z" fill="context-stroke"></path></marker></defs><rect x="100" y="100" width="3800" height="2800" fill="none" stroke="#4755694D" stroke-width="20" stroke-dasharray="10 5" rx="8"></rect><g id="canvas-grid"><line x1="100" y1="100" x2="100" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="150" y1="100" x2="150" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="200" y1="100" x2="200" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="250" y1="100" x2="250" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="300" y1="100" x2="300" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="350" y1="100" x2="350" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="400" y1="100" x2="400" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="450" y1="100" x2="450" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="500" y1="100" x2="500" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="550" y1="100" x2="550" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="600" y1="100" x2="600" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="650" y1="100" x2="650" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="700" y1="100" x2="700" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="750" y1="100" x2="750" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="800" y1="100" x2="800" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="850" y1="100" x2="850" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="900" y1="100" x2="900" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="950" y1="100" x2="950" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1000" y1="100" x2="1000" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1050" y1="100" x2="1050" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1100" y1="100" x2="1100" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="1150" y1="100" x2="1150" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1200" y1="100" x2="1200" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1250" y1="100" x2="1250" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1300" y1="100" x2="1300" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1350" y1="100" x2="1350" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="1400" y1="100" x2="1400" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1450" y1="100" x2="1450" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1500" y1="100" x2="1500" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1550" y1="100" x2="1550" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1600" y1="100" x2="1600" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="1650" y1="100" x2="1650" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1700" y1="100" x2="1700" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1750" y1="100" x2="1750" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1800" y1="100" x2="1800" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1850" y1="100" x2="1850" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="1900" y1="100" x2="1900" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1950" y1="100" x2="1950" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2000" y1="100" x2="2000" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2050" y1="100" x2="2050" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2100" y1="100" x2="2100" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="2150" y1="100" x2="2150" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2200" y1="100" x2="2200" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2250" y1="100" x2="2250" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2300" y1="100" x2="2300" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2350" y1="100" x2="2350" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="2400" y1="100" x2="2400" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2450" y1="100" x2="2450" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2500" y1="100" x2="2500" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2550" y1="100" x2="2550" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2600" y1="100" x2="2600" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="2650" y1="100" x2="2650" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2700" y1="100" x2="2700" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2750" y1="100" x2="2750" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2800" y1="100" x2="2800" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2850" y1="100" x2="2850" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="2900" y1="100" x2="2900" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2950" y1="100" x2="2950" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3000" y1="100" x2="3000" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3050" y1="100" x2="3050" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3100" y1="100" x2="3100" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="3150" y1="100" x2="3150" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3200" y1="100" x2="3200" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3250" y1="100" x2="3250" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3300" y1="100" x2="3300" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3350" y1="100" x2="3350" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="3400" y1="100" x2="3400" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3450" y1="100" x2="3450" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3500" y1="100" x2="3500" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3550" y1="100" x2="3550" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3600" y1="100" x2="3600" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="3650" y1="100" x2="3650" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3700" y1="100" x2="3700" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3750" y1="100" x2="3750" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3800" y1="100" x2="3800" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3850" y1="100" x2="3850" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="3900" y1="100" x2="3900" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="100" x2="3900" y2="100" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="150" x2="3900" y2="150" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="200" x2="3900" y2="200" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="250" x2="3900" y2="250" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="300" x2="3900" y2="300" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="350" x2="3900" y2="350" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="400" x2="3900" y2="400" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="450" x2="3900" y2="450" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="500" x2="3900" y2="500" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="550" x2="3900" y2="550" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="600" x2="3900" y2="600" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="650" x2="3900" y2="650" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="700" x2="3900" y2="700" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="750" x2="3900" y2="750" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="800" x2="3900" y2="800" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="850" x2="3900" y2="850" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="900" x2="3900" y2="900" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="950" x2="3900" y2="950" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1000" x2="3900" y2="1000" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1050" x2="3900" y2="1050" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1100" x2="3900" y2="1100" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="1150" x2="3900" y2="1150" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1200" x2="3900" y2="1200" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1250" x2="3900" y2="1250" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1300" x2="3900" y2="1300" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1350" x2="3900" y2="1350" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="1400" x2="3900" y2="1400" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1450" x2="3900" y2="1450" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1500" x2="3900" y2="1500" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1550" x2="3900" y2="1550" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1600" x2="3900" y2="1600" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="1650" x2="3900" y2="1650" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1700" x2="3900" y2="1700" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1750" x2="3900" y2="1750" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1800" x2="3900" y2="1800" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1850" x2="3900" y2="1850" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="1900" x2="3900" y2="1900" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1950" x2="3900" y2="1950" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2000" x2="3900" y2="2000" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2050" x2="3900" y2="2050" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2100" x2="3900" y2="2100" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="2150" x2="3900" y2="2150" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2200" x2="3900" y2="2200" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2250" x2="3900" y2="2250" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2300" x2="3900" y2="2300" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2350" x2="3900" y2="2350" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="2400" x2="3900" y2="2400" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2450" x2="3900" y2="2450" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2500" x2="3900" y2="2500" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2550" x2="3900" y2="2550" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2600" x2="3900" y2="2600" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="2650" x2="3900" y2="2650" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2700" x2="3900" y2="2700" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2750" x2="3900" y2="2750" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2800" x2="3900" y2="2800" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2850" x2="3900" y2="2850" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="2900" x2="3900" y2="2900" stroke="#47556933" stroke-width="1"></line></g><g class="rect-group" data-rect-id="rect-1765238219615"><rect class="rect-shape" x="2680.053955078125" y="251.44879150390625" width="814.10400390625" height="389.26678466796875" style="fill: rgb(236, 9, 153); fill-opacity: 0.3; stroke: rgb(236, 9, 153); stroke-width: 2px; stroke-dasharray: none; cursor: move;"></rect><g class="rect-delete-btn" style="cursor: pointer; display: none;"><circle cx="3484.157958984375" cy="261.44879150390625" r="12" style="fill: rgb(245, 101, 101); stroke: white; stroke-width: 2;"></circle><text x="3484.157958984375" y="261.44879150390625" text-anchor="middle" dominant-baseline="middle" style="fill: white; font-size: 16px; font-weight: bold; pointer-events: none;">×</text></g></g><path d="M 2071.640165880771 218.24354238566275 Q 2069.3039587352528 345.82772790170964 2066.9677515897347 473.4119134177565" fill="none" class="edge" data-edge-id="internet-internet-copy-1765238145151" data-from="internet" data-to="internet-copy" style="stroke: rgb(85, 226, 8); stroke-width: 4;"></path><path d="M 2071.640165880771 218.24354238566275 Q 2069.3039587352528 345.82772790170964 2066.9677515897347 473.4119134177565" fill="none" data-edge-id="internet-internet-copy-1765238145151" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 1921.3019190702034 570.8918786277175 1775.6360865506722 668.3718438376784" fill="none" class="edge" data-edge-id="internet-copy-opnsense-copy-1765238187451" data-from="internet-copy" data-to="opnsense-copy" style="stroke: rgb(76, 0, 255); stroke-width: 4;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 1921.3019190702034 570.8918786277175 1775.6360865506722 668.3718438376784" fill="none" data-edge-id="internet-copy-opnsense-copy-1765238187451" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2000.8787827715962 627.8447547749242 1934.7898139534577 782.2775961320921" fill="none" class="edge" data-edge-id="internet-copy-docker-copy-1765238242477" data-from="internet-copy" data-to="docker-copy" style="stroke: rgb(76, 0, 255); stroke-width: 4;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2000.8787827715962 627.8447547749242 1934.7898139534577 782.2775961320921" fill="none" data-edge-id="internet-copy-docker-copy-1765238242477" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2112.546995662221 620.5620704487524 2158.1262397347077 767.7122274797483" fill="none" class="edge" data-edge-id="internet-copy-docker-copy-1-1765238244637" data-from="internet-copy" data-to="docker-copy-1" style="stroke: rgb(76, 0, 255); stroke-width: 4;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2112.546995662221 620.5620704487524 2158.1262397347077 767.7122274797483" fill="none" data-edge-id="internet-copy-docker-copy-1-1765238244637" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2206.4130845294085 552.590055067893 2345.8584174690827 631.7681967180296" fill="none" class="edge" data-edge-id="internet-copy-docker-copy-2-1765238246233" data-from="internet-copy" data-to="docker-copy-2" style="stroke: rgb(76, 0, 255); stroke-width: 4;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2206.4130845294085 552.590055067893 2345.8584174690827 631.7681967180296" fill="none" data-edge-id="internet-copy-docker-copy-2-1765238246233" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2071.640165880771 218.24354238566275 Q 2414.759822984287 262.92762699742593 2757.879480087803 307.6117116091891" fill="none" class="edge" data-edge-id="internet-opnsense-copy-1-1765238266117" data-from="internet" data-to="opnsense-copy-1" style="stroke: rgb(128, 255, 0); stroke-width: 4;"></path><path d="M 2071.640165880771 218.24354238566275 Q 2414.759822984287 262.92762699742593 2757.879480087803 307.6117116091891" fill="none" data-edge-id="internet-opnsense-copy-1-1765238266117" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2757.879480087803 307.6117116091891 Q 2979.171899521397 314.04065142852505 3200.4643189549906 320.469591247861" fill="none" class="edge" data-edge-id="opnsense-copy-1-dns-1765238347996" data-from="opnsense-copy-1" data-to="dns" style="stroke: rgb(251, 0, 255); stroke-width: 4;"></path><path d="M 2757.879480087803 307.6117116091891 Q 2979.171899521397 314.04065142852505 3200.4643189549906 320.469591247861" fill="none" data-edge-id="opnsense-copy-1-dns-1765238347996" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 3200.4643189549906 320.469591247861 Q 3094.0802247167094 404.02690325957974 2987.696130478428 487.5842152712985" fill="none" class="edge" data-edge-id="dns-desktop-1765238386101" data-from="dns" data-to="desktop" style="stroke: rgb(255, 0, 208); stroke-width: 4;"></path><path d="M 3200.4643189549906 320.469591247861 Q 3094.0802247167094 404.02690325957974 2987.696130478428 487.5842152712985" fill="none" data-edge-id="dns-desktop-1765238386101" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 3312.857751572178 502.58220111114224 Q 3256.6610352635844 411.5258961795016 3200.4643189549906 320.469591247861" fill="none" class="edge" data-edge-id="phone-dns-1765238391156" data-from="phone" data-to="dns" style="stroke: rgb(255, 0, 208); stroke-width: 4;"></path><path d="M 3312.857751572178 502.58220111114224 Q 3256.6610352635844 411.5258961795016 3200.4643189549906 320.469591247861" fill="none" data-edge-id="phone-dns-1765238391156" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><polyline class="edge" data-edge-id="custom-1765238841477" fill="none" marker-start="url(#arrow-backward)" marker-end="url(#arrow-forward)" points="2905.255615234375,805.3433837890625 3189.95556640625,1005.8710327148438 2788.900390625,1008.3466796875" style="stroke: rgb(249, 115, 22); stroke-width: 4; stroke-dasharray: none;"></polyline><polyline points="2905.255615234375,805.3433837890625 3189.95556640625,1005.8710327148438 2788.900390625,1008.3466796875" data-edge-id="custom-1765238841477" style="fill: none; stroke: transparent; stroke-width: 20; cursor: pointer;"></polyline><g class="node-group" data-node-id="internet" transform="translate(2071.640165880771,218.24354238566275)" style="cursor: grab;"><circle r="127.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><rect x="-85" y="-85" width="170" height="170" rx="4" class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"></rect><text class="node-label" x="0" y="-23.8" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Internet</text><text class="node-sub" x="0" y="34" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="internet-copy" transform="translate(2066.9677515897347,473.4119134177565)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-55" y="-44" width="110" height="88" rx="4"></rect><line x1="-46.75" y1="-27.5" x2="46.75" y2="-27.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="-2.75" x2="46.75" y2="-2.75" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="22" x2="46.75" y2="22" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="-44" x2="-27.5" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="-44" x2="11" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="-19.25" x2="-8.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="-19.25" x2="30.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="5.5" x2="-27.5" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="5.5" x2="11" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="30.25" x2="-8.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="30.25" x2="30.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">OPNSENSE</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="opnsense-copy" transform="translate(1775.6360865506722,668.3718438376784)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-55" y="-44" width="110" height="88" rx="4"></rect><line x1="-46.75" y1="-27.5" x2="46.75" y2="-27.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="-2.75" x2="46.75" y2="-2.75" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="22" x2="46.75" y2="22" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="-44" x2="-27.5" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="-44" x2="11" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="-19.25" x2="-8.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="-19.25" x2="30.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="5.5" x2="-27.5" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="5.5" x2="11" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="30.25" x2="-8.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="30.25" x2="30.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Docker</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="docker-copy" transform="translate(1934.7898139534577,782.2775961320921)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-55" y="-44" width="110" height="88" rx="4"></rect><line x1="-46.75" y1="-27.5" x2="46.75" y2="-27.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="-2.75" x2="46.75" y2="-2.75" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="22" x2="46.75" y2="22" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="-44" x2="-27.5" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="-44" x2="11" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="-19.25" x2="-8.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="-19.25" x2="30.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="5.5" x2="-27.5" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="5.5" x2="11" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="30.25" x2="-8.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="30.25" x2="30.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Docker2</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="docker-copy-1" transform="translate(2158.1262397347077,767.7122274797483)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-55" y="-44" width="110" height="88" rx="4"></rect><line x1="-46.75" y1="-27.5" x2="46.75" y2="-27.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="-2.75" x2="46.75" y2="-2.75" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="22" x2="46.75" y2="22" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="-44" x2="-27.5" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="-44" x2="11" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="-19.25" x2="-8.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="-19.25" x2="30.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="5.5" x2="-27.5" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="5.5" x2="11" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="30.25" x2="-8.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="30.25" x2="30.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Docker3</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="docker-copy-2" transform="translate(2345.8584174690827,631.7681967180296)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-55" y="-44" width="110" height="88" rx="4"></rect><line x1="-46.75" y1="-27.5" x2="46.75" y2="-27.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="-2.75" x2="46.75" y2="-2.75" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="22" x2="46.75" y2="22" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="-44" x2="-27.5" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="-44" x2="11" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="-19.25" x2="-8.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="-19.25" x2="30.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="5.5" x2="-27.5" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="5.5" x2="11" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="30.25" x2="-8.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="30.25" x2="30.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Docker 4</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="opnsense-copy-1" transform="translate(2757.879480087803,307.6117116091891)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-55" y="-44" width="110" height="88" rx="4"></rect><line x1="-46.75" y1="-27.5" x2="46.75" y2="-27.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="-2.75" x2="46.75" y2="-2.75" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="22" x2="46.75" y2="22" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="-44" x2="-27.5" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="-44" x2="11" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="-19.25" x2="-8.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="-19.25" x2="30.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="5.5" x2="-27.5" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="5.5" x2="11" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="30.25" x2="-8.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="30.25" x2="30.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">OPNSENSE GUEST</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="phone" transform="translate(3312.857751572178,502.58220111114224)" style="cursor: grab;"><circle r="181.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-54.45" y="-121" width="108.9" height="242" rx="8"></rect><rect x="-45.980000000000004" y="-102.85" width="91.96000000000001" height="193.60000000000002" rx="4" style="fill: rgb(30, 41, 59);"></rect><rect x="-18.15" y="99.22" width="36.3" height="7.26" rx="2" style="fill: rgb(71, 85, 105);"></rect></g><text class="node-label" x="0" y="-33.88" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Phone</text><text class="node-sub" x="0" y="48.400000000000006" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="desktop" transform="translate(2987.696130478428,487.5842152712985)" style="cursor: grab;"><circle r="220.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-132.3" y="-117.60000000000001" width="264.6" height="176.4" rx="4"></rect><rect x="-110.25" y="-95.55" width="220.5" height="132.3" rx="2" style="fill: rgb(30, 41, 59);"></rect><rect x="-22.05" y="58.800000000000004" width="44.1" height="44.1"></rect><rect x="-73.5" y="102.89999999999999" width="147" height="22.05" rx="2"></rect></g><text class="node-label" x="0" y="-41.160000000000004" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Desktop</text><text class="node-sub" x="0" y="58.800000000000004" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="dns" transform="translate(3200.4643189549906,320.469591247861)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><path d="
             M -44 11
             Q -60.50000000000001 11 -60.50000000000001 -5.5
             Q -60.50000000000001 -27.5 -38.5 -27.5
             Q -38.5 -49.5 -11 -49.5
             Q 5.5 -60.50000000000001 27.5 -44
             Q 55 -44 60.50000000000001 -16.5
             Q 71.5 -5.5 60.50000000000001 11
             Q 60.50000000000001 27.5 38.5 27.5
             L -27.5 27.5
             Q -49.5 27.5 -49.5 11
             Z
            " class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"></path><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">DNS</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="racked" transform="translate(2600.8697010779656,975.5665527522032)" style="cursor: grab;"><circle r="205.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-164.4" y="-82.2" width="328.8" height="164.4" rx="4"></rect><line x1="-123.3" y1="-41.1" x2="-123.3" y2="41.1" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="-54.8" y1="-41.1" x2="-54.8" y2="41.1" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="13.700000000000003" y1="-41.1" x2="13.700000000000003" y2="41.1" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><circle cx="123.3" cy="0" r="13.700000000000001" style="fill: rgb(74, 222, 128);"></circle></g><text class="node-label" x="0" y="-38.36000000000001" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Racked</text><text class="node-sub" x="0" y="54.800000000000004" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;"></text></g><g class="text-group" data-text-id="text-1765238422602"><text class="text-element" x="2402.130859375" y="736.7828979492188" dominant-baseline="middle" style="fill: rgb(226, 232, 240); font-size: 48px; font-weight: normal; font-style: normal; text-anchor: start; text-decoration: none; opacity: 1; cursor: move; user-select: none;"><tspan x="2402.130859375" dy="0">Double click on desktop</tspan><tspan x="2402.130859375" dy="57.599999999999994">or long press on mobile</tspan><tspan x="2402.130859375" dy="57.599999999999994">to enter rack canvas view</tspan></text><g class="text-delete-btn" style="cursor: pointer; display: none;"><circle cx="2422.130859375" cy="688.7828979492188" r="12" style="fill: rgb(245, 101, 101); stroke: white; stroke-width: 2;"></circle><text x="2422.130859375" y="688.7828979492188" text-anchor="middle" dominant-baseline="middle" style="fill: white; font-size: 16px; font-weight: bold; pointer-events: none;">×</text></g></g></svg>
        </div>
        <div class="minimap-zoom-wrapper" id="minimap-zoom-wrapper" style="display: block;">
          <button type="button" class="minimap-close-btn" id="minimap-close-btn" title="Hide map &amp; zoom">✕</button>
          <div class="minimap-container" id="minimap-container">
            <svg id="minimap" viewBox="0 0 4000 3000">
              <line x1="2071.640165880771" y1="218.24354238566275" x2="2066.9677515897347" y2="473.4119134177565" class="minimap-edge"></line><line x1="2066.9677515897347" y1="473.4119134177565" x2="1775.6360865506722" y2="668.3718438376784" class="minimap-edge"></line><line x1="2066.9677515897347" y1="473.4119134177565" x2="1934.7898139534577" y2="782.2775961320921" class="minimap-edge"></line><line x1="2066.9677515897347" y1="473.4119134177565" x2="2158.1262397347077" y2="767.7122274797483" class="minimap-edge"></line><line x1="2066.9677515897347" y1="473.4119134177565" x2="2345.8584174690827" y2="631.7681967180296" class="minimap-edge"></line><line x1="2071.640165880771" y1="218.24354238566275" x2="2757.879480087803" y2="307.6117116091891" class="minimap-edge"></line><line x1="2757.879480087803" y1="307.6117116091891" x2="3200.4643189549906" y2="320.469591247861" class="minimap-edge"></line><line x1="3200.4643189549906" y1="320.469591247861" x2="2987.696130478428" y2="487.5842152712985" class="minimap-edge"></line><line x1="3312.857751572178" y1="502.58220111114224" x2="3200.4643189549906" y2="320.469591247861" class="minimap-edge"></line><circle cx="2071.640165880771" cy="218.24354238566275" r="40" class="minimap-node"></circle><circle cx="2066.9677515897347" cy="473.4119134177565" r="40" class="minimap-node"></circle><circle cx="1775.6360865506722" cy="668.3718438376784" r="40" class="minimap-node"></circle><circle cx="1934.7898139534577" cy="782.2775961320921" r="40" class="minimap-node"></circle><circle cx="2158.1262397347077" cy="767.7122274797483" r="40" class="minimap-node"></circle><circle cx="2345.8584174690827" cy="631.7681967180296" r="40" class="minimap-node"></circle><circle cx="2757.879480087803" cy="307.6117116091891" r="40" class="minimap-node"></circle><circle cx="3312.857751572178" cy="502.58220111114224" r="40" class="minimap-node"></circle><circle cx="2987.696130478428" cy="487.5842152712985" r="40" class="minimap-node"></circle><circle cx="3200.4643189549906" cy="320.469591247861" r="40" class="minimap-node"></circle><circle cx="2600.8697010779656" cy="975.5665527522032" r="40" class="minimap-node"></circle><rect class="minimap-viewport" id="minimap-viewport" x="-74.99705309342698" y="-7.395887697909075" width="4069.861183597212" height="3052.395887697909"></rect>
            </svg>
          </div>
          <div class="zoom-toolbar" id="zoom-toolbar">
            <button id="zoom-in-btn" title="Zoom in">+</button>
            <div class="zoom-level" id="zoom-level">98%</div>
            <button id="zoom-out-btn" title="Zoom out">-</button>
            <div class="divider"></div>
            <button id="zoom-fit-btn" title="Fit to view">[ ]</button>
            <button id="zoom-reset-btn" title="Reset view">R</button>
          </div>
        </div>
        <button type="button" id="edge-legend-mini" class="legend-mini-btn" style="bottom: 10px; display: none;">Line Legend</button>
        <button type="button" id="minimap-mini" class="legend-mini-btn" style="right: 10px; left: auto; bottom: 10px; display: none;">Map</button>
        <button type="button" id="draw-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: 10px; right: auto;">Draw</button>
        <button type="button" id="topology-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: auto; right: 40px;">Add Line</button></section>
      <aside class="details-panel" id="details-panel">
        <div class="sidebar-resizer" id="sidebar-resizer">
          <svg class="resizer-icon" width="6" height="40" viewBox="0 0 6 40" xmlns="http://www.w3.org/2000/svg">
            <circle cx="3" cy="14" r="2"></circle>
            <circle cx="3" cy="20" r="2"></circle>
            <circle cx="3" cy="26" r="2"></circle>
          </svg>
        </div>
        <div class="mobile-footer-resizer" id="mobile-footer-resizer">
          <svg class="resizer-icon" width="40" height="6" viewBox="0 0 40 6" xmlns="http://www.w3.org/2000/svg">
            <circle cx="14" cy="3" r="2"></circle>
            <circle cx="20" cy="3" r="2"></circle>
            <circle cx="26" cy="3" r="2"></circle>
          </svg>
        </div>
        <div id="node-panel" style="display: none;">
          <div class="details-name editable-text" id="node-name">Core Router 1</div>
          <div class="details-ip editable-text" id="node-ip">10.0.0.1</div>
          <div class="details-role" id="node-role">Core Routing</div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px;">MAC:</span>
            <span class="editable-text" id="node-mac" style="margin-left: 8px; font-size: 14px;">00:1A:2B:3C:4D:01</span>
          </div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px;">Rack Unit:</span>
            <span class="editable-text" id="node-rack" style="margin-left: 8px; font-size: 14px;">--</span>
          </div>
          <div class="details-info-row" id="uheight-row" style="display: none;">
            <span style="color: var(--text-soft); font-size: 14px;">U Height:</span>
            <span class="editable-text" id="node-uheight" style="margin-left: 8px; font-size: 14px;">2U</span>
          </div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px;">Layer:</span>
            <select id="node-layer" style="margin-left: 8px; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;">
              <option value="physical">Physical</option>
              <option value="logical">Logical</option>
              <option value="security">Security</option>
              <option value="application">Application</option>
            </select>
          </div>
          <div class="details-info-row" id="assigned-rack-row" style="display: flex;">
            <span style="color: var(--text-soft); font-size: 14px;">Assigned Rack:</span>
            <select id="node-assigned-rack" style="margin-left: 8px; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;"><option value="">None</option><option value="racked">Racked</option></select>
          </div>
          <div class="details-info-row" id="rack-capacity-row" style="display: none;">
            <span style="color: var(--text-soft); font-size: 14px;">Rack Capacity:</span>
            <select id="node-rack-capacity" style="margin-left: 8px; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;">
              <option value="42">42U</option>
              <option value="48">48U</option>
              <option value="24">24U</option>
              <option value="12">12U</option>
			  <option value="6">6U</option>
            </select>
          </div>
		  <details id="rack-contents-section" style="display: none; margin-top: 12px; margin-bottom: 12px; padding: 10px; background: var(--panel-alt); border-radius: 6px;" open="">
            <summary style="color: var(--accent); font-weight: 600; font-size: 14px; cursor: pointer;">Nodes in Rack (<span id="rack-contents-count">0</span>)</summary>
            <div id="rack-contents-list" style="max-height: 200px; overflow-y: auto; margin-top: 8px;"></div>
          </details>
          <div class="badge-row" id="node-tags"><span class="badge" style="cursor: pointer; position: relative;"><span>core</span><span style="opacity: 0.6; margin-left: 4px; font-size: 10px;"> ✕</span></span><span class="badge" style="cursor: pointer; position: relative;"><span>tier-1</span><span style="opacity: 0.6; margin-left: 4px; font-size: 10px;"> ✕</span></span><span class="badge" style="cursor: pointer; position: relative;"><span>redundant</span><span style="opacity: 0.6; margin-left: 4px; font-size: 10px;"> ✕</span></span><span class="badge" style="cursor: pointer; opacity: 0.6; border-style: dashed;">+ Add Tag</span></div>
          <div class="size-controls">
            <label>Size:</label>
            <input type="range" id="size-slider" min="20" max="200" value="55">
            <span id="size-value">55</span>
            <button id="reset-size">Reset</button>
          </div>
          <details class="style-section">
            <summary>Styling</summary>
            <div class="style-content">
              <div class="style-row">
                <label>Screen:</label>
                <select id="style-scope">
                  <option value="all">All</option>
                  <option value="desktop">Desktop</option>
                  <option value="tablet">Tablet</option>
                  <option value="mobile">Mobile</option>
                  <option value="fold">Fold</option>
                </select>
              </div>
              <div class="style-row">
                <label>Shape:</label>
                <select id="shape-select">
                  <optgroup label="Basic Shapes">
				  <option value="circle">Circle</option>
				  <option value="square">Square</option>
				  <option value="rectangle">Rectangle</option>
				  <option value="triangle">Triangle</option>
				  <option value="hexagon">Hexagon</option>
				  <option value="diamond">Diamond</option>
				  <option value="star">Star</option>
				  <option value="stop-sign">Stop Sign</option>
				  <option value="octagon">Octagon</option>
				  <option value="pentagon">Pentagon</option>
				  <option value="cross">Cross</option>
				  <option value="rounded-square">Rounded Square</option>
				  <option value="pill">Pill</option>
				  <option value="parallelogram">Parallelogram</option>
				  <option value="trapezoid">Trapezoid</option>
				</optgroup>
			  <optgroup label="Computers &amp; Devices">
			      <option value="server">Server</option>
				  <option value="pc">PC / Desktop</option>
				  <option value="laptop">Laptop</option>
				  <option value="phone">Phone / Mobile</option>
				  <option value="printer">Printer</option>
				  <option value="pi">Raspberry Pi</option>
				  <option value="sensor">Sensor / IoT</option>
			  </optgroup>
			  <optgroup label="Network Equipment">
				  <option value="router">Router</option>
				  <option value="switch">Switch</option>
				  <option value="firewall">Firewall</option>
				  <option value="access-point">Access Point</option>
				  <option value="load-balancer">Load Balancer</option>
				  <option value="gateway">Gateway</option>
				  <option value="vpn">VPN / Tunnel</option>
				  <option value="nas">NAS / Storage</option>
			  </optgroup>
			  <optgroup label="Cloud &amp; Services">
			      <option value="cloud">Cloud</option>
				  <option value="database">Database</option>
				  <option value="docker">Docker</option>
				  <option value="container">Container</option>
				  <option value="vm">Virtual Machine</option>
				  <option value="kubernetes">Kubernetes</option>
				  <option value="api">API / Endpoint</option>
				  <option value="queue">Queue / Message</option>
				  <option value="lambda">Lambda / Function</option>
				  <option value="bucket">Bucket / S3</option>
			  </optgroup>
			  <optgroup label="Security &amp; Monitoring">
				  <option value="shield">Shield</option>
				  <option value="camera">Camera / CCTV</option>
				  <option value="monitor">Monitor / Dashboard</option>
			  </optgroup>
             </select>
              </div>
              <div class="style-row">
                <label>Fill Color:</label>
                <input type="color" id="circle-color" value="#1e293b">
              </div>
              <div class="style-row">
                <label>Border Color:</label>
                <input type="color" id="circle-border" value="#475569">
              </div>
              <div class="style-row">
                <label>Title Color:</label>
                <input type="color" id="title-color" value="#e2e8f0">
              </div>
              <div class="style-row">
                <label>Title Font:</label>
                <select id="title-font">
                  <option value="system-ui, sans-serif"> System UI </option>
                  <option value="monospace">Monospace</option>
                  <option value="serif">Serif</option>
                  <option value="cursive">Cursive</option>
                  <option value="'Courier New', monospace"> Courier </option>
                  <option value="Arial, sans-serif">Arial</option>
                  <option value="'Times New Roman', serif"> Times </option>
                </select>
              </div>
              <div class="style-row">
                <label>Title Size:</label>
                <input type="number" id="title-size" min="8" max="100" value="18">
              </div>
              <div class="style-row">
                <label>Sub Color:</label>
                <input type="color" id="sub-color" value="#94a3b8">
              </div>
              <div class="style-row">
                <label>Sub Font:</label>
                <select id="sub-font">
                  <option value="system-ui, sans-serif"> System UI </option>
                  <option value="monospace">Monospace</option>
                  <option value="serif">Serif</option>
                  <option value="cursive">Cursive</option>
                  <option value="'Courier New', monospace"> Courier </option>
                  <option value="Arial, sans-serif">Arial</option>
                  <option value="'Times New Roman', serif"> Times </option>
                </select>
              </div>
              <div class="style-row">
                <label>Sub Size:</label>
                <input type="number" id="sub-size" min="6" max="80" value="13">
              </div>
              <div style="margin-top: 12px;padding-top: 10px;border-top: 1px solid var(--edge-main);">
                <div style="
                  font-size: 12px;
                  color: var(--text-soft);
                  margin-bottom: 8px;
                  text-transform: uppercase;
                  "> Text Position </div>
                <div class="style-row">
                  <label>Name Y:</label>
                  <input type="number" id="title-offset-y" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>Name X:</label>
                  <input type="number" id="title-offset-x" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>IP Y:</label>
                  <input type="number" id="sub-offset-y" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>IP X:</label>
                  <input type="number" id="sub-offset-x" min="-100" max="100" value="0" style="width: 60px">
                </div>
              </div>
              <button id="reset-styles" style="width: 100%;margin-top: 10px;padding: 8px;background: var(--panel);color: var(--text-main);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: clamp(13px, 1.5vw, 17px);">Reset Styles</button>
            </div>
          </details>
          <div class="section-label">Notes</div>
          <ul class="list" id="node-notes"><li><span style="flex: 1 1 0%;">Primary core router</span><span class="delete-note">✕</span></li><li><span style="flex: 1 1 0%;">BGP peering enabled</span><span class="delete-note">✕</span></li></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-note-input" placeholder="Type new note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-note-btn" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-node-btn" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: rgb(255, 255, 255);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;width: 100%;">Delete Node</button>
        </div>
        <div id="edge-panel" style="display: none">
          <div class="details-name" id="edge-title">Custom line</div>
          <div class="style-row" style="margin-top: 10px">
            <label>Width:</label>
            <input type="number" id="edge-width" min="1" max="20" value="4">
          </div>
          <div class="style-row">
            <label>Color:</label>
            <input type="color" id="edge-color" value="#475569">
          </div>
          <div class="style-row">
            <label>Line Style:</label>
            <select id="edge-line-style">
              <option value="solid">Solid</option>
              <option value="dashed">Dashed</option>
              <option value="dotted">Dotted</option>
            </select>
          </div>
          <div class="style-row">
            <label>Direction:</label>
            <select id="edge-direction">
              <option value="none">No arrows</option>
              <option value="forward">→ Forward</option>
              <option value="backward">← Backward</option>
              <option value="both">↔ Bidirectional</option>
            </select>
          </div>
          <div class="style-row" id="edge-from-port-row" style="display: none;">
            <label>From Port:</label>
            <input type="text" id="edge-from-port" placeholder="e.g. eth0, gi0/1" style="flex: 1;">
          </div>
          <div class="style-row" id="edge-to-port-row" style="display: none;">
            <label>To Port:</label>
            <input type="text" id="edge-to-port" placeholder="e.g. eth1, gi0/2" style="flex: 1;">
          </div>
          <div class="section-label">Line Notes</div>
          <ul class="list" id="edge-notes"></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-edge-note" placeholder="Add note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-edge-note" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-edge" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Delete Line</button>
        </div>
        <div id="rect-panel" style="display: none">
          <div class="details-name" id="rect-title">Zone</div>
          <div class="style-row" id="rect-fill-row" style="margin-top: 10px">
            <label>Fill Color:</label>
            <input type="color" id="rect-color" value="#f97316">
          </div>
          <div class="style-row">
            <label>Border Color:</label>
            <input type="color" id="rect-border-color" value="#f97316">
          </div>
          <div class="style-row">
            <label>Border Width:</label>
            <input type="number" id="rect-border-width" min="0" max="20" value="2">
          </div>
          <div class="style-row">
            <label>Style:</label>
            <select id="rect-style-select">
              <option value="filled">Filled</option>
              <option value="outlined">Outlined</option>
            </select>
          </div>
          <div class="style-row">
            <label>Line Style:</label>
            <select id="rect-line-style">
              <option value="solid">Solid</option>
              <option value="dashed">Dashed</option>
              <option value="dotted">Dotted</option>
            </select>
          </div>
          <div class="section-label">Zone Notes</div>
          <ul class="list" id="rect-notes"></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-rect-note" placeholder="Add note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-rect-note" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-rect" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Delete Zone</button>
        </div>
        <div id="text-panel" style="display: none">
          <div class="details-name" id="text-title">Text Element</div>
          <div class="style-row" style="margin-top: 10px">
            <label>Content:</label>
            <textarea id="text-content" placeholder="Enter text..." style="width: 100%;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: 14px;min-height: 80px;resize: vertical;font-family: inherit;"></textarea>
          </div>
          <div class="style-row">
            <label>Font Size:</label>
            <input type="number" id="text-font-size" min="8" max="200" value="18" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);">
          </div>
          <div class="style-row">
            <label>Color:</label>
            <input type="color" id="text-color" value="#e2e8f0">
          </div>
          <div class="style-row">
            <label>Font Weight:</label>
            <select id="text-font-weight" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="normal">Normal</option>
              <option value="bold">Bold</option>
              <option value="600">Semi-Bold</option>
              <option value="300">Light</option>
            </select>
          </div>
          <div class="style-row">
            <label>Font Style:</label>
            <select id="text-font-style" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="normal">Normal</option>
              <option value="italic">Italic</option>
            </select>
          </div>
          <div class="style-row">
            <label>Text Align:</label>
            <select id="text-align" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="start">Left</option>
              <option value="middle">Center</option>
              <option value="end">Right</option>
            </select>
          </div>
          <div class="style-row">
            <label>Text Decoration:</label>
            <select id="text-decoration" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="none">None</option>
              <option value="underline">Underline</option>
              <option value="line-through">Strike Through</option>
            </select>
          </div>
          <div class="style-row">
            <label>Background:</label>
            <input type="color" id="text-bg-color" value="#000000">
            <label style="margin-left: 10px; display: flex; align-items: center; gap: 6px;">
            <input type="checkbox" id="text-bg-enabled" style="cursor: pointer;">
            <span style="font-size: 13px;">Enable</span>
            </label>
          </div>
          <div class="style-row">
            <label>Opacity:</label>
            <input type="range" id="text-opacity" min="0" max="1" step="0.1" value="1" style="flex: 1">
            <span id="text-opacity-val" style="min-width: 35px; text-align: right">100%</span>
          </div>
          <button id="delete-text" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;width: 100%;"> Delete Text </button>
        </div>
        <details class="style-section" open="">
          <summary>Page Layout</summary>
          <div class="style-content">
            <div style="padding: 12px; background: var(--panel-alt); border-radius: 6px; color: var(--text-soft); font-size: 13px; line-height: 1.6;">
              <strong style="color: var(--accent); display: block; margin-bottom: 8px;">Drag to Resize:</strong>
              • <strong>Header:</strong> Drag the bottom edge of the header bar<br>
              • <strong>Sidebar:</strong> Drag the left edge of the sidebar panel<br>
              • <strong>Mobile:</strong> Drag the top edge of the footer panel<br>
              <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--edge-main); font-size: 12px;">
                Hover over panel edges to see resize handles
              </div>
            </div>
          </div>
        </details>
      </aside>
    </main>
    <script id="nodes-json" type="application/json">{}</script>
    <script id="topology-state" type="application/json">ENCRYPTED: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</script>
    <script>
      const BASE_NODE_DATA = JSON.parse(document.getElementById("nodes-json").textContent, );
      let currentNodeId = "host";
      let textDrawMode = false;
      let currentEdgeId = null;
      let currentStyleScope = "all";
      let NODE_DATA = {};
      let EDGE_DATA = {
       list: []
      };
      let currentRectId = null;
      let currentTextId = null;
      let rectDrawMode = false;
      let RECT_DATA = {
       list: []
      };
      let TEXT_DATA = {
       list: []
      };
      let EDGE_LEGEND = {};
      let freeDrawMode = false;
      let savedPositions = {};
      let savedSizes = {};
      let savedStyles = {};
      let legendCollapsed = false;
      let minimapCollapsed = false;
      let drawToolbarCollapsed = false;
      let activeLayers = new Set(["physical", "logical", "security", "application"]);
      let currentView = {
       mode: "topology",
       rackId: null
      };
      let savedTopologyView = null;
      let topologyToolbarCollapsed = false;
      let legendMiniBtn = null;
      let minimapMiniBtn = null;
      let drawToolbarMiniBtn = null;
      let topologyToolbarMiniBtn = null;
      let undoStack = [];
      let redoStack = [];
      const MAX_UNDO_STACK = 50;
      let selectedNodes = new Set();
      let selectedEdges = new Set();
      let selectedRects = new Set();
      let selectedTexts = new Set();
      let isSelecting = false;
      let selectionStart = null;
      let preDragSelectedNodes = new Set();
      let preDragSelectedEdges = new Set();
      let preDragSelectedRects = new Set();
      let preDragSelectedTexts = new Set();
      let selectionRect = null;
      let selectionBoxStyle = {
       fillColor: "#4fd1c5",
       fillOpacity: 0.1,
       strokeColor: "#4fd1c5",
       strokeWidth: 2,
       strokeDasharray: "5,5"
      };
      let isDraggingSelection = false;
      let dragSelectionStart = null;
      let clipboard = null;
      const ROLLBACK_STORAGE_KEY = "theonefile_rollbacks";
      const MAX_ROLLBACK_VERSIONS = 50;
      let rollbackVersions = [];
      let currentRollbackIndex = -1;
      const AUDIT_STORAGE_KEY = "theonefile_audit_log";
      let auditLog = [];
      const MAX_AUDIT_ENTRIES = 1000;
      let documentTabs = [{
        id: "main",
        name: "Main Topology",
        nodes: {},
        edges: { list: [] },
        positions: {},
        sizes: {},
        styles: {},
        legend: {},
        rects: { list: [] },
        texts: { list: [] },
      pageState: null
      }];
      let currentTabIndex = 0;
      let encryptedSections = {};
      let performanceMode = "auto";
      let cullOffscreenNodes = true;
      let minimapNeedsUpdate = true;
      let lastMinimapUpdate = 0;
      const MobileManager = {
        isMobile: false,
        detect() {
          if (navigator.userAgentData?.mobile === true) {
            this.isMobile = true;
            return true;
          }
          const coarse = matchMedia("(pointer: coarse)").matches;
          const width = window.innerWidth <= 900;
          const portrait = matchMedia("(orientation: portrait)").matches;
          this.isMobile = coarse && (width || portrait);
          return this.isMobile;
        },
        applyInitialCollapse() {
          if (!this.isMobile) return;
          legendCollapsed = true;
          minimapCollapsed = true;
          drawToolbarCollapsed = true;
          topologyToolbarCollapsed = true;
          if (typeof updateLegendVisibility === "function") updateLegendVisibility();
          if (typeof updateMinimapVisibility === "function") updateMinimapVisibility();
          if (typeof updateDrawToolbarVisibility === "function") updateDrawToolbarVisibility();
          if (typeof updateTopologyToolbarVisibility === "function") updateTopologyToolbarVisibility();
        },
        updateBulkToolbar() {
          const desktop = document.getElementById("bulk-toolbar");
          const mobile = document.getElementById("bulk-toolbar-mobile");
          if (!desktop || !mobile) return;
          if (typeof selectedNodes === 'undefined' || selectedNodes.size === 0) {
           desktop.style.display = "none";
           mobile.style.display = "none";
           return;
          }
          const isVisible = desktop.style.display !== "none" || mobile.style.display !== "none";
          if (this.isMobile) {
            desktop.style.display = "none";
            if (isVisible) {
              mobile.style.display = "flex";
            }
          } else {
            mobile.style.display = "none";
            if (isVisible) {
              desktop.style.display = "flex";
            }
          }
        },
        updateLayout() {
          const main = document.querySelector("main");
          if (!main) return;
        },
        updateCanvasHint() {
      const hint = document.getElementById("canvas-hint");
      if (!hint) return;
      if (PAGE_STATE.canvasHintText !== undefined && PAGE_STATE.canvasHintText !== "") {
        hint.innerHTML = PAGE_STATE.canvasHintText;
        return;
      }
      const items = this.isMobile
      ? [
        "Pinch to zoom",
        "Drag to pan",
        "Add node from top menu",
        "Double tap to clone and align",
        "Double tap to select multiple",
        "You have the power",
        "Your time is NOW!",
      ]
      : [
        "Scroll to zoom",
        "Drag to pan",
        "Right click to clone and align",
        "Right click to select multiple",
	    "Hold Shift + drag mouse for marquee selection",
        "You have the power",
        "Your time is NOW!",
      ];
      const list = document.createElement("ul");
      for (const item of items) {
      const li = document.createElement("li");
      li.textContent = item;
      list.appendChild(li);
      }
      hint.replaceChildren(list);
      },
        autoSelectStyleScope() {
          const scope = document.getElementById("style-scope");
          if (!scope) return;
          if (this.isMobile) scope.value = "mobile";
        },
        updateToolbarStack() {
          if (!this.isMobile) return;
          const draw = document.getElementById("draw-toolbar");
          const topo = document.getElementById("topology-toolbar");
          if (!draw || !topo) return;
          const h = draw.getBoundingClientRect().height;
          document.documentElement.style.setProperty("--draw-toolbar-height", h + "px");
        },
        updateLayoutControls() {
          const sidebarRow = document.getElementById("sidebar-width-row");
          const footerRow = document.getElementById("mobile-footer-row");
          if (sidebarRow && footerRow) {
            if (this.isMobile) {
              sidebarRow.style.display = "none";
              footerRow.style.display = "flex";
            } else {
              sidebarRow.style.display = "flex";
              footerRow.style.display = "none";
            }
          }
        },
        applyAll() {
          this.detect();
          this.applyInitialCollapse();
          this.updateBulkToolbar();
          this.updateLayout();
          this.updateCanvasHint();
          this.autoSelectStyleScope();
          this.updateToolbarStack();
          this.updateLayoutControls();
        }
      };
      function isMobileDevice() {
        return MobileManager.isMobile;
      }
      function u8ToBase64(u8) {
      let binary = "";
      for (let i = 0; i < u8.length; i++) binary += String.fromCharCode(u8[i]);
      return btoa(binary);
      }
      function base64ToU8(base64) {
      const binary = atob(base64);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
      return bytes;
      }
			  function ensureLegendMiniButton() {
		   if (legendMiniBtn) return legendMiniBtn;
		   const handleClick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			legendCollapsed = false;
			updateLegendVisibility();
		   };
		   const preventTouch = (e) => { e.preventDefault(); };
		   const existing = document.getElementById("edge-legend-mini");
		   if (existing) {
			existing.addEventListener("click", handleClick);
			existing.addEventListener("touchstart", preventTouch, { passive: false });
			existing.addEventListener("touchend", handleClick);
			legendMiniBtn = existing;
			return existing;
		   }
		   const panel = document.querySelector(".topology-panel");
		   if (!panel) return null;
		   const btn = document.createElement("button");
		   btn.type = "button";
		   btn.id = "edge-legend-mini";
		   btn.className = "legend-mini-btn";
		   btn.textContent = "Legend";
		   btn.style.bottom = "10px";
		   btn.addEventListener("click", handleClick);
		   btn.addEventListener("touchstart", preventTouch, { passive: false });
		   btn.addEventListener("touchend", handleClick);
		   panel.appendChild(btn);
		   legendMiniBtn = btn;
		   return btn;
		}
			  function ensureMinimapMiniButton() {
		   if (minimapMiniBtn) return minimapMiniBtn;
		   const handleClick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			minimapCollapsed = false;
			updateMinimapVisibility();
		   };
		   const preventTouch = (e) => { e.preventDefault(); };
		   const existing = document.getElementById("minimap-mini");
		   if (existing) {
			existing.addEventListener("click", handleClick);
			existing.addEventListener("touchstart", preventTouch, { passive: false });
			existing.addEventListener("touchend", handleClick);
			minimapMiniBtn = existing;
			return existing;
		   }
		   const panel = document.querySelector(".topology-panel");
		   if (!panel) return null;
		   const btn = document.createElement("button");
		   btn.type = "button";
		   btn.id = "minimap-mini";
		   btn.className = "legend-mini-btn";
		   btn.textContent = "Map";
		   btn.style.right = "10px";
		   btn.style.left = "auto";
		   btn.style.bottom = "10px";
		   btn.addEventListener("click", handleClick);
		   btn.addEventListener("touchstart", preventTouch, { passive: false });
		   btn.addEventListener("touchend", handleClick);
		   panel.appendChild(btn);
		   minimapMiniBtn = btn;
		   return btn;
		}
			  function ensureDrawToolbarMiniButton() {
		   if (drawToolbarMiniBtn) return drawToolbarMiniBtn;
		   const handleClick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			drawToolbarCollapsed = false;
			updateDrawToolbarVisibility();
		   };
		   const preventTouch = (e) => { e.preventDefault(); };
		   const existing = document.getElementById("draw-toolbar-mini");
		   if (existing) {
			existing.addEventListener("click", handleClick);
			existing.addEventListener("touchstart", preventTouch, { passive: false });
			existing.addEventListener("touchend", handleClick);
			drawToolbarMiniBtn = existing;
			return existing;
		   }
		   const panel = document.querySelector(".topology-panel");
		   if (!panel) return null;
		   const btn = document.createElement("button");
		   btn.type = "button";
		   btn.id = "draw-toolbar-mini";
		   btn.className = "legend-mini-btn";
		   btn.textContent = "Draw";
		   btn.style.top = "10px";
		   btn.style.left = "10px";
		   btn.style.right = "auto";
		   btn.addEventListener("click", handleClick);
		   btn.addEventListener("touchstart", preventTouch, { passive: false });
		   btn.addEventListener("touchend", handleClick);
		   panel.appendChild(btn);
		   drawToolbarMiniBtn = btn;
		   return btn;
		}
			  function ensureTopologyToolbarMiniButton() {
		   if (topologyToolbarMiniBtn) return topologyToolbarMiniBtn;
		   const handleClick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			topologyToolbarCollapsed = false;
			updateTopologyToolbarVisibility();
		   };
		   const preventTouch = (e) => { e.preventDefault(); };
		   const existing = document.getElementById("topology-toolbar-mini");
		   if (existing) {
			existing.addEventListener("click", handleClick);
			existing.addEventListener("touchstart", preventTouch, { passive: false });
			existing.addEventListener("touchend", handleClick);
			topologyToolbarMiniBtn = existing;
			return existing;
		   }
		   const panel = document.querySelector(".topology-panel");
		   if (!panel) return null;
		   const btn = document.createElement("button");
		   btn.type = "button";
		   btn.id = "topology-toolbar-mini";
		   btn.className = "legend-mini-btn";
		   btn.textContent = "Add Line";
		   btn.style.top = "10px";
		   btn.style.left = "auto";
		   btn.style.right = "40px";
		   btn.addEventListener("click", handleClick);
		   btn.addEventListener("touchstart", preventTouch, { passive: false });
		   btn.addEventListener("touchend", handleClick);
		   panel.appendChild(btn);
		   topologyToolbarMiniBtn = btn;
		   return btn;
		}
      function updateToolbarStack() {
       if (!isMobileDevice()) return;
       const draw = document.getElementById("draw-toolbar");
       const topo = document.getElementById("topology-toolbar");
       if (!draw || !topo) return;
       const h = draw.getBoundingClientRect().height;
       document.documentElement.style.setProperty("--draw-toolbar-height", h + "px");
      }
      window.addEventListener("resize", updateToolbarStack);
      window.addEventListener("DOMContentLoaded", updateToolbarStack);
      updateToolbarStack();
      function updateLegendVisibility() {
       const legend = document.getElementById("edge-legend");
       const mini = ensureLegendMiniButton();
       if (!legend || !mini) return;
       const hasItems = legend.querySelectorAll(".legend-item").length > 0;
       if (!hasItems) {
        legend.style.display = "none";
        mini.style.display = "none";
        return;
       }
       if (legendCollapsed) {
        legend.style.display = "none";
        mini.style.display = "inline-flex";
       } else {
        legend.style.display = "flex";
        mini.style.display = "none";
       }
      }
      function updateMinimapVisibility() {
       const wrapper = document.getElementById("minimap-zoom-wrapper");
       const mini = ensureMinimapMiniButton();
       if (!wrapper || !mini) return;
       if (minimapCollapsed) {
        wrapper.style.display = "none";
        mini.style.display = "inline-flex";
       } else {
        wrapper.style.display = "block";
        mini.style.display = "none";
       }
      }
      function updateDrawToolbarVisibility() {
       const toolbar = document.getElementById("draw-toolbar");
       const mini = ensureDrawToolbarMiniButton();
       if (isViewOnly()) {
        if (toolbar) toolbar.style.setProperty('display', 'none', 'important');
        if (mini) mini.style.display = "none";
        return;
       }
       if (!toolbar || !mini) return;
       if (drawToolbarCollapsed) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "inline-flex";
       } else {
      if (isMobileDevice()) {
        toolbar.style.setProperty('display', 'grid', 'important');
        mini.style.display = "none";
      } else {
        toolbar.style.setProperty('display', 'flex', 'important');
        mini.style.display = "none";
      }
       }
      }
      function updateTopologyToolbarVisibility() {
       const toolbar = document.getElementById("topology-toolbar");
       const mini = ensureTopologyToolbarMiniButton();
       if (isViewOnly()) {
        if (toolbar) toolbar.style.setProperty('display', 'none', 'important');
        if (mini) mini.style.display = "none";
        return;
       }
       if (!toolbar || !mini) return;
       const hasSelectedNode = currentNodeId !== null;
       if (!hasSelectedNode) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "none";
       } else if (topologyToolbarCollapsed) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "inline-flex";
       } else {
      if (isMobileDevice()) {
        toolbar.style.setProperty('display', 'grid', 'important');
        mini.style.display = "none";
        } else {
        toolbar.style.setProperty('display', 'flex', 'important');
        mini.style.display = "none";
      }
       }
      }
      const DEFAULT_CANVAS_HINT = document.getElementById("canvas-hint")?.innerHTML || "";
      const DEFAULT_PAGE_STATE = {
       title: "The One File",
       background: "",
       topbarBg: "rgba(9, 12, 20, 0.9)",
       topbarBorder: "#1f2533",
       panel: "#0b0e13",
       panelAlt: "#10141b",
       accent: "#4fd1c5",
       sidebarBg: "#10141b",
       btnBg: "#0b0e13",
       btnText: "#e2e8f0",
       tagFill: "#1e293b",
       tagText: "#e2e8f0",
       tagBorder: "#475569",
       inputBg: "#0b0e13",
       inputText: "#e2e8f0",
       inputBorder: "#1f2937",
       inputFont: "Inter, system-ui, sans-serif",
       inputFontSize: 14,
       toolbarBg: "#0f172a",
       toolbarBorder: "#1f2937",
       toolbarText: "#94a3b8",
       toolbarBtnBg: "#0b0e13",
       toolbarBtnText: "#e2e8f0",
       minimapDots: "#94a3b8",
       canvasHintEnabled: true,
       canvasHintText: "",
       canvasHintBg: "#0f172a",
       canvasHintColor: "#94a3b8",
       danger: "#f56565",
       textMain: "#e2e8f0",
       textSoft: "#94a3b8",
       topbarHeight: 52,
       sidebarWidth: 350,
       mobileFooterHeight: 40,
       sidebarCollapsed: false,
       nodeFill: "#1e293b",
       nodeStroke: "#475569",
       nodeTitle: "#e2e8f0",
       nodeSub: "#94a3b8",
       nodeTitleSize: 18,
       nodeSubSize: 13,
       nodeFont: "Inter, system-ui, sans-serif",
       defaultEdge: "#475569",
       selectionHandle: "#f59e0b",
       selectionHandleSize: 8,
       groupIndicator: "#4fd1c5",
      canvasGradientTop: "#1e2532",
       canvasGradientBottom: "#050608",
       canvasBorder: "#475569",
       canvasGrid: "#475569",
       canvasGridSize: 50,
       rackFrameFill: "#0f172a",
       rackFrameStroke: "#4fd1c5",
       rackLineColor: "#475569",
       rackTextColor: "#4fd1c5",
	   viewOnly: false,
      };
      let PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE);
	  function isViewOnly() {
       return PAGE_STATE.viewOnly === true;
      }
	  let viewOnlyClickCount = 0;
      let viewOnlyClickTimer = null;
      let viewOnlyClickTarget = null;
      function handleViewOnlyClick(id, type) {
       if (!isViewOnly()) return false;
       if (viewOnlyClickTarget !== id) {
        viewOnlyClickCount = 0;
        viewOnlyClickTarget = id;
       }
       viewOnlyClickCount++;
       clearTimeout(viewOnlyClickTimer);
       viewOnlyClickTimer = setTimeout(() => {
        viewOnlyClickCount = 0;
        viewOnlyClickTarget = null;
       }, 2000);
       if (viewOnlyClickCount >= 5) {
        viewOnlyClickCount = 0;
        viewOnlyClickTarget = null;
        document.body.classList.add("view-only-inspect");
        if (type === 'node') {
         currentNodeId = id;
         const data = NODE_DATA[id];
         if (data) {
          document.querySelectorAll(".node-group").forEach((n) => {
           n.classList.toggle("active", n.dataset.nodeId === id);
          });
          document.getElementById("node-panel").style.display = "block";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("node-name").textContent = data.name;
          document.getElementById("node-ip").textContent = data.ip;
          document.getElementById("node-role").textContent = data.role;
          document.getElementById("node-mac").textContent = data.mac || "--";
          document.getElementById("node-rack").textContent = data.rackUnit || "--";
          document.getElementById("node-uheight").textContent = (data.uHeight || "1") + "U";
          const tagList = document.getElementById("node-tags");
          if (tagList) {
           tagList.innerHTML = "";
           if (data.tags && data.tags.length > 0) {
            data.tags.forEach((tag) => {
             const li = document.createElement("li");
             li.textContent = tag;
             tagList.appendChild(li);
            });
           }
          }
          const noteList = document.getElementById("node-notes");
          if (noteList) {
           noteList.innerHTML = "";
           if (data.notes && data.notes.length > 0) {
            data.notes.forEach((note) => {
             const li = document.createElement("li");
             li.textContent = note;
             noteList.appendChild(li);
            });
           }
          }
         }
        } else if (type === 'edge') {
         currentEdgeId = id;
         const edge = EDGE_DATA.list.find(e => e.id === id);
         if (edge) {
          document.querySelectorAll(".edge").forEach((e) => {
           e.classList.toggle("active", e.dataset.edgeId === id);
          });
          document.getElementById("edge-panel").style.display = "block";
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-from").textContent = NODE_DATA[edge.from]?.name || edge.from;
          document.getElementById("edge-to").textContent = NODE_DATA[edge.to]?.name || edge.to;
          document.getElementById("edge-label").value = edge.label || "";
         }
        }
        return true;
       }
       return false;
      }
      const CANVAS_WIDTH = 4000;
      let CANVAS_HEIGHT = 3000;
      const BASE_CANVAS_HEIGHT = 3000;
      const CANVAS_PADDING = 100;
      const RACK_U_HEIGHT = 70;
      const RACK_WIDTH = 600;
      const RACK_START_X = CANVAS_WIDTH / 2;
      const RACK_START_Y = CANVAS_PADDING + 100;
      function getRackUHeight(rackId) {
      const capacity = getRackCapacity(rackId);
      const availableHeight = CANVAS_HEIGHT - RACK_START_Y - 200;
      return Math.floor(availableHeight / capacity);
      }
      let canvasState = {
       zoom: 1,
       panX: 0,
       panY: 0,
       minZoom: 0.25,
       maxZoom: 4,
       isPanning: false,
       panStartX: 0,
       panStartY: 0,
       spacePressed: false,
      };
      function getViewBox() {
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       return {
        x: canvasState.panX,
        y: canvasState.panY,
        width: viewWidth,
        height: viewHeight,
       };
      }
      function updateViewBox() {
       const svg = document.getElementById("map");
       const vb = getViewBox();
       svg.setAttribute("viewBox", `${vb.x} ${vb.y} ${vb.width} ${vb.height}`, );
       const zoomLevel = document.getElementById("zoom-level");
       if (zoomLevel) {
        zoomLevel.textContent = Math.round(canvasState.zoom * 100) + "%";
       }
       updateMinimap();
       populateRackDropdown();
      }
      function updateMinimap() {
       const minimapViewport = document.getElementById("minimap-viewport");
       const minimapSvg = document.getElementById("minimap");
       if (!minimapViewport || !minimapSvg) return;
       const vb = getViewBox();
       minimapViewport.setAttribute("x", vb.x);
       minimapViewport.setAttribute("y", vb.y);
       minimapViewport.setAttribute("width", vb.width);
       minimapViewport.setAttribute("height", vb.height);
       const minimapNodes = minimapSvg.querySelectorAll(".minimap-node");
       minimapNodes.forEach((n) => n.remove());
       const minimapEdges = minimapSvg.querySelectorAll(".minimap-edge");
       minimapEdges.forEach((e) => e.remove());
       EDGE_DATA.list.forEach((edge) => {
        if (edge.type === "custom") return;
        const fromNode = NODE_DATA[edge.from];
        const toNode = NODE_DATA[edge.to];
        if (!fromNode || !toNode) return;
        if (currentView.mode === "rack") {
         if (fromNode.assignedRack !== currentView.rackId ||
             toNode.assignedRack !== currentView.rackId) {
          return;
         }
        } else {
         if (fromNode.assignedRack || toNode.assignedRack) {
          return;
         }
        }
        const p1 = savedPositions[edge.from];
        const p2 = savedPositions[edge.to];
        if (!p1 || !p2) return;
        const line = document.createElementNS("http://www.w3.org/2000/svg", "line", );
        line.setAttribute("x1", p1.x);
        line.setAttribute("y1", p1.y);
        line.setAttribute("x2", p2.x);
        line.setAttribute("y2", p2.y);
        line.classList.add("minimap-edge");
        minimapSvg.insertBefore(line, minimapViewport);
       });
       Object.entries(savedPositions).forEach(([id, pos]) => {
        const node = NODE_DATA[id];
        if (!node) return;
        if (currentView.mode === "rack") {
         if (node.assignedRack !== currentView.rackId) {
          return;
         }
        } else {
         if (node.assignedRack) {
          return;
         }
        }
        const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle", );
        circle.setAttribute("cx", pos.x);
        circle.setAttribute("cy", pos.y);
        circle.setAttribute("r", 40);
        circle.classList.add("minimap-node");
        minimapSvg.insertBefore(circle, minimapViewport);
       });
      }
      function zoomTo(newZoom, centerX, centerY) {
       const oldZoom = canvasState.zoom;
       newZoom = Math.max(canvasState.minZoom, Math.min(canvasState.maxZoom, newZoom), );
       if (centerX !== undefined && centerY !== undefined) {
        const oldWidth = CANVAS_WIDTH / oldZoom;
        const oldHeight = CANVAS_HEIGHT / oldZoom;
        const newWidth = CANVAS_WIDTH / newZoom;
        const newHeight = CANVAS_HEIGHT / newZoom;
        const pointX = canvasState.panX + centerX * oldWidth;
        const pointY = canvasState.panY + centerY * oldHeight;
        canvasState.panX = pointX - centerX * newWidth;
        canvasState.panY = pointY - centerY * newHeight;
       }
       canvasState.zoom = newZoom;
       constrainPan();
       updateViewBox();
      }
      function constrainPan() {
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       const minVisiblePortion = 0.1;
       const maxPanX = CANVAS_WIDTH - viewWidth * minVisiblePortion;
       const maxPanY = CANVAS_HEIGHT - viewHeight * minVisiblePortion;
       const minPanX = -viewWidth * (1 - minVisiblePortion);
       const minPanY = -viewHeight * (1 - minVisiblePortion);
       canvasState.panX = Math.max(minPanX, Math.min(maxPanX, canvasState.panX), );
       canvasState.panY = Math.max(minPanY, Math.min(maxPanY, canvasState.panY), );
      }
      function fitToContent() {
       const positions = Object.values(savedPositions);
       if (positions.length === 0) {
        resetView();
        return;
       }
       let minX = Infinity,
        minY = Infinity,
        maxX = -Infinity,
        maxY = -Infinity;
       positions.forEach((pos) => {
        minX = Math.min(minX, pos.x - 100);
        minY = Math.min(minY, pos.y - 100);
        maxX = Math.max(maxX, pos.x + 100);
        maxY = Math.max(maxY, pos.y + 100);
       });
       const contentWidth = maxX - minX + 200;
       const contentHeight = maxY - minY + 200;
       const viewport = document.getElementById("canvas-viewport");
       const vpRect = viewport.getBoundingClientRect();
       const aspectRatio = vpRect.width / vpRect.height;
       const contentAspect = contentWidth / contentHeight;
       let newZoom;
       if (contentAspect > aspectRatio) {
        newZoom = (vpRect.width / contentWidth) * (CANVAS_WIDTH / vpRect.width);
       } else {
        newZoom = (vpRect.height / contentHeight) * (CANVAS_HEIGHT / vpRect.height);
       }
       newZoom = Math.max(canvasState.minZoom, Math.min(2, newZoom));
       const viewWidth = CANVAS_WIDTH / newZoom;
       const viewHeight = CANVAS_HEIGHT / newZoom;
       canvasState.zoom = newZoom;
       canvasState.panX = minX - 100 - (viewWidth - contentWidth) / 2;
       canvasState.panY = minY - 100 - (viewHeight - contentHeight) / 2;
       constrainPan();
       updateViewBox();
      }
      function resetView() {
       canvasState.zoom = 1;
       canvasState.panX = 0;
       canvasState.panY = 0;
       updateViewBox();
      }
      window.addEventListener("DOMContentLoaded", () => {
       const toggle = document.getElementById("mobile-menu-toggle");
       const menu = document.getElementById("topbar-menu");
       if (!toggle || !menu) return;
       toggle.addEventListener("click", () => {
        menu.classList.toggle("open");
       });
       menu.addEventListener("click", (e) => {
        const target = e.target.closest("a, button");
        if (!target) return;
        if (isMobileDevice()) {
       menu.classList.remove("open");
      }
       });
       const minimapCloseBtn = document.getElementById("minimap-close-btn");
       if (minimapCloseBtn) {
        const handleMinimapClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         minimapCollapsed = true;
         updateMinimapVisibility();
        };
        minimapCloseBtn.addEventListener("click", handleMinimapClose);
        minimapCloseBtn.addEventListener("touchend", handleMinimapClose);
       }
       const drawToolbarCloseBtn = document.getElementById("draw-toolbar-close-btn");
       if (drawToolbarCloseBtn) {
        const handleDrawClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         drawToolbarCollapsed = true;
         updateDrawToolbarVisibility();
        };
        drawToolbarCloseBtn.addEventListener("click", handleDrawClose);
        drawToolbarCloseBtn.addEventListener("touchend", handleDrawClose);
       }
       const topologyToolbarCloseBtn = document.getElementById("topology-toolbar-close-btn");
       if (topologyToolbarCloseBtn) {
        const handleTopologyClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         topologyToolbarCollapsed = true;
         updateTopologyToolbarVisibility();
        };
        topologyToolbarCloseBtn.addEventListener("click", handleTopologyClose);
        topologyToolbarCloseBtn.addEventListener("touchstart", (e) => e.preventDefault(), {
         passive: false
        });
        topologyToolbarCloseBtn.addEventListener("touchend", handleTopologyClose);
       }
       updateMinimapVisibility();
       updateDrawToolbarVisibility();
       updateTopologyToolbarVisibility();
      });
      function applyLayerFilter() {
       activeLayers.clear();
       if (document.getElementById("layer-physical").checked) activeLayers.add("physical");
       if (document.getElementById("layer-logical").checked) activeLayers.add("logical");
       if (document.getElementById("layer-security").checked) activeLayers.add("security");
       if (document.getElementById("layer-application").checked) activeLayers.add("application");
       forgeTheTopology();
      }
      function isNodeVisible(nodeId) {
       const node = NODE_DATA[nodeId];
       if (!node) return false;
       const nodeLayer = node.layer || "physical";
       return activeLayers.has(nodeLayer);
      }
      function enterRack(rackId) {
      if (!NODE_DATA[rackId] || !NODE_DATA[rackId].isRack) return;
      const rackCapacity = getRackCapacity(rackId);
      const neededHeight = RACK_START_Y + (rackCapacity * RACK_U_HEIGHT) + 200;
      if (neededHeight > BASE_CANVAS_HEIGHT) {
      CANVAS_HEIGHT = neededHeight;
      }
       savedTopologyView = {
        zoom: canvasState.zoom,
        panX: canvasState.panX,
        panY: canvasState.panY
       };
       currentView.mode = "rack";
       currentView.rackId = rackId;
       const backBtn = document.getElementById("back-to-topology-btn");
       if (backBtn) backBtn.style.display = "inline-block";
       const hint = document.getElementById("canvas-hint");
       if (hint) {
        hint.textContent = `Viewing: ${NODE_DATA[rackId].name} | Double click empty space to exit`;
        hint.classList.add("visible");
       }
      const rackUHeight = getRackUHeight(rackId);
      const rackHeight = rackCapacity * rackUHeight;
      const rackCenterX = RACK_START_X;
      const rackCenterY = RACK_START_Y + (rackHeight / 2);
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       canvasState.panX = rackCenterX - (viewWidth / 2);
       canvasState.panY = rackCenterY - (viewHeight / 2);
       constrainPan();
       updateViewBox();
       forgeTheTopology();
      }
      function exitRack() {
      CANVAS_HEIGHT = BASE_CANVAS_HEIGHT;
      currentView.mode = "topology";
      currentView.rackId = null;
       const backBtn = document.getElementById("back-to-topology-btn");
       if (backBtn) backBtn.style.display = "none";
       const hint = document.getElementById("canvas-hint");
       if (hint) {
        hint.classList.remove("visible");
       }
       if (savedTopologyView) {
        canvasState.zoom = savedTopologyView.zoom;
        canvasState.panX = savedTopologyView.panX;
        canvasState.panY = savedTopologyView.panY;
        updateViewBox();
       }
       forgeTheTopology();
      }
      function getRackCapacity(rackId) {
       const node = NODE_DATA[rackId];
       return node && node.rackCapacity ? parseInt(node.rackCapacity) : 42;
      }
      function populateRackDropdown() {
       const dropdown = document.getElementById("node-assigned-rack");
       if (!dropdown) return;
       dropdown.innerHTML = '<option value="">None</option>';
       Object.keys(NODE_DATA).forEach(id => {
        if (NODE_DATA[id].isRack) {
         const option = document.createElement("option");
         option.value = id;
         option.textContent = NODE_DATA[id].name;
         dropdown.appendChild(option);
        }
       });
      }
      function wieldThePower() {
       const root = document.documentElement;
       root.style.setProperty("--panel", PAGE_STATE.panel);
       root.style.setProperty("--panel-alt", PAGE_STATE.panelAlt);
       root.style.setProperty("--sidebar-bg", PAGE_STATE.sidebarBg || PAGE_STATE.panelAlt);
       root.style.setProperty("--btn-bg", PAGE_STATE.btnBg || PAGE_STATE.panel);
       root.style.setProperty("--btn-text", PAGE_STATE.btnText || "#e2e8f0");
       root.style.setProperty("--tag-fill", PAGE_STATE.tagFill || "#1e293b");
       root.style.setProperty("--tag-text", PAGE_STATE.tagText || "#e2e8f0");
       root.style.setProperty("--tag-border", PAGE_STATE.tagBorder || "#475569");
       root.style.setProperty("--input-bg", PAGE_STATE.inputBg || "#0b0e13");
       root.style.setProperty("--input-text", PAGE_STATE.inputText || "#e2e8f0");
       root.style.setProperty("--input-border", PAGE_STATE.inputBorder || "#1f2937");
       root.style.setProperty("--input-font", PAGE_STATE.inputFont || "Inter, system-ui, sans-serif");
       root.style.setProperty("--input-font-size", (PAGE_STATE.inputFontSize || 14) + "px");
       root.style.setProperty("--toolbar-bg", PAGE_STATE.toolbarBg || "#0f172a");
       root.style.setProperty("--toolbar-border", PAGE_STATE.toolbarBorder || "#1f2937");
       root.style.setProperty("--toolbar-text", PAGE_STATE.toolbarText || "#94a3b8");
       root.style.setProperty("--toolbar-btn-bg", PAGE_STATE.toolbarBtnBg || "#0b0e13");
       root.style.setProperty("--toolbar-btn-text", PAGE_STATE.toolbarBtnText || "#e2e8f0");
       root.style.setProperty("--minimap-dots", PAGE_STATE.minimapDots || "#94a3b8");
       root.style.setProperty("--canvas-hint-bg", PAGE_STATE.canvasHintBg || "#0f172a");
       root.style.setProperty("--canvas-hint-color", PAGE_STATE.canvasHintColor || "#94a3b8");
       const canvasHint = document.getElementById("canvas-hint");
       if (canvasHint) {
        canvasHint.style.display = PAGE_STATE.canvasHintEnabled === false ? "none" : "";
        if (PAGE_STATE.canvasHintText !== undefined && PAGE_STATE.canvasHintText !== "") {
         canvasHint.innerHTML = PAGE_STATE.canvasHintText;
        } else {
         canvasHint.innerHTML = DEFAULT_CANVAS_HINT;
        }
       }
       root.style.setProperty("--accent", PAGE_STATE.accent);
       root.style.setProperty("--danger", PAGE_STATE.danger);
       root.style.setProperty("--text-main", PAGE_STATE.textMain);
       root.style.setProperty("--text-soft", PAGE_STATE.textSoft);
       root.style.setProperty("--topbar-bg", PAGE_STATE.topbarBg);
       root.style.setProperty("--topbar-border", PAGE_STATE.topbarBorder);
       root.style.setProperty("--node-fill", PAGE_STATE.nodeFill || "#1e293b");
       root.style.setProperty("--node-stroke", PAGE_STATE.nodeStroke || "#475569");
       root.style.setProperty("--node-title", PAGE_STATE.nodeTitle || "#e2e8f0");
       root.style.setProperty("--node-sub", PAGE_STATE.nodeSub || "#94a3b8");
       root.style.setProperty("--node-title-size", (PAGE_STATE.nodeTitleSize || 18) + "px");
       root.style.setProperty("--node-sub-size", (PAGE_STATE.nodeSubSize || 13) + "px");
       root.style.setProperty("--node-font", PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif");
       root.style.setProperty("--default-edge", PAGE_STATE.defaultEdge || "#475569");
       root.style.setProperty("--selection-handle", PAGE_STATE.selectionHandle || "#f59e0b");
       root.style.setProperty("--selection-handle-size", (PAGE_STATE.selectionHandleSize || 8) + "px");
       root.style.setProperty("--group-indicator", PAGE_STATE.groupIndicator || "#4fd1c5");
       const topbarHeight = PAGE_STATE.topbarHeight || 52;
       const sidebarWidth = PAGE_STATE.sidebarWidth || 350;
       const mobileFooterHeight = PAGE_STATE.mobileFooterHeight || 40;
       root.style.setProperty("--topbar-height", topbarHeight + "px");
       root.style.setProperty("--sidebar-width", sidebarWidth + "px");
       root.style.setProperty("--mobile-footer-height", mobileFooterHeight + "vh", );
       const mainEl = document.querySelector("main");
       const detailsPanel = document.getElementById("details-panel");
       const sidebarToggle = document.getElementById("sidebar-toggle");
       if (PAGE_STATE.sidebarCollapsed) {
        if (mainEl) mainEl.classList.add("sidebar-collapsed");
        if (detailsPanel) detailsPanel.classList.add("collapsed");
        if (sidebarToggle) {
         sidebarToggle.classList.add("collapsed");
         sidebarToggle.textContent = "▶";
        }
       } else {
        if (mainEl) mainEl.classList.remove("sidebar-collapsed");
        if (detailsPanel) detailsPanel.classList.remove("collapsed");
        if (sidebarToggle) {
         sidebarToggle.classList.remove("collapsed");
         sidebarToggle.textContent = "◀";
        }
       }
       if (PAGE_STATE.background) {
        document.body.style.background = PAGE_STATE.background;
       } else {
        document.body.style.background = `radial-gradient(circle at top, ${PAGE_STATE.canvasGradientTop || "#1e2532"} 0, ${PAGE_STATE.canvasGradientBottom || "#050608"} 70%)`;
       }
       document.title = PAGE_STATE.title || DEFAULT_PAGE_STATE.title;
       const titleEl = document.getElementById("page-title");
       if (titleEl) {
        titleEl.textContent = PAGE_STATE.title || DEFAULT_PAGE_STATE.title;
       }
       const sidebarToggleEl = document.getElementById("sidebar-toggle");
       const isMobile = isMobileDevice();
       if (sidebarToggleEl) {
        sidebarToggleEl.style.display = isMobile ? "none" : "flex";
       }
       const viewOnlyMode = PAGE_STATE.viewOnly === true;
       const addNodeBtn = document.getElementById("add-node-btn");
       const addRackBtn = document.getElementById("add-rack-btn");
       const drawToolbar = document.getElementById("draw-toolbar");
       const topologyToolbar = document.getElementById("topology-toolbar");
       const bulkToolbar = document.getElementById("bulk-toolbar");
       if (addNodeBtn) addNodeBtn.style.display = viewOnlyMode ? "none" : "";
       if (addRackBtn) addRackBtn.style.display = viewOnlyMode ? "none" : "";
       if (viewOnlyMode) {
        if (drawToolbar) drawToolbar.style.setProperty('display', 'none', 'important');
        if (topologyToolbar) topologyToolbar.style.setProperty('display', 'none', 'important');
        if (bulkToolbar) bulkToolbar.style.display = "none";
        const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
       }
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       if (bulkToolbarMobile) bulkToolbarMobile.style.display = viewOnlyMode ? "none" : "";
       ["draw-toolbar-mini", "topology-toolbar-mini"].forEach(id => {
        const el = document.getElementById(id);
        if (el) el.style.display = viewOnlyMode ? "none" : "";
       });
       document.body.classList.toggle("view-only-mode", viewOnlyMode);
      }
      (async function awakeTheImmortal() {
       let initialState = {};
       let decryptionCancelled = false;
       const stateEl = document.getElementById("topology-state");
       if (stateEl && stateEl.textContent.trim()) {
        try {
         let stateText = stateEl.textContent.trim();
         if (isEncrypted(stateText)) {
          let decrypted = false;
          let attempts = 0;
          const maxAttempts = 3;
          while (!decrypted && attempts < maxAttempts) {
           const password = prompt("This file is encrypted. Enter password to decrypt:\n(Attempt " + (attempts + 1) + " of " + maxAttempts + ")", );
           if (!password) {
            alert("Decryption cancelled. The file will not be loaded.", );
            decryptionCancelled = true;
            break;
           }
           try {
            stateText = await decryptData(stateText, password);
            decrypted = true;
           } catch (e) {
            attempts++;
            if (attempts < maxAttempts) {
             alert("Incorrect password. Please try again.");
            } else {
             alert("Maximum attempts reached. The file will not be loaded.", );
             decryptionCancelled = true;
            }
           }
          }
          if (!decrypted) {
           stateText = "{}";
          }
         }
         initialState = JSON.parse(stateText);
        } catch (e) {
         console.error("Failed to load state:", e);
         initialState = {};
        }
       }
       if (decryptionCancelled) {
        NODE_DATA = {};
        EDGE_DATA = {
         list: []
        };
        RECT_DATA = { list: [] };
        TEXT_DATA = { list: [] };
        EDGE_LEGEND = {};
        savedPositions = {};
        savedSizes = {};
        savedStyles = {};
       } else {
        NODE_DATA = initialState.nodeData ? initialState.nodeData : BASE_NODE_DATA;
        EDGE_DATA = initialState.edgeData ? initialState.edgeData : {
         list: [],
        };
        RECT_DATA = initialState.rectData ? initialState.rectData : { list: [] };
        TEXT_DATA = initialState.textData ? initialState.textData : { list: [] };
        EDGE_LEGEND = initialState.edgeLegend || {};
        savedPositions = initialState.nodePositions || {};
        savedSizes = initialState.nodeSizes || {};
        savedStyles = initialState.nodeStyles || {};
       }
       if (initialState.page) {
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, initialState.page, );
       }
       if (initialState.canvas) {
        canvasState.zoom = initialState.canvas.zoom || 1;
        canvasState.panX = initialState.canvas.panX || 0;
        canvasState.panY = initialState.canvas.panY || 0;
       }
       if (initialState.savedTopologyView) {
        savedTopologyView = initialState.savedTopologyView;
       }
       if (initialState.documentTabs) {
        documentTabs = initialState.documentTabs;
        currentTabIndex = initialState.currentTabIndex || 0;
        const currentTab = documentTabs[currentTabIndex];
        if (currentTab) {
          NODE_DATA = currentTab.nodes || NODE_DATA;
          EDGE_DATA = currentTab.edges || EDGE_DATA;
          savedPositions = currentTab.positions || savedPositions;
          savedSizes = currentTab.sizes || savedSizes;
          savedStyles = currentTab.styles || savedStyles;
          EDGE_LEGEND = currentTab.legend || EDGE_LEGEND;
          RECT_DATA = currentTab.rects || RECT_DATA;
          TEXT_DATA = currentTab.texts || TEXT_DATA;
      if (currentTab.pageState) PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, currentTab.pageState);
        }
       }
       if (initialState.encryptedSections) {
        encryptedSections = initialState.encryptedSections;
       }
       wieldThePower();
       forgeTheTopology();
       updateViewBox();
       MobileManager.applyAll();
       const initialNodes = Object.keys(NODE_DATA);
       if (initialNodes.length > 0) {
        claimTheImmortal(initialNodes.includes("host") ? "host" : initialNodes[0], );
       } else {
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.display = "none";
       }
      })();
      let resizeDebounceTimer = null;
      window.addEventListener("resize", () => {
        clearTimeout(resizeDebounceTimer);
        resizeDebounceTimer = setTimeout(() => {
          MobileManager.applyAll();
          if (typeof updateDrawToolbarVisibility === 'function') updateDrawToolbarVisibility();
          if (typeof updateTopologyToolbarVisibility === 'function') updateTopologyToolbarVisibility();
        }, 100);
      });
      function getBreakpointKey() {
       const w = window.innerWidth;
       if (w <= 380) return "fold";
       if (w <= 768) return "mobile";
       if (w <= 1024) return "tablet";
       return "desktop";
      }
      function resolveStylesEntry(styleEntry) {
       if (!styleEntry) return {};
       if (styleEntry.circleColor || styleEntry.titleColor || styleEntry.titleFont || styleEntry.titleSize || styleEntry.subColor || styleEntry.subFont || styleEntry.subSize) {
        return styleEntry;
       }
       const bp = getBreakpointKey();
       const base = styleEntry.all || {};
       const bpStyles = styleEntry[bp] || {};
       return Object.assign({}, base, bpStyles);
      }
      function resolveStylesForNode(id) {
       const styleEntry = savedStyles[id];
       if (!styleEntry) return {};
       return resolveStylesEntry(styleEntry);
      }
      function ensureStyleEntry(id) {
       if (!savedStyles[id]) savedStyles[id] = {};
       const entry = savedStyles[id];
       const flatProps = ["circleColor", "circleBorder", "titleColor", "titleFont", "titleSize", "subColor", "subFont", "subSize", ];
       const isFlat = flatProps.some((p) => Object.prototype.hasOwnProperty.call(entry, p), );
       if (isFlat) {
        const all = entry.all || {};
        flatProps.forEach((p) => {
         if (entry[p] !== undefined) {
          all[p] = entry[p];
          delete entry[p];
         }
        });
        entry.all = all;
       }
       return entry;
      }
      function getDefaultSize() {
       if (window.innerWidth <= 380) return 120;
       if (window.innerWidth <= 768) return 140;
       if (window.innerWidth <= 1024) return 70;
       return 55;
      }
      function createShapeElement(shape, size) {
       const ns = "http://www.w3.org/2000/svg";
       if (shape === "circle") {
        const c = document.createElementNS(ns, "circle");
        c.setAttribute("r", size);
        return c;
       }
       if (shape === "square") {
        const r = document.createElementNS(ns, "rect");
        const s = size * 2;
        r.setAttribute("x", -size);
        r.setAttribute("y", -size);
        r.setAttribute("width", s);
        r.setAttribute("height", s);
        r.setAttribute("rx", 4);
        return r;
       }
       if (shape === "rectangle") {
        const r = document.createElementNS(ns, "rect");
        r.setAttribute("x", -size * 1.4);
        r.setAttribute("y", -size * 0.8);
        r.setAttribute("width", size * 2.8);
        r.setAttribute("height", size * 1.6);
        r.setAttribute("rx", 6);
        return r;
       }
       if (shape === "triangle") {
        const p = document.createElementNS(ns, "polygon");
        const h = size * 1.8;
        const w = size * 2;
        p.setAttribute("points", `0,${-h} ${w / 2},${h / 2} ${-w / 2},${h / 2}`, );
        return p;
       }
       if (shape === "hexagon") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        const pts = [
         [0, -s],
         [s * 0.86, -s * 0.5],
         [s * 0.86, s * 0.5],
         [0, s],
         [-s * 0.86, s * 0.5],
         [-s * 0.86, -s * 0.5],
        ].map((pt) => pt.join(",")).join(" ");
        p.setAttribute("points", pts);
        return p;
       }
       if (shape === "stop-sign") {
        const p = document.createElementNS(ns, "polygon");
        const r = size;
        const ptsArr = [];
        for (let i = 0; i < 8; i++) {
         const a = (Math.PI / 4) * i + Math.PI / 8;
         ptsArr.push([Math.cos(a) * r, Math.sin(a) * r]);
        }
        const pts = ptsArr.map((pt) => pt.join(",")).join(" ");
        p.setAttribute("points", pts);
        return p;
       }
       if (shape === "star") {
        const p = document.createElementNS(ns, "polygon");
        const outer = size;
        const inner = size * 0.45;
        let pts = "";
        for (let i = 0; i < 10; i++) {
         const a = (Math.PI / 5) * i - Math.PI / 2;
         const r = i % 2 === 0 ? outer : inner;
         pts += `${Math.cos(a) * r},${Math.sin(a) * r} `;
        }
        p.setAttribute("points", pts.trim());
        return p;
       }
       if (shape === "diamond") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `0,${-s} ${s},0 0,${s} ${-s},0`);
        return p;
       }
       if (shape === "server") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.2);
        body.setAttribute("y", -size * 0.6);
        body.setAttribute("width", size * 2.4);
        body.setAttribute("height", size * 1.2);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 3; i++) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", -size * 0.9 + i * size * 0.5);
         line.setAttribute("y1", -size * 0.3);
         line.setAttribute("x2", -size * 0.9 + i * size * 0.5);
         line.setAttribute("y2", size * 0.3);
         line.style.stroke = "currentColor";
         line.style.strokeWidth = "2";
         line.style.opacity = "0.5";
         g.appendChild(line);
        }
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", size * 0.9);
        led.setAttribute("cy", 0);
        led.setAttribute("r", size * 0.1);
        led.style.fill = "#4ade80";
        g.appendChild(led);
        return g;
       }
       if (shape === "pc" || shape === "desktop") {
        const g = document.createElementNS(ns, "g");
        const monitor = document.createElementNS(ns, "rect");
        monitor.setAttribute("x", -size * 0.9);
        monitor.setAttribute("y", -size * 0.8);
        monitor.setAttribute("width", size * 1.8);
        monitor.setAttribute("height", size * 1.2);
        monitor.setAttribute("rx", 4);
        g.appendChild(monitor);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.75);
        screen.setAttribute("y", -size * 0.65);
        screen.setAttribute("width", size * 1.5);
        screen.setAttribute("height", size * 0.9);
        screen.setAttribute("rx", 2);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        const neck = document.createElementNS(ns, "rect");
        neck.setAttribute("x", -size * 0.15);
        neck.setAttribute("y", size * 0.4);
        neck.setAttribute("width", size * 0.3);
        neck.setAttribute("height", size * 0.3);
        g.appendChild(neck);
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.5);
        base.setAttribute("y", size * 0.7);
        base.setAttribute("width", size * 1);
        base.setAttribute("height", size * 0.15);
        base.setAttribute("rx", 2);
        g.appendChild(base);
        return g;
       }
       if (shape === "laptop") {
        const g = document.createElementNS(ns, "g");
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.8);
        screen.setAttribute("y", -size * 0.9);
        screen.setAttribute("width", size * 1.6);
        screen.setAttribute("height", size * 1.1);
        screen.setAttribute("rx", 4);
        g.appendChild(screen);
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.9);
        base.setAttribute("y", size * 0.25);
        base.setAttribute("width", size * 1.8);
        base.setAttribute("height", size * 0.6);
        base.setAttribute("rx", 4);
        g.appendChild(base);
        const pad = document.createElementNS(ns, "rect");
        pad.setAttribute("x", -size * 0.25);
        pad.setAttribute("y", size * 0.45);
        pad.setAttribute("width", size * 0.5);
        pad.setAttribute("height", size * 0.25);
        pad.setAttribute("rx", 2);
        pad.style.fill = "#1e293b";
        g.appendChild(pad);
        return g;
       }
       if (shape === "phone" || shape === "mobile") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.45);
        body.setAttribute("y", -size);
        body.setAttribute("width", size * 0.9);
        body.setAttribute("height", size * 2);
        body.setAttribute("rx", 8);
        g.appendChild(body);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.38);
        screen.setAttribute("y", -size * 0.85);
        screen.setAttribute("width", size * 0.76);
        screen.setAttribute("height", size * 1.6);
        screen.setAttribute("rx", 4);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        const btn = document.createElementNS(ns, "rect");
        btn.setAttribute("x", -size * 0.15);
        btn.setAttribute("y", size * 0.82);
        btn.setAttribute("width", size * 0.3);
        btn.setAttribute("height", size * 0.06);
        btn.setAttribute("rx", 2);
        btn.style.fill = "#475569";
        g.appendChild(btn);
        return g;
       }
       if (shape === "router") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.1);
        body.setAttribute("y", -size * 0.3);
        body.setAttribute("width", size * 2.2);
        body.setAttribute("height", size * 0.8);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        for (let i = -1; i <= 1; i++) {
         const ant = document.createElementNS(ns, "rect");
         ant.setAttribute("x", i * size * 0.6 - size * 0.05);
         ant.setAttribute("y", -size * 0.9);
         ant.setAttribute("width", size * 0.1);
         ant.setAttribute("height", size * 0.6);
         ant.setAttribute("rx", 2);
         g.appendChild(ant);
         const tip = document.createElementNS(ns, "circle");
         tip.setAttribute("cx", i * size * 0.6);
         tip.setAttribute("cy", -size * 0.95);
         tip.setAttribute("r", size * 0.08);
         g.appendChild(tip);
        }
        for (let i = 0; i < 4; i++) {
         const led = document.createElementNS(ns, "circle");
         led.setAttribute("cx", -size * 0.7 + i * size * 0.35);
         led.setAttribute("cy", size * 0.1);
         led.setAttribute("r", size * 0.06);
         led.style.fill = i < 2 ? "#4ade80" : "#facc15";
         g.appendChild(led);
        }
        return g;
       }
       if (shape === "switch") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.4);
        body.setAttribute("y", -size * 0.4);
        body.setAttribute("width", size * 2.8);
        body.setAttribute("height", size * 0.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 8; i++) {
         const port = document.createElementNS(ns, "rect");
         port.setAttribute("x", -size * 1.2 + i * size * 0.32);
         port.setAttribute("y", -size * 0.15);
         port.setAttribute("width", size * 0.22);
         port.setAttribute("height", size * 0.3);
         port.setAttribute("rx", 1);
         port.style.fill = "#1e293b";
         g.appendChild(port);
        }
        return g;
       }
       if (shape === "firewall") {
        const g = document.createElementNS(ns, "g");
        const wall = document.createElementNS(ns, "rect");
        wall.setAttribute("x", -size);
        wall.setAttribute("y", -size * 0.8);
        wall.setAttribute("width", size * 2);
        wall.setAttribute("height", size * 1.6);
        wall.setAttribute("rx", 4);
        g.appendChild(wall);
        for (let row = 0; row < 3; row++) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", -size * 0.85);
         line.setAttribute("y1", -size * 0.5 + row * size * 0.45);
         line.setAttribute("x2", size * 0.85);
         line.setAttribute("y2", -size * 0.5 + row * size * 0.45);
         line.style.stroke = "#475569";
         line.style.strokeWidth = "2";
         g.appendChild(line);
        }
        for (let row = 0; row < 4; row++) {
         const offset = row % 2 === 0 ? 0 : size * 0.35;
         for (let col = 0; col < 3; col++) {
          const line = document.createElementNS(ns, "line");
          const x = -size * 0.5 + col * size * 0.7 + offset;
          if (x > -size * 0.85 && x < size * 0.85) {
           line.setAttribute("x1", x);
           line.setAttribute("y1", -size * 0.8 + row * size * 0.45, );
           line.setAttribute("x2", x);
           line.setAttribute("y2", -size * 0.8 + row * size * 0.45 + size * 0.45, );
           line.style.stroke = "#475569";
           line.style.strokeWidth = "2";
           g.appendChild(line);
          }
         }
        }
        return g;
       }
       if (shape === "cloud") {
        const p = document.createElementNS(ns, "path");
        const s = size;
        p.setAttribute("d", `
             M ${-s * 0.8} ${s * 0.2}
             Q ${-s * 1.1} ${s * 0.2} ${-s * 1.1} ${-s * 0.1}
             Q ${-s * 1.1} ${-s * 0.5} ${-s * 0.7} ${-s * 0.5}
             Q ${-s * 0.7} ${-s * 0.9} ${-s * 0.2} ${-s * 0.9}
             Q ${s * 0.1} ${-s * 1.1} ${s * 0.5} ${-s * 0.8}
             Q ${s * 1} ${-s * 0.8} ${s * 1.1} ${-s * 0.3}
             Q ${s * 1.3} ${-s * 0.1} ${s * 1.1} ${s * 0.2}
             Q ${s * 1.1} ${s * 0.5} ${s * 0.7} ${s * 0.5}
             L ${-s * 0.5} ${s * 0.5}
             Q ${-s * 0.9} ${s * 0.5} ${-s * 0.9} ${s * 0.2}
             Z
            `, );
        return p;
       }
       if (shape === "database") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.7);
        body.setAttribute("y", -size * 0.6);
        body.setAttribute("width", size * 1.4);
        body.setAttribute("height", size * 1.4);
        g.appendChild(body);
        const top = document.createElementNS(ns, "ellipse");
        top.setAttribute("cx", 0);
        top.setAttribute("cy", -size * 0.6);
        top.setAttribute("rx", size * 0.7);
        top.setAttribute("ry", size * 0.25);
        g.appendChild(top);
        const bottom = document.createElementNS(ns, "ellipse");
        bottom.setAttribute("cx", 0);
        bottom.setAttribute("cy", size * 0.8);
        bottom.setAttribute("rx", size * 0.7);
        bottom.setAttribute("ry", size * 0.25);
        g.appendChild(bottom);
        const mid1 = document.createElementNS(ns, "ellipse");
        mid1.setAttribute("cx", 0);
        mid1.setAttribute("cy", -size * 0.15);
        mid1.setAttribute("rx", size * 0.7);
        mid1.setAttribute("ry", size * 0.2);
        mid1.style.fill = "none";
        mid1.style.stroke = "#475569";
        mid1.style.strokeWidth = "2";
        g.appendChild(mid1);
        const mid2 = document.createElementNS(ns, "ellipse");
        mid2.setAttribute("cx", 0);
        mid2.setAttribute("cy", size * 0.35);
        mid2.setAttribute("rx", size * 0.7);
        mid2.setAttribute("ry", size * 0.2);
        mid2.style.fill = "none";
        mid2.style.stroke = "#475569";
        mid2.style.strokeWidth = "2";
        g.appendChild(mid2);
        return g;
       }
       if (shape === "printer") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.4);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size * 0.9);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const trayTop = document.createElementNS(ns, "rect");
        trayTop.setAttribute("x", -size * 0.7);
        trayTop.setAttribute("y", -size * 0.8);
        trayTop.setAttribute("width", size * 1.4);
        trayTop.setAttribute("height", size * 0.4);
        trayTop.setAttribute("rx", 2);
        trayTop.style.fill = "#1e293b";
        g.appendChild(trayTop);
        const trayOut = document.createElementNS(ns, "rect");
        trayOut.setAttribute("x", -size * 0.6);
        trayOut.setAttribute("y", size * 0.5);
        trayOut.setAttribute("width", size * 1.2);
        trayOut.setAttribute("height", size * 0.35);
        trayOut.setAttribute("rx", 2);
        g.appendChild(trayOut);
        const paper = document.createElementNS(ns, "rect");
        paper.setAttribute("x", -size * 0.5);
        paper.setAttribute("y", size * 0.3);
        paper.setAttribute("width", size * 1);
        paper.setAttribute("height", size * 0.5);
        paper.style.fill = "#e2e8f0";
        g.appendChild(paper);
        return g;
       }
       if (shape === "access-point" || shape === "wifi") {
        const g = document.createElementNS(ns, "g");
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.3);
        base.setAttribute("y", size * 0.2);
        base.setAttribute("width", size * 0.6);
        base.setAttribute("height", size * 0.3);
        base.setAttribute("rx", 3);
        g.appendChild(base);
        for (let i = 1; i <= 3; i++) {
         const arc = document.createElementNS(ns, "path");
         const r = size * 0.3 * i;
         arc.setAttribute("d", `M ${-r * 0.7} ${size * 0.1 - r * 0.5} A ${r} ${r} 0 0 1 ${r * 0.7} ${size * 0.1 - r * 0.5}`);
         arc.style.fill = "none";
         arc.style.stroke = "currentColor";
         arc.style.strokeWidth = "2";
         arc.style.opacity = 1 - (i * 0.2);
         g.appendChild(arc);
        }
        return g;
       }
       if (shape === "load-balancer") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.5);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        const bar = document.createElementNS(ns, "line");
        bar.setAttribute("x1", -size * 0.6);
        bar.setAttribute("y1", 0);
        bar.setAttribute("x2", size * 0.6);
        bar.setAttribute("y2", 0);
        bar.style.stroke = "#4ade80";
        bar.style.strokeWidth = "3";
        g.appendChild(bar);
        [-1, 1].forEach(dir => {
         const arrow = document.createElementNS(ns, "path");
         arrow.setAttribute("d", `M ${dir * size * 0.3} ${-size * 0.2} L ${dir * size * 0.6} 0 L ${dir * size * 0.3} ${size * 0.2}`);
         arrow.style.fill = "none";
         arrow.style.stroke = "#4ade80";
         arrow.style.strokeWidth = "2";
         g.appendChild(arrow);
        });
        return g;
       }
       if (shape === "nas" || shape === "storage") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.8);
        body.setAttribute("y", -size * 0.9);
        body.setAttribute("width", size * 1.6);
        body.setAttribute("height", size * 1.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 4; i++) {
         const bay = document.createElementNS(ns, "rect");
         bay.setAttribute("x", -size * 0.6);
         bay.setAttribute("y", -size * 0.7 + i * size * 0.4);
         bay.setAttribute("width", size * 1.2);
         bay.setAttribute("height", size * 0.3);
         bay.setAttribute("rx", 2);
         bay.style.fill = "#1e293b";
         g.appendChild(bay);
        }
        return g;
       }
       if (shape === "gateway" || shape === "modem") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.5);
        body.setAttribute("y", -size * 0.9);
        body.setAttribute("width", size);
        body.setAttribute("height", size * 1.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 4; i++) {
         const led = document.createElementNS(ns, "circle");
         led.setAttribute("cx", 0);
         led.setAttribute("cy", -size * 0.6 + i * size * 0.35);
         led.setAttribute("r", size * 0.08);
         led.style.fill = ["#4ade80", "#4ade80", "#facc15", "#60a5fa"][i];
         g.appendChild(led);
        }
        return g;
       }
       if (shape === "vpn" || shape === "tunnel") {
        const g = document.createElementNS(ns, "g");
        const outer = document.createElementNS(ns, "ellipse");
        outer.setAttribute("cx", 0);
        outer.setAttribute("cy", 0);
        outer.setAttribute("rx", size);
        outer.setAttribute("ry", size * 0.6);
        g.appendChild(outer);
        const inner = document.createElementNS(ns, "ellipse");
        inner.setAttribute("cx", 0);
        inner.setAttribute("cy", 0);
        inner.setAttribute("rx", size * 0.5);
        inner.setAttribute("ry", size * 0.3);
        inner.style.fill = "#1e293b";
        g.appendChild(inner);
        const lock = document.createElementNS(ns, "rect");
        lock.setAttribute("x", -size * 0.15);
        lock.setAttribute("y", -size * 0.1);
        lock.setAttribute("width", size * 0.3);
        lock.setAttribute("height", size * 0.25);
        lock.setAttribute("rx", 2);
        lock.style.fill = "#4ade80";
        g.appendChild(lock);
        return g;
       }
       if (shape === "container") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.5);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 3; i++) {
         const block = document.createElementNS(ns, "rect");
         block.setAttribute("x", -size * 0.8 + i * size * 0.55);
         block.setAttribute("y", -size * 0.3);
         block.setAttribute("width", size * 0.45);
         block.setAttribute("height", size * 0.6);
         block.setAttribute("rx", 2);
         block.style.fill = "#1e293b";
         g.appendChild(block);
        }
        return g;
       }
       if (shape === "vm" || shape === "virtual") {
        const g = document.createElementNS(ns, "g");
        const shadow = document.createElementNS(ns, "rect");
        shadow.setAttribute("x", -size * 0.85 + 4);
        shadow.setAttribute("y", -size * 0.65 + 4);
        shadow.setAttribute("width", size * 1.7);
        shadow.setAttribute("height", size * 1.3);
        shadow.setAttribute("rx", 4);
        shadow.style.opacity = "0.3";
        g.appendChild(shadow);
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.85);
        body.setAttribute("y", -size * 0.65);
        body.setAttribute("width", size * 1.7);
        body.setAttribute("height", size * 1.3);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.65);
        screen.setAttribute("y", -size * 0.45);
        screen.setAttribute("width", size * 1.3);
        screen.setAttribute("height", size * 0.7);
        screen.setAttribute("rx", 2);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        return g;
       }
       if (shape === "kubernetes" || shape === "k8s") {
        const g = document.createElementNS(ns, "g");
        const outer = document.createElementNS(ns, "circle");
        outer.setAttribute("cx", 0);
        outer.setAttribute("cy", 0);
        outer.setAttribute("r", size);
        g.appendChild(outer);
        const inner = document.createElementNS(ns, "circle");
        inner.setAttribute("cx", 0);
        inner.setAttribute("cy", 0);
        inner.setAttribute("r", size * 0.4);
        inner.style.fill = "#1e293b";
        g.appendChild(inner);
        for (let i = 0; i < 7; i++) {
         const angle = (Math.PI * 2 / 7) * i - Math.PI / 2;
         const spoke = document.createElementNS(ns, "line");
         spoke.setAttribute("x1", Math.cos(angle) * size * 0.4);
         spoke.setAttribute("y1", Math.sin(angle) * size * 0.4);
         spoke.setAttribute("x2", Math.cos(angle) * size * 0.85);
         spoke.setAttribute("y2", Math.sin(angle) * size * 0.85);
         spoke.style.stroke = "#326ce5";
         spoke.style.strokeWidth = "3";
         g.appendChild(spoke);
        }
        return g;
       }
       if (shape === "shield" || shape === "security") {
        const p = document.createElementNS(ns, "path");
        const s = size;
        p.setAttribute("d", `M 0 ${-s} L ${s * 0.85} ${-s * 0.5} L ${s * 0.85} ${s * 0.2} Q ${s * 0.7} ${s * 0.9} 0 ${s} Q ${-s * 0.7} ${s * 0.9} ${-s * 0.85} ${s * 0.2} L ${-s * 0.85} ${-s * 0.5} Z`);
        return p;
       }
       if (shape === "camera" || shape === "cctv") {
        const g = document.createElementNS(ns, "g");
        const mount = document.createElementNS(ns, "rect");
        mount.setAttribute("x", -size * 1.1);
        mount.setAttribute("y", -size * 0.5);
        mount.setAttribute("width", size * 0.25);
        mount.setAttribute("height", size * 0.6);
        mount.setAttribute("rx", 2);
        g.appendChild(mount);
        const arm = document.createElementNS(ns, "rect");
        arm.setAttribute("x", -size * 0.9);
        arm.setAttribute("y", -size * 0.15);
        arm.setAttribute("width", size * 0.5);
        arm.setAttribute("height", size * 0.15);
        g.appendChild(arm);
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.45);
        body.setAttribute("y", -size * 0.35);
        body.setAttribute("width", size * 1.1);
        body.setAttribute("height", size * 0.7);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const lensHousing = document.createElementNS(ns, "circle");
        lensHousing.setAttribute("cx", size * 0.85);
        lensHousing.setAttribute("cy", 0);
        lensHousing.setAttribute("r", size * 0.4);
        g.appendChild(lensHousing);
        const lensOuter = document.createElementNS(ns, "circle");
        lensOuter.setAttribute("cx", size * 0.85);
        lensOuter.setAttribute("cy", 0);
        lensOuter.setAttribute("r", size * 0.28);
        lensOuter.style.fill = "#1e293b";
        g.appendChild(lensOuter);
        const lensInner = document.createElementNS(ns, "circle");
        lensInner.setAttribute("cx", size * 0.85);
        lensInner.setAttribute("cy", 0);
        lensInner.setAttribute("r", size * 0.15);
        lensInner.style.fill = "#3b82f6";
        g.appendChild(lensInner);
        const reflection = document.createElementNS(ns, "circle");
        reflection.setAttribute("cx", size * 0.8);
        reflection.setAttribute("cy", -size * 0.05);
        reflection.setAttribute("r", size * 0.05);
        reflection.style.fill = "#93c5fd";
        g.appendChild(reflection);
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", -size * 0.2);
        led.setAttribute("cy", -size * 0.15);
        led.setAttribute("r", size * 0.06);
        led.style.fill = "#ef4444";
        g.appendChild(led);
        return g;
       }
       if (shape === "monitor" || shape === "dashboard") {
        const g = document.createElementNS(ns, "g");
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size);
        screen.setAttribute("y", -size * 0.7);
        screen.setAttribute("width", size * 2);
        screen.setAttribute("height", size * 1.2);
        screen.setAttribute("rx", 4);
        g.appendChild(screen);
        const graph = document.createElementNS(ns, "polyline");
        graph.setAttribute("points", `${-size * 0.8},${size * 0.2} ${-size * 0.3},${-size * 0.2} ${size * 0.2},${size * 0.1} ${size * 0.7},${-size * 0.3}`);
        graph.style.fill = "none";
        graph.style.stroke = "#4ade80";
        graph.style.strokeWidth = "3";
        g.appendChild(graph);
        return g;
       }
       if (shape === "docker" || shape === "whale") {
        const g = document.createElementNS(ns, "g");
        const s = size;
        const body = document.createElementNS(ns, "path");
        body.setAttribute("d", `
         M ${-s * 0.9} ${s * 0.2}
         Q ${-s * 1.1} ${s * 0.5} ${-s * 0.7} ${s * 0.7}
         Q ${-s * 0.3} ${s * 0.85} ${s * 0.3} ${s * 0.75}
         Q ${s * 0.8} ${s * 0.6} ${s * 1.0} ${s * 0.3}
         Q ${s * 1.1} ${s * 0.1} ${s * 1.0} ${-s * 0.1}
         L ${s * 0.85} ${-s * 0.1}
         Q ${s * 0.7} ${-s * 0.15} ${s * 0.4} ${-s * 0.2}
         L ${-s * 0.5} ${-s * 0.2}
         Q ${-s * 0.8} ${-s * 0.1} ${-s * 0.9} ${s * 0.2}
         Z
        `);
        body.style.fill = "#0db7ed";
        g.appendChild(body);
        const tail = document.createElementNS(ns, "path");
        tail.setAttribute("d", `
         M ${-s * 0.85} ${s * 0.1}
         Q ${-s * 1.2} ${-s * 0.2} ${-s * 1.0} ${-s * 0.55}
         Q ${-s * 0.95} ${-s * 0.35} ${-s * 0.8} ${-s * 0.15}
         Z
        `);
        tail.style.fill = "#0db7ed";
        g.appendChild(tail);
        const belly = document.createElementNS(ns, "path");
        belly.setAttribute("d", `
         M ${-s * 0.5} ${s * 0.65}
         Q ${s * 0.1} ${s * 0.75} ${s * 0.6} ${s * 0.55}
         Q ${s * 0.8} ${s * 0.45} ${s * 0.9} ${s * 0.25}
         Q ${s * 0.7} ${s * 0.5} ${s * 0.3} ${s * 0.6}
         Q ${-s * 0.1} ${s * 0.7} ${-s * 0.5} ${s * 0.65}
         Z
        `);
        belly.style.fill = "#ffffff";
        belly.style.opacity = "0.3";
        g.appendChild(belly);
        for (let row = 0; row < 2; row++) {
         for (let col = 0; col < 3; col++) {
          const container = document.createElementNS(ns, "rect");
          container.setAttribute("x", -s * 0.45 + col * s * 0.35);
          container.setAttribute("y", -s * 0.7 + row * s * 0.28);
          container.setAttribute("width", s * 0.3);
          container.setAttribute("height", s * 0.23);
          container.setAttribute("rx", 2);
          container.style.fill = "#0db7ed";
          container.style.stroke = "#0a9ed8";
          container.style.strokeWidth = "1.5";
          g.appendChild(container);
         }
        }
        const topContainer = document.createElementNS(ns, "rect");
        topContainer.setAttribute("x", -s * 0.1);
        topContainer.setAttribute("y", -s * 0.95);
        topContainer.setAttribute("width", s * 0.3);
        topContainer.setAttribute("height", s * 0.23);
        topContainer.setAttribute("rx", 2);
        topContainer.style.fill = "#0db7ed";
        topContainer.style.stroke = "#0a9ed8";
        topContainer.style.strokeWidth = "1.5";
        g.appendChild(topContainer);
        const eye = document.createElementNS(ns, "circle");
        eye.setAttribute("cx", s * 0.65);
        eye.setAttribute("cy", s * 0.25);
        eye.setAttribute("r", s * 0.08);
        eye.style.fill = "#0a5f7a";
        g.appendChild(eye);
        return g;
       }
       if (shape === "rounded-square") {
        const r = document.createElementNS(ns, "rect");
        const s = size * 1.6;
        r.setAttribute("x", -s / 2);
        r.setAttribute("y", -s / 2);
        r.setAttribute("width", s);
        r.setAttribute("height", s);
        r.setAttribute("rx", size * 0.4);
        return r;
       }
       if (shape === "pill" || shape === "capsule") {
        const r = document.createElementNS(ns, "rect");
        r.setAttribute("x", -size * 1.2);
        r.setAttribute("y", -size * 0.5);
        r.setAttribute("width", size * 2.4);
        r.setAttribute("height", size);
        r.setAttribute("rx", size * 0.5);
        return r;
       }
       if (shape === "octagon") {
        const p = document.createElementNS(ns, "polygon");
        const r = size;
        const pts = [];
        for (let i = 0; i < 8; i++) {
         const a = (Math.PI / 4) * i - Math.PI / 8;
         pts.push([Math.cos(a) * r, Math.sin(a) * r]);
        }
        p.setAttribute("points", pts.map(pt => pt.join(",")).join(" "));
        return p;
       }
       if (shape === "pentagon") {
        const p = document.createElementNS(ns, "polygon");
        const pts = [];
        for (let i = 0; i < 5; i++) {
         const a = (Math.PI * 2 / 5) * i - Math.PI / 2;
         pts.push([Math.cos(a) * size, Math.sin(a) * size]);
        }
        p.setAttribute("points", pts.map(pt => pt.join(",")).join(" "));
        return p;
       }
       if (shape === "cross" || shape === "plus") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        const t = size * 0.35;
        p.setAttribute("points", `${-t},${-s} ${t},${-s} ${t},${-t} ${s},${-t} ${s},${t} ${t},${t} ${t},${s} ${-t},${s} ${-t},${t} ${-s},${t} ${-s},${-t} ${-t},${-t}`);
        return p;
       }
       if (shape === "parallelogram") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `${-s * 0.6},${-s * 0.6} ${s * 1.2},${-s * 0.6} ${s * 0.6},${s * 0.6} ${-s * 1.2},${s * 0.6}`);
        return p;
       }
       if (shape === "trapezoid") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `${-s * 0.6},${-s * 0.6} ${s * 0.6},${-s * 0.6} ${s},${s * 0.6} ${-s},${s * 0.6}`);
        return p;
       }
       if (shape === "sensor" || shape === "iot") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "circle");
        body.setAttribute("cx", 0);
        body.setAttribute("cy", 0);
        body.setAttribute("r", size * 0.7);
        g.appendChild(body);
        const ant = document.createElementNS(ns, "line");
        ant.setAttribute("x1", 0);
        ant.setAttribute("y1", -size * 0.7);
        ant.setAttribute("x2", 0);
        ant.setAttribute("y2", -size);
        ant.style.stroke = "currentColor";
        ant.style.strokeWidth = "2";
        g.appendChild(ant);
        const tip = document.createElementNS(ns, "circle");
        tip.setAttribute("cx", 0);
        tip.setAttribute("cy", -size);
        tip.setAttribute("r", size * 0.1);
        tip.style.fill = "#4ade80";
        g.appendChild(tip);
        return g;
       }
       if (shape === "pi" || shape === "sbc" || shape === "raspberry") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.65);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size * 1.3);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 10; i++) {
         const pin = document.createElementNS(ns, "rect");
         pin.setAttribute("x", -size * 0.85 + i * size * 0.19);
         pin.setAttribute("y", -size * 0.8);
         pin.setAttribute("width", size * 0.08);
         pin.setAttribute("height", size * 0.15);
         pin.style.fill = "#facc15";
         g.appendChild(pin);
        }
        const port = document.createElementNS(ns, "rect");
        port.setAttribute("x", size * 0.6);
        port.setAttribute("y", -size * 0.2);
        port.setAttribute("width", size * 0.35);
        port.setAttribute("height", size * 0.4);
        port.style.fill = "#1e293b";
        g.appendChild(port);
        return g;
       }
       if (shape === "api" || shape === "endpoint") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.9);
        body.setAttribute("y", -size * 0.7);
        body.setAttribute("width", size * 1.8);
        body.setAttribute("height", size * 1.4);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        const left = document.createElementNS(ns, "text");
        left.setAttribute("x", -size * 0.5);
        left.setAttribute("y", size * 0.15);
        left.setAttribute("font-size", size * 0.9);
        left.setAttribute("fill", "#4ade80");
        left.setAttribute("font-family", "monospace");
        left.textContent = "{";
        g.appendChild(left);
        const right = document.createElementNS(ns, "text");
        right.setAttribute("x", size * 0.15);
        right.setAttribute("y", size * 0.15);
        right.setAttribute("font-size", size * 0.9);
        right.setAttribute("fill", "#4ade80");
        right.setAttribute("font-family", "monospace");
        right.textContent = "}";
        g.appendChild(right);
        return g;
       }
       if (shape === "queue" || shape === "message") {
        const g = document.createElementNS(ns, "g");
        for (let i = 2; i >= 0; i--) {
         const card = document.createElementNS(ns, "rect");
         card.setAttribute("x", -size * 0.7 + i * 4);
         card.setAttribute("y", -size * 0.5 + i * 4);
         card.setAttribute("width", size * 1.4);
         card.setAttribute("height", size * 0.8);
         card.setAttribute("rx", 3);
         card.style.opacity = 1 - i * 0.25;
         g.appendChild(card);
        }
        return g;
       }
       if (shape === "lambda" || shape === "function") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.8);
        body.setAttribute("y", -size * 0.8);
        body.setAttribute("width", size * 1.6);
        body.setAttribute("height", size * 1.6);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const lambda = document.createElementNS(ns, "text");
        lambda.setAttribute("x", 0);
        lambda.setAttribute("y", size * 0.2);
        lambda.setAttribute("font-size", size * 1.2);
        lambda.setAttribute("fill", "#f59e0b");
        lambda.setAttribute("text-anchor", "middle");
        lambda.setAttribute("font-family", "serif");
        lambda.textContent = "λ";
        g.appendChild(lambda);
        return g;
       }
       if (shape === "bucket" || shape === "s3") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "path");
        body.setAttribute("d", `M ${-size * 0.8} ${-size * 0.7} L ${-size * 0.6} ${size * 0.8} Q ${-size * 0.5} ${size} 0 ${size} Q ${size * 0.5} ${size} ${size * 0.6} ${size * 0.8} L ${size * 0.8} ${-size * 0.7} Z`);
        g.appendChild(body);
        const rim = document.createElementNS(ns, "ellipse");
        rim.setAttribute("cx", 0);
        rim.setAttribute("cy", -size * 0.7);
        rim.setAttribute("rx", size * 0.8);
        rim.setAttribute("ry", size * 0.25);
        g.appendChild(rim);
        return g;
       }
       const c = document.createElementNS(ns, "circle");
       c.setAttribute("r", size);
       return c;
      }
      function createNodeShape(id, size) {
       const shapeType = (NODE_DATA[id] && NODE_DATA[id].shape) || "circle";
       const shapeEl = createShapeElement(shapeType, size);
       shapeEl.classList.add("node-circle");
       const styles = resolveStylesForNode(id);
       shapeEl.style.fill = styles.circleColor || PAGE_STATE.nodeFill || "#1e293b";
       shapeEl.style.stroke = styles.circleBorder || PAGE_STATE.nodeStroke || "#475569";
       return shapeEl;
      }
      function forgeTheLegend() {
       const container = document.getElementById("edge-legend");
       if (!container) return;
       container.innerHTML = "";
       const title = document.createElement("div");
       title.className = "legend-title";
       title.textContent = "Line Legend";
       container.appendChild(title);
       const closeBtn = document.createElement("button");
       closeBtn.type = "button";
       closeBtn.className = "legend-close-btn";
       closeBtn.textContent = "✕";
       closeBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        legendCollapsed = true;
        updateLegendVisibility();
       });
       container.appendChild(closeBtn);
       const colors = [...new Set(EDGE_DATA.list.map((e) => e.color).filter(Boolean))];
       if (colors.length === 0) {
        updateLegendVisibility();
        return;
       }
       colors.forEach((color) => {
        if (!EDGE_LEGEND[color]) {
         EDGE_LEGEND[color] = "you can edit me too";
        }
        const item = document.createElement("div");
        item.className = "legend-item";
        item.addEventListener("mousedown", (e) => e.stopPropagation());
        item.addEventListener("click", (e) => e.stopPropagation());
        const swatch = document.createElement("span");
        swatch.className = "legend-swatch";
        swatch.style.backgroundColor = color;
        swatch.style.cursor = "pointer";
        swatch.addEventListener("click", (e) => {
         e.stopPropagation();
         const edgeWithColor = EDGE_DATA.list.find(edge => edge.color === color);
         if (edgeWithColor) {
          selectTheConnection(edgeWithColor.id);
         }
        });
        let swatchTouchStart = null;
        let swatchTouchMoved = false;
        swatch.addEventListener("touchstart", (e) => {
         swatchTouchStart = Date.now();
         swatchTouchMoved = false;
         if (e.touches[0]) {
          swatchTouchStartX = e.touches[0].clientX;
          swatchTouchStartY = e.touches[0].clientY;
         }
        }, {
         passive: false
        });
        let swatchTouchStartX = 0, swatchTouchStartY = 0;
        swatch.addEventListener("touchmove", (e) => {
         if (e.touches[0]) {
          const dx = Math.abs(e.touches[0].clientX - swatchTouchStartX);
          const dy = Math.abs(e.touches[0].clientY - swatchTouchStartY);
          if (dx > 10 || dy > 10) swatchTouchMoved = true;
         }
        }, {
         passive: false
        });
        swatch.addEventListener("touchend", (e) => {
         if (swatchTouchStart && !swatchTouchMoved && Date.now() - swatchTouchStart < 400) {
          e.stopPropagation();
          e.preventDefault();
          const edgeWithColor = EDGE_DATA.list.find(edge => edge.color === color);
          if (edgeWithColor) {
           selectTheConnection(edgeWithColor.id);
          }
         }
         swatchTouchStart = null;
         swatchTouchMoved = false;
        }, {
         passive: false
        });
        const label = document.createElement("span");
        label.className = "legend-label";
        label.textContent = EDGE_LEGEND[color];
        if (isMobileDevice()) {
         label.style.cursor = "pointer";
         let labelTapStart = null;
         let labelTapMoved = false;
         label.addEventListener("touchstart", (e) => {
          labelTapStart = Date.now();
          labelTapMoved = false;
          if (e.touches[0]) {
           labelTapStartX = e.touches[0].clientX;
           labelTapStartY = e.touches[0].clientY;
          }
          e.stopPropagation();
         });
         let labelTapStartX = 0, labelTapStartY = 0;
         label.addEventListener("touchmove", (e) => {
          if (e.touches[0]) {
           const dx = Math.abs(e.touches[0].clientX - labelTapStartX);
           const dy = Math.abs(e.touches[0].clientY - labelTapStartY);
           if (dx > 10 || dy > 10) labelTapMoved = true;
          }
         });
         label.addEventListener("touchend", (e) => {
          if (labelTapStart && !labelTapMoved && Date.now() - labelTapStart < 400) {
           e.preventDefault();
           e.stopPropagation();
           const currentText = label.textContent;
           const newText = prompt("Edit legend label:", currentText);
           if (newText !== null && newText.trim()) {
            label.textContent = newText.trim();
            EDGE_LEGEND[color] = newText.trim();
           }
          }
          labelTapStart = null;
          labelTapMoved = false;
         });
        } else {
         label.contentEditable = true;
         label.addEventListener("focus", () => {
          label.classList.add("editing");
         });
         label.addEventListener("blur", () => {
          label.classList.remove("editing");
          const text = label.textContent.trim() || "you can edit me too";
          EDGE_LEGEND[color] = text;
         });
         label.addEventListener("keydown", (e) => {
          if (e.key === "Enter") {
           e.preventDefault();
           label.blur();
          }
         });
        }
        item.append(swatch, label);
        container.appendChild(item);
       });
       updateLegendVisibility();
      }
       function deleteRectangle(rectId) {
      pushUndo("delete zone");
        RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== rectId);
        forgeTheTopology();
       }
       function updateRectangleDeleteButtons() {
        const deleteButtons = document.querySelectorAll('.rect-delete-btn');
        deleteButtons.forEach(btn => {
         btn.style.display = rectDrawMode ? 'block' : 'none';
        });
       }
      function forgeTheTopology() {
       if (!NODE_DATA || !EDGE_DATA) {
        console.warn("forgeTheTopology called before data initialized");
        return;
       }
       const svg = document.getElementById("map");
       svg.innerHTML = "";
       const ns = "http://www.w3.org/2000/svg";
       const defs = document.createElementNS(ns, "defs");
       const markerForward = document.createElementNS(ns, "marker");
       markerForward.id = "arrow-forward";
       markerForward.setAttribute("markerWidth", "10");
       markerForward.setAttribute("markerHeight", "10");
       markerForward.setAttribute("refX", "9");
       markerForward.setAttribute("refY", "3");
       markerForward.setAttribute("orient", "auto");
       markerForward.setAttribute("markerUnits", "strokeWidth");
       const pathForward = document.createElementNS(ns, "path");
       pathForward.setAttribute("d", "M0,0 L0,6 L9,3 z");
       pathForward.setAttribute("fill", "context-stroke");
       markerForward.appendChild(pathForward);
       defs.appendChild(markerForward);
       const markerBackward = document.createElementNS(ns, "marker");
       markerBackward.id = "arrow-backward";
       markerBackward.setAttribute("markerWidth", "10");
       markerBackward.setAttribute("markerHeight", "10");
       markerBackward.setAttribute("refX", "0");
       markerBackward.setAttribute("refY", "3");
       markerBackward.setAttribute("orient", "auto");
       markerBackward.setAttribute("markerUnits", "strokeWidth");
       const pathBackward = document.createElementNS(ns, "path");
       pathBackward.setAttribute("d", "M9,0 L9,6 L0,3 z");
       pathBackward.setAttribute("fill", "context-stroke");
       markerBackward.appendChild(pathBackward);
       defs.appendChild(markerBackward);
       svg.appendChild(defs);
       const boundary = document.createElementNS(ns, "rect");
       boundary.setAttribute("x", CANVAS_PADDING);
       boundary.setAttribute("y", CANVAS_PADDING);
       boundary.setAttribute("width", CANVAS_WIDTH - CANVAS_PADDING * 2);
       boundary.setAttribute("height", CANVAS_HEIGHT - CANVAS_PADDING * 2);
       boundary.setAttribute("fill", "none");
       boundary.setAttribute("stroke", (PAGE_STATE.canvasBorder || "#475569") + "4D");
       boundary.setAttribute("stroke-width", "20");
       boundary.setAttribute("stroke-dasharray", "10 5");
       boundary.setAttribute("rx", "8");
       svg.appendChild(boundary);
       if (currentView.mode !== "rack") {
        const gridGroup = document.createElementNS(ns, "g");
        gridGroup.id = "canvas-grid";
        const gridSize = PAGE_STATE.canvasGridSize || 50;
        const gridColor = (PAGE_STATE.canvasGrid || "#475569") + "33";
        const majorGridColor = (PAGE_STATE.canvasGrid || "#475569") + "66";
        for (let x = CANVAS_PADDING; x <= CANVAS_WIDTH - CANVAS_PADDING; x += gridSize) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", x);
         line.setAttribute("y1", CANVAS_PADDING);
         line.setAttribute("x2", x);
         line.setAttribute("y2", CANVAS_HEIGHT - CANVAS_PADDING);
         line.setAttribute("stroke", (x - CANVAS_PADDING) % (gridSize * 5) === 0 ? majorGridColor : gridColor);
         line.setAttribute("stroke-width", (x - CANVAS_PADDING) % (gridSize * 5) === 0 ? "2" : "1");
         gridGroup.appendChild(line);
        }
        for (let y = CANVAS_PADDING; y <= CANVAS_HEIGHT - CANVAS_PADDING; y += gridSize) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", CANVAS_PADDING);
         line.setAttribute("y1", y);
         line.setAttribute("x2", CANVAS_WIDTH - CANVAS_PADDING);
         line.setAttribute("y2", y);
         line.setAttribute("stroke", (y - CANVAS_PADDING) % (gridSize * 5) === 0 ? majorGridColor : gridColor);
         line.setAttribute("stroke-width", (y - CANVAS_PADDING) % (gridSize * 5) === 0 ? "2" : "1");
         gridGroup.appendChild(line);
        }
        svg.appendChild(gridGroup);
       }
       if (currentView.mode === "rack" && currentView.rackId) {
        const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
        const rackGroup = document.createElementNS(ns, "g");
        rackGroup.id = "rack-visualization";
        const rackFrame = document.createElementNS(ns, "rect");
        rackFrame.setAttribute("x", RACK_START_X - RACK_WIDTH / 2);
        rackFrame.setAttribute("y", RACK_START_Y);
        rackFrame.setAttribute("width", RACK_WIDTH);
      rackFrame.setAttribute("height", rackCapacity * rackUHeight);
        rackFrame.setAttribute("fill", (PAGE_STATE.rackFrameFill || "#0f172a") + "4D");
        rackFrame.setAttribute("stroke", PAGE_STATE.rackFrameStroke || "#4fd1c5");
        rackFrame.setAttribute("stroke-width", "3");
        rackFrame.setAttribute("rx", "4");
        rackGroup.appendChild(rackFrame);
        for (let u = 0; u <= rackCapacity; u++) {
         const y = RACK_START_Y + u * rackUHeight;
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", RACK_START_X - RACK_WIDTH / 2);
         line.setAttribute("y1", y);
         line.setAttribute("x2", RACK_START_X + RACK_WIDTH / 2);
         line.setAttribute("y2", y);
         line.setAttribute("stroke", (PAGE_STATE.rackLineColor || "#475569") + "66");
         line.setAttribute("stroke-width", u % 5 === 0 ? "2" : "1");
         line.setAttribute("stroke-dasharray", u % 5 === 0 ? "none" : "5,5");
         rackGroup.appendChild(line);
         if (u < rackCapacity) {
          const uNumber = rackCapacity - u;
          const text = document.createElementNS(ns, "text");
          text.setAttribute("x", RACK_START_X - RACK_WIDTH / 2 - 30);
          text.setAttribute("y", y + rackUHeight / 2);
          text.setAttribute("text-anchor", "middle");
          text.setAttribute("dominant-baseline", "middle");
          text.style.fill = PAGE_STATE.rackTextColor || "#4fd1c5";
          text.style.fontSize = "14px";
          text.style.fontWeight = "bold";
          text.textContent = `U${uNumber}`;
          rackGroup.appendChild(text);
          const textRight = document.createElementNS(ns, "text");
          textRight.setAttribute("x", RACK_START_X + RACK_WIDTH / 2 + 30);
          textRight.setAttribute("y", y + rackUHeight / 2);
          textRight.setAttribute("text-anchor", "middle");
          textRight.setAttribute("dominant-baseline", "middle");
          textRight.style.fill = PAGE_STATE.rackTextColor || "#4fd1c5";
          textRight.style.fontSize = "14px";
          textRight.style.fontWeight = "bold";
          textRight.textContent = `U${uNumber}`;
          rackGroup.appendChild(textRight);
         }
        }
        svg.appendChild(rackGroup);
       }
        if (RECT_DATA && RECT_DATA.list) {
         RECT_DATA.list.forEach((rect) => {
          if (currentView.mode === "rack") return;
          if (rect.style === "filled") {
           const g = document.createElementNS(ns, "g");
           g.classList.add("rect-group");
           g.dataset.rectId = rect.id;
           const rectEl = document.createElementNS(ns, "rect");
           rectEl.classList.add("rect-shape");
           rectEl.setAttribute("x", rect.x);
           rectEl.setAttribute("y", rect.y);
           rectEl.setAttribute("width", rect.width);
           rectEl.setAttribute("height", rect.height);
           rectEl.style.fill = rect.color;
           rectEl.style.fillOpacity = "0.3";
           rectEl.style.stroke = rect.borderColor || rect.color;
           rectEl.style.strokeWidth = (rect.borderWidth !== undefined ? rect.borderWidth : 2) + "px";
           if (rect.lineStyle === "dashed") { rectEl.style.strokeDasharray = "10,5"; }
           else if (rect.lineStyle === "dotted") { rectEl.style.strokeDasharray = "2,4"; }
           else { rectEl.style.strokeDasharray = "none"; }
           rectEl.style.cursor = "move";
          rectEl.addEventListener("click", (e) => {
		  if (isViewOnly()) return;
             if (rectDrawMode) return;
             e.stopPropagation();
             currentRectId = rect.id;
             selectTheRect(rect.id);
           });
           rectEl.addEventListener("contextmenu", (e) => {
		   if (isViewOnly()) return;
             e.preventDefault();
             e.stopPropagation();
             if (selectedRects.has(rect.id)) {
               selectedRects.delete(rect.id);
             } else {
               selectedRects.add(rect.id);
             }
             updateAllSelections();
           });
           let rectLastTap = 0;
           rectEl.addEventListener("touchend", (e) => {
             const now = Date.now();
             if (now - rectLastTap < 300) {
               e.preventDefault();
               if (selectedRects.has(rect.id)) {
                 selectedRects.delete(rect.id);
               } else {
                 selectedRects.add(rect.id);
               }
               updateAllSelections();
               if (navigator.vibrate) navigator.vibrate(50);
               rectLastTap = 0;
             } else {
               rectLastTap = now;
             }
           }, { passive: false });
           const deleteBtn = document.createElementNS(ns, "g");
           deleteBtn.classList.add("rect-delete-btn");
           deleteBtn.style.cursor = "pointer";
           deleteBtn.style.display = rectDrawMode ? "block" : "none";
           const deleteBg = document.createElementNS(ns, "circle");
           deleteBg.setAttribute("cx", rect.x + rect.width - 10);
           deleteBg.setAttribute("cy", rect.y + 10);
           deleteBg.setAttribute("r", 12);
           deleteBg.style.fill = "#f56565";
           deleteBg.style.stroke = "white";
           deleteBg.style.strokeWidth = "2";
           const deleteX = document.createElementNS(ns, "text");
           deleteX.setAttribute("x", rect.x + rect.width - 10);
           deleteX.setAttribute("y", rect.y + 10);
           deleteX.setAttribute("text-anchor", "middle");
           deleteX.setAttribute("dominant-baseline", "middle");
           deleteX.style.fill = "white";
           deleteX.style.fontSize = "16px";
           deleteX.style.fontWeight = "bold";
           deleteX.style.pointerEvents = "none";
           deleteX.textContent = "×";
           deleteBtn.appendChild(deleteBg);
           deleteBtn.appendChild(deleteX);
           deleteBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            e.preventDefault();
            deleteRectangle(rect.id);
           });
           deleteBtn.addEventListener("touchend", (e) => {
      e.stopPropagation();
           e.preventDefault();
           deleteRectangle(rect.id);
           });
           let isDragging = false;
           let dragStartX, dragStartY;
           let rectStartX, rectStartY;
         rectEl.addEventListener("mousedown", (e) => {
		 if (isViewOnly()) return;
      if (rectDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      rectStartX = rect.x;
      rectStartY = rect.y;
      rectEl.style.cursor = "grabbing";
      if (selectedRects.has(rect.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
           const moveHandler = (e) => {
      if (!isDragging || rectDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      rect.x = rectStartX + dx;
      rect.y = rectStartY + dy;
      if (selectedRects.has(rect.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       const newX = initialPositions[nodeId].x + dx;
       const newY = initialPositions[nodeId].y + dy;
       savedPositions[nodeId] = { x: newX, y: newY };
      }
      });
      selectedRects.forEach(rectId => {
      if (rectId === rect.id) return;
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      forgeTheTopology();
      };
           const upHandler = () => {
            if (isDragging) {
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           };
           document.addEventListener("mousemove", moveHandler);
           document.addEventListener("mouseup", upHandler);
           let touchStartX, touchStartY;
           let touchRectStartX, touchRectStartY;
           rectEl.addEventListener("touchstart", (e) => {
		   if (isViewOnly()) return;
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchRectStartX = rect.x;
            touchRectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           }, { passive: false });
           rectEl.addEventListener("touchmove", (e) => {
		    if (isViewOnly()) return;
            if (!isDragging || rectDrawMode) return;
            if (!e.touches[0]) return;
            e.preventDefault();
            e.stopPropagation();
            const svgEl = svg;
            const pt1 = svgEl.createSVGPoint();
            pt1.x = touchStartX;
            pt1.y = touchStartY;
            const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
            const touch = e.touches[0];
            const pt2 = svgEl.createSVGPoint();
            pt2.x = touch.clientX;
            pt2.y = touch.clientY;
            const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
            const dx = svgP2.x - svgP1.x;
            const dy = svgP2.y - svgP1.y;
            rect.x = touchRectStartX + dx;
            rect.y = touchRectStartY + dy;
            forgeTheTopology();
           }, { passive: false });
           rectEl.addEventListener("touchend", (e) => {
            if (isDragging) {
             e.preventDefault();
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           }, { passive: false });
            if (currentRectId === rect.id) {
      const corners = [
      { cx: rect.x, cy: rect.y, cursor: 'nwse-resize', dx: -1, dy: -1 },
      { cx: rect.x + rect.width, cy: rect.y, cursor: 'nesw-resize', dx: 1, dy: -1 },
      { cx: rect.x, cy: rect.y + rect.height, cursor: 'nesw-resize', dx: -1, dy: 1 },
      { cx: rect.x + rect.width, cy: rect.y + rect.height, cursor: 'nwse-resize', dx: 1, dy: 1 }
      ];
      corners.forEach((corner, idx) => {
      const handle = document.createElementNS(ns, "circle");
      handle.setAttribute("cx", corner.cx);
      handle.setAttribute("cy", corner.cy);
      handle.setAttribute("r", PAGE_STATE.selectionHandleSize || 8);
      handle.style.fill = PAGE_STATE.selectionHandle || "#f59e0b";
      handle.style.stroke = "#fff";
      handle.style.strokeWidth = "2";
      handle.style.cursor = corner.cursor;
      handle.addEventListener("mousedown", (e) => {
      e.preventDefault();
      e.stopPropagation();
	  pushUndo("resize zone");
      let dragging = true;
      const startX = e.clientX, startY = e.clientY;
      const origX = rect.x, origY = rect.y, origW = rect.width, origH = rect.height;
      const moveHandler = (ev) => {
        if (!dragging) return;
        const pt1 = svg.createSVGPoint(); pt1.x = startX; pt1.y = startY;
        const pt2 = svg.createSVGPoint(); pt2.x = ev.clientX; pt2.y = ev.clientY;
        const svgP1 = pt1.matrixTransform(svg.getScreenCTM().inverse());
        const svgP2 = pt2.matrixTransform(svg.getScreenCTM().inverse());
        const dx = svgP2.x - svgP1.x, dy = svgP2.y - svgP1.y;
        if (corner.dx < 0) { rect.x = origX + dx; rect.width = origW - dx; }
        else { rect.width = origW + dx; }
        if (corner.dy < 0) { rect.y = origY + dy; rect.height = origH - dy; }
        else { rect.height = origH + dy; }
        if (rect.width < 20) rect.width = 20;
        if (rect.height < 20) rect.height = 20;
        forgeTheTopology();
      };
      const upHandler = () => { dragging = false; document.removeEventListener("mousemove", moveHandler); document.removeEventListener("mouseup", upHandler); };
      document.addEventListener("mousemove", moveHandler);
      document.addEventListener("mouseup", upHandler);
      });
      g.appendChild(handle);
      });
      }
          if (rect.groupId) {
      const groupIndicator = document.createElementNS(ns, "rect");
      groupIndicator.setAttribute("x", rect.x - 4);
      groupIndicator.setAttribute("y", rect.y - 4);
      groupIndicator.setAttribute("width", rect.width + 8);
      groupIndicator.setAttribute("height", rect.height + 8);
      groupIndicator.style.fill = "none";
      groupIndicator.style.stroke = "#4fd1c5";
      groupIndicator.style.strokeWidth = "3";
      groupIndicator.style.strokeDasharray = "5,5";
      groupIndicator.style.pointerEvents = "none";
      g.insertBefore(groupIndicator, g.firstChild);
      }
      g.appendChild(rectEl);
      g.appendChild(deleteBtn);
      svg.appendChild(g);
          }
         });
        }
       const centerX = CANVAS_WIDTH / 2;
       const centerY = CANVAS_HEIGHT / 2;
       let positions = {};
              Object.keys(NODE_DATA).forEach((id) => {
        if (currentView.mode === "rack") {
         const node = NODE_DATA[id];
         if (!node || node.assignedRack !== currentView.rackId) {
          return;
         }
        }
        positions[id] = savedPositions[id] || {
         x: centerX,
         y: centerY
        };
       });
       if (Object.keys(savedPositions).length === 0) {
        const nodeIds = Object.keys(NODE_DATA).filter(id => {
         if (currentView.mode === "rack") {
          const node = NODE_DATA[id];
          return node && node.assignedRack === currentView.rackId;
         }
         return true;
        });
        const baseY = centerY - 300;
        if (nodeIds.length > 0) {
         positions[nodeIds[0]] = {
          x: centerX,
          y: baseY
         };
         const remaining = nodeIds.slice(1);
         const radius = 350;
         const startAngle = Math.PI * 0.3;
         const endAngle = Math.PI * 0.7;
         remaining.forEach((id, i) => {
          const angle = startAngle + (endAngle - startAngle) * (i / Math.max(1, remaining.length - 1));
          positions[id] = {
           x: centerX + Math.cos(angle) * radius * (i % 2 === 0 ? 1 : 1.3),
           y: baseY + 200 + Math.sin(angle) * radius * 0.8 + i * 80,
          };
         });
        }
       }
       Object.keys(positions).forEach((id) => {
        let pos = savedPositions[id] || positions[id];
        const nodeSize = savedSizes[id] || 55;
        pos.x = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, pos.x), );
        pos.y = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, pos.y), );
        positions[id] = {
         x: pos.x,
         y: pos.y
        };
        savedPositions[id] = {
         x: pos.x,
         y: pos.y
        };
       });
       const edgePairCount = {};
       const edgePairIndex = {};
       EDGE_DATA.list.forEach((edge) => {
        if (edge.type === "custom") return;
        const key = [edge.from, edge.to].sort().join("||");
        edgePairCount[key] = (edgePairCount[key] || 0) + 1;
       });
       EDGE_DATA.list.forEach((edge) => {
        if (edge.type === "custom") return;
        const key = [edge.from, edge.to].sort().join("||");
        if (!edgePairIndex[key]) edgePairIndex[key] = 0;
        edge._pairIndex = edgePairIndex[key];
        edge._pairTotal = edgePairCount[key];
        edgePairIndex[key]++;
       });
       EDGE_DATA.list.forEach((edge) => {
        if (edge.type === "custom" && Array.isArray(edge.points) && edge.points.length >= 2) {
         const poly = document.createElementNS(ns, "polyline");
         poly.classList.add("edge");
         poly.dataset.edgeId = edge.id;
         poly.style.stroke = edge.color || PAGE_STATE.defaultEdge || "#475569";
         poly.style.strokeWidth = edge.width || 4;
         poly.setAttribute("fill", "none");
         const lineStyle = edge.lineStyle || "solid";
         if (lineStyle === "dashed") {
          poly.style.strokeDasharray = "10,5";
         } else if (lineStyle === "dotted") {
          poly.style.strokeDasharray = "2,4";
         } else {
          poly.style.strokeDasharray = "none";
         }
         const direction = edge.direction || "none";
         if (direction === "forward") {
          poly.setAttribute("marker-end", "url(#arrow-forward)");
         } else if (direction === "backward") {
          poly.setAttribute("marker-start", "url(#arrow-backward)");
         } else if (direction === "both") {
          poly.setAttribute("marker-start", "url(#arrow-backward)");
          poly.setAttribute("marker-end", "url(#arrow-forward)");
         }
         const ptsStr = edge.points.map((p) => `${p.x},${p.y}`).join(" ");
         poly.setAttribute("points", ptsStr);
         const polyHit = document.createElementNS(ns, "polyline");
         polyHit.setAttribute("points", ptsStr);
         polyHit.style.fill = "none";
         polyHit.style.stroke = "transparent";
         polyHit.style.strokeWidth = "20";
         polyHit.style.cursor = "pointer";
         polyHit.dataset.edgeId = edge.id;
         polyHit.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         let edgeTouchStart = null;
         let edgeTouchMoved = false;
         polyHit.addEventListener("touchstart", (e) => {
          edgeTouchStart = Date.now();
          edgeTouchMoved = false;
          if (e.touches[0]) {
           edgeTouchStartX = e.touches[0].clientX;
           edgeTouchStartY = e.touches[0].clientY;
          }
         }, {
          passive: false
         });
         let edgeTouchStartX = 0, edgeTouchStartY = 0;
         polyHit.addEventListener("touchmove", (e) => {
          if (e.touches[0]) {
           const dx = Math.abs(e.touches[0].clientX - edgeTouchStartX);
           const dy = Math.abs(e.touches[0].clientY - edgeTouchStartY);
           if (dx > 10 || dy > 10) edgeTouchMoved = true;
          }
         }, {
          passive: false
         });
         polyHit.addEventListener("touchend", (e) => {
          if (edgeTouchStart && !edgeTouchMoved && Date.now() - edgeTouchStart < 400) {
           e.stopPropagation();
           e.preventDefault();
           selectTheConnection(edge.id);
          }
          edgeTouchStart = null;
          edgeTouchMoved = false;
         }, {
          passive: false
         });
         poly.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         polyHit.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (selectedEdges.has(edge.id)) {
           selectedEdges.delete(edge.id);
          } else {
           selectedEdges.add(edge.id);
          }
          updateAllSelections();
         });
         let customEdgeLastTap = 0;
         polyHit.addEventListener("touchend", (e) => {
          const now = Date.now();
          if (now - customEdgeLastTap < 300) {
           e.preventDefault();
           if (selectedEdges.has(edge.id)) {
            selectedEdges.delete(edge.id);
           } else {
            selectedEdges.add(edge.id);
           }
           updateAllSelections();
           if (navigator.vibrate) navigator.vibrate(50);
           customEdgeLastTap = 0;
          } else {
           customEdgeLastTap = now;
          }
         }, { passive: false });
         poly.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (selectedEdges.has(edge.id)) {
           selectedEdges.delete(edge.id);
          } else {
           selectedEdges.add(edge.id);
          }
          updateAllSelections();
         });
         let edgeLastTap = 0;
         poly.addEventListener("touchend", (e) => {
          const now = Date.now();
          if (now - edgeLastTap < 300) {
           e.preventDefault();
           if (selectedEdges.has(edge.id)) {
            selectedEdges.delete(edge.id);
           } else {
            selectedEdges.add(edge.id);
           }
           updateAllSelections();
           if (navigator.vibrate) navigator.vibrate(50);
           edgeLastTap = 0;
          } else {
           edgeLastTap = now;
          }
         });
         if (currentView.mode === "rack") {
          return;
         }
         if (edge.groupId) {
      const bounds = edge.points.reduce((acc, p) => ({ minX: Math.min(acc.minX, p.x), minY: Math.min(acc.minY, p.y), maxX: Math.max(acc.maxX, p.x), maxY: Math.max(acc.maxY, p.y) }), { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity });
      const groupIndicator = document.createElementNS(ns, "rect");
      groupIndicator.setAttribute("x", bounds.minX - 8);
      groupIndicator.setAttribute("y", bounds.minY - 8);
      groupIndicator.setAttribute("width", bounds.maxX - bounds.minX + 16);
      groupIndicator.setAttribute("height", bounds.maxY - bounds.minY + 16);
      groupIndicator.setAttribute("rx", "4");
      groupIndicator.style.fill = "none";
      groupIndicator.style.stroke = "#4fd1c5";
      groupIndicator.style.strokeWidth = "3";
      groupIndicator.style.strokeDasharray = "5,5";
      groupIndicator.style.pointerEvents = "none";
      svg.appendChild(groupIndicator);
      }
         let lineDragging = false;
      let lineDragStartX, lineDragStartY;
      let linePointsStart = [];
      polyHit.addEventListener("mousedown", (e) => {
      if (freeDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      lineDragging = true;
      lineDragStartX = e.clientX;
      lineDragStartY = e.clientY;
      linePointsStart = edge.points.map(p => ({x: p.x, y: p.y}));
      if (selectedEdges.has(edge.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
      const lineMoveHandler = (e) => {
      if (!lineDragging || freeDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = lineDragStartX;
      pt1.y = lineDragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      edge.points.forEach((p, i) => { p.x = linePointsStart[i].x + dx; p.y = linePointsStart[i].y + dy; });
      if (selectedEdges.has(edge.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       savedPositions[nodeId] = { x: initialPositions[nodeId].x + dx, y: initialPositions[nodeId].y + dy };
      }
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      if (edgeId === edge.id) return;
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      forgeTheTopology();
      };
      const lineUpHandler = () => { lineDragging = false; };
      document.addEventListener("mousemove", lineMoveHandler);
      document.addEventListener("mouseup", lineUpHandler);
      svg.appendChild(poly);
      svg.appendChild(polyHit);
         if (currentEdgeId === edge.id) {
          edge.points.forEach((p, idx) => {
           const c = document.createElementNS(ns, "circle");
           c.classList.add("edge-edit-point");
           c.setAttribute("cx", p.x);
           c.setAttribute("cy", p.y);
      c.setAttribute("r", PAGE_STATE.selectionHandleSize || 8);
           c.style.fill = PAGE_STATE.selectionHandle || "#f59e0b";
           c.style.stroke = "#fff";
           c.style.strokeWidth = "2";
           c.style.cursor = "move";
           c.dataset.edgeId = edge.id;
           c.dataset.pointIndex = String(idx);
           c.addEventListener("mousedown", (e) => {
		   if (isViewOnly()) return;
            e.preventDefault();
            e.stopPropagation();
            pushUndo("edit edge point");
            let dragging = true;
            const svgEl = svg;
            const moveHandler = (ev) => {
             if (!dragging) return;
             const pt = svgEl.createSVGPoint();
             pt.x = ev.clientX;
             pt.y = ev.clientY;
             const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
             edge.points[idx].x = svgP.x;
             edge.points[idx].y = svgP.y;
             forgeTheTopology();
            };
            const upHandler = () => {
             dragging = false;
             document.removeEventListener("mousemove", moveHandler);
             document.removeEventListener("mouseup", upHandler);
            };
            document.addEventListener("mousemove", moveHandler);
            document.addEventListener("mouseup", upHandler);
           });
           c.addEventListener("touchstart", (e) => {
            e.preventDefault();
            e.stopPropagation();
            pushUndo("edit edge point");
            let dragging = true;
            const svgEl = svg;
            const touchMoveHandler = (ev) => {
             if (!dragging || !ev.touches[0]) return;
             const pt = svgEl.createSVGPoint();
             pt.x = ev.touches[0].clientX;
             pt.y = ev.touches[0].clientY;
             const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
             edge.points[idx].x = svgP.x;
             edge.points[idx].y = svgP.y;
             forgeTheTopology();
            };
            const touchUpHandler = () => {
             dragging = false;
             document.removeEventListener("touchmove", touchMoveHandler);
             document.removeEventListener("touchend", touchUpHandler);
            };
            document.addEventListener("touchmove", touchMoveHandler);
            document.addEventListener("touchend", touchUpHandler);
           }, { passive: false });
           svg.appendChild(c);
          });
         }
         return;
        }
        const p1 = positions[edge.from];
        const p2 = positions[edge.to];
        if (!p1 || !p2) return;
        const pairTotal = edge._pairTotal || 1;
        const pairIndex = edge._pairIndex || 0;
        const midX = (p1.x + p2.x) / 2;
        const midY = (p1.y + p2.y) / 2;
        const dx = p2.x - p1.x;
        const dy = p2.y - p1.y;
        const len = Math.sqrt(dx * dx + dy * dy) || 1;
        const perpX = -dy / len;
        const perpY = dx / len;
        let offsetAmount = 0;
        if (pairTotal > 1) {
         offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
        }
        const ctrlX = midX + perpX * offsetAmount;
        const ctrlY = midY + perpY * offsetAmount;
        const path = document.createElementNS(ns, "path");
        path.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
        path.setAttribute("fill", "none");
        path.classList.add("edge");
        if (edge.type === "backup") path.classList.add("backup");
        path.dataset.edgeId = edge.id;
        path.dataset.from = edge.from;
        path.dataset.to = edge.to;
        path.style.stroke = edge.color;
        path.style.strokeWidth = edge.width;
        const pathHit = document.createElementNS(ns, "path");
        pathHit.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
        pathHit.setAttribute("fill", "none");
        pathHit.style.stroke = "transparent";
        pathHit.style.strokeWidth = "20";
        pathHit.style.cursor = "pointer";
        pathHit.dataset.edgeId = edge.id;
        pathHit.addEventListener("click", (e) => {
         e.stopPropagation();
         selectTheConnection(edge.id);
        });
        let pathTouchStart = null;
        let pathTouchMoved = false;
        pathHit.addEventListener("touchstart", (e) => {
         pathTouchStart = Date.now();
         pathTouchMoved = false;
         if (e.touches[0]) {
          pathTouchStartX = e.touches[0].clientX;
          pathTouchStartY = e.touches[0].clientY;
         }
        }, {
         passive: false
        });
        let pathTouchStartX = 0, pathTouchStartY = 0;
        pathHit.addEventListener("touchmove", (e) => {
         if (e.touches[0]) {
          const dx = Math.abs(e.touches[0].clientX - pathTouchStartX);
          const dy = Math.abs(e.touches[0].clientY - pathTouchStartY);
          if (dx > 10 || dy > 10) pathTouchMoved = true;
         }
        }, {
         passive: false
        });
        pathHit.addEventListener("touchend", (e) => {
         if (pathTouchStart && !pathTouchMoved && Date.now() - pathTouchStart < 400) {
          e.stopPropagation();
          e.preventDefault();
          selectTheConnection(edge.id);
         }
         pathTouchStart = null;
         pathTouchMoved = false;
        }, {
         passive: false
        });
        path.addEventListener("click", (e) => {
         e.stopPropagation();
         selectTheConnection(edge.id);
        });
        if (currentView.mode === "rack") {
         const fromNode = NODE_DATA[edge.from];
         const toNode = NODE_DATA[edge.to];
         if (!fromNode || !toNode ||
             fromNode.assignedRack !== currentView.rackId ||
             toNode.assignedRack !== currentView.rackId) {
          return;
         }
        }
        const fromVisible = isNodeVisible(edge.from);
        const toVisible = isNodeVisible(edge.to);
        if (!fromVisible || !toVisible) {
         path.style.opacity = "0.1";
         path.style.pointerEvents = "none";
         pathHit.style.pointerEvents = "none";
        }
        svg.appendChild(path);
        svg.appendChild(pathHit);
        if (edge.fromPort || edge.toPort) {
         const ns = "http://www.w3.org/2000/svg";
         if (edge.fromPort) {
          const fromLabel = document.createElementNS(ns, "text");
          fromLabel.textContent = edge.fromPort;
          fromLabel.setAttribute("x", p1.x);
          fromLabel.setAttribute("y", p1.y - 10);
          fromLabel.setAttribute("text-anchor", "middle");
          fromLabel.style.fill = "#94a3b8";
          fromLabel.style.fontSize = "12px";
          fromLabel.style.fontWeight = "600";
          fromLabel.style.pointerEvents = "none";
          fromLabel.classList.add("port-label");
          svg.appendChild(fromLabel);
         }
         if (edge.toPort) {
          const toLabel = document.createElementNS(ns, "text");
          toLabel.textContent = edge.toPort;
          toLabel.setAttribute("x", p2.x);
          toLabel.setAttribute("y", p2.y - 10);
          toLabel.setAttribute("text-anchor", "middle");
          toLabel.style.fill = "#94a3b8";
          toLabel.style.fontSize = "12px";
          toLabel.style.fontWeight = "600";
          toLabel.style.pointerEvents = "none";
          toLabel.classList.add("port-label");
          svg.appendChild(toLabel);
         }
        }
       });
       Object.entries(positions).forEach(([id, pos]) => {
        const node = NODE_DATA[id];
        if (!node) return;
        if (currentView.mode === "rack") {
         if (node.assignedRack !== currentView.rackId) return;
         const rackUnit = parseInt(node.rackUnit) || 1;
      const uHeight = parseInt(node.uHeight) || 1;
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      pos.x = RACK_START_X;
      pos.y = RACK_START_Y + (rackCapacity - rackUnit - uHeight + 1) * rackUHeight + (uHeight * rackUHeight) / 2;
        } else {
         if (node.assignedRack) return;
        }
        const g = document.createElementNS("http://www.w3.org/2000/svg", "g", );
        g.classList.add("node-group");
        g.dataset.nodeId = id;
        g.setAttribute("transform", `translate(${pos.x},${pos.y})`);
		let r = savedSizes[id] || 55;
		if (!savedSizes[id]) {
		 if (window.innerWidth <= 480) r = 45;
		 else if (window.innerWidth <= 768) r = 50;
		}
        const styles = resolveStylesForNode(id);
        const ns = "http://www.w3.org/2000/svg";
        const hitArea = document.createElementNS(ns, "circle");
        hitArea.setAttribute("r", r * 1.5);
        hitArea.style.fill = "transparent";
        hitArea.style.stroke = "none";
        hitArea.style.cursor = "grab";
        hitArea.classList.add("node-hit-area");
        const shapeEl = createNodeShape(id, r);
        const titleOffsetX = styles.titleOffsetX || 0;
        const titleOffsetY = styles.titleOffsetY || 0;
        const subOffsetX = styles.subOffsetX || 0;
        const subOffsetY = styles.subOffsetY || 0;
        const label = document.createElementNS("http://www.w3.org/2000/svg", "text", );
        label.classList.add("node-label");
        label.setAttribute("x", titleOffsetX);
        label.setAttribute("y", -r * 0.28 + titleOffsetY);
      const labelFontSize = styles.titleSize || PAGE_STATE.nodeTitleSize || r * 0.33;
        label.style.fontSize = labelFontSize + "px";
        label.textContent = NODE_DATA[id].name;
      label.style.fill = styles.titleColor || PAGE_STATE.nodeTitle || "#e2e8f0";
        label.style.fontFamily = styles.titleFont || PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
        label.style.pointerEvents = "none";
        const sub = document.createElementNS("http://www.w3.org/2000/svg", "text", );
        sub.classList.add("node-sub");
        sub.setAttribute("x", subOffsetX);
        sub.setAttribute("y", r * 0.4 + subOffsetY);
      const subFontSize = styles.subSize || PAGE_STATE.nodeSubSize || r * 0.24;
        sub.style.fontSize = subFontSize + "px";
        sub.textContent = NODE_DATA[id].ip;
      sub.style.fill = styles.subColor || PAGE_STATE.nodeSub || "#94a3b8";
        sub.style.fontFamily = styles.subFont || PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
        sub.style.pointerEvents = "none";
        g.append(hitArea, shapeEl, label, sub);
        if (NODE_DATA[id]?.locked) {
          const lockIcon = document.createElementNS(ns, "text");
          lockIcon.textContent = "🔒";
          lockIcon.setAttribute("x", r * 0.6);
          lockIcon.setAttribute("y", -r * 0.6);
          lockIcon.style.fontSize = (r * 0.4) + "px";
          lockIcon.style.pointerEvents = "none";
          lockIcon.style.userSelect = "none";
          lockIcon.classList.add("lock-indicator");
          g.appendChild(lockIcon);
        }
        if (NODE_DATA[id]?.groupId) {
          const groupIndicator = document.createElementNS(ns, "circle");
          groupIndicator.setAttribute("r", r + 4);
          groupIndicator.style.fill = "none";
      groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
          groupIndicator.style.strokeWidth = "3";
          groupIndicator.style.strokeDasharray = "5,5";
          groupIndicator.style.pointerEvents = "none";
          groupIndicator.classList.add("group-indicator");
          g.insertBefore(groupIndicator, g.firstChild);
        }
        let isDragging = false;
        let startX, startY;
        let initialPositions = {};
        let longPressTimer = null;
        let longPressTriggered = false;
        g.addEventListener("contextmenu", (e) => {
         e.preventDefault();
         e.stopPropagation();
         if (isViewOnly()) return;
         if (selectedNodes.has(id)) {
          selectedNodes.delete(id);
         } else {
          selectedNodes.add(id);
         }
         updateNodeSelection();
         return false;
        });
        g.addEventListener("touchstart", (e) => {
         if (NODE_DATA[id].isRack) {
          const touch = e.touches[0];
          longPressStartX = touch.clientX;
          longPressStartY = touch.clientY;
          longPressTimer = setTimeout(() => {
           longPressTriggered = true;
           if (navigator.vibrate) {
            navigator.vibrate(100);
           }
           enterRack(id);
          }, 500);
         }
        }, { passive: true });
        let lastTapTime = 0;
        let lastTapNode = null;
        g.addEventListener("touchend", (e) => {
         const currentTime = new Date().getTime();
         const tapLength = currentTime - lastTapTime;
         if (tapLength < 300 && tapLength > 0 && lastTapNode === id) {
          e.preventDefault();
          e.stopPropagation();
          if (isViewOnly()) return;
          if (selectedNodes.has(id)) {
           selectedNodes.delete(id);
          } else {
           selectedNodes.add(id);
          }
          updateNodeSelection();
          if (navigator.vibrate) {
           navigator.vibrate(50);
          }
          lastTapTime = 0;
          lastTapNode = null;
         } else {
          lastTapTime = currentTime;
          lastTapNode = id;
         }
        });
        g.addEventListener("touchend", (e) => {
         if (longPressTimer) {
          clearTimeout(longPressTimer);
          longPressTimer = null;
         }
         if (longPressTriggered) {
          e.preventDefault();
          e.stopPropagation();
          longPressTriggered = false;
         }
        });
        let longPressStartX = 0;
        let longPressStartY = 0;
        g.addEventListener("touchmove", (e) => {
         if (longPressTimer) {
          const touch = e.touches[0];
          const dx = Math.abs(touch.clientX - longPressStartX);
          const dy = Math.abs(touch.clientY - longPressStartY);
          if (dx > 15 || dy > 15) {
           clearTimeout(longPressTimer);
           longPressTimer = null;
           longPressTriggered = false;
          }
         }
        });
        g.addEventListener("mousedown", (e) => {
		 if (isViewOnly()) return;
         if (e.button === 2) {
          return;
         }
         if (NODE_DATA[id]?.locked) {
          return;
         }
         e.preventDefault();
         isDragging = true;
         const svgEl = document.getElementById("map");
         const pt = svgEl.createSVGPoint();
         pt.x = e.clientX;
         pt.y = e.clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
         startX = svgP.x;
         startY = svgP.y;
      if (selectedNodes.has(id)) {
      initialPositions = {};
      const allSelectedRects = Array.from(selectedRects);
      const allSelectedTexts = Array.from(selectedTexts);
      const allSelectedEdges = Array.from(selectedEdges).map(eid => EDGE_DATA.list.find(e => e.id === eid)).filter(Boolean);
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) {
      initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      }
      });
      Array.from(selectedRects).forEach(rectId => {
        const rect = RECT_DATA.list.find(r => r.id === rectId);
        if (rect) { rect._dragStartX = rect.x; rect._dragStartY = rect.y; }
      });
      Array.from(selectedTexts).forEach(textId => {
        const text = TEXT_DATA.list.find(t => t.id === textId);
        if (text) { text._dragStartX = text.x; text._dragStartY = text.y; }
      });
      Array.from(selectedEdges).forEach(edgeId => {
        const edge = EDGE_DATA.list.find(e => e.id === edgeId);
        if (edge && edge.points) { edge._dragStartPoints = edge.points.map(p => ({x: p.x, y: p.y})); }
      });
      } else {
      initialPositions = { [id]: { x: pos.x, y: pos.y } };
      }
      if (currentView.mode === "rack") {
      initialPositions[id] = { x: pos.x, y: pos.y };
      }
         g.style.cursor = "grabbing";
         hitArea.style.cursor = "grabbing";
         e.stopPropagation();
        });
        const handleMouseMove = (e) => {
         if (!isDragging) return;
         e.preventDefault();
         const svgEl = document.getElementById("map");
         const pt = svgEl.createSVGPoint();
         pt.x = e.clientX;
         pt.y = e.clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
         const dx = svgP.x - startX;
         const dy = svgP.y - startY;
         let nodesToMove = selectedNodes.has(id) ? Array.from(selectedNodes) : [id];
         const groupIds = new Set();
         nodesToMove.forEach(nodeId => {
          const groupId = NODE_DATA[nodeId]?.groupId;
          if (groupId) {
            groupIds.add(groupId);
          }
         });
         if (groupIds.size > 0) {
          Object.keys(NODE_DATA).forEach(nodeId => {
            const nodeGroupId = NODE_DATA[nodeId]?.groupId;
            if (nodeGroupId && groupIds.has(nodeGroupId)) {
              if (!nodesToMove.includes(nodeId)) {
                nodesToMove.push(nodeId);
                if (!initialPositions[nodeId]) {
                  const nodePos = savedPositions[nodeId];
                  if (nodePos) {
                    initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
                  }
                }
              }
            }
          });
         }
         nodesToMove = nodesToMove.filter(nodeId => !NODE_DATA[nodeId]?.locked);
         nodesToMove.forEach(nodeId => {
          if (!initialPositions[nodeId]) return;
          const initialPos = initialPositions[nodeId];
          let newX = initialPos.x + dx;
          let newY = initialPos.y + dy;
          const nodeSize = savedSizes[nodeId] || 55;
          newX = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, newX), );
          newY = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, newY), );
          savedPositions[nodeId] = { x: newX, y: newY };
          positions[nodeId] = { x: newX, y: newY };
          if (nodeId === id) {
           pos.x = newX;
           pos.y = newY;
          }
          const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
          if (nodeGroup) {
           nodeGroup.setAttribute("transform", `translate(${newX},${newY})`);
          }
         });
         Array.from(selectedRects).forEach(rectId => {
           const rect = RECT_DATA.list.find(r => r.id === rectId);
           if (rect && rect._dragStartX !== undefined) {
             rect.x = rect._dragStartX + dx;
             rect.y = rect._dragStartY + dy;
           }
         });
         Array.from(selectedTexts).forEach(textId => {
           const text = TEXT_DATA.list.find(t => t.id === textId);
           if (text && text._dragStartX !== undefined) {
             text.x = text._dragStartX + dx;
             text.y = text._dragStartY + dy;
           }
         });
         Array.from(selectedEdges).forEach(edgeId => {
           const edge = EDGE_DATA.list.find(e => e.id === edgeId);
           if (edge && edge._dragStartPoints) {
             edge.points.forEach((p, i) => {
               p.x = edge._dragStartPoints[i].x + dx;
               p.y = edge._dragStartPoints[i].y + dy;
             });
           }
         });
         forgeTheTopology();
         updateMinimap();
         document.querySelectorAll(".edge").forEach((edgeEl) => {
          const fromId = edgeEl.dataset.from;
          const toId = edgeEl.dataset.to;
          if (nodesToMove.includes(fromId) || nodesToMove.includes(toId)) {
           const p1 = savedPositions[fromId] || positions[fromId] || {
            x: 600,
            y: 350
           };
           const p2 = savedPositions[toId] || positions[toId] || {
            x: 600,
            y: 350
           };
           if (edgeEl.tagName === "line") {
            edgeEl.setAttribute("x1", p1.x);
            edgeEl.setAttribute("y1", p1.y);
            edgeEl.setAttribute("x2", p2.x);
            edgeEl.setAttribute("y2", p2.y);
           } else if (edgeEl.tagName === "path") {
            const edgeId = edgeEl.dataset.edgeId;
            const edge = EDGE_DATA.list.find(
             (e) => e.id === edgeId, );
            if (edge) {
             const pairTotal = edge._pairTotal || 1;
             const pairIndex = edge._pairIndex || 0;
             const midX = (p1.x + p2.x) / 2;
             const midY = (p1.y + p2.y) / 2;
             const dx = p2.x - p1.x;
             const dy = p2.y - p1.y;
             const len = Math.sqrt(dx * dx + dy * dy) || 1;
             const perpX = -dy / len;
             const perpY = dx / len;
             let offsetAmount = 0;
             if (pairTotal > 1) {
              offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
             }
             const ctrlX = midX + perpX * offsetAmount;
             const ctrlY = midY + perpY * offsetAmount;
             edgeEl.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
            }
           }
          }
         });
        };
      const handleMouseUp = () => {
      if (isDragging) {
      isDragging = false;
      g.style.cursor = "grab";
      hitArea.style.cursor = "grab";
      if (currentView.mode === "rack" && NODE_DATA[id]?.assignedRack === currentView.rackId) {
      const draggedY = savedPositions[id]?.y || pos.y;
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      let newUnit = rackCapacity - Math.round((draggedY - RACK_START_Y) / rackUHeight);
      newUnit = Math.max(1, Math.min(newUnit, rackCapacity));
      NODE_DATA[id].rackUnit = newUnit;
      forgeTheTopology();
      claimTheImmortal(id);
      }
      }
      };
        document.addEventListener("mousemove", handleMouseMove);
        document.addEventListener("mouseup", handleMouseUp);
        let touchStartTime = 0;
        let touchStartX = 0;
        let touchStartY = 0;
        let touchMoved = false;
        g.addEventListener("touchstart",
         (e) => {
          if (isViewOnly()) {
           touchStartTime = Date.now();
           touchMoved = false;
           e.stopPropagation();
           return;
          }
          if (NODE_DATA[id]?.locked) {
           return;
          }
          e.preventDefault();
          touchStartTime = Date.now();
          touchMoved = false;
          const svgEl = document.getElementById("map");
          const pt = svgEl.createSVGPoint();
          const touch = e.touches[0];
          pt.x = touch.clientX;
          pt.y = touch.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          touchStartX = svgP.x;
          touchStartY = svgP.y;
          startX = svgP.x;
          startY = svgP.y;
          if (selectedNodes.has(id)) {
           initialPositions = {};
           selectedNodes.forEach(nodeId => {
            const nodePos = savedPositions[nodeId];
            if (nodePos) {
             initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
            }
           });
          } else {
           initialPositions = { [id]: { x: pos.x, y: pos.y } };
          }
          e.stopPropagation();
         }, {
          passive: false
         }, );
        g.addEventListener("touchmove", (e) => {
		if (isViewOnly()) return;
         e.preventDefault();
         const svgEl = document.getElementById("map");
         const pt = svgEl.createSVGPoint();
         const touch = e.touches[0];
         pt.x = touch.clientX;
         pt.y = touch.clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
         const dx = Math.abs(svgP.x - touchStartX);
         const dy = Math.abs(svgP.y - touchStartY);
         if (dx > (isMobileDevice() ? 4 : 10) || dy > (isMobileDevice() ? 4 : 10)) {
      touchMoved = true;
      isDragging = true;
      }
         if (!isDragging) return;
         const deltaX = svgP.x - startX;
         const deltaY = svgP.y - startY;
         let nodesToMove = selectedNodes.has(id) ? Array.from(selectedNodes) : [id];
         const groupIds = new Set();
         nodesToMove.forEach(nodeId => {
          const groupId = NODE_DATA[nodeId]?.groupId;
          if (groupId) {
            groupIds.add(groupId);
          }
         });
         if (groupIds.size > 0) {
          Object.keys(NODE_DATA).forEach(nodeId => {
            const nodeGroupId = NODE_DATA[nodeId]?.groupId;
            if (nodeGroupId && groupIds.has(nodeGroupId)) {
              if (!nodesToMove.includes(nodeId)) {
                nodesToMove.push(nodeId);
                if (!initialPositions[nodeId]) {
                  const nodePos = savedPositions[nodeId];
                  if (nodePos) {
                    initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
                  }
                }
              }
            }
          });
         }
         nodesToMove = nodesToMove.filter(nodeId => !NODE_DATA[nodeId]?.locked);
         nodesToMove.forEach(nodeId => {
          if (!initialPositions[nodeId]) return;
          const initialPos = initialPositions[nodeId];
          let newX = initialPos.x + deltaX;
          let newY = initialPos.y + deltaY;
          const nodeSize = savedSizes[nodeId] || 55;
          newX = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, newX), );
          newY = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, newY), );
          savedPositions[nodeId] = { x: newX, y: newY };
          positions[nodeId] = { x: newX, y: newY };
          if (nodeId === id) {
           pos.x = newX;
           pos.y = newY;
          }
          const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
          if (nodeGroup) {
           nodeGroup.setAttribute("transform", `translate(${newX},${newY})`);
          }
         });
         updateMinimap();
         document.querySelectorAll(".edge").forEach((edgeEl) => {
          const fromId = edgeEl.dataset.from;
          const toId = edgeEl.dataset.to;
          if (nodesToMove.includes(fromId) || nodesToMove.includes(toId)) {
           const p1 = savedPositions[fromId] || positions[fromId] || {
            x: 600,
            y: 350
           };
           const p2 = savedPositions[toId] || positions[toId] || {
            x: 600,
            y: 350
           };
           if (edgeEl.tagName === "line") {
            edgeEl.setAttribute("x1", p1.x);
            edgeEl.setAttribute("y1", p1.y);
            edgeEl.setAttribute("x2", p2.x);
            edgeEl.setAttribute("y2", p2.y);
           } else if (edgeEl.tagName === "path") {
            const edgeId = edgeEl.dataset.edgeId;
            const edge = EDGE_DATA.list.find(
             (e) => e.id === edgeId, );
            if (edge) {
             const pairTotal = edge._pairTotal || 1;
             const pairIndex = edge._pairIndex || 0;
             const midX = (p1.x + p2.x) / 2;
             const midY = (p1.y + p2.y) / 2;
             const dx = p2.x - p1.x;
             const dy = p2.y - p1.y;
             const len = Math.sqrt(dx * dx + dy * dy) || 1;
             const perpX = -dy / len;
             const perpY = dx / len;
             let offsetAmount = 0;
             if (pairTotal > 1) {
              offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
             }
             const ctrlX = midX + perpX * offsetAmount;
             const ctrlY = midY + perpY * offsetAmount;
             edgeEl.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
            }
           }
          }
         });
        }, {
         passive: false
        });
      g.addEventListener("touchend", (e) => {
      const touchDuration = Date.now() - touchStartTime;
      if (!touchMoved && touchDuration < 400) {
       if (isViewOnly()) {
        handleViewOnlyClick(id, 'node');
        return;
       }
       claimTheImmortal(id);
      }
      if (isDragging) {
      const draggedY = pos.y;
      isDragging = false;
      savedPositions[id] = {
      x: pos.x,
      y: pos.y
      };
      if (currentView.mode === "rack" && NODE_DATA[id]?.assignedRack === currentView.rackId) {
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      let newUnit = rackCapacity - Math.round((draggedY - RACK_START_Y) / rackUHeight);
      newUnit = Math.max(1, Math.min(newUnit, rackCapacity));
      NODE_DATA[id].rackUnit = newUnit;
      forgeTheTopology();
      claimTheImmortal(id);
      }
      }
      touchMoved = false;
      });
        g.style.cursor = "grab";
        g.addEventListener("click", (e) => {
         if (!isDragging) {
          if (isViewOnly()) {
           handleViewOnlyClick(id, 'node');
           return;
          }
          claimTheImmortal(id);
         }
        });
        g.addEventListener("dblclick", (e) => {
         e.preventDefault();
         e.stopPropagation();
         if (NODE_DATA[id].isRack) {
          enterRack(id);
         }
        });
        if (!isNodeVisible(id)) {
         g.style.opacity = "0.1";
         g.style.pointerEvents = "none";
        }
        svg.appendChild(g);
       });
        if (RECT_DATA && RECT_DATA.list) {
         RECT_DATA.list.forEach((rect) => {
          if (currentView.mode === "rack") return;
          if (rect.style === "outlined") {
           const g = document.createElementNS(ns, "g");
           g.classList.add("rect-group");
           g.dataset.rectId = rect.id;
           const rectEl = document.createElementNS(ns, "rect");
           rectEl.classList.add("rect-shape");
           rectEl.setAttribute("x", rect.x);
           rectEl.setAttribute("y", rect.y);
           rectEl.setAttribute("width", rect.width);
           rectEl.setAttribute("height", rect.height);
           rectEl.style.fill = "none";
           rectEl.style.stroke = rect.borderColor || rect.color;
           rectEl.style.strokeWidth = (rect.borderWidth !== undefined ? rect.borderWidth : 3) + "px";
           if (rect.lineStyle === "dashed") { rectEl.style.strokeDasharray = "10,5"; }
           else if (rect.lineStyle === "dotted") { rectEl.style.strokeDasharray = "2,4"; }
           else { rectEl.style.strokeDasharray = "none"; }
           rectEl.style.cursor = "move";
           rectEl.addEventListener("click", (e) => {
             if (rectDrawMode) return;
             e.stopPropagation();
             currentRectId = rect.id;
             selectTheRect(rect.id);
           });
           rectEl.addEventListener("contextmenu", (e) => {
		   if (isViewOnly()) return;
             e.preventDefault();
             e.stopPropagation();
             if (selectedRects.has(rect.id)) {
               selectedRects.delete(rect.id);
             } else {
               selectedRects.add(rect.id);
             }
             updateAllSelections();
           });
           let rectLastTap = 0;
           rectEl.addEventListener("touchend", (e) => {
             const now = Date.now();
             if (now - rectLastTap < 300) {
               e.preventDefault();
               if (selectedRects.has(rect.id)) {
                 selectedRects.delete(rect.id);
               } else {
                 selectedRects.add(rect.id);
               }
               updateAllSelections();
               if (navigator.vibrate) navigator.vibrate(50);
               rectLastTap = 0;
             } else {
               rectLastTap = now;
             }
           }, { passive: false });
           const deleteBtn = document.createElementNS(ns, "g");
           deleteBtn.classList.add("rect-delete-btn");
           deleteBtn.style.cursor = "pointer";
           deleteBtn.style.display = rectDrawMode ? "block" : "none";
           const deleteBg = document.createElementNS(ns, "circle");
           deleteBg.setAttribute("cx", rect.x + rect.width - 10);
           deleteBg.setAttribute("cy", rect.y + 10);
           deleteBg.setAttribute("r", 12);
           deleteBg.style.fill = "#f56565";
           deleteBg.style.stroke = "white";
           deleteBg.style.strokeWidth = "2";
           const deleteX = document.createElementNS(ns, "text");
           deleteX.setAttribute("x", rect.x + rect.width - 10);
           deleteX.setAttribute("y", rect.y + 10);
           deleteX.setAttribute("text-anchor", "middle");
           deleteX.setAttribute("dominant-baseline", "middle");
           deleteX.style.fill = "white";
           deleteX.style.fontSize = "16px";
           deleteX.style.fontWeight = "bold";
           deleteX.style.pointerEvents = "none";
           deleteX.textContent = "×";
           deleteBtn.appendChild(deleteBg);
           deleteBtn.appendChild(deleteX);
           deleteBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            e.preventDefault();
            deleteRectangle(rect.id);
           });
           let isDragging = false;
           let dragStartX, dragStartY;
           let rectStartX, rectStartY;
           rectEl.addEventListener("mousedown", (e) => {
		   if (isViewOnly()) return;
      if (rectDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      rectStartX = rect.x;
      rectStartY = rect.y;
      rectEl.style.cursor = "grabbing";
      if (selectedRects.has(rect.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
           const moveHandler = (e) => {
      if (!isDragging || rectDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      rect.x = rectStartX + dx;
      rect.y = rectStartY + dy;
      if (selectedRects.has(rect.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       const newX = initialPositions[nodeId].x + dx;
       const newY = initialPositions[nodeId].y + dy;
       savedPositions[nodeId] = { x: newX, y: newY };
      }
      });
      selectedRects.forEach(rectId => {
      if (rectId === rect.id) return;
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      forgeTheTopology();
      };
           const upHandler = () => {
            if (isDragging) {
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           };
           document.addEventListener("mousemove", moveHandler);
           document.addEventListener("mouseup", upHandler);
           let touchStartX, touchStartY;
           let touchRectStartX, touchRectStartY;
           rectEl.addEventListener("touchstart", (e) => {
		   if (isViewOnly()) return;
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchRectStartX = rect.x;
            touchRectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           }, { passive: false });
           rectEl.addEventListener("touchmove", (e) => {
		    if (isViewOnly()) return;
            if (!isDragging || rectDrawMode) return;
            if (!e.touches[0]) return;
            e.preventDefault();
            e.stopPropagation();
            const svgEl = svg;
            const pt1 = svgEl.createSVGPoint();
            pt1.x = touchStartX;
            pt1.y = touchStartY;
            const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
            const touch = e.touches[0];
            const pt2 = svgEl.createSVGPoint();
            pt2.x = touch.clientX;
            pt2.y = touch.clientY;
            const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
            const dx = svgP2.x - svgP1.x;
            const dy = svgP2.y - svgP1.y;
            rect.x = touchRectStartX + dx;
            rect.y = touchRectStartY + dy;
            forgeTheTopology();
           }, { passive: false });
           rectEl.addEventListener("touchend", (e) => {
            if (isDragging) {
             e.preventDefault();
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           }, { passive: false });
           if (rect.groupId) {
             const groupIndicator = document.createElementNS(ns, "rect");
             groupIndicator.setAttribute("x", rect.x - 4);
             groupIndicator.setAttribute("y", rect.y - 4);
             groupIndicator.setAttribute("width", rect.width + 8);
             groupIndicator.setAttribute("height", rect.height + 8);
             groupIndicator.style.fill = "none";
             groupIndicator.style.stroke = "#4fd1c5";
             groupIndicator.style.strokeWidth = "3";
             groupIndicator.style.strokeDasharray = "5,5";
             groupIndicator.style.pointerEvents = "none";
             g.insertBefore(groupIndicator, g.firstChild);
           }
           g.appendChild(rectEl);
           g.appendChild(deleteBtn);
           svg.appendChild(g);
          }
         });
        }
        if (TEXT_DATA && TEXT_DATA.list) {
         TEXT_DATA.list.forEach((textItem) => {
          if (currentView.mode === "rack") return;
          const g = document.createElementNS(ns, "g");
          g.classList.add("text-group");
          g.dataset.textId = textItem.id;
          if (textItem.bgEnabled) {
           const bgRect = document.createElementNS(ns, "rect");
           bgRect.classList.add("text-bg");
           bgRect.setAttribute("x", textItem.x - 5);
           bgRect.setAttribute("y", textItem.y - textItem.fontSize - 2);
           bgRect.setAttribute("width", 100);
           bgRect.setAttribute("height", textItem.fontSize + 10);
           bgRect.style.fill = textItem.bgColor;
           bgRect.style.opacity = "0.7";
           bgRect.style.rx = "4";
           g.appendChild(bgRect);
          }
          const textEl = document.createElementNS(ns, "text");
          textEl.classList.add("text-element");
          textEl.setAttribute("x", textItem.x);
          textEl.setAttribute("y", textItem.y);
          textEl.style.fill = textItem.color;
          textEl.style.fontSize = textItem.fontSize + "px";
          textEl.style.fontWeight = textItem.fontWeight;
          textEl.style.fontStyle = textItem.fontStyle;
          textEl.style.textAnchor = textItem.textAlign;
          textEl.style.textDecoration = textItem.textDecoration;
          textEl.style.opacity = textItem.opacity;
          textEl.style.cursor = "move";
          textEl.style.userSelect = "none";
          textEl.setAttribute("dominant-baseline", "middle");
          const lines = textItem.content.split('\n');
          if (lines.length === 1) {
           textEl.textContent = textItem.content;
          } else {
           lines.forEach((line, i) => {
            const tspan = document.createElementNS(ns, "tspan");
            tspan.textContent = line;
            tspan.setAttribute("x", textItem.x);
            tspan.setAttribute("dy", i === 0 ? 0 : textItem.fontSize * 1.2);
            textEl.appendChild(tspan);
           });
          }
          g.appendChild(textEl);
          if (textItem.bgEnabled) {
           setTimeout(() => {
            try {
             const bbox = textEl.getBBox();
             const bgRect = g.querySelector('.text-bg');
             if (bgRect && bbox) {
              bgRect.setAttribute("x", bbox.x - 5);
              bgRect.setAttribute("y", bbox.y - 2);
              bgRect.setAttribute("width", bbox.width + 10);
              bgRect.setAttribute("height", bbox.height + 4);
             }
            } catch (e) {
            }
           }, 0);
          }
          const deleteBtn = document.createElementNS(ns, "g");
          deleteBtn.classList.add("text-delete-btn");
          deleteBtn.style.cursor = "pointer";
          deleteBtn.style.display = textDrawMode ? "block" : "none";
          const deleteBg = document.createElementNS(ns, "circle");
          deleteBg.setAttribute("cx", textItem.x + 20);
          deleteBg.setAttribute("cy", textItem.y - textItem.fontSize);
          deleteBg.setAttribute("r", 12);
          deleteBg.style.fill = "#f56565";
          deleteBg.style.stroke = "white";
          deleteBg.style.strokeWidth = "2";
          const deleteX = document.createElementNS(ns, "text");
          deleteX.setAttribute("x", textItem.x + 20);
          deleteX.setAttribute("y", textItem.y - textItem.fontSize);
          deleteX.setAttribute("text-anchor", "middle");
          deleteX.setAttribute("dominant-baseline", "middle");
          deleteX.style.fill = "white";
          deleteX.style.fontSize = "16px";
          deleteX.style.fontWeight = "bold";
          deleteX.style.pointerEvents = "none";
          deleteX.textContent = "×";
          deleteBtn.appendChild(deleteBg);
          deleteBtn.appendChild(deleteX);
          deleteBtn.addEventListener("click", (e) => {
           e.stopPropagation();
           e.preventDefault();
           deleteText(textItem.id);
          });
          let isDragging = false;
          let dragStartX, dragStartY;
          let textStartX, textStartY;
          textEl.addEventListener("mousedown", (e) => {
		  if (isViewOnly()) return;
      if (textDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      textStartX = textItem.x;
      textStartY = textItem.y;
      textEl.style.cursor = "grabbing";
      showTextPanel(textItem.id);
      if (selectedTexts.has(textItem.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
          const moveHandler = (e) => {
      if (!isDragging || textDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      textItem.x = textStartX + dx;
      textItem.y = textStartY + dy;
      if (selectedTexts.has(textItem.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       const newX = initialPositions[nodeId].x + dx;
       const newY = initialPositions[nodeId].y + dy;
       savedPositions[nodeId] = { x: newX, y: newY };
      }
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      if (textId === textItem.id) return;
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      forgeTheTopology();
      };
          const upHandler = () => {
           if (isDragging) {
            isDragging = false;
            textEl.style.cursor = "move";
           }
          };
          document.addEventListener("mousemove", moveHandler);
          document.addEventListener("mouseup", upHandler);
          let touchStartX = 0, touchStartY = 0;
          let textTouchStartX = 0, textTouchStartY = 0;
          textEl.addEventListener("touchstart", (e) => {
		   if (isViewOnly()) return;
           if (textDrawMode) return;
           if (e.touches.length !== 1) return;
           e.preventDefault();
           e.stopPropagation();
           const touch = e.touches[0];
           isDragging = true;
           touchStartX = touch.clientX;
           touchStartY = touch.clientY;
           textTouchStartX = textItem.x;
           textTouchStartY = textItem.y;
           showTextPanel(textItem.id);
          }, { passive: false });
          textEl.addEventListener("touchmove", (e) => {
           if (!isDragging || textDrawMode) return;
           if (e.touches.length !== 1) return;
           e.preventDefault();
           const touch = e.touches[0];
           const svgEl = svg;
           const pt1 = svgEl.createSVGPoint();
           pt1.x = touchStartX;
           pt1.y = touchStartY;
           const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
           const pt2 = svgEl.createSVGPoint();
           pt2.x = touch.clientX;
           pt2.y = touch.clientY;
           const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
           const dx = svgP2.x - svgP1.x;
           const dy = svgP2.y - svgP1.y;
           textItem.x = textTouchStartX + dx;
           textItem.y = textTouchStartY + dy;
           forgeTheTopology();
          }, { passive: false });
          textEl.addEventListener("touchend", () => {
           if (isDragging) {
            isDragging = false;
           }
          }, { passive: false });
          textEl.addEventListener("contextmenu", (e) => {
		  if (isViewOnly()) return;
           e.preventDefault();
           e.stopPropagation();
           if (selectedTexts.has(textItem.id)) {
            selectedTexts.delete(textItem.id);
           } else {
            selectedTexts.add(textItem.id);
           }
           updateAllSelections();
          });
          let textLastTap = 0;
          g.addEventListener("touchend", (e) => {
           const now = Date.now();
           if (now - textLastTap < 300) {
            e.preventDefault();
            if (selectedTexts.has(textItem.id)) {
             selectedTexts.delete(textItem.id);
            } else {
             selectedTexts.add(textItem.id);
            }
            updateAllSelections();
            if (navigator.vibrate) navigator.vibrate(50);
            textLastTap = 0;
           } else {
            textLastTap = now;
           }
          }, { passive: false });
          if (textItem.groupId) {
            const groupIndicator = document.createElementNS(ns, "rect");
            groupIndicator.setAttribute("x", textItem.x - 54);
            groupIndicator.setAttribute("y", textItem.y - 24);
            groupIndicator.setAttribute("width", 108);
            groupIndicator.setAttribute("height", 48);
            groupIndicator.setAttribute("rx", "8");
            groupIndicator.style.fill = "none";
            groupIndicator.style.stroke = "#4fd1c5";
            groupIndicator.style.strokeWidth = "3";
            groupIndicator.style.strokeDasharray = "5,5";
            groupIndicator.style.pointerEvents = "none";
            g.insertBefore(groupIndicator, g.firstChild);
          }
          g.appendChild(deleteBtn);
          svg.appendChild(g);
         });
        }
       forgeTheLegend();
       updateMinimap();
       populateRackDropdown();
      }
      function showEditModal(title, currentValue, onSave) {
       const modal = document.getElementById("edit-modal");
       const input = document.getElementById("modal-input");
       const titleEl = document.getElementById("modal-title");
       const saveBtn = document.getElementById("modal-save");
       const cancelBtn = document.getElementById("modal-cancel");
       titleEl.textContent = title;
       input.value = currentValue;
       modal.classList.add("active");
       input.focus();
       input.select();
       const handleSave = () => {
        if (input.value.trim()) {
         onSave(input.value.trim());
        }
        modal.classList.remove("active");
        saveBtn.removeEventListener("click", handleSave);
        cancelBtn.removeEventListener("click", handleCancel);
        input.removeEventListener("keypress", handleEnter);
       };
       const handleCancel = () => {
        modal.classList.remove("active");
        saveBtn.removeEventListener("click", handleSave);
        cancelBtn.removeEventListener("click", handleCancel);
        input.removeEventListener("keypress", handleEnter);
       };
       const handleEnter = (e) => {
        if (e.key === "Enter") handleSave();
       };
       saveBtn.addEventListener("click", handleSave);
       cancelBtn.addEventListener("click", handleCancel);
       input.addEventListener("keypress", handleEnter);
       modal.addEventListener("click", function bgHandler(e) {
        if (e.target === modal) {
         handleCancel();
         modal.removeEventListener("click", bgHandler);
        }
       });
      }
      function challengeTheImmortal(message, onConfirm) {
       const modal = document.getElementById("confirm-modal");
       const messageEl = document.getElementById("confirm-message");
       const deleteBtn = document.getElementById("confirm-delete");
       const cancelBtn = document.getElementById("confirm-cancel");
       messageEl.textContent = message;
       modal.classList.add("active");
       const handleConfirm = () => {
        onConfirm();
        modal.classList.remove("active");
        deleteBtn.removeEventListener("click", handleConfirm);
        cancelBtn.removeEventListener("click", handleCancel);
       };
       const handleCancel = () => {
        modal.classList.remove("active");
        deleteBtn.removeEventListener("click", handleConfirm);
        cancelBtn.removeEventListener("click", handleCancel);
       };
       deleteBtn.addEventListener("click", handleConfirm);
       cancelBtn.addEventListener("click", handleCancel);
       modal.addEventListener("click", function bgHandler(e) {
        if (e.target === modal) {
         handleCancel();
         modal.removeEventListener("click", bgHandler);
        }
       });
      }
      const pageTitleEl = document.getElementById("page-title");
      if (pageTitleEl) {
       pageTitleEl.addEventListener("click", () => {
        showEditModal("Edit Title", PAGE_STATE.title || DEFAULT_PAGE_STATE.title,
         (newTitle) => {
          PAGE_STATE.title = newTitle;
          wieldThePower();
         }, );
       });
      }
      function editNodeName(id) {
       showEditModal("Edit Name", NODE_DATA[id].name, (newName) => {
        pushUndo("edit node name");
        NODE_DATA[id].name = newName;
        const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`, );
        if (nodeGroup) {
         const label = nodeGroup.querySelector(".node-label");
         if (label) label.textContent = newName;
        }
        if (currentNodeId === id) {
         document.getElementById("node-name").textContent = newName;
        }
       });
      }
      function editNodeIp(id) {
       showEditModal("Edit IP/Subtitle", NODE_DATA[id].ip, (newIp) => {
        pushUndo("edit node ip");
        NODE_DATA[id].ip = newIp;
        const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`, );
        if (nodeGroup) {
         const sub = nodeGroup.querySelector(".node-sub");
         if (sub) sub.textContent = newIp;
        }
        if (currentNodeId === id) {
         document.getElementById("node-ip").textContent = newIp;
        }
       });
      }
      function claimTheImmortal(id) {
	   if (isViewOnly()) return;
	   if (!NODE_DATA[id]) return;
       currentNodeId = id;
       currentEdgeId = null;
       currentRectId = null;
       currentTextId = null;
       if (isMobileDevice()) {
        const currentHeight = PAGE_STATE.mobileFooterHeight || 40;
        if (currentHeight <= 20) {
         PAGE_STATE.mobileFooterHeight = 80;
         const root = document.documentElement;
         root.style.setProperty("--mobile-footer-height", "80vh");
         const mobileFooterHeightInput = document.getElementById("mobile-footer-height");
         const mobileFooterHeightVal = document.getElementById("mobile-footer-height-val");
         if (mobileFooterHeightInput) mobileFooterHeightInput.value = 80;
         if (mobileFooterHeightVal) mobileFooterHeightVal.textContent = "80%";
        }
       }
       const data = NODE_DATA[id];
       document.querySelectorAll(".node-group").forEach((n) => {
        n.classList.toggle("active", n.dataset.nodeId === id);
       });
       document.querySelectorAll(".edge").forEach((e) => {
        const active = e.dataset.from === id || e.dataset.to === id;
        e.classList.toggle("active", active);
       });
       document.querySelectorAll(".rect-group").forEach((r) => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach((t) => t.classList.remove("active"));
       document.getElementById("node-panel").style.display = "block";
       document.getElementById("edge-panel").style.display = "none";
       document.getElementById("text-panel").style.display = "none";
       const toolbar = document.getElementById("topology-toolbar");
       if (!topologyToolbarCollapsed) {
        toolbar.style.display = "flex";
       }
       updateTopologyToolbarVisibility();
       document.getElementById("node-name").textContent = data.name;
       document.getElementById("node-ip").textContent = data.ip;
       document.getElementById("node-role").textContent = data.role;
       document.getElementById("node-mac").textContent = data.mac || "--";
       document.getElementById("node-rack").textContent = data.rackUnit || "--";
       document.getElementById("node-uheight").textContent = (data.uHeight || "1") + "U";
       document.getElementById("node-layer").value = data.layer || "physical";
       populateRackDropdown();
       const assignedRackSelect = document.getElementById("node-assigned-rack");
       if (assignedRackSelect) {
        assignedRackSelect.value = data.assignedRack || "";
       }
       const rackCapacitySelect = document.getElementById("node-rack-capacity");
       if (rackCapacitySelect) {
        rackCapacitySelect.value = data.rackCapacity || "42";
       }
       const isRack = data.isRack === true;
       const isAssignedToRack = !!data.assignedRack;
       const assignedRackRow = document.getElementById("assigned-rack-row");
       const rackCapacityRow = document.getElementById("rack-capacity-row");
       const uheightRow = document.getElementById("uheight-row");
       if (assignedRackRow) assignedRackRow.style.display = isRack ? "none" : "flex";
       if (rackCapacityRow) rackCapacityRow.style.display = isRack ? "flex" : "none";
       if (uheightRow) uheightRow.style.display = isAssignedToRack ? "flex" : "none";
       const rackContentsSection = document.getElementById("rack-contents-section");
       const rackContentsList = document.getElementById("rack-contents-list");
       if (rackContentsSection && rackContentsList) {
        if (isRack) {
         const nodesInRack = Object.entries(NODE_DATA).filter(([nid, n]) => n.assignedRack === id);
         if (nodesInRack.length > 0) {
          rackContentsList.innerHTML = nodesInRack.map(([nid, n]) => {
           const tags = (n.tags || []).map(t => `<span style="background: var(--accent); color: var(--bg); padding: 2px 6px; border-radius: 4px; font-size: 11px; margin-left: 4px;">${t}</span>`).join('');
           return `<div style="padding: 6px 0; border-bottom: 1px solid var(--edge-main); cursor: pointer;" onclick="claimTheImmortal('${nid}')">
            <span style="color: var(--text-main);">${n.name}</span>${tags}
           </div>`;
          }).join('');
          rackContentsSection.style.display = "block";
         } else {
          rackContentsList.innerHTML = '<div style="color: var(--text-soft); font-style: italic;">No nodes assigned</div>';
          rackContentsSection.style.display = "block";
         }
        } else {
         rackContentsSection.style.display = "none";
        }
       }
       document.getElementById("node-name").onclick = () => editNodeName(id);
       document.getElementById("node-ip").onclick = () => editNodeIp(id);
       document.getElementById("node-mac").onclick = () => editNodeMac(id);
       document.getElementById("node-rack").onclick = () => editNodeRack(id);
       document.getElementById("node-uheight").onclick = () => editNodeUHeight(id);
       const currentSize = savedSizes[id] || getDefaultSize();
       document.getElementById("size-slider").value = currentSize;
       document.getElementById("size-value").textContent = currentSize;
       const styleEntry = savedStyles[id] || {};
       const resolvedStyles = resolveStylesEntry(styleEntry);
       const scopeKey = currentStyleScope || "all";
       const flatProps = ["circleColor", "circleBorder", "titleColor", "titleFont", "titleSize", "subColor", "subFont", "subSize", ];
       const isFlat = flatProps.some((p) => Object.prototype.hasOwnProperty.call(styleEntry, p), );
       const scopedStyles = isFlat ? styleEntry : styleEntry[scopeKey] || {};
       const circleColorInput = document.getElementById("circle-color");
       const titleColorInput = document.getElementById("title-color");
       const titleFontSelect = document.getElementById("title-font");
       const titleSizeInput = document.getElementById("title-size");
       const subColorInput = document.getElementById("sub-color");
       const subFontSelect = document.getElementById("sub-font");
       const subSizeInput = document.getElementById("sub-size");
       const shapeSelect = document.getElementById("shape-select");
       const scopeSelect = document.getElementById("style-scope");
      circleColorInput.value = scopedStyles.circleColor || resolvedStyles.circleColor || PAGE_STATE.nodeFill || "#1e293b";
       const circleBorderInput = document.getElementById("circle-border");
       circleBorderInput.value = scopedStyles.circleBorder || resolvedStyles.circleBorder || PAGE_STATE.nodeStroke || "#475569";
        titleColorInput.value = scopedStyles.titleColor || resolvedStyles.titleColor || PAGE_STATE.textMain || "#e2e8f0";
        titleFontSelect.value = scopedStyles.titleFont || resolvedStyles.titleFont || "system-ui, sans-serif";
        titleSizeInput.value = scopedStyles.titleSize || resolvedStyles.titleSize || 18;
        subColorInput.value = scopedStyles.subColor || resolvedStyles.subColor || PAGE_STATE.textSoft || "#94a3b8";
       subFontSelect.value = scopedStyles.subFont || resolvedStyles.subFont || "system-ui, sans-serif";
       subSizeInput.value = scopedStyles.subSize || resolvedStyles.subSize || 13;
       shapeSelect.value = data.shape || "circle";
       scopeSelect.value = currentStyleScope || "all";
       document.getElementById("title-offset-y").value = scopedStyles.titleOffsetY || resolvedStyles.titleOffsetY || 0;
       document.getElementById("title-offset-x").value = scopedStyles.titleOffsetX || resolvedStyles.titleOffsetX || 0;
       document.getElementById("sub-offset-y").value = scopedStyles.subOffsetY || resolvedStyles.subOffsetY || 0;
       document.getElementById("sub-offset-x").value = scopedStyles.subOffsetX || resolvedStyles.subOffsetX || 0;
       const tagEl = document.getElementById("node-tags");
       tagEl.innerHTML = "";
       data.tags.forEach((tag, i) => {
        const b = document.createElement("span");
        b.className = "badge";
        if (tag.toLowerCase().includes("wg")) b.classList.add("wg");
        b.style.cursor = "pointer";
        b.style.position = "relative";
        const tagText = document.createElement("span");
        tagText.textContent = tag;
        tagText.addEventListener("click", (e) => {
         e.stopPropagation();
         showEditModal("Edit Tag", tag, (newTag) => {
          if (newTag) {
           pushUndo("edit tag");
           data.tags[i] = newTag;
           claimTheImmortal(id);
          }
         });
        });
        const deleteTag = document.createElement("span");
        deleteTag.textContent = " ✕";
        deleteTag.style.opacity = "0.6";
        deleteTag.style.marginLeft = "4px";
        deleteTag.style.fontSize = "10px";
        deleteTag.addEventListener("click", (e) => {
         e.stopPropagation();
         pushUndo("delete tag");
         data.tags.splice(i, 1);
         claimTheImmortal(id);
        });
        b.append(tagText, deleteTag);
        tagEl.append(b);
       });
       const addTagBtn = document.createElement("span");
       addTagBtn.className = "badge";
       addTagBtn.style.cursor = "pointer";
       addTagBtn.style.opacity = "0.6";
       addTagBtn.style.borderStyle = "dashed";
       addTagBtn.textContent = "+ Add Tag";
       addTagBtn.addEventListener("click", () => {
        showEditModal("Add Tag(s) : comma separated", "",
         (newTagStr) => {
          if (newTagStr) {
           pushUndo("add tags");
           const newTags = newTagStr.split(",").map((t) => t.trim()).filter((t) => t);
           newTags.forEach((t) => data.tags.push(t));
           claimTheImmortal(id);
          }
         }, );
       });
       tagEl.append(addTagBtn);
       const notesEl = document.getElementById("node-notes");
       notesEl.innerHTML = "";
       data.notes.forEach((note, i) => {
        const li = document.createElement("li");
        const noteText = document.createElement("span");
        noteText.textContent = note;
        noteText.style.flex = "1";
        const deleteBtn = document.createElement("span");
        deleteBtn.className = "delete-note";
        deleteBtn.textContent = "✕";
        deleteBtn.addEventListener("click", (e) => {
         e.stopPropagation();
         challengeTheImmortal("Are you sure you want to delete this note?",
          () => {
           pushUndo("delete note");
           data.notes.splice(i, 1);
           claimTheImmortal(id);
          }, );
        });
        li.append(noteText, deleteBtn);
        noteText.addEventListener("dblclick", () => {
         noteText.classList.add("editing");
         noteText.contentEditable = true;
         noteText.focus();
        });
        noteText.addEventListener("blur", () => {
         noteText.classList.remove("editing");
         noteText.contentEditable = false;
         data.notes[i] = noteText.textContent;
        });
        notesEl.append(li);
       });
      const addLineSelect = document.getElementById("add-line-select");
      addLineSelect.innerHTML = "";
      const currentRack = data.assignedRack || "";
      Object.entries(NODE_DATA).forEach(([nodeId, node]) => {
      if (nodeId !== id) {
      const nodeRack = node.assignedRack || "";
      if (currentRack === nodeRack) {
      const opt = document.createElement("option");
      opt.value = nodeId;
      opt.textContent = node.name;
      addLineSelect.appendChild(opt);
      }
      }
      });
      }
      function selectTheConnection(id) {
	   if (isViewOnly()) return;
       currentEdgeId = id;
       currentNodeId = null;
       currentRectId = null;
       currentTextId = null;
       if (isMobileDevice()) {
        const currentHeight = PAGE_STATE.mobileFooterHeight || 40;
        if (currentHeight <= 20) {
         PAGE_STATE.mobileFooterHeight = 80;
         const root = document.documentElement;
         root.style.setProperty("--mobile-footer-height", "80vh");
         const mobileFooterHeightInput = document.getElementById("mobile-footer-height");
         const mobileFooterHeightVal = document.getElementById("mobile-footer-height-val");
         if (mobileFooterHeightInput) mobileFooterHeightInput.value = 80;
         if (mobileFooterHeightVal) mobileFooterHeightVal.textContent = "80%";
        }
       }
       document.getElementById("node-panel").style.display = "none";
       document.getElementById("edge-panel").style.display = "block";
       document.getElementById("text-panel").style.display = "none";
       document.getElementById("rect-panel").style.display = "none";
       document.getElementById("topology-toolbar").style.display = "none";
       document.querySelectorAll(".node-group").forEach((n) => n.classList.remove("active"));
       document.querySelectorAll(".rect-group").forEach((r) => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach((t) => t.classList.remove("active"));
       document.querySelectorAll(".edge").forEach((e) => {
        e.classList.toggle("active", e.dataset.edgeId === id);
       });
       const edge = EDGE_DATA.list.find((e) => e.id === id);
       if (!edge) return;
       const directionSymbols = {
        none: "⇄",
        forward: "→",
        backward: "←",
        both: "↔",
       };
       const dirSymbol = directionSymbols[edge.direction] || "⇄";
       let titleText = "Custom line";
       if (edge.from || edge.to) {
        const fromName = edge.from ? NODE_DATA[edge.from]?.name || edge.from : "";
        const toName = edge.to ? NODE_DATA[edge.to]?.name || edge.to : "";
        titleText = `${fromName || "?"} ${dirSymbol} ${toName || "?"}`;
       }
       document.getElementById("edge-title").textContent = titleText;
       const widthInput = document.getElementById("edge-width");
       const colorInput = document.getElementById("edge-color");
       const directionSelect = document.getElementById("edge-direction");
       const lineStyleSelect = document.getElementById("edge-line-style");
       widthInput.value = edge.width;
       colorInput.value = edge.color;
       directionSelect.value = edge.direction || "none";
       lineStyleSelect.value = edge.lineStyle || "solid";
       const fromPortRow = document.getElementById("edge-from-port-row");
       const toPortRow = document.getElementById("edge-to-port-row");
       const fromPortInput = document.getElementById("edge-from-port");
       const toPortInput = document.getElementById("edge-to-port");
       if (edge.type === "custom") {
        fromPortRow.style.display = "none";
        toPortRow.style.display = "none";
       } else {
        fromPortRow.style.display = "flex";
        toPortRow.style.display = "flex";
        fromPortInput.value = edge.fromPort || "";
        toPortInput.value = edge.toPort || "";
        fromPortInput.onchange = () => updateEdgePortLabels(id);
        toPortInput.onchange = () => updateEdgePortLabels(id);
       }
       const list = document.getElementById("edge-notes");
       list.innerHTML = "";
       edge.notes.forEach((note, i) => {
        const li = document.createElement("li");
        const txt = document.createElement("span");
        txt.textContent = note;
        txt.style.flex = "1";
        const del = document.createElement("span");
        del.className = "delete-note";
        del.textContent = "✕";
        del.addEventListener("click", (e) => {
         e.stopPropagation();
         challengeTheImmortal("Delete this line note?", () => {
          pushUndo("delete edge note");
          edge.notes.splice(i, 1);
          selectTheConnection(id);
         });
        });
        txt.addEventListener("dblclick", () => {
         txt.classList.add("editing");
         txt.contentEditable = true;
         txt.focus();
        });
        txt.addEventListener("blur", () => {
         txt.classList.remove("editing");
         txt.contentEditable = false;
         pushUndo("edit edge note");
         edge.notes[i] = txt.textContent;
        });
        li.append(txt, del);
        list.appendChild(li);
       });
       if (edge.type === "custom" && Array.isArray(edge.points)) {
        forgeTheTopology();
       }
      }
      window.addEventListener("resize", () => {
       forgeTheTopology();
       if (currentEdgeId) {
        selectTheConnection(currentEdgeId);
       } else if (currentNodeId && NODE_DATA[currentNodeId]) {
        claimTheImmortal(currentNodeId);
       } else {
        const availableNodes = Object.keys(NODE_DATA);
        if (availableNodes.length > 0) {
         claimTheImmortal(availableNodes[0]);
        }
       }
      });
      (function initZoomPan() {
       const viewport = document.getElementById("canvas-viewport");
       const svg = document.getElementById("map");
       const hint = document.getElementById("canvas-hint");
       setTimeout(() => {
        hint.classList.add("visible");
        setTimeout(() => hint.classList.remove("visible"), 4000);
       }, 1000);
       viewport.addEventListener("wheel",
        (e) => {
         e.preventDefault();
         const rect = viewport.getBoundingClientRect();
         const mouseX = (e.clientX - rect.left) / rect.width;
         const mouseY = (e.clientY - rect.top) / rect.height;
         const delta = e.deltaY > 0 ? 0.9 : 1.1;
         zoomTo(canvasState.zoom * delta, mouseX, mouseY);
        }, {
         passive: false
        }, );
       let initialPinchDistance = 0;
       let initialPinchZoom = 1;
       let pinchCenter = {
        x: 0.5,
        y: 0.5
       };
       viewport.addEventListener("touchstart",
        (e) => {
         if (e.touches.length === 2) {
          e.preventDefault();
          const touch1 = e.touches[0];
          const touch2 = e.touches[1];
          initialPinchDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY, );
          initialPinchZoom = canvasState.zoom;
          const rect = viewport.getBoundingClientRect();
          const centerX = (touch1.clientX + touch2.clientX) / 2;
          const centerY = (touch1.clientY + touch2.clientY) / 2;
          pinchCenter.x = (centerX - rect.left) / rect.width;
          pinchCenter.y = (centerY - rect.top) / rect.height;
         }
        }, {
         passive: false
        }, );
       viewport.addEventListener("touchmove",
        (e) => {
         if (e.touches.length === 2) {
          e.preventDefault();
          const touch1 = e.touches[0];
          const touch2 = e.touches[1];
          const currentDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY, );
          if (initialPinchDistance > 0) {
           const scale = currentDistance / initialPinchDistance;
           const newZoom = initialPinchZoom * scale;
           zoomTo(newZoom, pinchCenter.x, pinchCenter.y);
          }
         }
        }, {
         passive: false
        }, );
       let panStartViewX = 0;
       let panStartViewY = 0;
       let lastEmptyTapTime = 0;
       let emptyTapTimeout = null;
       let emptyTapMoved = false;
       let emptyTapStartX = 0;
       let emptyTapStartY = 0;
       viewport.addEventListener("touchend", (e) => {
         if (currentView.mode !== "rack") return;
         if (e.changedTouches.length !== 1) return;
      const isNodeOrEdge = e.target.closest(".node-group") || e.target.closest(".edge-group");
         if (isNodeOrEdge) return;
         if (emptyTapMoved) {
           emptyTapMoved = false;
           return;
         }
         const currentTime = new Date().getTime();
         const tapGap = currentTime - lastEmptyTapTime;
         if (tapGap < 300 && tapGap > 0) {
           e.preventDefault();
           exitRack();
           if (navigator.vibrate) {
             navigator.vibrate(50);
           }
           lastEmptyTapTime = 0;
           if (emptyTapTimeout) {
             clearTimeout(emptyTapTimeout);
             emptyTapTimeout = null;
           }
         } else {
           lastEmptyTapTime = currentTime;
           if (emptyTapTimeout) clearTimeout(emptyTapTimeout);
           emptyTapTimeout = setTimeout(() => {
             lastEmptyTapTime = 0;
           }, 300);
         }
       }, { passive: false });
       viewport.addEventListener("mousedown", (e) => {
        if (e.target.closest(".draw-toolbar") || e.target.closest(".topology-toolbar") || e.target.closest(".legend-container")) {
         return;
        }
        if (freeDrawMode || rectDrawMode) {
         return;
        }
      const isEmptySpace = e.target === svg || e.target === viewport || e.target.tagName === "svg";
      const isEdgeElement = e.target.closest('.edge') || e.target.classList.contains('edge-edit-point');
      const isTextElement = e.target.closest('.text-group') || e.target.closest('.text-element');
      const isRectElement = e.target.closest('.rect-group');
      if (!isEdgeElement && !isTextElement && !isRectElement && currentEdgeId) {
      currentEdgeId = null;
      forgeTheTopology();
      }
      if (!isRectElement && currentRectId) {
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      }
	  if (isViewOnly()) {
         document.body.classList.remove("view-only-inspect");
         document.getElementById("node-panel").style.display = "none";
         document.getElementById("edge-panel").style.display = "none";
        }
        if (isEmptySpace && e.shiftKey && e.button === 0) {
         if (isViewOnly()) return;
         e.preventDefault();
         startSelection(e);
         return;
        }
        if (isEmptySpace || e.button === 2 || e.button === 1) {
         e.preventDefault();
         canvasState.isPanning = true;
         canvasState.panStartX = e.clientX;
         canvasState.panStartY = e.clientY;
         panStartViewX = canvasState.panX;
         panStartViewY = canvasState.panY;
         viewport.classList.add("panning");
        }
       });
       viewport.addEventListener("touchstart",
        (e) => {
         if (e.target.closest(".draw-toolbar") || e.target.closest(".topology-toolbar") || e.target.closest(".legend-container")) {
          return;
         }
         if (freeDrawMode || rectDrawMode) {
          return;
         }
      const isEmptySpace = e.target === svg || e.target === viewport || e.target.tagName === "svg";
      const isEdgeElement = e.target.closest('.edge') || e.target.classList.contains('edge-edit-point');
      const isTextElement = e.target.closest('.text-group') || e.target.closest('.text-element');
      const isRectElement = e.target.closest('.rect-group');
      if (!isEdgeElement && !isTextElement && !isRectElement && currentEdgeId) {
      currentEdgeId = null;
      forgeTheTopology();
      }
      if (!isRectElement && currentRectId) {
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      }
          if (isEmptySpace && e.touches.length === 1) {
           e.preventDefault();
           emptyTapMoved = false;
           emptyTapStartX = e.touches[0].clientX;
           emptyTapStartY = e.touches[0].clientY;
           canvasState.isPanning = true;
           canvasState.panStartX = e.touches[0].clientX;
           canvasState.panStartY = e.touches[0].clientY;
           panStartViewX = canvasState.panX;
           panStartViewY = canvasState.panY;
           viewport.classList.add("panning");
         }
        }, {
         passive: false
        }, );
       document.addEventListener("mousemove", (e) => {
        if (isSelecting) {
         updateSelection(e);
         return;
        }
        if (!canvasState.isPanning) return;
        const dx = e.clientX - canvasState.panStartX;
        const dy = e.clientY - canvasState.panStartY;
        const rect = viewport.getBoundingClientRect();
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        const canvasDx = (dx / rect.width) * viewWidth;
        const canvasDy = (dy / rect.height) * viewHeight;
        canvasState.panX = panStartViewX - canvasDx;
        canvasState.panY = panStartViewY - canvasDy;
        constrainPan();
        updateViewBox();
       });
       document.addEventListener("touchmove", (e) => {
        if (!canvasState.isPanning || !e.touches[0]) return;
        const moveDx = Math.abs(e.touches[0].clientX - emptyTapStartX);
        const moveDy = Math.abs(e.touches[0].clientY - emptyTapStartY);
        if (moveDx > 15 || moveDy > 15) {
         emptyTapMoved = true;
        }
        const dx = e.touches[0].clientX - canvasState.panStartX;
        const dy = e.touches[0].clientY - canvasState.panStartY;
        const rect = viewport.getBoundingClientRect();
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        const canvasDx = (dx / rect.width) * viewWidth;
        const canvasDy = (dy / rect.height) * viewHeight;
        canvasState.panX = panStartViewX - canvasDx;
        canvasState.panY = panStartViewY - canvasDy;
        constrainPan();
        updateViewBox();
       });
       document.addEventListener("mouseup", () => {
        if (isSelecting) {
         endSelection();
        }
        if (canvasState.isPanning) {
         canvasState.isPanning = false;
         viewport.classList.remove("panning");
        }
       });
       document.addEventListener("touchend", () => {
        if (canvasState.isPanning) {
         canvasState.isPanning = false;
         viewport.classList.remove("panning");
        }
       });
       document.addEventListener("keydown", (e) => {
        const isEditing = document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "TEXTAREA" || document.activeElement.isContentEditable;
        if (e.code === "Space" && !e.repeat && !isEditing) {
         e.preventDefault();
         canvasState.spacePressed = true;
         viewport.style.cursor = "grab";
        }
       });
       document.addEventListener("keyup", (e) => {
        if (e.code === "Space") {
         canvasState.spacePressed = false;
         viewport.style.cursor = "";
        }
       });
       document.getElementById("zoom-in-btn").addEventListener("click", () => {
        zoomTo(canvasState.zoom * 1.25, 0.5, 0.5);
       });
       document.getElementById("zoom-out-btn").addEventListener("click", () => {
        zoomTo(canvasState.zoom * 0.8, 0.5, 0.5);
       });
       document.getElementById("zoom-fit-btn").addEventListener("click", fitToContent);
       document.getElementById("zoom-reset-btn").addEventListener("click", resetView);
       const minimapContainer = document.getElementById("minimap-container");
       const minimapSvg = document.getElementById("minimap");
       let minimapDragging = false;
       minimapContainer.addEventListener("mousedown", (e) => {
        e.preventDefault();
        minimapDragging = true;
        updatePanFromMinimap(e);
       });
       minimapContainer.addEventListener("touchstart",
        (e) => {
         e.preventDefault();
         minimapDragging = true;
         updatePanFromMinimapTouch(e);
        }, {
         passive: false
        }, );
       document.addEventListener("mousemove", (e) => {
        if (minimapDragging) {
         updatePanFromMinimap(e);
        }
       });
       document.addEventListener("touchmove", (e) => {
        if (minimapDragging && e.touches[0]) {
         updatePanFromMinimapTouch(e);
        }
       });
       document.addEventListener("mouseup", () => {
        minimapDragging = false;
       });
       document.addEventListener("touchend", () => {
        minimapDragging = false;
       });
       function updatePanFromMinimap(e) {
        const rect = minimapContainer.getBoundingClientRect();
        const x = (e.clientX - rect.left) / rect.width;
        const y = (e.clientY - rect.top) / rect.height;
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        canvasState.panX = x * CANVAS_WIDTH - viewWidth / 2;
        canvasState.panY = y * CANVAS_HEIGHT - viewHeight / 2;
        constrainPan();
        updateViewBox();
       }
       function updatePanFromMinimapTouch(e) {
        const rect = minimapContainer.getBoundingClientRect();
        const touch = e.touches[0];
        const x = (touch.clientX - rect.left) / rect.width;
        const y = (touch.clientY - rect.top) / rect.height;
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        canvasState.panX = x * CANVAS_WIDTH - viewWidth / 2;
        canvasState.panY = y * CANVAS_HEIGHT - viewHeight / 2;
        constrainPan();
        updateViewBox();
       }
       document.addEventListener("keydown", (e) => {
        if (document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "TEXTAREA") return;
        if (
         (e.key === "+" || e.key === "=") && (e.ctrlKey || e.metaKey)) {
         e.preventDefault();
         zoomTo(canvasState.zoom * 1.25, 0.5, 0.5);
        } else if (e.key === "-" && (e.ctrlKey || e.metaKey)) {
         e.preventDefault();
         zoomTo(canvasState.zoom * 0.8, 0.5, 0.5);
        } else if (e.key === "0" && (e.ctrlKey || e.metaKey)) {
         e.preventDefault();
         resetView();
        }
       });
       setTimeout(() => {
        fitToContent();
       }, 100);
      })();
      const sizeSlider = document.getElementById("size-slider");
      const sizeValue = document.getElementById("size-value");
      const resetSizeBtn = document.getElementById("reset-size");
      sizeSlider.addEventListener("input", () => {
       const newSize = parseInt(sizeSlider.value, 10);
       sizeValue.textContent = newSize;
       pushUndo("resize node");
       savedSizes[currentNodeId] = newSize;
       const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
       if (nodeGroup) {
        const oldShape = nodeGroup.querySelector(".node-circle");
        if (oldShape) oldShape.remove();
        const shapeType = (NODE_DATA[currentNodeId] && NODE_DATA[currentNodeId].shape) || "circle";
        const newShape = createShapeElement(shapeType, newSize);
        newShape.classList.add("node-circle");
        const styles = resolveStylesForNode(currentNodeId);
        if (styles.circleColor) newShape.style.fill = styles.circleColor;
        if (styles.circleBorder) newShape.style.stroke = styles.circleBorder;
        nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
        const label = nodeGroup.querySelector(".node-label");
        const sub = nodeGroup.querySelector(".node-sub");
        if (label) {
         label.setAttribute("y", -newSize * 0.28);
         const labelSize = styles.titleSize || newSize * 0.33;
         label.style.fontSize = labelSize + "px";
        }
        if (sub) {
         sub.setAttribute("y", newSize * 0.4);
         const subSize = styles.subSize || newSize * 0.24;
         sub.style.fontSize = subSize + "px";
        }
       }
      });
      resetSizeBtn.addEventListener("click", () => {
       pushUndo("reset size");
       delete savedSizes[currentNodeId];
       const defaultSize = getDefaultSize();
       sizeSlider.value = defaultSize;
       sizeValue.textContent = defaultSize;
       const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
       if (nodeGroup) {
        const oldShape = nodeGroup.querySelector(".node-circle");
        if (oldShape) oldShape.remove();
        const shapeType = (NODE_DATA[currentNodeId] && NODE_DATA[currentNodeId].shape) || "circle";
        const newShape = createNodeShape(currentNodeId, defaultSize);
        nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
        const styles = resolveStylesForNode(currentNodeId);
        if (styles.circleColor) newShape.style.fill = styles.circleColor;
        if (styles.circleBorder) newShape.style.stroke = styles.circleBorder;
        const label = nodeGroup.querySelector(".node-label");
        const sub = nodeGroup.querySelector(".node-sub");
        if (label) {
         label.setAttribute("y", -defaultSize * 0.28);
         const labelSize = styles.titleSize || defaultSize * 0.33;
         label.style.fontSize = labelSize + "px";
        }
        if (sub) {
         sub.setAttribute("y", defaultSize * 0.4);
         const subSize = styles.subSize || defaultSize * 0.24;
         sub.style.fontSize = subSize + "px";
        }
       }
      });
      const applyStyle = (property, value) => {
       pushUndo("style change");
       const styleEntry = ensureStyleEntry(currentNodeId);
       const scopeKey = currentStyleScope || "all";
       if (!styleEntry[scopeKey]) styleEntry[scopeKey] = {};
       styleEntry[scopeKey][property] = value;
       const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
       if (!nodeGroup) return;
       const shapeEl = nodeGroup.querySelector(".node-circle");
       const label = nodeGroup.querySelector(".node-label");
       const sub = nodeGroup.querySelector(".node-sub");
       if (property === "circleColor" && shapeEl) shapeEl.style.fill = value;
      else if (property === "circleBorder" && shapeEl) shapeEl.style.stroke = value;
       else if (property === "titleColor" && label) label.style.fill = value;
       else if (property === "titleFont" && label) label.style.fontFamily = value;
       else if (property === "titleSize" && label) label.style.fontSize = value + "px";
       else if (property === "subColor" && sub) sub.style.fill = value;
       else if (property === "subFont" && sub) sub.style.fontFamily = value;
       else if (property === "subSize" && sub) sub.style.fontSize = value + "px";
      };
      document.getElementById("circle-color").addEventListener("input", (e) => applyStyle("circleColor", e.target.value), );
      document.getElementById("circle-border").addEventListener("input", (e) => applyStyle("circleBorder", e.target.value), );
      document.getElementById("title-color").addEventListener("input", (e) => applyStyle("titleColor", e.target.value), );
      document.getElementById("title-font").addEventListener("change", (e) => applyStyle("titleFont", e.target.value), );
      document.getElementById("title-size").addEventListener("input", (e) => applyStyle("titleSize", parseInt(e.target.value, 10)), );
      document.getElementById("sub-color").addEventListener("input", (e) => applyStyle("subColor", e.target.value), );
      document.getElementById("sub-font").addEventListener("change", (e) => applyStyle("subFont", e.target.value), );
      document.getElementById("sub-size").addEventListener("input", (e) => applyStyle("subSize", parseInt(e.target.value, 10)), );
      document.getElementById("title-offset-y").addEventListener("input", (e) => {
       applyStyle("titleOffsetY", parseInt(e.target.value, 10) || 0);
       forgeTheTopology();
       if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      document.getElementById("title-offset-x").addEventListener("input", (e) => {
       applyStyle("titleOffsetX", parseInt(e.target.value, 10) || 0);
       forgeTheTopology();
       if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      document.getElementById("sub-offset-y").addEventListener("input", (e) => {
       applyStyle("subOffsetY", parseInt(e.target.value, 10) || 0);
       forgeTheTopology();
       if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      document.getElementById("sub-offset-x").addEventListener("input", (e) => {
       applyStyle("subOffsetX", parseInt(e.target.value, 10) || 0);
       forgeTheTopology();
       if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      document.getElementById("reset-styles").addEventListener("click", () => {
       delete savedStyles[currentNodeId];
       forgeTheTopology();
       claimTheImmortal(currentNodeId);
      });
      document.getElementById("style-scope").addEventListener("change", (e) => {
       currentStyleScope = e.target.value || "all";
       claimTheImmortal(currentNodeId);
      });
      document.getElementById("shape-select").addEventListener("change", (e) => {
       const shape = e.target.value || "circle";
       pushUndo("change shape");
       NODE_DATA[currentNodeId].shape = shape;
       const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
       if (!nodeGroup) return;
       const oldShape = nodeGroup.querySelector(".node-circle");
       if (oldShape) oldShape.remove();
       const size = savedSizes[currentNodeId] || getDefaultSize();
       const newShape = createNodeShape(currentNodeId, size);
       nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
      });
      const addNoteBtn = document.getElementById("add-note-btn");
      const noteInput = document.getElementById("new-note-input");
      addNoteBtn.addEventListener("click", () => {
       const newNote = noteInput.value.trim();
       if (newNote && currentNodeId) {
	    pushUndo("add note");
        NODE_DATA[currentNodeId].notes.push(newNote);
        claimTheImmortal(currentNodeId);
        noteInput.value = "";
       }
      });
      noteInput.addEventListener("keypress", (e) => {
       if (e.key === "Enter") {
        addNoteBtn.click();
       }
      });
      document.getElementById("edge-width").addEventListener("input", () => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       const v = parseInt(document.getElementById("edge-width").value, 10);
       if (Number.isNaN(v) || v <= 0) return;
       pushUndo("edit edge");
       edge.width = v;
       const el = document.querySelector(`.edge[data-edge-id="${currentEdgeId}"]`, );
       if (el) el.style.strokeWidth = v;
      });
      document.getElementById("edge-color").addEventListener("input", () => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       const color = document.getElementById("edge-color").value;
       pushUndo("edit edge");
       edge.color = color;
       const el = document.querySelector(`.edge[data-edge-id="${currentEdgeId}"]`, );
       if (el) el.style.stroke = color;
       forgeTheLegend();
      });
      document.getElementById("edge-direction").addEventListener("change", () => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       pushUndo("edit edge");
       edge.direction = document.getElementById("edge-direction").value;
       forgeTheTopology();
       selectTheConnection(currentEdgeId);
      });
      document.getElementById("edge-line-style").addEventListener("change", () => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       pushUndo("edit edge");
       edge.lineStyle = document.getElementById("edge-line-style").value;
       forgeTheTopology();
       selectTheConnection(currentEdgeId);
      });
      const addEdgeNoteBtn = document.getElementById("add-edge-note");
      const newEdgeNoteInput = document.getElementById("new-edge-note");
      addEdgeNoteBtn.addEventListener("click", () => {
       const txt = newEdgeNoteInput.value.trim();
       if (!txt || !currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
	   pushUndo("add edge note");
       edge.notes.push(txt);
       newEdgeNoteInput.value = "";
       selectTheConnection(currentEdgeId);
      });
      newEdgeNoteInput.addEventListener("keypress", (e) => {
       if (e.key === "Enter") {
        addEdgeNoteBtn.click();
       }
      });
      function selectTheRect(id) {
	  if (isViewOnly()) return;
      currentRectId = id;
      currentNodeId = null;
      currentEdgeId = null;
      currentTextId = null;
      document.getElementById("node-panel").style.display = "none";
      document.getElementById("edge-panel").style.display = "none";
      document.getElementById("text-panel").style.display = "none";
      document.getElementById("rect-panel").style.display = "block";
      document.getElementById("topology-toolbar").style.display = "none";
      document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active"));
      document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
      document.querySelectorAll(".text-element").forEach(t => t.classList.remove("active"));
      document.querySelectorAll(".rect-group").forEach(r => r.classList.toggle("active", r.dataset.rectId === id));
      const rect = RECT_DATA.list.find(r => r.id === id);
      if (!rect) return;
      document.getElementById("rect-title").textContent = "";
      document.getElementById("rect-color").value = rect.color || "#f97316";
      document.getElementById("rect-border-color").value = rect.borderColor || rect.color || "#f97316";
      document.getElementById("rect-border-width").value = rect.borderWidth !== undefined ? rect.borderWidth : 2;
      document.getElementById("rect-style-select").value = rect.style || "filled";
      document.getElementById("rect-line-style").value = rect.lineStyle || "solid";
      document.getElementById("rect-fill-row").style.display = (rect.style === "outlined") ? "none" : "flex";
      const list = document.getElementById("rect-notes");
      list.innerHTML = "";
      (rect.notes || []).forEach((note, i) => {
      const li = document.createElement("li");
      const txt = document.createElement("span");
      txt.textContent = note;
      txt.style.flex = "1";
      const del = document.createElement("span");
      del.className = "delete-note";
      del.textContent = "✕";
       del.addEventListener("click", (e) => {
      e.stopPropagation();
      challengeTheImmortal("Delete this note?", () => {
        pushUndo("delete zone note");
        rect.notes.splice(i, 1);
        selectTheRect(id);
      });
      });
      li.appendChild(txt);
      li.appendChild(del);
      list.appendChild(li);
      });
      forgeTheTopology();
      }
      document.getElementById("rect-color").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.color = document.getElementById("rect-color").value;
      forgeTheTopology();
      });
      document.getElementById("rect-border-color").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.borderColor = document.getElementById("rect-border-color").value;
      forgeTheTopology();
      });
      document.getElementById("rect-border-width").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.borderWidth = parseInt(document.getElementById("rect-border-width").value) || 2;
      forgeTheTopology();
      });
      document.getElementById("rect-style-select").addEventListener("change", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.style = document.getElementById("rect-style-select").value;
      forgeTheTopology();
      selectTheRect(currentRectId);
      });
      document.getElementById("rect-line-style").addEventListener("change", () => {
      if (!currentRectId) return;
      pushUndo("change zone line style");
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      rect.lineStyle = document.getElementById("rect-line-style").value;
      forgeTheTopology();
      });
      document.getElementById("add-rect-note").addEventListener("click", () => {
      const input = document.getElementById("new-rect-note");
      const txt = input.value.trim();
      if (!txt || !currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      if (!rect.notes) rect.notes = [];
	  pushUndo("add zone note");
      rect.notes.push(txt);
      input.value = "";
      selectTheRect(currentRectId);
      });
      document.getElementById("new-rect-note").addEventListener("keypress", (e) => {
      if (e.key === "Enter") {
      document.getElementById("add-rect-note").click();
      }
      });
      document.getElementById("delete-rect").addEventListener("click", () => {
      if (!currentRectId) return;
      challengeTheImmortal("Delete this zone?", () => {
      pushUndo("delete zone");
      RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== currentRectId);
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      });
      });
      document.getElementById("delete-edge").addEventListener("click", () => {
       if (!currentEdgeId) return;
       challengeTheImmortal("Are you sure you want to delete this line?",
        () => {
         pushUndo("delete edge");
         EDGE_DATA.list = EDGE_DATA.list.filter(
          (e) => e.id !== currentEdgeId, );
         currentEdgeId = null;
         forgeTheTopology();
         const availableNodes = Object.keys(NODE_DATA);
         if (availableNodes.length > 0) {
          claimTheImmortal(availableNodes[0]);
         } else {
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("topology-toolbar", ).style.display = "none";
         }
        }, );
      });
      document.getElementById("add-line-btn").addEventListener("click", () => {
       if (!currentNodeId) return;
       const select = document.getElementById("add-line-select");
       const directionSelect = document.getElementById("add-line-direction");
       const colorInput = document.getElementById("add-line-color");
       const targetId = select.value;
       if (!targetId || targetId === currentNodeId) return;
       const direction = directionSelect.value || "none";
       const lineColor = colorInput.value || "#475569";
       const newId = `${currentNodeId}-${targetId}-${Date.now()}`;
       const newEdge = {
        id: newId,
        from: currentNodeId,
        to: targetId,
        width: 4,
        color: lineColor,
        direction: direction,
        type: "main",
        notes: [],
        fromPort: "",
        toPort: "",
        lineStyle: "solid",
       };
	   pushUndo("add edge");
       EDGE_DATA.list.push(newEdge);
       forgeTheTopology();
       claimTheImmortal(currentNodeId);
      });
      let freeDrawPoints = [];
      let freeDrawPolylineEl = null;
      let freeDrawPointEls = [];
       let rectStartPoint = null;
       let rectPreviewEl = null;
       let rectStyle = "filled";
      const drawToggleBtn = document.getElementById("draw-toggle");
      const drawUndoBtn = document.getElementById("draw-undo");
      const drawColorInput = document.getElementById("draw-color");
      const drawStyleSelect = document.getElementById("draw-style");
      const drawArrowSelect = document.getElementById("draw-arrow");
      const svgMap = document.getElementById("map");
      function updateFreeDrawGraphics() {
       const ns = "http://www.w3.org/2000/svg";
       const svg = svgMap;
       if (!freeDrawPolylineEl && freeDrawPoints.length > 0) {
        freeDrawPolylineEl = document.createElementNS(ns, "polyline");
        freeDrawPolylineEl.classList.add("edge", "free-preview");
        freeDrawPolylineEl.setAttribute("fill", "none");
        svg.appendChild(freeDrawPolylineEl);
       }
       if (freeDrawPolylineEl) {
        if (freeDrawPoints.length === 0) {
         freeDrawPolylineEl.remove();
         freeDrawPolylineEl = null;
        } else {
         const ptsStr = freeDrawPoints.map((p) => `${p.x},${p.y}`).join(" ");
         freeDrawPolylineEl.setAttribute("points", ptsStr);
         freeDrawPolylineEl.style.stroke = drawColorInput.value || "#475569";
         freeDrawPolylineEl.style.strokeWidth = 3;
         const lineStyle = drawStyleSelect.value || "solid";
         if (lineStyle === "dashed") {
          freeDrawPolylineEl.style.strokeDasharray = "10,5";
         } else if (lineStyle === "dotted") {
          freeDrawPolylineEl.style.strokeDasharray = "2,4";
         } else {
          freeDrawPolylineEl.style.strokeDasharray = "none";
         }
        }
       }
       freeDrawPointEls.forEach((el) => el.remove());
       freeDrawPointEls = [];
       freeDrawPoints.forEach((p, idx) => {
        const c = document.createElementNS(ns, "circle");
        c.classList.add("free-point");
        c.setAttribute("cx", p.x);
        c.setAttribute("cy", p.y);
        c.setAttribute("r", 5);
        c.dataset.index = String(idx);
        c.addEventListener("mousedown", (e) => {
         if (!freeDrawMode) return;
         e.preventDefault();
         e.stopPropagation();
         let dragging = true;
         const svgEl = svgMap;
         const moveHandler = (ev) => {
          if (!dragging) return;
          const pt = svgEl.createSVGPoint();
          pt.x = ev.clientX;
          pt.y = ev.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          const i = parseInt(c.dataset.index, 10);
          if (Number.isNaN(i) || !freeDrawPoints[i]) return;
          freeDrawPoints[i].x = svgP.x;
          freeDrawPoints[i].y = svgP.y;
          updateFreeDrawGraphics();
         };
         const upHandler = () => {
          dragging = false;
          document.removeEventListener("mousemove", moveHandler);
          document.removeEventListener("mouseup", upHandler);
         };
         document.addEventListener("mousemove", moveHandler);
         document.addEventListener("mouseup", upHandler);
        });
        c.addEventListener("touchstart",
         (e) => {
          if (!freeDrawMode) return;
          e.preventDefault();
          e.stopPropagation();
          let dragging = true;
          const svgEl = svgMap;
          const touchMoveHandler = (ev) => {
           if (!dragging || !ev.touches[0]) return;
           const pt = svgEl.createSVGPoint();
           pt.x = ev.touches[0].clientX;
           pt.y = ev.touches[0].clientY;
           const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
           const i = parseInt(c.dataset.index, 10);
           if (Number.isNaN(i) || !freeDrawPoints[i]) return;
           freeDrawPoints[i].x = svgP.x;
           freeDrawPoints[i].y = svgP.y;
           updateFreeDrawGraphics();
          };
          const touchUpHandler = () => {
           dragging = false;
           document.removeEventListener("touchmove", touchMoveHandler, );
           document.removeEventListener("touchend", touchUpHandler, );
          };
          document.addEventListener("touchmove", touchMoveHandler);
          document.addEventListener("touchend", touchUpHandler);
         }, {
          passive: false
         }, );
        svg.appendChild(c);
        freeDrawPointEls.push(c);
       });
       drawUndoBtn.style.display = freeDrawPoints.length ? "inline-block" : "none";
      }
      function addFreeDrawPoint(x, y) {
       freeDrawPoints.push({
        x,
        y
       });
       updateFreeDrawGraphics();
      }
      function startFreeDraw() {
       freeDrawMode = true;
       freeDrawPoints = [];
       if (freeDrawPolylineEl) {
        freeDrawPolylineEl.remove();
        freeDrawPolylineEl = null;
       }
       freeDrawPointEls.forEach((el) => el.remove());
       freeDrawPointEls = [];
       svgMap.style.cursor = "crosshair";
       drawToggleBtn.textContent = "Done";
       drawUndoBtn.style.display = "none";
      }
      function finishFreeDraw() {
       freeDrawMode = false;
       svgMap.style.cursor = "";
       drawToggleBtn.textContent = "✏️";
       if (freeDrawPoints.length >= 2) {
        const color = drawColorInput.value || "#475569";
        const lineStyle = drawStyleSelect.value || "solid";
        const arrowDir = drawArrowSelect.value || "none";
        const newId = "custom-" + Date.now();
        const pointsCopy = freeDrawPoints.map((p) => ({
         x: p.x,
         y: p.y,
        }));
        EDGE_DATA.list.push({
         id: newId,
         type: "custom",
         color,
         width: 4,
         lineStyle: lineStyle,
         direction: arrowDir,
         points: pointsCopy,
         notes: [],
        });
        freeDrawPoints = [];
        if (freeDrawPolylineEl) {
         freeDrawPolylineEl.remove();
         freeDrawPolylineEl = null;
        }
        freeDrawPointEls.forEach((el) => el.remove());
        freeDrawPointEls = [];
        forgeTheTopology();
        selectTheConnection(newId);
       } else {
        freeDrawPoints = [];
        if (freeDrawPolylineEl) {
         freeDrawPolylineEl.remove();
         freeDrawPolylineEl = null;
        }
        freeDrawPointEls.forEach((el) => el.remove());
        freeDrawPointEls = [];
        forgeTheLegend();
       }
       drawUndoBtn.style.display = "none";
      }
      drawToggleBtn.addEventListener("click", () => {
       if (currentView.mode === "rack") {
        alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
        return;
       }
       if (freeDrawMode) {
        finishFreeDraw();
       } else {
        startFreeDraw();
       }
      });
      drawUndoBtn.addEventListener("click", () => {
       if (!freeDrawMode || !freeDrawPoints.length) return;
       freeDrawPoints.pop();
       updateFreeDrawGraphics();
      });
      const drawToolbar = document.getElementById("draw-toolbar");
      drawToolbar.addEventListener("mousedown", (e) => {
       e.stopPropagation();
      });
      drawToolbar.addEventListener("click", (e) => {
       if (e.target !== drawToggleBtn && e.target !== drawUndoBtn) {
        e.stopPropagation();
       }
      });
      drawStyleSelect.addEventListener("change", () => {
       if (freeDrawMode) {
        updateFreeDrawGraphics();
       }
      });
      drawArrowSelect.addEventListener("change", () => {
       if (freeDrawMode) {
        updateFreeDrawGraphics();
       }
      });
      drawColorInput.addEventListener("input", () => {
       if (freeDrawMode) {
        updateFreeDrawGraphics();
       }
      });
      drawStyleSelect.addEventListener("mousedown", (e) => {
       e.stopPropagation();
      });
      drawStyleSelect.addEventListener("click", (e) => {
       e.stopPropagation();
      });
      drawArrowSelect.addEventListener("mousedown", (e) => {
       e.stopPropagation();
      });
      drawArrowSelect.addEventListener("click", (e) => {
       e.stopPropagation();
      });
      drawColorInput.addEventListener("mousedown", (e) => {
       e.stopPropagation();
      });
      drawColorInput.addEventListener("click", (e) => {
       e.stopPropagation();
      });
      svgMap.addEventListener("click", (e) => {
       if (!freeDrawMode) return;
       if (e.button !== 0) return;
       const target = e.target;
       if (target && target.classList && target.classList.contains("free-point")) return;
       const svgEl = svgMap;
       const pt = svgEl.createSVGPoint();
       pt.x = e.clientX;
       pt.y = e.clientY;
       const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
       addFreeDrawPoint(svgP.x, svgP.y);
      });
      svgMap.addEventListener("touchend",
       (e) => {
        if (!freeDrawMode) return;
        const target = e.target;
        if (target && target.classList && target.classList.contains("free-point")) return;
        if (e.changedTouches && e.changedTouches[0]) {
         e.preventDefault();
         const svgEl = svgMap;
         const pt = svgEl.createSVGPoint();
         pt.x = e.changedTouches[0].clientX;
         pt.y = e.changedTouches[0].clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
         addFreeDrawPoint(svgP.x, svgP.y);
        }
       }, {
        passive: false
       }, );
       const rectToggleBtn = document.getElementById("rect-toggle");
       const rectStyleSelect = document.getElementById("rect-style");
       function startRectDraw() {
        rectDrawMode = true;
        rectStartPoint = null;
        rectPreviewEl = null;
        svgMap.style.cursor = "crosshair";
        rectToggleBtn.textContent = "Done";
        rectStyle = rectStyleSelect.value || "filled";
        if (freeDrawMode) {
         finishFreeDraw();
        }
        updateRectangleDeleteButtons();
       }
       function finishRectDraw() {
        rectDrawMode = false;
        svgMap.style.cursor = "";
        rectToggleBtn.textContent = "▭";
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
        updateRectangleDeleteButtons();
       }
       rectToggleBtn.addEventListener("click", () => {
        if (currentView.mode === "rack") {
         alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
         return;
        }
        if (rectDrawMode) {
         finishRectDraw();
        } else {
         startRectDraw();
        }
       });
       rectStyleSelect.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       rectStyleSelect.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       rectStyleSelect.addEventListener("change", () => {
        if (rectDrawMode) {
         rectStyle = rectStyleSelect.value || "filled";
        }
       });
       svgMap.addEventListener("mousedown", (e) => {
        if (!rectDrawMode) return;
        if (e.button !== 0) return;
        e.preventDefault();
        e.stopPropagation();
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        rectStartPoint = { x: svgP.x, y: svgP.y };
        const ns = "http://www.w3.org/2000/svg";
        rectPreviewEl = document.createElementNS(ns, "rect");
        rectPreviewEl.classList.add("rect-preview");
        rectPreviewEl.setAttribute("x", svgP.x);
        rectPreviewEl.setAttribute("y", svgP.y);
        rectPreviewEl.setAttribute("width", 0);
        rectPreviewEl.setAttribute("height", 0);
        const color = drawColorInput.value || "#f97316";
        rectPreviewEl.style.stroke = color;
        rectPreviewEl.style.strokeWidth = 2;
        rectPreviewEl.style.strokeDasharray = "5,5";
        if (rectStyle === "filled") {
         rectPreviewEl.style.fill = color;
         rectPreviewEl.style.fillOpacity = "0.3";
        } else {
         rectPreviewEl.style.fill = "none";
        }
        svgEl.appendChild(rectPreviewEl);
       });
       svgMap.addEventListener("mousemove", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        rectPreviewEl.setAttribute("x", x);
        rectPreviewEl.setAttribute("y", y);
        rectPreviewEl.setAttribute("width", width);
        rectPreviewEl.setAttribute("height", height);
       });
       svgMap.addEventListener("mouseup", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        if (width > 10 && height > 10) {
      pushUndo("draw zone");
         const color = drawColorInput.value || "#f97316";
         const newId = "rect-" + Date.now();
          const lineStyle = document.getElementById("draw-style").value || "solid";
         RECT_DATA.list.push({
          id: newId,
          x: x,
          y: y,
          width: width,
          height: height,
          color: color,
          style: rectStyle,
          lineStyle: lineStyle,
          notes: []
         });
         forgeTheTopology();
        }
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
       });
       let rectTouchStart = null;
       svgMap.addEventListener("touchstart", (e) => {
        if (!rectDrawMode) return;
        if (e.touches.length !== 1) return;
        e.preventDefault();
        const touch = e.touches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        rectStartPoint = { x: svgP.x, y: svgP.y };
        rectTouchStart = { x: svgP.x, y: svgP.y };
        const ns = "http://www.w3.org/2000/svg";
        rectPreviewEl = document.createElementNS(ns, "rect");
        rectPreviewEl.classList.add("rect-preview");
        rectPreviewEl.setAttribute("x", svgP.x);
        rectPreviewEl.setAttribute("y", svgP.y);
        rectPreviewEl.setAttribute("width", 0);
        rectPreviewEl.setAttribute("height", 0);
        const color = drawColorInput.value || "#f97316";
        rectPreviewEl.style.stroke = color;
        rectPreviewEl.style.strokeWidth = 2;
        rectPreviewEl.style.strokeDasharray = "5,5";
        if (rectStyle === "filled") {
         rectPreviewEl.style.fill = color;
         rectPreviewEl.style.fillOpacity = "0.3";
        } else {
         rectPreviewEl.style.fill = "none";
        }
        svgEl.appendChild(rectPreviewEl);
       }, { passive: false });
       svgMap.addEventListener("touchmove", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        if (e.touches.length !== 1) return;
        e.preventDefault();
        const touch = e.touches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        rectPreviewEl.setAttribute("x", x);
        rectPreviewEl.setAttribute("y", y);
        rectPreviewEl.setAttribute("width", width);
        rectPreviewEl.setAttribute("height", height);
       }, { passive: false });
       svgMap.addEventListener("touchend", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        if (!rectTouchStart) return;
        e.preventDefault();
        const touch = e.changedTouches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        if (width > 10 && height > 10) {
      pushUndo("draw zone");
         const color = drawColorInput.value || "#f97316";
         const newId = "rect-" + Date.now();
        const lineStyle = document.getElementById("draw-style").value || "solid";
         RECT_DATA.list.push({
          id: newId,
          x: x,
          y: y,
          width: width,
          height: height,
          color: color,
          style: rectStyle,
          lineStyle: lineStyle,
          notes: []
         });
         forgeTheTopology();
        }
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
        rectTouchStart = null;
       }, { passive: false });
      const textToggleBtn = document.getElementById("text-toggle");
      function startTextMode() {
       textDrawMode = true;
       svgMap.style.cursor = "crosshair";
       textToggleBtn.textContent = "Done";
       textToggleBtn.style.background = "var(--accent)";
       textToggleBtn.style.color = "var(--bg)";
       if (freeDrawMode) {
        finishFreeDraw();
       }
       if (rectDrawMode) {
        finishRectDraw();
       }
       updateTextDeleteButtons();
      }
      function finishTextMode() {
       textDrawMode = false;
       svgMap.style.cursor = "";
       textToggleBtn.textContent = "T";
       textToggleBtn.style.background = "";
       textToggleBtn.style.color = "";
       updateTextDeleteButtons();
      }
      textToggleBtn.addEventListener("click", () => {
       if (currentView.mode === "rack") {
        alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
        return;
       }
       if (textDrawMode) {
        finishTextMode();
       } else {
        startTextMode();
       }
      });
      function handleTextPlacement(e) {
       if (!textDrawMode) return;
       const svgEl = svgMap;
       const pt = svgEl.createSVGPoint();
       pt.x = e.clientX;
       pt.y = e.clientY;
       const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
       const newId = "text-" + Date.now();
      pushUndo("add text");
       TEXT_DATA.list.push({
        id: newId,
        x: svgP.x,
        y: svgP.y,
        content: "New Text",
        fontSize: 18,
        color: "#e2e8f0",
        fontWeight: "normal",
        fontStyle: "normal",
        textAlign: "start",
        textDecoration: "none",
        bgColor: "#000000",
        bgEnabled: false,
        opacity: 1
       });
       forgeTheTopology();
       showTextPanel(newId);
      }
      svgMap.addEventListener("click", (e) => {
       if (!textDrawMode) return;
       if (e.target.closest('.text-delete-btn')) return;
       if (e.target.closest('.text-group')) return;
       e.preventDefault();
       e.stopPropagation();
       handleTextPlacement(e);
      });
      svgMap.addEventListener("touchend", (e) => {
       if (!textDrawMode) return;
       if (e.target.closest('.text-delete-btn')) return;
       if (e.target.closest('.text-group')) return;
       if (e.touches.length > 0) return;
       e.preventDefault();
       const touch = e.changedTouches[0];
       const fakeEvent = {
        clientX: touch.clientX,
        clientY: touch.clientY,
        preventDefault: () => {},
        stopPropagation: () => {}
       };
       handleTextPlacement(fakeEvent);
      }, { passive: false });
      function showTextPanel(textId) {
	  if (isViewOnly()) return;
       currentTextId = textId;
       currentNodeId = null;
       currentEdgeId = null;
       currentRectId = null;
       const textItem = TEXT_DATA.list.find(t => t.id === textId);
       if (!textItem) return;
       document.getElementById("node-panel").style.display = "none";
       document.getElementById("edge-panel").style.display = "none";
       document.getElementById("rect-panel").style.display = "none";
       const textPanel = document.getElementById("text-panel");
       textPanel.style.display = "block";
       document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active"));
       document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
       document.querySelectorAll(".rect-group").forEach(r => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach(t => t.classList.toggle("active", t.dataset.textId === textId));
       document.getElementById("text-content").value = textItem.content;
       document.getElementById("text-font-size").value = textItem.fontSize;
       document.getElementById("text-color").value = textItem.color;
       document.getElementById("text-font-weight").value = textItem.fontWeight;
       document.getElementById("text-font-style").value = textItem.fontStyle;
       document.getElementById("text-align").value = textItem.textAlign;
       document.getElementById("text-decoration").value = textItem.textDecoration;
       document.getElementById("text-bg-color").value = textItem.bgColor;
       document.getElementById("text-bg-enabled").checked = textItem.bgEnabled;
       document.getElementById("text-opacity").value = textItem.opacity;
       document.getElementById("text-opacity-val").textContent = Math.round(textItem.opacity * 100) + "%";
      }
      function updateTextDeleteButtons() {
       const deleteButtons = document.querySelectorAll('.text-delete-btn');
       deleteButtons.forEach(btn => {
        btn.style.display = textDrawMode ? 'block' : 'none';
       });
      }
      function deleteText(textId) {
      pushUndo("delete text");
       TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== textId);
       forgeTheTopology();
       if (currentTextId === textId) {
        document.getElementById("text-panel").style.display = "none";
        currentTextId = null;
       }
      }
      document.getElementById("text-content").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
      pushUndo("edit text");
        textItem.content = e.target.value;
        forgeTheTopology();
       }
      });
      document.getElementById("text-font-size").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.fontSize = parseInt(e.target.value);
        forgeTheTopology();
       }
      });
      document.getElementById("text-color").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.color = e.target.value;
        forgeTheTopology();
       }
      });
      document.getElementById("text-font-weight").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.fontWeight = e.target.value;
        forgeTheTopology();
       }
      });
      document.getElementById("text-font-style").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.fontStyle = e.target.value;
        forgeTheTopology();
       }
      });
      document.getElementById("text-align").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.textAlign = e.target.value;
        forgeTheTopology();
       }
      });
      document.getElementById("text-decoration").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.textDecoration = e.target.value;
        forgeTheTopology();
       }
      });
      document.getElementById("text-bg-color").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.bgColor = e.target.value;
        forgeTheTopology();
       }
      });
      document.getElementById("text-bg-enabled").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.bgEnabled = e.target.checked;
        forgeTheTopology();
       }
      });
      document.getElementById("text-opacity").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.opacity = parseFloat(e.target.value);
        document.getElementById("text-opacity-val").textContent = Math.round(textItem.opacity * 100) + "%";
        forgeTheTopology();
       }
      });
      document.getElementById("delete-text").addEventListener("click", () => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        challengeTheImmortal(`Delete text "${textItem.content.substring(0, 30)}..."?`, () => {
         deleteText(currentTextId);
        });
       }
      });
      const settingsBtn = document.getElementById("settings-btn");
      const settingsModal = document.getElementById("settings-modal");
      const settingsClose = document.getElementById("settings-close");
      settingsBtn.addEventListener("click", () => {
       document.getElementById("page-bg-color").value = PAGE_STATE.background || "#050608";
       document.getElementById("topbar-bg-color").value = PAGE_STATE.topbarBg || "#0b0e13";
       document.getElementById("topbar-border-color").value = PAGE_STATE.topbarBorder || "#1f2533";
       document.getElementById("panel-color").value = PAGE_STATE.panel || "#0b0e13";
       document.getElementById("panel-alt-color").value = PAGE_STATE.panelAlt || "#10141b";
       document.getElementById("sidebar-bg-color").value = PAGE_STATE.sidebarBg || "#10141b";
       document.getElementById("btn-bg-color").value = PAGE_STATE.btnBg || "#0b0e13";
       document.getElementById("btn-text-color").value = PAGE_STATE.btnText || "#e2e8f0";
       document.getElementById("tag-fill-color").value = PAGE_STATE.tagFill || "#1e293b";
       document.getElementById("tag-text-color").value = PAGE_STATE.tagText || "#e2e8f0";
       document.getElementById("tag-border-color").value = PAGE_STATE.tagBorder || "#475569";
       document.getElementById("input-bg-color").value = PAGE_STATE.inputBg || "#0b0e13";
       document.getElementById("input-text-color").value = PAGE_STATE.inputText || "#e2e8f0";
       document.getElementById("input-border-color").value = PAGE_STATE.inputBorder || "#1f2937";
       document.getElementById("input-font-family").value = PAGE_STATE.inputFont || "Inter, system-ui, sans-serif";
       document.getElementById("input-font-size").value = PAGE_STATE.inputFontSize || 14;
       document.getElementById("toolbar-bg-color").value = PAGE_STATE.toolbarBg || "#0f172a";
       document.getElementById("toolbar-border-color").value = PAGE_STATE.toolbarBorder || "#1f2937";
       document.getElementById("toolbar-text-color").value = PAGE_STATE.toolbarText || "#94a3b8";
       document.getElementById("toolbar-btn-bg-color").value = PAGE_STATE.toolbarBtnBg || "#0b0e13";
       document.getElementById("toolbar-btn-text-color").value = PAGE_STATE.toolbarBtnText || "#e2e8f0";
       document.getElementById("minimap-dots-color").value = PAGE_STATE.minimapDots || "#94a3b8";
       document.getElementById("canvas-hint-enabled").checked = PAGE_STATE.canvasHintEnabled !== false;
       document.getElementById("canvas-hint-bg-color").value = PAGE_STATE.canvasHintBg || "#0f172a";
       document.getElementById("canvas-hint-text-color").value = PAGE_STATE.canvasHintColor || "#94a3b8";
       document.getElementById("canvas-hint-text").value = PAGE_STATE.canvasHintText || "";
       document.getElementById("accent-color").value = PAGE_STATE.accent || "#4fd1c5";
       document.getElementById("danger-color").value = PAGE_STATE.danger || "#f56565";
       document.getElementById("text-main-color").value = PAGE_STATE.textMain || "#e2e8f0";
       document.getElementById("text-soft-color").value = PAGE_STATE.textSoft || "#94a3b8";
       document.getElementById("node-fill-color").value = PAGE_STATE.nodeFill || "#1e293b";
       document.getElementById("node-stroke-color").value = PAGE_STATE.nodeStroke || "#475569";
       document.getElementById("node-title-color").value = PAGE_STATE.nodeTitle || "#e2e8f0";
       document.getElementById("node-sub-color").value = PAGE_STATE.nodeSub || "#94a3b8";
       document.getElementById("node-title-size").value = PAGE_STATE.nodeTitleSize || 18;
       document.getElementById("node-sub-size").value = PAGE_STATE.nodeSubSize || 13;
       document.getElementById("node-font-family").value = PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
       document.getElementById("default-edge-color").value = PAGE_STATE.defaultEdge || "#475569";
       document.getElementById("selection-handle-color").value = PAGE_STATE.selectionHandle || "#f59e0b";
       document.getElementById("selection-handle-size").value = PAGE_STATE.selectionHandleSize || 8;
       document.getElementById("group-indicator-color").value = PAGE_STATE.groupIndicator || "#4fd1c5";
       document.getElementById("canvas-gradient-top").value = PAGE_STATE.canvasGradientTop || "#1e2532";
       document.getElementById("canvas-gradient-bottom").value = PAGE_STATE.canvasGradientBottom || "#050608";
       document.getElementById("canvas-border-color").value = PAGE_STATE.canvasBorder || "#475569";
       document.getElementById("canvas-grid-color").value = PAGE_STATE.canvasGrid || "#475569";
       document.getElementById("canvas-grid-size").value = PAGE_STATE.canvasGridSize || 50;
       document.getElementById("rack-frame-fill").value = PAGE_STATE.rackFrameFill || "#0f172a";
       document.getElementById("rack-frame-stroke").value = PAGE_STATE.rackFrameStroke || "#4fd1c5";
       document.getElementById("rack-line-color").value = PAGE_STATE.rackLineColor || "#475569";
       document.getElementById("rack-text-color").value = PAGE_STATE.rackTextColor || "#4fd1c5";
	   document.getElementById("view-only-mode").checked = PAGE_STATE.viewOnly === true;
       settingsModal.classList.add("active");
      });
      settingsClose.addEventListener("click", () => {
       settingsModal.classList.remove("active");
      });
	  document.getElementById("view-only-mode").addEventListener("change", (e) => {
       PAGE_STATE.viewOnly = e.target.checked;
       if (e.target.checked) {
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        document.getElementById("rect-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.setProperty('display', 'none', 'important');
        document.getElementById("draw-toolbar").style.setProperty('display', 'none', 'important');
        currentNodeId = null;
        currentEdgeId = null;
        currentRectId = null;
        currentTextId = null;
        selectedNodes.clear();
        selectedRects.clear();
        selectedTexts.clear();
        selectedEdges.clear();
        const bulkToolbar = document.getElementById("bulk-toolbar");
        const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active", "selected"));
        document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
        document.querySelectorAll(".rect-group").forEach(r => r.classList.remove("active"));
        document.querySelectorAll(".text-element").forEach(t => t.classList.remove("active"));
       }
       wieldThePower();
       if (!e.target.checked) {
        updateDrawToolbarVisibility();
        updateTopologyToolbarVisibility();
       }
       forgeTheTopology();
      });
      settingsModal.addEventListener("click", (e) => {
       if (e.target === settingsModal) {
        settingsModal.classList.remove("active");
       }
      });
      document.getElementById("page-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.background = e.target.value;
       wieldThePower();
      });
      document.getElementById("topbar-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.topbarBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("topbar-border-color").addEventListener("input", (e) => {
       PAGE_STATE.topbarBorder = e.target.value;
       wieldThePower();
      });
      document.getElementById("panel-color").addEventListener("input", (e) => {
       PAGE_STATE.panel = e.target.value;
       wieldThePower();
      });
      document.getElementById("panel-alt-color").addEventListener("input", (e) => {
       PAGE_STATE.panelAlt = e.target.value;
       wieldThePower();
      });
      document.getElementById("sidebar-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.sidebarBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("btn-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.btnBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("btn-text-color").addEventListener("input", (e) => {
       PAGE_STATE.btnText = e.target.value;
       wieldThePower();
      });
      document.getElementById("tag-fill-color").addEventListener("input", (e) => {
       PAGE_STATE.tagFill = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("tag-text-color").addEventListener("input", (e) => {
       PAGE_STATE.tagText = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("tag-border-color").addEventListener("input", (e) => {
       PAGE_STATE.tagBorder = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
	  document.getElementById("selection-fill-color").addEventListener("input", function() {
       selectionBoxStyle.fillColor = this.value;
      });
      document.getElementById("selection-fill-opacity").addEventListener("input", function() {
       selectionBoxStyle.fillOpacity = parseFloat(this.value);
       document.getElementById("selection-fill-opacity-val").textContent = Math.round(this.value * 100) + "%";
      });
      document.getElementById("selection-stroke-color").addEventListener("input", function() {
       selectionBoxStyle.strokeColor = this.value;
      });
      document.getElementById("selection-stroke-width").addEventListener("input", function() {
       selectionBoxStyle.strokeWidth = parseInt(this.value) || 2;
      });
      document.getElementById("selection-stroke-style").addEventListener("change", function() {
       selectionBoxStyle.strokeDasharray = this.value;
      });
      document.getElementById("input-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.inputBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-text-color").addEventListener("input", (e) => {
       PAGE_STATE.inputText = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-border-color").addEventListener("input", (e) => {
       PAGE_STATE.inputBorder = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-font-family").addEventListener("change", (e) => {
       PAGE_STATE.inputFont = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-font-size").addEventListener("input", (e) => {
       PAGE_STATE.inputFontSize = parseInt(e.target.value) || 14;
       wieldThePower();
      });
      document.getElementById("toolbar-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-border-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBorder = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-text-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarText = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-btn-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBtnBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-btn-text-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBtnText = e.target.value;
       wieldThePower();
      });
      document.getElementById("minimap-dots-color").addEventListener("input", (e) => {
       PAGE_STATE.minimapDots = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("canvas-hint-enabled").addEventListener("change", (e) => {
       PAGE_STATE.canvasHintEnabled = e.target.checked;
       wieldThePower();
      });
      document.getElementById("canvas-hint-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-hint-text-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintColor = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-hint-text").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintText = e.target.value;
       wieldThePower();
      });
      document.getElementById("accent-color").addEventListener("input", (e) => {
       PAGE_STATE.accent = e.target.value;
       wieldThePower();
      });
      document.getElementById("danger-color").addEventListener("input", (e) => {
       PAGE_STATE.danger = e.target.value;
       wieldThePower();
      });
      document.getElementById("text-main-color").addEventListener("input", (e) => {
       PAGE_STATE.textMain = e.target.value;
       wieldThePower();
      });
      document.getElementById("text-soft-color").addEventListener("input", (e) => {
       PAGE_STATE.textSoft = e.target.value;
       wieldThePower();
      });
      document.getElementById("node-fill-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeFill = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-stroke-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeStroke = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-title-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeTitle = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-sub-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeSub = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-title-size").addEventListener("input", (e) => {
       PAGE_STATE.nodeTitleSize = parseInt(e.target.value) || 18;
       forgeTheTopology();
      });
      document.getElementById("node-sub-size").addEventListener("input", (e) => {
       PAGE_STATE.nodeSubSize = parseInt(e.target.value) || 13;
       forgeTheTopology();
      });
      document.getElementById("node-font-family").addEventListener("change", (e) => {
       PAGE_STATE.nodeFont = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("default-edge-color").addEventListener("input", (e) => {
       PAGE_STATE.defaultEdge = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("selection-handle-color").addEventListener("input", (e) => {
       PAGE_STATE.selectionHandle = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("selection-handle-size").addEventListener("input", (e) => {
       PAGE_STATE.selectionHandleSize = parseInt(e.target.value) || 8;
       forgeTheTopology();
      });
      document.getElementById("group-indicator-color").addEventListener("input", (e) => {
       PAGE_STATE.groupIndicator = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-gradient-top").addEventListener("input", (e) => {
       PAGE_STATE.canvasGradientTop = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-gradient-bottom").addEventListener("input", (e) => {
       PAGE_STATE.canvasGradientBottom = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-border-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasBorder = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-grid-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasGrid = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-grid-size").addEventListener("input", (e) => {
       PAGE_STATE.canvasGridSize = parseInt(e.target.value) || 50;
       forgeTheTopology();
      });
      document.getElementById("rack-frame-fill").addEventListener("input", (e) => {
       PAGE_STATE.rackFrameFill = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-frame-stroke").addEventListener("input", (e) => {
       PAGE_STATE.rackFrameStroke = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-line-color").addEventListener("input", (e) => {
       PAGE_STATE.rackLineColor = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-text-color").addEventListener("input", (e) => {
       PAGE_STATE.rackTextColor = e.target.value;
       forgeTheTopology();
      });
      (function initializeResizers() {
        const headerResizer = document.getElementById('header-resizer');
        const sidebarResizer = document.getElementById('sidebar-resizer');
        const mobileFooterResizer = document.getElementById('mobile-footer-resizer');
        let isResizing = false;
        let currentResizer = null;
        let startY = 0;
        let startX = 0;
        let startHeight = 0;
        let startWidth = 0;
        function getClientPos(e) {
          if (e.touches && e.touches.length > 0) {
            return { x: e.touches[0].clientX, y: e.touches[0].clientY };
          }
          return { x: e.clientX, y: e.clientY };
        }
        function startResize(resizer, type, e) {
          isResizing = true;
          currentResizer = type;
          const pos = getClientPos(e);
          if (type === 'header') {
            startY = pos.y;
            startHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--topbar-height'));
          } else if (type === 'sidebar') {
            startX = pos.x;
            startWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width'));
          } else if (type === 'mobile-footer') {
            startY = pos.y;
            const currentVh = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--mobile-footer-height'));
            startHeight = (currentVh / 100) * window.innerHeight;
          }
          resizer.classList.add('resizing');
          document.body.classList.add('resizing');
          document.body.style.cursor = (type === 'sidebar') ? 'col-resize' : 'row-resize';
          e.preventDefault();
        }
        if (headerResizer) {
          headerResizer.addEventListener('mousedown', (e) => startResize(headerResizer, 'header', e));
          headerResizer.addEventListener('touchstart', (e) => startResize(headerResizer, 'header', e), { passive: false });
        }
        if (sidebarResizer) {
          sidebarResizer.addEventListener('mousedown', (e) => startResize(sidebarResizer, 'sidebar', e));
          sidebarResizer.addEventListener('touchstart', (e) => startResize(sidebarResizer, 'sidebar', e), { passive: false });
        }
        if (mobileFooterResizer) {
          mobileFooterResizer.addEventListener('mousedown', (e) => startResize(mobileFooterResizer, 'mobile-footer', e));
          mobileFooterResizer.addEventListener('touchstart', (e) => startResize(mobileFooterResizer, 'mobile-footer', e), { passive: false });
        }
        function handleMove(e) {
          if (!isResizing) return;
          const pos = getClientPos(e);
          if (currentResizer === 'header') {
            const deltaY = pos.y - startY;
            const newHeight = Math.max(40, Math.min(150, startHeight + deltaY));
            document.documentElement.style.setProperty('--topbar-height', newHeight + 'px');
          } else if (currentResizer === 'sidebar') {
            const deltaX = startX - pos.x;
            const newWidth = Math.max(200, Math.min(800, startWidth + deltaX));
            document.documentElement.style.setProperty('--sidebar-width', newWidth + 'px');
          } else if (currentResizer === 'mobile-footer') {
            const deltaY = startY - pos.y;
            const newHeight = startHeight + deltaY;
            const newVh = Math.max(15, Math.min(80, (newHeight / window.innerHeight) * 100));
            document.documentElement.style.setProperty('--mobile-footer-height', newVh + 'vh');
          }
          e.preventDefault();
        }
        document.addEventListener('mousemove', handleMove);
        document.addEventListener('touchmove', handleMove, { passive: false });
        function handleEnd() {
          if (isResizing) {
            isResizing = false;
            if (currentResizer === 'header') {
              PAGE_STATE.topbarHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--topbar-height'));
              headerResizer.classList.remove('resizing');
            } else if (currentResizer === 'sidebar') {
              PAGE_STATE.sidebarWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width'));
              sidebarResizer.classList.remove('resizing');
            } else if (currentResizer === 'mobile-footer') {
              PAGE_STATE.mobileFooterHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--mobile-footer-height'));
              mobileFooterResizer.classList.remove('resizing');
            }
            document.body.classList.remove('resizing');
            document.body.style.cursor = '';
            currentResizer = null;
          }
        }
        document.addEventListener('mouseup', handleEnd);
        document.addEventListener('touchend', handleEnd);
        document.addEventListener('touchcancel', handleEnd);
      })();
      document.getElementById("export-data-btn").addEventListener("click", () => {
       const data = captureTheQuickening();
       const jsonStr = JSON.stringify(data, null, 2);
       const blob = new Blob([jsonStr], {
        type: "application/json"
       });
       const url = URL.createObjectURL(blob);
       const a = document.createElement("a");
       a.href = url;
       const safeTitle = (PAGE_STATE.title || "network-topology").toLowerCase().replace(/[^a-z0-9\-]+/g, "-");
       const timestamp = new Date().toISOString().split("T")[0];
       a.download = `${safeTitle}-data-${timestamp}.json`;
       document.body.appendChild(a);
       a.click();
       document.body.removeChild(a);
       URL.revokeObjectURL(url);
       logAuditEvent("export", `Exported JSON: ${a.download}`);
      });
      document.getElementById("import-data-btn").addEventListener("click", () => {
       document.getElementById("import-data-file").click();
      });
      document.getElementById("import-data-file").addEventListener("change", async (e) => {
       const file = e.target.files[0];
       if (!file) return;
       try {
        const text = await file.text();
        const data = JSON.parse(text);
        if (!data.nodeData || !data.edgeData) {
         alert("Invalid data file. Missing required fields.");
         return;
        }
        const confirmMsg = `This will replace all current data with the imported data.\n\nImporting:\n- ${Object.keys(data.nodeData).length} nodes\n- ${data.edgeData.list?.length || 0} connections\n- ${data.documentTabs?.length || 1} tab(s)\n\nContinue?`;
        if (!confirm(confirmMsg)) {
         e.target.value = "";
         return;
        }
        NODE_DATA = data.nodeData || {};
        EDGE_DATA = data.edgeData || {
         list: []
        };
        EDGE_LEGEND = data.edgeLegend || {};
        RECT_DATA = data.rectData || { list: [] };
        TEXT_DATA = data.textData || { list: [] };
        savedPositions = data.nodePositions || {};
        savedSizes = data.nodeSizes || {};
        savedStyles = data.nodeStyles || {};
        if (data.page) {
         PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, data.page, );
         wieldThePower();
        }
        if (data.canvas) {
         canvasState.zoom = data.canvas.zoom || 1;
         canvasState.panX = data.canvas.panX || 0;
         canvasState.panY = data.canvas.panY || 0;
        }
        if (data.page?.title) {
         document.title = data.page.title;
         document.querySelector(".editable-page-title", ).textContent = data.page.title;
        }
        if (data.documentTabs) {
         documentTabs = data.documentTabs;
         currentTabIndex = data.currentTabIndex || 0;
        }
        if (data.savedTopologyView) {
         savedTopologyView = data.savedTopologyView;
        }
        if (data.encryptedSections) {
         encryptedSections = data.encryptedSections;
        }
        if (data.auditLog && Array.isArray(data.auditLog)) {
         auditLog = data.auditLog;
         try {
           localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
         } catch (e) {
           console.warn("Failed to sync audit log to localStorage:", e);
         }
        }
        forgeTheTopology();
        forgeTheLegend();
		logAuditEvent("import", `Imported JSON: ${file.name} (${Object.keys(data.nodeData).length} nodes, ${data.edgeData.list?.length || 0} connections)`);
        updateViewBox();
        const nodeIds = Object.keys(NODE_DATA);
        if (nodeIds.length > 0) {
         claimTheImmortal(nodeIds[0]);
        } else {
         document.getElementById("node-panel").style.display = "none";
         document.getElementById("edge-panel").style.display = "none";
         document.getElementById("topology-toolbar").style.display = "none";
        }
        e.target.value = "";
       } catch (err) {
        console.error("Import error:", err);
        alert(`Failed to import data: ${err.message}`);
        e.target.value = "";
       }
      });
      const saveHelpBtn = document.getElementById("save-help-btn");
      const saveInfoModal = document.getElementById("save-info-modal");
      const saveInfoClose = document.getElementById("save-info-close");
      saveHelpBtn.addEventListener("click", () => {
       saveInfoModal.classList.add("active");
      });
      saveInfoClose.addEventListener("click", () => {
       saveInfoModal.classList.remove("active");
      });
      saveInfoModal.addEventListener("click", (e) => {
       if (e.target === saveInfoModal) {
        saveInfoModal.classList.remove("active");
       }
      });
      document.querySelectorAll(".help-tab").forEach(tab => {
        tab.addEventListener("click", () => {
          document.querySelectorAll(".help-tab").forEach(t => { t.style.background = "var(--panel)"; t.style.color = "var(--text-main)"; });
          tab.style.background = "var(--accent)"; tab.style.color = "var(--bg)";
          document.querySelectorAll(".help-tab-content").forEach(c => c.style.display = "none");
          document.getElementById("help-tab-" + tab.dataset.tab).style.display = "block";
        });
      });
      async function deriveKey(password, salt) {
      const encoder = new TextEncoder();
      const keyMaterial = await crypto.subtle.importKey(
      "raw",
      encoder.encode(password),
      "PBKDF2",
      false,
      ["deriveKey"]
      );
      return crypto.subtle.deriveKey(
      {
      name: "PBKDF2",
      salt: salt,
      iterations: 200000,
      hash: "SHA-256"
      },
      keyMaterial,
      {
      name: "AES-GCM",
      length: 256
      },
      false,
      ["encrypt", "decrypt"]
      );
      }
      async function encryptData(data, password) {
      const encoder = new TextEncoder();
      const salt = crypto.getRandomValues(new Uint8Array(16));
      const iv   = crypto.getRandomValues(new Uint8Array(12));
      const key = await deriveKey(password, salt);
      const encrypted = await crypto.subtle.encrypt(
      { name: "AES-GCM", iv },
      key,
      encoder.encode(data)
      );
      const encryptedU8 = new Uint8Array(encrypted);
      const result = new Uint8Array(salt.length + iv.length + encryptedU8.length);
      result.set(salt, 0);
      result.set(iv, salt.length);
      result.set(encryptedU8, salt.length + iv.length);
      return "ENCRYPTED:" + u8ToBase64(result);
      }
      async function decryptData(encryptedData, password) {
      const base64Data = encryptedData.replace("ENCRYPTED:", "");
      const fullData   = base64ToU8(base64Data);
      const salt      = fullData.slice(0, 16);
      const iv        = fullData.slice(16, 28);
      const encrypted = fullData.slice(28);
      const key = await deriveKey(password, salt);
      const decrypted = await crypto.subtle.decrypt(
      { name: "AES-GCM", iv },
      key,
      encrypted
      );
      const decoder = new TextDecoder();
      return decoder.decode(decrypted);
      }
      function isEncrypted(data) {
       return typeof data === "string" && data.startsWith("ENCRYPTED:");
      }
      function captureTheQuickening() {
       const currentTab = documentTabs[currentTabIndex];
       currentTab.nodes = JSON.parse(JSON.stringify(NODE_DATA));
       currentTab.edges = JSON.parse(JSON.stringify(EDGE_DATA));
       currentTab.positions = JSON.parse(JSON.stringify(savedPositions));
       currentTab.sizes = JSON.parse(JSON.stringify(savedSizes));
       currentTab.styles = JSON.parse(JSON.stringify(savedStyles));
       currentTab.legend = JSON.parse(JSON.stringify(EDGE_LEGEND));
       currentTab.rects = JSON.parse(JSON.stringify(RECT_DATA));
       currentTab.texts = JSON.parse(JSON.stringify(TEXT_DATA));
       currentTab.pageState = JSON.parse(JSON.stringify(PAGE_STATE));
       return {
        nodeData: NODE_DATA,
        edgeData: EDGE_DATA,
        rectData: RECT_DATA,
        textData: TEXT_DATA,
        edgeLegend: EDGE_LEGEND,
        nodePositions: savedPositions,
        nodeSizes: savedSizes,
        nodeStyles: savedStyles,
        page: PAGE_STATE,
        canvas: {
         zoom: canvasState.zoom,
         panX: canvasState.panX,
         panY: canvasState.panY,
        },
        savedTopologyView: savedTopologyView,
        documentTabs: documentTabs,
        currentTabIndex: currentTabIndex,
        encryptedSections: encryptedSections,
        auditLog: auditLog,
       };
      }
      function assembleTheImmortalForm() {
      const canvasHintEl = document.getElementById("canvas-hint");
       const savedHintHTML = canvasHintEl ? canvasHintEl.innerHTML : "";
       if (canvasHintEl) canvasHintEl.innerHTML = DEFAULT_CANVAS_HINT;
       const clone = document.documentElement.cloneNode(true);
       ["edge-legend-mini", "minimap-mini", "draw-toolbar-mini", "topology-toolbar-mini"].forEach(id => {
        const all = clone.querySelectorAll("#" + id);
        for (let i = 1; i < all.length; i++) {
         all[i].remove();
        }
       });
       const nodeScript = clone.querySelector("#nodes-json");
       if (nodeScript) {
        nodeScript.textContent = JSON.stringify(NODE_DATA, null, 2);
       }
       let stateScript = clone.querySelector("#topology-state");
       if (!stateScript) {
        stateScript = document.createElement("script");
        stateScript.id = "topology-state";
        stateScript.type = "application/json";
        const body = clone.querySelector("body") || clone;
        body.appendChild(stateScript);
       }
       stateScript.textContent = JSON.stringify(captureTheQuickening(), null, 2, );
       return "<!DOCTYPE html> \n " + clone.outerHTML;
      }
      async function becomeImmortal() {
       saveRollbackVersion("Auto-save");
       const encryptEnabled = document.getElementById("encrypt-toggle").checked;
       let stateData = JSON.stringify(captureTheQuickening(), null, 2);
       if (encryptEnabled) {
        const password = prompt("Enter a password to encrypt your data:\n(Remember this password! You will need it to open this file and its non recoverable!)", );
        if (!password) {
         alert("Encryption cancelled. File not saved.");
         return;
        }
        const confirmPassword = prompt("Confirm your password:");
        if (password !== confirmPassword) {
         alert("Passwords do not match. File not saved.");
         return;
        }
        try {
         stateData = await encryptData(stateData, password);
        } catch (e) {
         alert("Encryption failed: " + e.message);
         return;
        }
       }
       const canvasHintEl = document.getElementById("canvas-hint");
       const savedHintHTML = canvasHintEl ? canvasHintEl.innerHTML : "";
       if (canvasHintEl) canvasHintEl.innerHTML = DEFAULT_CANVAS_HINT;
       const clone = document.documentElement.cloneNode(true);
       ["edge-legend-mini", "minimap-mini", "draw-toolbar-mini", "topology-toolbar-mini"].forEach(id => {
        const all = clone.querySelectorAll("#" + id);
        for (let i = 1; i < all.length; i++) {
         all[i].remove();
        }
       });
       const nodeScript = clone.querySelector("#nodes-json");
       if (nodeScript) {
        if (encryptEnabled) {
         nodeScript.textContent = JSON.stringify({}, null, 2);
        } else {
         nodeScript.textContent = JSON.stringify(NODE_DATA, null, 2);
        }
       }
       let stateScript = clone.querySelector("#topology-state");
       if (!stateScript) {
        stateScript = document.createElement("script");
        stateScript.id = "topology-state";
        stateScript.type = "application/json";
        const body = clone.querySelector("body") || clone;
        body.appendChild(stateScript);
       }
       stateScript.textContent = stateData;
       const html = "<!DOCTYPE html> \n " + clone.outerHTML;
       const blob = new Blob([html], {
        type: "text/html"
       });
       const url = URL.createObjectURL(blob);
       const a = document.createElement("a");
       a.href = url;
       const safeTitle = (PAGE_STATE.title || document.title || "network-topology").toLowerCase().replace(/[^a-z0-9\-]+/g, "-");
       a.download = safeTitle + ".html";
       document.body.appendChild(a);
       a.click();
       document.body.removeChild(a);
       URL.revokeObjectURL(url);
       if (canvasHintEl) canvasHintEl.innerHTML = savedHintHTML;
       logAuditEvent("save", `File saved: ${safeTitle}.html`);
      }
      function captureState() {
      return {
       nodes: JSON.parse(JSON.stringify(NODE_DATA)),
       edges: JSON.parse(JSON.stringify(EDGE_DATA)),
       positions: JSON.parse(JSON.stringify(savedPositions)),
       sizes: JSON.parse(JSON.stringify(savedSizes)),
       styles: JSON.parse(JSON.stringify(savedStyles)),
       legend: JSON.parse(JSON.stringify(EDGE_LEGEND)),
       rects: JSON.parse(JSON.stringify(RECT_DATA)),
       texts: JSON.parse(JSON.stringify(TEXT_DATA))
       };
      }
      function pushUndo(action = "") {
       const state = captureState();
       undoStack.push(state);
       if (undoStack.length > MAX_UNDO_STACK) {
        undoStack.shift();
       }
       redoStack = [];
       updateUndoButtons();
       if (action) {
        const actionTypeMap = {
  "create node": "node",
  "delete node": "node",
  "add node": "node",
  "edit": "node",
  "clone node": "node",
  "paste node": "node",
  "move nodes": "node",
  "nudge": "node",
  "align nodes": "node",
  "distribute nodes": "node",
  "snap to grid": "node",
  "toggle group": "node",
  "toggle lock": "node",
  "create rack": "rack",
  "add rack": "rack",
  "edit rack": "rack",
  "edit mac": "rack",
  "edit U height": "rack",
  "change rack capacity": "rack",
  "change assigned rack": "rack",
  "add connection": "connection",
  "delete connection": "connection",
  "delete edge": "connection",
  "clone edge": "connection",
  "paste edge": "connection",
  "style change": "style",
  "change layer": "layer",
  "add text": "text",
  "edit text": "text",
  "delete text": "text",
  "clone text": "text",
  "paste text": "text",
  "draw zone": "zone",
  "delete zone": "zone",
  "delete rect": "zone",
  "clone rect": "zone",
  "paste rect": "zone",
  "change zone line style": "zone",
  "delete selected": "bulk",
  "clone selected": "bulk",
};
        const type = actionTypeMap[action] || "node";
        logAuditEvent(type, action);
       }
      }
      function undo() {
       if (undoStack.length === 0) return;
       const currentState = captureState();
       redoStack.push(currentState);
       const previousState = undoStack.pop();
       restoreState(previousState);
       updateUndoButtons();
       logAuditEvent("undo", "Undo action performed");
      }
      function redo() {
       if (redoStack.length === 0) return;
       logAuditEvent("redo", "Redo action performed");
       const currentState = captureState();
       undoStack.push(currentState);
       const nextState = redoStack.pop();
       restoreState(nextState);
       updateUndoButtons();
      }
      function restoreState(state) {
      NODE_DATA = state.nodes;
      EDGE_DATA = state.edges;
      savedPositions = state.positions;
      savedSizes = state.sizes;
      savedStyles = state.styles;
      EDGE_LEGEND = state.legend;
      RECT_DATA = state.rects || { list: [] };
      TEXT_DATA = state.texts || { list: [] };
      forgeTheTopology();
      if (currentNodeId && NODE_DATA[currentNodeId]) {
       claimTheImmortal(currentNodeId);
      } else if (currentEdgeId) {
       selectTheConnection(currentEdgeId);
       }
      }
      function updateUndoButtons() {
       const undoBtn = document.getElementById("undo-btn");
       const redoBtn = document.getElementById("redo-btn");
       if (undoBtn) {
        undoBtn.disabled = undoStack.length === 0;
        undoBtn.style.opacity = undoStack.length === 0 ? "0.5" : "1";
       }
       if (redoBtn) {
        redoBtn.disabled = redoStack.length === 0;
        redoBtn.style.opacity = redoStack.length === 0 ? "0.5" : "1";
       }
      }
      function editNodeMac(id) {
       const currentMac = NODE_DATA[id].mac || "";
       showEditModal("Edit MAC Address", currentMac, (newMac) => {
        pushUndo("edit mac");
        NODE_DATA[id].mac = newMac;
        if (currentNodeId === id) {
         document.getElementById("node-mac").textContent = newMac || "--";
        }
       });
      }
      function editNodeRack(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       document.getElementById("modal-title").textContent = "Edit Rack Unit";
       document.getElementById("modal-input").value = node.rackUnit || "";
       document.getElementById("edit-modal").style.display = "flex";
       document.getElementById("modal-input").focus();
       const saveHandler = () => {
        pushUndo("edit rack");
        const value = document.getElementById("modal-input").value.trim();
        node.rackUnit = value;
        document.getElementById("edit-modal").style.display = "none";
        claimTheImmortal(id);
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       const cancelHandler = () => {
        document.getElementById("edit-modal").style.display = "none";
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       document.getElementById("edit-modal").addEventListener("click", function bgHandler(e) {
        if (e.target === document.getElementById("edit-modal")) {
         cancelHandler();
         document.getElementById("edit-modal").removeEventListener("click", bgHandler);
        }
       });
      }
      function editNodeUHeight(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       document.getElementById("modal-title").textContent = "Edit U Height";
       document.getElementById("modal-input").value = node.uHeight || "1";
       document.getElementById("edit-modal").style.display = "flex";
       document.getElementById("modal-input").focus();
       const saveHandler = () => {
        pushUndo("edit U height");
        const value = document.getElementById("modal-input").value.trim();
        node.uHeight = value;
        document.getElementById("edit-modal").style.display = "none";
        claimTheImmortal(id);
        forgeTheTopology();
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       const cancelHandler = () => {
        document.getElementById("edit-modal").style.display = "none";
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       document.getElementById("edit-modal").addEventListener("click", function bgHandler(e) {
        if (e.target === document.getElementById("edit-modal")) {
         cancelHandler();
         document.getElementById("edit-modal").removeEventListener("click", bgHandler);
        }
       });
      }
      function updateEdgePortLabels(edgeId) {
       const edge = EDGE_DATA.list.find(e => e.id === edgeId);
       if (!edge || edge.type === "custom") return;
       const fromPortInput = document.getElementById("edge-from-port");
       const toPortInput = document.getElementById("edge-to-port");
       if (fromPortInput && toPortInput) {
        edge.fromPort = fromPortInput.value || "";
        edge.toPort = toPortInput.value || "";
        forgeTheTopology();
       }
      }
      function clearSelection() {
       selectedNodes.clear();
       selectedEdges.clear();
       selectedRects.clear();
       selectedTexts.clear();
       updateAllSelections();
      }
      function updateAllSelections() {
      updateNodeSelection();
      document.querySelectorAll(".edge").forEach(el => {
      const edgeId = el.dataset.edgeId;
      if (selectedEdges.has(edgeId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      document.querySelectorAll(".rect-group").forEach(el => {
      const rectId = el.dataset.rectId;
      if (selectedRects.has(rectId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      document.querySelectorAll(".text-group").forEach(el => {
      const textId = el.dataset.textId;
      if (selectedTexts.has(textId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
      const bulkToolbar = document.getElementById("bulk-toolbar");
      const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
      const bulkCount = document.getElementById("bulk-count");
      const bulkCountMobile = document.getElementById("bulk-count-mobile");
      if (total > 0) {
      if (bulkToolbar) bulkToolbar.style.display = "flex";
      if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
      if (bulkCount) bulkCount.textContent = total;
      if (bulkCountMobile) bulkCountMobile.textContent = total;
      } else {
      if (bulkToolbar) bulkToolbar.style.display = "none";
      if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
      }
      }
      function updateNodeSelection() {
       if (isViewOnly()) {
        selectedNodes.clear();
        selectedRects.clear();
        selectedTexts.clear();
        const bulkToolbar = document.getElementById("bulk-toolbar");
        const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        return;
       }
       document.querySelectorAll(".node-group").forEach(node => {
        const nodeId = node.dataset.nodeId;
        if (selectedNodes.has(nodeId)) {
         node.classList.add("selected");
        } else {
         node.classList.remove("selected");
        }
       });
       const bulkToolbar = document.getElementById("bulk-toolbar");
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       const bulkCount = document.getElementById("bulk-count");
       const bulkCountMobile = document.getElementById("bulk-count-mobile");
       const bulkCountModal = document.getElementById("bulk-count-modal");
       if (selectedNodes.size > 0) {
        if (bulkToolbar) bulkToolbar.style.display = "flex";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
        if (bulkCount) bulkCount.textContent = selectedNodes.size;
        if (bulkCountMobile) bulkCountMobile.textContent = selectedNodes.size;
        if (bulkCountModal) bulkCountModal.textContent = selectedNodes.size;
       } else {
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        const modal = document.getElementById("bulk-actions-modal");
        if (modal) modal.style.display = "none";
       }
      }
      function deleteSelected() {
       const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
       if (total === 0) return;
       let nodesInsideRacks = [];
       selectedNodes.forEach(nodeId => {
        if (NODE_DATA[nodeId]?.isRack) {
         Object.entries(NODE_DATA).forEach(([id, n]) => {
          if (n.assignedRack === nodeId) nodesInsideRacks.push(n.name || id);
         });
        }
       });
       let message = `Delete ${total} selected item(s)?`;
       if (nodesInsideRacks.length > 0) {
        message += `\n\nThis will also delete ${nodesInsideRacks.length} node(s) inside rack(s):\n• ${nodesInsideRacks.join('\n• ')}`;
       }
       challengeTheImmortal(message, () => {
        pushUndo("delete selected");
        selectedNodes.forEach(nodeId => {
         if (NODE_DATA[nodeId]?.isRack) {
          Object.keys(NODE_DATA).forEach(id => {
           if (NODE_DATA[id]?.assignedRack === nodeId) {
            EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== id && e.to !== id);
            delete NODE_DATA[id];
            delete savedPositions[id];
            delete savedSizes[id];
            delete savedStyles[id];
           }
          });
         }
         delete NODE_DATA[nodeId];
         delete savedPositions[nodeId];
         delete savedSizes[nodeId];
         delete savedStyles[nodeId];
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== nodeId && e.to !== nodeId);
        });
        selectedEdges.forEach(edgeId => {
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.id !== edgeId);
        });
        selectedRects.forEach(rectId => {
         RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== rectId);
        });
        selectedTexts.forEach(textId => {
         TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== textId);
        });
        clearSelection();
        forgeTheTopology();
       });
      }
      function startSelection(event) {
       if (event.button !== 0) return;
       if (event.target.closest(".node-group")) return;
       isSelecting = true;
       const svg = document.getElementById("map");
       const pt = svg.createSVGPoint();
       pt.x = event.clientX;
       pt.y = event.clientY;
       const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
       selectionStart = { x: svgP.x, y: svgP.y };
       clearSelection();
       preDragSelectedNodes = new Set(selectedNodes);
       preDragSelectedEdges = new Set(selectedEdges);
       preDragSelectedRects = new Set(selectedRects);
       preDragSelectedTexts = new Set(selectedTexts);
       if (!selectionRect || !selectionRect.parentNode) {
        selectionRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        selectionRect.setAttribute("fill", selectionBoxStyle.fillColor);
        selectionRect.setAttribute("fill-opacity", selectionBoxStyle.fillOpacity);
        selectionRect.setAttribute("stroke", selectionBoxStyle.strokeColor);
        selectionRect.setAttribute("stroke-width", selectionBoxStyle.strokeWidth);
        selectionRect.setAttribute("stroke-dasharray", selectionBoxStyle.strokeDasharray);
        svg.appendChild(selectionRect);
       }
       selectionRect.style.display = "block";
      }
      function updateSelection(event) {
       if (!isSelecting || !selectionStart) return;
       const svg = document.getElementById("map");
       const pt = svg.createSVGPoint();
       pt.x = event.clientX;
       pt.y = event.clientY;
       const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
       const x = Math.min(selectionStart.x, svgP.x);
       const y = Math.min(selectionStart.y, svgP.y);
       const width = Math.abs(svgP.x - selectionStart.x);
       const height = Math.abs(svgP.y - selectionStart.y);
       selectionRect.setAttribute("x", x);
       selectionRect.setAttribute("y", y);
       selectionRect.setAttribute("width", width);
       selectionRect.setAttribute("height", height);
       const box = { x, y, width, height };
       Object.entries(savedPositions).forEach(([nodeId, pos]) => {
        const size = savedSizes[nodeId] || 50;
        const halfSize = size / 2;
        const nodeBox = { x: pos.x - halfSize, y: pos.y - halfSize, width: size, height: size };
        if (boxesIntersect(box, nodeBox)) {
         selectedNodes.add(nodeId);
        } else if (!preDragSelectedNodes.has(nodeId)) {
         selectedNodes.delete(nodeId);
        }
       });
      EDGE_DATA.list.forEach(edge => {
        if (!edge.points || edge.points.length === 0) return;
        for (let i = 0; i < edge.points.length - 1; i++) {
         const p1 = edge.points[i];
         const p2 = edge.points[i + 1];
         if (lineIntersectsBox(p1.x, p1.y, p2.x, p2.y, box)) {
          selectedEdges.add(edge.id);
          return;
         }
        }
        if (!preDragSelectedEdges.has(edge.id)) {
         selectedEdges.delete(edge.id);
        }
       });
       RECT_DATA.list.forEach(rect => {
        const rectBox = { x: rect.x, y: rect.y, width: rect.width, height: rect.height };
        if (boxesIntersect(box, rectBox)) {
         selectedRects.add(rect.id);
        } else if (!preDragSelectedRects.has(rect.id)) {
         selectedRects.delete(rect.id);
        }
       });
       TEXT_DATA.list.forEach(text => {
        const fontSize = text.fontSize || 18;
        const textBox = { x: text.x - 50, y: text.y - fontSize, width: 100, height: fontSize * 1.5 };
        if (boxesIntersect(box, textBox)) {
         selectedTexts.add(text.id);
        } else if (!preDragSelectedTexts.has(text.id)) {
         selectedTexts.delete(text.id);
        }
       });
       updateAllSelectionVisuals();
      }
      function endSelection() {
       isSelecting = false;
       if (selectionRect) {
        selectionRect.style.display = "none";
       }
      }
      function boxesIntersect(a, b) {
       return !(a.x + a.width < b.x || b.x + b.width < a.x || a.y + a.height < b.y || b.y + b.height < a.y);
      }
      function lineIntersectsBox(x1, y1, x2, y2, box) {
       if (pointInBox(x1, y1, box) || pointInBox(x2, y2, box)) return true;
       const lines = [
        [box.x, box.y, box.x + box.width, box.y],
        [box.x + box.width, box.y, box.x + box.width, box.y + box.height],
        [box.x + box.width, box.y + box.height, box.x, box.y + box.height],
        [box.x, box.y + box.height, box.x, box.y]
       ];
       for (const [bx1, by1, bx2, by2] of lines) {
        if (linesIntersect(x1, y1, x2, y2, bx1, by1, bx2, by2)) return true;
       }
       return false;
      }
      function pointInBox(x, y, box) {
       return x >= box.x && x <= box.x + box.width && y >= box.y && y <= box.y + box.height;
      }
      function linesIntersect(x1, y1, x2, y2, x3, y3, x4, y4) {
       const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
       if (Math.abs(denom) < 0.0001) return false;
       const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom;
       const ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denom;
       return ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1;
      }
      function updateAllSelectionVisuals() {
       document.querySelectorAll(".node-group").forEach(node => {
        const nodeId = node.dataset.nodeId;
        if (selectedNodes.has(nodeId)) {
         node.classList.add("selected");
        } else {
         node.classList.remove("selected");
        }
       });
       document.querySelectorAll(".edge").forEach(edge => {
        const edgeId = edge.dataset.edgeId;
        if (selectedEdges.has(edgeId)) {
         edge.style.filter = "drop-shadow(0 0 6px #4fd1c5)";
        } else {
         edge.style.filter = "";
        }
       });
       document.querySelectorAll(".rect-group rect").forEach(el => {
        const rectId = el.closest(".rect-group")?.dataset?.rectId;
        if (selectedRects.has(rectId)) {
         el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
        } else {
         el.style.filter = "";
        }
       });
       document.querySelectorAll(".text-group, .text-element").forEach(el => {
        const textId = el.dataset?.textId;
        if (selectedTexts.has(textId)) {
         el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
        } else {
         el.style.filter = "";
        }
       });
       const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
       const bulkToolbar = document.getElementById("bulk-toolbar");
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       const bulkCount = document.getElementById("bulk-count");
       const bulkCountMobile = document.getElementById("bulk-count-mobile");
       if (total > 0) {
        if (bulkToolbar) bulkToolbar.style.display = "flex";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
        if (bulkCount) bulkCount.textContent = total;
        if (bulkCountMobile) bulkCountMobile.textContent = total;
       } else {
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
       }
      }
      function cloneNode(sourceId, skipUndo) {
       if (!NODE_DATA[sourceId]) return;
       if (!skipUndo) pushUndo("clone node");
       const source = NODE_DATA[sourceId];
       const baseName = source.name + " copy";
       let newName = baseName;
       let counter = 1;
       while (Object.values(NODE_DATA).some(n => n.name === newName)) {
        newName = `${baseName} ${counter}`;
        counter++;
       }
       const baseId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
       let newId = baseId;
       counter = 1;
       while (NODE_DATA[newId]) {
        newId = `${baseId}-${counter}`;
        counter++;
       }
       NODE_DATA[newId] = {
        shape: source.shape,
        name: newName,
        ip: source.ip,
        role: source.role,
        tags: [...source.tags],
        notes: [...source.notes],
        mac: source.mac || "",
        rackUnit: source.rackUnit || "",
        uHeight: source.uHeight || "1",
        layer: source.layer || "physical",
        assignedRack: source.assignedRack || "",
        rackCapacity: source.rackCapacity || "42",
        isRack: source.isRack || false
       };
       if (source.isRack) {
        const childNodes = Object.entries(NODE_DATA).filter(([id, n]) =>
         id !== newId && n.assignedRack === sourceId
        );
        childNodes.forEach(([childId, childNode]) => {
         const childBaseName = childNode.name + " copy";
         let childNewName = childBaseName;
         let c = 1;
         while (Object.values(NODE_DATA).some(n => n.name === childNewName)) {
          childNewName = `${childBaseName} ${c}`;
          c++;
         }
         const childBaseId = childNewName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
         let childNewId = childBaseId;
         c = 1;
         while (NODE_DATA[childNewId]) {
          childNewId = `${childBaseId}-${c}`;
          c++;
         }
         NODE_DATA[childNewId] = {
          ...JSON.parse(JSON.stringify(childNode)),
          name: childNewName,
          assignedRack: newId
         };
         if (savedPositions[childId]) {
          savedPositions[childNewId] = { ...savedPositions[childId] };
         }
         if (savedSizes[childId]) {
          savedSizes[childNewId] = savedSizes[childId];
         }
         if (savedStyles[childId]) {
          savedStyles[childNewId] = JSON.parse(JSON.stringify(savedStyles[childId]));
         }
        });
       }
       if (currentView.mode === "rack" && currentView.rackId) {
        NODE_DATA[newId].assignedRack = currentView.rackId;
       }
       const sourcePos = savedPositions[sourceId];
       savedPositions[newId] = {
        x: sourcePos.x + 100,
        y: sourcePos.y + 100
       };
       if (savedSizes[sourceId]) {
        savedSizes[newId] = savedSizes[sourceId];
       }
       if (savedStyles[sourceId]) {
        savedStyles[newId] = JSON.parse(JSON.stringify(savedStyles[sourceId]));
       }
       forgeTheTopology();
       claimTheImmortal(newId);
      }
      function alignSelectedNodes(direction) {
       if (selectedNodes.size < 2) return;
       pushUndo("align nodes");
       const nodes = Array.from(selectedNodes).map(id => ({
        id,
        pos: savedPositions[id]
       }));
       switch(direction) {
        case "left":
         const minX = Math.min(...nodes.map(n => n.pos.x));
         nodes.forEach(n => savedPositions[n.id].x = minX);
         break;
        case "right":
         const maxX = Math.max(...nodes.map(n => n.pos.x));
         nodes.forEach(n => savedPositions[n.id].x = maxX);
         break;
        case "top":
         const minY = Math.min(...nodes.map(n => n.pos.y));
         nodes.forEach(n => savedPositions[n.id].y = minY);
         break;
        case "bottom":
         const maxY = Math.max(...nodes.map(n => n.pos.y));
         nodes.forEach(n => savedPositions[n.id].y = maxY);
         break;
        case "center-h":
         const avgX = nodes.reduce((sum, n) => sum + n.pos.x, 0) / nodes.length;
         nodes.forEach(n => savedPositions[n.id].x = avgX);
         break;
        case "center-v":
         const avgY = nodes.reduce((sum, n) => sum + n.pos.y, 0) / nodes.length;
         nodes.forEach(n => savedPositions[n.id].y = avgY);
         break;
       }
       forgeTheTopology();
      }
      function distributeSelectedNodes(direction) {
       if (selectedNodes.size < 3) return;
       pushUndo("distribute nodes");
       const nodes = Array.from(selectedNodes).map(id => ({
        id,
        pos: savedPositions[id]
       }));
       if (direction === "horizontal") {
        nodes.sort((a, b) => a.pos.x - b.pos.x);
        const minX = nodes[0].pos.x;
        const maxX = nodes[nodes.length - 1].pos.x;
        const gap = (maxX - minX) / (nodes.length - 1);
        nodes.forEach((n, i) => {
         savedPositions[n.id].x = minX + (gap * i);
        });
       } else {
        nodes.sort((a, b) => a.pos.y - b.pos.y);
        const minY = nodes[0].pos.y;
        const maxY = nodes[nodes.length - 1].pos.y;
        const gap = (maxY - minY) / (nodes.length - 1);
        nodes.forEach((n, i) => {
         savedPositions[n.id].y = minY + (gap * i);
        });
       }
       forgeTheTopology();
      }
      function snapToGrid(nodeId, gridSize = 50) {
       if (!savedPositions[nodeId]) return;
       pushUndo("snap to grid");
       const pos = savedPositions[nodeId];
       pos.x = Math.round(pos.x / gridSize) * gridSize;
       pos.y = Math.round(pos.y / gridSize) * gridSize;
       forgeTheTopology();
      }
		function searchNodes(query) {
		   if (!query) {
			clearSearchHighlight();
			return [];
		   }
		   query = query.toLowerCase();
		   const results = [];
		   Object.entries(NODE_DATA).forEach(([id, data]) => {
			try {
			 const nameMatch = data.name && data.name.toLowerCase().includes(query);
			 const ipMatch = data.ip && data.ip.toLowerCase().includes(query);
			 const roleMatch = data.role && data.role.toLowerCase().includes(query);
			 const tagsMatch = data.tags && Array.isArray(data.tags) && data.tags.some(tag => tag && tag.toLowerCase().includes(query));
			 const macMatch = data.mac && data.mac.toLowerCase().includes(query);
			 const rackUnitMatch = data.rackUnit && String(data.rackUnit).toLowerCase().includes(query);
			 if (nameMatch || ipMatch || roleMatch || tagsMatch || macMatch || rackUnitMatch) {
			  results.push(id);
			 }
			} catch (e) {
			 console.warn("Search error for node:", id, e);
			}
		   });
		   highlightSearchResults(results, true);
		   return results;
		}
		function highlightSearchResults(nodeIds, hasQuery = false) {
		   document.querySelectorAll(".node-group").forEach(node => {
			const nodeId = node.dataset.nodeId;
			if (nodeIds.includes(nodeId)) {
			 node.classList.add("search-highlight");
			 node.classList.remove("search-faded");
			} else {
			 node.classList.remove("search-highlight");
			 if (hasQuery) {
			  node.classList.add("search-faded");
			 } else {
			  node.classList.remove("search-faded");
			 }
			}
		   });
		   document.querySelectorAll(".edge-group").forEach(edge => {
			const fromId = edge.dataset.from;
			const toId = edge.dataset.to;
			if (hasQuery && !nodeIds.includes(fromId) && !nodeIds.includes(toId)) {
			 edge.classList.add("search-faded");
			} else {
			 edge.classList.remove("search-faded");
			}
		   });
		}
		function clearSearchHighlight() {
   document.querySelectorAll(".search-highlight").forEach(node => {
    node.classList.remove("search-highlight");
   });
   document.querySelectorAll(".search-faded").forEach(el => {
    el.classList.remove("search-faded");
   });
}
      function nudgeSelectedNodes(direction, distance) {
        const nodesToNudge = selectedNodes.size > 0
          ? Array.from(selectedNodes)
          : (currentNodeId ? [currentNodeId] : []);
        const rectsToNudge = selectedRects.size > 0
          ? Array.from(selectedRects)
          : (currentRectId ? [currentRectId] : []);
        const textsToNudge = selectedTexts.size > 0
          ? Array.from(selectedTexts)
          : (currentTextId ? [currentTextId] : []);
        if (nodesToNudge.length === 0 && rectsToNudge.length === 0 && textsToNudge.length === 0) return;
        const unlockedNodes = nodesToNudge.filter(id => !NODE_DATA[id]?.locked);
        const unlockedRects = rectsToNudge.filter(id => { const r = RECT_DATA.list.find(x => x.id === id); return r && !r.locked; });
        const unlockedTexts = textsToNudge.filter(id => { const t = TEXT_DATA.list.find(x => x.id === id); return t && !t.locked; });
        if (unlockedNodes.length === 0 && unlockedRects.length === 0 && unlockedTexts.length === 0) return;
        pushUndo("nudge");
        const dx = direction === "ArrowLeft" ? -distance : direction === "ArrowRight" ? distance : 0;
        const dy = direction === "ArrowUp" ? -distance : direction === "ArrowDown" ? distance : 0;
        unlockedNodes.forEach(id => {
          if (!savedPositions[id]) savedPositions[id] = { x: 0, y: 0 };
          savedPositions[id].x += dx;
          savedPositions[id].y += dy;
        });
        unlockedRects.forEach(id => {
          const r = RECT_DATA.list.find(x => x.id === id);
          if (r) { r.x += dx; r.y += dy; }
        });
        unlockedTexts.forEach(id => {
          const t = TEXT_DATA.list.find(x => x.id === id);
          if (t) { t.x += dx; t.y += dy; }
        });
        forgeTheTopology();
      }
      function cycleNodes(reverse = false) {
        const nodeIds = Object.keys(NODE_DATA).filter(id => {
          if (currentView.mode === "rack" && currentView.rackId) {
            return NODE_DATA[id].assignedRack === currentView.rackId;
          }
          return !NODE_DATA[id].assignedRack;
        });
        if (nodeIds.length === 0) return;
        let currentIndex = nodeIds.indexOf(currentNodeId);
        if (reverse) {
          currentIndex = currentIndex <= 0 ? nodeIds.length - 1 : currentIndex - 1;
        } else {
          currentIndex = currentIndex >= nodeIds.length - 1 ? 0 : currentIndex + 1;
        }
        const nextNodeId = nodeIds[currentIndex];
        claimTheImmortal(nextNodeId);
        selectedNodes.clear();
        updateNodeSelection();
      }
      function focusOnSelected() {
        let minX = Infinity, minY = Infinity;
        let maxX = -Infinity, maxY = -Infinity;
        let hasItems = false;
        const nodesToFocus = selectedNodes.size > 0
          ? Array.from(selectedNodes)
          : (currentNodeId ? [currentNodeId] : []);
        nodesToFocus.forEach(id => {
          const pos = savedPositions[id];
          if (pos) {
            hasItems = true;
            const size = savedSizes[id] || 50;
            minX = Math.min(minX, pos.x - size/2);
            minY = Math.min(minY, pos.y - size/2);
            maxX = Math.max(maxX, pos.x + size/2);
            maxY = Math.max(maxY, pos.y + size/2);
          }
        });
        const rectsToFocus = selectedRects.size > 0 ? Array.from(selectedRects) : (currentRectId ? [currentRectId] : []);
        rectsToFocus.forEach(id => {
          const r = RECT_DATA.list.find(x => x.id === id);
          if (r) {
            hasItems = true;
            minX = Math.min(minX, r.x);
            minY = Math.min(minY, r.y);
            maxX = Math.max(maxX, r.x + r.width);
            maxY = Math.max(maxY, r.y + r.height);
          }
        });
        const textsToFocus = selectedTexts.size > 0 ? Array.from(selectedTexts) : (currentTextId ? [currentTextId] : []);
        textsToFocus.forEach(id => {
          const t = TEXT_DATA.list.find(x => x.id === id);
          if (t) {
            hasItems = true;
            minX = Math.min(minX, t.x - 50);
            minY = Math.min(minY, t.y - 20);
            maxX = Math.max(maxX, t.x + 50);
            maxY = Math.max(maxY, t.y + 20);
          }
        });
        const edgesToFocus = selectedEdges.size > 0 ? Array.from(selectedEdges) : (currentEdgeId ? [currentEdgeId] : []);
        edgesToFocus.forEach(id => {
          const e = EDGE_DATA.list.find(x => x.id === id);
          if (e) {
            const fromPos = savedPositions[e.from];
            const toPos = savedPositions[e.to];
            if (fromPos && toPos) {
              hasItems = true;
              minX = Math.min(minX, fromPos.x, toPos.x);
              minY = Math.min(minY, fromPos.y, toPos.y);
              maxX = Math.max(maxX, fromPos.x, toPos.x);
              maxY = Math.max(maxY, fromPos.y, toPos.y);
            }
          }
        });
        if (!hasItems || !isFinite(minX)) return;
        const padding = 100;
        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;
        const width = maxX - minX + padding * 2;
        const height = maxY - minY + padding * 2;
        const zoomX = CANVAS_WIDTH / width;
        const zoomY = CANVAS_HEIGHT / height;
        const targetZoom = Math.min(zoomX, zoomY, 2);
        canvasState.zoom = targetZoom;
        canvasState.panX = centerX - (CANVAS_WIDTH / targetZoom) / 2;
        canvasState.panY = centerY - (CANVAS_HEIGHT / targetZoom) / 2;
        forgeTheTopology();
      }
      function toggleLockSelected() {
        const nodesToToggle = selectedNodes.size > 0
          ? Array.from(selectedNodes)
          : (currentNodeId ? [currentNodeId] : []);
        const rectsToToggle = selectedRects.size > 0
          ? Array.from(selectedRects)
          : (currentRectId ? [currentRectId] : []);
        const textsToToggle = selectedTexts.size > 0
          ? Array.from(selectedTexts)
          : (currentTextId ? [currentTextId] : []);
        if (nodesToToggle.length === 0 && rectsToToggle.length === 0 && textsToToggle.length === 0) return;
        pushUndo("toggle lock");
        let hasUnlocked = nodesToToggle.some(id => !NODE_DATA[id]?.locked);
        hasUnlocked = hasUnlocked || rectsToToggle.some(id => { const r = RECT_DATA.list.find(x => x.id === id); return r && !r.locked; });
        hasUnlocked = hasUnlocked || textsToToggle.some(id => { const t = TEXT_DATA.list.find(x => x.id === id); return t && !t.locked; });
        nodesToToggle.forEach(id => {
          if (NODE_DATA[id]) NODE_DATA[id].locked = hasUnlocked;
        });
        rectsToToggle.forEach(id => {
          const r = RECT_DATA.list.find(x => x.id === id);
          if (r) r.locked = hasUnlocked;
        });
        textsToToggle.forEach(id => {
          const t = TEXT_DATA.list.find(x => x.id === id);
          if (t) t.locked = hasUnlocked;
        });
        forgeTheTopology();
      }
      function toggleGroupSelected() {
      const nodesToGroup = Array.from(selectedNodes);
      const rectsToGroup = Array.from(selectedRects);
      const textsToGroup = Array.from(selectedTexts);
      const edgesToGroup = Array.from(selectedEdges);
      const totalItems = nodesToGroup.length + rectsToGroup.length + textsToGroup.length + edgesToGroup.length;
      if (totalItems < 2) return;
      pushUndo("toggle group");
      const allGroupIds = [];
      nodesToGroup.forEach(id => { if (NODE_DATA[id]?.groupId) allGroupIds.push(NODE_DATA[id].groupId); });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r?.groupId) allGroupIds.push(r.groupId); });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t?.groupId) allGroupIds.push(t.groupId); });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e?.groupId) allGroupIds.push(e.groupId); });
      const uniqueGroups = [...new Set(allGroupIds)];
      if (uniqueGroups.length === 1 && allGroupIds.length === totalItems) {
      nodesToGroup.forEach(id => { if (NODE_DATA[id]) NODE_DATA[id].groupId = null; });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r) r.groupId = null; });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t) t.groupId = null; });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e) e.groupId = null; });
      } else {
      const newGroupId = "group-" + Date.now();
      nodesToGroup.forEach(id => { if (NODE_DATA[id]) NODE_DATA[id].groupId = newGroupId; });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r) r.groupId = newGroupId; });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t) t.groupId = newGroupId; });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e) e.groupId = newGroupId; });
      }
      forgeTheTopology();
      }
      function handleKeyDown(event) {
       if (event.target.tagName === "INPUT" || event.target.tagName === "TEXTAREA" || event.target.isContentEditable) {
        return;
       }
       if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(event.key)) {
        event.preventDefault();
        const distance = event.shiftKey ? 10 : 1;
        nudgeSelectedNodes(event.key, distance);
       }
       if (event.key === "Tab") {
        event.preventDefault();
        cycleNodes(event.shiftKey);
       }
       if (event.key === "f" || event.key === "F") {
        event.preventDefault();
        focusOnSelected();
       }
       if (event.key === "l" || event.key === "L") {
        event.preventDefault();
        toggleLockSelected();
       }
       if (event.key === "g" || event.key === "G") {
        event.preventDefault();
        toggleGroupSelected();
       }
       if (event.ctrlKey && event.key === "z") {
        event.preventDefault();
        undo();
       }
       if ((event.ctrlKey && event.key === "y") || (event.ctrlKey && event.shiftKey && event.key === "z")) {
        event.preventDefault();
        redo();
       }
 if (event.ctrlKey && event.key === "c") {
        event.preventDefault();
        clipboard = null;
        if (currentNodeId && NODE_DATA[currentNodeId]) {
         clipboard = {
          type: "node",
          data: JSON.parse(JSON.stringify(NODE_DATA[currentNodeId])),
          size: savedSizes[currentNodeId],
          style: savedStyles[currentNodeId] ? JSON.parse(JSON.stringify(savedStyles[currentNodeId])) : null
         };
        } else if (currentEdgeId) {
         const edge = EDGE_DATA.list.find(e => e.id === currentEdgeId);
         if (edge) clipboard = { type: "edge", data: JSON.parse(JSON.stringify(edge)) };
        } else if (currentRectId) {
         const rect = RECT_DATA.list.find(r => r.id === currentRectId);
         if (rect) clipboard = { type: "rect", data: JSON.parse(JSON.stringify(rect)) };
        } else if (currentTextId) {
         const text = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (text) clipboard = { type: "text", data: JSON.parse(JSON.stringify(text)) };
        }
       }
       if (event.ctrlKey && event.key === "v") {
        event.preventDefault();
        if (!clipboard) return;
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        const centerX = canvasState.panX + (viewWidth / 2);
        const centerY = canvasState.panY + (viewHeight / 2);
        if (clipboard.type === "node") {
         const data = clipboard.data;
         let newName = data.name + " copy";
         let counter = 1;
         while (Object.values(NODE_DATA).some(n => n.name === newName)) {
          newName = data.name + " copy " + counter;
          counter++;
         }
         let newId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
         counter = 1;
         while (NODE_DATA[newId]) {
          newId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-") + "-" + counter;
          counter++;
         }
         pushUndo("paste node");
         NODE_DATA[newId] = { ...data, name: newName };
         savedPositions[newId] = { x: centerX, y: centerY };
         if (clipboard.size) savedSizes[newId] = clipboard.size;
         if (clipboard.style) savedStyles[newId] = JSON.parse(JSON.stringify(clipboard.style));
         forgeTheTopology();
         claimTheImmortal(newId);
        } else if (clipboard.type === "edge") {
         pushUndo("paste edge");
         const newEdge = { ...clipboard.data, id: "edge-" + Date.now() };
         EDGE_DATA.list.push(newEdge);
         forgeTheTopology();
         selectTheConnection(newEdge.id);
        } else if (clipboard.type === "rect") {
         pushUndo("paste rect");
         const newRect = { ...clipboard.data, id: "rect-" + Date.now(), x: centerX - (clipboard.data.width || 100) / 2, y: centerY - (clipboard.data.height || 100) / 2 };
         RECT_DATA.list.push(newRect);
         forgeTheTopology();
         selectTheRect(newRect.id);
        } else if (clipboard.type === "text") {
         pushUndo("paste text");
         const newText = { ...clipboard.data, id: "text-" + Date.now(), x: centerX, y: centerY };
         TEXT_DATA.list.push(newText);
         forgeTheTopology();
         showTextPanel(newText.id);
        }
       }
       if (event.key === "Delete") {
        event.preventDefault();
        const totalSelected = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
        if (totalSelected > 0) {
         deleteSelected();
        } else if (currentNodeId && NODE_DATA[currentNodeId]) {
         challengeTheImmortal(`Delete node "${NODE_DATA[currentNodeId].name}"?`, () => {
          pushUndo("delete node");
          delete NODE_DATA[currentNodeId];
          delete savedPositions[currentNodeId];
          delete savedSizes[currentNodeId];
          delete savedStyles[currentNodeId];
          EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== currentNodeId && e.to !== currentNodeId);
          currentNodeId = null;
          forgeTheTopology();
          document.getElementById("node-panel").style.display = "none";
         });
        } else if (currentEdgeId) {
         challengeTheImmortal("Delete this line?", () => {
          pushUndo("delete edge");
          EDGE_DATA.list = EDGE_DATA.list.filter(e => e.id !== currentEdgeId);
          currentEdgeId = null;
          forgeTheTopology();
          document.getElementById("edge-panel").style.display = "none";
         });
        } else if (currentRectId) {
         challengeTheImmortal("Delete this zone?", () => {
          pushUndo("delete rect");
          RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== currentRectId);
          currentRectId = null;
          forgeTheTopology();
          document.getElementById("rect-panel").style.display = "none";
         });
        } else if (currentTextId) {
         const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (textItem) {
          challengeTheImmortal(`Delete text "${textItem.content.substring(0, 30)}..."?`, () => {
           pushUndo("delete text");
           TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== currentTextId);
           currentTextId = null;
           forgeTheTopology();
           document.getElementById("text-panel").style.display = "none";
          });
         }
        }
       }
       if (event.ctrlKey && event.key === "a") {
        event.preventDefault();
        Object.keys(NODE_DATA).forEach(id => selectedNodes.add(id));
        EDGE_DATA.list.forEach(e => selectedEdges.add(e.id));
        RECT_DATA.list.forEach(r => selectedRects.add(r.id));
        TEXT_DATA.list.forEach(t => selectedTexts.add(t.id));
        updateAllSelections();
       }
       if (event.key === "Escape") {
        clearSelection();
        clearSearchHighlight();
       }
       if (event.ctrlKey && event.key === "d") {
        event.preventDefault();
        if (currentNodeId && NODE_DATA[currentNodeId]) {
         cloneNode(currentNodeId);
        } else if (currentEdgeId) {
         const edge = EDGE_DATA.list.find(e => e.id === currentEdgeId);
         if (edge) {
          pushUndo("clone edge");
          const newEdge = { ...JSON.parse(JSON.stringify(edge)), id: "edge-" + Date.now() };
          EDGE_DATA.list.push(newEdge);
          forgeTheTopology();
          selectTheConnection(newEdge.id);
         }
        } else if (currentRectId) {
         const rect = RECT_DATA.list.find(r => r.id === currentRectId);
         if (rect) {
          pushUndo("clone rect");
          const newRect = { ...JSON.parse(JSON.stringify(rect)), id: "rect-" + Date.now(), x: rect.x + 50, y: rect.y + 50 };
          RECT_DATA.list.push(newRect);
          forgeTheTopology();
          selectTheRect(newRect.id);
         }
        } else if (currentTextId) {
         const text = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (text) {
          pushUndo("clone text");
          const newText = { ...JSON.parse(JSON.stringify(text)), id: "text-" + Date.now(), x: text.x + 50, y: text.y + 50 };
          TEXT_DATA.list.push(newText);
          forgeTheTopology();
          showTextPanel(newText.id);
         }
        }
       }
      }
      function saveRollbackVersion(description = "Auto-save") {
        const version = {
          timestamp: Date.now(),
          description,
          data: captureTheQuickening()
        };
        try {
          const stored = localStorage.getItem(ROLLBACK_STORAGE_KEY);
          rollbackVersions = stored ? JSON.parse(stored) : [];
        } catch (e) {
          rollbackVersions = [];
        }
        rollbackVersions.unshift(version);
        if (rollbackVersions.length > MAX_ROLLBACK_VERSIONS) {
          rollbackVersions = rollbackVersions.slice(0, MAX_ROLLBACK_VERSIONS);
        }
        try {
          localStorage.setItem(ROLLBACK_STORAGE_KEY, JSON.stringify(rollbackVersions));
        } catch (e) {
          console.warn("Failed to save rollback version:", e);
        }
      }
      function loadRollbackVersions() {
        try {
          const stored = localStorage.getItem(ROLLBACK_STORAGE_KEY);
          rollbackVersions = stored ? JSON.parse(stored) : [];
          displayRollbackVersions();
        } catch (e) {
          console.warn("Failed to load rollback versions:", e);
          rollbackVersions = [];
        }
      }
      function displayRollbackVersions() {
        const listEl = document.getElementById("rollback-list");
        if (!listEl) return;
        if (rollbackVersions.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No version history yet. Versions are saved automatically when you save the file.</div>';
          return;
        }
        listEl.innerHTML = rollbackVersions.map((version, index) => {
          const date = new Date(version.timestamp);
          const timeStr = date.toLocaleString();
          const nodeCount = Object.keys(version.data.nodeData || {}).length;
          const edgeCount = (version.data.edgeData?.list || []).length;
          return `
            <div class="version-item" onclick="restoreRollbackVersion(${index})">
              <div class="version-info">
                <div class="timestamp">${timeStr}</div>
                <div class="details">${version.description} • ${nodeCount} nodes • ${edgeCount} connections</div>
              </div>
              <div class="version-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteRollbackVersion(${index})" title="Delete this version">🗑️</button>
              </div>
            </div>
          `;
        }).join('');
      }
      function restoreRollbackVersion(index) {
        if (!confirm(`Restore version from ${new Date(rollbackVersions[index].timestamp).toLocaleString()}?\n\nYour current work will be lost unless you save first.`)) {
          return;
        }
        const version = rollbackVersions[index];
        const data = version.data;
        NODE_DATA = data.nodeData || {};
        EDGE_DATA = data.edgeData || { list: [] };
        RECT_DATA = data.rectData || { list: [] };
        TEXT_DATA = data.textData || { list: [] };
        EDGE_LEGEND = data.edgeLegend || {};
        savedPositions = data.nodePositions || {};
        savedSizes = data.nodeSizes || {};
        savedStyles = data.nodeStyles || {};
        PAGE_STATE = data.page || PAGE_STATE;
        if (data.canvas) {
          canvasState.zoom = data.canvas.zoom;
          canvasState.panX = data.canvas.panX;
          canvasState.panY = data.canvas.panY;
        }
        wieldThePower();
        forgeTheTopology();
        document.getElementById("rollback-modal").classList.remove("active");
        logAuditEvent("rollback", `Restored version from ${new Date(version.timestamp).toLocaleString()}`);
      }
      function deleteRollbackVersion(index) {
        if (!confirm("Delete this version from history?")) return;
        rollbackVersions.splice(index, 1);
        try {
          localStorage.setItem(ROLLBACK_STORAGE_KEY, JSON.stringify(rollbackVersions));
        } catch (e) {
          console.warn("Failed to delete version:", e);
        }
        displayRollbackVersions();
      }
      function clearRollbackHistory() {
        if (!confirm("Clear all version history?\n\nThis cannot be undone.")) return;
        rollbackVersions = [];
        localStorage.removeItem(ROLLBACK_STORAGE_KEY);
        displayRollbackVersions();
      }
      function createManualSnapshot() {
        const description = prompt("Enter a description for this snapshot:", "Manual snapshot");
        if (!description) return;
        saveRollbackVersion(description);
        displayRollbackVersions();
      }
      function switchTab(index) {
        if (index === currentTabIndex) return;
        const currentTab = documentTabs[currentTabIndex];
        currentTab.nodes = JSON.parse(JSON.stringify(NODE_DATA));
        currentTab.edges = JSON.parse(JSON.stringify(EDGE_DATA));
        currentTab.positions = JSON.parse(JSON.stringify(savedPositions));
        currentTab.sizes = JSON.parse(JSON.stringify(savedSizes));
        currentTab.styles = JSON.parse(JSON.stringify(savedStyles));
        currentTab.legend = JSON.parse(JSON.stringify(EDGE_LEGEND));
        currentTab.rects = JSON.parse(JSON.stringify(RECT_DATA));
        currentTab.texts = JSON.parse(JSON.stringify(TEXT_DATA));
        currentTab.pageState = JSON.parse(JSON.stringify(PAGE_STATE));
        currentTabIndex = index;
        const newTab = documentTabs[index];
        NODE_DATA = JSON.parse(JSON.stringify(newTab.nodes));
        EDGE_DATA = JSON.parse(JSON.stringify(newTab.edges));
        savedPositions = JSON.parse(JSON.stringify(newTab.positions));
        savedSizes = JSON.parse(JSON.stringify(newTab.sizes));
        savedStyles = JSON.parse(JSON.stringify(newTab.styles));
        EDGE_LEGEND = JSON.parse(JSON.stringify(newTab.legend));
        RECT_DATA = JSON.parse(JSON.stringify(newTab.rects));
        TEXT_DATA = JSON.parse(JSON.stringify(newTab.texts));
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, newTab.pageState || {});
        wieldThePower();
        document.title = PAGE_STATE.title || newTab.name;
        document.getElementById("page-title").textContent = PAGE_STATE.title || newTab.name;
        forgeTheTopology();
        currentNodeId = null;
        currentEdgeId = null;
        currentTextId = null;
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        displayTabs();
        logAuditEvent("tab", `Switched to tab: ${newTab.name}`);
      }
      function createNewTab() {
        const nameInput = document.getElementById("new-tab-name");
        const name = nameInput.value.trim();
        if (!name) {
          alert("Please enter a tab name");
          return;
        }
        const newTab = {
          id: `tab-${Date.now()}`,
          name,
          nodes: {},
          edges: { list: [] },
          positions: {},
          sizes: {},
          styles: {},
          legend: {},
          rects: { list: [] },
          texts: { list: [] },
      pageState: null
        };
        documentTabs.push(newTab);
        nameInput.value = "";
        displayTabs();
        logAuditEvent("tab", `Created new tab: ${name}`);
      }
      function renameTab(index) {
        const tab = documentTabs[index];
        const newName = prompt("Enter new name:", tab.name);
        if (!newName || newName === tab.name) return;
        tab.name = newName;
        displayTabs();
        logAuditEvent("tab", `Renamed tab to: ${newName}`);
      }
      function deleteTab(index) {
        if (documentTabs.length === 1) {
          alert("Cannot delete the last tab");
          return;
        }
        if (!confirm(`Delete tab "${documentTabs[index].name}"?`)) return;
        documentTabs.splice(index, 1);
        if (currentTabIndex >= documentTabs.length) {
          currentTabIndex = documentTabs.length - 1;
        }
        if (currentTabIndex === index) {
          switchTab(currentTabIndex);
        }
        displayTabs();
      }
      function displayTabs() {
        const listEl = document.getElementById("tabs-list");
        if (!listEl) return;
        listEl.innerHTML = documentTabs.map((tab, index) => {
          const nodeCount = Object.keys(tab.nodes).length;
          const edgeCount = tab.edges.list.length;
          const isActive = index === currentTabIndex;
          return `
            <div class="tab-item ${isActive ? 'active' : ''}" onclick="switchTab(${index})">
              <div class="tab-name">${tab.name}</div>
              <div class="tab-stats">${nodeCount} nodes • ${edgeCount} connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(${index})" title="Rename tab">✏️</button>
                ${documentTabs.length > 1 ? '<button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(${index})" title="Delete tab">🗑️</button>' : ''}
              </div>
            </div>
          `;
        }).join('');
      }
      function logAuditEvent(type, description, details = {}) {
        const event = {
          timestamp: Date.now(),
          type,
          description,
          details,
          tab: documentTabs[currentTabIndex]?.name || "Main"
        };
        auditLog.unshift(event);
        if (auditLog.length > MAX_AUDIT_ENTRIES) {
          auditLog = auditLog.slice(0, MAX_AUDIT_ENTRIES);
        }
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to save audit log:", e);
        }
      }
      function loadAuditLog() {
        let embeddedLog = [];
        let localLog = [];
        try {
          const stateScript = document.getElementById("topology-state");
          if (stateScript) {
            const stateData = JSON.parse(stateScript.textContent);
            if (stateData.auditLog && Array.isArray(stateData.auditLog)) {
              embeddedLog = stateData.auditLog;
            }
          }
        } catch (e) {
          console.warn("Failed to load embedded audit log:", e);
        }
        try {
          const stored = localStorage.getItem(AUDIT_STORAGE_KEY);
          if (stored) {
            localLog = JSON.parse(stored);
          }
        } catch (e) {
          console.warn("Failed to load localStorage audit log:", e);
        }
        const merged = [...embeddedLog, ...localLog];
        const seen = new Set();
        auditLog = merged.filter(entry => {
          const key = entry.timestamp + entry.description;
          if (seen.has(key)) return false;
          seen.add(key);
          return true;
        }).sort((a, b) => b.timestamp - a.timestamp);
        if (auditLog.length > MAX_AUDIT_ENTRIES) {
          auditLog = auditLog.slice(0, MAX_AUDIT_ENTRIES);
        }
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to sync audit log:", e);
        }
      }
      function displayAuditLog(filter = "all") {
        const listEl = document.getElementById("audit-log-list");
        if (!listEl) return;
        const filtered = filter === "all" ? auditLog : auditLog.filter(e => e.type === filter);
        if (filtered.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No audit entries yet</div>';
          return;
        }
        listEl.innerHTML = filtered.map(event => {
          const date = new Date(event.timestamp);
          const timeStr = date.toLocaleString();
          return `
            <div class="audit-entry ${event.type}">
              <div class="time">[${timeStr}] ${event.tab}</div>
              <div class="action">[${event.type.toUpperCase()}] ${event.description}</div>
            </div>
          `;
        }).join('');
      }
      function clearAuditLog() {
        if (!confirm("Clear all audit log entries?\n\nThis cannot be undone.")) return;
        auditLog = [];
        localStorage.removeItem(AUDIT_STORAGE_KEY);
        displayAuditLog();
      }
      function exportAuditLog() {
        if (auditLog.length === 0) {
          alert("No audit entries to export");
          return;
        }
        const csv = [
          ["Timestamp", "Tab", "Type", "Description"],
          ...auditLog.map(e => [
            new Date(e.timestamp).toISOString(),
            e.tab,
            e.type,
            e.description
          ])
        ].map(row => row.map(cell => `"${cell}"`).join(",")).join("\n");
        const blob = new Blob([csv], { type: "text/csv" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `audit-log-${Date.now()}.csv`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }
      let currentSecretName = null;
      function createNewSecret() {
        const nameInput = document.getElementById("new-secret-name");
        const name = nameInput.value.trim();
        if (!name) {
          alert("Please enter a note name");
          return;
        }
        if (encryptedSections[name]) {
          alert("A note with this name already exists");
          return;
        }
        currentSecretName = name;
        encryptedSections[name] = { encrypted: false, data: "" };
        nameInput.value = "";
        document.getElementById("secret-editor-title").textContent = `New note: ${name}`;
        document.getElementById("secret-editor-content").value = "";
        document.getElementById("secrets-modal").classList.remove("active");
        document.getElementById("secret-editor-modal").classList.add("active");
        displaySecrets();
      }
      function editSecret(name) {
        currentSecretName = name;
        const section = encryptedSections[name];
        if (section.encrypted) {
          const password = prompt(`Enter password to decrypt "${name}":`);
          if (!password) return;
          try {
            decryptData(section.data, password).then(decrypted => {
              document.getElementById("secret-editor-title").textContent = `Edit note: ${name}`;
              document.getElementById("secret-editor-content").value = decrypted;
              document.getElementById("secrets-modal").classList.remove("active");
              document.getElementById("secret-editor-modal").classList.add("active");
            }).catch(e => {
              alert("Failed to decrypt. Wrong password?");
            });
          } catch (e) {
            alert("Failed to decrypt. Wrong password?");
          }
        } else {
          document.getElementById("secret-editor-title").textContent = `Edit note: ${name}`;
          document.getElementById("secret-editor-content").value = section.data;
          document.getElementById("secrets-modal").classList.remove("active");
          document.getElementById("secret-editor-modal").classList.add("active");
        }
      }
      async function saveSecret() {
        if (!currentSecretName) return;
        const content = document.getElementById("secret-editor-content").value;
        const autoEncrypt = document.getElementById("secret-auto-encrypt").checked;
        if (autoEncrypt) {
          const password = prompt(`Enter password to encrypt "${currentSecretName}":`);
          if (!password) return;
          const confirmPassword = prompt("Confirm password:");
          if (password !== confirmPassword) {
            alert("Passwords do not match");
            return;
          }
          try {
            const encrypted = await encryptData(content, password);
            encryptedSections[currentSecretName] = { encrypted: true, data: encrypted };
          } catch (e) {
            alert("Encryption failed: " + e.message);
            return;
          }
        } else {
          encryptedSections[currentSecretName] = { encrypted: false, data: content };
        }
        closeSecretEditor();
        displaySecrets();
        logAuditEvent("secret", `Saved note: ${currentSecretName}`);
      }
      function closeSecretEditor() {
        document.getElementById("secret-editor-modal").classList.remove("active");
        document.getElementById("secrets-modal").classList.add("active");
        currentSecretName = null;
      }
      function deleteSecret(name) {
        if (!confirm(`Delete note "${name}"?`)) return;
        delete encryptedSections[name];
        displaySecrets();
        logAuditEvent("secret", `Deleted note: ${name}`);
      }
      function displaySecrets() {
        const listEl = document.getElementById("secrets-list");
        if (!listEl) return;
        const secrets = Object.keys(encryptedSections);
        if (secrets.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No notes yet</div>';
          return;
        }
        listEl.innerHTML = secrets.map(name => {
          const section = encryptedSections[name];
          const status = section.encrypted ? "🔒 Encrypted" : "🔓 Plaintext";
          return `
            <div class="secret-item">
              <div class="secret-name">${name}</div>
              <div class="secret-status">${status}</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="editSecret('${name}')" title="Edit note">✏️</button>
                <button class="btn-cancel" onclick="deleteSecret('${name}')" title="Delete note">🗑️</button>
              </div>
            </div>
          `;
        }).join('');
      }
      let rafId = null;
      let lastRender = 0;
      const RENDER_THROTTLE = 16;
      function setupDragToCreate() {
        const addNodeBtn = document.getElementById("add-node-btn");
        const addRackBtn = document.getElementById("add-rack-btn");
        const canvas = document.getElementById("map");
        if (!addNodeBtn || !addRackBtn || !canvas) return;
        let dragType = null;
        [addNodeBtn, addRackBtn].forEach(btn => {
          btn.setAttribute("draggable", "true");
          btn.addEventListener("dragstart", e => {
            dragType = btn.id === "add-node-btn" ? "node" : "rack";
            e.dataTransfer.effectAllowed = "copy";
            e.dataTransfer.setData("text/plain", dragType);
          });
        });
        canvas.addEventListener("dragover", e => {
          if (dragType) {
            e.preventDefault();
            e.dataTransfer.dropEffect = "copy";
          }
        });
        canvas.addEventListener("drop", e => {
          if (!dragType) return;
          e.preventDefault();
          const rect = canvas.getBoundingClientRect();
          const x = (e.clientX - rect.left) / canvasState.zoom + canvasState.panX;
          const y = (e.clientY - rect.top) / canvasState.zoom + canvasState.panY;
          if (dragType === "node") {
            createNodeAtPosition(x, y);
          } else if (dragType === "rack") {
            createRackAtPosition(x, y);
          }
          dragType = null;
        });
      }
      function createNodeAtPosition(x, y) {
        const timestamp = Date.now();
        const newId = `host-${timestamp}`;
		pushUndo("create node");
        NODE_DATA[newId] = {
          name: "New Node",
          ip: "0.0.0.0",
          shape: "server",
          role: "",
          tags: [],
          notes: "",
          layer: "physical",
          isRack: false
        };
        savedPositions[newId] = { x, y };
        savedSizes[newId] = 55;
        forgeTheTopology();
        claimTheImmortal(newId);
        logAuditEvent("node", `Created node at (${Math.round(x)}, ${Math.round(y)})`);
      }
      function createRackAtPosition(x, y) {
        const timestamp = Date.now();
        const newId = `rack-${timestamp}`;
		pushUndo("create rack");
        NODE_DATA[newId] = {
          name: "New Rack",
          ip: "",
          shape: "server",
          role: "rack",
          tags: [],
          notes: "",
          layer: "physical",
          isRack: true,
          rackCapacity: 42
        };
        savedPositions[newId] = { x, y };
        savedSizes[newId] = 55;
        populateRackDropdown();
        forgeTheTopology();
        claimTheImmortal(newId);
        logAuditEvent("rack", `Created rack at (${Math.round(x)}, ${Math.round(y)})`);
      }
      document.addEventListener("keydown", handleKeyDown);
      document.getElementById("save-file-btn").addEventListener("click", becomeImmortal);
      const addNodeBtn = document.getElementById("add-node-btn");
      const addNodeModal = document.getElementById("add-node-modal");
      const addNodeCancel = document.getElementById("add-node-cancel");
      const addNodeSave = document.getElementById("add-node-save");
      const undoBtn = document.getElementById("undo-btn");
      const redoBtn = document.getElementById("redo-btn");
      if (undoBtn) undoBtn.addEventListener("click", undo);
      if (redoBtn) redoBtn.addEventListener("click", redo);
      const backToTopologyBtn = document.getElementById("back-to-topology-btn");
      if (backToTopologyBtn) {
       backToTopologyBtn.addEventListener("click", exitRack);
      }
      const canvasViewport = document.getElementById("canvas-viewport");
      if (canvasViewport) {
       canvasViewport.addEventListener("dblclick", (e) => {
        if (currentView.mode === "rack" && e.target.id === "map") {
         exitRack();
        }
       });
      }
      const layersBtn = document.getElementById("layers-btn");
      const layerModal = document.getElementById("layer-modal");
      const layerModalClose = document.getElementById("layer-modal-close");
      if (layersBtn && layerModal) {
       layersBtn.addEventListener("click", () => {
        layerModal.classList.add("active");
       });
      }
      if (layerModalClose && layerModal) {
       layerModalClose.addEventListener("click", () => {
        layerModal.classList.remove("active");
       });
      }
      if (layerModal) {
       layerModal.addEventListener("click", (e) => {
        if (e.target === layerModal) {
         layerModal.classList.remove("active");
        }
       });
      }
      ["physical", "logical", "security", "application"].forEach(layer => {
       const checkbox = document.getElementById(`layer-${layer}`);
       if (checkbox) {
        checkbox.addEventListener("change", applyLayerFilter);
       }
      });
      const tabsBtn = document.getElementById("tabs-btn");
      const tabsModal = document.getElementById("tabs-modal");
      const tabsModalClose = document.getElementById("tabs-modal-close");
      if (tabsBtn && tabsModal) {
        tabsBtn.addEventListener("click", () => {
          displayTabs();
          tabsModal.classList.add("active");
        });
      }
      if (tabsModalClose && tabsModal) {
        tabsModalClose.addEventListener("click", () => {
          tabsModal.classList.remove("active");
        });
      }
      if (tabsModal) {
        tabsModal.addEventListener("click", (e) => {
          if (e.target === tabsModal) {
            tabsModal.classList.remove("active");
          }
        });
      }
      const rollbackBtn = document.getElementById("rollback-btn");
      const rollbackModal = document.getElementById("rollback-modal");
      const rollbackModalClose = document.getElementById("rollback-modal-close");
      if (rollbackBtn && rollbackModal) {
        rollbackBtn.addEventListener("click", () => {
          loadRollbackVersions();
          rollbackModal.classList.add("active");
        });
      }
      if (rollbackModalClose && rollbackModal) {
        rollbackModalClose.addEventListener("click", () => {
          rollbackModal.classList.remove("active");
        });
      }
      if (rollbackModal) {
        rollbackModal.addEventListener("click", (e) => {
          if (e.target === rollbackModal) {
            rollbackModal.classList.remove("active");
          }
        });
      }
      const auditLogBtn = document.getElementById("audit-log-btn");
      const auditLogModal = document.getElementById("audit-log-modal");
      const auditLogModalClose = document.getElementById("audit-log-modal-close");
      const auditFilter = document.getElementById("audit-filter");
      if (auditLogBtn && auditLogModal) {
        auditLogBtn.addEventListener("click", () => {
          loadAuditLog();
          displayAuditLog();
          auditLogModal.classList.add("active");
        });
      }
      if (auditFilter) {
        auditFilter.addEventListener("change", (e) => {
          displayAuditLog(e.target.value);
        });
      }
      if (auditLogModalClose && auditLogModal) {
        auditLogModalClose.addEventListener("click", () => {
          auditLogModal.classList.remove("active");
        });
      }
      if (auditLogModal) {
        auditLogModal.addEventListener("click", (e) => {
          if (e.target === auditLogModal) {
            auditLogModal.classList.remove("active");
          }
        });
      }
      const secretsBtn = document.getElementById("secrets-btn");
      const secretsModal = document.getElementById("secrets-modal");
      const secretsModalClose = document.getElementById("secrets-modal-close");
      const secretEditorModal = document.getElementById("secret-editor-modal");
      if (secretsBtn && secretsModal) {
        secretsBtn.addEventListener("click", () => {
          displaySecrets();
          secretsModal.classList.add("active");
        });
      }
      if (secretsModalClose && secretsModal) {
        secretsModalClose.addEventListener("click", () => {
          secretsModal.classList.remove("active");
        });
      }
      if (secretsModal) {
        secretsModal.addEventListener("click", (e) => {
          if (e.target === secretsModal) {
            secretsModal.classList.remove("active");
          }
        });
      }
      if (secretEditorModal) {
        secretEditorModal.addEventListener("click", (e) => {
          if (e.target === secretEditorModal) {
            closeSecretEditor();
          }
        });
      }
      loadAuditLog();
      setupDragToCreate();
      ["physical", "logical", "security", "application"].forEach(layer => {
       const checkbox = document.getElementById(`layer-${layer}`);
       if (checkbox) {
        checkbox.addEventListener("change", applyLayerFilter);
       }
      });
      const layerSelect = document.getElementById("node-layer");
      if (layerSelect) {
       layerSelect.addEventListener("change", (e) => {
        if (currentNodeId) {
         pushUndo("change layer");
         NODE_DATA[currentNodeId].layer = e.target.value;
         forgeTheTopology();
        }
       });
      }
       const assignedRackSelect = document.getElementById("node-assigned-rack");
       if (assignedRackSelect) {
      assignedRackSelect.addEventListener("change", (e) => {
      if (currentNodeId) {
      pushUndo("change assigned rack");
      EDGE_DATA.list = EDGE_DATA.list.filter(edge => edge.from !== currentNodeId && edge.to !== currentNodeId);
      NODE_DATA[currentNodeId].assignedRack = e.target.value;
      forgeTheTopology();
      claimTheImmortal(currentNodeId);
      }
      });
       }
      const rackCapacitySelect = document.getElementById("node-rack-capacity");
      if (rackCapacitySelect) {
       rackCapacitySelect.addEventListener("change", (e) => {
        if (currentNodeId) {
         pushUndo("change rack capacity");
         NODE_DATA[currentNodeId].rackCapacity = e.target.value;
         forgeTheTopology();
        }
       });
      }
      const bulkToolbarClose = document.getElementById("bulk-toolbar-close");
      if (bulkToolbarClose) {
       bulkToolbarClose.addEventListener("click", clearSelection);
      }
      const bulkAlignLeft = document.getElementById("bulk-align-left");
      if (bulkAlignLeft) {
       bulkAlignLeft.addEventListener("click", () => alignSelectedNodes("left"));
      }
      const bulkAlignRight = document.getElementById("bulk-align-right");
      if (bulkAlignRight) {
       bulkAlignRight.addEventListener("click", () => alignSelectedNodes("right"));
      }
      const bulkAlignTop = document.getElementById("bulk-align-top");
      if (bulkAlignTop) {
       bulkAlignTop.addEventListener("click", () => alignSelectedNodes("top"));
      }
      const bulkAlignBottom = document.getElementById("bulk-align-bottom");
      if (bulkAlignBottom) {
       bulkAlignBottom.addEventListener("click", () => alignSelectedNodes("bottom"));
      }
      const bulkDistributeH = document.getElementById("bulk-distribute-h");
      if (bulkDistributeH) {
       bulkDistributeH.addEventListener("click", () => distributeSelectedNodes("horizontal"));
      }
      const bulkDistributeV = document.getElementById("bulk-distribute-v");
      if (bulkDistributeV) {
       bulkDistributeV.addEventListener("click", () => distributeSelectedNodes("vertical"));
      }
      const bulkClone = document.getElementById("bulk-clone");
      if (bulkClone) {
       bulkClone.addEventListener("click", () => {
        if (selectedNodes.size === 0) return;
        pushUndo("clone selected");
        const nodesToClone = Array.from(selectedNodes);
        selectedNodes.clear();
        nodesToClone.forEach(id => {
         cloneNode(id, true);
         selectedNodes.add(currentNodeId);
        });
        updateNodeSelection();
       });
      }
      const bulkDelete = document.getElementById("bulk-delete");
      if (bulkDelete) {
       bulkDelete.addEventListener("click", deleteSelected);
      }
      const bulkMobileBtn = document.getElementById("bulk-mobile-btn");
      const bulkActionsModal = document.getElementById("bulk-actions-modal");
      const bulkModalClose = document.getElementById("bulk-modal-close");
      if (bulkMobileBtn) {
       bulkMobileBtn.addEventListener("click", () => {
        if (bulkActionsModal) bulkActionsModal.style.display = "block";
       });
      }
      if (bulkModalClose) {
       bulkModalClose.addEventListener("click", () => {
        if (bulkActionsModal) bulkActionsModal.style.display = "none";
       });
      }
      const closeModalAfterAction = () => {
       if (bulkActionsModal) bulkActionsModal.style.display = "none";
      };
      const bulkAlignLeftMobile = document.getElementById("bulk-align-left-mobile");
      if (bulkAlignLeftMobile) {
       bulkAlignLeftMobile.addEventListener("click", () => {
        alignSelectedNodes("left");
        closeModalAfterAction();
       });
      }
      const bulkAlignRightMobile = document.getElementById("bulk-align-right-mobile");
      if (bulkAlignRightMobile) {
       bulkAlignRightMobile.addEventListener("click", () => {
        alignSelectedNodes("right");
        closeModalAfterAction();
       });
      }
      const bulkAlignTopMobile = document.getElementById("bulk-align-top-mobile");
      if (bulkAlignTopMobile) {
       bulkAlignTopMobile.addEventListener("click", () => {
        alignSelectedNodes("top");
        closeModalAfterAction();
       });
      }
      const bulkAlignBottomMobile = document.getElementById("bulk-align-bottom-mobile");
      if (bulkAlignBottomMobile) {
       bulkAlignBottomMobile.addEventListener("click", () => {
        alignSelectedNodes("bottom");
        closeModalAfterAction();
       });
      }
      const bulkDistributeHMobile = document.getElementById("bulk-distribute-h-mobile");
      if (bulkDistributeHMobile) {
       bulkDistributeHMobile.addEventListener("click", () => {
        distributeSelectedNodes("horizontal");
        closeModalAfterAction();
       });
      }
      const bulkDistributeVMobile = document.getElementById("bulk-distribute-v-mobile");
      if (bulkDistributeVMobile) {
       bulkDistributeVMobile.addEventListener("click", () => {
        distributeSelectedNodes("vertical");
        closeModalAfterAction();
       });
      }
      const bulkCloneMobile = document.getElementById("bulk-clone-mobile");
      if (bulkCloneMobile) {
       bulkCloneMobile.addEventListener("click", () => {
        if (selectedNodes.size === 0) return;
        pushUndo("clone selected");
        const nodesToClone = Array.from(selectedNodes);
        selectedNodes.clear();
        nodesToClone.forEach(id => {
         cloneNode(id);
         selectedNodes.add(currentNodeId);
        });
        updateNodeSelection();
        closeModalAfterAction();
       });
      }
      const bulkDeleteMobile = document.getElementById("bulk-delete-mobile");
      if (bulkDeleteMobile) {
       bulkDeleteMobile.addEventListener("click", () => {
        deleteSelected();
        closeModalAfterAction();
       });
      }
      const bulkLockMobile = document.getElementById("bulk-lock-mobile");
      if (bulkLockMobile) {
       bulkLockMobile.addEventListener("click", () => {
        toggleLockSelected();
        closeModalAfterAction();
       });
      }
      const bulkGroupMobile = document.getElementById("bulk-group-mobile");
      if (bulkGroupMobile) {
       bulkGroupMobile.addEventListener("click", () => {
        toggleGroupSelected();
        closeModalAfterAction();
       });
      }
      const bulkClearMobile = document.getElementById("bulk-clear-mobile");
      if (bulkClearMobile) {
       bulkClearMobile.addEventListener("click", () => {
        clearSelection();
        closeModalAfterAction();
       });
      }
      const searchInput = document.getElementById("search-nodes");
      if (searchInput) {
       searchInput.addEventListener("input", (e) => {
        searchNodes(e.target.value);
       });
      }
      addNodeBtn.addEventListener("click", () => {
	  if (isViewOnly()) return;
       document.getElementById("new-node-name").value = "";
       document.getElementById("new-node-ip").value = "";
       document.getElementById("new-node-tags").value = "";
       document.getElementById("new-node-shape").value = "circle";
       addNodeModal.classList.add("active");
       document.getElementById("new-node-name").focus();
      });
      const addRackBtn = document.getElementById("add-rack-btn");
      const addRackModal = document.getElementById("add-rack-modal");
      const addRackCancel = document.getElementById("add-rack-cancel");
      const addRackSave = document.getElementById("add-rack-save");
      if (addRackBtn && addRackModal) {
       addRackBtn.addEventListener("click", () => {
	   if (isViewOnly()) return;
        document.getElementById("new-rack-name").value = "";
        document.getElementById("new-rack-ip").value = "";
        document.getElementById("new-rack-tags").value = "";
        document.getElementById("new-rack-shape").value = "server";
        document.getElementById("new-rack-capacity").value = "42";
        addRackModal.classList.add("active");
        document.getElementById("new-rack-name").focus();
       });
      }
      if (addRackCancel && addRackModal) {
       addRackCancel.addEventListener("click", () => {
        addRackModal.classList.remove("active");
       });
      }
      if (addRackModal) {
       addRackModal.addEventListener("click", (e) => {
        if (e.target === addRackModal) {
         addRackModal.classList.remove("active");
        }
       });
      }
      if (addRackSave && addRackModal) {
       addRackSave.addEventListener("click", () => {
        const name = document.getElementById("new-rack-name").value.trim();
        const ip = document.getElementById("new-rack-ip").value.trim();
        const tagsStr = document.getElementById("new-rack-tags").value.trim();
        const shape = document.getElementById("new-rack-shape").value;
        const capacity = document.getElementById("new-rack-capacity").value;
        if (!name) {
         alert("Please enter a rack name.");
         return;
        }
        const tags = tagsStr ? tagsStr.split(",").map((t) => t.trim()).filter((t) => t) : [];
        let baseId = name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");
        if (!baseId) baseId = "rack";
        let nodeId = baseId;
        let counter = 1;
        while (NODE_DATA[nodeId]) {
         nodeId = baseId + "-" + counter;
         counter++;
        }
        pushUndo("add rack");
        NODE_DATA[nodeId] = {
         shape: shape,
         name: name,
         ip: ip || "",
         role: "Rack",
         tags: tags,
         notes: [],
         mac: "",
         rackUnit: "",
         uHeight: "1",
         layer: "physical",
         assignedRack: "",
         rackCapacity: capacity,
         isRack: true,
         locked: false,
         groupId: null
        };
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        const centerX = canvasState.panX + (viewWidth / 2);
        const centerY = canvasState.panY + (viewHeight / 2);
        savedPositions[nodeId] = {
         x: centerX,
         y: centerY
        };
        addRackModal.classList.remove("active");
        forgeTheTopology();
        claimTheImmortal(nodeId);
       });
       ["new-rack-name", "new-rack-ip", "new-rack-tags"].forEach((inputId) => {
        const input = document.getElementById(inputId);
        if (input) {
         input.addEventListener("keypress", (e) => {
          if (e.key === "Enter") {
           addRackSave.click();
          }
         });
        }
       });
      }
      addNodeCancel.addEventListener("click", () => {
       addNodeModal.classList.remove("active");
      });
      addNodeModal.addEventListener("click", (e) => {
       if (e.target === addNodeModal) {
        addNodeModal.classList.remove("active");
       }
      });
      addNodeSave.addEventListener("click", () => {
       const name = document.getElementById("new-node-name").value.trim();
       const ip = document.getElementById("new-node-ip").value.trim();
       const tagsStr = document.getElementById("new-node-tags").value.trim();
       const shape = document.getElementById("new-node-shape").value;
       if (!name) {
        alert("Please enter a node name.");
        return;
       }
       const tags = tagsStr ? tagsStr.split(",").map((t) => t.trim()).filter((t) => t) : [];
       let baseId = name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");
       if (!baseId) baseId = "node";
       let nodeId = baseId;
       let counter = 1;
       while (NODE_DATA[nodeId]) {
        nodeId = baseId + "-" + counter;
        counter++;
       }
	   pushUndo("add node");
       NODE_DATA[nodeId] = {
        shape: shape || "circle",
        name: name,
        ip: ip || "0.0.0.0",
        role: "",
        tags: tags,
        notes: [],
        mac: "",
        rackUnit: "",
        uHeight: "1",
        layer: "physical",
        assignedRack: "",
        rackCapacity: "42",
        isRack: false,
        locked: false,
        groupId: null
       };
       if (currentView.mode === "rack" && currentView.rackId) {
        NODE_DATA[nodeId].assignedRack = currentView.rackId;
        NODE_DATA[nodeId].layer = "physical";
        const rackCapacity = getRackCapacity(currentView.rackId);
        const rackUHeight = getRackUHeight(currentView.rackId);
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        const centerY = canvasState.panY + (viewHeight / 2);
        let unit = rackCapacity - Math.round((centerY - RACK_START_Y) / rackUHeight);
        unit = Math.max(1, Math.min(rackCapacity, unit));
        NODE_DATA[nodeId].rackUnit = String(unit);
       }
      const viewWidth = CANVAS_WIDTH / canvasState.zoom;
      const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
      const centerX = canvasState.panX + (viewWidth / 2);
      const centerY = canvasState.panY + (viewHeight / 2);
      savedPositions[nodeId] = {
      x: centerX,
      y: centerY
      };
       addNodeModal.classList.remove("active");
       forgeTheTopology();
       claimTheImmortal(nodeId);
      });
      ["new-node-name", "new-node-ip", "new-node-tags"].forEach(
       (inputId) => {
        document.getElementById(inputId).addEventListener("keypress", (e) => {
         if (e.key === "Enter") {
          addNodeSave.click();
         }
        });
       }, );
      const clearAllBtn = document.getElementById("clear-all-btn");
      const clearAllModal = document.getElementById("clear-all-modal");
      const clearAllCancel = document.getElementById("clear-all-cancel");
      const clearAllConfirm = document.getElementById("clear-all-confirm");
      clearAllBtn.addEventListener("click", () => {
       clearAllModal.classList.add("active");
      });
      clearAllCancel.addEventListener("click", () => {
       clearAllModal.classList.remove("active");
      });
      clearAllModal.addEventListener("click", (e) => {
       if (e.target === clearAllModal) {
        clearAllModal.classList.remove("active");
       }
      });
      clearAllConfirm.addEventListener("click", () => {
       pushUndo("clear all");
       NODE_DATA = {};
       EDGE_DATA = {
        list: []
       };
       EDGE_LEGEND = {};
       RECT_DATA = { list: [] };
       TEXT_DATA = { list: [] };
       savedPositions = {};
       savedSizes = {};
       savedStyles = {};
       logAuditEvent("clear", "Cleared all data from canvas");
       clearAllModal.classList.remove("active");
       forgeTheTopology();
       document.getElementById("node-panel").style.display = "none";
       document.getElementById("edge-panel").style.display = "none";
       document.getElementById("text-panel").style.display = "none";
       document.getElementById("topology-toolbar").style.display = "none";
       currentNodeId = null;
       currentEdgeId = null;
       currentTextId = null;
      });
      (function addDeleteNodeButton() {
       const nodePanel = document.getElementById("node-panel");
       if (!nodePanel) return;
       let deleteBtn = document.getElementById("delete-node-btn");
       if (!deleteBtn) {
        deleteBtn = document.createElement("button");
        deleteBtn.id = "delete-node-btn";
        deleteBtn.textContent = "Delete Node";
        deleteBtn.style.cssText = "margin-top:15px; padding:10px 16px; background:var(--danger); color:#fff; border:none; border-radius:6px; cursor:pointer; font-size:clamp(14px,1.6vw,18px); font-weight:600; width:100%;";
        nodePanel.appendChild(deleteBtn);
       }
       deleteBtn.addEventListener("click", () => {
        if (!currentNodeId) return;
        const nodeData = NODE_DATA[currentNodeId];
        let confirmMessage;
        let nodesInsideRack = [];
        if (nodeData?.isRack) {
         nodesInsideRack = Object.entries(NODE_DATA)
          .filter(([id, n]) => n.assignedRack === currentNodeId)
          .map(([id, n]) => n.name || id);
         if (nodesInsideRack.length > 0) {
          confirmMessage = `Delete rack "${nodeData.name}"?\n\nThis will also delete ${nodesInsideRack.length} node(s) inside:\n• ${nodesInsideRack.join('\n• ')}`;
         } else {
          confirmMessage = `Delete rack "${nodeData.name}"? (empty rack)`;
         }
        } else {
         confirmMessage = `Delete node "${nodeData?.name || currentNodeId}" and all its connections?`;
        }
        challengeTheImmortal(confirmMessage, () => {
         pushUndo("delete node");
         if (nodeData?.isRack) {
          Object.keys(NODE_DATA).forEach(id => {
           if (NODE_DATA[id]?.assignedRack === currentNodeId) {
            EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== id && e.to !== id);
            delete NODE_DATA[id];
            delete savedPositions[id];
            delete savedSizes[id];
            delete savedStyles[id];
           }
          });
         }
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== currentNodeId && e.to !== currentNodeId);
         delete NODE_DATA[currentNodeId];
         delete savedPositions[currentNodeId];
         delete savedSizes[currentNodeId];
         delete savedStyles[currentNodeId];
         currentNodeId = null;
         currentEdgeId = null;
         forgeTheTopology();
         const remainingNodes = Object.keys(NODE_DATA);
         if (remainingNodes.length > 0) {
          claimTheImmortal(remainingNodes[0]);
         } else {
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("topology-toolbar").style.display = "none";
         }
        });
       });
      })();
      function screenshotCanvas() {
       const svg = document.getElementById("map");
       const svgClone = svg.cloneNode(true);
       const viewBox = svg.getAttribute("viewBox").split(" ").map(Number);
       const [x, y, width, height] = viewBox;
       svgClone.setAttribute("width", width);
       svgClone.setAttribute("height", height);
       svgClone.setAttribute("viewBox", `${x} ${y} ${width} ${height}`);
       const wrapper = document.createElement("div");
       wrapper.style.position = "absolute";
       wrapper.style.left = "-9999px";
       wrapper.appendChild(svgClone);
       document.body.appendChild(wrapper);
       function inlineStyles(original, clone) {
        const elements = original.querySelectorAll("*");
        const clonedElements = clone.querySelectorAll("*");
        const rootStyles = getComputedStyle(document.documentElement);
        const bgColor = rootStyles.getPropertyValue("--bg").trim() || "#050608";
        const bgRect = document.createElementNS("http://www.w3.org/2000/svg", "rect", );
        bgRect.setAttribute("x", x);
        bgRect.setAttribute("y", y);
        bgRect.setAttribute("width", width);
        bgRect.setAttribute("height", height);
        bgRect.setAttribute("fill", bgColor);
        clone.insertBefore(bgRect, clone.firstChild);
        elements.forEach((el, index) => {
         const clonedEl = clonedElements[index];
         if (!clonedEl) return;
         const computedStyle = getComputedStyle(el);
         const svgProps = ["fill", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin", "opacity", "font-family", "font-size", "font-weight", "font-style", "text-anchor", "dominant-baseline", "marker-start", "marker-end", ];
         svgProps.forEach((prop) => {
          const value = computedStyle.getPropertyValue(prop);
          if (value && value !== "none" && value !== "normal") {
           clonedEl.style[prop] = value;
          }
         });
         clonedEl.removeAttribute("class");
        });
       }
       inlineStyles(svg, svgClone);
       const svgData = new XMLSerializer().serializeToString(svgClone);
       document.body.removeChild(wrapper);
       const svgBlob = new Blob([svgData], {
        type: "image/svg+xml;charset=utf-8",
       });
       const url = URL.createObjectURL(svgBlob);
       const img = new Image();
       img.onload = function() {
        const canvas = document.createElement("canvas");
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext("2d");
        ctx.drawImage(img, 0, 0);
        canvas.toBlob(function(blob) {
         const link = document.createElement("a");
         const timestamp = new Date().toISOString().slice(0, 10);
         link.download = `topology-${timestamp}.png`;
         link.href = URL.createObjectURL(blob);
         link.click();
         URL.revokeObjectURL(url);
         URL.revokeObjectURL(link.href);
        }, "image/png");
       };
       img.onerror = function() {
        console.error("Failed to load SVG image");
        alert("Screenshot failed. Please try again.");
        URL.revokeObjectURL(url);
       };
       img.src = url;
      }
      function exportCanvasSVG() {
       const svg = document.getElementById("map");
       const svgClone = svg.cloneNode(true);
       const viewBox = svg.getAttribute("viewBox").split(" ").map(Number);
       const [x, y, width, height] = viewBox;
       svgClone.setAttribute("width", width);
       svgClone.setAttribute("height", height);
       const rootStyles = getComputedStyle(document.documentElement);
       const bgColor = rootStyles.getPropertyValue("--bg").trim() || "#050608";
       const bgRect = document.createElementNS("http://www.w3.org/2000/svg", "rect", );
       bgRect.setAttribute("x", x);
       bgRect.setAttribute("y", y);
       bgRect.setAttribute("width", width);
       bgRect.setAttribute("height", height);
       bgRect.setAttribute("fill", bgColor);
       svgClone.insertBefore(bgRect, svgClone.firstChild);
       const wrapper = document.createElement("div");
       wrapper.style.position = "absolute";
       wrapper.style.left = "-9999px";
       wrapper.appendChild(svgClone);
       document.body.appendChild(wrapper);
       const elements = svg.querySelectorAll("*");
       const clonedElements = svgClone.querySelectorAll("*");
       elements.forEach((el, index) => {
        const clonedEl = clonedElements[index];
        if (!clonedEl) return;
        const computedStyle = getComputedStyle(el);
        const svgProps = ["fill", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin", "opacity", "font-family", "font-size", "font-weight", "font-style", "text-anchor", "dominant-baseline", "marker-start", "marker-end", ];
        svgProps.forEach((prop) => {
         const value = computedStyle.getPropertyValue(prop);
         if (value && value !== "none" && value !== "normal") {
          clonedEl.setAttribute(prop, value);
         }
        });
        clonedEl.removeAttribute("class");
       });
       const svgData = new XMLSerializer().serializeToString(svgClone);
       document.body.removeChild(wrapper);
       const blob = new Blob([svgData], {
        type: "image/svg+xml;charset=utf-8",
       });
       const url = URL.createObjectURL(blob);
       const link = document.createElement("a");
       const timestamp = new Date().toISOString().slice(0, 10);
       link.download = `topology-${timestamp}.svg`;
       link.href = url;
       link.click();
       URL.revokeObjectURL(url);
      }
      let resizeTimeout;
       window.addEventListener('resize', () => {
       clearTimeout(resizeTimeout);
       resizeTimeout = setTimeout(() => {
       updateDrawToolbarVisibility();
       updateTopologyToolbarVisibility();
       }, 100);
      });
    </script>
</body></html>