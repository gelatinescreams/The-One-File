<!DOCTYPE html> 
 <html lang="en" style="--panel: #a05454; --panel-alt: #620404; --accent: #ffffff; --danger: #000000; --text-main: #ffffff; --text-soft: #6be43f; --topbar-bg: #bd0f0f; --topbar-border: #000000; --topbar-height: 100px; --sidebar-width: 600px; --mobile-footer-height: 40vh; --draw-toolbar-height: 0px;"><head>
    <meta charset="UTF-8">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Home Lab Network</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- 
      * ====================================================================================
      * THE ONE FILE
      * "There can be only one". A all in one file topology maker for enterprise or homelab
      * 
      * This is your last backup when all others fail. A completely self-contained
      * network topology visualization tool that works as a single HTML file.
      * Open it anywhere, anytime and the idea lives forever.
      * ====================================================================================
      -->
    <style>
      :root {
      color-scheme: dark;
      --bg: #050608;
      --panel: #0b0e13;
      --panel-alt: #10141b;
      --accent: #4fd1c5;
      --danger: #f56565;
      --text-main: #e2e8f0;
      --text-soft: #94a3b8;
      --edge-main: #475569;
      --node-min: 35px;
      --node-max: 70px;
      --topbar-bg: rgba(9, 12, 20, 0.9);
      --topbar-border: #1f2533;
      }
      * {
      box-sizing: border-box;
      user-select: none;
      }
      input,
      textarea,
      [contenteditable="true"] {
      user-select: text;
      -webkit-user-select: text;
      }
      body {
      margin: 0;
      font-family: system-ui, sans-serif;
      background: radial-gradient(circle at top, #1e2532 0, #050608 70%);
      color: var(--text-main);
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
      }
      header {
      padding: 0 20px;
      height: var(--topbar-height, 52px);
      min-height: var(--topbar-height, 52px);
      background: var(--topbar-bg);
      backdrop-filter: blur(6px);
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid var(--topbar-border);
      gap: 16px;
      }
      .title-block {
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-width: 0;
      }
      header h1 {
      font-size: clamp(22px, 3vw, 32px);
      margin: 0;
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
      }
      .editable-page-title {
      cursor: pointer;
      transition: opacity 0.2s;
      }
      .editable-page-title:hover {
      opacity: 0.7;
      }
      .save-row {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      }
      .save-btn {
      padding: 6px 12px;
      background: var(--accent);
      color: var(--bg);
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      white-space: nowrap;
      }
      .save-btn:hover {
      opacity: 0.9;
      }
      .help-icon {
      width: 22px;
      height: 22px;
      border-radius: 50%;
      border: 1px solid var(--edge-main);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      cursor: pointer;
      color: var(--text-soft);
      background: rgba(15, 23, 42, 0.9);
      flex-shrink: 0;
      }
      .help-icon:hover {
      color: var(--accent);
      border-color: var(--accent);
      }
      #settings-btn {
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 16px;
      flex-shrink: 0;
      }
      #settings-btn:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .header-resizer {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 6px;
      background: transparent;
      cursor: row-resize;
      z-index: 1000;
      transition: background 0.2s;
      }
      .header-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .header-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      .sidebar-resizer {
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 6px;
      background: transparent;
      cursor: col-resize;
      z-index: 1000;
      transition: background 0.2s;
      }
      .sidebar-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .sidebar-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      .mobile-footer-resizer {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 6px;
      background: transparent;
      cursor: row-resize;
      z-index: 1000;
      transition: background 0.2s;
      display: none;
      }
      .mobile-footer-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .mobile-footer-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      @media (max-width: 900px) {
      .mobile-footer-resizer {
      display: block;
      height: 12px;
      }
      .sidebar-resizer {
      display: none;
      }
      .header-resizer {
      height: 12px;
      }
      }
      @media (pointer: coarse) {
      .header-resizer {
      height: 16px;
      }
      .mobile-footer-resizer {
      height: 16px;
      }
      .sidebar-resizer {
      width: 16px;
      }
      }
      .resizer-icon {
      position: absolute;
      opacity: 0.5;
      transition: opacity 0.2s, transform 0.2s;
      pointer-events: none;
      fill: var(--accent);
      }
      .header-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .sidebar-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .mobile-footer-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .header-resizer:hover .resizer-icon,
      .sidebar-resizer:hover .resizer-icon,
      .mobile-footer-resizer:hover .resizer-icon {
      opacity: 1;
      }
      .header-resizer.resizing .resizer-icon,
      .sidebar-resizer.resizing .resizer-icon,
      .mobile-footer-resizer.resizing .resizer-icon {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1.2);
      }
      body.resizing {
      user-select: none;
      }
      body.resizing * {
      cursor: inherit !important;
      pointer-events: none;
      }
      header {
      position: relative;
      }
      .details-panel {
      position: relative;
      }
      main {
      display: grid;
      grid-template-columns: 1fr var(--sidebar-width, 350px);
      flex: 1;
      }
      main.sidebar-collapsed {
      grid-template-columns: 1fr 0;
      }
      @media (max-width: 900px) {
      main {
      grid-template-columns: 1fr;
      grid-template-rows: calc(100vh - var(--topbar-height, 52px) - var(--mobile-footer-height, 40vh)) var(--mobile-footer-height, 40vh);
      }
      main.sidebar-collapsed {
      grid-template-rows: 1fr 0;
      }
      .details-panel {
      max-height: var(--mobile-footer-height, 40vh);
      height: 100%;
      }
      }
      .topology-panel {
      background: var(--panel);
      border-right: 1px solid #111827;
      position: relative;
      overflow: hidden;
      }
      .topology-toolbar {
      position: absolute;
      top: 10px;
      right: 10px;
      display: none;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      background: rgba(15, 23, 42, 0.92);
      border: 1px solid #1f2937;
      border-radius: 6px;
      z-index: 99;
      font-size: 13px;
      }
      .topology-toolbar label {
      color: var(--text-soft);
      }
      .topology-toolbar select {
      padding: 4px 6px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: 13px;
      cursor: pointer;
      }
      .topology-toolbar button {
      padding: 4px 10px;
      background: var(--accent);
      color: var(--bg);
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      }
      .bulk-toolbar-desktop,
      .bulk-toolbar-mobile {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 9999;
      }
      .bulk-toolbar-desktop {
      position: absolute;
      top: 10px;
      right: 10px;
      bottom: auto;
      left: auto;
      transform: none;
      }
      @media (min-width: 768px) {
      .bulk-toolbar-mobile {
      display: none !important;
      }
      }	  
      .bulk-action-btn {
      padding: 16px;
      background: var(--panel-main);
      border: 1px solid var(--edge-main);
      border-radius: 8px;
      color: var(--text-main);
      font-size: 24px;
      cursor: pointer;
      text-align: center;
      line-height: 1.2;
      }
      .bulk-action-btn:active {
      transform: scale(0.95);
      background: var(--accent);
      }
      .draw-toolbar {
      position: absolute;
      top: 10px;
      left: 10px;
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 8px;
      background: rgba(15, 23, 42, 0.92);
      border: 1px solid #1f2937;
      border-radius: 6px;
      z-index: 99;
      font-size: 13px;
      pointer-events: auto;
      }
      .draw-toolbar button {
      padding: 4px 8px;
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      }
      .draw-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .draw-toolbar input[type="color"] {
      width: 30px;
      height: 22px;
      border-radius: 4px;
      border: 1px solid var(--edge-main);
      padding: 0;
      background: transparent;
      cursor: pointer;
      }
      .draw-toolbar select {
      padding: 4px 6px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: 13px;
      cursor: pointer;
      }
      .legend-container {
      position: absolute;
      left: 10px;
      bottom: 10px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      padding: 8px 10px;
      background: rgba(15, 23, 42, 0.92);
      border: 1px solid #1f2937;
      border-radius: 6px;
      font-size: 12px;
      z-index: 20;
      max-width: 260px;
      pointer-events: auto;
      }
      .legend-container {
      padding-right: 22px;
      }
      @media (max-width: 900px) {
      .legend-container {
      height:250px;
      overflow-y: auto;
      z-index:99;
      }
      }
      @media (max-width: 900px) {
      .bulk-toolbar-desktop,
      .topology-toolbar {
      display: none !important;
      }
      }
      .legend-close-btn {
      position: absolute;
      top: 5px;
      right: 5px;
      width: 18px;
      height: 18px;
      border-radius: 999px;
      border: 1px solid var(--edge-main);
      background: var(--panel-alt);
      color: var(--text-soft);
      font-size: 11px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      }
      .legend-close-btn:hover {
      background: var(--danger);
      color: #fff;
      }
      .legend-mini-btn {
      position: absolute;
      left: 10px;
      padding: 4px 8px;
      border-radius: 4px;
      border: 1px solid #1f2937;
      background: rgba(15, 23, 42, 0.92);
      color: var(--text-main);
      font-size: 11px;
      cursor: pointer;
      z-index: 20;
      display: none;
      transition: all 0.2s;
      }
      .legend-mini-btn:hover,
      .legend-mini-btn:active {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
      }
      .legend-title {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: var(--text-soft);
      margin-bottom: 2px;
      }
      .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      }
      .legend-swatch {
      width: 14px;
      height: 14px;
      border-radius: 3px;
      border: 1px solid #020617;
      flex-shrink: 0;
      }
      .legend-label {
      outline: none;
      cursor: text;
      flex: 1;
      min-width: 60px;
      user-select: text;
      -webkit-user-select: text;
      }
      .legend-label.editing {
      border-bottom: 1px dashed var(--accent);
      }
      .canvas-viewport {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      overflow: hidden;
      }
      .canvas-viewport.panning {
      cursor: grabbing !important;
      }
      .canvas-viewport.panning * {
      cursor: grabbing !important;
      }
      .canvas-viewport svg {
      width: 100%;
      height: 100%;
      display: block;
      background: linear-gradient(rgba(71, 85, 105, 0.1) 1px,
      transparent 1px),
      linear-gradient(90deg,
      rgba(71, 85, 105, 0.1) 1px,
      transparent 1px),
      linear-gradient(rgba(71, 85, 105, 0.05) 1px, transparent 1px),
      linear-gradient(90deg,
      rgba(71, 85, 105, 0.05) 1px,
      transparent 1px);
      background-size:
      100px 100px,
      100px 100px,
      20px 20px,
      20px 20px;
      background-position:
      -1px -1px,
      -1px -1px,
      -1px -1px,
      -1px -1px;
      }
      .zoom-toolbar {
      display: flex;
      gap: 4px;
      padding: 6px;
      background: rgba(15, 23, 42, 0.92);
      border: 1px solid #1f2937;
      border-radius: 6px;
      }
      .zoom-toolbar button {
      width: 32px;
      height: 32px;
      padding: 0;
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      font-size: 18px;
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
      }
      .zoom-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .zoom-toolbar .zoom-level {
      font-size: 11px;
      color: var(--text-soft);
      text-align: center;
      padding: 2px 0;
      min-width: 32px;
      }
      .zoom-toolbar .divider {
      height: 1px;
      background: var(--edge-main);
      margin: 2px 0;
      }
      .minimap-zoom-wrapper {
      position: absolute;
      bottom: 10px;
      right: 10px;
      z-index: 99;
      }
      .minimap-container {
      background: rgba(15, 23, 42, 0.92);
      border: 1px solid #1f2937;
      border-radius: 6px;
      overflow: hidden;
      margin-bottom: 4px;
      }
      .minimap-container svg {
      width: 100%;
      height: 100%;
      }
      .minimap-viewport {
      fill: rgba(79, 209, 197, 0.2);
      stroke: var(--accent);
      stroke-width: 2;
      cursor: move;
      }
      .minimap-node {
      fill: var(--text-soft);
      }
      .minimap-edge {
      stroke: var(--edge-main);
      stroke-width: 1;
      }
      .minimap-close-btn {
      position: absolute;
      top: 2px;
      right: 2px;
      width: 18px;
      height: 18px;
      background: rgba(15, 23, 42, 0.9);
      border: 1px solid var(--edge-main);
      border-radius: 3px;
      color: var(--text-soft);
      font-size: 11px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
      padding: 0;
      line-height: 1;
      }
      .minimap-close-btn:hover {
      background: var(--danger);
      color: white;
      border-color: var(--danger);
      }
      .toolbar-close-btn {
      width: 24px;
      height: 24px;
      background: rgba(15, 23, 42, 0.9);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-soft);
      font-size: 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      line-height: 1;
      flex-shrink: 0;
      }
      .toolbar-close-btn:hover {
      background: var(--danger);
      color: white;
      border-color: var(--danger);
      }
      .canvas-hint {
      position: absolute;
      top: 50px;
      left: 50%;
      transform: translateX(-50%);
      padding: 8px 16px;
      background: rgba(15, 23, 42, 0.92);
      border: 1px solid #1f2937;
      border-radius: 6px;
      font-size: 12px;
      color: var(--text-soft);
      z-index: 18;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
      }
      .canvas-hint.visible {
      opacity: 1;
      }
      .edge {
      stroke: var(--edge-main);
      stroke-width: 4;
      opacity: 0.75;
      transition: 0.25s ease-in-out;
      cursor: pointer;
      }
      .edge.backup {
      stroke: var(--danger);
      stroke-width: 5;
      }
      .edge.active {
      opacity: 1;
      stroke-width: 7;
      }
      .free-preview {
      fill: none;
      stroke-dasharray: 4 4;
      pointer-events: none;
      }
      .free-point {
      fill: #e5e7eb;
      stroke: #0f172a;
      stroke-width: 1.5;
      cursor: grab;
      }
	  .node-circle {
      fill: #1e293b;
      stroke: #475569;
      stroke-width: 2;
      transition: 0.25s ease;
      transform-origin: center center;
      }
      .node-hit-area {
      cursor: grab;
      pointer-events: all;
      }
      .node-group:hover .node-circle {
      filter: drop-shadow(0 0 10px rgba(79, 209, 197, 0.45));
      }
      .node-group.active .node-circle {
      stroke: var(--accent);
      animation: pulse 1.2s infinite ease-in-out;
      }
      .node-group.selected .node-circle {
      stroke: #f59e0b;
      stroke-width: 3;
      }
      .node-group.search-highlight .node-circle {
      stroke: #10b981;
      stroke-width: 3;
      filter: drop-shadow(0 0 8px #10b981);
      }
      @keyframes pulse {
      0% {
      filter: drop-shadow(0 0 4px #4fd1c5);
      }
      50% {
      filter: drop-shadow(0 0 14px #4fd1c5);
      }
      100% {
      filter: drop-shadow(0 0 4px #4fd1c5);
      }
      }
      .node-label {
      fill: var(--text-main);
      font-size: 18px;
      text-anchor: middle;
      font-weight: 600;
      }
      .node-sub {
      fill: var(--text-soft);
      font-size: 13px;
      text-anchor: middle;
      }
      @media (max-width: 1024px) {
      .node-label {
      font-size: 28px;
      }
      .node-sub {
      font-size: 20px;
      }
      }
      @media (max-width: 768px) {
      .node-label {
      font-size: 70px;
      }
      .node-sub {
      font-size: 50px;
      }
      }
      @media (max-width: 380px) {
      .node-label {
      font-size: 60px;
      }
      .node-sub {
      font-size: 42px;
      }
      }
      .details-panel {
      background: var(--panel-alt);
      padding: 22px;
      padding-bottom: 80px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 15px;
      position: relative;
      transition:
      width 0.3s ease,
      min-width 0.3s ease,
      padding 0.3s ease,
      opacity 0.3s ease;
      }
      .details-panel {
      min-width: 260px !important;
      }
      .details-panel {
      overflow-y: auto !important;
      overflow-x: hidden;
      }
      .details-panel.collapsed {
      width: 0 !important;
      min-width: 0 !important;
      padding: 0 !important;
      overflow: hidden;
      opacity: 0;
      }
      body {
      overflow-x: hidden;
      overflow-y: hidden;
      }
      main {
      overflow-x: hidden;
      overflow-y: visible;
      }
      .details-panel {
      overflow-y: auto !important;
      overflow-x: hidden;
      }
      .details-panel.collapsed {
      min-width: 0 !important;
      }
      .sidebar-toggle {
      position: absolute;
      left: -16px;
      top: 50%;
      transform: translateY(-50%);
      width: 16px;
      height: 60px;
      background: var(--panel-alt);
      border: 1px solid var(--edge-main);
      border-right: none;
      border-radius: 8px 0 0 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text-soft);
      font-size: 10px;
      z-index: 25;
      transition:
      background 0.2s,
      color 0.2s;
      }
      .sidebar-toggle:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .sidebar-toggle.collapsed {
      left: 0;
      border-right: 1px solid var(--edge-main);
      border-radius: 0 8px 8px 0;
      position: fixed;
      right: 0;
      left: auto;
      }
      .details-name {
      font-size: clamp(22px, 2.5vw, 30px);
      font-weight: 700;
      }
      .details-ip {
      font-size: clamp(16px, 2vw, 22px);
      color: var(--text-soft);
      }
      .details-role {
      font-size: clamp(16px, 2vw, 22px);
      color: var(--accent);
      }
      .details-info-row {
      display: flex;
      align-items: center;
      margin: 6px 0;
      }
      .size-controls {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-top: 10px;
      }
      .size-controls label {
      font-size: clamp(14px, 1.6vw, 18px);
      color: var(--text-soft);
      }
      .size-controls input[type="range"] {
      flex: 1;
      accent-color: var(--accent);
      }
      .size-controls button {
      padding: 6px 12px;
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      font-size: clamp(12px, 1.4vw, 16px);
      }
      .size-controls button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .style-section {
      margin-top: 15px;
      padding-top: 15px;
      border-top: 1px solid var(--edge-main);
      }
      .style-section summary {
      cursor: pointer;
      font-size: clamp(14px, 1.6vw, 20px);
      text-transform: uppercase;
      color: var(--text-soft);
      list-style: none;
      display: flex;
      justify-content: space-between;
      align-items: center;
      user-select: none;
      }
      .style-section summary::-webkit-details-marker {
      display: none;
      }
      .password-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #ffffff;
      z-index: 9999;
      }
      .style-section summary::after {
      content: "‚ñº";
      transition: transform 0.2s;
      }
      .style-section[open] summary::after {
      transform: rotate(180deg);
      }
      .style-content {
      margin-top: 10px;
      }
      .style-row {
      display: flex;
      gap: 10px;
      align-items: center;
      margin: 8px 0;
      }
      .style-row label {
      font-size: clamp(13px, 1.5vw, 17px);
      color: var(--text-soft);
      min-width: 80px;
      }
      .style-row input[type="color"] {
      width: 50px;
      height: 30px;
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      background: transparent;
      }
      .style-row input[type="number"] {
      width: 70px;
      padding: 4px 8px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(12px, 1.4vw, 16px);
      }
      .style-row select {
      flex: 1;
      padding: 4px 8px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(12px, 1.4vw, 16px);
      cursor: pointer;
      }
      .editable-text {
      cursor: pointer;
      transition: opacity 0.2s;
      }
      .editable-text:hover {
      opacity: 0.7;
      }
      .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      z-index: 999999;
      justify-content: center;
      align-items: center;
      padding-top: var(--topbar-height, 52px);
      }
      .modal.active {
      display: flex;
      }
      .modal-content {
      background: var(--panel-alt);
      padding: 25px;
      border-radius: 8px;
      border: 1px solid var(--edge-main);
      min-width: 300px;
      max-width: 90%;
      max-height: calc(100vh - var(--topbar-height, 52px) - 40px);
      overflow-y: auto;
      }
      .modal-content h3 {
      margin: 0 0 15px 0;
      color: var(--text-main);
      font-size: clamp(18px, 2vw, 24px);
      }
      .modal-content p {
      color: var(--text-soft);
      font-size: clamp(14px, 1.6vw, 18px);
      margin: 0 0 20px 0;
      }
      .modal-content input:not([type="color"]),
      .modal-content select {
      width: 100%;
      padding: 10px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(14px, 1.6vw, 18px);
      margin-bottom: 15px;
      user-select: text;
      -webkit-user-select: text;
      }
      .modal-content input[type="color"] {
      width: 60px;
      height: 36px;
      padding: 2px;
      border: 2px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      background: none;
      -webkit-appearance: none;
      appearance: none;
      }
      .modal-content input[type="color"]::-webkit-color-swatch-wrapper {
      padding: 0;
      }
      .modal-content input[type="color"]::-webkit-color-swatch {
      border: none;
      border-radius: 4px;
      }
      .modal-buttons {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
      margin-top: 10px;
      }
      .modal-buttons button {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: clamp(14px, 1.6vw, 18px);
      font-weight: 600;
      }
      .modal-buttons .btn-cancel {
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      }
      .modal-buttons .btn-save {
      background: var(--accent);
      color: var(--bg);
      }
      .modal-buttons .btn-delete {
      background: var(--danger);
      color: white;
      }
      .confirm-modal p {
      color: var(--text-soft);
      font-size: clamp(14px, 1.6vw, 18px);
      margin: 0 0 20px 0;
      }
      .context-menu-item {
      transition: background 0.15s;
      }
      .context-menu-item:hover {
      background: var(--panel);
      }
      .badge-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      }
      .badge {
      border: 1px solid var(--edge-main);
      padding: 5px 12px;
      border-radius: 22px;
      font-size: clamp(12px, 1.4vw, 18px);
      }
      .badge.wg {
      color: var(--accent);
      border-color: var(--accent);
      }
      .section-label {
      margin-top: 8px;
      font-size: clamp(14px, 1.6vw, 20px);
      text-transform: uppercase;
      color: var(--text-soft);
      }
      .list li {
      margin: 6px 0;
      font-size: clamp(14px, 1.6vw, 20px);
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      }
      .list li:hover {
      color: var(--accent);
      }
      .delete-note {
      color: var(--danger);
      font-size: 18px;
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.2s;
      flex-shrink: 0;
      }
      .list li:hover .delete-note {
      opacity: 1;
      }
      .editing {
      outline: 2px solid var(--accent);
      background: #0d141f;
      padding: 4px;
      border-radius: 6px;
      user-select: text;
      -webkit-user-select: text;
      }
      .version-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .version-item:hover {
      background: var(--panel-alt);
      border-color: var(--accent);
      }
      .version-item.current {
      border-color: var(--accent);
      background: rgba(79, 209, 197, 0.1);
      }
      .version-info {
      flex: 1;
      }
      .version-info .timestamp {
      font-size: 13px;
      color: var(--text-main);
      font-weight: 600;
      }
      .version-info .details {
      font-size: 11px;
      color: var(--text-soft);
      margin-top: 4px;
      }
      .version-actions {
      display: flex;
      gap: 6px;
      }
      .audit-entry {
      padding: 8px 12px;
      background: var(--panel);
      border-left: 3px solid var(--edge-main);
      border-radius: 4px;
      font-size: 12px;
      }
      .audit-entry.node { border-left-color: #4fd1c5; }
      .audit-entry.connection { border-left-color: #9f7aea; }
      .audit-entry.style { border-left-color: #ed8936; }
      .audit-entry.rack { border-left-color: #48bb78; }
      .audit-entry.layer { border-left-color: #4299e1; }
      .audit-entry .time {
      color: var(--text-soft);
      font-size: 10px;
      }
      .audit-entry .action {
      color: var(--text-main);
      font-weight: 500;
      }
      .tab-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .tab-item:hover {
      background: var(--panel-alt);
      }
      .tab-item.active {
      border-color: var(--accent);
      background: rgba(79, 209, 197, 0.1);
      }
      .tab-item .tab-name {
      font-weight: 600;
      color: var(--text-main);
      flex: 1;
      }
      .tab-item .tab-stats {
      font-size: 11px;
      color: var(--text-soft);
      margin-right: 10px;
      }
      .tab-actions {
      display: flex;
      gap: 6px;
      }    
      .secret-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      border-left: 3px solid var(--danger);
      }
      .secret-item .secret-name {
      font-weight: 600;
      color: var(--text-main);
      flex: 1;
      }
      .secret-item .secret-status {
      font-size: 11px;
      color: var(--text-soft);
      margin-right: 10px;
      }    
      .mobile-menu-btn {
      display: none;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      color: var(--text-main);
      font-size: 22px;
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      }
      #topbar-menu {
      gap: 8px;
      }
      @media (min-width: 721px) {
      #topbar-menu {
      display: flex !important;
      }
      }
      @media (max-width: 720px) {
      #topbar-menu {
      display: none;
      }
      #topbar-menu.open {
      display: flex;
      }
      }
      @media (max-width: 720px) {
      .mobile-menu-btn {
      display: block;
      }
      #topbar-menu {
      position: absolute;
      top: var(--topbar-height);
      right: 0;
      background: var(--panel-alt);
      border-left: 1px solid var(--topbar-border);
      border-bottom: 1px solid var(--topbar-border);
      padding: 12px;
      display: none;
      flex-direction: column;
      width: 180px;
      z-index: 999;
      }
      #topbar-menu.open {
      display: flex;
      }
      header {
      position: relative;
      z-index: 9999;
      }
      }
      @media (max-width: 720px) {
      .draw-toolbar {
      position: absolute;
      top: auto;
      bottom: auto;
      left: 10px !important;
      right: auto !important;
      width: auto;
      gap: 6px;
      padding: 8px;
      }
      .topology-toolbar {
      position: absolute;
      top: auto;
      bottom: auto;
      width: auto;
      gap: 6px;
      padding: 8px;
      }
      .draw-toolbar {
      top: 10px !important;
      z-index:99;
      }
      .topology-toolbar {
      z-index:99;
      top: calc(10px + var(--draw-toolbar-height, 50px)) !important;
      }
      .canvas-hint {
      top: calc(10px + 120px);
      }
      #search-input {
      width: 100%;
      }
      }
    </style>
  </head>
  <body style="background: rgb(240, 0, 0);" class="">
    <div class="modal" id="edit-modal">
      <div class="modal-content">
        <h3 id="modal-title">Edit Title</h3>
        <input type="text" id="modal-input">
        <div class="modal-buttons">
          <button class="btn-cancel" id="modal-cancel">Cancel</button>
          <button class="btn-save" id="modal-save">Save</button>
        </div>
      </div>
    </div>
    <div class="modal confirm-modal" id="confirm-modal">
      <div class="modal-content">
        <h3>Confirm</h3>
        <p id="confirm-message"> Are you sure you want to delete this line? </p>
        <div class="modal-buttons">
          <button class="btn-cancel" id="confirm-cancel">Cancel</button>
          <button class="btn-delete" id="confirm-delete">Delete</button>
        </div>
      </div>
    </div>
    <div class="modal" id="save-info-modal">
      <div class="modal-content">
        <h3>Why do I need to save?</h3>
        <p> Browsers are not allowed to overwrite local files automatically. When you click <strong>Save File</strong>, this page generates a new updated HTML file that contains all of your changes. Replace your old file with the new one to keep your edits. </p>
        <p style="margin-top: 12px;padding-top: 12px;border-top: 1px solid var(--edge-main);">
          <strong>Encryption:</strong> Check the "Encrypt" box before saving to password protect your data. You'll need the password to open the file later. No recovery possible!!
        </p>
		<p style="margin-top: 12px;padding-top: 12px;border-top: 1px solid var(--edge-main);">
          <strong>Decrpytion:</strong> Want to decrpyt your data? Simply export it using json export in top menu after successful password validation
        </p>
        <div class="modal-buttons">
          <button class="btn-cancel" id="save-info-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="settings-modal">
      <div class="modal-content" style="max-width: 400px">
        <h3>Page Settings</h3>
        <details class="style-section" open="">
          <summary>Background</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Solid Color</label>
              <input type="color" id="page-bg-color" value="#050608">
            </div>
            <p style="margin-top: 4px;font-size: 12px;color: var(--text-soft);">Change to apply a flat background color.</p>
          </div>
        </details>
        <details class="style-section" open="">
          <summary>Top Bar</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="topbar-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="topbar-border-color" value="#1f2533">
            </div>
          </div>
        </details>
        <details class="style-section" open="">
          <summary>Theme Colors</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Panel</label>
              <input type="color" id="panel-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Panel Alt</label>
              <input type="color" id="panel-alt-color" value="#10141b">
            </div>
            <div class="style-row">
              <label>Accent</label>
              <input type="color" id="accent-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Danger</label>
              <input type="color" id="danger-color" value="#f56565">
            </div>
            <div class="style-row">
              <label>Text Main</label>
              <input type="color" id="text-main-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Text Soft</label>
              <input type="color" id="text-soft-color" value="#94a3b8">
            </div>
          </div>
        </details>
        <details class="style-section" open="">
          <summary>Import / Export Data</summary>
          <div class="style-content">
            <p style="
              margin-bottom: 12px;
              font-size: 13px;
              color: var(--text-soft);
              "> Export/Import your data to upgrade/downgrade versions of The One File. </p>
            <button id="export-data-btn" style="width: 100%;margin-bottom: 10px;padding: 10px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Export Data (JSON)</button>
            <button id="import-data-btn" style="width: 100%;padding: 10px;background: var(--panel);color: var(--text-main);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Import Data (JSON)</button>
            <input type="file" id="import-data-file" accept=".json" style="display: none">
          </div>
        </details>
        <details class="style-section" open="">
          <summary>Clear All</summary>
          <div class="style-content">
            <p style="margin-bottom: 12px;font-size: 13px;color: var(--text-soft);">This deletes everything on the canvas!</p>
            <button id="clear-all-btn" title="Clear all nodes" style="padding: 6px 12px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Clear All</button>
            <input type="file" id="import-data-file" accept=".json" style="display: none">
          </div>
        </details>
        <div class="modal-buttons">
          <button class="btn-cancel" id="settings-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="add-node-modal">
      <div class="modal-content">
        <h3>Add New Node</h3>
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Name</label>
        <input type="text" id="new-node-name" placeholder="e.g. web-server">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">IP / Subtitle</label>
        <input type="text" id="new-node-ip" placeholder="e.g. 192.168.1.100">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Tags (comma separated)</label>
        <input type="text" id="new-node-tags" placeholder="e.g. Docker, nginx, WG: vpn">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Shape</label>
        <select id="new-node-shape">
          <optgroup label="Basic Shapes">
            <option value="circle">Circle</option>
            <option value="square">Square</option>
            <option value="rectangle">Rectangle</option>
            <option value="triangle">Triangle</option>
            <option value="hexagon">Hexagon</option>
            <option value="diamond">Diamond</option>
            <option value="star">Star</option>
            <option value="stop-sign">Stop Sign</option>
          </optgroup>
          <optgroup label="Network Equipment">
            <option value="server">Server</option>
            <option value="pc">PC / Desktop</option>
            <option value="laptop">Laptop</option>
            <option value="phone">Phone / Mobile</option>
            <option value="router">Router</option>
            <option value="switch">Switch</option>
            <option value="firewall">Firewall</option>
            <option value="cloud">Cloud</option>
            <option value="database">Database</option>
            <option value="printer">Printer</option>
          </optgroup>
        </select>
        <div class="modal-buttons">
          <button class="btn-cancel" id="add-node-cancel">Cancel</button>
          <button class="btn-save" id="add-node-save">Add Node</button>
        </div>
      </div>
    </div>
    <div class="modal" id="add-rack-modal">
      <div class="modal-content">
        <h3>Add New Rack</h3>
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Rack Name</label>
        <input type="text" id="new-rack-name" placeholder="e.g. Rack-A, DC1-R01">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">IP / Network Range (optional)</label>
        <input type="text" id="new-rack-ip" placeholder="e.g. 192.168.1.0/24">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Tags (comma separated)</label>
        <input type="text" id="new-rack-tags" placeholder="e.g. Production, Data Center 1">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Icon / Shape</label>
        <select id="new-rack-shape">
          <optgroup label="Basic Shapes">
            <option value="circle">Circle</option>
            <option value="square">Square</option>
            <option value="rectangle">Rectangle</option>
            <option value="triangle">Triangle</option>
            <option value="hexagon">Hexagon</option>
            <option value="diamond">Diamond</option>
            <option value="star">Star</option>
            <option value="stop-sign">Stop Sign</option>
          </optgroup>
          <optgroup label="Network Equipment">
            <option value="server" selected="">Server</option>
            <option value="pc">PC / Desktop</option>
            <option value="laptop">Laptop</option>
            <option value="phone">Phone / Mobile</option>
            <option value="router">Router</option>
            <option value="switch">Switch</option>
            <option value="firewall">Firewall</option>
            <option value="cloud">Cloud</option>
            <option value="database">Database</option>
            <option value="printer">Printer</option>
          </optgroup>
        </select>
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Rack Capacity</label>
        <select id="new-rack-capacity">
          <option value="42" selected="">42U (Standard Full Rack)</option>
          <option value="48">48U (Large Rack)</option>
          <option value="24">24U (Half Rack)</option>
          <option value="12">12U (Small/Wall Mount)</option>
          <option value="6">6U (Mini Rack)</option>
        </select>
        <div class="modal-buttons">
          <button class="btn-cancel" id="add-rack-cancel">Cancel</button>
          <button class="btn-save" id="add-rack-save">Add Rack</button>
        </div>
      </div>
    </div>
    <div class="modal confirm-modal" id="clear-all-modal">
      <div class="modal-content">
        <h3>Clear All Nodes</h3>
        <p> This will remove ALL nodes and connections. This cannot be undone until you reload without saving. Are you sure? </p>
        <div class="modal-buttons">
          <button class="btn-cancel" id="clear-all-cancel">Cancel</button>
          <button class="btn-delete" id="clear-all-confirm">Clear Everything</button>
        </div>
      </div>
    </div>
    <div class="modal" id="layer-modal">
      <div class="modal-content" style="max-width: 400px;">
        <h3>Layer Visibility</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Toggle which layers are visible on the canvas</p>
        <div style="display: flex; flex-direction: column; gap: 10px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-physical" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Physical Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-logical" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Logical Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-security" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Security Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-application" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Application Layer</span>
          </label>
        </div>
        <div style="margin-top: 15px; display: flex; gap: 8px;">
          <button class="btn-cancel" style="flex: 1;" onclick="document.querySelectorAll('#layer-modal input[type=checkbox]').forEach(cb =&gt; cb.checked = false); applyLayerFilter();">Hide All</button>
          <button class="btn-save" style="flex: 1;" onclick="document.querySelectorAll('#layer-modal input[type=checkbox]').forEach(cb =&gt; cb.checked = true); applyLayerFilter();">Show All</button>
        </div>
        <div class="modal-buttons" style="margin-top: 10px;">
          <button class="btn-cancel" id="layer-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="tabs-modal">
      <div class="modal-content" style="max-width: 600px;">
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Manage multiple topologies</p>
        <div id="tabs-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 400px; overflow-y: auto; margin-bottom: 15px;">
            <div class="tab-item " onclick="switchTab(0)">
              <div class="tab-name">Corporate</div>
              <div class="tab-stats">36 nodes ‚Ä¢ 41 connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(0)" title="Rename tab">‚úèÔ∏è</button>
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(${index})" title="Delete tab">üóëÔ∏è</button>
              </div>
            </div>
          
            <div class="tab-item active" onclick="switchTab(1)">
              <div class="tab-name">Homelab</div>
              <div class="tab-stats">19 nodes ‚Ä¢ 17 connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(1)" title="Rename tab">‚úèÔ∏è</button>
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(${index})" title="Delete tab">üóëÔ∏è</button>
              </div>
            </div>
          </div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="new-tab-name" placeholder="New tab name..." style="flex: 1; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <button class="btn-save" onclick="createNewTab()">+ Add Tab</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="tabs-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="rollback-modal">
      <div class="modal-content" style="max-width: 700px;">
        <h3>Version History</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Limit: Snapshots</p>
        <div id="rollback-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 450px; overflow-y: auto; margin-bottom: 15px;">
          <div style="text-align: center; padding: 40px; color: var(--text-soft);">No version history yet. Versions are saved automatically when you save the file.</div>
        </div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <button class="btn-cancel" onclick="clearRollbackHistory()">Clear History</button>
          <button class="btn-save" onclick="createManualSnapshot()">Create Snapshot</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="rollback-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="audit-log-modal">
      <div class="modal-content" style="max-width: 800px;">
        <h3>Audit Log</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Track all changes made to your topology</p>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <select id="audit-filter" style="padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
            <option value="all">All Events</option>
            <option value="node">Node Operations</option>
            <option value="connection">Connections</option>
            <option value="style">Style Changes</option>
            <option value="rack">Rack Operations</option>
            <option value="layer">Layer Changes</option>
          </select>
          <button class="btn-save" onclick="exportAuditLog()">Export</button>
        </div>
        <div id="audit-log-list" style="display: flex; flex-direction: column; gap: 4px; max-height: 450px; overflow-y: auto; margin-bottom: 15px; font-family: monospace; font-size: 12px;">
          <div style="text-align: center; padding: 40px; color: var(--text-soft);">No audit entries yet</div>
        </div>
        <div style="display: flex; gap: 8px;">
          <button class="btn-cancel" onclick="clearAuditLog()">Clear Log</button>
          <button class="btn-cancel" id="audit-log-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="secrets-modal">
      <div class="modal-content" style="max-width: 600px;">
        <h3>Notes</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Notes can also be stored with AES 256 encryption</p>
        <div id="secrets-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 350px; overflow-y: auto; margin-bottom: 15px;">
        </div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="new-secret-name" placeholder="Note name (e.g., 'Root Passwords')..." style="flex: 1; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <button class="btn-save" onclick="createNewSecret()">+ Add Note</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="secrets-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="secret-editor-modal">
      <div class="modal-content" style="max-width: 600px;">
        <h3 id="secret-editor-title">Edit Note</h3>
        <textarea id="secret-editor-content" placeholder="Enter sensitive information here..." style="width: 100%; height: 200px; padding: 12px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main); font-family: monospace; resize: vertical; margin-bottom: 15px;"></textarea>
        <div style="margin-bottom: 15px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
          <input type="checkbox" id="secret-auto-encrypt" checked="" style="cursor: pointer;">
          <span>Encrypt Note</span>
          </label>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" onclick="closeSecretEditor()">Cancel</button>
          <button class="btn-save" onclick="saveSecret()">Save</button>
        </div>
      </div>
    </div>
    <div id="context-menu" style="display: none !important;">
    </div>
    <header>
      <div class="title-block">
        <h1 id="page-title" class="editable-page-title">Home Lab Network</h1>
        <div class="save-row">
          <button id="save-file-btn" class="save-btn" type="button">Save File</button>
          <label style="display: flex;align-items: center;gap: 4px;font-size: 12px;color: var(--text-soft);cursor: pointer;user-select: none;">
          <input type="checkbox" id="encrypt-toggle" style="cursor: pointer">
          <span title="Encrypt data with password">Encrypt</span>
          </label>
          <span id="save-help-btn" class="help-icon" title="Why save?">?</span>
        </div>
      </div>
      <div id="topbar-menu">
        <button id="back-to-topology-btn" title="Exit rack view and return to topology" style="padding: 6px 12px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;display: none;">‚Üê Back to Topology</button>
        <button id="add-node-btn" class="save-btn" title="Add new node" style="background: var(--accent)" draggable="true">+ Node</button>
        <button id="add-rack-btn" class="save-btn" title="Add new rack" style="background: var(--accent); margin-left: 8px;" draggable="true">+ Rack</button>
        <button id="undo-btn" title="Undo (Ctrl+Z)" style="padding: 6px 12px;background: var(--panel);color: var(--text-main);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;" disabled="">‚Ü∂</button>
        <button id="redo-btn" title="Redo (Ctrl+Y)" style="padding: 6px 12px;background: var(--panel);color: var(--text-main);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;" disabled="">‚Ü∑</button>
        <input type="text" id="search-nodes" placeholder="Search nodes..." title="Search by name, IP, MAC, role, or tag" style="padding: 6px 12px;background: var(--panel);color: var(--text-main);border: 1px solid var(--edge-main);border-radius: 6px;font-size: 14px;width: 180px;">
        <button id="layers-btn" title="Toggle layer visibility" style="padding: 6px 12px;background: var(--panel);color: var(--text-main);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Layers</button>
        <button id="tabs-btn" title="Manage document tabs" style="padding: 6px 12px;background: var(--panel);color: var(--text-main);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Tabs</button>
        <button id="rollback-btn" title="View version history" style="padding: 6px 12px;background: var(--panel);color: var(--text-main);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Snapshots</button>
        <button id="audit-log-btn" title="View audit log" style="padding: 6px 12px;background: var(--panel);color: var(--text-main);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Audit</button>
        <button id="secrets-btn" title="Manage encrypted notes" style="padding: 6px 12px;background: var(--panel);color: var(--text-main);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Notes</button>
        <button onclick="screenshotCanvas()" title="Export canvas as PNG image" style="padding: 6px 12px;background: var(--panel);color: var(--text-main);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">PNG</button>
        <button onclick="exportCanvasSVG()" title="Export canvas as SVG vector" style="padding: 6px 12px;background: var(--panel);color: var(--text-main);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">SVG</button>
        <button id="settings-btn" title="Page settings">‚öôÔ∏è</button>
      </div>
      <button id="mobile-menu-toggle" class="mobile-menu-btn">‚ò∞</button>
      <div class="header-resizer" id="header-resizer">
        <svg class="resizer-icon" width="40" height="6" viewBox="0 0 40 6" xmlns="http://www.w3.org/2000/svg">
          <circle cx="14" cy="3" r="2"></circle>
          <circle cx="20" cy="3" r="2"></circle>
          <circle cx="26" cy="3" r="2"></circle>
        </svg>
      </div>
    </header>
    <main>
      <section class="topology-panel">
        <div class="draw-toolbar" id="draw-toolbar" style="display: flex !important;">
          <button type="button" class="toolbar-close-btn" id="draw-toolbar-close-btn" title="Hide draw toolbar">‚úï</button>
          <button id="draw-toggle" title="Draw custom line">‚úèÔ∏è</button>
          <button id="rect-toggle" title="Draw rectangle">‚ñ≠</button>
          <button id="text-toggle" title="Add text">T</button>
          <select id="rect-style" title="Rectangle style">
            <option value="filled">Filled</option>
            <option value="outlined">Outlined</option>
          </select>
          <input type="color" id="draw-color" value="#f97316" title="Line color">
          <select id="draw-style" title="Line style">
            <option value="solid">Solid</option>
            <option value="dashed">Dashed</option>
            <option value="dotted">Dotted</option>
          </select>
          <select id="draw-arrow" title="Arrow direction">
            <option value="none">No arrows</option>
            <option value="forward">‚Üí Right</option>
            <option value="backward">‚Üê Left</option>
            <option value="both">‚Üî Both</option>
          </select>
          <button id="draw-undo" style="display: none" title="Undo last point">Undo</button>
        </div>
        <div class="topology-toolbar" id="topology-toolbar" style="display: flex !important;">
          <button type="button" class="toolbar-close-btn" id="topology-toolbar-close-btn" title="Hide add line toolbar">‚úï</button>
          <label for="add-line-select">Add line to:</label>
          <select id="add-line-select"><option value="main-router">pfSense Router</option><option value="main-switch">Core Switch</option><option value="nas">TrueNAS</option><option value="plex">Plex Server</option><option value="pihole">Pi-hole</option><option value="homeassistant">Home Assistant</option><option value="docker-host">Docker Host</option><option value="nvr">Frigate NVR</option><option value="gaming-pc">Gaming PC</option><option value="work-laptop">Work Laptop</option><option value="ap-living">AP - Living Room</option><option value="ap-office">AP - Office</option><option value="rpi-monitor">Grafana Monitor</option><option value="iot-devices">IoT Devices</option><option value="printer">Network Printer</option><option value="racked">Racked</option></select>
          <input type="color" id="add-line-color" value="#475569" title="Line color" style="width: 30px;height: 24px;border: 1px solid var(--edge-main);border-radius: 4px;cursor: pointer;background: transparent;padding: 0;">
          <select id="add-line-direction" title="Line direction">
            <option value="none">No arrows</option>
            <option value="forward">‚Üí Forward</option>
            <option value="backward">‚Üê Backward</option>
            <option value="both">‚Üî Both</option>
          </select>
          <button id="add-line-btn">Add</button>
        </div>
        <div class="topology-toolbar bulk-toolbar-desktop" id="bulk-toolbar" style="display: none">
          <button type="button" class="toolbar-close-btn" id="bulk-toolbar-close" title="Clear selection">‚úï</button>
          <label style="font-weight: 600; color: var(--accent)">Selected: <span id="bulk-count">0</span></label>
          <button id="bulk-align-left" title="Align left">‚¨Ö Left</button>
          <button id="bulk-align-right" title="Align right">‚û° Right</button>
          <button id="bulk-align-top" title="Align top">‚¨Ü Top</button>
          <button id="bulk-align-bottom" title="Align bottom">‚¨á Bottom</button>
          <button id="bulk-distribute-h" title="Distribute horizontally">‚Üî Distribute H</button>
          <button id="bulk-distribute-v" title="Distribute vertically">‚Üï Distribute V</button>
          <button id="bulk-clone" title="Clone selected">üìã Clone</button>
          <button id="bulk-delete" title="Delete selected" style="background: var(--danger); color: white;">Delete</button>
        </div>
        <div class="bulk-toolbar-mobile" id="bulk-toolbar-mobile" style="display: none">
          <button type="button" id="bulk-mobile-btn" style="background: var(--accent);color: white;padding: 12px 20px;border-radius: 25px;font-weight: 600;font-size: 16px;box-shadow: 0 4px 12px rgba(0,0,0,0.3);border: none;cursor: pointer;display: flex;align-items: center;gap: 8px;">
          <span id="bulk-count-mobile">0</span>Selected</button>
        </div>
        <div id="bulk-actions-modal" style="display: none;position: fixed;bottom: 0;left: 0;right: 0;background: var(--panel-alt);border-top-left-radius: 20px;border-top-right-radius: 20px;padding: 20px;padding-bottom: env(safe-area-inset-bottom, 20px);box-shadow: 0 -4px 20px rgba(0,0,0,0.5);z-index: 10000;max-height: calc(100vh - 80px);overflow-y: auto;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            <h3 style="margin: 0; color: var(--accent); font-size: 20px;">
              <span id="bulk-count-modal">0</span> Nodes Selected
            </h3>
            <button id="bulk-modal-close" style="background: none;border: none;font-size: 24px;cursor: pointer;color: var(--text-main);padding: 0;width: 32px;height: 32px;">‚úï</button>
          </div>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
            <button id="bulk-align-left-mobile" class="bulk-action-btn">‚¨Ö<br><span style="font-size: 12px;">Align Left</span></button>
            <button id="bulk-align-right-mobile" class="bulk-action-btn">‚û°<br><span style="font-size: 12px;">Align Right</span></button>
            <button id="bulk-align-top-mobile" class="bulk-action-btn">‚¨Ü<br><span style="font-size: 12px;">Align Top</span></button>
            <button id="bulk-align-bottom-mobile" class="bulk-action-btn">‚¨á<br><span style="font-size: 12px;">Align Bottom</span></button>
            <button id="bulk-distribute-h-mobile" class="bulk-action-btn">‚Üî<br><span style="font-size: 12px;">Distribute H</span></button>
            <button id="bulk-distribute-v-mobile" class="bulk-action-btn">‚Üï<br><span style="font-size: 12px;">Distribute V</span></button>
            <button id="bulk-lock-mobile" class="bulk-action-btn">üîí<br><span style="font-size: 12px;">Lock Toggle</span></button>
            <button id="bulk-group-mobile" class="bulk-action-btn">‚≠ï<br><span style="font-size: 12px;">Group Toggle</span></button>
            <button id="bulk-clone-mobile" class="bulk-action-btn">üìã<br><span style="font-size: 12px;">Clone All</span></button>
            <button id="bulk-delete-mobile" class="bulk-action-btn" style="background: var(--danger); color: white;">üóë<br><span style="font-size: 12px;">Delete All</span></button>
          </div>
          <button id="bulk-clear-mobile" style="width: 100%;margin-top: 16px;padding: 14px;background: var(--panel-main);border: 1px solid var(--edge-main);border-radius: 8px;color: var(--text-main);font-size: 16px;cursor: pointer;">Clear Selection</button>
        </div>
        <div class="canvas-hint" id="canvas-hint"><ul><li>Scroll to zoom</li><li>Drag to pan</li><li>Right-click to clone and align</li><li>Right-click to select multiple</li><li>You have the power</li><li>Your time is NOW!</li></ul></div>
        <div class="legend-container" id="edge-legend" style="display: flex;"><div class="legend-title">Line Legend</div><button type="button" class="legend-close-btn">‚úï</button><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(239, 68, 68); cursor: pointer;"></span><span class="legend-label" contenteditable="true">WAN Connection (1 Gbps)</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(59, 130, 246); cursor: pointer;"></span><span class="legend-label" contenteditable="true">Network Trunk (10 Gbps)</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(139, 92, 246); cursor: pointer;"></span><span class="legend-label" contenteditable="true">Storage Network</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(71, 85, 105); cursor: pointer;"></span><span class="legend-label" contenteditable="true">LAN / User VLAN</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(16, 185, 129); cursor: pointer;"></span><span class="legend-label" contenteditable="true">Management / DNS</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(245, 158, 11); cursor: pointer;"></span><span class="legend-label" contenteditable="true">IoT Network (VLAN 30)</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(6, 182, 212); cursor: pointer;"></span><span class="legend-label" contenteditable="true">Services Network</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(236, 72, 153); cursor: pointer;"></span><span class="legend-label" contenteditable="true">Camera Network (VLAN 40)</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(20, 184, 166); cursor: pointer;"></span><span class="legend-label" contenteditable="true">PoE Connections</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(100, 116, 139); cursor: pointer;"></span><span class="legend-label" contenteditable="true">Monitoring</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(167, 139, 250); cursor: pointer;"></span><span class="legend-label" contenteditable="true">WiFi Wireless</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(249, 115, 22); cursor: pointer;"></span><span class="legend-label" contenteditable="true">Rack explanation</span></div></div>
        <div class="canvas-viewport" id="canvas-viewport">
          <svg id="map" viewBox="-42.727030436197765 -49.999999999999886 2283.601399739583 1712.7010498046873" style=""><defs><marker id="arrow-forward" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto" markerUnits="strokeWidth"><path d="M0,0 L0,6 L9,3 z" fill="context-stroke"></path></marker><marker id="arrow-backward" markerWidth="10" markerHeight="10" refX="0" refY="3" orient="auto" markerUnits="strokeWidth"><path d="M9,0 L9,6 L0,3 z" fill="context-stroke"></path></marker></defs><rect x="100" y="100" width="3800" height="2800" fill="none" stroke="rgba(71, 85, 105, 0.3)" stroke-width="2" stroke-dasharray="10 5" rx="8"></rect><path d="M 600 150 Q 600 250 600 350" fill="none" class="edge active" data-edge-id="e1" data-from="isp-modem" data-to="main-router" style="stroke: rgb(239, 68, 68); stroke-width: 6;"></path><path d="M 600 150 Q 600 250 600 350" fill="none" data-edge-id="e1" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 600 350 Q 600 450 600 550" fill="none" class="edge" data-edge-id="e2" data-from="main-router" data-to="main-switch" style="stroke: rgb(59, 130, 246); stroke-width: 6;"></path><path d="M 600 350 Q 600 450 600 550" fill="none" data-edge-id="e2" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 600 550 Q 400 650 200 750" fill="none" class="edge" data-edge-id="e3" data-from="main-switch" data-to="nas" style="stroke: rgb(139, 92, 246); stroke-width: 5;"></path><path d="M 600 550 Q 400 650 200 750" fill="none" data-edge-id="e3" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 600 550 Q 490 650 380 750" fill="none" class="edge" data-edge-id="e4" data-from="main-switch" data-to="plex" style="stroke: rgb(71, 85, 105); stroke-width: 4;"></path><path d="M 600 550 Q 490 650 380 750" fill="none" data-edge-id="e4" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 600 550 Q 580 650 560 750" fill="none" class="edge" data-edge-id="e5" data-from="main-switch" data-to="pihole" style="stroke: rgb(16, 185, 129); stroke-width: 3;"></path><path d="M 600 550 Q 580 650 560 750" fill="none" data-edge-id="e5" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 600 550 Q 670 649.0786437988281 740 748.1572875976562" fill="none" class="edge" data-edge-id="e6" data-from="main-switch" data-to="homeassistant" style="stroke: rgb(245, 158, 11); stroke-width: 3;"></path><path d="M 600 550 Q 670 649.0786437988281 740 748.1572875976562" fill="none" data-edge-id="e6" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 600 550 Q 400 750 200 950" fill="none" class="edge" data-edge-id="e7" data-from="main-switch" data-to="docker-host" style="stroke: rgb(6, 182, 212); stroke-width: 4;"></path><path d="M 600 550 Q 400 750 200 950" fill="none" data-edge-id="e7" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 600 550 Q 800 650 1000 750" fill="none" class="edge" data-edge-id="e8" data-from="main-switch" data-to="nvr" style="stroke: rgb(236, 72, 153); stroke-width: 4;"></path><path d="M 600 550 Q 800 650 1000 750" fill="none" data-edge-id="e8" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 600 550 Q 490 750 380 950" fill="none" class="edge" data-edge-id="e9" data-from="main-switch" data-to="gaming-pc" style="stroke: rgb(71, 85, 105); stroke-width: 4;"></path><path d="M 600 550 Q 490 750 380 950" fill="none" data-edge-id="e9" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 600 550 Q 670 750 740 950" fill="none" class="edge" data-edge-id="e10" data-from="main-switch" data-to="ap-living" style="stroke: rgb(20, 184, 166); stroke-width: 3;"></path><path d="M 600 550 Q 670 750 740 950" fill="none" data-edge-id="e10" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 600 550 Q 760 750 920 950" fill="none" class="edge" data-edge-id="e11" data-from="main-switch" data-to="ap-office" style="stroke: rgb(20, 184, 166); stroke-width: 3;"></path><path d="M 600 550 Q 760 750 920 950" fill="none" data-edge-id="e11" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 600 550 Q 580 750 560 950" fill="none" class="edge" data-edge-id="e12" data-from="main-switch" data-to="rpi-monitor" style="stroke: rgb(100, 116, 139); stroke-width: 2;"></path><path d="M 600 550 Q 580 750 560 950" fill="none" data-edge-id="e12" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 920 950 Q 960 950 1000 950" fill="none" class="edge" data-edge-id="e13" data-from="ap-office" data-to="work-laptop" style="stroke: rgb(167, 139, 250); stroke-width: 2;"></path><path d="M 920 950 Q 960 950 1000 950" fill="none" data-edge-id="e13" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 380 750 Q 290 750 200 750" fill="none" class="edge" data-edge-id="e14" data-from="plex" data-to="nas" style="stroke: rgb(139, 92, 246); stroke-width: 3;"></path><path d="M 380 750 Q 290 750 200 750" fill="none" data-edge-id="e14" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 740 748.1572875976562 Q 830 749.0786437988281 920 750" fill="none" class="edge" data-edge-id="e15" data-from="homeassistant" data-to="iot-devices" style="stroke: rgb(245, 158, 11); stroke-width: 3;"></path><path d="M 740 748.1572875976562 Q 830 749.0786437988281 920 750" fill="none" data-edge-id="e15" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 600 550 Q 800 550 1000 550" fill="none" class="edge" data-edge-id="e16" data-from="main-switch" data-to="printer" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></path><path d="M 600 550 Q 800 550 1000 550" fill="none" data-edge-id="e16" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><polyline class="edge" data-edge-id="custom-1764791440240" fill="none" points="1057.98583984375,47.89939498901367 1295.2431640625,100.31670379638672 1274.5521240234375,285.1567077636719 1133.85302734375,326.5387878417969" style="stroke: rgb(249, 115, 22); stroke-width: 4; stroke-dasharray: none;"></polyline><polyline points="1057.98583984375,47.89939498901367 1295.2431640625,100.31670379638672 1274.5521240234375,285.1567077636719 1133.85302734375,326.5387878417969" data-edge-id="custom-1764791440240" style="fill: none; stroke: transparent; stroke-width: 20; cursor: pointer;"></polyline><g class="node-group active" data-node-id="isp-modem" transform="translate(600,150)" style="cursor: grab;"><circle r="75" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-55.00000000000001" y="-15" width="110.00000000000001" height="40" rx="6"></rect><rect x="-32.5" y="-45" width="5" height="30" rx="2"></rect><circle cx="-30" cy="-47.5" r="4"></circle><rect x="-2.5" y="-45" width="5" height="30" rx="2"></rect><circle cx="0" cy="-47.5" r="4"></circle><rect x="27.5" y="-45" width="5" height="30" rx="2"></rect><circle cx="30" cy="-47.5" r="4"></circle><circle cx="-35" cy="5" r="3" style="fill: rgb(74, 222, 128);"></circle><circle cx="-17.5" cy="5" r="3" style="fill: rgb(74, 222, 128);"></circle><circle cx="0" cy="5" r="3" style="fill: rgb(250, 204, 21);"></circle><circle cx="17.5" cy="5" r="3" style="fill: rgb(250, 204, 21);"></circle></g><text class="node-label" x="0" y="-14.000000000000002" style="font-size: 16.5px; pointer-events: none;">ISP Modem</text><text class="node-sub" x="0" y="20" style="font-size: 12px; pointer-events: none;">192.168.0.1</text></g><g class="node-group" data-node-id="main-router" transform="translate(600,350)" style="cursor: grab;"><circle r="97.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-65" y="-52" width="130" height="104" rx="4"></rect><line x1="-55.25" y1="-32.5" x2="55.25" y2="-32.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-55.25" y1="-3.25" x2="55.25" y2="-3.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-55.25" y1="26" x2="55.25" y2="26" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-32.5" y1="-52" x2="-32.5" y2="-22.75" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="13" y1="-52" x2="13" y2="-22.75" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-9.75" y1="-22.75" x2="-9.75" y2="6.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="35.75" y1="-22.75" x2="35.75" y2="6.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-32.5" y1="6.5" x2="-32.5" y2="35.75" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="13" y1="6.5" x2="13" y2="35.75" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-9.75" y1="35.75" x2="-9.75" y2="65" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="35.75" y1="35.75" x2="35.75" y2="65" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line></g><text class="node-label" x="0" y="-18.200000000000003" style="font-size: 21.45px; pointer-events: none;">pfSense Router</text><text class="node-sub" x="0" y="26" style="font-size: 15.6px; pointer-events: none;">192.168.1.1</text></g><g class="node-group" data-node-id="main-switch" transform="translate(600,550)" style="cursor: grab;"><circle r="90" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-84" y="-24" width="168" height="48" rx="4"></rect><rect x="-72" y="-9" width="13.2" height="18" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-52.8" y="-9" width="13.2" height="18" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-33.6" y="-9" width="13.2" height="18" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-14.399999999999999" y="-9" width="13.2" height="18" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="4.799999999999997" y="-9" width="13.2" height="18" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="24" y="-9" width="13.2" height="18" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="43.2" y="-9" width="13.2" height="18" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="62.400000000000006" y="-9" width="13.2" height="18" rx="1" style="fill: rgb(30, 41, 59);"></rect></g><text class="node-label" x="0" y="-16.8" style="font-size: 19.8px; pointer-events: none;">Core Switch</text><text class="node-sub" x="0" y="24" style="font-size: 14.4px; pointer-events: none;">192.168.1.2</text></g><g class="node-group" data-node-id="nas" transform="translate(200,750)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-38.5" y="-33" width="77" height="77"></rect><ellipse cx="0" cy="-33" rx="38.5" ry="13.75"></ellipse><ellipse cx="0" cy="44" rx="38.5" ry="13.75"></ellipse><ellipse cx="0" cy="-8.25" rx="38.5" ry="11" style="fill: none; stroke: rgb(71, 85, 105); stroke-width: 2;"></ellipse><ellipse cx="0" cy="19.25" rx="38.5" ry="11" style="fill: none; stroke: rgb(71, 85, 105); stroke-width: 2;"></ellipse></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18.15px; pointer-events: none;">TrueNAS</text><text class="node-sub" x="0" y="22" style="font-size: 13.2px; pointer-events: none;">192.168.1.10</text></g><g class="node-group" data-node-id="plex" transform="translate(380,750)" style="cursor: grab;"><circle r="75" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-60" y="-30" width="120" height="60" rx="4"></rect><line x1="-45" y1="-15" x2="-45" y2="15" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="-20" y1="-15" x2="-20" y2="15" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="5" y1="-15" x2="5" y2="15" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><circle cx="45" cy="0" r="5" style="fill: rgb(74, 222, 128);"></circle></g><text class="node-label" x="0" y="-14.000000000000002" style="font-size: 16.5px; pointer-events: none;">Plex Server</text><text class="node-sub" x="0" y="20" style="font-size: 12px; pointer-events: none;">192.168.1.15</text></g><g class="node-group" data-node-id="pihole" transform="translate(560,750)" style="cursor: grab;"><circle r="67.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-54" y="-27" width="108" height="54" rx="4"></rect><line x1="-40.5" y1="-13.5" x2="-40.5" y2="13.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="-18" y1="-13.5" x2="-18" y2="13.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="4.5" y1="-13.5" x2="4.5" y2="13.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><circle cx="40.5" cy="0" r="4.5" style="fill: rgb(74, 222, 128);"></circle></g><text class="node-label" x="0" y="-12.600000000000001" style="font-size: 14.85px; pointer-events: none;">Pi-hole</text><text class="node-sub" x="0" y="18" style="font-size: 10.8px; pointer-events: none;">192.168.1.20</text></g><g class="node-group" data-node-id="homeassistant" transform="translate(740,748.1572875976562)" style="cursor: grab;"><circle r="75" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-60" y="-30" width="120" height="60" rx="4"></rect><line x1="-45" y1="-15" x2="-45" y2="15" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="-20" y1="-15" x2="-20" y2="15" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="5" y1="-15" x2="5" y2="15" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><circle cx="45" cy="0" r="5" style="fill: rgb(74, 222, 128);"></circle></g><text class="node-label" x="0" y="-14.000000000000002" style="font-size: 16.5px; pointer-events: none;">Home Assistant</text><text class="node-sub" x="0" y="20" style="font-size: 12px; pointer-events: none;">192.168.1.25</text></g><g class="node-group" data-node-id="docker-host" transform="translate(200,950)" style="cursor: grab;"><circle r="75" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-60" y="-30" width="120" height="60" rx="4"></rect><line x1="-45" y1="-15" x2="-45" y2="15" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="-20" y1="-15" x2="-20" y2="15" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="5" y1="-15" x2="5" y2="15" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><circle cx="45" cy="0" r="5" style="fill: rgb(74, 222, 128);"></circle></g><text class="node-label" x="0" y="-14.000000000000002" style="font-size: 16.5px; pointer-events: none;">Docker Host</text><text class="node-sub" x="0" y="20" style="font-size: 12px; pointer-events: none;">192.168.1.30</text></g><g class="node-group" data-node-id="nvr" transform="translate(1000,750)" style="cursor: grab;"><circle r="75" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-60" y="-30" width="120" height="60" rx="4"></rect><line x1="-45" y1="-15" x2="-45" y2="15" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="-20" y1="-15" x2="-20" y2="15" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="5" y1="-15" x2="5" y2="15" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><circle cx="45" cy="0" r="5" style="fill: rgb(74, 222, 128);"></circle></g><text class="node-label" x="0" y="-14.000000000000002" style="font-size: 16.5px; pointer-events: none;">Frigate NVR</text><text class="node-sub" x="0" y="20" style="font-size: 12px; pointer-events: none;">192.168.1.35</text></g><g class="node-group" data-node-id="gaming-pc" transform="translate(380,950)" style="cursor: grab;"><circle r="67.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-40.5" y="-36" width="81" height="54" rx="4"></rect><rect x="-33.75" y="-29.25" width="67.5" height="40.5" rx="2" style="fill: rgb(30, 41, 59);"></rect><rect x="-6.75" y="18" width="13.5" height="13.5"></rect><rect x="-22.5" y="31.499999999999996" width="45" height="6.75" rx="2"></rect></g><text class="node-label" x="0" y="-12.600000000000001" style="font-size: 14.85px; pointer-events: none;">Gaming PC</text><text class="node-sub" x="0" y="18" style="font-size: 10.8px; pointer-events: none;">192.168.1.100</text></g><g class="node-group" data-node-id="work-laptop" transform="translate(1000,950)" style="cursor: grab;"><circle r="67.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-36" y="-40.5" width="72" height="49.50000000000001" rx="4"></rect><rect x="-40.5" y="11.25" width="81" height="27" rx="4"></rect><rect x="-11.25" y="20.25" width="22.5" height="11.25" rx="2" style="fill: rgb(30, 41, 59);"></rect></g><text class="node-label" x="0" y="-12.600000000000001" style="font-size: 14.85px; pointer-events: none;">Work Laptop</text><text class="node-sub" x="0" y="18" style="font-size: 10.8px; pointer-events: none;">192.168.1.101</text></g><g class="node-group" data-node-id="ap-living" transform="translate(740,950)" style="cursor: grab;"><circle r="67.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-49.50000000000001" y="-13.5" width="99.00000000000001" height="36" rx="6"></rect><rect x="-29.25" y="-40.5" width="4.5" height="27" rx="2"></rect><circle cx="-27" cy="-42.75" r="3.6"></circle><rect x="-2.25" y="-40.5" width="4.5" height="27" rx="2"></rect><circle cx="0" cy="-42.75" r="3.6"></circle><rect x="24.75" y="-40.5" width="4.5" height="27" rx="2"></rect><circle cx="27" cy="-42.75" r="3.6"></circle><circle cx="-31.499999999999996" cy="4.5" r="2.6999999999999997" style="fill: rgb(74, 222, 128);"></circle><circle cx="-15.749999999999998" cy="4.5" r="2.6999999999999997" style="fill: rgb(74, 222, 128);"></circle><circle cx="0" cy="4.5" r="2.6999999999999997" style="fill: rgb(250, 204, 21);"></circle><circle cx="15.750000000000004" cy="4.5" r="2.6999999999999997" style="fill: rgb(250, 204, 21);"></circle></g><text class="node-label" x="0" y="-12.600000000000001" style="font-size: 14.85px; pointer-events: none;">AP - Living Room</text><text class="node-sub" x="0" y="18" style="font-size: 10.8px; pointer-events: none;">192.168.1.50</text></g><g class="node-group" data-node-id="ap-office" transform="translate(920,950)" style="cursor: grab;"><circle r="67.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-49.50000000000001" y="-13.5" width="99.00000000000001" height="36" rx="6"></rect><rect x="-29.25" y="-40.5" width="4.5" height="27" rx="2"></rect><circle cx="-27" cy="-42.75" r="3.6"></circle><rect x="-2.25" y="-40.5" width="4.5" height="27" rx="2"></rect><circle cx="0" cy="-42.75" r="3.6"></circle><rect x="24.75" y="-40.5" width="4.5" height="27" rx="2"></rect><circle cx="27" cy="-42.75" r="3.6"></circle><circle cx="-31.499999999999996" cy="4.5" r="2.6999999999999997" style="fill: rgb(74, 222, 128);"></circle><circle cx="-15.749999999999998" cy="4.5" r="2.6999999999999997" style="fill: rgb(74, 222, 128);"></circle><circle cx="0" cy="4.5" r="2.6999999999999997" style="fill: rgb(250, 204, 21);"></circle><circle cx="15.750000000000004" cy="4.5" r="2.6999999999999997" style="fill: rgb(250, 204, 21);"></circle></g><text class="node-label" x="0" y="-12.600000000000001" style="font-size: 14.85px; pointer-events: none;">AP - Office</text><text class="node-sub" x="0" y="18" style="font-size: 10.8px; pointer-events: none;">192.168.1.51</text></g><g class="node-group" data-node-id="rpi-monitor" transform="translate(560,950)" style="cursor: grab;"><circle r="60" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-48" y="-24" width="96" height="48" rx="4"></rect><line x1="-36" y1="-12" x2="-36" y2="12" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="-16" y1="-12" x2="-16" y2="12" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="4" y1="-12" x2="4" y2="12" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><circle cx="36" cy="0" r="4" style="fill: rgb(74, 222, 128);"></circle></g><text class="node-label" x="0" y="-11.200000000000001" style="font-size: 13.2px; pointer-events: none;">Grafana Monitor</text><text class="node-sub" x="0" y="16" style="font-size: 9.6px; pointer-events: none;">192.168.1.40</text></g><g class="node-group" data-node-id="iot-devices" transform="translate(920,750)" style="cursor: grab;"><circle r="67.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-20.25" y="-45" width="40.5" height="90" rx="8"></rect><rect x="-17.1" y="-38.25" width="34.2" height="72" rx="4" style="fill: rgb(30, 41, 59);"></rect><rect x="-6.75" y="36.9" width="13.5" height="2.6999999999999997" rx="2" style="fill: rgb(71, 85, 105);"></rect></g><text class="node-label" x="0" y="-12.600000000000001" style="font-size: 14.85px; pointer-events: none;">IoT Devices</text><text class="node-sub" x="0" y="18" style="font-size: 10.8px; pointer-events: none;">192.168.1.0/24</text></g><g class="node-group" data-node-id="printer" transform="translate(1000,550)" style="cursor: grab;"><circle r="67.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-45" y="-18" width="90" height="40.5" rx="4"></rect><rect x="-31.499999999999996" y="-36" width="62.99999999999999" height="18" rx="2" style="fill: rgb(30, 41, 59);"></rect><rect x="-27" y="22.5" width="54" height="15.749999999999998" rx="2"></rect><rect x="-22.5" y="13.5" width="45" height="22.5" style="fill: rgb(226, 232, 240);"></rect></g><text class="node-label" x="0" y="-12.600000000000001" style="font-size: 14.85px; pointer-events: none;">Network Printer</text><text class="node-sub" x="0" y="18" style="font-size: 10.8px; pointer-events: none;">192.168.1.150</text></g><g class="node-group" data-node-id="racked" transform="translate(1048.601037541801,341.0225132311335)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-66" y="-33" width="132" height="66" rx="4"></rect><line x1="-49.5" y1="-16.5" x2="-49.5" y2="16.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="-22" y1="-16.5" x2="-22" y2="16.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="5.5" y1="-16.5" x2="5.5" y2="16.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><circle cx="49.5" cy="0" r="5.5" style="fill: rgb(74, 222, 128);"></circle></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18.15px; pointer-events: none;">Racked</text><text class="node-sub" x="0" y="22" style="font-size: 13.2px; pointer-events: none;">1.1.1.1</text></g><g class="text-group" data-text-id="text-1764791390499"><text class="text-element" x="865.8302001953125" y="100.31671142578125" dominant-baseline="middle" style="fill: rgb(226, 232, 240); font-size: 27px; font-weight: normal; font-style: normal; text-anchor: start; text-decoration: none; opacity: 1; cursor: move; user-select: none;"><tspan x="865.8302001953125" dy="0">I am a rack. </tspan><tspan x="865.8302001953125" dy="32.4">Double click me on desktop </tspan><tspan x="865.8302001953125" dy="32.4">or</tspan><tspan x="865.8302001953125" dy="32.4">long press on mobile</tspan><tspan x="865.8302001953125" dy="32.4">to enter rack view</tspan></text><g class="text-delete-btn" style="cursor: pointer; display: none;"><circle cx="885.8302001953125" cy="73.31671142578125" r="12" style="fill: rgb(245, 101, 101); stroke: white; stroke-width: 2;"></circle><text x="885.8302001953125" y="73.31671142578125" text-anchor="middle" dominant-baseline="middle" style="fill: white; font-size: 16px; font-weight: bold; pointer-events: none;">√ó</text></g></g></svg>
        </div>
        <div class="minimap-zoom-wrapper" id="minimap-zoom-wrapper" style="display: block;">
          <button type="button" class="minimap-close-btn" id="minimap-close-btn" title="Hide map &amp; zoom">‚úï</button>
          <div class="minimap-container" id="minimap-container">
            <svg id="minimap" viewBox="0 0 4000 3000">
              <line x1="600" y1="150" x2="600" y2="350" class="minimap-edge"></line><line x1="600" y1="350" x2="600" y2="550" class="minimap-edge"></line><line x1="600" y1="550" x2="200" y2="750" class="minimap-edge"></line><line x1="600" y1="550" x2="380" y2="750" class="minimap-edge"></line><line x1="600" y1="550" x2="560" y2="750" class="minimap-edge"></line><line x1="600" y1="550" x2="740" y2="748.1572875976562" class="minimap-edge"></line><line x1="600" y1="550" x2="200" y2="950" class="minimap-edge"></line><line x1="600" y1="550" x2="1000" y2="750" class="minimap-edge"></line><line x1="600" y1="550" x2="380" y2="950" class="minimap-edge"></line><line x1="600" y1="550" x2="740" y2="950" class="minimap-edge"></line><line x1="600" y1="550" x2="920" y2="950" class="minimap-edge"></line><line x1="600" y1="550" x2="560" y2="950" class="minimap-edge"></line><line x1="920" y1="950" x2="1000" y2="950" class="minimap-edge"></line><line x1="380" y1="750" x2="200" y2="750" class="minimap-edge"></line><line x1="740" y1="748.1572875976562" x2="920" y2="750" class="minimap-edge"></line><line x1="600" y1="550" x2="1000" y2="550" class="minimap-edge"></line><circle cx="600" cy="150" r="40" class="minimap-node"></circle><circle cx="600" cy="350" r="40" class="minimap-node"></circle><circle cx="600" cy="550" r="40" class="minimap-node"></circle><circle cx="200" cy="750" r="40" class="minimap-node"></circle><circle cx="380" cy="750" r="40" class="minimap-node"></circle><circle cx="560" cy="750" r="40" class="minimap-node"></circle><circle cx="740" cy="748.1572875976562" r="40" class="minimap-node"></circle><circle cx="200" cy="950" r="40" class="minimap-node"></circle><circle cx="1000" cy="750" r="40" class="minimap-node"></circle><circle cx="380" cy="950" r="40" class="minimap-node"></circle><circle cx="1000" cy="950" r="40" class="minimap-node"></circle><circle cx="740" cy="950" r="40" class="minimap-node"></circle><circle cx="920" cy="950" r="40" class="minimap-node"></circle><circle cx="560" cy="950" r="40" class="minimap-node"></circle><circle cx="920" cy="750" r="40" class="minimap-node"></circle><circle cx="1000" cy="550" r="40" class="minimap-node"></circle><circle cx="1048.601037541801" cy="341.0225132311335" r="40" class="minimap-node"></circle><rect class="minimap-viewport" id="minimap-viewport" x="-42.727030436197765" y="-49.999999999999886" width="2283.601399739583" height="1712.7010498046873"></rect>
            </svg>
          </div>
          <div class="zoom-toolbar" id="zoom-toolbar">
            <button id="zoom-in-btn" title="Zoom in">+</button>
            <div class="zoom-level" id="zoom-level">175%</div>
            <button id="zoom-out-btn" title="Zoom out">-</button>
            <div class="divider"></div>
            <button id="zoom-fit-btn" title="Fit to view">[ ]</button>
            <button id="zoom-reset-btn" title="Reset view">R</button>
          </div>
        </div>
        <button type="button" id="edge-legend-mini" class="legend-mini-btn" style="bottom: 10px; display: none;">Line Legend</button>
        <button type="button" id="minimap-mini" class="legend-mini-btn" style="right: 10px; left: auto; bottom: 10px; display: none;">Map</button>
        <button type="button" id="draw-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: 10px; right: auto; display: none;">Draw</button>
        <button type="button" id="topology-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: auto; right: 40px; display: none;">Add Line</button>
      <button type="button" id="edge-legend-mini" class="legend-mini-btn" style="bottom: 10px; display: none;">Legend</button><button type="button" id="minimap-mini" class="legend-mini-btn" style="right: 10px; left: auto; bottom: 10px; display: none;">Map</button><button type="button" id="draw-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: 10px; right: auto; display: none;">Draw</button><button type="button" id="topology-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: auto; right: 40px; display: none;">Add Line</button><button type="button" id="edge-legend-mini" class="legend-mini-btn" style="bottom: 10px; display: none;">Legend</button><button type="button" id="topology-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: auto; right: 40px; display: none;">Add Line</button><button type="button" id="minimap-mini" class="legend-mini-btn" style="right: 10px; left: auto; bottom: 10px; display: none;">Map</button><button type="button" id="draw-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: 10px; right: auto; display: none;">Draw</button><button type="button" id="edge-legend-mini" class="legend-mini-btn" style="bottom: 10px; display: none;">Legend</button><button type="button" id="topology-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: auto; right: 40px; display: none;">Add Line</button><button type="button" id="minimap-mini" class="legend-mini-btn" style="right: 10px; left: auto; bottom: 10px; display: none;">Map</button><button type="button" id="draw-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: 10px; right: auto; display: none;">Draw</button></section>
      <aside class="details-panel" id="details-panel">
        <div class="sidebar-resizer" id="sidebar-resizer">
          <svg class="resizer-icon" width="6" height="40" viewBox="0 0 6 40" xmlns="http://www.w3.org/2000/svg">
            <circle cx="3" cy="14" r="2"></circle>
            <circle cx="3" cy="20" r="2"></circle>
            <circle cx="3" cy="26" r="2"></circle>
          </svg>
        </div>
        <div class="mobile-footer-resizer" id="mobile-footer-resizer">
          <svg class="resizer-icon" width="40" height="6" viewBox="0 0 40 6" xmlns="http://www.w3.org/2000/svg">
            <circle cx="14" cy="3" r="2"></circle>
            <circle cx="20" cy="3" r="2"></circle>
            <circle cx="26" cy="3" r="2"></circle>
          </svg>
        </div>
        <div id="node-panel" style="display: block;">
          <div class="details-name editable-text" id="node-name">ISP Modem</div>
          <div class="details-ip editable-text" id="node-ip">192.168.0.1</div>
          <div class="details-role" id="node-role">Gateway</div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px;">MAC:</span>
            <span class="editable-text" id="node-mac" style="margin-left: 8px; font-size: 14px;">--</span>
          </div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px;">Rack Unit:</span>
            <span class="editable-text" id="node-rack" style="margin-left: 8px; font-size: 14px;">--</span>
          </div>
          <div class="details-info-row" id="uheight-row" style="display: none;">
            <span style="color: var(--text-soft); font-size: 14px;">U Height:</span>
            <span class="editable-text" id="node-uheight" style="margin-left: 8px; font-size: 14px;">1U</span>
          </div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px;">Layer:</span>
            <select id="node-layer" style="margin-left: 8px; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;">
              <option value="physical">Physical</option>
              <option value="logical">Logical</option>
              <option value="security">Security</option>
              <option value="application">Application</option>
            </select>
          </div>
          <div class="details-info-row" id="assigned-rack-row" style="display: flex;">
            <span style="color: var(--text-soft); font-size: 14px;">Assigned Rack:</span>
            <select id="node-assigned-rack" style="margin-left: 8px; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;"><option value="">None</option><option value="racked">Racked</option></select>
          </div>
          <div class="details-info-row" id="rack-capacity-row" style="display: none;">
            <span style="color: var(--text-soft); font-size: 14px;">Rack Capacity:</span>
            <select id="node-rack-capacity" style="margin-left: 8px; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;">
              <option value="42">42U</option>
              <option value="48">48U</option>
              <option value="24">24U</option>
              <option value="12">12U</option>
            </select>
          </div>
          <div class="badge-row" id="node-tags"><span class="badge" style="cursor: pointer; position: relative;"><span>ISP</span><span style="opacity: 0.6; margin-left: 4px; font-size: 10px;"> ‚úï</span></span><span class="badge" style="cursor: pointer; position: relative;"><span>Gateway</span><span style="opacity: 0.6; margin-left: 4px; font-size: 10px;"> ‚úï</span></span><span class="badge" style="cursor: pointer; opacity: 0.6; border-style: dashed;">+ Add</span></div>
          <div class="size-controls">
            <label>Size:</label>
            <input type="range" id="size-slider" min="20" max="200" value="55">
            <span id="size-value">50</span>
            <button id="reset-size">Reset</button>
          </div>
          <details class="style-section">
            <summary>Styling</summary>
            <div class="style-content">
              <div class="style-row">
                <label>Screen:</label>
                <select id="style-scope">
                  <option value="all">All</option>
                  <option value="desktop">Desktop</option>
                  <option value="tablet">Tablet</option>
                  <option value="mobile">Mobile</option>
                  <option value="fold">Fold</option>
                </select>
              </div>
              <div class="style-row">
                <label>Shape:</label>
                <select id="shape-select">
                  <optgroup label="Basic Shapes">
                    <option value="circle">Circle</option>
                    <option value="square">Square</option>
                    <option value="rectangle">Rectangle</option>
                    <option value="triangle">Triangle</option>
                    <option value="hexagon">Hexagon</option>
                    <option value="diamond">Diamond</option>
                    <option value="star">Star</option>
                    <option value="stop-sign">Stop Sign</option>
                  </optgroup>
                  <optgroup label="Network Equipment">
                    <option value="server">Server</option>
                    <option value="pc">PC / Desktop</option>
                    <option value="laptop">Laptop</option>
                    <option value="phone">Phone / Mobile</option>
                    <option value="router">Router</option>
                    <option value="switch">Switch</option>
                    <option value="firewall">Firewall</option>
                    <option value="cloud">Cloud</option>
                    <option value="database">Database</option>
                    <option value="printer">Printer</option>
                  </optgroup>
                </select>
              </div>
              <div class="style-row">
                <label>Fill Color:</label>
                <input type="color" id="circle-color" value="#1e293b">
              </div>
              <div class="style-row">
                <label>Border Color:</label>
                <input type="color" id="circle-border" value="#475569">
              </div>
              <div class="style-row">
                <label>Title Color:</label>
                <input type="color" id="title-color" value="#e2e8f0">
              </div>
              <div class="style-row">
                <label>Title Font:</label>
                <select id="title-font">
                  <option value="system-ui, sans-serif"> System UI </option>
                  <option value="monospace">Monospace</option>
                  <option value="serif">Serif</option>
                  <option value="cursive">Cursive</option>
                  <option value="'Courier New', monospace"> Courier </option>
                  <option value="Arial, sans-serif">Arial</option>
                  <option value="'Times New Roman', serif"> Times </option>
                </select>
              </div>
              <div class="style-row">
                <label>Title Size:</label>
                <input type="number" id="title-size" min="8" max="100" value="18">
              </div>
              <div class="style-row">
                <label>Sub Color:</label>
                <input type="color" id="sub-color" value="#94a3b8">
              </div>
              <div class="style-row">
                <label>Sub Font:</label>
                <select id="sub-font">
                  <option value="system-ui, sans-serif"> System UI </option>
                  <option value="monospace">Monospace</option>
                  <option value="serif">Serif</option>
                  <option value="cursive">Cursive</option>
                  <option value="'Courier New', monospace"> Courier </option>
                  <option value="Arial, sans-serif">Arial</option>
                  <option value="'Times New Roman', serif"> Times </option>
                </select>
              </div>
              <div class="style-row">
                <label>Sub Size:</label>
                <input type="number" id="sub-size" min="6" max="80" value="13">
              </div>
              <div style="margin-top: 12px;padding-top: 10px;border-top: 1px solid var(--edge-main);">
                <div style="
                  font-size: 12px;
                  color: var(--text-soft);
                  margin-bottom: 8px;
                  text-transform: uppercase;
                  "> Text Position </div>
                <div class="style-row">
                  <label>Name Y:</label>
                  <input type="number" id="title-offset-y" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>Name X:</label>
                  <input type="number" id="title-offset-x" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>IP Y:</label>
                  <input type="number" id="sub-offset-y" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>IP X:</label>
                  <input type="number" id="sub-offset-x" min="-100" max="100" value="0" style="width: 60px">
                </div>
              </div>
              <button id="reset-styles" style="width: 100%;margin-top: 10px;padding: 8px;background: var(--panel);color: var(--text-main);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: clamp(13px, 1.5vw, 17px);">Reset Styles</button>
            </div>
          </details>
          <div class="section-label">Notes</div>
          <ul class="list" id="node-notes"><li><span style="flex: 1 1 0%;">Comcast Gigabit</span><span class="delete-note">‚úï</span></li><li><span style="flex: 1 1 0%;">Bridge mode enabled</span><span class="delete-note">‚úï</span></li></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-note-input" placeholder="Type new note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-note-btn" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-node-btn" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: rgb(255, 255, 255);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;width: 100%;">Delete Node</button>
        </div>
        <div id="edge-panel" style="display: none">
          <div class="details-name" id="edge-title">Custom line</div>
          <div class="style-row" style="margin-top: 10px">
            <label>Width:</label>
            <input type="number" id="edge-width" min="1" max="20" value="4">
          </div>
          <div class="style-row">
            <label>Color:</label>
            <input type="color" id="edge-color" value="#475569">
          </div>
          <div class="style-row">
            <label>Line Style:</label>
            <select id="edge-line-style">
              <option value="solid">Solid</option>
              <option value="dashed">Dashed</option>
              <option value="dotted">Dotted</option>
            </select>
          </div>
          <div class="style-row">
            <label>Direction:</label>
            <select id="edge-direction">
              <option value="none">No arrows</option>
              <option value="forward">‚Üí Forward</option>
              <option value="backward">‚Üê Backward</option>
              <option value="both">‚Üî Bidirectional</option>
            </select>
          </div>
          <div class="style-row" id="edge-from-port-row" style="display: none;">
            <label>From Port:</label>
            <input type="text" id="edge-from-port" placeholder="e.g. eth0, gi0/1" style="flex: 1;">
          </div>
          <div class="style-row" id="edge-to-port-row" style="display: none;">
            <label>To Port:</label>
            <input type="text" id="edge-to-port" placeholder="e.g. eth1, gi0/2" style="flex: 1;">
          </div>
          <div class="section-label">Line Notes</div>
          <ul class="list" id="edge-notes"></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-edge-note" placeholder="Add note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-edge-note" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-edge" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Delete Line</button>
        </div>
        <div id="text-panel" style="display: none">
          <div class="details-name" id="text-title">Text Element</div>
          <div class="style-row" style="margin-top: 10px">
            <label>Content:</label>
            <textarea id="text-content" placeholder="Enter text..." style="width: 100%;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: 14px;min-height: 80px;resize: vertical;font-family: inherit;"></textarea>
          </div>
          <div class="style-row">
            <label>Font Size:</label>
            <input type="number" id="text-font-size" min="8" max="200" value="18" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);">
          </div>
          <div class="style-row">
            <label>Color:</label>
            <input type="color" id="text-color" value="#e2e8f0">
          </div>
          <div class="style-row">
            <label>Font Weight:</label>
            <select id="text-font-weight" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="normal">Normal</option>
              <option value="bold">Bold</option>
              <option value="600">Semi-Bold</option>
              <option value="300">Light</option>
            </select>
          </div>
          <div class="style-row">
            <label>Font Style:</label>
            <select id="text-font-style" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="normal">Normal</option>
              <option value="italic">Italic</option>
            </select>
          </div>
          <div class="style-row">
            <label>Text Align:</label>
            <select id="text-align" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="start">Left</option>
              <option value="middle">Center</option>
              <option value="end">Right</option>
            </select>
          </div>
          <div class="style-row">
            <label>Text Decoration:</label>
            <select id="text-decoration" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="none">None</option>
              <option value="underline">Underline</option>
              <option value="line-through">Strike Through</option>
            </select>
          </div>
          <div class="style-row">
            <label>Background:</label>
            <input type="color" id="text-bg-color" value="#000000">
            <label style="margin-left: 10px; display: flex; align-items: center; gap: 6px;">
            <input type="checkbox" id="text-bg-enabled" style="cursor: pointer;">
            <span style="font-size: 13px;">Enable</span>
            </label>
          </div>
          <div class="style-row">
            <label>Opacity:</label>
            <input type="range" id="text-opacity" min="0" max="1" step="0.1" value="1" style="flex: 1">
            <span id="text-opacity-val" style="min-width: 35px; text-align: right">100%</span>
          </div>
          <button id="delete-text" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;width: 100%;"> Delete Text </button>
        </div>
        <details class="style-section" open="">
          <summary>Page Layout</summary>
          <div class="style-content">
            <div style="padding: 12px; background: var(--panel-alt); border-radius: 6px; color: var(--text-soft); font-size: 13px; line-height: 1.6;">
              <strong style="color: var(--accent); display: block; margin-bottom: 8px;">Drag to Resize:</strong>
              ‚Ä¢ <strong>Header:</strong> Drag the bottom edge of the header bar<br>
              ‚Ä¢ <strong>Sidebar:</strong> Drag the left edge of the sidebar panel<br>
              ‚Ä¢ <strong>Mobile:</strong> Drag the top edge of the footer panel<br>
              <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--edge-main); font-size: 12px;">
                Hover over panel edges to see resize handles
              </div>
            </div>
          </div>
        </details>
      </aside>
    </main>
    <script id="nodes-json" type="application/json">{}</script>
    <script id="topology-state" type="application/json">ENCRYPTED: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</script>
    <script>
      const BASE_NODE_DATA = JSON.parse(document.getElementById("nodes-json").textContent, );
      let currentNodeId = "host";
      let textDrawMode = false;
      let currentEdgeId = null;
      let currentStyleScope = "all";
      let NODE_DATA = {};
      let EDGE_DATA = {
       list: []
      };
      let RECT_DATA = {
       list: []
      };
      let TEXT_DATA = {
       list: []
      };
      let EDGE_LEGEND = {};
      let savedPositions = {};
      let savedSizes = {};
      let savedStyles = {};
      let legendCollapsed = false;
      let minimapCollapsed = false;
      let drawToolbarCollapsed = false;
      let activeLayers = new Set(["physical", "logical", "security", "application"]);
      let currentView = {
       mode: "topology",  
       rackId: null      
      };
      let savedTopologyView = null; 
      let topologyToolbarCollapsed = false;
      let legendMiniBtn = null;
      let minimapMiniBtn = null;
      let drawToolbarMiniBtn = null;
      let topologyToolbarMiniBtn = null;
      
      let undoStack = [];
      let redoStack = [];
      const MAX_UNDO_STACK = 50;
      
      let selectedNodes = new Set();
      let isSelecting = false;
      let selectionStart = null;
      let selectionRect = null;
      let isDraggingSelection = false;
      let dragSelectionStart = null;
      
      let clipboard = null;
      
      const ROLLBACK_STORAGE_KEY = "theonefile_rollbacks";
      const MAX_ROLLBACK_VERSIONS = 50;
      let rollbackVersions = [];
      let currentRollbackIndex = -1;
      
      const AUDIT_STORAGE_KEY = "theonefile_audit_log";
      let auditLog = [];
      const MAX_AUDIT_ENTRIES = 1000;
      
      let documentTabs = [{
        id: "main",
        name: "Main Topology",
        nodes: {},
        edges: { list: [] },
        positions: {},
        sizes: {},
        styles: {},
        legend: {},
        rects: { list: [] },
        texts: { list: [] },
		pageState: null
      }];
      let currentTabIndex = 0;
      
      let encryptedSections = {}; 
      
      let performanceMode = "auto"; 
      let cullOffscreenNodes = true;
      let minimapNeedsUpdate = true;
      let lastMinimapUpdate = 0;
      
      const MobileManager = {
        isMobile: false,
        detect() {
          if (navigator.userAgentData?.mobile === true) {
            this.isMobile = true;
            return true;
          }
          const coarse = matchMedia("(pointer: coarse)").matches;
          const width = window.innerWidth <= 900;
          const portrait = matchMedia("(orientation: portrait)").matches;
          this.isMobile = coarse && (width || portrait);
          return this.isMobile;
        },
        applyInitialCollapse() {
          if (!this.isMobile) return;
          legendCollapsed = true;
          minimapCollapsed = true;
          drawToolbarCollapsed = true;
          topologyToolbarCollapsed = true;
          if (typeof updateLegendVisibility === "function") updateLegendVisibility();
          if (typeof updateMinimapVisibility === "function") updateMinimapVisibility();
          if (typeof updateDrawToolbarVisibility === "function") updateDrawToolbarVisibility();
          if (typeof updateTopologyToolbarVisibility === "function") updateTopologyToolbarVisibility();
        },
        updateBulkToolbar() {
          const desktop = document.getElementById("bulk-toolbar");
          const mobile = document.getElementById("bulk-toolbar-mobile");
          if (!desktop || !mobile) return;
      
          const isVisible = desktop.style.display !== "none" || mobile.style.display !== "none";
          
          if (this.isMobile) {
            desktop.style.display = "none";
            if (isVisible) {
              mobile.style.display = "flex";
            }
          } else {
            mobile.style.display = "none";
            if (isVisible) {
              desktop.style.display = "flex";
            }
          }
        },
        updateLayout() {
          const main = document.querySelector("main");
          if (!main) return;
        },
        updateCanvasHint() {
      const hint = document.getElementById("canvas-hint");
      if (!hint) return;
      
      const items = this.isMobile
      ? [
        "Pinch to zoom",
        "Drag to pan",
        "Add node from top menu",
        "Double tap to clone and align",
        "Double tap to select multiple",
        "You have the power",	
        "Your time is NOW!",
      ]
      : [
        "Scroll to zoom",
        "Drag to pan",
        "Right-click to clone and align",
        "Right-click to select multiple",
        "You have the power",
        "Your time is NOW!",
      ];
      
      const list = document.createElement("ul");
      for (const item of items) {
      const li = document.createElement("li");
      li.textContent = item;
      list.appendChild(li);
      }
      
      hint.replaceChildren(list);
      },
        autoSelectStyleScope() {
          const scope = document.getElementById("style-scope");
          if (!scope) return;
          if (this.isMobile) scope.value = "mobile";
        },
        updateToolbarStack() {
          if (!this.isMobile) return;
          const draw = document.getElementById("draw-toolbar");
          const topo = document.getElementById("topology-toolbar");
          if (!draw || !topo) return;
          const h = draw.getBoundingClientRect().height;
          document.documentElement.style.setProperty("--draw-toolbar-height", h + "px");
        },
        updateLayoutControls() {
          const sidebarRow = document.getElementById("sidebar-width-row");
          const footerRow = document.getElementById("mobile-footer-row");
          if (sidebarRow && footerRow) {
            if (this.isMobile) {
              sidebarRow.style.display = "none";
              footerRow.style.display = "flex";
            } else {
              sidebarRow.style.display = "flex";
              footerRow.style.display = "none";
            }
          }
        },
        applyAll() {
          this.detect();
          this.applyInitialCollapse();
          this.updateBulkToolbar();
          this.updateLayout();
          this.updateCanvasHint();
          this.autoSelectStyleScope();
          this.updateToolbarStack();
          this.updateLayoutControls();
        }
      };
      
      function isMobileDevice() {
        return MobileManager.isMobile;
      }
      
      function u8ToBase64(u8) {
      let binary = "";
      for (let i = 0; i < u8.length; i++) binary += String.fromCharCode(u8[i]);
      return btoa(binary);
      }
      
      function base64ToU8(base64) {
      const binary = atob(base64);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
      return bytes;
      }
      
      function ensureLegendMiniButton() {
       if (legendMiniBtn) return legendMiniBtn;
       const panel = document.querySelector(".topology-panel");
       if (!panel) return null;
       const btn = document.createElement("button");
       btn.type = "button";
       btn.id = "edge-legend-mini";
       btn.className = "legend-mini-btn";
       btn.textContent = "Legend";
       btn.style.bottom = "10px";
       const handleClick = (e) => {
        e.stopPropagation();
        e.preventDefault();
        legendCollapsed = false;
        updateLegendVisibility();
       };
       btn.addEventListener("click", handleClick);
       btn.addEventListener("touchend", handleClick);
       panel.appendChild(btn);
       legendMiniBtn = btn;
       return btn;
      }
      
      function ensureMinimapMiniButton() {
       if (minimapMiniBtn) return minimapMiniBtn;
       const panel = document.querySelector(".topology-panel");
       if (!panel) return null;
       const btn = document.createElement("button");
       btn.type = "button";
       btn.id = "minimap-mini";
       btn.className = "legend-mini-btn";
       btn.textContent = "Map";
       btn.style.right = "10px";
       btn.style.left = "auto";
       btn.style.bottom = "10px";
       const handleClick = (e) => {
        e.stopPropagation();
        e.preventDefault();
        minimapCollapsed = false;
        updateMinimapVisibility();
       };
       btn.addEventListener("click", handleClick);
       btn.addEventListener("touchend", handleClick);
       panel.appendChild(btn);
       minimapMiniBtn = btn;
       return btn;
      }
      
      function ensureDrawToolbarMiniButton() {
       if (drawToolbarMiniBtn) return drawToolbarMiniBtn;
       const panel = document.querySelector(".topology-panel");
       if (!panel) return null;
       const btn = document.createElement("button");
       btn.type = "button";
       btn.id = "draw-toolbar-mini";
       btn.className = "legend-mini-btn";
       btn.textContent = "Draw";
       btn.style.top = "10px";
       btn.style.left = "10px";
       btn.style.right = "auto";
       const handleClick = (e) => {
        e.stopPropagation();
        e.preventDefault();
        drawToolbarCollapsed = false;
        updateDrawToolbarVisibility();
       };
       btn.addEventListener("click", handleClick);
       btn.addEventListener("touchend", handleClick);
       panel.appendChild(btn);
       drawToolbarMiniBtn = btn;
       return btn;
      }
      
      function ensureTopologyToolbarMiniButton() {
       if (topologyToolbarMiniBtn) return topologyToolbarMiniBtn;
       const panel = document.querySelector(".topology-panel");
       if (!panel) return null;
       const btn = document.createElement("button");
       btn.type = "button";
       btn.id = "topology-toolbar-mini";
       btn.className = "legend-mini-btn";
       btn.textContent = "Add Line";
       btn.style.top = "10px";
       btn.style.left = "auto";
       btn.style.right = "40px";
       const handleClick = (e) => {
        e.stopPropagation();
        e.preventDefault();
        topologyToolbarCollapsed = false;
        updateTopologyToolbarVisibility();
       };
       btn.addEventListener("click", handleClick);
       btn.addEventListener("touchend", handleClick);
       panel.appendChild(btn);
       topologyToolbarMiniBtn = btn;
       return btn;
      }
      
      function updateToolbarStack() {
       if (!isMobileDevice()) return;
       const draw = document.getElementById("draw-toolbar");
       const topo = document.getElementById("topology-toolbar");
       if (!draw || !topo) return;
       const h = draw.getBoundingClientRect().height;
       document.documentElement.style.setProperty("--draw-toolbar-height", h + "px");
      }
      window.addEventListener("resize", updateToolbarStack);
      window.addEventListener("DOMContentLoaded", updateToolbarStack);
      updateToolbarStack();
      
      function updateLegendVisibility() {
       const legend = document.getElementById("edge-legend");
       const mini = ensureLegendMiniButton();
       if (!legend || !mini) return;
       const hasItems = legend.querySelectorAll(".legend-item").length > 0;
       if (!hasItems) {
        legend.style.display = "none";
        mini.style.display = "none";
        return;
       }
       if (legendCollapsed) {
        legend.style.display = "none";
        mini.style.display = "inline-flex";
       } else {
        legend.style.display = "flex";
        mini.style.display = "none";
       }
      }
      
      function updateMinimapVisibility() {
       const wrapper = document.getElementById("minimap-zoom-wrapper");
       const mini = ensureMinimapMiniButton();
       if (!wrapper || !mini) return;
       if (minimapCollapsed) {
        wrapper.style.display = "none";
        mini.style.display = "inline-flex";
       } else {
        wrapper.style.display = "block";
        mini.style.display = "none";
       }
      }
      
      function updateDrawToolbarVisibility() {
       const toolbar = document.getElementById("draw-toolbar");
       const mini = ensureDrawToolbarMiniButton();
       if (!toolbar || !mini) return;
       if (drawToolbarCollapsed) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "inline-flex";
       } else {
      if (isMobileDevice()) {    	   
        toolbar.style.setProperty('display', 'grid', 'important');
        mini.style.display = "none";
      } else {   
        toolbar.style.setProperty('display', 'flex', 'important');
        mini.style.display = "none";	  
      }
       }
      }
      
      function updateTopologyToolbarVisibility() {
       const toolbar = document.getElementById("topology-toolbar");
       const mini = ensureTopologyToolbarMiniButton();
       if (!toolbar || !mini) return;
       const hasSelectedNode = currentNodeId !== null;
       if (!hasSelectedNode) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "none";
       } else if (topologyToolbarCollapsed) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "inline-flex";
       } else {   
      if (isMobileDevice()) {    	   
        toolbar.style.setProperty('display', 'grid', 'important');
        mini.style.display = "none";
        } else {   
        toolbar.style.setProperty('display', 'flex', 'important');
        mini.style.display = "none";	  
      }
       }
      }
      
      const DEFAULT_PAGE_STATE = {
       title: "The One File",
       background: "",
       topbarBg: "rgba(9, 12, 20, 0.9)",
       topbarBorder: "#1f2533",
       panel: "#0b0e13",
       panelAlt: "#10141b",
       accent: "#4fd1c5",
       danger: "#f56565",
       textMain: "#e2e8f0",
       textSoft: "#94a3b8",
       topbarHeight: 52,
       sidebarWidth: 350,
       mobileFooterHeight: 40,
       sidebarCollapsed: false,
      };
      let PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE);
      const CANVAS_WIDTH = 4000;
      let CANVAS_HEIGHT = 3000;
      const BASE_CANVAS_HEIGHT = 3000;
      const CANVAS_PADDING = 100;
      
      const RACK_U_HEIGHT = 70; 
      const RACK_WIDTH = 600;
      const RACK_START_X = CANVAS_WIDTH / 2; 
      const RACK_START_Y = CANVAS_PADDING + 100;
      function getRackUHeight(rackId) {
      const capacity = getRackCapacity(rackId);
      const availableHeight = CANVAS_HEIGHT - RACK_START_Y - 200;
      return Math.floor(availableHeight / capacity);
      }
      let canvasState = {
       zoom: 1,
       panX: 0,
       panY: 0,
       minZoom: 0.25,
       maxZoom: 4,
       isPanning: false,
       panStartX: 0,
       panStartY: 0,
       spacePressed: false,
      };
      
      function getViewBox() {
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       return {
        x: canvasState.panX,
        y: canvasState.panY,
        width: viewWidth,
        height: viewHeight,
       };
      }
      
      function updateViewBox() {
       const svg = document.getElementById("map");
       const vb = getViewBox();
       svg.setAttribute("viewBox", `${vb.x} ${vb.y} ${vb.width} ${vb.height}`, );
       const zoomLevel = document.getElementById("zoom-level");
       if (zoomLevel) {
        zoomLevel.textContent = Math.round(canvasState.zoom * 100) + "%";
       }
       updateMinimap();
       populateRackDropdown();
      }
      
      function updateMinimap() {
       const minimapViewport = document.getElementById("minimap-viewport");
       const minimapSvg = document.getElementById("minimap");
       if (!minimapViewport || !minimapSvg) return;
       const vb = getViewBox();
       minimapViewport.setAttribute("x", vb.x);
       minimapViewport.setAttribute("y", vb.y);
       minimapViewport.setAttribute("width", vb.width);
       minimapViewport.setAttribute("height", vb.height);
       const minimapNodes = minimapSvg.querySelectorAll(".minimap-node");
       minimapNodes.forEach((n) => n.remove());
       const minimapEdges = minimapSvg.querySelectorAll(".minimap-edge");
       minimapEdges.forEach((e) => e.remove());
       
       EDGE_DATA.list.forEach((edge) => {
        if (edge.type === "custom") return;
        
        const fromNode = NODE_DATA[edge.from];
        const toNode = NODE_DATA[edge.to];
        if (!fromNode || !toNode) return;
        
        if (currentView.mode === "rack") {
         if (fromNode.assignedRack !== currentView.rackId || 
             toNode.assignedRack !== currentView.rackId) {
          return;
         }
        } else {
         if (fromNode.assignedRack || toNode.assignedRack) {
          return;
         }
        }
        
        const p1 = savedPositions[edge.from];
        const p2 = savedPositions[edge.to];
        if (!p1 || !p2) return;
        const line = document.createElementNS("http://www.w3.org/2000/svg", "line", );
        line.setAttribute("x1", p1.x);
        line.setAttribute("y1", p1.y);
        line.setAttribute("x2", p2.x);
        line.setAttribute("y2", p2.y);
        line.classList.add("minimap-edge");
        minimapSvg.insertBefore(line, minimapViewport);
       });
       
       Object.entries(savedPositions).forEach(([id, pos]) => {
        const node = NODE_DATA[id];
        if (!node) return;
        
        if (currentView.mode === "rack") {
         if (node.assignedRack !== currentView.rackId) {
          return; 
         }
        } else {
         if (node.assignedRack) {
          return; 
         }
        }
        
        const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle", );
        circle.setAttribute("cx", pos.x);
        circle.setAttribute("cy", pos.y);
        circle.setAttribute("r", 40);
        circle.classList.add("minimap-node");
        minimapSvg.insertBefore(circle, minimapViewport);
       });
      }
      
      function zoomTo(newZoom, centerX, centerY) {
       const oldZoom = canvasState.zoom;
       newZoom = Math.max(canvasState.minZoom, Math.min(canvasState.maxZoom, newZoom), );
       if (centerX !== undefined && centerY !== undefined) {
        const oldWidth = CANVAS_WIDTH / oldZoom;
        const oldHeight = CANVAS_HEIGHT / oldZoom;
        const newWidth = CANVAS_WIDTH / newZoom;
        const newHeight = CANVAS_HEIGHT / newZoom;
        const pointX = canvasState.panX + centerX * oldWidth;
        const pointY = canvasState.panY + centerY * oldHeight;
        canvasState.panX = pointX - centerX * newWidth;
        canvasState.panY = pointY - centerY * newHeight;
       }
       canvasState.zoom = newZoom;
       constrainPan();
       updateViewBox();
      }
      
      function constrainPan() {
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       const minVisiblePortion = 0.1;
       const maxPanX = CANVAS_WIDTH - viewWidth * minVisiblePortion;
       const maxPanY = CANVAS_HEIGHT - viewHeight * minVisiblePortion;
       const minPanX = -viewWidth * (1 - minVisiblePortion);
       const minPanY = -viewHeight * (1 - minVisiblePortion);
       canvasState.panX = Math.max(minPanX, Math.min(maxPanX, canvasState.panX), );
       canvasState.panY = Math.max(minPanY, Math.min(maxPanY, canvasState.panY), );
      }
      
      function fitToContent() {
       const positions = Object.values(savedPositions);
       if (positions.length === 0) {
        resetView();
        return;
       }
       let minX = Infinity,
        minY = Infinity,
        maxX = -Infinity,
        maxY = -Infinity;
       positions.forEach((pos) => {
        minX = Math.min(minX, pos.x - 100);
        minY = Math.min(minY, pos.y - 100);
        maxX = Math.max(maxX, pos.x + 100);
        maxY = Math.max(maxY, pos.y + 100);
       });
       const contentWidth = maxX - minX + 200;
       const contentHeight = maxY - minY + 200;
       const viewport = document.getElementById("canvas-viewport");
       const vpRect = viewport.getBoundingClientRect();
       const aspectRatio = vpRect.width / vpRect.height;
       const contentAspect = contentWidth / contentHeight;
       let newZoom;
       if (contentAspect > aspectRatio) {
        newZoom = (vpRect.width / contentWidth) * (CANVAS_WIDTH / vpRect.width);
       } else {
        newZoom = (vpRect.height / contentHeight) * (CANVAS_HEIGHT / vpRect.height);
       }
       newZoom = Math.max(canvasState.minZoom, Math.min(2, newZoom));
       const viewWidth = CANVAS_WIDTH / newZoom;
       const viewHeight = CANVAS_HEIGHT / newZoom;
       canvasState.zoom = newZoom;
       canvasState.panX = minX - 100 - (viewWidth - contentWidth) / 2;
       canvasState.panY = minY - 100 - (viewHeight - contentHeight) / 2;
       constrainPan();
       updateViewBox();
      }
      
      function resetView() {
       canvasState.zoom = 1;
       canvasState.panX = 0;
       canvasState.panY = 0;
       updateViewBox();
      }
      window.addEventListener("DOMContentLoaded", () => {
       const toggle = document.getElementById("mobile-menu-toggle");
       const menu = document.getElementById("topbar-menu");
       if (!toggle || !menu) return;
       toggle.addEventListener("click", () => {
        menu.classList.toggle("open");
       });
       menu.addEventListener("click", (e) => {
        const target = e.target.closest("a, button");
        if (!target) return;
        if (isMobileDevice()) {
       menu.classList.remove("open");
      }
       });
       const minimapCloseBtn = document.getElementById("minimap-close-btn");
       if (minimapCloseBtn) {
        const handleMinimapClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         minimapCollapsed = true;
         updateMinimapVisibility();
        };
        minimapCloseBtn.addEventListener("click", handleMinimapClose);
        minimapCloseBtn.addEventListener("touchend", handleMinimapClose);
       }
       const drawToolbarCloseBtn = document.getElementById("draw-toolbar-close-btn");
       if (drawToolbarCloseBtn) {
        const handleDrawClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         drawToolbarCollapsed = true;
         updateDrawToolbarVisibility();
        };
        drawToolbarCloseBtn.addEventListener("click", handleDrawClose);
        drawToolbarCloseBtn.addEventListener("touchend", handleDrawClose);
       }
       const topologyToolbarCloseBtn = document.getElementById("topology-toolbar-close-btn");
       if (topologyToolbarCloseBtn) {
        const handleTopologyClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         topologyToolbarCollapsed = true;
         updateTopologyToolbarVisibility();
        };
        topologyToolbarCloseBtn.addEventListener("click", handleTopologyClose);
        topologyToolbarCloseBtn.addEventListener("touchstart", (e) => e.preventDefault(), {
         passive: false
        });
        topologyToolbarCloseBtn.addEventListener("touchend", handleTopologyClose);
       }
      
       updateMinimapVisibility();
       updateDrawToolbarVisibility();
       updateTopologyToolbarVisibility();
      });
      
      function applyLayerFilter() {
       activeLayers.clear();
       if (document.getElementById("layer-physical").checked) activeLayers.add("physical");
       if (document.getElementById("layer-logical").checked) activeLayers.add("logical");
       if (document.getElementById("layer-security").checked) activeLayers.add("security");
       if (document.getElementById("layer-application").checked) activeLayers.add("application");
       forgeTheTopology();
      }
      
      function isNodeVisible(nodeId) {
       const node = NODE_DATA[nodeId];
       if (!node) return false;
       const nodeLayer = node.layer || "physical";
       return activeLayers.has(nodeLayer);
      }
      
      function enterRack(rackId) {
      if (!NODE_DATA[rackId] || !NODE_DATA[rackId].isRack) return;
      const rackCapacity = getRackCapacity(rackId);
      const neededHeight = RACK_START_Y + (rackCapacity * RACK_U_HEIGHT) + 200;
      if (neededHeight > BASE_CANVAS_HEIGHT) {
      CANVAS_HEIGHT = neededHeight;
      }
       
       savedTopologyView = {
        zoom: canvasState.zoom,
        panX: canvasState.panX,
        panY: canvasState.panY
       };
       
       currentView.mode = "rack";
       currentView.rackId = rackId;
       
       const backBtn = document.getElementById("back-to-topology-btn");
       if (backBtn) backBtn.style.display = "inline-block";
       
       const hint = document.getElementById("canvas-hint");
       if (hint) {
        hint.textContent = `Viewing: ${NODE_DATA[rackId].name} | Double-click empty space to exit`;
        hint.classList.add("visible");
       }
       
      
      const rackUHeight = getRackUHeight(rackId);
      const rackHeight = rackCapacity * rackUHeight;
      const rackCenterX = RACK_START_X;
      const rackCenterY = RACK_START_Y + (rackHeight / 2);
       
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       
       canvasState.panX = rackCenterX - (viewWidth / 2);
       canvasState.panY = rackCenterY - (viewHeight / 2);
       
       constrainPan();
       updateViewBox();
       
       forgeTheTopology();
      }
      
      function exitRack() {
      CANVAS_HEIGHT = BASE_CANVAS_HEIGHT;
      currentView.mode = "topology";
      currentView.rackId = null;
       
       const backBtn = document.getElementById("back-to-topology-btn");
       if (backBtn) backBtn.style.display = "none";
       
       const hint = document.getElementById("canvas-hint");
       if (hint) {
        hint.classList.remove("visible");
       }
       
       if (savedTopologyView) {
        canvasState.zoom = savedTopologyView.zoom;
        canvasState.panX = savedTopologyView.panX;
        canvasState.panY = savedTopologyView.panY;
        updateViewBox();
       }
       
       forgeTheTopology();
      }
      
      function getRackCapacity(rackId) {
       const node = NODE_DATA[rackId];
       return node && node.rackCapacity ? parseInt(node.rackCapacity) : 42;
      }
      
      function populateRackDropdown() {
       const dropdown = document.getElementById("node-assigned-rack");
       if (!dropdown) return;
       
       dropdown.innerHTML = '<option value="">None</option>';
       
       Object.keys(NODE_DATA).forEach(id => {
        if (NODE_DATA[id].isRack) {
         const option = document.createElement("option");
         option.value = id;
         option.textContent = NODE_DATA[id].name;
         dropdown.appendChild(option);
        }
       });
      }
      
      function wieldThePower() {
       const root = document.documentElement;
       root.style.setProperty("--panel", PAGE_STATE.panel);
       root.style.setProperty("--panel-alt", PAGE_STATE.panelAlt);
       root.style.setProperty("--accent", PAGE_STATE.accent);
       root.style.setProperty("--danger", PAGE_STATE.danger);
       root.style.setProperty("--text-main", PAGE_STATE.textMain);
       root.style.setProperty("--text-soft", PAGE_STATE.textSoft);
       root.style.setProperty("--topbar-bg", PAGE_STATE.topbarBg);
       root.style.setProperty("--topbar-border", PAGE_STATE.topbarBorder);
       const topbarHeight = PAGE_STATE.topbarHeight || 52;
       const sidebarWidth = PAGE_STATE.sidebarWidth || 350;
       const mobileFooterHeight = PAGE_STATE.mobileFooterHeight || 40;
       root.style.setProperty("--topbar-height", topbarHeight + "px");
       root.style.setProperty("--sidebar-width", sidebarWidth + "px");
       root.style.setProperty("--mobile-footer-height", mobileFooterHeight + "vh", );
       const mainEl = document.querySelector("main");
       const detailsPanel = document.getElementById("details-panel");
       const sidebarToggle = document.getElementById("sidebar-toggle");
       if (PAGE_STATE.sidebarCollapsed) {
        if (mainEl) mainEl.classList.add("sidebar-collapsed");
        if (detailsPanel) detailsPanel.classList.add("collapsed");
        if (sidebarToggle) {
         sidebarToggle.classList.add("collapsed");
         sidebarToggle.textContent = "‚ñ∂";
        }
       } else {
        if (mainEl) mainEl.classList.remove("sidebar-collapsed");
        if (detailsPanel) detailsPanel.classList.remove("collapsed");
        if (sidebarToggle) {
         sidebarToggle.classList.remove("collapsed");
         sidebarToggle.textContent = "‚óÄ";
        }
       }
       if (PAGE_STATE.background) {
        document.body.style.background = PAGE_STATE.background;
       } else {
        document.body.style.background = "radial-gradient(circle at top, #1e2532 0, #050608 70%)";
       }
       document.title = PAGE_STATE.title || DEFAULT_PAGE_STATE.title;
       const titleEl = document.getElementById("page-title");
       if (titleEl) {
        titleEl.textContent = PAGE_STATE.title || DEFAULT_PAGE_STATE.title;
       }
       
       const sidebarToggleEl = document.getElementById("sidebar-toggle");
       const isMobile = isMobileDevice();
       if (sidebarToggleEl) {
        sidebarToggleEl.style.display = isMobile ? "none" : "flex";
       }
      }
      (async function awakeTheImmortal() {
       let initialState = {};
       let decryptionCancelled = false;
       const stateEl = document.getElementById("topology-state");
       if (stateEl && stateEl.textContent.trim()) {
        try {
         let stateText = stateEl.textContent.trim();
         if (isEncrypted(stateText)) {
          let decrypted = false;
          let attempts = 0;
          const maxAttempts = 3;
          while (!decrypted && attempts < maxAttempts) {
           const password = prompt("This file is encrypted. Enter password to decrypt:\n(Attempt " + (attempts + 1) + " of " + maxAttempts + ")", );
           if (!password) {
            alert("Decryption cancelled. The file will not be loaded.", );
            decryptionCancelled = true;
            break;
           }
           try {
            stateText = await decryptData(stateText, password);
            decrypted = true;
           } catch (e) {
            attempts++;
            if (attempts < maxAttempts) {
             alert("Incorrect password. Please try again.");
            } else {
             alert("Maximum attempts reached. The file will not be loaded.", );
             decryptionCancelled = true;
            }
           }
          }
          if (!decrypted) {
           stateText = "{}";
          }
         }
         initialState = JSON.parse(stateText);
        } catch (e) {
         console.error("Failed to load state:", e);
         initialState = {};
        }
       }
       if (decryptionCancelled) {
        NODE_DATA = {};
        EDGE_DATA = {
         list: []
        };
        EDGE_LEGEND = {};
        savedPositions = {};
        savedSizes = {};
        savedStyles = {};
       } else {
        NODE_DATA = initialState.nodeData ? initialState.nodeData : BASE_NODE_DATA;
        EDGE_DATA = initialState.edgeData ? initialState.edgeData : {
         list: [],
        };
        RECT_DATA = initialState.rectData ? initialState.rectData : { list: [] };
        TEXT_DATA = initialState.textData ? initialState.textData : { list: [] };
        EDGE_LEGEND = initialState.edgeLegend || {};
        savedPositions = initialState.nodePositions || {};
        savedSizes = initialState.nodeSizes || {};
        savedStyles = initialState.nodeStyles || {};
       }
       if (initialState.page) {
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, initialState.page, );
       }
       if (initialState.canvas) {
        canvasState.zoom = initialState.canvas.zoom || 1;
        canvasState.panX = initialState.canvas.panX || 0;
        canvasState.panY = initialState.canvas.panY || 0;
       }
       
       if (initialState.savedTopologyView) {
        savedTopologyView = initialState.savedTopologyView;
       }
       
       if (initialState.documentTabs) {
        documentTabs = initialState.documentTabs;
        currentTabIndex = initialState.currentTabIndex || 0;
        
        const currentTab = documentTabs[currentTabIndex];
        if (currentTab) {
          NODE_DATA = currentTab.nodes || NODE_DATA;
          EDGE_DATA = currentTab.edges || EDGE_DATA;
          savedPositions = currentTab.positions || savedPositions;
          savedSizes = currentTab.sizes || savedSizes;
          savedStyles = currentTab.styles || savedStyles;
          EDGE_LEGEND = currentTab.legend || EDGE_LEGEND;
          RECT_DATA = currentTab.rects || RECT_DATA;
          TEXT_DATA = currentTab.texts || TEXT_DATA;
		  if (currentTab.pageState) PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, currentTab.pageState);
        }
       }
           
       if (initialState.encryptedSections) {
        encryptedSections = initialState.encryptedSections;
       }
       
       wieldThePower();
       forgeTheTopology();
       updateViewBox();
       
       MobileManager.applyAll();
       
       const initialNodes = Object.keys(NODE_DATA);
       if (initialNodes.length > 0) {
        claimTheImmortal(initialNodes.includes("host") ? "host" : initialNodes[0], );
       } else {
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.display = "none";
       }
      })();
      
      window.addEventListener("resize", () => {
        MobileManager.applyAll();
      });
      
      function saveEdgeData() {}
      
      function saveEdgeLegend() {}
      
      function getBreakpointKey() {
       const w = window.innerWidth;
       if (w <= 380) return "fold";
       if (w <= 768) return "mobile";
       if (w <= 1024) return "tablet";
       return "desktop";
      }
      
      function resolveStylesEntry(styleEntry) {
       if (!styleEntry) return {};
       if (styleEntry.circleColor || styleEntry.titleColor || styleEntry.titleFont || styleEntry.titleSize || styleEntry.subColor || styleEntry.subFont || styleEntry.subSize) {
        return styleEntry;
       }
       const bp = getBreakpointKey();
       const base = styleEntry.all || {};
       const bpStyles = styleEntry[bp] || {};
       return Object.assign({}, base, bpStyles);
      }
      
      function resolveStylesForNode(id) {
       const styleEntry = savedStyles[id];
       if (!styleEntry) return {};
       return resolveStylesEntry(styleEntry);
      }
      
      function ensureStyleEntry(id) {
       if (!savedStyles[id]) savedStyles[id] = {};
       const entry = savedStyles[id];
       const flatProps = ["circleColor", "circleBorder", "titleColor", "titleFont", "titleSize", "subColor", "subFont", "subSize", ];
       const isFlat = flatProps.some((p) => Object.prototype.hasOwnProperty.call(entry, p), );
       if (isFlat) {
        const all = entry.all || {};
        flatProps.forEach((p) => {
         if (entry[p] !== undefined) {
          all[p] = entry[p];
          delete entry[p];
         }
        });
        entry.all = all;
       }
       return entry;
      }
      
      function getDefaultSize() {
       if (window.innerWidth <= 380) return 120;
       if (window.innerWidth <= 768) return 140;
       if (window.innerWidth <= 1024) return 70;
       return 55;
      }
      
      function createShapeElement(shape, size) {
       const ns = "http://www.w3.org/2000/svg";
       if (shape === "circle") {
        const c = document.createElementNS(ns, "circle");
        c.setAttribute("r", size);
        return c;
       }
       if (shape === "square") {
        const r = document.createElementNS(ns, "rect");
        const s = size * 2;
        r.setAttribute("x", -size);
        r.setAttribute("y", -size);
        r.setAttribute("width", s);
        r.setAttribute("height", s);
        r.setAttribute("rx", 4);
        return r;
       }
       if (shape === "rectangle") {
        const r = document.createElementNS(ns, "rect");
        r.setAttribute("x", -size * 1.4);
        r.setAttribute("y", -size * 0.8);
        r.setAttribute("width", size * 2.8);
        r.setAttribute("height", size * 1.6);
        r.setAttribute("rx", 6);
        return r;
       }
       if (shape === "triangle") {
        const p = document.createElementNS(ns, "polygon");
        const h = size * 1.8;
        const w = size * 2;
        p.setAttribute("points", `0,${-h} ${w / 2},${h / 2} ${-w / 2},${h / 2}`, );
        return p;
       }
       if (shape === "hexagon") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        const pts = [
         [0, -s],
         [s * 0.86, -s * 0.5],
         [s * 0.86, s * 0.5],
         [0, s],
         [-s * 0.86, s * 0.5],
         [-s * 0.86, -s * 0.5],
        ].map((pt) => pt.join(",")).join(" ");
        p.setAttribute("points", pts);
        return p;
       }
       if (shape === "stop-sign") {
        const p = document.createElementNS(ns, "polygon");
        const r = size;
        const ptsArr = [];
        for (let i = 0; i < 8; i++) {
         const a = (Math.PI / 4) * i + Math.PI / 8;
         ptsArr.push([Math.cos(a) * r, Math.sin(a) * r]);
        }
        const pts = ptsArr.map((pt) => pt.join(",")).join(" ");
        p.setAttribute("points", pts);
        return p;
       }
       if (shape === "star") {
        const p = document.createElementNS(ns, "polygon");
        const outer = size;
        const inner = size * 0.45;
        let pts = "";
        for (let i = 0; i < 10; i++) {
         const a = (Math.PI / 5) * i - Math.PI / 2;
         const r = i % 2 === 0 ? outer : inner;
         pts += `${Math.cos(a) * r},${Math.sin(a) * r} `;
        }
        p.setAttribute("points", pts.trim());
        return p;
       }
       if (shape === "diamond") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `0,${-s} ${s},0 0,${s} ${-s},0`);
        return p;
       }
       if (shape === "server") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.2);
        body.setAttribute("y", -size * 0.6);
        body.setAttribute("width", size * 2.4);
        body.setAttribute("height", size * 1.2);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 3; i++) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", -size * 0.9 + i * size * 0.5);
         line.setAttribute("y1", -size * 0.3);
         line.setAttribute("x2", -size * 0.9 + i * size * 0.5);
         line.setAttribute("y2", size * 0.3);
         line.style.stroke = "currentColor";
         line.style.strokeWidth = "2";
         line.style.opacity = "0.5";
         g.appendChild(line);
        }
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", size * 0.9);
        led.setAttribute("cy", 0);
        led.setAttribute("r", size * 0.1);
        led.style.fill = "#4ade80";
        g.appendChild(led);
        return g;
       }
       if (shape === "pc" || shape === "desktop") {
        const g = document.createElementNS(ns, "g");
        const monitor = document.createElementNS(ns, "rect");
        monitor.setAttribute("x", -size * 0.9);
        monitor.setAttribute("y", -size * 0.8);
        monitor.setAttribute("width", size * 1.8);
        monitor.setAttribute("height", size * 1.2);
        monitor.setAttribute("rx", 4);
        g.appendChild(monitor);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.75);
        screen.setAttribute("y", -size * 0.65);
        screen.setAttribute("width", size * 1.5);
        screen.setAttribute("height", size * 0.9);
        screen.setAttribute("rx", 2);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        const neck = document.createElementNS(ns, "rect");
        neck.setAttribute("x", -size * 0.15);
        neck.setAttribute("y", size * 0.4);
        neck.setAttribute("width", size * 0.3);
        neck.setAttribute("height", size * 0.3);
        g.appendChild(neck);
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.5);
        base.setAttribute("y", size * 0.7);
        base.setAttribute("width", size * 1);
        base.setAttribute("height", size * 0.15);
        base.setAttribute("rx", 2);
        g.appendChild(base);
        return g;
       }
       if (shape === "laptop") {
        const g = document.createElementNS(ns, "g");
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.8);
        screen.setAttribute("y", -size * 0.9);
        screen.setAttribute("width", size * 1.6);
        screen.setAttribute("height", size * 1.1);
        screen.setAttribute("rx", 4);
        g.appendChild(screen);
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.9);
        base.setAttribute("y", size * 0.25);
        base.setAttribute("width", size * 1.8);
        base.setAttribute("height", size * 0.6);
        base.setAttribute("rx", 4);
        g.appendChild(base);
        const pad = document.createElementNS(ns, "rect");
        pad.setAttribute("x", -size * 0.25);
        pad.setAttribute("y", size * 0.45);
        pad.setAttribute("width", size * 0.5);
        pad.setAttribute("height", size * 0.25);
        pad.setAttribute("rx", 2);
        pad.style.fill = "#1e293b";
        g.appendChild(pad);
        return g;
       }
       if (shape === "phone" || shape === "mobile") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.45);
        body.setAttribute("y", -size);
        body.setAttribute("width", size * 0.9);
        body.setAttribute("height", size * 2);
        body.setAttribute("rx", 8);
        g.appendChild(body);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.38);
        screen.setAttribute("y", -size * 0.85);
        screen.setAttribute("width", size * 0.76);
        screen.setAttribute("height", size * 1.6);
        screen.setAttribute("rx", 4);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        const btn = document.createElementNS(ns, "rect");
        btn.setAttribute("x", -size * 0.15);
        btn.setAttribute("y", size * 0.82);
        btn.setAttribute("width", size * 0.3);
        btn.setAttribute("height", size * 0.06);
        btn.setAttribute("rx", 2);
        btn.style.fill = "#475569";
        g.appendChild(btn);
        return g;
       }
       if (shape === "router") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.1);
        body.setAttribute("y", -size * 0.3);
        body.setAttribute("width", size * 2.2);
        body.setAttribute("height", size * 0.8);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        for (let i = -1; i <= 1; i++) {
         const ant = document.createElementNS(ns, "rect");
         ant.setAttribute("x", i * size * 0.6 - size * 0.05);
         ant.setAttribute("y", -size * 0.9);
         ant.setAttribute("width", size * 0.1);
         ant.setAttribute("height", size * 0.6);
         ant.setAttribute("rx", 2);
         g.appendChild(ant);
         const tip = document.createElementNS(ns, "circle");
         tip.setAttribute("cx", i * size * 0.6);
         tip.setAttribute("cy", -size * 0.95);
         tip.setAttribute("r", size * 0.08);
         g.appendChild(tip);
        }
        for (let i = 0; i < 4; i++) {
         const led = document.createElementNS(ns, "circle");
         led.setAttribute("cx", -size * 0.7 + i * size * 0.35);
         led.setAttribute("cy", size * 0.1);
         led.setAttribute("r", size * 0.06);
         led.style.fill = i < 2 ? "#4ade80" : "#facc15";
         g.appendChild(led);
        }
        return g;
       }
       if (shape === "switch") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.4);
        body.setAttribute("y", -size * 0.4);
        body.setAttribute("width", size * 2.8);
        body.setAttribute("height", size * 0.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 8; i++) {
         const port = document.createElementNS(ns, "rect");
         port.setAttribute("x", -size * 1.2 + i * size * 0.32);
         port.setAttribute("y", -size * 0.15);
         port.setAttribute("width", size * 0.22);
         port.setAttribute("height", size * 0.3);
         port.setAttribute("rx", 1);
         port.style.fill = "#1e293b";
         g.appendChild(port);
        }
        return g;
       }
       if (shape === "firewall") {
        const g = document.createElementNS(ns, "g");
        const wall = document.createElementNS(ns, "rect");
        wall.setAttribute("x", -size);
        wall.setAttribute("y", -size * 0.8);
        wall.setAttribute("width", size * 2);
        wall.setAttribute("height", size * 1.6);
        wall.setAttribute("rx", 4);
        g.appendChild(wall);
        for (let row = 0; row < 3; row++) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", -size * 0.85);
         line.setAttribute("y1", -size * 0.5 + row * size * 0.45);
         line.setAttribute("x2", size * 0.85);
         line.setAttribute("y2", -size * 0.5 + row * size * 0.45);
         line.style.stroke = "#475569";
         line.style.strokeWidth = "2";
         g.appendChild(line);
        }
        for (let row = 0; row < 4; row++) {
         const offset = row % 2 === 0 ? 0 : size * 0.35;
         for (let col = 0; col < 3; col++) {
          const line = document.createElementNS(ns, "line");
          const x = -size * 0.5 + col * size * 0.7 + offset;
          if (x > -size * 0.85 && x < size * 0.85) {
           line.setAttribute("x1", x);
           line.setAttribute("y1", -size * 0.8 + row * size * 0.45, );
           line.setAttribute("x2", x);
           line.setAttribute("y2", -size * 0.8 + row * size * 0.45 + size * 0.45, );
           line.style.stroke = "#475569";
           line.style.strokeWidth = "2";
           g.appendChild(line);
          }
         }
        }
        return g;
       }
       if (shape === "cloud") {
        const p = document.createElementNS(ns, "path");
        const s = size;
        p.setAttribute("d", `
             M ${-s * 0.8} ${s * 0.2}
             Q ${-s * 1.1} ${s * 0.2} ${-s * 1.1} ${-s * 0.1}
             Q ${-s * 1.1} ${-s * 0.5} ${-s * 0.7} ${-s * 0.5}
             Q ${-s * 0.7} ${-s * 0.9} ${-s * 0.2} ${-s * 0.9}
             Q ${s * 0.1} ${-s * 1.1} ${s * 0.5} ${-s * 0.8}
             Q ${s * 1} ${-s * 0.8} ${s * 1.1} ${-s * 0.3}
             Q ${s * 1.3} ${-s * 0.1} ${s * 1.1} ${s * 0.2}
             Q ${s * 1.1} ${s * 0.5} ${s * 0.7} ${s * 0.5}
             L ${-s * 0.5} ${s * 0.5}
             Q ${-s * 0.9} ${s * 0.5} ${-s * 0.9} ${s * 0.2}
             Z
            `, );
        return p;
       }
       if (shape === "database") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.7);
        body.setAttribute("y", -size * 0.6);
        body.setAttribute("width", size * 1.4);
        body.setAttribute("height", size * 1.4);
        g.appendChild(body);
        const top = document.createElementNS(ns, "ellipse");
        top.setAttribute("cx", 0);
        top.setAttribute("cy", -size * 0.6);
        top.setAttribute("rx", size * 0.7);
        top.setAttribute("ry", size * 0.25);
        g.appendChild(top);
        const bottom = document.createElementNS(ns, "ellipse");
        bottom.setAttribute("cx", 0);
        bottom.setAttribute("cy", size * 0.8);
        bottom.setAttribute("rx", size * 0.7);
        bottom.setAttribute("ry", size * 0.25);
        g.appendChild(bottom);
        const mid1 = document.createElementNS(ns, "ellipse");
        mid1.setAttribute("cx", 0);
        mid1.setAttribute("cy", -size * 0.15);
        mid1.setAttribute("rx", size * 0.7);
        mid1.setAttribute("ry", size * 0.2);
        mid1.style.fill = "none";
        mid1.style.stroke = "#475569";
        mid1.style.strokeWidth = "2";
        g.appendChild(mid1);
        const mid2 = document.createElementNS(ns, "ellipse");
        mid2.setAttribute("cx", 0);
        mid2.setAttribute("cy", size * 0.35);
        mid2.setAttribute("rx", size * 0.7);
        mid2.setAttribute("ry", size * 0.2);
        mid2.style.fill = "none";
        mid2.style.stroke = "#475569";
        mid2.style.strokeWidth = "2";
        g.appendChild(mid2);
        return g;
       }
       if (shape === "printer") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.4);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size * 0.9);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const trayTop = document.createElementNS(ns, "rect");
        trayTop.setAttribute("x", -size * 0.7);
        trayTop.setAttribute("y", -size * 0.8);
        trayTop.setAttribute("width", size * 1.4);
        trayTop.setAttribute("height", size * 0.4);
        trayTop.setAttribute("rx", 2);
        trayTop.style.fill = "#1e293b";
        g.appendChild(trayTop);
        const trayOut = document.createElementNS(ns, "rect");
        trayOut.setAttribute("x", -size * 0.6);
        trayOut.setAttribute("y", size * 0.5);
        trayOut.setAttribute("width", size * 1.2);
        trayOut.setAttribute("height", size * 0.35);
        trayOut.setAttribute("rx", 2);
        g.appendChild(trayOut);
        const paper = document.createElementNS(ns, "rect");
        paper.setAttribute("x", -size * 0.5);
        paper.setAttribute("y", size * 0.3);
        paper.setAttribute("width", size * 1);
        paper.setAttribute("height", size * 0.5);
        paper.style.fill = "#e2e8f0";
        g.appendChild(paper);
        return g;
       }
       const c = document.createElementNS(ns, "circle");
       c.setAttribute("r", size);
       return c;
      }
      
      function createNodeShape(id, size) {
       const shapeType = (NODE_DATA[id] && NODE_DATA[id].shape) || "circle";
       const shapeEl = createShapeElement(shapeType, size);
       shapeEl.classList.add("node-circle");
       const styles = resolveStylesForNode(id);
       if (styles.circleColor) {
        shapeEl.style.fill = styles.circleColor;
       }
       if (styles.circleBorder) {
        shapeEl.style.stroke = styles.circleBorder;
       }
       return shapeEl;
      }
      
      function forgeTheLegend() {
       const container = document.getElementById("edge-legend");
       if (!container) return;
       container.innerHTML = "";
       const title = document.createElement("div");
       title.className = "legend-title";
       title.textContent = "Line Legend";
       container.appendChild(title);
       const closeBtn = document.createElement("button");
       closeBtn.type = "button";
       closeBtn.className = "legend-close-btn";
       closeBtn.textContent = "‚úï";
       closeBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        legendCollapsed = true;
        updateLegendVisibility();
       });
       container.appendChild(closeBtn);
       const colors = [...new Set(EDGE_DATA.list.map((e) => e.color).filter(Boolean))];
       if (colors.length === 0) {
        updateLegendVisibility();
        return;
       }
       colors.forEach((color) => {
        if (!EDGE_LEGEND[color]) {
         EDGE_LEGEND[color] = "you can edit me too";
        }
        const item = document.createElement("div");
        item.className = "legend-item";
        item.addEventListener("mousedown", (e) => e.stopPropagation());
        item.addEventListener("click", (e) => e.stopPropagation());
        const swatch = document.createElement("span");
        swatch.className = "legend-swatch";
        swatch.style.backgroundColor = color;
        swatch.style.cursor = "pointer";
        swatch.addEventListener("click", (e) => {
         e.stopPropagation();
         const edgeWithColor = EDGE_DATA.list.find(edge => edge.color === color);
         if (edgeWithColor) {
          selectTheConnection(edgeWithColor.id);
         }
        });
        let swatchTouchStart = null;
        let swatchTouchMoved = false;
        swatch.addEventListener("touchstart", (e) => {
         swatchTouchStart = Date.now();
         swatchTouchMoved = false;
        }, {
         passive: false
        });
        swatch.addEventListener("touchmove", (e) => {
         swatchTouchMoved = true;
        }, {
         passive: false
        });
        swatch.addEventListener("touchend", (e) => {
         if (swatchTouchStart && !swatchTouchMoved && Date.now() - swatchTouchStart < 400) {
          e.stopPropagation();
          e.preventDefault();
          const edgeWithColor = EDGE_DATA.list.find(edge => edge.color === color);
          if (edgeWithColor) {
           selectTheConnection(edgeWithColor.id);
          }
         }
         swatchTouchStart = null;
         swatchTouchMoved = false;
        }, {
         passive: false
        });
        const label = document.createElement("span");
        label.className = "legend-label";
        label.textContent = EDGE_LEGEND[color];
        if (isMobileDevice()) {
         label.style.cursor = "pointer";
         let labelTapStart = null;
         let labelTapMoved = false;
         label.addEventListener("touchstart", (e) => {
          labelTapStart = Date.now();
          labelTapMoved = false;
          e.stopPropagation();
         });
         label.addEventListener("touchmove", (e) => {
          labelTapMoved = true;
         });
         label.addEventListener("touchend", (e) => {
          if (labelTapStart && !labelTapMoved && Date.now() - labelTapStart < 400) {
           e.preventDefault();
           e.stopPropagation();
           const currentText = label.textContent;
           const newText = prompt("Edit legend label:", currentText);
           if (newText !== null && newText.trim()) {
            label.textContent = newText.trim();
            EDGE_LEGEND[color] = newText.trim();
            saveEdgeLegend();
           }
          }
          labelTapStart = null;
          labelTapMoved = false;
         });
        } else {
         label.contentEditable = true;
         label.addEventListener("focus", () => {
          label.classList.add("editing");
         });
         label.addEventListener("blur", () => {
          label.classList.remove("editing");
          const text = label.textContent.trim() || "you can edit me too";
          EDGE_LEGEND[color] = text;
          saveEdgeLegend();
         });
         label.addEventListener("keydown", (e) => {
          if (e.key === "Enter") {
           e.preventDefault();
           label.blur();
          }
         });
        }
        item.append(swatch, label);
        container.appendChild(item);
       });
       updateLegendVisibility();
      }
      
       function deleteRectangle(rectId) {
      pushUndo("delete rectangle");
        RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== rectId);
        forgeTheTopology();
       }
      
       function updateRectangleDeleteButtons() {
        const deleteButtons = document.querySelectorAll('.rect-delete-btn');
        deleteButtons.forEach(btn => {
         btn.style.display = rectDrawMode ? 'block' : 'none';
        });
       }
      
      function forgeTheTopology() {
       if (!NODE_DATA || !EDGE_DATA) {
        console.warn("forgeTheTopology called before data initialized");
        return;
       }
       const svg = document.getElementById("map");
       svg.innerHTML = "";
       const ns = "http://www.w3.org/2000/svg";
       const defs = document.createElementNS(ns, "defs");
       const markerForward = document.createElementNS(ns, "marker");
       markerForward.id = "arrow-forward";
       markerForward.setAttribute("markerWidth", "10");
       markerForward.setAttribute("markerHeight", "10");
       markerForward.setAttribute("refX", "9");
       markerForward.setAttribute("refY", "3");
       markerForward.setAttribute("orient", "auto");
       markerForward.setAttribute("markerUnits", "strokeWidth");
       const pathForward = document.createElementNS(ns, "path");
       pathForward.setAttribute("d", "M0,0 L0,6 L9,3 z");
       pathForward.setAttribute("fill", "context-stroke");
       markerForward.appendChild(pathForward);
       defs.appendChild(markerForward);
       const markerBackward = document.createElementNS(ns, "marker");
       markerBackward.id = "arrow-backward";
       markerBackward.setAttribute("markerWidth", "10");
       markerBackward.setAttribute("markerHeight", "10");
       markerBackward.setAttribute("refX", "0");
       markerBackward.setAttribute("refY", "3");
       markerBackward.setAttribute("orient", "auto");
       markerBackward.setAttribute("markerUnits", "strokeWidth");
       const pathBackward = document.createElementNS(ns, "path");
       pathBackward.setAttribute("d", "M9,0 L9,6 L0,3 z");
       pathBackward.setAttribute("fill", "context-stroke");
       markerBackward.appendChild(pathBackward);
       defs.appendChild(markerBackward);
       svg.appendChild(defs);
       const boundary = document.createElementNS(ns, "rect");
       boundary.setAttribute("x", CANVAS_PADDING);
       boundary.setAttribute("y", CANVAS_PADDING);
       boundary.setAttribute("width", CANVAS_WIDTH - CANVAS_PADDING * 2);
       boundary.setAttribute("height", CANVAS_HEIGHT - CANVAS_PADDING * 2);
       boundary.setAttribute("fill", "none");
       boundary.setAttribute("stroke", "rgba(71, 85, 105, 0.3)");
       boundary.setAttribute("stroke-width", "2");
       boundary.setAttribute("stroke-dasharray", "10 5");
       boundary.setAttribute("rx", "8");
       svg.appendChild(boundary);
       
       if (currentView.mode === "rack" && currentView.rackId) {
        const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
        const rackGroup = document.createElementNS(ns, "g");
        rackGroup.id = "rack-visualization";
        
        const rackFrame = document.createElementNS(ns, "rect");
        rackFrame.setAttribute("x", RACK_START_X - RACK_WIDTH / 2);
        rackFrame.setAttribute("y", RACK_START_Y);
        rackFrame.setAttribute("width", RACK_WIDTH);
      
      rackFrame.setAttribute("height", rackCapacity * rackUHeight);
      
        rackFrame.setAttribute("fill", "rgba(15, 23, 42, 0.3)");
        rackFrame.setAttribute("stroke", "var(--accent)");
        rackFrame.setAttribute("stroke-width", "3");
        rackFrame.setAttribute("rx", "4");
        rackGroup.appendChild(rackFrame);
        
        for (let u = 0; u <= rackCapacity; u++) {
         const y = RACK_START_Y + u * rackUHeight;
      
         
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", RACK_START_X - RACK_WIDTH / 2);
         line.setAttribute("y1", y);
         line.setAttribute("x2", RACK_START_X + RACK_WIDTH / 2);
         line.setAttribute("y2", y);
         line.setAttribute("stroke", "rgba(71, 85, 105, 0.4)");
         line.setAttribute("stroke-width", u % 5 === 0 ? "2" : "1");
         line.setAttribute("stroke-dasharray", u % 5 === 0 ? "none" : "5,5");
         rackGroup.appendChild(line);
         
         if (u < rackCapacity) {
          const uNumber = rackCapacity - u; 
          const text = document.createElementNS(ns, "text");
          text.setAttribute("x", RACK_START_X - RACK_WIDTH / 2 - 30);
          text.setAttribute("y", y + rackUHeight / 2);
      
          text.setAttribute("text-anchor", "middle");
          text.setAttribute("dominant-baseline", "middle");
          text.style.fill = "var(--accent)";
          text.style.fontSize = "14px";
          text.style.fontWeight = "bold";
          text.textContent = `U${uNumber}`;
          rackGroup.appendChild(text);
          
          const textRight = document.createElementNS(ns, "text");
          textRight.setAttribute("x", RACK_START_X + RACK_WIDTH / 2 + 30);
          textRight.setAttribute("y", y + rackUHeight / 2);
      
          textRight.setAttribute("text-anchor", "middle");
          textRight.setAttribute("dominant-baseline", "middle");
          textRight.style.fill = "var(--accent)";
          textRight.style.fontSize = "14px";
          textRight.style.fontWeight = "bold";
          textRight.textContent = `U${uNumber}`;
          rackGroup.appendChild(textRight);
         }
        }
        
        svg.appendChild(rackGroup);
       }
       
        if (RECT_DATA && RECT_DATA.list) {
         RECT_DATA.list.forEach((rect) => {
          if (currentView.mode === "rack") return;
          
          if (rect.style === "filled") {
           const g = document.createElementNS(ns, "g");
           g.classList.add("rect-group");
           g.dataset.rectId = rect.id;
           
           const rectEl = document.createElementNS(ns, "rect");
           rectEl.classList.add("rect-shape");
           rectEl.setAttribute("x", rect.x);
           rectEl.setAttribute("y", rect.y);
           rectEl.setAttribute("width", rect.width);
           rectEl.setAttribute("height", rect.height);
           rectEl.style.fill = rect.color;
           rectEl.style.fillOpacity = "0.3";
           rectEl.style.stroke = rect.color;
           rectEl.style.strokeWidth = "2";
           rectEl.style.cursor = "move";
           
           const deleteBtn = document.createElementNS(ns, "g");
           deleteBtn.classList.add("rect-delete-btn");
           deleteBtn.style.cursor = "pointer";
           deleteBtn.style.display = rectDrawMode ? "block" : "none";
           
           const deleteBg = document.createElementNS(ns, "circle");
           deleteBg.setAttribute("cx", rect.x + rect.width - 10);
           deleteBg.setAttribute("cy", rect.y + 10);
           deleteBg.setAttribute("r", 12);
           deleteBg.style.fill = "#f56565";
           deleteBg.style.stroke = "white";
           deleteBg.style.strokeWidth = "2";
           
           const deleteX = document.createElementNS(ns, "text");
           deleteX.setAttribute("x", rect.x + rect.width - 10);
           deleteX.setAttribute("y", rect.y + 10);
           deleteX.setAttribute("text-anchor", "middle");
           deleteX.setAttribute("dominant-baseline", "middle");
           deleteX.style.fill = "white";
           deleteX.style.fontSize = "16px";
           deleteX.style.fontWeight = "bold";
           deleteX.style.pointerEvents = "none";
           deleteX.textContent = "√ó";
           
           deleteBtn.appendChild(deleteBg);
           deleteBtn.appendChild(deleteX);
           
           deleteBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            e.preventDefault();
            deleteRectangle(rect.id);
           });
      
           deleteBtn.addEventListener("touchend", (e) => {
      e.stopPropagation();
           e.preventDefault();
           deleteRectangle(rect.id);
           });
           
           let isDragging = false;
           let dragStartX, dragStartY;
           let rectStartX, rectStartY;
           
           rectEl.addEventListener("mousedown", (e) => {
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            dragStartX = e.clientX;
            dragStartY = e.clientY;
            rectStartX = rect.x;
            rectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           });
           
           const moveHandler = (e) => {
            if (!isDragging || rectDrawMode) return;
            const svgEl = svg;
            const pt1 = svgEl.createSVGPoint();
            pt1.x = dragStartX;
            pt1.y = dragStartY;
            const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
            
            const pt2 = svgEl.createSVGPoint();
            pt2.x = e.clientX;
            pt2.y = e.clientY;
            const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
            
            const dx = svgP2.x - svgP1.x;
            const dy = svgP2.y - svgP1.y;
            
            rect.x = rectStartX + dx;
            rect.y = rectStartY + dy;
            
            forgeTheTopology();
           };
           
           const upHandler = () => {
            if (isDragging) {
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           };
           
           document.addEventListener("mousemove", moveHandler);
           document.addEventListener("mouseup", upHandler);
           
           let touchStartX, touchStartY;
           let touchRectStartX, touchRectStartY;
           
           rectEl.addEventListener("touchstart", (e) => {
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchRectStartX = rect.x;
            touchRectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           }, { passive: false });
           
           rectEl.addEventListener("touchmove", (e) => {
            if (!isDragging || rectDrawMode) return;
            if (!e.touches[0]) return;
            e.preventDefault();
            e.stopPropagation();
            
            const svgEl = svg;
            const pt1 = svgEl.createSVGPoint();
            pt1.x = touchStartX;
            pt1.y = touchStartY;
            const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
            
            const touch = e.touches[0];
            const pt2 = svgEl.createSVGPoint();
            pt2.x = touch.clientX;
            pt2.y = touch.clientY;
            const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
            
            const dx = svgP2.x - svgP1.x;
            const dy = svgP2.y - svgP1.y;
            
            rect.x = touchRectStartX + dx;
            rect.y = touchRectStartY + dy;
            
            forgeTheTopology();
           }, { passive: false });
           
           rectEl.addEventListener("touchend", (e) => {
            if (isDragging) {
             e.preventDefault();
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           }, { passive: false });
           
           g.appendChild(rectEl);
           g.appendChild(deleteBtn);
           svg.appendChild(g);
          }
         });
        }
       const centerX = CANVAS_WIDTH / 2;
       const centerY = CANVAS_HEIGHT / 2;
       let positions = {};
              Object.keys(NODE_DATA).forEach((id) => {
        if (currentView.mode === "rack") {
         const node = NODE_DATA[id];
         if (!node || node.assignedRack !== currentView.rackId) {
          return; 
         }
        }
        
        positions[id] = savedPositions[id] || {
         x: centerX,
         y: centerY
        };
       });
       if (Object.keys(savedPositions).length === 0) {
        const nodeIds = Object.keys(NODE_DATA).filter(id => {
         if (currentView.mode === "rack") {
          const node = NODE_DATA[id];
          return node && node.assignedRack === currentView.rackId;
         }
         return true;
        });
        
        const baseY = centerY - 300;
        if (nodeIds.length > 0) {
         positions[nodeIds[0]] = {
          x: centerX,
          y: baseY
         };
         const remaining = nodeIds.slice(1);
         const radius = 350;
         const startAngle = Math.PI * 0.3;
         const endAngle = Math.PI * 0.7;
         remaining.forEach((id, i) => {
          const angle = startAngle + (endAngle - startAngle) * (i / Math.max(1, remaining.length - 1));
          positions[id] = {
           x: centerX + Math.cos(angle) * radius * (i % 2 === 0 ? 1 : 1.3),
           y: baseY + 200 + Math.sin(angle) * radius * 0.8 + i * 80,
          };
         });
        }
       }
       Object.keys(positions).forEach((id) => {
        let pos = savedPositions[id] || positions[id];
        const nodeSize = savedSizes[id] || 55;
        pos.x = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, pos.x), );
        pos.y = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, pos.y), );
        positions[id] = {
         x: pos.x,
         y: pos.y
        };
        savedPositions[id] = {
         x: pos.x,
         y: pos.y
        };
       });
       const edgePairCount = {};
       const edgePairIndex = {};
       EDGE_DATA.list.forEach((edge) => {
        if (edge.type === "custom") return;
        const key = [edge.from, edge.to].sort().join("||");
        edgePairCount[key] = (edgePairCount[key] || 0) + 1;
       });
       EDGE_DATA.list.forEach((edge) => {
        if (edge.type === "custom") return;
        const key = [edge.from, edge.to].sort().join("||");
        if (!edgePairIndex[key]) edgePairIndex[key] = 0;
        edge._pairIndex = edgePairIndex[key];
        edge._pairTotal = edgePairCount[key];
        edgePairIndex[key]++;
       });
       EDGE_DATA.list.forEach((edge) => {
        if (edge.type === "custom" && Array.isArray(edge.points) && edge.points.length >= 2) {
         const poly = document.createElementNS(ns, "polyline");
         poly.classList.add("edge");
         poly.dataset.edgeId = edge.id;
         poly.style.stroke = edge.color || "#475569";
         poly.style.strokeWidth = edge.width || 4;
         poly.setAttribute("fill", "none");
         const lineStyle = edge.lineStyle || "solid";
         if (lineStyle === "dashed") {
          poly.style.strokeDasharray = "10,5";
         } else if (lineStyle === "dotted") {
          poly.style.strokeDasharray = "2,4";
         } else {
          poly.style.strokeDasharray = "none";
         }
         const direction = edge.direction || "none";
         if (direction === "forward") {
          poly.setAttribute("marker-end", "url(#arrow-forward)");
         } else if (direction === "backward") {
          poly.setAttribute("marker-start", "url(#arrow-backward)");
         } else if (direction === "both") {
          poly.setAttribute("marker-start", "url(#arrow-backward)");
          poly.setAttribute("marker-end", "url(#arrow-forward)");
         }
         const ptsStr = edge.points.map((p) => `${p.x},${p.y}`).join(" ");
         poly.setAttribute("points", ptsStr);
         const polyHit = document.createElementNS(ns, "polyline");
         polyHit.setAttribute("points", ptsStr);
         polyHit.style.fill = "none";
         polyHit.style.stroke = "transparent";
         polyHit.style.strokeWidth = "20";
         polyHit.style.cursor = "pointer";
         polyHit.dataset.edgeId = edge.id;
         polyHit.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         let edgeTouchStart = null;
         let edgeTouchMoved = false;
         polyHit.addEventListener("touchstart", (e) => {
          edgeTouchStart = Date.now();
          edgeTouchMoved = false;
         }, {
          passive: false
         });
         polyHit.addEventListener("touchmove", (e) => {
          edgeTouchMoved = true;
         }, {
          passive: false
         });
         polyHit.addEventListener("touchend", (e) => {
          if (edgeTouchStart && !edgeTouchMoved && Date.now() - edgeTouchStart < 400) {
           e.stopPropagation();
           e.preventDefault();
           selectTheConnection(edge.id);
          }
          edgeTouchStart = null;
          edgeTouchMoved = false;
         }, {
          passive: false
         });
         poly.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         
         if (currentView.mode === "rack") {
          return;
         }
         
         svg.appendChild(poly);
         svg.appendChild(polyHit);
         return;
        }
        const p1 = positions[edge.from];
        const p2 = positions[edge.to];
        if (!p1 || !p2) return;
        const pairTotal = edge._pairTotal || 1;
        const pairIndex = edge._pairIndex || 0;
        const midX = (p1.x + p2.x) / 2;
        const midY = (p1.y + p2.y) / 2;
        const dx = p2.x - p1.x;
        const dy = p2.y - p1.y;
        const len = Math.sqrt(dx * dx + dy * dy) || 1;
        const perpX = -dy / len;
        const perpY = dx / len;
        let offsetAmount = 0;
        if (pairTotal > 1) {
         offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
        }
        const ctrlX = midX + perpX * offsetAmount;
        const ctrlY = midY + perpY * offsetAmount;
        const path = document.createElementNS(ns, "path");
        path.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
        path.setAttribute("fill", "none");
        path.classList.add("edge");
        if (edge.type === "backup") path.classList.add("backup");
        path.dataset.edgeId = edge.id;
        path.dataset.from = edge.from;
        path.dataset.to = edge.to;
        path.style.stroke = edge.color;
        path.style.strokeWidth = edge.width;
        const pathHit = document.createElementNS(ns, "path");
        pathHit.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
        pathHit.setAttribute("fill", "none");
        pathHit.style.stroke = "transparent";
        pathHit.style.strokeWidth = "20";
        pathHit.style.cursor = "pointer";
        pathHit.dataset.edgeId = edge.id;
        pathHit.addEventListener("click", (e) => {
         e.stopPropagation();
         selectTheConnection(edge.id);
        });
        let pathTouchStart = null;
        let pathTouchMoved = false;
        pathHit.addEventListener("touchstart", (e) => {
         pathTouchStart = Date.now();
         pathTouchMoved = false;
        }, {
         passive: false
        });
        pathHit.addEventListener("touchmove", (e) => {
         pathTouchMoved = true;
        }, {
         passive: false
        });
        pathHit.addEventListener("touchend", (e) => {
         if (pathTouchStart && !pathTouchMoved && Date.now() - pathTouchStart < 400) {
          e.stopPropagation();
          e.preventDefault();
          selectTheConnection(edge.id);
         }
         pathTouchStart = null;
         pathTouchMoved = false;
        }, {
         passive: false
        });
        path.addEventListener("click", (e) => {
         e.stopPropagation();
         selectTheConnection(edge.id);
        });
        
        if (currentView.mode === "rack") {
         const fromNode = NODE_DATA[edge.from];
         const toNode = NODE_DATA[edge.to];
         if (!fromNode || !toNode || 
             fromNode.assignedRack !== currentView.rackId || 
             toNode.assignedRack !== currentView.rackId) {
          return; 
         }
        }
        
        const fromVisible = isNodeVisible(edge.from);
        const toVisible = isNodeVisible(edge.to);
        if (!fromVisible || !toVisible) {
         path.style.opacity = "0.1";
         path.style.pointerEvents = "none";
         pathHit.style.pointerEvents = "none";
        }
        
        svg.appendChild(path);
        svg.appendChild(pathHit);
        
        if (edge.fromPort || edge.toPort) {
         const ns = "http://www.w3.org/2000/svg";
         
         if (edge.fromPort) {
          const fromLabel = document.createElementNS(ns, "text");
          fromLabel.textContent = edge.fromPort;
          fromLabel.setAttribute("x", p1.x);
          fromLabel.setAttribute("y", p1.y - 10);
          fromLabel.setAttribute("text-anchor", "middle");
          fromLabel.style.fill = "#94a3b8";
          fromLabel.style.fontSize = "12px";
          fromLabel.style.fontWeight = "600";
          fromLabel.style.pointerEvents = "none";
          fromLabel.classList.add("port-label");
          svg.appendChild(fromLabel);
         }
         
         if (edge.toPort) {
          const toLabel = document.createElementNS(ns, "text");
          toLabel.textContent = edge.toPort;
          toLabel.setAttribute("x", p2.x);
          toLabel.setAttribute("y", p2.y - 10);
          toLabel.setAttribute("text-anchor", "middle");
          toLabel.style.fill = "#94a3b8";
          toLabel.style.fontSize = "12px";
          toLabel.style.fontWeight = "600";
          toLabel.style.pointerEvents = "none";
          toLabel.classList.add("port-label");
          svg.appendChild(toLabel);
         }
        }
       });
       Object.entries(positions).forEach(([id, pos]) => {
        const node = NODE_DATA[id];
        if (!node) return;
        
        if (currentView.mode === "rack") {
         if (node.assignedRack !== currentView.rackId) return;
         
         const rackUnit = parseInt(node.rackUnit) || 1;
      const uHeight = parseInt(node.uHeight) || 1;
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      pos.x = RACK_START_X;
      pos.y = RACK_START_Y + (rackCapacity - rackUnit - uHeight + 1) * rackUHeight + (uHeight * rackUHeight) / 2;
      
        } else {
         if (node.assignedRack) return;
        }
        
        const g = document.createElementNS("http://www.w3.org/2000/svg", "g", );
        g.classList.add("node-group");
        g.dataset.nodeId = id;
        g.setAttribute("transform", `translate(${pos.x},${pos.y})`);
        let r = savedSizes[id] || 55;
        if (!savedSizes[id]) {
         if (window.innerWidth <= 380) r = 120;
         else if (window.innerWidth <= 768) r = 140;
         else if (window.innerWidth <= 1024) r = 70;
        }
        const styles = resolveStylesForNode(id);
        const ns = "http://www.w3.org/2000/svg";
        const hitArea = document.createElementNS(ns, "circle");
        hitArea.setAttribute("r", r * 1.5);
        hitArea.style.fill = "transparent";
        hitArea.style.stroke = "none";
        hitArea.style.cursor = "grab";
        hitArea.classList.add("node-hit-area");
        const shapeEl = createNodeShape(id, r);
        const titleOffsetX = styles.titleOffsetX || 0;
        const titleOffsetY = styles.titleOffsetY || 0;
        const subOffsetX = styles.subOffsetX || 0;
        const subOffsetY = styles.subOffsetY || 0;
        const label = document.createElementNS("http://www.w3.org/2000/svg", "text", );
        label.classList.add("node-label");
        label.setAttribute("x", titleOffsetX);
        label.setAttribute("y", -r * 0.28 + titleOffsetY);
        const labelFontSize = styles.titleSize || r * 0.33;
        label.style.fontSize = labelFontSize + "px";
        label.textContent = NODE_DATA[id].name;
        if (styles.titleColor) label.style.fill = styles.titleColor;
        if (styles.titleFont) label.style.fontFamily = styles.titleFont;
        label.style.pointerEvents = "none";
        const sub = document.createElementNS("http://www.w3.org/2000/svg", "text", );
        sub.classList.add("node-sub");
        sub.setAttribute("x", subOffsetX);
        sub.setAttribute("y", r * 0.4 + subOffsetY);
        const subFontSize = styles.subSize || r * 0.24;
        sub.style.fontSize = subFontSize + "px";
        sub.textContent = NODE_DATA[id].ip;
        if (styles.subColor) sub.style.fill = styles.subColor;
        if (styles.subFont) sub.style.fontFamily = styles.subFont;
        sub.style.pointerEvents = "none";
        g.append(hitArea, shapeEl, label, sub);
        
        if (NODE_DATA[id]?.locked) {
          const lockIcon = document.createElementNS(ns, "text");
          lockIcon.textContent = "üîí";
          lockIcon.setAttribute("x", r * 0.6);
          lockIcon.setAttribute("y", -r * 0.6);
          lockIcon.style.fontSize = (r * 0.4) + "px";
          lockIcon.style.pointerEvents = "none";
          lockIcon.style.userSelect = "none";
          lockIcon.classList.add("lock-indicator");
          g.appendChild(lockIcon);
        }
        
        if (NODE_DATA[id]?.groupId) {
          const groupIndicator = document.createElementNS(ns, "circle");
          groupIndicator.setAttribute("r", r + 4);
          groupIndicator.style.fill = "none";
          groupIndicator.style.stroke = "#4fd1c5";
          groupIndicator.style.strokeWidth = "3";
          groupIndicator.style.strokeDasharray = "5,5";
          groupIndicator.style.pointerEvents = "none";
          groupIndicator.classList.add("group-indicator");
          g.insertBefore(groupIndicator, g.firstChild);
        }
        
        let isDragging = false;
        let startX, startY;
        let initialPositions = {};
        let longPressTimer = null;
        let longPressTriggered = false;
        
        g.addEventListener("contextmenu", (e) => {
         e.preventDefault();
         e.stopPropagation();
         
         if (selectedNodes.has(id)) {
          selectedNodes.delete(id);
         } else {
          selectedNodes.add(id);
         }
         updateNodeSelection();
         return false;
        });
        
        g.addEventListener("touchstart", (e) => {
         if (NODE_DATA[id].isRack) {
          longPressTimer = setTimeout(() => {
           longPressTriggered = true;
           if (navigator.vibrate) {
            navigator.vibrate(100);
           }
           enterRack(id);
          }, 500); 
         }
        }, { passive: true });
        
        let lastTapTime = 0;
        let lastTapNode = null;
        
        g.addEventListener("touchend", (e) => {
         const currentTime = new Date().getTime();
         const tapLength = currentTime - lastTapTime;
         
         if (tapLength < 300 && tapLength > 0 && lastTapNode === id) {
          e.preventDefault();
          e.stopPropagation();
          
          if (selectedNodes.has(id)) {
           selectedNodes.delete(id);
          } else {
           selectedNodes.add(id);
          }
          updateNodeSelection();
          
          if (navigator.vibrate) {
           navigator.vibrate(50);
          }
          
          lastTapTime = 0;
          lastTapNode = null;
         } else {
          lastTapTime = currentTime;
          lastTapNode = id;
         }
        });
        
        g.addEventListener("touchend", (e) => {
         if (longPressTimer) {
          clearTimeout(longPressTimer);
          longPressTimer = null;
         }
         if (longPressTriggered) {
          e.preventDefault();
          e.stopPropagation();
          longPressTriggered = false;
         }
        });
        
        g.addEventListener("touchmove", (e) => {
         if (longPressTimer) {
          clearTimeout(longPressTimer);
          longPressTimer = null;
          longPressTriggered = false;
         }
        });
        
        g.addEventListener("mousedown", (e) => {
         if (e.button === 2) {
          return;
         }
         
         if (NODE_DATA[id]?.locked) {
          return;
         }
         
         e.preventDefault();
         isDragging = true;
         const svgEl = document.getElementById("map");
         const pt = svgEl.createSVGPoint();
         pt.x = e.clientX;
         pt.y = e.clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
         startX = svgP.x;
         startY = svgP.y;
         
      if (selectedNodes.has(id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) {
      initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      }
      });
      } else {
      initialPositions = { [id]: { x: pos.x, y: pos.y } };
      }
      if (currentView.mode === "rack") {
      initialPositions[id] = { x: pos.x, y: pos.y };
      }
         
         g.style.cursor = "grabbing";
         hitArea.style.cursor = "grabbing";
         e.stopPropagation();
        });
        const handleMouseMove = (e) => {
         if (!isDragging) return;
         e.preventDefault();
         const svgEl = document.getElementById("map");
         const pt = svgEl.createSVGPoint();
         pt.x = e.clientX;
         pt.y = e.clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
         const dx = svgP.x - startX;
         const dy = svgP.y - startY;
         
         let nodesToMove = selectedNodes.has(id) ? Array.from(selectedNodes) : [id];
         
         const groupIds = new Set();
         nodesToMove.forEach(nodeId => {
          const groupId = NODE_DATA[nodeId]?.groupId;
          if (groupId) {
            groupIds.add(groupId);
          }
         });
         
         if (groupIds.size > 0) {
          Object.keys(NODE_DATA).forEach(nodeId => {
            const nodeGroupId = NODE_DATA[nodeId]?.groupId;
            if (nodeGroupId && groupIds.has(nodeGroupId)) {
              if (!nodesToMove.includes(nodeId)) {
                nodesToMove.push(nodeId);
                if (!initialPositions[nodeId]) {
                  const nodePos = savedPositions[nodeId];
                  if (nodePos) {
                    initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
                  }
                }
              }
            }
          });
         }
         
         nodesToMove = nodesToMove.filter(nodeId => !NODE_DATA[nodeId]?.locked);
         
         nodesToMove.forEach(nodeId => {
          if (!initialPositions[nodeId]) return;
          const initialPos = initialPositions[nodeId];
          let newX = initialPos.x + dx;
          let newY = initialPos.y + dy;
          const nodeSize = savedSizes[nodeId] || 55;
          newX = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, newX), );
          newY = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, newY), );
          
          savedPositions[nodeId] = { x: newX, y: newY };
          positions[nodeId] = { x: newX, y: newY };
          
          if (nodeId === id) {
           pos.x = newX;
           pos.y = newY;
          }
          
          const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
          if (nodeGroup) {
           nodeGroup.setAttribute("transform", `translate(${newX},${newY})`);
          }
         });
         
         updateMinimap();
         document.querySelectorAll(".edge").forEach((edgeEl) => {
          const fromId = edgeEl.dataset.from;
          const toId = edgeEl.dataset.to;
          if (nodesToMove.includes(fromId) || nodesToMove.includes(toId)) {
           const p1 = savedPositions[fromId] || positions[fromId] || {
            x: 600,
            y: 350
           };
           const p2 = savedPositions[toId] || positions[toId] || {
            x: 600,
            y: 350
           };
           if (edgeEl.tagName === "line") {
            edgeEl.setAttribute("x1", p1.x);
            edgeEl.setAttribute("y1", p1.y);
            edgeEl.setAttribute("x2", p2.x);
            edgeEl.setAttribute("y2", p2.y);
           } else if (edgeEl.tagName === "path") {
            const edgeId = edgeEl.dataset.edgeId;
            const edge = EDGE_DATA.list.find(
             (e) => e.id === edgeId, );
            if (edge) {
             const pairTotal = edge._pairTotal || 1;
             const pairIndex = edge._pairIndex || 0;
             const midX = (p1.x + p2.x) / 2;
             const midY = (p1.y + p2.y) / 2;
             const dx = p2.x - p1.x;
             const dy = p2.y - p1.y;
             const len = Math.sqrt(dx * dx + dy * dy) || 1;
             const perpX = -dy / len;
             const perpY = dx / len;
             let offsetAmount = 0;
             if (pairTotal > 1) {
              offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
             }
             const ctrlX = midX + perpX * offsetAmount;
             const ctrlY = midY + perpY * offsetAmount;
             edgeEl.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
            }
           }
          }
         });
        };
      const handleMouseUp = () => {
      if (isDragging) {
      pushUndo("move nodes");
      isDragging = false;
      g.style.cursor = "grab";
      hitArea.style.cursor = "grab";
      if (currentView.mode === "rack" && NODE_DATA[id]?.assignedRack === currentView.rackId) {
      const draggedY = savedPositions[id]?.y || pos.y;
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      let newUnit = rackCapacity - Math.round((draggedY - RACK_START_Y) / rackUHeight);
      newUnit = Math.max(1, Math.min(newUnit, rackCapacity));
      NODE_DATA[id].rackUnit = newUnit;
      
      forgeTheTopology();
      claimTheImmortal(id);
      }
      }
      };
        document.addEventListener("mousemove", handleMouseMove);
        document.addEventListener("mouseup", handleMouseUp);
        let touchStartTime = 0;
        let touchStartX = 0;
        let touchStartY = 0;
        let touchMoved = false;
       g.addEventListener("touchstart",
         (e) => {
          if (NODE_DATA[id]?.locked) {
           return;
          }
          
          e.preventDefault();
          touchStartTime = Date.now();
          touchMoved = false;
          const svgEl = document.getElementById("map");
          const pt = svgEl.createSVGPoint();
          const touch = e.touches[0];
          pt.x = touch.clientX;
          pt.y = touch.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          touchStartX = svgP.x;
          touchStartY = svgP.y;
          startX = svgP.x;
          startY = svgP.y;
          
          if (selectedNodes.has(id)) {
           initialPositions = {};
           selectedNodes.forEach(nodeId => {
            const nodePos = savedPositions[nodeId];
            if (nodePos) {
             initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
            }
           });
          } else {
           initialPositions = { [id]: { x: pos.x, y: pos.y } };
          }
          
          e.stopPropagation();
         }, {
          passive: false
         }, );
        g.addEventListener("touchmove", (e) => {
         e.preventDefault();
         const svgEl = document.getElementById("map");
         const pt = svgEl.createSVGPoint();
         const touch = e.touches[0];
         pt.x = touch.clientX;
         pt.y = touch.clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
         const dx = Math.abs(svgP.x - touchStartX);
         const dy = Math.abs(svgP.y - touchStartY);
         if (dx > (isMobileDevice() ? 4 : 10) || dy > (isMobileDevice() ? 4 : 10)) {
      touchMoved = true;
      isDragging = true;
      }
         if (!isDragging) return;
         
         const deltaX = svgP.x - startX;
         const deltaY = svgP.y - startY;
         
         let nodesToMove = selectedNodes.has(id) ? Array.from(selectedNodes) : [id];
         
         const groupIds = new Set();
         nodesToMove.forEach(nodeId => {
          const groupId = NODE_DATA[nodeId]?.groupId;
          if (groupId) {
            groupIds.add(groupId);
          }
         });
         
         if (groupIds.size > 0) {
          Object.keys(NODE_DATA).forEach(nodeId => {
            const nodeGroupId = NODE_DATA[nodeId]?.groupId;
            if (nodeGroupId && groupIds.has(nodeGroupId)) {
              if (!nodesToMove.includes(nodeId)) {
                nodesToMove.push(nodeId);
                if (!initialPositions[nodeId]) {
                  const nodePos = savedPositions[nodeId];
                  if (nodePos) {
                    initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
                  }
                }
              }
            }
          });
         }
         
         nodesToMove = nodesToMove.filter(nodeId => !NODE_DATA[nodeId]?.locked);
         
         nodesToMove.forEach(nodeId => {
          if (!initialPositions[nodeId]) return;
          const initialPos = initialPositions[nodeId];
          let newX = initialPos.x + deltaX;
          let newY = initialPos.y + deltaY;
          const nodeSize = savedSizes[nodeId] || 55;
          newX = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, newX), );
          newY = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, newY), );
          
          savedPositions[nodeId] = { x: newX, y: newY };
          positions[nodeId] = { x: newX, y: newY };
          
          if (nodeId === id) {
           pos.x = newX;
           pos.y = newY;
          }
          
          const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
          if (nodeGroup) {
           nodeGroup.setAttribute("transform", `translate(${newX},${newY})`);
          }
         });
         
         updateMinimap();
         document.querySelectorAll(".edge").forEach((edgeEl) => {
          const fromId = edgeEl.dataset.from;
          const toId = edgeEl.dataset.to;
          if (nodesToMove.includes(fromId) || nodesToMove.includes(toId)) {
           const p1 = savedPositions[fromId] || positions[fromId] || {
            x: 600,
            y: 350
           };
           const p2 = savedPositions[toId] || positions[toId] || {
            x: 600,
            y: 350
           };
           if (edgeEl.tagName === "line") {
            edgeEl.setAttribute("x1", p1.x);
            edgeEl.setAttribute("y1", p1.y);
            edgeEl.setAttribute("x2", p2.x);
            edgeEl.setAttribute("y2", p2.y);
           } else if (edgeEl.tagName === "path") {
            const edgeId = edgeEl.dataset.edgeId;
            const edge = EDGE_DATA.list.find(
             (e) => e.id === edgeId, );
            if (edge) {
             const pairTotal = edge._pairTotal || 1;
             const pairIndex = edge._pairIndex || 0;
             const midX = (p1.x + p2.x) / 2;
             const midY = (p1.y + p2.y) / 2;
             const dx = p2.x - p1.x;
             const dy = p2.y - p1.y;
             const len = Math.sqrt(dx * dx + dy * dy) || 1;
             const perpX = -dy / len;
             const perpY = dx / len;
             let offsetAmount = 0;
             if (pairTotal > 1) {
              offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
             }
             const ctrlX = midX + perpX * offsetAmount;
             const ctrlY = midY + perpY * offsetAmount;
             edgeEl.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
            }
           }
          }
         });
        }, {
         passive: false
        });
      g.addEventListener("touchend", (e) => {
      const touchDuration = Date.now() - touchStartTime;
      if (!touchMoved && touchDuration < 400) {
      claimTheImmortal(id);
      }
      if (isDragging) {
      const draggedY = pos.y;
      isDragging = false;
      savedPositions[id] = {
      x: pos.x,
      y: pos.y
      };
      if (currentView.mode === "rack" && NODE_DATA[id]?.assignedRack === currentView.rackId) {
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      let newUnit = rackCapacity - Math.round((draggedY - RACK_START_Y) / rackUHeight);
      
      newUnit = Math.max(1, Math.min(newUnit, rackCapacity));
      NODE_DATA[id].rackUnit = newUnit;
      forgeTheTopology();
      claimTheImmortal(id);
      }
      }
      touchMoved = false;
      });
        g.style.cursor = "grab";
        g.addEventListener("click", (e) => {
         if (!isDragging) {
          claimTheImmortal(id);
         }
        });
        
        g.addEventListener("dblclick", (e) => {
         e.preventDefault();
         e.stopPropagation();
         if (NODE_DATA[id].isRack) {
          enterRack(id);
         }
        });
        
        if (!isNodeVisible(id)) {
         g.style.opacity = "0.1";
         g.style.pointerEvents = "none";
        }
        
        svg.appendChild(g);
       });
        if (RECT_DATA && RECT_DATA.list) {
         RECT_DATA.list.forEach((rect) => {
          if (rect.style === "outlined") {
           const g = document.createElementNS(ns, "g");
           g.classList.add("rect-group");
           g.dataset.rectId = rect.id;
           
           const rectEl = document.createElementNS(ns, "rect");
           rectEl.classList.add("rect-shape");
           rectEl.setAttribute("x", rect.x);
           rectEl.setAttribute("y", rect.y);
           rectEl.setAttribute("width", rect.width);
           rectEl.setAttribute("height", rect.height);
           rectEl.style.fill = "none";
           rectEl.style.stroke = rect.color;
           rectEl.style.strokeWidth = "3";
           rectEl.style.cursor = "move";
           
           const deleteBtn = document.createElementNS(ns, "g");
           deleteBtn.classList.add("rect-delete-btn");
           deleteBtn.style.cursor = "pointer";
           deleteBtn.style.display = rectDrawMode ? "block" : "none";
           
           const deleteBg = document.createElementNS(ns, "circle");
           deleteBg.setAttribute("cx", rect.x + rect.width - 10);
           deleteBg.setAttribute("cy", rect.y + 10);
           deleteBg.setAttribute("r", 12);
           deleteBg.style.fill = "#f56565";
           deleteBg.style.stroke = "white";
           deleteBg.style.strokeWidth = "2";
           
           const deleteX = document.createElementNS(ns, "text");
           deleteX.setAttribute("x", rect.x + rect.width - 10);
           deleteX.setAttribute("y", rect.y + 10);
           deleteX.setAttribute("text-anchor", "middle");
           deleteX.setAttribute("dominant-baseline", "middle");
           deleteX.style.fill = "white";
           deleteX.style.fontSize = "16px";
           deleteX.style.fontWeight = "bold";
           deleteX.style.pointerEvents = "none";
           deleteX.textContent = "√ó";
           
           deleteBtn.appendChild(deleteBg);
           deleteBtn.appendChild(deleteX);
           
           deleteBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            e.preventDefault();
            deleteRectangle(rect.id);
           });
           
           let isDragging = false;
           let dragStartX, dragStartY;
           let rectStartX, rectStartY;
           
           rectEl.addEventListener("mousedown", (e) => {
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            dragStartX = e.clientX;
            dragStartY = e.clientY;
            rectStartX = rect.x;
            rectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           });
           
           const moveHandler = (e) => {
            if (!isDragging || rectDrawMode) return;
            const svgEl = svg;
            const pt1 = svgEl.createSVGPoint();
            pt1.x = dragStartX;
            pt1.y = dragStartY;
            const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
            
            const pt2 = svgEl.createSVGPoint();
            pt2.x = e.clientX;
            pt2.y = e.clientY;
            const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
            
            const dx = svgP2.x - svgP1.x;
            const dy = svgP2.y - svgP1.y;
            
            rect.x = rectStartX + dx;
            rect.y = rectStartY + dy;
            
            forgeTheTopology();
           };
           
           const upHandler = () => {
            if (isDragging) {
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           };
           
           document.addEventListener("mousemove", moveHandler);
           document.addEventListener("mouseup", upHandler);
           
           let touchStartX, touchStartY;
           let touchRectStartX, touchRectStartY;
           
           rectEl.addEventListener("touchstart", (e) => {
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchRectStartX = rect.x;
            touchRectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           }, { passive: false });
           
           rectEl.addEventListener("touchmove", (e) => {
            if (!isDragging || rectDrawMode) return;
            if (!e.touches[0]) return;
            e.preventDefault();
            e.stopPropagation();
            
            const svgEl = svg;
            const pt1 = svgEl.createSVGPoint();
            pt1.x = touchStartX;
            pt1.y = touchStartY;
            const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
            
            const touch = e.touches[0];
            const pt2 = svgEl.createSVGPoint();
            pt2.x = touch.clientX;
            pt2.y = touch.clientY;
            const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
            
            const dx = svgP2.x - svgP1.x;
            const dy = svgP2.y - svgP1.y;
            
            rect.x = touchRectStartX + dx;
            rect.y = touchRectStartY + dy;
            
            forgeTheTopology();
           }, { passive: false });
           
           rectEl.addEventListener("touchend", (e) => {
            if (isDragging) {
             e.preventDefault();
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           }, { passive: false });
           
           g.appendChild(rectEl);
           g.appendChild(deleteBtn);
           svg.appendChild(g);
          }
         });
        }
        
        if (TEXT_DATA && TEXT_DATA.list) {
         TEXT_DATA.list.forEach((textItem) => {
          if (currentView.mode === "rack") return;
          
          const g = document.createElementNS(ns, "g");
          g.classList.add("text-group");
          g.dataset.textId = textItem.id;
          
          if (textItem.bgEnabled) {
           const bgRect = document.createElementNS(ns, "rect");
           bgRect.classList.add("text-bg");
           
           bgRect.setAttribute("x", textItem.x - 5);
           bgRect.setAttribute("y", textItem.y - textItem.fontSize - 2);
           bgRect.setAttribute("width", 100);
           bgRect.setAttribute("height", textItem.fontSize + 10);
           bgRect.style.fill = textItem.bgColor;
           bgRect.style.opacity = "0.7";
           bgRect.style.rx = "4";
           g.appendChild(bgRect);
          }
          
          const textEl = document.createElementNS(ns, "text");
          textEl.classList.add("text-element");
          textEl.setAttribute("x", textItem.x);
          textEl.setAttribute("y", textItem.y);
          textEl.style.fill = textItem.color;
          textEl.style.fontSize = textItem.fontSize + "px";
          textEl.style.fontWeight = textItem.fontWeight;
          textEl.style.fontStyle = textItem.fontStyle;
          textEl.style.textAnchor = textItem.textAlign;
          textEl.style.textDecoration = textItem.textDecoration;
          textEl.style.opacity = textItem.opacity;
          textEl.style.cursor = "move";
          textEl.style.userSelect = "none";
          textEl.setAttribute("dominant-baseline", "middle");
          
          const lines = textItem.content.split('\n');
          if (lines.length === 1) {
           textEl.textContent = textItem.content;
          } else {
           lines.forEach((line, i) => {
            const tspan = document.createElementNS(ns, "tspan");
            tspan.textContent = line;
            tspan.setAttribute("x", textItem.x);
            tspan.setAttribute("dy", i === 0 ? 0 : textItem.fontSize * 1.2);
            textEl.appendChild(tspan);
           });
          }
          
          g.appendChild(textEl);
          
          if (textItem.bgEnabled) {
           setTimeout(() => {
            try {
             const bbox = textEl.getBBox();
             const bgRect = g.querySelector('.text-bg');
             if (bgRect && bbox) {
              bgRect.setAttribute("x", bbox.x - 5);
              bgRect.setAttribute("y", bbox.y - 2);
              bgRect.setAttribute("width", bbox.width + 10);
              bgRect.setAttribute("height", bbox.height + 4);
             }
            } catch (e) {
            }
           }, 0);
          }
          
          const deleteBtn = document.createElementNS(ns, "g");
          deleteBtn.classList.add("text-delete-btn");
          deleteBtn.style.cursor = "pointer";
          deleteBtn.style.display = textDrawMode ? "block" : "none";
          
          const deleteBg = document.createElementNS(ns, "circle");
          deleteBg.setAttribute("cx", textItem.x + 20);
          deleteBg.setAttribute("cy", textItem.y - textItem.fontSize);
          deleteBg.setAttribute("r", 12);
          deleteBg.style.fill = "#f56565";
          deleteBg.style.stroke = "white";
          deleteBg.style.strokeWidth = "2";
          
          const deleteX = document.createElementNS(ns, "text");
          deleteX.setAttribute("x", textItem.x + 20);
          deleteX.setAttribute("y", textItem.y - textItem.fontSize);
          deleteX.setAttribute("text-anchor", "middle");
          deleteX.setAttribute("dominant-baseline", "middle");
          deleteX.style.fill = "white";
          deleteX.style.fontSize = "16px";
          deleteX.style.fontWeight = "bold";
          deleteX.style.pointerEvents = "none";
          deleteX.textContent = "√ó";
          
          deleteBtn.appendChild(deleteBg);
          deleteBtn.appendChild(deleteX);
          
          deleteBtn.addEventListener("click", (e) => {
           e.stopPropagation();
           e.preventDefault();
           deleteText(textItem.id);
          });
          
          let isDragging = false;
          let dragStartX, dragStartY;
          let textStartX, textStartY;
          
          textEl.addEventListener("mousedown", (e) => {
           if (textDrawMode) return;
           e.preventDefault();
           e.stopPropagation();
           isDragging = true;
           dragStartX = e.clientX;
           dragStartY = e.clientY;
           textStartX = textItem.x;
           textStartY = textItem.y;
           textEl.style.cursor = "grabbing";
           
           showTextPanel(textItem.id);
          });
          
          const moveHandler = (e) => {
           if (!isDragging || textDrawMode) return;
           const svgEl = svg;
           const pt1 = svgEl.createSVGPoint();
           pt1.x = dragStartX;
           pt1.y = dragStartY;
           const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
           
           const pt2 = svgEl.createSVGPoint();
           pt2.x = e.clientX;
           pt2.y = e.clientY;
           const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
           
           const dx = svgP2.x - svgP1.x;
           const dy = svgP2.y - svgP1.y;
           
           textItem.x = textStartX + dx;
           textItem.y = textStartY + dy;
           
           forgeTheTopology();
          };
          
          const upHandler = () => {
           if (isDragging) {
            isDragging = false;
            textEl.style.cursor = "move";
           }
          };
          
          document.addEventListener("mousemove", moveHandler);
          document.addEventListener("mouseup", upHandler);
          
          let touchStartX = 0, touchStartY = 0;
          let textTouchStartX = 0, textTouchStartY = 0;
          
          textEl.addEventListener("touchstart", (e) => {
           if (textDrawMode) return;
           if (e.touches.length !== 1) return;
           
           e.preventDefault();
           e.stopPropagation();
           const touch = e.touches[0];
           isDragging = true;
           touchStartX = touch.clientX;
           touchStartY = touch.clientY;
           textTouchStartX = textItem.x;
           textTouchStartY = textItem.y;
           
           showTextPanel(textItem.id);
          }, { passive: false });
          
          textEl.addEventListener("touchmove", (e) => {
           if (!isDragging || textDrawMode) return;
           if (e.touches.length !== 1) return;
           
           e.preventDefault();
           const touch = e.touches[0];
           const svgEl = svg;
           
           const pt1 = svgEl.createSVGPoint();
           pt1.x = touchStartX;
           pt1.y = touchStartY;
           const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
           
           const pt2 = svgEl.createSVGPoint();
           pt2.x = touch.clientX;
           pt2.y = touch.clientY;
           const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
           
           const dx = svgP2.x - svgP1.x;
           const dy = svgP2.y - svgP1.y;
           
           textItem.x = textTouchStartX + dx;
           textItem.y = textTouchStartY + dy;
           
           forgeTheTopology();
          }, { passive: false });
          
          textEl.addEventListener("touchend", () => {
           if (isDragging) {
            isDragging = false;
           }
          }, { passive: false });
          
          g.appendChild(deleteBtn);
          svg.appendChild(g);
         });
        }
        
       forgeTheLegend();
       updateMinimap();
       populateRackDropdown();
      }
      
      function showEditModal(title, currentValue, onSave) {
       const modal = document.getElementById("edit-modal");
       const input = document.getElementById("modal-input");
       const titleEl = document.getElementById("modal-title");
       const saveBtn = document.getElementById("modal-save");
       const cancelBtn = document.getElementById("modal-cancel");
       titleEl.textContent = title;
       input.value = currentValue;
       modal.classList.add("active");
       input.focus();
       input.select();
       const handleSave = () => {
        if (input.value.trim()) {
         onSave(input.value.trim());
        }
        modal.classList.remove("active");
        saveBtn.removeEventListener("click", handleSave);
        cancelBtn.removeEventListener("click", handleCancel);
        input.removeEventListener("keypress", handleEnter);
       };
       const handleCancel = () => {
        modal.classList.remove("active");
        saveBtn.removeEventListener("click", handleSave);
        cancelBtn.removeEventListener("click", handleCancel);
        input.removeEventListener("keypress", handleEnter);
       };
       const handleEnter = (e) => {
        if (e.key === "Enter") handleSave();
       };
       saveBtn.addEventListener("click", handleSave);
       cancelBtn.addEventListener("click", handleCancel);
       input.addEventListener("keypress", handleEnter);
       modal.addEventListener("click", function bgHandler(e) {
        if (e.target === modal) {
         handleCancel();
         modal.removeEventListener("click", bgHandler);
        }
       });
      }
      
      function challengeTheImmortal(message, onConfirm) {
       const modal = document.getElementById("confirm-modal");
       const messageEl = document.getElementById("confirm-message");
       const deleteBtn = document.getElementById("confirm-delete");
       const cancelBtn = document.getElementById("confirm-cancel");
       messageEl.textContent = message;
       modal.classList.add("active");
       const handleConfirm = () => {
        onConfirm();
        modal.classList.remove("active");
        deleteBtn.removeEventListener("click", handleConfirm);
        cancelBtn.removeEventListener("click", handleCancel);
       };
       const handleCancel = () => {
        modal.classList.remove("active");
        deleteBtn.removeEventListener("click", handleConfirm);
        cancelBtn.removeEventListener("click", handleCancel);
       };
       deleteBtn.addEventListener("click", handleConfirm);
       cancelBtn.addEventListener("click", handleCancel);
       modal.addEventListener("click", function bgHandler(e) {
        if (e.target === modal) {
         handleCancel();
         modal.removeEventListener("click", bgHandler);
        }
       });
      }
      const pageTitleEl = document.getElementById("page-title");
      if (pageTitleEl) {
       pageTitleEl.addEventListener("click", () => {
        showEditModal("Edit Title", PAGE_STATE.title || DEFAULT_PAGE_STATE.title,
         (newTitle) => {
          PAGE_STATE.title = newTitle;
          wieldThePower();
         }, );
       });
      }
      
      function editNodeName(id) {
       showEditModal("Edit Name", NODE_DATA[id].name, (newName) => {
        NODE_DATA[id].name = newName;
        const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`, );
        if (nodeGroup) {
         const label = nodeGroup.querySelector(".node-label");
         if (label) label.textContent = newName;
        }
        if (currentNodeId === id) {
         document.getElementById("node-name").textContent = newName;
        }
       });
      }
      
      function editNodeIp(id) {
       showEditModal("Edit IP/Subtitle", NODE_DATA[id].ip, (newIp) => {
        NODE_DATA[id].ip = newIp;
        const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`, );
        if (nodeGroup) {
         const sub = nodeGroup.querySelector(".node-sub");
         if (sub) sub.textContent = newIp;
        }
        if (currentNodeId === id) {
         document.getElementById("node-ip").textContent = newIp;
        }
       });
      }
      
      function claimTheImmortal(id) {
       currentNodeId = id;
       currentEdgeId = null;
       
       if (isMobileDevice()) {
        const currentHeight = PAGE_STATE.mobileFooterHeight || 40;
        if (currentHeight <= 20) {
         PAGE_STATE.mobileFooterHeight = 80;
         const root = document.documentElement;
         root.style.setProperty("--mobile-footer-height", "80vh");
         const mobileFooterHeightInput = document.getElementById("mobile-footer-height");
         const mobileFooterHeightVal = document.getElementById("mobile-footer-height-val");
         if (mobileFooterHeightInput) mobileFooterHeightInput.value = 80;
         if (mobileFooterHeightVal) mobileFooterHeightVal.textContent = "80%";
        }
       }
       
       const data = NODE_DATA[id];
       document.querySelectorAll(".node-group").forEach((n) => {
        n.classList.toggle("active", n.dataset.nodeId === id);
       });
       document.querySelectorAll(".edge").forEach((e) => {
        const active = e.dataset.from === id || e.dataset.to === id;
        e.classList.toggle("active", active);
       });
       document.getElementById("node-panel").style.display = "block";
       document.getElementById("edge-panel").style.display = "none";
       document.getElementById("text-panel").style.display = "none";
       const toolbar = document.getElementById("topology-toolbar");
       if (!topologyToolbarCollapsed) {
        toolbar.style.display = "flex";
       }
       updateTopologyToolbarVisibility();
       document.getElementById("node-name").textContent = data.name;
       document.getElementById("node-ip").textContent = data.ip;
       document.getElementById("node-role").textContent = data.role;
       document.getElementById("node-mac").textContent = data.mac || "--";
       document.getElementById("node-rack").textContent = data.rackUnit || "--";
       document.getElementById("node-uheight").textContent = (data.uHeight || "1") + "U";
       document.getElementById("node-layer").value = data.layer || "physical";
       
       populateRackDropdown();
       const assignedRackSelect = document.getElementById("node-assigned-rack");
       if (assignedRackSelect) {
        assignedRackSelect.value = data.assignedRack || "";
       }
       
       const rackCapacitySelect = document.getElementById("node-rack-capacity");
       if (rackCapacitySelect) {
        rackCapacitySelect.value = data.rackCapacity || "42";
       }
       
       const isRack = data.isRack === true;
       const isAssignedToRack = !!data.assignedRack;
       const assignedRackRow = document.getElementById("assigned-rack-row");
       const rackCapacityRow = document.getElementById("rack-capacity-row");
       const uheightRow = document.getElementById("uheight-row");
       if (assignedRackRow) assignedRackRow.style.display = isRack ? "none" : "flex";
       if (rackCapacityRow) rackCapacityRow.style.display = isRack ? "flex" : "none";
       if (uheightRow) uheightRow.style.display = isAssignedToRack ? "flex" : "none";
       
       document.getElementById("node-name").onclick = () => editNodeName(id);
       document.getElementById("node-ip").onclick = () => editNodeIp(id);
       document.getElementById("node-mac").onclick = () => editNodeMac(id);
       document.getElementById("node-rack").onclick = () => editNodeRack(id);
       document.getElementById("node-uheight").onclick = () => editNodeUHeight(id);
       const currentSize = savedSizes[id] || getDefaultSize();
       document.getElementById("size-slider").value = currentSize;
       document.getElementById("size-value").textContent = currentSize;
       const styleEntry = savedStyles[id] || {};
       const resolvedStyles = resolveStylesEntry(styleEntry);
       const scopeKey = currentStyleScope || "all";
       const flatProps = ["circleColor", "circleBorder", "titleColor", "titleFont", "titleSize", "subColor", "subFont", "subSize", ];
       const isFlat = flatProps.some((p) => Object.prototype.hasOwnProperty.call(styleEntry, p), );
       const scopedStyles = isFlat ? styleEntry : styleEntry[scopeKey] || {};
       const circleColorInput = document.getElementById("circle-color");
       const titleColorInput = document.getElementById("title-color");
       const titleFontSelect = document.getElementById("title-font");
       const titleSizeInput = document.getElementById("title-size");
       const subColorInput = document.getElementById("sub-color");
       const subFontSelect = document.getElementById("sub-font");
       const subSizeInput = document.getElementById("sub-size");
       const shapeSelect = document.getElementById("shape-select");
       const scopeSelect = document.getElementById("style-scope");
       circleColorInput.value = scopedStyles.circleColor || resolvedStyles.circleColor || "#1e293b";
       const circleBorderInput = document.getElementById("circle-border");
       circleBorderInput.value = scopedStyles.circleBorder || resolvedStyles.circleBorder || "#475569";
       titleColorInput.value = scopedStyles.titleColor || resolvedStyles.titleColor || "#e2e8f0";
       titleFontSelect.value = scopedStyles.titleFont || resolvedStyles.titleFont || "system-ui, sans-serif";
       titleSizeInput.value = scopedStyles.titleSize || resolvedStyles.titleSize || 18;
       subColorInput.value = scopedStyles.subColor || resolvedStyles.subColor || "#94a3b8";
       subFontSelect.value = scopedStyles.subFont || resolvedStyles.subFont || "system-ui, sans-serif";
       subSizeInput.value = scopedStyles.subSize || resolvedStyles.subSize || 13;
       shapeSelect.value = data.shape || "circle";
       scopeSelect.value = currentStyleScope || "all";
       document.getElementById("title-offset-y").value = scopedStyles.titleOffsetY || resolvedStyles.titleOffsetY || 0;
       document.getElementById("title-offset-x").value = scopedStyles.titleOffsetX || resolvedStyles.titleOffsetX || 0;
       document.getElementById("sub-offset-y").value = scopedStyles.subOffsetY || resolvedStyles.subOffsetY || 0;
       document.getElementById("sub-offset-x").value = scopedStyles.subOffsetX || resolvedStyles.subOffsetX || 0;
       const tagEl = document.getElementById("node-tags");
       tagEl.innerHTML = "";
       data.tags.forEach((tag, i) => {
        const b = document.createElement("span");
        b.className = "badge";
        if (tag.toLowerCase().includes("wg")) b.classList.add("wg");
        b.style.cursor = "pointer";
        b.style.position = "relative";
        const tagText = document.createElement("span");
        tagText.textContent = tag;
        tagText.addEventListener("click", (e) => {
         e.stopPropagation();
         showEditModal("Edit Tag", tag, (newTag) => {
          if (newTag) {
           data.tags[i] = newTag;
           claimTheImmortal(id);
          }
         });
        });
        const deleteTag = document.createElement("span");
        deleteTag.textContent = " ‚úï";
        deleteTag.style.opacity = "0.6";
        deleteTag.style.marginLeft = "4px";
        deleteTag.style.fontSize = "10px";
        deleteTag.addEventListener("click", (e) => {
         e.stopPropagation();
         data.tags.splice(i, 1);
         claimTheImmortal(id);
        });
        b.append(tagText, deleteTag);
        tagEl.append(b);
       });
       const addTagBtn = document.createElement("span");
       addTagBtn.className = "badge";
       addTagBtn.style.cursor = "pointer";
       addTagBtn.style.opacity = "0.6";
       addTagBtn.style.borderStyle = "dashed";
       addTagBtn.textContent = "+ Add";
       addTagBtn.addEventListener("click", () => {
        showEditModal("Add Tag(s) : comma separated", "",
         (newTagStr) => {
          if (newTagStr) {
           const newTags = newTagStr.split(",").map((t) => t.trim()).filter((t) => t);
           newTags.forEach((t) => data.tags.push(t));
           claimTheImmortal(id);
          }
         }, );
       });
       tagEl.append(addTagBtn);
       const notesEl = document.getElementById("node-notes");
       notesEl.innerHTML = "";
       data.notes.forEach((note, i) => {
        const li = document.createElement("li");
        const noteText = document.createElement("span");
        noteText.textContent = note;
        noteText.style.flex = "1";
        const deleteBtn = document.createElement("span");
        deleteBtn.className = "delete-note";
        deleteBtn.textContent = "‚úï";
        deleteBtn.addEventListener("click", (e) => {
         e.stopPropagation();
         challengeTheImmortal("Are you sure you want to delete this note?",
          () => {
           data.notes.splice(i, 1);
           claimTheImmortal(id);
          }, );
        });
        li.append(noteText, deleteBtn);
        noteText.addEventListener("dblclick", () => {
         noteText.classList.add("editing");
         noteText.contentEditable = true;
         noteText.focus();
        });
        noteText.addEventListener("blur", () => {
         noteText.classList.remove("editing");
         noteText.contentEditable = false;
         data.notes[i] = noteText.textContent;
        });
        notesEl.append(li);
       });
      const addLineSelect = document.getElementById("add-line-select");
      addLineSelect.innerHTML = "";
      const currentRack = data.assignedRack || "";
      Object.entries(NODE_DATA).forEach(([nodeId, node]) => {
      if (nodeId !== id) {
      const nodeRack = node.assignedRack || "";
      if (currentRack === nodeRack) {
      const opt = document.createElement("option");
      opt.value = nodeId;
      opt.textContent = node.name;
      addLineSelect.appendChild(opt);
      }
      }
      });
      }
      
      function selectTheConnection(id) {
       currentEdgeId = id;
       
       if (isMobileDevice()) {
        const currentHeight = PAGE_STATE.mobileFooterHeight || 40;
        if (currentHeight <= 20) {
         PAGE_STATE.mobileFooterHeight = 80;
         const root = document.documentElement;
         root.style.setProperty("--mobile-footer-height", "80vh");
         const mobileFooterHeightInput = document.getElementById("mobile-footer-height");
         const mobileFooterHeightVal = document.getElementById("mobile-footer-height-val");
         if (mobileFooterHeightInput) mobileFooterHeightInput.value = 80;
         if (mobileFooterHeightVal) mobileFooterHeightVal.textContent = "80%";
        }
       }
       
       document.getElementById("node-panel").style.display = "none";
       document.getElementById("edge-panel").style.display = "block";
       document.getElementById("text-panel").style.display = "none";
       document.getElementById("topology-toolbar").style.display = "none";
       document.querySelectorAll(".node-group").forEach((n) => n.classList.remove("active"));
       document.querySelectorAll(".edge").forEach((e) => {
        e.classList.toggle("active", e.dataset.edgeId === id);
       });
       const edge = EDGE_DATA.list.find((e) => e.id === id);
       if (!edge) return;
       const directionSymbols = {
        none: "‚áÑ",
        forward: "‚Üí",
        backward: "‚Üê",
        both: "‚Üî",
       };
       const dirSymbol = directionSymbols[edge.direction] || "‚áÑ";
       let titleText = "Custom line";
       if (edge.from || edge.to) {
        const fromName = edge.from ? NODE_DATA[edge.from]?.name || edge.from : "";
        const toName = edge.to ? NODE_DATA[edge.to]?.name || edge.to : "";
        titleText = `${fromName || "?"} ${dirSymbol} ${toName || "?"}`;
       }
       document.getElementById("edge-title").textContent = titleText;
       const widthInput = document.getElementById("edge-width");
       const colorInput = document.getElementById("edge-color");
       const directionSelect = document.getElementById("edge-direction");
       const lineStyleSelect = document.getElementById("edge-line-style");
       widthInput.value = edge.width;
       colorInput.value = edge.color;
       directionSelect.value = edge.direction || "none";
       lineStyleSelect.value = edge.lineStyle || "solid";
       
       const fromPortRow = document.getElementById("edge-from-port-row");
       const toPortRow = document.getElementById("edge-to-port-row");
       const fromPortInput = document.getElementById("edge-from-port");
       const toPortInput = document.getElementById("edge-to-port");
       
       if (edge.type === "custom") {
        fromPortRow.style.display = "none";
        toPortRow.style.display = "none";
       } else {
        fromPortRow.style.display = "flex";
        toPortRow.style.display = "flex";
        fromPortInput.value = edge.fromPort || "";
        toPortInput.value = edge.toPort || "";
        
        fromPortInput.onchange = () => updateEdgePortLabels(id);
        toPortInput.onchange = () => updateEdgePortLabels(id);
       }
       
       const list = document.getElementById("edge-notes");
       list.innerHTML = "";
       edge.notes.forEach((note, i) => {
        const li = document.createElement("li");
        const txt = document.createElement("span");
        txt.textContent = note;
        txt.style.flex = "1";
        const del = document.createElement("span");
        del.className = "delete-note";
        del.textContent = "‚úï";
        del.addEventListener("click", (e) => {
         e.stopPropagation();
         challengeTheImmortal("Delete this line note?", () => {
          edge.notes.splice(i, 1);
          saveEdgeData();
          selectTheConnection(id);
         });
        });
        txt.addEventListener("dblclick", () => {
         txt.classList.add("editing");
         txt.contentEditable = true;
         txt.focus();
        });
        txt.addEventListener("blur", () => {
         txt.classList.remove("editing");
         txt.contentEditable = false;
         edge.notes[i] = txt.textContent;
         saveEdgeData();
        });
        li.append(txt, del);
        list.appendChild(li);
       });
      }
      window.addEventListener("resize", () => {
       forgeTheTopology();
       if (currentEdgeId) {
        selectTheConnection(currentEdgeId);
       } else if (currentNodeId && NODE_DATA[currentNodeId]) {
        claimTheImmortal(currentNodeId);
       } else {
        const availableNodes = Object.keys(NODE_DATA);
        if (availableNodes.length > 0) {
         claimTheImmortal(availableNodes[0]);
        }
       }
      });
      (function initZoomPan() {
       const viewport = document.getElementById("canvas-viewport");
       const svg = document.getElementById("map");
       const hint = document.getElementById("canvas-hint");
       setTimeout(() => {
        hint.classList.add("visible");
        setTimeout(() => hint.classList.remove("visible"), 4000);
       }, 1000);
       viewport.addEventListener("wheel",
        (e) => {
         e.preventDefault();
         const rect = viewport.getBoundingClientRect();
         const mouseX = (e.clientX - rect.left) / rect.width;
         const mouseY = (e.clientY - rect.top) / rect.height;
         const delta = e.deltaY > 0 ? 0.9 : 1.1;
         zoomTo(canvasState.zoom * delta, mouseX, mouseY);
        }, {
         passive: false
        }, );
       let initialPinchDistance = 0;
       let initialPinchZoom = 1;
       let pinchCenter = {
        x: 0.5,
        y: 0.5
       };
       viewport.addEventListener("touchstart",
        (e) => {
         if (e.touches.length === 2) {
          e.preventDefault();
          const touch1 = e.touches[0];
          const touch2 = e.touches[1];
          initialPinchDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY, );
          initialPinchZoom = canvasState.zoom;
          const rect = viewport.getBoundingClientRect();
          const centerX = (touch1.clientX + touch2.clientX) / 2;
          const centerY = (touch1.clientY + touch2.clientY) / 2;
          pinchCenter.x = (centerX - rect.left) / rect.width;
          pinchCenter.y = (centerY - rect.top) / rect.height;
         }
        }, {
         passive: false
        }, );
       viewport.addEventListener("touchmove",
        (e) => {
         if (e.touches.length === 2) {
          e.preventDefault();
          const touch1 = e.touches[0];
          const touch2 = e.touches[1];
          const currentDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY, );
          if (initialPinchDistance > 0) {
           const scale = currentDistance / initialPinchDistance;
           const newZoom = initialPinchZoom * scale;
           zoomTo(newZoom, pinchCenter.x, pinchCenter.y);
          }
         }
        }, {
         passive: false
        }, );
       let panStartViewX = 0;
       let panStartViewY = 0;
       
       let lastEmptyTapTime = 0;
       let emptyTapTimeout = null;
       let emptyTapMoved = false;
       
       viewport.addEventListener("touchend", (e) => {
         if (currentView.mode !== "rack") return;
         
         if (e.changedTouches.length !== 1) return;
         
         const isEmptySpace = e.target === svg || e.target === viewport || e.target.tagName === "svg";
         if (!isEmptySpace) return;
         
         if (emptyTapMoved) {
           emptyTapMoved = false;
           return;
         }
         
         const currentTime = new Date().getTime();
         const tapGap = currentTime - lastEmptyTapTime;
         
         if (tapGap < 300 && tapGap > 0) {
           e.preventDefault();
           
           exitRack();
           
           if (navigator.vibrate) {
             navigator.vibrate(50);
           }
           
           lastEmptyTapTime = 0;
           if (emptyTapTimeout) {
             clearTimeout(emptyTapTimeout);
             emptyTapTimeout = null;
           }
         } else {
           lastEmptyTapTime = currentTime;
           
           if (emptyTapTimeout) clearTimeout(emptyTapTimeout);
           emptyTapTimeout = setTimeout(() => {
             lastEmptyTapTime = 0;
           }, 300);
         }
       }, { passive: false });
       
       viewport.addEventListener("mousedown", (e) => {
        if (e.target.closest(".draw-toolbar") || e.target.closest(".topology-toolbar") || e.target.closest(".legend-container")) {
         return;
        }
      
        if (freeDrawMode || rectDrawMode) {
         return;
        }
        const isEmptySpace = e.target === svg || e.target === viewport || e.target.tagName === "svg";
        if (isEmptySpace || e.button === 2 || e.button === 1) {
         e.preventDefault();
         canvasState.isPanning = true;
         canvasState.panStartX = e.clientX;
         canvasState.panStartY = e.clientY;
         panStartViewX = canvasState.panX;
         panStartViewY = canvasState.panY;
         viewport.classList.add("panning");
        }
       });
       viewport.addEventListener("touchstart",
        (e) => {
         if (e.target.closest(".draw-toolbar") || e.target.closest(".topology-toolbar") || e.target.closest(".legend-container")) {
          return;
         }
      
         if (freeDrawMode || rectDrawMode) {
          return;
         }
         const isEmptySpace = e.target === svg || e.target === viewport || e.target.tagName === "svg";
         if (isEmptySpace && e.touches.length === 1) {
          e.preventDefault();
          emptyTapMoved = false;
          canvasState.isPanning = true;
          canvasState.panStartX = e.touches[0].clientX;
          canvasState.panStartY = e.touches[0].clientY;
          panStartViewX = canvasState.panX;
          panStartViewY = canvasState.panY;
          viewport.classList.add("panning");
         }
        }, {
         passive: false
        }, );
       document.addEventListener("mousemove", (e) => {
        if (!canvasState.isPanning) return;
        const dx = e.clientX - canvasState.panStartX;
        const dy = e.clientY - canvasState.panStartY;
        const rect = viewport.getBoundingClientRect();
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        const canvasDx = (dx / rect.width) * viewWidth;
        const canvasDy = (dy / rect.height) * viewHeight;
        canvasState.panX = panStartViewX - canvasDx;
        canvasState.panY = panStartViewY - canvasDy;
        constrainPan();
        updateViewBox();
       });
       document.addEventListener("touchmove", (e) => {
        if (!canvasState.isPanning || !e.touches[0]) return;
        emptyTapMoved = true; 
        const dx = e.touches[0].clientX - canvasState.panStartX;
        const dy = e.touches[0].clientY - canvasState.panStartY;
        const rect = viewport.getBoundingClientRect();
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        const canvasDx = (dx / rect.width) * viewWidth;
        const canvasDy = (dy / rect.height) * viewHeight;
        canvasState.panX = panStartViewX - canvasDx;
        canvasState.panY = panStartViewY - canvasDy;
        constrainPan();
        updateViewBox();
       });
       document.addEventListener("mouseup", () => {
        if (canvasState.isPanning) {
         canvasState.isPanning = false;
         viewport.classList.remove("panning");
        }
       });
       document.addEventListener("touchend", () => {
        if (canvasState.isPanning) {
         canvasState.isPanning = false;
         viewport.classList.remove("panning");
        }
       });
       document.addEventListener("keydown", (e) => {
        const isEditing = document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "TEXTAREA" || document.activeElement.isContentEditable;
        if (e.code === "Space" && !e.repeat && !isEditing) {
         e.preventDefault();
         canvasState.spacePressed = true;
         viewport.style.cursor = "grab";
        }
       });
       document.addEventListener("keyup", (e) => {
        if (e.code === "Space") {
         canvasState.spacePressed = false;
         viewport.style.cursor = "";
        }
       });
       document.getElementById("zoom-in-btn").addEventListener("click", () => {
        zoomTo(canvasState.zoom * 1.25, 0.5, 0.5);
       });
       document.getElementById("zoom-out-btn").addEventListener("click", () => {
        zoomTo(canvasState.zoom * 0.8, 0.5, 0.5);
       });
       document.getElementById("zoom-fit-btn").addEventListener("click", fitToContent);
       document.getElementById("zoom-reset-btn").addEventListener("click", resetView);
       const minimapContainer = document.getElementById("minimap-container");
       const minimapSvg = document.getElementById("minimap");
       let minimapDragging = false;
       minimapContainer.addEventListener("mousedown", (e) => {
        e.preventDefault();
        minimapDragging = true;
        updatePanFromMinimap(e);
       });
       minimapContainer.addEventListener("touchstart",
        (e) => {
         e.preventDefault();
         minimapDragging = true;
         updatePanFromMinimapTouch(e);
        }, {
         passive: false
        }, );
       document.addEventListener("mousemove", (e) => {
        if (minimapDragging) {
         updatePanFromMinimap(e);
        }
       });
       document.addEventListener("touchmove", (e) => {
        if (minimapDragging && e.touches[0]) {
         updatePanFromMinimapTouch(e);
        }
       });
       document.addEventListener("mouseup", () => {
        minimapDragging = false;
       });
       document.addEventListener("touchend", () => {
        minimapDragging = false;
       });
      
       function updatePanFromMinimap(e) {
        const rect = minimapContainer.getBoundingClientRect();
        const x = (e.clientX - rect.left) / rect.width;
        const y = (e.clientY - rect.top) / rect.height;
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        canvasState.panX = x * CANVAS_WIDTH - viewWidth / 2;
        canvasState.panY = y * CANVAS_HEIGHT - viewHeight / 2;
        constrainPan();
        updateViewBox();
       }
      
       function updatePanFromMinimapTouch(e) {
        const rect = minimapContainer.getBoundingClientRect();
        const touch = e.touches[0];
        const x = (touch.clientX - rect.left) / rect.width;
        const y = (touch.clientY - rect.top) / rect.height;
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        canvasState.panX = x * CANVAS_WIDTH - viewWidth / 2;
        canvasState.panY = y * CANVAS_HEIGHT - viewHeight / 2;
        constrainPan();
        updateViewBox();
       }
       document.addEventListener("keydown", (e) => {
        if (document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "TEXTAREA") return;
        if (
         (e.key === "+" || e.key === "=") && (e.ctrlKey || e.metaKey)) {
         e.preventDefault();
         zoomTo(canvasState.zoom * 1.25, 0.5, 0.5);
        } else if (e.key === "-" && (e.ctrlKey || e.metaKey)) {
         e.preventDefault();
         zoomTo(canvasState.zoom * 0.8, 0.5, 0.5);
        } else if (e.key === "0" && (e.ctrlKey || e.metaKey)) {
         e.preventDefault();
         resetView();
        }
       });
       setTimeout(() => {
        fitToContent();
       }, 100);
      })();
      const sizeSlider = document.getElementById("size-slider");
      const sizeValue = document.getElementById("size-value");
      const resetSizeBtn = document.getElementById("reset-size");
      sizeSlider.addEventListener("input", () => {
       const newSize = parseInt(sizeSlider.value, 10);
       sizeValue.textContent = newSize;
       savedSizes[currentNodeId] = newSize;
       const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
       if (nodeGroup) {
        const oldShape = nodeGroup.querySelector(".node-circle");
        if (oldShape) oldShape.remove();
        const shapeType = (NODE_DATA[currentNodeId] && NODE_DATA[currentNodeId].shape) || "circle";
        const newShape = createShapeElement(shapeType, newSize);
        newShape.classList.add("node-circle");
        const styles = resolveStylesForNode(currentNodeId);
        if (styles.circleColor) newShape.style.fill = styles.circleColor;
        if (styles.circleBorder) newShape.style.stroke = styles.circleBorder;
        nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
        const label = nodeGroup.querySelector(".node-label");
        const sub = nodeGroup.querySelector(".node-sub");
        if (label) {
         label.setAttribute("y", -newSize * 0.28);
         const labelSize = styles.titleSize || newSize * 0.33;
         label.style.fontSize = labelSize + "px";
        }
        if (sub) {
         sub.setAttribute("y", newSize * 0.4);
         const subSize = styles.subSize || newSize * 0.24;
         sub.style.fontSize = subSize + "px";
        }
       }
      });
      resetSizeBtn.addEventListener("click", () => {
       delete savedSizes[currentNodeId];
       const defaultSize = getDefaultSize();
       sizeSlider.value = defaultSize;
       sizeValue.textContent = defaultSize;
       const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
       if (nodeGroup) {
        const oldShape = nodeGroup.querySelector(".node-circle");
        if (oldShape) oldShape.remove();
        const shapeType = (NODE_DATA[currentNodeId] && NODE_DATA[currentNodeId].shape) || "circle";
        const newShape = createNodeShape(currentNodeId, defaultSize);
        nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
        const styles = resolveStylesForNode(currentNodeId);
        if (styles.circleColor) newShape.style.fill = styles.circleColor;
        if (styles.circleBorder) newShape.style.stroke = styles.circleBorder;
        const label = nodeGroup.querySelector(".node-label");
        const sub = nodeGroup.querySelector(".node-sub");
        if (label) {
         label.setAttribute("y", -defaultSize * 0.28);
         const labelSize = styles.titleSize || defaultSize * 0.33;
         label.style.fontSize = labelSize + "px";
        }
        if (sub) {
         sub.setAttribute("y", defaultSize * 0.4);
         const subSize = styles.subSize || defaultSize * 0.24;
         sub.style.fontSize = subSize + "px";
        }
       }
      });
      const applyStyle = (property, value) => {
       const styleEntry = ensureStyleEntry(currentNodeId);
       const scopeKey = currentStyleScope || "all";
       if (!styleEntry[scopeKey]) styleEntry[scopeKey] = {};
       styleEntry[scopeKey][property] = value;
       const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
       if (!nodeGroup) return;
       const shapeEl = nodeGroup.querySelector(".node-circle");
       const label = nodeGroup.querySelector(".node-label");
       const sub = nodeGroup.querySelector(".node-sub");
       if (property === "circleColor" && shapeEl) shapeEl.style.fill = value;
	   else if (property === "circleBorder" && shapeEl) shapeEl.style.stroke = value;
       else if (property === "titleColor" && label) label.style.fill = value;
       else if (property === "titleFont" && label) label.style.fontFamily = value;
       else if (property === "titleSize" && label) label.style.fontSize = value + "px";
       else if (property === "subColor" && sub) sub.style.fill = value;
       else if (property === "subFont" && sub) sub.style.fontFamily = value;
       else if (property === "subSize" && sub) sub.style.fontSize = value + "px";
      };
      document.getElementById("circle-color").addEventListener("input", (e) => applyStyle("circleColor", e.target.value), );
      document.getElementById("circle-border").addEventListener("input", (e) => applyStyle("circleBorder", e.target.value), );
      document.getElementById("title-color").addEventListener("input", (e) => applyStyle("titleColor", e.target.value), );
      document.getElementById("title-font").addEventListener("change", (e) => applyStyle("titleFont", e.target.value), );
      document.getElementById("title-size").addEventListener("input", (e) => applyStyle("titleSize", parseInt(e.target.value, 10)), );
      document.getElementById("sub-color").addEventListener("input", (e) => applyStyle("subColor", e.target.value), );
      document.getElementById("sub-font").addEventListener("change", (e) => applyStyle("subFont", e.target.value), );
      document.getElementById("sub-size").addEventListener("input", (e) => applyStyle("subSize", parseInt(e.target.value, 10)), );
      document.getElementById("title-offset-y").addEventListener("input", (e) => {
       applyStyle("titleOffsetY", parseInt(e.target.value, 10) || 0);
       forgeTheTopology();
       if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      document.getElementById("title-offset-x").addEventListener("input", (e) => {
       applyStyle("titleOffsetX", parseInt(e.target.value, 10) || 0);
       forgeTheTopology();
       if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      document.getElementById("sub-offset-y").addEventListener("input", (e) => {
       applyStyle("subOffsetY", parseInt(e.target.value, 10) || 0);
       forgeTheTopology();
       if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      document.getElementById("sub-offset-x").addEventListener("input", (e) => {
       applyStyle("subOffsetX", parseInt(e.target.value, 10) || 0);
       forgeTheTopology();
       if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      document.getElementById("reset-styles").addEventListener("click", () => {
       delete savedStyles[currentNodeId];
       forgeTheTopology();
       claimTheImmortal(currentNodeId);
      });
      document.getElementById("style-scope").addEventListener("change", (e) => {
       currentStyleScope = e.target.value || "all";
       claimTheImmortal(currentNodeId);
      });
      document.getElementById("shape-select").addEventListener("change", (e) => {
       const shape = e.target.value || "circle";
       NODE_DATA[currentNodeId].shape = shape;
       const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
       if (!nodeGroup) return;
       const oldShape = nodeGroup.querySelector(".node-circle");
       if (oldShape) oldShape.remove();
       const size = savedSizes[currentNodeId] || getDefaultSize();
       const newShape = createNodeShape(currentNodeId, size);
       nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
      });
      const addNoteBtn = document.getElementById("add-note-btn");
      const noteInput = document.getElementById("new-note-input");
      addNoteBtn.addEventListener("click", () => {
       const newNote = noteInput.value.trim();
       if (newNote && currentNodeId) {
        NODE_DATA[currentNodeId].notes.push(newNote);
        claimTheImmortal(currentNodeId);
        noteInput.value = "";
       }
      });
      noteInput.addEventListener("keypress", (e) => {
       if (e.key === "Enter") {
        addNoteBtn.click();
       }
      });
      document.getElementById("edge-width").addEventListener("input", () => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       const v = parseInt(document.getElementById("edge-width").value, 10);
       if (Number.isNaN(v) || v <= 0) return;
       edge.width = v;
       saveEdgeData();
       const el = document.querySelector(`.edge[data-edge-id="${currentEdgeId}"]`, );
       if (el) el.style.strokeWidth = v;
      });
      document.getElementById("edge-color").addEventListener("input", () => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       const color = document.getElementById("edge-color").value;
       edge.color = color;
       saveEdgeData();
       const el = document.querySelector(`.edge[data-edge-id="${currentEdgeId}"]`, );
       if (el) el.style.stroke = color;
       forgeTheLegend();
      });
      document.getElementById("edge-direction").addEventListener("change", () => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       edge.direction = document.getElementById("edge-direction").value;
       saveEdgeData();
       forgeTheTopology();
       selectTheConnection(currentEdgeId);
      });
      document.getElementById("edge-line-style").addEventListener("change", () => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       edge.lineStyle = document.getElementById("edge-line-style").value;
       saveEdgeData();
       forgeTheTopology();
       selectTheConnection(currentEdgeId);
      });
      const addEdgeNoteBtn = document.getElementById("add-edge-note");
      const newEdgeNoteInput = document.getElementById("new-edge-note");
      addEdgeNoteBtn.addEventListener("click", () => {
       const txt = newEdgeNoteInput.value.trim();
       if (!txt || !currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       edge.notes.push(txt);
       saveEdgeData();
       newEdgeNoteInput.value = "";
       selectTheConnection(currentEdgeId);
      });
      newEdgeNoteInput.addEventListener("keypress", (e) => {
       if (e.key === "Enter") {
        addEdgeNoteBtn.click();
       }
      });
      document.getElementById("delete-edge").addEventListener("click", () => {
       if (!currentEdgeId) return;
       challengeTheImmortal("Are you sure you want to delete this line?",
        () => {
         EDGE_DATA.list = EDGE_DATA.list.filter(
          (e) => e.id !== currentEdgeId, );
         saveEdgeData();
         currentEdgeId = null;
         forgeTheTopology();
         const availableNodes = Object.keys(NODE_DATA);
         if (availableNodes.length > 0) {
          claimTheImmortal(availableNodes[0]);
         } else {
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("topology-toolbar", ).style.display = "none";
         }
        }, );
      });
      document.getElementById("add-line-btn").addEventListener("click", () => {
       if (!currentNodeId) return;
       const select = document.getElementById("add-line-select");
       const directionSelect = document.getElementById("add-line-direction");
       const colorInput = document.getElementById("add-line-color");
       const targetId = select.value;
       if (!targetId || targetId === currentNodeId) return;
       const direction = directionSelect.value || "none";
       const lineColor = colorInput.value || "#475569";
       const newId = `${currentNodeId}-${targetId}-${Date.now()}`;
       const newEdge = {
        id: newId,
        from: currentNodeId,
        to: targetId,
        width: 4,
        color: lineColor,
        direction: direction,
        type: "main",
        notes: [],
        fromPort: "",
        toPort: "",
        lineStyle: "solid",
       };
       EDGE_DATA.list.push(newEdge);
       saveEdgeData();
       forgeTheTopology();
       claimTheImmortal(currentNodeId);
      });
      let freeDrawMode = false;
      let freeDrawPoints = [];
      let freeDrawPolylineEl = null;
      let freeDrawPointEls = [];
       let rectDrawMode = false;
       let currentTextId = null;
       let rectStartPoint = null;
       let rectPreviewEl = null;
       let rectStyle = "filled";
      const drawToggleBtn = document.getElementById("draw-toggle");
      const drawUndoBtn = document.getElementById("draw-undo");
      const drawColorInput = document.getElementById("draw-color");
      const drawStyleSelect = document.getElementById("draw-style");
      const drawArrowSelect = document.getElementById("draw-arrow");
      const svgMap = document.getElementById("map");
      
      function updateFreeDrawGraphics() {
       const ns = "http://www.w3.org/2000/svg";
       const svg = svgMap;
       if (!freeDrawPolylineEl && freeDrawPoints.length > 0) {
        freeDrawPolylineEl = document.createElementNS(ns, "polyline");
        freeDrawPolylineEl.classList.add("edge", "free-preview");
        freeDrawPolylineEl.setAttribute("fill", "none");
        svg.appendChild(freeDrawPolylineEl);
       }
       if (freeDrawPolylineEl) {
        if (freeDrawPoints.length === 0) {
         freeDrawPolylineEl.remove();
         freeDrawPolylineEl = null;
        } else {
         const ptsStr = freeDrawPoints.map((p) => `${p.x},${p.y}`).join(" ");
         freeDrawPolylineEl.setAttribute("points", ptsStr);
         freeDrawPolylineEl.style.stroke = drawColorInput.value || "#475569";
         freeDrawPolylineEl.style.strokeWidth = 3;
         const lineStyle = drawStyleSelect.value || "solid";
         if (lineStyle === "dashed") {
          freeDrawPolylineEl.style.strokeDasharray = "10,5";
         } else if (lineStyle === "dotted") {
          freeDrawPolylineEl.style.strokeDasharray = "2,4";
         } else {
          freeDrawPolylineEl.style.strokeDasharray = "none";
         }
        }
       }
       freeDrawPointEls.forEach((el) => el.remove());
       freeDrawPointEls = [];
       freeDrawPoints.forEach((p, idx) => {
        const c = document.createElementNS(ns, "circle");
        c.classList.add("free-point");
        c.setAttribute("cx", p.x);
        c.setAttribute("cy", p.y);
        c.setAttribute("r", 5);
        c.dataset.index = String(idx);
        c.addEventListener("mousedown", (e) => {
         if (!freeDrawMode) return;
         e.preventDefault();
         e.stopPropagation();
         let dragging = true;
         const svgEl = svgMap;
         const moveHandler = (ev) => {
          if (!dragging) return;
          const pt = svgEl.createSVGPoint();
          pt.x = ev.clientX;
          pt.y = ev.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          const i = parseInt(c.dataset.index, 10);
          if (Number.isNaN(i) || !freeDrawPoints[i]) return;
          freeDrawPoints[i].x = svgP.x;
          freeDrawPoints[i].y = svgP.y;
          updateFreeDrawGraphics();
         };
         const upHandler = () => {
          dragging = false;
          document.removeEventListener("mousemove", moveHandler);
          document.removeEventListener("mouseup", upHandler);
         };
         document.addEventListener("mousemove", moveHandler);
         document.addEventListener("mouseup", upHandler);
        });
        c.addEventListener("touchstart",
         (e) => {
          if (!freeDrawMode) return;
          e.preventDefault();
          e.stopPropagation();
          let dragging = true;
          const svgEl = svgMap;
          const touchMoveHandler = (ev) => {
           if (!dragging || !ev.touches[0]) return;
           const pt = svgEl.createSVGPoint();
           pt.x = ev.touches[0].clientX;
           pt.y = ev.touches[0].clientY;
           const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
           const i = parseInt(c.dataset.index, 10);
           if (Number.isNaN(i) || !freeDrawPoints[i]) return;
           freeDrawPoints[i].x = svgP.x;
           freeDrawPoints[i].y = svgP.y;
           updateFreeDrawGraphics();
          };
          const touchUpHandler = () => {
           dragging = false;
           document.removeEventListener("touchmove", touchMoveHandler, );
           document.removeEventListener("touchend", touchUpHandler, );
          };
          document.addEventListener("touchmove", touchMoveHandler);
          document.addEventListener("touchend", touchUpHandler);
         }, {
          passive: false
         }, );
        svg.appendChild(c);
        freeDrawPointEls.push(c);
       });
       drawUndoBtn.style.display = freeDrawPoints.length ? "inline-block" : "none";
      }
      
      function addFreeDrawPoint(x, y) {
       freeDrawPoints.push({
        x,
        y
       });
       updateFreeDrawGraphics();
      }
      
      function startFreeDraw() {
       freeDrawMode = true;
       freeDrawPoints = [];
       if (freeDrawPolylineEl) {
        freeDrawPolylineEl.remove();
        freeDrawPolylineEl = null;
       }
       freeDrawPointEls.forEach((el) => el.remove());
       freeDrawPointEls = [];
       svgMap.style.cursor = "crosshair";
       drawToggleBtn.textContent = "Done";
       drawUndoBtn.style.display = "none";
      }
      
      function finishFreeDraw() {
       freeDrawMode = false;
       svgMap.style.cursor = "";
       drawToggleBtn.textContent = "‚úèÔ∏è";
       if (freeDrawPoints.length >= 2) {
        const color = drawColorInput.value || "#475569";
        const lineStyle = drawStyleSelect.value || "solid";
        const arrowDir = drawArrowSelect.value || "none";
        const newId = "custom-" + Date.now();
        const pointsCopy = freeDrawPoints.map((p) => ({
         x: p.x,
         y: p.y,
        }));
        EDGE_DATA.list.push({
         id: newId,
         type: "custom",
         color,
         width: 4,
         lineStyle: lineStyle,
         direction: arrowDir,
         points: pointsCopy,
         notes: [],
        });
        saveEdgeData();
        freeDrawPoints = [];
        if (freeDrawPolylineEl) {
         freeDrawPolylineEl.remove();
         freeDrawPolylineEl = null;
        }
        freeDrawPointEls.forEach((el) => el.remove());
        freeDrawPointEls = [];
        forgeTheTopology();
        selectTheConnection(newId);
       } else {
        freeDrawPoints = [];
        if (freeDrawPolylineEl) {
         freeDrawPolylineEl.remove();
         freeDrawPolylineEl = null;
        }
        freeDrawPointEls.forEach((el) => el.remove());
        freeDrawPointEls = [];
        forgeTheLegend();
       }
       drawUndoBtn.style.display = "none";
      }
      drawToggleBtn.addEventListener("click", () => {
       if (currentView.mode === "rack") {
        alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
        return;
       }
       
       if (freeDrawMode) {
        finishFreeDraw();
       } else {
        startFreeDraw();
       }
      });
      drawUndoBtn.addEventListener("click", () => {
       if (!freeDrawMode || !freeDrawPoints.length) return;
       freeDrawPoints.pop();
       updateFreeDrawGraphics();
      });
      const drawToolbar = document.getElementById("draw-toolbar");
      drawToolbar.addEventListener("mousedown", (e) => {
       e.stopPropagation();
      });
      drawToolbar.addEventListener("click", (e) => {
       if (e.target !== drawToggleBtn && e.target !== drawUndoBtn) {
        e.stopPropagation();
       }
      });
      drawStyleSelect.addEventListener("change", () => {
       if (freeDrawMode) {
        updateFreeDrawGraphics();
       }
      });
      drawArrowSelect.addEventListener("change", () => {
       if (freeDrawMode) {
        updateFreeDrawGraphics();
       }
      });
      drawColorInput.addEventListener("input", () => {
       if (freeDrawMode) {
        updateFreeDrawGraphics();
       }
      });
      drawStyleSelect.addEventListener("mousedown", (e) => {
       e.stopPropagation();
      });
      drawStyleSelect.addEventListener("click", (e) => {
       e.stopPropagation();
      });
      drawArrowSelect.addEventListener("mousedown", (e) => {
       e.stopPropagation();
      });
      drawArrowSelect.addEventListener("click", (e) => {
       e.stopPropagation();
      });
      drawColorInput.addEventListener("mousedown", (e) => {
       e.stopPropagation();
      });
      drawColorInput.addEventListener("click", (e) => {
       e.stopPropagation();
      });
      
      svgMap.addEventListener("click", (e) => {
       if (!freeDrawMode) return;
       if (e.button !== 0) return;
       const target = e.target;
       if (target && target.classList && target.classList.contains("free-point")) return;
       const svgEl = svgMap;
       const pt = svgEl.createSVGPoint();
       pt.x = e.clientX;
       pt.y = e.clientY;
       const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
       addFreeDrawPoint(svgP.x, svgP.y);
      });
      svgMap.addEventListener("touchend",
       (e) => {
        if (!freeDrawMode) return;
        const target = e.target;
        if (target && target.classList && target.classList.contains("free-point")) return;
        if (e.changedTouches && e.changedTouches[0]) {
         e.preventDefault();
         const svgEl = svgMap;
         const pt = svgEl.createSVGPoint();
         pt.x = e.changedTouches[0].clientX;
         pt.y = e.changedTouches[0].clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
         addFreeDrawPoint(svgP.x, svgP.y);
        }
       }, {
        passive: false
       }, );
      
       const rectToggleBtn = document.getElementById("rect-toggle");
       const rectStyleSelect = document.getElementById("rect-style");
      
       function startRectDraw() {
        rectDrawMode = true;
        rectStartPoint = null;
        rectPreviewEl = null;
        svgMap.style.cursor = "crosshair";
        rectToggleBtn.textContent = "Done";
        rectStyle = rectStyleSelect.value || "filled";
        
        if (freeDrawMode) {
         finishFreeDraw();
        }
        updateRectangleDeleteButtons();
       }
      
       function finishRectDraw() {
        rectDrawMode = false;
        svgMap.style.cursor = "";
        rectToggleBtn.textContent = "‚ñ≠";
        
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
        updateRectangleDeleteButtons();
       }
      
       rectToggleBtn.addEventListener("click", () => {
        if (currentView.mode === "rack") {
         alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
         return;
        }
        
        if (rectDrawMode) {
         finishRectDraw();
        } else {
         startRectDraw();
        }
       });
      
       rectStyleSelect.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       rectStyleSelect.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       rectStyleSelect.addEventListener("change", () => {
        if (rectDrawMode) {
         rectStyle = rectStyleSelect.value || "filled";
        }
       });
      
       svgMap.addEventListener("mousedown", (e) => {
        if (!rectDrawMode) return;
        if (e.button !== 0) return;
        e.preventDefault();
        e.stopPropagation();
        
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        rectStartPoint = { x: svgP.x, y: svgP.y };
        
        const ns = "http://www.w3.org/2000/svg";
        rectPreviewEl = document.createElementNS(ns, "rect");
        rectPreviewEl.classList.add("rect-preview");
        rectPreviewEl.setAttribute("x", svgP.x);
        rectPreviewEl.setAttribute("y", svgP.y);
        rectPreviewEl.setAttribute("width", 0);
        rectPreviewEl.setAttribute("height", 0);
        
        const color = drawColorInput.value || "#f97316";
        rectPreviewEl.style.stroke = color;
        rectPreviewEl.style.strokeWidth = 2;
        rectPreviewEl.style.strokeDasharray = "5,5";
        
        if (rectStyle === "filled") {
         rectPreviewEl.style.fill = color;
         rectPreviewEl.style.fillOpacity = "0.3";
        } else {
         rectPreviewEl.style.fill = "none";
        }
        
        svgEl.appendChild(rectPreviewEl);
       });
      
       svgMap.addEventListener("mousemove", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        
        rectPreviewEl.setAttribute("x", x);
        rectPreviewEl.setAttribute("y", y);
        rectPreviewEl.setAttribute("width", width);
        rectPreviewEl.setAttribute("height", height);
       });
      
       svgMap.addEventListener("mouseup", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        
        if (width > 10 && height > 10) {
      pushUndo("draw rectangle");
         const color = drawColorInput.value || "#f97316";
         const newId = "rect-" + Date.now();
         
         RECT_DATA.list.push({
          id: newId,
          x: x,
          y: y,
          width: width,
          height: height,
          color: color,
          style: rectStyle,
          notes: []
         });
         
         forgeTheTopology();
        }
        
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
       });
      
       let rectTouchStart = null;
       
       svgMap.addEventListener("touchstart", (e) => {
        if (!rectDrawMode) return;
        if (e.touches.length !== 1) return;
        
        e.preventDefault();
        const touch = e.touches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        rectStartPoint = { x: svgP.x, y: svgP.y };
        rectTouchStart = { x: svgP.x, y: svgP.y };
        
        const ns = "http://www.w3.org/2000/svg";
        rectPreviewEl = document.createElementNS(ns, "rect");
        rectPreviewEl.classList.add("rect-preview");
        rectPreviewEl.setAttribute("x", svgP.x);
        rectPreviewEl.setAttribute("y", svgP.y);
        rectPreviewEl.setAttribute("width", 0);
        rectPreviewEl.setAttribute("height", 0);
        
        const color = drawColorInput.value || "#f97316";
        rectPreviewEl.style.stroke = color;
        rectPreviewEl.style.strokeWidth = 2;
        rectPreviewEl.style.strokeDasharray = "5,5";
        
        if (rectStyle === "filled") {
         rectPreviewEl.style.fill = color;
         rectPreviewEl.style.fillOpacity = "0.3";
        } else {
         rectPreviewEl.style.fill = "none";
        }
        
        svgEl.appendChild(rectPreviewEl);
       }, { passive: false });
      
       svgMap.addEventListener("touchmove", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        if (e.touches.length !== 1) return;
        
        e.preventDefault();
        const touch = e.touches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        
        rectPreviewEl.setAttribute("x", x);
        rectPreviewEl.setAttribute("y", y);
        rectPreviewEl.setAttribute("width", width);
        rectPreviewEl.setAttribute("height", height);
       }, { passive: false });
      
       svgMap.addEventListener("touchend", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        if (!rectTouchStart) return;
        
        e.preventDefault();
        const touch = e.changedTouches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        
        if (width > 10 && height > 10) {
      pushUndo("draw rectangle");
         const color = drawColorInput.value || "#f97316";
         const newId = "rect-" + Date.now();
         
         RECT_DATA.list.push({
          id: newId,
          x: x,
          y: y,
          width: width,
          height: height,
          color: color,
          style: rectStyle,
          notes: []
         });
         
         forgeTheTopology();
        }
        
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
        rectTouchStart = null;
       }, { passive: false });
      
      const textToggleBtn = document.getElementById("text-toggle");
      
      function startTextMode() {
       textDrawMode = true;
       svgMap.style.cursor = "crosshair";
       textToggleBtn.textContent = "Done";
       textToggleBtn.style.background = "var(--accent)";
       textToggleBtn.style.color = "var(--bg)";
       
       if (freeDrawMode) {
        finishFreeDraw();
       }
       if (rectDrawMode) {
        finishRectDraw();
       }
       
       updateTextDeleteButtons();
      }
      
      function finishTextMode() {
       textDrawMode = false;
       svgMap.style.cursor = "";
       textToggleBtn.textContent = "T";
       textToggleBtn.style.background = "";
       textToggleBtn.style.color = "";
       updateTextDeleteButtons();
      }
      
      textToggleBtn.addEventListener("click", () => {
       if (currentView.mode === "rack") {
        alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
        return;
       }
       
       if (textDrawMode) {
        finishTextMode();
       } else {
        startTextMode();
       }
      });
      
      function handleTextPlacement(e) {
       if (!textDrawMode) return;
       
       const svgEl = svgMap;
       const pt = svgEl.createSVGPoint();
       pt.x = e.clientX;
       pt.y = e.clientY;
       const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
       
       const newId = "text-" + Date.now();
      pushUndo("add text");
       TEXT_DATA.list.push({
        id: newId,
        x: svgP.x,
        y: svgP.y,
        content: "New Text",
        fontSize: 18,
        color: "#e2e8f0",
        fontWeight: "normal",
        fontStyle: "normal",
        textAlign: "start",
        textDecoration: "none",
        bgColor: "#000000",
        bgEnabled: false,
        opacity: 1
       });
       
       forgeTheTopology();
       
       showTextPanel(newId);
      }
      
      svgMap.addEventListener("click", (e) => {
       if (!textDrawMode) return;
       if (e.target.closest('.text-delete-btn')) return;
       if (e.target.closest('.text-group')) return;
       
       e.preventDefault();
       e.stopPropagation();
       handleTextPlacement(e);
      });
      
      svgMap.addEventListener("touchend", (e) => {
       if (!textDrawMode) return;
       if (e.target.closest('.text-delete-btn')) return;
       if (e.target.closest('.text-group')) return;
       if (e.touches.length > 0) return;
       
       e.preventDefault();
       const touch = e.changedTouches[0];
       const fakeEvent = {
        clientX: touch.clientX,
        clientY: touch.clientY,
        preventDefault: () => {},
        stopPropagation: () => {}
       };
       handleTextPlacement(fakeEvent);
      }, { passive: false });
      
      function showTextPanel(textId) {
       currentTextId = textId;
       const textItem = TEXT_DATA.list.find(t => t.id === textId);
       if (!textItem) return;
       
       document.getElementById("node-panel").style.display = "none";
       document.getElementById("edge-panel").style.display = "none";
       
       const textPanel = document.getElementById("text-panel");
       textPanel.style.display = "block";
       
       document.getElementById("text-content").value = textItem.content;
       document.getElementById("text-font-size").value = textItem.fontSize;
       document.getElementById("text-color").value = textItem.color;
       document.getElementById("text-font-weight").value = textItem.fontWeight;
       document.getElementById("text-font-style").value = textItem.fontStyle;
       document.getElementById("text-align").value = textItem.textAlign;
       document.getElementById("text-decoration").value = textItem.textDecoration;
       document.getElementById("text-bg-color").value = textItem.bgColor;
       document.getElementById("text-bg-enabled").checked = textItem.bgEnabled;
       document.getElementById("text-opacity").value = textItem.opacity;
       document.getElementById("text-opacity-val").textContent = Math.round(textItem.opacity * 100) + "%";
      }
      
      function updateTextDeleteButtons() {
       const deleteButtons = document.querySelectorAll('.text-delete-btn');
       deleteButtons.forEach(btn => {
        btn.style.display = textDrawMode ? 'block' : 'none';
       });
      }
      
      function deleteText(textId) {
      pushUndo("delete text");
       TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== textId);
       forgeTheTopology();
       
       if (currentTextId === textId) {
        document.getElementById("text-panel").style.display = "none";
        currentTextId = null;
       }
      }
      
      document.getElementById("text-content").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
      pushUndo("edit text");
        textItem.content = e.target.value;
        forgeTheTopology();
       }
      });
      
      document.getElementById("text-font-size").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        textItem.fontSize = parseInt(e.target.value);
        forgeTheTopology();
       }
      });
      
      document.getElementById("text-color").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        textItem.color = e.target.value;
        forgeTheTopology();
       }
      });
      
      document.getElementById("text-font-weight").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        textItem.fontWeight = e.target.value;
        forgeTheTopology();
       }
      });
      
      document.getElementById("text-font-style").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        textItem.fontStyle = e.target.value;
        forgeTheTopology();
       }
      });
      
      document.getElementById("text-align").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        textItem.textAlign = e.target.value;
        forgeTheTopology();
       }
      });
      
      document.getElementById("text-decoration").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        textItem.textDecoration = e.target.value;
        forgeTheTopology();
       }
      });
      
      document.getElementById("text-bg-color").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        textItem.bgColor = e.target.value;
        forgeTheTopology();
       }
      });
      
      document.getElementById("text-bg-enabled").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        textItem.bgEnabled = e.target.checked;
        forgeTheTopology();
       }
      });
      
      document.getElementById("text-opacity").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        textItem.opacity = parseFloat(e.target.value);
        document.getElementById("text-opacity-val").textContent = Math.round(textItem.opacity * 100) + "%";
        forgeTheTopology();
       }
      });
      
      document.getElementById("delete-text").addEventListener("click", () => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        challengeTheImmortal(`Delete text "${textItem.content.substring(0, 30)}..."?`, () => {
         deleteText(currentTextId);
        });
       }
      });
      
      const settingsBtn = document.getElementById("settings-btn");
      const settingsModal = document.getElementById("settings-modal");
      const settingsClose = document.getElementById("settings-close");
      settingsBtn.addEventListener("click", () => {
       document.getElementById("page-bg-color").value = PAGE_STATE.background || "#050608";
       document.getElementById("topbar-bg-color").value = PAGE_STATE.topbarBg || "#0b0e13";
       document.getElementById("topbar-border-color").value = PAGE_STATE.topbarBorder || "#1f2533";
       document.getElementById("panel-color").value = PAGE_STATE.panel || "#0b0e13";
       document.getElementById("panel-alt-color").value = PAGE_STATE.panelAlt || "#10141b";
       document.getElementById("accent-color").value = PAGE_STATE.accent || "#4fd1c5";
       document.getElementById("danger-color").value = PAGE_STATE.danger || "#f56565";
       document.getElementById("text-main-color").value = PAGE_STATE.textMain || "#e2e8f0";
       document.getElementById("text-soft-color").value = PAGE_STATE.textSoft || "#94a3b8";
       settingsModal.classList.add("active");
      });
      settingsClose.addEventListener("click", () => {
       settingsModal.classList.remove("active");
      });
      settingsModal.addEventListener("click", (e) => {
       if (e.target === settingsModal) {
        settingsModal.classList.remove("active");
       }
      });
      document.getElementById("page-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.background = e.target.value;
       wieldThePower();
      });
      document.getElementById("topbar-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.topbarBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("topbar-border-color").addEventListener("input", (e) => {
       PAGE_STATE.topbarBorder = e.target.value;
       wieldThePower();
      });
      document.getElementById("panel-color").addEventListener("input", (e) => {
       PAGE_STATE.panel = e.target.value;
       wieldThePower();
      });
      document.getElementById("panel-alt-color").addEventListener("input", (e) => {
       PAGE_STATE.panelAlt = e.target.value;
       wieldThePower();
      });
      document.getElementById("accent-color").addEventListener("input", (e) => {
       PAGE_STATE.accent = e.target.value;
       wieldThePower();
      });
      document.getElementById("danger-color").addEventListener("input", (e) => {
       PAGE_STATE.danger = e.target.value;
       wieldThePower();
      });
      document.getElementById("text-main-color").addEventListener("input", (e) => {
       PAGE_STATE.textMain = e.target.value;
       wieldThePower();
      });
      document.getElementById("text-soft-color").addEventListener("input", (e) => {
       PAGE_STATE.textSoft = e.target.value;
       wieldThePower();
      });
      
      (function initializeResizers() {
        const headerResizer = document.getElementById('header-resizer');
        const sidebarResizer = document.getElementById('sidebar-resizer');
        const mobileFooterResizer = document.getElementById('mobile-footer-resizer');
        
        let isResizing = false;
        let currentResizer = null;
        let startY = 0;
        let startX = 0;
        let startHeight = 0;
        let startWidth = 0;
        
        function getClientPos(e) {
          if (e.touches && e.touches.length > 0) {
            return { x: e.touches[0].clientX, y: e.touches[0].clientY };
          }
          return { x: e.clientX, y: e.clientY };
        }
        
        function startResize(resizer, type, e) {
          isResizing = true;
          currentResizer = type;
          const pos = getClientPos(e);
          
          if (type === 'header') {
            startY = pos.y;
            startHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--topbar-height'));
          } else if (type === 'sidebar') {
            startX = pos.x;
            startWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width'));
          } else if (type === 'mobile-footer') {
            startY = pos.y;
            const currentVh = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--mobile-footer-height'));
            startHeight = (currentVh / 100) * window.innerHeight;
          }
          
          resizer.classList.add('resizing');
          document.body.classList.add('resizing');
          document.body.style.cursor = (type === 'sidebar') ? 'col-resize' : 'row-resize';
          e.preventDefault();
        }
        
        if (headerResizer) {
          headerResizer.addEventListener('mousedown', (e) => startResize(headerResizer, 'header', e));
          headerResizer.addEventListener('touchstart', (e) => startResize(headerResizer, 'header', e), { passive: false });
        }
        
        if (sidebarResizer) {
          sidebarResizer.addEventListener('mousedown', (e) => startResize(sidebarResizer, 'sidebar', e));
          sidebarResizer.addEventListener('touchstart', (e) => startResize(sidebarResizer, 'sidebar', e), { passive: false });
        }
        
        if (mobileFooterResizer) {
          mobileFooterResizer.addEventListener('mousedown', (e) => startResize(mobileFooterResizer, 'mobile-footer', e));
          mobileFooterResizer.addEventListener('touchstart', (e) => startResize(mobileFooterResizer, 'mobile-footer', e), { passive: false });
        }
        
        function handleMove(e) {
          if (!isResizing) return;
          
          const pos = getClientPos(e);
          
          if (currentResizer === 'header') {
            const deltaY = pos.y - startY;
            const newHeight = Math.max(40, Math.min(150, startHeight + deltaY));
            document.documentElement.style.setProperty('--topbar-height', newHeight + 'px');
          } else if (currentResizer === 'sidebar') {
            const deltaX = startX - pos.x;
            const newWidth = Math.max(200, Math.min(800, startWidth + deltaX));
            document.documentElement.style.setProperty('--sidebar-width', newWidth + 'px');
          } else if (currentResizer === 'mobile-footer') {
            const deltaY = startY - pos.y;
            const newHeight = startHeight + deltaY;
            const newVh = Math.max(15, Math.min(80, (newHeight / window.innerHeight) * 100));
            document.documentElement.style.setProperty('--mobile-footer-height', newVh + 'vh');
          }
          
          e.preventDefault();
        }
        
        document.addEventListener('mousemove', handleMove);
        document.addEventListener('touchmove', handleMove, { passive: false });
        
        function handleEnd() {
          if (isResizing) {
            isResizing = false;
            
            if (currentResizer === 'header') {
              PAGE_STATE.topbarHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--topbar-height'));
              headerResizer.classList.remove('resizing');
            } else if (currentResizer === 'sidebar') {
              PAGE_STATE.sidebarWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width'));
              sidebarResizer.classList.remove('resizing');
            } else if (currentResizer === 'mobile-footer') {
              PAGE_STATE.mobileFooterHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--mobile-footer-height'));
              mobileFooterResizer.classList.remove('resizing');
            }
            
            document.body.classList.remove('resizing');
            document.body.style.cursor = '';
            currentResizer = null;
          }
        }
        
        document.addEventListener('mouseup', handleEnd);
        document.addEventListener('touchend', handleEnd);
        document.addEventListener('touchcancel', handleEnd);
      })();
      
      document.getElementById("export-data-btn").addEventListener("click", () => {
       const data = captureTheQuickening();
       const jsonStr = JSON.stringify(data, null, 2);
       const blob = new Blob([jsonStr], {
        type: "application/json"
       });
       const url = URL.createObjectURL(blob);
       const a = document.createElement("a");
       a.href = url;
       const safeTitle = (PAGE_STATE.title || "network-topology").toLowerCase().replace(/[^a-z0-9\-]+/g, "-");
       const timestamp = new Date().toISOString().split("T")[0];
       a.download = `${safeTitle}-data-${timestamp}.json`;
       document.body.appendChild(a);
       a.click();
       document.body.removeChild(a);
       URL.revokeObjectURL(url);
      });
      document.getElementById("import-data-btn").addEventListener("click", () => {
       document.getElementById("import-data-file").click();
      });
      document.getElementById("import-data-file").addEventListener("change", async (e) => {
       const file = e.target.files[0];
       if (!file) return;
       try {
        const text = await file.text();
        const data = JSON.parse(text);
        if (!data.nodeData || !data.edgeData) {
         alert("Invalid data file. Missing required fields.");
         return;
        }
        const confirmMsg = `This will replace all current data with the imported data.\n\nImporting:\n- ${Object.keys(data.nodeData).length} nodes\n- ${data.edgeData.list?.length || 0} connections\n\nContinue?`;
        if (!confirm(confirmMsg)) {
         e.target.value = "";
         return;
        }
        NODE_DATA = data.nodeData || {};
        EDGE_DATA = data.edgeData || {
         list: []
        };
        EDGE_LEGEND = data.edgeLegend || {};
        RECT_DATA = data.rectData || { list: [] };
        TEXT_DATA = data.textData || { list: [] };
        savedPositions = data.nodePositions || {};
        savedSizes = data.nodeSizes || {};
        savedStyles = data.nodeStyles || {};
        if (data.page) {
         PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, data.page, );
         wieldThePower();
        }
        if (data.canvas) {
         canvasState.zoom = data.canvas.zoom || 1;
         canvasState.panX = data.canvas.panX || 0;
         canvasState.panY = data.canvas.panY || 0;
        }
        if (data.page?.title) {
         document.title = data.page.title;
         document.querySelector(".editable-page-title", ).textContent = data.page.title;
        }
        forgeTheTopology();
        forgeTheLegend();
        updateViewBox();
        const nodeIds = Object.keys(NODE_DATA);
        if (nodeIds.length > 0) {
         claimTheImmortal(nodeIds[0]);
        } else {
         document.getElementById("node-panel").style.display = "none";
         document.getElementById("edge-panel").style.display = "none";
         document.getElementById("topology-toolbar").style.display = "none";
        }
        e.target.value = "";
       } catch (err) {
        console.error("Import error:", err);
        alert(`Failed to import data: ${err.message}`);
        e.target.value = "";
       }
      });
      const saveHelpBtn = document.getElementById("save-help-btn");
      const saveInfoModal = document.getElementById("save-info-modal");
      const saveInfoClose = document.getElementById("save-info-close");
      saveHelpBtn.addEventListener("click", () => {
       saveInfoModal.classList.add("active");
      });
      saveInfoClose.addEventListener("click", () => {
       saveInfoModal.classList.remove("active");
      });
      saveInfoModal.addEventListener("click", (e) => {
       if (e.target === saveInfoModal) {
        saveInfoModal.classList.remove("active");
       }
      });
      async function deriveKey(password, salt) {
      const encoder = new TextEncoder();
      
      const keyMaterial = await crypto.subtle.importKey(
      "raw",
      encoder.encode(password),
      "PBKDF2",
      false,
      ["deriveKey"]
      );
      
      return crypto.subtle.deriveKey(
      {
      name: "PBKDF2",
      salt: salt,
      iterations: 200000,
      hash: "SHA-256"
      },
      keyMaterial,
      {
      name: "AES-GCM",
      length: 256
      },
      false,
      ["encrypt", "decrypt"]
      );
      }
      
      async function encryptData(data, password) {
      const encoder = new TextEncoder();
      const salt = crypto.getRandomValues(new Uint8Array(16));
      const iv   = crypto.getRandomValues(new Uint8Array(12));
      
      const key = await deriveKey(password, salt);
      const encrypted = await crypto.subtle.encrypt(
      { name: "AES-GCM", iv },
      key,
      encoder.encode(data)
      );
      
      const encryptedU8 = new Uint8Array(encrypted);
      
      const result = new Uint8Array(salt.length + iv.length + encryptedU8.length);
      result.set(salt, 0);
      result.set(iv, salt.length);
      result.set(encryptedU8, salt.length + iv.length);
      
      return "ENCRYPTED:" + u8ToBase64(result);
      }
      
      async function decryptData(encryptedData, password) {
      const base64Data = encryptedData.replace("ENCRYPTED:", "");
      const fullData   = base64ToU8(base64Data);
      
      const salt      = fullData.slice(0, 16);
      const iv        = fullData.slice(16, 28);
      const encrypted = fullData.slice(28);
      
      const key = await deriveKey(password, salt);
      
      const decrypted = await crypto.subtle.decrypt(
      { name: "AES-GCM", iv },
      key,
      encrypted
      );
      
      const decoder = new TextDecoder();
      return decoder.decode(decrypted);
      }
      
      
      function isEncrypted(data) {
       return typeof data === "string" && data.startsWith("ENCRYPTED:");
      }
      
      function captureTheQuickening() {
       const currentTab = documentTabs[currentTabIndex];
       currentTab.nodes = JSON.parse(JSON.stringify(NODE_DATA));
       currentTab.edges = JSON.parse(JSON.stringify(EDGE_DATA));
       currentTab.positions = JSON.parse(JSON.stringify(savedPositions));
       currentTab.sizes = JSON.parse(JSON.stringify(savedSizes));
       currentTab.styles = JSON.parse(JSON.stringify(savedStyles));
       currentTab.legend = JSON.parse(JSON.stringify(EDGE_LEGEND));
       currentTab.rects = JSON.parse(JSON.stringify(RECT_DATA));
       currentTab.texts = JSON.parse(JSON.stringify(TEXT_DATA));
       currentTab.pageState = JSON.parse(JSON.stringify(PAGE_STATE));
       
       return {
        nodeData: NODE_DATA,
        edgeData: EDGE_DATA,
        rectData: RECT_DATA,
        textData: TEXT_DATA,
        edgeLegend: EDGE_LEGEND,
        nodePositions: savedPositions,
        nodeSizes: savedSizes,
        nodeStyles: savedStyles,
        page: PAGE_STATE,
        canvas: {
         zoom: canvasState.zoom,
         panX: canvasState.panX,
         panY: canvasState.panY,
        },
        savedTopologyView: savedTopologyView,
        documentTabs: documentTabs,
        currentTabIndex: currentTabIndex,
        encryptedSections: encryptedSections,
       };
      }
      
      function assembleTheImmortalForm() {
       const clone = document.documentElement.cloneNode(true);
       const nodeScript = clone.querySelector("#nodes-json");
       if (nodeScript) {
        nodeScript.textContent = JSON.stringify(NODE_DATA, null, 2);
       }
       let stateScript = clone.querySelector("#topology-state");
       if (!stateScript) {
        stateScript = document.createElement("script");
        stateScript.id = "topology-state";
        stateScript.type = "application/json";
        const body = clone.querySelector("body") || clone;
        body.appendChild(stateScript);
       }
       stateScript.textContent = JSON.stringify(captureTheQuickening(), null, 2, );
       return "<!DOCTYPE html> \n " + clone.outerHTML;
      }
      async function becomeImmortal() {
       saveRollbackVersion("Auto-save");
       
       const encryptEnabled = document.getElementById("encrypt-toggle").checked;
       let stateData = JSON.stringify(captureTheQuickening(), null, 2);
       if (encryptEnabled) {
        const password = prompt("Enter a password to encrypt your data:\n(Remember this password! You will need it to open this file and its non recoverable!)", );
        if (!password) {
         alert("Encryption cancelled. File not saved.");
         return;
        }
        const confirmPassword = prompt("Confirm your password:");
        if (password !== confirmPassword) {
         alert("Passwords do not match. File not saved.");
         return;
        }
        try {
         stateData = await encryptData(stateData, password);
        } catch (e) {
         alert("Encryption failed: " + e.message);
         return;
        }
       }
       const clone = document.documentElement.cloneNode(true);
       const nodeScript = clone.querySelector("#nodes-json");
       if (nodeScript) {
        if (encryptEnabled) {
         nodeScript.textContent = JSON.stringify({}, null, 2);
        } else {
         nodeScript.textContent = JSON.stringify(NODE_DATA, null, 2);
        }
       }
       let stateScript = clone.querySelector("#topology-state");
       if (!stateScript) {
        stateScript = document.createElement("script");
        stateScript.id = "topology-state";
        stateScript.type = "application/json";
        const body = clone.querySelector("body") || clone;
        body.appendChild(stateScript);
       }
       stateScript.textContent = stateData;
       const html = "<!DOCTYPE html> \n " + clone.outerHTML;
       const blob = new Blob([html], {
        type: "text/html"
       });
       const url = URL.createObjectURL(blob);
       const a = document.createElement("a");
       a.href = url;
       const safeTitle = (PAGE_STATE.title || document.title || "network-topology").toLowerCase().replace(/[^a-z0-9\-]+/g, "-");
       a.download = safeTitle + ".html";
       document.body.appendChild(a);
       a.click();
       document.body.removeChild(a);
       URL.revokeObjectURL(url);
       
       logAuditEvent("save", `File saved: ${safeTitle}.html`);
      }
      
      function captureState() {
      return {
       nodes: JSON.parse(JSON.stringify(NODE_DATA)),
       edges: JSON.parse(JSON.stringify(EDGE_DATA)),
       positions: JSON.parse(JSON.stringify(savedPositions)),
       sizes: JSON.parse(JSON.stringify(savedSizes)),
       styles: JSON.parse(JSON.stringify(savedStyles)),
       legend: JSON.parse(JSON.stringify(EDGE_LEGEND)),
       rects: JSON.parse(JSON.stringify(RECT_DATA)),
       texts: JSON.parse(JSON.stringify(TEXT_DATA))
       };
      }
      
      function pushUndo(action = "") {
       const state = captureState();
       undoStack.push(state);
       if (undoStack.length > MAX_UNDO_STACK) {
        undoStack.shift();
       }
       redoStack = [];
       updateUndoButtons();
       
       if (action) {
        const actionTypeMap = {
          "create node": "node",
          "delete node": "node",
          "edit": "node",
          "create rack": "rack",
          "add connection": "connection",
          "delete connection": "connection",
          "style change": "style",
          "change layer": "layer",
          "change assigned rack": "rack",
        };
        
        const type = actionTypeMap[action] || "node";
        logAuditEvent(type, action);
       }
      }
      
      function undo() {
       if (undoStack.length === 0) return;
       const currentState = captureState();
       redoStack.push(currentState);
       const previousState = undoStack.pop();
       restoreState(previousState);
       updateUndoButtons();
      }
      
      function redo() {
       if (redoStack.length === 0) return;
       const currentState = captureState();
       undoStack.push(currentState);
       const nextState = redoStack.pop();
       restoreState(nextState);
       updateUndoButtons();
      }
      
      function restoreState(state) {
      NODE_DATA = state.nodes;
      EDGE_DATA = state.edges;
      savedPositions = state.positions;
      savedSizes = state.sizes;
      savedStyles = state.styles;
      EDGE_LEGEND = state.legend;
      RECT_DATA = state.rects || { list: [] };
      TEXT_DATA = state.texts || { list: [] };
      forgeTheTopology();
      if (currentNodeId && NODE_DATA[currentNodeId]) {
       claimTheImmortal(currentNodeId);
      } else if (currentEdgeId) {
       selectTheConnection(currentEdgeId);
       }
      }
      
      function updateUndoButtons() {
       const undoBtn = document.getElementById("undo-btn");
       const redoBtn = document.getElementById("redo-btn");
       if (undoBtn) {
        undoBtn.disabled = undoStack.length === 0;
        undoBtn.style.opacity = undoStack.length === 0 ? "0.5" : "1";
       }
       if (redoBtn) {
        redoBtn.disabled = redoStack.length === 0;
        redoBtn.style.opacity = redoStack.length === 0 ? "0.5" : "1";
       }
      }
      
      function editNodeMac(id) {
       const currentMac = NODE_DATA[id].mac || "";
       showEditModal("Edit MAC Address", currentMac, (newMac) => {
        pushUndo("edit mac");
        NODE_DATA[id].mac = newMac;
        if (currentNodeId === id) {
         document.getElementById("node-mac").textContent = newMac || "--";
        }
       });
      }
      
      function editNodeRack(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       
       document.getElementById("modal-title").textContent = "Edit Rack Unit";
       document.getElementById("modal-input").value = node.rackUnit || "";
       document.getElementById("edit-modal").style.display = "flex";
       document.getElementById("modal-input").focus();
       
       const saveHandler = () => {
        pushUndo("edit rack");
        const value = document.getElementById("modal-input").value.trim();
        node.rackUnit = value;
        document.getElementById("edit-modal").style.display = "none";
        claimTheImmortal(id);
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       
       const cancelHandler = () => {
        document.getElementById("edit-modal").style.display = "none";
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       
       document.getElementById("edit-modal").addEventListener("click", function bgHandler(e) {
        if (e.target === document.getElementById("edit-modal")) {
         cancelHandler();
         document.getElementById("edit-modal").removeEventListener("click", bgHandler);
        }
       });
      }
      
      function editNodeUHeight(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       
       document.getElementById("modal-title").textContent = "Edit U Height";
       document.getElementById("modal-input").value = node.uHeight || "1";
       document.getElementById("edit-modal").style.display = "flex";
       document.getElementById("modal-input").focus();
       
       const saveHandler = () => {
        pushUndo("edit U height");
        const value = document.getElementById("modal-input").value.trim();
        node.uHeight = value;
        document.getElementById("edit-modal").style.display = "none";
        claimTheImmortal(id);
        forgeTheTopology();
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       
       const cancelHandler = () => {
        document.getElementById("edit-modal").style.display = "none";
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       
       document.getElementById("edit-modal").addEventListener("click", function bgHandler(e) {
        if (e.target === document.getElementById("edit-modal")) {
         cancelHandler();
         document.getElementById("edit-modal").removeEventListener("click", bgHandler);
        }
       });
      }
      
      function updateEdgePortLabels(edgeId) {
       const edge = EDGE_DATA.list.find(e => e.id === edgeId);
       if (!edge || edge.type === "custom") return;
       
       const fromPortInput = document.getElementById("edge-from-port");
       const toPortInput = document.getElementById("edge-to-port");
       
       if (fromPortInput && toPortInput) {
        edge.fromPort = fromPortInput.value || "";
        edge.toPort = toPortInput.value || "";
        saveEdgeData();
        forgeTheTopology();
       }
      }
      
      function selectNode(nodeId, addToSelection = false) {
       if (!addToSelection) {
        clearSelection();
       }
       selectedNodes.add(nodeId);
       updateNodeSelection();
      }
      
      function clearSelection() {
       selectedNodes.clear();
       updateNodeSelection();
      }
      
      function updateNodeSelection() {
       document.querySelectorAll(".node-group").forEach(node => {
        const nodeId = node.dataset.nodeId;
        if (selectedNodes.has(nodeId)) {
         node.classList.add("selected");
        } else {
         node.classList.remove("selected");
        }
       });
       
       const bulkToolbar = document.getElementById("bulk-toolbar");
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       const bulkCount = document.getElementById("bulk-count");
       const bulkCountMobile = document.getElementById("bulk-count-mobile");
       const bulkCountModal = document.getElementById("bulk-count-modal");
       
       if (selectedNodes.size > 0) {
        if (bulkToolbar) bulkToolbar.style.display = "flex";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
        if (bulkCount) bulkCount.textContent = selectedNodes.size;
        if (bulkCountMobile) bulkCountMobile.textContent = selectedNodes.size;
        if (bulkCountModal) bulkCountModal.textContent = selectedNodes.size;
       } else {
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        const modal = document.getElementById("bulk-actions-modal");
        if (modal) modal.style.display = "none";
       }
      }
      
      function deleteSelected() {
       if (selectedNodes.size === 0) return;
       const message = `Delete ${selectedNodes.size} selected node(s)?`;
       challengeTheImmortal(message, () => {
        pushUndo("delete selected");
        selectedNodes.forEach(nodeId => {
         delete NODE_DATA[nodeId];
         delete savedPositions[nodeId];
         delete savedSizes[nodeId];
         delete savedStyles[nodeId];
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== nodeId && e.to !== nodeId);
        });
        clearSelection();
        saveEdgeData();
        forgeTheTopology();
       });
      }
      
      function startSelection(event) {
       if (event.button !== 0) return;
       if (event.target.closest(".node-group")) return;
       
       isSelecting = true;
       const svg = document.getElementById("map");
       const pt = svg.createSVGPoint();
       pt.x = event.clientX;
       pt.y = event.clientY;
       const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
       selectionStart = { x: svgP.x, y: svgP.y };
       
       if (!event.shiftKey) {
        clearSelection();
       }
       
       if (!selectionRect) {
        selectionRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        selectionRect.setAttribute("fill", "rgba(79, 209, 197, 0.1)");
        selectionRect.setAttribute("stroke", "#4fd1c5");
        selectionRect.setAttribute("stroke-width", "2");
        selectionRect.setAttribute("stroke-dasharray", "5,5");
        svg.appendChild(selectionRect);
       }
       selectionRect.style.display = "block";
      }
      
      function updateSelection(event) {
       if (!isSelecting || !selectionStart) return;
       
       const svg = document.getElementById("map");
       const pt = svg.createSVGPoint();
       pt.x = event.clientX;
       pt.y = event.clientY;
       const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
       
       const x = Math.min(selectionStart.x, svgP.x);
       const y = Math.min(selectionStart.y, svgP.y);
       const width = Math.abs(svgP.x - selectionStart.x);
       const height = Math.abs(svgP.y - selectionStart.y);
       
       selectionRect.setAttribute("x", x);
       selectionRect.setAttribute("y", y);
       selectionRect.setAttribute("width", width);
       selectionRect.setAttribute("height", height);
       
       Object.entries(savedPositions).forEach(([nodeId, pos]) => {
        if (pos.x >= x && pos.x <= x + width && pos.y >= y && pos.y <= y + height) {
         selectedNodes.add(nodeId);
        } else if (!event.shiftKey) {
         selectedNodes.delete(nodeId);
        }
       });
       updateNodeSelection();
      }
      
      function endSelection() {
       isSelecting = false;
       if (selectionRect) {
        selectionRect.style.display = "none";
       }
      }
      
      function cloneNode(sourceId) {
       if (!NODE_DATA[sourceId]) return;
       
       pushUndo("clone node");
       const source = NODE_DATA[sourceId];
       const baseName = source.name + " copy";
       let newName = baseName;
       let counter = 1;
       while (Object.values(NODE_DATA).some(n => n.name === newName)) {
        newName = `${baseName} ${counter}`;
        counter++;
       }
       
       const baseId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
       let newId = baseId;
       counter = 1;
       while (NODE_DATA[newId]) {
        newId = `${baseId}-${counter}`;
        counter++;
       }
       
       NODE_DATA[newId] = {
        shape: source.shape,
        name: newName,
        ip: source.ip,
        role: source.role,
        tags: [...source.tags],
        notes: [...source.notes],
        mac: source.mac || "",
        rackUnit: source.rackUnit || "",
        uHeight: source.uHeight || "1",
        layer: source.layer || "physical",
        assignedRack: source.assignedRack || "",
        rackCapacity: source.rackCapacity || "42",
        isRack: source.isRack || false
       };
       
       const sourcePos = savedPositions[sourceId];
       savedPositions[newId] = {
        x: sourcePos.x + 100,
        y: sourcePos.y + 100
       };
       
       if (savedSizes[sourceId]) {
        savedSizes[newId] = savedSizes[sourceId];
       }
       
       if (savedStyles[sourceId]) {
        savedStyles[newId] = JSON.parse(JSON.stringify(savedStyles[sourceId]));
       }
       
       forgeTheTopology();
       claimTheImmortal(newId);
      }
      
      function alignSelectedNodes(direction) {
       if (selectedNodes.size < 2) return;
       
       pushUndo("align nodes");
       const nodes = Array.from(selectedNodes).map(id => ({
        id,
        pos: savedPositions[id]
       }));
       
       switch(direction) {
        case "left":
         const minX = Math.min(...nodes.map(n => n.pos.x));
         nodes.forEach(n => savedPositions[n.id].x = minX);
         break;
        case "right":
         const maxX = Math.max(...nodes.map(n => n.pos.x));
         nodes.forEach(n => savedPositions[n.id].x = maxX);
         break;
        case "top":
         const minY = Math.min(...nodes.map(n => n.pos.y));
         nodes.forEach(n => savedPositions[n.id].y = minY);
         break;
        case "bottom":
         const maxY = Math.max(...nodes.map(n => n.pos.y));
         nodes.forEach(n => savedPositions[n.id].y = maxY);
         break;
        case "center-h":
         const avgX = nodes.reduce((sum, n) => sum + n.pos.x, 0) / nodes.length;
         nodes.forEach(n => savedPositions[n.id].x = avgX);
         break;
        case "center-v":
         const avgY = nodes.reduce((sum, n) => sum + n.pos.y, 0) / nodes.length;
         nodes.forEach(n => savedPositions[n.id].y = avgY);
         break;
       }
       
       forgeTheTopology();
      }
      
      function distributeSelectedNodes(direction) {
       if (selectedNodes.size < 3) return;
       
       pushUndo("distribute nodes");
       const nodes = Array.from(selectedNodes).map(id => ({
        id,
        pos: savedPositions[id]
       }));
       
       if (direction === "horizontal") {
        nodes.sort((a, b) => a.pos.x - b.pos.x);
        const minX = nodes[0].pos.x;
        const maxX = nodes[nodes.length - 1].pos.x;
        const gap = (maxX - minX) / (nodes.length - 1);
        nodes.forEach((n, i) => {
         savedPositions[n.id].x = minX + (gap * i);
        });
       } else {
        nodes.sort((a, b) => a.pos.y - b.pos.y);
        const minY = nodes[0].pos.y;
        const maxY = nodes[nodes.length - 1].pos.y;
        const gap = (maxY - minY) / (nodes.length - 1);
        nodes.forEach((n, i) => {
         savedPositions[n.id].y = minY + (gap * i);
        });
       }
       
       forgeTheTopology();
      }
      
      function snapToGrid(nodeId, gridSize = 50) {
       if (!savedPositions[nodeId]) return;
       
       pushUndo("snap to grid");
       const pos = savedPositions[nodeId];
       pos.x = Math.round(pos.x / gridSize) * gridSize;
       pos.y = Math.round(pos.y / gridSize) * gridSize;
       forgeTheTopology();
      }
      
      function searchNodes(query) {
       if (!query) {
        clearSearchHighlight();
        return [];
       }
       
       query = query.toLowerCase();
       const results = [];
       
       Object.entries(NODE_DATA).forEach(([id, data]) => {
        if (data.name.toLowerCase().includes(query) ||
            data.ip.toLowerCase().includes(query) ||
            data.role.toLowerCase().includes(query) ||
            data.tags.some(tag => tag.toLowerCase().includes(query)) ||
            (data.mac && data.mac.toLowerCase().includes(query)) ||
            (data.rackUnit && data.rackUnit.toLowerCase().includes(query))) {
         results.push(id);
        }
       });
       
       highlightSearchResults(results);
       return results;
      }
      
      function highlightSearchResults(nodeIds) {
       document.querySelectorAll(".node-group").forEach(node => {
        const nodeId = node.dataset.nodeId;
        if (nodeIds.includes(nodeId)) {
         node.classList.add("search-highlight");
        } else {
         node.classList.remove("search-highlight");
        }
       });
      }
      
      function clearSearchHighlight() {
       document.querySelectorAll(".search-highlight").forEach(node => {
        node.classList.remove("search-highlight");
       });
      }
      
      function nudgeSelectedNodes(direction, distance) {
        const nodesToNudge = selectedNodes.size > 0 
          ? Array.from(selectedNodes) 
          : (currentNodeId ? [currentNodeId] : []);
        
        if (nodesToNudge.length === 0) return;
        
        const unlockedNodes = nodesToNudge.filter(id => !NODE_DATA[id]?.locked);
        
        if (unlockedNodes.length === 0) {
          return;
        }
        
        pushUndo("nudge nodes");
        
        unlockedNodes.forEach(id => {
          if (!savedPositions[id]) {
            savedPositions[id] = { x: 0, y: 0 };
          }
          
          switch(direction) {
            case "ArrowUp":
              savedPositions[id].y -= distance;
              break;
            case "ArrowDown":
              savedPositions[id].y += distance;
              break;
            case "ArrowLeft":
              savedPositions[id].x -= distance;
              break;
            case "ArrowRight":
              savedPositions[id].x += distance;
              break;
          }
        });
        
        forgeTheTopology();
      }
      
      function cycleNodes(reverse = false) {
        const nodeIds = Object.keys(NODE_DATA).filter(id => {
          if (currentView.mode === "rack" && currentView.rackId) {
            return NODE_DATA[id].assignedRack === currentView.rackId;
          }
          return !NODE_DATA[id].assignedRack;
        });
        
        if (nodeIds.length === 0) return;
        
        let currentIndex = nodeIds.indexOf(currentNodeId);
        
        if (reverse) {
          currentIndex = currentIndex <= 0 ? nodeIds.length - 1 : currentIndex - 1;
        } else {
          currentIndex = currentIndex >= nodeIds.length - 1 ? 0 : currentIndex + 1;
        }
        
        const nextNodeId = nodeIds[currentIndex];
        claimTheImmortal(nextNodeId);
        
        selectedNodes.clear();
        updateNodeSelection();
      }
      
      function focusOnSelected() {
        const nodesToFocus = selectedNodes.size > 0 
          ? Array.from(selectedNodes) 
          : (currentNodeId ? [currentNodeId] : []);
        
        if (nodesToFocus.length === 0) return;
        
        let minX = Infinity, minY = Infinity;
        let maxX = -Infinity, maxY = -Infinity;
        
        nodesToFocus.forEach(id => {
          const pos = savedPositions[id];
          if (pos) {
            const size = savedSizes[id] || 50;
            minX = Math.min(minX, pos.x - size/2);
            minY = Math.min(minY, pos.y - size/2);
            maxX = Math.max(maxX, pos.x + size/2);
            maxY = Math.max(maxY, pos.y + size/2);
          }
        });
        
        if (!isFinite(minX)) return;
        
        const padding = 100;
        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;
        const width = maxX - minX + padding * 2;
        const height = maxY - minY + padding * 2;
        
        const zoomX = CANVAS_WIDTH / width;
        const zoomY = CANVAS_HEIGHT / height;
        const targetZoom = Math.min(zoomX, zoomY, 2); 
        
        canvasState.zoom = targetZoom;
        canvasState.panX = centerX - (CANVAS_WIDTH / targetZoom) / 2;
        canvasState.panY = centerY - (CANVAS_HEIGHT / targetZoom) / 2;
        
        forgeTheTopology();
      }
      
      function toggleLockSelected() {
        const nodesToToggle = selectedNodes.size > 0 
          ? Array.from(selectedNodes) 
          : (currentNodeId ? [currentNodeId] : []);
        
        if (nodesToToggle.length === 0) return;
        
        pushUndo("toggle lock");
        
        const hasUnlocked = nodesToToggle.some(id => !NODE_DATA[id]?.locked);
        
        nodesToToggle.forEach(id => {
          if (NODE_DATA[id]) {
            NODE_DATA[id].locked = hasUnlocked;
          }
        });
        
        forgeTheTopology();
      
        const lockState = hasUnlocked ? "locked" : "unlocked";
      }
      
      function toggleGroupSelected() {
        const nodesToGroup = Array.from(selectedNodes);
        if (nodesToGroup.length < 2) {
          return;
        }
        
        pushUndo("toggle group");
        
        const groupIds = nodesToGroup.map(id => NODE_DATA[id]?.groupId).filter(g => g !== null && g !== undefined);
        const uniqueGroups = [...new Set(groupIds)];
        
        if (uniqueGroups.length === 1 && groupIds.length === nodesToGroup.length) {
          nodesToGroup.forEach(id => {
            if (NODE_DATA[id]) {
              NODE_DATA[id].groupId = null;
            }
          });
        } else {
          const newGroupId = "group-" + Date.now();
          nodesToGroup.forEach(id => {
            if (NODE_DATA[id]) {
              NODE_DATA[id].groupId = newGroupId;
            }
          });
        }
        
        forgeTheTopology();
      }
      
      function handleKeyDown(event) {
       if (event.target.tagName === "INPUT" || event.target.tagName === "TEXTAREA" || event.target.isContentEditable) {
        return;
       }
       
       if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(event.key)) {
        event.preventDefault();
        const distance = event.shiftKey ? 10 : 1;
        nudgeSelectedNodes(event.key, distance);
       }
       
       if (event.key === "Tab") {
        event.preventDefault();
        cycleNodes(event.shiftKey);
       }
       
       if (event.key === "f" || event.key === "F") {
        event.preventDefault();
        focusOnSelected();
       }
       
       if (event.key === "l" || event.key === "L") {
        event.preventDefault();
        toggleLockSelected();
       }
       
       if (event.key === "g" || event.key === "G") {
        event.preventDefault();
        toggleGroupSelected();
       }
       
       if (event.ctrlKey && event.key === "z") {
        event.preventDefault();
        undo();
       }
       
       if ((event.ctrlKey && event.key === "y") || (event.ctrlKey && event.shiftKey && event.key === "z")) {
        event.preventDefault();
        redo();
       }
       
       if (event.ctrlKey && event.key === "c") {
        event.preventDefault();
        if (currentNodeId && NODE_DATA[currentNodeId]) {
         clipboard = {
          type: "node",
          data: JSON.parse(JSON.stringify(NODE_DATA[currentNodeId])),
          size: savedSizes[currentNodeId],
          style: savedStyles[currentNodeId] ? JSON.parse(JSON.stringify(savedStyles[currentNodeId])) : null
         };
        }
       }
       
       if (event.ctrlKey && event.key === "v") {
        event.preventDefault();
        if (clipboard && clipboard.type === "node") {
         const data = clipboard.data;
         const baseName = data.name + " copy";
         let newName = baseName;
         let counter = 1;
         while (Object.values(NODE_DATA).some(n => n.name === newName)) {
          newName = `${baseName} ${counter}`;
          counter++;
         }
         
         const baseId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
         let newId = baseId;
         counter = 1;
         while (NODE_DATA[newId]) {
          newId = `${baseId}-${counter}`;
          counter++;
         }
         
         pushUndo("paste node");
         NODE_DATA[newId] = {
          ...data,
          name: newName
         };
         
      const viewWidth = CANVAS_WIDTH / canvasState.zoom;
      const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
      const centerX = canvasState.panX + (viewWidth / 2);
      const centerY = canvasState.panY + (viewHeight / 2);
      savedPositions[nodeId] = {
      x: centerX,
      y: centerY
      };
         
         if (clipboard.size) savedSizes[newId] = clipboard.size;
         if (clipboard.style) savedStyles[newId] = clipboard.style;
         
         forgeTheTopology();
         claimTheImmortal(newId);
        }
       }
       
       if (event.key === "Delete") {
        event.preventDefault();
        if (selectedNodes.size > 0) {
         deleteSelected();
        } else if (currentNodeId && NODE_DATA[currentNodeId]) {
         challengeTheImmortal(`Delete node "${NODE_DATA[currentNodeId].name}"?`, () => {
          pushUndo("delete node");
          delete NODE_DATA[currentNodeId];
          delete savedPositions[currentNodeId];
          delete savedSizes[currentNodeId];
          delete savedStyles[currentNodeId];
          EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== currentNodeId && e.to !== currentNodeId);
          currentNodeId = null;
          saveEdgeData();
          forgeTheTopology();
          document.getElementById("node-panel").style.display = "none";
         });
        } else if (currentEdgeId) {
         challengeTheImmortal("Delete this line?", () => {
          pushUndo("delete edge");
          EDGE_DATA.list = EDGE_DATA.list.filter(e => e.id !== currentEdgeId);
          currentEdgeId = null;
          saveEdgeData();
          forgeTheTopology();
          document.getElementById("edge-panel").style.display = "none";
         });
        }
       }
      
       if (event.ctrlKey && event.key === "a") {
        event.preventDefault();
        Object.keys(NODE_DATA).forEach(id => selectedNodes.add(id));
        updateNodeSelection();
       }
       
       if (event.key === "Escape") {
        clearSelection();
        clearSearchHighlight();
       }
      
       if (event.ctrlKey && event.key === "d") {
        event.preventDefault();
        if (currentNodeId && NODE_DATA[currentNodeId]) {
         cloneNode(currentNodeId);
        }
       }
      }
      
      function saveRollbackVersion(description = "Auto-save") {
        const version = {
          timestamp: Date.now(),
          description,
          data: captureTheQuickening()
        };
        
        try {
          const stored = localStorage.getItem(ROLLBACK_STORAGE_KEY);
          rollbackVersions = stored ? JSON.parse(stored) : [];
        } catch (e) {
          rollbackVersions = [];
        }
        
        rollbackVersions.unshift(version);
        
        if (rollbackVersions.length > MAX_ROLLBACK_VERSIONS) {
          rollbackVersions = rollbackVersions.slice(0, MAX_ROLLBACK_VERSIONS);
        }
        
        try {
          localStorage.setItem(ROLLBACK_STORAGE_KEY, JSON.stringify(rollbackVersions));
        } catch (e) {
          console.warn("Failed to save rollback version:", e);
        }
      }
      
      function loadRollbackVersions() {
        try {
          const stored = localStorage.getItem(ROLLBACK_STORAGE_KEY);
          rollbackVersions = stored ? JSON.parse(stored) : [];
          displayRollbackVersions();
        } catch (e) {
          console.warn("Failed to load rollback versions:", e);
          rollbackVersions = [];
        }
      }
      
      function displayRollbackVersions() {
        const listEl = document.getElementById("rollback-list");
        if (!listEl) return;
        
        if (rollbackVersions.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No version history yet. Versions are saved automatically when you save the file.</div>';
          return;
        }
        
        listEl.innerHTML = rollbackVersions.map((version, index) => {
          const date = new Date(version.timestamp);
          const timeStr = date.toLocaleString();
          const nodeCount = Object.keys(version.data.nodeData || {}).length;
          const edgeCount = (version.data.edgeData?.list || []).length;
          
          return `
            <div class="version-item" onclick="restoreRollbackVersion(${index})">
              <div class="version-info">
                <div class="timestamp">${timeStr}</div>
                <div class="details">${version.description} ‚Ä¢ ${nodeCount} nodes ‚Ä¢ ${edgeCount} connections</div>
              </div>
              <div class="version-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteRollbackVersion(${index})" title="Delete this version">üóëÔ∏è</button>
              </div>
            </div>
          `;
        }).join('');
      }
      
      function restoreRollbackVersion(index) {
        if (!confirm(`Restore version from ${new Date(rollbackVersions[index].timestamp).toLocaleString()}?\n\nYour current work will be lost unless you save first.`)) {
          return;
        }
        
        const version = rollbackVersions[index];
        const data = version.data;
        
        NODE_DATA = data.nodeData || {};
        EDGE_DATA = data.edgeData || { list: [] };
        RECT_DATA = data.rectData || { list: [] };
        TEXT_DATA = data.textData || { list: [] };
        EDGE_LEGEND = data.edgeLegend || {};
        savedPositions = data.nodePositions || {};
        savedSizes = data.nodeSizes || {};
        savedStyles = data.nodeStyles || {};
        PAGE_STATE = data.page || PAGE_STATE;
        
        if (data.canvas) {
          canvasState.zoom = data.canvas.zoom;
          canvasState.panX = data.canvas.panX;
          canvasState.panY = data.canvas.panY;
        }
        
        wieldThePower();
        forgeTheTopology();
        
        document.getElementById("rollback-modal").classList.remove("active");
        
        logAuditEvent("rollback", `Restored version from ${new Date(version.timestamp).toLocaleString()}`);
      }
      
      function deleteRollbackVersion(index) {
        if (!confirm("Delete this version from history?")) return;
        
        rollbackVersions.splice(index, 1);
        try {
          localStorage.setItem(ROLLBACK_STORAGE_KEY, JSON.stringify(rollbackVersions));
        } catch (e) {
          console.warn("Failed to delete version:", e);
        }
        displayRollbackVersions();
      }
      
      function clearRollbackHistory() {
        if (!confirm("Clear all version history?\n\nThis cannot be undone.")) return;
        
        rollbackVersions = [];
        localStorage.removeItem(ROLLBACK_STORAGE_KEY);
        displayRollbackVersions();
      }
      
      function createManualSnapshot() {
        const description = prompt("Enter a description for this snapshot:", "Manual snapshot");
        if (!description) return;
        
        saveRollbackVersion(description);
        displayRollbackVersions();
      }
      
      function switchTab(index) {
        if (index === currentTabIndex) return;
        
        const currentTab = documentTabs[currentTabIndex];
        currentTab.nodes = JSON.parse(JSON.stringify(NODE_DATA));
        currentTab.edges = JSON.parse(JSON.stringify(EDGE_DATA));
        currentTab.positions = JSON.parse(JSON.stringify(savedPositions));
        currentTab.sizes = JSON.parse(JSON.stringify(savedSizes));
        currentTab.styles = JSON.parse(JSON.stringify(savedStyles));
        currentTab.legend = JSON.parse(JSON.stringify(EDGE_LEGEND));
        currentTab.rects = JSON.parse(JSON.stringify(RECT_DATA));
        currentTab.texts = JSON.parse(JSON.stringify(TEXT_DATA));
        currentTab.pageState = JSON.parse(JSON.stringify(PAGE_STATE));
      
        currentTabIndex = index;
        const newTab = documentTabs[index];
        NODE_DATA = JSON.parse(JSON.stringify(newTab.nodes));
        EDGE_DATA = JSON.parse(JSON.stringify(newTab.edges));
        savedPositions = JSON.parse(JSON.stringify(newTab.positions));
        savedSizes = JSON.parse(JSON.stringify(newTab.sizes));
        savedStyles = JSON.parse(JSON.stringify(newTab.styles));
        EDGE_LEGEND = JSON.parse(JSON.stringify(newTab.legend));
        RECT_DATA = JSON.parse(JSON.stringify(newTab.rects));
        TEXT_DATA = JSON.parse(JSON.stringify(newTab.texts));
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, newTab.pageState || {});
               wieldThePower();
        document.title = newTab.name;
      document.getElementById("page-title").textContent = newTab.name;
        forgeTheTopology();
        displayTabs();
        
        logAuditEvent("tab", `Switched to tab: ${newTab.name}`);
      }
      
      function createNewTab() {
        const nameInput = document.getElementById("new-tab-name");
        const name = nameInput.value.trim();
        
        if (!name) {
          alert("Please enter a tab name");
          return;
        }
        
        const newTab = {
          id: `tab-${Date.now()}`,
          name,
          nodes: {},
          edges: { list: [] },
          positions: {},
          sizes: {},
          styles: {},
          legend: {},
          rects: { list: [] },
          texts: { list: [] },
		  pageState: null
        };
        
        documentTabs.push(newTab);
        nameInput.value = "";
        displayTabs();
        
        logAuditEvent("tab", `Created new tab: ${name}`);
      }
      
      function renameTab(index) {
        const tab = documentTabs[index];
        const newName = prompt("Enter new name:", tab.name);
        if (!newName || newName === tab.name) return;
        
        tab.name = newName;
        displayTabs();
        
        logAuditEvent("tab", `Renamed tab to: ${newName}`);
      }
      
      function deleteTab(index) {
        if (documentTabs.length === 1) {
          alert("Cannot delete the last tab");
          return;
        }
        
        if (!confirm(`Delete tab "${documentTabs[index].name}"?`)) return;
        
        documentTabs.splice(index, 1);
        
        if (currentTabIndex >= documentTabs.length) {
          currentTabIndex = documentTabs.length - 1;
        }
        
        if (currentTabIndex === index) {
          switchTab(currentTabIndex);
        }
        
        displayTabs();
      }
      
      function displayTabs() {
        const listEl = document.getElementById("tabs-list");
        if (!listEl) return;
        
        listEl.innerHTML = documentTabs.map((tab, index) => {
          const nodeCount = Object.keys(tab.nodes).length;
          const edgeCount = tab.edges.list.length;
          const isActive = index === currentTabIndex;
          
          return `
            <div class="tab-item ${isActive ? 'active' : ''}" onclick="switchTab(${index})">
              <div class="tab-name">${tab.name}</div>
              <div class="tab-stats">${nodeCount} nodes ‚Ä¢ ${edgeCount} connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(${index})" title="Rename tab">‚úèÔ∏è</button>
                ${documentTabs.length > 1 ? '<button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(${index})" title="Delete tab">üóëÔ∏è</button>' : ''}
              </div>
            </div>
          `;
        }).join('');
      }
      
      function logAuditEvent(type, description, details = {}) {
        const event = {
          timestamp: Date.now(),
          type,
          description,
          details,
          tab: documentTabs[currentTabIndex]?.name || "Main"
        };
        
        auditLog.unshift(event);
        
        if (auditLog.length > MAX_AUDIT_ENTRIES) {
          auditLog = auditLog.slice(0, MAX_AUDIT_ENTRIES);
        }
      
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to save audit log:", e);
        }
      }
      
      function loadAuditLog() {
        try {
          const stored = localStorage.getItem(AUDIT_STORAGE_KEY);
          auditLog = stored ? JSON.parse(stored) : [];
        } catch (e) {
          console.warn("Failed to load audit log:", e);
          auditLog = [];
        }
      }
      
      function displayAuditLog(filter = "all") {
        const listEl = document.getElementById("audit-log-list");
        if (!listEl) return;
        
        const filtered = filter === "all" ? auditLog : auditLog.filter(e => e.type === filter);
        
        if (filtered.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No audit entries yet</div>';
          return;
        }
        
        listEl.innerHTML = filtered.map(event => {
          const date = new Date(event.timestamp);
          const timeStr = date.toLocaleString();
          
          return `
            <div class="audit-entry ${event.type}">
              <div class="time">[${timeStr}] ${event.tab}</div>
              <div class="action">[${event.type.toUpperCase()}] ${event.description}</div>
            </div>
          `;
        }).join('');
      }
      
      function clearAuditLog() {
        if (!confirm("Clear all audit log entries?\n\nThis cannot be undone.")) return;
        
        auditLog = [];
        localStorage.removeItem(AUDIT_STORAGE_KEY);
        displayAuditLog();
      }
      
      function exportAuditLog() {
        if (auditLog.length === 0) {
          alert("No audit entries to export");
          return;
        }
        
        const csv = [
          ["Timestamp", "Tab", "Type", "Description"],
          ...auditLog.map(e => [
            new Date(e.timestamp).toISOString(),
            e.tab,
            e.type,
            e.description
          ])
        ].map(row => row.map(cell => `"${cell}"`).join(",")).join("\n");
        
        const blob = new Blob([csv], { type: "text/csv" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `audit-log-${Date.now()}.csv`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }
      
      let currentSecretName = null;
      
      function createNewSecret() {
        const nameInput = document.getElementById("new-secret-name");
        const name = nameInput.value.trim();
        
        if (!name) {
          alert("Please enter a note name");
          return;
        }
        
        if (encryptedSections[name]) {
          alert("A note with this name already exists");
          return;
        }
        
        currentSecretName = name;
        encryptedSections[name] = { encrypted: false, data: "" };
        nameInput.value = "";
        
        document.getElementById("secret-editor-title").textContent = `New note: ${name}`;
        document.getElementById("secret-editor-content").value = "";
        document.getElementById("secrets-modal").classList.remove("active");
        document.getElementById("secret-editor-modal").classList.add("active");
        
        displaySecrets();
      }
      
      function editSecret(name) {
        currentSecretName = name;
        const section = encryptedSections[name];
        
        if (section.encrypted) {
          const password = prompt(`Enter password to decrypt "${name}":`);
          if (!password) return;
          
          try {
            decryptData(section.data, password).then(decrypted => {
              document.getElementById("secret-editor-title").textContent = `Edit note: ${name}`;
              document.getElementById("secret-editor-content").value = decrypted;
              document.getElementById("secrets-modal").classList.remove("active");
              document.getElementById("secret-editor-modal").classList.add("active");
            }).catch(e => {
              alert("Failed to decrypt. Wrong password?");
            });
          } catch (e) {
            alert("Failed to decrypt. Wrong password?");
          }
        } else {
          document.getElementById("secret-editor-title").textContent = `Edit note: ${name}`;
          document.getElementById("secret-editor-content").value = section.data;
          document.getElementById("secrets-modal").classList.remove("active");
          document.getElementById("secret-editor-modal").classList.add("active");
        }
      }
      
      async function saveSecret() {
        if (!currentSecretName) return;
        
        const content = document.getElementById("secret-editor-content").value;
        const autoEncrypt = document.getElementById("secret-auto-encrypt").checked;
        
        if (autoEncrypt) {
          const password = prompt(`Enter password to encrypt "${currentSecretName}":`);
          if (!password) return;
          
          const confirmPassword = prompt("Confirm password:");
          if (password !== confirmPassword) {
            alert("Passwords do not match");
            return;
          }
          
          try {
            const encrypted = await encryptData(content, password);
            encryptedSections[currentSecretName] = { encrypted: true, data: encrypted };
          } catch (e) {
            alert("Encryption failed: " + e.message);
            return;
          }
        } else {
          encryptedSections[currentSecretName] = { encrypted: false, data: content };
        }
        
        closeSecretEditor();
        displaySecrets();
        
        logAuditEvent("secret", `Saved note: ${currentSecretName}`);
      }
      
      function closeSecretEditor() {
        document.getElementById("secret-editor-modal").classList.remove("active");
        document.getElementById("secrets-modal").classList.add("active");
        currentSecretName = null;
      }
      
      function deleteSecret(name) {
        if (!confirm(`Delete note "${name}"?`)) return;
        
        delete encryptedSections[name];
        displaySecrets();
        
        logAuditEvent("secret", `Deleted note: ${name}`);
      }
      
      function displaySecrets() {
        const listEl = document.getElementById("secrets-list");
        if (!listEl) return;
        
        const secrets = Object.keys(encryptedSections);
        
        if (secrets.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No notes yet</div>';
          return;
        }
        
        listEl.innerHTML = secrets.map(name => {
          const section = encryptedSections[name];
          const status = section.encrypted ? "üîí Encrypted" : "üîì Plaintext";
          
          return `
            <div class="secret-item">
              <div class="secret-name">${name}</div>
              <div class="secret-status">${status}</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="editSecret('${name}')" title="Edit note">‚úèÔ∏è</button>
                <button class="btn-cancel" onclick="deleteSecret('${name}')" title="Delete note">üóëÔ∏è</button>
              </div>
            </div>
          `;
        }).join('');
      }
      
      let rafId = null;
      let lastRender = 0;
      const RENDER_THROTTLE = 16;
      
      function optimizedForgeTheTopology() {
        if (rafId) return;
        
        rafId = requestAnimationFrame((timestamp) => {
          if (timestamp - lastRender < RENDER_THROTTLE) {
            rafId = requestAnimationFrame(optimizedForgeTheTopology);
            return;
          }
          
          lastRender = timestamp;
          rafId = null;
          
          if (cullOffscreenNodes && Object.keys(NODE_DATA).length > 100) {
            cullOffscreenElements();
          }
          
          forgeTheTopology();
          
          if (Date.now() - lastMinimapUpdate > 500) {
            updateMinimapOptimized();
            lastMinimapUpdate = Date.now();
          }
        });
      }
      
      function cullOffscreenElements() {
        const viewX = canvasState.panX;
        const viewY = canvasState.panY;
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        
        Object.keys(NODE_DATA).forEach(id => {
          const pos = savedPositions[id];
          if (!pos) return;
          
          const nodeEl = document.querySelector(`[data-node-id="${id}"]`);
          if (!nodeEl) return;
          
          const isVisible = (
            pos.x + 100 >= viewX &&
            pos.x - 100 <= viewX + viewWidth &&
            pos.y + 100 >= viewY &&
            pos.y - 100 <= viewY + viewHeight
          );
          
          nodeEl.style.display = isVisible ? "" : "none";
        });
      }
      
      function updateMinimapOptimized() {
        minimapNeedsUpdate = true;
      }
      
      function setupDragToCreate() {
        const addNodeBtn = document.getElementById("add-node-btn");
        const addRackBtn = document.getElementById("add-rack-btn");
        const canvas = document.getElementById("map");
        
        if (!addNodeBtn || !addRackBtn || !canvas) return;
        
        let dragType = null;
        
        [addNodeBtn, addRackBtn].forEach(btn => {
          btn.setAttribute("draggable", "true");
          
          btn.addEventListener("dragstart", e => {
            dragType = btn.id === "add-node-btn" ? "node" : "rack";
            e.dataTransfer.effectAllowed = "copy";
            e.dataTransfer.setData("text/plain", dragType);
          });
        });
        
        canvas.addEventListener("dragover", e => {
          if (dragType) {
            e.preventDefault();
            e.dataTransfer.dropEffect = "copy";
          }
        });
        
        canvas.addEventListener("drop", e => {
          if (!dragType) return;
          
          e.preventDefault();
          
          const rect = canvas.getBoundingClientRect();
          const x = (e.clientX - rect.left) / canvasState.zoom + canvasState.panX;
          const y = (e.clientY - rect.top) / canvasState.zoom + canvasState.panY;
          
          if (dragType === "node") {
            createNodeAtPosition(x, y);
          } else if (dragType === "rack") {
            createRackAtPosition(x, y);
          }
          
          dragType = null;
        });
      }
      
      function createNodeAtPosition(x, y) {
        const timestamp = Date.now();
        const newId = `host-${timestamp}`;
        
        NODE_DATA[newId] = {
          name: "New Node",
          ip: "0.0.0.0",
          shape: "server",
          role: "",
          tags: [],
          notes: "",
          layer: "physical",
          isRack: false
        };
        
        savedPositions[newId] = { x, y };
        savedSizes[newId] = 55;
        
        pushUndo("create node");
        forgeTheTopology();
        claimTheImmortal(newId);
        
        logAuditEvent("node", `Created node at (${Math.round(x)}, ${Math.round(y)})`);
      }
      
      function createRackAtPosition(x, y) {
        const timestamp = Date.now();
        const newId = `rack-${timestamp}`;
        
        NODE_DATA[newId] = {
          name: "New Rack",
          ip: "",
          shape: "server",
          role: "rack",
          tags: [],
          notes: "",
          layer: "physical",
          isRack: true,
          rackCapacity: 42
        };
        
        savedPositions[newId] = { x, y };
        savedSizes[newId] = 55;
        
        pushUndo("create rack");
        populateRackDropdown();
        forgeTheTopology();
        claimTheImmortal(newId);
        
        logAuditEvent("rack", `Created rack at (${Math.round(x)}, ${Math.round(y)})`);
      }
      
      document.addEventListener("keydown", handleKeyDown);
      
      document.getElementById("save-file-btn").addEventListener("click", becomeImmortal);
      const addNodeBtn = document.getElementById("add-node-btn");
      const addNodeModal = document.getElementById("add-node-modal");
      const addNodeCancel = document.getElementById("add-node-cancel");
      const addNodeSave = document.getElementById("add-node-save");
      
      const undoBtn = document.getElementById("undo-btn");
      const redoBtn = document.getElementById("redo-btn");
      if (undoBtn) undoBtn.addEventListener("click", undo);
      if (redoBtn) redoBtn.addEventListener("click", redo);
      
      const backToTopologyBtn = document.getElementById("back-to-topology-btn");
      if (backToTopologyBtn) {
       backToTopologyBtn.addEventListener("click", exitRack);
      }
      
      const canvasViewport = document.getElementById("canvas-viewport");
      if (canvasViewport) {
       canvasViewport.addEventListener("dblclick", (e) => {
        if (currentView.mode === "rack" && e.target.id === "map") {
         exitRack();
        }
       });
      }
      
      const layersBtn = document.getElementById("layers-btn");
      const layerModal = document.getElementById("layer-modal");
      const layerModalClose = document.getElementById("layer-modal-close");
      if (layersBtn && layerModal) {
       layersBtn.addEventListener("click", () => {
        layerModal.classList.add("active");
       });
      }
      if (layerModalClose && layerModal) {
       layerModalClose.addEventListener("click", () => {
        layerModal.classList.remove("active");
       });
      }
      if (layerModal) {
       layerModal.addEventListener("click", (e) => {
        if (e.target === layerModal) {
         layerModal.classList.remove("active");
        }
       });
      }
      
      ["physical", "logical", "security", "application"].forEach(layer => {
       const checkbox = document.getElementById(`layer-${layer}`);
       if (checkbox) {
        checkbox.addEventListener("change", applyLayerFilter);
       }
      });
            
      const tabsBtn = document.getElementById("tabs-btn");
      const tabsModal = document.getElementById("tabs-modal");
      const tabsModalClose = document.getElementById("tabs-modal-close");
      
      if (tabsBtn && tabsModal) {
        tabsBtn.addEventListener("click", () => {
          displayTabs();
          tabsModal.classList.add("active");
        });
      }
      
      if (tabsModalClose && tabsModal) {
        tabsModalClose.addEventListener("click", () => {
          tabsModal.classList.remove("active");
        });
      }
      
      if (tabsModal) {
        tabsModal.addEventListener("click", (e) => {
          if (e.target === tabsModal) {
            tabsModal.classList.remove("active");
          }
        });
      }
      
      const rollbackBtn = document.getElementById("rollback-btn");
      const rollbackModal = document.getElementById("rollback-modal");
      const rollbackModalClose = document.getElementById("rollback-modal-close");
      
      if (rollbackBtn && rollbackModal) {
        rollbackBtn.addEventListener("click", () => {
          loadRollbackVersions();
          rollbackModal.classList.add("active");
        });
      }
      
      if (rollbackModalClose && rollbackModal) {
        rollbackModalClose.addEventListener("click", () => {
          rollbackModal.classList.remove("active");
        });
      }
      
      if (rollbackModal) {
        rollbackModal.addEventListener("click", (e) => {
          if (e.target === rollbackModal) {
            rollbackModal.classList.remove("active");
          }
        });
      }
      
      const auditLogBtn = document.getElementById("audit-log-btn");
      const auditLogModal = document.getElementById("audit-log-modal");
      const auditLogModalClose = document.getElementById("audit-log-modal-close");
      const auditFilter = document.getElementById("audit-filter");
      
      if (auditLogBtn && auditLogModal) {
        auditLogBtn.addEventListener("click", () => {
          loadAuditLog();
          displayAuditLog();
          auditLogModal.classList.add("active");
        });
      }
      
      if (auditFilter) {
        auditFilter.addEventListener("change", (e) => {
          displayAuditLog(e.target.value);
        });
      }
      
      if (auditLogModalClose && auditLogModal) {
        auditLogModalClose.addEventListener("click", () => {
          auditLogModal.classList.remove("active");
        });
      }
      
      if (auditLogModal) {
        auditLogModal.addEventListener("click", (e) => {
          if (e.target === auditLogModal) {
            auditLogModal.classList.remove("active");
          }
        });
      }
      
      const secretsBtn = document.getElementById("secrets-btn");
      const secretsModal = document.getElementById("secrets-modal");
      const secretsModalClose = document.getElementById("secrets-modal-close");
      const secretEditorModal = document.getElementById("secret-editor-modal");
      
      if (secretsBtn && secretsModal) {
        secretsBtn.addEventListener("click", () => {
          displaySecrets();
          secretsModal.classList.add("active");
        });
      }
      
      if (secretsModalClose && secretsModal) {
        secretsModalClose.addEventListener("click", () => {
          secretsModal.classList.remove("active");
        });
      }
      
      if (secretsModal) {
        secretsModal.addEventListener("click", (e) => {
          if (e.target === secretsModal) {
            secretsModal.classList.remove("active");
          }
        });
      }
      
      if (secretEditorModal) {
        secretEditorModal.addEventListener("click", (e) => {
          if (e.target === secretEditorModal) {
            closeSecretEditor();
          }
        });
      }
      
      loadAuditLog();
      setupDragToCreate();
      
      ["physical", "logical", "security", "application"].forEach(layer => {
       const checkbox = document.getElementById(`layer-${layer}`);
       if (checkbox) {
        checkbox.addEventListener("change", applyLayerFilter);
       }
      });
      
      const layerSelect = document.getElementById("node-layer");
      if (layerSelect) {
       layerSelect.addEventListener("change", (e) => {
        if (currentNodeId) {
         pushUndo("change layer");
         NODE_DATA[currentNodeId].layer = e.target.value;
         forgeTheTopology();
        }
       });
      }
      
       const assignedRackSelect = document.getElementById("node-assigned-rack");
       if (assignedRackSelect) {
      assignedRackSelect.addEventListener("change", (e) => {
      if (currentNodeId) {
      pushUndo("change assigned rack");
      EDGE_DATA.list = EDGE_DATA.list.filter(edge => edge.from !== currentNodeId && edge.to !== currentNodeId);
      NODE_DATA[currentNodeId].assignedRack = e.target.value;
      forgeTheTopology();
      claimTheImmortal(currentNodeId);
      }
      });
       }
      
      const rackCapacitySelect = document.getElementById("node-rack-capacity");
      if (rackCapacitySelect) {
       rackCapacitySelect.addEventListener("change", (e) => {
        if (currentNodeId) {
         pushUndo("change rack capacity");
         NODE_DATA[currentNodeId].rackCapacity = e.target.value;
         forgeTheTopology();
        }
       });
      }
      
      const bulkToolbarClose = document.getElementById("bulk-toolbar-close");
      if (bulkToolbarClose) {
       bulkToolbarClose.addEventListener("click", clearSelection);
      }
      
      const bulkAlignLeft = document.getElementById("bulk-align-left");
      if (bulkAlignLeft) {
       bulkAlignLeft.addEventListener("click", () => alignSelectedNodes("left"));
      }
      
      const bulkAlignRight = document.getElementById("bulk-align-right");
      if (bulkAlignRight) {
       bulkAlignRight.addEventListener("click", () => alignSelectedNodes("right"));
      }
      
      const bulkAlignTop = document.getElementById("bulk-align-top");
      if (bulkAlignTop) {
       bulkAlignTop.addEventListener("click", () => alignSelectedNodes("top"));
      }
      
      const bulkAlignBottom = document.getElementById("bulk-align-bottom");
      if (bulkAlignBottom) {
       bulkAlignBottom.addEventListener("click", () => alignSelectedNodes("bottom"));
      }
      
      const bulkDistributeH = document.getElementById("bulk-distribute-h");
      if (bulkDistributeH) {
       bulkDistributeH.addEventListener("click", () => distributeSelectedNodes("horizontal"));
      }
      
      const bulkDistributeV = document.getElementById("bulk-distribute-v");
      if (bulkDistributeV) {
       bulkDistributeV.addEventListener("click", () => distributeSelectedNodes("vertical"));
      }
      
      const bulkClone = document.getElementById("bulk-clone");
      if (bulkClone) {
       bulkClone.addEventListener("click", () => {
        if (selectedNodes.size === 0) return;
        pushUndo("clone selected");
        const nodesToClone = Array.from(selectedNodes);
        selectedNodes.clear();
        nodesToClone.forEach(id => {
         cloneNode(id);
         selectedNodes.add(currentNodeId);
        });
        updateNodeSelection();
       });
      }
      
      const bulkDelete = document.getElementById("bulk-delete");
      if (bulkDelete) {
       bulkDelete.addEventListener("click", deleteSelected);
      }
      
      const bulkMobileBtn = document.getElementById("bulk-mobile-btn");
      const bulkActionsModal = document.getElementById("bulk-actions-modal");
      const bulkModalClose = document.getElementById("bulk-modal-close");
      
      if (bulkMobileBtn) {
       bulkMobileBtn.addEventListener("click", () => {
        if (bulkActionsModal) bulkActionsModal.style.display = "block";
       });
      }
      
      if (bulkModalClose) {
       bulkModalClose.addEventListener("click", () => {
        if (bulkActionsModal) bulkActionsModal.style.display = "none";
       });
      }
      
      const closeModalAfterAction = () => {
       if (bulkActionsModal) bulkActionsModal.style.display = "none";
      };
      
      const bulkAlignLeftMobile = document.getElementById("bulk-align-left-mobile");
      if (bulkAlignLeftMobile) {
       bulkAlignLeftMobile.addEventListener("click", () => {
        alignSelectedNodes("left");
        closeModalAfterAction();
       });
      }
      
      const bulkAlignRightMobile = document.getElementById("bulk-align-right-mobile");
      if (bulkAlignRightMobile) {
       bulkAlignRightMobile.addEventListener("click", () => {
        alignSelectedNodes("right");
        closeModalAfterAction();
       });
      }
      
      const bulkAlignTopMobile = document.getElementById("bulk-align-top-mobile");
      if (bulkAlignTopMobile) {
       bulkAlignTopMobile.addEventListener("click", () => {
        alignSelectedNodes("top");
        closeModalAfterAction();
       });
      }
      
      const bulkAlignBottomMobile = document.getElementById("bulk-align-bottom-mobile");
      if (bulkAlignBottomMobile) {
       bulkAlignBottomMobile.addEventListener("click", () => {
        alignSelectedNodes("bottom");
        closeModalAfterAction();
       });
      }
      
      const bulkDistributeHMobile = document.getElementById("bulk-distribute-h-mobile");
      if (bulkDistributeHMobile) {
       bulkDistributeHMobile.addEventListener("click", () => {
        distributeSelectedNodes("horizontal");
        closeModalAfterAction();
       });
      }
      
      const bulkDistributeVMobile = document.getElementById("bulk-distribute-v-mobile");
      if (bulkDistributeVMobile) {
       bulkDistributeVMobile.addEventListener("click", () => {
        distributeSelectedNodes("vertical");
        closeModalAfterAction();
       });
      }
      
      const bulkCloneMobile = document.getElementById("bulk-clone-mobile");
      if (bulkCloneMobile) {
       bulkCloneMobile.addEventListener("click", () => {
        if (selectedNodes.size === 0) return;
        pushUndo("clone selected");
        const nodesToClone = Array.from(selectedNodes);
        selectedNodes.clear();
        nodesToClone.forEach(id => {
         cloneNode(id);
         selectedNodes.add(currentNodeId);
        });
        updateNodeSelection();
        closeModalAfterAction();
       });
      }
      
      const bulkDeleteMobile = document.getElementById("bulk-delete-mobile");
      if (bulkDeleteMobile) {
       bulkDeleteMobile.addEventListener("click", () => {
        deleteSelected();
        closeModalAfterAction();
       });
      }
      
      const bulkLockMobile = document.getElementById("bulk-lock-mobile");
      if (bulkLockMobile) {
       bulkLockMobile.addEventListener("click", () => {
        toggleLockSelected();
        closeModalAfterAction();
       });
      }
      
      const bulkGroupMobile = document.getElementById("bulk-group-mobile");
      if (bulkGroupMobile) {
       bulkGroupMobile.addEventListener("click", () => {
        toggleGroupSelected();
        closeModalAfterAction();
       });
      }
      
      const bulkClearMobile = document.getElementById("bulk-clear-mobile");
      if (bulkClearMobile) {
       bulkClearMobile.addEventListener("click", () => {
        clearSelection();
        closeModalAfterAction();
       });
      }
      
      const searchInput = document.getElementById("search-nodes");
      if (searchInput) {
       searchInput.addEventListener("input", (e) => {
        searchNodes(e.target.value);
       });
      }
      
      addNodeBtn.addEventListener("click", () => {
       document.getElementById("new-node-name").value = "";
       document.getElementById("new-node-ip").value = "";
       document.getElementById("new-node-tags").value = "";
       document.getElementById("new-node-shape").value = "circle";
       addNodeModal.classList.add("active");
       document.getElementById("new-node-name").focus();
      });
      
      const addRackBtn = document.getElementById("add-rack-btn");
      const addRackModal = document.getElementById("add-rack-modal");
      const addRackCancel = document.getElementById("add-rack-cancel");
      const addRackSave = document.getElementById("add-rack-save");
      
      if (addRackBtn && addRackModal) {
       addRackBtn.addEventListener("click", () => {
        document.getElementById("new-rack-name").value = "";
        document.getElementById("new-rack-ip").value = "";
        document.getElementById("new-rack-tags").value = "";
        document.getElementById("new-rack-shape").value = "server";
        document.getElementById("new-rack-capacity").value = "42";
        addRackModal.classList.add("active");
        document.getElementById("new-rack-name").focus();
       });
      }
      
      if (addRackCancel && addRackModal) {
       addRackCancel.addEventListener("click", () => {
        addRackModal.classList.remove("active");
       });
      }
      
      if (addRackModal) {
       addRackModal.addEventListener("click", (e) => {
        if (e.target === addRackModal) {
         addRackModal.classList.remove("active");
        }
       });
      }
      
      if (addRackSave && addRackModal) {
       addRackSave.addEventListener("click", () => {
        const name = document.getElementById("new-rack-name").value.trim();
        const ip = document.getElementById("new-rack-ip").value.trim();
        const tagsStr = document.getElementById("new-rack-tags").value.trim();
        const shape = document.getElementById("new-rack-shape").value;
        const capacity = document.getElementById("new-rack-capacity").value;
        
        if (!name) {
         alert("Please enter a rack name.");
         return;
        }
        
        const tags = tagsStr ? tagsStr.split(",").map((t) => t.trim()).filter((t) => t) : [];
        let baseId = name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");
        if (!baseId) baseId = "rack";
        let nodeId = baseId;
        let counter = 1;
        while (NODE_DATA[nodeId]) {
         nodeId = baseId + "-" + counter;
         counter++;
        }
        
        pushUndo("add rack");
        
        NODE_DATA[nodeId] = {
         shape: shape,
         name: name,
         ip: ip || "",
         role: "Rack",
         tags: tags,
         notes: [],
         mac: "",
         rackUnit: "",
         uHeight: "1",
         layer: "physical",
         assignedRack: "",
         rackCapacity: capacity,
         isRack: true,  
         locked: false, 
         groupId: null 
        };
        
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        const centerX = canvasState.panX + (viewWidth / 2);
        const centerY = canvasState.panY + (viewHeight / 2);
        savedPositions[nodeId] = {
         x: centerX,
         y: centerY
        };
        
        addRackModal.classList.remove("active");
        forgeTheTopology();
        claimTheImmortal(nodeId);
       });
       
       ["new-rack-name", "new-rack-ip", "new-rack-tags"].forEach((inputId) => {
        const input = document.getElementById(inputId);
        if (input) {
         input.addEventListener("keypress", (e) => {
          if (e.key === "Enter") {
           addRackSave.click();
          }
         });
        }
       });
      }
      
      addNodeCancel.addEventListener("click", () => {
       addNodeModal.classList.remove("active");
      });
      addNodeModal.addEventListener("click", (e) => {
       if (e.target === addNodeModal) {
        addNodeModal.classList.remove("active");
       }
      });
      addNodeSave.addEventListener("click", () => {
       const name = document.getElementById("new-node-name").value.trim();
       const ip = document.getElementById("new-node-ip").value.trim();
       const tagsStr = document.getElementById("new-node-tags").value.trim();
       const shape = document.getElementById("new-node-shape").value;
       if (!name) {
        alert("Please enter a node name.");
        return;
       }
       const tags = tagsStr ? tagsStr.split(",").map((t) => t.trim()).filter((t) => t) : [];
       let baseId = name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");
       if (!baseId) baseId = "node";
       let nodeId = baseId;
       let counter = 1;
       while (NODE_DATA[nodeId]) {
        nodeId = baseId + "-" + counter;
        counter++;
       }
       NODE_DATA[nodeId] = {
        shape: shape || "circle",
        name: name,
        ip: ip || "0.0.0.0",
        role: "",
        tags: tags,
        notes: [],
        mac: "",
        rackUnit: "",
        uHeight: "1",
        layer: "physical",
        assignedRack: "",  
        rackCapacity: "42",
        isRack: false, 
        locked: false, 
        groupId: null 
       };
       
       if (currentView.mode === "rack" && currentView.rackId) {
        NODE_DATA[nodeId].assignedRack = currentView.rackId;
       }
       
      const viewWidth = CANVAS_WIDTH / canvasState.zoom;
      const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
      const centerX = canvasState.panX + (viewWidth / 2);
      const centerY = canvasState.panY + (viewHeight / 2);
      savedPositions[nodeId] = {
      x: centerX,
      y: centerY
      };
       pushUndo("add node");
       addNodeModal.classList.remove("active");
       forgeTheTopology();
       claimTheImmortal(nodeId);
      });
      ["new-node-name", "new-node-ip", "new-node-tags"].forEach(
       (inputId) => {
        document.getElementById(inputId).addEventListener("keypress", (e) => {
         if (e.key === "Enter") {
          addNodeSave.click();
         }
        });
       }, );
      const clearAllBtn = document.getElementById("clear-all-btn");
      const clearAllModal = document.getElementById("clear-all-modal");
      const clearAllCancel = document.getElementById("clear-all-cancel");
      const clearAllConfirm = document.getElementById("clear-all-confirm");
      clearAllBtn.addEventListener("click", () => {
       clearAllModal.classList.add("active");
      });
      clearAllCancel.addEventListener("click", () => {
       clearAllModal.classList.remove("active");
      });
      clearAllModal.addEventListener("click", (e) => {
       if (e.target === clearAllModal) {
        clearAllModal.classList.remove("active");
       }
      });
      clearAllConfirm.addEventListener("click", () => {
       NODE_DATA = {};
       EDGE_DATA = {
        list: []
       };
       EDGE_LEGEND = {};
       RECT_DATA = { list: [] };
       TEXT_DATA = { list: [] };
       savedPositions = {};
       savedSizes = {};
       savedStyles = {};
       clearAllModal.classList.remove("active");
       forgeTheTopology();
       document.getElementById("node-panel").style.display = "none";
       document.getElementById("edge-panel").style.display = "none";
       document.getElementById("text-panel").style.display = "none";
       document.getElementById("topology-toolbar").style.display = "none";
       currentNodeId = null;
       currentEdgeId = null;
       currentTextId = null;
      });
      (function addDeleteNodeButton() {
       const nodePanel = document.getElementById("node-panel");
       if (!nodePanel) return;
       if (document.getElementById("delete-node-btn")) return;
       const deleteBtn = document.createElement("button");
       deleteBtn.id = "delete-node-btn";
       deleteBtn.textContent = "Delete Node";
       deleteBtn.style.cssText = "margin-top:15px; padding:10px 16px; background:var(--danger); color:#fff; border:none; border-radius:6px; cursor:pointer; font-size:clamp(14px,1.6vw,18px); font-weight:600; width:100%;";
       deleteBtn.addEventListener("click", () => {
        if (!currentNodeId) return;
        challengeTheImmortal(`Delete node "${NODE_DATA[currentNodeId]?.name || currentNodeId}" and all its connections?`,
         () => {
          EDGE_DATA.list = EDGE_DATA.list.filter(
           (e) => e.from !== currentNodeId && e.to !== currentNodeId, );
          delete NODE_DATA[currentNodeId];
          delete savedPositions[currentNodeId];
          delete savedSizes[currentNodeId];
          delete savedStyles[currentNodeId];
          currentNodeId = null;
          currentEdgeId = null;
          forgeTheTopology();
          const remainingNodes = Object.keys(NODE_DATA);
          if (remainingNodes.length > 0) {
           claimTheImmortal(remainingNodes[0]);
          } else {
           document.getElementById("node-panel").style.display = "none";
           document.getElementById("edge-panel").style.display = "none";
           document.getElementById("topology-toolbar", ).style.display = "none";
          }
         }, );
       });
       nodePanel.appendChild(deleteBtn);
      })();
      
      function screenshotCanvas() {
       const svg = document.getElementById("map");
       const svgClone = svg.cloneNode(true);
       const viewBox = svg.getAttribute("viewBox").split(" ").map(Number);
       const [x, y, width, height] = viewBox;
       svgClone.setAttribute("width", width);
       svgClone.setAttribute("height", height);
       svgClone.setAttribute("viewBox", `${x} ${y} ${width} ${height}`);
       const wrapper = document.createElement("div");
       wrapper.style.position = "absolute";
       wrapper.style.left = "-9999px";
       wrapper.appendChild(svgClone);
       document.body.appendChild(wrapper);
      
       function inlineStyles(original, clone) {
        const elements = original.querySelectorAll("*");
        const clonedElements = clone.querySelectorAll("*");
        const rootStyles = getComputedStyle(document.documentElement);
        const bgColor = rootStyles.getPropertyValue("--bg").trim() || "#050608";
        const bgRect = document.createElementNS("http://www.w3.org/2000/svg", "rect", );
        bgRect.setAttribute("x", x);
        bgRect.setAttribute("y", y);
        bgRect.setAttribute("width", width);
        bgRect.setAttribute("height", height);
        bgRect.setAttribute("fill", bgColor);
        clone.insertBefore(bgRect, clone.firstChild);
        elements.forEach((el, index) => {
         const clonedEl = clonedElements[index];
         if (!clonedEl) return;
         const computedStyle = getComputedStyle(el);
         const svgProps = ["fill", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin", "opacity", "font-family", "font-size", "font-weight", "font-style", "text-anchor", "dominant-baseline", "marker-start", "marker-end", ];
         svgProps.forEach((prop) => {
          const value = computedStyle.getPropertyValue(prop);
          if (value && value !== "none" && value !== "normal") {
           clonedEl.style[prop] = value;
          }
         });
         clonedEl.removeAttribute("class");
        });
       }
       inlineStyles(svg, svgClone);
       const svgData = new XMLSerializer().serializeToString(svgClone);
       document.body.removeChild(wrapper);
       const svgBlob = new Blob([svgData], {
        type: "image/svg+xml;charset=utf-8",
       });
       const url = URL.createObjectURL(svgBlob);
       const img = new Image();
       img.onload = function() {
        const canvas = document.createElement("canvas");
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext("2d");
        ctx.drawImage(img, 0, 0);
        canvas.toBlob(function(blob) {
         const link = document.createElement("a");
         const timestamp = new Date().toISOString().slice(0, 10);
         link.download = `topology-${timestamp}.png`;
         link.href = URL.createObjectURL(blob);
         link.click();
         URL.revokeObjectURL(url);
         URL.revokeObjectURL(link.href);
        }, "image/png");
       };
       img.onerror = function() {
        console.error("Failed to load SVG image");
        alert("Screenshot failed. Please try again.");
        URL.revokeObjectURL(url);
       };
       img.src = url;
      }
      
      function exportCanvasSVG() {
       const svg = document.getElementById("map");
       const svgClone = svg.cloneNode(true);
       const viewBox = svg.getAttribute("viewBox").split(" ").map(Number);
       const [x, y, width, height] = viewBox;
       svgClone.setAttribute("width", width);
       svgClone.setAttribute("height", height);
       const rootStyles = getComputedStyle(document.documentElement);
       const bgColor = rootStyles.getPropertyValue("--bg").trim() || "#050608";
       const bgRect = document.createElementNS("http://www.w3.org/2000/svg", "rect", );
       bgRect.setAttribute("x", x);
       bgRect.setAttribute("y", y);
       bgRect.setAttribute("width", width);
       bgRect.setAttribute("height", height);
       bgRect.setAttribute("fill", bgColor);
       svgClone.insertBefore(bgRect, svgClone.firstChild);
       const wrapper = document.createElement("div");
       wrapper.style.position = "absolute";
       wrapper.style.left = "-9999px";
       wrapper.appendChild(svgClone);
       document.body.appendChild(wrapper);
       const elements = svg.querySelectorAll("*");
       const clonedElements = svgClone.querySelectorAll("*");
       elements.forEach((el, index) => {
        const clonedEl = clonedElements[index];
        if (!clonedEl) return;
        const computedStyle = getComputedStyle(el);
        const svgProps = ["fill", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin", "opacity", "font-family", "font-size", "font-weight", "font-style", "text-anchor", "dominant-baseline", "marker-start", "marker-end", ];
        svgProps.forEach((prop) => {
         const value = computedStyle.getPropertyValue(prop);
         if (value && value !== "none" && value !== "normal") {
          clonedEl.setAttribute(prop, value);
         }
        });
        clonedEl.removeAttribute("class");
       });
       const svgData = new XMLSerializer().serializeToString(svgClone);
       document.body.removeChild(wrapper);
       const blob = new Blob([svgData], {
        type: "image/svg+xml;charset=utf-8",
       });
       const url = URL.createObjectURL(blob);
       const link = document.createElement("a");
       const timestamp = new Date().toISOString().slice(0, 10);
       link.download = `topology-${timestamp}.svg`;
       link.href = url;
       link.click();
       URL.revokeObjectURL(url);
      }
      let resizeTimeout;
       window.addEventListener('resize', () => {
       clearTimeout(resizeTimeout);
       resizeTimeout = setTimeout(() => {
       updateDrawToolbarVisibility();
       updateTopologyToolbarVisibility();
       }, 100);
      });
    </script>
  
</body></html>