<!DOCTYPE html> 
 <html lang="en" style="--panel: #0b0e13; --panel-alt: #10141b; --accent: #4fd1c5; --danger: #f56565; --text-main: #e2e8f0; --text-soft: #94a3b8; --topbar-bg: rgba(9, 12, 20, 0.9); --topbar-border: #1f2533; --topbar-height: 100px; --sidebar-width: 435px; --mobile-footer-height: 20vh; --draw-toolbar-height: 45px;"><head>
    <meta charset="UTF-8">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Corporate Network</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- 
      * ==================================================================================
      * The One File: The Networkening
      * !!!!!!!!!!!!!!!!!!!NOTE: THIS IS THE ONLINE VERSION!!!!!!!!!!!!!!!!!!!!!!
      * Online version uses 3 cdn calls from cdn.jsdelivr.net to display additional icons
      * Since 3.0 Online version uses http as a form of ping to display uptime
      * "There can be only one". A all in one file topology maker.
      * 
      * This is your last backup when all others fail. A completely self-contained
      * network topology visualization tool that works as a single HTML file.
      * Open it anywhere, anytime and the idea lives forever.
      * ==================================================================================
      -->
    <style>
      :root {
      color-scheme: dark;
      --bg: #050608;
      --panel: #0b0e13;
      --panel-alt: #10141b;
      --accent: #4fd1c5;
      --danger: #f56565;
      --text-main: #e2e8f0;
      --text-soft: #94a3b8;
      --edge-main: #475569;
      --node-min: 35px;
      --node-max: 70px;
      --topbar-bg: rgba(9, 12, 20, 0.9);
      --topbar-border: #1f2533;
      }
      * {
      box-sizing: border-box;
      user-select: none;
      }
      input,
      textarea,
      [contenteditable="true"] {
      user-select: text;
      -webkit-user-select: text;
      }
      body {
      margin: 0;
      font-family: system-ui, sans-serif;
      background: radial-gradient(circle at top, #1e2532 0, #050608 70%);
      color: var(--text-main);
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
      }
      header {
      padding: 0 20px;
      height: var(--topbar-height, 52px);
      min-height: var(--topbar-height, 52px);
      background: var(--topbar-bg);
      backdrop-filter: blur(6px);
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid var(--topbar-border);
      gap: 16px;
      }
      .title-block {
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-width: 0;
      }
      header h1 {
      font-size: clamp(22px, 3vw, 32px);
      margin: 0;
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
      }
      .editable-page-title {
      cursor: pointer;
      transition: opacity 0.2s;
      }
      .editable-page-title:hover {
      opacity: 0.7;
      }
      .save-row {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      }
      .save-btn {
      padding: 6px 12px;
      background: var(--accent);
      color: var(--bg);
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      white-space: nowrap;
      }
      .save-btn:hover {
      opacity: 0.9;
      }
      .help-icon {
      width: 22px;
      height: 22px;
      border-radius: 50%;
      border: 1px solid var(--edge-main);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      cursor: pointer;
      color: var(--text-soft);
      background: rgba(15, 23, 42, 0.9);
      flex-shrink: 0;
      }
      .help-icon:hover {
      color: var(--accent);
      border-color: var(--accent);
      }
      #settings-btn {
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 16px;
      flex-shrink: 0;
      }
      #settings-btn:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .header-resizer {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 6px;
      background: transparent;
      cursor: row-resize;
      z-index: 1000;
      transition: background 0.2s;
      }
      .header-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .header-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      .sidebar-resizer {
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 6px;
      background: transparent;
      cursor: col-resize;
      z-index: 1000;
      transition: background 0.2s;
      }
      .sidebar-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .sidebar-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      .mobile-footer-resizer {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 6px;
      background: transparent;
      cursor: row-resize;
      z-index: 1000;
      transition: background 0.2s;
      display: none;
      }
      .mobile-footer-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .mobile-footer-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      @media (max-width: 900px) {
      .mobile-footer-resizer {
      display: block;
      height: 12px;
      }
      .sidebar-resizer {
      display: none;
      }
      .header-resizer {
      height: 12px;
      }
      }
      @media (pointer: coarse) {
      .header-resizer {
      height: 16px;
      }
      .mobile-footer-resizer {
      height: 16px;
      }
      .sidebar-resizer {
      width: 16px;
      }
      }
      .resizer-icon {
      position: absolute;
      opacity: 0.5;
      transition: opacity 0.2s, transform 0.2s;
      pointer-events: none;
      fill: var(--accent);
      }
      .header-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .sidebar-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .mobile-footer-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .header-resizer:hover .resizer-icon,
      .sidebar-resizer:hover .resizer-icon,
      .mobile-footer-resizer:hover .resizer-icon {
      opacity: 1;
      }
      .header-resizer.resizing .resizer-icon,
      .sidebar-resizer.resizing .resizer-icon,
      .mobile-footer-resizer.resizing .resizer-icon {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1.2);
      }
      body.resizing {
      user-select: none;
      }
      body.resizing * {
      cursor: inherit !important;
      pointer-events: none;
      }
      header {
      position: relative;
      }
      .details-panel {
      position: relative;
      }
      main {
      display: grid;
      grid-template-columns: 1fr var(--sidebar-width, 350px);
      flex: 1;
      }
      main.sidebar-collapsed {
      grid-template-columns: 1fr 0;
      }
      @media (max-width: 900px) {
      main {
      grid-template-columns: 1fr;
      grid-template-rows: calc(100vh - var(--topbar-height, 52px) - var(--mobile-footer-height, 40vh)) var(--mobile-footer-height, 40vh);
      }
      main.sidebar-collapsed {
      grid-template-rows: 1fr 0;
      }
      .details-panel {
      max-height: var(--mobile-footer-height, 40vh);
      height: 100%;
      }
      }
      .topology-panel {
      background: var(--panel);
      border-right: 1px solid #111827;
      position: relative;
      overflow: hidden;
      }
      .topology-toolbar {
      position: absolute;
      top: 10px;
      right: 10px;
      display: none;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      background: rgba(15, 23, 42, 0.92);
      border: 1px solid #1f2937;
      border-radius: 6px;
      z-index: 20;
      font-size: 13px;
      }
      .topology-toolbar label {
      color: var(--text-soft);
      }
      .topology-toolbar select {
      padding: 4px 6px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: 13px;
      cursor: pointer;
      }
      .topology-toolbar button {
      padding: 4px 10px;
      background: var(--accent);
      color: var(--bg);
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      }
      .bulk-toolbar-desktop,
      .bulk-toolbar-mobile {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 9999;
      }
      .bulk-toolbar-desktop {
      position: absolute;
      top: 10px;
      right: 10px;
      bottom: auto;
      left: auto;
      transform: none;
      }
      .bulk-action-btn {
      padding: 16px;
      background: var(--panel-main);
      border: 1px solid var(--edge-main);
      border-radius: 8px;
      color: var(--text-main);
      font-size: 24px;
      cursor: pointer;
      text-align: center;
      line-height: 1.2;
      }
      .bulk-action-btn:active {
      transform: scale(0.95);
      background: var(--accent);
      }
      .draw-toolbar {
      position: absolute;
      top: 10px;
      left: 10px;
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 8px;
      background: rgba(15, 23, 42, 0.92);
      border: 1px solid #1f2937;
      border-radius: 6px;
      z-index: 20;
      font-size: 13px;
      pointer-events: auto;
      }
      .draw-toolbar button {
      padding: 4px 8px;
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      }
      .draw-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .draw-toolbar input[type="color"] {
      width: 30px;
      height: 22px;
      border-radius: 4px;
      border: 1px solid var(--edge-main);
      padding: 0;
      background: transparent;
      cursor: pointer;
      }
      .draw-toolbar select {
      padding: 4px 6px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: 13px;
      cursor: pointer;
      }
      .legend-container {
      position: absolute;
      left: 10px;
      bottom: 10px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      padding: 8px 10px;
      background: rgba(15, 23, 42, 0.92);
      border: 1px solid #1f2937;
      border-radius: 6px;
      font-size: 12px;
      z-index: 20;
      max-width: 260px;
      pointer-events: auto;
      }
      .legend-container {
      padding-right: 22px;
      }
      @media (max-width: 900px) {
      .legend-container {
      max-height: calc(100vh - var(--topbar-height, 100px) - 120px);
      overflow-y: auto;
      }
      }
      @media (max-width: 900px) {
      .bulk-toolbar-desktop,
      .topology-toolbar {
      display: none !important;
      }
      }
      .legend-close-btn {
      position: absolute;
      top: 5px;
      right: 5px;
      width: 18px;
      height: 18px;
      border-radius: 999px;
      border: 1px solid var(--edge-main);
      background: var(--panel-alt);
      color: var(--text-soft);
      font-size: 11px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      }
      .legend-close-btn:hover {
      background: var(--danger);
      color: #fff;
      }
      .legend-mini-btn {
      position: absolute;
      left: 10px;
      padding: 4px 8px;
      border-radius: 4px;
      border: 1px solid #1f2937;
      background: rgba(15, 23, 42, 0.92);
      color: var(--text-main);
      font-size: 11px;
      cursor: pointer;
      z-index: 20;
      display: none;
      transition: all 0.2s;
      }
      .legend-mini-btn:hover,
      .legend-mini-btn:active {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
      }
      .legend-title {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: var(--text-soft);
      margin-bottom: 2px;
      }
      .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      }
      .legend-swatch {
      width: 14px;
      height: 14px;
      border-radius: 3px;
      border: 1px solid #020617;
      flex-shrink: 0;
      }
      .legend-label {
      outline: none;
      cursor: text;
      flex: 1;
      min-width: 60px;
      user-select: text;
      -webkit-user-select: text;
      }
      .legend-label.editing {
      border-bottom: 1px dashed var(--accent);
      }
      .canvas-viewport {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      overflow: hidden;
      }
      .canvas-viewport.panning {
      cursor: grabbing !important;
      }
      .canvas-viewport.panning * {
      cursor: grabbing !important;
      }
      .canvas-viewport svg {
      width: 100%;
      height: 100%;
      display: block;
      background: linear-gradient(rgba(71, 85, 105, 0.1) 1px,
      transparent 1px),
      linear-gradient(90deg,
      rgba(71, 85, 105, 0.1) 1px,
      transparent 1px),
      linear-gradient(rgba(71, 85, 105, 0.05) 1px, transparent 1px),
      linear-gradient(90deg,
      rgba(71, 85, 105, 0.05) 1px,
      transparent 1px);
      background-size:
      100px 100px,
      100px 100px,
      20px 20px,
      20px 20px;
      background-position:
      -1px -1px,
      -1px -1px,
      -1px -1px,
      -1px -1px;
      }
      .zoom-toolbar {
      display: flex;
      gap: 4px;
      padding: 6px;
      background: rgba(15, 23, 42, 0.92);
      border: 1px solid #1f2937;
      border-radius: 6px;
      }
      .zoom-toolbar button {
      width: 32px;
      height: 32px;
      padding: 0;
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      font-size: 18px;
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
      }
      .zoom-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .zoom-toolbar .zoom-level {
      font-size: 11px;
      color: var(--text-soft);
      text-align: center;
      padding: 2px 0;
      min-width: 32px;
      }
      .zoom-toolbar .divider {
      height: 1px;
      background: var(--edge-main);
      margin: 2px 0;
      }
      .minimap-zoom-wrapper {
      position: absolute;
      bottom: 10px;
      right: 10px;
      z-index: 99;
      }
      .minimap-container {
      background: rgba(15, 23, 42, 0.92);
      border: 1px solid #1f2937;
      border-radius: 6px;
      overflow: hidden;
      margin-bottom: 4px;
      }
      .minimap-container svg {
      width: 100%;
      height: 100%;
      }
      .minimap-viewport {
      fill: rgba(79, 209, 197, 0.2);
      stroke: var(--accent);
      stroke-width: 2;
      cursor: move;
      }
      .minimap-node {
      fill: var(--text-soft);
      }
      .minimap-edge {
      stroke: var(--edge-main);
      stroke-width: 1;
      }
      .minimap-close-btn {
      position: absolute;
      top: 2px;
      right: 2px;
      width: 18px;
      height: 18px;
      background: rgba(15, 23, 42, 0.9);
      border: 1px solid var(--edge-main);
      border-radius: 3px;
      color: var(--text-soft);
      font-size: 11px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
      padding: 0;
      line-height: 1;
      }
      .minimap-close-btn:hover {
      background: var(--danger);
      color: white;
      border-color: var(--danger);
      }
      .toolbar-close-btn {
      width: 24px;
      height: 24px;
      background: rgba(15, 23, 42, 0.9);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-soft);
      font-size: 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      line-height: 1;
      flex-shrink: 0;
      }
      .toolbar-close-btn:hover {
      background: var(--danger);
      color: white;
      border-color: var(--danger);
      }
      .canvas-hint {
      position: absolute;
      top: 50px;
      left: 50%;
      transform: translateX(-50%);
      padding: 8px 16px;
      background: rgba(15, 23, 42, 0.92);
      border: 1px solid #1f2937;
      border-radius: 6px;
      font-size: 12px;
      color: var(--text-soft);
      z-index: 18;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
      }
      .canvas-hint.visible {
      opacity: 1;
      }
      .edge {
      stroke: var(--edge-main);
      stroke-width: 4;
      opacity: 0.75;
      transition: 0.25s ease-in-out;
      cursor: pointer;
      }
      .edge.backup {
      stroke: var(--danger);
      stroke-width: 5;
      }
      .edge.active {
      opacity: 1;
      stroke-width: 7;
      }
      .free-preview {
      fill: none;
      stroke-dasharray: 4 4;
      pointer-events: none;
      }
      .free-point {
      fill: #e5e7eb;
      stroke: #0f172a;
      stroke-width: 1.5;
      cursor: grab;
      }
      .node-circle {
      transition: 0.25s ease;
      transform-origin: center center;
      }
      .node-hit-area {
      cursor: grab;
      pointer-events: all;
      }
      .node-group:hover .node-circle {
      transform: scale(1.08);
      filter: drop-shadow(0 0 10px rgba(79, 209, 197, 0.45));
      }
      .node-group:hover .node-label,
      .node-group:hover .node-sub {
      transform: scale(1.08);
      }
      .node-group.active .node-circle {
      stroke: var(--accent);
      animation: pulse 1.2s infinite ease-in-out;
      }
      @keyframes pulse {
      0% {
      filter: drop-shadow(0 0 4px #4fd1c5);
      }
      50% {
      filter: drop-shadow(0 0 14px #4fd1c5);
      }
      100% {
      filter: drop-shadow(0 0 4px #4fd1c5);
      }
      }
      .node-label {
      fill: var(--text-main);
      font-size: 18px;
      text-anchor: middle;
      font-weight: 600;
      }
      .node-sub {
      fill: var(--text-soft);
      font-size: 13px;
      text-anchor: middle;
      }
      .ping-indicator {
      fill: #6b7280;
      stroke: #4b5563;
      stroke-width: 1;
      }
      .ping-indicator.online {
      fill: #10b981;
      stroke: #059669;
      }
      .ping-indicator.offline {
      fill: #ef4444;
      stroke: #dc2626;
      }
      .ping-indicator.checking {
      fill: #f59e0b;
      stroke: #d97706;
      }
      @media (max-width: 1024px) {
      .node-label {
      font-size: 28px;
      }
      .node-sub {
      font-size: 20px;
      }
      }
      @media (max-width: 768px) {
      .node-label {
      font-size: 70px;
      }
      .node-sub {
      font-size: 50px;
      }
      }
      @media (max-width: 380px) {
      .node-label {
      font-size: 60px;
      }
      .node-sub {
      font-size: 42px;
      }
      }
      .details-panel {
      background: var(--panel-alt);
      padding: 22px;
      padding-bottom: 80px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 15px;
      position: relative;
      transition:
      width 0.3s ease,
      min-width 0.3s ease,
      padding 0.3s ease,
      opacity 0.3s ease;
      }
      .details-panel {
      min-width: 260px !important;
      }
      .details-panel {
      overflow-y: auto !important;
      overflow-x: hidden;
      }
      .details-panel.collapsed {
      width: 0 !important;
      min-width: 0 !important;
      padding: 0 !important;
      overflow: hidden;
      opacity: 0;
      }
      body {
      overflow-x: hidden;
      overflow-y: hidden;
      }
      main {
      overflow-x: hidden;
      overflow-y: visible;
      }
      .details-panel {
      overflow-y: auto !important;
      overflow-x: hidden;
      }
      .details-panel.collapsed {
      min-width: 0 !important;
      }
      .sidebar-toggle {
      position: absolute;
      left: -16px;
      top: 50%;
      transform: translateY(-50%);
      width: 16px;
      height: 60px;
      background: var(--panel-alt);
      border: 1px solid var(--edge-main);
      border-right: none;
      border-radius: 8px 0 0 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text-soft);
      font-size: 10px;
      z-index: 25;
      transition:
      background 0.2s,
      color 0.2s;
      }
      .sidebar-toggle:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .sidebar-toggle.collapsed {
      left: 0;
      border-right: 1px solid var(--edge-main);
      border-radius: 0 8px 8px 0;
      position: fixed;
      right: 0;
      left: auto;
      }
      .details-name {
      font-size: clamp(22px, 2.5vw, 30px);
      font-weight: 700;
      }
      .details-ip {
      font-size: clamp(16px, 2vw, 22px);
      color: var(--text-soft);
      }
      .details-role {
      font-size: clamp(16px, 2vw, 22px);
      color: var(--accent);
      }
      .size-controls {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-top: 10px;
      }
      .size-controls label {
      font-size: clamp(14px, 1.6vw, 18px);
      color: var(--text-soft);
      }
      .size-controls input[type="range"] {
      flex: 1;
      accent-color: var(--accent);
      }
      .size-controls button {
      padding: 6px 12px;
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      font-size: clamp(12px, 1.4vw, 16px);
      }
      .size-controls button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .style-section {
      margin-top: 15px;
      padding-top: 15px;
      border-top: 1px solid var(--edge-main);
      }
      .style-section summary {
      cursor: pointer;
      font-size: clamp(14px, 1.6vw, 20px);
      text-transform: uppercase;
      color: var(--text-soft);
      list-style: none;
      display: flex;
      justify-content: space-between;
      align-items: center;
      user-select: none;
      }
      .style-section summary::-webkit-details-marker {
      display: none;
      }
      .password-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #ffffff;
      z-index: 9999;
      }
      .style-section summary::after {
      content: "â–¼";
      transition: transform 0.2s;
      }
      .style-section[open] summary::after {
      transform: rotate(180deg);
      }
      .style-content {
      margin-top: 10px;
      }
      .style-row {
      display: flex;
      gap: 10px;
      align-items: center;
      margin: 8px 0;
      }
      .style-row label {
      font-size: clamp(13px, 1.5vw, 17px);
      color: var(--text-soft);
      min-width: 80px;
      }
      .style-row input[type="color"] {
      width: 50px;
      height: 30px;
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      background: transparent;
      }
      .style-row input[type="number"] {
      width: 70px;
      padding: 4px 8px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(12px, 1.4vw, 16px);
      }
      .style-row select {
      flex: 1;
      padding: 4px 8px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(12px, 1.4vw, 16px);
      cursor: pointer;
      }
      .editable-text {
      cursor: pointer;
      transition: opacity 0.2s;
      }
      .editable-text:hover {
      opacity: 0.7;
      }
      .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      z-index: 999999;
      justify-content: center;
      align-items: center;
      overflow: auto;
      }
      .modal.active {
      display: inline-grid;
      }
      .modal-content {
      background: var(--panel-alt);
      padding: 25px;
      border-radius: 8px;
      border: 1px solid var(--edge-main);
      min-width: 300px;
      max-width: 90%;
      }
      .modal-content h3 {
      margin: 0 0 15px 0;
      color: var(--text-main);
      font-size: clamp(18px, 2vw, 24px);
      }
      .modal-content p {
      color: var(--text-soft);
      font-size: clamp(14px, 1.6vw, 18px);
      margin: 0 0 20px 0;
      }
      .modal-content input:not([type="color"]),
      .modal-content select {
      width: 100%;
      padding: 10px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(14px, 1.6vw, 18px);
      margin-bottom: 15px;
      user-select: text;
      -webkit-user-select: text;
      }
      .modal-content input[type="color"] {
      width: 60px;
      height: 36px;
      padding: 2px;
      border: 2px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      background: none;
      -webkit-appearance: none;
      appearance: none;
      }
      .modal-content input[type="color"]::-webkit-color-swatch-wrapper {
      padding: 0;
      }
      .modal-content input[type="color"]::-webkit-color-swatch {
      border: none;
      border-radius: 4px;
      }
      .modal-buttons {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
      margin-top: 10px;
      }
      .modal-buttons button {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: clamp(14px, 1.6vw, 18px);
      font-weight: 600;
      }
      .modal-buttons .btn-cancel {
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      }
      .modal-buttons .btn-save {
      background: var(--accent);
      color: var(--bg);
      }
      .modal-buttons .btn-delete {
      background: var(--danger);
      color: white;
      }
      .confirm-modal p {
      color: var(--text-soft);
      font-size: clamp(14px, 1.6vw, 18px);
      margin: 0 0 20px 0;
      }
      .context-menu-item {
      transition: background 0.15s;
      }
      .context-menu-item:hover {
      background: var(--panel);
      }
      .details-info-row {
      display: flex;
      align-items: center;
      margin: 6px 0;
      }
      .node-group.selected .node-circle,
      .node-group.selected rect,
      .node-group.selected polygon {
      stroke: #f59e0b;
      stroke-width: 3;
      }
      .node-group.search-highlight .node-circle,
      .node-group.search-highlight rect,
      .node-group.search-highlight polygon {
      stroke: #10b981;
      stroke-width: 3;
      filter: drop-shadow(0 0 8px #10b981);
      }
      .badge-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      }
      .badge {
      border: 1px solid var(--edge-main);
      padding: 5px 12px;
      border-radius: 22px;
      font-size: clamp(12px, 1.4vw, 18px);
      }
      .badge.wg {
      color: var(--accent);
      border-color: var(--accent);
      }
      .section-label {
      margin-top: 8px;
      font-size: clamp(14px, 1.6vw, 20px);
      text-transform: uppercase;
      color: var(--text-soft);
      }
      .list li {
      margin: 6px 0;
      font-size: clamp(14px, 1.6vw, 20px);
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      }
      .list li:hover {
      color: var(--accent);
      }
      .delete-note {
      color: var(--danger);
      font-size: 18px;
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.2s;
      flex-shrink: 0;
      }
      .list li:hover .delete-note {
      opacity: 1;
      }
      .editing {
      outline: 2px solid var(--accent);
      background: #0d141f;
      padding: 4px;
      border-radius: 6px;
      user-select: text;
      -webkit-user-select: text;
      }
      .mobile-menu-btn {
      display: none;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      color: var(--text-main);
      font-size: 22px;
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      }
      #topbar-menu {
      gap: 8px;
      }
      @media (min-width: 721px) {
      #topbar-menu {
      display: flex !important;
      }
      }
      @media (max-width: 720px) {
      #topbar-menu {
      display: none;
      }
      #topbar-menu.open {
      display: flex;
      }
      }
      @media (max-width: 720px) {
      .mobile-menu-btn {
      display: block;
      }
      #topbar-menu {
      position: absolute;
      top: var(--topbar-height);
      right: 0;
      background: var(--panel-alt);
      border-left: 1px solid var(--topbar-border);
      border-bottom: 1px solid var(--topbar-border);
      padding: 12px;
      display: none;
      flex-direction: column;
      width: 180px;
      z-index: 999;
      }
      #topbar-menu.open {
      display: flex;
      }
      header {
      position: relative;
      z-index: 9999;
      }
      }
      @media (max-width: 720px) {
      .draw-toolbar {
      position: absolute;
      top: auto;
      bottom: auto;
      left: 10px !important;
      right: auto !important;
      width: auto;
      gap: 6px;
      padding: 8px;
      }	  
      .topology-toolbar {
      position: absolute;
      top: auto;
      bottom: auto;
      width: auto;
      gap: 6px;
      padding: 8px;
      }
      .draw-toolbar {
      top: 10px !important;
      }
      .topology-toolbar {
      top: calc(10px + var(--draw-toolbar-height, 50px)) !important;
      }
      .canvas-hint {
      top: calc(10px + 120px);
      }
      }
      .icon-picker-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      z-index: 999999999;
      justify-content: center;
      align-items: center;
      }
      .icon-picker-modal.active {
      display: flex;
      }
      .icon-picker-content {
      background: var(--panel);
      border-radius: 12px;
      width: 90%;
      max-width: 800px;
      max-height: 80vh;
      display: flex;
      flex-direction: column;
      border: 1px solid var(--edge-main);
      }
      .icon-picker-header {
      padding: 20px;
      border-bottom: 1px solid var(--edge-main);
      }
      .icon-picker-header h3 {
      margin: 0 0 15px 0;
      color: var(--text-main);
      }
      .icon-picker-tabs {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
      flex-wrap: wrap;
      }
      .icon-picker-tab {
      padding: 8px 16px;
      background: var(--panel-alt);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      color: var(--text-soft);
      font-size: 14px;
      transition: all 0.2s;
      }
      .icon-picker-tab:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .icon-picker-tab.active {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
      }
      .icon-picker-search {
      width: 100%;
      padding: 10px 15px;
      background: var(--panel-alt);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      color: var(--text-main);
      font-size: 14px;
      }
      .icon-picker-search::placeholder {
      color: var(--text-soft);
      }
      .icon-picker-body {
      padding: 20px;
      overflow-y: auto;
      flex: 1;
      }
      .icon-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
      gap: 10px;
      }
      .icon-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 15px 10px;
      background: var(--panel-alt);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .icon-item:hover {
      background: var(--accent);
      border-color: var(--accent);
      transform: scale(1.05);
      }
      .icon-item svg {
      width: 32px;
      height: 32px;
      fill: var(--text-main);
      }
      .icon-item:hover svg {
      fill: var(--bg);
      }
      .icon-item-name {
      margin-top: 8px;
      font-size: 10px;
      color: var(--text-soft);
      text-align: center;
      word-break: break-word;
      }
      .icon-item:hover .icon-item-name {
      color: var(--bg);
      }
      .icon-picker-loading {
      text-align: center;
      padding: 40px;
      color: var(--text-soft);
      }
      .icon-picker-footer {
      padding: 15px 20px;
      border-top: 1px solid var(--edge-main);
      display: flex;
      justify-content: flex-end;
      }
      .icon-btn-cancel {
      padding: 8px 20px;
      background: var(--panel-alt);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      }
      .icon-btn-cancel:hover {
      background: var(--edge-main);
      }
      .icon-badge {
      display: inline-flex;
      align-items: center;
      gap: 5px;
      padding: 4px 8px;
      background: var(--panel-alt);
      border-radius: 4px;
      font-size: 12px;
      margin: 2px;
      }
      .icon-badge svg {
      width: 16px;
      height: 16px;
      fill: currentColor;
      }
      .pick-icon-btn {
      padding: 6px 12px;
      background: var(--accent);
      color: var(--bg);
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      margin-top: 8px;
      width: 100%;
      }
      .pick-icon-btn:hover {
      opacity: 0.9;
      }
      @media (max-width: 768px) {
      .icon-picker-content {
      width: 95%;
      max-height: 90vh;	
      }
      .modal-content {
      background: var(--panel-alt);
      }
      #search-input {
      width: 100%;
      }
      }
    </style>
  </head>
  <body style="background: radial-gradient(circle at center top, rgb(30, 37, 50) 0px, rgb(5, 6, 8) 70%);" class="">
    <div class="icon-picker-modal" id="icon-picker-modal">
      <div class="icon-picker-content">
        <div class="icon-picker-header">
          <h3>Select Icon</h3>
          <div class="icon-picker-tabs">
            <button class="icon-picker-tab" data-library="mdi">MDI</button>
            <button class="icon-picker-tab" data-library="simple">Simple Icons</button>
            <button class="icon-picker-tab active" data-library="selfhst">Selfh.st</button>
          </div>
          <input type="text" class="icon-picker-search" id="icon-search" placeholder="Search icons..." style="display: none;">
        </div>
        <div class="icon-picker-body" id="icon-picker-body"><div style="padding: 20px;"><p style="color: var(--text-soft); margin-bottom: 15px; text-align: center;">Search MDI (Material Design Icons):</p><input type="text" id="icon-search-field" placeholder="Search icons..." style="width: 100%; padding: 12px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main); font-size: 16px; margin-bottom: 20px;"><div id="icon-grid-container" style="max-height: 400px; overflow-y: auto;"><div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 15px; padding: 10px;"><div style="display: flex; flex-direction: column; align-items: center; gap: 8px; padding: 15px; background: var(--panel-alt); border-color: var(--edge-main); border-top-style: ; border-top-width: ; border-right-style: ; border-right-width: ; border-bottom-style: ; border-bottom-width: ; border-left-style: ; border-left-width: ; border-image-source: ; border-image-slice: ; border-image-width: ; border-image-outset: ; border-image-repeat: ; border-radius: 6px; cursor: pointer; transition: 0.2s;"><div style="width: 48px; height: 48px; display: flex; align-items: center; justify-content: center;"><svg xmlns="http://www.w3.org/2000/svg" id="mdi-docker" viewBox="0 0 24 24" width="48" height="48" style="fill: var(--text-main);"><path d="M21.81 10.25C21.75 10.21 21.25 9.82 20.17 9.82C19.89 9.82 19.61 9.85 19.33 9.9C19.12 8.5 17.95 7.79 17.9 7.76L17.61 7.59L17.43 7.86C17.19 8.22 17 8.63 16.92 9.05C16.72 9.85 16.84 10.61 17.25 11.26C16.76 11.54 15.96 11.61 15.79 11.61H2.62C2.28 11.61 2 11.89 2 12.24C2 13.39 2.18 14.54 2.58 15.62C3.03 16.81 3.71 17.69 4.58 18.23C5.56 18.83 7.17 19.17 9 19.17C9.79 19.17 10.61 19.1 11.42 18.95C12.54 18.75 13.62 18.36 14.61 17.79C15.43 17.32 16.16 16.72 16.78 16C17.83 14.83 18.45 13.5 18.9 12.35H19.09C20.23 12.35 20.94 11.89 21.33 11.5C21.59 11.26 21.78 10.97 21.92 10.63L22 10.39L21.81 10.25M3.85 11.24H5.61C5.69 11.24 5.77 11.17 5.77 11.08V9.5C5.77 9.42 5.7 9.34 5.61 9.34H3.85C3.76 9.34 3.69 9.41 3.69 9.5V11.08C3.7 11.17 3.76 11.24 3.85 11.24M6.28 11.24H8.04C8.12 11.24 8.2 11.17 8.2 11.08V9.5C8.2 9.42 8.13 9.34 8.04 9.34H6.28C6.19 9.34 6.12 9.41 6.12 9.5V11.08C6.13 11.17 6.19 11.24 6.28 11.24M8.75 11.24H10.5C10.6 11.24 10.67 11.17 10.67 11.08V9.5C10.67 9.42 10.61 9.34 10.5 9.34H8.75C8.67 9.34 8.6 9.41 8.6 9.5V11.08C8.6 11.17 8.66 11.24 8.75 11.24M11.19 11.24H12.96C13.04 11.24 13.11 11.17 13.11 11.08V9.5C13.11 9.42 13.05 9.34 12.96 9.34H11.19C11.11 9.34 11.04 9.41 11.04 9.5V11.08C11.04 11.17 11.11 11.24 11.19 11.24M6.28 9H8.04C8.12 9 8.2 8.91 8.2 8.82V7.25C8.2 7.16 8.13 7.09 8.04 7.09H6.28C6.19 7.09 6.12 7.15 6.12 7.25V8.82C6.13 8.91 6.19 9 6.28 9M8.75 9H10.5C10.6 9 10.67 8.91 10.67 8.82V7.25C10.67 7.16 10.61 7.09 10.5 7.09H8.75C8.67 7.09 8.6 7.15 8.6 7.25V8.82C8.6 8.91 8.66 9 8.75 9M11.19 9H12.96C13.04 9 13.11 8.91 13.11 8.82V7.25C13.11 7.16 13.04 7.09 12.96 7.09H11.19C11.11 7.09 11.04 7.15 11.04 7.25V8.82C11.04 8.91 11.11 9 11.19 9M11.19 6.72H12.96C13.04 6.72 13.11 6.65 13.11 6.56V5C13.11 4.9 13.04 4.83 12.96 4.83H11.19C11.11 4.83 11.04 4.89 11.04 5V6.56C11.04 6.64 11.11 6.72 11.19 6.72M13.65 11.24H15.41C15.5 11.24 15.57 11.17 15.57 11.08V9.5C15.57 9.42 15.5 9.34 15.41 9.34H13.65C13.57 9.34 13.5 9.41 13.5 9.5V11.08C13.5 11.17 13.57 11.24 13.65 11.24"></path></svg></div><div style="font-size: 11px; color: var(--text-soft); text-align: center; word-break: break-word; max-width: 100%;">docker</div></div></div></div></div></div>
        <div class="icon-picker-footer">
          <button class="icon-btn-cancel" id="icon-picker-cancel">Cancel</button>
        </div>
      </div>
    </div>
    <div class="modal" id="edit-modal">
      <div class="modal-content">
        <h3 id="modal-title">Edit Name</h3>
        <input type="text" id="modal-input">
        <div class="modal-buttons">
          <button class="btn-cancel" id="modal-cancel">Cancel</button>
          <button class="btn-save" id="modal-save">Save</button>
        </div>
      </div>
    </div>
    <div class="modal confirm-modal" id="confirm-modal">
      <div class="modal-content">
        <h3>Confirm</h3>
        <p id="confirm-message"> Are you sure you want to delete this line? </p>
        <div class="modal-buttons">
          <button class="btn-cancel" id="confirm-cancel">Cancel</button>
          <button class="btn-delete" id="confirm-delete">Delete</button>
        </div>
      </div>
    </div>
    <div class="modal" id="save-info-modal">
      <div class="modal-content">
        <h3>Why do I need to save?</h3>
        <p> Browsers are not allowed to overwrite local files automatically. When you click <strong>Save File</strong>, this page generates a new updated HTML file that contains all of your changes. Replace your old file with the new one to keep your edits. </p>
        <p style="
          margin-top: 12px;
          padding-top: 12px;
          border-top: 1px solid var(--edge-main);
          ">
          <strong>Encryption:</strong> Check the "Encrypt" box before saving to password protect your data. You'll need the password to open the file later. No recovery possible!!
        </p>
        <div class="modal-buttons">
          <button class="btn-cancel" id="save-info-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="settings-modal">
      <div class="modal-content" style="max-width: 400px">
        <h3>Page Settings</h3>
        <details class="style-section" open="">
          <summary>Background</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Solid Color</label>
              <input type="color" id="page-bg-color" value="#050608">
            </div>
            <p style="
              margin-top: 4px;
              font-size: 12px;
              color: var(--text-soft);
              "> Change to apply a flat background color. </p>
          </div>
        </details>
        <details class="style-section" open="">
          <summary>Top Bar</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="topbar-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="topbar-border-color" value="#1f2533">
            </div>
          </div>
        </details>
        <details class="style-section" open="">
          <summary>Theme Colors</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Panel</label>
              <input type="color" id="panel-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Panel Alt</label>
              <input type="color" id="panel-alt-color" value="#10141b">
            </div>
            <div class="style-row">
              <label>Accent</label>
              <input type="color" id="accent-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Danger</label>
              <input type="color" id="danger-color" value="#f56565">
            </div>
            <div class="style-row">
              <label>Text Main</label>
              <input type="color" id="text-main-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Text Soft</label>
              <input type="color" id="text-soft-color" value="#94a3b8">
            </div>
          </div>
        </details>
        <details class="style-section" open="">
          <summary>Auto Status Checking</summary>
          <div class="style-content">
            <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 16px; cursor: pointer;">
            <input type="checkbox" id="auto-ping-enabled" style="cursor: pointer;">
            <span style="font-size: 14px; font-weight: 600;">Enable automatic status checking</span>
            </label>
            <div id="auto-ping-settings" style="display: none; padding-left: 20px; border-left: 2px solid var(--edge-main);">
              <div class="style-row" style="margin-bottom: 12px;">
                <label>Check Interval (seconds):</label>
                <input type="number" id="auto-ping-interval" min="5" max="3600" value="30" style="width: 80px; padding: 6px; background: var(--panel); border: 1px solid var(--edge-main); border-radius: 4px; color: var(--text-main);">
              </div>
              <div style="padding: 10px; background: var(--panel); border-radius: 6px; border: 1px solid var(--edge-main); font-size: 12px; color: var(--text-soft);">
                <div style="margin-bottom: 4px;"><span id="auto-ping-next-check">Next check in: 23s</span></div>
                <div><span id="auto-ping-last-run">Last run: 1:42:52 PM</span></div>
              </div>
            </div>
            <p style="margin-top: 12px; font-size: 12px; color: var(--text-soft); font-style: italic;">
              Automatically checks all ping enabled nodes at the specified interval. I recommend 30 to 60 seconds for local networks.
            </p>
          </div>
        </details>
        <details class="style-section" open="">
          <summary>Import / Export Data</summary>
          <div class="style-content">
            <p style="
              margin-bottom: 12px;
              font-size: 13px;
              color: var(--text-soft);
              "> Export / Import your data to upgrade/downgrade versions of The One File. </p>
            <button id="export-data-btn" style="
              width: 100%;
              margin-bottom: 10px;
              padding: 10px;
              background: var(--accent);
              color: var(--bg);
              border: none;
              border-radius: 6px;
              cursor: pointer;
              font-size: 14px;
              font-weight: 600;
              "> Export Data (JSON) </button>
            <button id="import-data-btn" style="
              width: 100%;
              padding: 10px;
              background: var(--panel);
              color: var(--text-main);
              border: 1px solid var(--edge-main);
              border-radius: 6px;
              cursor: pointer;
              font-size: 14px;
              font-weight: 600;
              "> Import Data (JSON) </button>
            <input type="file" id="import-data-file" accept=".json" style="display: none">
          </div>
        </details>
        <div class="modal-buttons">
          <button class="btn-cancel" id="settings-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="add-node-modal">
      <div class="modal-content">
        <h3>Add New Node</h3>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Basic Information</div>
          <label style="
            display: block;
            margin-bottom: 4px;
            color: var(--text-soft);
            font-size: 13px;
            ">Name</label>
          <input type="text" id="new-node-name" placeholder="e.g. web server, jellyfin">
          <label style="
            display: block;
            margin-bottom: 4px;
            margin-top: 12px;
            color: var(--text-soft);
            font-size: 13px;
            ">IP / Subtitle</label>
          <input type="text" id="new-node-ip" placeholder="e.g. 192.168.1.100">
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Tags</div>
          <label style="
            display: block;
            margin-bottom: 4px;
            color: var(--text-soft);
            font-size: 13px;
            ">Text Tags (comma separated)</label>
          <input type="text" id="new-node-tags" placeholder="e.g. Docker, nginx, WG: vpn">
          <button class="pick-icon-btn" id="pick-new-node-tag-icon-btn" style="margin-top: 10px;">Add Icon Tag</button>
          <div id="new-node-icon-tags" style="margin-top: 10px; display: none;">
            <label style="display: block; margin-bottom: 8px; color: var(--text-soft); font-size: 13px;">Icon Tags:</label>
            <div id="new-node-icon-tags-list" style="display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 10px;"></div>
          </div>
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Node Appearance</div>
          <label style="
            display: block;
            margin-bottom: 4px;
            color: var(--text-soft);
            font-size: 13px;
            ">Basic Shapes</label>
          <select id="new-node-shape">
            <optgroup label="Basic Shapes">
              <option value="circle">Circle</option>
              <option value="square">Square</option>
              <option value="rectangle">Rectangle</option>
              <option value="triangle">Triangle</option>
              <option value="hexagon">Hexagon</option>
              <option value="diamond">Diamond</option>
              <option value="star">Star</option>
              <option value="stop-sign">Stop Sign</option>
            </optgroup>
            <optgroup label="Network Equipment">
              <option value="server">Server</option>
              <option value="pc">PC / Desktop</option>
              <option value="laptop">Laptop</option>
              <option value="phone">Phone / Mobile</option>
              <option value="router">Router</option>
              <option value="switch">Switch</option>
              <option value="firewall">Firewall</option>
              <option value="cloud">Cloud</option>
              <option value="database">Database</option>
              <option value="printer">Printer</option>
            </optgroup>
          </select>
          <button class="pick-icon-btn" id="pick-node-icon-btn" style="margin-top: 10px;"> Or search web icons</button>
          <div id="selected-node-icon" style="margin-top: 10px; display: none;">
            <label style="display: block; margin-bottom: 8px; color: var(--text-soft); font-size: 13px;">Selected Icon:</label>
            <div class="icon-badge" id="selected-node-icon-preview">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24">
                <image href="https://cdn.jsdelivr.net/gh/selfhst/icons@master/png/docker.png" width="24" height="24"></image>
              </svg>
              <span>docker</span>
            </div>
          </div>
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Ping / Status Monitoring</div>
          <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px; cursor: pointer;">
          <input type="checkbox" id="new-node-pingable" style="cursor: pointer;">
          <span style="color: var(--text-soft); font-size: 13px;">Enable ping/status check for this node</span>
          </label>
          <div id="new-node-ping-options" style="display: block; padding-left: 24px; border-left: 2px solid var(--edge-main);">
            <label style="display: block; margin-bottom: 4px; color: var(--text-soft); font-size: 13px;">Protocol</label>
            <select id="new-node-ping-protocol" style="margin-bottom: 12px;">
              <option value="http">HTTP (port 80) uses IP field</option>
              <option value="https">HTTPS (port 443) uses IP field</option>
              <option value="custom">Custom URL</option>
            </select>
            <div id="new-node-custom-url-container" style="display: none;">
              <label style="display: block; margin-bottom: 4px; color: var(--text-soft); font-size: 13px;">Custom URL</label>
              <input type="text" id="new-node-custom-url" placeholder="e.g. http://192.168.1.1:8080">
            </div>
            <label style="display: block; margin-bottom: 4px; margin-top: 8px; color: var(--text-soft); font-size: 13px;">
            Timeout (ms)
            </label>
            <input type="number" id="new-node-ping-timeout" value="3000" min="1000" max="10000" step="500">
          </div>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="add-node-cancel">Cancel</button>
          <button class="btn-save" id="add-node-save">Add Node</button>
        </div>
      </div>
    </div>
    <div class="modal" id="add-rack-modal">
      <div class="modal-content">
        <h3>Add New Rack</h3>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Basic Information</div>
          <label style="
            display: block;
            margin-bottom: 4px;
            color: var(--text-soft);
            font-size: 13px;
            ">Rack Name</label>
          <input type="text" id="new-rack-name" placeholder="e.g. Rack-A, DC1-R01, Production-01">
          <label style="
            display: block;
            margin-bottom: 4px;
            margin-top: 12px;
            color: var(--text-soft);
            font-size: 13px;
            ">IP / Network Range (optional)</label>
          <input type="text" id="new-rack-ip" placeholder="e.g. 192.168.1.0/24">
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Tags</div>
          <label style="
            display: block;
            margin-bottom: 4px;
            color: var(--text-soft);
            font-size: 13px;
            ">Text Tags (comma separated)</label>
          <input type="text" id="new-rack-tags" placeholder="e.g. Production, Data Center 1, Row A">
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Rack Appearance</div>
          <label style="
            display: block;
            margin-bottom: 4px;
            color: var(--text-soft);
            font-size: 13px;
            ">Icon / Shape</label>
          <select id="new-rack-shape">
            <optgroup label="Basic Shapes">
              <option value="circle">Circle</option>
              <option value="square">Square</option>
              <option value="rectangle">Rectangle</option>
              <option value="triangle">Triangle</option>
              <option value="hexagon">Hexagon</option>
              <option value="diamond">Diamond</option>
              <option value="star">Star</option>
              <option value="stop-sign">Stop Sign</option>
            </optgroup>
            <optgroup label="Network Equipment">
              <option value="server" selected="">Server</option>
              <option value="pc">PC / Desktop</option>
              <option value="laptop">Laptop</option>
              <option value="phone">Phone / Mobile</option>
              <option value="router">Router</option>
              <option value="switch">Switch</option>
              <option value="firewall">Firewall</option>
              <option value="cloud">Cloud</option>
              <option value="database">Database</option>
              <option value="printer">Printer</option>
            </optgroup>
          </select>
          <button class="pick-icon-btn" id="pick-rack-icon-btn" style="margin-top: 10px;">Or Search Web Icons</button>
          <div id="selected-rack-icon" style="margin-top: 10px; display: none;">
            <label style="display: block; margin-bottom: 8px; color: var(--text-soft); font-size: 13px;">Selected Icon:</label>
            <div class="icon-badge" id="selected-rack-icon-preview"><svg xmlns="http://www.w3.org/2000/svg" id="mdi-airplane" viewBox="0 0 24 24"><path d="M20.56 3.91C21.15 4.5 21.15 5.45 20.56 6.03L16.67 9.92L18.79 19.11L17.38 20.53L13.5 13.1L9.6 17L9.96 19.47L8.89 20.53L7.13 17.35L3.94 15.58L5 14.5L7.5 14.87L11.37 11L3.94 7.09L5.36 5.68L14.55 7.8L18.44 3.91C19 3.33 20 3.33 20.56 3.91Z"></path></svg><span>airplane</span></div>
          </div>
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Rack Configuration</div>
          <label style="
            display: block;
            margin-bottom: 4px;
            color: var(--text-soft);
            font-size: 13px;
            ">Rack Capacity</label>
          <select id="new-rack-capacity">
            <option value="42" selected="">42U (Standard Full Rack)</option>
            <option value="48">48U (Large Rack)</option>
            <option value="24">24U (Half Rack)</option>
            <option value="12">12U (Small/Wall Mount)</option>
            <option value="6">6U (Mini Rack)</option>
          </select>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="add-rack-cancel">Cancel</button>
          <button class="btn-save" id="add-rack-save">Add Rack</button>
        </div>
      </div>
    </div>
    <div class="modal confirm-modal" id="clear-all-modal">
      <div class="modal-content">
        <h3>Clear All Nodes</h3>
        <p> This will remove ALL nodes and connections. This cannot be undone until you reload without saving. Are you sure? </p>
        <div class="modal-buttons">
          <button class="btn-cancel" id="clear-all-cancel">Cancel</button>
          <button class="btn-delete" id="clear-all-confirm"> Clear Everything </button>
        </div>
      </div>
    </div>
    <div class="modal" id="layer-modal">
      <div class="modal-content" style="max-width: 400px;">
        <h3>Layer Visibility</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Toggle which layers are visible on the canvas</p>
        <div style="display: flex; flex-direction: column; gap: 10px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
            <input type="checkbox" id="layer-physical" checked="" style="cursor: pointer; width: 18px; height: 18px;">
            <span style="flex: 1; font-weight: 500;">Physical Layer</span>
            <span style="font-size: 12px; color: var(--text-soft);">Hardware &amp; cabling</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
            <input type="checkbox" id="layer-logical" checked="" style="cursor: pointer; width: 18px; height: 18px;">
            <span style="flex: 1; font-weight: 500;">Logical Layer</span>
            <span style="font-size: 12px; color: var(--text-soft);">VLANs &amp; routing</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
            <input type="checkbox" id="layer-security" checked="" style="cursor: pointer; width: 18px; height: 18px;">
            <span style="flex: 1; font-weight: 500;">Security Layer</span>
            <span style="font-size: 12px; color: var(--text-soft);">Firewalls &amp; zones</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
            <input type="checkbox" id="layer-application" checked="" style="cursor: pointer; width: 18px; height: 18px;">
            <span style="flex: 1; font-weight: 500;">Application Layer</span>
            <span style="font-size: 12px; color: var(--text-soft);">Services &amp; apps</span>
          </label>
        </div>
        <div style="margin-top: 15px; display: flex; gap: 8px;">
          <button class="btn-cancel" style="flex: 1;" onclick="document.querySelectorAll('#layer-modal input[type=checkbox]').forEach(cb =&gt; cb.checked = false); applyLayerFilter();">Hide All</button>
          <button class="btn-save" style="flex: 1;" onclick="document.querySelectorAll('#layer-modal input[type=checkbox]').forEach(cb =&gt; cb.checked = true); applyLayerFilter();">Show All</button>
        </div>
        <div class="modal-buttons" style="margin-top: 10px;">
          <button class="btn-cancel" id="layer-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div id="context-menu" style="display: none !important;">
    </div>
    <header>
      <div class="title-block">
        <h1 id="page-title" class="editable-page-title">Corporate Network</h1>
        <div class="save-row">
          <button id="save-file-btn" class="save-btn" type="button"> Save File </button>
          <label style="
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 12px;
            color: var(--text-soft);
            cursor: pointer;
            user-select: none;
            ">
          <input type="checkbox" id="encrypt-toggle" style="cursor: pointer">
          <span title="Encrypt data with password">Encrypt</span>
          </label>
          <span id="save-help-btn" class="help-icon" title="Why save?">?</span>
        </div>
      </div>
      <div id="topbar-menu">
        <button id="back-to-topology-btn" title="Exit rack view and return to topology" style="padding: 6px 12px; background: var(--accent); color: var(--bg); border: none; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600; display: none;">â† Back to Topology</button>
        <button id="add-node-btn" class="save-btn" title="Add new node" style="background: var(--accent)"> + Node </button>
        <button id="add-rack-btn" class="save-btn" title="Add new rack" style="background: var(--accent); margin-left: 8px;"> + Rack </button>
        <button id="undo-btn" title="Undo (Ctrl+Z)" style="padding: 6px 12px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600; opacity: 1;">â†¶ Undo</button>
        <button id="redo-btn" title="Redo (Ctrl+Y)" disabled="" style="
          padding: 6px 12px;
          background: var(--panel);
          color: var(--text-main);
          border: 1px solid var(--edge-main);
          border-radius: 6px;
          cursor: pointer;
          font-size: 14px;
          font-weight: 600;
          opacity: 0.5;
          ">â†· Redo</button>
        <input id="search-input" type="text" placeholder="Search nodes..." style="
          padding: 6px 12px;
          background: var(--panel);
          color: var(--text-main);
          border: 1px solid var(--edge-main);
          border-radius: 6px;
          font-size: 14px;
          ">
        <button id="check-all-ping-btn" title="Check status of all enabled nodes" style="
          padding: 6px 12px;
          background: var(--panel);
          color: var(--text-main);
          border: 1px solid var(--edge-main);
          border-radius: 6px;
          cursor: pointer;
          font-size: 14px;
          font-weight: 600;
          "> Check Pings</button>
        <button id="layers-btn" title="Toggle layer visibility" style="
          padding: 6px 12px;
          background: var(--panel);
          color: var(--text-main);
          border: 1px solid var(--edge-main);
          border-radius: 6px;
          cursor: pointer;
          font-size: 14px;
          font-weight: 600;
          ">ðŸ“ Layers</button>
        <button onclick="screenshotCanvas()" title="Export canvas as PNG image" style="
          padding: 6px 12px;
          background: var(--panel);
          color: var(--text-main);
          border: 1px solid var(--edge-main);
          border-radius: 6px;
          cursor: pointer;
          font-size: 14px;
          font-weight: 600;
          "> PNG </button>
        <button onclick="exportCanvasSVG()" title="Export canvas as SVG vector" style="
          padding: 6px 12px;
          background: var(--panel);
          color: var(--text-main);
          border: 1px solid var(--edge-main);
          border-radius: 6px;
          cursor: pointer;
          font-size: 14px;
          font-weight: 600;
          "> SVG </button>
        <button id="settings-btn" title="Page settings">âš™ï¸</button>
        <button id="clear-all-btn" title="Clear all nodes" style="
          padding: 6px 12px;
          background: var(--danger);
          color: #fff;
          border: none;
          border-radius: 6px;
          cursor: pointer;
          font-size: 14px;
          font-weight: 600;
          "> Clear All </button>
      </div>
      <button id="mobile-menu-toggle" class="mobile-menu-btn">â˜°</button>
      <div class="header-resizer" id="header-resizer">
        <svg class="resizer-icon" width="40" height="6" viewBox="0 0 40 6" xmlns="http://www.w3.org/2000/svg">
          <circle cx="14" cy="3" r="2"></circle>
          <circle cx="20" cy="3" r="2"></circle>
          <circle cx="26" cy="3" r="2"></circle>
        </svg>
      </div>
    </header>
    <main>
      <section class="topology-panel">
        <div class="draw-toolbar" id="draw-toolbar" style="display: grid !important;">
          <button type="button" class="toolbar-close-btn" id="draw-toolbar-close-btn" title="Hide draw toolbar">âœ•</button>
          <button id="draw-toggle" title="Draw custom line">âœï¸</button>
          <button id="rect-toggle" title="Draw rectangle">â–­</button>
          <button id="text-toggle" title="Add text" style="">T</button>
          <select id="rect-style" title="Rectangle style">
            <option value="filled">Filled</option>
            <option value="outlined">Outlined</option>
          </select>
          <input type="color" id="draw-color" value="#f97316" title="Line color">
          <select id="draw-style" title="Line style">
            <option value="solid">Solid</option>
            <option value="dashed">Dashed</option>
            <option value="dotted">Dotted</option>
          </select>
          <select id="draw-arrow" title="Arrow direction">
            <option value="none">No arrows</option>
            <option value="forward">â†’ Right</option>
            <option value="backward">â† Left</option>
            <option value="both">â†” Both</option>
          </select>
          <button id="draw-undo" style="display: none;" title="Undo last point"> Undo </button>
        </div>
        <div class="topology-toolbar" id="topology-toolbar" style="display: grid !important;">
          <button type="button" class="toolbar-close-btn" id="topology-toolbar-close-btn" title="Hide add line toolbar">âœ•</button>
          <label for="add-line-select">Add line to:</label>
          <select id="add-line-select"><option value="edge-firewall">Edge Firewall</option><option value="core-switch-1">Core Switch 1</option><option value="core-switch-2">Core Switch 2</option><option value="dmz-firewall">DMZ Firewall</option><option value="web-server">Web Server</option><option value="mail-server">Mail Server</option><option value="dist-switch-1">Distribution SW 1</option><option value="dist-switch-2">Distribution SW 2</option><option value="access-switch-1">Access SW 1-1</option><option value="access-switch-2">Access SW 1-2</option><option value="access-switch-3">Access SW 2-1</option><option value="domain-controller">Domain Controller</option><option value="file-server">File Server</option><option value="db-server">Database Server</option><option value="backup-server">Backup Server</option><option value="wifi-controller">WiFi Controller</option><option value="vpn-gateway">VPN Gateway</option><option value="im-a-rack">IM A RACK</option><option value="node-in-a-rack">Node in a rack</option></select>
          <input type="color" id="add-line-color" value="#475569" title="Line color" style="
            width: 30px;
            height: 24px;
            border: 1px solid var(--edge-main);
            border-radius: 4px;
            cursor: pointer;
            background: transparent;
            padding: 0;
            ">
          <select id="add-line-direction" title="Line direction">
            <option value="none">No arrows</option>
            <option value="forward">â†’ Forward</option>
            <option value="backward">â† Backward</option>
            <option value="both">â†” Both</option>
          </select>
          <button id="add-line-btn">Add</button>
        </div>
        <div class="topology-toolbar bulk-toolbar-desktop" id="bulk-toolbar" style="display: none">
          <button type="button" class="toolbar-close-btn" id="bulk-toolbar-close" title="Clear selection">âœ•</button>
          <label style="font-weight: 600; color: var(--accent)">Selected: <span id="bulk-count">0</span></label>
          <button id="bulk-align-left" title="Align left">â¬… Left</button>
          <button id="bulk-align-right" title="Align right">âž¡ Right</button>
          <button id="bulk-align-top" title="Align top">â¬† Top</button>
          <button id="bulk-align-bottom" title="Align bottom">â¬‡ Bottom</button>
          <button id="bulk-distribute-h" title="Distribute horizontally">â†” Distribute H</button>
          <button id="bulk-distribute-v" title="Distribute vertically">â†• Distribute V</button>
          <button id="bulk-clone" title="Clone selected">ðŸ“‹ Clone</button>
          <button id="bulk-delete" title="Delete selected" style="background: var(--danger); color: white;">Delete</button>
        </div>
        <div class="bulk-toolbar-mobile" id="bulk-toolbar-mobile" style="display: none">
          <button type="button" id="bulk-mobile-btn" style="
            background: var(--accent);
            color: white;
            padding: 12px 20px;
            border-radius: 25px;
            font-weight: 600;
            font-size: 16px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            ">
          <span id="bulk-count-mobile">0</span> Selected
          </button>
        </div>
        <div id="bulk-actions-modal" style="
          display: none;
          position: fixed;
          bottom: 0;
          left: 0;
          right: 0;
          background: var(--panel-alt);
          border-top-left-radius: 20px;
          border-top-right-radius: 20px;
          padding: 20px;
          padding-bottom: env(safe-area-inset-bottom, 20px);
          box-shadow: 0 -4px 20px rgba(0,0,0,0.5);
          z-index: 10000;
          max-height: calc(100vh - 80px);
          overflow-y: auto;
          ">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            <h3 style="margin: 0; color: var(--accent); font-size: 20px;">
              <span id="bulk-count-modal">0</span> Nodes Selected
            </h3>
            <button id="bulk-modal-close" style="
              background: none;
              border: none;
              font-size: 24px;
              cursor: pointer;
              color: var(--text-main);
              padding: 0;
              width: 32px;
              height: 32px;
              ">âœ•</button>
          </div>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
            <button id="bulk-align-left-mobile" class="bulk-action-btn">
            â¬…<br><span style="font-size: 12px;">Align Left</span>
            </button>
            <button id="bulk-align-right-mobile" class="bulk-action-btn">
            âž¡<br><span style="font-size: 12px;">Align Right</span>
            </button>
            <button id="bulk-align-top-mobile" class="bulk-action-btn">
            â¬†<br><span style="font-size: 12px;">Align Top</span>
            </button>
            <button id="bulk-align-bottom-mobile" class="bulk-action-btn">
            â¬‡<br><span style="font-size: 12px;">Align Bottom</span>
            </button>
            <button id="bulk-distribute-h-mobile" class="bulk-action-btn">
            â†”<br><span style="font-size: 12px;">Distribute H</span>
            </button>
            <button id="bulk-distribute-v-mobile" class="bulk-action-btn">
            â†•<br><span style="font-size: 12px;">Distribute V</span>
            </button>
            <button id="bulk-lock-mobile" class="bulk-action-btn">
            ðŸ”’<br><span style="font-size: 12px;">Lock Toggle</span>
            </button>
            <button id="bulk-group-mobile" class="bulk-action-btn">
            â­•<br><span style="font-size: 12px;">Group Toggle</span>
            </button>
            <button id="bulk-clone-mobile" class="bulk-action-btn">
            ðŸ“‹<br><span style="font-size: 12px;">Clone All</span>
            </button>
            <button id="bulk-delete-mobile" class="bulk-action-btn" style="background: var(--danger); color: white;">
            ðŸ—‘<br><span style="font-size: 12px;">Delete All</span>
            </button>
          </div>
          <button id="bulk-clear-mobile" style="
            width: 100%;
            margin-top: 16px;
            padding: 14px;
            background: var(--panel-main);
            border: 1px solid var(--edge-main);
            border-radius: 8px;
            color: var(--text-main);
            font-size: 16px;
            cursor: pointer;
            ">Clear Selection</button>
        </div>
        <div class="canvas-hint" id="canvas-hint"><ul><li>Scroll to zoom</li><li>Drag to pan</li><li>Right-click to select multiple</li><li>Your time is NOW!</li></ul></div>
        <div class="legend-container" id="edge-legend" style="display: flex;"><div class="legend-title">Line Legend</div><button type="button" class="legend-close-btn">âœ•</button><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(239, 68, 68); cursor: pointer;"></span><span class="legend-label" contenteditable="true">WAN / DMZ</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(245, 158, 11); cursor: pointer;"></span><span class="legend-label" contenteditable="true">Trunk / Uplink</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(16, 185, 129); cursor: pointer;"></span><span class="legend-label" contenteditable="true">Core / Distribution</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(59, 130, 246); cursor: pointer;"></span><span class="legend-label" contenteditable="true">Access Layer</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(139, 92, 246); cursor: pointer;"></span><span class="legend-label" contenteditable="true">Server VLAN</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(6, 182, 212); cursor: pointer;"></span><span class="legend-label" contenteditable="true">Management</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(249, 115, 22); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div></div>
        <div class="canvas-viewport" id="canvas-viewport">
          <svg id="map" viewBox="531.3333333333335 47.00000000000023 2737.333333333333 2052.9999999999995" style=""><defs><marker id="arrow-forward" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto" markerUnits="strokeWidth"><path d="M0,0 L0,6 L9,3 z" fill="context-stroke"></path></marker><marker id="arrow-backward" markerWidth="10" markerHeight="10" refX="0" refY="3" orient="auto" markerUnits="strokeWidth"><path d="M9,0 L9,6 L0,3 z" fill="context-stroke"></path></marker></defs><rect x="100" y="100" width="3800" height="2800" fill="none" stroke="rgba(71, 85, 105, 0.3)" stroke-width="2" stroke-dasharray="10 5" rx="8"></rect><path d="M 2061.6986083984375 247 Q 2030.8493041992188 373.5 2000 500" fill="none" class="edge active" data-edge-id="edge-1" data-from="internet" data-to="edge-firewall" style="stroke: rgb(239, 68, 68); stroke-width: 6;"></path><path d="M 2061.6986083984375 247 Q 2030.8493041992188 373.5 2000 500" fill="none" data-edge-id="edge-1" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2000 500 Q 1850 700 1700 900" fill="none" class="edge" data-edge-id="edge-2" data-from="edge-firewall" data-to="core-switch-1" style="stroke: rgb(245, 158, 11); stroke-width: 5;"></path><path d="M 2000 500 Q 1850 700 1700 900" fill="none" data-edge-id="edge-2" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2000 500 Q 2150 700 2300 900" fill="none" class="edge" data-edge-id="edge-3" data-from="edge-firewall" data-to="core-switch-2" style="stroke: rgb(245, 158, 11); stroke-width: 5;"></path><path d="M 2000 500 Q 2150 700 2300 900" fill="none" data-edge-id="edge-3" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 1700 900 Q 2000 900 2300 900" fill="none" class="edge" data-edge-id="edge-4" data-from="core-switch-1" data-to="core-switch-2" style="stroke: rgb(16, 185, 129); stroke-width: 6;"></path><path d="M 1700 900 Q 2000 900 2300 900" fill="none" data-edge-id="edge-4" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 1700 900 Q 2250 900 2800 900" fill="none" class="edge" data-edge-id="edge-5" data-from="core-switch-1" data-to="dmz-firewall" style="stroke: rgb(239, 68, 68); stroke-width: 4;"></path><path d="M 1700 900 Q 2250 900 2800 900" fill="none" data-edge-id="edge-5" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2800 900 Q 2800 1075 2800 1250" fill="none" class="edge" data-edge-id="edge-6" data-from="dmz-firewall" data-to="web-server" style="stroke: rgb(239, 68, 68); stroke-width: 4;"></path><path d="M 2800 900 Q 2800 1075 2800 1250" fill="none" data-edge-id="edge-6" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2800 900 Q 2800 1225 2800 1550" fill="none" class="edge" data-edge-id="edge-7" data-from="dmz-firewall" data-to="mail-server" style="stroke: rgb(239, 68, 68); stroke-width: 4;"></path><path d="M 2800 900 Q 2800 1225 2800 1550" fill="none" data-edge-id="edge-7" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 1700 900 Q 1450 1150 1200 1400" fill="none" class="edge" data-edge-id="edge-8" data-from="core-switch-1" data-to="dist-switch-1" style="stroke: rgb(16, 185, 129); stroke-width: 5;"></path><path d="M 1700 900 Q 1450 1150 1200 1400" fill="none" data-edge-id="edge-8" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2300 900 Q 1750 1150 1200 1400" fill="none" class="edge" data-edge-id="edge-9" data-from="core-switch-2" data-to="dist-switch-1" style="stroke: rgb(16, 185, 129); stroke-width: 5;"></path><path d="M 2300 900 Q 1750 1150 1200 1400" fill="none" data-edge-id="edge-9" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 1700 900 Q 2100 1150 2500 1400" fill="none" class="edge" data-edge-id="edge-10" data-from="core-switch-1" data-to="dist-switch-2" style="stroke: rgb(16, 185, 129); stroke-width: 5;"></path><path d="M 1700 900 Q 2100 1150 2500 1400" fill="none" data-edge-id="edge-10" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2300 900 Q 2400 1150 2500 1400" fill="none" class="edge" data-edge-id="edge-11" data-from="core-switch-2" data-to="dist-switch-2" style="stroke: rgb(16, 185, 129); stroke-width: 5;"></path><path d="M 2300 900 Q 2400 1150 2500 1400" fill="none" data-edge-id="edge-11" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 1200 1400 Q 1000 1650 800 1900" fill="none" class="edge" data-edge-id="edge-12" data-from="dist-switch-1" data-to="access-switch-1" style="stroke: rgb(59, 130, 246); stroke-width: 4;"></path><path d="M 1200 1400 Q 1000 1650 800 1900" fill="none" data-edge-id="edge-12" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 1200 1400 Q 1200 1650 1200 1900" fill="none" class="edge" data-edge-id="edge-13" data-from="dist-switch-1" data-to="access-switch-2" style="stroke: rgb(59, 130, 246); stroke-width: 4;"></path><path d="M 1200 1400 Q 1200 1650 1200 1900" fill="none" data-edge-id="edge-13" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2500 1400 Q 2500 1650 2500 1900" fill="none" class="edge" data-edge-id="edge-14" data-from="dist-switch-2" data-to="access-switch-3" style="stroke: rgb(59, 130, 246); stroke-width: 4;"></path><path d="M 2500 1400 Q 2500 1650 2500 1900" fill="none" data-edge-id="edge-14" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 1700 900 Q 1400 900 1100 900" fill="none" class="edge" data-edge-id="edge-15" data-from="core-switch-1" data-to="domain-controller" style="stroke: rgb(139, 92, 246); stroke-width: 4;"></path><path d="M 1700 900 Q 1400 900 1100 900" fill="none" data-edge-id="edge-15" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 1700 900 Q 1150 900 600 900" fill="none" class="edge" data-edge-id="edge-16" data-from="core-switch-1" data-to="file-server" style="stroke: rgb(139, 92, 246); stroke-width: 4;"></path><path d="M 1700 900 Q 1150 900 600 900" fill="none" data-edge-id="edge-16" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 1700 900 Q 1150 1100 600 1300" fill="none" class="edge" data-edge-id="edge-17" data-from="core-switch-1" data-to="db-server" style="stroke: rgb(139, 92, 246); stroke-width: 4;"></path><path d="M 1700 900 Q 1150 1100 600 1300" fill="none" data-edge-id="edge-17" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 1700 900 Q 1400 1100 1100 1300" fill="none" class="edge" data-edge-id="edge-18" data-from="core-switch-1" data-to="backup-server" style="stroke: rgb(139, 92, 246); stroke-width: 4;"></path><path d="M 1700 900 Q 1400 1100 1100 1300" fill="none" data-edge-id="edge-18" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 1700 900 Q 2450 1150 3200 1400" fill="none" class="edge" data-edge-id="edge-19" data-from="core-switch-1" data-to="wifi-controller" style="stroke: rgb(6, 182, 212); stroke-width: 4;"></path><path d="M 1700 900 Q 2450 1150 3200 1400" fill="none" data-edge-id="edge-19" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2000 500 Q 1721.3592529296875 496.2307434082031 1442.718505859375 492.46148681640625" fill="none" class="edge" data-edge-id="edge-20" data-from="edge-firewall" data-to="vpn-gateway" style="stroke: rgb(245, 158, 11); stroke-width: 4;"></path><path d="M 2000 500 Q 1721.3592529296875 496.2307434082031 1442.718505859375 492.46148681640625" fill="none" data-edge-id="edge-20" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><polyline class="edge" data-edge-id="custom-1764789640610" fill="none" marker-end="url(#arrow-forward)" points="1692.203125,87.20563507080078 1797.742919921875,-18.33414649963379 1870.6156005859375,62.07711410522461" style="stroke: rgb(249, 115, 22); stroke-width: 4; stroke-dasharray: none;"></polyline><polyline points="1692.203125,87.20563507080078 1797.742919921875,-18.33414649963379 1870.6156005859375,62.07711410522461" data-edge-id="custom-1764789640610" style="fill: none; stroke: transparent; stroke-width: 20; cursor: pointer;"></polyline><polyline class="edge" data-edge-id="custom-1764789700766" fill="none" marker-start="url(#arrow-backward)" marker-end="url(#arrow-forward)" points="3094.37451171875,531.9804077148438 2848.114990234375,396.2864074707031" style="stroke: rgb(249, 115, 22); stroke-width: 4; stroke-dasharray: none;"></polyline><polyline points="3094.37451171875,531.9804077148438 2848.114990234375,396.2864074707031" data-edge-id="custom-1764789700766" style="fill: none; stroke: transparent; stroke-width: 20; cursor: pointer;"></polyline><g class="node-group active" data-node-id="internet" transform="translate(2061.6986083984375,247)" style="cursor: grab;"><circle r="220.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><path d="
             M -117.60000000000001 29.400000000000002
             Q -161.70000000000002 29.400000000000002 -161.70000000000002 -14.700000000000001
             Q -161.70000000000002 -73.5 -102.89999999999999 -73.5
             Q -102.89999999999999 -132.3 -29.400000000000002 -132.3
             Q 14.700000000000001 -161.70000000000002 73.5 -117.60000000000001
             Q 147 -117.60000000000001 161.70000000000002 -44.1
             Q 191.1 -14.700000000000001 161.70000000000002 29.400000000000002
             Q 161.70000000000002 73.5 102.89999999999999 73.5
             L -73.5 73.5
             Q -132.3 73.5 -132.3 29.400000000000002
             Z
            " class="node-circle"></path><text class="node-label" x="0" y="-41.160000000000004" style="font-size: 48.51px; pointer-events: none;">Internet</text><text class="node-sub" x="0" y="58.800000000000004" style="font-size: 35.28px; pointer-events: none;">google.com</text><circle class="ping-indicator online" r="8.82" cx="-138.22334704589844" cy="-117.334"></circle></g><g class="node-group" data-node-id="edge-firewall" transform="translate(2000,500)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-55" y="-44" width="110" height="88" rx="4"></rect><line x1="-46.75" y1="-27.5" x2="46.75" y2="-27.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="-2.75" x2="46.75" y2="-2.75" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="22" x2="46.75" y2="22" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="-44" x2="-27.5" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="-44" x2="11" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="-19.25" x2="-8.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="-19.25" x2="30.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="5.5" x2="-27.5" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="5.5" x2="11" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="30.25" x2="-8.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="30.25" x2="30.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18.15px; pointer-events: none;">Edge Firewall</text><text class="node-sub" x="0" y="22" style="font-size: 13.2px; pointer-events: none;">192.168.1.1</text></g><g class="node-group" data-node-id="core-switch-1" transform="translate(1700,900)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-77" y="-22" width="154" height="44" rx="4"></rect><rect x="-66" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-48.4" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-30.799999999999997" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-13.199999999999996" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="4.400000000000006" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="22" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="39.60000000000001" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="57.2" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18.15px; pointer-events: none;">Core Switch 1</text><text class="node-sub" x="0" y="22" style="font-size: 13.2px; pointer-events: none;">10.0.0.1</text></g><g class="node-group" data-node-id="core-switch-2" transform="translate(2300,900)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-77" y="-22" width="154" height="44" rx="4"></rect><rect x="-66" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-48.4" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-30.799999999999997" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-13.199999999999996" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="4.400000000000006" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="22" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="39.60000000000001" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="57.2" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18.15px; pointer-events: none;">Core Switch 2</text><text class="node-sub" x="0" y="22" style="font-size: 13.2px; pointer-events: none;">10.0.0.2</text></g><g class="node-group" data-node-id="dmz-firewall" transform="translate(2800,900)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-55" y="-44" width="110" height="88" rx="4"></rect><line x1="-46.75" y1="-27.5" x2="46.75" y2="-27.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="-2.75" x2="46.75" y2="-2.75" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="22" x2="46.75" y2="22" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="-44" x2="-27.5" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="-44" x2="11" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="-19.25" x2="-8.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="-19.25" x2="30.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="5.5" x2="-27.5" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="5.5" x2="11" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="30.25" x2="-8.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="30.25" x2="30.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18.15px; pointer-events: none;">DMZ Firewall</text><text class="node-sub" x="0" y="22" style="font-size: 13.2px; pointer-events: none;">10.10.0.1</text></g><g class="node-group" data-node-id="web-server" transform="translate(2800,1250)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-66" y="-33" width="132" height="66" rx="4"></rect><line x1="-49.5" y1="-16.5" x2="-49.5" y2="16.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="-22" y1="-16.5" x2="-22" y2="16.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="5.5" y1="-16.5" x2="5.5" y2="16.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><circle cx="49.5" cy="0" r="5.5" style="fill: rgb(74, 222, 128);"></circle></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18.15px; pointer-events: none;">Web Server</text><text class="node-sub" x="0" y="22" style="font-size: 13.2px; pointer-events: none;">10.10.1.10</text></g><g class="node-group" data-node-id="mail-server" transform="translate(2800,1550)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-66" y="-33" width="132" height="66" rx="4"></rect><line x1="-49.5" y1="-16.5" x2="-49.5" y2="16.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="-22" y1="-16.5" x2="-22" y2="16.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="5.5" y1="-16.5" x2="5.5" y2="16.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><circle cx="49.5" cy="0" r="5.5" style="fill: rgb(74, 222, 128);"></circle></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18.15px; pointer-events: none;">Mail Server</text><text class="node-sub" x="0" y="22" style="font-size: 13.2px; pointer-events: none;">10.10.1.20</text></g><g class="node-group" data-node-id="dist-switch-1" transform="translate(1200,1400)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-77" y="-22" width="154" height="44" rx="4"></rect><rect x="-66" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-48.4" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-30.799999999999997" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-13.199999999999996" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="4.400000000000006" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="22" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="39.60000000000001" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="57.2" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18.15px; pointer-events: none;">Distribution SW 1</text><text class="node-sub" x="0" y="22" style="font-size: 13.2px; pointer-events: none;">10.1.0.1</text></g><g class="node-group" data-node-id="dist-switch-2" transform="translate(2500,1400)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-77" y="-22" width="154" height="44" rx="4"></rect><rect x="-66" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-48.4" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-30.799999999999997" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-13.199999999999996" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="4.400000000000006" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="22" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="39.60000000000001" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="57.2" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18.15px; pointer-events: none;">Distribution SW 2</text><text class="node-sub" x="0" y="22" style="font-size: 13.2px; pointer-events: none;">10.2.0.1</text></g><g class="node-group" data-node-id="access-switch-1" transform="translate(800,1900)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-77" y="-22" width="154" height="44" rx="4"></rect><rect x="-66" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-48.4" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-30.799999999999997" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-13.199999999999996" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="4.400000000000006" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="22" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="39.60000000000001" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="57.2" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18.15px; pointer-events: none;">Access SW 1-1</text><text class="node-sub" x="0" y="22" style="font-size: 13.2px; pointer-events: none;">10.1.1.1</text></g><g class="node-group" data-node-id="access-switch-2" transform="translate(1200,1900)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-77" y="-22" width="154" height="44" rx="4"></rect><rect x="-66" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-48.4" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-30.799999999999997" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-13.199999999999996" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="4.400000000000006" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="22" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="39.60000000000001" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="57.2" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18.15px; pointer-events: none;">Access SW 1-2</text><text class="node-sub" x="0" y="22" style="font-size: 13.2px; pointer-events: none;">10.1.2.1</text></g><g class="node-group" data-node-id="access-switch-3" transform="translate(2500,1900)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-77" y="-22" width="154" height="44" rx="4"></rect><rect x="-66" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-48.4" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-30.799999999999997" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-13.199999999999996" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="4.400000000000006" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="22" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="39.60000000000001" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="57.2" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18.15px; pointer-events: none;">Access SW 2-1</text><text class="node-sub" x="0" y="22" style="font-size: 13.2px; pointer-events: none;">10.2.1.1</text></g><g class="node-group" data-node-id="domain-controller" transform="translate(1100,900)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-66" y="-33" width="132" height="66" rx="4"></rect><line x1="-49.5" y1="-16.5" x2="-49.5" y2="16.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="-22" y1="-16.5" x2="-22" y2="16.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="5.5" y1="-16.5" x2="5.5" y2="16.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><circle cx="49.5" cy="0" r="5.5" style="fill: rgb(74, 222, 128);"></circle></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18.15px; pointer-events: none;">Domain Controller</text><text class="node-sub" x="0" y="22" style="font-size: 13.2px; pointer-events: none;">10.1.10.10</text></g><g class="node-group" data-node-id="file-server" transform="translate(600,900)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-66" y="-33" width="132" height="66" rx="4"></rect><line x1="-49.5" y1="-16.5" x2="-49.5" y2="16.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="-22" y1="-16.5" x2="-22" y2="16.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="5.5" y1="-16.5" x2="5.5" y2="16.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><circle cx="49.5" cy="0" r="5.5" style="fill: rgb(74, 222, 128);"></circle></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18.15px; pointer-events: none;">File Server</text><text class="node-sub" x="0" y="22" style="font-size: 13.2px; pointer-events: none;">10.1.10.20</text></g><g class="node-group" data-node-id="db-server" transform="translate(600,1300)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-38.5" y="-33" width="77" height="77"></rect><ellipse cx="0" cy="-33" rx="38.5" ry="13.75"></ellipse><ellipse cx="0" cy="44" rx="38.5" ry="13.75"></ellipse><ellipse cx="0" cy="-8.25" rx="38.5" ry="11" style="fill: none; stroke: rgb(71, 85, 105); stroke-width: 2;"></ellipse><ellipse cx="0" cy="19.25" rx="38.5" ry="11" style="fill: none; stroke: rgb(71, 85, 105); stroke-width: 2;"></ellipse></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18.15px; pointer-events: none;">Database Server</text><text class="node-sub" x="0" y="22" style="font-size: 13.2px; pointer-events: none;">10.1.10.30</text></g><g class="node-group" data-node-id="backup-server" transform="translate(1100,1300)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-66" y="-33" width="132" height="66" rx="4"></rect><line x1="-49.5" y1="-16.5" x2="-49.5" y2="16.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="-22" y1="-16.5" x2="-22" y2="16.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="5.5" y1="-16.5" x2="5.5" y2="16.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><circle cx="49.5" cy="0" r="5.5" style="fill: rgb(74, 222, 128);"></circle></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18.15px; pointer-events: none;">Backup Server</text><text class="node-sub" x="0" y="22" style="font-size: 13.2px; pointer-events: none;">10.1.10.40</text></g><g class="node-group" data-node-id="wifi-controller" transform="translate(3200,1400)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-60.50000000000001" y="-16.5" width="121.00000000000001" height="44" rx="6"></rect><rect x="-35.75" y="-49.5" width="5.5" height="33" rx="2"></rect><circle cx="-33" cy="-52.25" r="4.4"></circle><rect x="-2.75" y="-49.5" width="5.5" height="33" rx="2"></rect><circle cx="0" cy="-52.25" r="4.4"></circle><rect x="30.25" y="-49.5" width="5.5" height="33" rx="2"></rect><circle cx="33" cy="-52.25" r="4.4"></circle><circle cx="-38.5" cy="5.5" r="3.3" style="fill: rgb(74, 222, 128);"></circle><circle cx="-19.25" cy="5.5" r="3.3" style="fill: rgb(74, 222, 128);"></circle><circle cx="0" cy="5.5" r="3.3" style="fill: rgb(250, 204, 21);"></circle><circle cx="19.249999999999993" cy="5.5" r="3.3" style="fill: rgb(250, 204, 21);"></circle></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18.15px; pointer-events: none;">WiFi Controller</text><text class="node-sub" x="0" y="22" style="font-size: 13.2px; pointer-events: none;">10.0.0.100</text></g><g class="node-group" data-node-id="vpn-gateway" transform="translate(1442.718505859375,492.46148681640625)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-60.50000000000001" y="-16.5" width="121.00000000000001" height="44" rx="6"></rect><rect x="-35.75" y="-49.5" width="5.5" height="33" rx="2"></rect><circle cx="-33" cy="-52.25" r="4.4"></circle><rect x="-2.75" y="-49.5" width="5.5" height="33" rx="2"></rect><circle cx="0" cy="-52.25" r="4.4"></circle><rect x="30.25" y="-49.5" width="5.5" height="33" rx="2"></rect><circle cx="33" cy="-52.25" r="4.4"></circle><circle cx="-38.5" cy="5.5" r="3.3" style="fill: rgb(74, 222, 128);"></circle><circle cx="-19.25" cy="5.5" r="3.3" style="fill: rgb(74, 222, 128);"></circle><circle cx="0" cy="5.5" r="3.3" style="fill: rgb(250, 204, 21);"></circle><circle cx="19.249999999999993" cy="5.5" r="3.3" style="fill: rgb(250, 204, 21);"></circle></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18.15px; pointer-events: none;">VPN Gateway</text><text class="node-sub" x="0" y="22" style="font-size: 13.2px; pointer-events: none;">10.0.0.50</text></g><g class="node-group" data-node-id="im-a-rack" transform="translate(2626.9840737177465,397.5428295158845)" style="cursor: grab;"><circle r="300" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" id="mdi-airplane" viewBox="0 0 24 24" width="240" height="240" x="-120" y="-120" style="fill: rgb(219, 0, 0);"><path d="M20.56 3.91C21.15 4.5 21.15 5.45 20.56 6.03L16.67 9.92L18.79 19.11L17.38 20.53L13.5 13.1L9.6 17L9.96 19.47L8.89 20.53L7.13 17.35L3.94 15.58L5 14.5L7.5 14.87L11.37 11L3.94 7.09L5.36 5.68L14.55 7.8L18.44 3.91C19 3.33 20 3.33 20.56 3.91Z"></path></svg></g><text class="node-label" x="0" y="-56.00000000000001" style="font-size: 66px; pointer-events: none;">IM A RACK</text><text class="node-sub" x="0" y="80" style="font-size: 48px; pointer-events: none;"></text></g><g class="text-group" data-text-id="text-1764789614780"><text class="text-element" x="1513.7906494140625" y="145.001220703125" dominant-baseline="middle" style="fill: rgb(226, 232, 240); font-size: 48px; font-weight: normal; font-style: normal; text-anchor: start; text-decoration: none; opacity: 1; cursor: move; user-select: none;">Google is live!</text><g class="text-delete-btn" style="cursor: pointer; display: none;"><circle cx="1533.7906494140625" cy="97.001220703125" r="12" style="fill: rgb(245, 101, 101); stroke: white; stroke-width: 2;"></circle><text x="1533.7906494140625" y="97.001220703125" text-anchor="middle" dominant-baseline="middle" style="fill: white; font-size: 16px; font-weight: bold; pointer-events: none;">Ã—</text></g></g><g class="text-group" data-text-id="text-1764789667151"><text class="text-element" x="2755.139404296875" y="592.2888336181641" dominant-baseline="middle" style="fill: rgb(226, 232, 240); font-size: 43px; font-weight: normal; font-style: normal; text-anchor: start; text-decoration: none; opacity: 1; cursor: move; user-select: none;"><tspan x="2755.139404296875" dy="0">Double click me on desktop</tspan><tspan x="2755.139404296875" dy="51.6">or long press on mobile</tspan><tspan x="2755.139404296875" dy="51.6">to open the rack view</tspan></text><g class="text-delete-btn" style="cursor: pointer; display: none;"><circle cx="2775.139404296875" cy="549.2888336181641" r="12" style="fill: rgb(245, 101, 101); stroke: white; stroke-width: 2;"></circle><text x="2775.139404296875" y="549.2888336181641" text-anchor="middle" dominant-baseline="middle" style="fill: white; font-size: 16px; font-weight: bold; pointer-events: none;">Ã—</text></g></g></svg>
        </div>
        <div class="minimap-zoom-wrapper" id="minimap-zoom-wrapper" style="display: block;">
          <button type="button" class="minimap-close-btn" id="minimap-close-btn" title="Hide map &amp; zoom">âœ•</button>
          <div class="minimap-container" id="minimap-container">
            <svg id="minimap" viewBox="0 0 4000 3000">
              <line x1="2061.6986083984375" y1="247" x2="2000" y2="500" class="minimap-edge"></line><line x1="2000" y1="500" x2="1700" y2="900" class="minimap-edge"></line><line x1="2000" y1="500" x2="2300" y2="900" class="minimap-edge"></line><line x1="1700" y1="900" x2="2300" y2="900" class="minimap-edge"></line><line x1="1700" y1="900" x2="2800" y2="900" class="minimap-edge"></line><line x1="2800" y1="900" x2="2800" y2="1250" class="minimap-edge"></line><line x1="2800" y1="900" x2="2800" y2="1550" class="minimap-edge"></line><line x1="1700" y1="900" x2="1200" y2="1400" class="minimap-edge"></line><line x1="2300" y1="900" x2="1200" y2="1400" class="minimap-edge"></line><line x1="1700" y1="900" x2="2500" y2="1400" class="minimap-edge"></line><line x1="2300" y1="900" x2="2500" y2="1400" class="minimap-edge"></line><line x1="1200" y1="1400" x2="800" y2="1900" class="minimap-edge"></line><line x1="1200" y1="1400" x2="1200" y2="1900" class="minimap-edge"></line><line x1="2500" y1="1400" x2="2500" y2="1900" class="minimap-edge"></line><line x1="1700" y1="900" x2="1100" y2="900" class="minimap-edge"></line><line x1="1700" y1="900" x2="600" y2="900" class="minimap-edge"></line><line x1="1700" y1="900" x2="600" y2="1300" class="minimap-edge"></line><line x1="1700" y1="900" x2="1100" y2="1300" class="minimap-edge"></line><line x1="1700" y1="900" x2="3200" y2="1400" class="minimap-edge"></line><line x1="2000" y1="500" x2="1442.718505859375" y2="492.46148681640625" class="minimap-edge"></line><circle cx="2061.6986083984375" cy="247" r="40" class="minimap-node"></circle><circle cx="2000" cy="500" r="40" class="minimap-node"></circle><circle cx="1700" cy="900" r="40" class="minimap-node"></circle><circle cx="2300" cy="900" r="40" class="minimap-node"></circle><circle cx="2800" cy="900" r="40" class="minimap-node"></circle><circle cx="2800" cy="1250" r="40" class="minimap-node"></circle><circle cx="2800" cy="1550" r="40" class="minimap-node"></circle><circle cx="1200" cy="1400" r="40" class="minimap-node"></circle><circle cx="2500" cy="1400" r="40" class="minimap-node"></circle><circle cx="800" cy="1900" r="40" class="minimap-node"></circle><circle cx="1200" cy="1900" r="40" class="minimap-node"></circle><circle cx="2500" cy="1900" r="40" class="minimap-node"></circle><circle cx="1100" cy="900" r="40" class="minimap-node"></circle><circle cx="600" cy="900" r="40" class="minimap-node"></circle><circle cx="600" cy="1300" r="40" class="minimap-node"></circle><circle cx="1100" cy="1300" r="40" class="minimap-node"></circle><circle cx="3200" cy="1400" r="40" class="minimap-node"></circle><circle cx="1442.718505859375" cy="492.46148681640625" r="40" class="minimap-node"></circle><circle cx="2626.9840737177465" cy="397.5428295158845" r="40" class="minimap-node"></circle><rect class="minimap-viewport" id="minimap-viewport" x="531.3333333333335" y="47.00000000000023" width="2737.333333333333" height="2052.9999999999995"></rect>
            </svg>
          </div>
          <div class="zoom-toolbar" id="zoom-toolbar">
            <button id="zoom-in-btn" title="Zoom in">+</button>
            <div class="zoom-level" id="zoom-level">146%</div>
            <button id="zoom-out-btn" title="Zoom out">-</button>
            <div class="divider"></div>
            <button id="zoom-fit-btn" title="Fit to view">[ ]</button>
            <button id="zoom-reset-btn" title="Reset view">R</button>
          </div>
        </div>
        <button type="button" id="edge-legend-mini" class="legend-mini-btn" style="bottom: 10px; display: none;">Line Legend</button>
		<button type="button" id="minimap-mini" class="legend-mini-btn" style="right: 10px; left: auto; bottom: 10px; display: none;">Map</button>
		<button type="button" id="draw-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: 10px; right: auto; display: none;">Draw</button>
		<button type="button" id="topology-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: auto; right: 40px; display: none;">Add Line</button>
      <button type="button" id="edge-legend-mini" class="legend-mini-btn" style="bottom: 10px; display: none;">Legend</button><button type="button" id="minimap-mini" class="legend-mini-btn" style="right: 10px; left: auto; bottom: 10px; display: none;">Map</button><button type="button" id="draw-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: 10px; right: auto; display: none;">Draw</button><button type="button" id="topology-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: auto; right: 40px; display: none;">Add Line</button><button type="button" id="edge-legend-mini" class="legend-mini-btn" style="bottom: 10px; display: none;">Legend</button><button type="button" id="topology-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: auto; right: 40px; display: inline-flex;">Add Line</button><button type="button" id="minimap-mini" class="legend-mini-btn" style="right: 10px; left: auto; bottom: 10px; display: none;">Map</button><button type="button" id="draw-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: 10px; right: auto; display: none;">Draw</button><button type="button" id="minimap-mini" class="legend-mini-btn" style="right: 10px; left: auto; bottom: 10px; display: none;">Map</button><button type="button" id="draw-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: 10px; right: auto; display: none;">Draw</button><button type="button" id="topology-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: auto; right: 40px; display: none;">Add Line</button><button type="button" id="edge-legend-mini" class="legend-mini-btn" style="bottom: 10px; display: none;">Legend</button><button type="button" id="edge-legend-mini" class="legend-mini-btn" style="bottom: 10px; display: none;">Legend</button><button type="button" id="topology-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: auto; right: 40px; display: none;">Add Line</button><button type="button" id="minimap-mini" class="legend-mini-btn" style="right: 10px; left: auto; bottom: 10px; display: none;">Map</button><button type="button" id="draw-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: 10px; right: auto; display: none;">Draw</button><button type="button" id="edge-legend-mini" class="legend-mini-btn" style="bottom: 10px; display: none;">Legend</button><button type="button" id="topology-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: auto; right: 40px; display: none;">Add Line</button><button type="button" id="minimap-mini" class="legend-mini-btn" style="right: 10px; left: auto; bottom: 10px; display: none;">Map</button><button type="button" id="draw-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: 10px; right: auto; display: none;">Draw</button><button type="button" id="edge-legend-mini" class="legend-mini-btn" style="bottom: 10px; display: none;">Legend</button><button type="button" id="topology-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: auto; right: 40px; display: none;">Add Line</button><button type="button" id="minimap-mini" class="legend-mini-btn" style="right: 10px; left: auto; bottom: 10px; display: none;">Map</button><button type="button" id="draw-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: 10px; right: auto; display: none;">Draw</button></section>
      <aside class="details-panel" id="details-panel">
        <div class="sidebar-resizer" id="sidebar-resizer">
          <svg class="resizer-icon" width="6" height="40" viewBox="0 0 6 40" xmlns="http://www.w3.org/2000/svg">
            <circle cx="3" cy="14" r="2"></circle>
            <circle cx="3" cy="20" r="2"></circle>
            <circle cx="3" cy="26" r="2"></circle>
          </svg>
        </div>
        <div class="mobile-footer-resizer" id="mobile-footer-resizer">
          <svg class="resizer-icon" width="40" height="6" viewBox="0 0 40 6" xmlns="http://www.w3.org/2000/svg">
            <circle cx="14" cy="3" r="2"></circle>
            <circle cx="20" cy="3" r="2"></circle>
            <circle cx="26" cy="3" r="2"></circle>
          </svg>
        </div>
        <div id="node-panel" style="display: block;">
          <div class="details-name editable-text" id="node-name">Internet</div>
          <div class="details-ip editable-text" id="node-ip">google.com</div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">MAC:</span>
            <span class="editable-text" id="node-mac" style="flex: 1; cursor: pointer; color: var(--text-main);">--</span>
          </div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">Rack Unit:</span>
            <span class="editable-text" id="node-rack" style="flex: 1; cursor: pointer; color: var(--text-main);">--</span>
          </div>
          <div class="details-info-row" id="uheight-row" style="display: none;">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">U Height:</span>
            <span class="editable-text" id="node-uheight" style="flex: 1; cursor: pointer; color: var(--text-main);">1U</span>
          </div>
          <div class="details-info-row" id="assigned-rack-row" style="display: flex;">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">Assigned Rack:</span>
            <select id="node-assigned-rack" style="flex: 1; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;"><option value="">None</option><option value="im-a-rack">IM A RACK</option></select>
          </div>
          <div class="details-info-row" id="rack-capacity-row" style="display: none;">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">Rack Capacity:</span>
            <select id="node-rack-capacity" style="flex: 1; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;">
              <option value="42">42U</option>
              <option value="48">48U</option>
              <option value="24">24U</option>
              <option value="12">12U</option>
              <option value="6">6U</option>
            </select>
          </div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">Layer:</span>
            <select id="node-layer" style="flex: 1; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;">
              <option value="physical">Physical</option>
              <option value="logical">Logical</option>
              <option value="security">Security</option>
              <option value="application">Application</option>
            </select>
          </div>
          <div class="details-role" id="node-role">WAN</div>
          <div class="badge-row" id="node-tags"><span class="badge" style="cursor: pointer; position: relative;"><span>1Gbps</span><span style="opacity: 0.6; margin-left: 4px; font-size: 10px;"> âœ•</span></span><span class="badge" style="cursor: pointer; position: relative;"><span>Redundant</span><span style="opacity: 0.6; margin-left: 4px; font-size: 10px;"> âœ•</span></span><span class="badge" style="cursor: pointer; opacity: 0.6; border-style: dashed;">+ Add</span></div>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-tag-input" placeholder="Add tag..." style="
              flex: 1;
              padding: 8px 12px;
              background: var(--panel);
              border: 1px solid var(--edge-main);
              border-radius: 6px;
              color: var(--text-main);
              font-size: clamp(14px, 1.6vw, 18px);
              ">
            <button id="add-tag-btn" style="
              padding: 8px 16px;
              background: var(--accent);
              color: var(--bg);
              border: none;
              border-radius: 6px;
              cursor: pointer;
              font-size: clamp(14px, 1.6vw, 18px);
              font-weight: 600;
              "> Add </button>
          </div>
          <button class="pick-icon-btn" id="pick-tag-icon-btn">Add Icon Tag</button>
          <div class="section-label">Size</div>
          <div class="size-controls">
            <label>Size:</label>
            <input type="range" id="size-slider" min="20" max="200" value="55">
            <span id="size-value">147</span>
            <button id="reset-size">Reset</button>
          </div>
          <details class="style-section" open="">
            <summary>Styling</summary>
            <div class="style-content">
              <div class="style-row">
                <label>Screen:</label>
                <select id="style-scope">
                  <option value="all">All</option>
                  <option value="desktop">Desktop</option>
                  <option value="tablet">Tablet</option>
                  <option value="mobile">Mobile</option>
                  <option value="fold">Fold</option>
                </select>
              </div>
              <div class="style-row">
                <label>Shape:</label>
                <select id="shape-select">
                  <optgroup label="Basic Shapes">
                    <option value="circle">Circle</option>
                    <option value="square">Square</option>
                    <option value="rectangle">Rectangle</option>
                    <option value="triangle">Triangle</option>
                    <option value="hexagon">Hexagon</option>
                    <option value="diamond">Diamond</option>
                    <option value="star">Star</option>
                    <option value="stop-sign">Stop Sign</option>
                  </optgroup>
                  <optgroup label="Network Equipment">
                    <option value="server">Server</option>
                    <option value="pc">PC / Desktop</option>
                    <option value="laptop">Laptop</option>
                    <option value="phone">Phone / Mobile</option>
                    <option value="router">Router</option>
                    <option value="switch">Switch</option>
                    <option value="firewall">Firewall</option>
                    <option value="cloud">Cloud</option>
                    <option value="database">Database</option>
                    <option value="printer">Printer</option>
                  </optgroup>
                </select>
              </div>
              <button class="pick-icon-btn" id="pick-shape-icon-btn">Or Search Web Icons</button>
              <div class="style-row">
                <label>Circle Color:</label>
                <input type="color" id="circle-color" value="#1e293b">
              </div>
              <div class="style-row">
                <label>Title Color:</label>
                <input type="color" id="title-color" value="#e2e8f0">
              </div>
              <div class="style-row">
                <label>Title Font:</label>
                <select id="title-font">
                  <option value="system-ui, sans-serif"> System UI </option>
                  <option value="monospace">Monospace</option>
                  <option value="serif">Serif</option>
                  <option value="cursive">Cursive</option>
                  <option value="'Courier New', monospace"> Courier </option>
                  <option value="Arial, sans-serif">Arial</option>
                  <option value="'Times New Roman', serif"> Times </option>
                </select>
              </div>
              <div class="style-row">
                <label>Title Size:</label>
                <input type="number" id="title-size" min="8" max="100" value="18">
              </div>
              <div class="style-row">
                <label>Sub Color:</label>
                <input type="color" id="sub-color" value="#94a3b8">
              </div>
              <div class="style-row">
                <label>Sub Font:</label>
                <select id="sub-font">
                  <option value="system-ui, sans-serif"> System UI </option>
                  <option value="monospace">Monospace</option>
                  <option value="serif">Serif</option>
                  <option value="cursive">Cursive</option>
                  <option value="'Courier New', monospace"> Courier </option>
                  <option value="Arial, sans-serif">Arial</option>
                  <option value="'Times New Roman', serif"> Times </option>
                </select>
              </div>
              <div class="style-row">
                <label>Sub Size:</label>
                <input type="number" id="sub-size" min="6" max="80" value="13">
              </div>
              <div style="
                margin-top: 12px;
                padding-top: 10px;
                border-top: 1px solid var(--edge-main);
                ">
                <div style="
                  font-size: 12px;
                  color: var(--text-soft);
                  margin-bottom: 8px;
                  text-transform: uppercase;
                  "> Text Position </div>
                <div class="style-row">
                  <label>Name Y:</label>
                  <input type="number" id="title-offset-y" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>Name X:</label>
                  <input type="number" id="title-offset-x" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>IP Y:</label>
                  <input type="number" id="sub-offset-y" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>IP X:</label>
                  <input type="number" id="sub-offset-x" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div style="margin-top: 16px; font-size: 12px; color: var(--text-soft); text-transform: uppercase;">
                  Ping Indicator Position
                </div>
                <div class="style-row">
                  <label>Ping X:</label>
                  <input type="number" id="ping-offset-x" min="-200" max="200" value="0" style="width: 60px;">
                </div>
                <div class="style-row">
                  <label>Ping Y:</label>
                  <input type="number" id="ping-offset-y" min="-200" max="200" value="0" style="width: 60px;">
                </div>
              </div>
              <button id="reset-styles" style="
                width: 100%;
                margin-top: 10px;
                padding: 8px;
                background: var(--panel);
                color: var(--text-main);
                border: 1px solid var(--edge-main);
                border-radius: 6px;
                cursor: pointer;
                font-size: clamp(13px, 1.5vw, 17px);
                "> Reset Styles </button>
            </div>
          </details>
          <details class="style-section">
            <summary>Ping / Status Monitoring</summary>
            <div class="style-content">
              <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px; cursor: pointer;">
              <input type="checkbox" id="node-pingable" style="cursor: pointer;">
              <span style="font-size: 14px;">Enable status check for this node</span>
              </label>
              <div id="node-ping-options" style="display: block;">
                <div class="style-row">
                  <label>Protocol:</label>
                  <select id="node-ping-protocol">
                    <option value="http">HTTP (port 80)</option>
                    <option value="https">HTTPS (port 443)</option>
                    <option value="custom">Custom URL</option>
                  </select>
                </div>
                <div id="node-custom-url-container" style="display: block; margin-top: 8px;">
                  <label style="display: block; margin-bottom: 4px; font-size: 13px;">Custom URL:</label>
                  <input type="text" id="node-custom-url" placeholder="e.g. http://192.168.1.1:8080" style="
                    width: 100%;
                    padding: 8px 12px;
                    background: var(--panel);
                    border: 1px solid var(--edge-main);
                    border-radius: 6px;
                    color: var(--text-main);
                    font-size: 14px;
                    ">
                </div>
                <div class="style-row" style="margin-top: 8px;">
                  <label>Timeout (ms):</label>
                  <input type="number" id="node-ping-timeout" value="3000" min="1000" max="10000" step="500" style="width: 100px;">
                </div>
                <div style="margin-top: 12px; padding: 10px; background: var(--panel); border-radius: 6px; border: 1px solid var(--edge-main);">
                  <div style="font-size: 12px; color: var(--text-soft); margin-bottom: 8px;">Current Status:</div>
                  <div id="node-ping-status" style="font-size: 14px; font-weight: 600; color: var(--accent);">â— Online</div>
                  <div id="node-ping-last-check" style="font-size: 11px; color: var(--text-soft); margin-top: 4px;">Last checked: 1:42:52 PM</div>
                </div>
                <button id="check-ping-now" style="
                  width: 100%;
                  margin-top: 10px;
                  padding: 8px;
                  background: var(--accent);
                  color: var(--bg);
                  border: none;
                  border-radius: 6px;
                  cursor: pointer;
                  font-size: 14px;
                  font-weight: 600;
                  ">Check Status Now</button>
              </div>
            </div>
          </details>
          <div class="section-label">Notes</div>
          <ul class="list" id="node-notes"><li><span style="flex: 1 1 0%;">Primary: Fiber</span><span class="delete-note">âœ•</span></li><li><span style="flex: 1 1 0%;">Backup: Cable</span><span class="delete-note">âœ•</span></li></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-note-input" placeholder="Type new note..." style="
              flex: 1;
              padding: 8px 12px;
              background: var(--panel);
              border: 1px solid var(--edge-main);
              border-radius: 6px;
              color: var(--text-main);
              font-size: clamp(14px, 1.6vw, 18px);
              ">
            <button id="add-note-btn" style="
              padding: 8px 16px;
              background: var(--accent);
              color: var(--bg);
              border: none;
              border-radius: 6px;
              cursor: pointer;
              font-size: clamp(14px, 1.6vw, 18px);
              font-weight: 600;
              "> Add </button>
          </div>
          <button id="delete-node-btn" style="
            margin-top: 15px;
            padding: 10px 16px;
            background: var(--danger);
            color: rgb(255, 255, 255);
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: clamp(14px, 1.6vw, 18px);
            font-weight: 600;
            width: 100%;
            "> Delete Node </button>
        </div>
        <div id="edge-panel" style="display: none;">
          <div class="details-name" id="edge-title">Custom line</div>
          <div class="style-row" style="margin-top: 10px">
            <label>Width:</label>
            <input type="number" id="edge-width" min="1" max="20" value="4">
          </div>
          <div class="style-row">
            <label>Color:</label>
            <input type="color" id="edge-color" value="#475569">
          </div>
          <div class="style-row">
            <label>Line Style:</label>
            <select id="edge-line-style">
              <option value="solid">Solid</option>
              <option value="dashed">Dashed</option>
              <option value="dotted">Dotted</option>
            </select>
          </div>
          <div class="style-row">
            <label>Direction:</label>
            <select id="edge-direction">
              <option value="none">No arrows</option>
              <option value="forward">â†’ Forward</option>
              <option value="backward">â† Backward</option>
              <option value="both">â†” Bidirectional</option>
            </select>
          </div>
          <div class="style-row" id="edge-port-fields" style="display: none;">
            <label>From Port:</label>
            <input type="text" id="edge-from-port" placeholder="e.g. eth0, gi0/1" style="
              flex: 1;
              padding: 6px 10px;
              background: var(--panel);
              border: 1px solid var(--edge-main);
              border-radius: 4px;
              color: var(--text-main);
              font-size: 14px;
              ">
          </div>
          <div class="style-row" id="edge-port-fields-to" style="display: none;">
            <label>To Port:</label>
            <input type="text" id="edge-to-port" placeholder="e.g. eth1, gi0/2" style="
              flex: 1;
              padding: 6px 10px;
              background: var(--panel);
              border: 1px solid var(--edge-main);
              border-radius: 4px;
              color: var(--text-main);
              font-size: 14px;
              ">
          </div>
          <div class="section-label">Line Notes</div>
          <ul class="list" id="edge-notes"></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-edge-note" placeholder="Add note..." style="
              flex: 1;
              padding: 8px 12px;
              background: var(--panel);
              border: 1px solid var(--edge-main);
              border-radius: 6px;
              color: var(--text-main);
              font-size: clamp(14px, 1.6vw, 18px);
              ">
            <button id="add-edge-note" style="
              padding: 8px 16px;
              background: var(--accent);
              color: var(--bg);
              border: none;
              border-radius: 6px;
              cursor: pointer;
              font-size: clamp(14px, 1.6vw, 18px);
              font-weight: 600;
              "> Add </button>
          </div>
          <button id="delete-edge" style="
            margin-top: 15px;
            padding: 10px 16px;
            background: var(--danger);
            color: #fff;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: clamp(14px, 1.6vw, 18px);
            font-weight: 600;
            "> Delete Line </button>
        </div>
        <div id="text-panel" style="display: none;">
          <div class="details-name" id="text-title">Text Element</div>
          <div class="style-row" style="margin-top: 10px">
            <label>Content:</label>
            <textarea id="text-content" placeholder="Enter text..." style="
              width: 100%;
              padding: 8px 12px;
              background: var(--panel);
              border: 1px solid var(--edge-main);
              border-radius: 6px;
              color: var(--text-main);
              font-size: 14px;
              min-height: 80px;
              resize: vertical;
              font-family: inherit;
              "></textarea>
          </div>
          <div class="style-row">
            <label>Font Size:</label>
            <input type="number" id="text-font-size" min="8" max="200" value="18" style="
              flex: 1;
              padding: 6px 10px;
              background: var(--panel);
              border: 1px solid var(--edge-main);
              border-radius: 4px;
              color: var(--text-main);
              ">
          </div>
          <div class="style-row">
            <label>Color:</label>
            <input type="color" id="text-color" value="#e2e8f0">
          </div>
          <div class="style-row">
            <label>Font Weight:</label>
            <select id="text-font-weight" style="
              flex: 1;
              padding: 6px 10px;
              background: var(--panel);
              border: 1px solid var(--edge-main);
              border-radius: 4px;
              color: var(--text-main);
              cursor: pointer;
              ">
              <option value="normal">Normal</option>
              <option value="bold">Bold</option>
              <option value="600">Semi-Bold</option>
              <option value="300">Light</option>
            </select>
          </div>
          <div class="style-row">
            <label>Font Style:</label>
            <select id="text-font-style" style="
              flex: 1;
              padding: 6px 10px;
              background: var(--panel);
              border: 1px solid var(--edge-main);
              border-radius: 4px;
              color: var(--text-main);
              cursor: pointer;
              ">
              <option value="normal">Normal</option>
              <option value="italic">Italic</option>
            </select>
          </div>
          <div class="style-row">
            <label>Text Align:</label>
            <select id="text-align" style="
              flex: 1;
              padding: 6px 10px;
              background: var(--panel);
              border: 1px solid var(--edge-main);
              border-radius: 4px;
              color: var(--text-main);
              cursor: pointer;
              ">
              <option value="start">Left</option>
              <option value="middle">Center</option>
              <option value="end">Right</option>
            </select>
          </div>
          <div class="style-row">
            <label>Text Decoration:</label>
            <select id="text-decoration" style="
              flex: 1;
              padding: 6px 10px;
              background: var(--panel);
              border: 1px solid var(--edge-main);
              border-radius: 4px;
              color: var(--text-main);
              cursor: pointer;
              ">
              <option value="none">None</option>
              <option value="underline">Underline</option>
              <option value="line-through">Strike Through</option>
            </select>
          </div>
          <div class="style-row">
            <label>Background:</label>
            <input type="color" id="text-bg-color" value="#000000">
            <label style="margin-left: 10px; display: flex; align-items: center; gap: 6px;">
            <input type="checkbox" id="text-bg-enabled" style="cursor: pointer;">
            <span style="font-size: 13px;">Enable</span>
            </label>
          </div>
          <div class="style-row">
            <label>Opacity:</label>
            <input type="range" id="text-opacity" min="0" max="1" step="0.1" value="1" style="flex: 1">
            <span id="text-opacity-val" style="min-width: 35px; text-align: right">100%</span>
          </div>
          <button id="delete-text" style="
            margin-top: 15px;
            padding: 10px 16px;
            background: var(--danger);
            color: #fff;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: clamp(14px, 1.6vw, 18px);
            font-weight: 600;
            width: 100%;
            "> Delete Text </button>
        </div>
        <details class="style-section" open="">
          <summary>Page Layout</summary>
          <div class="style-content">
            <div style="padding: 12px; background: var(--panel-alt); border-radius: 6px; color: var(--text-soft); font-size: 13px; line-height: 1.6;">
              <strong style="color: var(--accent); display: block; margin-bottom: 8px;">Drag to Resize:</strong>
              â€¢ <strong>Header:</strong> Drag the bottom edge of the header bar<br>
              â€¢ <strong>Sidebar:</strong> Drag the left edge of the sidebar panel<br>
              â€¢ <strong>Mobile:</strong> Drag the top edge of the footer panel<br>
              <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--edge-main); font-size: 12px;">
                ðŸ’¡ Hover over panel edges to see resize handles
              </div>
            </div>
          </div>
        </details>
      </aside>
    </main>
    <script id="nodes-json" type="application/json">{}</script>
    <script id="topology-state" type="application/json">ENCRYPTED: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</script>
    <script>
      const IconLibrary = {
       libraries: {
        mdi: {
         name: 'Material Design Icons',
         cdnBase: 'https://cdn.jsdelivr.net/npm/@mdi/svg@latest/svg/',
         metaUrl: 'https://cdn.jsdelivr.net/npm/@mdi/svg@latest/meta.json',
         icons: []
        },
        simple: {
         name: 'Simple Icons',
         cdnBase: 'https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/',
         indexUrl: 'https://cdn.jsdelivr.net/npm/@iconify-json/simple-icons@latest/icons.json',
         icons: []
        },
        selfhst: {
         name: 'Selfh.st',
         cdnBase: 'https://cdn.jsdelivr.net/gh/selfhst/icons@master/png/',
         indexUrl: 'https://raw.githubusercontent.com/selfhst/icons/refs/heads/main/index.json',
         icons: []
        }
       },
       currentLibrary: 'mdi',
       iconCache: {},
       indexCache: {},
       indexLoading: {},
       async loadLibraryIndex(library) {
        if (this.indexCache[library]) {
         return this.indexCache[library];
        }
        if (this.indexLoading[library]) {
         return this.indexLoading[library];
        }
        const lib = this.libraries[library];
        this.indexLoading[library] = (async () => {
         try {
          if (library === 'selfhst') {
           const response = await fetch(lib.indexUrl);
           const data = await response.json();
           const icons = data.map(item => ({
            name: item.Reference,
            displayName: item.Name,
            tags: item.Tags ? item.Tags.split(',').map(t => t.trim()).filter(t => t) : [],
            category: item.Category
           }));
           this.indexCache[library] = icons;
           lib.icons = icons;
           return icons;
          } else if (library === 'simple') {
           const response = await fetch('https://cdn.jsdelivr.net/npm/@iconify-json/simple-icons@latest/icons.json');
           const data = await response.json();
           const icons = Object.keys(data.icons).map(slug => ({
            name: slug,
            displayName: data.icons[slug].title || slug,
            tags: data.aliases && data.aliases[slug] ? [data.aliases[slug].parent] : [],
            hex: data.icons[slug].hex
           }));
           this.indexCache[library] = icons;
           lib.icons = icons;
           return icons;
          } else if (library === 'mdi') {
           const response = await fetch(lib.metaUrl);
           const data = await response.json();
           const icons = data.map(item => ({
            name: item.name,
            displayName: item.name,
            tags: item.tags || [],
            author: item.author
           }));
           this.indexCache[library] = icons;
           lib.icons = icons;
           return icons;
          }
         } catch (error) {
          console.error(`Failed to load index for ${library}:`, error);
          this.indexCache[library] = [];
          lib.icons = [];
          return [];
         } finally {
          delete this.indexLoading[library];
         }
        })();
        return this.indexLoading[library];
       },
       async getIcon(library, name) {
        const cacheKey = `${library}-${name}`;
        if (this.iconCache[cacheKey]) {
         return this.iconCache[cacheKey];
        }
        const cached = localStorage.getItem(`icon-${cacheKey}`);
        if (cached) {
         this.iconCache[cacheKey] = cached;
         return cached;
        }
        const lib = this.libraries[library];
        if (library === 'selfhst') {
         const pngUrl = `${lib.cdnBase}${name}.png`;
         const svgWrapper = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><image href="${pngUrl}" width="24" height="24"/></svg>`;
         this.iconCache[cacheKey] = svgWrapper;
         localStorage.setItem(`icon-${cacheKey}`, svgWrapper);
         return svgWrapper;
        }
        const url = `${lib.cdnBase}${name}.svg`;
        try {
         const response = await fetch(url);
         if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
         }
         const svg = await response.text();
         this.iconCache[cacheKey] = svg;
         localStorage.setItem(`icon-${cacheKey}`, svg);
         return svg;
        } catch (error) {
         console.error(`Failed to fetch icon ${cacheKey}:`, error);
         return null;
        }
       },
       searchIcons(library, query) {
        const lib = this.libraries[library];
        if (!lib.icons.length) return [];
        const q = query.toLowerCase();
        return lib.icons.filter(icon => {
         const nameMatch = icon.name.toLowerCase().includes(q);
         const displayMatch = icon.displayName && icon.displayName.toLowerCase().includes(q);
         const tagMatch = icon.tags && icon.tags.some(t => t.toLowerCase().includes(q));
         const categoryMatch = icon.category && icon.category.toLowerCase().includes(q);
         return nameMatch || displayMatch || tagMatch || categoryMatch;
        }).slice(0, 50);
       }
      };
      let iconPickerCallback = null;
      let selectedNodeIconData = null;
      let selectedRackIconData = null;
      let newNodeIconTags = [];
      
      async function checkNodeStatus(nodeId) {
       const data = NODE_DATA[nodeId];
       if (!data || !data.ping || !data.ping.enabled) return;
       
       data.ping.status = 'checking';
       data.ping.lastCheck = new Date().toISOString();
       updatePingIndicator(nodeId);
       if (currentNodeId === nodeId) {
        updatePingStatusDisplay(nodeId);
       }
       
       let url;
       if (data.ping.protocol === 'custom') {
        url = data.ping.customUrl;
       } else {
        const ip = data.ip || '0.0.0.0';
        const protocol = data.ping.protocol || 'http';
        url = `${protocol}://${ip}`;
       }
       
       if (!url) {
        data.ping.status = 'unknown';
        updatePingIndicator(nodeId);
        if (currentNodeId === nodeId) {
         updatePingStatusDisplay(nodeId);
        }
        return;
       }
       
       try {
        const controller = new AbortController();
        const timeout = data.ping.timeout || 3000;
        const timeoutId = setTimeout(() => controller.abort(), timeout);
        
        const response = await fetch(url, {
         method: 'HEAD',
         mode: 'no-cors', 
         signal: controller.signal
        });
        
        clearTimeout(timeoutId);
        
        data.ping.status = 'online';
       } catch (error) {
        data.ping.status = 'offline';
       }
       
       data.ping.lastCheck = new Date().toISOString();
       updatePingIndicator(nodeId);
       if (currentNodeId === nodeId) {
        updatePingStatusDisplay(nodeId);
       }
      }
      function rgbaToHex(val) {
      if (!val) return "#000000";
      if (val.startsWith("#")) return val;
      
      const m = val.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
      if (!m) return "#000000";
      
      const r = Number(m[1]).toString(16).padStart(2, "0");
      const g = Number(m[2]).toString(16).padStart(2, "0");
      const b = Number(m[3]).toString(16).padStart(2, "0");
      
      return `#${r}${g}${b}`;
      }
      function updatePingIndicator(nodeId) {
      const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
      if (!nodeGroup) return;
      
      const data = NODE_DATA[nodeId];
      if (!data || !data.ping || !data.ping.enabled) {
       const existingIndicator = nodeGroup.querySelector('.ping-indicator');
       if (existingIndicator) existingIndicator.remove();
       return;
      }
      
      let indicator = nodeGroup.querySelector('.ping-indicator');
      const label = nodeGroup.querySelector('.node-label');
      
      if (!indicator && label) {
       indicator = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
       indicator.classList.add('ping-indicator');
       nodeGroup.appendChild(indicator);
      }
      
      if (indicator && label) {
       const size = savedSizes[nodeId] || getDefaultSize();
       const radius = Math.max(4, size * 0.06);
      
       indicator.setAttribute('r', radius);
      
       const labelBBox = label.getBBox();
       const labelX = parseFloat(label.getAttribute('x') || 0);
       const labelY = parseFloat(label.getAttribute('y') || 0);
      
       const styles = resolveStylesForNode(nodeId);
      const offX = styles.pingOffsetX || 0;
      const offY = styles.pingOffsetY || 0;
      
      indicator.setAttribute('cx', (labelX - labelBBox.width / 2 - radius * 1.1) + offX);
      indicator.setAttribute('cy', (labelY - radius * 0.7) + offY);
      }
      
      if (indicator) {
       indicator.classList.remove('online', 'offline', 'checking');
       if (data.ping.status) indicator.classList.add(data.ping.status);
      }
      }
      
      
      function checkAllNodesStatus() {
       Object.keys(NODE_DATA).forEach(nodeId => {
        const data = NODE_DATA[nodeId];
        if (data && data.ping && data.ping.enabled) {
         checkNodeStatus(nodeId);
        }
       });
      }
      
      function startAutoPing() {
       stopAutoPing();
       
       checkAllNodesStatus();
       updateAutoPingLastRun();
       
       autoPingSecondsRemaining = autoPingInterval;
       
      
       autoPingTimer = setInterval(() => {
        checkAllNodesStatus();
        updateAutoPingLastRun();
        autoPingSecondsRemaining = autoPingInterval;
       }, autoPingInterval * 1000);
       
       autoPingCountdown = setInterval(() => {
        autoPingSecondsRemaining--;
        updateAutoPingCountdown();
        if (autoPingSecondsRemaining <= 0) {
         autoPingSecondsRemaining = autoPingInterval;
        }
       }, 1000);
       
       updateAutoPingCountdown();
      }
      
      function stopAutoPing() {
       if (autoPingTimer) {
        clearInterval(autoPingTimer);
        autoPingTimer = null;
       }
       if (autoPingCountdown) {
        clearInterval(autoPingCountdown);
        autoPingCountdown = null;
       }
       autoPingSecondsRemaining = 0;
       updateAutoPingCountdown();
      }
      
      function updateAutoPingCountdown() {
       const nextCheckEl = document.getElementById('auto-ping-next-check');
       if (nextCheckEl) {
        if (autoPingSecondsRemaining > 0 && autoPingEnabled) {
         const mins = Math.floor(autoPingSecondsRemaining / 60);
         const secs = autoPingSecondsRemaining % 60;
         if (mins > 0) {
          nextCheckEl.textContent = `Next check in: ${mins}m ${secs}s`;
         } else {
          nextCheckEl.textContent = `Next check in: ${secs}s`;
         }
        } else {
         nextCheckEl.textContent = 'Next check in: --';
        }
       }
      }
      
      function updateAutoPingLastRun() {
       const lastRunEl = document.getElementById('auto-ping-last-run');
       if (lastRunEl) {
        const now = new Date();
        lastRunEl.textContent = `Last run: ${now.toLocaleTimeString()}`;
       }
      }
      
      function openIconPicker(callback) {
       iconPickerCallback = callback;
       const modal = document.getElementById('icon-picker-modal');
       modal.classList.add('active');
       const searchInput = document.getElementById('icon-search');
       searchInput.style.display = 'none';
       loadIconsForCurrentLibrary();
      }
      
      function closeIconPicker() {
       const modal = document.getElementById('icon-picker-modal');
       modal.classList.remove('active');
       iconPickerCallback = null;
      }
      async function loadIconsForCurrentLibrary() {
       const body = document.getElementById('icon-picker-body');
       const libNames = {
        mdi: 'MDI (Material Design Icons)',
        simple: 'Simple Icons',
        selfhst: 'Selfh.st'
       };
       body.innerHTML = `<div style="padding: 20px;"><p style="color: var(--text-soft); margin-bottom: 15px; text-align: center;">Search ${libNames[IconLibrary.currentLibrary]}:</p><input type="text" id="icon-search-field" placeholder="Search icons..." style="width: 100%; padding: 12px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main); font-size: 16px; margin-bottom: 20px;"><div id="icon-grid-container" style="max-height: 400px; overflow-y: auto;"><div style="text-align: center; color: var(--text-soft); padding: 40px;">Loading icons...</div></div></div>`;
       const searchField = document.getElementById('icon-search-field');
       const gridContainer = document.getElementById('icon-grid-container');
       await IconLibrary.loadLibraryIndex(IconLibrary.currentLibrary);
       const renderIcons = (icons) => {
        if (!icons || icons.length === 0) {
         gridContainer.innerHTML = '<div style="text-align: center; color: var(--text-soft); padding: 40px;">No icons found</div>';
         return;
        }
        const grid = document.createElement('div');
        grid.style.cssText = 'display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 15px; padding: 10px;';
        icons.forEach(icon => {
         const item = document.createElement('div');
         item.style.cssText = 'display: flex; flex-direction: column; align-items: center; gap: 8px; padding: 15px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; cursor: pointer; transition: all 0.2s;';
         item.onmouseover = () => {
          item.style.background = 'var(--panel)';
          item.style.borderColor = 'var(--accent)';
         };
         item.onmouseout = () => {
          item.style.background = 'var(--panel-alt)';
          item.style.borderColor = 'var(--edge-main)';
         };
         const iconPreview = document.createElement('div');
         iconPreview.style.cssText = 'width: 48px; height: 48px; display: flex; align-items: center; justify-content: center;';
         iconPreview.innerHTML = '<div style="color: var(--text-soft); font-size: 12px;">...</div>';
         IconLibrary.getIcon(IconLibrary.currentLibrary, icon.name).then(svg => {
          if (svg) {
           const parser = new DOMParser();
           const doc = parser.parseFromString(svg, 'image/svg+xml');
           const svgEl = doc.querySelector('svg');
           if (svgEl) {
            svgEl.setAttribute('width', '48');
            svgEl.setAttribute('height', '48');
            svgEl.style.fill = 'var(--text-main)';
            iconPreview.innerHTML = '';
            iconPreview.appendChild(svgEl);
           }
          }
         });
         const name = document.createElement('div');
         name.textContent = icon.displayName || icon.name;
         name.style.cssText = 'font-size: 11px; color: var(--text-soft); text-align: center; word-break: break-word; max-width: 100%;';
         item.appendChild(iconPreview);
         item.appendChild(name);
         item.addEventListener('click', async () => {
          const svg = await IconLibrary.getIcon(IconLibrary.currentLibrary, icon.name);
          if (iconPickerCallback && svg) {
           iconPickerCallback({
            library: IconLibrary.currentLibrary,
            name: icon.name,
            svg: svg
           });
          }
          closeIconPicker();
         });
         grid.appendChild(item);
        });
        gridContainer.innerHTML = '';
        gridContainer.appendChild(grid);
       };
       gridContainer.innerHTML = '<div style="text-align: center; color: var(--text-soft); padding: 40px;">Type to search icons</div>';
       let searchTimeout;
       searchField.addEventListener('input', (e) => {
        clearTimeout(searchTimeout);
        const query = e.target.value.trim();
        searchTimeout = setTimeout(() => {
         if (!query) {
          gridContainer.innerHTML = '<div style="text-align: center; color: var(--text-soft); padding: 40px;">Type to search icons</div>';
          return;
         }
         const results = IconLibrary.searchIcons(IconLibrary.currentLibrary, query);
         renderIcons(results);
        }, 300);
       });
       searchField.focus();
      }
      async function displayIcons(icons) {
       const body = document.getElementById('icon-picker-body');
       const grid = document.createElement('div');
       grid.className = 'icon-grid';
       for (const icon of icons) {
        const item = document.createElement('div');
        item.className = 'icon-item';
        const svg = await IconLibrary.getIcon(icon.library, icon.name);
        if (svg) {
         const parser = new DOMParser();
         const doc = parser.parseFromString(svg, 'image/svg+xml');
         const svgEl = doc.querySelector('svg');
         if (svgEl) {
          item.innerHTML = svgEl.outerHTML;
         }
        } else {
         item.innerHTML = '<svg width = "32" height = "32"><rect width = "32" height = "32" fill = "currentColor"/> </svg>';
        }
        const name = document.createElement('div');
        name.className = 'icon-item-name';
        name.textContent = icon.name;
        item.appendChild(name);
        item.addEventListener('click', () => {
         if (iconPickerCallback) {
          iconPickerCallback({
           library: icon.library,
           name: icon.name,
           svg: svg
          });
         }
         closeIconPicker();
        });
        grid.appendChild(item);
       }
       body.innerHTML = '';
       body.appendChild(grid);
      }
      window.addEventListener('DOMContentLoaded', () => {
       document.querySelectorAll('.icon-picker-tab').forEach(tab => {
        tab.addEventListener('click', () => {
         document.querySelectorAll('.icon-picker-tab').forEach(t => t.classList.remove('active'));
         tab.classList.add('active');
         IconLibrary.currentLibrary = tab.dataset.library;
         loadIconsForCurrentLibrary();
        });
       });
       document.getElementById('icon-picker-cancel').addEventListener('click', closeIconPicker);
       document.getElementById('icon-picker-modal').addEventListener('click', (e) => {
        if (e.target.id === 'icon-picker-modal') {
         closeIconPicker();
        }
       });
      });
	  let textDrawMode = false;
      const BASE_NODE_DATA = JSON.parse(document.getElementById("nodes-json").textContent, );
      let currentNodeId = "host";
      let currentEdgeId = null;
      let currentStyleScope = "all";
      let NODE_DATA = {};
      let EDGE_DATA = {
       list: []
      };
      let RECT_DATA = {
       list: []
      };
      let TEXT_DATA = {
       list: []
      };
      let EDGE_LEGEND = {};
      let savedPositions = {};
      let savedSizes = {};
      let savedStyles = {};
      let legendCollapsed = false;
      let minimapCollapsed = false;
      let drawToolbarCollapsed = false;
      let currentView = {
       mode: "topology",
       rackId: null
      };
      let savedTopologyView = null;
      let activeLayers = new Set(["physical", "logical", "security", "application"]);
      let topologyToolbarCollapsed = false;
      let legendMiniBtn = null;
      let minimapMiniBtn = null;
      let drawToolbarMiniBtn = null;
      let topologyToolbarMiniBtn = null;
      
      let autoPingEnabled = false;
      let autoPingInterval = 30;
      let autoPingTimer = null;
      let autoPingCountdown = null;
      let autoPingSecondsRemaining = 0;
      
      let undoStack = [];
      let redoStack = [];
      const MAX_UNDO_STACK = 50;
      let selectedNodes = new Set();
      let isSelecting = false;
      let selectionStart = null;
      let selectionRect = null;
      let isDraggingSelection = false;
      let dragSelectionStart = null;
      let clipboard = null;
      
      const MobileManager = {
        isMobile: false,
        detect() {
      
          if (navigator.userAgentData?.mobile === true) {
            this.isMobile = true;
            return true;
          }
          const coarse = matchMedia("(pointer: coarse)").matches;
          const width = window.innerWidth <= 900;
          const portrait = matchMedia("(orientation: portrait)").matches;
          this.isMobile = coarse && (width || portrait);
          return this.isMobile;
        },
        applyInitialCollapse() {
          if (!this.isMobile) return;
          legendCollapsed = true;
          minimapCollapsed = true;
          drawToolbarCollapsed = true;
          topologyToolbarCollapsed = true;
          if (typeof updateLegendVisibility === "function") updateLegendVisibility();
          if (typeof updateMinimapVisibility === "function") updateMinimapVisibility();
          if (typeof updateDrawToolbarVisibility === "function") updateDrawToolbarVisibility();
          if (typeof updateTopologyToolbarVisibility === "function") updateTopologyToolbarVisibility();
        },
        updateBulkToolbar() {
          const desktop = document.getElementById("bulk-toolbar");
          const mobile = document.getElementById("bulk-toolbar-mobile");
          if (!desktop || !mobile) return;
          
          const isVisible = desktop.style.display !== "none" || mobile.style.display !== "none";
          
          if (this.isMobile) {
            desktop.style.display = "none";
            if (isVisible) {
              mobile.style.display = "flex";
            }
          } else {
            mobile.style.display = "none";
            if (isVisible) {
              desktop.style.display = "flex";
            }
          }
        },
        updateLayout() {
          const main = document.querySelector("main");
          if (!main) return;
        },
        updateCanvasHint() {
      const hint = document.getElementById("canvas-hint");
      if (!hint) return;
      
      const items = this.isMobile
      ? [
        "Pinch to zoom",
        "Drag to pan",
        "Double tap to select multiple",
        "Double tap to select multiple",
        "Your time is NOW!",
      ]
      : [
        "Scroll to zoom",
        "Drag to pan",
        "Right-click to select multiple",
        "Your time is NOW!",
      ];
      
      const list = document.createElement("ul");
      for (const item of items) {
      const li = document.createElement("li");
      li.textContent = item;
      list.appendChild(li);
      }
      
      hint.replaceChildren(list);
      },
        autoSelectStyleScope() {
          const scope = document.getElementById("style-scope");
          if (!scope) return;
          if (this.isMobile) scope.value = "mobile";
        },
        updateToolbarStack() {
          if (!this.isMobile) return;
          const draw = document.getElementById("draw-toolbar");
          const topo = document.getElementById("topology-toolbar");
          if (!draw || !topo) return;
          const h = draw.getBoundingClientRect().height;
          document.documentElement.style.setProperty("--draw-toolbar-height", h + "px");
        },
        updateLayoutControls() {
          const sidebarRow = document.getElementById("sidebar-width-row");
          const footerRow = document.getElementById("mobile-footer-row");
          if (sidebarRow && footerRow) {
            if (this.isMobile) {
              sidebarRow.style.display = "none";
              footerRow.style.display = "flex";
            } else {
              sidebarRow.style.display = "flex";
              footerRow.style.display = "none";
            }
          }
        },
        applyAll() {
          this.detect();
          this.applyInitialCollapse();
          this.updateBulkToolbar();
          this.updateLayout();
          this.updateCanvasHint();
          this.autoSelectStyleScope();
          this.updateToolbarStack();
          this.updateLayoutControls();
        }
      };
      function isMobileDevice() {
        return MobileManager.isMobile;
      }
      
      function ensureLegendMiniButton() {
       if (legendMiniBtn) return legendMiniBtn;
      
       const panel = document.querySelector(".topology-panel");
       if (!panel) return null;
       const btn = document.createElement("button");
       btn.type = "button";
       btn.id = "edge-legend-mini";
       btn.className = "legend-mini-btn";
       btn.textContent = "Legend";
       btn.style.bottom = "10px";
       const handleClick = (e) => {
        e.stopPropagation();
        e.preventDefault();
        legendCollapsed = false;
        updateLegendVisibility();
       };
       btn.addEventListener("click", handleClick);
       btn.addEventListener("touchend", handleClick);
       panel.appendChild(btn);
       legendMiniBtn = btn;
       return btn;
      }
      
      function ensureMinimapMiniButton() {
       if (minimapMiniBtn) return minimapMiniBtn;
       const panel = document.querySelector(".topology-panel");
       if (!panel) return null;
       const btn = document.createElement("button");
       btn.type = "button";
       btn.id = "minimap-mini";
       btn.className = "legend-mini-btn";
       btn.textContent = "Map";
       btn.style.right = "10px";
       btn.style.left = "auto";
       btn.style.bottom = "10px";
       const handleClick = (e) => {
        e.stopPropagation();
        e.preventDefault();
        minimapCollapsed = false;
        updateMinimapVisibility();
       };
       btn.addEventListener("click", handleClick);
       btn.addEventListener("touchend", handleClick);
       panel.appendChild(btn);
       minimapMiniBtn = btn;
       return btn;
      }
      
      function ensureDrawToolbarMiniButton() {
       if (drawToolbarMiniBtn) return drawToolbarMiniBtn;
       const panel = document.querySelector(".topology-panel");
       if (!panel) return null;
       const btn = document.createElement("button");
       btn.type = "button";
       btn.id = "draw-toolbar-mini";
       btn.className = "legend-mini-btn";
       btn.textContent = "Draw";
       btn.style.top = "10px";
       btn.style.left = "10px";
       btn.style.right = "auto";
       const handleClick = (e) => {
        e.stopPropagation();
        e.preventDefault();
        drawToolbarCollapsed = false;
        updateDrawToolbarVisibility();
       };
       btn.addEventListener("click", handleClick);
       btn.addEventListener("touchend", handleClick);
       panel.appendChild(btn);
       drawToolbarMiniBtn = btn;
       return btn;
      }
      
      function ensureTopologyToolbarMiniButton() {
       if (topologyToolbarMiniBtn) return topologyToolbarMiniBtn;
       const panel = document.querySelector(".topology-panel");
       if (!panel) return null;
       const btn = document.createElement("button");
       btn.type = "button";
       btn.id = "topology-toolbar-mini";
       btn.className = "legend-mini-btn";
       btn.textContent = "Add Line";
       btn.style.top = "10px";
       btn.style.left = "auto";
       btn.style.right = "40px";
       const handleClick = (e) => {
        e.stopPropagation();
        e.preventDefault();
        topologyToolbarCollapsed = false;
        updateTopologyToolbarVisibility();
       };
       btn.addEventListener("click", handleClick);
       btn.addEventListener("touchend", handleClick);
       panel.appendChild(btn);
       topologyToolbarMiniBtn = btn;
       return btn;
      }
      
      function updateToolbarStack() {
       if (!isMobileDevice()) return;
       const draw = document.getElementById("draw-toolbar");
       const topo = document.getElementById("topology-toolbar");
       if (!draw || !topo) return;
       const h = draw.getBoundingClientRect().height;
       document.documentElement.style.setProperty("--draw-toolbar-height", h + "px");
      }
      window.addEventListener("resize", updateToolbarStack);
      window.addEventListener("DOMContentLoaded", updateToolbarStack);
      updateToolbarStack();
      
      function updateLegendVisibility() {
       const legend = document.getElementById("edge-legend");
       const mini = ensureLegendMiniButton();
       if (!legend || !mini) return;
       const hasItems = legend.querySelectorAll(".legend-item").length > 0;
       if (!hasItems) {
        legend.style.display = "none";
        mini.style.display = "none";
        return;
       }
       if (legendCollapsed) {
        legend.style.display = "none";
        mini.style.display = "inline-flex";
       } else {
        legend.style.display = "flex";
        mini.style.display = "none";
       }
      }
      
      function updateMinimapVisibility() {
       const wrapper = document.getElementById("minimap-zoom-wrapper");
       const mini = ensureMinimapMiniButton();
       if (!wrapper || !mini) return;
       if (minimapCollapsed) {
        wrapper.style.display = "none";
        mini.style.display = "inline-flex";
       } else {
        wrapper.style.display = "block";
        mini.style.display = "none";
       }
      }
      
      function updateDrawToolbarVisibility() {
       const toolbar = document.getElementById("draw-toolbar");
       const mini = ensureDrawToolbarMiniButton();
       if (!toolbar || !mini) return;
       if (drawToolbarCollapsed) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "inline-flex";
       } else {
        toolbar.style.setProperty('display', 'grid', 'important');
        mini.style.display = "none";
       }
      }
       function u8ToBase64(u8) {
      let binary = "";
      for (let i = 0; i < u8.length; i++) binary += String.fromCharCode(u8[i]);
      return btoa(binary);
      }
      
      function base64ToU8(base64) {
      const binary = atob(base64);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
      return bytes;
      }  
      function updateTopologyToolbarVisibility() {
       const toolbar = document.getElementById("topology-toolbar");
       const mini = ensureTopologyToolbarMiniButton();
       if (!toolbar || !mini) return;
       const hasSelectedNode = currentNodeId !== null;
       if (!hasSelectedNode) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "none";
       } else if (topologyToolbarCollapsed) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "inline-flex";
       } else {
        toolbar.style.setProperty('display', 'grid', 'important');
        mini.style.display = "none";
       }
      }
      const DEFAULT_PAGE_STATE = {
       title: "The One File: The Networkening",
       background: "",
       topbarBg: "rgba(9, 12, 20, 0.9)",
       topbarBorder: "#1f2533",
       panel: "#0b0e13",
       panelAlt: "#10141b",
       accent: "#4fd1c5",
       danger: "#f56565",
       textMain: "#e2e8f0",
       textSoft: "#94a3b8",
       topbarHeight: 52,
       sidebarWidth: 350,
       mobileFooterHeight: 40,
       sidebarCollapsed: false,
       autoPingEnabled: false,
       autoPingInterval: 30,
      };
      let PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE);
      const CANVAS_WIDTH = 4000;
      const CANVAS_HEIGHT = 3000;
      const CANVAS_PADDING = 100;
      
      const RACK_U_HEIGHT = 70;
      const RACK_WIDTH = 600;
      const RACK_START_X = CANVAS_WIDTH / 2;
      const RACK_START_Y = CANVAS_PADDING + 100;
      
      let canvasState = {
       zoom: 1,
       panX: 0,
       panY: 0,
       minZoom: 0.25,
       maxZoom: 4,
       isPanning: false,
       panStartX: 0,
       panStartY: 0,
       spacePressed: false,
      };
      
      function getViewBox() {
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       return {
        x: canvasState.panX,
        y: canvasState.panY,
        width: viewWidth,
        height: viewHeight,
       };
      }
      
      function updateViewBox() {
       const svg = document.getElementById("map");
       const vb = getViewBox();
       svg.setAttribute("viewBox", `${vb.x} ${vb.y} ${vb.width} ${vb.height}`, );
       const zoomLevel = document.getElementById("zoom-level");
       if (zoomLevel) {
        zoomLevel.textContent = Math.round(canvasState.zoom * 100) + "%";
       }
       updateMinimap();
      }
      
      function updateMinimap() {
       const minimapViewport = document.getElementById("minimap-viewport");
       const minimapSvg = document.getElementById("minimap");
       if (!minimapViewport || !minimapSvg) return;
       const vb = getViewBox();
       minimapViewport.setAttribute("x", vb.x);
       minimapViewport.setAttribute("y", vb.y);
       minimapViewport.setAttribute("width", vb.width);
       minimapViewport.setAttribute("height", vb.height);
       const minimapNodes = minimapSvg.querySelectorAll(".minimap-node");
       minimapNodes.forEach((n) => n.remove());
       const minimapEdges = minimapSvg.querySelectorAll(".minimap-edge");
       minimapEdges.forEach((e) => e.remove());
       
       EDGE_DATA.list.forEach((edge) => {
        if (edge.type === "custom") return;
        
        const fromNode = NODE_DATA[edge.from];
        const toNode = NODE_DATA[edge.to];
        if (!fromNode || !toNode) return;
        
        if (currentView.mode === "rack") {
         if (fromNode.assignedRack !== currentView.rackId || 
             toNode.assignedRack !== currentView.rackId) {
          return;
         }
        } else {
         if (fromNode.assignedRack || toNode.assignedRack) {
          return;
         }
        }
        
        const p1 = savedPositions[edge.from];
        const p2 = savedPositions[edge.to];
        if (!p1 || !p2) return;
        const line = document.createElementNS("http://www.w3.org/2000/svg", "line", );
        line.setAttribute("x1", p1.x);
        line.setAttribute("y1", p1.y);
        line.setAttribute("x2", p2.x);
        line.setAttribute("y2", p2.y);
        line.classList.add("minimap-edge");
        minimapSvg.insertBefore(line, minimapViewport);
       });
	   
       Object.entries(savedPositions).forEach(([id, pos]) => {
        const node = NODE_DATA[id];
        if (!node) return;
        
        if (currentView.mode === "rack") {
         if (node.assignedRack !== currentView.rackId) {
          return;
         }
        } else {
         if (node.assignedRack) {
          return;
         }
        }
        
        const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle", );
        circle.setAttribute("cx", pos.x);
        circle.setAttribute("cy", pos.y);
        circle.setAttribute("r", 40);
        circle.classList.add("minimap-node");
        minimapSvg.insertBefore(circle, minimapViewport);
       });
      }
      
      function zoomTo(newZoom, centerX, centerY) {
       const oldZoom = canvasState.zoom;
       newZoom = Math.max(canvasState.minZoom, Math.min(canvasState.maxZoom, newZoom), );
       if (centerX !== undefined && centerY !== undefined) {
        const oldWidth = CANVAS_WIDTH / oldZoom;
        const oldHeight = CANVAS_HEIGHT / oldZoom;
        const newWidth = CANVAS_WIDTH / newZoom;
        const newHeight = CANVAS_HEIGHT / newZoom;
        const pointX = canvasState.panX + centerX * oldWidth;
        const pointY = canvasState.panY + centerY * oldHeight;
        canvasState.panX = pointX - centerX * newWidth;
        canvasState.panY = pointY - centerY * newHeight;
       }
       canvasState.zoom = newZoom;
       constrainPan();
       updateViewBox();
      }
      
      function constrainPan() {
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       const minVisiblePortion = 0.1;
       const maxPanX = CANVAS_WIDTH - viewWidth * minVisiblePortion;
       const maxPanY = CANVAS_HEIGHT - viewHeight * minVisiblePortion;
       const minPanX = -viewWidth * (1 - minVisiblePortion);
       const minPanY = -viewHeight * (1 - minVisiblePortion);
       canvasState.panX = Math.max(minPanX, Math.min(maxPanX, canvasState.panX), );
       canvasState.panY = Math.max(minPanY, Math.min(maxPanY, canvasState.panY), );
      }
      
      function fitToContent() {
       const positions = Object.values(savedPositions);
       if (positions.length === 0) {
        resetView();
        return;
       }
       let minX = Infinity,
        minY = Infinity,
        maxX = -Infinity,
        maxY = -Infinity;
       positions.forEach((pos) => {
        minX = Math.min(minX, pos.x - 100);
        minY = Math.min(minY, pos.y - 100);
        maxX = Math.max(maxX, pos.x + 100);
        maxY = Math.max(maxY, pos.y + 100);
       });
       const contentWidth = maxX - minX + 200;
       const contentHeight = maxY - minY + 200;
       const viewport = document.getElementById("canvas-viewport");
       const vpRect = viewport.getBoundingClientRect();
       const aspectRatio = vpRect.width / vpRect.height;
       const contentAspect = contentWidth / contentHeight;
       let newZoom;
       if (contentAspect > aspectRatio) {
        newZoom = (vpRect.width / contentWidth) * (CANVAS_WIDTH / vpRect.width);
       } else {
        newZoom = (vpRect.height / contentHeight) * (CANVAS_HEIGHT / vpRect.height);
       }
       newZoom = Math.max(canvasState.minZoom, Math.min(2, newZoom));
       const viewWidth = CANVAS_WIDTH / newZoom;
       const viewHeight = CANVAS_HEIGHT / newZoom;
       canvasState.zoom = newZoom;
       canvasState.panX = minX - 100 - (viewWidth - contentWidth) / 2;
       canvasState.panY = minY - 100 - (viewHeight - contentHeight) / 2;
       constrainPan();
       updateViewBox();
      }
      
      function resetView() {
       canvasState.zoom = 1;
       canvasState.panX = 0;
       canvasState.panY = 0;
       updateViewBox();
      }
      window.addEventListener("DOMContentLoaded", () => {
       const toggle = document.getElementById("mobile-menu-toggle");
       const menu = document.getElementById("topbar-menu");
       if (!toggle || !menu) return;
       toggle.addEventListener("click", () => {
        menu.classList.toggle("open");
       });
       menu.addEventListener("click", (e) => {
        const target = e.target.closest("a, button");
        if (!target) return;
        if (isMobileDevice()) {
       menu.classList.remove("open");
      }
       });
       const minimapCloseBtn = document.getElementById("minimap-close-btn");
       if (minimapCloseBtn) {
        const handleMinimapClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         minimapCollapsed = true;
         updateMinimapVisibility();
        };
        minimapCloseBtn.addEventListener("click", handleMinimapClose);
        minimapCloseBtn.addEventListener("touchend", handleMinimapClose);
       }
       const drawToolbarCloseBtn = document.getElementById("draw-toolbar-close-btn");
       if (drawToolbarCloseBtn) {
        const handleDrawClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         drawToolbarCollapsed = true;
         updateDrawToolbarVisibility();
        };
        drawToolbarCloseBtn.addEventListener("click", handleDrawClose);
        drawToolbarCloseBtn.addEventListener("touchend", handleDrawClose);
       }
       const topologyToolbarCloseBtn = document.getElementById("topology-toolbar-close-btn");
       if (topologyToolbarCloseBtn) {
        const handleTopologyClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         topologyToolbarCollapsed = true;
         updateTopologyToolbarVisibility();
        };
        topologyToolbarCloseBtn.addEventListener("click", handleTopologyClose);
        topologyToolbarCloseBtn.addEventListener("touchstart", (e) => e.preventDefault(), {
         passive: false
        });
        topologyToolbarCloseBtn.addEventListener("touchend", handleTopologyClose);
       }
      
       updateMinimapVisibility();
       updateDrawToolbarVisibility();
       updateTopologyToolbarVisibility();
      });
      
      function applyLayerFilter() {

      
       activeLayers.clear();

      
       if (document.getElementById("layer-physical").checked) activeLayers.add("physical");

      
       if (document.getElementById("layer-logical").checked) activeLayers.add("logical");

      
       if (document.getElementById("layer-security").checked) activeLayers.add("security");

      
       if (document.getElementById("layer-application").checked) activeLayers.add("application");

      
       forgeTheTopology();

      
      }

      
      

      
      function isNodeVisible(nodeId) {

      
       const node = NODE_DATA[nodeId];

      
       if (!node) return false;

      
       const nodeLayer = node.layer || "physical";

      
       return activeLayers.has(nodeLayer);

      
      }

      
      

      
      function enterRack(rackId) {
       if (!NODE_DATA[rackId] || !NODE_DATA[rackId].isRack) return;
       
       savedTopologyView = {
        zoom: canvasState.zoom,
        panX: canvasState.panX,
        panY: canvasState.panY
       };
       
       currentView.mode = "rack";
       currentView.rackId = rackId;
       
       const backBtn = document.getElementById("back-to-topology-btn");
       if (backBtn) backBtn.style.display = "inline-block";
       
       const hint = document.getElementById("canvas-hint");
       if (hint) {
        hint.textContent = `Viewing: ${NODE_DATA[rackId].name} | Double-click empty space to exit`;
        hint.classList.add("visible");
       }
       
       const rackCapacity = getRackCapacity(rackId);
       const rackHeight = rackCapacity * RACK_U_HEIGHT;
       const rackCenterX = RACK_START_X;
       const rackCenterY = RACK_START_Y + (rackHeight / 2);
       
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       
       canvasState.panX = rackCenterX - (viewWidth / 2);
       canvasState.panY = rackCenterY - (viewHeight / 2);
       
       constrainPan();
       updateViewBox();
       
       forgeTheTopology();
      }
      
      function exitRack() {
       currentView.mode = "topology";
       currentView.rackId = null;
       
       const backBtn = document.getElementById("back-to-topology-btn");
       if (backBtn) backBtn.style.display = "none";
       
       const hint = document.getElementById("canvas-hint");
       if (hint) {
        hint.classList.remove("visible");
       }
       
       if (savedTopologyView) {
        canvasState.zoom = savedTopologyView.zoom;
        canvasState.panX = savedTopologyView.panX;
        canvasState.panY = savedTopologyView.panY;
        updateViewBox();
       }
       
       forgeTheTopology();
      }
      
      function getRackCapacity(rackId) {
       const node = NODE_DATA[rackId];
       return node && node.rackCapacity ? parseInt(node.rackCapacity) : 42;
      }
      
      function populateRackDropdown() {
       const dropdown = document.getElementById("node-assigned-rack");
       if (!dropdown) return;
       
       dropdown.innerHTML = '<option value="">None</option>';
       
       Object.keys(NODE_DATA).forEach(id => {
        if (NODE_DATA[id].isRack) {
         const option = document.createElement("option");
         option.value = id;
         option.textContent = NODE_DATA[id].name;
         dropdown.appendChild(option);
        }
       });
      }
      
      function wieldThePower() {
       const root = document.documentElement;
       root.style.setProperty("--panel", PAGE_STATE.panel);
       root.style.setProperty("--panel-alt", PAGE_STATE.panelAlt);
       root.style.setProperty("--accent", PAGE_STATE.accent);
       root.style.setProperty("--danger", PAGE_STATE.danger);
       root.style.setProperty("--text-main", PAGE_STATE.textMain);
       root.style.setProperty("--text-soft", PAGE_STATE.textSoft);
       root.style.setProperty("--topbar-bg", PAGE_STATE.topbarBg);
       root.style.setProperty("--topbar-border", PAGE_STATE.topbarBorder);
       const topbarHeight = PAGE_STATE.topbarHeight || 52;
       const sidebarWidth = PAGE_STATE.sidebarWidth || 350;
       const mobileFooterHeight = PAGE_STATE.mobileFooterHeight || 40;
       root.style.setProperty("--topbar-height", topbarHeight + "px");
       root.style.setProperty("--sidebar-width", sidebarWidth + "px");
       root.style.setProperty("--mobile-footer-height", mobileFooterHeight + "vh", );
       const mainEl = document.querySelector("main");
       const detailsPanel = document.getElementById("details-panel");
       const sidebarToggle = document.getElementById("sidebar-toggle");
       if (PAGE_STATE.sidebarCollapsed) {
        if (mainEl) mainEl.classList.add("sidebar-collapsed");
        if (detailsPanel) detailsPanel.classList.add("collapsed");
        if (sidebarToggle) {
         sidebarToggle.classList.add("collapsed");
         sidebarToggle.textContent = "â–¶";
        }
       } else {
        if (mainEl) mainEl.classList.remove("sidebar-collapsed");
        if (detailsPanel) detailsPanel.classList.remove("collapsed");
        if (sidebarToggle) {
         sidebarToggle.classList.remove("collapsed");
         sidebarToggle.textContent = "â—€";
        }
       }
       if (PAGE_STATE.background) {
        document.body.style.background = PAGE_STATE.background;
       } else {
        document.body.style.background = "radial-gradient(circle at top, #1e2532 0, #050608 70%)";
       }
       document.title = PAGE_STATE.title || DEFAULT_PAGE_STATE.title;
       const titleEl = document.getElementById("page-title");
       if (titleEl) {
        titleEl.textContent = PAGE_STATE.title || DEFAULT_PAGE_STATE.title;
       }
      }
      (async function awakeTheImmortal() {
       let initialState = {};
       let decryptionCancelled = false;
       const stateEl = document.getElementById("topology-state");
       if (stateEl && stateEl.textContent.trim()) {
        try {
         let stateText = stateEl.textContent.trim();
         if (isEncrypted(stateText)) {
          let decrypted = false;
          let attempts = 0;
          const maxAttempts = 3;
          while (!decrypted && attempts < maxAttempts) {
           const password = prompt("This file is encrypted. Enter password to decrypt:\n(Attempt " + (attempts + 1) + " of " + maxAttempts + ")", );
           if (!password) {
            alert("Decryption cancelled. The file will not be loaded.", );
            decryptionCancelled = true;
            break;
           }
           try {
            stateText = await decryptData(stateText, password);
            decrypted = true;
           } catch (e) {
            attempts++;
            if (attempts < maxAttempts) {
             alert("Incorrect password. Please try again.");
            } else {
             alert("Maximum attempts reached. The file will not be loaded.", );
             decryptionCancelled = true;
            }
           }
          }
          if (!decrypted) {
           stateText = "{}";
          }
         }
         initialState = JSON.parse(stateText);
        } catch (e) {
         console.error("Failed to load state:", e);
         initialState = {};
        }
       }
       if (decryptionCancelled) {
        NODE_DATA = {};
        EDGE_DATA = {
         list: []
        };
        RECT_DATA = { list: [] };
        TEXT_DATA = { list: [] };
        EDGE_LEGEND = {};
        savedPositions = {};
        savedSizes = {};
        savedStyles = {};
       } else {
        NODE_DATA = initialState.nodeData ? initialState.nodeData : BASE_NODE_DATA;
        
        Object.keys(NODE_DATA).forEach(nodeId => {
         if (!NODE_DATA[nodeId].ping) {
          NODE_DATA[nodeId].ping = {
           enabled: false,
           protocol: 'http',
           customUrl: '',
           timeout: 3000,
           status: 'unknown',
           lastCheck: null
          };
         }
        });
        
        EDGE_DATA = initialState.edgeData ? initialState.edgeData : {
         list: [],
        };
        RECT_DATA = initialState.rectData ? initialState.rectData : { list: [] };
        TEXT_DATA = initialState.textData ? initialState.textData : { list: [] };
        EDGE_LEGEND = initialState.edgeLegend || {};
        savedPositions = initialState.nodePositions || {};
        savedSizes = initialState.nodeSizes || {};
        savedStyles = initialState.nodeStyles || {};
        if (initialState.iconCache) {
         IconLibrary.iconCache = initialState.iconCache;
        }
       }
       if (initialState.page) {
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, initialState.page, );
       }
       
       if (PAGE_STATE.autoPingEnabled !== undefined) {
        autoPingEnabled = PAGE_STATE.autoPingEnabled;
       }
       if (PAGE_STATE.autoPingInterval !== undefined) {
        autoPingInterval = PAGE_STATE.autoPingInterval;
       }
       
       if (initialState.canvas) {
        canvasState.zoom = initialState.canvas.zoom || 1;
        canvasState.panX = initialState.canvas.panX || 0;
        canvasState.panY = initialState.canvas.panY || 0;
       }
       
       if (initialState.savedTopologyView) {
        savedTopologyView = initialState.savedTopologyView;
       }
       
       wieldThePower();
       forgeTheTopology();
       updateViewBox();
       
       MobileManager.applyAll();
       
       if (autoPingEnabled) {
        startAutoPing();
       }
       
       const initialNodes = Object.keys(NODE_DATA);
       if (initialNodes.length > 0) {
        claimTheImmortal(initialNodes.includes("host") ? "host" : initialNodes[0], );
       } else {
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.display = "none";
       }
      })();
      
      window.addEventListener("resize", () => {
        MobileManager.applyAll();
      });
      
      function saveEdgeData() {}
      
      function saveEdgeLegend() {}
      
      function getBreakpointKey() {
       const w = window.innerWidth;
       if (w <= 380) return "fold";
       if (w <= 768) return "mobile";
       if (w <= 1024) return "tablet";
       return "desktop";
      }
      
      function resolveStylesEntry(styleEntry) {
       if (!styleEntry) return {};
       if (styleEntry.circleColor || styleEntry.titleColor || styleEntry.titleFont || styleEntry.titleSize || styleEntry.subColor || styleEntry.subFont || styleEntry.subSize) {
        return styleEntry;
       }
       const bp = getBreakpointKey();
       const base = styleEntry.all || {};
       const bpStyles = styleEntry[bp] || {};
       return Object.assign({}, base, bpStyles);
      }
      
      function resolveStylesForNode(id) {
       const styleEntry = savedStyles[id];
       if (!styleEntry) return {};
       return resolveStylesEntry(styleEntry);
      }
      
      function ensureStyleEntry(id) {
       if (!savedStyles[id]) savedStyles[id] = {};
       const entry = savedStyles[id];
       const flatProps = ["circleColor", "titleColor", "titleFont", "titleSize", "subColor", "subFont", "subSize", ];
       const isFlat = flatProps.some((p) => Object.prototype.hasOwnProperty.call(entry, p), );
       if (isFlat) {
        const all = entry.all || {};
        flatProps.forEach((p) => {
         if (entry[p] !== undefined) {
          all[p] = entry[p];
          delete entry[p];
         }
        });
        entry.all = all;
       }
       return entry;
      }
      
      function getDefaultSize() {
       if (window.innerWidth <= 380) return 120;
       if (window.innerWidth <= 768) return 140;
       if (window.innerWidth <= 1024) return 70;
       return 55;
      }
      
      function createShapeElement(shape, size) {
       const ns = "http://www.w3.org/2000/svg";
       if (shape === "circle") {
        const c = document.createElementNS(ns, "circle");
        c.setAttribute("r", size);
        return c;
       }
       if (shape === "square") {
        const r = document.createElementNS(ns, "rect");
        const s = size * 2;
        r.setAttribute("x", -size);
        r.setAttribute("y", -size);
        r.setAttribute("width", s);
        r.setAttribute("height", s);
        r.setAttribute("rx", 4);
        return r;
       }
       if (shape === "rectangle") {
        const r = document.createElementNS(ns, "rect");
        r.setAttribute("x", -size * 1.4);
        r.setAttribute("y", -size * 0.8);
        r.setAttribute("width", size * 2.8);
        r.setAttribute("height", size * 1.6);
        r.setAttribute("rx", 6);
        return r;
       }
       if (shape === "triangle") {
        const p = document.createElementNS(ns, "polygon");
        const h = size * 1.8;
        const w = size * 2;
        p.setAttribute("points", `0,${-h} ${w / 2},${h / 2} ${-w / 2},${h / 2}`, );
        return p;
       }
       if (shape === "hexagon") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        const pts = [
         [0, -s],
         [s * 0.86, -s * 0.5],
         [s * 0.86, s * 0.5],
         [0, s],
         [-s * 0.86, s * 0.5],
         [-s * 0.86, -s * 0.5],
        ].map((pt) => pt.join(",")).join(" ");
        p.setAttribute("points", pts);
        return p;
       }
       if (shape === "stop-sign") {
        const p = document.createElementNS(ns, "polygon");
        const r = size;
        const ptsArr = [];
        for (let i = 0; i < 8; i++) {
         const a = (Math.PI / 4) * i + Math.PI / 8;
         ptsArr.push([Math.cos(a) * r, Math.sin(a) * r]);
        }
        const pts = ptsArr.map((pt) => pt.join(",")).join(" ");
        p.setAttribute("points", pts);
        return p;
       }
       if (shape === "star") {
        const p = document.createElementNS(ns, "polygon");
        const outer = size;
        const inner = size * 0.45;
        let pts = "";
        for (let i = 0; i < 10; i++) {
         const a = (Math.PI / 5) * i - Math.PI / 2;
         const r = i % 2 === 0 ? outer : inner;
         pts += `${Math.cos(a) * r},${Math.sin(a) * r} `;
        }
        p.setAttribute("points", pts.trim());
        return p;
       }
       if (shape === "diamond") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `0,${-s} ${s},0 0,${s} ${-s},0`);
        return p;
       }
       if (shape === "server") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.2);
        body.setAttribute("y", -size * 0.6);
        body.setAttribute("width", size * 2.4);
        body.setAttribute("height", size * 1.2);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 3; i++) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", -size * 0.9 + i * size * 0.5);
         line.setAttribute("y1", -size * 0.3);
         line.setAttribute("x2", -size * 0.9 + i * size * 0.5);
         line.setAttribute("y2", size * 0.3);
         line.style.stroke = "currentColor";
         line.style.strokeWidth = "2";
         line.style.opacity = "0.5";
         g.appendChild(line);
        }
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", size * 0.9);
        led.setAttribute("cy", 0);
        led.setAttribute("r", size * 0.1);
        led.style.fill = "#4ade80";
        g.appendChild(led);
        return g;
       }
       if (shape === "pc" || shape === "desktop") {
        const g = document.createElementNS(ns, "g");
        const monitor = document.createElementNS(ns, "rect");
        monitor.setAttribute("x", -size * 0.9);
        monitor.setAttribute("y", -size * 0.8);
        monitor.setAttribute("width", size * 1.8);
        monitor.setAttribute("height", size * 1.2);
        monitor.setAttribute("rx", 4);
        g.appendChild(monitor);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.75);
        screen.setAttribute("y", -size * 0.65);
        screen.setAttribute("width", size * 1.5);
        screen.setAttribute("height", size * 0.9);
        screen.setAttribute("rx", 2);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        const neck = document.createElementNS(ns, "rect");
        neck.setAttribute("x", -size * 0.15);
        neck.setAttribute("y", size * 0.4);
        neck.setAttribute("width", size * 0.3);
        neck.setAttribute("height", size * 0.3);
        g.appendChild(neck);
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.5);
        base.setAttribute("y", size * 0.7);
        base.setAttribute("width", size * 1);
        base.setAttribute("height", size * 0.15);
        base.setAttribute("rx", 2);
        g.appendChild(base);
        return g;
       }
       if (shape === "laptop") {
        const g = document.createElementNS(ns, "g");
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.8);
        screen.setAttribute("y", -size * 0.9);
        screen.setAttribute("width", size * 1.6);
        screen.setAttribute("height", size * 1.1);
        screen.setAttribute("rx", 4);
        g.appendChild(screen);
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.9);
        base.setAttribute("y", size * 0.25);
        base.setAttribute("width", size * 1.8);
        base.setAttribute("height", size * 0.6);
        base.setAttribute("rx", 4);
        g.appendChild(base);
        const pad = document.createElementNS(ns, "rect");
        pad.setAttribute("x", -size * 0.25);
        pad.setAttribute("y", size * 0.45);
        pad.setAttribute("width", size * 0.5);
        pad.setAttribute("height", size * 0.25);
        pad.setAttribute("rx", 2);
        pad.style.fill = "#1e293b";
        g.appendChild(pad);
        return g;
       }
       if (shape === "phone" || shape === "mobile") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.45);
        body.setAttribute("y", -size);
        body.setAttribute("width", size * 0.9);
        body.setAttribute("height", size * 2);
        body.setAttribute("rx", 8);
        g.appendChild(body);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.38);
        screen.setAttribute("y", -size * 0.85);
        screen.setAttribute("width", size * 0.76);
        screen.setAttribute("height", size * 1.6);
        screen.setAttribute("rx", 4);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        const btn = document.createElementNS(ns, "rect");
        btn.setAttribute("x", -size * 0.15);
        btn.setAttribute("y", size * 0.82);
        btn.setAttribute("width", size * 0.3);
        btn.setAttribute("height", size * 0.06);
        btn.setAttribute("rx", 2);
        btn.style.fill = "#475569";
        g.appendChild(btn);
        return g;
       }
       if (shape === "router") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.1);
        body.setAttribute("y", -size * 0.3);
        body.setAttribute("width", size * 2.2);
        body.setAttribute("height", size * 0.8);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        for (let i = -1; i <= 1; i++) {
         const ant = document.createElementNS(ns, "rect");
         ant.setAttribute("x", i * size * 0.6 - size * 0.05);
         ant.setAttribute("y", -size * 0.9);
         ant.setAttribute("width", size * 0.1);
         ant.setAttribute("height", size * 0.6);
         ant.setAttribute("rx", 2);
         g.appendChild(ant);
         const tip = document.createElementNS(ns, "circle");
         tip.setAttribute("cx", i * size * 0.6);
         tip.setAttribute("cy", -size * 0.95);
         tip.setAttribute("r", size * 0.08);
         g.appendChild(tip);
        }
        for (let i = 0; i < 4; i++) {
         const led = document.createElementNS(ns, "circle");
         led.setAttribute("cx", -size * 0.7 + i * size * 0.35);
         led.setAttribute("cy", size * 0.1);
         led.setAttribute("r", size * 0.06);
         led.style.fill = i < 2 ? "#4ade80" : "#facc15";
         g.appendChild(led);
        }
        return g;
       }
       if (shape === "switch") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.4);
        body.setAttribute("y", -size * 0.4);
        body.setAttribute("width", size * 2.8);
        body.setAttribute("height", size * 0.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 8; i++) {
         const port = document.createElementNS(ns, "rect");
         port.setAttribute("x", -size * 1.2 + i * size * 0.32);
         port.setAttribute("y", -size * 0.15);
         port.setAttribute("width", size * 0.22);
         port.setAttribute("height", size * 0.3);
         port.setAttribute("rx", 1);
         port.style.fill = "#1e293b";
         g.appendChild(port);
        }
        return g;
       }
       if (shape === "firewall") {
        const g = document.createElementNS(ns, "g");
        const wall = document.createElementNS(ns, "rect");
        wall.setAttribute("x", -size);
        wall.setAttribute("y", -size * 0.8);
        wall.setAttribute("width", size * 2);
        wall.setAttribute("height", size * 1.6);
        wall.setAttribute("rx", 4);
        g.appendChild(wall);
        for (let row = 0; row < 3; row++) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", -size * 0.85);
         line.setAttribute("y1", -size * 0.5 + row * size * 0.45);
         line.setAttribute("x2", size * 0.85);
         line.setAttribute("y2", -size * 0.5 + row * size * 0.45);
         line.style.stroke = "#475569";
         line.style.strokeWidth = "2";
         g.appendChild(line);
        }
        for (let row = 0; row < 4; row++) {
         const offset = row % 2 === 0 ? 0 : size * 0.35;
         for (let col = 0; col < 3; col++) {
          const line = document.createElementNS(ns, "line");
          const x = -size * 0.5 + col * size * 0.7 + offset;
          if (x > -size * 0.85 && x < size * 0.85) {
           line.setAttribute("x1", x);
           line.setAttribute("y1", -size * 0.8 + row * size * 0.45, );
           line.setAttribute("x2", x);
           line.setAttribute("y2", -size * 0.8 + row * size * 0.45 + size * 0.45, );
           line.style.stroke = "#475569";
           line.style.strokeWidth = "2";
           g.appendChild(line);
          }
         }
        }
        return g;
       }
       if (shape === "cloud") {
        const p = document.createElementNS(ns, "path");
        const s = size;
        p.setAttribute("d", `
             M ${-s * 0.8} ${s * 0.2}
             Q ${-s * 1.1} ${s * 0.2} ${-s * 1.1} ${-s * 0.1}
             Q ${-s * 1.1} ${-s * 0.5} ${-s * 0.7} ${-s * 0.5}
             Q ${-s * 0.7} ${-s * 0.9} ${-s * 0.2} ${-s * 0.9}
             Q ${s * 0.1} ${-s * 1.1} ${s * 0.5} ${-s * 0.8}
             Q ${s * 1} ${-s * 0.8} ${s * 1.1} ${-s * 0.3}
             Q ${s * 1.3} ${-s * 0.1} ${s * 1.1} ${s * 0.2}
             Q ${s * 1.1} ${s * 0.5} ${s * 0.7} ${s * 0.5}
             L ${-s * 0.5} ${s * 0.5}
             Q ${-s * 0.9} ${s * 0.5} ${-s * 0.9} ${s * 0.2}
             Z
            `, );
        return p;
       }
       if (shape === "database") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.7);
        body.setAttribute("y", -size * 0.6);
        body.setAttribute("width", size * 1.4);
        body.setAttribute("height", size * 1.4);
        g.appendChild(body);
        const top = document.createElementNS(ns, "ellipse");
        top.setAttribute("cx", 0);
        top.setAttribute("cy", -size * 0.6);
        top.setAttribute("rx", size * 0.7);
        top.setAttribute("ry", size * 0.25);
        g.appendChild(top);
        const bottom = document.createElementNS(ns, "ellipse");
        bottom.setAttribute("cx", 0);
        bottom.setAttribute("cy", size * 0.8);
        bottom.setAttribute("rx", size * 0.7);
        bottom.setAttribute("ry", size * 0.25);
        g.appendChild(bottom);
        const mid1 = document.createElementNS(ns, "ellipse");
        mid1.setAttribute("cx", 0);
        mid1.setAttribute("cy", -size * 0.15);
        mid1.setAttribute("rx", size * 0.7);
        mid1.setAttribute("ry", size * 0.2);
        mid1.style.fill = "none";
        mid1.style.stroke = "#475569";
        mid1.style.strokeWidth = "2";
        g.appendChild(mid1);
        const mid2 = document.createElementNS(ns, "ellipse");
        mid2.setAttribute("cx", 0);
        mid2.setAttribute("cy", size * 0.35);
        mid2.setAttribute("rx", size * 0.7);
        mid2.setAttribute("ry", size * 0.2);
        mid2.style.fill = "none";
        mid2.style.stroke = "#475569";
        mid2.style.strokeWidth = "2";
        g.appendChild(mid2);
        return g;
       }
       if (shape === "printer") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.4);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size * 0.9);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const trayTop = document.createElementNS(ns, "rect");
        trayTop.setAttribute("x", -size * 0.7);
        trayTop.setAttribute("y", -size * 0.8);
        trayTop.setAttribute("width", size * 1.4);
        trayTop.setAttribute("height", size * 0.4);
        trayTop.setAttribute("rx", 2);
        trayTop.style.fill = "#1e293b";
        g.appendChild(trayTop);
        const trayOut = document.createElementNS(ns, "rect");
        trayOut.setAttribute("x", -size * 0.6);
        trayOut.setAttribute("y", size * 0.5);
        trayOut.setAttribute("width", size * 1.2);
        trayOut.setAttribute("height", size * 0.35);
        trayOut.setAttribute("rx", 2);
        g.appendChild(trayOut);
        const paper = document.createElementNS(ns, "rect");
        paper.setAttribute("x", -size * 0.5);
        paper.setAttribute("y", size * 0.3);
        paper.setAttribute("width", size * 1);
        paper.setAttribute("height", size * 0.5);
        paper.style.fill = "#e2e8f0";
        g.appendChild(paper);
        return g;
       }
       const c = document.createElementNS(ns, "circle");
       c.setAttribute("r", size);
       return c;
      }
      
      function createNodeShape(id, size) {
       const styles = resolveStylesForNode(id);
       if (styles.icon && styles.icon.library && styles.icon.name) {
        const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
        g.classList.add("node-circle");
        IconLibrary.getIcon(styles.icon.library, styles.icon.name).then(svgText => {
         if (svgText) {
          const parser = new DOMParser();
          const doc = parser.parseFromString(svgText, 'image/svg+xml');
          const svgEl = doc.querySelector('svg');
          if (svgEl) {
           svgEl.setAttribute('width', size * 1.2);
           svgEl.setAttribute('height', size * 1.2);
           svgEl.setAttribute('x', -size * 0.6);
           svgEl.setAttribute('y', -size * 0.6);
           if (styles.circleColor) {
            svgEl.style.fill = styles.circleColor;
           }
           g.innerHTML = svgEl.outerHTML;
          }
         }
        });
        return g;
       }
       const shapeType = (NODE_DATA[id] && NODE_DATA[id].shape) || "circle";
       const shapeEl = createShapeElement(shapeType, size);
       shapeEl.classList.add("node-circle");
       if (styles.circleColor) {
        shapeEl.style.stroke = styles.circleColor;
       }
       return shapeEl;
      }
      
      function forgeTheLegend() {
       const container = document.getElementById("edge-legend");
       if (!container) return;
       container.innerHTML = "";
       const title = document.createElement("div");
       title.className = "legend-title";
       title.textContent = "Line Legend";
       container.appendChild(title);
       const closeBtn = document.createElement("button");
       closeBtn.type = "button";
       closeBtn.className = "legend-close-btn";
       closeBtn.textContent = "âœ•";
       closeBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        legendCollapsed = true;
        updateLegendVisibility();
       });
       container.appendChild(closeBtn);
       const colors = [...new Set(EDGE_DATA.list.map((e) => e.color).filter(Boolean))];
       if (colors.length === 0) {
        updateLegendVisibility();
        return;
       }
       colors.forEach((color) => {
         if (!EDGE_LEGEND[color]) {
          EDGE_LEGEND[color] = "you can edit me too";
         }
         const item = document.createElement("div");
         item.className = "legend-item";
         item.addEventListener("mousedown", (e) => e.stopPropagation());
         item.addEventListener("click", (e) => e.stopPropagation());
         const swatch = document.createElement("span");
         swatch.className = "legend-swatch";
         swatch.style.backgroundColor = color;
         swatch.style.cursor = "pointer";
         swatch.addEventListener("click", (e) => {
          e.stopPropagation();
          const edgeWithColor = EDGE_DATA.list.find(edge => edge.color === color);
          if (edgeWithColor) {
           selectTheConnection(edgeWithColor.id);
          }
         });
         let swatchTouchStart = null;
         let swatchTouchMoved = false;
         swatch.addEventListener("touchstart", (e) => {
          swatchTouchStart = Date.now();
          swatchTouchMoved = false;
         }, {
          passive: false
         });
         swatch.addEventListener("touchmove", (e) => {
          swatchTouchMoved = true;
         }, {
          passive: false
         });
         swatch.addEventListener("touchend", (e) => {
          if (swatchTouchStart && !swatchTouchMoved && Date.now() - swatchTouchStart < 400) {
           e.stopPropagation();
           e.preventDefault();
           const edgeWithColor = EDGE_DATA.list.find(edge => edge.color === color);
           if (edgeWithColor) {
            selectTheConnection(edgeWithColor.id);
           }
          }
          swatchTouchStart = null;
          swatchTouchMoved = false;
         }, {
          passive: false
         });
        const label = document.createElement("span");
        label.className = "legend-label";
        label.textContent = EDGE_LEGEND[color];
        if (isMobileDevice()) {
         label.style.cursor = "pointer";
         let labelTapStart = null;
         let labelTapMoved = false;
         label.addEventListener("touchstart", (e) => {
          labelTapStart = Date.now();
          labelTapMoved = false;
          e.stopPropagation();
         });
         label.addEventListener("touchmove", (e) => {
          labelTapMoved = true;
         });
         label.addEventListener("touchend", (e) => {
          if (labelTapStart && !labelTapMoved && Date.now() - labelTapStart < 400) {
           e.preventDefault();
           e.stopPropagation();
           const currentText = label.textContent;
           const newText = prompt("Edit legend label:", currentText);
           if (newText !== null && newText.trim()) {
            label.textContent = newText.trim();
            EDGE_LEGEND[color] = newText.trim();
            saveEdgeLegend();
           }
          }
          labelTapStart = null;
          labelTapMoved = false;
         });
        } else {
           label.contentEditable = true;
           label.addEventListener("focus", () => {
            label.classList.add("editing");
           });
           label.addEventListener("blur", () => {
            label.classList.remove("editing");
            const text = label.textContent.trim() || "you can edit me too";
            EDGE_LEGEND[color] = text;
            saveEdgeLegend();
           });
           label.addEventListener("keydown", (e) => {
            if (e.key === "Enter") {
             e.preventDefault();
             label.blur();
            }
           });
          }
          item.append(swatch, label); container.appendChild(item);
         }); updateLegendVisibility();
       }
      
       function deleteRectangle(rectId) {
	    pushUndo("delete rectangle");
        RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== rectId);
        forgeTheTopology();
       }
      
       function updateRectangleDeleteButtons() {
        const deleteButtons = document.querySelectorAll('.rect-delete-btn');
        deleteButtons.forEach(btn => {
         btn.style.display = rectDrawMode ? 'block' : 'none';
        });
       }
      
      
       function forgeTheTopology() {
        if (!NODE_DATA || !EDGE_DATA) {
         console.warn("forgeTheTopology called before data initialized");
         return;
        }
        const svg = document.getElementById("map");
        svg.innerHTML = "";
        const ns = "http://www.w3.org/2000/svg";
        const defs = document.createElementNS(ns, "defs");
        const markerForward = document.createElementNS(ns, "marker");
        markerForward.id = "arrow-forward";
        markerForward.setAttribute("markerWidth", "10");
        markerForward.setAttribute("markerHeight", "10");
        markerForward.setAttribute("refX", "9");
        markerForward.setAttribute("refY", "3");
        markerForward.setAttribute("orient", "auto");
        markerForward.setAttribute("markerUnits", "strokeWidth");
        const pathForward = document.createElementNS(ns, "path");
        pathForward.setAttribute("d", "M0,0 L0,6 L9,3 z");
        pathForward.setAttribute("fill", "context-stroke");
        markerForward.appendChild(pathForward);
        defs.appendChild(markerForward);
        const markerBackward = document.createElementNS(ns, "marker");
        markerBackward.id = "arrow-backward";
        markerBackward.setAttribute("markerWidth", "10");
        markerBackward.setAttribute("markerHeight", "10");
        markerBackward.setAttribute("refX", "0");
        markerBackward.setAttribute("refY", "3");
        markerBackward.setAttribute("orient", "auto");
        markerBackward.setAttribute("markerUnits", "strokeWidth");
        const pathBackward = document.createElementNS(ns, "path");
        pathBackward.setAttribute("d", "M9,0 L9,6 L0,3 z");
        pathBackward.setAttribute("fill", "context-stroke");
        markerBackward.appendChild(pathBackward);
        defs.appendChild(markerBackward);
        svg.appendChild(defs);
        const boundary = document.createElementNS(ns, "rect");
        boundary.setAttribute("x", CANVAS_PADDING);
        boundary.setAttribute("y", CANVAS_PADDING);
        boundary.setAttribute("width", CANVAS_WIDTH - CANVAS_PADDING * 2);
        boundary.setAttribute("height", CANVAS_HEIGHT - CANVAS_PADDING * 2);
        boundary.setAttribute("fill", "none");
        boundary.setAttribute("stroke", "rgba(71, 85, 105, 0.3)");
        boundary.setAttribute("stroke-width", "2");
        boundary.setAttribute("stroke-dasharray", "10 5");
        boundary.setAttribute("rx", "8");
        svg.appendChild(boundary);
        
        if (currentView.mode === "rack" && currentView.rackId) {
         const rackCapacity = getRackCapacity(currentView.rackId);
         const rackGroup = document.createElementNS(ns, "g");
         rackGroup.id = "rack-visualization";
         
         const rackFrame = document.createElementNS(ns, "rect");
         rackFrame.setAttribute("x", RACK_START_X - RACK_WIDTH / 2);
         rackFrame.setAttribute("y", RACK_START_Y);
         rackFrame.setAttribute("width", RACK_WIDTH);
         rackFrame.setAttribute("height", rackCapacity * RACK_U_HEIGHT);
         rackFrame.setAttribute("fill", "rgba(15, 23, 42, 0.3)");
         rackFrame.setAttribute("stroke", "var(--accent)");
         rackFrame.setAttribute("stroke-width", "3");
         rackFrame.setAttribute("rx", "4");
         rackGroup.appendChild(rackFrame);
         
         for (let u = 0; u <= rackCapacity; u++) {
          const y = RACK_START_Y + u * RACK_U_HEIGHT;
          
          const line = document.createElementNS(ns, "line");
          line.setAttribute("x1", RACK_START_X - RACK_WIDTH / 2);
          line.setAttribute("y1", y);
          line.setAttribute("x2", RACK_START_X + RACK_WIDTH / 2);
          line.setAttribute("y2", y);
          line.setAttribute("stroke", "rgba(71, 85, 105, 0.4)");
          line.setAttribute("stroke-width", u % 5 === 0 ? "2" : "1");
          line.setAttribute("stroke-dasharray", u % 5 === 0 ? "none" : "5,5");
          rackGroup.appendChild(line);
          
          if (u < rackCapacity) {
           const uNumber = rackCapacity - u;
           const text = document.createElementNS(ns, "text");
           text.setAttribute("x", RACK_START_X - RACK_WIDTH / 2 - 30);
           text.setAttribute("y", y + RACK_U_HEIGHT / 2);
           text.setAttribute("text-anchor", "middle");
           text.setAttribute("dominant-baseline", "middle");
           text.style.fill = "var(--accent)";
           text.style.fontSize = "14px";
           text.style.fontWeight = "bold";
           text.textContent = `U${uNumber}`;
           rackGroup.appendChild(text);
           
           const textRight = document.createElementNS(ns, "text");
           textRight.setAttribute("x", RACK_START_X + RACK_WIDTH / 2 + 30);
           textRight.setAttribute("y", y + RACK_U_HEIGHT / 2);
           textRight.setAttribute("text-anchor", "middle");
           textRight.setAttribute("dominant-baseline", "middle");
           textRight.style.fill = "var(--accent)";
           textRight.style.fontSize = "14px";
           textRight.style.fontWeight = "bold";
           textRight.textContent = `U${uNumber}`;
           rackGroup.appendChild(textRight);
          }
         }
         
         svg.appendChild(rackGroup);
        }
        
        const centerX = CANVAS_WIDTH / 2;
      
        if (RECT_DATA && RECT_DATA.list) {
         RECT_DATA.list.forEach((rect) => {
          if (currentView.mode === "rack") return;
          
          if (rect.style === "filled") {
           const g = document.createElementNS(ns, "g");
           g.classList.add("rect-group");
           g.dataset.rectId = rect.id;
           
           const rectEl = document.createElementNS(ns, "rect");
           rectEl.classList.add("rect-shape");
           rectEl.setAttribute("x", rect.x);
           rectEl.setAttribute("y", rect.y);
           rectEl.setAttribute("width", rect.width);
           rectEl.setAttribute("height", rect.height);
           rectEl.style.fill = rect.color;
           rectEl.style.fillOpacity = "0.3";
           rectEl.style.stroke = rect.color;
           rectEl.style.strokeWidth = "2";
           rectEl.style.cursor = "move";
           
           const deleteBtn = document.createElementNS(ns, "g");
           deleteBtn.classList.add("rect-delete-btn");
           deleteBtn.style.cursor = "pointer";
           deleteBtn.style.display = rectDrawMode ? "block" : "none";
           
           const deleteBg = document.createElementNS(ns, "circle");
           deleteBg.setAttribute("cx", rect.x + rect.width - 10);
           deleteBg.setAttribute("cy", rect.y + 10);
           deleteBg.setAttribute("r", 12);
           deleteBg.style.fill = "#f56565";
           deleteBg.style.stroke = "white";
           deleteBg.style.strokeWidth = "2";
           
           const deleteX = document.createElementNS(ns, "text");
           deleteX.setAttribute("x", rect.x + rect.width - 10);
           deleteX.setAttribute("y", rect.y + 10);
           deleteX.setAttribute("text-anchor", "middle");
           deleteX.setAttribute("dominant-baseline", "middle");
           deleteX.style.fill = "white";
           deleteX.style.fontSize = "16px";
           deleteX.style.fontWeight = "bold";
           deleteX.style.pointerEvents = "none";
           deleteX.textContent = "Ã—";
           
           deleteBtn.appendChild(deleteBg);
           deleteBtn.appendChild(deleteX);
           
           deleteBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            e.preventDefault();
            deleteRectangle(rect.id);
           });
           
           deleteBtn.addEventListener("touchend", (e) => {
		   e.stopPropagation();
           e.preventDefault();
           deleteRectangle(rect.id);
           });

           let isDragging = false;
           let dragStartX, dragStartY;
           let rectStartX, rectStartY;
           
           rectEl.addEventListener("mousedown", (e) => {
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            dragStartX = e.clientX;
            dragStartY = e.clientY;
            rectStartX = rect.x;
            rectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           });
           
           const moveHandler = (e) => {
            if (!isDragging || rectDrawMode) return;
            const svgEl = svg;
            const pt1 = svgEl.createSVGPoint();
            pt1.x = dragStartX;
            pt1.y = dragStartY;
            const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
            
            const pt2 = svgEl.createSVGPoint();
            pt2.x = e.clientX;
            pt2.y = e.clientY;
            const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
            
            const dx = svgP2.x - svgP1.x;
            const dy = svgP2.y - svgP1.y;
            
            rect.x = rectStartX + dx;
            rect.y = rectStartY + dy;
            
            forgeTheTopology();
           };
           
           const upHandler = () => {
            if (isDragging) {
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           };
           
           document.addEventListener("mousemove", moveHandler);
           document.addEventListener("mouseup", upHandler);
           
           let touchStartX, touchStartY;
           let touchRectStartX, touchRectStartY;
           
           rectEl.addEventListener("touchstart", (e) => {
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchRectStartX = rect.x;
            touchRectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           }, { passive: false });
           
           rectEl.addEventListener("touchmove", (e) => {
            if (!isDragging || rectDrawMode) return;
            if (!e.touches[0]) return;
            e.preventDefault();
            e.stopPropagation();
            
            const svgEl = svg;
            const pt1 = svgEl.createSVGPoint();
            pt1.x = touchStartX;
            pt1.y = touchStartY;
            const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
            
            const touch = e.touches[0];
            const pt2 = svgEl.createSVGPoint();
            pt2.x = touch.clientX;
            pt2.y = touch.clientY;
            const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
            
            const dx = svgP2.x - svgP1.x;
            const dy = svgP2.y - svgP1.y;
            
            rect.x = touchRectStartX + dx;
            rect.y = touchRectStartY + dy;
            
            forgeTheTopology();
           }, { passive: false });
           
           rectEl.addEventListener("touchend", (e) => {
            if (isDragging) {
             e.preventDefault();
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           }, { passive: false });
           
           g.appendChild(rectEl);
           g.appendChild(deleteBtn);
           svg.appendChild(g);
          }
         });
        }
        const centerY = CANVAS_HEIGHT / 2;
        let positions = {};
        
        Object.keys(NODE_DATA).forEach((id) => {
         if (currentView.mode === "rack") {
          const node = NODE_DATA[id];
          if (!node || node.assignedRack !== currentView.rackId) {
           return;
          }
         }
         
         positions[id] = savedPositions[id] || {
          x: centerX,
          y: centerY
         };
        });
        if (Object.keys(savedPositions).length === 0) {
         const nodeIds = Object.keys(NODE_DATA).filter(id => {
          if (currentView.mode === "rack") {
           const node = NODE_DATA[id];
           return node && node.assignedRack === currentView.rackId;
          }
          return true;
         });
         
         const baseY = centerY - 300;
         if (nodeIds.length > 0) {
          positions[nodeIds[0]] = {
           x: centerX,
           y: baseY
          };
          const remaining = nodeIds.slice(1);
          const radius = 350;
          const startAngle = Math.PI * 0.3;
          const endAngle = Math.PI * 0.7;
          remaining.forEach((id, i) => {
           const angle = startAngle + (endAngle - startAngle) * (i / Math.max(1, remaining.length - 1));
           positions[id] = {
            x: centerX + Math.cos(angle) * radius * (i % 2 === 0 ? 1 : 1.3),
            y: baseY + 200 + Math.sin(angle) * radius * 0.8 + i * 80,
           };
          });
         }
        }
        Object.keys(positions).forEach((id) => {
         let pos = savedPositions[id] || positions[id];
         const nodeSize = savedSizes[id] || 55;
         pos.x = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, pos.x), );
         pos.y = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, pos.y), );
         positions[id] = {
          x: pos.x,
          y: pos.y
         };
         savedPositions[id] = {
          x: pos.x,
          y: pos.y
         };
        });
        const edgePairCount = {};
        const edgePairIndex = {};
        EDGE_DATA.list.forEach((edge) => {
         if (edge.type === "custom") return;
         const key = [edge.from, edge.to].sort().join("||");
         edgePairCount[key] = (edgePairCount[key] || 0) + 1;
        });
        EDGE_DATA.list.forEach((edge) => {
         if (edge.type === "custom") return;
         const key = [edge.from, edge.to].sort().join("||");
         if (!edgePairIndex[key]) edgePairIndex[key] = 0;
         edge._pairIndex = edgePairIndex[key];
         edge._pairTotal = edgePairCount[key];
         edgePairIndex[key]++;
        });
        EDGE_DATA.list.forEach((edge) => {
         if (edge.type === "custom" && Array.isArray(edge.points) && edge.points.length >= 2) {
          const poly = document.createElementNS(ns, "polyline");
          poly.classList.add("edge");
          poly.dataset.edgeId = edge.id;
          poly.style.stroke = edge.color || "#475569";
          poly.style.strokeWidth = edge.width || 4;
          poly.setAttribute("fill", "none");
          const lineStyle = edge.lineStyle || "solid";
          if (lineStyle === "dashed") {
           poly.style.strokeDasharray = "10,5";
          } else if (lineStyle === "dotted") {
           poly.style.strokeDasharray = "2,4";
          } else {
           poly.style.strokeDasharray = "none";
          }
          const direction = edge.direction || "none";
          if (direction === "forward") {
           poly.setAttribute("marker-end", "url(#arrow-forward)");
          } else if (direction === "backward") {
           poly.setAttribute("marker-start", "url(#arrow-backward)");
          } else if (direction === "both") {
           poly.setAttribute("marker-start", "url(#arrow-backward)");
           poly.setAttribute("marker-end", "url(#arrow-forward)");
          }
          const ptsStr = edge.points.map((p) => `${p.x},${p.y}`).join(" ");
          poly.setAttribute("points", ptsStr);
          const polyHit = document.createElementNS(ns, "polyline");
          polyHit.setAttribute("points", ptsStr);
          polyHit.style.fill = "none";
          polyHit.style.stroke = "transparent";
          polyHit.style.strokeWidth = "20";
          polyHit.style.cursor = "pointer";
          polyHit.dataset.edgeId = edge.id;
          polyHit.addEventListener("click", (e) => {
           e.stopPropagation();
           selectTheConnection(edge.id);
          });
          let edgeTouchStart = null;
          let edgeTouchMoved = false;
          polyHit.addEventListener("touchstart", (e) => {
           edgeTouchStart = Date.now();
           edgeTouchMoved = false;
          }, {
           passive: false
          });
          polyHit.addEventListener("touchmove", (e) => {
           edgeTouchMoved = true;
          }, {
           passive: false
          });
          polyHit.addEventListener("touchend", (e) => {
           if (edgeTouchStart && !edgeTouchMoved && Date.now() - edgeTouchStart < 400) {
            e.stopPropagation();
            e.preventDefault();
            selectTheConnection(edge.id);
           }
           edgeTouchStart = null;
           edgeTouchMoved = false;
          }, {
           passive: false
          });
          poly.addEventListener("click", (e) => {
           e.stopPropagation();
           selectTheConnection(edge.id);
          });
          
          if (currentView.mode === "rack") {
           return;
          }
          
          svg.appendChild(poly);
          svg.appendChild(polyHit);
          return;
         }
         const p1 = positions[edge.from];
         const p2 = positions[edge.to];
         if (!p1 || !p2) return;
         const pairTotal = edge._pairTotal || 1;
         const pairIndex = edge._pairIndex || 0;
         const midX = (p1.x + p2.x) / 2;
         const midY = (p1.y + p2.y) / 2;
         const dx = p2.x - p1.x;
         const dy = p2.y - p1.y;
         const len = Math.sqrt(dx * dx + dy * dy) || 1;
         const perpX = -dy / len;
         const perpY = dx / len;
         let offsetAmount = 0;
         if (pairTotal > 1) {
          offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
         }
         const ctrlX = midX + perpX * offsetAmount;
         const ctrlY = midY + perpY * offsetAmount;
         const path = document.createElementNS(ns, "path");
         path.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
         path.setAttribute("fill", "none");
         path.classList.add("edge");
         if (edge.type === "backup") path.classList.add("backup");
         path.dataset.edgeId = edge.id;
         path.dataset.from = edge.from;
         path.dataset.to = edge.to;
         path.style.stroke = edge.color;
         path.style.strokeWidth = edge.width;
         const pathHit = document.createElementNS(ns, "path");
         pathHit.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
         pathHit.setAttribute("fill", "none");
         pathHit.style.stroke = "transparent";
         pathHit.style.strokeWidth = "20";
         pathHit.style.cursor = "pointer";
         pathHit.dataset.edgeId = edge.id;
         pathHit.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         let pathTouchStart = null;
         let pathTouchMoved = false;
         pathHit.addEventListener("touchstart", (e) => {
          pathTouchStart = Date.now();
          pathTouchMoved = false;
         }, {
          passive: false
         });
         pathHit.addEventListener("touchmove", (e) => {
          pathTouchMoved = true;
         }, {
          passive: false
         });
         pathHit.addEventListener("touchend", (e) => {
          if (pathTouchStart && !pathTouchMoved && Date.now() - pathTouchStart < 400) {
           e.stopPropagation();
           e.preventDefault();
           selectTheConnection(edge.id);
          }
          pathTouchStart = null;
          pathTouchMoved = false;
         }, {
          passive: false
         });
         path.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         
         if (currentView.mode === "rack") {
          const fromNode = NODE_DATA[edge.from];
          const toNode = NODE_DATA[edge.to];
          if (!fromNode || !toNode || 
              fromNode.assignedRack !== currentView.rackId || 
              toNode.assignedRack !== currentView.rackId) {
           return;
          }
         }
         
         svg.appendChild(path);
         svg.appendChild(pathHit);
         
         if (edge.fromPort || edge.toPort) {
          const ns = "http://www.w3.org/2000/svg";
          
          if (edge.fromPort) {
           const fromLabel = document.createElementNS(ns, "text");
           fromLabel.textContent = edge.fromPort;
           fromLabel.setAttribute("x", p1.x);
           fromLabel.setAttribute("y", p1.y - 10);
           fromLabel.setAttribute("text-anchor", "middle");
           fromLabel.style.fill = "#94a3b8";
           fromLabel.style.fontSize = "12px";
           fromLabel.style.fontWeight = "600";
           fromLabel.style.pointerEvents = "none";
           fromLabel.classList.add("port-label");
           svg.appendChild(fromLabel);
          }
      
          if (edge.toPort) {
           const toLabel = document.createElementNS(ns, "text");
           toLabel.textContent = edge.toPort;
           toLabel.setAttribute("x", p2.x);
           toLabel.setAttribute("y", p2.y - 10);
           toLabel.setAttribute("text-anchor", "middle");
           toLabel.style.fill = "#94a3b8";
           toLabel.style.fontSize = "12px";
           toLabel.style.fontWeight = "600";
           toLabel.style.pointerEvents = "none";
           toLabel.classList.add("port-label");
           svg.appendChild(toLabel);
          }
         }
        });
        Object.entries(positions).forEach(([id, pos]) => {
         const node = NODE_DATA[id];
         if (!node) return;
         
         if (currentView.mode === "rack") {
          if (node.assignedRack !== currentView.rackId) return;
          
          const rackUnit = parseInt(node.rackUnit) || 1;
          const uHeight = parseInt(node.uHeight) || 1;
          const rackCapacity = getRackCapacity(currentView.rackId);
          pos.x = RACK_START_X;
          pos.y = RACK_START_Y + (rackUnit - 1) * RACK_U_HEIGHT + (uHeight * RACK_U_HEIGHT) / 2;
         } else {
          if (node.assignedRack) return;
         }
         
         const g = document.createElementNS("http://www.w3.org/2000/svg", "g", );
         g.classList.add("node-group");
         g.dataset.nodeId = id;
         g.setAttribute("transform", `translate(${pos.x},${pos.y})`);
         let r = savedSizes[id] || 55;
         if (!savedSizes[id]) {
          if (window.innerWidth <= 380) r = 120;
          else if (window.innerWidth <= 768) r = 140;
          else if (window.innerWidth <= 1024) r = 70;
         }
         const styles = resolveStylesForNode(id);
         const ns = "http://www.w3.org/2000/svg";
         const hitArea = document.createElementNS(ns, "circle");
         hitArea.setAttribute("r", r * 1.5);
         hitArea.style.fill = "transparent";
         hitArea.style.stroke = "none";
         hitArea.style.cursor = "grab";
         hitArea.classList.add("node-hit-area");
         const shapeEl = createNodeShape(id, r);
         const titleOffsetX = styles.titleOffsetX || 0;
         const titleOffsetY = styles.titleOffsetY || 0;
         const subOffsetX = styles.subOffsetX || 0;
         const subOffsetY = styles.subOffsetY || 0;
         const label = document.createElementNS("http://www.w3.org/2000/svg", "text", );
         label.classList.add("node-label");
         label.setAttribute("x", titleOffsetX);
         label.setAttribute("y", -r * 0.28 + titleOffsetY);
         const labelFontSize = styles.titleSize || r * 0.33;
         label.style.fontSize = labelFontSize + "px";
         label.textContent = NODE_DATA[id].name;
         if (styles.titleColor) label.style.fill = styles.titleColor;
         if (styles.titleFont) label.style.fontFamily = styles.titleFont;
         label.style.pointerEvents = "none";
         const sub = document.createElementNS("http://www.w3.org/2000/svg", "text", );
         sub.classList.add("node-sub");
         sub.setAttribute("x", subOffsetX);
         sub.setAttribute("y", r * 0.4 + subOffsetY);
         const subFontSize = styles.subSize || r * 0.24;
         sub.style.fontSize = subFontSize + "px";
         sub.textContent = NODE_DATA[id].ip;
         if (styles.subColor) sub.style.fill = styles.subColor;
         if (styles.subFont) sub.style.fontFamily = styles.subFont;
         sub.style.pointerEvents = "none";
         g.append(hitArea, shapeEl, label, sub);
         
         if (NODE_DATA[id]?.locked) {
           const lockIndicator = document.createElementNS(ns, "text");
           lockIndicator.textContent = "ðŸ”’";
           lockIndicator.setAttribute("x", r * 0.7);
           lockIndicator.setAttribute("y", -r * 0.7);
           lockIndicator.style.fontSize = (r * 0.3) + "px";
           lockIndicator.style.pointerEvents = "none";
           lockIndicator.classList.add("lock-indicator");
           g.appendChild(lockIndicator);
         }
         
         if (NODE_DATA[id]?.groupId) {
           const groupIndicator = document.createElementNS(ns, "circle");
           groupIndicator.setAttribute("r", r + 4);
           groupIndicator.style.fill = "none";
           groupIndicator.style.stroke = "#4fd1c5";
           groupIndicator.style.strokeWidth = "3";
           groupIndicator.style.strokeDasharray = "5,5";
           groupIndicator.style.pointerEvents = "none";
           groupIndicator.classList.add("group-indicator");
           
           g.insertBefore(groupIndicator, g.firstChild);
         }
         
         let isDragging = false;
         let startX, startY;
         let initialPositions = {};
         let longPressTimer = null;
         let longPressTriggered = false;
         
         g.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          e.stopPropagation();
          
          if (selectedNodes.has(id)) {
           selectedNodes.delete(id);
          } else {
           selectedNodes.add(id);
          }
          updateNodeSelection();
          return false;
         });
         
        g.addEventListener("touchstart", (e) => {
         if (NODE_DATA[id].isRack) {
          longPressTimer = setTimeout(() => {
           longPressTriggered = true;
           if (navigator.vibrate) {
            navigator.vibrate(100);
           }
           enterRack(id);
          }, 500);
         }
        }, { passive: true });
        
        g.addEventListener("dblclick", (e) => {
         e.preventDefault();
         e.stopPropagation();
         if (NODE_DATA[id].isRack) {
          enterRack(id);
         }
        });
        
        let lastTapTime = 0;
        let lastTapNode = null;
        
        g.addEventListener("touchend", (e) => {
         const currentTime = new Date().getTime();
         const tapLength = currentTime - lastTapTime;
         
         if (tapLength < 300 && tapLength > 0 && lastTapNode === id) {
          e.preventDefault();
          e.stopPropagation();
          
          if (selectedNodes.has(id)) {
           selectedNodes.delete(id);
          } else {
           selectedNodes.add(id);
          }
          updateNodeSelection();
          
          if (navigator.vibrate) {
           navigator.vibrate(50);
          }
          
          lastTapTime = 0;
          lastTapNode = null;
         } else {
          lastTapTime = currentTime;
          lastTapNode = id;
         }
        });
         
         g.addEventListener("touchend", (e) => {
          if (longPressTimer) {
           clearTimeout(longPressTimer);
           longPressTimer = null;
          }
          if (longPressTriggered) {
           e.preventDefault();
           e.stopPropagation();
           longPressTriggered = false;
          }
         });
         
         g.addEventListener("touchmove", (e) => {
          if (longPressTimer) {
           clearTimeout(longPressTimer);
           longPressTimer = null;
           longPressTriggered = false;
          }
         });
         
         g.addEventListener("mousedown", (e) => {
          if (e.button === 2) {
           return;
          }
          
          if (NODE_DATA[id]?.locked) {
           console.log(`Node "${NODE_DATA[id].name}" is locked`);
           return;
          }
          
          e.preventDefault();
          isDragging = true;
          const svgEl = document.getElementById("map");
          const pt = svgEl.createSVGPoint();
          pt.x = e.clientX;
          pt.y = e.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          startX = svgP.x;
          startY = svgP.y;
          
          let nodesToCollect = [];
          if (selectedNodes.has(id)) {
           nodesToCollect = Array.from(selectedNodes);
          } else {
           nodesToCollect = [id];
          }
          
          const groupIds = new Set();
          nodesToCollect.forEach(nodeId => {
           const groupId = NODE_DATA[nodeId]?.groupId;
           if (groupId) {
             groupIds.add(groupId);
           }
          });
          
          if (groupIds.size > 0) {
           Object.keys(NODE_DATA).forEach(nodeId => {
             const nodeGroupId = NODE_DATA[nodeId]?.groupId;
             if (nodeGroupId && groupIds.has(nodeGroupId)) {
               if (!nodesToCollect.includes(nodeId)) {
                 nodesToCollect.push(nodeId);
               }
             }
           });
          }
          
          nodesToCollect = nodesToCollect.filter(nodeId => !NODE_DATA[nodeId]?.locked);
          
          if (nodesToCollect.length === 0) {
           console.log("All nodes in selection are locked");
           return;
          }
          
          initialPositions = {};
          nodesToCollect.forEach(nodeId => {
           const nodePos = savedPositions[nodeId];
           if (nodePos) {
            initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
           }
          });
          
          g.style.cursor = "grabbing";
          hitArea.style.cursor = "grabbing";
          e.stopPropagation();
         });
         const handleMouseMove = (e) => {
          if (!isDragging) return;
          e.preventDefault();
          const svgEl = document.getElementById("map");
          const pt = svgEl.createSVGPoint();
          pt.x = e.clientX;
          pt.y = e.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          const dx = svgP.x - startX;
          const dy = svgP.y - startY;
          
          const nodesToMove = selectedNodes.has(id) ? Array.from(selectedNodes) : [id];
          nodesToMove.forEach(nodeId => {
           if (!initialPositions[nodeId]) return;
           const initialPos = initialPositions[nodeId];
           let newX = initialPos.x + dx;
           let newY = initialPos.y + dy;
           const nodeSize = savedSizes[nodeId] || 55;
           newX = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, newX), );
           newY = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, newY), );
           
           savedPositions[nodeId] = { x: newX, y: newY };
           positions[nodeId] = { x: newX, y: newY };
           
           if (nodeId === id) {
            pos.x = newX;
            pos.y = newY;
           }
           
           const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
           if (nodeGroup) {
            nodeGroup.setAttribute("transform", `translate(${newX},${newY})`);
           }
          });
          
          updateMinimap();
          document.querySelectorAll(".edge").forEach((edgeEl) => {
           const fromId = edgeEl.dataset.from;
           const toId = edgeEl.dataset.to;
           if (nodesToMove.includes(fromId) || nodesToMove.includes(toId)) {
            const p1 = savedPositions[fromId] || positions[fromId] || {
             x: 600,
             y: 350
            };
            const p2 = savedPositions[toId] || positions[toId] || {
             x: 600,
             y: 350
            };
            if (edgeEl.tagName === "line") {
             edgeEl.setAttribute("x1", p1.x);
             edgeEl.setAttribute("y1", p1.y);
             edgeEl.setAttribute("x2", p2.x);
             edgeEl.setAttribute("y2", p2.y);
            } else if (edgeEl.tagName === "path") {
             const edgeId = edgeEl.dataset.edgeId;
             const edge = EDGE_DATA.list.find(
              (e) => e.id === edgeId, );
             if (edge) {
              const pairTotal = edge._pairTotal || 1;
              const pairIndex = edge._pairIndex || 0;
              const midX = (p1.x + p2.x) / 2;
              const midY = (p1.y + p2.y) / 2;
              const dx = p2.x - p1.x;
              const dy = p2.y - p1.y;
              const len = Math.sqrt(dx * dx + dy * dy) || 1;
              const perpX = -dy / len;
              const perpY = dx / len;
              let offsetAmount = 0;
              if (pairTotal > 1) {
               offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
              }
              const ctrlX = midX + perpX * offsetAmount;
              const ctrlY = midY + perpY * offsetAmount;
              edgeEl.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
             }
            }
           }
          });
         };
         const handleMouseUp = () => {
          if (isDragging) {
           pushUndo("move nodes");
           isDragging = false;
           g.style.cursor = "grab";
           hitArea.style.cursor = "grab";
          }
         };
         document.addEventListener("mousemove", handleMouseMove);
         document.addEventListener("mouseup", handleMouseUp);
         let touchStartTime = 0;
         let touchStartX = 0;
         let touchStartY = 0;
         let touchMoved = false;
       g.addEventListener("touchstart",
         (e) => {
          if (NODE_DATA[id]?.locked) {
           console.log(`Node "${NODE_DATA[id].name}" is locked`);
           return;
          }
          
          e.preventDefault();
          touchStartTime = Date.now();
          touchMoved = false;
          const svgEl = document.getElementById("map");
          const pt = svgEl.createSVGPoint();
          const touch = e.touches[0];
          pt.x = touch.clientX;
          pt.y = touch.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          touchStartX = svgP.x;
          touchStartY = svgP.y;
          startX = svgP.x;
          startY = svgP.y;
          
          let nodesToCollect = [];
          if (selectedNodes.has(id)) {
           nodesToCollect = Array.from(selectedNodes);
          } else {
           nodesToCollect = [id];
          }
          
          const groupIds = new Set();
          nodesToCollect.forEach(nodeId => {
           const groupId = NODE_DATA[nodeId]?.groupId;
           if (groupId) {
             groupIds.add(groupId);
           }
          });
          
          if (groupIds.size > 0) {
           Object.keys(NODE_DATA).forEach(nodeId => {
             const nodeGroupId = NODE_DATA[nodeId]?.groupId;
             if (nodeGroupId && groupIds.has(nodeGroupId)) {
               if (!nodesToCollect.includes(nodeId)) {
                 nodesToCollect.push(nodeId);
               }
             }
           });
          }
          
          nodesToCollect = nodesToCollect.filter(nodeId => !NODE_DATA[nodeId]?.locked);
          
          if (nodesToCollect.length === 0) {
           console.log("All nodes in selection are locked");
           return;
          }
          
          initialPositions = {};
          nodesToCollect.forEach(nodeId => {
           const nodePos = savedPositions[nodeId];
           if (nodePos) {
            initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
           }
          });
          
          e.stopPropagation();
         }, {
          passive: false
         }, );
         g.addEventListener("touchmove", (e) => {
         e.preventDefault();
         const svgEl = document.getElementById("map");
         const pt = svgEl.createSVGPoint();
         const touch = e.touches[0];
         pt.x = touch.clientX;
         pt.y = touch.clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
         const dx = Math.abs(svgP.x - touchStartX);
         const dy = Math.abs(svgP.y - touchStartY);
         if (dx > (isMobileDevice() ? 4 : 10) || dy > (isMobileDevice() ? 4 : 10)) {
      touchMoved = true;
      isDragging = true;
      }
         if (!isDragging) return;
         
         const deltaX = svgP.x - startX;
         const deltaY = svgP.y - startY;
         
         const nodesToMove = selectedNodes.has(id) ? Array.from(selectedNodes) : [id];
         nodesToMove.forEach(nodeId => {
          if (!initialPositions[nodeId]) return;
          const initialPos = initialPositions[nodeId];
          let newX = initialPos.x + deltaX;
          let newY = initialPos.y + deltaY;
          const nodeSize = savedSizes[nodeId] || 55;
          newX = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, newX), );
          newY = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, newY), );
          
          savedPositions[nodeId] = { x: newX, y: newY };
          positions[nodeId] = { x: newX, y: newY };
          
          if (nodeId === id) {
           pos.x = newX;
           pos.y = newY;
          }
          
          const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
          if (nodeGroup) {
           nodeGroup.setAttribute("transform", `translate(${newX},${newY})`);
          }
         });
         
         updateMinimap();
         document.querySelectorAll(".edge").forEach((edgeEl) => {
          const fromId = edgeEl.dataset.from;
          const toId = edgeEl.dataset.to;
          if (nodesToMove.includes(fromId) || nodesToMove.includes(toId)) {
            const p1 = savedPositions[fromId] || positions[fromId] || {
             x: 600,
             y: 350
            };
            const p2 = savedPositions[toId] || positions[toId] || {
             x: 600,
             y: 350
            };
            if (edgeEl.tagName === "line") {
             edgeEl.setAttribute("x1", p1.x);
             edgeEl.setAttribute("y1", p1.y);
             edgeEl.setAttribute("x2", p2.x);
             edgeEl.setAttribute("y2", p2.y);
            } else if (edgeEl.tagName === "path") {
             const edgeId = edgeEl.dataset.edgeId;
             const edge = EDGE_DATA.list.find(
              (e) => e.id === edgeId, );
             if (edge) {
              const pairTotal = edge._pairTotal || 1;
              const pairIndex = edge._pairIndex || 0;
              const midX = (p1.x + p2.x) / 2;
              const midY = (p1.y + p2.y) / 2;
              const dx = p2.x - p1.x;
              const dy = p2.y - p1.y;
              const len = Math.sqrt(dx * dx + dy * dy) || 1;
              const perpX = -dy / len;
              const perpY = dx / len;
              let offsetAmount = 0;
              if (pairTotal > 1) {
               offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
              }
              const ctrlX = midX + perpX * offsetAmount;
              const ctrlY = midY + perpY * offsetAmount;
              edgeEl.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
             }
            }
           }
          });
         }, {
          passive: false
         });
         g.addEventListener("touchend", (e) => {
          const touchDuration = Date.now() - touchStartTime;
          if (!touchMoved && touchDuration < 400) {
           claimTheImmortal(id);
          }
          if (isDragging) {
           isDragging = false;
           savedPositions[id] = {
            x: pos.x,
            y: pos.y
           };
          }
          touchMoved = false;
         });
         g.style.cursor = "grab";
         g.addEventListener("click", (e) => {
          if (!isDragging) {
           claimTheImmortal(id);
          }
         });
         svg.appendChild(g);
        });
        
        if (RECT_DATA && RECT_DATA.list) {
         RECT_DATA.list.forEach((rect) => {
          if (rect.style === "outlined") {
           const g = document.createElementNS(ns, "g");
           g.classList.add("rect-group");
           g.dataset.rectId = rect.id;
           
           const rectEl = document.createElementNS(ns, "rect");
           rectEl.classList.add("rect-shape");
           rectEl.setAttribute("x", rect.x);
           rectEl.setAttribute("y", rect.y);
           rectEl.setAttribute("width", rect.width);
           rectEl.setAttribute("height", rect.height);
           rectEl.style.fill = "none";
           rectEl.style.stroke = rect.color;
           rectEl.style.strokeWidth = "3";
           rectEl.style.cursor = "move";
           
           const deleteBtn = document.createElementNS(ns, "g");
           deleteBtn.classList.add("rect-delete-btn");
           deleteBtn.style.cursor = "pointer";
           deleteBtn.style.display = rectDrawMode ? "block" : "none";
           
           const deleteBg = document.createElementNS(ns, "circle");
           deleteBg.setAttribute("cx", rect.x + rect.width - 10);
           deleteBg.setAttribute("cy", rect.y + 10);
           deleteBg.setAttribute("r", 12);
           deleteBg.style.fill = "#f56565";
           deleteBg.style.stroke = "white";
           deleteBg.style.strokeWidth = "2";
           
           const deleteX = document.createElementNS(ns, "text");
           deleteX.setAttribute("x", rect.x + rect.width - 10);
           deleteX.setAttribute("y", rect.y + 10);
           deleteX.setAttribute("text-anchor", "middle");
           deleteX.setAttribute("dominant-baseline", "middle");
           deleteX.style.fill = "white";
           deleteX.style.fontSize = "16px";
           deleteX.style.fontWeight = "bold";
           deleteX.style.pointerEvents = "none";
           deleteX.textContent = "Ã—";
           
           deleteBtn.appendChild(deleteBg);
           deleteBtn.appendChild(deleteX);
           
           deleteBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            e.preventDefault();
            deleteRectangle(rect.id);
           });
           
           let isDragging = false;
           let dragStartX, dragStartY;
           let rectStartX, rectStartY;
           
           rectEl.addEventListener("mousedown", (e) => {
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            dragStartX = e.clientX;
            dragStartY = e.clientY;
            rectStartX = rect.x;
            rectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           });
           
           const moveHandler = (e) => {
            if (!isDragging || rectDrawMode) return;
            const svgEl = svg;
            const pt1 = svgEl.createSVGPoint();
            pt1.x = dragStartX;
            pt1.y = dragStartY;
            const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
            
            const pt2 = svgEl.createSVGPoint();
            pt2.x = e.clientX;
            pt2.y = e.clientY;
            const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
            
            const dx = svgP2.x - svgP1.x;
            const dy = svgP2.y - svgP1.y;
            
            rect.x = rectStartX + dx;
            rect.y = rectStartY + dy;
            
            forgeTheTopology();
           };
           
           const upHandler = () => {
            if (isDragging) {
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           };
           
           document.addEventListener("mousemove", moveHandler);
           document.addEventListener("mouseup", upHandler);
           
           let touchStartX, touchStartY;
           let touchRectStartX, touchRectStartY;
           
           rectEl.addEventListener("touchstart", (e) => {
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchRectStartX = rect.x;
            touchRectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           }, { passive: false });
           
           rectEl.addEventListener("touchmove", (e) => {
            if (!isDragging || rectDrawMode) return;
            if (!e.touches[0]) return;
            e.preventDefault();
            e.stopPropagation();
            
            const svgEl = svg;
            const pt1 = svgEl.createSVGPoint();
            pt1.x = touchStartX;
            pt1.y = touchStartY;
            const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
            
            const touch = e.touches[0];
            const pt2 = svgEl.createSVGPoint();
            pt2.x = touch.clientX;
            pt2.y = touch.clientY;
            const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
            
            const dx = svgP2.x - svgP1.x;
            const dy = svgP2.y - svgP1.y;
            
            rect.x = touchRectStartX + dx;
            rect.y = touchRectStartY + dy;
            
            forgeTheTopology();
           }, { passive: false });
           
           rectEl.addEventListener("touchend", (e) => {
            if (isDragging) {
             e.preventDefault();
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           }, { passive: false });
           
           g.appendChild(rectEl);
           g.appendChild(deleteBtn);
           svg.appendChild(g);
          }
         });
        }
        
        if (TEXT_DATA && TEXT_DATA.list) {
         TEXT_DATA.list.forEach((textItem) => {
          if (currentView.mode === "rack") return;
          
          const g = document.createElementNS(ns, "g");
          g.classList.add("text-group");
          g.dataset.textId = textItem.id;
          
          if (textItem.bgEnabled) {
           const bgRect = document.createElementNS(ns, "rect");
           bgRect.classList.add("text-bg");
      
           bgRect.setAttribute("x", textItem.x - 5);
           bgRect.setAttribute("y", textItem.y - textItem.fontSize - 2);
           bgRect.setAttribute("width", 100);
           bgRect.setAttribute("height", textItem.fontSize + 10);
           bgRect.style.fill = textItem.bgColor;
           bgRect.style.opacity = "0.7";
           bgRect.style.rx = "4";
           g.appendChild(bgRect);
          }
          
          const textEl = document.createElementNS(ns, "text");
          textEl.classList.add("text-element");
          textEl.setAttribute("x", textItem.x);
          textEl.setAttribute("y", textItem.y);
          textEl.style.fill = textItem.color;
          textEl.style.fontSize = textItem.fontSize + "px";
          textEl.style.fontWeight = textItem.fontWeight;
          textEl.style.fontStyle = textItem.fontStyle;
          textEl.style.textAnchor = textItem.textAlign;
          textEl.style.textDecoration = textItem.textDecoration;
          textEl.style.opacity = textItem.opacity;
          textEl.style.cursor = "move";
          textEl.style.userSelect = "none";
          textEl.setAttribute("dominant-baseline", "middle");
          
          const lines = textItem.content.split('\n');
          if (lines.length === 1) {
           textEl.textContent = textItem.content;
          } else {
           lines.forEach((line, i) => {
            const tspan = document.createElementNS(ns, "tspan");
            tspan.textContent = line;
            tspan.setAttribute("x", textItem.x);
            tspan.setAttribute("dy", i === 0 ? 0 : textItem.fontSize * 1.2);
            textEl.appendChild(tspan);
           });
          }
          
          g.appendChild(textEl);
          
          if (textItem.bgEnabled) {
           setTimeout(() => {
            try {
             const bbox = textEl.getBBox();
             const bgRect = g.querySelector('.text-bg');
             if (bgRect && bbox) {
              bgRect.setAttribute("x", bbox.x - 5);
              bgRect.setAttribute("y", bbox.y - 2);
              bgRect.setAttribute("width", bbox.width + 10);
              bgRect.setAttribute("height", bbox.height + 4);
             }
            } catch (e) {
            }
           }, 0);
          }
          
          const deleteBtn = document.createElementNS(ns, "g");
          deleteBtn.classList.add("text-delete-btn");
          deleteBtn.style.cursor = "pointer";
          deleteBtn.style.display = textDrawMode ? "block" : "none";
          
          const deleteBg = document.createElementNS(ns, "circle");
          deleteBg.setAttribute("cx", textItem.x + 20);
          deleteBg.setAttribute("cy", textItem.y - textItem.fontSize);
          deleteBg.setAttribute("r", 12);
          deleteBg.style.fill = "#f56565";
          deleteBg.style.stroke = "white";
          deleteBg.style.strokeWidth = "2";
          
          const deleteX = document.createElementNS(ns, "text");
          deleteX.setAttribute("x", textItem.x + 20);
          deleteX.setAttribute("y", textItem.y - textItem.fontSize);
          deleteX.setAttribute("text-anchor", "middle");
          deleteX.setAttribute("dominant-baseline", "middle");
          deleteX.style.fill = "white";
          deleteX.style.fontSize = "16px";
          deleteX.style.fontWeight = "bold";
          deleteX.style.pointerEvents = "none";
          deleteX.textContent = "Ã—";
          
          deleteBtn.appendChild(deleteBg);
          deleteBtn.appendChild(deleteX);
          
          deleteBtn.addEventListener("click", (e) => {
           e.stopPropagation();
           e.preventDefault();
           deleteText(textItem.id);
          });
          
          let isDragging = false;
          let dragStartX, dragStartY;
          let textStartX, textStartY;
          
          textEl.addEventListener("mousedown", (e) => {
           if (textDrawMode) return;
           e.preventDefault();
           e.stopPropagation();
           isDragging = true;
           dragStartX = e.clientX;
           dragStartY = e.clientY;
           textStartX = textItem.x;
           textStartY = textItem.y;
           textEl.style.cursor = "grabbing";
           
           showTextPanel(textItem.id);
          });
          
          const moveHandler = (e) => {
           if (!isDragging || textDrawMode) return;
           const svgEl = svg;
           const pt1 = svgEl.createSVGPoint();
           pt1.x = dragStartX;
           pt1.y = dragStartY;
           const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
           
           const pt2 = svgEl.createSVGPoint();
           pt2.x = e.clientX;
           pt2.y = e.clientY;
           const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
           
           const dx = svgP2.x - svgP1.x;
           const dy = svgP2.y - svgP1.y;
           
           textItem.x = textStartX + dx;
           textItem.y = textStartY + dy;
           
           forgeTheTopology();
          };
          
          const upHandler = () => {
           if (isDragging) {
            isDragging = false;
            textEl.style.cursor = "move";
           }
          };
          
          document.addEventListener("mousemove", moveHandler);
          document.addEventListener("mouseup", upHandler);
          
          let touchStartX = 0, touchStartY = 0;
          let textTouchStartX = 0, textTouchStartY = 0;
          
          textEl.addEventListener("touchstart", (e) => {
           if (textDrawMode) return;
           if (e.touches.length !== 1) return;
           
           e.preventDefault();
           e.stopPropagation();
           const touch = e.touches[0];
           isDragging = true;
           touchStartX = touch.clientX;
           touchStartY = touch.clientY;
           textTouchStartX = textItem.x;
           textTouchStartY = textItem.y;
           
           showTextPanel(textItem.id);
          }, { passive: false });
          
          textEl.addEventListener("touchmove", (e) => {
           if (!isDragging || textDrawMode) return;
           if (e.touches.length !== 1) return;
           
           e.preventDefault();
           const touch = e.touches[0];
           const svgEl = svg;
           
           const pt1 = svgEl.createSVGPoint();
           pt1.x = touchStartX;
           pt1.y = touchStartY;
           const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
           
           const pt2 = svgEl.createSVGPoint();
           pt2.x = touch.clientX;
           pt2.y = touch.clientY;
           const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
           
           const dx = svgP2.x - svgP1.x;
           const dy = svgP2.y - svgP1.y;
           
           textItem.x = textTouchStartX + dx;
           textItem.y = textTouchStartY + dy;
           
           forgeTheTopology();
          }, { passive: false });
          
          textEl.addEventListener("touchend", () => {
           if (isDragging) {
            isDragging = false;
           }
          }, { passive: false });
          
          g.appendChild(deleteBtn);
          svg.appendChild(g);
         });
        }
        
        
        Object.keys(NODE_DATA).forEach(nodeId => {
         updatePingIndicator(nodeId);
        });
        
        forgeTheLegend();
        updateMinimap();
       }
      
       function showEditModal(title, currentValue, onSave) {
        const modal = document.getElementById("edit-modal");
        const input = document.getElementById("modal-input");
        const titleEl = document.getElementById("modal-title");
        const saveBtn = document.getElementById("modal-save");
        const cancelBtn = document.getElementById("modal-cancel");
        titleEl.textContent = title;
        input.value = currentValue;
        modal.classList.add("active");
        input.focus();
        input.select();
        const handleSave = () => {
         if (input.value.trim()) {
          onSave(input.value.trim());
         }
         modal.classList.remove("active");
         saveBtn.removeEventListener("click", handleSave);
         cancelBtn.removeEventListener("click", handleCancel);
         input.removeEventListener("keypress", handleEnter);
        };
        const handleCancel = () => {
         modal.classList.remove("active");
         saveBtn.removeEventListener("click", handleSave);
         cancelBtn.removeEventListener("click", handleCancel);
         input.removeEventListener("keypress", handleEnter);
        };
        const handleEnter = (e) => {
         if (e.key === "Enter") handleSave();
        };
        saveBtn.addEventListener("click", handleSave);
        cancelBtn.addEventListener("click", handleCancel);
        input.addEventListener("keypress", handleEnter);
        modal.addEventListener("click", function bgHandler(e) {
         if (e.target === modal) {
          handleCancel();
          modal.removeEventListener("click", bgHandler);
         }
        });
       }
      
       function challengeTheImmortal(message, onConfirm) {
        const modal = document.getElementById("confirm-modal");
        const messageEl = document.getElementById("confirm-message");
        const deleteBtn = document.getElementById("confirm-delete");
        const cancelBtn = document.getElementById("confirm-cancel");
        messageEl.textContent = message;
        modal.classList.add("active");
        const handleConfirm = () => {
         onConfirm();
         modal.classList.remove("active");
         deleteBtn.removeEventListener("click", handleConfirm);
         cancelBtn.removeEventListener("click", handleCancel);
        };
        const handleCancel = () => {
         modal.classList.remove("active");
         deleteBtn.removeEventListener("click", handleConfirm);
         cancelBtn.removeEventListener("click", handleCancel);
        };
        deleteBtn.addEventListener("click", handleConfirm);
        cancelBtn.addEventListener("click", handleCancel);
        modal.addEventListener("click", function bgHandler(e) {
         if (e.target === modal) {
          handleCancel();
          modal.removeEventListener("click", bgHandler);
         }
        });
       }
       const pageTitleEl = document.getElementById("page-title");
       if (pageTitleEl) {
        pageTitleEl.addEventListener("click", () => {
         showEditModal("Edit Title", PAGE_STATE.title || DEFAULT_PAGE_STATE.title,
          (newTitle) => {
           PAGE_STATE.title = newTitle;
           wieldThePower();
          }, );
        });
       }
      
       function editNodeName(id) {
        if (!NODE_DATA[id]) return;
        showEditModal("Edit Name", NODE_DATA[id].name, (newName) => {
         if (!NODE_DATA[id]) return;
         NODE_DATA[id].name = newName;
         const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`, );
         if (nodeGroup) {
          const label = nodeGroup.querySelector(".node-label");
          if (label) label.textContent = newName;
         }
         if (currentNodeId === id) {
          document.getElementById("node-name").textContent = newName;
         }
        });
       }
      
       function editNodeIp(id) {
        if (!NODE_DATA[id]) return;
        showEditModal("Edit IP/Subtitle", NODE_DATA[id].ip, (newIp) => {
         if (!NODE_DATA[id]) return;
         NODE_DATA[id].ip = newIp;
         const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`, );
         if (nodeGroup) {
          const sub = nodeGroup.querySelector(".node-sub");
          if (sub) sub.textContent = newIp;
         }
         if (currentNodeId === id) {
          document.getElementById("node-ip").textContent = newIp;
         }
        });
       }
      
       function claimTheImmortal(id) {
        if (!NODE_DATA[id]) return;
        currentNodeId = id;
        currentEdgeId = null;
        const data = NODE_DATA[id];
        document.querySelectorAll(".node-group").forEach((n) => {
         n.classList.toggle("active", n.dataset.nodeId === id);
        });
        document.querySelectorAll(".edge").forEach((e) => {
         const active = e.dataset.from === id || e.dataset.to === id;
         e.classList.toggle("active", active);
        });
        document.getElementById("node-panel").style.display = "block";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        const toolbar = document.getElementById("topology-toolbar");
        if (!topologyToolbarCollapsed) {
         toolbar.style.display = "flex";
        }
        updateTopologyToolbarVisibility();
        document.getElementById("node-name").textContent = data.name;
        document.getElementById("node-ip").textContent = data.ip;
        document.getElementById("node-mac").textContent = data.mac || "--";
        document.getElementById("node-rack").textContent = data.rackUnit || "--";
        document.getElementById("node-uheight").textContent = (data.uHeight || "1") + "U";
        document.getElementById("node-role").textContent = data.role;

        populateRackDropdown();
        const assignedRackSelect = document.getElementById("node-assigned-rack");
        if (assignedRackSelect) {
         assignedRackSelect.value = data.assignedRack || "";
        }
        
        const rackCapacitySelect = document.getElementById("node-rack-capacity");
        if (rackCapacitySelect) {
         rackCapacitySelect.value = data.rackCapacity || "42";
        }
        
        const isRack = data.isRack === true;
        const isAssignedToRack = !!data.assignedRack;
        const assignedRackRow = document.getElementById("assigned-rack-row");
        const rackCapacityRow = document.getElementById("rack-capacity-row");
        const uheightRow = document.getElementById("uheight-row");
        if (assignedRackRow) assignedRackRow.style.display = isRack ? "none" : "flex";
        if (rackCapacityRow) rackCapacityRow.style.display = isRack ? "flex" : "none";
        if (uheightRow) uheightRow.style.display = isAssignedToRack ? "flex" : "none";
        
        document.getElementById("node-name").onclick = () => editNodeName(id);
        document.getElementById("node-ip").onclick = () => editNodeIp(id);
        document.getElementById("node-mac").onclick = () => editNodeMac(id);
        document.getElementById("node-rack").onclick = () => editNodeRack(id);
        document.getElementById("node-uheight").onclick = () => editNodeUHeight(id);
        const currentSize = savedSizes[id] || getDefaultSize();
        document.getElementById("size-slider").value = currentSize;
        document.getElementById("size-value").textContent = currentSize;
        const styleEntry = savedStyles[id] || {};
        const resolvedStyles = resolveStylesEntry(styleEntry);
        const scopeKey = currentStyleScope || "all";
        const flatProps = ["circleColor", "titleColor", "titleFont", "titleSize", "subColor", "subFont", "subSize", ];
        const isFlat = flatProps.some((p) => Object.prototype.hasOwnProperty.call(styleEntry, p), );
        const scopedStyles = isFlat ? styleEntry : styleEntry[scopeKey] || {};
        const circleColorInput = document.getElementById("circle-color");
        const titleColorInput = document.getElementById("title-color");
        const titleFontSelect = document.getElementById("title-font");
        const titleSizeInput = document.getElementById("title-size");
        const subColorInput = document.getElementById("sub-color");
        const subFontSelect = document.getElementById("sub-font");
        const subSizeInput = document.getElementById("sub-size");
        const shapeSelect = document.getElementById("shape-select");
        const scopeSelect = document.getElementById("style-scope");
        circleColorInput.value = scopedStyles.circleColor || resolvedStyles.circleColor || "#1e293b";
        titleColorInput.value = scopedStyles.titleColor || resolvedStyles.titleColor || "#e2e8f0";
        titleFontSelect.value = scopedStyles.titleFont || resolvedStyles.titleFont || "system-ui, sans-serif";
        titleSizeInput.value = scopedStyles.titleSize || resolvedStyles.titleSize || 18;
        subColorInput.value = scopedStyles.subColor || resolvedStyles.subColor || "#94a3b8";
        subFontSelect.value = scopedStyles.subFont || resolvedStyles.subFont || "system-ui, sans-serif";
        subSizeInput.value = scopedStyles.subSize || resolvedStyles.subSize || 13;
        shapeSelect.value = data.shape || "circle";
        scopeSelect.value = currentStyleScope || "all";
        document.getElementById("title-offset-y").value = scopedStyles.titleOffsetY || resolvedStyles.titleOffsetY || 0;
        document.getElementById("title-offset-x").value = scopedStyles.titleOffsetX || resolvedStyles.titleOffsetX || 0;
        document.getElementById("sub-offset-y").value = scopedStyles.subOffsetY || resolvedStyles.subOffsetY || 0;
        document.getElementById("sub-offset-x").value = scopedStyles.subOffsetX || resolvedStyles.subOffsetX || 0;
      
      const pingOffsetXInput = document.getElementById("ping-offset-x");
      const pingOffsetYInput = document.getElementById("ping-offset-y");
      
      if (pingOffsetXInput && pingOffsetYInput) {
      pingOffsetXInput.value =
       (scopedStyles.pingOffsetX !== undefined
         ? scopedStyles.pingOffsetX
         : (resolvedStyles.pingOffsetX !== undefined
             ? resolvedStyles.pingOffsetX
             : 0));
      
      pingOffsetYInput.value =
       (scopedStyles.pingOffsetY !== undefined
         ? scopedStyles.pingOffsetY
         : (resolvedStyles.pingOffsetY !== undefined
             ? resolvedStyles.pingOffsetY
             : 0));
      }
        const tagEl = document.getElementById("node-tags");
        tagEl.innerHTML = "";
        data.tags.forEach((tag, i) => {
         const b = document.createElement("span");
         b.className = "badge";
         const isIconTag = typeof tag === 'object' && tag.type === 'icon';
         if (!isIconTag && typeof tag === 'string' && tag.toLowerCase().includes("wg")) b.classList.add("wg");
         b.style.cursor = "pointer";
         b.style.position = "relative";
         const tagContent = document.createElement("span");
         if (isIconTag) {
          b.classList.add("icon-badge");
          IconLibrary.getIcon(tag.library, tag.name).then(svgText => {
           if (svgText) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(svgText, 'image/svg+xml');
            const svgEl = doc.querySelector('svg');
            if (svgEl) {
             svgEl.setAttribute('width', '16');
             svgEl.setAttribute('height', '16');
             tagContent.innerHTML = '';
             tagContent.appendChild(svgEl);
             const nameSpan = document.createElement('span');
             nameSpan.textContent = tag.name;
             nameSpan.style.marginLeft = '4px';
             tagContent.appendChild(nameSpan);
            }
           }
          });
         } else {
          tagContent.textContent = tag;
          tagContent.addEventListener("click", (e) => {
           e.stopPropagation();
           showEditModal("Edit Tag", tag, (newTag) => {
            if (newTag) {
             data.tags[i] = newTag;
             claimTheImmortal(id);
            }
           });
          });
         }
         const deleteTag = document.createElement("span");
         deleteTag.textContent = " âœ•";
         deleteTag.style.opacity = "0.6";
         deleteTag.style.marginLeft = "4px";
         deleteTag.style.fontSize = "10px";
         deleteTag.addEventListener("click", (e) => {
          e.stopPropagation();
          data.tags.splice(i, 1);
          claimTheImmortal(id);
         });
         b.append(tagContent, deleteTag);
         tagEl.append(b);
        });
        const addTagBtn = document.createElement("span");
        addTagBtn.className = "badge";
        addTagBtn.style.cursor = "pointer";
        addTagBtn.style.opacity = "0.6";
        addTagBtn.style.borderStyle = "dashed";
        addTagBtn.textContent = "+ Add";
        addTagBtn.addEventListener("click", () => {
         showEditModal("Add Tag(s) : comma separated", "",
          (newTagStr) => {
           if (newTagStr) {
            const newTags = newTagStr.split(",").map((t) => t.trim()).filter((t) => t);
            newTags.forEach((t) => data.tags.push(t));
            claimTheImmortal(id);
           }
          }, );
        });
        tagEl.append(addTagBtn);
        const notesEl = document.getElementById("node-notes");
        notesEl.innerHTML = "";
        data.notes.forEach((note, i) => {
         const li = document.createElement("li");
         const noteText = document.createElement("span");
         noteText.textContent = note;
         noteText.style.flex = "1";
         const deleteBtn = document.createElement("span");
         deleteBtn.className = "delete-note";
         deleteBtn.textContent = "âœ•";
         deleteBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          challengeTheImmortal("Are you sure you want to delete this note?",
           () => {
            data.notes.splice(i, 1);
            claimTheImmortal(id);
           }, );
         });
         li.append(noteText, deleteBtn);
         noteText.addEventListener("dblclick", () => {
          noteText.classList.add("editing");
          noteText.contentEditable = true;
          noteText.focus();
         });
         noteText.addEventListener("blur", () => {
          noteText.classList.remove("editing");
          noteText.contentEditable = false;
          data.notes[i] = noteText.textContent;
         });
         notesEl.append(li);
        });
        const addLineSelect = document.getElementById("add-line-select");
        addLineSelect.innerHTML = "";
        Object.entries(NODE_DATA).forEach(([nodeId, node]) => {
         if (nodeId !== id) {
          const opt = document.createElement("option");
          opt.value = nodeId;
          opt.textContent = node.name;
          addLineSelect.appendChild(opt);
         }
        });
        
        const pingEnabled = data.ping && data.ping.enabled;
        document.getElementById('node-pingable').checked = pingEnabled;
        document.getElementById('node-ping-options').style.display = pingEnabled ? 'block' : 'none';
        
        if (data.ping) {
         document.getElementById('node-ping-protocol').value = data.ping.protocol || 'http';
         document.getElementById('node-custom-url').value = data.ping.customUrl || '';
         document.getElementById('node-ping-timeout').value = data.ping.timeout || 3000;
         document.getElementById('node-custom-url-container').style.display = 
          data.ping.protocol === 'custom' ? 'block' : 'none';
         
         updatePingStatusDisplay(id);
        }
       }
      
       function updatePingStatusDisplay(nodeId) {
        const data = NODE_DATA[nodeId];
        if (!data || !data.ping) return;
        
        const statusEl = document.getElementById('node-ping-status');
        const lastCheckEl = document.getElementById('node-ping-last-check');
        
        const statusColors = {
         online: 'var(--accent)',
         offline: 'var(--danger)',
         checking: '#f59e0b',
         unknown: 'var(--text-soft)'
        };
        
        const statusTexts = {
         online: 'â— Online',
         offline: 'â— Offline',
         checking: 'â— Checking...',
         unknown: 'â— Unknown'
        };
        
        statusEl.textContent = statusTexts[data.ping.status] || statusTexts.unknown;
        statusEl.style.color = statusColors[data.ping.status] || statusColors.unknown;
        
        if (data.ping.lastCheck) {
         const checkTime = new Date(data.ping.lastCheck);
         lastCheckEl.textContent = `Last checked: ${checkTime.toLocaleTimeString()}`;
        } else {
         lastCheckEl.textContent = 'Never checked';
        }
       }
      
       function selectTheConnection(id) {
        currentEdgeId = id;
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "block";
        document.getElementById("text-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.display = "none";
        document.querySelectorAll(".node-group").forEach((n) => n.classList.remove("active"));
        document.querySelectorAll(".edge").forEach((e) => {
         e.classList.toggle("active", e.dataset.edgeId === id);
        });
        const edge = EDGE_DATA.list.find((e) => e.id === id);
        if (!edge) return;
        const directionSymbols = {
         none: "â‡„",
         forward: "â†’",
         backward: "â†",
         both: "â†”",
        };
        const dirSymbol = directionSymbols[edge.direction] || "â‡„";
        let titleText = "Custom line";
        if (edge.from || edge.to) {
         const fromName = edge.from ? NODE_DATA[edge.from]?.name || edge.from : "";
         const toName = edge.to ? NODE_DATA[edge.to]?.name || edge.to : "";
         titleText = `${fromName || "?"} ${dirSymbol} ${toName || "?"}`;
        }
        document.getElementById("edge-title").textContent = titleText;
        const widthInput = document.getElementById("edge-width");
        const colorInput = document.getElementById("edge-color");
        const directionSelect = document.getElementById("edge-direction");
        const lineStyleSelect = document.getElementById("edge-line-style");
        widthInput.value = edge.width;
        colorInput.value = edge.color;
        directionSelect.value = edge.direction || "none";
        lineStyleSelect.value = edge.lineStyle || "solid";
        
        const fromPortInput = document.getElementById("edge-from-port");
        const toPortInput = document.getElementById("edge-to-port");
        const portFieldsFrom = document.getElementById("edge-port-fields");
        const portFieldsTo = document.getElementById("edge-port-fields-to");
        
        if (edge.type === "custom") {
         if (portFieldsFrom) portFieldsFrom.style.display = "none";
         if (portFieldsTo) portFieldsTo.style.display = "none";
        } else {
         if (portFieldsFrom) portFieldsFrom.style.display = "flex";
         if (portFieldsTo) portFieldsTo.style.display = "flex";
         if (fromPortInput) {
          fromPortInput.value = edge.fromPort || "";
          fromPortInput.onchange = () => updateEdgePortLabels(id);
         }
         if (toPortInput) {
          toPortInput.value = edge.toPort || "";
          toPortInput.onchange = () => updateEdgePortLabels(id);
         }
        }
        
        const list = document.getElementById("edge-notes");
        list.innerHTML = "";
        edge.notes.forEach((note, i) => {
         const li = document.createElement("li");
         const txt = document.createElement("span");
         txt.textContent = note;
         txt.style.flex = "1";
         const del = document.createElement("span");
         del.className = "delete-note";
         del.textContent = "âœ•";
         del.addEventListener("click", (e) => {
          e.stopPropagation();
          challengeTheImmortal("Delete this line note?", () => {
           edge.notes.splice(i, 1);
           saveEdgeData();
           selectTheConnection(id);
          });
         });
         txt.addEventListener("dblclick", () => {
          txt.classList.add("editing");
          txt.contentEditable = true;
          txt.focus();
         });
         txt.addEventListener("blur", () => {
          txt.classList.remove("editing");
          txt.contentEditable = false;
          edge.notes[i] = txt.textContent;
          saveEdgeData();
         });
         li.append(txt, del);
         list.appendChild(li);
        });
       }
       window.addEventListener("resize", () => {
        forgeTheTopology();
        if (currentEdgeId) {
         selectTheConnection(currentEdgeId);
        } else if (currentNodeId && NODE_DATA[currentNodeId]) {
         claimTheImmortal(currentNodeId);
        } else {
         const availableNodes = Object.keys(NODE_DATA);
         if (availableNodes.length > 0) {
          claimTheImmortal(availableNodes[0]);
         }
        }
       });
       (function initZoomPan() {
        const viewport = document.getElementById("canvas-viewport");
        const svg = document.getElementById("map");
        const hint = document.getElementById("canvas-hint");
        setTimeout(() => {
         hint.classList.add("visible");
         setTimeout(() => hint.classList.remove("visible"), 4000);
        }, 1000);
        viewport.addEventListener("wheel",
         (e) => {
          e.preventDefault();
          const rect = viewport.getBoundingClientRect();
          const mouseX = (e.clientX - rect.left) / rect.width;
          const mouseY = (e.clientY - rect.top) / rect.height;
          const delta = e.deltaY > 0 ? 0.9 : 1.1;
          zoomTo(canvasState.zoom * delta, mouseX, mouseY);
         }, {
          passive: false
         }, );
        let initialPinchDistance = 0;
        let initialPinchZoom = 1;
        let pinchCenter = {
         x: 0.5,
         y: 0.5
        };
        viewport.addEventListener("touchstart",
         (e) => {
          if (e.touches.length === 2) {
           e.preventDefault();
           const touch1 = e.touches[0];
           const touch2 = e.touches[1];
           initialPinchDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY, );
           initialPinchZoom = canvasState.zoom;
           const rect = viewport.getBoundingClientRect();
           const centerX = (touch1.clientX + touch2.clientX) / 2;
           const centerY = (touch1.clientY + touch2.clientY) / 2;
           pinchCenter.x = (centerX - rect.left) / rect.width;
           pinchCenter.y = (centerY - rect.top) / rect.height;
          }
         }, {
          passive: false
         }, );
        viewport.addEventListener("touchmove",
         (e) => {
          if (e.touches.length === 2) {
           e.preventDefault();
           const touch1 = e.touches[0];
           const touch2 = e.touches[1];
           const currentDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY, );
           if (initialPinchDistance > 0) {
            const scale = currentDistance / initialPinchDistance;
            const newZoom = initialPinchZoom * scale;
            zoomTo(newZoom, pinchCenter.x, pinchCenter.y);
           }
          }
         }, {
          passive: false
         }, );
        let panStartViewX = 0;
        let panStartViewY = 0;
        
        let lastEmptyTapTime = 0;
        let emptyTapTimeout = null;
        let emptyTapMoved = false;
        
        viewport.addEventListener("touchend", (e) => {
          if (currentView.mode !== "rack") return;
          
          if (e.changedTouches.length !== 1) return;
          
          const isEmptySpace = e.target === svg || e.target === viewport || e.target.tagName === "svg";
          if (!isEmptySpace) return;
          
          if (emptyTapMoved) {
            emptyTapMoved = false;
            return;
          }
          
          const currentTime = new Date().getTime();
          const tapGap = currentTime - lastEmptyTapTime;
          
          if (tapGap < 300 && tapGap > 0) {
            e.preventDefault();
            
            exitRack();
            
            if (navigator.vibrate) {
              navigator.vibrate(50);
            }
            
            lastEmptyTapTime = 0;
            if (emptyTapTimeout) {
              clearTimeout(emptyTapTimeout);
              emptyTapTimeout = null;
            }
          } else {
            lastEmptyTapTime = currentTime;
            
            if (emptyTapTimeout) clearTimeout(emptyTapTimeout);
            emptyTapTimeout = setTimeout(() => {
              lastEmptyTapTime = 0;
            }, 300);
          }
        }, { passive: false });
        
        viewport.addEventListener("mousedown", (e) => {
         if (e.target.closest(".draw-toolbar") || e.target.closest(".topology-toolbar") || e.target.closest(".legend-container")) {
          return;
         }
         if (freeDrawMode || rectDrawMode) {
          return;
         }
         const isEmptySpace = e.target === svg || e.target === viewport || e.target.tagName === "svg";
         if (isEmptySpace || e.button === 2 || e.button === 1) {
          e.preventDefault();
          canvasState.isPanning = true;
          canvasState.panStartX = e.clientX;
          canvasState.panStartY = e.clientY;
          panStartViewX = canvasState.panX;
          panStartViewY = canvasState.panY;
          viewport.classList.add("panning");
         }
        });
        viewport.addEventListener("touchstart",
         (e) => {
          if (e.target.closest(".draw-toolbar") || e.target.closest(".topology-toolbar") || e.target.closest(".legend-container")) {
           return;
          }
          if (freeDrawMode || rectDrawMode) {
           return;
          }
          const isEmptySpace = e.target === svg || e.target === viewport || e.target.tagName === "svg";
          if (isEmptySpace && e.touches.length === 1) {
           e.preventDefault();
           emptyTapMoved = false;
           canvasState.isPanning = true;
           canvasState.panStartX = e.touches[0].clientX;
           canvasState.panStartY = e.touches[0].clientY;
           panStartViewX = canvasState.panX;
           panStartViewY = canvasState.panY;
           viewport.classList.add("panning");
          }
         }, {
          passive: false
         }, );
        document.addEventListener("mousemove", (e) => {
         if (!canvasState.isPanning) return;
         const dx = e.clientX - canvasState.panStartX;
         const dy = e.clientY - canvasState.panStartY;
         const rect = viewport.getBoundingClientRect();
         const viewWidth = CANVAS_WIDTH / canvasState.zoom;
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         const canvasDx = (dx / rect.width) * viewWidth;
         const canvasDy = (dy / rect.height) * viewHeight;
         canvasState.panX = panStartViewX - canvasDx;
         canvasState.panY = panStartViewY - canvasDy;
         constrainPan();
         updateViewBox();
        });
        document.addEventListener("touchmove", (e) => {
         if (!canvasState.isPanning || !e.touches[0]) return;
         emptyTapMoved = true; 
         const dx = e.touches[0].clientX - canvasState.panStartX;
         const dy = e.touches[0].clientY - canvasState.panStartY;
         const rect = viewport.getBoundingClientRect();
         const viewWidth = CANVAS_WIDTH / canvasState.zoom;
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         const canvasDx = (dx / rect.width) * viewWidth;
         const canvasDy = (dy / rect.height) * viewHeight;
         canvasState.panX = panStartViewX - canvasDx;
         canvasState.panY = panStartViewY - canvasDy;
         constrainPan();
         updateViewBox();
        });
        document.addEventListener("mouseup", () => {
         if (canvasState.isPanning) {
          canvasState.isPanning = false;
          viewport.classList.remove("panning");
         }
        });
        document.addEventListener("touchend", () => {
         if (canvasState.isPanning) {
          canvasState.isPanning = false;
          viewport.classList.remove("panning");
         }
        });
        document.addEventListener("keydown", (e) => {
         const isEditing = document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "TEXTAREA" || document.activeElement.isContentEditable;
         if (e.code === "Space" && !e.repeat && !isEditing) {
          e.preventDefault();
          canvasState.spacePressed = true;
          viewport.style.cursor = "grab";
         }
        });
        document.addEventListener("keyup", (e) => {
         if (e.code === "Space") {
          canvasState.spacePressed = false;
          viewport.style.cursor = "";
         }
        });
        document.getElementById("zoom-in-btn").addEventListener("click", () => {
         zoomTo(canvasState.zoom * 1.25, 0.5, 0.5);
        });
        document.getElementById("zoom-out-btn").addEventListener("click", () => {
         zoomTo(canvasState.zoom * 0.8, 0.5, 0.5);
        });
        document.getElementById("zoom-fit-btn").addEventListener("click", fitToContent);
        document.getElementById("zoom-reset-btn").addEventListener("click", resetView);
        const minimapContainer = document.getElementById("minimap-container");
        const minimapSvg = document.getElementById("minimap");
        let minimapDragging = false;
        minimapContainer.addEventListener("mousedown", (e) => {
         e.preventDefault();
         minimapDragging = true;
         updatePanFromMinimap(e);
        });
        minimapContainer.addEventListener("touchstart",
         (e) => {
          e.preventDefault();
          minimapDragging = true;
          updatePanFromMinimapTouch(e);
         }, {
          passive: false
         }, );
        document.addEventListener("mousemove", (e) => {
         if (minimapDragging) {
          updatePanFromMinimap(e);
         }
        });
        document.addEventListener("touchmove", (e) => {
         if (minimapDragging && e.touches[0]) {
          updatePanFromMinimapTouch(e);
         }
        });
        document.addEventListener("mouseup", () => {
         minimapDragging = false;
        });
        document.addEventListener("touchend", () => {
         minimapDragging = false;
        });
      
        function updatePanFromMinimap(e) {
         const rect = minimapContainer.getBoundingClientRect();
         const x = (e.clientX - rect.left) / rect.width;
         const y = (e.clientY - rect.top) / rect.height;
         const viewWidth = CANVAS_WIDTH / canvasState.zoom;
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         canvasState.panX = x * CANVAS_WIDTH - viewWidth / 2;
         canvasState.panY = y * CANVAS_HEIGHT - viewHeight / 2;
         constrainPan();
         updateViewBox();
        }
      
        function updatePanFromMinimapTouch(e) {
         const rect = minimapContainer.getBoundingClientRect();
         const touch = e.touches[0];
         const x = (touch.clientX - rect.left) / rect.width;
         const y = (touch.clientY - rect.top) / rect.height;
         const viewWidth = CANVAS_WIDTH / canvasState.zoom;
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         canvasState.panX = x * CANVAS_WIDTH - viewWidth / 2;
         canvasState.panY = y * CANVAS_HEIGHT - viewHeight / 2;
         constrainPan();
         updateViewBox();
        }
        document.addEventListener("keydown", (e) => {
         if (document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "TEXTAREA") return;
         if (
          (e.key === "+" || e.key === "=") && (e.ctrlKey || e.metaKey)) {
          e.preventDefault();
          zoomTo(canvasState.zoom * 1.25, 0.5, 0.5);
         } else if (e.key === "-" && (e.ctrlKey || e.metaKey)) {
          e.preventDefault();
          zoomTo(canvasState.zoom * 0.8, 0.5, 0.5);
         } else if (e.key === "0" && (e.ctrlKey || e.metaKey)) {
          e.preventDefault();
          resetView();
         }
        });
        setTimeout(() => {
         fitToContent();
        }, 100);
       })();
       const sizeSlider = document.getElementById("size-slider");
       const sizeValue = document.getElementById("size-value");
       const resetSizeBtn = document.getElementById("reset-size");
       sizeSlider.addEventListener("input", () => {
        const newSize = parseInt(sizeSlider.value, 10);
        sizeValue.textContent = newSize;
        savedSizes[currentNodeId] = newSize;
        const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
        if (nodeGroup) {
         const oldShape = nodeGroup.querySelector(".node-circle");
         if (oldShape) oldShape.remove();
         const newShape = createNodeShape(currentNodeId, newSize);
         nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
         const styles = resolveStylesForNode(currentNodeId);
         if (styles.circleColor) newShape.style.stroke = styles.circleColor;
         const label = nodeGroup.querySelector(".node-label");
         const sub = nodeGroup.querySelector(".node-sub");
         if (label) {
          label.setAttribute("y", -newSize * 0.28);
          const labelSize = styles.titleSize || newSize * 0.33;
          label.style.fontSize = labelSize + "px";
         }
         if (sub) {
          sub.setAttribute("y", newSize * 0.4);
          const subSize = styles.subSize || newSize * 0.24;
          sub.style.fontSize = subSize + "px";
         }
       updatePingIndicator(currentNodeId);
        }
       });
       resetSizeBtn.addEventListener("click", () => {
        delete savedSizes[currentNodeId];
        const defaultSize = getDefaultSize();
        sizeSlider.value = defaultSize;
        sizeValue.textContent = defaultSize;
        const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
        if (nodeGroup) {
         const oldShape = nodeGroup.querySelector(".node-circle");
         if (oldShape) oldShape.remove();
         const shapeType = (NODE_DATA[currentNodeId] && NODE_DATA[currentNodeId].shape) || "circle";
         const newShape = createNodeShape(currentNodeId, defaultSize);
         nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
         const styles = resolveStylesForNode(currentNodeId);
         if (styles.circleColor) newShape.style.stroke = styles.circleColor;
         const label = nodeGroup.querySelector(".node-label");
         const sub = nodeGroup.querySelector(".node-sub");
         if (label) {
          label.setAttribute("y", -defaultSize * 0.28);
          const labelSize = styles.titleSize || defaultSize * 0.33;
          label.style.fontSize = labelSize + "px";
         }
         if (sub) {
          sub.setAttribute("y", defaultSize * 0.4);
          const subSize = styles.subSize || defaultSize * 0.24;
          sub.style.fontSize = subSize + "px";
         }
          updatePingIndicator(currentNodeId);
      
        }
       });
       const applyStyle = (property, value) => {
        const styleEntry = ensureStyleEntry(currentNodeId);
        const scopeKey = currentStyleScope || "all";
        if (!styleEntry[scopeKey]) styleEntry[scopeKey] = {};
        styleEntry[scopeKey][property] = value;
        const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
        if (!nodeGroup) return;
        const shapeEl = nodeGroup.querySelector(".node-circle");
        const label = nodeGroup.querySelector(".node-label");
        const sub = nodeGroup.querySelector(".node-sub");
        if (property === "circleColor" && shapeEl) shapeEl.style.stroke = value;
        else if (property === "titleColor" && label) label.style.fill = value;
        else if (property === "titleFont" && label) label.style.fontFamily = value;
        else if (property === "titleSize" && label) label.style.fontSize = value + "px";
        else if (property === "subColor" && sub) sub.style.fill = value;
        else if (property === "subFont" && sub) sub.style.fontFamily = value;
        else if (property === "subSize" && sub) sub.style.fontSize = value + "px";
       };
       document.getElementById("circle-color").addEventListener("input", (e) => applyStyle("circleColor", e.target.value), );
       document.getElementById("title-color").addEventListener("input", (e) => applyStyle("titleColor", e.target.value), );
       document.getElementById("title-font").addEventListener("change", (e) => applyStyle("titleFont", e.target.value), );
       document.getElementById("title-size").addEventListener("input", (e) => applyStyle("titleSize", parseInt(e.target.value, 10)), );
       document.getElementById("sub-color").addEventListener("input", (e) => applyStyle("subColor", e.target.value), );
       document.getElementById("sub-font").addEventListener("change", (e) => applyStyle("subFont", e.target.value), );
       document.getElementById("sub-size").addEventListener("input", (e) => applyStyle("subSize", parseInt(e.target.value, 10)), );
       document.getElementById("title-offset-y").addEventListener("input", (e) => {
        applyStyle("titleOffsetY", parseInt(e.target.value, 10) || 0);
        forgeTheTopology();
        if (currentNodeId) claimTheImmortal(currentNodeId);
       });
       document.getElementById("title-offset-x").addEventListener("input", (e) => {
        applyStyle("titleOffsetX", parseInt(e.target.value, 10) || 0);
        forgeTheTopology();
        if (currentNodeId) claimTheImmortal(currentNodeId);
       });
       document.getElementById("sub-offset-y").addEventListener("input", (e) => {
        applyStyle("subOffsetY", parseInt(e.target.value, 10) || 0);
        forgeTheTopology();
        if (currentNodeId) claimTheImmortal(currentNodeId);
       });
       document.getElementById("sub-offset-x").addEventListener("input", (e) => {
        applyStyle("subOffsetX", parseInt(e.target.value, 10) || 0);
        forgeTheTopology();
        if (currentNodeId) claimTheImmortal(currentNodeId);
       });
      document.getElementById("ping-offset-x").addEventListener("input", (e) => {
      applyStyle("pingOffsetX", parseInt(e.target.value, 10) || 0);
      updatePingIndicator(currentNodeId);
      if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      
      document.getElementById("ping-offset-y").addEventListener("input", (e) => {
      applyStyle("pingOffsetY", parseInt(e.target.value, 10) || 0);
      updatePingIndicator(currentNodeId);
      if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      
       document.getElementById("reset-styles").addEventListener("click", () => {
        delete savedStyles[currentNodeId];
        forgeTheTopology();
        claimTheImmortal(currentNodeId);
       });
       document.getElementById("style-scope").addEventListener("change", (e) => {
        currentStyleScope = e.target.value || "all";
        claimTheImmortal(currentNodeId);
       });
       document.getElementById("shape-select").addEventListener("change", (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId]) return;
        const shape = e.target.value || "circle";
        NODE_DATA[currentNodeId].shape = shape;
        const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
        if (!nodeGroup) return;
        const oldShape = nodeGroup.querySelector(".node-circle");
        if (oldShape) oldShape.remove();
        const size = savedSizes[currentNodeId] || getDefaultSize();
        const newShape = createNodeShape(currentNodeId, size);
        nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
       });
       const addNoteBtn = document.getElementById("add-note-btn");
       const noteInput = document.getElementById("new-note-input");
       addNoteBtn.addEventListener("click", () => {
        const newNote = noteInput.value.trim();
        if (newNote && currentNodeId && NODE_DATA[currentNodeId]) {
         NODE_DATA[currentNodeId].notes.push(newNote);
         claimTheImmortal(currentNodeId);
         noteInput.value = "";
        }
       });
       noteInput.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
         addNoteBtn.click();
        }
       });
       
       document.getElementById('node-pingable').addEventListener('change', (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId]) return;
        if (!NODE_DATA[currentNodeId].ping) {
         NODE_DATA[currentNodeId].ping = {
          enabled: false,
          protocol: 'http',
          customUrl: '',
          timeout: 3000,
          status: 'unknown',
          lastCheck: null
         };
        }
        NODE_DATA[currentNodeId].ping.enabled = e.target.checked;
        document.getElementById('node-ping-options').style.display = e.target.checked ? 'block' : 'none';
        forgeTheTopology();
       });
       
       document.getElementById('node-ping-protocol').addEventListener('change', (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId].ping) return;
        NODE_DATA[currentNodeId].ping.protocol = e.target.value;
        document.getElementById('node-custom-url-container').style.display = 
         e.target.value === 'custom' ? 'block' : 'none';
       });
       
       document.getElementById('node-custom-url').addEventListener('change', (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId].ping) return;
        NODE_DATA[currentNodeId].ping.customUrl = e.target.value.trim();
       });
       
       document.getElementById('node-ping-timeout').addEventListener('change', (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId].ping) return;
        NODE_DATA[currentNodeId].ping.timeout = parseInt(e.target.value) || 3000;
       });
       
       document.getElementById('check-ping-now').addEventListener('click', () => {
        if (!currentNodeId) return;
        checkNodeStatus(currentNodeId);
       });
       
       document.getElementById("edge-width").addEventListener("input", () => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        const v = parseInt(document.getElementById("edge-width").value, 10);
        if (Number.isNaN(v) || v <= 0) return;
        edge.width = v;
        saveEdgeData();
        const el = document.querySelector(`.edge[data-edge-id="${currentEdgeId}"]`, );
        if (el) el.style.strokeWidth = v;
       });
       document.getElementById("edge-color").addEventListener("input", () => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        const color = document.getElementById("edge-color").value;
        edge.color = color;
        saveEdgeData();
        const el = document.querySelector(`.edge[data-edge-id="${currentEdgeId}"]`, );
        if (el) el.style.stroke = color;
        forgeTheLegend();
       });
       document.getElementById("edge-direction").addEventListener("change", () => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        edge.direction = document.getElementById("edge-direction").value;
        saveEdgeData();
        forgeTheTopology();
        selectTheConnection(currentEdgeId);
       });
       document.getElementById("edge-line-style").addEventListener("change", () => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        edge.lineStyle = document.getElementById("edge-line-style").value;
        saveEdgeData();
        forgeTheTopology();
        selectTheConnection(currentEdgeId);
       });
       const addEdgeNoteBtn = document.getElementById("add-edge-note");
       const newEdgeNoteInput = document.getElementById("new-edge-note");
       addEdgeNoteBtn.addEventListener("click", () => {
        const txt = newEdgeNoteInput.value.trim();
        if (!txt || !currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        edge.notes.push(txt);
        saveEdgeData();
        newEdgeNoteInput.value = "";
        selectTheConnection(currentEdgeId);
       });
       newEdgeNoteInput.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
         addEdgeNoteBtn.click();
        }
       });
       document.getElementById("delete-edge").addEventListener("click", () => {
        if (!currentEdgeId) return;
        challengeTheImmortal("Are you sure you want to delete this line?",
         () => {
          EDGE_DATA.list = EDGE_DATA.list.filter(
           (e) => e.id !== currentEdgeId, );
          saveEdgeData();
          currentEdgeId = null;
          forgeTheTopology();
          const availableNodes = Object.keys(NODE_DATA);
          if (availableNodes.length > 0) {
           claimTheImmortal(availableNodes[0]);
          } else {
           document.getElementById("node-panel").style.display = "none";
           document.getElementById("edge-panel").style.display = "none";
           document.getElementById("topology-toolbar", ).style.display = "none";
          }
         }, );
       });
       document.getElementById("add-line-btn").addEventListener("click", () => {
        if (!currentNodeId) return;
        const select = document.getElementById("add-line-select");
        const directionSelect = document.getElementById("add-line-direction");
        const colorInput = document.getElementById("add-line-color");
        const targetId = select.value;
        if (!targetId || targetId === currentNodeId) return;
        const direction = directionSelect.value || "none";
        const lineColor = colorInput.value || "#475569";
        const newId = `${currentNodeId}-${targetId}-${Date.now()}`;
        const newEdge = {
         id: newId,
         from: currentNodeId,
         to: targetId,
         width: 4,
         color: lineColor,
         direction: direction,
         type: "main",
         notes: [],
         fromPort: "",
         toPort: "",
        };
        EDGE_DATA.list.push(newEdge);
        saveEdgeData();
        forgeTheTopology();
        claimTheImmortal(currentNodeId);
       });
       let freeDrawMode = false;
       let rectDrawMode = false;
       let currentTextId = null;
       let rectStartPoint = null;
       let rectPreviewEl = null;
       let rectStyle = "filled";
       let freeDrawPoints = [];
       let freeDrawPolylineEl = null;
       let freeDrawPointEls = [];
       const drawToggleBtn = document.getElementById("draw-toggle");
       const drawUndoBtn = document.getElementById("draw-undo");
       const drawColorInput = document.getElementById("draw-color");
       const drawStyleSelect = document.getElementById("draw-style");
       const drawArrowSelect = document.getElementById("draw-arrow");
       const svgMap = document.getElementById("map");
      
       function updateFreeDrawGraphics() {
        const ns = "http://www.w3.org/2000/svg";
        const svg = svgMap;
        if (!freeDrawPolylineEl && freeDrawPoints.length > 0) {
         freeDrawPolylineEl = document.createElementNS(ns, "polyline");
         freeDrawPolylineEl.classList.add("edge", "free-preview");
         freeDrawPolylineEl.setAttribute("fill", "none");
         svg.appendChild(freeDrawPolylineEl);
        }
        if (freeDrawPolylineEl) {
         if (freeDrawPoints.length === 0) {
          freeDrawPolylineEl.remove();
          freeDrawPolylineEl = null;
         } else {
          const ptsStr = freeDrawPoints.map((p) => `${p.x},${p.y}`).join(" ");
          freeDrawPolylineEl.setAttribute("points", ptsStr);
          freeDrawPolylineEl.style.stroke = drawColorInput.value || "#475569";
          freeDrawPolylineEl.style.strokeWidth = 3;
          const lineStyle = drawStyleSelect.value || "solid";
          if (lineStyle === "dashed") {
           freeDrawPolylineEl.style.strokeDasharray = "10,5";
          } else if (lineStyle === "dotted") {
           freeDrawPolylineEl.style.strokeDasharray = "2,4";
          } else {
           freeDrawPolylineEl.style.strokeDasharray = "none";
          }
         }
        }
        freeDrawPointEls.forEach((el) => el.remove());
        freeDrawPointEls = [];
        freeDrawPoints.forEach((p, idx) => {
         const c = document.createElementNS(ns, "circle");
         c.classList.add("free-point");
         c.setAttribute("cx", p.x);
         c.setAttribute("cy", p.y);
         c.setAttribute("r", 5);
         c.dataset.index = String(idx);
         c.addEventListener("mousedown", (e) => {
          if (!freeDrawMode) return;
          e.preventDefault();
          e.stopPropagation();
          let dragging = true;
          const svgEl = svgMap;
          const moveHandler = (ev) => {
           if (!dragging) return;
           const pt = svgEl.createSVGPoint();
           pt.x = ev.clientX;
           pt.y = ev.clientY;
           const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
           const i = parseInt(c.dataset.index, 10);
           if (Number.isNaN(i) || !freeDrawPoints[i]) return;
           freeDrawPoints[i].x = svgP.x;
           freeDrawPoints[i].y = svgP.y;
           updateFreeDrawGraphics();
          };
          const upHandler = () => {
           dragging = false;
           document.removeEventListener("mousemove", moveHandler);
           document.removeEventListener("mouseup", upHandler);
          };
          document.addEventListener("mousemove", moveHandler);
          document.addEventListener("mouseup", upHandler);
         });
         c.addEventListener("touchstart",
          (e) => {
           if (!freeDrawMode) return;
           e.preventDefault();
           e.stopPropagation();
           let dragging = true;
           const svgEl = svgMap;
           const touchMoveHandler = (ev) => {
            if (!dragging || !ev.touches[0]) return;
            const pt = svgEl.createSVGPoint();
            pt.x = ev.touches[0].clientX;
            pt.y = ev.touches[0].clientY;
            const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
            const i = parseInt(c.dataset.index, 10);
            if (Number.isNaN(i) || !freeDrawPoints[i]) return;
            freeDrawPoints[i].x = svgP.x;
            freeDrawPoints[i].y = svgP.y;
            updateFreeDrawGraphics();
           };
           const touchUpHandler = () => {
            dragging = false;
            document.removeEventListener("touchmove", touchMoveHandler, );
            document.removeEventListener("touchend", touchUpHandler, );
           };
           document.addEventListener("touchmove", touchMoveHandler);
           document.addEventListener("touchend", touchUpHandler);
          }, {
           passive: false
          }, );
         svg.appendChild(c);
         freeDrawPointEls.push(c);
        });
        drawUndoBtn.style.display = freeDrawPoints.length ? "inline-block" : "none";
       }
      
       function addFreeDrawPoint(x, y) {
        freeDrawPoints.push({
         x,
         y
        });
        updateFreeDrawGraphics();
       }
      
       function startFreeDraw() {
        freeDrawMode = true;
        freeDrawPoints = [];
        if (freeDrawPolylineEl) {
         freeDrawPolylineEl.remove();
         freeDrawPolylineEl = null;
        }
        freeDrawPointEls.forEach((el) => el.remove());
        freeDrawPointEls = [];
        svgMap.style.cursor = "crosshair";
        drawToggleBtn.textContent = "Done";
        drawUndoBtn.style.display = "none";
       }
      
       function finishFreeDraw() {
        freeDrawMode = false;
        svgMap.style.cursor = "";
        drawToggleBtn.textContent = "âœï¸";
        if (freeDrawPoints.length >= 2) {
         const color = drawColorInput.value || "#475569";
         const lineStyle = drawStyleSelect.value || "solid";
         const arrowDir = drawArrowSelect.value || "none";
         const newId = "custom-" + Date.now();
         const pointsCopy = freeDrawPoints.map((p) => ({
          x: p.x,
          y: p.y,
         }));
         EDGE_DATA.list.push({
          id: newId,
          type: "custom",
          color,
          width: 4,
          lineStyle: lineStyle,
          direction: arrowDir,
          points: pointsCopy,
          notes: [],
         });
         saveEdgeData();
         freeDrawPoints = [];
         if (freeDrawPolylineEl) {
          freeDrawPolylineEl.remove();
          freeDrawPolylineEl = null;
         }
         freeDrawPointEls.forEach((el) => el.remove());
         freeDrawPointEls = [];
         forgeTheTopology();
         selectTheConnection(newId);
        } else {
         freeDrawPoints = [];
         if (freeDrawPolylineEl) {
          freeDrawPolylineEl.remove();
          freeDrawPolylineEl = null;
         }
         freeDrawPointEls.forEach((el) => el.remove());
         freeDrawPointEls = [];
         forgeTheLegend();
        }
        drawUndoBtn.style.display = "none";
       }
       drawToggleBtn.addEventListener("click", () => {
        if (currentView.mode === "rack") {
         alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
         return;
        }
        
        if (freeDrawMode) {
         finishFreeDraw();
        } else {
         startFreeDraw();
        }
       });
       drawUndoBtn.addEventListener("click", () => {
        if (!freeDrawMode || !freeDrawPoints.length) return;
        freeDrawPoints.pop();
        updateFreeDrawGraphics();
       });
       const drawToolbar = document.getElementById("draw-toolbar");
       drawToolbar.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       drawToolbar.addEventListener("click", (e) => {
        if (e.target !== drawToggleBtn && e.target !== drawUndoBtn) {
         e.stopPropagation();
        }
       });
       drawStyleSelect.addEventListener("change", () => {
        if (freeDrawMode) {
         updateFreeDrawGraphics();
        }
       });
       drawArrowSelect.addEventListener("change", () => {
        if (freeDrawMode) {
         updateFreeDrawGraphics();
        }
       });
       drawColorInput.addEventListener("input", () => {
        if (freeDrawMode) {
         updateFreeDrawGraphics();
        }
       });
       drawStyleSelect.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       drawStyleSelect.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       drawArrowSelect.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       drawArrowSelect.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       drawColorInput.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       drawColorInput.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       svgMap.addEventListener("click", (e) => {
        if (!freeDrawMode) return;
        if (e.button !== 0) return;
        const target = e.target;
        if (target && target.classList && target.classList.contains("free-point")) return;
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        addFreeDrawPoint(svgP.x, svgP.y);
       });
       svgMap.addEventListener("touchend",
        (e) => {
         if (!freeDrawMode) return;
         const target = e.target;
         if (target && target.classList && target.classList.contains("free-point")) return;
         if (e.changedTouches && e.changedTouches[0]) {
          e.preventDefault();
          const svgEl = svgMap;
          const pt = svgEl.createSVGPoint();
          pt.x = e.changedTouches[0].clientX;
          pt.y = e.changedTouches[0].clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          addFreeDrawPoint(svgP.x, svgP.y);
         }
        }, {
         passive: false
        }, );
       const settingsBtn = document.getElementById("settings-btn");
      
       const rectToggleBtn = document.getElementById("rect-toggle");
       const rectStyleSelect = document.getElementById("rect-style");
      
       function updateRectPreview() {
        if (!rectPreviewEl || !rectStartPoint) return;
        
        const ns = "http://www.w3.org/2000/svg";
        const svg = svgMap;
        
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
       }
      
       function startRectDraw() {
        rectDrawMode = true;
        rectStartPoint = null;
        rectPreviewEl = null;
        svgMap.style.cursor = "crosshair";
        rectToggleBtn.textContent = "Done";
        rectStyle = rectStyleSelect.value || "filled";
        
        if (freeDrawMode) {
         finishFreeDraw();
        }
        updateRectangleDeleteButtons();
       }
      
       function finishRectDraw() {
        rectDrawMode = false;
        svgMap.style.cursor = "";
        rectToggleBtn.textContent = "â–­";
        
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
       }
        updateRectangleDeleteButtons();
      
       rectToggleBtn.addEventListener("click", () => {
        if (currentView.mode === "rack") {
         alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
         return;
        }
        
        if (rectDrawMode) {
         finishRectDraw();
        } else {
         startRectDraw();
        }
       });
      
       rectStyleSelect.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       rectStyleSelect.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       rectStyleSelect.addEventListener("change", () => {
        if (rectDrawMode) {
         rectStyle = rectStyleSelect.value || "filled";
        }
       });
      
       svgMap.addEventListener("mousedown", (e) => {
        if (!rectDrawMode) return;
        if (e.button !== 0) return;
        e.preventDefault();
        e.stopPropagation();
        
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        rectStartPoint = { x: svgP.x, y: svgP.y };
        
        const ns = "http://www.w3.org/2000/svg";
        rectPreviewEl = document.createElementNS(ns, "rect");
        rectPreviewEl.classList.add("rect-preview");
        rectPreviewEl.setAttribute("x", svgP.x);
        rectPreviewEl.setAttribute("y", svgP.y);
        rectPreviewEl.setAttribute("width", 0);
        rectPreviewEl.setAttribute("height", 0);
        
        const color = drawColorInput.value || "#f97316";
        rectPreviewEl.style.stroke = color;
        rectPreviewEl.style.strokeWidth = 2;
        rectPreviewEl.style.strokeDasharray = "5,5";
        
        if (rectStyle === "filled") {
         rectPreviewEl.style.fill = color;
         rectPreviewEl.style.fillOpacity = "0.3";
        } else {
         rectPreviewEl.style.fill = "none";
        }
        
        svgEl.appendChild(rectPreviewEl);
       });
      
       svgMap.addEventListener("mousemove", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        
        rectPreviewEl.setAttribute("x", x);
        rectPreviewEl.setAttribute("y", y);
        rectPreviewEl.setAttribute("width", width);
        rectPreviewEl.setAttribute("height", height);
       });
      
       svgMap.addEventListener("mouseup", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        
        if (width > 10 && height > 10) {
		pushUndo("draw rectangle"); 
         const color = drawColorInput.value || "#f97316";
         const newId = "rect-" + Date.now();
         
         RECT_DATA.list.push({
          id: newId,
          x: x,
          y: y,
          width: width,
          height: height,
          color: color,
          style: rectStyle,
          notes: []
         });
         
         forgeTheTopology();
        }
        
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
       });
      
       let rectTouchStart = null;
       
       svgMap.addEventListener("touchstart", (e) => {
        if (!rectDrawMode) return;
        if (e.touches.length !== 1) return;
        
        e.preventDefault();
        const touch = e.touches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        rectStartPoint = { x: svgP.x, y: svgP.y };
        rectTouchStart = { x: svgP.x, y: svgP.y };
        
        const ns = "http://www.w3.org/2000/svg";
        rectPreviewEl = document.createElementNS(ns, "rect");
        rectPreviewEl.classList.add("rect-preview");
        rectPreviewEl.setAttribute("x", svgP.x);
        rectPreviewEl.setAttribute("y", svgP.y);
        rectPreviewEl.setAttribute("width", 0);
        rectPreviewEl.setAttribute("height", 0);
        
        const color = drawColorInput.value || "#f97316";
        rectPreviewEl.style.stroke = color;
        rectPreviewEl.style.strokeWidth = 2;
        rectPreviewEl.style.strokeDasharray = "5,5";
        
        if (rectStyle === "filled") {
         rectPreviewEl.style.fill = color;
         rectPreviewEl.style.fillOpacity = "0.3";
        } else {
         rectPreviewEl.style.fill = "none";
        }
        
        svgEl.appendChild(rectPreviewEl);
       }, { passive: false });
      
       svgMap.addEventListener("touchmove", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        if (e.touches.length !== 1) return;
        
        e.preventDefault();
        const touch = e.touches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        
        rectPreviewEl.setAttribute("x", x);
        rectPreviewEl.setAttribute("y", y);
        rectPreviewEl.setAttribute("width", width);
        rectPreviewEl.setAttribute("height", height);
       }, { passive: false });
      
       svgMap.addEventListener("touchend", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        if (!rectTouchStart) return;
        
        e.preventDefault();
        const touch = e.changedTouches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        
        if (width > 10 && height > 10) {
		pushUndo("draw rectangle");
         const color = drawColorInput.value || "#f97316";
         const newId = "rect-" + Date.now();
         
         RECT_DATA.list.push({
          id: newId,
          x: x,
          y: y,
          width: width,
          height: height,
          color: color,
          style: rectStyle,
          notes: []
         });
         
         forgeTheTopology();
        }
        
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
        rectTouchStart = null;
       }, { passive: false });
      
       const textToggleBtn = document.getElementById("text-toggle");
       
       function startTextMode() {
        textDrawMode = true;
        svgMap.style.cursor = "crosshair";
        textToggleBtn.textContent = "Done";
        textToggleBtn.style.background = "var(--accent)";
        textToggleBtn.style.color = "var(--bg)";
        
        if (freeDrawMode) {
         finishFreeDraw();
        }
        if (rectDrawMode) {
         finishRectDraw();
        }
        
        updateTextDeleteButtons();
       }
       
       function finishTextMode() {
        textDrawMode = false;
        svgMap.style.cursor = "";
        textToggleBtn.textContent = "T";
        textToggleBtn.style.background = "";
        textToggleBtn.style.color = "";
        updateTextDeleteButtons();
       }
       
       textToggleBtn.addEventListener("click", () => {
        if (currentView.mode === "rack") {
         alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
         return;
        }
        
        if (textDrawMode) {
         finishTextMode();
        } else {
         startTextMode();
        }
       });
       
       function handleTextPlacement(e) {
        if (!textDrawMode) return;
        
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        const newId = "text-" + Date.now();
		pushUndo("add text");
        TEXT_DATA.list.push({
         id: newId,
         x: svgP.x,
         y: svgP.y,
         content: "New Text",
         fontSize: 18,
         color: "#e2e8f0",
         fontWeight: "normal",
         fontStyle: "normal",
         textAlign: "start",
         textDecoration: "none",
         bgColor: "#000000",
         bgEnabled: false,
         opacity: 1
        });
        
        forgeTheTopology();
        
        showTextPanel(newId);
       }
       
       svgMap.addEventListener("click", (e) => {
        if (!textDrawMode) return;
        if (e.target.closest('.text-delete-btn')) return;
        if (e.target.closest('.text-group')) return;
        
        e.preventDefault();
        e.stopPropagation();
        handleTextPlacement(e);
       });
       
       svgMap.addEventListener("touchend", (e) => {
        if (!textDrawMode) return;
        if (e.target.closest('.text-delete-btn')) return;
        if (e.target.closest('.text-group')) return;
        if (e.touches.length > 0) return;
        
        e.preventDefault();
        const touch = e.changedTouches[0];
        const fakeEvent = {
         clientX: touch.clientX,
         clientY: touch.clientY,
         preventDefault: () => {},
         stopPropagation: () => {}
        };
        handleTextPlacement(fakeEvent);
       }, { passive: false });
       
       function showTextPanel(textId) {
        currentTextId = textId;
        const textItem = TEXT_DATA.list.find(t => t.id === textId);
        if (!textItem) return;
        
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        
        const textPanel = document.getElementById("text-panel");
        textPanel.style.display = "block";
        
        document.getElementById("text-content").value = textItem.content;
        document.getElementById("text-font-size").value = textItem.fontSize;
        document.getElementById("text-color").value = textItem.color;
        document.getElementById("text-font-weight").value = textItem.fontWeight;
        document.getElementById("text-font-style").value = textItem.fontStyle;
        document.getElementById("text-align").value = textItem.textAlign;
        document.getElementById("text-decoration").value = textItem.textDecoration;
        document.getElementById("text-bg-color").value = textItem.bgColor;
        document.getElementById("text-bg-enabled").checked = textItem.bgEnabled;
        document.getElementById("text-opacity").value = textItem.opacity;
        document.getElementById("text-opacity-val").textContent = Math.round(textItem.opacity * 100) + "%";
       }
       
       function updateTextDeleteButtons() {
        const deleteButtons = document.querySelectorAll('.text-delete-btn');
        deleteButtons.forEach(btn => {
         btn.style.display = textDrawMode ? 'block' : 'none';
        });
       }
       
       function deleteText(textId) {
	    pushUndo("delete text");
        TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== textId);
        forgeTheTopology();
        
        if (currentTextId === textId) {
         document.getElementById("text-panel").style.display = "none";
         currentTextId = null;
        }
       }
       
       document.getElementById("text-content").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
		 pushUndo("edit text");
         textItem.content = e.target.value;
         forgeTheTopology();
        }
       });
       
       document.getElementById("text-font-size").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         textItem.fontSize = parseInt(e.target.value);
         forgeTheTopology();
        }
       });
       
       document.getElementById("text-color").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         textItem.color = e.target.value;
         forgeTheTopology();
        }
       });
       
       document.getElementById("text-font-weight").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         textItem.fontWeight = e.target.value;
         forgeTheTopology();
        }
       });
       
       document.getElementById("text-font-style").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         textItem.fontStyle = e.target.value;
         forgeTheTopology();
        }
       });
       
       document.getElementById("text-align").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         textItem.textAlign = e.target.value;
         forgeTheTopology();
        }
       });
       
       document.getElementById("text-decoration").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         textItem.textDecoration = e.target.value;
         forgeTheTopology();
        }
       });
       
       document.getElementById("text-bg-color").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         textItem.bgColor = e.target.value;
         forgeTheTopology();
        }
       });
       
       document.getElementById("text-bg-enabled").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         textItem.bgEnabled = e.target.checked;
         forgeTheTopology();
        }
       });
       
       document.getElementById("text-opacity").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         textItem.opacity = parseFloat(e.target.value);
         document.getElementById("text-opacity-val").textContent = Math.round(textItem.opacity * 100) + "%";
         forgeTheTopology();
        }
       });
       
       document.getElementById("delete-text").addEventListener("click", () => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         challengeTheImmortal(`Delete text "${textItem.content.substring(0, 30)}..."?`, () => {
          deleteText(currentTextId);
         });
        }
       });
      
       const settingsModal = document.getElementById("settings-modal");
       const settingsClose = document.getElementById("settings-close");
       settingsBtn.addEventListener("click", () => {	 
      document.getElementById("page-bg-color").value = rgbaToHex(PAGE_STATE.background) || "#050608";
        document.getElementById("topbar-bg-color").value = rgbaToHex(PAGE_STATE.topbarBg) || "#0b0e13";
        document.getElementById("topbar-border-color").value = rgbaToHex(PAGE_STATE.topbarBorder) || "#1f2533";	 
      document.getElementById("panel-color").value = rgbaToHex(PAGE_STATE.panel) || "#0b0e13";
      document.getElementById("panel-alt-color").value = rgbaToHex(PAGE_STATE.panelAlt) || "#10141b";
      document.getElementById("accent-color").value = rgbaToHex(PAGE_STATE.accent) || "#4fd1c5";
      document.getElementById("danger-color").value = rgbaToHex(PAGE_STATE.danger) || "#f56565";
      document.getElementById("text-main-color").value = rgbaToHex(PAGE_STATE.textMain) || "#e2e8f0";
      document.getElementById("text-soft-color").value = rgbaToHex(PAGE_STATE.textSoft) || "#94a3b8";
      
        
        document.getElementById("auto-ping-enabled").checked = autoPingEnabled;
        document.getElementById("auto-ping-interval").value = autoPingInterval;
        document.getElementById("auto-ping-settings").style.display = autoPingEnabled ? 'block' : 'none';
        
        settingsModal.classList.add("active");
       });
       settingsClose.addEventListener("click", () => {
        settingsModal.classList.remove("active");
       });
       settingsModal.addEventListener("click", (e) => {
        if (e.target === settingsModal) {
         settingsModal.classList.remove("active");
        }
       });
       document.getElementById("page-bg-color").addEventListener("input", (e) => {
        PAGE_STATE.background = e.target.value;
        wieldThePower();
       });
       document.getElementById("topbar-bg-color").addEventListener("input", (e) => {
        PAGE_STATE.topbarBg = e.target.value;
        wieldThePower();
       });
       document.getElementById("topbar-border-color").addEventListener("input", (e) => {
        PAGE_STATE.topbarBorder = e.target.value;
        wieldThePower();
       });
       document.getElementById("panel-color").addEventListener("input", (e) => {
        PAGE_STATE.panel = e.target.value;
        wieldThePower();
       });
       document.getElementById("panel-alt-color").addEventListener("input", (e) => {
        PAGE_STATE.panelAlt = e.target.value;
        wieldThePower();
       });
       document.getElementById("accent-color").addEventListener("input", (e) => {
        PAGE_STATE.accent = e.target.value;
        wieldThePower();
       });
       document.getElementById("danger-color").addEventListener("input", (e) => {
        PAGE_STATE.danger = e.target.value;
        wieldThePower();
       });
       document.getElementById("text-main-color").addEventListener("input", (e) => {
        PAGE_STATE.textMain = e.target.value;
        wieldThePower();
       });
       document.getElementById("text-soft-color").addEventListener("input", (e) => {
        PAGE_STATE.textSoft = e.target.value;
        wieldThePower();
       });
       
       (function initializeResizers() {
         const headerResizer = document.getElementById('header-resizer');
         const sidebarResizer = document.getElementById('sidebar-resizer');
         const mobileFooterResizer = document.getElementById('mobile-footer-resizer');
         
         let isResizing = false;
         let currentResizer = null;
         let startY = 0;
         let startX = 0;
         let startHeight = 0;
         let startWidth = 0;
         
         function getClientPos(e) {
           if (e.touches && e.touches.length > 0) {
             return { x: e.touches[0].clientX, y: e.touches[0].clientY };
           }
           return { x: e.clientX, y: e.clientY };
         }
         
         function startResize(resizer, type, e) {
           isResizing = true;
           currentResizer = type;
           const pos = getClientPos(e);
           
           if (type === 'header') {
             startY = pos.y;
             startHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--topbar-height'));
           } else if (type === 'sidebar') {
             startX = pos.x;
             startWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width'));
           } else if (type === 'mobile-footer') {
             startY = pos.y;
             const currentVh = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--mobile-footer-height'));
             startHeight = (currentVh / 100) * window.innerHeight;
           }
           
           resizer.classList.add('resizing');
           document.body.classList.add('resizing');
           document.body.style.cursor = (type === 'sidebar') ? 'col-resize' : 'row-resize';
           e.preventDefault();
         }
         
         if (headerResizer) {
           headerResizer.addEventListener('mousedown', (e) => startResize(headerResizer, 'header', e));
           headerResizer.addEventListener('touchstart', (e) => startResize(headerResizer, 'header', e), { passive: false });
         }
         
         if (sidebarResizer) {
           sidebarResizer.addEventListener('mousedown', (e) => startResize(sidebarResizer, 'sidebar', e));
           sidebarResizer.addEventListener('touchstart', (e) => startResize(sidebarResizer, 'sidebar', e), { passive: false });
         }
         
         if (mobileFooterResizer) {
           mobileFooterResizer.addEventListener('mousedown', (e) => startResize(mobileFooterResizer, 'mobile-footer', e));
           mobileFooterResizer.addEventListener('touchstart', (e) => startResize(mobileFooterResizer, 'mobile-footer', e), { passive: false });
         }
         
         function handleMove(e) {
           if (!isResizing) return;
           
           const pos = getClientPos(e);
           
           if (currentResizer === 'header') {
             const deltaY = pos.y - startY;
             const newHeight = Math.max(40, Math.min(150, startHeight + deltaY));
             document.documentElement.style.setProperty('--topbar-height', newHeight + 'px');
           } else if (currentResizer === 'sidebar') {
             const deltaX = startX - pos.x;
             const newWidth = Math.max(200, Math.min(800, startWidth + deltaX));
             document.documentElement.style.setProperty('--sidebar-width', newWidth + 'px');
           } else if (currentResizer === 'mobile-footer') {
             const deltaY = startY - pos.y;
             const newHeight = startHeight + deltaY;
             const newVh = Math.max(15, Math.min(80, (newHeight / window.innerHeight) * 100));
             document.documentElement.style.setProperty('--mobile-footer-height', newVh + 'vh');
           }
           
           e.preventDefault();
         }
         
         document.addEventListener('mousemove', handleMove);
         document.addEventListener('touchmove', handleMove, { passive: false });
         
         function handleEnd() {
           if (isResizing) {
             isResizing = false;
             
             if (currentResizer === 'header') {
               PAGE_STATE.topbarHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--topbar-height'));
               headerResizer.classList.remove('resizing');
             } else if (currentResizer === 'sidebar') {
               PAGE_STATE.sidebarWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width'));
               sidebarResizer.classList.remove('resizing');
             } else if (currentResizer === 'mobile-footer') {
               PAGE_STATE.mobileFooterHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--mobile-footer-height'));
               mobileFooterResizer.classList.remove('resizing');
             }
             
             document.body.classList.remove('resizing');
             document.body.style.cursor = '';
             currentResizer = null;
           }
         }
         
         document.addEventListener('mouseup', handleEnd);
         document.addEventListener('touchend', handleEnd);
         document.addEventListener('touchcancel', handleEnd);
       })();
       
       document.getElementById("auto-ping-enabled").addEventListener("change", (e) => {
        autoPingEnabled = e.target.checked;
        PAGE_STATE.autoPingEnabled = autoPingEnabled;
        document.getElementById("auto-ping-settings").style.display = autoPingEnabled ? 'block' : 'none';
        
        if (autoPingEnabled) {
         startAutoPing();
        } else {
         stopAutoPing();
        }
       });
       
       document.getElementById("auto-ping-interval").addEventListener("change", (e) => {
        const newInterval = parseInt(e.target.value, 10);
        if (newInterval >= 5 && newInterval <= 3600) {
         autoPingInterval = newInterval;
         PAGE_STATE.autoPingInterval = autoPingInterval;
         
         if (autoPingEnabled) {
          startAutoPing();
         }
        }
       });
       
       document.getElementById("export-data-btn").addEventListener("click", () => {
        const data = captureTheQuickening();
        const jsonStr = JSON.stringify(data, null, 2);
        const blob = new Blob([jsonStr], {
         type: "application/json"
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        const safeTitle = (PAGE_STATE.title || "network-topology").toLowerCase().replace(/[^a-z0-9\-]+/g, "-");
        const timestamp = new Date().toISOString().split("T")[0];
        a.download = `${safeTitle}-data-${timestamp}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
       });
       document.getElementById("import-data-btn").addEventListener("click", () => {
        document.getElementById("import-data-file").click();
       });
       document.getElementById("import-data-file").addEventListener("change", async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        try {
         const text = await file.text();
         const data = JSON.parse(text);
         if (!data.nodeData || !data.edgeData) {
          alert("Invalid data file. Missing required fields.");
          return;
         }
         const confirmMsg = `This will replace all current data with the imported data.\n\nImporting:\n- ${Object.keys(data.nodeData).length} nodes\n- ${data.edgeData.list?.length || 0} connections\n\nContinue?`;
         if (!confirm(confirmMsg)) {
          e.target.value = "";
          return;
         }
         NODE_DATA = data.nodeData || {};
         EDGE_DATA = data.edgeData || {
          list: []
         };
         EDGE_LEGEND = data.edgeLegend || {};
         RECT_DATA = data.rectData || { list: [] };
         TEXT_DATA = data.textData || { list: [] };
         savedPositions = data.nodePositions || {};
         savedSizes = data.nodeSizes || {};
         savedStyles = data.nodeStyles || {};
         if (data.page) {
          PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, data.page, );
          wieldThePower();
         }
      
      if (data.autoPingEnabled !== undefined) {
      autoPingEnabled = data.autoPingEnabled;
      PAGE_STATE.autoPingEnabled = autoPingEnabled;
      document.getElementById("auto-ping-enabled").checked = autoPingEnabled;
      }
      
      if (data.autoPingInterval !== undefined) {
      autoPingInterval = data.autoPingInterval;
      PAGE_STATE.autoPingInterval = autoPingInterval;
      document.getElementById("auto-ping-interval").value = autoPingInterval;
      }
         if (data.canvas) {
          canvasState.zoom = data.canvas.zoom || 1;
          canvasState.panX = data.canvas.panX || 0;
          canvasState.panY = data.canvas.panY || 0;
         }
         if (data.page?.title) {
          document.title = data.page.title;
          document.querySelector(".editable-page-title", ).textContent = data.page.title;
         }
         forgeTheTopology();
         forgeTheLegend();
         updateViewBox();
      
      if (autoPingEnabled) {
      startAutoPing();
      } else {
      stopAutoPing();
      }
      
         const nodeIds = Object.keys(NODE_DATA);
         if (nodeIds.length > 0) {
          claimTheImmortal(nodeIds[0]);
         } else {
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("topology-toolbar").style.display = "none";
         }
         alert("Data imported successfully!");
         e.target.value = "";
        } catch (err) {
         console.error("Import error:", err);
         alert(`Failed to import data: ${err.message}`);
         e.target.value = "";
        }
       });
       const saveHelpBtn = document.getElementById("save-help-btn");
       const saveInfoModal = document.getElementById("save-info-modal");
       const saveInfoClose = document.getElementById("save-info-close");
       saveHelpBtn.addEventListener("click", () => {
        saveInfoModal.classList.add("active");
       });
       saveInfoClose.addEventListener("click", () => {
        saveInfoModal.classList.remove("active");
       });
       saveInfoModal.addEventListener("click", (e) => {
        if (e.target === saveInfoModal) {
         saveInfoModal.classList.remove("active");
        }
       });
       async function deriveKey(password, salt) {
      const encoder = new TextEncoder();
      
      const keyMaterial = await crypto.subtle.importKey(
      "raw",
      encoder.encode(password),
      "PBKDF2",
      false,
      ["deriveKey"]
      );
      
      return crypto.subtle.deriveKey(
      {
      name: "PBKDF2",
      salt: salt,
      iterations: 200000,  
      hash: "SHA-256"
      },
      keyMaterial,
      {
      name: "AES-GCM",
      length: 256
      },
      false,
      ["encrypt", "decrypt"]
      );
      }
      
       async function encryptData(data, password) {
      const encoder = new TextEncoder();
      const salt = crypto.getRandomValues(new Uint8Array(16));
      const iv   = crypto.getRandomValues(new Uint8Array(12));
      
      const key = await deriveKey(password, salt);
      const encrypted = await crypto.subtle.encrypt(
      { name: "AES-GCM", iv },
      key,
      encoder.encode(data)
      );
      
      const encryptedU8 = new Uint8Array(encrypted);
      
      const result = new Uint8Array(salt.length + iv.length + encryptedU8.length);
      result.set(salt, 0);
      result.set(iv, salt.length);
      result.set(encryptedU8, salt.length + iv.length);
      
      return "ENCRYPTED:" + u8ToBase64(result);
      }
      
       async function decryptData(encryptedData, password) {
      const base64Data = encryptedData.replace("ENCRYPTED:", "");
      const fullData   = base64ToU8(base64Data);
      
      const salt      = fullData.slice(0, 16);
      const iv        = fullData.slice(16, 28);
      const encrypted = fullData.slice(28);
      
      const key = await deriveKey(password, salt);
      
      const decrypted = await crypto.subtle.decrypt(
      { name: "AES-GCM", iv },
      key,
      encrypted
      );
      
      const decoder = new TextDecoder();
      return decoder.decode(decrypted);
      }
      
      
       function isEncrypted(data) {
        return typeof data === "string" && data.startsWith("ENCRYPTED:");
       }
      
       function captureTheQuickening() {
      return {
       nodeData: NODE_DATA,
       edgeData: EDGE_DATA,
       rectData: RECT_DATA,
       textData: TEXT_DATA,
       edgeLegend: EDGE_LEGEND,
       nodePositions: savedPositions,
       nodeSizes: savedSizes,
       nodeStyles: savedStyles,
       iconCache: IconLibrary.iconCache,
      
       page: PAGE_STATE,
      
       autoPingEnabled: autoPingEnabled,
       autoPingInterval: autoPingInterval,
      
       canvas: {
         zoom: canvasState.zoom,
         panX: canvasState.panX,
         panY: canvasState.panY,
       },
       
       savedTopologyView: savedTopologyView,
      };
      }
      
      
       function assembleTheImmortalForm() {
        const clone = document.documentElement.cloneNode(true);
        const nodeScript = clone.querySelector("#nodes-json");
        if (nodeScript) {
         nodeScript.textContent = JSON.stringify(NODE_DATA, null, 2);
        }
        let stateScript = clone.querySelector("#topology-state");
        if (!stateScript) {
         stateScript = document.createElement("script");
         stateScript.id = "topology-state";
         stateScript.type = "application/json";
         const body = clone.querySelector("body") || clone;
         body.appendChild(stateScript);
        }
        stateScript.textContent = JSON.stringify(captureTheQuickening(), null, 2, );
        return " <!DOCTYPE html> \n " + clone.outerHTML;
       }
       async function becomeImmortal() {
        const encryptEnabled = document.getElementById("encrypt-toggle").checked;
        let stateData = JSON.stringify(captureTheQuickening(), null, 2);
        if (encryptEnabled) {
         const password = prompt("Enter a password to encrypt your data:\n(Remember this password! You will need it to open this file and its non recoverable!)", );
         if (!password) {
          alert("Encryption cancelled. File not saved.");
          return;
         }
         const confirmPassword = prompt("Confirm your password:");
         if (password !== confirmPassword) {
          alert("Passwords do not match. File not saved.");
          return;
         }
         try {
          stateData = await encryptData(stateData, password);
         } catch (e) {
          alert("Encryption failed: " + e.message);
          return;
         }
        }
        const clone = document.documentElement.cloneNode(true);
        const nodeScript = clone.querySelector("#nodes-json");
        if (nodeScript) {
         if (encryptEnabled) {
          nodeScript.textContent = JSON.stringify({}, null, 2);
         } else {
          nodeScript.textContent = JSON.stringify(NODE_DATA, null, 2);
         }
        }
        let stateScript = clone.querySelector("#topology-state");
        if (!stateScript) {
         stateScript = document.createElement("script");
         stateScript.id = "topology-state";
         stateScript.type = "application/json";
         const body = clone.querySelector("body") || clone;
         body.appendChild(stateScript);
        }
        stateScript.textContent = stateData;
        const html = "<!DOCTYPE html> \n " + clone.outerHTML;
        const blob = new Blob([html], {
         type: "text/html"
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        const safeTitle = (PAGE_STATE.title || document.title || "network-topology").toLowerCase().replace(/[^a-z0-9\-]+/g, "-");
        a.download = safeTitle + ".html";
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
       }
       
      function captureState() {
	    return {
        nodes: JSON.parse(JSON.stringify(NODE_DATA)),
        edges: JSON.parse(JSON.stringify(EDGE_DATA)),
        positions: JSON.parse(JSON.stringify(savedPositions)),
        sizes: JSON.parse(JSON.stringify(savedSizes)),
        styles: JSON.parse(JSON.stringify(savedStyles)),
        legend: JSON.parse(JSON.stringify(EDGE_LEGEND)),
        rects: JSON.parse(JSON.stringify(RECT_DATA)),
        texts: JSON.parse(JSON.stringify(TEXT_DATA))
        };
      }
      
      function pushUndo(action = "") {
       const state = captureState();
       undoStack.push(state);
       if (undoStack.length > MAX_UNDO_STACK) {
        undoStack.shift();
       }
       redoStack = [];
       updateUndoButtons();
      }
      
      function undo() {
       if (undoStack.length === 0) return;
       const currentState = captureState();
       redoStack.push(currentState);
       const previousState = undoStack.pop();
       restoreState(previousState);
       updateUndoButtons();
      }
      
      function redo() {
       if (redoStack.length === 0) return;
       const currentState = captureState();
       undoStack.push(currentState);
       const nextState = redoStack.pop();
       restoreState(nextState);
       updateUndoButtons();
      }
      
      function restoreState(state) {
	   NODE_DATA = state.nodes;
       EDGE_DATA = state.edges;
       savedPositions = state.positions;
       savedSizes = state.sizes;
       savedStyles = state.styles;
       EDGE_LEGEND = state.legend;
       RECT_DATA = state.rects || { list: [] };
       TEXT_DATA = state.texts || { list: [] };
       forgeTheTopology();
       if (currentNodeId && NODE_DATA[currentNodeId]) {
       claimTheImmortal(currentNodeId);
       } else if (currentEdgeId) {
       selectTheConnection(currentEdgeId);
       }
      }
      
      function updateUndoButtons() {
       const undoBtn = document.getElementById("undo-btn");
       const redoBtn = document.getElementById("redo-btn");
       if (undoBtn) {
        undoBtn.disabled = undoStack.length === 0;
        undoBtn.style.opacity = undoStack.length === 0 ? "0.5" : "1";
       }
       if (redoBtn) {
        redoBtn.disabled = redoStack.length === 0;
        redoBtn.style.opacity = redoStack.length === 0 ? "0.5" : "1";
       }
      }
      
      function selectNode(nodeId, addToSelection = false) {
       if (!addToSelection) {
        selectedNodes.clear();
       }
       selectedNodes.add(nodeId);
       updateNodeSelection();
      }
      
      function clearSelection() {
       selectedNodes.clear();
       updateNodeSelection();
       clearSearchHighlight();
      }
      
      function updateNodeSelection() {
       document.querySelectorAll(".node-group").forEach(node => {
        const nodeId = node.dataset.nodeId;
        if (selectedNodes.has(nodeId)) {
         node.classList.add("selected");
        } else {
         node.classList.remove("selected");
        }
       });
       
       const bulkToolbar = document.getElementById("bulk-toolbar");
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       const bulkCount = document.getElementById("bulk-count");
       const bulkCountMobile = document.getElementById("bulk-count-mobile");
       const bulkCountModal = document.getElementById("bulk-count-modal");
       
       if (selectedNodes.size > 0) {
        if (bulkToolbar) bulkToolbar.style.display = "flex";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
        if (bulkCount) bulkCount.textContent = selectedNodes.size;
        if (bulkCountMobile) bulkCountMobile.textContent = selectedNodes.size;
        if (bulkCountModal) bulkCountModal.textContent = selectedNodes.size;
       } else {
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        const modal = document.getElementById("bulk-actions-modal");
        if (modal) modal.style.display = "none";
       }
      }
      
      function deleteSelected() {
       if (selectedNodes.size === 0) return;
       const count = selectedNodes.size;
       challengeTheImmortal(`Delete ${count} selected node${count > 1 ? 's' : ''}?`, () => {
        pushUndo("delete selected");
        selectedNodes.forEach(nodeId => {
         delete NODE_DATA[nodeId];
         delete savedPositions[nodeId];
         delete savedSizes[nodeId];
         delete savedStyles[nodeId];
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== nodeId && e.to !== nodeId);
        });
        selectedNodes.clear();
        saveEdgeData();
        forgeTheTopology();
        if (currentNodeId && !NODE_DATA[currentNodeId]) {
         currentNodeId = null;
         document.getElementById("node-panel").style.display = "none";
        }
        updateNodeSelection();
       });
      }
      
      function startSelection(event) {
       const svgEl = document.getElementById("map");
       const pt = svgEl.createSVGPoint();
       pt.x = event.clientX;
       pt.y = event.clientY;
       const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
       
       isSelecting = true;
       selectionStart = { x: svgP.x, y: svgP.y };
       
       if (!selectionRect) {
        selectionRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        selectionRect.setAttribute("fill", "rgba(79, 209, 197, 0.1)");
        selectionRect.setAttribute("stroke", "#4fd1c5");
        selectionRect.setAttribute("stroke-width", "2");
        selectionRect.setAttribute("stroke-dasharray", "5,5");
        selectionRect.style.pointerEvents = "none";
        svgEl.appendChild(selectionRect);
       }
       
       if (!event.shiftKey) {
        selectedNodes.clear();
       }
      }
      
      function updateSelection(event) {
       if (!isSelecting || !selectionStart) return;
       
       const svgEl = document.getElementById("map");
       const pt = svgEl.createSVGPoint();
       pt.x = event.clientX;
       pt.y = event.clientY;
       const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
       
       const x = Math.min(selectionStart.x, svgP.x);
       const y = Math.min(selectionStart.y, svgP.y);
       const width = Math.abs(svgP.x - selectionStart.x);
       const height = Math.abs(svgP.y - selectionStart.y);
       
       selectionRect.setAttribute("x", x);
       selectionRect.setAttribute("y", y);
       selectionRect.setAttribute("width", width);
       selectionRect.setAttribute("height", height);
       selectionRect.style.display = "block";
       
       document.querySelectorAll(".node-group").forEach(node => {
        const nodeId = node.dataset.nodeId;
        const pos = savedPositions[nodeId];
        if (pos && pos.x >= x && pos.x <= x + width && pos.y >= y && pos.y <= y + height) {
         selectedNodes.add(nodeId);
        } else if (!event.shiftKey) {
         selectedNodes.delete(nodeId);
        }
       });
       
       updateNodeSelection();
      }
      
      function endSelection() {
       isSelecting = false;
       selectionStart = null;
       if (selectionRect) {
        selectionRect.style.display = "none";
       }
      }
      
      function cloneNode(sourceId) {
       const source = NODE_DATA[sourceId];
       if (!source) return;
       
       pushUndo("clone node");
       
       let baseName = source.name;
       let copyNum = 0;
       let newName = baseName + " copy";
       while (Object.values(NODE_DATA).some(n => n.name === newName)) {
        copyNum++;
        newName = baseName + " copy " + copyNum;
       }
       
       const newId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
       
       NODE_DATA[newId] = {
        shape: source.shape,
        name: newName,
        ip: source.ip,
        role: source.role,
        tags: [...source.tags],
        notes: [...source.notes],
        mac: source.mac || "",
        rackUnit: source.rackUnit || "",
        uHeight: source.uHeight || "1",
        ping: source.ping ? JSON.parse(JSON.stringify(source.ping)) : {
         enabled: false,
         protocol: 'http',
         customUrl: '',
         timeout: 3000,
         status: 'unknown',
         lastCheck: null
        }
       };
       
       if (savedSizes[sourceId]) {
        savedSizes[newId] = savedSizes[sourceId];
       }
       
       if (savedStyles[sourceId]) {
        savedStyles[newId] = JSON.parse(JSON.stringify(savedStyles[sourceId]));
       }
       
       const sourcePos = savedPositions[sourceId];
       savedPositions[newId] = {
        x: sourcePos.x + 100,
        y: sourcePos.y + 100
       };
       
       forgeTheTopology();
       claimTheImmortal(newId);
      }
      
      function alignSelectedNodes(direction) {
       if (selectedNodes.size < 2) return;
       
       pushUndo("align nodes");
       
       const nodeIds = Array.from(selectedNodes);
       const positions = nodeIds.map(id => ({ id, pos: savedPositions[id] }));
       
       switch(direction) {
        case "left":
         const minX = Math.min(...positions.map(p => p.pos.x));
         positions.forEach(p => savedPositions[p.id].x = minX);
         break;
        case "right":
         const maxX = Math.max(...positions.map(p => p.pos.x));
         positions.forEach(p => savedPositions[p.id].x = maxX);
         break;
        case "top":
         const minY = Math.min(...positions.map(p => p.pos.y));
         positions.forEach(p => savedPositions[p.id].y = minY);
         break;
        case "bottom":
         const maxY = Math.max(...positions.map(p => p.pos.y));
         positions.forEach(p => savedPositions[p.id].y = maxY);
         break;
        case "center-h":
         const avgX = positions.reduce((sum, p) => sum + p.pos.x, 0) / positions.length;
         positions.forEach(p => savedPositions[p.id].x = avgX);
         break;
        case "center-v":
         const avgY = positions.reduce((sum, p) => sum + p.pos.y, 0) / positions.length;
         positions.forEach(p => savedPositions[p.id].y = avgY);
         break;
       }
       
       forgeTheTopology();
      }
      
      function distributeSelectedNodes(direction) {
       if (selectedNodes.size < 3) return;
       
       pushUndo("distribute nodes");
       
       const nodeIds = Array.from(selectedNodes);
       const positions = nodeIds.map(id => ({ id, pos: savedPositions[id] }));
       
       if (direction === "horizontal") {
        positions.sort((a, b) => a.pos.x - b.pos.x);
        const minX = positions[0].pos.x;
        const maxX = positions[positions.length - 1].pos.x;
        const gap = (maxX - minX) / (positions.length - 1);
        positions.forEach((p, i) => {
         savedPositions[p.id].x = minX + (gap * i);
        });
       } else if (direction === "vertical") {
        positions.sort((a, b) => a.pos.y - b.pos.y);
        const minY = positions[0].pos.y;
        const maxY = positions[positions.length - 1].pos.y;
        const gap = (maxY - minY) / (positions.length - 1);
        positions.forEach((p, i) => {
         savedPositions[p.id].y = minY + (gap * i);
        });
       }
       
       forgeTheTopology();
      }
      
      function snapToGrid(nodeId, gridSize = 50) {
       if (!savedPositions[nodeId]) return;
       
       pushUndo("snap to grid");
       
       const pos = savedPositions[nodeId];
       pos.x = Math.round(pos.x / gridSize) * gridSize;
       pos.y = Math.round(pos.y / gridSize) * gridSize;
       
       forgeTheTopology();
      }
      
      function nudgeSelectedNodes(direction, distance) {
        const nodesToNudge = selectedNodes.size > 0 
          ? Array.from(selectedNodes) 
          : (currentNodeId ? [currentNodeId] : []);
        
        if (nodesToNudge.length === 0) return;
        
        const unlockedNodes = nodesToNudge.filter(id => !NODE_DATA[id]?.locked);
        
        if (unlockedNodes.length === 0) {
          console.log("All selected nodes are locked");
          return;
        }
        
        pushUndo("nudge nodes");
        
        unlockedNodes.forEach(id => {
          if (!savedPositions[id]) {
            savedPositions[id] = { x: 0, y: 0 };
          }
          
          switch(direction) {
            case "ArrowUp":
              savedPositions[id].y -= distance;
              break;
            case "ArrowDown":
              savedPositions[id].y += distance;
              break;
            case "ArrowLeft":
              savedPositions[id].x -= distance;
              break;
            case "ArrowRight":
              savedPositions[id].x += distance;
              break;
          }
        });
        
        forgeTheTopology();
      }

      function cycleNodes(reverse = false) {
        const nodeIds = Object.keys(NODE_DATA).filter(id => {
          if (currentView.mode === "rack" && currentView.rackId) {
            return NODE_DATA[id].assignedRack === currentView.rackId;
          }
          return !NODE_DATA[id].assignedRack;
        });
        
        if (nodeIds.length === 0) return;
        
        let currentIndex = nodeIds.indexOf(currentNodeId);
        
        if (reverse) {
          currentIndex = currentIndex <= 0 ? nodeIds.length - 1 : currentIndex - 1;
        } else {
          currentIndex = currentIndex >= nodeIds.length - 1 ? 0 : currentIndex + 1;
        }
        
        const nextNodeId = nodeIds[currentIndex];
        claimTheImmortal(nextNodeId);
        
        selectedNodes.clear();
        updateNodeSelection();
      }

      function focusOnSelected() {
        const nodesToFocus = selectedNodes.size > 0 
          ? Array.from(selectedNodes) 
          : (currentNodeId ? [currentNodeId] : []);
        
        if (nodesToFocus.length === 0) return;
        
        let minX = Infinity, minY = Infinity;
        let maxX = -Infinity, maxY = -Infinity;
        
        nodesToFocus.forEach(id => {
          const pos = savedPositions[id];
          if (pos) {
            const size = savedSizes[id] || 50;
            minX = Math.min(minX, pos.x - size/2);
            minY = Math.min(minY, pos.y - size/2);
            maxX = Math.max(maxX, pos.x + size/2);
            maxY = Math.max(maxY, pos.y + size/2);
          }
        });
        
        if (!isFinite(minX)) return;
        
        const padding = 100;
        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;
        const width = maxX - minX + padding * 2;
        const height = maxY - minY + padding * 2;
        
        const zoomX = CANVAS_WIDTH / width;
        const zoomY = CANVAS_HEIGHT / height;
        const targetZoom = Math.min(zoomX, zoomY, 2);
        
        canvasState.zoom = targetZoom;
        canvasState.panX = centerX - (CANVAS_WIDTH / targetZoom) / 2;
        canvasState.panY = centerY - (CANVAS_HEIGHT / targetZoom) / 2;
        
        forgeTheTopology();
      }

      function toggleLockSelected() {
        const nodesToToggle = selectedNodes.size > 0 
          ? Array.from(selectedNodes) 
          : (currentNodeId ? [currentNodeId] : []);
        
        if (nodesToToggle.length === 0) return;
        
        pushUndo("toggle lock");
        
        const hasUnlocked = nodesToToggle.some(id => !NODE_DATA[id]?.locked);
        
        nodesToToggle.forEach(id => {
          if (NODE_DATA[id]) {
            NODE_DATA[id].locked = hasUnlocked;
          }
        });
        
        forgeTheTopology();

        const lockState = hasUnlocked ? "locked" : "unlocked";
        console.log(`${nodesToToggle.length} node(s) ${lockState}`);
      }
      
      function toggleGroupSelected() {
        const nodesToGroup = Array.from(selectedNodes);
        
        if (nodesToGroup.length < 2) {
          console.log("Select at least 2 nodes to create a group");
          return;
        }
        
        pushUndo("toggle group");
        
        const groupIds = nodesToGroup.map(id => NODE_DATA[id]?.groupId).filter(g => g !== null && g !== undefined);
        const uniqueGroups = [...new Set(groupIds)];
        
        if (uniqueGroups.length === 1 && groupIds.length === nodesToGroup.length) {
          nodesToGroup.forEach(id => {
            if (NODE_DATA[id]) {
              NODE_DATA[id].groupId = null;
            }
          });
          console.log(`Ungrouped ${nodesToGroup.length} node(s)`);
        } else {
          const newGroupId = "group-" + Date.now();
          nodesToGroup.forEach(id => {
            if (NODE_DATA[id]) {
              NODE_DATA[id].groupId = newGroupId;
            }
          });
          console.log(`Grouped ${nodesToGroup.length} node(s) into ${newGroupId}`);
        }
        
        forgeTheTopology();
      }

      function handleKeyDown(event) {
       if (event.target.tagName === "INPUT" || event.target.tagName === "TEXTAREA" || event.target.isContentEditable) {
        return;
       }

       if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(event.key)) {
        event.preventDefault();
        const distance = event.shiftKey ? 10 : 1;
        nudgeSelectedNodes(event.key, distance);
       }
       
       if (event.key === "Tab") {
        event.preventDefault();
        cycleNodes(event.shiftKey);
       }
       
       if (event.key === "f" || event.key === "F") {
        event.preventDefault();
        focusOnSelected();
       }
       
       if (event.key === "l" || event.key === "L") {
        event.preventDefault();
        toggleLockSelected();
       }
       
       if (event.key === "g" || event.key === "G") {
        event.preventDefault();
        toggleGroupSelected();
       }
       
       if (event.ctrlKey && event.key === "z" && !event.shiftKey) {
        event.preventDefault();
        undo();
       }
       
       if ((event.ctrlKey && event.key === "y") || (event.ctrlKey && event.shiftKey && event.key === "z")) {
        event.preventDefault();
        redo();
       }
       
       if (event.ctrlKey && event.key === "c" && currentNodeId) {
        event.preventDefault();
        const node = NODE_DATA[currentNodeId];
        if (node) {
         clipboard = {
          type: "node",
          data: JSON.parse(JSON.stringify(node)),
          size: savedSizes[currentNodeId],
          style: savedStyles[currentNodeId] ? JSON.parse(JSON.stringify(savedStyles[currentNodeId])) : null
         };
        }
       }
       
       if (event.ctrlKey && event.key === "v" && clipboard && clipboard.type === "node") {
        event.preventDefault();
        pushUndo("paste node");
        
        let baseName = clipboard.data.name;
        let copyNum = 0;
        let newName = baseName + " copy";
        while (Object.values(NODE_DATA).some(n => n.name === newName)) {
         copyNum++;
         newName = baseName + " copy " + copyNum;
        }
        
        const newId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
        NODE_DATA[newId] = JSON.parse(JSON.stringify(clipboard.data));
        NODE_DATA[newId].name = newName;
        
        if (clipboard.size) savedSizes[newId] = clipboard.size;
        if (clipboard.style) savedStyles[newId] = JSON.parse(JSON.stringify(clipboard.style));
        
        const svgEl = document.getElementById("map");
        const rect = svgEl.getBoundingClientRect();
        const pt = svgEl.createSVGPoint();
        pt.x = rect.left + rect.width / 2;
        pt.y = rect.top + rect.height / 2;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        savedPositions[newId] = { x: svgP.x, y: svgP.y };
        
        forgeTheTopology();
        claimTheImmortal(newId);
       }
       
       if (event.ctrlKey && event.key === "d" && currentNodeId) {
        event.preventDefault();
        cloneNode(currentNodeId);
       }
       
       if (event.key === "Delete") {
        event.preventDefault();
        if (selectedNodes.size > 0) {
         deleteSelected();
        } else if (currentNodeId && NODE_DATA[currentNodeId]) {
         challengeTheImmortal(`Delete node "${NODE_DATA[currentNodeId].name}"?`, () => {
          pushUndo("delete node");
          delete NODE_DATA[currentNodeId];
          delete savedPositions[currentNodeId];
          delete savedSizes[currentNodeId];
          delete savedStyles[currentNodeId];
          EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== currentNodeId && e.to !== currentNodeId);
          saveEdgeData();
          forgeTheTopology();
          currentNodeId = null;
          document.getElementById("node-panel").style.display = "none";
         });
        } else if (currentEdgeId) {
         const edge = EDGE_DATA.list.find(e => e.id === currentEdgeId);
         if (edge) {
          challengeTheImmortal("Delete this line?", () => {
           pushUndo("delete edge");
           EDGE_DATA.list = EDGE_DATA.list.filter(e => e.id !== currentEdgeId);
           saveEdgeData();
           forgeTheTopology();
           currentEdgeId = null;
           document.getElementById("edge-panel").style.display = "none";
          });
         }
        }
       }
       
       if (event.ctrlKey && event.key === "a") {
        event.preventDefault();
        selectedNodes.clear();
        Object.keys(NODE_DATA).forEach(id => selectedNodes.add(id));
        updateNodeSelection();
       }
       
       if (event.key === "Escape") {
        clearSelection();
       }
      }
      
      function searchNodes(query) {
       clearSearchHighlight();
       
       if (!query || query.trim() === "") return;
       
       const lowerQuery = query.toLowerCase();
       const matchingIds = [];
       
       Object.entries(NODE_DATA).forEach(([id, node]) => {
        const searchableText = [
         node.name,
         node.ip,
         node.role,
         ...(node.tags || []),
         node.mac || "",
         node.rackUnit || ""
        ].join(" ").toLowerCase();
        
        if (searchableText.includes(lowerQuery)) {
         matchingIds.push(id);
        }
       });
       
       highlightSearchResults(matchingIds);
      }
      
      function highlightSearchResults(nodeIds) {
       clearSearchHighlight();
       nodeIds.forEach(id => {
        const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`);
        if (nodeGroup) {
         nodeGroup.classList.add("search-highlight");
        }
       });
      }
      
      function clearSearchHighlight() {
       document.querySelectorAll(".node-group").forEach(node => {
        node.classList.remove("search-highlight");
       });
      }
      
      function editNodeMac(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       
       document.getElementById("modal-title").textContent = "Edit MAC Address";
       document.getElementById("modal-input").value = node.mac || "";
       document.getElementById("edit-modal").style.display = "flex";
       document.getElementById("modal-input").focus();
       
       const saveHandler = () => {
        pushUndo("edit mac");
        const value = document.getElementById("modal-input").value.trim();
        node.mac = value;
        document.getElementById("edit-modal").style.display = "none";
        claimTheImmortal(id);
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       
       const cancelHandler = () => {
        document.getElementById("edit-modal").style.display = "none";
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       
       document.getElementById("edit-modal").addEventListener("click", function bgHandler(e) {
        if (e.target === document.getElementById("edit-modal")) {
         cancelHandler();
         document.getElementById("edit-modal").removeEventListener("click", bgHandler);
        }
       });
      }
      
      function editNodeRack(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       
       document.getElementById("modal-title").textContent = "Edit Rack Unit";
       document.getElementById("modal-input").value = node.rackUnit || "";
       document.getElementById("edit-modal").style.display = "flex";
       document.getElementById("modal-input").focus();
       
       const saveHandler = () => {
        pushUndo("edit rack");
        const value = document.getElementById("modal-input").value.trim();
        node.rackUnit = value;
        document.getElementById("edit-modal").style.display = "none";
        claimTheImmortal(id);
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       
       const cancelHandler = () => {
        document.getElementById("edit-modal").style.display = "none";
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       
       document.getElementById("edit-modal").addEventListener("click", function bgHandler(e) {
        if (e.target === document.getElementById("edit-modal")) {
         cancelHandler();
         document.getElementById("edit-modal").removeEventListener("click", bgHandler);
        }
       });
      }
      
      function editNodeUHeight(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       
       document.getElementById("modal-title").textContent = "Edit U Height";
       document.getElementById("modal-input").value = node.uHeight || "1";
       document.getElementById("edit-modal").style.display = "flex";
       document.getElementById("modal-input").focus();
       
       const saveHandler = () => {
        pushUndo("edit U height");
        const value = document.getElementById("modal-input").value.trim();
        node.uHeight = value;
        document.getElementById("edit-modal").style.display = "none";
        claimTheImmortal(id);
        forgeTheTopology();
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       
       const cancelHandler = () => {
        document.getElementById("edit-modal").style.display = "none";
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       
       document.getElementById("edit-modal").addEventListener("click", function bgHandler(e) {
        if (e.target === document.getElementById("edit-modal")) {
         cancelHandler();
         document.getElementById("edit-modal").removeEventListener("click", bgHandler);
        }
       });
      }
      
      function updateEdgePortLabels(edgeId) {
       const edge = EDGE_DATA.list.find(e => e.id === edgeId);
       if (!edge) return;
       
       const fromPortInput = document.getElementById("edge-from-port");
       const toPortInput = document.getElementById("edge-to-port");
       
       edge.fromPort = fromPortInput ? fromPortInput.value.trim() : "";
       edge.toPort = toPortInput ? toPortInput.value.trim() : "";
       
       saveEdgeData();
       forgeTheTopology();
      }
      
      document.addEventListener("keydown", handleKeyDown);
      
      const undoBtn = document.getElementById("undo-btn");
      const redoBtn = document.getElementById("redo-btn");
      if (undoBtn) undoBtn.addEventListener("click", undo);
      if (redoBtn) redoBtn.addEventListener("click", redo);
      
      const backToTopologyBtn = document.getElementById("back-to-topology-btn");
      if (backToTopologyBtn) {
       backToTopologyBtn.addEventListener("click", exitRack);
      }
      
      const bulkToolbarClose = document.getElementById("bulk-toolbar-close");
      if (bulkToolbarClose) {
       bulkToolbarClose.addEventListener("click", clearSelection);
      }
      
      const bulkAlignLeft = document.getElementById("bulk-align-left");
      if (bulkAlignLeft) {
       bulkAlignLeft.addEventListener("click", () => alignSelectedNodes("left"));
      }
      
      const bulkAlignRight = document.getElementById("bulk-align-right");
      if (bulkAlignRight) {
       bulkAlignRight.addEventListener("click", () => alignSelectedNodes("right"));
      }
      
      const bulkAlignTop = document.getElementById("bulk-align-top");
      if (bulkAlignTop) {
       bulkAlignTop.addEventListener("click", () => alignSelectedNodes("top"));
      }
      
      const bulkAlignBottom = document.getElementById("bulk-align-bottom");
      if (bulkAlignBottom) {
       bulkAlignBottom.addEventListener("click", () => alignSelectedNodes("bottom"));
      }
      
      const bulkDistributeH = document.getElementById("bulk-distribute-h");
      if (bulkDistributeH) {
       bulkDistributeH.addEventListener("click", () => distributeSelectedNodes("horizontal"));
      }
      
      const bulkDistributeV = document.getElementById("bulk-distribute-v");
      if (bulkDistributeV) {
       bulkDistributeV.addEventListener("click", () => distributeSelectedNodes("vertical"));
      }
      
      const bulkClone = document.getElementById("bulk-clone");
      if (bulkClone) {
       bulkClone.addEventListener("click", () => {
        if (selectedNodes.size === 0) return;
        pushUndo("clone selected");
        const nodesToClone = Array.from(selectedNodes);
        selectedNodes.clear();
        nodesToClone.forEach(id => {
         cloneNode(id);
         selectedNodes.add(currentNodeId);
        });
        updateNodeSelection();
       });
      }
      
      const bulkDelete = document.getElementById("bulk-delete");
      if (bulkDelete) {
       bulkDelete.addEventListener("click", deleteSelected);
      }
      
      const bulkMobileBtn = document.getElementById("bulk-mobile-btn");
      const bulkActionsModal = document.getElementById("bulk-actions-modal");
      const bulkModalClose = document.getElementById("bulk-modal-close");
      
      if (bulkMobileBtn) {
       bulkMobileBtn.addEventListener("click", () => {
        if (bulkActionsModal) bulkActionsModal.style.display = "block";
       });
      }
      
      if (bulkModalClose) {
       bulkModalClose.addEventListener("click", () => {
        if (bulkActionsModal) bulkActionsModal.style.display = "none";
       });
      }
      
      const closeModalAfterAction = () => {
       if (bulkActionsModal) bulkActionsModal.style.display = "none";
      };
      
      const bulkAlignLeftMobile = document.getElementById("bulk-align-left-mobile");
      if (bulkAlignLeftMobile) {
       bulkAlignLeftMobile.addEventListener("click", () => {
        alignSelectedNodes("left");
        closeModalAfterAction();
       });
      }
      
      const bulkAlignRightMobile = document.getElementById("bulk-align-right-mobile");
      if (bulkAlignRightMobile) {
       bulkAlignRightMobile.addEventListener("click", () => {
        alignSelectedNodes("right");
        closeModalAfterAction();
       });
      }
      
      const bulkAlignTopMobile = document.getElementById("bulk-align-top-mobile");
      if (bulkAlignTopMobile) {
       bulkAlignTopMobile.addEventListener("click", () => {
        alignSelectedNodes("top");
        closeModalAfterAction();
       });
      }
      
      const bulkAlignBottomMobile = document.getElementById("bulk-align-bottom-mobile");
      if (bulkAlignBottomMobile) {
       bulkAlignBottomMobile.addEventListener("click", () => {
        alignSelectedNodes("bottom");
        closeModalAfterAction();
       });
      }
      
      const bulkDistributeHMobile = document.getElementById("bulk-distribute-h-mobile");
      if (bulkDistributeHMobile) {
       bulkDistributeHMobile.addEventListener("click", () => {
        distributeSelectedNodes("horizontal");
        closeModalAfterAction();
       });
      }
      
      const bulkDistributeVMobile = document.getElementById("bulk-distribute-v-mobile");
      if (bulkDistributeVMobile) {
       bulkDistributeVMobile.addEventListener("click", () => {
        distributeSelectedNodes("vertical");
        closeModalAfterAction();
       });
      }
      
      const bulkCloneMobile = document.getElementById("bulk-clone-mobile");
      if (bulkCloneMobile) {
       bulkCloneMobile.addEventListener("click", () => {
        if (selectedNodes.size === 0) return;
        pushUndo("clone selected");
        const nodesToClone = Array.from(selectedNodes);
        selectedNodes.clear();
        nodesToClone.forEach(id => {
         cloneNode(id);
         selectedNodes.add(currentNodeId);
        });
        updateNodeSelection();
        closeModalAfterAction();
       });
      }
      
      const bulkDeleteMobile = document.getElementById("bulk-delete-mobile");
      if (bulkDeleteMobile) {
       bulkDeleteMobile.addEventListener("click", () => {
        deleteSelected();
        closeModalAfterAction();
       });
      }
      
      const bulkLockMobile = document.getElementById("bulk-lock-mobile");
      if (bulkLockMobile) {
       bulkLockMobile.addEventListener("click", () => {
        toggleLockSelected();
        closeModalAfterAction();
       });
      }
      
      const bulkGroupMobile = document.getElementById("bulk-group-mobile");
      if (bulkGroupMobile) {
       bulkGroupMobile.addEventListener("click", () => {
        toggleGroupSelected();
        closeModalAfterAction();
       });
      }
      
      const bulkClearMobile = document.getElementById("bulk-clear-mobile");
      if (bulkClearMobile) {
       bulkClearMobile.addEventListener("click", () => {
        clearSelection();
        closeModalAfterAction();
       });
      }
      
      const searchInput = document.getElementById("search-input");
      if (searchInput) {
       searchInput.addEventListener("input", (e) => {
        searchNodes(e.target.value);
       });
      }
      
       document.getElementById("save-file-btn").addEventListener("click", becomeImmortal);
       document.getElementById("check-all-ping-btn").addEventListener("click", checkAllNodesStatus);
       const addNodeBtn = document.getElementById("add-node-btn");
       const addNodeModal = document.getElementById("add-node-modal");
       const addNodeCancel = document.getElementById("add-node-cancel");
       const addNodeSave = document.getElementById("add-node-save");
       addNodeBtn.addEventListener("click", () => {
        document.getElementById("new-node-name").value = "";
        document.getElementById("new-node-ip").value = "";
        document.getElementById("new-node-tags").value = "";
        document.getElementById("new-node-shape").value = "circle";
        document.getElementById("new-node-pingable").checked = false;
        document.getElementById("new-node-ping-protocol").value = "http";
        document.getElementById("new-node-custom-url").value = "";
        document.getElementById("new-node-ping-timeout").value = "3000";
        document.getElementById("new-node-ping-options").style.display = "none";
        document.getElementById("new-node-custom-url-container").style.display = "none";
        newNodeIconTags = [];
        document.getElementById("new-node-icon-tags").style.display = "none";
        document.getElementById("new-node-icon-tags-list").innerHTML = "";
        addNodeModal.classList.add("active");
        document.getElementById("new-node-name").focus();
       });
       
       const canvasViewport = document.getElementById("canvas-viewport");
       if (canvasViewport) {
        canvasViewport.addEventListener("dblclick", (e) => {
         if (currentView.mode === "rack" && e.target.id === "map") {
          exitRack();
         }
        });
       }
       
       const layersBtn = document.getElementById("layers-btn");
       const layerModal = document.getElementById("layer-modal");
       const layerModalClose = document.getElementById("layer-modal-close");
       if (layersBtn && layerModal) {
        layersBtn.addEventListener("click", () => {
         layerModal.classList.add("active");
        });
       }
       if (layerModalClose && layerModal) {
        layerModalClose.addEventListener("click", () => {
         layerModal.classList.remove("active");
        });
       }
       if (layerModal) {
        layerModal.addEventListener("click", (e) => {
         if (e.target === layerModal) {
          layerModal.classList.remove("active");
         }
        });
       }
       
       ["physical", "logical", "security", "application"].forEach(layer => {
        const checkbox = document.getElementById(`layer-${layer}`);
        if (checkbox) {
         checkbox.addEventListener("change", applyLayerFilter);
        }
       });
       
       const layerSelect = document.getElementById("node-layer");
       if (layerSelect) {
        layerSelect.addEventListener("change", (e) => {
         if (currentNodeId) {
          pushUndo("change layer");
          NODE_DATA[currentNodeId].layer = e.target.value;
          forgeTheTopology();
         }
        });
       }
       
       const assignedRackSelect = document.getElementById("node-assigned-rack");
       if (assignedRackSelect) {
        assignedRackSelect.addEventListener("change", (e) => {
         if (currentNodeId) {
          pushUndo("change assigned rack");
          NODE_DATA[currentNodeId].assignedRack = e.target.value;
          forgeTheTopology();
         }
        });
       }
       
       const rackCapacitySelect = document.getElementById("node-rack-capacity");
       if (rackCapacitySelect) {
        rackCapacitySelect.addEventListener("change", (e) => {
         if (currentNodeId) {
          pushUndo("change rack capacity");
          NODE_DATA[currentNodeId].rackCapacity = e.target.value;
          forgeTheTopology();
         }
        });
       }
       
       const addRackBtn = document.getElementById("add-rack-btn");
       const addRackModal = document.getElementById("add-rack-modal");
       const addRackCancel = document.getElementById("add-rack-cancel");
       const addRackSave = document.getElementById("add-rack-save");
       
       if (addRackBtn && addRackModal) {
        addRackBtn.addEventListener("click", () => {
         document.getElementById("new-rack-name").value = "";
         document.getElementById("new-rack-ip").value = "";
         document.getElementById("new-rack-tags").value = "";
         document.getElementById("new-rack-shape").value = "server";
         document.getElementById("new-rack-capacity").value = "42";
         selectedRackIconData = null;
         document.getElementById('selected-rack-icon').style.display = 'none';
         addRackModal.classList.add("active");
         document.getElementById("new-rack-name").focus();
        });
       }
       
       if (addRackCancel && addRackModal) {
        addRackCancel.addEventListener("click", () => {
         addRackModal.classList.remove("active");
        });
       }
       
       if (addRackModal) {
        addRackModal.addEventListener("click", (e) => {
         if (e.target === addRackModal) {
          addRackModal.classList.remove("active");
         }
        });
       }
       
       if (addRackSave && addRackModal) {
        addRackSave.addEventListener("click", () => {
         const name = document.getElementById("new-rack-name").value.trim();
         const ip = document.getElementById("new-rack-ip").value.trim();
         const tagsStr = document.getElementById("new-rack-tags").value.trim();
         const shape = document.getElementById("new-rack-shape").value;
         const capacity = document.getElementById("new-rack-capacity").value;
         
         if (!name) {
          alert("Please enter a rack name.");
          return;
         }
         
         const tags = tagsStr ? tagsStr.split(",").map((t) => t.trim()).filter((t) => t) : [];
         let baseId = name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");
         if (!baseId) baseId = "rack";
         let nodeId = baseId;
         let counter = 1;
         while (NODE_DATA[nodeId]) {
          nodeId = baseId + "-" + counter;
          counter++;
         }
         
         pushUndo("add rack");
         
         NODE_DATA[nodeId] = {
          shape: shape,
          name: name,
          ip: ip || "",
          role: "Rack",
          tags: tags,
          notes: [],
          mac: "",
          rackUnit: "",
          uHeight: "1",
          layer: "physical",
          assignedRack: "",
          rackCapacity: capacity,
          isRack: true,
          locked: false,
          groupId: null
         };
         
         const viewWidth = CANVAS_WIDTH / canvasState.zoom;
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         const centerX = canvasState.panX + (viewWidth / 2);
         const centerY = canvasState.panY + (viewHeight / 2);
         savedPositions[nodeId] = {
          x: centerX,
          y: centerY
         };
         
         if (selectedRackIconData) {
          if (!savedStyles[nodeId]) {
           savedStyles[nodeId] = {};
          }
          if (!savedStyles[nodeId]['all']) {
           savedStyles[nodeId]['all'] = {};
          }
          savedStyles[nodeId]['all'].icon = {
           library: selectedRackIconData.library,
           name: selectedRackIconData.name
          };
          selectedRackIconData = null;
          document.getElementById('selected-rack-icon').style.display = 'none';
         }
         
         addRackModal.classList.remove("active");
         forgeTheTopology();
         claimTheImmortal(nodeId);
        });
        
        ["new-rack-name", "new-rack-ip", "new-rack-tags"].forEach((inputId) => {
         const input = document.getElementById(inputId);
         if (input) {
          input.addEventListener("keypress", (e) => {
           if (e.key === "Enter") {
            addRackSave.click();
           }
          });
         }
        });
       }
       
       addNodeCancel.addEventListener("click", () => {
        addNodeModal.classList.remove("active");
       });
       addNodeModal.addEventListener("click", (e) => {
        if (e.target === addNodeModal) {
         addNodeModal.classList.remove("active");
        }
       });
       addNodeSave.addEventListener("click", () => {
        const name = document.getElementById("new-node-name").value.trim();
        const ip = document.getElementById("new-node-ip").value.trim();
        const tagsStr = document.getElementById("new-node-tags").value.trim();
        const shape = document.getElementById("new-node-shape").value;
        const pingable = document.getElementById("new-node-pingable").checked;
        const pingProtocol = document.getElementById("new-node-ping-protocol").value;
        const pingCustomUrl = document.getElementById("new-node-custom-url").value.trim();
        const pingTimeout = parseInt(document.getElementById("new-node-ping-timeout").value) || 3000;
        
        if (!name) {
         alert("Please enter a node name.");
         return;
        }
        const tags = tagsStr ? tagsStr.split(",").map((t) => t.trim()).filter((t) => t) : [];
        if (newNodeIconTags.length > 0) {
         tags.push(...newNodeIconTags);
        }
        let baseId = name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");
        if (!baseId) baseId = "node";
        let nodeId = baseId;
        let counter = 1;
        while (NODE_DATA[nodeId]) {
         nodeId = baseId + "-" + counter;
         counter++;
        }
        NODE_DATA[nodeId] = {
         shape: shape || "circle",
         name: name,
         ip: ip || "0.0.0.0",
         role: "",
         tags: tags,
         notes: [],
         mac: "",
         rackUnit: "",
         uHeight: "1",
         ping: {
          enabled: pingable,
          protocol: pingProtocol,
          customUrl: pingCustomUrl,
          timeout: pingTimeout,
          status: 'unknown',
          lastCheck: null
         },
         locked: false, 
         groupId: null 
        };
        
        if (currentView.mode === "rack" && currentView.rackId) {
         NODE_DATA[nodeId].assignedRack = currentView.rackId;
         NODE_DATA[nodeId].layer = "physical";
        }
        
        if (selectedNodeIconData) {
         if (!savedStyles[nodeId]) savedStyles[nodeId] = {};
         if (!savedStyles[nodeId]['all']) savedStyles[nodeId]['all'] = {};
         savedStyles[nodeId]['all'].icon = {
          library: selectedNodeIconData.library,
          name: selectedNodeIconData.name
         };
         selectedNodeIconData = null;
         document.getElementById('selected-node-icon').style.display = 'none';
        }
        newNodeIconTags = [];
		const viewWidth = CANVAS_WIDTH / canvasState.zoom;
		const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
		const centerX = canvasState.panX + (viewWidth / 2);
		const centerY = canvasState.panY + (viewHeight / 2);
		savedPositions[nodeId] = {
		x: centerX,
		y: centerY
		};
        addNodeModal.classList.remove("active");
        forgeTheTopology();
        claimTheImmortal(nodeId);
       });
       ["new-node-name", "new-node-ip", "new-node-tags"].forEach(
        (inputId) => {
         document.getElementById(inputId).addEventListener("keypress", (e) => {
          if (e.key === "Enter") {
           addNodeSave.click();
          }
         });
        }, );
       
       document.getElementById('new-node-pingable').addEventListener('change', (e) => {
        const pingOptions = document.getElementById('new-node-ping-options');
        pingOptions.style.display = e.target.checked ? 'block' : 'none';
       });
       
       document.getElementById('new-node-ping-protocol').addEventListener('change', (e) => {
        const customUrlContainer = document.getElementById('new-node-custom-url-container');
        customUrlContainer.style.display = e.target.value === 'custom' ? 'block' : 'none';
       });
       
       document.getElementById('pick-rack-icon-btn').addEventListener('click', () => {
        openIconPicker((iconData) => {
         selectedRackIconData = iconData;
         const preview = document.getElementById('selected-rack-icon-preview');
         const container = document.getElementById('selected-rack-icon');
         const parser = new DOMParser();
         const doc = parser.parseFromString(iconData.svg, 'image/svg+xml');
         const svgEl = doc.querySelector('svg');
         preview.innerHTML = '';
         if (svgEl) {
          preview.appendChild(svgEl.cloneNode(true));
         }
         const nameSpan = document.createElement('span');
         nameSpan.textContent = iconData.name;
         preview.appendChild(nameSpan);
         container.style.display = 'block';
        });
       });
       
       document.getElementById('pick-node-icon-btn').addEventListener('click', () => {
        openIconPicker((iconData) => {
         selectedNodeIconData = iconData;
         const preview = document.getElementById('selected-node-icon-preview');
         const container = document.getElementById('selected-node-icon');
         const parser = new DOMParser();
         const doc = parser.parseFromString(iconData.svg, 'image/svg+xml');
         const svgEl = doc.querySelector('svg');
         preview.innerHTML = '';
         if (svgEl) {
          preview.appendChild(svgEl.cloneNode(true));
         }
         const nameSpan = document.createElement('span');
         nameSpan.textContent = iconData.name;
         preview.appendChild(nameSpan);
         container.style.display = 'block';
        });
       });
       document.getElementById('pick-tag-icon-btn').addEventListener('click', () => {
        if (!currentNodeId) return;
        openIconPicker((iconData) => {
         if (!currentNodeId || !NODE_DATA[currentNodeId]) return;
         if (!NODE_DATA[currentNodeId].tags) {
          NODE_DATA[currentNodeId].tags = [];
         }
         NODE_DATA[currentNodeId].tags.push({
          type: 'icon',
          library: iconData.library,
          name: iconData.name
         });
         forgeTheTopology();
         claimTheImmortal(currentNodeId);
        });
       });
       document.getElementById('pick-new-node-tag-icon-btn').addEventListener('click', () => {
        openIconPicker((iconData) => {
         newNodeIconTags.push({
          type: 'icon',
          library: iconData.library,
          name: iconData.name
         });
         const container = document.getElementById('new-node-icon-tags');
         const list = document.getElementById('new-node-icon-tags-list');
         const badge = document.createElement('div');
         badge.className = 'icon-badge';
         badge.style.cssText = 'display: inline-flex; align-items: center; gap: 6px; padding: 6px 10px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; font-size: 13px;';
         const iconPreview = document.createElement('div');
         iconPreview.style.cssText = 'width: 16px; height: 16px; display: flex; align-items: center; justify-content: center;';
         IconLibrary.getIcon(iconData.library, iconData.name).then(svg => {
          if (svg) {
           const parser = new DOMParser();
           const doc = parser.parseFromString(svg, 'image/svg+xml');
           const svgEl = doc.querySelector('svg');
           if (svgEl) {
            svgEl.setAttribute('width', '16');
            svgEl.setAttribute('height', '16');
            svgEl.style.fill = 'var(--text-main)';
            iconPreview.appendChild(svgEl);
           }
          }
         });
         const name = document.createElement('span');
         name.textContent = iconData.name;
         name.style.color = 'var(--text-soft)';
         const removeBtn = document.createElement('button');
         removeBtn.textContent = 'Ã—';
         removeBtn.style.cssText = 'background: none; border: none; color: var(--danger); cursor: pointer; font-size: 18px; line-height: 1; padding: 0 4px;';
         removeBtn.addEventListener('click', () => {
          const index = newNodeIconTags.findIndex(t => t.type === 'icon' && t.library === iconData.library && t.name === iconData.name);
          if (index > -1) {
           newNodeIconTags.splice(index, 1);
          }
          badge.remove();
          if (list.children.length === 0) {
           container.style.display = 'none';
          }
         });
         badge.appendChild(iconPreview);
         badge.appendChild(name);
         badge.appendChild(removeBtn);
         list.appendChild(badge);
         container.style.display = 'block';
        });
       });
       document.getElementById('pick-shape-icon-btn').addEventListener('click', () => {
        if (!currentNodeId) return;
        openIconPicker((iconData) => {
         if (!savedStyles[currentNodeId]) {
          savedStyles[currentNodeId] = {};
         }
         if (!savedStyles[currentNodeId][currentStyleScope]) {
          savedStyles[currentNodeId][currentStyleScope] = {};
         }
         savedStyles[currentNodeId][currentStyleScope].icon = {
          library: iconData.library,
          name: iconData.name
         };
         forgeTheTopology();
        });
       });
       document.getElementById('add-tag-btn').addEventListener('click', () => {
        if (!currentNodeId) return;
        if (!NODE_DATA[currentNodeId]) return;
        const input = document.getElementById('new-tag-input');
        const tagText = input.value.trim();
        if (!tagText) return;
        if (!NODE_DATA[currentNodeId].tags) {
         NODE_DATA[currentNodeId].tags = [];
        }
        NODE_DATA[currentNodeId].tags.push(tagText);
        input.value = '';
        forgeTheTopology();
        claimTheImmortal(currentNodeId);
       });
       const clearAllBtn = document.getElementById("clear-all-btn");
       const clearAllModal = document.getElementById("clear-all-modal");
       const clearAllCancel = document.getElementById("clear-all-cancel");
       const clearAllConfirm = document.getElementById("clear-all-confirm");
       clearAllBtn.addEventListener("click", () => {
        clearAllModal.classList.add("active");
       });
       clearAllCancel.addEventListener("click", () => {
        clearAllModal.classList.remove("active");
       });
       clearAllModal.addEventListener("click", (e) => {
        if (e.target === clearAllModal) {
         clearAllModal.classList.remove("active");
        }
       });
       clearAllConfirm.addEventListener("click", () => {
        NODE_DATA = {};
        EDGE_DATA = {
         list: []
        };
        EDGE_LEGEND = {};
        RECT_DATA = { list: [] };
        TEXT_DATA = { list: [] };
        savedPositions = {};
        savedSizes = {};
        savedStyles = {};
        clearAllModal.classList.remove("active");
      
      autoPingEnabled = false;
      autoPingInterval = 30;
      PAGE_STATE.autoPingEnabled = false;
      PAGE_STATE.autoPingInterval = autoPingInterval;
      
      stopAutoPing();
      
      document.getElementById("auto-ping-enabled").checked = false;
      document.getElementById("auto-ping-settings").style.display = "none";
      document.getElementById("auto-ping-interval").value = autoPingInterval;
        forgeTheTopology();
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.display = "none";
        currentNodeId = null;
        currentEdgeId = null;
        currentTextId = null;
       });
       (function addDeleteNodeButton() {
        const nodePanel = document.getElementById("node-panel");
        if (!nodePanel) return;
        if (document.getElementById("delete-node-btn")) return;
        const deleteBtn = document.createElement("button");
        deleteBtn.id = "delete-node-btn";
        deleteBtn.textContent = "Delete Node";
        deleteBtn.style.cssText = "margin-top:15px; padding:10px 16px; background:var(--danger); color:#fff; border:none; border-radius:6px; cursor:pointer; font-size:clamp(14px,1.6vw,18px); font-weight:600; width:100%;";
        deleteBtn.addEventListener("click", () => {
         if (!currentNodeId) return;
         challengeTheImmortal(`Delete node "${NODE_DATA[currentNodeId]?.name || currentNodeId}" and all its connections?`,
          () => {
           EDGE_DATA.list = EDGE_DATA.list.filter(
            (e) => e.from !== currentNodeId && e.to !== currentNodeId, );
           delete NODE_DATA[currentNodeId];
           delete savedPositions[currentNodeId];
           delete savedSizes[currentNodeId];
           delete savedStyles[currentNodeId];
           currentNodeId = null;
           currentEdgeId = null;
           forgeTheTopology();
           const remainingNodes = Object.keys(NODE_DATA);
           if (remainingNodes.length > 0) {
            claimTheImmortal(remainingNodes[0]);
           } else {
            document.getElementById("node-panel").style.display = "none";
            document.getElementById("edge-panel").style.display = "none";
            document.getElementById("topology-toolbar", ).style.display = "none";
           }
          }, );
        });
        nodePanel.appendChild(deleteBtn);
       })();
      
       function screenshotCanvas() {
        const svg = document.getElementById("map");
        const svgClone = svg.cloneNode(true);
        const viewBox = svg.getAttribute("viewBox").split(" ").map(Number);
        const [x, y, width, height] = viewBox;
        svgClone.setAttribute("width", width);
        svgClone.setAttribute("height", height);
        svgClone.setAttribute("viewBox", `${x} ${y} ${width} ${height}`);
        const wrapper = document.createElement("div");
        wrapper.style.position = "absolute";
        wrapper.style.left = "-9999px";
        wrapper.appendChild(svgClone);
        document.body.appendChild(wrapper);
      
        function inlineStyles(original, clone) {
         const elements = original.querySelectorAll("*");
         const clonedElements = clone.querySelectorAll("*");
         const rootStyles = getComputedStyle(document.documentElement);
         const bgColor = rootStyles.getPropertyValue("--bg").trim() || "#050608";
         const bgRect = document.createElementNS("http://www.w3.org/2000/svg", "rect", );
         bgRect.setAttribute("x", x);
         bgRect.setAttribute("y", y);
         bgRect.setAttribute("width", width);
         bgRect.setAttribute("height", height);
         bgRect.setAttribute("fill", bgColor);
         clone.insertBefore(bgRect, clone.firstChild);
         elements.forEach((el, index) => {
          const clonedEl = clonedElements[index];
          if (!clonedEl) return;
          const computedStyle = getComputedStyle(el);
          const svgProps = ["fill", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin", "opacity", "font-family", "font-size", "font-weight", "font-style", "text-anchor", "dominant-baseline", "marker-start", "marker-end", ];
          svgProps.forEach((prop) => {
           const value = computedStyle.getPropertyValue(prop);
           if (value && value !== "none" && value !== "normal") {
            clonedEl.style[prop] = value;
           }
          });
          clonedEl.removeAttribute("class");
         });
        }
        inlineStyles(svg, svgClone);
        const svgData = new XMLSerializer().serializeToString(svgClone);
        document.body.removeChild(wrapper);
        const svgBlob = new Blob([svgData], {
         type: "image/svg+xml;charset=utf-8",
        });
        const url = URL.createObjectURL(svgBlob);
        const img = new Image();
        img.onload = function() {
         const canvas = document.createElement("canvas");
         canvas.width = width;
         canvas.height = height;
         const ctx = canvas.getContext("2d");
         ctx.drawImage(img, 0, 0);
         canvas.toBlob(function(blob) {
          const link = document.createElement("a");
          const timestamp = new Date().toISOString().slice(0, 10);
          link.download = `topology-${timestamp}.png`;
          link.href = URL.createObjectURL(blob);
          link.click();
          URL.revokeObjectURL(url);
          URL.revokeObjectURL(link.href);
         }, "image/png");
        };
        img.onerror = function() {
         console.error("Failed to load SVG image");
         alert("Screenshot failed. Please try again.");
         URL.revokeObjectURL(url);
        };
        img.src = url;
       }
      
       function exportCanvasSVG() {
        const svg = document.getElementById("map");
        const svgClone = svg.cloneNode(true);
        const viewBox = svg.getAttribute("viewBox").split(" ").map(Number);
        const [x, y, width, height] = viewBox;
        svgClone.setAttribute("width", width);
        svgClone.setAttribute("height", height);
        const rootStyles = getComputedStyle(document.documentElement);
        const bgColor = rootStyles.getPropertyValue("--bg").trim() || "#050608";
        const bgRect = document.createElementNS("http://www.w3.org/2000/svg", "rect", );
        bgRect.setAttribute("x", x);
        bgRect.setAttribute("y", y);
        bgRect.setAttribute("width", width);
        bgRect.setAttribute("height", height);
        bgRect.setAttribute("fill", bgColor);
        svgClone.insertBefore(bgRect, svgClone.firstChild);
        const wrapper = document.createElement("div");
        wrapper.style.position = "absolute";
        wrapper.style.left = "-9999px";
        wrapper.appendChild(svgClone);
        document.body.appendChild(wrapper);
        const elements = svg.querySelectorAll("*");
        const clonedElements = svgClone.querySelectorAll("*");
        elements.forEach((el, index) => {
         const clonedEl = clonedElements[index];
         if (!clonedEl) return;
         const computedStyle = getComputedStyle(el);
         const svgProps = ["fill", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin", "opacity", "font-family", "font-size", "font-weight", "font-style", "text-anchor", "dominant-baseline", "marker-start", "marker-end", ];
         svgProps.forEach((prop) => {
          const value = computedStyle.getPropertyValue(prop);
          if (value && value !== "none" && value !== "normal") {
           clonedEl.setAttribute(prop, value);
          }
         });
         clonedEl.removeAttribute("class");
        });
        const svgData = new XMLSerializer().serializeToString(svgClone);
        document.body.removeChild(wrapper);
        const blob = new Blob([svgData], {
         type: "image/svg+xml;charset=utf-8",
        });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        const timestamp = new Date().toISOString().slice(0, 10);
        link.download = `topology-${timestamp}.svg`;
        link.href = url;
        link.click();
        URL.revokeObjectURL(url);
       }
    </script>
  
</body></html>