<!DOCTYPE html> 
 <html lang="en" style="--panel: #a0a0ac; --panel-alt: #161d1c; --accent: #3eabc1; --danger: #070603; --text-main: #ffffff; --text-soft: #ffffff; --topbar-bg: #728cda; --topbar-border: #000000; --topbar-height: 100px; --sidebar-width: 435px; --mobile-footer-height: 20vh; --draw-toolbar-height: 45px; --sidebar-bg: #10141b; --btn-bg: #0b0e13; --btn-text: #e2e8f0; --tag-fill: #1e293b; --tag-text: #e2e8f0; --tag-border: #475569; --input-bg: #0b0e13; --input-text: #e2e8f0; --input-border: #1f2937; --input-font: Inter, system-ui, sans-serif; --input-font-size: 14px; --toolbar-bg: #233661; --toolbar-border: #1f2937; --toolbar-text: #94a3b8; --toolbar-btn-bg: #0b0e13; --toolbar-btn-text: #e2e8f0; --minimap-dots: #4ca5c2; --canvas-hint-bg: #0f172a; --canvas-hint-color: #94a3b8; --node-fill: #1e293b; --node-stroke: #475569; --node-title: #e2e8f0; --node-sub: #94a3b8; --node-title-size: 18px; --node-sub-size: 13px; --node-font: Inter, system-ui, sans-serif; --default-edge: #475569; --selection-handle: #f59e0b; --selection-handle-size: 8px; --group-indicator: #4fd1c5;"><head>
    <meta charset="UTF-8">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Corporate</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- 
      * ==================================================================================
      * The One File: The Networkening
      * !!!!!!!!!!!!!!!!!!!NOTE: THIS IS THE ONLINE VERSION!!!!!!!!!!!!!!!!!!!!!!
      * Online version uses 3 cdn calls from cdn.jsdelivr.net to display additional icons
      * Since 3.0 Online version uses http as a form of ping to display uptime
      * "There can be only one". A all in one file topology maker.
      * 
      * This is your last backup when all others fail. A completely self-contained
      * network topology visualization tool that works as a single HTML file.
      * Open it anywhere, anytime and the idea lives forever.
      * ==================================================================================
      -->
    <style>
      :root {
      color-scheme: dark;
      --bg: #050608;
      --panel: #0b0e13;
      --panel-alt: #10141b;
      --accent: #4fd1c5;
      --danger: #f56565;
      --text-main: #e2e8f0;
      --text-soft: #94a3b8;
      --edge-main: #475569;
      --node-min: 35px;
      --node-max: 70px;
      --topbar-bg: rgba(9, 12, 20, 0.9);
      --topbar-border: #1f2533;
      }
      * {
      box-sizing: border-box;
      user-select: none;
      }
      input,
      textarea,
      [contenteditable="true"] {
      user-select: text;
      -webkit-user-select: text;
      }
      body {
      margin: 0;
      font-family: system-ui, sans-serif;
      background: radial-gradient(circle at top, #1e2532 0, #050608 70%);
      color: var(--text-main);
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
      }
      header {
      padding: 0 20px;
      height: var(--topbar-height, 52px);
      min-height: var(--topbar-height, 52px);
      background: var(--topbar-bg);
      backdrop-filter: blur(6px);
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid var(--topbar-border);
      gap: 16px;
      }
      .title-block {
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-width: 0;
      }
      header h1 {
      font-size: clamp(22px, 3vw, 32px);
      margin: 0;
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
      }
      .editable-page-title {
      cursor: pointer;
      transition: opacity 0.2s;
      }
      .editable-page-title:hover {
      opacity: 0.7;
      }
      .save-row {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      }
      .save-btn {
      padding: 6px 12px;
      background: var(--accent);
      color: var(--bg);
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      white-space: nowrap;
      }
      .save-btn:hover {
      opacity: 0.9;
      }
      .help-icon {
      width: 22px;
      height: 22px;
      border-radius: 50%;
      border: 1px solid var(--edge-main);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      cursor: pointer;
      color: var(--text-soft);
      background: rgba(15, 23, 42, 0.9);
      flex-shrink: 0;
      }
      .help-icon:hover {
      color: var(--accent);
      border-color: var(--accent);
      }
#settings-btn {
      background: var(--btn-bg, var(--panel));
      color: var(--btn-text, var(--text-main));
      border: 1px solid var(--edge-main);
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 16px;
      flex-shrink: 0;
      }
      #settings-btn:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .header-resizer {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 6px;
      background: transparent;
      cursor: row-resize;
      z-index: 1000;
      transition: background 0.2s;
      }
      .header-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .header-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      .sidebar-resizer {
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 6px;
      background: transparent;
      cursor: col-resize;
      z-index: 1000;
      transition: background 0.2s;
      }
      .sidebar-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .sidebar-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      .mobile-footer-resizer {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 6px;
      background: transparent;
      cursor: row-resize;
      z-index: 1000;
      transition: background 0.2s;
      display: none;
      }
      .mobile-footer-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .mobile-footer-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      @media (max-width: 900px) {
      .mobile-footer-resizer {
      display: block;
      height: 12px;
      }
      .sidebar-resizer {
      display: none;
      }
      .header-resizer {
      height: 12px;
      }
      }
      @media (pointer: coarse) {
      .header-resizer {
      height: 16px;
      }
      .mobile-footer-resizer {
      height: 16px;
      }
      .sidebar-resizer {
      width: 16px;
      }
      }
      .resizer-icon {
      position: absolute;
      opacity: 0.5;
      transition: opacity 0.2s, transform 0.2s;
      pointer-events: none;
      fill: var(--accent);
      }
      .header-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .sidebar-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .mobile-footer-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .header-resizer:hover .resizer-icon,
      .sidebar-resizer:hover .resizer-icon,
      .mobile-footer-resizer:hover .resizer-icon {
      opacity: 1;
      }
      .header-resizer.resizing .resizer-icon,
      .sidebar-resizer.resizing .resizer-icon,
      .mobile-footer-resizer.resizing .resizer-icon {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1.2);
      }
      body.resizing {
      user-select: none;
      }
      body.resizing * {
      cursor: inherit !important;
      pointer-events: none;
      }
      header {
      position: relative;
      }
      .details-panel {
      position: relative;
      }
      main {
      display: grid;
      grid-template-columns: 1fr var(--sidebar-width, 350px);
      flex: 1;
      }
      main.sidebar-collapsed {
      grid-template-columns: 1fr 0;
      }
      @media (max-width: 900px) {
      main {
      grid-template-columns: 1fr;
      grid-template-rows: calc(100vh - var(--topbar-height, 52px) - var(--mobile-footer-height, 40vh)) var(--mobile-footer-height, 40vh);
      }
      main.sidebar-collapsed {
      grid-template-rows: 1fr 0;
      }
      .details-panel {
      max-height: var(--mobile-footer-height, 40vh);
      height: 100%;
      }
      }
      .topology-panel {
      background: var(--panel);
      border-right: 1px solid #111827;
      position: relative;
      overflow: hidden;
      }
.topology-toolbar {
      position: absolute;
      top: 10px;
      right: 10px;
      display: none;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      z-index: 99;
      font-size: 13px;
      color: var(--toolbar-text, #94a3b8);
      }
.topology-toolbar label {
      color: var(--toolbar-text, var(--text-soft));
      }
.topology-toolbar select {
      padding: 4px 6px;
      background: var(--toolbar-btn-bg, var(--panel));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 13px;
      cursor: pointer;
      }
.topology-toolbar button {
      padding: 4px 10px;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      }
      .topology-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .bulk-toolbar-desktop,
      .bulk-toolbar-mobile {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 9999;
      }
      .bulk-toolbar-desktop {
      position: absolute;
      top: 10px;
      right: 10px;
      bottom: auto;
      left: auto;
      transform: none;
      }
      @media (min-width: 768px) {
      .bulk-toolbar-mobile {
      display: none !important;
      }
      }	  
      .bulk-action-btn {
      padding: 16px;
      background: var(--panel-main);
      border: 1px solid var(--edge-main);
      border-radius: 8px;
      color: var(--text-main);
      font-size: 24px;
      cursor: pointer;
      text-align: center;
      line-height: 1.2;
      }
      .bulk-action-btn:active {
      transform: scale(0.95);
      background: var(--accent);
      }
.draw-toolbar {
      position: absolute;
      top: 10px;
      left: 10px;
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 8px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      z-index: 99;
      font-size: 13px;
      pointer-events: auto;
      color: var(--toolbar-text, #94a3b8);
      }
.draw-toolbar button {
      padding: 4px 8px;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      }
      .draw-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .draw-toolbar input[type="color"] {
      width: 30px;
      height: 22px;
      border-radius: 4px;
      border: 1px solid var(--edge-main);
      padding: 0;
      background: transparent;
      cursor: pointer;
      }
.draw-toolbar select {
      padding: 4px 6px;
      background: var(--toolbar-btn-bg, var(--panel));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 13px;
      cursor: pointer;
      }
.legend-container {
      position: absolute;
      left: 10px;
      bottom: 10px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      padding: 8px 10px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      font-size: 12px;
      z-index: 20;
      max-width: 260px;
      pointer-events: auto;
      color: var(--toolbar-text, #94a3b8);
      }
      .legend-container {
      padding-right: 22px;
      }
      @media (max-width: 900px) {
      .legend-container {
      max-height: calc(100vh - var(--topbar-height, 100px) - 120px);
      overflow-y: auto;
      }
      }
      @media (max-width: 900px) {
      .bulk-toolbar-desktop,
      .topology-toolbar {
      display: none !important;
      }
      }
      .legend-close-btn {
      position: absolute;
      top: 5px;
      right: 5px;
      width: 18px;
      height: 18px;
      border-radius: 999px;
      border: 1px solid var(--edge-main);
      background: var(--panel-alt);
      color: var(--text-soft);
      font-size: 11px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      }
      .legend-close-btn:hover {
      background: var(--danger);
      color: #fff;
      }
.legend-mini-btn {
      position: absolute;
      left: 10px;
      padding: 4px 8px;
      border-radius: 4px;
      border: 1px solid var(--toolbar-border, #1f2937);
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 11px;
      cursor: pointer;
      z-index: 20;
      display: none;
      transition: all 0.2s;
      }
      .legend-mini-btn:hover,
      .legend-mini-btn:active {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
      }
.legend-title {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: var(--toolbar-text, var(--text-soft));
      margin-bottom: 2px;
      }
      .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      }
      .legend-swatch {
      width: 14px;
      height: 14px;
      border-radius: 3px;
      border: 1px solid #020617;
      flex-shrink: 0;
      }
      .legend-label {
      outline: none;
      cursor: text;
      flex: 1;
      min-width: 60px;
      user-select: text;
      -webkit-user-select: text;
      }
      .legend-label.editing {
      border-bottom: 1px dashed var(--accent);
      }
      .canvas-viewport {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      overflow: hidden;
      }
      .canvas-viewport.panning {
      cursor: grabbing !important;
      }
      .canvas-viewport.panning * {
      cursor: grabbing !important;
      }
      .canvas-viewport svg {
      width: 100%;
      height: 100%;
      display: block;
      background: linear-gradient(rgba(71, 85, 105, 0.1) 1px,
      transparent 1px),
      linear-gradient(90deg,
      rgba(71, 85, 105, 0.1) 1px,
      transparent 1px),
      linear-gradient(rgba(71, 85, 105, 0.05) 1px, transparent 1px),
      linear-gradient(90deg,
      rgba(71, 85, 105, 0.05) 1px,
      transparent 1px);
      background-size:
      100px 100px,
      100px 100px,
      20px 20px,
      20px 20px;
      background-position:
      -1px -1px,
      -1px -1px,
      -1px -1px,
      -1px -1px;
      }
.zoom-toolbar {
      display: flex;
      gap: 4px;
      padding: 6px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      }
.zoom-toolbar button {
      width: 32px;
      height: 32px;
      padding: 0;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 18px;
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
      }
      .zoom-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
.zoom-toolbar .zoom-level {
      font-size: 11px;
      color: var(--toolbar-text, var(--text-soft));
      text-align: center;
      padding: 2px 0;
      min-width: 32px;
      }
.zoom-toolbar .divider {
      height: 1px;
      background: var(--toolbar-border, var(--edge-main));
      margin: 2px 0;
      }
      .minimap-zoom-wrapper {
      position: absolute;
      bottom: 10px;
      right: 10px;
      z-index: 99;
      }
.minimap-container {
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      overflow: hidden;
      margin-bottom: 4px;
      }
      .minimap-container svg {
      width: 100%;
      height: 100%;
      }
      .minimap-viewport {
      fill: rgba(79, 209, 197, 0.2);
      stroke: var(--accent);
      stroke-width: 2;
      cursor: move;
      }
.minimap-node {
      fill: var(--minimap-dots, var(--text-soft));
      }
      .minimap-edge {
      stroke: var(--edge-main);
      stroke-width: 1;
      }
.minimap-close-btn {
      position: absolute;
      top: 2px;
      right: 2px;
      width: 18px;
      height: 18px;
      background: var(--toolbar-btn-bg, rgba(15, 23, 42, 0.9));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 3px;
      color: var(--toolbar-text, var(--text-soft));
      font-size: 11px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
      padding: 0;
      line-height: 1;
      }
      .minimap-close-btn:hover {
      background: var(--danger);
      color: white;
      border-color: var(--danger);
      }
.toolbar-close-btn {
      width: 24px;
      height: 24px;
      background: var(--toolbar-btn-bg, rgba(15, 23, 42, 0.9));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-text, var(--text-soft));
      font-size: 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      line-height: 1;
      flex-shrink: 0;
      }
      .toolbar-close-btn:hover {
      background: var(--danger);
      color: white;
      border-color: var(--danger);
      }
.canvas-hint {
      position: absolute;
      top: 50px;
      left: 50%;
      transform: translateX(-50%);
      padding: 8px 16px;
      background: var(--canvas-hint-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      font-size: 12px;
      color: var(--canvas-hint-color, var(--text-soft));
      z-index: 18;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
      }
      .canvas-hint.visible {
      opacity: 1;
      }
      .edge {
      stroke: var(--edge-main);
      stroke-width: 4;
      opacity: 0.75;
      transition: 0.25s ease-in-out;
      cursor: pointer;
      }
      .edge.backup {
      stroke: var(--danger);
      stroke-width: 5;
      }
      .edge.active {
      opacity: 1;
      stroke-width: 7;
      }
      .free-preview {
      fill: none;
      stroke-dasharray: 4 4;
      pointer-events: none;
      }
      .free-point {
      fill: #e5e7eb;
      stroke: #0f172a;
      stroke-width: 1.5;
      cursor: grab;
      }
      .node-circle {
      fill: var(--node-fill, #1e293b);
      stroke: var(--node-stroke, #475569);
      stroke-width: 2;
      transition: 0.25s ease;
      transform-origin: center center;
      }
      .node-hit-area {
      cursor: grab;
      pointer-events: all;
      }
      .node-group:hover .node-circle {
      filter: drop-shadow(0 0 10px rgba(79, 209, 197, 0.45));
      }
      .node-group.active .node-circle {
      stroke: var(--accent);
      animation: pulse 1.2s infinite ease-in-out;
      }
      @keyframes pulse {
      0% {
      filter: drop-shadow(0 0 4px #4fd1c5);
      }
      50% {
      filter: drop-shadow(0 0 14px #4fd1c5);
      }
      100% {
      filter: drop-shadow(0 0 4px #4fd1c5);
      }
      }
      .node-label {
      fill: var(--text-main);
      font-size: 18px;
      text-anchor: middle;
      font-weight: 600;
      }
      .node-sub {
      fill: var(--text-soft);
      font-size: 13px;
      text-anchor: middle;
      }
      .ping-indicator {
      fill: #6b7280;
      stroke: #4b5563;
      stroke-width: 1;
      }
      .ping-indicator.online {
      fill: #10b981;
      stroke: #059669;
      }
      .ping-indicator.offline {
      fill: #ef4444;
      stroke: #dc2626;
      }
      .ping-indicator.checking {
      fill: #f59e0b;
      stroke: #d97706;
      }
      @media (max-width: 1024px) {
      .node-label {
      font-size: 28px;
      }
      .node-sub {
      font-size: 20px;
      }
      }
      @media (max-width: 768px) {
      .node-label {
      font-size: 70px;
      }
      .node-sub {
      font-size: 50px;
      }
      }
      @media (max-width: 380px) {
      .node-label {
      font-size: 60px;
      }
      .node-sub {
      font-size: 42px;
      }
      }
      .details-panel {
      background: var(--sidebar-bg, var(--panel-alt));
      padding: 22px;
      padding-bottom: 80px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 15px;
      position: relative;
      transition:
      width 0.3s ease,
      min-width 0.3s ease,
      padding 0.3s ease,
      opacity 0.3s ease;
      }
      .details-panel {
      min-width: 260px !important;
      }
      .details-panel {
      overflow-y: auto !important;
      overflow-x: hidden;
      }
      .details-panel.collapsed {
      width: 0 !important;
      min-width: 0 !important;
      padding: 0 !important;
      overflow: hidden;
      opacity: 0;
      }
      body {
      overflow-x: hidden;
      overflow-y: hidden;
      }
      main {
      overflow-x: hidden;
      overflow-y: visible;
      }
      .details-panel {
      overflow-y: auto !important;
      overflow-x: hidden;
      }
      .details-panel.collapsed {
      min-width: 0 !important;
      }
      .sidebar-toggle {
      position: absolute;
      left: -16px;
      top: 50%;
      transform: translateY(-50%);
      width: 16px;
      height: 60px;
      background: var(--sidebar-bg, var(--panel-alt));
      border: 1px solid var(--edge-main);
      border-right: none;
      border-radius: 8px 0 0 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text-soft);
      font-size: 10px;
      z-index: 25;
      transition:
      background 0.2s,
      color 0.2s;
      }
      .sidebar-toggle:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .sidebar-toggle.collapsed {
      left: 0;
      border-right: 1px solid var(--edge-main);
      border-radius: 0 8px 8px 0;
      position: fixed;
      right: 0;
      left: auto;
      }
      .details-name {
      font-size: clamp(22px, 2.5vw, 30px);
      font-weight: 700;
      }
      .details-ip {
      font-size: clamp(16px, 2vw, 22px);
      color: var(--text-soft);
      }
      .details-role {
      font-size: clamp(16px, 2vw, 22px);
      color: var(--accent);
      }
      .size-controls {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-top: 10px;
      }
      .size-controls label {
      font-size: clamp(14px, 1.6vw, 18px);
      color: var(--text-soft);
      }
      .size-controls input[type="range"] {
      flex: 1;
      accent-color: var(--accent);
      }
      .size-controls button {
      padding: 6px 12px;
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      font-size: clamp(12px, 1.4vw, 16px);
      }
      .size-controls button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .style-section {
      margin-top: 15px;
      padding-top: 15px;
      border-top: 1px solid var(--edge-main);
      }
      .style-section summary {
      cursor: pointer;
      font-size: clamp(14px, 1.6vw, 20px);
      text-transform: uppercase;
      color: var(--text-soft);
      list-style: none;
      display: flex;
      justify-content: space-between;
      align-items: center;
      user-select: none;
      }
      .style-section summary::-webkit-details-marker {
      display: none;
      }
      .password-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #ffffff;
      z-index: 9999;
      }
      .style-section summary::after {
      content: "‚ñº";
      transition: transform 0.2s;
      }
      .style-section[open] summary::after {
      transform: rotate(180deg);
      }
      .style-content {
      margin-top: 10px;
      }
      .style-row {
      display: flex;
      gap: 10px;
      align-items: center;
      margin: 8px 0;
      }
      .style-row label {
      font-size: clamp(13px, 1.5vw, 17px);
      color: var(--text-soft);
      min-width: 80px;
      }
      .style-row input[type="color"] {
      width: 50px;
      height: 30px;
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      background: transparent;
      }
      .style-row input[type="number"] {
      width: 70px;
      padding: 4px 8px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(12px, 1.4vw, 16px);
      }
      .style-row select {
      flex: 1;
      padding: 4px 8px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(12px, 1.4vw, 16px);
      cursor: pointer;
      }
      .editable-text {
      cursor: pointer;
      transition: opacity 0.2s;
      }
      .editable-text:hover {
      opacity: 0.7;
      }
      .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 999999;
      justify-content: center;
      align-items: center;
      overflow: auto;
      }
      .modal.active {
      display: inline-grid;
      }
      .modal-content {
      background: var(--panel-alt);
      padding: 25px;
      border-radius: 8px;
      border: 1px solid var(--edge-main);
      min-width: 300px;
      max-width: 90%;
      }
      .modal-content h3 {
      margin: 0 0 15px 0;
      color: var(--text-main);
      font-size: clamp(18px, 2vw, 24px);
      }
      .modal-content p {
      color: var(--text-soft);
      font-size: clamp(14px, 1.6vw, 18px);
      margin: 0 0 20px 0;
      }
      .modal-content input:not([type="color"]),
      .modal-content select {
      width: 100%;
      padding: 10px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(14px, 1.6vw, 18px);
      margin-bottom: 15px;
      user-select: text;
      -webkit-user-select: text;
      }
      .modal-content input[type="color"] {
      width: 60px;
      height: 36px;
      padding: 2px;
      border: 2px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      background: none;
      -webkit-appearance: none;
      appearance: none;
      }
      .modal-content input[type="color"]::-webkit-color-swatch-wrapper {
      padding: 0;
      }
      .modal-content input[type="color"]::-webkit-color-swatch {
      border: none;
      border-radius: 4px;
      }
      .modal-buttons {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
      margin-top: 10px;
      }
      .modal-buttons button {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: clamp(14px, 1.6vw, 18px);
      font-weight: 600;
      }
      .modal-buttons .btn-cancel {
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      }
      .modal-buttons .btn-save {
      background: var(--accent);
      color: var(--bg);
      }
      .modal-buttons .btn-delete {
      background: var(--danger);
      color: white;
      }
      .confirm-modal p {
      color: var(--text-soft);
      font-size: clamp(14px, 1.6vw, 18px);
      margin: 0 0 20px 0;
      }
      .context-menu-item {
      transition: background 0.15s;
      }
      .context-menu-item:hover {
      background: var(--panel);
      }
      .details-info-row {
      display: flex;
      align-items: center;
      margin: 6px 0;
      }
	 .node-group.selected .node-circle {
      stroke: var(--selection-handle, #f59e0b);
      stroke-width: 3;
      }
	  .node-group.layer-faded {
      pointer-events: none;
      }
      .edge.layer-faded {
      pointer-events: none;
      }
      .node-group.search-highlight .node-circle,
      .node-group.search-highlight rect,
      .node-group.search-highlight polygon {
      stroke: #10b981;
      stroke-width: 3;
      filter: drop-shadow(0 0 8px #10b981);
      }
      .badge-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      }
     .badge {
      background: var(--tag-fill, #1e293b);
      color: var(--tag-text, #e2e8f0);
      border: 1px solid var(--tag-border, var(--edge-main));
      padding: 5px 12px;
      border-radius: 22px;
      font-size: clamp(12px, 1.4vw, 18px);
      }
.badge.wg {
      color: var(--accent);
      border-color: var(--accent);
      }
input[type="text"],
      input[type="number"],
      input[type="password"],
      textarea,
      select {
      background: var(--input-bg, #0b0e13) !important;
      color: var(--input-text, #e2e8f0) !important;
      border-color: var(--input-border, #1f2937) !important;
      font-family: var(--input-font, Inter, system-ui, sans-serif) !important;
      font-size: var(--input-font-size, 14px) !important;
      }
      .section-label {
      margin-top: 8px;
      font-size: clamp(14px, 1.6vw, 20px);
      text-transform: uppercase;
      color: var(--text-soft);
      }
      .list li {
      margin: 6px 0;
      font-size: clamp(14px, 1.6vw, 20px);
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      }
      .list li:hover {
      color: var(--accent);
      }
      .delete-note {
      color: var(--danger);
      font-size: 18px;
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.2s;
      flex-shrink: 0;
      }
      .list li:hover .delete-note {
      opacity: 1;
      }
      .editing {
      outline: 2px solid var(--accent);
      background: #0d141f;
      padding: 4px;
      border-radius: 6px;
      user-select: text;
      -webkit-user-select: text;
      }
      .mobile-menu-btn {
      display: none;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      color: var(--text-main);
      font-size: 22px;
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      }
      #topbar-menu {
      gap: 8px;
      }
      @media (min-width: 721px) {
      #topbar-menu {
      display: flex !important;
      }
      }
      @media (max-width: 720px) {
      #topbar-menu {
      display: none;
      }
      #topbar-menu.open {
      display: flex;
      }
      }
      @media (max-width: 720px) {
      .mobile-menu-btn {
      display: block;
      }
      #topbar-menu {
      position: absolute;
      top: var(--topbar-height);
      right: 0;
      background: var(--panel-alt);
      border-left: 1px solid var(--topbar-border);
      border-bottom: 1px solid var(--topbar-border);
      padding: 12px;
      display: none;
      flex-direction: column;
      width: 180px;
      z-index: 999;
      }
      #topbar-menu.open {
      display: flex;
      }
      header {
      position: relative;
      z-index: 9999;
      }
      }
      @media (max-width: 720px) {
      .draw-toolbar {
      position: absolute;
      top: auto;
      bottom: auto;
      left: 10px !important;
      right: auto !important;
      width: auto;
      gap: 6px;
      padding: 8px;
      }	  
      .topology-toolbar {
      position: absolute;
      top: auto;
      bottom: auto;
      width: auto;
      gap: 6px;
      padding: 8px;
      }
      .draw-toolbar {
      top: 10px !important;
      }
      .topology-toolbar {
      top: calc(10px + var(--draw-toolbar-height, 50px)) !important;
      }
      .canvas-hint {
      top: calc(10px + 120px);
      }
      }
      .icon-picker-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      z-index: 999999999;
      justify-content: center;
      align-items: center;
      }
      .icon-picker-modal.active {
      display: flex;
      }
      .icon-picker-content {
      background: var(--panel);
      border-radius: 12px;
      width: 90%;
      max-width: 800px;
      max-height: 80vh;
      display: flex;
      flex-direction: column;
      border: 1px solid var(--edge-main);
      }
      .icon-picker-header {
      padding: 20px;
      border-bottom: 1px solid var(--edge-main);
      }
      .icon-picker-header h3 {
      margin: 0 0 15px 0;
      color: var(--text-main);
      }
      .icon-picker-tabs {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
      flex-wrap: wrap;
      }
      .icon-picker-tab {
      padding: 8px 16px;
      background: var(--panel-alt);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      color: var(--text-soft);
      font-size: 14px;
      transition: all 0.2s;
      }
      .icon-picker-tab:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .icon-picker-tab.active {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
      }
      .icon-picker-search {
      width: 100%;
      padding: 10px 15px;
      background: var(--panel-alt);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      color: var(--text-main);
      font-size: 14px;
      }
      .icon-picker-search::placeholder {
      color: var(--text-soft);
      }
      .icon-picker-body {
      padding: 20px;
      overflow-y: auto;
      flex: 1;
      }
      .icon-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
      gap: 10px;
      }
      .icon-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 15px 10px;
      background: var(--panel-alt);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .icon-item:hover {
      background: var(--accent);
      border-color: var(--accent);
      transform: scale(1.05);
      }
      .icon-item svg {
      width: 32px;
      height: 32px;
      fill: var(--text-main);
      }
      .icon-item:hover svg {
      fill: var(--bg);
      }
      .icon-item-name {
      margin-top: 8px;
      font-size: 10px;
      color: var(--text-soft);
      text-align: center;
      word-break: break-word;
      }
      .icon-item:hover .icon-item-name {
      color: var(--bg);
      }
      .icon-picker-loading {
      text-align: center;
      padding: 40px;
      color: var(--text-soft);
      }
      .icon-picker-footer {
      padding: 15px 20px;
      border-top: 1px solid var(--edge-main);
      display: flex;
      justify-content: flex-end;
      }
      .icon-btn-cancel {
      padding: 8px 20px;
      background: var(--panel-alt);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      }
      .icon-btn-cancel:hover {
      background: var(--edge-main);
      }
      .icon-badge {
      display: inline-flex;
      align-items: center;
      gap: 5px;
      padding: 4px 8px;
      background: var(--panel-alt);
      border-radius: 4px;
      font-size: 12px;
      margin: 2px;
      }
      .icon-badge svg {
      width: 16px;
      height: 16px;
      fill: currentColor;
      }
      .pick-icon-btn {
      padding: 6px 12px;
      background: var(--accent);
      color: var(--bg);
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      margin-top: 8px;
      width: 100%;
      }
      .pick-icon-btn:hover {
      opacity: 0.9;
      }
      @media (max-width: 768px) {
      .icon-picker-content {
      width: 95%;
      max-height: 90vh;	
      }
      .modal-content {
      background: var(--panel-alt);
      }
      #search-input {
      width: 100%;
      }
      }
      .version-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .version-item:hover {
      background: var(--panel-alt);
      border-color: var(--accent);
      }
      .version-item.current {
      border-color: var(--accent);
      background: rgba(79, 209, 197, 0.1);
      }
      .version-info {
      flex: 1;
      }
      .version-info .timestamp {
      font-size: 13px;
      color: var(--text-main);
      font-weight: 600;
      }
      .version-info .details {
      font-size: 11px;
      color: var(--text-soft);
      margin-top: 4px;
      }
      .version-actions {
      display: flex;
      gap: 6px;
      }
      .audit-entry {
      padding: 8px 12px;
      background: var(--panel);
      border-left: 3px solid var(--edge-main);
      border-radius: 4px;
      font-size: 12px;
      }
      .audit-entry.node { border-left-color: #4fd1c5; }
      .audit-entry.connection { border-left-color: #9f7aea; }
      .audit-entry.style { border-left-color: #ed8936; }
      .audit-entry.rack { border-left-color: #48bb78; }
      .audit-entry.layer { border-left-color: #4299e1; }
      .audit-entry .time {
      color: var(--text-soft);
      font-size: 10px;
      }
      .audit-entry .action {
      color: var(--text-main);
      font-weight: 500;
      }
      .tab-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .tab-item:hover {
      background: var(--panel-alt);
      }
      .tab-item.active {
      border-color: var(--accent);
      background: rgba(79, 209, 197, 0.1);
      }
      .tab-item .tab-name {
      font-weight: 600;
      color: var(--text-main);
      flex: 1;
      }
      .tab-item .tab-stats {
      font-size: 11px;
      color: var(--text-soft);
      margin-right: 10px;
      }
      .tab-actions {
      display: flex;
      gap: 6px;
      }
      .secret-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      border-left: 3px solid var(--danger);
      }
      .secret-item .secret-name {
      font-weight: 600;
      color: var(--text-main);
      flex: 1;
      }
      .secret-item .secret-status {
      font-size: 11px;
      color: var(--text-soft);
      margin-right: 10px;
      }   
    </style>
  </head>
  <body style="background: rgb(5, 5, 5);" class="">
    <div class="icon-picker-modal" id="icon-picker-modal">
      <div class="icon-picker-content">
        <div class="icon-picker-header">
          <h3>Select Icon</h3>
          <div class="icon-picker-tabs">
            <button class="icon-picker-tab" data-library="mdi">MDI</button>
            <button class="icon-picker-tab" data-library="simple">Simple Icons</button>
            <button class="icon-picker-tab active" data-library="selfhst">selfh.st/icons</button>
          </div>
          <input type="text" class="icon-picker-search" id="icon-search" placeholder="Search icons..." style="display: none;">
        </div>
        <div class="icon-picker-body" id="icon-picker-body">
        </div>
        <div class="icon-picker-footer">
          <button class="icon-btn-cancel" id="icon-picker-cancel">Cancel</button>
        </div>
      </div>
    </div>
    <div class="modal" id="tabs-modal">
      <div class="modal-content" style="max-width: 600px;">
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Manage multiple topologies</p>
        <div id="tabs-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 400px; overflow-y: auto; margin-bottom: 15px;">
            <div class="tab-item " onclick="switchTab(0)">
              <div class="tab-name">Homelab</div>
              <div class="tab-stats">20 nodes ‚Ä¢ 22 connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(0)" title="Rename tab">‚úèÔ∏è</button>
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(${index})" title="Delete tab">üóëÔ∏è</button>
              </div>
            </div>
          
            <div class="tab-item active" onclick="switchTab(1)">
              <div class="tab-name">Corporate</div>
              <div class="tab-stats">21 nodes ‚Ä¢ 22 connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(1)" title="Rename tab">‚úèÔ∏è</button>
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(${index})" title="Delete tab">üóëÔ∏è</button>
              </div>
            </div>
          </div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="new-tab-name" placeholder="New tab name..." style="flex: 1; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <button class="btn-save" onclick="createNewTab()">+ Add Tab</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="tabs-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="rollback-modal">
      <div class="modal-content" style="max-width: 700px;">
        <h3>Version History</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Limit: Snapshots</p>
        <div id="rollback-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 450px; overflow-y: auto; margin-bottom: 15px;">
          <div style="text-align: center; padding: 40px; color: var(--text-soft);">No version history yet. Versions are saved automatically when you save the file.</div>
        </div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <button class="btn-cancel" onclick="clearRollbackHistory()">Clear History</button>
          <button class="btn-save" onclick="createManualSnapshot()">Create Snapshot</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="rollback-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="audit-log-modal">
      <div class="modal-content" style="max-width: 800px;">
        <h3>Audit Log</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Track all changes made to your topology</p>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <select id="audit-filter" style="padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
            <option value="all">All Events</option>
            <option value="node">Node Operations</option>
            <option value="connection">Connections</option>
            <option value="style">Style Changes</option>
            <option value="rack">Rack Operations</option>
            <option value="layer">Layer Changes</option>
          </select>
          <button class="btn-save" onclick="exportAuditLog()">Export</button>
        </div>
        <div id="audit-log-list" style="display: flex; flex-direction: column; gap: 4px; max-height: 450px; overflow-y: auto; margin-bottom: 15px; font-family: monospace; font-size: 12px;">
          <div style="text-align: center; padding: 40px; color: var(--text-soft);">No audit entries yet</div>
        </div>
        <div style="display: flex; gap: 8px;">
          <button class="btn-cancel" onclick="clearAuditLog()">Clear Log</button>
          <button class="btn-cancel" id="audit-log-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="secrets-modal">
      <div class="modal-content" style="max-width: 600px;">
        <h3>Notes</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Notes can also be stored with AES 256 encryption</p>
        <div id="secrets-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 350px; overflow-y: auto; margin-bottom: 15px;">
        </div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="new-secret-name" placeholder="Section name (e.g., 'Root Passwords')..." style="flex: 1; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <button class="btn-save" onclick="createNewSecret()">+ Add Note</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="secrets-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="secret-editor-modal">
      <div class="modal-content" style="max-width: 600px;">
        <h3 id="secret-editor-title">Edit Note</h3>
        <textarea id="secret-editor-content" placeholder="Enter sensitive information here..." style="width: 100%; height: 200px; padding: 12px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main); font-family: monospace; resize: vertical; margin-bottom: 15px;"></textarea>
        <div style="margin-bottom: 15px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
          <input type="checkbox" id="secret-auto-encrypt" checked="" style="cursor: pointer;">
          <span>Encrypt Note</span>
          </label>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" onclick="closeSecretEditor()">Cancel</button>
          <button class="btn-save" onclick="saveSecret()">Save</button>
        </div>
      </div>
    </div>
    <div class="modal" id="edit-modal">
      <div class="modal-content">
        <h3 id="modal-title">Edit Name</h3>
        <input type="text" id="modal-input">
        <div class="modal-buttons">
          <button class="btn-cancel" id="modal-cancel">Cancel</button>
          <button class="btn-save" id="modal-save">Save</button>
        </div>
      </div>
    </div>
    <div class="modal confirm-modal" id="confirm-modal">
      <div class="modal-content">
        <h3>Confirm</h3>
        <p id="confirm-message"> Are you sure you want to delete this line? </p>
        <div class="modal-buttons">
          <button class="btn-cancel" id="confirm-cancel">Cancel</button>
          <button class="btn-delete" id="confirm-delete">Delete</button>
        </div>
      </div>
    </div>
    <div class="modal" id="save-info-modal">
      <div class="modal-content" style="max-width: 700px; max-height: 80vh; overflow-y: auto;">
        <h3 style="margin-bottom: 16px;">Help</h3>
        <div style="display: flex; gap: 8px; margin-bottom: 16px; flex-wrap: wrap;">
          <button class="help-tab active" data-tab="general" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--accent); color: var(--bg); border-radius: 6px; cursor: pointer; font-weight: 600;">General</button>
          <button class="help-tab" data-tab="desktop" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--panel); color: var(--text-main); border-radius: 6px; cursor: pointer; font-weight: 600;">Desktop</button>
          <button class="help-tab" data-tab="mobile" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--panel); color: var(--text-main); border-radius: 6px; cursor: pointer; font-weight: 600;">Mobile</button>
        </div>
        <div id="help-tab-general" class="help-tab-content" style="display: block;">
          <ul style="margin-left: 20px; margin-bottom: 12px; line-height: 1.8;">
            <li><strong>Add Nodes:</strong> Click "+ Node" or "+ Rack" in the top menu</li>
            <li><strong>Connect Nodes:</strong> Select a node, then use "Add Connection" in the panel</li>
            <li><strong>Move Nodes:</strong> Drag nodes to reposition them</li>
            <li><strong>Enter Rack View:</strong> Double click on desktop or Long press on mobile</li>
            <li><strong>Multi Select:</strong> Right click (desktop) or double tap (mobile)</li>
            <li><strong>Pan Canvas:</strong> Drag empty space or hold Space + drag</li>
            <li><strong>Zoom:</strong> Scroll wheel or pinch gesture</li>
            <li><strong>Free Draw:</strong> Use draw toolbar for drawing lines, boxes/zones , and text</li>
          </ul>
          <h4 style="color: var(--accent); margin-bottom: 8px;">Saving &amp; Encryption</h4>
          <p style="margin-bottom: 8px;">Browsers cannot overwrite local files. Click <strong>Save File</strong> to download an updated HTML with all changes. Replace your old file to keep edits.</p>
          <p style="margin-bottom: 8px;"><strong>Encryption of data:</strong> Check "Encrypt" before saving to password protect your data. Beware! No recovery possible without password!!</p>
          <p><strong>Decryption of data:</strong> Export via JSON in top settings menu after successful password validation to decrypt your data. You can then reimport back into the same file and save!</p>
        </div>
        <div id="help-tab-desktop" class="help-tab-content" style="display: none;">
          <h4 style="color: var(--accent); margin-bottom: 12px;">Navigation</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Arrow Keys</code></td>
              <td style="padding: 8px;">Move selected 1px</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Shift + Arrows</code></td>
              <td style="padding: 8px;">Move selected 10px</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Tab / Shift+Tab</code></td>
              <td style="padding: 8px;">Cycle through nodes</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">F</code></td>
              <td style="padding: 8px;">Focus on selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Space + Drag</code></td>
              <td style="padding: 8px;">Pan canvas</td>
            </tr>
          </tbody></table>
          <h4 style="color: var(--accent); margin-bottom: 12px;">Management</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">L</code></td>
              <td style="padding: 8px;">Lock/unlock selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">G</code></td>
              <td style="padding: 8px;">Group/ungroup selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+C / Ctrl+V</code></td>
              <td style="padding: 8px;">Copy / Paste</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+D</code></td>
              <td style="padding: 8px;">Duplicate</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+A</code></td>
              <td style="padding: 8px;">Select all</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Delete</code></td>
              <td style="padding: 8px;">Delete selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Escape</code></td>
              <td style="padding: 8px;">Clear selection</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+Z / Ctrl+Y</code></td>
              <td style="padding: 8px;">Undo / Redo</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Right Click</code></td>
              <td style="padding: 8px;">Multi select toggle</td>
            </tr>
          </tbody></table>
        </div>
        <div id="help-tab-mobile" class="help-tab-content" style="display: none;">
          <h4 style="color: var(--accent); margin-bottom: 12px;">Basic Gestures</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Tap node</strong></td>
              <td style="padding: 8px;">Select &amp; open properties</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Tap empty</strong></td>
              <td style="padding: 8px;">Deselect all</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Drag node</strong></td>
              <td style="padding: 8px;">Move node</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Drag empty</strong></td>
              <td style="padding: 8px;">Pan canvas</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Pinch</strong></td>
              <td style="padding: 8px;">Zoom in/out</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Double-tap node</strong></td>
              <td style="padding: 8px;">Add/remove from selection</td>
            </tr>
          </tbody></table>
          <h4 style="color: var(--accent); margin-bottom: 12px;">Rack View</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Long-press rack</strong></td>
              <td style="padding: 8px;">Enter rack view</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Double-tap empty</strong></td>
              <td style="padding: 8px;">Exit rack view</td>
            </tr>
          </tbody></table>
        </div>
        <div class="modal-buttons" style="margin-top: 16px;">
          <button class="btn-cancel" id="save-info-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="settings-modal">
	
	
	<div class="modal-content">
        <h2>Settings</h2>
        
        <details class="style-section">
          <summary>General Theme</summary>
          <div class="style-content">
		    <div class="style-row">
              <label>Main Background</label>
              <input type="color" id="panel-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Modal Window (popup) Background</label>
              <input type="color" id="panel-alt-color" value="#10141b">
            </div>
            <div class="style-row">
              <label>Accent Buttons</label>
              <input type="color" id="accent-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Danger Buttons</label>
              <input type="color" id="danger-color" value="#f56565">
            </div>
            <div class="style-row">
              <label>Primary Text</label>
              <input type="color" id="text-main-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Secondary Text</label>
              <input type="color" id="text-soft-color" value="#94a3b8">
            </div>
          </div>
        </details>
		
        <details class="style-section">
          <summary>Top Bar</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="topbar-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="topbar-border-color" value="#1f2533">
            </div>
          </div>
		  <div class="style-content">
            <div class="style-row">
              <label>Button Fill</label>
              <input type="color" id="btn-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Button Text</label>
              <input type="color" id="btn-text-color" value="#e2e8f0">
            </div>
          </div>
        </details>
		
        <details class="style-section">
          <summary>Main Canvas</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="canvas-border-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Grid Lines</label>
              <input type="color" id="canvas-grid-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Grid Size</label>
              <input type="number" id="canvas-grid-size" value="50" min="20" max="200" style="width:60px;">
            </div>
		    <div class="style-row">
              <label>Background Top</label>
              <input type="color" id="canvas-gradient-top" value="#1e2532">
            </div>
            <div class="style-row">
              <label>Background Bottom</label>
              <input type="color" id="canvas-gradient-bottom" value="#050608">
            </div>
            <div class="style-row">
              <label>Solid Background</label>
              <input type="color" id="page-bg-color" value="#050608">
            </div>
            <p style="margin-top:4px;font-size:12px;color:var(--text-soft);">Set solid background to override gradient.</p>
          </div>
        </details>
        <details class="style-section">
          <summary>Rack Canvas</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Frame Fill</label>
              <input type="color" id="rack-frame-fill" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Frame Border</label>
              <input type="color" id="rack-frame-stroke" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Grid Lines</label>
              <input type="color" id="rack-line-color" value="#475569">
            </div>
            <div class="style-row">
              <label>U Labels</label>
              <input type="color" id="rack-text-color" value="#4fd1c5">
            </div>
          </div>
       </details>
	   <details class="style-section">
          <summary>Canvas Toolbars</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="toolbar-bg-color" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="toolbar-border-color" value="#1f2937">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="toolbar-text-color" value="#94a3b8">
            </div>
            <div class="style-row">
              <label>Button Fill</label>
              <input type="color" id="toolbar-btn-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Button Text</label>
              <input type="color" id="toolbar-btn-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Minimap Dots</label>
              <input type="color" id="minimap-dots-color" value="#94a3b8">
            </div>
          </div>
        </details>
		
        <details class="style-section">
          <summary>Nodes</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Fill</label>
              <input type="color" id="node-fill-color" value="#1e293b">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="node-stroke-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Title Color</label>
              <input type="color" id="node-title-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Title Size</label>
              <input type="number" id="node-title-size" value="18" min="8" max="48" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Subtitle Color</label>
              <input type="color" id="node-sub-color" value="#94a3b8">
            </div>
            <div class="style-row">
              <label>Subtitle Size</label>
              <input type="number" id="node-sub-size" value="13" min="8" max="48" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Font</label>
              <select id="node-font-family" style="flex:1;padding:4px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;">
                <option value="Inter, system-ui, sans-serif">Inter</option>
                <option value="Arial, sans-serif">Arial</option>
                <option value="Helvetica, sans-serif">Helvetica</option>
                <option value="Georgia, serif">Georgia</option>
                <option value="monospace">Monospace</option>
              </select>
            </div>
          </div>
        </details>
        
        <details class="style-section">
          <summary>Connections</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Default Color</label>
              <input type="color" id="default-edge-color" value="#475569">
            </div>
          </div>
        </details>
        
        <details class="style-section">
          <summary>Groups &amp; Editing</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Resize handle Color</label>
              <input type="color" id="selection-handle-color" value="#f59e0b">
            </div>
            <div class="style-row">
              <label>Resize Handle Size</label>
              <input type="number" id="selection-handle-size" value="8" min="4" max="16" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Grouped Icon Outline</label>
              <input type="color" id="group-indicator-color" value="#4fd1c5">
            </div>
          </div>
        </details>
   
		<details class="style-section">
          <summary>Inputs &amp; Dropdowns</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="input-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="input-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="input-border-color" value="#1f2937">
            </div>
            <div class="style-row">
              <label>Font</label>
              <select id="input-font-family" style="flex:1;padding:4px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;">
                <option value="Inter, system-ui, sans-serif">Inter</option>
                <option value="Arial, sans-serif">Arial</option>
                <option value="Helvetica, sans-serif">Helvetica</option>
                <option value="Georgia, serif">Georgia</option>
                <option value="monospace">Monospace</option>
              </select>
            </div>
            <div class="style-row">
              <label>Font Size</label>
              <input type="number" id="input-font-size" value="14" min="10" max="24" style="width:60px;">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Welcome Message</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Enabled</label>
              <input type="checkbox" id="canvas-hint-enabled" checked="" style="width:auto;">
            </div>
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="canvas-hint-bg-color" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Text Color</label>
              <input type="color" id="canvas-hint-text-color" value="#94a3b8">
            </div>
            <div class="style-row" style="flex-direction:column;align-items:stretch;">
              <label>Custom Text (HTML)</label>
              <textarea id="canvas-hint-text" rows="4" style="width:100%;margin-top:4px;padding:6px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;font-size:12px;resize:vertical;" placeholder="Leave empty for default"></textarea>
            </div>
          </div>
        </details>
        
        <details class="style-section">
          <summary>Sidebar / Mobile Footer</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="sidebar-bg-color" value="#10141b">
            </div>
          </div>
        </details>
        
        <details class="style-section">
          <summary>Tags</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Fill</label>
              <input type="color" id="tag-fill-color" value="#1e293b">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="tag-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="tag-border-color" value="#475569">
            </div>
          </div>
        </details>     
        <details class="style-section" open="">
          <summary>Import / Export / Upgrade JSON</summary>
          <div class="style-content">
            <button id="export-data-btn" style="width:100%;margin-bottom:10px;padding:10px;background:var(--accent);color:var(--bg);border:none;border-radius:6px;cursor:pointer;font-size:14px;font-weight:600;">Export JSON</button>
            <button id="import-data-btn" style="width:100%;padding:10px;background:var(--panel);color:var(--text-main);border:1px solid var(--edge-main);border-radius:6px;cursor:pointer;font-size:14px;font-weight:600;">Import JSON</button>
            <input type="file" id="import-data-file" accept=".json" style="display:none">
          </div>
        </details>
         <details class="style-section">
          <summary>Auto Status Checking</summary>
          <div class="style-content">
            <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 16px; cursor: pointer;">
            <input type="checkbox" id="auto-ping-enabled" style="cursor: pointer;">
            <span style="font-size: 14px; font-weight: 600;">Enable automatic status checking</span>
            </label>
            <div id="auto-ping-settings" style="display: none; padding-left: 20px; border-left: 2px solid var(--edge-main);">
              <div class="style-row" style="margin-bottom: 12px;">
                <label>Check Interval (seconds):</label>
                <input type="number" id="auto-ping-interval" min="5" max="3600" value="30" style="width: 80px; padding: 6px; background: var(--panel); border: 1px solid var(--edge-main); border-radius: 4px; color: var(--text-main);">
              </div>
              <div style="padding: 10px; background: var(--panel); border-radius: 6px; border: 1px solid var(--edge-main); font-size: 12px; color: var(--text-soft);">
                <div style="margin-bottom: 4px;"><span id="auto-ping-next-check">Next check in: --</span></div>
                <div><span id="auto-ping-last-run">Last run: 1:15:07 PM</span></div>
              </div>
            </div>
            <p style="margin-top: 12px; font-size: 12px; color: var(--text-soft); font-style: italic;">
              Automatically checks all ping enabled nodes at the specified interval. I recommend 30 to 60 seconds for local networks.
            </p>
			</div>
        </details>
        <details class="style-section">
          <summary>Danger Zone</summary>
          <div class="style-content">
            <p style="margin-bottom:12px;font-size:13px;color:var(--text-soft);">Permanently delete everything on the canvas.</p>
            <button id="clear-all-btn" title="Clear all nodes" style="padding:6px 12px;background:var(--danger);color:#fff;border:none;border-radius:6px;cursor:pointer;font-size:14px;font-weight:600;">Clear All</button>
            <input type="file" id="import-data-file" accept=".json" style="display:none">
          </div>
        </details>
        
        <div class="modal-buttons">
          <button class="btn-cancel" id="settings-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="add-node-modal">
      <div class="modal-content">
        <h3>Add New Node</h3>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Basic Information</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Name</label>
          <input type="text" id="new-node-name" placeholder="e.g. web server, jellyfin">
          <label style="display: block;margin-bottom: 4px;margin-top: 12px;color: var(--text-soft);font-size: 13px;">IP / Subtitle</label>
          <input type="text" id="new-node-ip" placeholder="e.g. 192.168.1.100">
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Tags</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Text Tags (comma separated)</label>
          <input type="text" id="new-node-tags" placeholder="e.g. Docker, nginx, WG: vpn">
          <button class="pick-icon-btn" id="pick-new-node-tag-icon-btn" style="margin-top: 10px;">Add Icon Tag</button>
          <div id="new-node-icon-tags" style="margin-top: 10px; display: none;">
            <label style="display: block; margin-bottom: 8px; color: var(--text-soft); font-size: 13px;">Icon Tags:</label>
            <div id="new-node-icon-tags-list" style="display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 10px;"></div>
          </div>
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Node Appearance</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Basic Shapes</label>
          <select id="new-node-shape">
            <optgroup label="Basic Shapes">
              <option value="circle">Circle</option>
              <option value="square">Square</option>
              <option value="rectangle">Rectangle</option>
              <option value="triangle">Triangle</option>
              <option value="hexagon">Hexagon</option>
              <option value="diamond">Diamond</option>
              <option value="star">Star</option>
              <option value="stop-sign">Stop Sign</option>
            </optgroup>
            <optgroup label="Network Equipment">
              <option value="server">Server</option>
              <option value="pc">PC / Desktop</option>
              <option value="laptop">Laptop</option>
              <option value="phone">Phone / Mobile</option>
              <option value="router">Router</option>
              <option value="switch">Switch</option>
              <option value="firewall">Firewall</option>
              <option value="cloud">Cloud</option>
              <option value="database">Database</option>
              <option value="printer">Printer</option>
            </optgroup>
          </select>
          <button class="pick-icon-btn" id="pick-node-icon-btn" style="margin-top: 10px;"> Or search web icons</button>
          <div id="selected-node-icon" style="margin-top: 10px; display: none;">
            <label style="display: block; margin-bottom: 8px; color: var(--text-soft); font-size: 13px;">Selected Icon:</label>
            <div class="icon-badge" id="selected-node-icon-preview">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24">
                <image href="https://cdn.jsdelivr.net/gh/selfhst/icons@master/png/docker.png" width="24" height="24"></image>
              </svg>
              <span>docker</span>
            </div>
          </div>
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Ping / Status Monitoring</div>
          <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px; cursor: pointer;">
          <input type="checkbox" id="new-node-pingable" style="cursor: pointer;">
          <span style="color: var(--text-soft); font-size: 13px;">Enable ping/status check for this node</span>
          </label>
          <div id="new-node-ping-options" style="display: block; padding-left: 24px; border-left: 2px solid var(--edge-main);">
            <label style="display: block; margin-bottom: 4px; color: var(--text-soft); font-size: 13px;">Protocol</label>
            <select id="new-node-ping-protocol" style="margin-bottom: 12px;">
              <option value="http">HTTP (port 80) uses IP field</option>
              <option value="https">HTTPS (port 443) uses IP field</option>
              <option value="custom">Custom URL</option>
            </select>
            <div id="new-node-custom-url-container" style="display: block;">
              <label style="display: block; margin-bottom: 4px; color: var(--text-soft); font-size: 13px;">Custom URL</label>
              <input type="text" id="new-node-custom-url" placeholder="e.g. http://192.168.1.1:8080">
            </div>
            <label style="display: block; margin-bottom: 4px; margin-top: 8px; color: var(--text-soft); font-size: 13px;">
            Timeout (ms)
            </label>
            <input type="number" id="new-node-ping-timeout" value="3000" min="1000" max="10000" step="500">
          </div>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="add-node-cancel">Cancel</button>
          <button class="btn-save" id="add-node-save">Add Node</button>
        </div>
      </div>
    </div>
    <div class="modal" id="add-rack-modal">
      <div class="modal-content">
        <h3>Add New Rack</h3>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Basic Information</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Rack Name</label>
          <input type="text" id="new-rack-name" placeholder="e.g. Rack-A, DC1-R01, Production-01">
          <label style="display: block;margin-bottom: 4px;margin-top: 12px;color: var(--text-soft);font-size: 13px;">IP / Network Range (optional)</label>
          <input type="text" id="new-rack-ip" placeholder="e.g. 192.168.1.0/24">
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Tags</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Text Tags (comma separated)</label>
          <input type="text" id="new-rack-tags" placeholder="e.g. Production, Data Center 1, Row A">
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Rack Appearance</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Icon / Shape</label>
          <select id="new-rack-shape">
            <optgroup label="Basic Shapes">
              <option value="circle">Circle</option>
              <option value="square">Square</option>
              <option value="rectangle">Rectangle</option>
              <option value="triangle">Triangle</option>
              <option value="hexagon">Hexagon</option>
              <option value="diamond">Diamond</option>
              <option value="star">Star</option>
              <option value="stop-sign">Stop Sign</option>
            </optgroup>
            <optgroup label="Network Equipment">
              <option value="server" selected="">Server</option>
              <option value="pc">PC / Desktop</option>
              <option value="laptop">Laptop</option>
              <option value="phone">Phone / Mobile</option>
              <option value="router">Router</option>
              <option value="switch">Switch</option>
              <option value="firewall">Firewall</option>
              <option value="cloud">Cloud</option>
              <option value="database">Database</option>
              <option value="printer">Printer</option>
            </optgroup>
          </select>
          <button class="pick-icon-btn" id="pick-rack-icon-btn" style="margin-top: 10px;">Or Search Web Icons</button>
          <div id="selected-rack-icon" style="margin-top: 10px; display: none;">
            <label style="display: block; margin-bottom: 8px; color: var(--text-soft); font-size: 13px;">Selected Icon:</label>
            <div class="icon-badge" id="selected-rack-icon-preview">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24">
                <image href="" width="24" height="24"></image>
              </svg>
              <span></span>
            </div>
          </div>
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Rack Configuration</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Rack Capacity</label>
          <select id="new-rack-capacity">
            <option value="42" selected="">42U (Standard Full Rack)</option>
            <option value="48">48U (Large Rack)</option>
            <option value="24">24U (Half Rack)</option>
            <option value="12">12U (Small/Wall Mount)</option>
            <option value="6">6U (Mini Rack)</option>
          </select>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="add-rack-cancel">Cancel</button>
          <button class="btn-save" id="add-rack-save">Add Rack</button>
        </div>
      </div>
    </div>
    <div class="modal confirm-modal" id="clear-all-modal">
      <div class="modal-content">
        <h3>Clear All Nodes</h3>
        <p> This will remove ALL nodes and connections. This cannot be undone until you reload without saving. Are you sure? </p>
        <div class="modal-buttons">
          <button class="btn-cancel" id="clear-all-cancel">Cancel</button>
          <button class="btn-delete" id="clear-all-confirm">Clear Everything</button>
        </div>
      </div>
    </div>
    <div class="modal" id="layer-modal">
      <div class="modal-content" style="max-width: 400px;">
        <h3>Layer Visibility</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Toggle which layers are visible on the canvas</p>
        <div style="display: flex; flex-direction: column; gap: 10px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-physical" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Physical Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-logical" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Logical Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-security" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Security Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-application" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Application Layer</span>
          </label>
        </div>
        <div style="margin-top: 15px; display: flex; gap: 8px;">
          <button class="btn-cancel" style="flex: 1;" onclick="document.querySelectorAll('#layer-modal input[type=checkbox]').forEach(cb =&gt; cb.checked = false); applyLayerFilter();">Hide All</button>
          <button class="btn-save" style="flex: 1;" onclick="document.querySelectorAll('#layer-modal input[type=checkbox]').forEach(cb =&gt; cb.checked = true); applyLayerFilter();">Show All</button>
        </div>
        <div class="modal-buttons" style="margin-top: 10px;">
          <button class="btn-cancel" id="layer-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div id="context-menu" style="display: none !important;">
    </div>
    <header>
      <div class="title-block">
        <h1 id="page-title" class="editable-page-title">Corporate</h1>
        <div class="save-row">
          <button id="save-file-btn" class="save-btn" type="button">Save File</button>
          <label style="display: flex;align-items: center;gap: 4px;font-size: 12px;color: var(--text-soft);cursor: pointer;user-select: none;">
          <input type="checkbox" id="encrypt-toggle" style="cursor: pointer">
          <span title="Encrypt data with password">Encrypt</span>
          </label>
          <span id="save-help-btn" class="help-icon" title="Why save?">?</span>
        </div>
      </div>
      <div id="topbar-menu">
        <button id="back-to-topology-btn" title="Exit rack view and return to topology" style="padding: 6px 12px; background: var(--accent); color: var(--bg); border: none; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600; display: none;">‚Üê Back to Topology</button>
        <button id="add-node-btn" class="save-btn" title="Add new node" style="background: var(--accent)">+ Node</button>
        <button id="add-rack-btn" class="save-btn" title="Add new rack" style="background: var(--accent); margin-left: 8px;">+ Rack</button>
        <button id="undo-btn" title="Undo (Ctrl+Z)" style="padding: 6px 12px; background: var(--btn-bg); color: var(--btn-text); border: 1px solid var(--edge-main); border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600; opacity: 1;">‚Ü∂</button>
        <button id="redo-btn" title="Redo (Ctrl+Y)" style="padding: 6px 12px; background: var(--btn-bg); color: var(--btn-text); border: 1px solid var(--edge-main); border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600; opacity: 0.5;" disabled="">‚Ü∑</button>
<input type="text" id="search-nodes" placeholder="Search nodes..." title="Search by name, IP, MAC, role, or tag" style="padding: 6px 12px;background: var(--input-bg);color: var(--input-text);border: 1px solid var(--input-border);border-radius: 6px;font-family: var(--input-font);font-size: var(--input-font-size);width: 180px;">
        <button id="check-all-ping-btn" title="Check status of all enabled nodes" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600">Check Pings</button>
        <button id="layers-btn" title="Toggle layer visibility" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Layers</button>
        <button id="tabs-btn" title="Manage document tabs" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Tabs</button>
        <button id="rollback-btn" title="View version history" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Snapshots</button>
        <button id="audit-log-btn" title="View audit log" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Audit</button>
        <button id="secrets-btn" title="Manage encrypted notes" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Notes</button>
        <button onclick="screenshotCanvas()" title="Export canvas as PNG image" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">PNG</button>
        <button onclick="exportCanvasSVG()" title="Export canvas as SVG vector" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">SVG</button>
        <button id="settings-btn" title="Page settings">‚öôÔ∏è</button>
      </div>
      <button id="mobile-menu-toggle" class="mobile-menu-btn">‚ò∞</button>
      <div class="header-resizer" id="header-resizer">
        <svg class="resizer-icon" width="40" height="6" viewBox="0 0 40 6" xmlns="http://www.w3.org/2000/svg">
          <circle cx="14" cy="3" r="2"></circle>
          <circle cx="20" cy="3" r="2"></circle>
          <circle cx="26" cy="3" r="2"></circle>
        </svg>
      </div>
    </header>
    <main>
      <section class="topology-panel">
        <div class="draw-toolbar" id="draw-toolbar" style="display: flex !important;">
          <button type="button" class="toolbar-close-btn" id="draw-toolbar-close-btn" title="Hide draw toolbar">‚úï</button>
          <button id="draw-toggle" title="Draw custom line">‚úèÔ∏è</button>
          <button id="rect-toggle" title="Draw zone">‚ñ≠</button>
          <button id="text-toggle" title="Add text">T</button>
          <select id="rect-style" title="zone style">
            <option value="filled">Filled</option>
            <option value="outlined">Outlined</option>
          </select>
          <input type="color" id="draw-color" value="#f97316" title="Line color">
          <select id="draw-style" title="Line style">
            <option value="solid">Solid</option>
            <option value="dashed">Dashed</option>
            <option value="dotted">Dotted</option>
          </select>
          <select id="draw-arrow" title="Arrow direction">
            <option value="none">No arrows</option>
            <option value="forward">‚Üí Right</option>
            <option value="backward">‚Üê Left</option>
            <option value="both">‚Üî Both</option>
          </select>
          <button id="draw-undo" style="display: none" title="Undo last point">Undo</button>
        </div>
        <div class="topology-toolbar" id="topology-toolbar" style="display: flex !important;">
          <button type="button" class="toolbar-close-btn" id="topology-toolbar-close-btn" title="Hide add line toolbar">‚úï</button>
          <label for="add-line-select">Add line to:</label>
          <select id="add-line-select"><option value="opnsense">OPNsense</option><option value="main-switch">Main Switch</option><option value="proxmox">Proxmox</option><option value="truenas">TrueNAS</option><option value="docker-host">Docker Host</option><option value="pi-hole">Pi-hole</option><option value="plex">Plex</option><option value="jellyfin">Jellyfin</option><option value="nextcloud">Nextcloud</option><option value="bitwarden">Vaultwarden</option><option value="homeassistant">Home Assistant</option><option value="portainer">Portainer</option><option value="traefik">Traefik</option><option value="grafana">Grafana</option><option value="prometheus">Prometheus</option><option value="unifi-controller">UniFi Controller</option><option value="wireguard">WireGuard</option><option value="im-a-rack">IM A RACK</option></select>
<input type="color" id="add-line-color" value="#475569" title="Line color" style="width: 30px;height: 24px;border: 1px solid var(--toolbar-border);border-radius: 4px;cursor: pointer;background: transparent;padding: 0;">          <select id="add-line-direction" title="Line direction">
            <option value="none">No arrows</option>
            <option value="forward">‚Üí Forward</option>
            <option value="backward">‚Üê Backward</option>
            <option value="both">‚Üî Both</option>
          </select>
          <button id="add-line-btn">Add</button>
        </div>
        <div class="topology-toolbar bulk-toolbar-desktop" id="bulk-toolbar" style="display: none">
          <button type="button" class="toolbar-close-btn" id="bulk-toolbar-close" title="Clear selection">‚úï</button>
          <label style="font-weight: 600; color: var(--accent)">Selected: <span id="bulk-count">0</span></label>
          <button id="bulk-align-left" title="Align left">‚¨Ö Left</button>
          <button id="bulk-align-right" title="Align right">‚û° Right</button>
          <button id="bulk-align-top" title="Align top">‚¨Ü Top</button>
          <button id="bulk-align-bottom" title="Align bottom">‚¨á Bottom</button>
          <button id="bulk-distribute-h" title="Distribute horizontally">‚Üî Distribute H</button>
          <button id="bulk-distribute-v" title="Distribute vertically">‚Üï Distribute V</button>
          <button id="bulk-clone" title="Clone selected">üìã Clone</button>
          <button id="bulk-delete" title="Delete selected" style="background: var(--danger); color: white;">Delete</button>
        </div>
        <div class="bulk-toolbar-mobile" id="bulk-toolbar-mobile" style="display: none">
          <button type="button" id="bulk-mobile-btn" style="background: var(--accent);color: white;padding: 12px 20px;border-radius: 25px;font-weight: 600;font-size: 16px;box-shadow: 0 4px 12px rgba(0,0,0,0.3);border: none;cursor: pointer;display: flex;align-items: center;gap: 8px;">
          <span id="bulk-count-mobile">0</span>Selected</button>
        </div>
        <div id="bulk-actions-modal" style="display: none;position: fixed;bottom: 0;left: 0;right: 0;background: var(--panel-alt);border-top-left-radius:20px;border-top-right-radius:20px;padding:20px;padding-bottom:(safe-area-inset-bottom, 20px);box-shadow: 0 -4px 20px rgba(0,0,0,0.5);z-index: 10000;max-height: calc(100vh - 80px);overflow-y: auto;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            <h3 style="margin: 0; color: var(--accent); font-size: 20px;">
              <span id="bulk-count-modal">0</span> Nodes Selected
            </h3>
            <button id="bulk-modal-close" style="background: none;border: none;font-size: 24px;cursor: pointer;color: var(--text-main);padding: 0;width: 32px;height: 32px;">‚úï</button>
          </div>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
            <button id="bulk-align-left-mobile" class="bulk-action-btn">‚¨Ö<br><span style="font-size: 12px;">Align Left</span></button>
            <button id="bulk-align-right-mobile" class="bulk-action-btn">‚û°<br><span style="font-size: 12px;">Align Right</span></button>
            <button id="bulk-align-top-mobile" class="bulk-action-btn">‚¨Ü<br><span style="font-size: 12px;">Align Top</span></button>
            <button id="bulk-align-bottom-mobile" class="bulk-action-btn">‚¨á<br><span style="font-size: 12px;">Align Bottom</span></button>
            <button id="bulk-distribute-h-mobile" class="bulk-action-btn">‚Üî<br><span style="font-size: 12px;">Distribute H</span></button>
            <button id="bulk-distribute-v-mobile" class="bulk-action-btn">‚Üï<br><span style="font-size: 12px;">Distribute V</span></button>
            <button id="bulk-lock-mobile" class="bulk-action-btn">üîí<br><span style="font-size: 12px;">Lock Toggle</span></button>
            <button id="bulk-group-mobile" class="bulk-action-btn">‚≠ï<br><span style="font-size: 12px;">Group Toggle</span></button>
            <button id="bulk-clone-mobile" class="bulk-action-btn">üìã<br><span style="font-size: 12px;">Clone All</span></button>
            <button id="bulk-delete-mobile" class="bulk-action-btn" style="background: var(--danger); color: white;">üóë<br><span style="font-size: 12px;">Delete All</span></button>
          </div>
          <button id="bulk-clear-mobile" style="width: 100%;margin-top: 16px;padding: 14px;background: var(--panel-main);border: 1px solid var(--edge-main);border-radius: 8px;color: var(--text-main);font-size: 16px;cursor: pointer;">Clear Selection</button>
        </div>
        <div class="canvas-hint" id="canvas-hint"></div>
        <div class="legend-container" id="edge-legend" style="display: flex;"><div class="legend-title">Line Legend</div><button type="button" class="legend-close-btn">‚úï</button><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(239, 68, 68); cursor: pointer;"></span><span class="legend-label" contenteditable="true">WAN / DMZ</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(245, 158, 11); cursor: pointer;"></span><span class="legend-label" contenteditable="true">Trunk / Uplink</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(16, 185, 129); cursor: pointer;"></span><span class="legend-label" contenteditable="true">Core / Distribution</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(59, 130, 246); cursor: pointer;"></span><span class="legend-label" contenteditable="true">Access Layer</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(139, 92, 246); cursor: pointer;"></span><span class="legend-label" contenteditable="true">Server VLAN</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(6, 182, 212); cursor: pointer;"></span><span class="legend-label" contenteditable="true">Management</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(249, 115, 22); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div></div>
        <div class="canvas-viewport" id="canvas-viewport">
          <svg id="map" viewBox="384.66666666666674 27 3230.6666666666665 2423" style=""><defs><marker id="arrow-forward" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto" markerUnits="strokeWidth"><path d="M0,0 L0,6 L9,3 z" fill="context-stroke"></path></marker><marker id="arrow-backward" markerWidth="10" markerHeight="10" refX="0" refY="3" orient="auto" markerUnits="strokeWidth"><path d="M9,0 L9,6 L0,3 z" fill="context-stroke"></path></marker></defs><rect x="100" y="100" width="3800" height="2800" fill="none" stroke="#ffffff4D" stroke-width="20" stroke-dasharray="10 5" rx="8"></rect><g id="canvas-grid"><line x1="100" y1="100" x2="100" y2="2900" stroke="#00000066" stroke-width="2"></line><line x1="150" y1="100" x2="150" y2="2900" stroke="#00000033" stroke-width="1"></line><line x1="200" y1="100" x2="200" y2="2900" stroke="#00000033" stroke-width="1"></line><line x1="250" y1="100" x2="250" y2="2900" stroke="#00000033" stroke-width="1"></line><line x1="300" y1="100" x2="300" y2="2900" stroke="#00000033" stroke-width="1"></line><line x1="350" y1="100" x2="350" y2="2900" stroke="#00000066" stroke-width="2"></line><line x1="400" y1="100" x2="400" y2="2900" stroke="#00000033" stroke-width="1"></line><line x1="450" y1="100" x2="450" y2="2900" stroke="#00000033" stroke-width="1"></line><line x1="500" y1="100" x2="500" y2="2900" stroke="#00000033" stroke-width="1"></line><line x1="550" y1="100" x2="550" y2="2900" stroke="#00000033" stroke-width="1"></line><line x1="600" y1="100" x2="600" y2="2900" stroke="#00000066" stroke-width="2"></line><line x1="650" y1="100" x2="650" y2="2900" stroke="#00000033" stroke-width="1"></line><line x1="700" y1="100" x2="700" y2="2900" stroke="#00000033" stroke-width="1"></line><line x1="750" y1="100" x2="750" y2="2900" stroke="#00000033" stroke-width="1"></line><line x1="800" y1="100" x2="800" y2="2900" stroke="#00000033" stroke-width="1"></line><line x1="850" y1="100" x2="850" y2="2900" stroke="#00000066" stroke-width="2"></line><line x1="900" y1="100" x2="900" y2="2900" stroke="#00000033" stroke-width="1"></line><line x1="950" y1="100" x2="950" y2="2900" stroke="#00000033" stroke-width="1"></line><line x1="1000" y1="100" x2="1000" y2="2900" stroke="#00000033" stroke-width="1"></line><line x1="1050" y1="100" x2="1050" y2="2900" stroke="#00000033" stroke-width="1"></line><line x1="1100" y1="100" x2="1100" y2="2900" stroke="#00000066" stroke-width="2"></line><line x1="1150" y1="100" x2="1150" y2="2900" stroke="#00000033" stroke-width="1"></line><line x1="1200" y1="100" x2="1200" y2="2900" stroke="#00000033" stroke-width="1"></line><line x1="1250" y1="100" x2="1250" y2="2900" stroke="#00000033" stroke-width="1"></line><line x1="1300" y1="100" x2="1300" y2="2900" stroke="#00000033" stroke-width="1"></line><line x1="1350" y1="100" x2="1350" y2="2900" stroke="#00000066" stroke-width="2"></line><line x1="1400" y1="100" x2="1400" y2="2900" stroke="#00000033" stroke-width="1"></line><line x1="1450" y1="100" x2="1450" y2="2900" stroke="#00000033" stroke-width="1"></line><line x1="1500" y1="100" x2="1500" y2="2900" stroke="#00000033" stroke-width="1"></line><line x1="1550" y1="100" x2="1550" y2="2900" stroke="#00000033" stroke-width="1"></line><line x1="1600" y1="100" x2="1600" y2="2900" stroke="#00000066" stroke-width="2"></line><line x1="1650" y1="100" x2="1650" y2="2900" stroke="#00000033" stroke-width="1"></line><line x1="1700" y1="100" x2="1700" y2="2900" stroke="#00000033" stroke-width="1"></line><line x1="1750" y1="100" x2="1750" y2="2900" stroke="#00000033" stroke-width="1"></line><line x1="1800" y1="100" x2="1800" y2="2900" stroke="#00000033" stroke-width="1"></line><line x1="1850" y1="100" x2="1850" y2="2900" stroke="#00000066" stroke-width="2"></line><line x1="1900" y1="100" x2="1900" y2="2900" stroke="#00000033" stroke-width="1"></line><line x1="1950" y1="100" x2="1950" y2="2900" stroke="#00000033" stroke-width="1"></line><line x1="2000" y1="100" x2="2000" y2="2900" stroke="#00000033" stroke-width="1"></line><line x1="2050" y1="100" x2="2050" y2="2900" stroke="#00000033" stroke-width="1"></line><line x1="2100" y1="100" x2="2100" y2="2900" stroke="#00000066" stroke-width="2"></line><line x1="2150" y1="100" x2="2150" y2="2900" stroke="#00000033" stroke-width="1"></line><line x1="2200" y1="100" x2="2200" y2="2900" stroke="#00000033" stroke-width="1"></line><line x1="2250" y1="100" x2="2250" y2="2900" stroke="#00000033" stroke-width="1"></line><line x1="2300" y1="100" x2="2300" y2="2900" stroke="#00000033" stroke-width="1"></line><line x1="2350" y1="100" x2="2350" y2="2900" stroke="#00000066" stroke-width="2"></line><line x1="2400" y1="100" x2="2400" y2="2900" stroke="#00000033" stroke-width="1"></line><line x1="2450" y1="100" x2="2450" y2="2900" stroke="#00000033" stroke-width="1"></line><line x1="2500" y1="100" x2="2500" y2="2900" stroke="#00000033" stroke-width="1"></line><line x1="2550" y1="100" x2="2550" y2="2900" stroke="#00000033" stroke-width="1"></line><line x1="2600" y1="100" x2="2600" y2="2900" stroke="#00000066" stroke-width="2"></line><line x1="2650" y1="100" x2="2650" y2="2900" stroke="#00000033" stroke-width="1"></line><line x1="2700" y1="100" x2="2700" y2="2900" stroke="#00000033" stroke-width="1"></line><line x1="2750" y1="100" x2="2750" y2="2900" stroke="#00000033" stroke-width="1"></line><line x1="2800" y1="100" x2="2800" y2="2900" stroke="#00000033" stroke-width="1"></line><line x1="2850" y1="100" x2="2850" y2="2900" stroke="#00000066" stroke-width="2"></line><line x1="2900" y1="100" x2="2900" y2="2900" stroke="#00000033" stroke-width="1"></line><line x1="2950" y1="100" x2="2950" y2="2900" stroke="#00000033" stroke-width="1"></line><line x1="3000" y1="100" x2="3000" y2="2900" stroke="#00000033" stroke-width="1"></line><line x1="3050" y1="100" x2="3050" y2="2900" stroke="#00000033" stroke-width="1"></line><line x1="3100" y1="100" x2="3100" y2="2900" stroke="#00000066" stroke-width="2"></line><line x1="3150" y1="100" x2="3150" y2="2900" stroke="#00000033" stroke-width="1"></line><line x1="3200" y1="100" x2="3200" y2="2900" stroke="#00000033" stroke-width="1"></line><line x1="3250" y1="100" x2="3250" y2="2900" stroke="#00000033" stroke-width="1"></line><line x1="3300" y1="100" x2="3300" y2="2900" stroke="#00000033" stroke-width="1"></line><line x1="3350" y1="100" x2="3350" y2="2900" stroke="#00000066" stroke-width="2"></line><line x1="3400" y1="100" x2="3400" y2="2900" stroke="#00000033" stroke-width="1"></line><line x1="3450" y1="100" x2="3450" y2="2900" stroke="#00000033" stroke-width="1"></line><line x1="3500" y1="100" x2="3500" y2="2900" stroke="#00000033" stroke-width="1"></line><line x1="3550" y1="100" x2="3550" y2="2900" stroke="#00000033" stroke-width="1"></line><line x1="3600" y1="100" x2="3600" y2="2900" stroke="#00000066" stroke-width="2"></line><line x1="3650" y1="100" x2="3650" y2="2900" stroke="#00000033" stroke-width="1"></line><line x1="3700" y1="100" x2="3700" y2="2900" stroke="#00000033" stroke-width="1"></line><line x1="3750" y1="100" x2="3750" y2="2900" stroke="#00000033" stroke-width="1"></line><line x1="3800" y1="100" x2="3800" y2="2900" stroke="#00000033" stroke-width="1"></line><line x1="3850" y1="100" x2="3850" y2="2900" stroke="#00000066" stroke-width="2"></line><line x1="3900" y1="100" x2="3900" y2="2900" stroke="#00000033" stroke-width="1"></line><line x1="100" y1="100" x2="3900" y2="100" stroke="#00000066" stroke-width="2"></line><line x1="100" y1="150" x2="3900" y2="150" stroke="#00000033" stroke-width="1"></line><line x1="100" y1="200" x2="3900" y2="200" stroke="#00000033" stroke-width="1"></line><line x1="100" y1="250" x2="3900" y2="250" stroke="#00000033" stroke-width="1"></line><line x1="100" y1="300" x2="3900" y2="300" stroke="#00000033" stroke-width="1"></line><line x1="100" y1="350" x2="3900" y2="350" stroke="#00000066" stroke-width="2"></line><line x1="100" y1="400" x2="3900" y2="400" stroke="#00000033" stroke-width="1"></line><line x1="100" y1="450" x2="3900" y2="450" stroke="#00000033" stroke-width="1"></line><line x1="100" y1="500" x2="3900" y2="500" stroke="#00000033" stroke-width="1"></line><line x1="100" y1="550" x2="3900" y2="550" stroke="#00000033" stroke-width="1"></line><line x1="100" y1="600" x2="3900" y2="600" stroke="#00000066" stroke-width="2"></line><line x1="100" y1="650" x2="3900" y2="650" stroke="#00000033" stroke-width="1"></line><line x1="100" y1="700" x2="3900" y2="700" stroke="#00000033" stroke-width="1"></line><line x1="100" y1="750" x2="3900" y2="750" stroke="#00000033" stroke-width="1"></line><line x1="100" y1="800" x2="3900" y2="800" stroke="#00000033" stroke-width="1"></line><line x1="100" y1="850" x2="3900" y2="850" stroke="#00000066" stroke-width="2"></line><line x1="100" y1="900" x2="3900" y2="900" stroke="#00000033" stroke-width="1"></line><line x1="100" y1="950" x2="3900" y2="950" stroke="#00000033" stroke-width="1"></line><line x1="100" y1="1000" x2="3900" y2="1000" stroke="#00000033" stroke-width="1"></line><line x1="100" y1="1050" x2="3900" y2="1050" stroke="#00000033" stroke-width="1"></line><line x1="100" y1="1100" x2="3900" y2="1100" stroke="#00000066" stroke-width="2"></line><line x1="100" y1="1150" x2="3900" y2="1150" stroke="#00000033" stroke-width="1"></line><line x1="100" y1="1200" x2="3900" y2="1200" stroke="#00000033" stroke-width="1"></line><line x1="100" y1="1250" x2="3900" y2="1250" stroke="#00000033" stroke-width="1"></line><line x1="100" y1="1300" x2="3900" y2="1300" stroke="#00000033" stroke-width="1"></line><line x1="100" y1="1350" x2="3900" y2="1350" stroke="#00000066" stroke-width="2"></line><line x1="100" y1="1400" x2="3900" y2="1400" stroke="#00000033" stroke-width="1"></line><line x1="100" y1="1450" x2="3900" y2="1450" stroke="#00000033" stroke-width="1"></line><line x1="100" y1="1500" x2="3900" y2="1500" stroke="#00000033" stroke-width="1"></line><line x1="100" y1="1550" x2="3900" y2="1550" stroke="#00000033" stroke-width="1"></line><line x1="100" y1="1600" x2="3900" y2="1600" stroke="#00000066" stroke-width="2"></line><line x1="100" y1="1650" x2="3900" y2="1650" stroke="#00000033" stroke-width="1"></line><line x1="100" y1="1700" x2="3900" y2="1700" stroke="#00000033" stroke-width="1"></line><line x1="100" y1="1750" x2="3900" y2="1750" stroke="#00000033" stroke-width="1"></line><line x1="100" y1="1800" x2="3900" y2="1800" stroke="#00000033" stroke-width="1"></line><line x1="100" y1="1850" x2="3900" y2="1850" stroke="#00000066" stroke-width="2"></line><line x1="100" y1="1900" x2="3900" y2="1900" stroke="#00000033" stroke-width="1"></line><line x1="100" y1="1950" x2="3900" y2="1950" stroke="#00000033" stroke-width="1"></line><line x1="100" y1="2000" x2="3900" y2="2000" stroke="#00000033" stroke-width="1"></line><line x1="100" y1="2050" x2="3900" y2="2050" stroke="#00000033" stroke-width="1"></line><line x1="100" y1="2100" x2="3900" y2="2100" stroke="#00000066" stroke-width="2"></line><line x1="100" y1="2150" x2="3900" y2="2150" stroke="#00000033" stroke-width="1"></line><line x1="100" y1="2200" x2="3900" y2="2200" stroke="#00000033" stroke-width="1"></line><line x1="100" y1="2250" x2="3900" y2="2250" stroke="#00000033" stroke-width="1"></line><line x1="100" y1="2300" x2="3900" y2="2300" stroke="#00000033" stroke-width="1"></line><line x1="100" y1="2350" x2="3900" y2="2350" stroke="#00000066" stroke-width="2"></line><line x1="100" y1="2400" x2="3900" y2="2400" stroke="#00000033" stroke-width="1"></line><line x1="100" y1="2450" x2="3900" y2="2450" stroke="#00000033" stroke-width="1"></line><line x1="100" y1="2500" x2="3900" y2="2500" stroke="#00000033" stroke-width="1"></line><line x1="100" y1="2550" x2="3900" y2="2550" stroke="#00000033" stroke-width="1"></line><line x1="100" y1="2600" x2="3900" y2="2600" stroke="#00000066" stroke-width="2"></line><line x1="100" y1="2650" x2="3900" y2="2650" stroke="#00000033" stroke-width="1"></line><line x1="100" y1="2700" x2="3900" y2="2700" stroke="#00000033" stroke-width="1"></line><line x1="100" y1="2750" x2="3900" y2="2750" stroke="#00000033" stroke-width="1"></line><line x1="100" y1="2800" x2="3900" y2="2800" stroke="#00000033" stroke-width="1"></line><line x1="100" y1="2850" x2="3900" y2="2850" stroke="#00000066" stroke-width="2"></line><line x1="100" y1="2900" x2="3900" y2="2900" stroke="#00000033" stroke-width="1"></line></g><path d="M 2107.5723876953125 295.1676330566406 Q 2053.7861938476562 397.5838165283203 2000 500" fill="none" class="edge" data-edge-id="edge-1" data-from="internet" data-to="edge-firewall" style="stroke: rgb(239, 68, 68); stroke-width: 6;"></path><path d="M 2107.5723876953125 295.1676330566406 Q 2053.7861938476562 397.5838165283203 2000 500" fill="none" data-edge-id="edge-1" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2000 500 Q 1850 700 1700 900" fill="none" class="edge" data-edge-id="edge-2" data-from="edge-firewall" data-to="core-switch-1" style="stroke: rgb(245, 158, 11); stroke-width: 5;"></path><path d="M 2000 500 Q 1850 700 1700 900" fill="none" data-edge-id="edge-2" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2000 500 Q 2150 700 2300 900" fill="none" class="edge" data-edge-id="edge-3" data-from="edge-firewall" data-to="core-switch-2" style="stroke: rgb(245, 158, 11); stroke-width: 5;"></path><path d="M 2000 500 Q 2150 700 2300 900" fill="none" data-edge-id="edge-3" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 1700 900 Q 2000 900 2300 900" fill="none" class="edge" data-edge-id="edge-4" data-from="core-switch-1" data-to="core-switch-2" style="stroke: rgb(16, 185, 129); stroke-width: 6;"></path><path d="M 1700 900 Q 2000 900 2300 900" fill="none" data-edge-id="edge-4" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 1700 900 Q 2250 900 2800 900" fill="none" class="edge" data-edge-id="edge-5" data-from="core-switch-1" data-to="dmz-firewall" style="stroke: rgb(239, 68, 68); stroke-width: 4;"></path><path d="M 1700 900 Q 2250 900 2800 900" fill="none" data-edge-id="edge-5" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2800 900 Q 2800 1075 2800 1250" fill="none" class="edge" data-edge-id="edge-6" data-from="dmz-firewall" data-to="web-server" style="stroke: rgb(239, 68, 68); stroke-width: 4;"></path><path d="M 2800 900 Q 2800 1075 2800 1250" fill="none" data-edge-id="edge-6" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2800 900 Q 2800 1225 2800 1550" fill="none" class="edge" data-edge-id="edge-7" data-from="dmz-firewall" data-to="mail-server" style="stroke: rgb(239, 68, 68); stroke-width: 4;"></path><path d="M 2800 900 Q 2800 1225 2800 1550" fill="none" data-edge-id="edge-7" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 1700 900 Q 1450 1150 1200 1400" fill="none" class="edge" data-edge-id="edge-8" data-from="core-switch-1" data-to="dist-switch-1" style="stroke: rgb(16, 185, 129); stroke-width: 5;"></path><path d="M 1700 900 Q 1450 1150 1200 1400" fill="none" data-edge-id="edge-8" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2300 900 Q 1750 1150 1200 1400" fill="none" class="edge" data-edge-id="edge-9" data-from="core-switch-2" data-to="dist-switch-1" style="stroke: rgb(16, 185, 129); stroke-width: 5;"></path><path d="M 2300 900 Q 1750 1150 1200 1400" fill="none" data-edge-id="edge-9" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 1700 900 Q 2100 1150 2500 1400" fill="none" class="edge" data-edge-id="edge-10" data-from="core-switch-1" data-to="dist-switch-2" style="stroke: rgb(16, 185, 129); stroke-width: 5;"></path><path d="M 1700 900 Q 2100 1150 2500 1400" fill="none" data-edge-id="edge-10" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2300 900 Q 2400 1150 2500 1400" fill="none" class="edge" data-edge-id="edge-11" data-from="core-switch-2" data-to="dist-switch-2" style="stroke: rgb(16, 185, 129); stroke-width: 5;"></path><path d="M 2300 900 Q 2400 1150 2500 1400" fill="none" data-edge-id="edge-11" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 1200 1400 Q 1000 1650 800 1900" fill="none" class="edge" data-edge-id="edge-12" data-from="dist-switch-1" data-to="access-switch-1" style="stroke: rgb(59, 130, 246); stroke-width: 4;"></path><path d="M 1200 1400 Q 1000 1650 800 1900" fill="none" data-edge-id="edge-12" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 1200 1400 Q 1200 1650 1200 1900" fill="none" class="edge" data-edge-id="edge-13" data-from="dist-switch-1" data-to="access-switch-2" style="stroke: rgb(59, 130, 246); stroke-width: 4;"></path><path d="M 1200 1400 Q 1200 1650 1200 1900" fill="none" data-edge-id="edge-13" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2500 1400 Q 2500 1650 2500 1900" fill="none" class="edge" data-edge-id="edge-14" data-from="dist-switch-2" data-to="access-switch-3" style="stroke: rgb(59, 130, 246); stroke-width: 4;"></path><path d="M 2500 1400 Q 2500 1650 2500 1900" fill="none" data-edge-id="edge-14" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 1700 900 Q 1400 900 1100 900" fill="none" class="edge" data-edge-id="edge-15" data-from="core-switch-1" data-to="domain-controller" style="stroke: rgb(139, 92, 246); stroke-width: 4;"></path><path d="M 1700 900 Q 1400 900 1100 900" fill="none" data-edge-id="edge-15" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 1700 900 Q 1150 900 600 900" fill="none" class="edge" data-edge-id="edge-16" data-from="core-switch-1" data-to="file-server" style="stroke: rgb(139, 92, 246); stroke-width: 4;"></path><path d="M 1700 900 Q 1150 900 600 900" fill="none" data-edge-id="edge-16" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 1700 900 Q 1150 1100 600 1300" fill="none" class="edge" data-edge-id="edge-17" data-from="core-switch-1" data-to="db-server" style="stroke: rgb(139, 92, 246); stroke-width: 4;"></path><path d="M 1700 900 Q 1150 1100 600 1300" fill="none" data-edge-id="edge-17" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 1700 900 Q 1400 1100 1100 1300" fill="none" class="edge" data-edge-id="edge-18" data-from="core-switch-1" data-to="backup-server" style="stroke: rgb(139, 92, 246); stroke-width: 4;"></path><path d="M 1700 900 Q 1400 1100 1100 1300" fill="none" data-edge-id="edge-18" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 1700 900 Q 2450 1150 3200 1400" fill="none" class="edge" data-edge-id="edge-19" data-from="core-switch-1" data-to="wifi-controller" style="stroke: rgb(6, 182, 212); stroke-width: 4;"></path><path d="M 1700 900 Q 2450 1150 3200 1400" fill="none" data-edge-id="edge-19" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2000 500 Q 1721.3592529296875 496.2307434082031 1442.718505859375 492.46148681640625" fill="none" class="edge" data-edge-id="edge-20" data-from="edge-firewall" data-to="vpn-gateway" style="stroke: rgb(245, 158, 11); stroke-width: 4;"></path><path d="M 2000 500 Q 1721.3592529296875 496.2307434082031 1442.718505859375 492.46148681640625" fill="none" data-edge-id="edge-20" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><polyline class="edge" data-edge-id="custom-1764789640610" fill="none" marker-end="url(#arrow-forward)" points="1726.6842041015625,257.1484310775995 1832.2239990234375,151.60864950716496 1905.0966796875,232.01991011202335" style="stroke: rgb(249, 115, 22); stroke-width: 4; stroke-dasharray: none;"></polyline><polyline points="1726.6842041015625,257.1484310775995 1832.2239990234375,151.60864950716496 1905.0966796875,232.01991011202335" data-edge-id="custom-1764789640610" style="fill: none; stroke: transparent; stroke-width: 20; cursor: pointer;"></polyline><polyline class="edge" data-edge-id="custom-1764789700766" fill="none" marker-start="url(#arrow-backward)" marker-end="url(#arrow-forward)" points="3131.318603515625,829.9960327148438 2885.05908203125,694.3020324707031" style="stroke: rgb(249, 115, 22); stroke-width: 4; stroke-dasharray: none;"></polyline><polyline points="3131.318603515625,829.9960327148438 2885.05908203125,694.3020324707031" data-edge-id="custom-1764789700766" style="fill: none; stroke: transparent; stroke-width: 20; cursor: pointer;"></polyline><g class="node-group" data-node-id="internet" transform="translate(2107.5723876953125,295.1676330566406)" style="cursor: grab;"><circle r="220.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><path d="
             M -117.60000000000001 29.400000000000002
             Q -161.70000000000002 29.400000000000002 -161.70000000000002 -14.700000000000001
             Q -161.70000000000002 -73.5 -102.89999999999999 -73.5
             Q -102.89999999999999 -132.3 -29.400000000000002 -132.3
             Q 14.700000000000001 -161.70000000000002 73.5 -117.60000000000001
             Q 147 -117.60000000000001 161.70000000000002 -44.1
             Q 191.1 -14.700000000000001 161.70000000000002 29.400000000000002
             Q 161.70000000000002 73.5 102.89999999999999 73.5
             L -73.5 73.5
             Q -132.3 73.5 -132.3 29.400000000000002
             Z
            " class="node-circle" style="fill: rgb(0, 0, 0); stroke: rgb(235, 0, 0);"></path><text class="node-label" x="0" y="-41.160000000000004" style="font-size: 43px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Internet</text><text class="node-sub" x="0" y="58.800000000000004" style="font-size: 28px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">google.com</text><circle class="ping-indicator online" r="8.82" cx="-129.40574298095703" cy="-117.334"></circle></g><g class="node-group" data-node-id="edge-firewall" transform="translate(2000,500)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-55" y="-44" width="110" height="88" rx="4"></rect><line x1="-46.75" y1="-27.5" x2="46.75" y2="-27.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="-2.75" x2="46.75" y2="-2.75" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="22" x2="46.75" y2="22" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="-44" x2="-27.5" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="-44" x2="11" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="-19.25" x2="-8.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="-19.25" x2="30.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="5.5" x2="-27.5" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="5.5" x2="11" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="30.25" x2="-8.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="30.25" x2="30.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Edge Firewall</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">192.168.1.1</text></g><g class="node-group" data-node-id="core-switch-1" transform="translate(1700,900)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-77" y="-22" width="154" height="44" rx="4"></rect><rect x="-66" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-48.4" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-30.799999999999997" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-13.199999999999996" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="4.400000000000006" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="22" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="39.60000000000001" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="57.2" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Core Switch 1</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">10.0.0.1</text></g><g class="node-group" data-node-id="core-switch-2" transform="translate(2300,900)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-77" y="-22" width="154" height="44" rx="4"></rect><rect x="-66" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-48.4" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-30.799999999999997" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-13.199999999999996" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="4.400000000000006" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="22" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="39.60000000000001" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="57.2" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Core Switch 2</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">10.0.0.2</text></g><g class="node-group" data-node-id="dmz-firewall" transform="translate(2800,900)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-55" y="-44" width="110" height="88" rx="4"></rect><line x1="-46.75" y1="-27.5" x2="46.75" y2="-27.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="-2.75" x2="46.75" y2="-2.75" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="22" x2="46.75" y2="22" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="-44" x2="-27.5" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="-44" x2="11" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="-19.25" x2="-8.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="-19.25" x2="30.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="5.5" x2="-27.5" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="5.5" x2="11" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="30.25" x2="-8.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="30.25" x2="30.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">DMZ Firewall</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">10.10.0.1</text></g><g class="node-group" data-node-id="web-server" transform="translate(2800,1250)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-66" y="-33" width="132" height="66" rx="4"></rect><line x1="-49.5" y1="-16.5" x2="-49.5" y2="16.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="-22" y1="-16.5" x2="-22" y2="16.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="5.5" y1="-16.5" x2="5.5" y2="16.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><circle cx="49.5" cy="0" r="5.5" style="fill: rgb(74, 222, 128);"></circle></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Web Server</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">10.10.1.10</text></g><g class="node-group" data-node-id="mail-server" transform="translate(2800,1550)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-66" y="-33" width="132" height="66" rx="4"></rect><line x1="-49.5" y1="-16.5" x2="-49.5" y2="16.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="-22" y1="-16.5" x2="-22" y2="16.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="5.5" y1="-16.5" x2="5.5" y2="16.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><circle cx="49.5" cy="0" r="5.5" style="fill: rgb(74, 222, 128);"></circle></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Mail Server</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">10.10.1.20</text></g><g class="node-group" data-node-id="dist-switch-1" transform="translate(1200,1400)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-77" y="-22" width="154" height="44" rx="4"></rect><rect x="-66" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-48.4" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-30.799999999999997" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-13.199999999999996" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="4.400000000000006" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="22" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="39.60000000000001" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="57.2" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Distribution SW 1</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">10.1.0.1</text></g><g class="node-group" data-node-id="dist-switch-2" transform="translate(2500,1400)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-77" y="-22" width="154" height="44" rx="4"></rect><rect x="-66" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-48.4" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-30.799999999999997" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-13.199999999999996" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="4.400000000000006" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="22" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="39.60000000000001" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="57.2" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Distribution SW 2</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">10.2.0.1</text></g><g class="node-group" data-node-id="access-switch-1" transform="translate(800,1900)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-77" y="-22" width="154" height="44" rx="4"></rect><rect x="-66" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-48.4" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-30.799999999999997" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-13.199999999999996" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="4.400000000000006" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="22" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="39.60000000000001" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="57.2" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Access SW 1-1</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">10.1.1.1</text></g><g class="node-group" data-node-id="access-switch-2" transform="translate(1200,1900)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-77" y="-22" width="154" height="44" rx="4"></rect><rect x="-66" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-48.4" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-30.799999999999997" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-13.199999999999996" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="4.400000000000006" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="22" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="39.60000000000001" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="57.2" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Access SW 1-2</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">10.1.2.1</text></g><g class="node-group" data-node-id="access-switch-3" transform="translate(2500,1900)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-77" y="-22" width="154" height="44" rx="4"></rect><rect x="-66" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-48.4" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-30.799999999999997" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-13.199999999999996" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="4.400000000000006" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="22" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="39.60000000000001" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="57.2" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Access SW 2-1</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">10.2.1.1</text></g><g class="node-group" data-node-id="domain-controller" transform="translate(1100,900)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-66" y="-33" width="132" height="66" rx="4"></rect><line x1="-49.5" y1="-16.5" x2="-49.5" y2="16.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="-22" y1="-16.5" x2="-22" y2="16.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="5.5" y1="-16.5" x2="5.5" y2="16.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><circle cx="49.5" cy="0" r="5.5" style="fill: rgb(74, 222, 128);"></circle></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Domain Controller</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">10.1.10.10</text></g><g class="node-group" data-node-id="file-server" transform="translate(600,900)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-66" y="-33" width="132" height="66" rx="4"></rect><line x1="-49.5" y1="-16.5" x2="-49.5" y2="16.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="-22" y1="-16.5" x2="-22" y2="16.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="5.5" y1="-16.5" x2="5.5" y2="16.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><circle cx="49.5" cy="0" r="5.5" style="fill: rgb(74, 222, 128);"></circle></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">File Server</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">10.1.10.20</text></g><g class="node-group" data-node-id="db-server" transform="translate(600,1300)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-38.5" y="-33" width="77" height="77"></rect><ellipse cx="0" cy="-33" rx="38.5" ry="13.75"></ellipse><ellipse cx="0" cy="44" rx="38.5" ry="13.75"></ellipse><ellipse cx="0" cy="-8.25" rx="38.5" ry="11" style="fill: none; stroke: rgb(71, 85, 105); stroke-width: 2;"></ellipse><ellipse cx="0" cy="19.25" rx="38.5" ry="11" style="fill: none; stroke: rgb(71, 85, 105); stroke-width: 2;"></ellipse></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Database Server</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">10.1.10.30</text></g><g class="node-group" data-node-id="backup-server" transform="translate(1100,1300)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-66" y="-33" width="132" height="66" rx="4"></rect><line x1="-49.5" y1="-16.5" x2="-49.5" y2="16.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="-22" y1="-16.5" x2="-22" y2="16.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="5.5" y1="-16.5" x2="5.5" y2="16.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><circle cx="49.5" cy="0" r="5.5" style="fill: rgb(74, 222, 128);"></circle></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Backup Server</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">10.1.10.40</text></g><g class="node-group" data-node-id="wifi-controller" transform="translate(3200,1400)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-60.50000000000001" y="-16.5" width="121.00000000000001" height="44" rx="6"></rect><rect x="-35.75" y="-49.5" width="5.5" height="33" rx="2"></rect><circle cx="-33" cy="-52.25" r="4.4"></circle><rect x="-2.75" y="-49.5" width="5.5" height="33" rx="2"></rect><circle cx="0" cy="-52.25" r="4.4"></circle><rect x="30.25" y="-49.5" width="5.5" height="33" rx="2"></rect><circle cx="33" cy="-52.25" r="4.4"></circle><circle cx="-38.5" cy="5.5" r="3.3" style="fill: rgb(74, 222, 128);"></circle><circle cx="-19.25" cy="5.5" r="3.3" style="fill: rgb(74, 222, 128);"></circle><circle cx="0" cy="5.5" r="3.3" style="fill: rgb(250, 204, 21);"></circle><circle cx="19.249999999999993" cy="5.5" r="3.3" style="fill: rgb(250, 204, 21);"></circle></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">WiFi Controller</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">10.0.0.100</text></g><g class="node-group" data-node-id="vpn-gateway" transform="translate(1442.718505859375,492.46148681640625)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-60.50000000000001" y="-16.5" width="121.00000000000001" height="44" rx="6"></rect><rect x="-35.75" y="-49.5" width="5.5" height="33" rx="2"></rect><circle cx="-33" cy="-52.25" r="4.4"></circle><rect x="-2.75" y="-49.5" width="5.5" height="33" rx="2"></rect><circle cx="0" cy="-52.25" r="4.4"></circle><rect x="30.25" y="-49.5" width="5.5" height="33" rx="2"></rect><circle cx="33" cy="-52.25" r="4.4"></circle><circle cx="-38.5" cy="5.5" r="3.3" style="fill: rgb(74, 222, 128);"></circle><circle cx="-19.25" cy="5.5" r="3.3" style="fill: rgb(74, 222, 128);"></circle><circle cx="0" cy="5.5" r="3.3" style="fill: rgb(250, 204, 21);"></circle><circle cx="19.249999999999993" cy="5.5" r="3.3" style="fill: rgb(250, 204, 21);"></circle></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">VPN Gateway</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">10.0.0.50</text></g><g class="node-group" data-node-id="im-a-rack" transform="translate(2769.0062905146215,660.7209606194001)" style="cursor: grab;"><circle r="300" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" id="mdi-airplane" viewBox="0 0 24 24" width="240" height="240" x="-120" y="-120" style="fill: rgb(219, 0, 0);"><path d="M20.56 3.91C21.15 4.5 21.15 5.45 20.56 6.03L16.67 9.92L18.79 19.11L17.38 20.53L13.5 13.1L9.6 17L9.96 19.47L8.89 20.53L7.13 17.35L3.94 15.58L5 14.5L7.5 14.87L11.37 11L3.94 7.09L5.36 5.68L14.55 7.8L18.44 3.91C19 3.33 20 3.33 20.56 3.91Z"></path></svg></g><text class="node-label" x="0" y="-56.00000000000001" style="font-size: 52px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">IM A RACK</text><text class="node-sub" x="0" y="80" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;"></text></g><g class="text-group" data-text-id="text-1764789614780"><text class="text-element" x="1526.2745361328125" y="312.6503448486328" dominant-baseline="middle" style="fill: rgb(10, 10, 10); font-size: 65px; font-weight: normal; font-style: normal; text-anchor: start; text-decoration: none; opacity: 1; cursor: move; user-select: none;">Google is live!</text><g class="text-delete-btn" style="cursor: pointer; display: none;"><circle cx="1546.2745361328125" cy="247.6503448486328" r="12" style="fill: rgb(245, 101, 101); stroke: white; stroke-width: 2;"></circle><text x="1546.2745361328125" y="247.6503448486328" text-anchor="middle" dominant-baseline="middle" style="fill: white; font-size: 16px; font-weight: bold; pointer-events: none;">√ó</text></g></g><g class="text-group" data-text-id="text-1764789667151"><text class="text-element" x="2971.8779296875" y="914.9339141845703" dominant-baseline="middle" style="fill: rgb(0, 0, 0); font-size: 43px; font-weight: normal; font-style: normal; text-anchor: start; text-decoration: none; opacity: 1; cursor: move; user-select: none;"><tspan x="2971.8779296875" dy="0">Double click me on desktop</tspan><tspan x="2971.8779296875" dy="51.6">or long press on mobile</tspan><tspan x="2971.8779296875" dy="51.6">to open the rack view</tspan></text><g class="text-delete-btn" style="cursor: pointer; display: none;"><circle cx="2991.8779296875" cy="871.9339141845703" r="12" style="fill: rgb(245, 101, 101); stroke: white; stroke-width: 2;"></circle><text x="2991.8779296875" y="871.9339141845703" text-anchor="middle" dominant-baseline="middle" style="fill: white; font-size: 16px; font-weight: bold; pointer-events: none;">√ó</text></g></g></svg>
        </div>
        <div class="minimap-zoom-wrapper" id="minimap-zoom-wrapper" style="display: block;">
          <button type="button" class="minimap-close-btn" id="minimap-close-btn" title="Hide map &amp; zoom">‚úï</button>
          <div class="minimap-container" id="minimap-container">
            <svg id="minimap" viewBox="0 0 4000 3000">
              <line x1="2107.5723876953125" y1="295.1676330566406" x2="2000" y2="500" class="minimap-edge"></line><line x1="2000" y1="500" x2="1700" y2="900" class="minimap-edge"></line><line x1="2000" y1="500" x2="2300" y2="900" class="minimap-edge"></line><line x1="1700" y1="900" x2="2300" y2="900" class="minimap-edge"></line><line x1="1700" y1="900" x2="2800" y2="900" class="minimap-edge"></line><line x1="2800" y1="900" x2="2800" y2="1250" class="minimap-edge"></line><line x1="2800" y1="900" x2="2800" y2="1550" class="minimap-edge"></line><line x1="1700" y1="900" x2="1200" y2="1400" class="minimap-edge"></line><line x1="2300" y1="900" x2="1200" y2="1400" class="minimap-edge"></line><line x1="1700" y1="900" x2="2500" y2="1400" class="minimap-edge"></line><line x1="2300" y1="900" x2="2500" y2="1400" class="minimap-edge"></line><line x1="1200" y1="1400" x2="800" y2="1900" class="minimap-edge"></line><line x1="1200" y1="1400" x2="1200" y2="1900" class="minimap-edge"></line><line x1="2500" y1="1400" x2="2500" y2="1900" class="minimap-edge"></line><line x1="1700" y1="900" x2="1100" y2="900" class="minimap-edge"></line><line x1="1700" y1="900" x2="600" y2="900" class="minimap-edge"></line><line x1="1700" y1="900" x2="600" y2="1300" class="minimap-edge"></line><line x1="1700" y1="900" x2="1100" y2="1300" class="minimap-edge"></line><line x1="1700" y1="900" x2="3200" y2="1400" class="minimap-edge"></line><line x1="2000" y1="500" x2="1442.718505859375" y2="492.46148681640625" class="minimap-edge"></line><circle cx="2107.5723876953125" cy="295.1676330566406" r="40" class="minimap-node"></circle><circle cx="2000" cy="500" r="40" class="minimap-node"></circle><circle cx="1700" cy="900" r="40" class="minimap-node"></circle><circle cx="2300" cy="900" r="40" class="minimap-node"></circle><circle cx="2800" cy="900" r="40" class="minimap-node"></circle><circle cx="2800" cy="1250" r="40" class="minimap-node"></circle><circle cx="2800" cy="1550" r="40" class="minimap-node"></circle><circle cx="1200" cy="1400" r="40" class="minimap-node"></circle><circle cx="2500" cy="1400" r="40" class="minimap-node"></circle><circle cx="800" cy="1900" r="40" class="minimap-node"></circle><circle cx="1200" cy="1900" r="40" class="minimap-node"></circle><circle cx="2500" cy="1900" r="40" class="minimap-node"></circle><circle cx="1100" cy="900" r="40" class="minimap-node"></circle><circle cx="600" cy="900" r="40" class="minimap-node"></circle><circle cx="600" cy="1300" r="40" class="minimap-node"></circle><circle cx="1100" cy="1300" r="40" class="minimap-node"></circle><circle cx="3200" cy="1400" r="40" class="minimap-node"></circle><circle cx="1442.718505859375" cy="492.46148681640625" r="40" class="minimap-node"></circle><circle cx="2769.0062905146215" cy="660.7209606194001" r="40" class="minimap-node"></circle><rect class="minimap-viewport" id="minimap-viewport" x="384.66666666666674" y="27" width="3230.6666666666665" height="2423"></rect>
            </svg>
          </div>
          <div class="zoom-toolbar" id="zoom-toolbar">
            <button id="zoom-in-btn" title="Zoom in">+</button>
            <div class="zoom-level" id="zoom-level">124%</div>
            <button id="zoom-out-btn" title="Zoom out">-</button>
            <div class="divider"></div>
            <button id="zoom-fit-btn" title="Fit to view">[ ]</button>
            <button id="zoom-reset-btn" title="Reset view">R</button>
          </div>
        </div>
        <button type="button" id="edge-legend-mini" class="legend-mini-btn" style="bottom: 10px; display: none;">Line Legend</button>
        <button type="button" id="minimap-mini" class="legend-mini-btn" style="right: 10px; left: auto; bottom: 10px; display: none;">Map</button>
        <button type="button" id="draw-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: 10px; right: auto; display: none;">Draw</button>
        <button type="button" id="topology-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: auto; right: 40px; display: none;">Add Line</button>
      <button type="button" id="edge-legend-mini" class="legend-mini-btn" style="bottom: 10px; display: none;">Legend</button><button type="button" id="minimap-mini" class="legend-mini-btn" style="right: 10px; left: auto; bottom: 10px; display: none;">Map</button><button type="button" id="draw-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: 10px; right: auto; display: none;">Draw</button><button type="button" id="topology-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: auto; right: 40px; display: none;">Add Line</button><button type="button" id="edge-legend-mini" class="legend-mini-btn" style="bottom: 10px; display: none;">Legend</button><button type="button" id="topology-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: auto; right: 40px; display: none;">Add Line</button><button type="button" id="minimap-mini" class="legend-mini-btn" style="right: 10px; left: auto; bottom: 10px; display: none;">Map</button><button type="button" id="draw-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: 10px; right: auto; display: none;">Draw</button></section>
      <aside class="details-panel" id="details-panel">
        <div class="sidebar-resizer" id="sidebar-resizer">
          <svg class="resizer-icon" width="6" height="40" viewBox="0 0 6 40" xmlns="http://www.w3.org/2000/svg">
            <circle cx="3" cy="14" r="2"></circle>
            <circle cx="3" cy="20" r="2"></circle>
            <circle cx="3" cy="26" r="2"></circle>
          </svg>
        </div>
        <div class="mobile-footer-resizer" id="mobile-footer-resizer">
          <svg class="resizer-icon" width="40" height="6" viewBox="0 0 40 6" xmlns="http://www.w3.org/2000/svg">
            <circle cx="14" cy="3" r="2"></circle>
            <circle cx="20" cy="3" r="2"></circle>
            <circle cx="26" cy="3" r="2"></circle>
          </svg>
        </div>
        <div id="node-panel" style="display: block;">
          <div class="details-name editable-text" id="node-name">OPNSENSE</div>
          <div class="details-ip editable-text" id="node-ip">192.168.100.1</div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">MAC:</span>
            <span class="editable-text" id="node-mac" style="flex: 1; cursor: pointer; color: var(--text-main);">--</span>
          </div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">Rack Unit:</span>
            <span class="editable-text" id="node-rack" style="flex: 1; cursor: pointer; color: var(--text-main);">--</span>
          </div>
          <div class="details-info-row" id="uheight-row" style="display: none;">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">U Height:</span>
            <span class="editable-text" id="node-uheight" style="flex: 1; cursor: pointer; color: var(--text-main);">1U</span>
          </div>
          <div class="details-info-row" id="assigned-rack-row" style="display: flex;">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">Assigned Rack:</span>
            <select id="node-assigned-rack" style="flex: 1; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;"><option value="">None</option><option value="im-a-rack">IM A RACK</option></select>
          </div>
          <div class="details-info-row" id="rack-capacity-row" style="display: none;">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">Rack Capacity:</span>
            <select id="node-rack-capacity" style="flex: 1; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;">
              <option value="42">42U</option>
              <option value="48">48U</option>
              <option value="24">24U</option>
              <option value="12">12U</option>
              <option value="6">6U</option>
            </select>
          </div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">Layer:</span>
            <select id="node-layer" style="flex: 1; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;">
              <option value="physical">Physical</option>
              <option value="logical">Logical</option>
              <option value="security">Security</option>
              <option value="application">Application</option>
            </select>
          </div>
          <div class="details-role" id="node-role">WAN</div>
          <div class="badge-row" id="node-tags"><span class="badge" style="cursor: pointer; position: relative;"><span>1Gbps Fiber</span><span style="opacity: 0.6; margin-left: 4px; font-size: 10px;"> ‚úï</span></span><span class="badge" style="cursor: pointer; position: relative;"><span>Bridge Mode</span><span style="opacity: 0.6; margin-left: 4px; font-size: 10px;"> ‚úï</span></span><span class="badge" style="cursor: pointer; opacity: 0.6; border-style: dashed;">+ Add</span></div>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-tag-input" placeholder="Add tag..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-tag-btn" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button class="pick-icon-btn" id="pick-tag-icon-btn">Add Icon Tag</button>
          <div class="section-label">Size</div>
          <div class="size-controls">
            <label>Size:</label>
            <input type="range" id="size-slider" min="20" max="200" value="55">
            <span id="size-value">127</span>
            <button id="reset-size">Reset</button>
          </div>
          <details class="style-section" open="">
            <summary>Styling</summary>
            <div class="style-content">
              <div class="style-row">
                <label>Screen:</label>
                <select id="style-scope">
                  <option value="all">All</option>
                  <option value="desktop">Desktop</option>
                  <option value="tablet">Tablet</option>
                  <option value="mobile">Mobile</option>
                  <option value="fold">Fold</option>
                </select>
              </div>
              <div class="style-row">
                <label>Shape:</label>
                <select id="shape-select">
                  <optgroup label="Basic Shapes">
                    <option value="circle">Circle</option>
                    <option value="square">Square</option>
                    <option value="rectangle">Rectangle</option>
                    <option value="triangle">Triangle</option>
                    <option value="hexagon">Hexagon</option>
                    <option value="diamond">Diamond</option>
                    <option value="star">Star</option>
                    <option value="stop-sign">Stop Sign</option>
                  </optgroup>
                  <optgroup label="Network Equipment">
                    <option value="server">Server</option>
                    <option value="pc">PC / Desktop</option>
                    <option value="laptop">Laptop</option>
                    <option value="phone">Phone / Mobile</option>
                    <option value="router">Router</option>
                    <option value="switch">Switch</option>
                    <option value="firewall">Firewall</option>
                    <option value="cloud">Cloud</option>
                    <option value="database">Database</option>
                    <option value="printer">Printer</option>
                  </optgroup>
                </select>
              </div>
              <button class="pick-icon-btn" id="pick-shape-icon-btn">Or Search Web Icons</button>
              <div class="style-row">
                <label>Fill Color:</label>
                <input type="color" id="circle-color" value="#1e293b">
              </div>
              <div class="style-row">
                <label>Border Color:</label>
                <input type="color" id="circle-border" value="#475569">
              </div>
              <div class="style-row">
                <label>Title Color:</label>
                <input type="color" id="title-color" value="#e2e8f0">
              </div>
              <div class="style-row">
                <label>Title Font:</label>
                <select id="title-font">
                  <option value="system-ui, sans-serif">System UI</option>
                  <option value="monospace">Monospace</option>
                  <option value="serif">Serif</option>
                  <option value="cursive">Cursive</option>
                  <option value="'Courier New', monospace">Courier</option>
                  <option value="Arial, sans-serif">Arial</option>
                  <option value="'Times New Roman', serif">Times</option>
                </select>
              </div>
              <div class="style-row">
                <label>Title Size:</label>
                <input type="number" id="title-size" min="8" max="100" value="18">
              </div>
              <div class="style-row">
                <label>Sub Color:</label>
                <input type="color" id="sub-color" value="#94a3b8">
              </div>
              <div class="style-row">
                <label>Sub Font:</label>
                <select id="sub-font">
                  <option value="system-ui, sans-serif">System UI</option>
                  <option value="monospace">Monospace</option>
                  <option value="serif">Serif</option>
                  <option value="cursive">Cursive</option>
                  <option value="'Courier New', monospace">Courier</option>
                  <option value="Arial, sans-serif">Arial</option>
                  <option value="'Times New Roman', serif">Times</option>
                </select>
              </div>
              <div class="style-row">
                <label>Sub Size:</label>
                <input type="number" id="sub-size" min="6" max="80" value="13">
              </div>
              <div style="
                margin-top: 12px;
                padding-top: 10px;
                border-top: 1px solid var(--edge-main);
                ">
                <div style="font-size: 12px;color: var(--text-soft);margin-bottom: 8px;text-transform: uppercase;">Text Position</div>
                <div class="style-row">
                  <label>Name Y:</label>
                  <input type="number" id="title-offset-y" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>Name X:</label>
                  <input type="number" id="title-offset-x" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>IP Y:</label>
                  <input type="number" id="sub-offset-y" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>IP X:</label>
                  <input type="number" id="sub-offset-x" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div style="margin-top: 16px; font-size: 12px; color: var(--text-soft); text-transform: uppercase;">
                  Ping Indicator Position
                </div>
                <div class="style-row">
                  <label>Ping X:</label>
                  <input type="number" id="ping-offset-x" min="-200" max="200" value="0" style="width: 60px;">
                </div>
                <div class="style-row">
                  <label>Ping Y:</label>
                  <input type="number" id="ping-offset-y" min="-200" max="200" value="0" style="width: 60px;">
                </div>
              </div>
              <button id="reset-styles" style="width: 100%;margin-top: 10px;padding: 8px;background: var(--panel);color: var(--text-main);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: clamp(13px, 1.5vw, 17px);">Reset Styles</button>
            </div>
          </details>
          <details class="style-section">
            <summary>Ping / Status Monitoring</summary>
            <div class="style-content">
              <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px; cursor: pointer;">
              <input type="checkbox" id="node-pingable" style="cursor: pointer;">
              <span style="font-size: 14px;">Enable status check for this node</span>
              </label>
              <div id="node-ping-options" style="display: block;">
                <div class="style-row">
                  <label>Protocol:</label>
                  <select id="node-ping-protocol">
                    <option value="http">HTTP (port 80)</option>
                    <option value="https">HTTPS (port 443)</option>
                    <option value="custom">Custom URL</option>
                  </select>
                </div>
                <div id="node-custom-url-container" style="display: block; margin-top: 8px;">
                  <label style="display: block; margin-bottom: 4px; font-size: 13px;">Custom URL:</label>
                  <input type="text" id="node-custom-url" placeholder="e.g. http://192.168.1.1:8080" style="width: 100%;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: 14px;">
                </div>
                <div class="style-row" style="margin-top: 8px;">
                  <label>Timeout (ms):</label>
                  <input type="number" id="node-ping-timeout" value="3000" min="1000" max="10000" step="500" style="width: 100px;">
                </div>
                <div style="margin-top: 12px; padding: 10px; background: var(--panel); border-radius: 6px; border: 1px solid var(--edge-main);">
                  <div style="font-size: 12px; color: var(--text-soft); margin-bottom: 8px;">Current Status:</div>
                  <div id="node-ping-status" style="font-size: 14px; font-weight: 600; color: var(--accent);">‚óè Online</div>
                  <div id="node-ping-last-check" style="font-size: 11px; color: var(--text-soft); margin-top: 4px;">Last checked: 2:25:19 PM</div>
                </div>
                <button id="check-ping-now" style="width: 100%;margin-top: 10px;padding: 8px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Check Status Now</button>
              </div>
            </div>
          </details>
          <div class="section-label">Notes</div>
          <ul class="list" id="node-notes"><li><span style="flex: 1 1 0%;">ISP: AT&amp;T Fiber</span><span class="delete-note">‚úï</span></li><li><span style="flex: 1 1 0%;">set to google for ping sake</span><span class="delete-note">‚úï</span></li></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-note-input" placeholder="Type new note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-note-btn" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-node-btn" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: rgb(255, 255, 255);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;width: 100%;">Delete Node</button>
        </div>
        <div id="edge-panel" style="display: none">
          <div class="details-name" id="edge-title">Custom line</div>
          <div class="style-row" style="margin-top: 10px">
            <label>Width:</label>
            <input type="number" id="edge-width" min="1" max="20" value="4">
          </div>
          <div class="style-row">
            <label>Color:</label>
            <input type="color" id="edge-color" value="#475569">
          </div>
          <div class="style-row">
            <label>Line Style:</label>
            <select id="edge-line-style">
              <option value="solid">Solid</option>
              <option value="dashed">Dashed</option>
              <option value="dotted">Dotted</option>
            </select>
          </div>
          <div class="style-row">
            <label>Direction:</label>
            <select id="edge-direction">
              <option value="none">No arrows</option>
              <option value="forward">‚Üí Forward</option>
              <option value="backward">‚Üê Backward</option>
              <option value="both">‚Üî Bidirectional</option>
            </select>
          </div>
          <div class="style-row" id="edge-port-fields">
            <label>From Port:</label>
            <input type="text" id="edge-from-port" placeholder="e.g. eth0, gi0/1" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);font-size: 14px;">
          </div>
          <div class="style-row" id="edge-port-fields-to">
            <label>To Port:</label>
            <input type="text" id="edge-to-port" placeholder="e.g. eth1, gi0/2" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);font-size: 14px;">
          </div>
          <div class="section-label">Line Notes</div>
          <ul class="list" id="edge-notes"></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-edge-note" placeholder="Add note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-edge-note" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-edge" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Delete Line</button>
        </div>
        <div id="rect-panel" style="display: none">
          <div class="details-name" id="rect-title">Zone</div>
          <div class="style-row" id="rect-fill-row" style="margin-top: 10px">
            <label>Fill Color:</label>
            <input type="color" id="rect-color" value="#f97316">
          </div>
          <div class="style-row">
            <label>Border Color:</label>
            <input type="color" id="rect-border-color" value="#f97316">
          </div>
          <div class="style-row">
            <label>Border Width:</label>
            <input type="number" id="rect-border-width" min="0" max="20" value="2">
          </div>
          <div class="style-row">
            <label>Style:</label>
            <select id="rect-style-select">
              <option value="filled">Filled</option>
              <option value="outlined">Outlined</option>
            </select>
          </div>
          <div class="section-label">Zone Notes</div>
          <ul class="list" id="rect-notes"></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-rect-note" placeholder="Add note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-rect-note" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-rect" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Delete Zone</button>
        </div>
        <div id="text-panel" style="display: none;">
          <div class="details-name" id="text-title">Text Element</div>
          <div class="style-row" style="margin-top: 10px">
            <label>Content:</label>
            <textarea id="text-content" placeholder="Enter text..." style="width: 100%;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: 14px;min-height: 80px;resize: vertical;font-family: inherit;"></textarea>
          </div>
          <div class="style-row">
            <label>Font Size:</label>
            <input type="number" id="text-font-size" min="8" max="200" value="18" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);">
          </div>
          <div class="style-row">
            <label>Color:</label>
            <input type="color" id="text-color" value="#e2e8f0">
          </div>
          <div class="style-row">
            <label>Font Weight:</label>
            <select id="text-font-weight" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="normal">Normal</option>
              <option value="bold">Bold</option>
              <option value="600">Semi-Bold</option>
              <option value="300">Light</option>
            </select>
          </div>
          <div class="style-row">
            <label>Font Style:</label>
            <select id="text-font-style" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="normal">Normal</option>
              <option value="italic">Italic</option>
            </select>
          </div>
          <div class="style-row">
            <label>Text Align:</label>
            <select id="text-align" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="start">Left</option>
              <option value="middle">Center</option>
              <option value="end">Right</option>
            </select>
          </div>
          <div class="style-row">
            <label>Text Decoration:</label>
            <select id="text-decoration" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="none">None</option>
              <option value="underline">Underline</option>
              <option value="line-through">Strike Through</option>
            </select>
          </div>
          <div class="style-row">
            <label>Background:</label>
            <input type="color" id="text-bg-color" value="#000000">
            <label style="margin-left: 10px; display: flex; align-items: center; gap: 6px;">
            <input type="checkbox" id="text-bg-enabled" style="cursor: pointer;">
            <span style="font-size: 13px;">Enable</span>
            </label>
          </div>
          <div class="style-row">
            <label>Opacity:</label>
            <input type="range" id="text-opacity" min="0" max="1" step="0.1" value="1" style="flex: 1">
            <span id="text-opacity-val" style="min-width: 35px; text-align: right">100%</span>
          </div>
          <button id="delete-text" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;width: 100%;">Delete Text</button>
        </div>
     <details class="style-section">
          <summary>Page Layout</summary>
          <div class="style-content">
            <div style="padding: 12px; background: var(--panel-alt); border-radius: 6px; color: var(--text-soft); font-size: 13px; line-height: 1.6;">
              <strong style="color: var(--accent); display: block; margin-bottom: 8px;">Drag to Resize:</strong>
              ‚Ä¢ <strong>Header:</strong> Drag the bottom edge of the header bar<br>
              ‚Ä¢ <strong>Sidebar:</strong> Drag the left edge of the sidebar panel<br>
              ‚Ä¢ <strong>Mobile:</strong> Drag the top edge of the footer panel<br>
              <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--edge-main); font-size: 12px;">
                Hover over panel edges to see resize handles
              </div>
            </div>
          </div>
        </details>
      </aside>
    </main>
    <script id="nodes-json" type="application/json">{}</script>
    <script id="topology-state" type="application/json">ENCRYPTED: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</script>
    <script>
      const IconLibrary = {
       libraries: {
        mdi: {
         name: 'Material Design Icons',
         cdnBase: 'https://cdn.jsdelivr.net/npm/@mdi/svg@latest/svg/',
         metaUrl: 'https://cdn.jsdelivr.net/npm/@mdi/svg@latest/meta.json',
         icons: []
        },
        simple: {
         name: 'Simple Icons',
         cdnBase: 'https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/',
         indexUrl: 'https://cdn.jsdelivr.net/npm/@iconify-json/simple-icons@latest/icons.json',
         icons: []
        },
        selfhst: {
         name: 'selfh.st/icons',
         cdnBase: 'https://cdn.jsdelivr.net/gh/selfhst/icons@master/png/',
         indexUrl: 'https://raw.githubusercontent.com/selfhst/icons/refs/heads/main/index.json',
         icons: []
        }
       },
       currentLibrary: 'selfhst',
       iconCache: {},
       indexCache: {},
       indexLoading: {},
       async loadLibraryIndex(library) {
        if (this.indexCache[library]) {
         return this.indexCache[library];
        }
        if (this.indexLoading[library]) {
         return this.indexLoading[library];
        }
        const lib = this.libraries[library];
        this.indexLoading[library] = (async () => {
         try {
          if (library === 'selfhst') {
           const response = await fetch(lib.indexUrl);
           const data = await response.json();
           const icons = data.map(item => ({
            name: item.Reference,
            displayName: item.Name,
            tags: item.Tags ? item.Tags.split(',').map(t => t.trim()).filter(t => t) : [],
            category: item.Category
           }));
           this.indexCache[library] = icons;
           lib.icons = icons;
           return icons;
          } else if (library === 'simple') {
           const response = await fetch('https://cdn.jsdelivr.net/npm/@iconify-json/simple-icons@latest/icons.json');
           const data = await response.json();
           const icons = Object.keys(data.icons).map(slug => ({
            name: slug,
            displayName: data.icons[slug].title || slug,
            tags: data.aliases && data.aliases[slug] ? [data.aliases[slug].parent] : [],
            hex: data.icons[slug].hex
           }));
           this.indexCache[library] = icons;
           lib.icons = icons;
           return icons;
          } else if (library === 'mdi') {
           const response = await fetch(lib.metaUrl);
           const data = await response.json();
           const icons = data.map(item => ({
            name: item.name,
            displayName: item.name,
            tags: item.tags || [],
            author: item.author
           }));
           this.indexCache[library] = icons;
           lib.icons = icons;
           return icons;
          }
         } catch (error) {
          console.error(`Failed to load index for ${library}:`, error);
          this.indexCache[library] = [];
          lib.icons = [];
          return [];
         } finally {
          delete this.indexLoading[library];
         }
        })();
        return this.indexLoading[library];
       },
       async getIcon(library, name) {
        const cacheKey = `${library}-${name}`;
        if (this.iconCache[cacheKey]) {
         return this.iconCache[cacheKey];
        }
        const cached = localStorage.getItem(`icon-${cacheKey}`);
        if (cached) {
         this.iconCache[cacheKey] = cached;
         return cached;
        }
        const lib = this.libraries[library];
        if (library === 'selfhst') {
         const pngUrl = `${lib.cdnBase}${name}.png`;
         const svgWrapper = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><image href="${pngUrl}" width="24" height="24"/></svg>`;
         this.iconCache[cacheKey] = svgWrapper;
         localStorage.setItem(`icon-${cacheKey}`, svgWrapper);
         return svgWrapper;
        }
        const url = `${lib.cdnBase}${name}.svg`;
        try {
         const response = await fetch(url);
         if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
         }
         const svg = await response.text();
         this.iconCache[cacheKey] = svg;
         localStorage.setItem(`icon-${cacheKey}`, svg);
         return svg;
        } catch (error) {
         console.error(`Failed to fetch icon ${cacheKey}:`, error);
         return null;
        }
       },
       searchIcons(library, query) {
        const lib = this.libraries[library];
        if (!lib.icons.length) return [];
        const q = query.toLowerCase();
        return lib.icons.filter(icon => {
         const nameMatch = icon.name.toLowerCase().includes(q);
         const displayMatch = icon.displayName && icon.displayName.toLowerCase().includes(q);
         const tagMatch = icon.tags && icon.tags.some(t => t.toLowerCase().includes(q));
         const categoryMatch = icon.category && icon.category.toLowerCase().includes(q);
         return nameMatch || displayMatch || tagMatch || categoryMatch;
        }).slice(0, 50);
       }
      };
      let iconPickerCallback = null;
      let selectedNodeIconData = null;
      let selectedRackIconData = null;
      let newNodeIconTags = [];
      let freeDrawMode = false;
      async function checkNodeStatus(nodeId) {
       const data = NODE_DATA[nodeId];
       if (!data || !data.ping || !data.ping.enabled) return;
       
       data.ping.status = 'checking';
       data.ping.lastCheck = new Date().toISOString();
       updatePingIndicator(nodeId);
       if (currentNodeId === nodeId) {
        updatePingStatusDisplay(nodeId);
       }
       
       let url;
       if (data.ping.protocol === 'custom') {
        url = data.ping.customUrl;
       } else {
        const ip = data.ip || '0.0.0.0';
        const protocol = data.ping.protocol || 'http';
        url = `${protocol}://${ip}`;
       }
       
       if (!url) {
        data.ping.status = 'unknown';
        updatePingIndicator(nodeId);
        if (currentNodeId === nodeId) {
         updatePingStatusDisplay(nodeId);
        }
        return;
       }
       
       try {
        const controller = new AbortController();
        const timeout = data.ping.timeout || 3000;
        const timeoutId = setTimeout(() => controller.abort(), timeout);
        
        const response = await fetch(url, {
         method: 'HEAD',
         mode: 'no-cors', 
         signal: controller.signal
        });
        
        clearTimeout(timeoutId);
        
        data.ping.status = 'online';
       } catch (error) {
        data.ping.status = 'offline';
       }
       
       data.ping.lastCheck = new Date().toISOString();
       updatePingIndicator(nodeId);
       if (currentNodeId === nodeId) {
        updatePingStatusDisplay(nodeId);
       }
      }
      function rgbaToHex(val) {
      if (!val) return "#000000";
      if (val.startsWith("#")) return val;
      
      const m = val.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
      if (!m) return "#000000";
      
      const r = Number(m[1]).toString(16).padStart(2, "0");
      const g = Number(m[2]).toString(16).padStart(2, "0");
      const b = Number(m[3]).toString(16).padStart(2, "0");
      
      return `#${r}${g}${b}`;
      }
      function updatePingIndicator(nodeId) {
      const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
      if (!nodeGroup) return;
      
      const data = NODE_DATA[nodeId];
      if (!data || !data.ping || !data.ping.enabled) {
       const existingIndicator = nodeGroup.querySelector('.ping-indicator');
       if (existingIndicator) existingIndicator.remove();
       return;
      }
      
      let indicator = nodeGroup.querySelector('.ping-indicator');
      const label = nodeGroup.querySelector('.node-label');
      
      if (!indicator && label) {
       indicator = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
       indicator.classList.add('ping-indicator');
       nodeGroup.appendChild(indicator);
      }
      
      if (indicator && label) {
       const size = savedSizes[nodeId] || getDefaultSize();
       const radius = Math.max(4, size * 0.06);
      
       indicator.setAttribute('r', radius);
      
       const labelBBox = label.getBBox();
       const labelX = parseFloat(label.getAttribute('x') || 0);
       const labelY = parseFloat(label.getAttribute('y') || 0);
      
       const styles = resolveStylesForNode(nodeId);
      const offX = styles.pingOffsetX || 0;
      const offY = styles.pingOffsetY || 0;
      
      indicator.setAttribute('cx', (labelX - labelBBox.width / 2 - radius * 1.1) + offX);
      indicator.setAttribute('cy', (labelY - radius * 0.7) + offY);
      }
      
      if (indicator) {
       indicator.classList.remove('online', 'offline', 'checking');
       if (data.ping.status) indicator.classList.add(data.ping.status);
      }
      }
      
      
      function checkAllNodesStatus() {
       Object.keys(NODE_DATA).forEach(nodeId => {
        const data = NODE_DATA[nodeId];
        if (data && data.ping && data.ping.enabled) {
         checkNodeStatus(nodeId);
        }
       });
      }
      
      function startAutoPing() {
       stopAutoPing();
       
       checkAllNodesStatus();
       updateAutoPingLastRun();
       
       autoPingSecondsRemaining = autoPingInterval;
       
      
       autoPingTimer = setInterval(() => {
        checkAllNodesStatus();
        updateAutoPingLastRun();
        autoPingSecondsRemaining = autoPingInterval;
       }, autoPingInterval * 1000);
       
       autoPingCountdown = setInterval(() => {
        autoPingSecondsRemaining--;
        updateAutoPingCountdown();
        if (autoPingSecondsRemaining <= 0) {
         autoPingSecondsRemaining = autoPingInterval;
        }
       }, 1000);
       
       updateAutoPingCountdown();
      }
      
      function stopAutoPing() {
       if (autoPingTimer) {
        clearInterval(autoPingTimer);
        autoPingTimer = null;
       }
       if (autoPingCountdown) {
        clearInterval(autoPingCountdown);
        autoPingCountdown = null;
       }
       autoPingSecondsRemaining = 0;
       updateAutoPingCountdown();
      }
      
      function updateAutoPingCountdown() {
       const nextCheckEl = document.getElementById('auto-ping-next-check');
       if (nextCheckEl) {
        if (autoPingSecondsRemaining > 0 && autoPingEnabled) {
         const mins = Math.floor(autoPingSecondsRemaining / 60);
         const secs = autoPingSecondsRemaining % 60;
         if (mins > 0) {
          nextCheckEl.textContent = `Next check in: ${mins}m ${secs}s`;
         } else {
          nextCheckEl.textContent = `Next check in: ${secs}s`;
         }
        } else {
         nextCheckEl.textContent = 'Next check in: --';
        }
       }
      }
      
      function updateAutoPingLastRun() {
       const lastRunEl = document.getElementById('auto-ping-last-run');
       if (lastRunEl) {
        const now = new Date();
        lastRunEl.textContent = `Last run: ${now.toLocaleTimeString()}`;
       }
      }
      
      function openIconPicker(callback) {
       iconPickerCallback = callback;
       const modal = document.getElementById('icon-picker-modal');
       modal.classList.add('active');
       const searchInput = document.getElementById('icon-search');
       searchInput.style.display = 'none';
       loadIconsForCurrentLibrary();
      }
      
      function closeIconPicker() {
       const modal = document.getElementById('icon-picker-modal');
       modal.classList.remove('active');
       iconPickerCallback = null;
      }
      async function loadIconsForCurrentLibrary() {
       const body = document.getElementById('icon-picker-body');
       const libNames = {
        mdi: 'MDI (Material Design Icons)',
        simple: 'Simple Icons',
        selfhst: 'selfh.st/icons'
       };
       body.innerHTML = `<div style="padding: 20px;"><p style="color: var(--text-soft); margin-bottom: 15px; text-align: center;">Search ${libNames[IconLibrary.currentLibrary]}:</p><input type="text" id="icon-search-field" placeholder="Search icons..." style="width: 100%; padding: 12px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main); font-size: 16px; margin-bottom: 20px;"><div id="icon-grid-container" style="max-height: 400px; overflow-y: auto;"><div style="text-align: center; color: var(--text-soft); padding: 40px;">Loading icons...</div></div></div>`;
       const searchField = document.getElementById('icon-search-field');
       const gridContainer = document.getElementById('icon-grid-container');
       await IconLibrary.loadLibraryIndex(IconLibrary.currentLibrary);
       const renderIcons = (icons) => {
        if (!icons || icons.length === 0) {
         gridContainer.innerHTML = '<div style="text-align: center; color: var(--text-soft); padding: 40px;">No icons found</div>';
         return;
        }
        const grid = document.createElement('div');
        grid.style.cssText = 'display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 15px; padding: 10px;';
        icons.forEach(icon => {
         const item = document.createElement('div');
         item.style.cssText = 'display: flex; flex-direction: column; align-items: center; gap: 8px; padding: 15px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; cursor: pointer; transition: all 0.2s;';
         item.onmouseover = () => {
          item.style.background = 'var(--panel)';
          item.style.borderColor = 'var(--accent)';
         };
         item.onmouseout = () => {
          item.style.background = 'var(--panel-alt)';
          item.style.borderColor = 'var(--edge-main)';
         };
         const iconPreview = document.createElement('div');
         iconPreview.style.cssText = 'width: 48px; height: 48px; display: flex; align-items: center; justify-content: center;';
         iconPreview.innerHTML = '<div style="color: var(--text-soft); font-size: 12px;">...</div>';
         IconLibrary.getIcon(IconLibrary.currentLibrary, icon.name).then(svg => {
          if (svg) {
           const parser = new DOMParser();
           const doc = parser.parseFromString(svg, 'image/svg+xml');
           const svgEl = doc.querySelector('svg');
           if (svgEl) {
            svgEl.setAttribute('width', '48');
            svgEl.setAttribute('height', '48');
            svgEl.style.fill = 'var(--text-main)';
            iconPreview.innerHTML = '';
            iconPreview.appendChild(svgEl);
           }
          }
         });
         const name = document.createElement('div');
         name.textContent = icon.displayName || icon.name;
         name.style.cssText = 'font-size: 11px; color: var(--text-soft); text-align: center; word-break: break-word; max-width: 100%;';
         item.appendChild(iconPreview);
         item.appendChild(name);
         item.addEventListener('click', async () => {
          const svg = await IconLibrary.getIcon(IconLibrary.currentLibrary, icon.name);
          if (iconPickerCallback && svg) {
           iconPickerCallback({
            library: IconLibrary.currentLibrary,
            name: icon.name,
            svg: svg
           });
          }
          closeIconPicker();
         });
         grid.appendChild(item);
        });
        gridContainer.innerHTML = '';
        gridContainer.appendChild(grid);
       };
       gridContainer.innerHTML = '<div style="text-align: center; color: var(--text-soft); padding: 40px;">Type to search icons</div>';
       let searchTimeout;
       searchField.addEventListener('input', (e) => {
        clearTimeout(searchTimeout);
        const query = e.target.value.trim();
        searchTimeout = setTimeout(() => {
         if (!query) {
          gridContainer.innerHTML = '<div style="text-align: center; color: var(--text-soft); padding: 40px;">Type to search icons</div>';
          return;
         }
         const results = IconLibrary.searchIcons(IconLibrary.currentLibrary, query);
         renderIcons(results);
        }, 300);
       });
       searchField.focus();
      }
      async function displayIcons(icons) {
       const body = document.getElementById('icon-picker-body');
       const grid = document.createElement('div');
       grid.className = 'icon-grid';
       for (const icon of icons) {
        const item = document.createElement('div');
        item.className = 'icon-item';
        const svg = await IconLibrary.getIcon(icon.library, icon.name);
        if (svg) {
         const parser = new DOMParser();
         const doc = parser.parseFromString(svg, 'image/svg+xml');
         const svgEl = doc.querySelector('svg');
         if (svgEl) {
          item.innerHTML = svgEl.outerHTML;
         }
        } else {
         item.innerHTML = '<svg width = "32" height = "32"><rect width = "32" height = "32" fill = "currentColor"/> </svg>';
        }
        const name = document.createElement('div');
        name.className = 'icon-item-name';
        name.textContent = icon.name;
        item.appendChild(name);
        item.addEventListener('click', () => {
         if (iconPickerCallback) {
          iconPickerCallback({
           library: icon.library,
           name: icon.name,
           svg: svg
          });
         }
         closeIconPicker();
        });
        grid.appendChild(item);
       }
       body.innerHTML = '';
       body.appendChild(grid);
      }
      window.addEventListener('DOMContentLoaded', () => {
       document.querySelectorAll('.icon-picker-tab').forEach(tab => {
        tab.addEventListener('click', () => {
         document.querySelectorAll('.icon-picker-tab').forEach(t => t.classList.remove('active'));
         tab.classList.add('active');
         IconLibrary.currentLibrary = tab.dataset.library;
         loadIconsForCurrentLibrary();
        });
       });
       document.getElementById('icon-picker-cancel').addEventListener('click', closeIconPicker);
       document.getElementById('icon-picker-modal').addEventListener('click', (e) => {
        if (e.target.id === 'icon-picker-modal') {
         closeIconPicker();
        }
       });
      });
      let textDrawMode = false;
      const BASE_NODE_DATA = JSON.parse(document.getElementById("nodes-json").textContent, );
      let currentNodeId = "host";
      let currentEdgeId = null;
      let currentStyleScope = "all";
      let NODE_DATA = {};
      let EDGE_DATA = {
       list: []
      };
      let currentRectId = null;
      let rectDrawMode = false;
      let RECT_DATA = {
       list: []
      };
      let TEXT_DATA = {
       list: []
      };
      let EDGE_LEGEND = {};
      let savedPositions = {};
      let savedSizes = {};
      let savedStyles = {};
      let legendCollapsed = false;
      let minimapCollapsed = false;
      let drawToolbarCollapsed = false;
      let currentView = {
       mode: "topology",
       rackId: null
      };
      let savedTopologyView = null;
      let activeLayers = new Set(["physical", "logical", "security", "application"]);
      let topologyToolbarCollapsed = false;
      let legendMiniBtn = null;
      let minimapMiniBtn = null;
      let drawToolbarMiniBtn = null;
      let topologyToolbarMiniBtn = null;
      
      let autoPingEnabled = false;
      let autoPingInterval = 30;
      let autoPingTimer = null;
      let autoPingCountdown = null;
      let autoPingSecondsRemaining = 0;
      
      const ROLLBACK_STORAGE_KEY = "theonefile_rollback_history";
      let rollbackVersions = [];
      const MAX_ROLLBACK_VERSIONS = 50;
      let currentRollbackIndex = -1;
      
      const AUDIT_STORAGE_KEY = "theonefile_audit_log";
      let auditLog = [];
      const MAX_AUDIT_ENTRIES = 1000;
      
      let documentTabs = [{
        id: "main",
        name: "Main Topology",
        nodes: {},
        edges: { list: [] },
        positions: {},
        sizes: {},
        styles: {},
        legend: {},
        rects: { list: [] },
        texts: { list: [] },
      pageState: null
      }];
      let currentTabIndex = 0;
      
      let encryptedSections = {};
      
      let undoStack = [];
      let redoStack = [];
      const MAX_UNDO_STACK = 50;
      let selectedNodes = new Set();
      let selectedEdges = new Set();
      let selectedRects = new Set();
      let selectedTexts = new Set();
      let isSelecting = false;
      let selectionStart = null;
      let selectionRect = null;
      let isDraggingSelection = false;
      let dragSelectionStart = null;
      let clipboard = null;
      
      const MobileManager = {
        isMobile: false,
        detect() {
      
          if (navigator.userAgentData?.mobile === true) {
            this.isMobile = true;
            return true;
          }
          const coarse = matchMedia("(pointer: coarse)").matches;
          const width = window.innerWidth <= 900;
          const portrait = matchMedia("(orientation: portrait)").matches;
          this.isMobile = coarse && (width || portrait);
          return this.isMobile;
        },
        applyInitialCollapse() {
          if (!this.isMobile) return;
          legendCollapsed = true;
          minimapCollapsed = true;
          drawToolbarCollapsed = true;
          topologyToolbarCollapsed = true;
          if (typeof updateLegendVisibility === "function") updateLegendVisibility();
          if (typeof updateMinimapVisibility === "function") updateMinimapVisibility();
          if (typeof updateDrawToolbarVisibility === "function") updateDrawToolbarVisibility();
          if (typeof updateTopologyToolbarVisibility === "function") updateTopologyToolbarVisibility();
        },
        updateBulkToolbar() {
          const desktop = document.getElementById("bulk-toolbar");
          const mobile = document.getElementById("bulk-toolbar-mobile");
          if (!desktop || !mobile) return;
          
          const isVisible = desktop.style.display !== "none" || mobile.style.display !== "none";
          
          if (this.isMobile) {
            desktop.style.display = "none";
            if (isVisible) {
              mobile.style.display = "flex";
            }
          } else {
            mobile.style.display = "none";
            if (isVisible) {
              desktop.style.display = "flex";
            }
          }
        },
        updateLayout() {
          const main = document.querySelector("main");
          if (!main) return;
        },
        updateCanvasHint() {
      const hint = document.getElementById("canvas-hint");
      if (!hint) return;
      
      if (PAGE_STATE.canvasHintText !== undefined && PAGE_STATE.canvasHintText !== "") {
        hint.innerHTML = PAGE_STATE.canvasHintText;
        return;
      }
      
      const items = this.isMobile
      ? [
        "Pinch to zoom",
        "Drag to pan",
        "Add node from top menu",
        "Double tap to clone and align",
        "Double tap to select multiple",
        "You have the power",	
        "Your time is NOW!",
      ]
      : [
        "Scroll to zoom",
        "Drag to pan",
        "Right click to clone and align",
        "Right click to select multiple",
        "You have the power",
        "Your time is NOW!",
      ];
      
      const list = document.createElement("ul");
      for (const item of items) {
      const li = document.createElement("li");
      li.textContent = item;
      list.appendChild(li);
      }
      
      hint.replaceChildren(list);
      },
        autoSelectStyleScope() {
          const scope = document.getElementById("style-scope");
          if (!scope) return;
          if (this.isMobile) scope.value = "mobile";
        },
        updateToolbarStack() {
          if (!this.isMobile) return;
          const draw = document.getElementById("draw-toolbar");
          const topo = document.getElementById("topology-toolbar");
          if (!draw || !topo) return;
          const h = draw.getBoundingClientRect().height;
          document.documentElement.style.setProperty("--draw-toolbar-height", h + "px");
        },
        updateLayoutControls() {
          const sidebarRow = document.getElementById("sidebar-width-row");
          const footerRow = document.getElementById("mobile-footer-row");
          if (sidebarRow && footerRow) {
            if (this.isMobile) {
              sidebarRow.style.display = "none";
              footerRow.style.display = "flex";
            } else {
              sidebarRow.style.display = "flex";
              footerRow.style.display = "none";
            }
          }
        },
        applyAll() {
          this.detect();
          this.applyInitialCollapse();
          this.updateBulkToolbar();
          this.updateLayout();
          this.updateCanvasHint();
          this.autoSelectStyleScope();
          this.updateToolbarStack();
          this.updateLayoutControls();
        }
      };
      function isMobileDevice() {
        return MobileManager.isMobile;
      }
      
      function ensureLegendMiniButton() {
       if (legendMiniBtn) return legendMiniBtn;
      
       const panel = document.querySelector(".topology-panel");
       if (!panel) return null;
       const btn = document.createElement("button");
       btn.type = "button";
       btn.id = "edge-legend-mini";
       btn.className = "legend-mini-btn";
       btn.textContent = "Legend";
       btn.style.bottom = "10px";
       const handleClick = (e) => {
        e.stopPropagation();
        e.preventDefault();
        legendCollapsed = false;
        updateLegendVisibility();
       };
       btn.addEventListener("click", handleClick);
       btn.addEventListener("touchend", handleClick);
       panel.appendChild(btn);
       legendMiniBtn = btn;
       return btn;
      }
      
      function ensureMinimapMiniButton() {
       if (minimapMiniBtn) return minimapMiniBtn;
       const panel = document.querySelector(".topology-panel");
       if (!panel) return null;
       const btn = document.createElement("button");
       btn.type = "button";
       btn.id = "minimap-mini";
       btn.className = "legend-mini-btn";
       btn.textContent = "Map";
       btn.style.right = "10px";
       btn.style.left = "auto";
       btn.style.bottom = "10px";
       const handleClick = (e) => {
        e.stopPropagation();
        e.preventDefault();
        minimapCollapsed = false;
        updateMinimapVisibility();
       };
       btn.addEventListener("click", handleClick);
       btn.addEventListener("touchend", handleClick);
       panel.appendChild(btn);
       minimapMiniBtn = btn;
       return btn;
      }
      
      function ensureDrawToolbarMiniButton() {
       if (drawToolbarMiniBtn) return drawToolbarMiniBtn;
       const panel = document.querySelector(".topology-panel");
       if (!panel) return null;
       const btn = document.createElement("button");
       btn.type = "button";
       btn.id = "draw-toolbar-mini";
       btn.className = "legend-mini-btn";
       btn.textContent = "Draw";
       btn.style.top = "10px";
       btn.style.left = "10px";
       btn.style.right = "auto";
       const handleClick = (e) => {
        e.stopPropagation();
        e.preventDefault();
        drawToolbarCollapsed = false;
        updateDrawToolbarVisibility();
       };
       btn.addEventListener("click", handleClick);
       btn.addEventListener("touchend", handleClick);
       panel.appendChild(btn);
       drawToolbarMiniBtn = btn;
       return btn;
      }
      
      function ensureTopologyToolbarMiniButton() {
       if (topologyToolbarMiniBtn) return topologyToolbarMiniBtn;
       const panel = document.querySelector(".topology-panel");
       if (!panel) return null;
       const btn = document.createElement("button");
       btn.type = "button";
       btn.id = "topology-toolbar-mini";
       btn.className = "legend-mini-btn";
       btn.textContent = "Add Line";
       btn.style.top = "10px";
       btn.style.left = "auto";
       btn.style.right = "40px";
       const handleClick = (e) => {
        e.stopPropagation();
        e.preventDefault();
        topologyToolbarCollapsed = false;
        updateTopologyToolbarVisibility();
       };
       btn.addEventListener("click", handleClick);
       btn.addEventListener("touchend", handleClick);
       panel.appendChild(btn);
       topologyToolbarMiniBtn = btn;
       return btn;
      }
      
      function updateToolbarStack() {
       if (!isMobileDevice()) return;
       const draw = document.getElementById("draw-toolbar");
       const topo = document.getElementById("topology-toolbar");
       if (!draw || !topo) return;
       const h = draw.getBoundingClientRect().height;
       document.documentElement.style.setProperty("--draw-toolbar-height", h + "px");
      }
      window.addEventListener("resize", updateToolbarStack);
      window.addEventListener("DOMContentLoaded", updateToolbarStack);
      updateToolbarStack();
      
      function updateLegendVisibility() {
       const legend = document.getElementById("edge-legend");
       const mini = ensureLegendMiniButton();
       if (!legend || !mini) return;
       const hasItems = legend.querySelectorAll(".legend-item").length > 0;
       if (!hasItems) {
        legend.style.display = "none";
        mini.style.display = "none";
        return;
       }
       if (legendCollapsed) {
        legend.style.display = "none";
        mini.style.display = "inline-flex";
       } else {
        legend.style.display = "flex";
        mini.style.display = "none";
       }
      }
      
      function updateMinimapVisibility() {
       const wrapper = document.getElementById("minimap-zoom-wrapper");
       const mini = ensureMinimapMiniButton();
       if (!wrapper || !mini) return;
       if (minimapCollapsed) {
        wrapper.style.display = "none";
        mini.style.display = "inline-flex";
       } else {
        wrapper.style.display = "block";
        mini.style.display = "none";
       }
      }
      
      function updateDrawToolbarVisibility() {
       const toolbar = document.getElementById("draw-toolbar");
       const mini = ensureDrawToolbarMiniButton();
       if (!toolbar || !mini) return;
       if (drawToolbarCollapsed) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "inline-flex";
       } else {
      if (isMobileDevice()) {    	   
        toolbar.style.setProperty('display', 'grid', 'important');
        mini.style.display = "none";
        } else {   
        toolbar.style.setProperty('display', 'flex', 'important');
        mini.style.display = "none";	  
      }
       }
      }
      
      function u8ToBase64(u8) {
      let binary = "";
      for (let i = 0; i < u8.length; i++) binary += String.fromCharCode(u8[i]);
      return btoa(binary);
      }
      
      function base64ToU8(base64) {
      const binary = atob(base64);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
      return bytes;
      }  
      
      function updateTopologyToolbarVisibility() {
       const toolbar = document.getElementById("topology-toolbar");
       const mini = ensureTopologyToolbarMiniButton();
       if (!toolbar || !mini) return;
       const hasSelectedNode = currentNodeId !== null;
       if (!hasSelectedNode) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "none";
       } else if (topologyToolbarCollapsed) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "inline-flex";
       } else {   
      if (isMobileDevice()) {    	   
        toolbar.style.setProperty('display', 'grid', 'important');
        mini.style.display = "none";
        } else {   
        toolbar.style.setProperty('display', 'flex', 'important');
        mini.style.display = "none";	  
      }
       }
      }
      const DEFAULT_CANVAS_HINT = document.getElementById("canvas-hint")?.innerHTML || "";
      const DEFAULT_PAGE_STATE = {
       title: "The One File: The Networkening",
       background: "",
       topbarBg: "rgba(9, 12, 20, 0.9)",
       topbarBorder: "#1f2533",
       panel: "#0b0e13",
       panelAlt: "#10141b",
       accent: "#4fd1c5",
       sidebarBg: "#10141b",
       btnBg: "#0b0e13",
       btnText: "#e2e8f0",
       tagFill: "#1e293b",
       tagText: "#e2e8f0",
       tagBorder: "#475569",
       inputBg: "#0b0e13",
       inputText: "#e2e8f0",
       inputBorder: "#1f2937",
       inputFont: "Inter, system-ui, sans-serif",
       inputFontSize: 14,
       toolbarBg: "#0f172a",
       toolbarBorder: "#1f2937",
       toolbarText: "#94a3b8",
       toolbarBtnBg: "#0b0e13",
       toolbarBtnText: "#e2e8f0",
       minimapDots: "#94a3b8",
       canvasHintEnabled: true,
       canvasHintText: "",
       canvasHintBg: "#0f172a",
       canvasHintColor: "#94a3b8",
       danger: "#f56565",
       textMain: "#e2e8f0",
       textSoft: "#94a3b8",
       topbarHeight: 52,
       sidebarWidth: 350,
       mobileFooterHeight: 40,
       sidebarCollapsed: false,
       nodeFill: "#1e293b",
       nodeStroke: "#475569",
       nodeTitle: "#e2e8f0",
       nodeSub: "#94a3b8",
       nodeTitleSize: 18,
       nodeSubSize: 13,
       nodeFont: "Inter, system-ui, sans-serif",
       defaultEdge: "#475569",
       selectionHandle: "#f59e0b",
       selectionHandleSize: 8,
       groupIndicator: "#4fd1c5",
       canvasGradientTop: "#1e2532",
       canvasGradientBottom: "#050608",
       canvasBorder: "#475569",
       canvasGrid: "#475569",
       canvasGridSize: 50,
       rackFrameFill: "#0f172a",
       rackFrameStroke: "#4fd1c5",
       rackLineColor: "#475569",
       rackTextColor: "#4fd1c5",
      };
      let PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE);
      const CANVAS_WIDTH = 4000;
      let CANVAS_HEIGHT = 3000;
      const BASE_CANVAS_HEIGHT = 3000;
      const CANVAS_PADDING = 100;
      
      const RACK_U_HEIGHT = 70;
      const RACK_WIDTH = 600;
      const RACK_START_X = CANVAS_WIDTH / 2;
      const RACK_START_Y = CANVAS_PADDING + 100;
      function getRackUHeight(rackId) {
      const capacity = getRackCapacity(rackId);
      const availableHeight = CANVAS_HEIGHT - RACK_START_Y - 200;
      return Math.floor(availableHeight / capacity);
      }
      let canvasState = {
       zoom: 1,
       panX: 0,
       panY: 0,
       minZoom: 0.25,
       maxZoom: 4,
       isPanning: false,
       panStartX: 0,
       panStartY: 0,
       spacePressed: false,
      };
      
      function getViewBox() {
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       return {
        x: canvasState.panX,
        y: canvasState.panY,
        width: viewWidth,
        height: viewHeight,
       };
      }
      
      function updateViewBox() {
       const svg = document.getElementById("map");
       const vb = getViewBox();
       svg.setAttribute("viewBox", `${vb.x} ${vb.y} ${vb.width} ${vb.height}`, );
       const zoomLevel = document.getElementById("zoom-level");
       if (zoomLevel) {
        zoomLevel.textContent = Math.round(canvasState.zoom * 100) + "%";
       }
       updateMinimap();
      }
      
      function updateMinimap() {
       const minimapViewport = document.getElementById("minimap-viewport");
       const minimapSvg = document.getElementById("minimap");
       if (!minimapViewport || !minimapSvg) return;
       const vb = getViewBox();
       minimapViewport.setAttribute("x", vb.x);
       minimapViewport.setAttribute("y", vb.y);
       minimapViewport.setAttribute("width", vb.width);
       minimapViewport.setAttribute("height", vb.height);
       const minimapNodes = minimapSvg.querySelectorAll(".minimap-node");
       minimapNodes.forEach((n) => n.remove());
       const minimapEdges = minimapSvg.querySelectorAll(".minimap-edge");
       minimapEdges.forEach((e) => e.remove());
       
       EDGE_DATA.list.forEach((edge) => {
        if (edge.type === "custom") return;
        
        const fromNode = NODE_DATA[edge.from];
        const toNode = NODE_DATA[edge.to];
        if (!fromNode || !toNode) return;
        
        if (currentView.mode === "rack") {
         if (fromNode.assignedRack !== currentView.rackId || 
             toNode.assignedRack !== currentView.rackId) {
          return;
         }
        } else {
         if (fromNode.assignedRack || toNode.assignedRack) {
          return;
         }
        }
        
        const p1 = savedPositions[edge.from];
        const p2 = savedPositions[edge.to];
        if (!p1 || !p2) return;
        const line = document.createElementNS("http://www.w3.org/2000/svg", "line", );
        line.setAttribute("x1", p1.x);
        line.setAttribute("y1", p1.y);
        line.setAttribute("x2", p2.x);
        line.setAttribute("y2", p2.y);
        line.classList.add("minimap-edge");
        minimapSvg.insertBefore(line, minimapViewport);
       });
      
       Object.entries(savedPositions).forEach(([id, pos]) => {
        const node = NODE_DATA[id];
        if (!node) return;
        
        if (currentView.mode === "rack") {
         if (node.assignedRack !== currentView.rackId) {
          return;
         }
        } else {
         if (node.assignedRack) {
          return;
         }
        }
        
        const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle", );
        circle.setAttribute("cx", pos.x);
        circle.setAttribute("cy", pos.y);
        circle.setAttribute("r", 40);
        circle.classList.add("minimap-node");
        minimapSvg.insertBefore(circle, minimapViewport);
       });
      }
      
      function zoomTo(newZoom, centerX, centerY) {
       const oldZoom = canvasState.zoom;
       newZoom = Math.max(canvasState.minZoom, Math.min(canvasState.maxZoom, newZoom), );
       if (centerX !== undefined && centerY !== undefined) {
        const oldWidth = CANVAS_WIDTH / oldZoom;
        const oldHeight = CANVAS_HEIGHT / oldZoom;
        const newWidth = CANVAS_WIDTH / newZoom;
        const newHeight = CANVAS_HEIGHT / newZoom;
        const pointX = canvasState.panX + centerX * oldWidth;
        const pointY = canvasState.panY + centerY * oldHeight;
        canvasState.panX = pointX - centerX * newWidth;
        canvasState.panY = pointY - centerY * newHeight;
       }
       canvasState.zoom = newZoom;
       constrainPan();
       updateViewBox();
      }
      
      function constrainPan() {
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       const minVisiblePortion = 0.1;
       const maxPanX = CANVAS_WIDTH - viewWidth * minVisiblePortion;
       const maxPanY = CANVAS_HEIGHT - viewHeight * minVisiblePortion;
       const minPanX = -viewWidth * (1 - minVisiblePortion);
       const minPanY = -viewHeight * (1 - minVisiblePortion);
       canvasState.panX = Math.max(minPanX, Math.min(maxPanX, canvasState.panX), );
       canvasState.panY = Math.max(minPanY, Math.min(maxPanY, canvasState.panY), );
      }
      
      function fitToContent() {
       const positions = Object.values(savedPositions);
       if (positions.length === 0) {
        resetView();
        return;
       }
       let minX = Infinity,
        minY = Infinity,
        maxX = -Infinity,
        maxY = -Infinity;
       positions.forEach((pos) => {
        minX = Math.min(minX, pos.x - 100);
        minY = Math.min(minY, pos.y - 100);
        maxX = Math.max(maxX, pos.x + 100);
        maxY = Math.max(maxY, pos.y + 100);
       });
       const contentWidth = maxX - minX + 200;
       const contentHeight = maxY - minY + 200;
       const viewport = document.getElementById("canvas-viewport");
       const vpRect = viewport.getBoundingClientRect();
       const aspectRatio = vpRect.width / vpRect.height;
       const contentAspect = contentWidth / contentHeight;
       let newZoom;
       if (contentAspect > aspectRatio) {
        newZoom = (vpRect.width / contentWidth) * (CANVAS_WIDTH / vpRect.width);
       } else {
        newZoom = (vpRect.height / contentHeight) * (CANVAS_HEIGHT / vpRect.height);
       }
       newZoom = Math.max(canvasState.minZoom, Math.min(2, newZoom));
       const viewWidth = CANVAS_WIDTH / newZoom;
       const viewHeight = CANVAS_HEIGHT / newZoom;
       canvasState.zoom = newZoom;
       canvasState.panX = minX - 100 - (viewWidth - contentWidth) / 2;
       canvasState.panY = minY - 100 - (viewHeight - contentHeight) / 2;
       constrainPan();
       updateViewBox();
      }
      
      function resetView() {
       canvasState.zoom = 1;
       canvasState.panX = 0;
       canvasState.panY = 0;
       updateViewBox();
      }
      window.addEventListener("DOMContentLoaded", () => {
       const toggle = document.getElementById("mobile-menu-toggle");
       const menu = document.getElementById("topbar-menu");
       if (!toggle || !menu) return;
       toggle.addEventListener("click", () => {
        menu.classList.toggle("open");
       });
       menu.addEventListener("click", (e) => {
        const target = e.target.closest("a, button");
        if (!target) return;
        if (isMobileDevice()) {
       menu.classList.remove("open");
      }
       });
       const minimapCloseBtn = document.getElementById("minimap-close-btn");
       if (minimapCloseBtn) {
        const handleMinimapClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         minimapCollapsed = true;
         updateMinimapVisibility();
        };
        minimapCloseBtn.addEventListener("click", handleMinimapClose);
        minimapCloseBtn.addEventListener("touchend", handleMinimapClose);
       }
       const drawToolbarCloseBtn = document.getElementById("draw-toolbar-close-btn");
       if (drawToolbarCloseBtn) {
        const handleDrawClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         drawToolbarCollapsed = true;
         updateDrawToolbarVisibility();
        };
        drawToolbarCloseBtn.addEventListener("click", handleDrawClose);
        drawToolbarCloseBtn.addEventListener("touchend", handleDrawClose);
       }
       const topologyToolbarCloseBtn = document.getElementById("topology-toolbar-close-btn");
       if (topologyToolbarCloseBtn) {
        const handleTopologyClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         topologyToolbarCollapsed = true;
         updateTopologyToolbarVisibility();
        };
        topologyToolbarCloseBtn.addEventListener("click", handleTopologyClose);
        topologyToolbarCloseBtn.addEventListener("touchstart", (e) => e.preventDefault(), {
         passive: false
        });
        topologyToolbarCloseBtn.addEventListener("touchend", handleTopologyClose);
       }
      
       updateMinimapVisibility();
       updateDrawToolbarVisibility();
       updateTopologyToolbarVisibility();
      });
      
      function applyLayerFilter() {  
       activeLayers.clear(); 
       if (document.getElementById("layer-physical").checked) activeLayers.add("physical");    
       if (document.getElementById("layer-logical").checked) activeLayers.add("logical");    
       if (document.getElementById("layer-security").checked) activeLayers.add("security");     
       if (document.getElementById("layer-application").checked) activeLayers.add("application");
       forgeTheTopology();    
      }
      
      function isNodeVisible(nodeId) {  
       const node = NODE_DATA[nodeId];    
       if (!node) return false;     
       const nodeLayer = node.layer || "physical";     
       return activeLayers.has(nodeLayer);     
      }
      
      function enterRack(rackId) {
      if (!NODE_DATA[rackId] || !NODE_DATA[rackId].isRack) return;
      const rackCapacity = getRackCapacity(rackId);
      const neededHeight = RACK_START_Y + (rackCapacity * RACK_U_HEIGHT) + 200;
      if (neededHeight > BASE_CANVAS_HEIGHT) {
      CANVAS_HEIGHT = neededHeight;
      }
       
       currentView.mode = "rack";
       currentView.rackId = rackId;
       
       const backBtn = document.getElementById("back-to-topology-btn");
       if (backBtn) backBtn.style.display = "inline-block";
       
       const hint = document.getElementById("canvas-hint");
       if (hint) {
        hint.textContent = `Viewing: ${NODE_DATA[rackId].name} | Double click empty space to exit`;
        hint.classList.add("visible");
       }
       
      
      const rackUHeight = getRackUHeight(rackId);
      const rackHeight = rackCapacity * rackUHeight;
      const rackCenterX = RACK_START_X;
      const rackCenterY = RACK_START_Y + (rackHeight / 2);
       
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       
       canvasState.panX = rackCenterX - (viewWidth / 2);
       canvasState.panY = rackCenterY - (viewHeight / 2);
       
       constrainPan();
       updateViewBox();
       
       forgeTheTopology();
      }
      
      function exitRack() {
      CANVAS_HEIGHT = BASE_CANVAS_HEIGHT;
      currentView.mode = "topology";
      currentView.rackId = null;
       
       const backBtn = document.getElementById("back-to-topology-btn");
       if (backBtn) backBtn.style.display = "none";
       
       const hint = document.getElementById("canvas-hint");
       if (hint) {
        hint.classList.remove("visible");
       }
       
       if (savedTopologyView) {
        canvasState.zoom = savedTopologyView.zoom;
        canvasState.panX = savedTopologyView.panX;
        canvasState.panY = savedTopologyView.panY;
        updateViewBox();
       }
       
       forgeTheTopology();
      }
      
      function getRackCapacity(rackId) {
       const node = NODE_DATA[rackId];
       return node && node.rackCapacity ? parseInt(node.rackCapacity) : 42;
      }
      
      function populateRackDropdown() {
       const dropdown = document.getElementById("node-assigned-rack");
       if (!dropdown) return;
       
       dropdown.innerHTML = '<option value="">None</option>';
       
       Object.keys(NODE_DATA).forEach(id => {
        if (NODE_DATA[id].isRack) {
         const option = document.createElement("option");
         option.value = id;
         option.textContent = NODE_DATA[id].name;
         dropdown.appendChild(option);
        }
       });
      }
      
      function wieldThePower() {
       const root = document.documentElement;
       root.style.setProperty("--panel", PAGE_STATE.panel);
       root.style.setProperty("--panel-alt", PAGE_STATE.panelAlt);
       root.style.setProperty("--sidebar-bg", PAGE_STATE.sidebarBg || PAGE_STATE.panelAlt);
       root.style.setProperty("--btn-bg", PAGE_STATE.btnBg || PAGE_STATE.panel);
       root.style.setProperty("--btn-text", PAGE_STATE.btnText || "#e2e8f0");
       root.style.setProperty("--tag-fill", PAGE_STATE.tagFill || "#1e293b");
       root.style.setProperty("--tag-text", PAGE_STATE.tagText || "#e2e8f0");
       root.style.setProperty("--tag-border", PAGE_STATE.tagBorder || "#475569");
       root.style.setProperty("--input-bg", PAGE_STATE.inputBg || "#0b0e13");
       root.style.setProperty("--input-text", PAGE_STATE.inputText || "#e2e8f0");
       root.style.setProperty("--input-border", PAGE_STATE.inputBorder || "#1f2937");
       root.style.setProperty("--input-font", PAGE_STATE.inputFont || "Inter, system-ui, sans-serif");
       root.style.setProperty("--input-font-size", (PAGE_STATE.inputFontSize || 14) + "px");
       root.style.setProperty("--toolbar-bg", PAGE_STATE.toolbarBg || "#0f172a");
       root.style.setProperty("--toolbar-border", PAGE_STATE.toolbarBorder || "#1f2937");
       root.style.setProperty("--toolbar-text", PAGE_STATE.toolbarText || "#94a3b8");
       root.style.setProperty("--toolbar-btn-bg", PAGE_STATE.toolbarBtnBg || "#0b0e13");
       root.style.setProperty("--toolbar-btn-text", PAGE_STATE.toolbarBtnText || "#e2e8f0");
       root.style.setProperty("--minimap-dots", PAGE_STATE.minimapDots || "#94a3b8");
       root.style.setProperty("--canvas-hint-bg", PAGE_STATE.canvasHintBg || "#0f172a");
       root.style.setProperty("--canvas-hint-color", PAGE_STATE.canvasHintColor || "#94a3b8");
       
       const canvasHint = document.getElementById("canvas-hint");
       if (canvasHint) {
        canvasHint.style.display = PAGE_STATE.canvasHintEnabled === false ? "none" : "";
        if (PAGE_STATE.canvasHintText !== undefined && PAGE_STATE.canvasHintText !== "") {
         canvasHint.innerHTML = PAGE_STATE.canvasHintText;
        } else {
         canvasHint.innerHTML = DEFAULT_CANVAS_HINT;
        }
       }
       root.style.setProperty("--accent", PAGE_STATE.accent);
       root.style.setProperty("--danger", PAGE_STATE.danger);
       root.style.setProperty("--text-main", PAGE_STATE.textMain);
       root.style.setProperty("--text-soft", PAGE_STATE.textSoft);
       root.style.setProperty("--topbar-bg", PAGE_STATE.topbarBg);
       root.style.setProperty("--topbar-border", PAGE_STATE.topbarBorder);
       root.style.setProperty("--node-fill", PAGE_STATE.nodeFill || "#1e293b");
       root.style.setProperty("--node-stroke", PAGE_STATE.nodeStroke || "#475569");
       root.style.setProperty("--node-title", PAGE_STATE.nodeTitle || "#e2e8f0");
       root.style.setProperty("--node-sub", PAGE_STATE.nodeSub || "#94a3b8");
       root.style.setProperty("--node-title-size", (PAGE_STATE.nodeTitleSize || 18) + "px");
       root.style.setProperty("--node-sub-size", (PAGE_STATE.nodeSubSize || 13) + "px");
       root.style.setProperty("--node-font", PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif");
       root.style.setProperty("--default-edge", PAGE_STATE.defaultEdge || "#475569");
       root.style.setProperty("--selection-handle", PAGE_STATE.selectionHandle || "#f59e0b");
       root.style.setProperty("--selection-handle-size", (PAGE_STATE.selectionHandleSize || 8) + "px");
       root.style.setProperty("--group-indicator", PAGE_STATE.groupIndicator || "#4fd1c5");
       const topbarHeight = PAGE_STATE.topbarHeight || 52;
       const sidebarWidth = PAGE_STATE.sidebarWidth || 350;
       const mobileFooterHeight = PAGE_STATE.mobileFooterHeight || 40;
       root.style.setProperty("--topbar-height", topbarHeight + "px");
       root.style.setProperty("--sidebar-width", sidebarWidth + "px");
       root.style.setProperty("--mobile-footer-height", mobileFooterHeight + "vh", );
       const mainEl = document.querySelector("main");
       const detailsPanel = document.getElementById("details-panel");
       const sidebarToggle = document.getElementById("sidebar-toggle");
       if (PAGE_STATE.sidebarCollapsed) {
        if (mainEl) mainEl.classList.add("sidebar-collapsed");
        if (detailsPanel) detailsPanel.classList.add("collapsed");
        if (sidebarToggle) {
         sidebarToggle.classList.add("collapsed");
         sidebarToggle.textContent = "‚ñ∂";
        }
       } else {
        if (mainEl) mainEl.classList.remove("sidebar-collapsed");
        if (detailsPanel) detailsPanel.classList.remove("collapsed");
        if (sidebarToggle) {
         sidebarToggle.classList.remove("collapsed");
         sidebarToggle.textContent = "‚óÄ";
        }
       }
       if (PAGE_STATE.background) {
        document.body.style.background = PAGE_STATE.background;
       } else {
        document.body.style.background = `radial-gradient(circle at top, ${PAGE_STATE.canvasGradientTop || "#1e2532"} 0, ${PAGE_STATE.canvasGradientBottom || "#050608"} 70%)`;
       }
       document.title = PAGE_STATE.title || DEFAULT_PAGE_STATE.title;
       const titleEl = document.getElementById("page-title");
       if (titleEl) {
        titleEl.textContent = PAGE_STATE.title || DEFAULT_PAGE_STATE.title;
       }
      }
      (async function awakeTheImmortal() {
       let initialState = {};
       let decryptionCancelled = false;
       const stateEl = document.getElementById("topology-state");
       if (stateEl && stateEl.textContent.trim()) {
        try {
         let stateText = stateEl.textContent.trim();
         if (isEncrypted(stateText)) {
          let decrypted = false;
          let attempts = 0;
          const maxAttempts = 3;
          while (!decrypted && attempts < maxAttempts) {
           const password = prompt("This file is encrypted. Enter password to decrypt:\n(Attempt " + (attempts + 1) + " of " + maxAttempts + ")", );
           if (!password) {
            alert("Decryption cancelled. The file will not be loaded.", );
            decryptionCancelled = true;
            break;
           }
           try {
            stateText = await decryptData(stateText, password);
            decrypted = true;
           } catch (e) {
            attempts++;
            if (attempts < maxAttempts) {
             alert("Incorrect password. Please try again.");
            } else {
             alert("Maximum attempts reached. The file will not be loaded.", );
             decryptionCancelled = true;
            }
           }
          }
          if (!decrypted) {
           stateText = "{}";
          }
         }
         initialState = JSON.parse(stateText);
        } catch (e) {
         console.error("Failed to load state:", e);
         initialState = {};
        }
       }
       if (decryptionCancelled) {
        NODE_DATA = {};
        EDGE_DATA = {
         list: []
        };
        RECT_DATA = { list: [] };
        TEXT_DATA = { list: [] };
        EDGE_LEGEND = {};
        savedPositions = {};
        savedSizes = {};
        savedStyles = {};
       } else {
        NODE_DATA = initialState.nodeData ? initialState.nodeData : BASE_NODE_DATA;
        
        Object.keys(NODE_DATA).forEach(nodeId => {
         if (!NODE_DATA[nodeId].ping) {
          NODE_DATA[nodeId].ping = {
           enabled: false,
           protocol: 'http',
           customUrl: '',
           timeout: 3000,
           status: 'unknown',
           lastCheck: null
          };
         }
        });
        
        EDGE_DATA = initialState.edgeData ? initialState.edgeData : {
         list: [],
        };
        RECT_DATA = initialState.rectData ? initialState.rectData : { list: [] };
        TEXT_DATA = initialState.textData ? initialState.textData : { list: [] };
        EDGE_LEGEND = initialState.edgeLegend || {};
        savedPositions = initialState.nodePositions || {};
        savedSizes = initialState.nodeSizes || {};
        savedStyles = initialState.nodeStyles || {};
        if (initialState.iconCache) {
         IconLibrary.iconCache = initialState.iconCache;
        }
       }
       if (initialState.page) {
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, initialState.page, );
       }
       
       if (PAGE_STATE.autoPingEnabled !== undefined) {
        autoPingEnabled = PAGE_STATE.autoPingEnabled;
       }
       if (PAGE_STATE.autoPingInterval !== undefined) {
        autoPingInterval = PAGE_STATE.autoPingInterval;
       }
       
       if (initialState.canvas) {
        canvasState.zoom = initialState.canvas.zoom || 1;
        canvasState.panX = initialState.canvas.panX || 0;
        canvasState.panY = initialState.canvas.panY || 0;
       }
       
       if (initialState.savedTopologyView) {
        savedTopologyView = initialState.savedTopologyView;
       }
       
       if (initialState.documentTabs) {
        documentTabs = initialState.documentTabs;
        if (initialState.currentTabIndex !== undefined) {
          currentTabIndex = initialState.currentTabIndex;
          const currentTab = documentTabs[currentTabIndex];
          if (currentTab) {
            NODE_DATA = currentTab.nodes || NODE_DATA;
            EDGE_DATA = currentTab.edges || EDGE_DATA;
            savedPositions = currentTab.positions || savedPositions;
            savedSizes = currentTab.sizes || savedSizes;
            savedStyles = currentTab.styles || savedStyles;
            EDGE_LEGEND = currentTab.legend || EDGE_LEGEND;
            RECT_DATA = currentTab.rects || RECT_DATA;
            TEXT_DATA = currentTab.texts || TEXT_DATA;
            if (currentTab.pageState) PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, currentTab.pageState);
          }
        }
       }
       
       if (initialState.encryptedSections) {
        encryptedSections = initialState.encryptedSections;
       }
       
       wieldThePower();
       forgeTheTopology();
       updateViewBox();
       
       MobileManager.applyAll();
       
       if (autoPingEnabled) {
        startAutoPing();
       }
       
       const initialNodes = Object.keys(NODE_DATA);
       if (initialNodes.length > 0) {
        claimTheImmortal(initialNodes.includes("host") ? "host" : initialNodes[0], );
       } else {
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.display = "none";
       }
      })();
      
      window.addEventListener("resize", () => {
        MobileManager.applyAll();
      });
      
      function saveEdgeData() {}
      
      function saveEdgeLegend() {}
      
      function getBreakpointKey() {
       const w = window.innerWidth;
       if (w <= 380) return "fold";
       if (w <= 768) return "mobile";
       if (w <= 1024) return "tablet";
       return "desktop";
      }
      
      function resolveStylesEntry(styleEntry) {
       if (!styleEntry) return {};
       if (styleEntry.circleColor || styleEntry.titleColor || styleEntry.titleFont || styleEntry.titleSize || styleEntry.subColor || styleEntry.subFont || styleEntry.subSize) {
        return styleEntry;
       }
       const bp = getBreakpointKey();
       const base = styleEntry.all || {};
       const bpStyles = styleEntry[bp] || {};
       return Object.assign({}, base, bpStyles);
      }
      
      function resolveStylesForNode(id) {
       const styleEntry = savedStyles[id];
       if (!styleEntry) return {};
       return resolveStylesEntry(styleEntry);
      }
      
      function ensureStyleEntry(id) {
       if (!savedStyles[id]) savedStyles[id] = {};
       const entry = savedStyles[id];
       const flatProps = ["circleColor", "circleBorder", "titleColor", "titleFont", "titleSize", "subColor", "subFont", "subSize", ];
       const isFlat = flatProps.some((p) => Object.prototype.hasOwnProperty.call(entry, p), );
       if (isFlat) {
        const all = entry.all || {};
        flatProps.forEach((p) => {
         if (entry[p] !== undefined) {
          all[p] = entry[p];
          delete entry[p];
         }
        });
        entry.all = all;
       }
       return entry;
      }
      
      function getDefaultSize() {
       if (window.innerWidth <= 380) return 120;
       if (window.innerWidth <= 768) return 140;
       if (window.innerWidth <= 1024) return 70;
       return 55;
      }
      
      function createShapeElement(shape, size) {
       const ns = "http://www.w3.org/2000/svg";
       if (shape === "circle") {
        const c = document.createElementNS(ns, "circle");
        c.setAttribute("r", size);
        return c;
       }
       if (shape === "square") {
        const r = document.createElementNS(ns, "rect");
        const s = size * 2;
        r.setAttribute("x", -size);
        r.setAttribute("y", -size);
        r.setAttribute("width", s);
        r.setAttribute("height", s);
        r.setAttribute("rx", 4);
        return r;
       }
       if (shape === "rectangle") {
        const r = document.createElementNS(ns, "rect");
        r.setAttribute("x", -size * 1.4);
        r.setAttribute("y", -size * 0.8);
        r.setAttribute("width", size * 2.8);
        r.setAttribute("height", size * 1.6);
        r.setAttribute("rx", 6);
        return r;
       }
       if (shape === "triangle") {
        const p = document.createElementNS(ns, "polygon");
        const h = size * 1.8;
        const w = size * 2;
        p.setAttribute("points", `0,${-h} ${w / 2},${h / 2} ${-w / 2},${h / 2}`, );
        return p;
       }
       if (shape === "hexagon") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        const pts = [
         [0, -s],
         [s * 0.86, -s * 0.5],
         [s * 0.86, s * 0.5],
         [0, s],
         [-s * 0.86, s * 0.5],
         [-s * 0.86, -s * 0.5],
        ].map((pt) => pt.join(",")).join(" ");
        p.setAttribute("points", pts);
        return p;
       }
       if (shape === "stop-sign") {
        const p = document.createElementNS(ns, "polygon");
        const r = size;
        const ptsArr = [];
        for (let i = 0; i < 8; i++) {
         const a = (Math.PI / 4) * i + Math.PI / 8;
         ptsArr.push([Math.cos(a) * r, Math.sin(a) * r]);
        }
        const pts = ptsArr.map((pt) => pt.join(",")).join(" ");
        p.setAttribute("points", pts);
        return p;
       }
       if (shape === "star") {
        const p = document.createElementNS(ns, "polygon");
        const outer = size;
        const inner = size * 0.45;
        let pts = "";
        for (let i = 0; i < 10; i++) {
         const a = (Math.PI / 5) * i - Math.PI / 2;
         const r = i % 2 === 0 ? outer : inner;
         pts += `${Math.cos(a) * r},${Math.sin(a) * r} `;
        }
        p.setAttribute("points", pts.trim());
        return p;
       }
       if (shape === "diamond") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `0,${-s} ${s},0 0,${s} ${-s},0`);
        return p;
       }
       if (shape === "server") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.2);
        body.setAttribute("y", -size * 0.6);
        body.setAttribute("width", size * 2.4);
        body.setAttribute("height", size * 1.2);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 3; i++) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", -size * 0.9 + i * size * 0.5);
         line.setAttribute("y1", -size * 0.3);
         line.setAttribute("x2", -size * 0.9 + i * size * 0.5);
         line.setAttribute("y2", size * 0.3);
         line.style.stroke = "currentColor";
         line.style.strokeWidth = "2";
         line.style.opacity = "0.5";
         g.appendChild(line);
        }
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", size * 0.9);
        led.setAttribute("cy", 0);
        led.setAttribute("r", size * 0.1);
        led.style.fill = "#4ade80";
        g.appendChild(led);
        return g;
       }
       if (shape === "pc" || shape === "desktop") {
        const g = document.createElementNS(ns, "g");
        const monitor = document.createElementNS(ns, "rect");
        monitor.setAttribute("x", -size * 0.9);
        monitor.setAttribute("y", -size * 0.8);
        monitor.setAttribute("width", size * 1.8);
        monitor.setAttribute("height", size * 1.2);
        monitor.setAttribute("rx", 4);
        g.appendChild(monitor);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.75);
        screen.setAttribute("y", -size * 0.65);
        screen.setAttribute("width", size * 1.5);
        screen.setAttribute("height", size * 0.9);
        screen.setAttribute("rx", 2);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        const neck = document.createElementNS(ns, "rect");
        neck.setAttribute("x", -size * 0.15);
        neck.setAttribute("y", size * 0.4);
        neck.setAttribute("width", size * 0.3);
        neck.setAttribute("height", size * 0.3);
        g.appendChild(neck);
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.5);
        base.setAttribute("y", size * 0.7);
        base.setAttribute("width", size * 1);
        base.setAttribute("height", size * 0.15);
        base.setAttribute("rx", 2);
        g.appendChild(base);
        return g;
       }
       if (shape === "laptop") {
        const g = document.createElementNS(ns, "g");
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.8);
        screen.setAttribute("y", -size * 0.9);
        screen.setAttribute("width", size * 1.6);
        screen.setAttribute("height", size * 1.1);
        screen.setAttribute("rx", 4);
        g.appendChild(screen);
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.9);
        base.setAttribute("y", size * 0.25);
        base.setAttribute("width", size * 1.8);
        base.setAttribute("height", size * 0.6);
        base.setAttribute("rx", 4);
        g.appendChild(base);
        const pad = document.createElementNS(ns, "rect");
        pad.setAttribute("x", -size * 0.25);
        pad.setAttribute("y", size * 0.45);
        pad.setAttribute("width", size * 0.5);
        pad.setAttribute("height", size * 0.25);
        pad.setAttribute("rx", 2);
        pad.style.fill = "#1e293b";
        g.appendChild(pad);
        return g;
       }
       if (shape === "phone" || shape === "mobile") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.45);
        body.setAttribute("y", -size);
        body.setAttribute("width", size * 0.9);
        body.setAttribute("height", size * 2);
        body.setAttribute("rx", 8);
        g.appendChild(body);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.38);
        screen.setAttribute("y", -size * 0.85);
        screen.setAttribute("width", size * 0.76);
        screen.setAttribute("height", size * 1.6);
        screen.setAttribute("rx", 4);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        const btn = document.createElementNS(ns, "rect");
        btn.setAttribute("x", -size * 0.15);
        btn.setAttribute("y", size * 0.82);
        btn.setAttribute("width", size * 0.3);
        btn.setAttribute("height", size * 0.06);
        btn.setAttribute("rx", 2);
        btn.style.fill = "#475569";
        g.appendChild(btn);
        return g;
       }
       if (shape === "router") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.1);
        body.setAttribute("y", -size * 0.3);
        body.setAttribute("width", size * 2.2);
        body.setAttribute("height", size * 0.8);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        for (let i = -1; i <= 1; i++) {
         const ant = document.createElementNS(ns, "rect");
         ant.setAttribute("x", i * size * 0.6 - size * 0.05);
         ant.setAttribute("y", -size * 0.9);
         ant.setAttribute("width", size * 0.1);
         ant.setAttribute("height", size * 0.6);
         ant.setAttribute("rx", 2);
         g.appendChild(ant);
         const tip = document.createElementNS(ns, "circle");
         tip.setAttribute("cx", i * size * 0.6);
         tip.setAttribute("cy", -size * 0.95);
         tip.setAttribute("r", size * 0.08);
         g.appendChild(tip);
        }
        for (let i = 0; i < 4; i++) {
         const led = document.createElementNS(ns, "circle");
         led.setAttribute("cx", -size * 0.7 + i * size * 0.35);
         led.setAttribute("cy", size * 0.1);
         led.setAttribute("r", size * 0.06);
         led.style.fill = i < 2 ? "#4ade80" : "#facc15";
         g.appendChild(led);
        }
        return g;
       }
       if (shape === "switch") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.4);
        body.setAttribute("y", -size * 0.4);
        body.setAttribute("width", size * 2.8);
        body.setAttribute("height", size * 0.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 8; i++) {
         const port = document.createElementNS(ns, "rect");
         port.setAttribute("x", -size * 1.2 + i * size * 0.32);
         port.setAttribute("y", -size * 0.15);
         port.setAttribute("width", size * 0.22);
         port.setAttribute("height", size * 0.3);
         port.setAttribute("rx", 1);
         port.style.fill = "#1e293b";
         g.appendChild(port);
        }
        return g;
       }
       if (shape === "firewall") {
        const g = document.createElementNS(ns, "g");
        const wall = document.createElementNS(ns, "rect");
        wall.setAttribute("x", -size);
        wall.setAttribute("y", -size * 0.8);
        wall.setAttribute("width", size * 2);
        wall.setAttribute("height", size * 1.6);
        wall.setAttribute("rx", 4);
        g.appendChild(wall);
        for (let row = 0; row < 3; row++) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", -size * 0.85);
         line.setAttribute("y1", -size * 0.5 + row * size * 0.45);
         line.setAttribute("x2", size * 0.85);
         line.setAttribute("y2", -size * 0.5 + row * size * 0.45);
         line.style.stroke = "#475569";
         line.style.strokeWidth = "2";
         g.appendChild(line);
        }
        for (let row = 0; row < 4; row++) {
         const offset = row % 2 === 0 ? 0 : size * 0.35;
         for (let col = 0; col < 3; col++) {
          const line = document.createElementNS(ns, "line");
          const x = -size * 0.5 + col * size * 0.7 + offset;
          if (x > -size * 0.85 && x < size * 0.85) {
           line.setAttribute("x1", x);
           line.setAttribute("y1", -size * 0.8 + row * size * 0.45, );
           line.setAttribute("x2", x);
           line.setAttribute("y2", -size * 0.8 + row * size * 0.45 + size * 0.45, );
           line.style.stroke = "#475569";
           line.style.strokeWidth = "2";
           g.appendChild(line);
          }
         }
        }
        return g;
       }
       if (shape === "cloud") {
        const p = document.createElementNS(ns, "path");
        const s = size;
        p.setAttribute("d", `
             M ${-s * 0.8} ${s * 0.2}
             Q ${-s * 1.1} ${s * 0.2} ${-s * 1.1} ${-s * 0.1}
             Q ${-s * 1.1} ${-s * 0.5} ${-s * 0.7} ${-s * 0.5}
             Q ${-s * 0.7} ${-s * 0.9} ${-s * 0.2} ${-s * 0.9}
             Q ${s * 0.1} ${-s * 1.1} ${s * 0.5} ${-s * 0.8}
             Q ${s * 1} ${-s * 0.8} ${s * 1.1} ${-s * 0.3}
             Q ${s * 1.3} ${-s * 0.1} ${s * 1.1} ${s * 0.2}
             Q ${s * 1.1} ${s * 0.5} ${s * 0.7} ${s * 0.5}
             L ${-s * 0.5} ${s * 0.5}
             Q ${-s * 0.9} ${s * 0.5} ${-s * 0.9} ${s * 0.2}
             Z
            `, );
        return p;
       }
       if (shape === "database") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.7);
        body.setAttribute("y", -size * 0.6);
        body.setAttribute("width", size * 1.4);
        body.setAttribute("height", size * 1.4);
        g.appendChild(body);
        const top = document.createElementNS(ns, "ellipse");
        top.setAttribute("cx", 0);
        top.setAttribute("cy", -size * 0.6);
        top.setAttribute("rx", size * 0.7);
        top.setAttribute("ry", size * 0.25);
        g.appendChild(top);
        const bottom = document.createElementNS(ns, "ellipse");
        bottom.setAttribute("cx", 0);
        bottom.setAttribute("cy", size * 0.8);
        bottom.setAttribute("rx", size * 0.7);
        bottom.setAttribute("ry", size * 0.25);
        g.appendChild(bottom);
        const mid1 = document.createElementNS(ns, "ellipse");
        mid1.setAttribute("cx", 0);
        mid1.setAttribute("cy", -size * 0.15);
        mid1.setAttribute("rx", size * 0.7);
        mid1.setAttribute("ry", size * 0.2);
        mid1.style.fill = "none";
        mid1.style.stroke = "#475569";
        mid1.style.strokeWidth = "2";
        g.appendChild(mid1);
        const mid2 = document.createElementNS(ns, "ellipse");
        mid2.setAttribute("cx", 0);
        mid2.setAttribute("cy", size * 0.35);
        mid2.setAttribute("rx", size * 0.7);
        mid2.setAttribute("ry", size * 0.2);
        mid2.style.fill = "none";
        mid2.style.stroke = "#475569";
        mid2.style.strokeWidth = "2";
        g.appendChild(mid2);
        return g;
       }
       if (shape === "printer") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.4);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size * 0.9);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const trayTop = document.createElementNS(ns, "rect");
        trayTop.setAttribute("x", -size * 0.7);
        trayTop.setAttribute("y", -size * 0.8);
        trayTop.setAttribute("width", size * 1.4);
        trayTop.setAttribute("height", size * 0.4);
        trayTop.setAttribute("rx", 2);
        trayTop.style.fill = "#1e293b";
        g.appendChild(trayTop);
        const trayOut = document.createElementNS(ns, "rect");
        trayOut.setAttribute("x", -size * 0.6);
        trayOut.setAttribute("y", size * 0.5);
        trayOut.setAttribute("width", size * 1.2);
        trayOut.setAttribute("height", size * 0.35);
        trayOut.setAttribute("rx", 2);
        g.appendChild(trayOut);
        const paper = document.createElementNS(ns, "rect");
        paper.setAttribute("x", -size * 0.5);
        paper.setAttribute("y", size * 0.3);
        paper.setAttribute("width", size * 1);
        paper.setAttribute("height", size * 0.5);
        paper.style.fill = "#e2e8f0";
        g.appendChild(paper);
        return g;
       }
       const c = document.createElementNS(ns, "circle");
       c.setAttribute("r", size);
       return c;
      }
      
      function createNodeShape(id, size) {
       const styles = resolveStylesForNode(id);
       if (styles.icon && styles.icon.library && styles.icon.name) {
        const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
        g.classList.add("node-circle");
        IconLibrary.getIcon(styles.icon.library, styles.icon.name).then(svgText => {
         if (svgText) {
          const parser = new DOMParser();
          const doc = parser.parseFromString(svgText, 'image/svg+xml');
          const svgEl = doc.querySelector('svg');
          if (svgEl) {
           svgEl.setAttribute('width', size * 1.2);
           svgEl.setAttribute('height', size * 1.2);
           svgEl.setAttribute('x', -size * 0.6);
           svgEl.setAttribute('y', -size * 0.6);
           if (styles.circleColor) {
            svgEl.style.fill = styles.circleColor;
           }
           g.innerHTML = svgEl.outerHTML;
          }
         }
        });
        return g;
       }
       const shapeType = (NODE_DATA[id] && NODE_DATA[id].shape) || "circle";
       const shapeEl = createShapeElement(shapeType, size);
       shapeEl.classList.add("node-circle");
shapeEl.style.fill = styles.circleColor || PAGE_STATE.nodeFill || "#1e293b";
       shapeEl.style.stroke = styles.circleBorder || PAGE_STATE.nodeStroke || "#475569";
       return shapeEl;
      }
      
      function forgeTheLegend() {
       const container = document.getElementById("edge-legend");
       if (!container) return;
       container.innerHTML = "";
       const title = document.createElement("div");
       title.className = "legend-title";
       title.textContent = "Line Legend";
       container.appendChild(title);
       const closeBtn = document.createElement("button");
       closeBtn.type = "button";
       closeBtn.className = "legend-close-btn";
       closeBtn.textContent = "‚úï";
       closeBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        legendCollapsed = true;
        updateLegendVisibility();
       });
       container.appendChild(closeBtn);
       const colors = [...new Set(EDGE_DATA.list.map((e) => e.color).filter(Boolean))];
       if (colors.length === 0) {
        updateLegendVisibility();
        return;
       }
       colors.forEach((color) => {
         if (!EDGE_LEGEND[color]) {
          EDGE_LEGEND[color] = "you can edit me too";
         }
         const item = document.createElement("div");
         item.className = "legend-item";
         item.addEventListener("mousedown", (e) => e.stopPropagation());
         item.addEventListener("click", (e) => e.stopPropagation());
         const swatch = document.createElement("span");
         swatch.className = "legend-swatch";
         swatch.style.backgroundColor = color;
         swatch.style.cursor = "pointer";
         swatch.addEventListener("click", (e) => {
          e.stopPropagation();
          const edgeWithColor = EDGE_DATA.list.find(edge => edge.color === color);
          if (edgeWithColor) {
           selectTheConnection(edgeWithColor.id);
          }
         });
         let swatchTouchStart = null;
         let swatchTouchMoved = false;
         swatch.addEventListener("touchstart", (e) => {
         swatchTouchStart = Date.now();
         swatchTouchMoved = false;
         if (e.touches[0]) {
          swatchTouchStartX = e.touches[0].clientX;
          swatchTouchStartY = e.touches[0].clientY;
         }
        }, {
          passive: false
         });
         let swatchTouchStartX = 0, swatchTouchStartY = 0;
        swatch.addEventListener("touchmove", (e) => {
         if (e.touches[0]) {
          const dx = Math.abs(e.touches[0].clientX - swatchTouchStartX);
          const dy = Math.abs(e.touches[0].clientY - swatchTouchStartY);
          if (dx > 10 || dy > 10) swatchTouchMoved = true;
         }
        }, {
          passive: false
         });
         swatch.addEventListener("touchend", (e) => {
          if (swatchTouchStart && !swatchTouchMoved && Date.now() - swatchTouchStart < 400) {
           e.stopPropagation();
           e.preventDefault();
           const edgeWithColor = EDGE_DATA.list.find(edge => edge.color === color);
           if (edgeWithColor) {
            selectTheConnection(edgeWithColor.id);
           }
          }
          swatchTouchStart = null;
          swatchTouchMoved = false;
         }, {
          passive: false
         });
        const label = document.createElement("span");
        label.className = "legend-label";
        label.textContent = EDGE_LEGEND[color];
        if (isMobileDevice()) {
         label.style.cursor = "pointer";
         let labelTapStart = null;
         let labelTapMoved = false;
         label.addEventListener("touchstart", (e) => {
          labelTapStart = Date.now();
          labelTapMoved = false;
          if (e.touches[0]) {
           labelTapStartX = e.touches[0].clientX;
           labelTapStartY = e.touches[0].clientY;
          }
          e.stopPropagation();
         });
         let labelTapStartX = 0, labelTapStartY = 0;
         label.addEventListener("touchmove", (e) => {
          if (e.touches[0]) {
           const dx = Math.abs(e.touches[0].clientX - labelTapStartX);
           const dy = Math.abs(e.touches[0].clientY - labelTapStartY);
           if (dx > 10 || dy > 10) labelTapMoved = true;
          }
         });
         label.addEventListener("touchend", (e) => {
          if (labelTapStart && !labelTapMoved && Date.now() - labelTapStart < 400) {
           e.preventDefault();
           e.stopPropagation();
           const currentText = label.textContent;
           const newText = prompt("Edit legend label:", currentText);
           if (newText !== null && newText.trim()) {
            label.textContent = newText.trim();
            EDGE_LEGEND[color] = newText.trim();
            saveEdgeLegend();
           }
          }
          labelTapStart = null;
          labelTapMoved = false;
         });
        } else {
           label.contentEditable = true;
           label.addEventListener("focus", () => {
            label.classList.add("editing");
           });
           label.addEventListener("blur", () => {
            label.classList.remove("editing");
            const text = label.textContent.trim() || "you can edit me too";
            EDGE_LEGEND[color] = text;
            saveEdgeLegend();
           });
           label.addEventListener("keydown", (e) => {
            if (e.key === "Enter") {
             e.preventDefault();
             label.blur();
            }
           });
          }
          item.append(swatch, label); container.appendChild(item);
         }); updateLegendVisibility();
       }
      
       function deleteRectangle(rectId) {
      pushUndo("delete zone");
        RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== rectId);
        forgeTheTopology();
       }
      
       function updateRectangleDeleteButtons() {
        const deleteButtons = document.querySelectorAll('.rect-delete-btn');
        deleteButtons.forEach(btn => {
         btn.style.display = rectDrawMode ? 'block' : 'none';
        });
       }
      
      
       function forgeTheTopology() {
        if (!NODE_DATA || !EDGE_DATA) {
         console.warn("forgeTheTopology called before data initialized");
         return;
        }
        const svg = document.getElementById("map");
        svg.innerHTML = "";
        const ns = "http://www.w3.org/2000/svg";
        const defs = document.createElementNS(ns, "defs");
        const markerForward = document.createElementNS(ns, "marker");
        markerForward.id = "arrow-forward";
        markerForward.setAttribute("markerWidth", "10");
        markerForward.setAttribute("markerHeight", "10");
        markerForward.setAttribute("refX", "9");
        markerForward.setAttribute("refY", "3");
        markerForward.setAttribute("orient", "auto");
        markerForward.setAttribute("markerUnits", "strokeWidth");
        const pathForward = document.createElementNS(ns, "path");
        pathForward.setAttribute("d", "M0,0 L0,6 L9,3 z");
        pathForward.setAttribute("fill", "context-stroke");
        markerForward.appendChild(pathForward);
        defs.appendChild(markerForward);
        const markerBackward = document.createElementNS(ns, "marker");
        markerBackward.id = "arrow-backward";
        markerBackward.setAttribute("markerWidth", "10");
        markerBackward.setAttribute("markerHeight", "10");
        markerBackward.setAttribute("refX", "0");
        markerBackward.setAttribute("refY", "3");
        markerBackward.setAttribute("orient", "auto");
        markerBackward.setAttribute("markerUnits", "strokeWidth");
        const pathBackward = document.createElementNS(ns, "path");
        pathBackward.setAttribute("d", "M9,0 L9,6 L0,3 z");
        pathBackward.setAttribute("fill", "context-stroke");
        markerBackward.appendChild(pathBackward);
        defs.appendChild(markerBackward);
        svg.appendChild(defs);
        const boundary = document.createElementNS(ns, "rect");
        boundary.setAttribute("x", CANVAS_PADDING);
        boundary.setAttribute("y", CANVAS_PADDING);
        boundary.setAttribute("width", CANVAS_WIDTH - CANVAS_PADDING * 2);
        boundary.setAttribute("height", CANVAS_HEIGHT - CANVAS_PADDING * 2);
        boundary.setAttribute("fill", "none");
        boundary.setAttribute("stroke", (PAGE_STATE.canvasBorder || "#475569") + "4D");
        boundary.setAttribute("stroke-width", "20");
        boundary.setAttribute("stroke-dasharray", "10 5");
        boundary.setAttribute("rx", "8");
        svg.appendChild(boundary);
       
       if (currentView.mode !== "rack") {
        const gridGroup = document.createElementNS(ns, "g");
        gridGroup.id = "canvas-grid";
        const gridSize = PAGE_STATE.canvasGridSize || 50;
        const gridColor = (PAGE_STATE.canvasGrid || "#475569") + "33";
        const majorGridColor = (PAGE_STATE.canvasGrid || "#475569") + "66";
        
        for (let x = CANVAS_PADDING; x <= CANVAS_WIDTH - CANVAS_PADDING; x += gridSize) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", x);
         line.setAttribute("y1", CANVAS_PADDING);
         line.setAttribute("x2", x);
         line.setAttribute("y2", CANVAS_HEIGHT - CANVAS_PADDING);
         line.setAttribute("stroke", (x - CANVAS_PADDING) % (gridSize * 5) === 0 ? majorGridColor : gridColor);
         line.setAttribute("stroke-width", (x - CANVAS_PADDING) % (gridSize * 5) === 0 ? "2" : "1");
         gridGroup.appendChild(line);
        }
        
        for (let y = CANVAS_PADDING; y <= CANVAS_HEIGHT - CANVAS_PADDING; y += gridSize) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", CANVAS_PADDING);
         line.setAttribute("y1", y);
         line.setAttribute("x2", CANVAS_WIDTH - CANVAS_PADDING);
         line.setAttribute("y2", y);
         line.setAttribute("stroke", (y - CANVAS_PADDING) % (gridSize * 5) === 0 ? majorGridColor : gridColor);
         line.setAttribute("stroke-width", (y - CANVAS_PADDING) % (gridSize * 5) === 0 ? "2" : "1");
         gridGroup.appendChild(line);
        }
        
        svg.appendChild(gridGroup);
       }
       
       if (currentView.mode === "rack" && currentView.rackId) {
         const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
         const rackGroup = document.createElementNS(ns, "g");
         rackGroup.id = "rack-visualization";       
         const rackFrame = document.createElementNS(ns, "rect");
         rackFrame.setAttribute("x", RACK_START_X - RACK_WIDTH / 2);
         rackFrame.setAttribute("y", RACK_START_Y);
         rackFrame.setAttribute("width", RACK_WIDTH);
         rackFrame.setAttribute("height", rackCapacity * rackUHeight);
      
         rackFrame.setAttribute("fill", (PAGE_STATE.rackFrameFill || "#0f172a") + "4D");
         rackFrame.setAttribute("stroke", PAGE_STATE.rackFrameStroke || "#4fd1c5");
         rackFrame.setAttribute("stroke-width", "3");
         rackFrame.setAttribute("rx", "4");
         rackGroup.appendChild(rackFrame);
         
         for (let u = 0; u <= rackCapacity; u++) {
          const y = RACK_START_Y + u * rackUHeight;
        
          const line = document.createElementNS(ns, "line");
          line.setAttribute("x1", RACK_START_X - RACK_WIDTH / 2);
          line.setAttribute("y1", y);
          line.setAttribute("x2", RACK_START_X + RACK_WIDTH / 2);
          line.setAttribute("y2", y);
          line.setAttribute("stroke", (PAGE_STATE.rackLineColor || "#475569") + "66");
          line.setAttribute("stroke-width", u % 5 === 0 ? "2" : "1");
          line.setAttribute("stroke-dasharray", u % 5 === 0 ? "none" : "5,5");
          rackGroup.appendChild(line);
          
          if (u < rackCapacity) {
           const uNumber = rackCapacity - u;
           const text = document.createElementNS(ns, "text");
           text.setAttribute("x", RACK_START_X - RACK_WIDTH / 2 - 30);
           text.setAttribute("y", y + rackUHeight / 2);
           text.setAttribute("text-anchor", "middle");
           text.setAttribute("dominant-baseline", "middle");
           text.style.fill = PAGE_STATE.rackTextColor || "#4fd1c5";
           text.style.fontSize = "14px";
           text.style.fontWeight = "bold";
           text.textContent = `U${uNumber}`;
           rackGroup.appendChild(text);
           
           const textRight = document.createElementNS(ns, "text");
           textRight.setAttribute("x", RACK_START_X + RACK_WIDTH / 2 + 30);
           textRight.setAttribute("y", y + rackUHeight / 2);
           textRight.setAttribute("text-anchor", "middle");
           textRight.setAttribute("dominant-baseline", "middle");
           textRight.style.fill = PAGE_STATE.rackTextColor || "#4fd1c5";
           textRight.style.fontSize = "14px";
           textRight.style.fontWeight = "bold";
           textRight.textContent = `U${uNumber}`;
           rackGroup.appendChild(textRight);
          }
         }
         
         svg.appendChild(rackGroup);
        }
      
        const centerX = CANVAS_WIDTH / 2;
      
        if (RECT_DATA && RECT_DATA.list) {
         RECT_DATA.list.forEach((rect) => {
          if (currentView.mode === "rack") return;
          
          if (rect.style === "filled") {
           const g = document.createElementNS(ns, "g");
           g.classList.add("rect-group");
           g.dataset.rectId = rect.id;
           
           const rectEl = document.createElementNS(ns, "rect");
           rectEl.classList.add("rect-shape");
           rectEl.setAttribute("x", rect.x);
           rectEl.setAttribute("y", rect.y);
           rectEl.setAttribute("width", rect.width);
           rectEl.setAttribute("height", rect.height);
           rectEl.style.fill = rect.color;
           rectEl.style.fillOpacity = "0.3";
           rectEl.style.stroke = rect.borderColor || rect.color;
           rectEl.style.strokeWidth = (rect.borderWidth !== undefined ? rect.borderWidth : 2) + "px";
           if (rect.lineStyle === "dashed") { rectEl.style.strokeDasharray = "10,5"; }
           else if (rect.lineStyle === "dotted") { rectEl.style.strokeDasharray = "2,4"; }
           else { rectEl.style.strokeDasharray = "none"; }
           rectEl.style.cursor = "move";
           
           rectEl.addEventListener("click", (e) => {
             if (rectDrawMode) return;
             e.stopPropagation();
             currentRectId = rect.id;
             selectTheRect(rect.id);
           });
           
           rectEl.addEventListener("contextmenu", (e) => {
             e.preventDefault();
             e.stopPropagation();
             if (selectedRects.has(rect.id)) {
               selectedRects.delete(rect.id);
             } else {
               selectedRects.add(rect.id);
             }
             updateAllSelections();
           });
           
           let rectLastTap = 0;
           rectEl.addEventListener("touchend", (e) => {
             const now = Date.now();
             if (now - rectLastTap < 300) {
               e.preventDefault();
               if (selectedRects.has(rect.id)) {
                 selectedRects.delete(rect.id);
               } else {
                 selectedRects.add(rect.id);
               }
               updateAllSelections();
               if (navigator.vibrate) navigator.vibrate(50);
               rectLastTap = 0;
             } else {
               rectLastTap = now;
             }
           }, { passive: false });
           
           const deleteBtn = document.createElementNS(ns, "g");
           deleteBtn.classList.add("rect-delete-btn");
           deleteBtn.style.cursor = "pointer";
           deleteBtn.style.display = rectDrawMode ? "block" : "none";
           
           const deleteBg = document.createElementNS(ns, "circle");
           deleteBg.setAttribute("cx", rect.x + rect.width - 10);
           deleteBg.setAttribute("cy", rect.y + 10);
           deleteBg.setAttribute("r", 12);
           deleteBg.style.fill = "#f56565";
           deleteBg.style.stroke = "white";
           deleteBg.style.strokeWidth = "2";
           
           const deleteX = document.createElementNS(ns, "text");
           deleteX.setAttribute("x", rect.x + rect.width - 10);
           deleteX.setAttribute("y", rect.y + 10);
           deleteX.setAttribute("text-anchor", "middle");
           deleteX.setAttribute("dominant-baseline", "middle");
           deleteX.style.fill = "white";
           deleteX.style.fontSize = "16px";
           deleteX.style.fontWeight = "bold";
           deleteX.style.pointerEvents = "none";
           deleteX.textContent = "√ó";
           
           deleteBtn.appendChild(deleteBg);
           deleteBtn.appendChild(deleteX);
           
           deleteBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            e.preventDefault();
            deleteRectangle(rect.id);
           });
           
           deleteBtn.addEventListener("touchend", (e) => {
      e.stopPropagation();
           e.preventDefault();
           deleteRectangle(rect.id);
           });
      
           let isDragging = false;
           let dragStartX, dragStartY;
           let rectStartX, rectStartY;
           
           rectEl.addEventListener("mousedown", (e) => {
      if (rectDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      rectStartX = rect.x;
      rectStartY = rect.y;
      rectEl.style.cursor = "grabbing";
      
      if (selectedRects.has(rect.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
           
      const moveHandler = (e) => {
      if (!isDragging || rectDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      rect.x = rectStartX + dx;
      rect.y = rectStartY + dy;
      if (selectedRects.has(rect.id)) {
      selectedNodes.forEach(nodeId => { if (initialPositions[nodeId]) { savedPositions[nodeId] = { x: initialPositions[nodeId].x + dx, y: initialPositions[nodeId].y + dy }; } });
      selectedRects.forEach(rectId => { if (rectId === rect.id) return; const r = RECT_DATA.list.find(x => x.id === rectId); if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; } });
      selectedTexts.forEach(textId => { const t = TEXT_DATA.list.find(x => x.id === textId); if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; } });
      selectedEdges.forEach(edgeId => { const ed = EDGE_DATA.list.find(x => x.id === edgeId); if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); } });
      }
      forgeTheTopology();
      };
           
           const upHandler = () => {
            if (isDragging) {
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           };
           
           document.addEventListener("mousemove", moveHandler);
           document.addEventListener("mouseup", upHandler);
           
           let touchStartX, touchStartY;
           let touchRectStartX, touchRectStartY;
           
           rectEl.addEventListener("touchstart", (e) => {
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchRectStartX = rect.x;
            touchRectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           }, { passive: false });
           
           rectEl.addEventListener("touchmove", (e) => {
            if (!isDragging || rectDrawMode) return;
            if (!e.touches[0]) return;
            e.preventDefault();
            e.stopPropagation();
            
            const svgEl = svg;
            const pt1 = svgEl.createSVGPoint();
            pt1.x = touchStartX;
            pt1.y = touchStartY;
            const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
            
            const touch = e.touches[0];
            const pt2 = svgEl.createSVGPoint();
            pt2.x = touch.clientX;
            pt2.y = touch.clientY;
            const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
            
            const dx = svgP2.x - svgP1.x;
            const dy = svgP2.y - svgP1.y;
            
            rect.x = touchRectStartX + dx;
            rect.y = touchRectStartY + dy;
            
            forgeTheTopology();
           }, { passive: false });
           
           rectEl.addEventListener("touchend", (e) => {
            if (isDragging) {
             e.preventDefault();
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           }, { passive: false });
            if (currentRectId === rect.id) {
      const corners = [
      { cx: rect.x, cy: rect.y, cursor: 'nwse-resize', dx: -1, dy: -1 },
      { cx: rect.x + rect.width, cy: rect.y, cursor: 'nesw-resize', dx: 1, dy: -1 },
      { cx: rect.x, cy: rect.y + rect.height, cursor: 'nesw-resize', dx: -1, dy: 1 },
      { cx: rect.x + rect.width, cy: rect.y + rect.height, cursor: 'nwse-resize', dx: 1, dy: 1 }
      ];
      corners.forEach((corner, idx) => {
      const handle = document.createElementNS(ns, "circle");
      handle.setAttribute("cx", corner.cx);
      handle.setAttribute("cy", corner.cy);
      handle.setAttribute("r", 8);
      handle.style.fill = "#f59e0b";
      handle.style.stroke = "#fff";
      handle.style.strokeWidth = "2";
      handle.style.cursor = corner.cursor;
      handle.addEventListener("mousedown", (e) => {
      e.preventDefault();
      e.stopPropagation();
      let dragging = true;
      const startX = e.clientX, startY = e.clientY;
      const origX = rect.x, origY = rect.y, origW = rect.width, origH = rect.height;
      const moveHandler = (ev) => {
        if (!dragging) return;
        const pt1 = svg.createSVGPoint(); pt1.x = startX; pt1.y = startY;
        const pt2 = svg.createSVGPoint(); pt2.x = ev.clientX; pt2.y = ev.clientY;
        const svgP1 = pt1.matrixTransform(svg.getScreenCTM().inverse());
        const svgP2 = pt2.matrixTransform(svg.getScreenCTM().inverse());
        const dx = svgP2.x - svgP1.x, dy = svgP2.y - svgP1.y;
        if (corner.dx < 0) { rect.x = origX + dx; rect.width = origW - dx; }
        else { rect.width = origW + dx; }
        if (corner.dy < 0) { rect.y = origY + dy; rect.height = origH - dy; }
        else { rect.height = origH + dy; }
        if (rect.width < 20) rect.width = 20;
        if (rect.height < 20) rect.height = 20;
        forgeTheTopology();
      };
      const upHandler = () => { dragging = false; document.removeEventListener("mousemove", moveHandler); document.removeEventListener("mouseup", upHandler); };
      document.addEventListener("mousemove", moveHandler);
      document.addEventListener("mouseup", upHandler);
      });
      g.appendChild(handle);
      });
      }
            if (rect.groupId) {
             const groupIndicator = document.createElementNS(ns, "rect");
             groupIndicator.setAttribute("x", rect.x - 4);
             groupIndicator.setAttribute("y", rect.y - 4);
             groupIndicator.setAttribute("width", rect.width + 8);
             groupIndicator.setAttribute("height", rect.height + 8);
             groupIndicator.style.fill = "none";
        groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
             groupIndicator.style.strokeWidth = "3";
             groupIndicator.style.strokeDasharray = "5,5";
             groupIndicator.style.pointerEvents = "none";
             g.insertBefore(groupIndicator, g.firstChild);
           }
           g.appendChild(rectEl);
           g.appendChild(deleteBtn);
           svg.appendChild(g);
          }
         });
        }
        const centerY = CANVAS_HEIGHT / 2;
        let positions = {};
        
        Object.keys(NODE_DATA).forEach((id) => {
         if (currentView.mode === "rack") {
          const node = NODE_DATA[id];
          if (!node || node.assignedRack !== currentView.rackId) {
           return;
          }
         }
         
         positions[id] = savedPositions[id] || {
          x: centerX,
          y: centerY
         };
        });
        if (Object.keys(savedPositions).length === 0) {
         const nodeIds = Object.keys(NODE_DATA).filter(id => {
          if (currentView.mode === "rack") {
           const node = NODE_DATA[id];
           return node && node.assignedRack === currentView.rackId;
          }
          return true;
         });
         
         const baseY = centerY - 300;
         if (nodeIds.length > 0) {
          positions[nodeIds[0]] = {
           x: centerX,
           y: baseY
          };
          const remaining = nodeIds.slice(1);
          const radius = 350;
          const startAngle = Math.PI * 0.3;
          const endAngle = Math.PI * 0.7;
          remaining.forEach((id, i) => {
           const angle = startAngle + (endAngle - startAngle) * (i / Math.max(1, remaining.length - 1));
           positions[id] = {
            x: centerX + Math.cos(angle) * radius * (i % 2 === 0 ? 1 : 1.3),
            y: baseY + 200 + Math.sin(angle) * radius * 0.8 + i * 80,
           };
          });
         }
        }
        Object.keys(positions).forEach((id) => {
         let pos = savedPositions[id] || positions[id];
         const nodeSize = savedSizes[id] || 55;
         pos.x = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, pos.x), );
         pos.y = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, pos.y), );
         positions[id] = {
          x: pos.x,
          y: pos.y
         };
         savedPositions[id] = {
          x: pos.x,
          y: pos.y
         };
        });
        const edgePairCount = {};
        const edgePairIndex = {};
        EDGE_DATA.list.forEach((edge) => {
         if (edge.type === "custom") return;
         const key = [edge.from, edge.to].sort().join("||");
         edgePairCount[key] = (edgePairCount[key] || 0) + 1;
        });
        EDGE_DATA.list.forEach((edge) => {
         if (edge.type === "custom") return;
         const key = [edge.from, edge.to].sort().join("||");
         if (!edgePairIndex[key]) edgePairIndex[key] = 0;
         edge._pairIndex = edgePairIndex[key];
         edge._pairTotal = edgePairCount[key];
         edgePairIndex[key]++;
        });
        EDGE_DATA.list.forEach((edge) => {
         if (edge.type === "custom" && Array.isArray(edge.points) && edge.points.length >= 2) {
          const customEdgeFaded = currentView.mode !== "rack" && edge.from && edge.to && (!isNodeVisible(edge.from) || !isNodeVisible(edge.to));
          const poly = document.createElementNS(ns, "polyline");
          poly.classList.add("edge");
          if (customEdgeFaded) {
           poly.style.opacity = "0.25";
           poly.classList.add("layer-faded");
          }
          poly.dataset.edgeId = edge.id;
poly.style.stroke = edge.color || PAGE_STATE.defaultEdge || "#475569";
          poly.style.strokeWidth = edge.width || 4;
          poly.setAttribute("fill", "none");
          const lineStyle = edge.lineStyle || "solid";
          if (lineStyle === "dashed") {
           poly.style.strokeDasharray = "10,5";
          } else if (lineStyle === "dotted") {
           poly.style.strokeDasharray = "2,4";
          } else {
           poly.style.strokeDasharray = "none";
          }
          const direction = edge.direction || "none";
          if (direction === "forward") {
           poly.setAttribute("marker-end", "url(#arrow-forward)");
          } else if (direction === "backward") {
           poly.setAttribute("marker-start", "url(#arrow-backward)");
          } else if (direction === "both") {
           poly.setAttribute("marker-start", "url(#arrow-backward)");
           poly.setAttribute("marker-end", "url(#arrow-forward)");
          }
          const ptsStr = edge.points.map((p) => `${p.x},${p.y}`).join(" ");
          poly.setAttribute("points", ptsStr);
          const polyHit = document.createElementNS(ns, "polyline");
          polyHit.setAttribute("points", ptsStr);
          polyHit.style.fill = "none";
          polyHit.style.stroke = "transparent";
          polyHit.style.strokeWidth = "20";
          polyHit.style.cursor = "pointer";
          polyHit.dataset.edgeId = edge.id;
          polyHit.addEventListener("click", (e) => {
           e.stopPropagation();
           selectTheConnection(edge.id);
          });
          let edgeTouchStart = null;
          let edgeTouchMoved = false;
          polyHit.addEventListener("touchstart", (e) => {
          edgeTouchStart = Date.now();
          edgeTouchMoved = false;
          if (e.touches[0]) {
           edgeTouchStartX = e.touches[0].clientX;
           edgeTouchStartY = e.touches[0].clientY;
          }
         }, {
           passive: false
          });
          let edgeTouchStartX = 0, edgeTouchStartY = 0;
         polyHit.addEventListener("touchmove", (e) => {
          if (e.touches[0]) {
           const dx = Math.abs(e.touches[0].clientX - edgeTouchStartX);
           const dy = Math.abs(e.touches[0].clientY - edgeTouchStartY);
           if (dx > 10 || dy > 10) edgeTouchMoved = true;
          }
         }, {
           passive: false
          });
          polyHit.addEventListener("touchend", (e) => {
           if (edgeTouchStart && !edgeTouchMoved && Date.now() - edgeTouchStart < 400) {
            e.stopPropagation();
            e.preventDefault();
            selectTheConnection(edge.id);
           }
           edgeTouchStart = null;
           edgeTouchMoved = false;
          }, {
           passive: false
          });
          poly.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         
         polyHit.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (selectedEdges.has(edge.id)) {
           selectedEdges.delete(edge.id);
          } else {
           selectedEdges.add(edge.id);
          }
          updateAllSelections();
         });
         
         let customEdgeLastTap = 0;
         polyHit.addEventListener("touchend", (e) => {
          const now = Date.now();
          if (now - customEdgeLastTap < 300) {
           e.preventDefault();
           if (selectedEdges.has(edge.id)) {
            selectedEdges.delete(edge.id);
           } else {
            selectedEdges.add(edge.id);
           }
           updateAllSelections();
           if (navigator.vibrate) navigator.vibrate(50);
           customEdgeLastTap = 0;
          } else {
           customEdgeLastTap = now;
          }
         }, { passive: false });
         
         poly.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (selectedEdges.has(edge.id)) {
           selectedEdges.delete(edge.id);
          } else {
           selectedEdges.add(edge.id);
          }
          updateAllSelections();
         });
         
         let edgeLastTap = 0;
         poly.addEventListener("touchend", (e) => {
          const now = Date.now();
          if (now - edgeLastTap < 300) {
           e.preventDefault();
           if (selectedEdges.has(edge.id)) {
            selectedEdges.delete(edge.id);
           } else {
            selectedEdges.add(edge.id);
           }
           updateAllSelections();
           if (navigator.vibrate) navigator.vibrate(50);
           edgeLastTap = 0;
          } else {
           edgeLastTap = now;
          }
         });
          
          if (currentView.mode === "rack") {
           return;
          }
          if (edge.groupId) {
      const bounds = edge.points.reduce((acc, p) => ({ minX: Math.min(acc.minX, p.x), minY: Math.min(acc.minY, p.y), maxX: Math.max(acc.maxX, p.x), maxY: Math.max(acc.maxY, p.y) }), { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity });
      const groupIndicator = document.createElementNS(ns, "rect");
      groupIndicator.setAttribute("x", bounds.minX - 8);
      groupIndicator.setAttribute("y", bounds.minY - 8);
      groupIndicator.setAttribute("width", bounds.maxX - bounds.minX + 16);
      groupIndicator.setAttribute("height", bounds.maxY - bounds.minY + 16);
      groupIndicator.setAttribute("rx", "4");
      groupIndicator.style.fill = "none";
  groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
      groupIndicator.style.strokeWidth = "3";
      groupIndicator.style.strokeDasharray = "5,5";
      groupIndicator.style.pointerEvents = "none";
      svg.appendChild(groupIndicator);
      }
         let lineDragging = false;
      let lineDragStartX, lineDragStartY;
      let linePointsStart = [];
      
      polyHit.addEventListener("mousedown", (e) => {
      if (freeDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      lineDragging = true;
      lineDragStartX = e.clientX;
      lineDragStartY = e.clientY;
      linePointsStart = edge.points.map(p => ({x: p.x, y: p.y}));
      
      if (selectedEdges.has(edge.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
      
      const lineMoveHandler = (e) => {
      if (!lineDragging || freeDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = lineDragStartX;
      pt1.y = lineDragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      
      edge.points.forEach((p, i) => { p.x = linePointsStart[i].x + dx; p.y = linePointsStart[i].y + dy; });
      
      if (selectedEdges.has(edge.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       savedPositions[nodeId] = { x: initialPositions[nodeId].x + dx, y: initialPositions[nodeId].y + dy };
      }
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      if (edgeId === edge.id) return;
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      forgeTheTopology();
      };
      
      const lineUpHandler = () => { lineDragging = false; };
      document.addEventListener("mousemove", lineMoveHandler);
      document.addEventListener("mouseup", lineUpHandler);
      
      svg.appendChild(poly);
      svg.appendChild(polyHit);
         
         if (currentEdgeId === edge.id) {
          edge.points.forEach((p, idx) => {
           const c = document.createElementNS(ns, "circle");
           c.classList.add("edge-edit-point");
           c.setAttribute("cx", p.x);
           c.setAttribute("cy", p.y);
c.setAttribute("r", PAGE_STATE.selectionHandleSize || 8);
           c.style.fill = PAGE_STATE.selectionHandle || "#f59e0b";
           c.style.stroke = "#fff";
           c.style.strokeWidth = "2";
           c.style.cursor = "move";
           c.dataset.edgeId = edge.id;
           c.dataset.pointIndex = String(idx);
           
           c.addEventListener("mousedown", (e) => {
            e.preventDefault();
            e.stopPropagation();
            let dragging = true;
            const svgEl = svg;
            const moveHandler = (ev) => {
             if (!dragging) return;
             const pt = svgEl.createSVGPoint();
             pt.x = ev.clientX;
             pt.y = ev.clientY;
             const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
             edge.points[idx].x = svgP.x;
             edge.points[idx].y = svgP.y;
             forgeTheTopology();
            };
            const upHandler = () => {
             dragging = false;
             document.removeEventListener("mousemove", moveHandler);
             document.removeEventListener("mouseup", upHandler);
            };
            document.addEventListener("mousemove", moveHandler);
            document.addEventListener("mouseup", upHandler);
           });
           
           c.addEventListener("touchstart", (e) => {
            e.preventDefault();
            e.stopPropagation();
            let dragging = true;
            const svgEl = svg;
            const touchMoveHandler = (ev) => {
             if (!dragging || !ev.touches[0]) return;
             const pt = svgEl.createSVGPoint();
             pt.x = ev.touches[0].clientX;
             pt.y = ev.touches[0].clientY;
             const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
             edge.points[idx].x = svgP.x;
             edge.points[idx].y = svgP.y;
             forgeTheTopology();
            };
            const touchUpHandler = () => {
             dragging = false;
             document.removeEventListener("touchmove", touchMoveHandler);
             document.removeEventListener("touchend", touchUpHandler);
            };
            document.addEventListener("touchmove", touchMoveHandler);
            document.addEventListener("touchend", touchUpHandler);
           }, { passive: false });
           
           svg.appendChild(c);
          });
         }
         
         return;
         }
         const p1 = positions[edge.from];
         const p2 = positions[edge.to];
         if (!p1 || !p2) return;
         const edgeFaded = currentView.mode !== "rack" && (!isNodeVisible(edge.from) || !isNodeVisible(edge.to));
         const pairTotal = edge._pairTotal || 1;
         const pairIndex = edge._pairIndex || 0;
         const midX = (p1.x + p2.x) / 2;
         const midY = (p1.y + p2.y) / 2;
         const dx = p2.x - p1.x;
         const dy = p2.y - p1.y;
         const len = Math.sqrt(dx * dx + dy * dy) || 1;
         const perpX = -dy / len;
         const perpY = dx / len;
         let offsetAmount = 0;
         if (pairTotal > 1) {
          offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
         }
         const ctrlX = midX + perpX * offsetAmount;
         const ctrlY = midY + perpY * offsetAmount;
         const path = document.createElementNS(ns, "path");
         path.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
         path.setAttribute("fill", "none");
         path.classList.add("edge");
         if (edgeFaded) {
          path.style.opacity = "0.25";
          path.classList.add("layer-faded");
         }
         if (edge.type === "backup") path.classList.add("backup");
         path.dataset.edgeId = edge.id;
         path.dataset.from = edge.from;
         path.dataset.to = edge.to;
         path.style.stroke = edge.color;
         path.style.strokeWidth = edge.width;
         const pathHit = document.createElementNS(ns, "path");
         pathHit.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
         pathHit.setAttribute("fill", "none");
         pathHit.style.stroke = "transparent";
         pathHit.style.strokeWidth = "20";
         pathHit.style.cursor = "pointer";
         pathHit.dataset.edgeId = edge.id;
         pathHit.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         let pathTouchStart = null;
         let pathTouchMoved = false;
         pathHit.addEventListener("touchstart", (e) => {
         pathTouchStart = Date.now();
         pathTouchMoved = false;
         if (e.touches[0]) {
          pathTouchStartX = e.touches[0].clientX;
          pathTouchStartY = e.touches[0].clientY;
         }
        }, {
          passive: false
         });
         let pathTouchStartX = 0, pathTouchStartY = 0;
        pathHit.addEventListener("touchmove", (e) => {
         if (e.touches[0]) {
          const dx = Math.abs(e.touches[0].clientX - pathTouchStartX);
          const dy = Math.abs(e.touches[0].clientY - pathTouchStartY);
          if (dx > 10 || dy > 10) pathTouchMoved = true;
         }
        }, {
          passive: false
         });
         pathHit.addEventListener("touchend", (e) => {
          if (pathTouchStart && !pathTouchMoved && Date.now() - pathTouchStart < 400) {
           e.stopPropagation();
           e.preventDefault();
           selectTheConnection(edge.id);
          }
          pathTouchStart = null;
          pathTouchMoved = false;
         }, {
          passive: false
         });
         path.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         
         if (currentView.mode === "rack") {
          const fromNode = NODE_DATA[edge.from];
          const toNode = NODE_DATA[edge.to];
          if (!fromNode || !toNode || 
              fromNode.assignedRack !== currentView.rackId || 
              toNode.assignedRack !== currentView.rackId) {
           return;
          }
         }
         
         svg.appendChild(path);
         svg.appendChild(pathHit);
         
         if (edge.fromPort || edge.toPort) {
          const ns = "http://www.w3.org/2000/svg";
          
          if (edge.fromPort) {
           const fromLabel = document.createElementNS(ns, "text");
           fromLabel.textContent = edge.fromPort;
           fromLabel.setAttribute("x", p1.x);
           fromLabel.setAttribute("y", p1.y - 10);
           fromLabel.setAttribute("text-anchor", "middle");
           fromLabel.style.fill = "#94a3b8";
           fromLabel.style.fontSize = "12px";
           fromLabel.style.fontWeight = "600";
           fromLabel.style.pointerEvents = "none";
           fromLabel.classList.add("port-label");
           svg.appendChild(fromLabel);
          }
      
          if (edge.toPort) {
           const toLabel = document.createElementNS(ns, "text");
           toLabel.textContent = edge.toPort;
           toLabel.setAttribute("x", p2.x);
           toLabel.setAttribute("y", p2.y - 10);
           toLabel.setAttribute("text-anchor", "middle");
           toLabel.style.fill = "#94a3b8";
           toLabel.style.fontSize = "12px";
           toLabel.style.fontWeight = "600";
           toLabel.style.pointerEvents = "none";
           toLabel.classList.add("port-label");
           svg.appendChild(toLabel);
          }
         }
        });
        Object.entries(positions).forEach(([id, pos]) => {
         const node = NODE_DATA[id];
         if (!node) return;
         
         if (currentView.mode === "rack") {
          if (node.assignedRack !== currentView.rackId) return;
          
         const rackUnit = parseInt(node.rackUnit) || 1;
      const uHeight = parseInt(node.uHeight) || 1;
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      pos.x = RACK_START_X;
      pos.y = RACK_START_Y + (rackCapacity - rackUnit - uHeight + 1) * rackUHeight + (uHeight * rackUHeight) / 2;
         } else {
          if (node.assignedRack) return;
         }
         
         const g = document.createElementNS("http://www.w3.org/2000/svg", "g", );
         g.classList.add("node-group");
         g.dataset.nodeId = id;
         g.setAttribute("transform", `translate(${pos.x},${pos.y})`);
         if (currentView.mode !== "rack" && !isNodeVisible(id)) {
          g.style.opacity = "0.25";
          g.classList.add("layer-faded");
         }
         let r = savedSizes[id] || 55;
         if (!savedSizes[id]) {
          if (window.innerWidth <= 380) r = 120;
          else if (window.innerWidth <= 768) r = 140;
          else if (window.innerWidth <= 1024) r = 70;
         }
         const styles = resolveStylesForNode(id);
         const ns = "http://www.w3.org/2000/svg";
         const hitArea = document.createElementNS(ns, "circle");
         hitArea.setAttribute("r", r * 1.5);
         hitArea.style.fill = "transparent";
         hitArea.style.stroke = "none";
         hitArea.style.cursor = "grab";
         hitArea.classList.add("node-hit-area");
         const shapeEl = createNodeShape(id, r);
         const titleOffsetX = styles.titleOffsetX || 0;
         const titleOffsetY = styles.titleOffsetY || 0;
         const subOffsetX = styles.subOffsetX || 0;
         const subOffsetY = styles.subOffsetY || 0;
         const label = document.createElementNS("http://www.w3.org/2000/svg", "text", );
         label.classList.add("node-label");
         label.setAttribute("x", titleOffsetX);
         label.setAttribute("y", -r * 0.28 + titleOffsetY);
         const labelFontSize = styles.titleSize || PAGE_STATE.nodeTitleSize || r * 0.33;
        label.style.fontSize = labelFontSize + "px";
         label.textContent = NODE_DATA[id].name;
label.style.fill = styles.titleColor || PAGE_STATE.nodeTitle || "#e2e8f0";
        label.style.fontFamily = styles.titleFont || PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
         label.style.pointerEvents = "none";
         const sub = document.createElementNS("http://www.w3.org/2000/svg", "text", );
         sub.classList.add("node-sub");
         sub.setAttribute("x", subOffsetX);
         sub.setAttribute("y", r * 0.4 + subOffsetY);
         const subFontSize = styles.subSize || PAGE_STATE.nodeSubSize || r * 0.24;
        sub.style.fontSize = subFontSize + "px";
         sub.textContent = NODE_DATA[id].ip;
sub.style.fill = styles.subColor || PAGE_STATE.nodeSub || "#94a3b8";
        sub.style.fontFamily = styles.subFont || PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
         sub.style.pointerEvents = "none";
         g.append(hitArea, shapeEl, label, sub);
         
         if (NODE_DATA[id]?.locked) {
           const lockIndicator = document.createElementNS(ns, "text");
           lockIndicator.textContent = "üîí";
           lockIndicator.setAttribute("x", r * 0.7);
           lockIndicator.setAttribute("y", -r * 0.7);
           lockIndicator.style.fontSize = (r * 0.3) + "px";
           lockIndicator.style.pointerEvents = "none";
           lockIndicator.classList.add("lock-indicator");
           g.appendChild(lockIndicator);
         }
         
         if (NODE_DATA[id]?.groupId) {
           const groupIndicator = document.createElementNS(ns, "circle");
           groupIndicator.setAttribute("r", r + 4);
           groupIndicator.style.fill = "none";
         groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
           groupIndicator.style.strokeWidth = "3";
           groupIndicator.style.strokeDasharray = "5,5";
           groupIndicator.style.pointerEvents = "none";
           groupIndicator.classList.add("group-indicator");
           
           g.insertBefore(groupIndicator, g.firstChild);
         }
         
         let isDragging = false;
         let startX, startY;
         let initialPositions = {};
         let longPressTimer = null;
         let longPressTriggered = false;
         
         g.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          e.stopPropagation();
          
          if (selectedNodes.has(id)) {
           selectedNodes.delete(id);
          } else {
           selectedNodes.add(id);
          }
          updateNodeSelection();
          return false;
         });
         
        g.addEventListener("touchstart", (e) => {
         if (NODE_DATA[id].isRack) {
          const touch = e.touches[0];
          longPressStartX = touch.clientX;
          longPressStartY = touch.clientY;
          longPressTimer = setTimeout(() => {
           longPressTriggered = true;
           if (navigator.vibrate) {
            navigator.vibrate(100);
           }
           enterRack(id);
          }, 500);
         }
        }, { passive: true });
        
        g.addEventListener("dblclick", (e) => {
         e.preventDefault();
         e.stopPropagation();
         if (NODE_DATA[id].isRack) {
          enterRack(id);
         }
        });
        
        let lastTapTime = 0;
        let lastTapNode = null;
        
        g.addEventListener("touchend", (e) => {
         const currentTime = new Date().getTime();
         const tapLength = currentTime - lastTapTime;
         
         if (tapLength < 300 && tapLength > 0 && lastTapNode === id) {
          e.preventDefault();
          e.stopPropagation();
          
          if (selectedNodes.has(id)) {
           selectedNodes.delete(id);
          } else {
           selectedNodes.add(id);
          }
          updateNodeSelection();
          
          if (navigator.vibrate) {
           navigator.vibrate(50);
          }
          
          lastTapTime = 0;
          lastTapNode = null;
         } else {
          lastTapTime = currentTime;
          lastTapNode = id;
         }
        });
         
         g.addEventListener("touchend", (e) => {
          if (longPressTimer) {
           clearTimeout(longPressTimer);
           longPressTimer = null;
          }
          if (longPressTriggered) {
           e.preventDefault();
           e.stopPropagation();
           longPressTriggered = false;
          }
         });
         
         let longPressStartX = 0;
        let longPressStartY = 0;
        g.addEventListener("touchmove", (e) => {
         if (longPressTimer) {
          const touch = e.touches[0];
          const dx = Math.abs(touch.clientX - longPressStartX);
          const dy = Math.abs(touch.clientY - longPressStartY);
          if (dx > 15 || dy > 15) {
           clearTimeout(longPressTimer);
           longPressTimer = null;
           longPressTriggered = false;
          }
         }
        });
         
         g.addEventListener("mousedown", (e) => {
          if (e.button === 2) {
           return;
          }
          
          if (NODE_DATA[id]?.locked) {
           return;
          }
          
          e.preventDefault();
          isDragging = true;
          const svgEl = document.getElementById("map");
          const pt = svgEl.createSVGPoint();
          pt.x = e.clientX;
          pt.y = e.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          startX = svgP.x;
          startY = svgP.y;
          
          let nodesToCollect = [];
      
      
      if (selectedNodes.has(id)) {
      initialPositions = {};
      const allSelectedRects = Array.from(selectedRects);
      const allSelectedTexts = Array.from(selectedTexts);
      const allSelectedEdges = Array.from(selectedEdges).map(eid => EDGE_DATA.list.find(e => e.id === eid)).filter(Boolean);
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) {
      initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      }
      });
      Array.from(selectedRects).forEach(rectId => {
        const rect = RECT_DATA.list.find(r => r.id === rectId);
        if (rect) { rect._dragStartX = rect.x; rect._dragStartY = rect.y; }
      });
      Array.from(selectedTexts).forEach(textId => {
        const text = TEXT_DATA.list.find(t => t.id === textId);
        if (text) { text._dragStartX = text.x; text._dragStartY = text.y; }
      });
      Array.from(selectedEdges).forEach(edgeId => {
        const edge = EDGE_DATA.list.find(e => e.id === edgeId);
        if (edge && edge.points) { edge._dragStartPoints = edge.points.map(p => ({x: p.x, y: p.y})); }
      });
      
      
      } else {
      initialPositions = { [id]: { x: pos.x, y: pos.y } };
      }
          
          const groupIds = new Set();
          nodesToCollect.forEach(nodeId => {
           const groupId = NODE_DATA[nodeId]?.groupId;
           if (groupId) {
             groupIds.add(groupId);
           }
          });
          
          if (groupIds.size > 0) {
           Object.keys(NODE_DATA).forEach(nodeId => {
             const nodeGroupId = NODE_DATA[nodeId]?.groupId;
             if (nodeGroupId && groupIds.has(nodeGroupId)) {
               if (!nodesToCollect.includes(nodeId)) {
                 nodesToCollect.push(nodeId);
               }
             }
           });
          }
          
          nodesToCollect = nodesToCollect.filter(nodeId => !NODE_DATA[nodeId]?.locked);
          
          if (nodesToCollect.length === 0) {
           return;
          }
          
          initialPositions = {};
          nodesToCollect.forEach(nodeId => {
           const nodePos = savedPositions[nodeId];
           if (nodePos) {
            initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
           }
          });
          
          g.style.cursor = "grabbing";
          hitArea.style.cursor = "grabbing";
          e.stopPropagation();
         });
         const handleMouseMove = (e) => {
          if (!isDragging) return;
          e.preventDefault();
          const svgEl = document.getElementById("map");
          const pt = svgEl.createSVGPoint();
          pt.x = e.clientX;
          pt.y = e.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          const dx = svgP.x - startX;
          const dy = svgP.y - startY;
          
          const nodesToMove = selectedNodes.has(id) ? Array.from(selectedNodes) : [id];
          nodesToMove.forEach(nodeId => {
           if (!initialPositions[nodeId]) return;
           const initialPos = initialPositions[nodeId];
           let newX = initialPos.x + dx;
           let newY = initialPos.y + dy;
           const nodeSize = savedSizes[nodeId] || 55;
           newX = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, newX), );
           newY = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, newY), );
           
           savedPositions[nodeId] = { x: newX, y: newY };
           positions[nodeId] = { x: newX, y: newY };
           
           if (nodeId === id) {
            pos.x = newX;
            pos.y = newY;
           }
           
           const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
          if (nodeGroup) {
           nodeGroup.setAttribute("transform", `translate(${newX},${newY})`);
          }
         });
         
         Array.from(selectedRects).forEach(rectId => {
           const rect = RECT_DATA.list.find(r => r.id === rectId);
           if (rect && rect._dragStartX !== undefined) {
             rect.x = rect._dragStartX + dx;
             rect.y = rect._dragStartY + dy;
           }
         });
         Array.from(selectedTexts).forEach(textId => {
           const text = TEXT_DATA.list.find(t => t.id === textId);
           if (text && text._dragStartX !== undefined) {
             text.x = text._dragStartX + dx;
             text.y = text._dragStartY + dy;
           }
         });
         Array.from(selectedEdges).forEach(edgeId => {
           const edge = EDGE_DATA.list.find(e => e.id === edgeId);
           if (edge && edge._dragStartPoints) {
             edge.points.forEach((p, i) => {
               p.x = edge._dragStartPoints[i].x + dx;
               p.y = edge._dragStartPoints[i].y + dy;
             });
           }
         });
         forgeTheTopology();
         
         updateMinimap();
          document.querySelectorAll(".edge").forEach((edgeEl) => {
           const fromId = edgeEl.dataset.from;
           const toId = edgeEl.dataset.to;
           if (nodesToMove.includes(fromId) || nodesToMove.includes(toId)) {
            const p1 = savedPositions[fromId] || positions[fromId] || {
             x: 600,
             y: 350
            };
            const p2 = savedPositions[toId] || positions[toId] || {
             x: 600,
             y: 350
            };
            if (edgeEl.tagName === "line") {
             edgeEl.setAttribute("x1", p1.x);
             edgeEl.setAttribute("y1", p1.y);
             edgeEl.setAttribute("x2", p2.x);
             edgeEl.setAttribute("y2", p2.y);
            } else if (edgeEl.tagName === "path") {
             const edgeId = edgeEl.dataset.edgeId;
             const edge = EDGE_DATA.list.find(
              (e) => e.id === edgeId, );
             if (edge) {
              const pairTotal = edge._pairTotal || 1;
              const pairIndex = edge._pairIndex || 0;
              const midX = (p1.x + p2.x) / 2;
              const midY = (p1.y + p2.y) / 2;
              const dx = p2.x - p1.x;
              const dy = p2.y - p1.y;
              const len = Math.sqrt(dx * dx + dy * dy) || 1;
              const perpX = -dy / len;
              const perpY = dx / len;
              let offsetAmount = 0;
              if (pairTotal > 1) {
               offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
              }
              const ctrlX = midX + perpX * offsetAmount;
              const ctrlY = midY + perpY * offsetAmount;
              edgeEl.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
             }
            }
           }
          });
         };
      const handleMouseUp = () => {
      if (isDragging) {
      pushUndo("move nodes");
      isDragging = false;
      g.style.cursor = "grab";
      hitArea.style.cursor = "grab";
      if (currentView.mode === "rack" && NODE_DATA[id]?.assignedRack === currentView.rackId) {
      const draggedY = savedPositions[id]?.y || pos.y;
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      let newUnit = rackCapacity - Math.round((draggedY - RACK_START_Y) / rackUHeight);
      newUnit = Math.max(1, Math.min(newUnit, rackCapacity));
      NODE_DATA[id].rackUnit = newUnit;
      forgeTheTopology();
      claimTheImmortal(id);
      }
      }
      };
         document.addEventListener("mousemove", handleMouseMove);
         document.addEventListener("mouseup", handleMouseUp);
         let touchStartTime = 0;
         let touchStartX = 0;
         let touchStartY = 0;
         let touchMoved = false;
       g.addEventListener("touchstart",
         (e) => {
          if (NODE_DATA[id]?.locked) {
           return;
          }
          
          e.preventDefault();
          touchStartTime = Date.now();
          touchMoved = false;
          const svgEl = document.getElementById("map");
          const pt = svgEl.createSVGPoint();
          const touch = e.touches[0];
          pt.x = touch.clientX;
          pt.y = touch.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          touchStartX = svgP.x;
          touchStartY = svgP.y;
          startX = svgP.x;
          startY = svgP.y;
          
          let nodesToCollect = [];
          if (selectedNodes.has(id)) {
           nodesToCollect = Array.from(selectedNodes);
          } else {
           nodesToCollect = [id];
          }
          
          const groupIds = new Set();
          nodesToCollect.forEach(nodeId => {
           const groupId = NODE_DATA[nodeId]?.groupId;
           if (groupId) {
             groupIds.add(groupId);
           }
          });
          
          if (groupIds.size > 0) {
           Object.keys(NODE_DATA).forEach(nodeId => {
             const nodeGroupId = NODE_DATA[nodeId]?.groupId;
             if (nodeGroupId && groupIds.has(nodeGroupId)) {
               if (!nodesToCollect.includes(nodeId)) {
                 nodesToCollect.push(nodeId);
               }
             }
           });
          }
          
          nodesToCollect = nodesToCollect.filter(nodeId => !NODE_DATA[nodeId]?.locked);
          
          if (nodesToCollect.length === 0) {
           return;
          }
          
          initialPositions = {};
          nodesToCollect.forEach(nodeId => {
           const nodePos = savedPositions[nodeId];
           if (nodePos) {
            initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
           }
          });
          
          e.stopPropagation();
         }, {
          passive: false
         }, );
         g.addEventListener("touchmove", (e) => {
         e.preventDefault();
         const svgEl = document.getElementById("map");
         const pt = svgEl.createSVGPoint();
         const touch = e.touches[0];
         pt.x = touch.clientX;
         pt.y = touch.clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
         const dx = Math.abs(svgP.x - touchStartX);
         const dy = Math.abs(svgP.y - touchStartY);
         if (dx > (isMobileDevice() ? 4 : 10) || dy > (isMobileDevice() ? 4 : 10)) {
      touchMoved = true;
      isDragging = true;
      }
         if (!isDragging) return;
         
         const deltaX = svgP.x - startX;
         const deltaY = svgP.y - startY;
         
         const nodesToMove = selectedNodes.has(id) ? Array.from(selectedNodes) : [id];
         nodesToMove.forEach(nodeId => {
          if (!initialPositions[nodeId]) return;
          const initialPos = initialPositions[nodeId];
          let newX = initialPos.x + deltaX;
          let newY = initialPos.y + deltaY;
          const nodeSize = savedSizes[nodeId] || 55;
          newX = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, newX), );
          newY = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, newY), );
          
          savedPositions[nodeId] = { x: newX, y: newY };
          positions[nodeId] = { x: newX, y: newY };
          
          if (nodeId === id) {
           pos.x = newX;
           pos.y = newY;
          }
          
          const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
          if (nodeGroup) {
           nodeGroup.setAttribute("transform", `translate(${newX},${newY})`);
          }
         });
         
         updateMinimap();
         document.querySelectorAll(".edge").forEach((edgeEl) => {
          const fromId = edgeEl.dataset.from;
          const toId = edgeEl.dataset.to;
          if (nodesToMove.includes(fromId) || nodesToMove.includes(toId)) {
            const p1 = savedPositions[fromId] || positions[fromId] || {
             x: 600,
             y: 350
            };
            const p2 = savedPositions[toId] || positions[toId] || {
             x: 600,
             y: 350
            };
            if (edgeEl.tagName === "line") {
             edgeEl.setAttribute("x1", p1.x);
             edgeEl.setAttribute("y1", p1.y);
             edgeEl.setAttribute("x2", p2.x);
             edgeEl.setAttribute("y2", p2.y);
            } else if (edgeEl.tagName === "path") {
             const edgeId = edgeEl.dataset.edgeId;
             const edge = EDGE_DATA.list.find(
              (e) => e.id === edgeId, );
             if (edge) {
              const pairTotal = edge._pairTotal || 1;
              const pairIndex = edge._pairIndex || 0;
              const midX = (p1.x + p2.x) / 2;
              const midY = (p1.y + p2.y) / 2;
              const dx = p2.x - p1.x;
              const dy = p2.y - p1.y;
              const len = Math.sqrt(dx * dx + dy * dy) || 1;
              const perpX = -dy / len;
              const perpY = dx / len;
              let offsetAmount = 0;
              if (pairTotal > 1) {
               offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
              }
              const ctrlX = midX + perpX * offsetAmount;
              const ctrlY = midY + perpY * offsetAmount;
              edgeEl.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
             }
            }
           }
          });
         }, {
          passive: false
         });
      g.addEventListener("touchend", (e) => {
      const touchDuration = Date.now() - touchStartTime;
      if (!touchMoved && touchDuration < 400) {
      claimTheImmortal(id);
      }
      if (isDragging) {
      const draggedY = pos.y;
      isDragging = false;
      savedPositions[id] = {
      x: pos.x,
      y: pos.y
      };
      if (currentView.mode === "rack" && NODE_DATA[id]?.assignedRack === currentView.rackId) {
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      let newUnit = rackCapacity - Math.round((draggedY - RACK_START_Y) / rackUHeight);
      newUnit = Math.max(1, Math.min(newUnit, rackCapacity));
      NODE_DATA[id].rackUnit = newUnit;
      forgeTheTopology();
      claimTheImmortal(id);
      }
      }
      touchMoved = false;
      });
         g.style.cursor = "grab";
         g.addEventListener("click", (e) => {
          if (!isDragging) {
           claimTheImmortal(id);
          }
         });
         svg.appendChild(g);
        });
        
        if (RECT_DATA && RECT_DATA.list) {
         RECT_DATA.list.forEach((rect) => {
          if (currentView.mode === "rack") return;
          if (rect.style === "outlined") {
           const g = document.createElementNS(ns, "g");
           g.classList.add("rect-group");
           g.dataset.rectId = rect.id;
           
           const rectEl = document.createElementNS(ns, "rect");
           rectEl.classList.add("rect-shape");
           rectEl.setAttribute("x", rect.x);
           rectEl.setAttribute("y", rect.y);
           rectEl.setAttribute("width", rect.width);
           rectEl.setAttribute("height", rect.height);
           rectEl.style.fill = "none";
           rectEl.style.stroke = rect.borderColor || rect.color;
           rectEl.style.strokeWidth = (rect.borderWidth !== undefined ? rect.borderWidth : 3) + "px";
      if (rect.lineStyle === "dashed") { rectEl.style.strokeDasharray = "10,5"; }
           else if (rect.lineStyle === "dotted") { rectEl.style.strokeDasharray = "2,4"; }
           else { rectEl.style.strokeDasharray = "none"; }
           rectEl.style.cursor = "move";
           
           rectEl.addEventListener("click", (e) => {
             if (rectDrawMode) return;
             e.stopPropagation();
             currentRectId = rect.id;
             selectTheRect(rect.id);
           });
           
           rectEl.addEventListener("contextmenu", (e) => {
             e.preventDefault();
             e.stopPropagation();
             if (selectedRects.has(rect.id)) {
               selectedRects.delete(rect.id);
             } else {
               selectedRects.add(rect.id);
             }
             updateAllSelections();
           });
           
           let rectLastTap = 0;
           rectEl.addEventListener("touchend", (e) => {
             const now = Date.now();
             if (now - rectLastTap < 300) {
               e.preventDefault();
               if (selectedRects.has(rect.id)) {
                 selectedRects.delete(rect.id);
               } else {
                 selectedRects.add(rect.id);
               }
               updateAllSelections();
               if (navigator.vibrate) navigator.vibrate(50);
               rectLastTap = 0;
             } else {
               rectLastTap = now;
             }
           }, { passive: false });
           
           const deleteBtn = document.createElementNS(ns, "g");
           deleteBtn.classList.add("rect-delete-btn");
           deleteBtn.style.cursor = "pointer";
           deleteBtn.style.display = rectDrawMode ? "block" : "none";
           
           const deleteBg = document.createElementNS(ns, "circle");
           deleteBg.setAttribute("cx", rect.x + rect.width - 10);
           deleteBg.setAttribute("cy", rect.y + 10);
           deleteBg.setAttribute("r", 12);
           deleteBg.style.fill = "#f56565";
           deleteBg.style.stroke = "white";
           deleteBg.style.strokeWidth = "2";
           
           const deleteX = document.createElementNS(ns, "text");
           deleteX.setAttribute("x", rect.x + rect.width - 10);
           deleteX.setAttribute("y", rect.y + 10);
           deleteX.setAttribute("text-anchor", "middle");
           deleteX.setAttribute("dominant-baseline", "middle");
           deleteX.style.fill = "white";
           deleteX.style.fontSize = "16px";
           deleteX.style.fontWeight = "bold";
           deleteX.style.pointerEvents = "none";
           deleteX.textContent = "√ó";
           
           deleteBtn.appendChild(deleteBg);
           deleteBtn.appendChild(deleteX);
           
           deleteBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            e.preventDefault();
            deleteRectangle(rect.id);
           });
           
           let isDragging = false;
           let dragStartX, dragStartY;
           let rectStartX, rectStartY;
           
           rectEl.addEventListener("mousedown", (e) => {
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            dragStartX = e.clientX;
            dragStartY = e.clientY;
            rectStartX = rect.x;
            rectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           });
           
      const moveHandler = (e) => {
      if (!isDragging || rectDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      rect.x = rectStartX + dx;
      rect.y = rectStartY + dy;
      if (selectedRects.has(rect.id)) {
      selectedNodes.forEach(nodeId => { if (initialPositions[nodeId]) { savedPositions[nodeId] = { x: initialPositions[nodeId].x + dx, y: initialPositions[nodeId].y + dy }; } });
      selectedRects.forEach(rectId => { if (rectId === rect.id) return; const r = RECT_DATA.list.find(x => x.id === rectId); if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; } });
      selectedTexts.forEach(textId => { const t = TEXT_DATA.list.find(x => x.id === textId); if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; } });
      selectedEdges.forEach(edgeId => { const ed = EDGE_DATA.list.find(x => x.id === edgeId); if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); } });
      }
      forgeTheTopology();
      };
           
           const upHandler = () => {
            if (isDragging) {
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           };
           
           document.addEventListener("mousemove", moveHandler);
           document.addEventListener("mouseup", upHandler);
           
           let touchStartX, touchStartY;
           let touchRectStartX, touchRectStartY;
           
           rectEl.addEventListener("touchstart", (e) => {
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchRectStartX = rect.x;
            touchRectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           }, { passive: false });
           
           rectEl.addEventListener("touchmove", (e) => {
            if (!isDragging || rectDrawMode) return;
            if (!e.touches[0]) return;
            e.preventDefault();
            e.stopPropagation();
            
            const svgEl = svg;
            const pt1 = svgEl.createSVGPoint();
            pt1.x = touchStartX;
            pt1.y = touchStartY;
            const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
            
            const touch = e.touches[0];
            const pt2 = svgEl.createSVGPoint();
            pt2.x = touch.clientX;
            pt2.y = touch.clientY;
            const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
            
            const dx = svgP2.x - svgP1.x;
            const dy = svgP2.y - svgP1.y;
            
            rect.x = touchRectStartX + dx;
            rect.y = touchRectStartY + dy;
            
            forgeTheTopology();
           }, { passive: false });
           
           rectEl.addEventListener("touchend", (e) => {
            if (isDragging) {
             e.preventDefault();
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           }, { passive: false });
           
           if (currentRectId === rect.id) {
             const corners = [
               { cx: rect.x, cy: rect.y, cursor: 'nwse-resize', dx: -1, dy: -1 },
               { cx: rect.x + rect.width, cy: rect.y, cursor: 'nesw-resize', dx: 1, dy: -1 },
               { cx: rect.x, cy: rect.y + rect.height, cursor: 'nesw-resize', dx: -1, dy: 1 },
               { cx: rect.x + rect.width, cy: rect.y + rect.height, cursor: 'nwse-resize', dx: 1, dy: 1 }
             ];
             corners.forEach((corner) => {
               const handle = document.createElementNS(ns, "circle");
               handle.setAttribute("cx", corner.cx);
               handle.setAttribute("cy", corner.cy);
handle.setAttribute("r", PAGE_STATE.selectionHandleSize || 8);
      handle.style.fill = PAGE_STATE.selectionHandle || "#f59e0b";
               handle.style.stroke = "#fff";
               handle.style.strokeWidth = "2";
               handle.style.cursor = corner.cursor;
               handle.addEventListener("mousedown", (e) => {
                 e.preventDefault();
                 e.stopPropagation();
                 let dragging = true;
                 const startX = e.clientX, startY = e.clientY;
                 const origX = rect.x, origY = rect.y, origW = rect.width, origH = rect.height;
                 const moveHandler = (ev) => {
                   if (!dragging) return;
                   const pt1 = svg.createSVGPoint(); pt1.x = startX; pt1.y = startY;
                   const pt2 = svg.createSVGPoint(); pt2.x = ev.clientX; pt2.y = ev.clientY;
                   const svgP1 = pt1.matrixTransform(svg.getScreenCTM().inverse());
                   const svgP2 = pt2.matrixTransform(svg.getScreenCTM().inverse());
                   const dx = svgP2.x - svgP1.x, dy = svgP2.y - svgP1.y;
                   if (corner.dx < 0) { rect.x = origX + dx; rect.width = origW - dx; }
                   else { rect.width = origW + dx; }
                   if (corner.dy < 0) { rect.y = origY + dy; rect.height = origH - dy; }
                   else { rect.height = origH + dy; }
                   if (rect.width < 20) rect.width = 20;
                   if (rect.height < 20) rect.height = 20;
                   forgeTheTopology();
                 };
                 const upHandler = () => { dragging = false; document.removeEventListener("mousemove", moveHandler); document.removeEventListener("mouseup", upHandler); };
                 document.addEventListener("mousemove", moveHandler);
                 document.addEventListener("mouseup", upHandler);
               });
               g.appendChild(handle);
             });
           }
           if (rect.groupId) {
             const groupIndicator = document.createElementNS(ns, "rect");
             groupIndicator.setAttribute("x", rect.x - 4);
             groupIndicator.setAttribute("y", rect.y - 4);
             groupIndicator.setAttribute("width", rect.width + 8);
             groupIndicator.setAttribute("height", rect.height + 8);
             groupIndicator.style.fill = "none";
         groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
             groupIndicator.style.strokeWidth = "3";
             groupIndicator.style.strokeDasharray = "5,5";
             groupIndicator.style.pointerEvents = "none";
             g.insertBefore(groupIndicator, g.firstChild);
           }
           g.appendChild(rectEl);
           g.appendChild(deleteBtn);
           svg.appendChild(g);
          }
         });
        }
        
        if (TEXT_DATA && TEXT_DATA.list) {
         TEXT_DATA.list.forEach((textItem) => {
          if (currentView.mode === "rack") return;
          
          const g = document.createElementNS(ns, "g");
          g.classList.add("text-group");
          g.dataset.textId = textItem.id;
          
          if (textItem.bgEnabled) {
           const bgRect = document.createElementNS(ns, "rect");
           bgRect.classList.add("text-bg");
      
           bgRect.setAttribute("x", textItem.x - 5);
           bgRect.setAttribute("y", textItem.y - textItem.fontSize - 2);
           bgRect.setAttribute("width", 100);
           bgRect.setAttribute("height", textItem.fontSize + 10);
           bgRect.style.fill = textItem.bgColor;
           bgRect.style.opacity = "0.7";
           bgRect.style.rx = "4";
           g.appendChild(bgRect);
          }
          
          const textEl = document.createElementNS(ns, "text");
          textEl.classList.add("text-element");
          textEl.setAttribute("x", textItem.x);
          textEl.setAttribute("y", textItem.y);
          textEl.style.fill = textItem.color;
          textEl.style.fontSize = textItem.fontSize + "px";
          textEl.style.fontWeight = textItem.fontWeight;
          textEl.style.fontStyle = textItem.fontStyle;
          textEl.style.textAnchor = textItem.textAlign;
          textEl.style.textDecoration = textItem.textDecoration;
          textEl.style.opacity = textItem.opacity;
          textEl.style.cursor = "move";
          textEl.style.userSelect = "none";
          textEl.setAttribute("dominant-baseline", "middle");
          
          const lines = textItem.content.split('\n');
          if (lines.length === 1) {
           textEl.textContent = textItem.content;
          } else {
           lines.forEach((line, i) => {
            const tspan = document.createElementNS(ns, "tspan");
            tspan.textContent = line;
            tspan.setAttribute("x", textItem.x);
            tspan.setAttribute("dy", i === 0 ? 0 : textItem.fontSize * 1.2);
            textEl.appendChild(tspan);
           });
          }
          
          g.appendChild(textEl);
          
          if (textItem.bgEnabled) {
           setTimeout(() => {
            try {
             const bbox = textEl.getBBox();
             const bgRect = g.querySelector('.text-bg');
             if (bgRect && bbox) {
              bgRect.setAttribute("x", bbox.x - 5);
              bgRect.setAttribute("y", bbox.y - 2);
              bgRect.setAttribute("width", bbox.width + 10);
              bgRect.setAttribute("height", bbox.height + 4);
             }
            } catch (e) {
            }
           }, 0);
          }
          
          const deleteBtn = document.createElementNS(ns, "g");
          deleteBtn.classList.add("text-delete-btn");
          deleteBtn.style.cursor = "pointer";
          deleteBtn.style.display = textDrawMode ? "block" : "none";
          
          const deleteBg = document.createElementNS(ns, "circle");
          deleteBg.setAttribute("cx", textItem.x + 20);
          deleteBg.setAttribute("cy", textItem.y - textItem.fontSize);
          deleteBg.setAttribute("r", 12);
          deleteBg.style.fill = "#f56565";
          deleteBg.style.stroke = "white";
          deleteBg.style.strokeWidth = "2";
          
          const deleteX = document.createElementNS(ns, "text");
          deleteX.setAttribute("x", textItem.x + 20);
          deleteX.setAttribute("y", textItem.y - textItem.fontSize);
          deleteX.setAttribute("text-anchor", "middle");
          deleteX.setAttribute("dominant-baseline", "middle");
          deleteX.style.fill = "white";
          deleteX.style.fontSize = "16px";
          deleteX.style.fontWeight = "bold";
          deleteX.style.pointerEvents = "none";
          deleteX.textContent = "√ó";
          
          deleteBtn.appendChild(deleteBg);
          deleteBtn.appendChild(deleteX);
          
          deleteBtn.addEventListener("click", (e) => {
           e.stopPropagation();
           e.preventDefault();
           deleteText(textItem.id);
          });
          
          let isDragging = false;
          let dragStartX, dragStartY;
          let textStartX, textStartY;
          
          textEl.addEventListener("mousedown", (e) => {
      if (textDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      textStartX = textItem.x;
      textStartY = textItem.y;
      textEl.style.cursor = "grabbing";
      
      showTextPanel(textItem.id);
      
      if (selectedTexts.has(textItem.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
          
          const moveHandler = (e) => {
      if (!isDragging || textDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      
      textItem.x = textStartX + dx;
      textItem.y = textStartY + dy;
      
      if (selectedTexts.has(textItem.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       const newX = initialPositions[nodeId].x + dx;
       const newY = initialPositions[nodeId].y + dy;
       savedPositions[nodeId] = { x: newX, y: newY };
      }
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      if (textId === textItem.id) return;
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      
      forgeTheTopology();
      };
          
          const upHandler = () => {
           if (isDragging) {
            isDragging = false;
            textEl.style.cursor = "move";
           }
          };
          
          document.addEventListener("mousemove", moveHandler);
          document.addEventListener("mouseup", upHandler);
          
          let touchStartX = 0, touchStartY = 0;
          let textTouchStartX = 0, textTouchStartY = 0;
          
          textEl.addEventListener("touchstart", (e) => {
           if (textDrawMode) return;
           if (e.touches.length !== 1) return;
           
           e.preventDefault();
           e.stopPropagation();
           const touch = e.touches[0];
           isDragging = true;
           touchStartX = touch.clientX;
           touchStartY = touch.clientY;
           textTouchStartX = textItem.x;
           textTouchStartY = textItem.y;
           
           showTextPanel(textItem.id);
          }, { passive: false });
          
          textEl.addEventListener("touchmove", (e) => {
           if (!isDragging || textDrawMode) return;
           if (e.touches.length !== 1) return;
           
           e.preventDefault();
           const touch = e.touches[0];
           const svgEl = svg;
           
           const pt1 = svgEl.createSVGPoint();
           pt1.x = touchStartX;
           pt1.y = touchStartY;
           const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
           
           const pt2 = svgEl.createSVGPoint();
           pt2.x = touch.clientX;
           pt2.y = touch.clientY;
           const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
           
           const dx = svgP2.x - svgP1.x;
           const dy = svgP2.y - svgP1.y;
           
           textItem.x = textTouchStartX + dx;
           textItem.y = textTouchStartY + dy;
           
           forgeTheTopology();
          }, { passive: false });
          
          textEl.addEventListener("touchend", () => {
           if (isDragging) {
            isDragging = false;
           }
          }, { passive: false });
          
          textEl.addEventListener("contextmenu", (e) => {
           e.preventDefault();
           e.stopPropagation();
           if (selectedTexts.has(textItem.id)) {
            selectedTexts.delete(textItem.id);
           } else {
            selectedTexts.add(textItem.id);
           }
           updateAllSelections();
          });
          
          let textLastTap = 0;
          g.addEventListener("touchend", (e) => {
           const now = Date.now();
           if (now - textLastTap < 300) {
            e.preventDefault();
            if (selectedTexts.has(textItem.id)) {
             selectedTexts.delete(textItem.id);
            } else {
             selectedTexts.add(textItem.id);
            }
            updateAllSelections();
            if (navigator.vibrate) navigator.vibrate(50);
            textLastTap = 0;
           } else {
            textLastTap = now;
           }
          }, { passive: false });
          
          if (textItem.groupId) {
            const groupIndicator = document.createElementNS(ns, "rect");
            groupIndicator.setAttribute("x", textItem.x - 54);
            groupIndicator.setAttribute("y", textItem.y - 24);
            groupIndicator.setAttribute("width", 108);
            groupIndicator.setAttribute("height", 48);
            groupIndicator.setAttribute("rx", "8");
            groupIndicator.style.fill = "none";
       groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
            groupIndicator.style.strokeWidth = "3";
            groupIndicator.style.strokeDasharray = "5,5";
            groupIndicator.style.pointerEvents = "none";
            g.insertBefore(groupIndicator, g.firstChild);
          }
          g.appendChild(deleteBtn);
          svg.appendChild(g);
         });
        }
        
        
        Object.keys(NODE_DATA).forEach(nodeId => {
         updatePingIndicator(nodeId);
        });
        
        forgeTheLegend();
        updateMinimap();
       }
      
       function showEditModal(title, currentValue, onSave) {
        const modal = document.getElementById("edit-modal");
        const input = document.getElementById("modal-input");
        const titleEl = document.getElementById("modal-title");
        const saveBtn = document.getElementById("modal-save");
        const cancelBtn = document.getElementById("modal-cancel");
        titleEl.textContent = title;
        input.value = currentValue;
        modal.classList.add("active");
        input.focus();
        input.select();
        const handleSave = () => {
         if (input.value.trim()) {
          onSave(input.value.trim());
         }
         modal.classList.remove("active");
         saveBtn.removeEventListener("click", handleSave);
         cancelBtn.removeEventListener("click", handleCancel);
         input.removeEventListener("keypress", handleEnter);
        };
        const handleCancel = () => {
         modal.classList.remove("active");
         saveBtn.removeEventListener("click", handleSave);
         cancelBtn.removeEventListener("click", handleCancel);
         input.removeEventListener("keypress", handleEnter);
        };
        const handleEnter = (e) => {
         if (e.key === "Enter") handleSave();
        };
        saveBtn.addEventListener("click", handleSave);
        cancelBtn.addEventListener("click", handleCancel);
        input.addEventListener("keypress", handleEnter);
        modal.addEventListener("click", function bgHandler(e) {
         if (e.target === modal) {
          handleCancel();
          modal.removeEventListener("click", bgHandler);
         }
        });
       }
      
       function challengeTheImmortal(message, onConfirm) {
        const modal = document.getElementById("confirm-modal");
        const messageEl = document.getElementById("confirm-message");
        const deleteBtn = document.getElementById("confirm-delete");
        const cancelBtn = document.getElementById("confirm-cancel");
        messageEl.textContent = message;
        modal.classList.add("active");
        const handleConfirm = () => {
         onConfirm();
         modal.classList.remove("active");
         deleteBtn.removeEventListener("click", handleConfirm);
         cancelBtn.removeEventListener("click", handleCancel);
        };
        const handleCancel = () => {
         modal.classList.remove("active");
         deleteBtn.removeEventListener("click", handleConfirm);
         cancelBtn.removeEventListener("click", handleCancel);
        };
        deleteBtn.addEventListener("click", handleConfirm);
        cancelBtn.addEventListener("click", handleCancel);
        modal.addEventListener("click", function bgHandler(e) {
         if (e.target === modal) {
          handleCancel();
          modal.removeEventListener("click", bgHandler);
         }
        });
       }
       const pageTitleEl = document.getElementById("page-title");
       if (pageTitleEl) {
        pageTitleEl.addEventListener("click", () => {
         showEditModal("Edit Title", PAGE_STATE.title || DEFAULT_PAGE_STATE.title,
          (newTitle) => {
           PAGE_STATE.title = newTitle;
           wieldThePower();
          }, );
        });
       }
      
       function editNodeName(id) {
        if (!NODE_DATA[id]) return;
        showEditModal("Edit Name", NODE_DATA[id].name, (newName) => {
         if (!NODE_DATA[id]) return;
         NODE_DATA[id].name = newName;
         const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`, );
         if (nodeGroup) {
          const label = nodeGroup.querySelector(".node-label");
          if (label) label.textContent = newName;
         }
         if (currentNodeId === id) {
          document.getElementById("node-name").textContent = newName;
         }
        });
       }
      
       function editNodeIp(id) {
        if (!NODE_DATA[id]) return;
        showEditModal("Edit IP/Subtitle", NODE_DATA[id].ip, (newIp) => {
         if (!NODE_DATA[id]) return;
         NODE_DATA[id].ip = newIp;
         const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`, );
         if (nodeGroup) {
          const sub = nodeGroup.querySelector(".node-sub");
          if (sub) sub.textContent = newIp;
         }
         if (currentNodeId === id) {
          document.getElementById("node-ip").textContent = newIp;
         }
        });
       }
      
       function claimTheImmortal(id) {
        if (!NODE_DATA[id]) return;
        currentNodeId = id;
        currentEdgeId = null;
        const data = NODE_DATA[id];
        document.querySelectorAll(".node-group").forEach((n) => {
         n.classList.toggle("active", n.dataset.nodeId === id);
        });
        document.querySelectorAll(".edge").forEach((e) => {
         const active = e.dataset.from === id || e.dataset.to === id;
         e.classList.toggle("active", active);
        });
        document.getElementById("node-panel").style.display = "block";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        const toolbar = document.getElementById("topology-toolbar");
        if (!topologyToolbarCollapsed) {
         toolbar.style.display = "flex";
        }
        updateTopologyToolbarVisibility();
        document.getElementById("node-name").textContent = data.name;
        document.getElementById("node-ip").textContent = data.ip;
        document.getElementById("node-mac").textContent = data.mac || "--";
        document.getElementById("node-rack").textContent = data.rackUnit || "--";
        document.getElementById("node-uheight").textContent = (data.uHeight || "1") + "U";
        document.getElementById("node-role").textContent = data.role;
      
        populateRackDropdown();
        const assignedRackSelect = document.getElementById("node-assigned-rack");
        if (assignedRackSelect) {
         assignedRackSelect.value = data.assignedRack || "";
        }
        
        const rackCapacitySelect = document.getElementById("node-rack-capacity");
        if (rackCapacitySelect) {
         rackCapacitySelect.value = data.rackCapacity || "42";
        }
        
        const isRack = data.isRack === true;
        const isAssignedToRack = !!data.assignedRack;
        const assignedRackRow = document.getElementById("assigned-rack-row");
        const rackCapacityRow = document.getElementById("rack-capacity-row");
        const uheightRow = document.getElementById("uheight-row");
        if (assignedRackRow) assignedRackRow.style.display = isRack ? "none" : "flex";
        if (rackCapacityRow) rackCapacityRow.style.display = isRack ? "flex" : "none";
        if (uheightRow) uheightRow.style.display = isAssignedToRack ? "flex" : "none";
        
        document.getElementById("node-name").onclick = () => editNodeName(id);
        document.getElementById("node-ip").onclick = () => editNodeIp(id);
        document.getElementById("node-mac").onclick = () => editNodeMac(id);
        document.getElementById("node-rack").onclick = () => editNodeRack(id);
        document.getElementById("node-uheight").onclick = () => editNodeUHeight(id);
        const currentSize = savedSizes[id] || getDefaultSize();
        document.getElementById("size-slider").value = currentSize;
        document.getElementById("size-value").textContent = currentSize;
        const styleEntry = savedStyles[id] || {};
        const resolvedStyles = resolveStylesEntry(styleEntry);
        const scopeKey = currentStyleScope || "all";
        const flatProps = ["circleColor", "circleBorder", "titleColor", "titleFont", "titleSize", "subColor", "subFont", "subSize", ];
        const isFlat = flatProps.some((p) => Object.prototype.hasOwnProperty.call(styleEntry, p), );
        const scopedStyles = isFlat ? styleEntry : styleEntry[scopeKey] || {};
        const circleColorInput = document.getElementById("circle-color");
        const titleColorInput = document.getElementById("title-color");
        const titleFontSelect = document.getElementById("title-font");
        const titleSizeInput = document.getElementById("title-size");
        const subColorInput = document.getElementById("sub-color");
        const subFontSelect = document.getElementById("sub-font");
        const subSizeInput = document.getElementById("sub-size");
        const shapeSelect = document.getElementById("shape-select");
        const scopeSelect = document.getElementById("style-scope");
circleColorInput.value = scopedStyles.circleColor || resolvedStyles.circleColor || PAGE_STATE.nodeFill || "#1e293b";
       const circleBorderInput = document.getElementById("circle-border");
       circleBorderInput.value = scopedStyles.circleBorder || resolvedStyles.circleBorder || PAGE_STATE.nodeStroke || "#475569";
        titleColorInput.value = scopedStyles.titleColor || resolvedStyles.titleColor || PAGE_STATE.textMain || "#e2e8f0";
        titleFontSelect.value = scopedStyles.titleFont || resolvedStyles.titleFont || "system-ui, sans-serif";
        titleSizeInput.value = scopedStyles.titleSize || resolvedStyles.titleSize || 18;
        subColorInput.value = scopedStyles.subColor || resolvedStyles.subColor || PAGE_STATE.textSoft || "#94a3b8";
        subFontSelect.value = scopedStyles.subFont || resolvedStyles.subFont || "system-ui, sans-serif";
        subSizeInput.value = scopedStyles.subSize || resolvedStyles.subSize || 13;
        shapeSelect.value = data.shape || "circle";
        const layerSelect = document.getElementById("node-layer");
        if (layerSelect) {
         layerSelect.value = data.layer || "physical";
        }
        scopeSelect.value = currentStyleScope || "all";
        document.getElementById("title-offset-y").value = scopedStyles.titleOffsetY || resolvedStyles.titleOffsetY || 0;
        document.getElementById("title-offset-x").value = scopedStyles.titleOffsetX || resolvedStyles.titleOffsetX || 0;
        document.getElementById("sub-offset-y").value = scopedStyles.subOffsetY || resolvedStyles.subOffsetY || 0;
        document.getElementById("sub-offset-x").value = scopedStyles.subOffsetX || resolvedStyles.subOffsetX || 0;
      
      const pingOffsetXInput = document.getElementById("ping-offset-x");
      const pingOffsetYInput = document.getElementById("ping-offset-y");
      
      if (pingOffsetXInput && pingOffsetYInput) {
      pingOffsetXInput.value =
       (scopedStyles.pingOffsetX !== undefined
         ? scopedStyles.pingOffsetX
         : (resolvedStyles.pingOffsetX !== undefined
             ? resolvedStyles.pingOffsetX
             : 0));
      
      pingOffsetYInput.value =
       (scopedStyles.pingOffsetY !== undefined
         ? scopedStyles.pingOffsetY
         : (resolvedStyles.pingOffsetY !== undefined
             ? resolvedStyles.pingOffsetY
             : 0));
      }
        const tagEl = document.getElementById("node-tags");
        tagEl.innerHTML = "";
        data.tags.forEach((tag, i) => {
         const b = document.createElement("span");
         b.className = "badge";
         const isIconTag = typeof tag === 'object' && tag.type === 'icon';
         if (!isIconTag && typeof tag === 'string' && tag.toLowerCase().includes("wg")) b.classList.add("wg");
         b.style.cursor = "pointer";
         b.style.position = "relative";
         const tagContent = document.createElement("span");
         if (isIconTag) {
          b.classList.add("icon-badge");
          IconLibrary.getIcon(tag.library, tag.name).then(svgText => {
           if (svgText) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(svgText, 'image/svg+xml');
            const svgEl = doc.querySelector('svg');
            if (svgEl) {
             svgEl.setAttribute('width', '16');
             svgEl.setAttribute('height', '16');
             tagContent.innerHTML = '';
             tagContent.appendChild(svgEl);
             const nameSpan = document.createElement('span');
             nameSpan.textContent = tag.name;
             nameSpan.style.marginLeft = '4px';
             tagContent.appendChild(nameSpan);
            }
           }
          });
         } else {
          tagContent.textContent = tag;
          tagContent.addEventListener("click", (e) => {
           e.stopPropagation();
           showEditModal("Edit Tag", tag, (newTag) => {
            if (newTag) {
             data.tags[i] = newTag;
             claimTheImmortal(id);
            }
           });
          });
         }
         const deleteTag = document.createElement("span");
         deleteTag.textContent = " ‚úï";
         deleteTag.style.opacity = "0.6";
         deleteTag.style.marginLeft = "4px";
         deleteTag.style.fontSize = "10px";
         deleteTag.addEventListener("click", (e) => {
          e.stopPropagation();
          data.tags.splice(i, 1);
          claimTheImmortal(id);
         });
         b.append(tagContent, deleteTag);
         tagEl.append(b);
        });
        const addTagBtn = document.createElement("span");
        addTagBtn.className = "badge";
        addTagBtn.style.cursor = "pointer";
        addTagBtn.style.opacity = "0.6";
        addTagBtn.style.borderStyle = "dashed";
        addTagBtn.textContent = "+ Add";
        addTagBtn.addEventListener("click", () => {
         showEditModal("Add Tag(s) : comma separated", "",
          (newTagStr) => {
           if (newTagStr) {
            const newTags = newTagStr.split(",").map((t) => t.trim()).filter((t) => t);
            newTags.forEach((t) => data.tags.push(t));
            claimTheImmortal(id);
           }
          }, );
        });
        tagEl.append(addTagBtn);
        const notesEl = document.getElementById("node-notes");
        notesEl.innerHTML = "";
        data.notes.forEach((note, i) => {
         const li = document.createElement("li");
         const noteText = document.createElement("span");
         noteText.textContent = note;
         noteText.style.flex = "1";
         const deleteBtn = document.createElement("span");
         deleteBtn.className = "delete-note";
         deleteBtn.textContent = "‚úï";
         deleteBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          challengeTheImmortal("Are you sure you want to delete this note?",
           () => {
            data.notes.splice(i, 1);
            claimTheImmortal(id);
           }, );
         });
         li.append(noteText, deleteBtn);
         noteText.addEventListener("dblclick", () => {
          noteText.classList.add("editing");
          noteText.contentEditable = true;
          noteText.focus();
         });
         noteText.addEventListener("blur", () => {
          noteText.classList.remove("editing");
          noteText.contentEditable = false;
          data.notes[i] = noteText.textContent;
         });
         notesEl.append(li);
        });
        const addLineSelect = document.getElementById("add-line-select");
      addLineSelect.innerHTML = "";
      const currentRack = data.assignedRack || "";
      Object.entries(NODE_DATA).forEach(([nodeId, node]) => {
      if (nodeId !== id) {
      const nodeRack = node.assignedRack || "";
      if (currentRack === nodeRack) {
      const opt = document.createElement("option");
      opt.value = nodeId;
      opt.textContent = node.name;
      addLineSelect.appendChild(opt);
      }
      }
      });
        
        const pingEnabled = data.ping && data.ping.enabled;
        document.getElementById('node-pingable').checked = pingEnabled;
        document.getElementById('node-ping-options').style.display = pingEnabled ? 'block' : 'none';
        
        if (data.ping) {
         document.getElementById('node-ping-protocol').value = data.ping.protocol || 'http';
         document.getElementById('node-custom-url').value = data.ping.customUrl || '';
         document.getElementById('node-ping-timeout').value = data.ping.timeout || 3000;
         document.getElementById('node-custom-url-container').style.display = 
          data.ping.protocol === 'custom' ? 'block' : 'none';
         
         updatePingStatusDisplay(id);
        }
       }
      
       function updatePingStatusDisplay(nodeId) {
        const data = NODE_DATA[nodeId];
        if (!data || !data.ping) return;
        
        const statusEl = document.getElementById('node-ping-status');
        const lastCheckEl = document.getElementById('node-ping-last-check');
        
        const statusColors = {
         online: 'var(--accent)',
         offline: 'var(--danger)',
         checking: '#f59e0b',
         unknown: 'var(--text-soft)'
        };
        
        const statusTexts = {
         online: '‚óè Online',
         offline: '‚óè Offline',
         checking: '‚óè Checking...',
         unknown: '‚óè Unknown'
        };
        
        statusEl.textContent = statusTexts[data.ping.status] || statusTexts.unknown;
        statusEl.style.color = statusColors[data.ping.status] || statusColors.unknown;
        
        if (data.ping.lastCheck) {
         const checkTime = new Date(data.ping.lastCheck);
         lastCheckEl.textContent = `Last checked: ${checkTime.toLocaleTimeString()}`;
        } else {
         lastCheckEl.textContent = 'Never checked';
        }
       }
      
       function selectTheConnection(id) {
        currentEdgeId = id;
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "block";
        document.getElementById("text-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.display = "none";
        document.querySelectorAll(".node-group").forEach((n) => n.classList.remove("active"));
        document.querySelectorAll(".edge").forEach((e) => {
         e.classList.toggle("active", e.dataset.edgeId === id);
        });
        const edge = EDGE_DATA.list.find((e) => e.id === id);
        if (!edge) return;
        const directionSymbols = {
         none: "‚áÑ",
         forward: "‚Üí",
         backward: "‚Üê",
         both: "‚Üî",
        };
        const dirSymbol = directionSymbols[edge.direction] || "‚áÑ";
        let titleText = "Custom line";
        if (edge.from || edge.to) {
         const fromName = edge.from ? NODE_DATA[edge.from]?.name || edge.from : "";
         const toName = edge.to ? NODE_DATA[edge.to]?.name || edge.to : "";
         titleText = `${fromName || "?"} ${dirSymbol} ${toName || "?"}`;
        }
        document.getElementById("edge-title").textContent = titleText;
        const widthInput = document.getElementById("edge-width");
        const colorInput = document.getElementById("edge-color");
        const directionSelect = document.getElementById("edge-direction");
        const lineStyleSelect = document.getElementById("edge-line-style");
        widthInput.value = edge.width;
        colorInput.value = edge.color;
        directionSelect.value = edge.direction || "none";
        lineStyleSelect.value = edge.lineStyle || "solid";
        
        const fromPortInput = document.getElementById("edge-from-port");
        const toPortInput = document.getElementById("edge-to-port");
        const portFieldsFrom = document.getElementById("edge-port-fields");
        const portFieldsTo = document.getElementById("edge-port-fields-to");
        
        if (edge.type === "custom") {
         if (portFieldsFrom) portFieldsFrom.style.display = "none";
         if (portFieldsTo) portFieldsTo.style.display = "none";
        } else {
         if (portFieldsFrom) portFieldsFrom.style.display = "flex";
         if (portFieldsTo) portFieldsTo.style.display = "flex";
         if (fromPortInput) {
          fromPortInput.value = edge.fromPort || "";
          fromPortInput.onchange = () => updateEdgePortLabels(id);
         }
         if (toPortInput) {
          toPortInput.value = edge.toPort || "";
          toPortInput.onchange = () => updateEdgePortLabels(id);
         }
        }
        
        const list = document.getElementById("edge-notes");
        list.innerHTML = "";
        edge.notes.forEach((note, i) => {
         const li = document.createElement("li");
         const txt = document.createElement("span");
         txt.textContent = note;
         txt.style.flex = "1";
         const del = document.createElement("span");
         del.className = "delete-note";
         del.textContent = "‚úï";
         del.addEventListener("click", (e) => {
          e.stopPropagation();
          challengeTheImmortal("Delete this line note?", () => {
           edge.notes.splice(i, 1);
           saveEdgeData();
           selectTheConnection(id);
          });
         });
         txt.addEventListener("dblclick", () => {
          txt.classList.add("editing");
          txt.contentEditable = true;
          txt.focus();
         });
         txt.addEventListener("blur", () => {
          txt.classList.remove("editing");
          txt.contentEditable = false;
          edge.notes[i] = txt.textContent;
          saveEdgeData();
         });
         li.append(txt, del);
         list.appendChild(li);
       });
       
       if (edge.type === "custom" && Array.isArray(edge.points)) {
        forgeTheTopology();
       }
      }
       window.addEventListener("resize", () => {
        forgeTheTopology();
        if (currentEdgeId) {
         selectTheConnection(currentEdgeId);
        } else if (currentNodeId && NODE_DATA[currentNodeId]) {
         claimTheImmortal(currentNodeId);
        } else {
         const availableNodes = Object.keys(NODE_DATA);
         if (availableNodes.length > 0) {
          claimTheImmortal(availableNodes[0]);
         }
        }
       });
       (function initZoomPan() {
        const viewport = document.getElementById("canvas-viewport");
        const svg = document.getElementById("map");
        const hint = document.getElementById("canvas-hint");
        setTimeout(() => {
         hint.classList.add("visible");
         setTimeout(() => hint.classList.remove("visible"), 4000);
        }, 1000);
        viewport.addEventListener("wheel",
         (e) => {
          e.preventDefault();
          const rect = viewport.getBoundingClientRect();
          const mouseX = (e.clientX - rect.left) / rect.width;
          const mouseY = (e.clientY - rect.top) / rect.height;
          const delta = e.deltaY > 0 ? 0.9 : 1.1;
          zoomTo(canvasState.zoom * delta, mouseX, mouseY);
         }, {
          passive: false
         }, );
        let initialPinchDistance = 0;
        let initialPinchZoom = 1;
        let pinchCenter = {
         x: 0.5,
         y: 0.5
        };
        viewport.addEventListener("touchstart",
         (e) => {
          if (e.touches.length === 2) {
           e.preventDefault();
           const touch1 = e.touches[0];
           const touch2 = e.touches[1];
           initialPinchDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY, );
           initialPinchZoom = canvasState.zoom;
           const rect = viewport.getBoundingClientRect();
           const centerX = (touch1.clientX + touch2.clientX) / 2;
           const centerY = (touch1.clientY + touch2.clientY) / 2;
           pinchCenter.x = (centerX - rect.left) / rect.width;
           pinchCenter.y = (centerY - rect.top) / rect.height;
          }
         }, {
          passive: false
         }, );
        viewport.addEventListener("touchmove",
         (e) => {
          if (e.touches.length === 2) {
           e.preventDefault();
           const touch1 = e.touches[0];
           const touch2 = e.touches[1];
           const currentDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY, );
           if (initialPinchDistance > 0) {
            const scale = currentDistance / initialPinchDistance;
            const newZoom = initialPinchZoom * scale;
            zoomTo(newZoom, pinchCenter.x, pinchCenter.y);
           }
          }
         }, {
          passive: false
         }, );
        let panStartViewX = 0;
        let panStartViewY = 0;
        
        let lastEmptyTapTime = 0;
        let emptyTapTimeout = null;
        let emptyTapMoved = false;
        let emptyTapStartX = 0;
        let emptyTapStartY = 0;
        
        viewport.addEventListener("touchend", (e) => {
          if (currentView.mode !== "rack") return;
          
          if (e.changedTouches.length !== 1) return;
          
      const isNodeOrEdge = e.target.closest(".node-group") || e.target.closest(".edge-group");
         if (isNodeOrEdge) return;
          
          if (emptyTapMoved) {
            emptyTapMoved = false;
            return;
          }
          
          const currentTime = new Date().getTime();
          const tapGap = currentTime - lastEmptyTapTime;
          
          if (tapGap < 300 && tapGap > 0) {
            e.preventDefault();
            
            exitRack();
            
            if (navigator.vibrate) {
              navigator.vibrate(50);
            }
            
            lastEmptyTapTime = 0;
            if (emptyTapTimeout) {
              clearTimeout(emptyTapTimeout);
              emptyTapTimeout = null;
            }
          } else {
            lastEmptyTapTime = currentTime;
            
            if (emptyTapTimeout) clearTimeout(emptyTapTimeout);
            emptyTapTimeout = setTimeout(() => {
              lastEmptyTapTime = 0;
            }, 300);
          }
        }, { passive: false });
        
        viewport.addEventListener("mousedown", (e) => {
         if (e.target.closest(".draw-toolbar") || e.target.closest(".topology-toolbar") || e.target.closest(".legend-container")) {
          return;
         }
         if (freeDrawMode || rectDrawMode) {
          return;
         }
      const isEmptySpace = e.target === svg || e.target === viewport || e.target.tagName === "svg";
      const isEdgeElement = e.target.closest('.edge') || e.target.classList.contains('edge-edit-point');
      const isTextElement = e.target.closest('.text-group') || e.target.closest('.text-element');
      const isRectElement = e.target.closest('.rect-group');
      if (!isEdgeElement && !isTextElement && !isRectElement && currentEdgeId) {
      currentEdgeId = null;
      forgeTheTopology();
      }
      if (!isRectElement && currentRectId) {
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      }
         if (isEmptySpace || e.button === 2 || e.button === 1) {
          e.preventDefault();
          canvasState.isPanning = true;
          canvasState.panStartX = e.clientX;
          canvasState.panStartY = e.clientY;
          panStartViewX = canvasState.panX;
          panStartViewY = canvasState.panY;
          viewport.classList.add("panning");
         }
        });
        viewport.addEventListener("touchstart",
         (e) => {
          if (e.target.closest(".draw-toolbar") || e.target.closest(".topology-toolbar") || e.target.closest(".legend-container")) {
           return;
          }
          if (freeDrawMode || rectDrawMode) {
           return;
          }
      const isEmptySpace = e.target === svg || e.target === viewport || e.target.tagName === "svg";
      const isEdgeElement = e.target.closest('.edge') || e.target.classList.contains('edge-edit-point');
      const isTextElement = e.target.closest('.text-group') || e.target.closest('.text-element');
      const isRectElement = e.target.closest('.rect-group');
      if (!isEdgeElement && !isTextElement && !isRectElement && currentEdgeId) {
      currentEdgeId = null;
      forgeTheTopology();
      }
      if (!isRectElement && currentRectId) {
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      }
          if (isEmptySpace && e.touches.length === 1) {
           e.preventDefault();
           emptyTapMoved = false;
           emptyTapStartX = e.touches[0].clientX;
           emptyTapStartY = e.touches[0].clientY;
           canvasState.isPanning = true;
           canvasState.panStartX = e.touches[0].clientX;
           canvasState.panStartY = e.touches[0].clientY;
           panStartViewX = canvasState.panX;
           panStartViewY = canvasState.panY;
           viewport.classList.add("panning");
          }
         }, {
          passive: false
         }, );
        document.addEventListener("mousemove", (e) => {
         if (!canvasState.isPanning) return;
         const dx = e.clientX - canvasState.panStartX;
         const dy = e.clientY - canvasState.panStartY;
         const rect = viewport.getBoundingClientRect();
         const viewWidth = CANVAS_WIDTH / canvasState.zoom;
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         const canvasDx = (dx / rect.width) * viewWidth;
         const canvasDy = (dy / rect.height) * viewHeight;
         canvasState.panX = panStartViewX - canvasDx;
         canvasState.panY = panStartViewY - canvasDy;
         constrainPan();
         updateViewBox();
        });
       document.addEventListener("touchmove", (e) => {
        if (!canvasState.isPanning || !e.touches[0]) return;
        const moveDx = Math.abs(e.touches[0].clientX - emptyTapStartX);
        const moveDy = Math.abs(e.touches[0].clientY - emptyTapStartY);
        if (moveDx > 15 || moveDy > 15) {
         emptyTapMoved = true;
        }
        const dx = e.touches[0].clientX - canvasState.panStartX;
         const dy = e.touches[0].clientY - canvasState.panStartY;
         const rect = viewport.getBoundingClientRect();
         const viewWidth = CANVAS_WIDTH / canvasState.zoom;
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         const canvasDx = (dx / rect.width) * viewWidth;
         const canvasDy = (dy / rect.height) * viewHeight;
         canvasState.panX = panStartViewX - canvasDx;
         canvasState.panY = panStartViewY - canvasDy;
         constrainPan();
         updateViewBox();
        });
        document.addEventListener("mouseup", () => {
         if (canvasState.isPanning) {
          canvasState.isPanning = false;
          viewport.classList.remove("panning");
         }
        });
        document.addEventListener("touchend", () => {
         if (canvasState.isPanning) {
          canvasState.isPanning = false;
          viewport.classList.remove("panning");
         }
        });
        document.addEventListener("keydown", (e) => {
         const isEditing = document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "TEXTAREA" || document.activeElement.isContentEditable;
         if (e.code === "Space" && !e.repeat && !isEditing) {
          e.preventDefault();
          canvasState.spacePressed = true;
          viewport.style.cursor = "grab";
         }
        });
        document.addEventListener("keyup", (e) => {
         if (e.code === "Space") {
          canvasState.spacePressed = false;
          viewport.style.cursor = "";
         }
        });
        document.getElementById("zoom-in-btn").addEventListener("click", () => {
         zoomTo(canvasState.zoom * 1.25, 0.5, 0.5);
        });
        document.getElementById("zoom-out-btn").addEventListener("click", () => {
         zoomTo(canvasState.zoom * 0.8, 0.5, 0.5);
        });
        document.getElementById("zoom-fit-btn").addEventListener("click", fitToContent);
        document.getElementById("zoom-reset-btn").addEventListener("click", resetView);
        const minimapContainer = document.getElementById("minimap-container");
        const minimapSvg = document.getElementById("minimap");
        let minimapDragging = false;
        minimapContainer.addEventListener("mousedown", (e) => {
         e.preventDefault();
         minimapDragging = true;
         updatePanFromMinimap(e);
        });
        minimapContainer.addEventListener("touchstart",
         (e) => {
          e.preventDefault();
          minimapDragging = true;
          updatePanFromMinimapTouch(e);
         }, {
          passive: false
         }, );
        document.addEventListener("mousemove", (e) => {
         if (minimapDragging) {
          updatePanFromMinimap(e);
         }
        });
        document.addEventListener("touchmove", (e) => {
         if (minimapDragging && e.touches[0]) {
          updatePanFromMinimapTouch(e);
         }
        });
        document.addEventListener("mouseup", () => {
         minimapDragging = false;
        });
        document.addEventListener("touchend", () => {
         minimapDragging = false;
        });
      
        function updatePanFromMinimap(e) {
         const rect = minimapContainer.getBoundingClientRect();
         const x = (e.clientX - rect.left) / rect.width;
         const y = (e.clientY - rect.top) / rect.height;
         const viewWidth = CANVAS_WIDTH / canvasState.zoom;
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         canvasState.panX = x * CANVAS_WIDTH - viewWidth / 2;
         canvasState.panY = y * CANVAS_HEIGHT - viewHeight / 2;
         constrainPan();
         updateViewBox();
        }
      
        function updatePanFromMinimapTouch(e) {
         const rect = minimapContainer.getBoundingClientRect();
         const touch = e.touches[0];
         const x = (touch.clientX - rect.left) / rect.width;
         const y = (touch.clientY - rect.top) / rect.height;
         const viewWidth = CANVAS_WIDTH / canvasState.zoom;
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         canvasState.panX = x * CANVAS_WIDTH - viewWidth / 2;
         canvasState.panY = y * CANVAS_HEIGHT - viewHeight / 2;
         constrainPan();
         updateViewBox();
        }
        document.addEventListener("keydown", (e) => {
         if (document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "TEXTAREA") return;
         if (
          (e.key === "+" || e.key === "=") && (e.ctrlKey || e.metaKey)) {
          e.preventDefault();
          zoomTo(canvasState.zoom * 1.25, 0.5, 0.5);
         } else if (e.key === "-" && (e.ctrlKey || e.metaKey)) {
          e.preventDefault();
          zoomTo(canvasState.zoom * 0.8, 0.5, 0.5);
         } else if (e.key === "0" && (e.ctrlKey || e.metaKey)) {
          e.preventDefault();
          resetView();
         }
        });
        setTimeout(() => {
         fitToContent();
        }, 100);
       })();
       const sizeSlider = document.getElementById("size-slider");
       const sizeValue = document.getElementById("size-value");
       const resetSizeBtn = document.getElementById("reset-size");
       sizeSlider.addEventListener("input", () => {
        const newSize = parseInt(sizeSlider.value, 10);
        sizeValue.textContent = newSize;
        savedSizes[currentNodeId] = newSize;
        const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
        if (nodeGroup) {
         const oldShape = nodeGroup.querySelector(".node-circle");
         if (oldShape) oldShape.remove();
         const newShape = createNodeShape(currentNodeId, newSize);
         nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
         const styles = resolveStylesForNode(currentNodeId);
         if (styles.circleColor) newShape.style.fill = styles.circleColor;
      if (styles.circleBorder) newShape.style.stroke = styles.circleBorder;
         const label = nodeGroup.querySelector(".node-label");
         const sub = nodeGroup.querySelector(".node-sub");
         if (label) {
          label.setAttribute("y", -newSize * 0.28);
          const labelSize = styles.titleSize || newSize * 0.33;
          label.style.fontSize = labelSize + "px";
         }
         if (sub) {
          sub.setAttribute("y", newSize * 0.4);
          const subSize = styles.subSize || newSize * 0.24;
          sub.style.fontSize = subSize + "px";
         }
       updatePingIndicator(currentNodeId);
        }
       });
       resetSizeBtn.addEventListener("click", () => {
        delete savedSizes[currentNodeId];
        const defaultSize = getDefaultSize();
        sizeSlider.value = defaultSize;
        sizeValue.textContent = defaultSize;
        const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
        if (nodeGroup) {
         const oldShape = nodeGroup.querySelector(".node-circle");
         if (oldShape) oldShape.remove();
         const shapeType = (NODE_DATA[currentNodeId] && NODE_DATA[currentNodeId].shape) || "circle";
         const newShape = createNodeShape(currentNodeId, defaultSize);
         nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
         const styles = resolveStylesForNode(currentNodeId);
         if (styles.circleColor) newShape.style.fill = styles.circleColor;
      if (styles.circleBorder) newShape.style.stroke = styles.circleBorder;
         const label = nodeGroup.querySelector(".node-label");
         const sub = nodeGroup.querySelector(".node-sub");
         if (label) {
          label.setAttribute("y", -defaultSize * 0.28);
          const labelSize = styles.titleSize || defaultSize * 0.33;
          label.style.fontSize = labelSize + "px";
         }
         if (sub) {
          sub.setAttribute("y", defaultSize * 0.4);
          const subSize = styles.subSize || defaultSize * 0.24;
          sub.style.fontSize = subSize + "px";
         }
          updatePingIndicator(currentNodeId);
      
        }
       });
       const applyStyle = (property, value) => {
        const styleEntry = ensureStyleEntry(currentNodeId);
        const scopeKey = currentStyleScope || "all";
        if (!styleEntry[scopeKey]) styleEntry[scopeKey] = {};
        styleEntry[scopeKey][property] = value;
        const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
        if (!nodeGroup) return;
        const shapeEl = nodeGroup.querySelector(".node-circle");
        const label = nodeGroup.querySelector(".node-label");
        const sub = nodeGroup.querySelector(".node-sub");
        if (property === "circleColor" && shapeEl) shapeEl.style.fill = value;
      else if (property === "circleBorder" && shapeEl) shapeEl.style.stroke = value;
        else if (property === "titleColor" && label) label.style.fill = value;
        else if (property === "titleFont" && label) label.style.fontFamily = value;
        else if (property === "titleSize" && label) label.style.fontSize = value + "px";
        else if (property === "subColor" && sub) sub.style.fill = value;
        else if (property === "subFont" && sub) sub.style.fontFamily = value;
        else if (property === "subSize" && sub) sub.style.fontSize = value + "px";
       };
       document.getElementById("circle-color").addEventListener("input", (e) => applyStyle("circleColor", e.target.value), );
      document.getElementById("circle-border").addEventListener("input", (e) => applyStyle("circleBorder", e.target.value), );
       document.getElementById("title-color").addEventListener("input", (e) => applyStyle("titleColor", e.target.value), );
       document.getElementById("title-font").addEventListener("change", (e) => applyStyle("titleFont", e.target.value), );
       document.getElementById("title-size").addEventListener("input", (e) => applyStyle("titleSize", parseInt(e.target.value, 10)), );
       document.getElementById("sub-color").addEventListener("input", (e) => applyStyle("subColor", e.target.value), );
       document.getElementById("sub-font").addEventListener("change", (e) => applyStyle("subFont", e.target.value), );
       document.getElementById("sub-size").addEventListener("input", (e) => applyStyle("subSize", parseInt(e.target.value, 10)), );
       document.getElementById("title-offset-y").addEventListener("input", (e) => {
        applyStyle("titleOffsetY", parseInt(e.target.value, 10) || 0);
        forgeTheTopology();
        if (currentNodeId) claimTheImmortal(currentNodeId);
       });
       document.getElementById("title-offset-x").addEventListener("input", (e) => {
        applyStyle("titleOffsetX", parseInt(e.target.value, 10) || 0);
        forgeTheTopology();
        if (currentNodeId) claimTheImmortal(currentNodeId);
       });
       document.getElementById("sub-offset-y").addEventListener("input", (e) => {
        applyStyle("subOffsetY", parseInt(e.target.value, 10) || 0);
        forgeTheTopology();
        if (currentNodeId) claimTheImmortal(currentNodeId);
       });
       document.getElementById("sub-offset-x").addEventListener("input", (e) => {
        applyStyle("subOffsetX", parseInt(e.target.value, 10) || 0);
        forgeTheTopology();
        if (currentNodeId) claimTheImmortal(currentNodeId);
       });
      document.getElementById("ping-offset-x").addEventListener("input", (e) => {
      applyStyle("pingOffsetX", parseInt(e.target.value, 10) || 0);
      updatePingIndicator(currentNodeId);
      if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      
      document.getElementById("ping-offset-y").addEventListener("input", (e) => {
      applyStyle("pingOffsetY", parseInt(e.target.value, 10) || 0);
      updatePingIndicator(currentNodeId);
      if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      
       document.getElementById("reset-styles").addEventListener("click", () => {
        delete savedStyles[currentNodeId];
        forgeTheTopology();
        claimTheImmortal(currentNodeId);
       });
       document.getElementById("style-scope").addEventListener("change", (e) => {
        currentStyleScope = e.target.value || "all";
        claimTheImmortal(currentNodeId);
       });
       document.getElementById("shape-select").addEventListener("change", (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId]) return;
        const shape = e.target.value || "circle";
        NODE_DATA[currentNodeId].shape = shape;
        const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
        if (!nodeGroup) return;
        const oldShape = nodeGroup.querySelector(".node-circle");
        if (oldShape) oldShape.remove();
        const size = savedSizes[currentNodeId] || getDefaultSize();
        const newShape = createNodeShape(currentNodeId, size);
        nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
       });
       const addNoteBtn = document.getElementById("add-note-btn");
       const noteInput = document.getElementById("new-note-input");
       addNoteBtn.addEventListener("click", () => {
        const newNote = noteInput.value.trim();
        if (newNote && currentNodeId && NODE_DATA[currentNodeId]) {
         NODE_DATA[currentNodeId].notes.push(newNote);
         claimTheImmortal(currentNodeId);
         noteInput.value = "";
        }
       });
       noteInput.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
         addNoteBtn.click();
        }
       });
       
       document.getElementById('node-pingable').addEventListener('change', (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId]) return;
        if (!NODE_DATA[currentNodeId].ping) {
         NODE_DATA[currentNodeId].ping = {
          enabled: false,
          protocol: 'http',
          customUrl: '',
          timeout: 3000,
          status: 'unknown',
          lastCheck: null
         };
        }
        NODE_DATA[currentNodeId].ping.enabled = e.target.checked;
        document.getElementById('node-ping-options').style.display = e.target.checked ? 'block' : 'none';
        forgeTheTopology();
       });
       
       document.getElementById('node-ping-protocol').addEventListener('change', (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId].ping) return;
        NODE_DATA[currentNodeId].ping.protocol = e.target.value;
        document.getElementById('node-custom-url-container').style.display = 
         e.target.value === 'custom' ? 'block' : 'none';
       });
       
       document.getElementById('node-custom-url').addEventListener('change', (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId].ping) return;
        NODE_DATA[currentNodeId].ping.customUrl = e.target.value.trim();
       });
       
       document.getElementById('node-ping-timeout').addEventListener('change', (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId].ping) return;
        NODE_DATA[currentNodeId].ping.timeout = parseInt(e.target.value) || 3000;
       });
       
       document.getElementById('check-ping-now').addEventListener('click', () => {
        if (!currentNodeId) return;
        checkNodeStatus(currentNodeId);
       });
       
       document.getElementById("edge-width").addEventListener("input", () => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        const v = parseInt(document.getElementById("edge-width").value, 10);
        if (Number.isNaN(v) || v <= 0) return;
        edge.width = v;
        saveEdgeData();
        const el = document.querySelector(`.edge[data-edge-id="${currentEdgeId}"]`, );
        if (el) el.style.strokeWidth = v;
       });
       document.getElementById("edge-color").addEventListener("input", () => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        const color = document.getElementById("edge-color").value;
        edge.color = color;
        saveEdgeData();
        const el = document.querySelector(`.edge[data-edge-id="${currentEdgeId}"]`, );
        if (el) el.style.stroke = color;
        forgeTheLegend();
       });
       document.getElementById("edge-direction").addEventListener("change", () => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        edge.direction = document.getElementById("edge-direction").value;
        saveEdgeData();
        forgeTheTopology();
        selectTheConnection(currentEdgeId);
       });
       document.getElementById("edge-line-style").addEventListener("change", () => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        edge.lineStyle = document.getElementById("edge-line-style").value;
        saveEdgeData();
        forgeTheTopology();
        selectTheConnection(currentEdgeId);
       });
       const addEdgeNoteBtn = document.getElementById("add-edge-note");
       const newEdgeNoteInput = document.getElementById("new-edge-note");
       addEdgeNoteBtn.addEventListener("click", () => {
        const txt = newEdgeNoteInput.value.trim();
        if (!txt || !currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        edge.notes.push(txt);
        saveEdgeData();
        newEdgeNoteInput.value = "";
        selectTheConnection(currentEdgeId);
       });
       newEdgeNoteInput.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
         addEdgeNoteBtn.click();
        }
       });
      function selectTheRect(id) {
      currentRectId = id;
      document.getElementById("node-panel").style.display = "none";
      document.getElementById("edge-panel").style.display = "none";
      document.getElementById("text-panel").style.display = "none";
      document.getElementById("rect-panel").style.display = "block";
      document.getElementById("topology-toolbar").style.display = "none";
      
      const rect = RECT_DATA.list.find(r => r.id === id);
      if (!rect) return;
      
      document.getElementById("rect-title").textContent = "";
      document.getElementById("rect-color").value = rect.color || "#f97316";
      document.getElementById("rect-border-color").value = rect.borderColor || rect.color || "#f97316";
      document.getElementById("rect-border-width").value = rect.borderWidth !== undefined ? rect.borderWidth : 2;
      document.getElementById("rect-style-select").value = rect.style || "filled";
      document.getElementById("rect-fill-row").style.display = (rect.style === "outlined") ? "none" : "flex";
      
      const list = document.getElementById("rect-notes");
      list.innerHTML = "";
      (rect.notes || []).forEach((note, i) => {
      const li = document.createElement("li");
      const txt = document.createElement("span");
      txt.textContent = note;
      txt.style.flex = "1";
      const del = document.createElement("span");
      del.className = "delete-note";
      del.textContent = "‚úï";
      del.addEventListener("click", (e) => {
      e.stopPropagation();
      challengeTheImmortal("Delete this note?", () => {
        rect.notes.splice(i, 1);
        selectTheRect(id);
      });
      });
      li.appendChild(txt);
      li.appendChild(del);
      list.appendChild(li);
      });
      
      forgeTheTopology();
      }
      
      document.getElementById("rect-color").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      rect.color = document.getElementById("rect-color").value;
      forgeTheTopology();
      });
      
      document.getElementById("rect-border-color").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      rect.borderColor = document.getElementById("rect-border-color").value;
      forgeTheTopology();
      });
      
      document.getElementById("rect-border-width").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      rect.borderWidth = parseInt(document.getElementById("rect-border-width").value) || 2;
      forgeTheTopology();
      });
      
      document.getElementById("rect-style-select").addEventListener("change", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      rect.style = document.getElementById("rect-style-select").value;
      forgeTheTopology();
      selectTheRect(currentRectId);
      });
      
      document.getElementById("add-rect-note").addEventListener("click", () => {
      const input = document.getElementById("new-rect-note");
      const txt = input.value.trim();
      if (!txt || !currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      if (!rect.notes) rect.notes = [];
      rect.notes.push(txt);
      input.value = "";
      selectTheRect(currentRectId);
      });
      
      document.getElementById("new-rect-note").addEventListener("keypress", (e) => {
      if (e.key === "Enter") {
      document.getElementById("add-rect-note").click();
      }
      });
      
      document.getElementById("delete-rect").addEventListener("click", () => {
      if (!currentRectId) return;
      challengeTheImmortal("Delete this box?", () => {
      RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== currentRectId);
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      });
      });
       document.getElementById("delete-edge").addEventListener("click", () => {
        if (!currentEdgeId) return;
        challengeTheImmortal("Are you sure you want to delete this line?",
         () => {
          EDGE_DATA.list = EDGE_DATA.list.filter(
           (e) => e.id !== currentEdgeId, );
          saveEdgeData();
          currentEdgeId = null;
          forgeTheTopology();
          const availableNodes = Object.keys(NODE_DATA);
          if (availableNodes.length > 0) {
           claimTheImmortal(availableNodes[0]);
          } else {
           document.getElementById("node-panel").style.display = "none";
           document.getElementById("edge-panel").style.display = "none";
           document.getElementById("topology-toolbar", ).style.display = "none";
          }
         }, );
       });
       document.getElementById("add-line-btn").addEventListener("click", () => {
        if (!currentNodeId) return;
        const select = document.getElementById("add-line-select");
        const directionSelect = document.getElementById("add-line-direction");
        const colorInput = document.getElementById("add-line-color");
        const targetId = select.value;
        if (!targetId || targetId === currentNodeId) return;
        const direction = directionSelect.value || "none";
        const lineColor = colorInput.value || "#475569";
        const newId = `${currentNodeId}-${targetId}-${Date.now()}`;
        const newEdge = {
         id: newId,
         from: currentNodeId,
         to: targetId,
         width: 4,
         color: lineColor,
         direction: direction,
         type: "main",
         notes: [],
         fromPort: "",
         toPort: "",
        };
        EDGE_DATA.list.push(newEdge);
        saveEdgeData();
        forgeTheTopology();
        claimTheImmortal(currentNodeId);
       });
       let currentTextId = null;
       let rectStartPoint = null;
       let rectPreviewEl = null;
       let rectStyle = "filled";
       let freeDrawPoints = [];
       let freeDrawPolylineEl = null;
       let freeDrawPointEls = [];
       const drawToggleBtn = document.getElementById("draw-toggle");
       const drawUndoBtn = document.getElementById("draw-undo");
       const drawColorInput = document.getElementById("draw-color");
       const drawStyleSelect = document.getElementById("draw-style");
       const drawArrowSelect = document.getElementById("draw-arrow");
       const svgMap = document.getElementById("map");
      
       function updateFreeDrawGraphics() {
        const ns = "http://www.w3.org/2000/svg";
        const svg = svgMap;
        if (!freeDrawPolylineEl && freeDrawPoints.length > 0) {
         freeDrawPolylineEl = document.createElementNS(ns, "polyline");
         freeDrawPolylineEl.classList.add("edge", "free-preview");
         freeDrawPolylineEl.setAttribute("fill", "none");
         svg.appendChild(freeDrawPolylineEl);
        }
        if (freeDrawPolylineEl) {
         if (freeDrawPoints.length === 0) {
          freeDrawPolylineEl.remove();
          freeDrawPolylineEl = null;
         } else {
          const ptsStr = freeDrawPoints.map((p) => `${p.x},${p.y}`).join(" ");
          freeDrawPolylineEl.setAttribute("points", ptsStr);
          freeDrawPolylineEl.style.stroke = drawColorInput.value || "#475569";
          freeDrawPolylineEl.style.strokeWidth = 3;
          const lineStyle = drawStyleSelect.value || "solid";
          if (lineStyle === "dashed") {
           freeDrawPolylineEl.style.strokeDasharray = "10,5";
          } else if (lineStyle === "dotted") {
           freeDrawPolylineEl.style.strokeDasharray = "2,4";
          } else {
           freeDrawPolylineEl.style.strokeDasharray = "none";
          }
         }
        }
        freeDrawPointEls.forEach((el) => el.remove());
        freeDrawPointEls = [];
        freeDrawPoints.forEach((p, idx) => {
         const c = document.createElementNS(ns, "circle");
         c.classList.add("free-point");
         c.setAttribute("cx", p.x);
         c.setAttribute("cy", p.y);
         c.setAttribute("r", 5);
         c.dataset.index = String(idx);
         c.addEventListener("mousedown", (e) => {
          if (!freeDrawMode) return;
          e.preventDefault();
          e.stopPropagation();
          let dragging = true;
          const svgEl = svgMap;
          const moveHandler = (ev) => {
           if (!dragging) return;
           const pt = svgEl.createSVGPoint();
           pt.x = ev.clientX;
           pt.y = ev.clientY;
           const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
           const i = parseInt(c.dataset.index, 10);
           if (Number.isNaN(i) || !freeDrawPoints[i]) return;
           freeDrawPoints[i].x = svgP.x;
           freeDrawPoints[i].y = svgP.y;
           updateFreeDrawGraphics();
          };
          const upHandler = () => {
           dragging = false;
           document.removeEventListener("mousemove", moveHandler);
           document.removeEventListener("mouseup", upHandler);
          };
          document.addEventListener("mousemove", moveHandler);
          document.addEventListener("mouseup", upHandler);
         });
         c.addEventListener("touchstart",
          (e) => {
           if (!freeDrawMode) return;
           e.preventDefault();
           e.stopPropagation();
           let dragging = true;
           const svgEl = svgMap;
           const touchMoveHandler = (ev) => {
            if (!dragging || !ev.touches[0]) return;
            const pt = svgEl.createSVGPoint();
            pt.x = ev.touches[0].clientX;
            pt.y = ev.touches[0].clientY;
            const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
            const i = parseInt(c.dataset.index, 10);
            if (Number.isNaN(i) || !freeDrawPoints[i]) return;
            freeDrawPoints[i].x = svgP.x;
            freeDrawPoints[i].y = svgP.y;
            updateFreeDrawGraphics();
           };
           const touchUpHandler = () => {
            dragging = false;
            document.removeEventListener("touchmove", touchMoveHandler, );
            document.removeEventListener("touchend", touchUpHandler, );
           };
           document.addEventListener("touchmove", touchMoveHandler);
           document.addEventListener("touchend", touchUpHandler);
          }, {
           passive: false
          }, );
         svg.appendChild(c);
         freeDrawPointEls.push(c);
        });
        drawUndoBtn.style.display = freeDrawPoints.length ? "inline-block" : "none";
       }
      
       function addFreeDrawPoint(x, y) {
        freeDrawPoints.push({
         x,
         y
        });
        updateFreeDrawGraphics();
       }
      
       function startFreeDraw() {
        freeDrawMode = true;
        freeDrawPoints = [];
        if (freeDrawPolylineEl) {
         freeDrawPolylineEl.remove();
         freeDrawPolylineEl = null;
        }
        freeDrawPointEls.forEach((el) => el.remove());
        freeDrawPointEls = [];
        svgMap.style.cursor = "crosshair";
        drawToggleBtn.textContent = "Done";
        drawUndoBtn.style.display = "none";
       }
      
       function finishFreeDraw() {
        freeDrawMode = false;
        svgMap.style.cursor = "";
        drawToggleBtn.textContent = "‚úèÔ∏è";
        if (freeDrawPoints.length >= 2) {
         const color = drawColorInput.value || "#475569";
         const lineStyle = drawStyleSelect.value || "solid";
         const arrowDir = drawArrowSelect.value || "none";
         const newId = "custom-" + Date.now();
         const pointsCopy = freeDrawPoints.map((p) => ({
          x: p.x,
          y: p.y,
         }));
         EDGE_DATA.list.push({
          id: newId,
          type: "custom",
          color,
          width: 4,
          lineStyle: lineStyle,
          direction: arrowDir,
          points: pointsCopy,
          notes: [],
         });
         saveEdgeData();
         freeDrawPoints = [];
         if (freeDrawPolylineEl) {
          freeDrawPolylineEl.remove();
          freeDrawPolylineEl = null;
         }
         freeDrawPointEls.forEach((el) => el.remove());
         freeDrawPointEls = [];
         forgeTheTopology();
         selectTheConnection(newId);
        } else {
         freeDrawPoints = [];
         if (freeDrawPolylineEl) {
          freeDrawPolylineEl.remove();
          freeDrawPolylineEl = null;
         }
         freeDrawPointEls.forEach((el) => el.remove());
         freeDrawPointEls = [];
         forgeTheLegend();
        }
        drawUndoBtn.style.display = "none";
       }
       drawToggleBtn.addEventListener("click", () => {
        if (currentView.mode === "rack") {
         alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
         return;
        }
        
        if (freeDrawMode) {
         finishFreeDraw();
        } else {
         startFreeDraw();
        }
       });
       drawUndoBtn.addEventListener("click", () => {
        if (!freeDrawMode || !freeDrawPoints.length) return;
        freeDrawPoints.pop();
        updateFreeDrawGraphics();
       });
       const drawToolbar = document.getElementById("draw-toolbar");
       drawToolbar.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       drawToolbar.addEventListener("click", (e) => {
        if (e.target !== drawToggleBtn && e.target !== drawUndoBtn) {
         e.stopPropagation();
        }
       });
       drawStyleSelect.addEventListener("change", () => {
        if (freeDrawMode) {
         updateFreeDrawGraphics();
        }
       });
       drawArrowSelect.addEventListener("change", () => {
        if (freeDrawMode) {
         updateFreeDrawGraphics();
        }
       });
       drawColorInput.addEventListener("input", () => {
        if (freeDrawMode) {
         updateFreeDrawGraphics();
        }
       });
       drawStyleSelect.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       drawStyleSelect.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       drawArrowSelect.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       drawArrowSelect.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       drawColorInput.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       drawColorInput.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       svgMap.addEventListener("click", (e) => {
        if (!freeDrawMode) return;
        if (e.button !== 0) return;
        const target = e.target;
        if (target && target.classList && target.classList.contains("free-point")) return;
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        addFreeDrawPoint(svgP.x, svgP.y);
       });
       svgMap.addEventListener("touchend",
        (e) => {
         if (!freeDrawMode) return;
         const target = e.target;
         if (target && target.classList && target.classList.contains("free-point")) return;
         if (e.changedTouches && e.changedTouches[0]) {
          e.preventDefault();
          const svgEl = svgMap;
          const pt = svgEl.createSVGPoint();
          pt.x = e.changedTouches[0].clientX;
          pt.y = e.changedTouches[0].clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          addFreeDrawPoint(svgP.x, svgP.y);
         }
        }, {
         passive: false
        }, );
       const settingsBtn = document.getElementById("settings-btn");
      
       const rectToggleBtn = document.getElementById("rect-toggle");
       const rectStyleSelect = document.getElementById("rect-style");
      
       function updateRectPreview() {
        if (!rectPreviewEl || !rectStartPoint) return;
        
        const ns = "http://www.w3.org/2000/svg";
        const svg = svgMap;
        
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
       }
      
       function startRectDraw() {
        rectDrawMode = true;
        rectStartPoint = null;
        rectPreviewEl = null;
        svgMap.style.cursor = "crosshair";
        rectToggleBtn.textContent = "Done";
        rectStyle = rectStyleSelect.value || "filled";
        
        if (freeDrawMode) {
         finishFreeDraw();
        }
        updateRectangleDeleteButtons();
       }
      
       function finishRectDraw() {
        rectDrawMode = false;
        svgMap.style.cursor = "";
        rectToggleBtn.textContent = "‚ñ≠";
        
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
       }
        updateRectangleDeleteButtons();
      
       rectToggleBtn.addEventListener("click", () => {
        if (currentView.mode === "rack") {
         alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
         return;
        }
        
        if (rectDrawMode) {
         finishRectDraw();
        } else {
         startRectDraw();
        }
       });
      
       rectStyleSelect.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       rectStyleSelect.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       rectStyleSelect.addEventListener("change", () => {
        if (rectDrawMode) {
         rectStyle = rectStyleSelect.value || "filled";
        }
       });
      
       svgMap.addEventListener("mousedown", (e) => {
        if (!rectDrawMode) return;
        if (e.button !== 0) return;
        e.preventDefault();
        e.stopPropagation();
        
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        rectStartPoint = { x: svgP.x, y: svgP.y };
        
        const ns = "http://www.w3.org/2000/svg";
        rectPreviewEl = document.createElementNS(ns, "rect");
        rectPreviewEl.classList.add("rect-preview");
        rectPreviewEl.setAttribute("x", svgP.x);
        rectPreviewEl.setAttribute("y", svgP.y);
        rectPreviewEl.setAttribute("width", 0);
        rectPreviewEl.setAttribute("height", 0);
        
        const color = drawColorInput.value || "#f97316";
        rectPreviewEl.style.stroke = color;
        rectPreviewEl.style.strokeWidth = 2;
        rectPreviewEl.style.strokeDasharray = "5,5";
        
        if (rectStyle === "filled") {
         rectPreviewEl.style.fill = color;
         rectPreviewEl.style.fillOpacity = "0.3";
        } else {
         rectPreviewEl.style.fill = "none";
        }
        
        svgEl.appendChild(rectPreviewEl);
       });
      
       svgMap.addEventListener("mousemove", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        
        rectPreviewEl.setAttribute("x", x);
        rectPreviewEl.setAttribute("y", y);
        rectPreviewEl.setAttribute("width", width);
        rectPreviewEl.setAttribute("height", height);
       });
      
       svgMap.addEventListener("mouseup", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        
        if (width > 10 && height > 10) {
      pushUndo("draw zone"); 
         const color = drawColorInput.value || "#f97316";
         const newId = "rect-" + Date.now();
         
         const lineStyle = document.getElementById("draw-style").value || "solid";
         RECT_DATA.list.push({
          id: newId,
          x: x,
          y: y,
          width: width,
          height: height,
          color: color,
          style: rectStyle,
          lineStyle: lineStyle,
          notes: []
         });
         
         forgeTheTopology();
        }
        
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
       });
      
       let rectTouchStart = null;
       
       svgMap.addEventListener("touchstart", (e) => {
        if (!rectDrawMode) return;
        if (e.touches.length !== 1) return;
        
        e.preventDefault();
        const touch = e.touches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        rectStartPoint = { x: svgP.x, y: svgP.y };
        rectTouchStart = { x: svgP.x, y: svgP.y };
        
        const ns = "http://www.w3.org/2000/svg";
        rectPreviewEl = document.createElementNS(ns, "rect");
        rectPreviewEl.classList.add("rect-preview");
        rectPreviewEl.setAttribute("x", svgP.x);
        rectPreviewEl.setAttribute("y", svgP.y);
        rectPreviewEl.setAttribute("width", 0);
        rectPreviewEl.setAttribute("height", 0);
        
        const color = drawColorInput.value || "#f97316";
        rectPreviewEl.style.stroke = color;
        rectPreviewEl.style.strokeWidth = 2;
        rectPreviewEl.style.strokeDasharray = "5,5";
        
        if (rectStyle === "filled") {
         rectPreviewEl.style.fill = color;
         rectPreviewEl.style.fillOpacity = "0.3";
        } else {
         rectPreviewEl.style.fill = "none";
        }
        
        svgEl.appendChild(rectPreviewEl);
       }, { passive: false });
      
       svgMap.addEventListener("touchmove", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        if (e.touches.length !== 1) return;
        
        e.preventDefault();
        const touch = e.touches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        
        rectPreviewEl.setAttribute("x", x);
        rectPreviewEl.setAttribute("y", y);
        rectPreviewEl.setAttribute("width", width);
        rectPreviewEl.setAttribute("height", height);
       }, { passive: false });
      
       svgMap.addEventListener("touchend", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        if (!rectTouchStart) return;
        
        e.preventDefault();
        const touch = e.changedTouches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        
        if (width > 10 && height > 10) {
      pushUndo("draw zone");
         const color = drawColorInput.value || "#f97316";
         const newId = "rect-" + Date.now();
         
         const lineStyle = document.getElementById("draw-style").value || "solid";
         RECT_DATA.list.push({
          id: newId,
          x: x,
          y: y,
          width: width,
          height: height,
          color: color,
          style: rectStyle,
          lineStyle: lineStyle,
          notes: []
         });
         
         forgeTheTopology();
        }
        
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
        rectTouchStart = null;
       }, { passive: false });
      
       const textToggleBtn = document.getElementById("text-toggle");
       
       function startTextMode() {
        textDrawMode = true;
        svgMap.style.cursor = "crosshair";
        textToggleBtn.textContent = "Done";
        textToggleBtn.style.background = "var(--accent)";
        textToggleBtn.style.color = "var(--bg)";
        
        if (freeDrawMode) {
         finishFreeDraw();
        }
        if (rectDrawMode) {
         finishRectDraw();
        }
        
        updateTextDeleteButtons();
       }
       
       function finishTextMode() {
        textDrawMode = false;
        svgMap.style.cursor = "";
        textToggleBtn.textContent = "T";
        textToggleBtn.style.background = "";
        textToggleBtn.style.color = "";
        updateTextDeleteButtons();
       }
       
       textToggleBtn.addEventListener("click", () => {
        if (currentView.mode === "rack") {
         alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
         return;
        }
        
        if (textDrawMode) {
         finishTextMode();
        } else {
         startTextMode();
        }
       });
       
       function handleTextPlacement(e) {
        if (!textDrawMode) return;
        
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        const newId = "text-" + Date.now();
      pushUndo("add text");
        TEXT_DATA.list.push({
         id: newId,
         x: svgP.x,
         y: svgP.y,
         content: "New Text",
         fontSize: 18,
         color: "#e2e8f0",
         fontWeight: "normal",
         fontStyle: "normal",
         textAlign: "start",
         textDecoration: "none",
         bgColor: "#000000",
         bgEnabled: false,
         opacity: 1
        });
        
        forgeTheTopology();
        
        showTextPanel(newId);
       }
       
       svgMap.addEventListener("click", (e) => {
        if (!textDrawMode) return;
        if (e.target.closest('.text-delete-btn')) return;
        if (e.target.closest('.text-group')) return;
        
        e.preventDefault();
        e.stopPropagation();
        handleTextPlacement(e);
       });
       
       svgMap.addEventListener("touchend", (e) => {
        if (!textDrawMode) return;
        if (e.target.closest('.text-delete-btn')) return;
        if (e.target.closest('.text-group')) return;
        if (e.touches.length > 0) return;
        
        e.preventDefault();
        const touch = e.changedTouches[0];
        const fakeEvent = {
         clientX: touch.clientX,
         clientY: touch.clientY,
         preventDefault: () => {},
         stopPropagation: () => {}
        };
        handleTextPlacement(fakeEvent);
       }, { passive: false });
       
       function showTextPanel(textId) {
        currentTextId = textId;
        const textItem = TEXT_DATA.list.find(t => t.id === textId);
        if (!textItem) return;
        
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        
        const textPanel = document.getElementById("text-panel");
        textPanel.style.display = "block";
        
        document.getElementById("text-content").value = textItem.content;
        document.getElementById("text-font-size").value = textItem.fontSize;
        document.getElementById("text-color").value = textItem.color;
        document.getElementById("text-font-weight").value = textItem.fontWeight;
        document.getElementById("text-font-style").value = textItem.fontStyle;
        document.getElementById("text-align").value = textItem.textAlign;
        document.getElementById("text-decoration").value = textItem.textDecoration;
        document.getElementById("text-bg-color").value = textItem.bgColor;
        document.getElementById("text-bg-enabled").checked = textItem.bgEnabled;
        document.getElementById("text-opacity").value = textItem.opacity;
        document.getElementById("text-opacity-val").textContent = Math.round(textItem.opacity * 100) + "%";
       }
       
       function updateTextDeleteButtons() {
        const deleteButtons = document.querySelectorAll('.text-delete-btn');
        deleteButtons.forEach(btn => {
         btn.style.display = textDrawMode ? 'block' : 'none';
        });
       }
       
       function deleteText(textId) {
      pushUndo("delete text");
        TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== textId);
        forgeTheTopology();
        
        if (currentTextId === textId) {
         document.getElementById("text-panel").style.display = "none";
         currentTextId = null;
        }
       }
       
       document.getElementById("text-content").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
      pushUndo("edit text");
         textItem.content = e.target.value;
         forgeTheTopology();
        }
       });
       
       document.getElementById("text-font-size").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         textItem.fontSize = parseInt(e.target.value);
         forgeTheTopology();
        }
       });
       
       document.getElementById("text-color").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         textItem.color = e.target.value;
         forgeTheTopology();
        }
       });
       
       document.getElementById("text-font-weight").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         textItem.fontWeight = e.target.value;
         forgeTheTopology();
        }
       });
       
       document.getElementById("text-font-style").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         textItem.fontStyle = e.target.value;
         forgeTheTopology();
        }
       });
       
       document.getElementById("text-align").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         textItem.textAlign = e.target.value;
         forgeTheTopology();
        }
       });
       
       document.getElementById("text-decoration").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         textItem.textDecoration = e.target.value;
         forgeTheTopology();
        }
       });
       
       document.getElementById("text-bg-color").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         textItem.bgColor = e.target.value;
         forgeTheTopology();
        }
       });
       
       document.getElementById("text-bg-enabled").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         textItem.bgEnabled = e.target.checked;
         forgeTheTopology();
        }
       });
       
       document.getElementById("text-opacity").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         textItem.opacity = parseFloat(e.target.value);
         document.getElementById("text-opacity-val").textContent = Math.round(textItem.opacity * 100) + "%";
         forgeTheTopology();
        }
       });
       
       document.getElementById("delete-text").addEventListener("click", () => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         challengeTheImmortal(`Delete text "${textItem.content.substring(0, 30)}..."?`, () => {
          deleteText(currentTextId);
         });
        }
       });
      
       const settingsModal = document.getElementById("settings-modal");
       const settingsClose = document.getElementById("settings-close");
       settingsBtn.addEventListener("click", () => {	 
      document.getElementById("page-bg-color").value = rgbaToHex(PAGE_STATE.background) || "#050608";
        document.getElementById("topbar-bg-color").value = rgbaToHex(PAGE_STATE.topbarBg) || "#0b0e13";
        document.getElementById("topbar-border-color").value = rgbaToHex(PAGE_STATE.topbarBorder) || "#1f2533";	 
      document.getElementById("panel-color").value = rgbaToHex(PAGE_STATE.panel) || "#0b0e13";
      document.getElementById("panel-alt-color").value = PAGE_STATE.panelAlt || "#10141b";
       document.getElementById("sidebar-bg-color").value = PAGE_STATE.sidebarBg || "#10141b";
       document.getElementById("btn-bg-color").value = PAGE_STATE.btnBg || "#0b0e13";
       document.getElementById("btn-text-color").value = PAGE_STATE.btnText || "#e2e8f0";
       document.getElementById("tag-fill-color").value = PAGE_STATE.tagFill || "#1e293b";
       document.getElementById("tag-text-color").value = PAGE_STATE.tagText || "#e2e8f0";
       document.getElementById("tag-border-color").value = PAGE_STATE.tagBorder || "#475569";
       document.getElementById("input-bg-color").value = PAGE_STATE.inputBg || "#0b0e13";
       document.getElementById("input-text-color").value = PAGE_STATE.inputText || "#e2e8f0";
document.getElementById("input-border-color").value = PAGE_STATE.inputBorder || "#1f2937";
       document.getElementById("input-font-family").value = PAGE_STATE.inputFont || "Inter, system-ui, sans-serif";
       document.getElementById("input-font-size").value = PAGE_STATE.inputFontSize || 14;
       document.getElementById("toolbar-bg-color").value = PAGE_STATE.toolbarBg || "#0f172a";
       document.getElementById("toolbar-border-color").value = PAGE_STATE.toolbarBorder || "#1f2937";
       document.getElementById("toolbar-text-color").value = PAGE_STATE.toolbarText || "#94a3b8";
       document.getElementById("toolbar-btn-bg-color").value = PAGE_STATE.toolbarBtnBg || "#0b0e13";
       document.getElementById("toolbar-btn-text-color").value = PAGE_STATE.toolbarBtnText || "#e2e8f0";
       document.getElementById("minimap-dots-color").value = PAGE_STATE.minimapDots || "#94a3b8";
       document.getElementById("canvas-hint-enabled").checked = PAGE_STATE.canvasHintEnabled !== false;
       document.getElementById("canvas-hint-bg-color").value = PAGE_STATE.canvasHintBg || "#0f172a";
       document.getElementById("canvas-hint-text-color").value = PAGE_STATE.canvasHintColor || "#94a3b8";
       document.getElementById("canvas-hint-text").value = PAGE_STATE.canvasHintText || "";
      document.getElementById("accent-color").value = rgbaToHex(PAGE_STATE.accent) || "#4fd1c5";
      document.getElementById("danger-color").value = rgbaToHex(PAGE_STATE.danger) || "#f56565";
      document.getElementById("text-main-color").value = rgbaToHex(PAGE_STATE.textMain) || "#e2e8f0";
      document.getElementById("text-soft-color").value = PAGE_STATE.textSoft || "#94a3b8";
       document.getElementById("node-fill-color").value = PAGE_STATE.nodeFill || "#1e293b";
       document.getElementById("node-stroke-color").value = PAGE_STATE.nodeStroke || "#475569";
       document.getElementById("node-title-color").value = PAGE_STATE.nodeTitle || "#e2e8f0";
       document.getElementById("node-sub-color").value = PAGE_STATE.nodeSub || "#94a3b8";
       document.getElementById("node-title-size").value = PAGE_STATE.nodeTitleSize || 18;
       document.getElementById("node-sub-size").value = PAGE_STATE.nodeSubSize || 13;
       document.getElementById("node-font-family").value = PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
       document.getElementById("default-edge-color").value = PAGE_STATE.defaultEdge || "#475569";
       document.getElementById("selection-handle-color").value = PAGE_STATE.selectionHandle || "#f59e0b";
       document.getElementById("selection-handle-size").value = PAGE_STATE.selectionHandleSize || 8;
       document.getElementById("group-indicator-color").value = PAGE_STATE.groupIndicator || "#4fd1c5";
       document.getElementById("canvas-gradient-top").value = PAGE_STATE.canvasGradientTop || "#1e2532";
       document.getElementById("canvas-gradient-bottom").value = PAGE_STATE.canvasGradientBottom || "#050608";
       document.getElementById("canvas-border-color").value = PAGE_STATE.canvasBorder || "#475569";
       document.getElementById("canvas-grid-color").value = PAGE_STATE.canvasGrid || "#475569";
       document.getElementById("canvas-grid-size").value = PAGE_STATE.canvasGridSize || 50;
       document.getElementById("rack-frame-fill").value = PAGE_STATE.rackFrameFill || "#0f172a";
       document.getElementById("rack-frame-stroke").value = PAGE_STATE.rackFrameStroke || "#4fd1c5";
       document.getElementById("rack-line-color").value = PAGE_STATE.rackLineColor || "#475569";
       document.getElementById("rack-text-color").value = PAGE_STATE.rackTextColor || "#4fd1c5";
      
        
        document.getElementById("auto-ping-enabled").checked = autoPingEnabled;
        document.getElementById("auto-ping-interval").value = autoPingInterval;
        document.getElementById("auto-ping-settings").style.display = autoPingEnabled ? 'block' : 'none';
        
        settingsModal.classList.add("active");
       });
       settingsClose.addEventListener("click", () => {
        settingsModal.classList.remove("active");
       });
       settingsModal.addEventListener("click", (e) => {
        if (e.target === settingsModal) {
         settingsModal.classList.remove("active");
        }
       });
       document.getElementById("page-bg-color").addEventListener("input", (e) => {
        PAGE_STATE.background = e.target.value;
        wieldThePower();
       });
       document.getElementById("topbar-bg-color").addEventListener("input", (e) => {
        PAGE_STATE.topbarBg = e.target.value;
        wieldThePower();
       });
       document.getElementById("topbar-border-color").addEventListener("input", (e) => {
        PAGE_STATE.topbarBorder = e.target.value;
        wieldThePower();
       });
       document.getElementById("panel-color").addEventListener("input", (e) => {
        PAGE_STATE.panel = e.target.value;
        wieldThePower();
       });
       document.getElementById("panel-alt-color").addEventListener("input", (e) => {
       PAGE_STATE.panelAlt = e.target.value;
       wieldThePower();
      });
      document.getElementById("sidebar-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.sidebarBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("btn-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.btnBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("btn-text-color").addEventListener("input", (e) => {
       PAGE_STATE.btnText = e.target.value;
       wieldThePower();
      });
      document.getElementById("tag-fill-color").addEventListener("input", (e) => {
       PAGE_STATE.tagFill = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("tag-text-color").addEventListener("input", (e) => {
       PAGE_STATE.tagText = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
document.getElementById("tag-border-color").addEventListener("input", (e) => {
       PAGE_STATE.tagBorder = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("input-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.inputBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-text-color").addEventListener("input", (e) => {
       PAGE_STATE.inputText = e.target.value;
       wieldThePower();
      });
document.getElementById("input-border-color").addEventListener("input", (e) => {
       PAGE_STATE.inputBorder = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-font-family").addEventListener("change", (e) => {
       PAGE_STATE.inputFont = e.target.value;
       wieldThePower();
      });
document.getElementById("input-font-size").addEventListener("input", (e) => {
       PAGE_STATE.inputFontSize = parseInt(e.target.value) || 14;
       wieldThePower();
      });
      document.getElementById("toolbar-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-border-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBorder = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-text-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarText = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-btn-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBtnBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-btn-text-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBtnText = e.target.value;
       wieldThePower();
      });
      document.getElementById("minimap-dots-color").addEventListener("input", (e) => {
       PAGE_STATE.minimapDots = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("canvas-hint-enabled").addEventListener("change", (e) => {
       PAGE_STATE.canvasHintEnabled = e.target.checked;
       wieldThePower();
      });
      document.getElementById("canvas-hint-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-hint-text-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintColor = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-hint-text").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintText = e.target.value;
       wieldThePower();
      });
       document.getElementById("accent-color").addEventListener("input", (e) => {
        PAGE_STATE.accent = e.target.value;
        wieldThePower();
       });
       document.getElementById("danger-color").addEventListener("input", (e) => {
        PAGE_STATE.danger = e.target.value;
        wieldThePower();
       });
       document.getElementById("text-main-color").addEventListener("input", (e) => {
        PAGE_STATE.textMain = e.target.value;
        wieldThePower();
       });
       document.getElementById("text-soft-color").addEventListener("input", (e) => {
       PAGE_STATE.textSoft = e.target.value;
       wieldThePower();
      });
      document.getElementById("node-fill-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeFill = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-stroke-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeStroke = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-title-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeTitle = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-sub-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeSub = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-title-size").addEventListener("input", (e) => {
       PAGE_STATE.nodeTitleSize = parseInt(e.target.value) || 18;
       forgeTheTopology();
      });
      document.getElementById("node-sub-size").addEventListener("input", (e) => {
       PAGE_STATE.nodeSubSize = parseInt(e.target.value) || 13;
       forgeTheTopology();
      });
      document.getElementById("node-font-family").addEventListener("change", (e) => {
       PAGE_STATE.nodeFont = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("default-edge-color").addEventListener("input", (e) => {
       PAGE_STATE.defaultEdge = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("selection-handle-color").addEventListener("input", (e) => {
       PAGE_STATE.selectionHandle = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("selection-handle-size").addEventListener("input", (e) => {
       PAGE_STATE.selectionHandleSize = parseInt(e.target.value) || 8;
       forgeTheTopology();
      });
      document.getElementById("group-indicator-color").addEventListener("input", (e) => {
       PAGE_STATE.groupIndicator = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-gradient-top").addEventListener("input", (e) => {
       PAGE_STATE.canvasGradientTop = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-gradient-bottom").addEventListener("input", (e) => {
       PAGE_STATE.canvasGradientBottom = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-border-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasBorder = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-grid-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasGrid = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-grid-size").addEventListener("input", (e) => {
       PAGE_STATE.canvasGridSize = parseInt(e.target.value) || 50;
       forgeTheTopology();
      });
      document.getElementById("rack-frame-fill").addEventListener("input", (e) => {
       PAGE_STATE.rackFrameFill = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-frame-stroke").addEventListener("input", (e) => {
       PAGE_STATE.rackFrameStroke = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-line-color").addEventListener("input", (e) => {
       PAGE_STATE.rackLineColor = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-text-color").addEventListener("input", (e) => {
       PAGE_STATE.rackTextColor = e.target.value;
       forgeTheTopology();
      });
      
      (function initializeResizers() {
         const headerResizer = document.getElementById('header-resizer');
         const sidebarResizer = document.getElementById('sidebar-resizer');
         const mobileFooterResizer = document.getElementById('mobile-footer-resizer');
         
         let isResizing = false;
         let currentResizer = null;
         let startY = 0;
         let startX = 0;
         let startHeight = 0;
         let startWidth = 0;
         
         function getClientPos(e) {
           if (e.touches && e.touches.length > 0) {
             return { x: e.touches[0].clientX, y: e.touches[0].clientY };
           }
           return { x: e.clientX, y: e.clientY };
         }
         
         function startResize(resizer, type, e) {
           isResizing = true;
           currentResizer = type;
           const pos = getClientPos(e);
           
           if (type === 'header') {
             startY = pos.y;
             startHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--topbar-height'));
           } else if (type === 'sidebar') {
             startX = pos.x;
             startWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width'));
           } else if (type === 'mobile-footer') {
             startY = pos.y;
             const currentVh = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--mobile-footer-height'));
             startHeight = (currentVh / 100) * window.innerHeight;
           }
           
           resizer.classList.add('resizing');
           document.body.classList.add('resizing');
           document.body.style.cursor = (type === 'sidebar') ? 'col-resize' : 'row-resize';
           e.preventDefault();
         }
         
         if (headerResizer) {
           headerResizer.addEventListener('mousedown', (e) => startResize(headerResizer, 'header', e));
           headerResizer.addEventListener('touchstart', (e) => startResize(headerResizer, 'header', e), { passive: false });
         }
         
         if (sidebarResizer) {
           sidebarResizer.addEventListener('mousedown', (e) => startResize(sidebarResizer, 'sidebar', e));
           sidebarResizer.addEventListener('touchstart', (e) => startResize(sidebarResizer, 'sidebar', e), { passive: false });
         }
         
         if (mobileFooterResizer) {
           mobileFooterResizer.addEventListener('mousedown', (e) => startResize(mobileFooterResizer, 'mobile-footer', e));
           mobileFooterResizer.addEventListener('touchstart', (e) => startResize(mobileFooterResizer, 'mobile-footer', e), { passive: false });
         }
         
         function handleMove(e) {
           if (!isResizing) return;
           
           const pos = getClientPos(e);
           
           if (currentResizer === 'header') {
             const deltaY = pos.y - startY;
             const newHeight = Math.max(40, Math.min(150, startHeight + deltaY));
             document.documentElement.style.setProperty('--topbar-height', newHeight + 'px');
           } else if (currentResizer === 'sidebar') {
             const deltaX = startX - pos.x;
             const newWidth = Math.max(200, Math.min(800, startWidth + deltaX));
             document.documentElement.style.setProperty('--sidebar-width', newWidth + 'px');
           } else if (currentResizer === 'mobile-footer') {
             const deltaY = startY - pos.y;
             const newHeight = startHeight + deltaY;
             const newVh = Math.max(15, Math.min(80, (newHeight / window.innerHeight) * 100));
             document.documentElement.style.setProperty('--mobile-footer-height', newVh + 'vh');
           }
           
           e.preventDefault();
         }
         
         document.addEventListener('mousemove', handleMove);
         document.addEventListener('touchmove', handleMove, { passive: false });
         
         function handleEnd() {
           if (isResizing) {
             isResizing = false;
             
             if (currentResizer === 'header') {
               PAGE_STATE.topbarHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--topbar-height'));
               headerResizer.classList.remove('resizing');
             } else if (currentResizer === 'sidebar') {
               PAGE_STATE.sidebarWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width'));
               sidebarResizer.classList.remove('resizing');
             } else if (currentResizer === 'mobile-footer') {
               PAGE_STATE.mobileFooterHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--mobile-footer-height'));
               mobileFooterResizer.classList.remove('resizing');
             }
             
             document.body.classList.remove('resizing');
             document.body.style.cursor = '';
             currentResizer = null;
           }
         }
         
         document.addEventListener('mouseup', handleEnd);
         document.addEventListener('touchend', handleEnd);
         document.addEventListener('touchcancel', handleEnd);
       })();
       
       document.getElementById("auto-ping-enabled").addEventListener("change", (e) => {
        autoPingEnabled = e.target.checked;
        PAGE_STATE.autoPingEnabled = autoPingEnabled;
        document.getElementById("auto-ping-settings").style.display = autoPingEnabled ? 'block' : 'none';
        
        if (autoPingEnabled) {
         startAutoPing();
        } else {
         stopAutoPing();
        }
       });
       
       document.getElementById("auto-ping-interval").addEventListener("change", (e) => {
        const newInterval = parseInt(e.target.value, 10);
        if (newInterval >= 5 && newInterval <= 3600) {
         autoPingInterval = newInterval;
         PAGE_STATE.autoPingInterval = autoPingInterval;
         
         if (autoPingEnabled) {
          startAutoPing();
         }
        }
       });
       
       document.getElementById("export-data-btn").addEventListener("click", () => {
        const data = captureTheQuickening();
        const jsonStr = JSON.stringify(data, null, 2);
        const blob = new Blob([jsonStr], {
         type: "application/json"
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        const safeTitle = (PAGE_STATE.title || "network-topology").toLowerCase().replace(/[^a-z0-9\-]+/g, "-");
        const timestamp = new Date().toISOString().split("T")[0];
        a.download = `${safeTitle}-data-${timestamp}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
       });
       document.getElementById("import-data-btn").addEventListener("click", () => {
        document.getElementById("import-data-file").click();
       });
       document.getElementById("import-data-file").addEventListener("change", async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        try {
         const text = await file.text();
         const data = JSON.parse(text);
         if (!data.nodeData || !data.edgeData) {
          alert("Invalid data file. Missing required fields.");
          return;
         }
         const confirmMsg = `This will replace all current data with the imported data.\n\nImporting:\n- ${Object.keys(data.nodeData).length} nodes\n- ${data.edgeData.list?.length || 0} connections\n- ${data.documentTabs?.length || 1} tab(s)\n\nContinue?`;         if (!confirm(confirmMsg)) {
          e.target.value = "";
          return;
         }
         NODE_DATA = data.nodeData || {};
         EDGE_DATA = data.edgeData || {
          list: []
         };
         EDGE_LEGEND = data.edgeLegend || {};
         RECT_DATA = data.rectData || { list: [] };
         TEXT_DATA = data.textData || { list: [] };
         savedPositions = data.nodePositions || {};
         savedSizes = data.nodeSizes || {};
         savedStyles = data.nodeStyles || {};
         if (data.page) {
          PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, data.page, );
          wieldThePower();
         }
      
      if (data.autoPingEnabled !== undefined) {
      autoPingEnabled = data.autoPingEnabled;
      PAGE_STATE.autoPingEnabled = autoPingEnabled;
      document.getElementById("auto-ping-enabled").checked = autoPingEnabled;
      }
      
      if (data.autoPingInterval !== undefined) {
      autoPingInterval = data.autoPingInterval;
      PAGE_STATE.autoPingInterval = autoPingInterval;
      document.getElementById("auto-ping-interval").value = autoPingInterval;
      }
         if (data.canvas) {
          canvasState.zoom = data.canvas.zoom || 1;
          canvasState.panX = data.canvas.panX || 0;
          canvasState.panY = data.canvas.panY || 0;
         }
         if (data.page?.title) {
         document.title = data.page.title;
         document.querySelector(".editable-page-title", ).textContent = data.page.title;
        }
        if (data.documentTabs) {
         documentTabs = data.documentTabs;
         currentTabIndex = data.currentTabIndex || 0;
        }
        if (data.savedTopologyView) {
         savedTopologyView = data.savedTopologyView;
        }
        if (data.encryptedSections) {
         encryptedSections = data.encryptedSections;
        }
        forgeTheTopology();
         forgeTheLegend();
         updateViewBox();
      
      if (autoPingEnabled) {
      startAutoPing();
      } else {
      stopAutoPing();
      }
      
         const nodeIds = Object.keys(NODE_DATA);
         if (nodeIds.length > 0) {
          claimTheImmortal(nodeIds[0]);
         } else {
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("topology-toolbar").style.display = "none";
         }
         alert("Data imported successfully!");
         e.target.value = "";
        } catch (err) {
         console.error("Import error:", err);
         alert(`Failed to import data: ${err.message}`);
         e.target.value = "";
        }
       });
       const saveHelpBtn = document.getElementById("save-help-btn");
       const saveInfoModal = document.getElementById("save-info-modal");
       const saveInfoClose = document.getElementById("save-info-close");
       saveHelpBtn.addEventListener("click", () => {
        saveInfoModal.classList.add("active");
       });
       saveInfoClose.addEventListener("click", () => {
        saveInfoModal.classList.remove("active");
       });
       saveInfoModal.addEventListener("click", (e) => {
       if (e.target === saveInfoModal) {
        saveInfoModal.classList.remove("active");
       }
      });
      document.querySelectorAll(".help-tab").forEach(tab => {
        tab.addEventListener("click", () => {
          document.querySelectorAll(".help-tab").forEach(t => { t.style.background = "var(--panel)"; t.style.color = "var(--text-main)"; });
          tab.style.background = "var(--accent)"; tab.style.color = "var(--bg)";
          document.querySelectorAll(".help-tab-content").forEach(c => c.style.display = "none");
          document.getElementById("help-tab-" + tab.dataset.tab).style.display = "block";
        });
      });
      async function deriveKey(password, salt) {
      const encoder = new TextEncoder();
      
      const keyMaterial = await crypto.subtle.importKey(
      "raw",
      encoder.encode(password),
      "PBKDF2",
      false,
      ["deriveKey"]
      );
      
      return crypto.subtle.deriveKey(
      {
      name: "PBKDF2",
      salt: salt,
      iterations: 200000,  
      hash: "SHA-256"
      },
      keyMaterial,
      {
      name: "AES-GCM",
      length: 256
      },
      false,
      ["encrypt", "decrypt"]
      );
      }
      
       async function encryptData(data, password) {
      const encoder = new TextEncoder();
      const salt = crypto.getRandomValues(new Uint8Array(16));
      const iv   = crypto.getRandomValues(new Uint8Array(12));
      
      const key = await deriveKey(password, salt);
      const encrypted = await crypto.subtle.encrypt(
      { name: "AES-GCM", iv },
      key,
      encoder.encode(data)
      );
      
      const encryptedU8 = new Uint8Array(encrypted);
      
      const result = new Uint8Array(salt.length + iv.length + encryptedU8.length);
      result.set(salt, 0);
      result.set(iv, salt.length);
      result.set(encryptedU8, salt.length + iv.length);
      
      return "ENCRYPTED:" + u8ToBase64(result);
      }
      
       async function decryptData(encryptedData, password) {
      const base64Data = encryptedData.replace("ENCRYPTED:", "");
      const fullData   = base64ToU8(base64Data);
      
      const salt      = fullData.slice(0, 16);
      const iv        = fullData.slice(16, 28);
      const encrypted = fullData.slice(28);
      
      const key = await deriveKey(password, salt);
      
      const decrypted = await crypto.subtle.decrypt(
      { name: "AES-GCM", iv },
      key,
      encrypted
      );
      
      const decoder = new TextDecoder();
      return decoder.decode(decrypted);
      }
      
      
       function isEncrypted(data) {
        return typeof data === "string" && data.startsWith("ENCRYPTED:");
       }
      
       function captureTheQuickening() {
      const currentTab = documentTabs[currentTabIndex];
      currentTab.nodes = JSON.parse(JSON.stringify(NODE_DATA));
      currentTab.edges = JSON.parse(JSON.stringify(EDGE_DATA));
      currentTab.positions = JSON.parse(JSON.stringify(savedPositions));
      currentTab.sizes = JSON.parse(JSON.stringify(savedSizes));
      currentTab.styles = JSON.parse(JSON.stringify(savedStyles));
      currentTab.legend = JSON.parse(JSON.stringify(EDGE_LEGEND));
      currentTab.rects = JSON.parse(JSON.stringify(RECT_DATA));
      currentTab.texts = JSON.parse(JSON.stringify(TEXT_DATA));
      currentTab.pageState = JSON.parse(JSON.stringify(PAGE_STATE));
       
      return {
      nodeData: NODE_DATA,
       edgeData: EDGE_DATA,
       rectData: RECT_DATA,
       textData: TEXT_DATA,
       edgeLegend: EDGE_LEGEND,
       nodePositions: savedPositions,
       nodeSizes: savedSizes,
       nodeStyles: savedStyles,
       iconCache: IconLibrary.iconCache,
      
       page: PAGE_STATE,
      
       autoPingEnabled: autoPingEnabled,
       autoPingInterval: autoPingInterval,
      
       canvas: {
         zoom: canvasState.zoom,
         panX: canvasState.panX,
         panY: canvasState.panY,
       },
       
       savedTopologyView: savedTopologyView,
       
       documentTabs: documentTabs,
       currentTabIndex: currentTabIndex,
       encryptedSections: encryptedSections,
      };
      }
      
       function assembleTheImmortalForm() {
	   const canvasHintEl = document.getElementById("canvas-hint");
       const savedHintHTML = canvasHintEl ? canvasHintEl.innerHTML : "";
       if (canvasHintEl) canvasHintEl.innerHTML = DEFAULT_CANVAS_HINT;
        const clone = document.documentElement.cloneNode(true);
        const nodeScript = clone.querySelector("#nodes-json");
        if (nodeScript) {
         nodeScript.textContent = JSON.stringify(NODE_DATA, null, 2);
        }
        let stateScript = clone.querySelector("#topology-state");
        if (!stateScript) {
         stateScript = document.createElement("script");
         stateScript.id = "topology-state";
         stateScript.type = "application/json";
         const body = clone.querySelector("body") || clone;
         body.appendChild(stateScript);
        }
        stateScript.textContent = JSON.stringify(captureTheQuickening(), null, 2, );
        return " <!DOCTYPE html> \n " + clone.outerHTML;
       }
       async function becomeImmortal() {
        const encryptEnabled = document.getElementById("encrypt-toggle").checked;
        let stateData = JSON.stringify(captureTheQuickening(), null, 2);
        if (encryptEnabled) {
         const password = prompt("Enter a password to encrypt your data:\n(Remember this password! You will need it to open this file and its non recoverable!)", );
         if (!password) {
          alert("Encryption cancelled. File not saved.");
          return;
         }
         const confirmPassword = prompt("Confirm your password:");
         if (password !== confirmPassword) {
          alert("Passwords do not match. File not saved.");
          return;
         }
         try {
          stateData = await encryptData(stateData, password);
         } catch (e) {
          alert("Encryption failed: " + e.message);
          return;
         }
        }
       const canvasHintEl = document.getElementById("canvas-hint");
       const savedHintHTML = canvasHintEl ? canvasHintEl.innerHTML : "";
       if (canvasHintEl) canvasHintEl.innerHTML = DEFAULT_CANVAS_HINT;
       
       const clone = document.documentElement.cloneNode(true);
        const nodeScript = clone.querySelector("#nodes-json");
        if (nodeScript) {
         if (encryptEnabled) {
          nodeScript.textContent = JSON.stringify({}, null, 2);
         } else {
          nodeScript.textContent = JSON.stringify(NODE_DATA, null, 2);
         }
        }
        let stateScript = clone.querySelector("#topology-state");
        if (!stateScript) {
         stateScript = document.createElement("script");
         stateScript.id = "topology-state";
         stateScript.type = "application/json";
         const body = clone.querySelector("body") || clone;
         body.appendChild(stateScript);
        }
        stateScript.textContent = stateData;
        const html = "<!DOCTYPE html> \n " + clone.outerHTML;
        const blob = new Blob([html], {
         type: "text/html"
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        const safeTitle = (PAGE_STATE.title || document.title || "network-topology").toLowerCase().replace(/[^a-z0-9\-]+/g, "-");
        a.download = safeTitle + ".html";
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url); 
		if (canvasHintEl) canvasHintEl.innerHTML = savedHintHTML;
        saveRollbackVersion("Manual save");
		logAuditEvent("save", `File saved: ${safeTitle}.html`);
       }
       
      function captureState() {
      return {
        nodes: JSON.parse(JSON.stringify(NODE_DATA)),
        edges: JSON.parse(JSON.stringify(EDGE_DATA)),
        positions: JSON.parse(JSON.stringify(savedPositions)),
        sizes: JSON.parse(JSON.stringify(savedSizes)),
        styles: JSON.parse(JSON.stringify(savedStyles)),
        legend: JSON.parse(JSON.stringify(EDGE_LEGEND)),
        rects: JSON.parse(JSON.stringify(RECT_DATA)),
        texts: JSON.parse(JSON.stringify(TEXT_DATA))
        };
      }
      
      function pushUndo(action = "") {
       const state = captureState();
       undoStack.push(state);
       if (undoStack.length > MAX_UNDO_STACK) {
        undoStack.shift();
       }
       redoStack = [];
       updateUndoButtons();
      }
      
      function undo() {
       if (undoStack.length === 0) return;
       const currentState = captureState();
       redoStack.push(currentState);
       const previousState = undoStack.pop();
       restoreState(previousState);
       updateUndoButtons();
      }
      
      function redo() {
       if (redoStack.length === 0) return;
       const currentState = captureState();
       undoStack.push(currentState);
       const nextState = redoStack.pop();
       restoreState(nextState);
       updateUndoButtons();
      }
      
      function restoreState(state) {
      NODE_DATA = state.nodes;
       EDGE_DATA = state.edges;
       savedPositions = state.positions;
       savedSizes = state.sizes;
       savedStyles = state.styles;
       EDGE_LEGEND = state.legend;
       RECT_DATA = state.rects || { list: [] };
       TEXT_DATA = state.texts || { list: [] };
       forgeTheTopology();
       if (currentNodeId && NODE_DATA[currentNodeId]) {
       claimTheImmortal(currentNodeId);
       } else if (currentEdgeId) {
       selectTheConnection(currentEdgeId);
       }
      }
      
      function updateUndoButtons() {
       const undoBtn = document.getElementById("undo-btn");
       const redoBtn = document.getElementById("redo-btn");
       if (undoBtn) {
        undoBtn.disabled = undoStack.length === 0;
        undoBtn.style.opacity = undoStack.length === 0 ? "0.5" : "1";
       }
       if (redoBtn) {
        redoBtn.disabled = redoStack.length === 0;
        redoBtn.style.opacity = redoStack.length === 0 ? "0.5" : "1";
       }
      }
      
      function selectNode(nodeId, addToSelection = false) {
       if (!addToSelection) {
        selectedNodes.clear();
       }
       selectedNodes.add(nodeId);
       updateNodeSelection();
      }
      
      function clearSelection() {
       selectedNodes.clear();
       selectedEdges.clear();
       selectedRects.clear();
       selectedTexts.clear();
       updateAllSelections();
      }
      
      function updateAllSelections() {
      updateNodeSelection();
      clearSearchHighlight();
      document.querySelectorAll(".edge").forEach(el => {
      const edgeId = el.dataset.edgeId;
      if (selectedEdges.has(edgeId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      
      document.querySelectorAll(".rect-group").forEach(el => {
      const rectId = el.dataset.rectId;
      if (selectedRects.has(rectId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      
      document.querySelectorAll(".text-group").forEach(el => {
      const textId = el.dataset.textId;
      if (selectedTexts.has(textId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      
      const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
      const bulkToolbar = document.getElementById("bulk-toolbar");
      const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
      const bulkCount = document.getElementById("bulk-count");
      const bulkCountMobile = document.getElementById("bulk-count-mobile");
      
      if (total > 0) {
      if (bulkToolbar) bulkToolbar.style.display = "flex";
      if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
      if (bulkCount) bulkCount.textContent = total;
      if (bulkCountMobile) bulkCountMobile.textContent = total;
      } else {
      if (bulkToolbar) bulkToolbar.style.display = "none";
      if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
      }
      }
      
      
      function updateNodeSelection() {
       document.querySelectorAll(".node-group").forEach(node => {
        const nodeId = node.dataset.nodeId;
        if (selectedNodes.has(nodeId)) {
         node.classList.add("selected");
        } else {
         node.classList.remove("selected");
        }
       });
       
       const bulkToolbar = document.getElementById("bulk-toolbar");
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       const bulkCount = document.getElementById("bulk-count");
       const bulkCountMobile = document.getElementById("bulk-count-mobile");
       const bulkCountModal = document.getElementById("bulk-count-modal");
       
       if (selectedNodes.size > 0) {
        if (bulkToolbar) bulkToolbar.style.display = "flex";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
        if (bulkCount) bulkCount.textContent = selectedNodes.size;
        if (bulkCountMobile) bulkCountMobile.textContent = selectedNodes.size;
        if (bulkCountModal) bulkCountModal.textContent = selectedNodes.size;
       } else {
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        const modal = document.getElementById("bulk-actions-modal");
        if (modal) modal.style.display = "none";
       }
      }
      
      function deleteSelected() {
       const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
       if (total === 0) return;
       const message = `Delete ${total} selected item(s)?`;
       challengeTheImmortal(message, () => {
        pushUndo("delete selected");
        selectedNodes.forEach(nodeId => {
         delete NODE_DATA[nodeId];
         delete savedPositions[nodeId];
         delete savedSizes[nodeId];
         delete savedStyles[nodeId];
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== nodeId && e.to !== nodeId);
        });
        selectedEdges.forEach(edgeId => {
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.id !== edgeId);
        });
        selectedRects.forEach(rectId => {
         RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== rectId);
        });
        selectedTexts.forEach(textId => {
         TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== textId);
        });
        clearSelection();
        saveEdgeData();
        forgeTheTopology();
       });
      }
      
      function startSelection(event) {
       const svgEl = document.getElementById("map");
       const pt = svgEl.createSVGPoint();
       pt.x = event.clientX;
       pt.y = event.clientY;
       const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
       
       isSelecting = true;
       selectionStart = { x: svgP.x, y: svgP.y };
       
       if (!selectionRect) {
        selectionRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        selectionRect.setAttribute("fill", "rgba(79, 209, 197, 0.1)");
        selectionRect.setAttribute("stroke", "#4fd1c5");
        selectionRect.setAttribute("stroke-width", "2");
        selectionRect.setAttribute("stroke-dasharray", "5,5");
        selectionRect.style.pointerEvents = "none";
        svgEl.appendChild(selectionRect);
       }
       
       if (!event.shiftKey) {
        selectedNodes.clear();
       }
      }
      
      function updateSelection(event) {
       if (!isSelecting || !selectionStart) return;
       
       const svgEl = document.getElementById("map");
       const pt = svgEl.createSVGPoint();
       pt.x = event.clientX;
       pt.y = event.clientY;
       const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
       
       const x = Math.min(selectionStart.x, svgP.x);
       const y = Math.min(selectionStart.y, svgP.y);
       const width = Math.abs(svgP.x - selectionStart.x);
       const height = Math.abs(svgP.y - selectionStart.y);
       
       selectionRect.setAttribute("x", x);
       selectionRect.setAttribute("y", y);
       selectionRect.setAttribute("width", width);
       selectionRect.setAttribute("height", height);
       selectionRect.style.display = "block";
       
       document.querySelectorAll(".node-group").forEach(node => {
        const nodeId = node.dataset.nodeId;
        const pos = savedPositions[nodeId];
        if (pos && pos.x >= x && pos.x <= x + width && pos.y >= y && pos.y <= y + height) {
         selectedNodes.add(nodeId);
        } else if (!event.shiftKey) {
         selectedNodes.delete(nodeId);
        }
       });
       
       updateNodeSelection();
      }
      
      function endSelection() {
       isSelecting = false;
       selectionStart = null;
       if (selectionRect) {
        selectionRect.style.display = "none";
       }
      }
      
      function cloneNode(sourceId) {
       const source = NODE_DATA[sourceId];
       if (!source) return;
       
       pushUndo("clone node");
       
       let baseName = source.name;
       let copyNum = 0;
       let newName = baseName + " copy";
       while (Object.values(NODE_DATA).some(n => n.name === newName)) {
        copyNum++;
        newName = baseName + " copy " + copyNum;
       }
       
       const newId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
       
       NODE_DATA[newId] = {
        shape: source.shape,
        name: newName,
        ip: source.ip,
        role: source.role,
        tags: [...source.tags],
        notes: [...source.notes],
        mac: source.mac || "",
        rackUnit: source.rackUnit || "",
        uHeight: source.uHeight || "1",
        ping: source.ping ? JSON.parse(JSON.stringify(source.ping)) : {
         enabled: false,
         protocol: 'http',
         customUrl: '',
         timeout: 3000,
         status: 'unknown',
         lastCheck: null
        }
       };
       
       if (savedSizes[sourceId]) {
        savedSizes[newId] = savedSizes[sourceId];
       }
       
       if (savedStyles[sourceId]) {
        savedStyles[newId] = JSON.parse(JSON.stringify(savedStyles[sourceId]));
       }
       
      if (currentView.mode === "rack" && currentView.rackId) {
        NODE_DATA[newId].assignedRack = currentView.rackId;
       }
       
       const sourcePos = savedPositions[sourceId];
       savedPositions[newId] = {
        x: sourcePos.x + 100,
        y: sourcePos.y + 100
       };
       
       forgeTheTopology();
       claimTheImmortal(newId);
      }
      
      function alignSelectedNodes(direction) {
       if (selectedNodes.size < 2) return;
       
       pushUndo("align nodes");
       
       const nodeIds = Array.from(selectedNodes);
       const positions = nodeIds.map(id => ({ id, pos: savedPositions[id] }));
       
       switch(direction) {
        case "left":
         const minX = Math.min(...positions.map(p => p.pos.x));
         positions.forEach(p => savedPositions[p.id].x = minX);
         break;
        case "right":
         const maxX = Math.max(...positions.map(p => p.pos.x));
         positions.forEach(p => savedPositions[p.id].x = maxX);
         break;
        case "top":
         const minY = Math.min(...positions.map(p => p.pos.y));
         positions.forEach(p => savedPositions[p.id].y = minY);
         break;
        case "bottom":
         const maxY = Math.max(...positions.map(p => p.pos.y));
         positions.forEach(p => savedPositions[p.id].y = maxY);
         break;
        case "center-h":
         const avgX = positions.reduce((sum, p) => sum + p.pos.x, 0) / positions.length;
         positions.forEach(p => savedPositions[p.id].x = avgX);
         break;
        case "center-v":
         const avgY = positions.reduce((sum, p) => sum + p.pos.y, 0) / positions.length;
         positions.forEach(p => savedPositions[p.id].y = avgY);
         break;
       }
       
       forgeTheTopology();
      }
      
      function distributeSelectedNodes(direction) {
       if (selectedNodes.size < 3) return;
       
       pushUndo("distribute nodes");
       
       const nodeIds = Array.from(selectedNodes);
       const positions = nodeIds.map(id => ({ id, pos: savedPositions[id] }));
       
       if (direction === "horizontal") {
        positions.sort((a, b) => a.pos.x - b.pos.x);
        const minX = positions[0].pos.x;
        const maxX = positions[positions.length - 1].pos.x;
        const gap = (maxX - minX) / (positions.length - 1);
        positions.forEach((p, i) => {
         savedPositions[p.id].x = minX + (gap * i);
        });
       } else if (direction === "vertical") {
        positions.sort((a, b) => a.pos.y - b.pos.y);
        const minY = positions[0].pos.y;
        const maxY = positions[positions.length - 1].pos.y;
        const gap = (maxY - minY) / (positions.length - 1);
        positions.forEach((p, i) => {
         savedPositions[p.id].y = minY + (gap * i);
        });
       }
       
       forgeTheTopology();
      }
      
      function snapToGrid(nodeId, gridSize = 50) {
       if (!savedPositions[nodeId]) return;
       
       pushUndo("snap to grid");
       
       const pos = savedPositions[nodeId];
       pos.x = Math.round(pos.x / gridSize) * gridSize;
       pos.y = Math.round(pos.y / gridSize) * gridSize;
       
       forgeTheTopology();
      }
      
      function nudgeSelectedNodes(direction, distance) {
        const nodesToNudge = selectedNodes.size > 0 
          ? Array.from(selectedNodes) 
          : (currentNodeId ? [currentNodeId] : []);
        
        if (nodesToNudge.length === 0) return;
        
        const unlockedNodes = nodesToNudge.filter(id => !NODE_DATA[id]?.locked);
        
        if (unlockedNodes.length === 0) {
          return;
        }
        
        pushUndo("nudge nodes");
        
        unlockedNodes.forEach(id => {
          if (!savedPositions[id]) {
            savedPositions[id] = { x: 0, y: 0 };
          }
          
          switch(direction) {
            case "ArrowUp":
              savedPositions[id].y -= distance;
              break;
            case "ArrowDown":
              savedPositions[id].y += distance;
              break;
            case "ArrowLeft":
              savedPositions[id].x -= distance;
              break;
            case "ArrowRight":
              savedPositions[id].x += distance;
              break;
          }
        });
        
        forgeTheTopology();
      }
      
      function cycleNodes(reverse = false) {
        const nodeIds = Object.keys(NODE_DATA).filter(id => {
          if (currentView.mode === "rack") {
           const node = NODE_DATA[id];
           return node && node.assignedRack === currentView.rackId;
          }
          return isNodeVisible(id);
         });
        
        if (nodeIds.length === 0) return;
        
        let currentIndex = nodeIds.indexOf(currentNodeId);
        
        if (reverse) {
          currentIndex = currentIndex <= 0 ? nodeIds.length - 1 : currentIndex - 1;
        } else {
          currentIndex = currentIndex >= nodeIds.length - 1 ? 0 : currentIndex + 1;
        }
        
        const nextNodeId = nodeIds[currentIndex];
        claimTheImmortal(nextNodeId);
        
        selectedNodes.clear();
        updateNodeSelection();
      }
      
      function focusOnSelected() {
        const nodesToFocus = selectedNodes.size > 0 
          ? Array.from(selectedNodes) 
          : (currentNodeId ? [currentNodeId] : []);
        
        if (nodesToFocus.length === 0) return;
        
        let minX = Infinity, minY = Infinity;
        let maxX = -Infinity, maxY = -Infinity;
        
        nodesToFocus.forEach(id => {
          const pos = savedPositions[id];
          if (pos) {
            const size = savedSizes[id] || 50;
            minX = Math.min(minX, pos.x - size/2);
            minY = Math.min(minY, pos.y - size/2);
            maxX = Math.max(maxX, pos.x + size/2);
            maxY = Math.max(maxY, pos.y + size/2);
          }
        });
        
        if (!isFinite(minX)) return;
        
        const padding = 100;
        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;
        const width = maxX - minX + padding * 2;
        const height = maxY - minY + padding * 2;
        
        const zoomX = CANVAS_WIDTH / width;
        const zoomY = CANVAS_HEIGHT / height;
        const targetZoom = Math.min(zoomX, zoomY, 2);
        
        canvasState.zoom = targetZoom;
        canvasState.panX = centerX - (CANVAS_WIDTH / targetZoom) / 2;
        canvasState.panY = centerY - (CANVAS_HEIGHT / targetZoom) / 2;
        
        forgeTheTopology();
      }
      
      function toggleLockSelected() {
        const nodesToToggle = selectedNodes.size > 0 
          ? Array.from(selectedNodes) 
          : (currentNodeId ? [currentNodeId] : []);
        
        if (nodesToToggle.length === 0) return;
        
        pushUndo("toggle lock");
        
        const hasUnlocked = nodesToToggle.some(id => !NODE_DATA[id]?.locked);
        
        nodesToToggle.forEach(id => {
          if (NODE_DATA[id]) {
            NODE_DATA[id].locked = hasUnlocked;
          }
        });
        
        forgeTheTopology();
      
        const lockState = hasUnlocked ? "locked" : "unlocked";
      }
      
      function toggleGroupSelected() {
      const nodesToGroup = Array.from(selectedNodes);
      const rectsToGroup = Array.from(selectedRects);
      const textsToGroup = Array.from(selectedTexts);
      const edgesToGroup = Array.from(selectedEdges);
      const totalItems = nodesToGroup.length + rectsToGroup.length + textsToGroup.length + edgesToGroup.length;
      if (totalItems < 2) return;
      
      pushUndo("toggle group");
      
      const allGroupIds = [];
      nodesToGroup.forEach(id => { if (NODE_DATA[id]?.groupId) allGroupIds.push(NODE_DATA[id].groupId); });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r?.groupId) allGroupIds.push(r.groupId); });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t?.groupId) allGroupIds.push(t.groupId); });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e?.groupId) allGroupIds.push(e.groupId); });
      const uniqueGroups = [...new Set(allGroupIds)];
      
      if (uniqueGroups.length === 1 && allGroupIds.length === totalItems) {
      nodesToGroup.forEach(id => { if (NODE_DATA[id]) NODE_DATA[id].groupId = null; });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r) r.groupId = null; });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t) t.groupId = null; });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e) e.groupId = null; });
      } else {
      const newGroupId = "group-" + Date.now();
      nodesToGroup.forEach(id => { if (NODE_DATA[id]) NODE_DATA[id].groupId = newGroupId; });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r) r.groupId = newGroupId; });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t) t.groupId = newGroupId; });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e) e.groupId = newGroupId; });
      }
      
      forgeTheTopology();
      }
      
      function handleKeyDown(event) {
       if (event.target.tagName === "INPUT" || event.target.tagName === "TEXTAREA" || event.target.isContentEditable) {
        return;
       }
      
       if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(event.key)) {
        event.preventDefault();
        const distance = event.shiftKey ? 10 : 1;
        nudgeSelectedNodes(event.key, distance);
       }
       
       if (event.key === "Tab") {
        event.preventDefault();
        cycleNodes(event.shiftKey);
       }
       
       if (event.key === "f" || event.key === "F") {
        event.preventDefault();
        focusOnSelected();
       }
       
       if (event.key === "l" || event.key === "L") {
        event.preventDefault();
        toggleLockSelected();
       }
       
       if (event.key === "g" || event.key === "G") {
        event.preventDefault();
        toggleGroupSelected();
       }
       
       if (event.ctrlKey && event.key === "z" && !event.shiftKey) {
        event.preventDefault();
        undo();
       }
       
       if ((event.ctrlKey && event.key === "y") || (event.ctrlKey && event.shiftKey && event.key === "z")) {
        event.preventDefault();
        redo();
       }
       
       if (event.ctrlKey && event.key === "c" && currentNodeId) {
        event.preventDefault();
        const node = NODE_DATA[currentNodeId];
        if (node) {
         clipboard = {
          type: "node",
          data: JSON.parse(JSON.stringify(node)),
          size: savedSizes[currentNodeId],
          style: savedStyles[currentNodeId] ? JSON.parse(JSON.stringify(savedStyles[currentNodeId])) : null
         };
        }
       }
       
       if (event.ctrlKey && event.key === "v" && clipboard && clipboard.type === "node") {
        event.preventDefault();
        pushUndo("paste node");
        
        let baseName = clipboard.data.name;
        let copyNum = 0;
        let newName = baseName + " copy";
        while (Object.values(NODE_DATA).some(n => n.name === newName)) {
         copyNum++;
         newName = baseName + " copy " + copyNum;
        }
        
        const newId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
        NODE_DATA[newId] = JSON.parse(JSON.stringify(clipboard.data));
        NODE_DATA[newId].name = newName;
        
        if (clipboard.size) savedSizes[newId] = clipboard.size;
        if (clipboard.style) savedStyles[newId] = JSON.parse(JSON.stringify(clipboard.style));
        
        const svgEl = document.getElementById("map");
        const rect = svgEl.getBoundingClientRect();
        const pt = svgEl.createSVGPoint();
        pt.x = rect.left + rect.width / 2;
        pt.y = rect.top + rect.height / 2;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        savedPositions[newId] = { x: svgP.x, y: svgP.y };
        
        forgeTheTopology();
        claimTheImmortal(newId);
       }
       
       if (event.ctrlKey && event.key === "d" && currentNodeId) {
        event.preventDefault();
        cloneNode(currentNodeId);
       }
       
       if (event.key === "Delete") {
        event.preventDefault();
        if (selectedNodes.size > 0) {
         deleteSelected();
        } else if (currentNodeId && NODE_DATA[currentNodeId]) {
         challengeTheImmortal(`Delete node "${NODE_DATA[currentNodeId].name}"?`, () => {
          pushUndo("delete node");
          delete NODE_DATA[currentNodeId];
          delete savedPositions[currentNodeId];
          delete savedSizes[currentNodeId];
          delete savedStyles[currentNodeId];
          EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== currentNodeId && e.to !== currentNodeId);
          saveEdgeData();
          forgeTheTopology();
          currentNodeId = null;
          document.getElementById("node-panel").style.display = "none";
         });
        } else if (currentEdgeId) {
         const edge = EDGE_DATA.list.find(e => e.id === currentEdgeId);
         if (edge) {
          challengeTheImmortal("Delete this line?", () => {
           pushUndo("delete edge");
           EDGE_DATA.list = EDGE_DATA.list.filter(e => e.id !== currentEdgeId);
           saveEdgeData();
           forgeTheTopology();
           currentEdgeId = null;
           document.getElementById("edge-panel").style.display = "none";
          });
         }
        }
       }
       
       if (event.ctrlKey && event.key === "a") {
        event.preventDefault();
        selectedNodes.clear();
        Object.keys(NODE_DATA).forEach(id => selectedNodes.add(id));
        updateNodeSelection();
       }
       
       if (event.key === "Escape") {
        clearSelection();
       }
      }
      
      function searchNodes(query) {
       clearSearchHighlight();
       
       if (!query || query.trim() === "") return;
       
       const lowerQuery = query.toLowerCase();
       const matchingIds = [];
       
       Object.entries(NODE_DATA).forEach(([id, node]) => {
        const searchableText = [
         node.name,
         node.ip,
         node.role,
         ...(node.tags || []),
         node.mac || "",
         node.rackUnit || ""
        ].join(" ").toLowerCase();
        
        if (searchableText.includes(lowerQuery)) {
         matchingIds.push(id);
        }
       });
       
       highlightSearchResults(matchingIds);
      }
      
      function highlightSearchResults(nodeIds) {
       clearSearchHighlight();
       nodeIds.forEach(id => {
        const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`);
        if (nodeGroup) {
         nodeGroup.classList.add("search-highlight");
        }
       });
      }
      
      function clearSearchHighlight() {
       document.querySelectorAll(".node-group").forEach(node => {
        node.classList.remove("search-highlight");
       });
      }
      
      function editNodeMac(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       
       document.getElementById("modal-title").textContent = "Edit MAC Address";
       document.getElementById("modal-input").value = node.mac || "";
       document.getElementById("edit-modal").style.display = "flex";
       document.getElementById("modal-input").focus();
       
       const saveHandler = () => {
        pushUndo("edit mac");
        const value = document.getElementById("modal-input").value.trim();
        node.mac = value;
        document.getElementById("edit-modal").style.display = "none";
        claimTheImmortal(id);
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       
       const cancelHandler = () => {
        document.getElementById("edit-modal").style.display = "none";
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       
       document.getElementById("edit-modal").addEventListener("click", function bgHandler(e) {
        if (e.target === document.getElementById("edit-modal")) {
         cancelHandler();
         document.getElementById("edit-modal").removeEventListener("click", bgHandler);
        }
       });
      }
      
      function editNodeRack(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       
       document.getElementById("modal-title").textContent = "Edit Rack Unit";
       document.getElementById("modal-input").value = node.rackUnit || "";
       document.getElementById("edit-modal").style.display = "flex";
       document.getElementById("modal-input").focus();
       
       const saveHandler = () => {
        pushUndo("edit rack");
        const value = document.getElementById("modal-input").value.trim();
        node.rackUnit = value;
        document.getElementById("edit-modal").style.display = "none";
        claimTheImmortal(id);
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       
       const cancelHandler = () => {
        document.getElementById("edit-modal").style.display = "none";
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       
       document.getElementById("edit-modal").addEventListener("click", function bgHandler(e) {
        if (e.target === document.getElementById("edit-modal")) {
         cancelHandler();
         document.getElementById("edit-modal").removeEventListener("click", bgHandler);
        }
       });
      }
      
      function editNodeUHeight(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       
       document.getElementById("modal-title").textContent = "Edit U Height";
       document.getElementById("modal-input").value = node.uHeight || "1";
       document.getElementById("edit-modal").style.display = "flex";
       document.getElementById("modal-input").focus();
       
       const saveHandler = () => {
        pushUndo("edit U height");
        const value = document.getElementById("modal-input").value.trim();
        node.uHeight = value;
        document.getElementById("edit-modal").style.display = "none";
        claimTheImmortal(id);
        forgeTheTopology();
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       
       const cancelHandler = () => {
        document.getElementById("edit-modal").style.display = "none";
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       
       document.getElementById("edit-modal").addEventListener("click", function bgHandler(e) {
        if (e.target === document.getElementById("edit-modal")) {
         cancelHandler();
         document.getElementById("edit-modal").removeEventListener("click", bgHandler);
        }
       });
      }
      
      function updateEdgePortLabels(edgeId) {
       const edge = EDGE_DATA.list.find(e => e.id === edgeId);
       if (!edge) return;
       
       const fromPortInput = document.getElementById("edge-from-port");
       const toPortInput = document.getElementById("edge-to-port");
       
       edge.fromPort = fromPortInput ? fromPortInput.value.trim() : "";
       edge.toPort = toPortInput ? toPortInput.value.trim() : "";
       
       saveEdgeData();
       forgeTheTopology();
      }
      
      document.addEventListener("keydown", handleKeyDown);
      
      const undoBtn = document.getElementById("undo-btn");
      const redoBtn = document.getElementById("redo-btn");
      if (undoBtn) undoBtn.addEventListener("click", undo);
      if (redoBtn) redoBtn.addEventListener("click", redo);
      
      const backToTopologyBtn = document.getElementById("back-to-topology-btn");
      if (backToTopologyBtn) {
       backToTopologyBtn.addEventListener("click", exitRack);
      }
      
      const bulkToolbarClose = document.getElementById("bulk-toolbar-close");
      if (bulkToolbarClose) {
       bulkToolbarClose.addEventListener("click", clearSelection);
      }
      
      const bulkAlignLeft = document.getElementById("bulk-align-left");
      if (bulkAlignLeft) {
       bulkAlignLeft.addEventListener("click", () => alignSelectedNodes("left"));
      }
      
      const bulkAlignRight = document.getElementById("bulk-align-right");
      if (bulkAlignRight) {
       bulkAlignRight.addEventListener("click", () => alignSelectedNodes("right"));
      }
      
      const bulkAlignTop = document.getElementById("bulk-align-top");
      if (bulkAlignTop) {
       bulkAlignTop.addEventListener("click", () => alignSelectedNodes("top"));
      }
      
      const bulkAlignBottom = document.getElementById("bulk-align-bottom");
      if (bulkAlignBottom) {
       bulkAlignBottom.addEventListener("click", () => alignSelectedNodes("bottom"));
      }
      
      const bulkDistributeH = document.getElementById("bulk-distribute-h");
      if (bulkDistributeH) {
       bulkDistributeH.addEventListener("click", () => distributeSelectedNodes("horizontal"));
      }
      
      const bulkDistributeV = document.getElementById("bulk-distribute-v");
      if (bulkDistributeV) {
       bulkDistributeV.addEventListener("click", () => distributeSelectedNodes("vertical"));
      }
      
      const bulkClone = document.getElementById("bulk-clone");
      if (bulkClone) {
       bulkClone.addEventListener("click", () => {
        if (selectedNodes.size === 0) return;
        pushUndo("clone selected");
        const nodesToClone = Array.from(selectedNodes);
        selectedNodes.clear();
        nodesToClone.forEach(id => {
         cloneNode(id);
         selectedNodes.add(currentNodeId);
        });
        updateNodeSelection();
       });
      }
      
      const bulkDelete = document.getElementById("bulk-delete");
      if (bulkDelete) {
       bulkDelete.addEventListener("click", deleteSelected);
      }
      
      const bulkMobileBtn = document.getElementById("bulk-mobile-btn");
      const bulkActionsModal = document.getElementById("bulk-actions-modal");
      const bulkModalClose = document.getElementById("bulk-modal-close");
      
      if (bulkMobileBtn) {
       bulkMobileBtn.addEventListener("click", () => {
        if (bulkActionsModal) bulkActionsModal.style.display = "block";
       });
      }
      
      if (bulkModalClose) {
       bulkModalClose.addEventListener("click", () => {
        if (bulkActionsModal) bulkActionsModal.style.display = "none";
       });
      }
      
      const closeModalAfterAction = () => {
       if (bulkActionsModal) bulkActionsModal.style.display = "none";
      };
      
      const bulkAlignLeftMobile = document.getElementById("bulk-align-left-mobile");
      if (bulkAlignLeftMobile) {
       bulkAlignLeftMobile.addEventListener("click", () => {
        alignSelectedNodes("left");
        closeModalAfterAction();
       });
      }
      
      const bulkAlignRightMobile = document.getElementById("bulk-align-right-mobile");
      if (bulkAlignRightMobile) {
       bulkAlignRightMobile.addEventListener("click", () => {
        alignSelectedNodes("right");
        closeModalAfterAction();
       });
      }
      
      const bulkAlignTopMobile = document.getElementById("bulk-align-top-mobile");
      if (bulkAlignTopMobile) {
       bulkAlignTopMobile.addEventListener("click", () => {
        alignSelectedNodes("top");
        closeModalAfterAction();
       });
      }
      
      const bulkAlignBottomMobile = document.getElementById("bulk-align-bottom-mobile");
      if (bulkAlignBottomMobile) {
       bulkAlignBottomMobile.addEventListener("click", () => {
        alignSelectedNodes("bottom");
        closeModalAfterAction();
       });
      }
      
      const bulkDistributeHMobile = document.getElementById("bulk-distribute-h-mobile");
      if (bulkDistributeHMobile) {
       bulkDistributeHMobile.addEventListener("click", () => {
        distributeSelectedNodes("horizontal");
        closeModalAfterAction();
       });
      }
      
      const bulkDistributeVMobile = document.getElementById("bulk-distribute-v-mobile");
      if (bulkDistributeVMobile) {
       bulkDistributeVMobile.addEventListener("click", () => {
        distributeSelectedNodes("vertical");
        closeModalAfterAction();
       });
      }
      
      const bulkCloneMobile = document.getElementById("bulk-clone-mobile");
      if (bulkCloneMobile) {
       bulkCloneMobile.addEventListener("click", () => {
        if (selectedNodes.size === 0) return;
        pushUndo("clone selected");
        const nodesToClone = Array.from(selectedNodes);
        selectedNodes.clear();
        nodesToClone.forEach(id => {
         cloneNode(id);
         selectedNodes.add(currentNodeId);
        });
        updateNodeSelection();
        closeModalAfterAction();
       });
      }
      
      const bulkDeleteMobile = document.getElementById("bulk-delete-mobile");
      if (bulkDeleteMobile) {
       bulkDeleteMobile.addEventListener("click", () => {
        deleteSelected();
        closeModalAfterAction();
       });
      }
      
      const bulkLockMobile = document.getElementById("bulk-lock-mobile");
      if (bulkLockMobile) {
       bulkLockMobile.addEventListener("click", () => {
        toggleLockSelected();
        closeModalAfterAction();
       });
      }
      
      const bulkGroupMobile = document.getElementById("bulk-group-mobile");
      if (bulkGroupMobile) {
       bulkGroupMobile.addEventListener("click", () => {
        toggleGroupSelected();
        closeModalAfterAction();
       });
      }
      
      const bulkClearMobile = document.getElementById("bulk-clear-mobile");
      if (bulkClearMobile) {
       bulkClearMobile.addEventListener("click", () => {
        clearSelection();
        closeModalAfterAction();
       });
      }
      
      const searchInput = document.getElementById("search-input");
      if (searchInput) {
       searchInput.addEventListener("input", (e) => {
        searchNodes(e.target.value);
       });
      }
      
       document.getElementById("save-file-btn").addEventListener("click", becomeImmortal);
       document.getElementById("check-all-ping-btn").addEventListener("click", checkAllNodesStatus);
       const addNodeBtn = document.getElementById("add-node-btn");
       const addNodeModal = document.getElementById("add-node-modal");
       const addNodeCancel = document.getElementById("add-node-cancel");
       const addNodeSave = document.getElementById("add-node-save");
       addNodeBtn.addEventListener("click", () => {
        document.getElementById("new-node-name").value = "";
        document.getElementById("new-node-ip").value = "";
        document.getElementById("new-node-tags").value = "";
        document.getElementById("new-node-shape").value = "circle";
        document.getElementById("new-node-pingable").checked = false;
        document.getElementById("new-node-ping-protocol").value = "http";
        document.getElementById("new-node-custom-url").value = "";
        document.getElementById("new-node-ping-timeout").value = "3000";
        document.getElementById("new-node-ping-options").style.display = "none";
        document.getElementById("new-node-custom-url-container").style.display = "none";
        newNodeIconTags = [];
        document.getElementById("new-node-icon-tags").style.display = "none";
        document.getElementById("new-node-icon-tags-list").innerHTML = "";
        addNodeModal.classList.add("active");
        document.getElementById("new-node-name").focus();
       });
       
       const canvasViewport = document.getElementById("canvas-viewport");
       if (canvasViewport) {
        canvasViewport.addEventListener("dblclick", (e) => {
         if (currentView.mode === "rack" && e.target.id === "map") {
          exitRack();
         }
        });
       }
       
       const layersBtn = document.getElementById("layers-btn");
       const layerModal = document.getElementById("layer-modal");
       const layerModalClose = document.getElementById("layer-modal-close");
       if (layersBtn && layerModal) {
        layersBtn.addEventListener("click", () => {
         layerModal.classList.add("active");
        });
       }
       if (layerModalClose && layerModal) {
        layerModalClose.addEventListener("click", () => {
         layerModal.classList.remove("active");
        });
       }
       if (layerModal) {
        layerModal.addEventListener("click", (e) => {
         if (e.target === layerModal) {
          layerModal.classList.remove("active");
         }
        });
       }
      
       const tabsBtn = document.getElementById("tabs-btn");
       const tabsModal = document.getElementById("tabs-modal");
       const tabsModalClose = document.getElementById("tabs-modal-close");
       if (tabsBtn && tabsModal) {
         tabsBtn.addEventListener("click", () => {
           displayTabs();
           tabsModal.classList.add("active");
         });
       }
       if (tabsModalClose && tabsModal) {
         tabsModalClose.addEventListener("click", () => {
           tabsModal.classList.remove("active");
         });
       }
       if (tabsModal) {
         tabsModal.addEventListener("click", (e) => {
           if (e.target === tabsModal) {
             tabsModal.classList.remove("active");
           }
         });
       }
       
       const rollbackBtn = document.getElementById("rollback-btn");
       const rollbackModal = document.getElementById("rollback-modal");
       const rollbackModalClose = document.getElementById("rollback-modal-close");
       if (rollbackBtn && rollbackModal) {
         rollbackBtn.addEventListener("click", () => {
           loadRollbackVersions();
           rollbackModal.classList.add("active");
         });
       }
       if (rollbackModalClose && rollbackModal) {
         rollbackModalClose.addEventListener("click", () => {
           rollbackModal.classList.remove("active");
         });
       }
       if (rollbackModal) {
         rollbackModal.addEventListener("click", (e) => {
           if (e.target === rollbackModal) {
             rollbackModal.classList.remove("active");
           }
         });
       }
       
       const auditLogBtn = document.getElementById("audit-log-btn");
       const auditLogModal = document.getElementById("audit-log-modal");
       const auditLogModalClose = document.getElementById("audit-log-modal-close");
       if (auditLogBtn && auditLogModal) {
         auditLogBtn.addEventListener("click", () => {
           loadAuditLog();
           displayAuditLog();
           auditLogModal.classList.add("active");
         });
       }
       if (auditLogModalClose && auditLogModal) {
         auditLogModalClose.addEventListener("click", () => {
           auditLogModal.classList.remove("active");
         });
       }
       if (auditLogModal) {
         auditLogModal.addEventListener("click", (e) => {
           if (e.target === auditLogModal) {
             auditLogModal.classList.remove("active");
           }
         });
       }
      
       const auditFilter = document.getElementById("audit-filter");
       if (auditFilter) {
         auditFilter.addEventListener("change", (e) => {
           displayAuditLog(e.target.value);
         });
       }
       
       const secretsBtn = document.getElementById("secrets-btn");
       const secretsModal = document.getElementById("secrets-modal");
       const secretsModalClose = document.getElementById("secrets-modal-close");
       if (secretsBtn && secretsModal) {
         secretsBtn.addEventListener("click", () => {
           displaySecrets();
           secretsModal.classList.add("active");
         });
       }
       if (secretsModalClose && secretsModal) {
         secretsModalClose.addEventListener("click", () => {
           secretsModal.classList.remove("active");
         });
       }
       if (secretsModal) {
         secretsModal.addEventListener("click", (e) => {
           if (e.target === secretsModal) {
             secretsModal.classList.remove("active");
           }
         });
       }
       
       const secretEditorModal = document.getElementById("secret-editor-modal");
       if (secretEditorModal) {
         secretEditorModal.addEventListener("click", (e) => {
           if (e.target === secretEditorModal) {
             closeSecretEditor();
           }
         });
       }
       
       ["physical", "logical", "security", "application"].forEach(layer => {
        const checkbox = document.getElementById(`layer-${layer}`);
        if (checkbox) {
         checkbox.addEventListener("change", applyLayerFilter);
        }
       });
       
       const layerSelect = document.getElementById("node-layer");
       if (layerSelect) {
        layerSelect.addEventListener("change", (e) => {
         if (currentNodeId) {
          pushUndo("change layer");
          NODE_DATA[currentNodeId].layer = e.target.value;
          forgeTheTopology();
         }
        });
       }
       
       const assignedRackSelect = document.getElementById("node-assigned-rack");
       if (assignedRackSelect) {
        assignedRackSelect.addEventListener("change", (e) => {
      if (currentNodeId) {
      pushUndo("change assigned rack");
      EDGE_DATA.list = EDGE_DATA.list.filter(edge => edge.from !== currentNodeId && edge.to !== currentNodeId);
      NODE_DATA[currentNodeId].assignedRack = e.target.value;
      forgeTheTopology();
      claimTheImmortal(currentNodeId);
      }
      });
       }
       
       const rackCapacitySelect = document.getElementById("node-rack-capacity");
       if (rackCapacitySelect) {
        rackCapacitySelect.addEventListener("change", (e) => {
         if (currentNodeId) {
          pushUndo("change rack capacity");
          NODE_DATA[currentNodeId].rackCapacity = e.target.value;
          forgeTheTopology();
         }
        });
       }
       
       const addRackBtn = document.getElementById("add-rack-btn");
       const addRackModal = document.getElementById("add-rack-modal");
       const addRackCancel = document.getElementById("add-rack-cancel");
       const addRackSave = document.getElementById("add-rack-save");
       
       if (addRackBtn && addRackModal) {
        addRackBtn.addEventListener("click", () => {
         document.getElementById("new-rack-name").value = "";
         document.getElementById("new-rack-ip").value = "";
         document.getElementById("new-rack-tags").value = "";
         document.getElementById("new-rack-shape").value = "server";
         document.getElementById("new-rack-capacity").value = "42";
         selectedRackIconData = null;
         document.getElementById('selected-rack-icon').style.display = 'none';
         addRackModal.classList.add("active");
         document.getElementById("new-rack-name").focus();
        });
       }
       
       if (addRackCancel && addRackModal) {
        addRackCancel.addEventListener("click", () => {
         addRackModal.classList.remove("active");
        });
       }
       
       if (addRackModal) {
        addRackModal.addEventListener("click", (e) => {
         if (e.target === addRackModal) {
          addRackModal.classList.remove("active");
         }
        });
       }
       
       if (addRackSave && addRackModal) {
        addRackSave.addEventListener("click", () => {
         const name = document.getElementById("new-rack-name").value.trim();
         const ip = document.getElementById("new-rack-ip").value.trim();
         const tagsStr = document.getElementById("new-rack-tags").value.trim();
         const shape = document.getElementById("new-rack-shape").value;
         const capacity = document.getElementById("new-rack-capacity").value;
         
         if (!name) {
          alert("Please enter a rack name.");
          return;
         }
         
         const tags = tagsStr ? tagsStr.split(",").map((t) => t.trim()).filter((t) => t) : [];
         let baseId = name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");
         if (!baseId) baseId = "rack";
         let nodeId = baseId;
         let counter = 1;
         while (NODE_DATA[nodeId]) {
          nodeId = baseId + "-" + counter;
          counter++;
         }
         
         pushUndo("add rack");
         
         NODE_DATA[nodeId] = {
          shape: shape,
          name: name,
          ip: ip || "",
          role: "Rack",
          tags: tags,
          notes: [],
          mac: "",
          rackUnit: "",
          uHeight: "1",
          layer: "physical",
          assignedRack: "",
          rackCapacity: capacity,
          isRack: true,
          locked: false,
          groupId: null
         };
         
         const viewWidth = CANVAS_WIDTH / canvasState.zoom;
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         const centerX = canvasState.panX + (viewWidth / 2);
         const centerY = canvasState.panY + (viewHeight / 2);
         savedPositions[nodeId] = {
          x: centerX,
          y: centerY
         };
         
         if (selectedRackIconData) {
          if (!savedStyles[nodeId]) {
           savedStyles[nodeId] = {};
          }
          if (!savedStyles[nodeId]['all']) {
           savedStyles[nodeId]['all'] = {};
          }
          savedStyles[nodeId]['all'].icon = {
           library: selectedRackIconData.library,
           name: selectedRackIconData.name
          };
          selectedRackIconData = null;
          document.getElementById('selected-rack-icon').style.display = 'none';
         }
         
         addRackModal.classList.remove("active");
         forgeTheTopology();
         claimTheImmortal(nodeId);
        });
        
        ["new-rack-name", "new-rack-ip", "new-rack-tags"].forEach((inputId) => {
         const input = document.getElementById(inputId);
         if (input) {
          input.addEventListener("keypress", (e) => {
           if (e.key === "Enter") {
            addRackSave.click();
           }
          });
         }
        });
       }
       
       addNodeCancel.addEventListener("click", () => {
        addNodeModal.classList.remove("active");
       });
       addNodeModal.addEventListener("click", (e) => {
        if (e.target === addNodeModal) {
         addNodeModal.classList.remove("active");
        }
       });
       addNodeSave.addEventListener("click", () => {
        const name = document.getElementById("new-node-name").value.trim();
        const ip = document.getElementById("new-node-ip").value.trim();
        const tagsStr = document.getElementById("new-node-tags").value.trim();
        const shape = document.getElementById("new-node-shape").value;
        const pingable = document.getElementById("new-node-pingable").checked;
        const pingProtocol = document.getElementById("new-node-ping-protocol").value;
        const pingCustomUrl = document.getElementById("new-node-custom-url").value.trim();
        const pingTimeout = parseInt(document.getElementById("new-node-ping-timeout").value) || 3000;
        
        if (!name) {
         alert("Please enter a node name.");
         return;
        }
        const tags = tagsStr ? tagsStr.split(",").map((t) => t.trim()).filter((t) => t) : [];
        if (newNodeIconTags.length > 0) {
         tags.push(...newNodeIconTags);
        }
        let baseId = name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");
        if (!baseId) baseId = "node";
        let nodeId = baseId;
        let counter = 1;
        while (NODE_DATA[nodeId]) {
         nodeId = baseId + "-" + counter;
         counter++;
        }
        NODE_DATA[nodeId] = {
         shape: shape || "circle",
         name: name,
         ip: ip || "0.0.0.0",
         role: "",
         tags: tags,
         notes: [],
         mac: "",
         rackUnit: "",
         uHeight: "1",
         ping: {
          enabled: pingable,
          protocol: pingProtocol,
          customUrl: pingCustomUrl,
          timeout: pingTimeout,
          status: 'unknown',
          lastCheck: null
         },
         locked: false, 
         groupId: null 
        };
        
        if (currentView.mode === "rack" && currentView.rackId) {
         NODE_DATA[nodeId].assignedRack = currentView.rackId;
         NODE_DATA[nodeId].layer = "physical";
        }
        
        if (selectedNodeIconData) {
         if (!savedStyles[nodeId]) savedStyles[nodeId] = {};
         if (!savedStyles[nodeId]['all']) savedStyles[nodeId]['all'] = {};
         savedStyles[nodeId]['all'].icon = {
          library: selectedNodeIconData.library,
          name: selectedNodeIconData.name
         };
         selectedNodeIconData = null;
         document.getElementById('selected-node-icon').style.display = 'none';
        }
        newNodeIconTags = [];
      const viewWidth = CANVAS_WIDTH / canvasState.zoom;
      const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
      const centerX = canvasState.panX + (viewWidth / 2);
      const centerY = canvasState.panY + (viewHeight / 2);
      savedPositions[nodeId] = {
      x: centerX,
      y: centerY
      };
        addNodeModal.classList.remove("active");
        forgeTheTopology();
        claimTheImmortal(nodeId);
       });
       ["new-node-name", "new-node-ip", "new-node-tags"].forEach(
        (inputId) => {
         document.getElementById(inputId).addEventListener("keypress", (e) => {
          if (e.key === "Enter") {
           addNodeSave.click();
          }
         });
        }, );
       
       document.getElementById('new-node-pingable').addEventListener('change', (e) => {
        const pingOptions = document.getElementById('new-node-ping-options');
        pingOptions.style.display = e.target.checked ? 'block' : 'none';
       });
       
       document.getElementById('new-node-ping-protocol').addEventListener('change', (e) => {
        const customUrlContainer = document.getElementById('new-node-custom-url-container');
        customUrlContainer.style.display = e.target.value === 'custom' ? 'block' : 'none';
       });
       
       document.getElementById('pick-rack-icon-btn').addEventListener('click', () => {
        openIconPicker((iconData) => {
         selectedRackIconData = iconData;
         const preview = document.getElementById('selected-rack-icon-preview');
         const container = document.getElementById('selected-rack-icon');
         const parser = new DOMParser();
         const doc = parser.parseFromString(iconData.svg, 'image/svg+xml');
         const svgEl = doc.querySelector('svg');
         preview.innerHTML = '';
         if (svgEl) {
          preview.appendChild(svgEl.cloneNode(true));
         }
         const nameSpan = document.createElement('span');
         nameSpan.textContent = iconData.name;
         preview.appendChild(nameSpan);
         container.style.display = 'block';
        });
       });
       
       document.getElementById('pick-node-icon-btn').addEventListener('click', () => {
        openIconPicker((iconData) => {
         selectedNodeIconData = iconData;
         const preview = document.getElementById('selected-node-icon-preview');
         const container = document.getElementById('selected-node-icon');
         const parser = new DOMParser();
         const doc = parser.parseFromString(iconData.svg, 'image/svg+xml');
         const svgEl = doc.querySelector('svg');
         preview.innerHTML = '';
         if (svgEl) {
          preview.appendChild(svgEl.cloneNode(true));
         }
         const nameSpan = document.createElement('span');
         nameSpan.textContent = iconData.name;
         preview.appendChild(nameSpan);
         container.style.display = 'block';
        });
       });
       document.getElementById('pick-tag-icon-btn').addEventListener('click', () => {
        if (!currentNodeId) return;
        openIconPicker((iconData) => {
         if (!currentNodeId || !NODE_DATA[currentNodeId]) return;
         if (!NODE_DATA[currentNodeId].tags) {
          NODE_DATA[currentNodeId].tags = [];
         }
         NODE_DATA[currentNodeId].tags.push({
          type: 'icon',
          library: iconData.library,
          name: iconData.name
         });
         forgeTheTopology();
         claimTheImmortal(currentNodeId);
        });
       });
       document.getElementById('pick-new-node-tag-icon-btn').addEventListener('click', () => {
        openIconPicker((iconData) => {
         newNodeIconTags.push({
          type: 'icon',
          library: iconData.library,
          name: iconData.name
         });
         const container = document.getElementById('new-node-icon-tags');
         const list = document.getElementById('new-node-icon-tags-list');
         const badge = document.createElement('div');
         badge.className = 'icon-badge';
         badge.style.cssText = 'display: inline-flex; align-items: center; gap: 6px; padding: 6px 10px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; font-size: 13px;';
         const iconPreview = document.createElement('div');
         iconPreview.style.cssText = 'width: 16px; height: 16px; display: flex; align-items: center; justify-content: center;';
         IconLibrary.getIcon(iconData.library, iconData.name).then(svg => {
          if (svg) {
           const parser = new DOMParser();
           const doc = parser.parseFromString(svg, 'image/svg+xml');
           const svgEl = doc.querySelector('svg');
           if (svgEl) {
            svgEl.setAttribute('width', '16');
            svgEl.setAttribute('height', '16');
            svgEl.style.fill = 'var(--text-main)';
            iconPreview.appendChild(svgEl);
           }
          }
         });
         const name = document.createElement('span');
         name.textContent = iconData.name;
         name.style.color = 'var(--text-soft)';
         const removeBtn = document.createElement('button');
         removeBtn.textContent = '√ó';
         removeBtn.style.cssText = 'background: none; border: none; color: var(--danger); cursor: pointer; font-size: 18px; line-height: 1; padding: 0 4px;';
         removeBtn.addEventListener('click', () => {
          const index = newNodeIconTags.findIndex(t => t.type === 'icon' && t.library === iconData.library && t.name === iconData.name);
          if (index > -1) {
           newNodeIconTags.splice(index, 1);
          }
          badge.remove();
          if (list.children.length === 0) {
           container.style.display = 'none';
          }
         });
         badge.appendChild(iconPreview);
         badge.appendChild(name);
         badge.appendChild(removeBtn);
         list.appendChild(badge);
         container.style.display = 'block';
        });
       });
       document.getElementById('pick-shape-icon-btn').addEventListener('click', () => {
        if (!currentNodeId) return;
        openIconPicker((iconData) => {
         if (!savedStyles[currentNodeId]) {
          savedStyles[currentNodeId] = {};
         }
         if (!savedStyles[currentNodeId][currentStyleScope]) {
          savedStyles[currentNodeId][currentStyleScope] = {};
         }
         savedStyles[currentNodeId][currentStyleScope].icon = {
          library: iconData.library,
          name: iconData.name
         };
         forgeTheTopology();
        });
       });
       document.getElementById('add-tag-btn').addEventListener('click', () => {
        if (!currentNodeId) return;
        if (!NODE_DATA[currentNodeId]) return;
        const input = document.getElementById('new-tag-input');
        const tagText = input.value.trim();
        if (!tagText) return;
        if (!NODE_DATA[currentNodeId].tags) {
         NODE_DATA[currentNodeId].tags = [];
        }
        NODE_DATA[currentNodeId].tags.push(tagText);
        input.value = '';
        forgeTheTopology();
        claimTheImmortal(currentNodeId);
       });
      
      function saveRollbackVersion(description = "Auto-save") {
        const version = {
          timestamp: Date.now(),
          description,
          data: captureTheQuickening()
        };
        
        try {
          const stored = localStorage.getItem(ROLLBACK_STORAGE_KEY);
          rollbackVersions = stored ? JSON.parse(stored) : [];
        } catch (e) {
          rollbackVersions = [];
        }
        
        rollbackVersions.unshift(version);
        
        if (rollbackVersions.length > MAX_ROLLBACK_VERSIONS) {
          rollbackVersions = rollbackVersions.slice(0, MAX_ROLLBACK_VERSIONS);
        }
        
        try {
          localStorage.setItem(ROLLBACK_STORAGE_KEY, JSON.stringify(rollbackVersions));
        } catch (e) {
          console.warn("Failed to save rollback version:", e);
        }
      }
      
      function loadRollbackVersions() {
        try {
          const stored = localStorage.getItem(ROLLBACK_STORAGE_KEY);
          rollbackVersions = stored ? JSON.parse(stored) : [];
          displayRollbackVersions();
        } catch (e) {
          console.warn("Failed to load rollback versions:", e);
          rollbackVersions = [];
        }
      }
      
      function displayRollbackVersions() {
        const listEl = document.getElementById("rollback-list");
        if (!listEl) return;
        
        if (rollbackVersions.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No version history yet. Versions are saved automatically when you save the file.</div>';
          return;
        }
        
        listEl.innerHTML = rollbackVersions.map((version, index) => {
          const date = new Date(version.timestamp);
          const timeStr = date.toLocaleString();
          const nodeCount = Object.keys(version.data.nodeData || {}).length;
          const edgeCount = (version.data.edgeData?.list || []).length;
          
          return `
            <div class="version-item" onclick="restoreRollbackVersion(${index})">
              <div class="version-info">
                <div class="timestamp">${timeStr}</div>
                <div class="details">${version.description} ‚Ä¢ ${nodeCount} nodes ‚Ä¢ ${edgeCount} connections</div>
              </div>
              <div class="version-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteRollbackVersion(${index})" title="Delete this version">üóëÔ∏è</button>
              </div>
            </div>
          `;
        }).join('');
      }
      
      function restoreRollbackVersion(index) {
        if (!confirm(`Restore version from ${new Date(rollbackVersions[index].timestamp).toLocaleString()}?\n\nYour current work will be lost unless you save first.`)) {
          return;
        }
        
        const version = rollbackVersions[index];
        const data = version.data;
        
        NODE_DATA = data.nodeData || {};
        EDGE_DATA = data.edgeData || { list: [] };
        RECT_DATA = data.rectData || { list: [] };
        TEXT_DATA = data.textData || { list: [] };
        EDGE_LEGEND = data.edgeLegend || {};
        savedPositions = data.nodePositions || {};
        savedSizes = data.nodeSizes || {};
        savedStyles = data.nodeStyles || {};
        PAGE_STATE = data.page || PAGE_STATE;
        
        if (data.canvas) {
          canvasState.zoom = data.canvas.zoom;
          canvasState.panX = data.canvas.panX;
          canvasState.panY = data.canvas.panY;
        }
        
        wieldThePower();
        forgeTheTopology();
        
        document.getElementById("rollback-modal").classList.remove("active");
        
        logAuditEvent("rollback", `Restored version from ${new Date(version.timestamp).toLocaleString()}`);
      }
      
      function deleteRollbackVersion(index) {
        if (!confirm("Delete this version from history?")) return;
        
        rollbackVersions.splice(index, 1);
        try {
          localStorage.setItem(ROLLBACK_STORAGE_KEY, JSON.stringify(rollbackVersions));
        } catch (e) {
          console.warn("Failed to delete version:", e);
        }
        displayRollbackVersions();
      }
      
      function clearRollbackHistory() {
        if (!confirm("Clear all version history?\n\nThis cannot be undone.")) return;
        
        rollbackVersions = [];
        localStorage.removeItem(ROLLBACK_STORAGE_KEY);
        displayRollbackVersions();
      }
      
      function createManualSnapshot() {
        const description = prompt("Enter a description for this snapshot:", "Manual snapshot");
        if (!description) return;
        
        saveRollbackVersion(description);
        displayRollbackVersions();
      }
      
      function switchTab(index) {
        if (index === currentTabIndex) return;
        
        const currentTab = documentTabs[currentTabIndex];
        currentTab.nodes = JSON.parse(JSON.stringify(NODE_DATA));
        currentTab.edges = JSON.parse(JSON.stringify(EDGE_DATA));
        currentTab.positions = JSON.parse(JSON.stringify(savedPositions));
        currentTab.sizes = JSON.parse(JSON.stringify(savedSizes));
        currentTab.styles = JSON.parse(JSON.stringify(savedStyles));
        currentTab.legend = JSON.parse(JSON.stringify(EDGE_LEGEND));
        currentTab.rects = JSON.parse(JSON.stringify(RECT_DATA));
        currentTab.texts = JSON.parse(JSON.stringify(TEXT_DATA));
        currentTab.pageState = JSON.parse(JSON.stringify(PAGE_STATE));
      
        currentTabIndex = index;
        const newTab = documentTabs[index];
        NODE_DATA = JSON.parse(JSON.stringify(newTab.nodes));
        EDGE_DATA = JSON.parse(JSON.stringify(newTab.edges));
        savedPositions = JSON.parse(JSON.stringify(newTab.positions));
        savedSizes = JSON.parse(JSON.stringify(newTab.sizes));
        savedStyles = JSON.parse(JSON.stringify(newTab.styles));
        EDGE_LEGEND = JSON.parse(JSON.stringify(newTab.legend));
        RECT_DATA = JSON.parse(JSON.stringify(newTab.rects));
        TEXT_DATA = JSON.parse(JSON.stringify(newTab.texts));
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, newTab.pageState || {});
        wieldThePower();
        document.title = newTab.name;
        document.getElementById("page-title").textContent = newTab.name;
        forgeTheTopology();
        displayTabs();
        
        logAuditEvent("tab", `Switched to tab: ${newTab.name}`);
      }
      
      function createNewTab() {
        const nameInput = document.getElementById("new-tab-name");
        const name = nameInput.value.trim();
        
        if (!name) {
          alert("Please enter a tab name");
          return;
        }
        
        const newTab = {
          id: `tab-${Date.now()}`,
          name,
          nodes: {},
          edges: { list: [] },
          positions: {},
          sizes: {},
          styles: {},
          legend: {},
          rects: { list: [] },
          texts: { list: [] },
      pageState: null
        };
        
        documentTabs.push(newTab);
        nameInput.value = "";
        displayTabs();
        
        logAuditEvent("tab", `Created new tab: ${name}`);
      }
      
      function renameTab(index) {
        const tab = documentTabs[index];
        const newName = prompt("Enter new name:", tab.name);
        if (!newName || newName === tab.name) return;
        
        tab.name = newName;
        displayTabs();
        
        logAuditEvent("tab", `Renamed tab to: ${newName}`);
      }
      
      function deleteTab(index) {
        if (documentTabs.length === 1) {
          alert("Cannot delete the last tab");
          return;
        }
        
        if (!confirm(`Delete tab "${documentTabs[index].name}"?`)) return;
        
        documentTabs.splice(index, 1);
        
        if (currentTabIndex >= documentTabs.length) {
          currentTabIndex = documentTabs.length - 1;
        }
        
        if (currentTabIndex === index) {
          switchTab(currentTabIndex);
        }
        
        displayTabs();
      }
      
      function displayTabs() {
        const listEl = document.getElementById("tabs-list");
        if (!listEl) return;
        
        listEl.innerHTML = documentTabs.map((tab, index) => {
          const nodeCount = Object.keys(tab.nodes).length;
          const edgeCount = tab.edges.list.length;
          const isActive = index === currentTabIndex;
          
          return `
            <div class="tab-item ${isActive ? 'active' : ''}" onclick="switchTab(${index})">
              <div class="tab-name">${tab.name}</div>
              <div class="tab-stats">${nodeCount} nodes ‚Ä¢ ${edgeCount} connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(${index})" title="Rename tab">‚úèÔ∏è</button>
                ${documentTabs.length > 1 ? '<button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(${index})" title="Delete tab">üóëÔ∏è</button>' : ''}
              </div>
            </div>
          `;
        }).join('');
      }
      
      function logAuditEvent(type, description, details = {}) {
        const event = {
          timestamp: Date.now(),
          type,
          description,
          details,
          tab: documentTabs[currentTabIndex]?.name || "Main"
        };
        
        auditLog.unshift(event);
        
        if (auditLog.length > MAX_AUDIT_ENTRIES) {
          auditLog = auditLog.slice(0, MAX_AUDIT_ENTRIES);
        }
        
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to save audit log:", e);
        }
      }
      
      function loadAuditLog() {
        try {
          const stored = localStorage.getItem(AUDIT_STORAGE_KEY);
          auditLog = stored ? JSON.parse(stored) : [];
        } catch (e) {
          console.warn("Failed to load audit log:", e);
          auditLog = [];
        }
      }
      
      function displayAuditLog(filter = "all") {
        const listEl = document.getElementById("audit-log-list");
        if (!listEl) return;
        
        const filtered = filter === "all" ? auditLog : auditLog.filter(e => e.type === filter);
        
        if (filtered.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No audit entries yet</div>';
          return;
        }
        
        listEl.innerHTML = filtered.map(event => {
          const date = new Date(event.timestamp);
          const timeStr = date.toLocaleString();
          
          return `<div class="audit-entry ${event.type}">
              <div class="time">[${timeStr}] ${event.tab}</div>
              <div class="action">[${event.type.toUpperCase()}] ${event.description}</div>
            </div>
          `;
        }).join('');
      }
      
      function clearAuditLog() {
        if (!confirm("Clear all audit log entries?\n\nThis cannot be undone.")) return;
        
        auditLog = [];
        localStorage.removeItem(AUDIT_STORAGE_KEY);
        displayAuditLog();
      }
      
      function exportAuditLog() {
        if (auditLog.length === 0) {
          alert("No audit entries to export");
          return;
        }
        
        const csv = [
          ["Timestamp", "Tab", "Type", "Description"],
          ...auditLog.map(e => [
            new Date(e.timestamp).toISOString(),
            e.tab,
            e.type,
            e.description
          ])
        ].map(row => row.map(cell => `"${cell}"`).join(",")).join("\n");
        
        const blob = new Blob([csv], { type: "text/csv" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `audit-log-${Date.now()}.csv`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }
      
      let currentSecretName = null;
      
      function createNewSecret() {
        const nameInput = document.getElementById("new-secret-name");
        const name = nameInput.value.trim();
        
        if (!name) {
          alert("Please enter a note name");
          return;
        }
        
        if (encryptedSections[name]) {
          alert("A note note with this name already exists");
          return;
        }
        
        currentSecretName = name;
        encryptedSections[name] = { encrypted: false, data: "" };
        nameInput.value = "";
        
        document.getElementById("secret-editor-title").textContent = `New note: ${name}`;
        document.getElementById("secret-editor-content").value = "";
        document.getElementById("secrets-modal").classList.remove("active");
        document.getElementById("secret-editor-modal").classList.add("active");
        
        displaySecrets();
      }
      
      function editSecret(name) {
        currentSecretName = name;
        const section = encryptedSections[name];
        
        if (section.encrypted) {
          const password = prompt(`Enter password to decrypt "${name}":`);
          if (!password) return;
          
          try {
            decryptData(section.data, password).then(decrypted => {
              document.getElementById("secret-editor-title").textContent = `Edit Secret: ${name}`;
              document.getElementById("secret-editor-content").value = decrypted;
              document.getElementById("secrets-modal").classList.remove("active");
              document.getElementById("secret-editor-modal").classList.add("active");
            }).catch(e => {
              alert("Failed to decrypt. Wrong password?");
            });
          } catch (e) {
            alert("Failed to decrypt. Wrong password?");
          }
        } else {
          document.getElementById("secret-editor-title").textContent = `Edit note: ${name}`;
          document.getElementById("secret-editor-content").value = section.data;
          document.getElementById("secrets-modal").classList.remove("active");
          document.getElementById("secret-editor-modal").classList.add("active");
        }
      }
      
      async function saveSecret() {
        if (!currentSecretName) return;
        
        const content = document.getElementById("secret-editor-content").value;
        const autoEncrypt = document.getElementById("secret-auto-encrypt").checked;
        
        if (autoEncrypt) {
          const password = prompt(`Enter password to encrypt "${currentSecretName}":`);
          if (!password) return;
          
          const confirmPassword = prompt("Confirm password:");
          if (password !== confirmPassword) {
            alert("Passwords do not match");
            return;
          }
          
          try {
            const encrypted = await encryptData(content, password);
            encryptedSections[currentSecretName] = { encrypted: true, data: encrypted };
          } catch (e) {
            alert("Encryption failed: " + e.message);
            return;
          }
        } else {
          encryptedSections[currentSecretName] = { encrypted: false, data: content };
        }
        
        closeSecretEditor();
        displaySecrets();
        
        logAuditEvent("secret", `Saved note section: ${currentSecretName}`);
      }
      
      function closeSecretEditor() {
        document.getElementById("secret-editor-modal").classList.remove("active");
        document.getElementById("secrets-modal").classList.add("active");
        currentSecretName = null;
      }
      
      function deleteSecret(name) {
        if (!confirm(`Delete note "${name}"?`)) return;
        
        delete encryptedSections[name];
        displaySecrets();
        
        logAuditEvent("secret", `Deleted note: ${name}`);
      }
      
      function displaySecrets() {
        const listEl = document.getElementById("secrets-list");
        if (!listEl) return;
        
        const secrets = Object.keys(encryptedSections);
        
        if (secrets.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No notes yet</div>';
          return;
        }
        
        listEl.innerHTML = secrets.map(name => {
          const section = encryptedSections[name];
          const status = section.encrypted ? "üîí Encrypted" : "üîì Plaintext";
          
          return `
            <div class="secret-item">
              <div class="secret-name">${name}</div>
              <div class="secret-status">${status}</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="editSecret('${name}')" title="Edit note">‚úèÔ∏è</button>
                <button class="btn-cancel" onclick="deleteSecret('${name}')" title="Delete note">üóëÔ∏è</button>
              </div>
            </div>
          `;
        }).join('');
      }
      
       const clearAllBtn = document.getElementById("clear-all-btn");
       const clearAllModal = document.getElementById("clear-all-modal");
       const clearAllCancel = document.getElementById("clear-all-cancel");
       const clearAllConfirm = document.getElementById("clear-all-confirm");
       clearAllBtn.addEventListener("click", () => {
        clearAllModal.classList.add("active");
       });
       clearAllCancel.addEventListener("click", () => {
        clearAllModal.classList.remove("active");
       });
       clearAllModal.addEventListener("click", (e) => {
        if (e.target === clearAllModal) {
         clearAllModal.classList.remove("active");
        }
       });
       clearAllConfirm.addEventListener("click", () => {
        NODE_DATA = {};
        EDGE_DATA = {
         list: []
        };
        EDGE_LEGEND = {};
        RECT_DATA = { list: [] };
        TEXT_DATA = { list: [] };
        savedPositions = {};
        savedSizes = {};
        savedStyles = {};
        clearAllModal.classList.remove("active");
      
      autoPingEnabled = false;
      autoPingInterval = 30;
      PAGE_STATE.autoPingEnabled = false;
      PAGE_STATE.autoPingInterval = autoPingInterval;
      
      stopAutoPing();
      
      document.getElementById("auto-ping-enabled").checked = false;
      document.getElementById("auto-ping-settings").style.display = "none";
      document.getElementById("auto-ping-interval").value = autoPingInterval;
        forgeTheTopology();
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.display = "none";
        currentNodeId = null;
        currentEdgeId = null;
        currentTextId = null;
       });
       (function addDeleteNodeButton() {
        const nodePanel = document.getElementById("node-panel");
        if (!nodePanel) return;
        if (document.getElementById("delete-node-btn")) return;
        const deleteBtn = document.createElement("button");
        deleteBtn.id = "delete-node-btn";
        deleteBtn.textContent = "Delete Node";
        deleteBtn.style.cssText = "margin-top:15px; padding:10px 16px; background:var(--danger); color:#fff; border:none; border-radius:6px; cursor:pointer; font-size:clamp(14px,1.6vw,18px); font-weight:600; width:100%;";
        deleteBtn.addEventListener("click", () => {
         if (!currentNodeId) return;
         challengeTheImmortal(`Delete node "${NODE_DATA[currentNodeId]?.name || currentNodeId}" and all its connections?`,
          () => {
           EDGE_DATA.list = EDGE_DATA.list.filter(
            (e) => e.from !== currentNodeId && e.to !== currentNodeId, );
           delete NODE_DATA[currentNodeId];
           delete savedPositions[currentNodeId];
           delete savedSizes[currentNodeId];
           delete savedStyles[currentNodeId];
           currentNodeId = null;
           currentEdgeId = null;
           forgeTheTopology();
           const remainingNodes = Object.keys(NODE_DATA);
           if (remainingNodes.length > 0) {
            claimTheImmortal(remainingNodes[0]);
           } else {
            document.getElementById("node-panel").style.display = "none";
            document.getElementById("edge-panel").style.display = "none";
            document.getElementById("topology-toolbar", ).style.display = "none";
           }
          }, );
        });
        nodePanel.appendChild(deleteBtn);
       })();
      
       function screenshotCanvas() {
        const svg = document.getElementById("map");
        const svgClone = svg.cloneNode(true);
        const viewBox = svg.getAttribute("viewBox").split(" ").map(Number);
        const [x, y, width, height] = viewBox;
        svgClone.setAttribute("width", width);
        svgClone.setAttribute("height", height);
        svgClone.setAttribute("viewBox", `${x} ${y} ${width} ${height}`);
        const wrapper = document.createElement("div");
        wrapper.style.position = "absolute";
        wrapper.style.left = "-9999px";
        wrapper.appendChild(svgClone);
        document.body.appendChild(wrapper);
      
        function inlineStyles(original, clone) {
         const elements = original.querySelectorAll("*");
         const clonedElements = clone.querySelectorAll("*");
         const rootStyles = getComputedStyle(document.documentElement);
         const bgColor = rootStyles.getPropertyValue("--bg").trim() || "#050608";
         const bgRect = document.createElementNS("http://www.w3.org/2000/svg", "rect", );
         bgRect.setAttribute("x", x);
         bgRect.setAttribute("y", y);
         bgRect.setAttribute("width", width);
         bgRect.setAttribute("height", height);
         bgRect.setAttribute("fill", bgColor);
         clone.insertBefore(bgRect, clone.firstChild);
         elements.forEach((el, index) => {
          const clonedEl = clonedElements[index];
          if (!clonedEl) return;
          const computedStyle = getComputedStyle(el);
          const svgProps = ["fill", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin", "opacity", "font-family", "font-size", "font-weight", "font-style", "text-anchor", "dominant-baseline", "marker-start", "marker-end", ];
          svgProps.forEach((prop) => {
           const value = computedStyle.getPropertyValue(prop);
           if (value && value !== "none" && value !== "normal") {
            clonedEl.style[prop] = value;
           }
          });
          clonedEl.removeAttribute("class");
         });
        }
        inlineStyles(svg, svgClone);
        const svgData = new XMLSerializer().serializeToString(svgClone);
        document.body.removeChild(wrapper);
        const svgBlob = new Blob([svgData], {
         type: "image/svg+xml;charset=utf-8",
        });
        const url = URL.createObjectURL(svgBlob);
        const img = new Image();
        img.onload = function() {
         const canvas = document.createElement("canvas");
         canvas.width = width;
         canvas.height = height;
         const ctx = canvas.getContext("2d");
         ctx.drawImage(img, 0, 0);
         canvas.toBlob(function(blob) {
          const link = document.createElement("a");
          const timestamp = new Date().toISOString().slice(0, 10);
          link.download = `topology-${timestamp}.png`;
          link.href = URL.createObjectURL(blob);
          link.click();
          URL.revokeObjectURL(url);
          URL.revokeObjectURL(link.href);
         }, "image/png");
        };
        img.onerror = function() {
         console.error("Failed to load SVG image");
         alert("Screenshot failed. Please try again.");
         URL.revokeObjectURL(url);
        };
        img.src = url;
       }
      
       function exportCanvasSVG() {
        const svg = document.getElementById("map");
        const svgClone = svg.cloneNode(true);
        const viewBox = svg.getAttribute("viewBox").split(" ").map(Number);
        const [x, y, width, height] = viewBox;
        svgClone.setAttribute("width", width);
        svgClone.setAttribute("height", height);
        const rootStyles = getComputedStyle(document.documentElement);
        const bgColor = rootStyles.getPropertyValue("--bg").trim() || "#050608";
        const bgRect = document.createElementNS("http://www.w3.org/2000/svg", "rect", );
        bgRect.setAttribute("x", x);
        bgRect.setAttribute("y", y);
        bgRect.setAttribute("width", width);
        bgRect.setAttribute("height", height);
        bgRect.setAttribute("fill", bgColor);
        svgClone.insertBefore(bgRect, svgClone.firstChild);
        const wrapper = document.createElement("div");
        wrapper.style.position = "absolute";
        wrapper.style.left = "-9999px";
        wrapper.appendChild(svgClone);
        document.body.appendChild(wrapper);
        const elements = svg.querySelectorAll("*");
        const clonedElements = svgClone.querySelectorAll("*");
        elements.forEach((el, index) => {
         const clonedEl = clonedElements[index];
         if (!clonedEl) return;
         const computedStyle = getComputedStyle(el);
         const svgProps = ["fill", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin", "opacity", "font-family", "font-size", "font-weight", "font-style", "text-anchor", "dominant-baseline", "marker-start", "marker-end", ];
         svgProps.forEach((prop) => {
          const value = computedStyle.getPropertyValue(prop);
          if (value && value !== "none" && value !== "normal") {
           clonedEl.setAttribute(prop, value);
          }
         });
         clonedEl.removeAttribute("class");
        });
        const svgData = new XMLSerializer().serializeToString(svgClone);
        document.body.removeChild(wrapper);
        const blob = new Blob([svgData], {
         type: "image/svg+xml;charset=utf-8",
        });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        const timestamp = new Date().toISOString().slice(0, 10);
        link.download = `topology-${timestamp}.svg`;
        link.href = url;
        link.click();
        URL.revokeObjectURL(url);
       }
      let resizeTimeout;
       window.addEventListener('resize', () => {
       clearTimeout(resizeTimeout);
       resizeTimeout = setTimeout(() => {
       updateDrawToolbarVisibility();
       updateTopologyToolbarVisibility();
       }, 100);
      });	   
    </script>
  
</body></html>