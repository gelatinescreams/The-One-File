<!DOCTYPE html> 
 <html lang="en" style="--panel: #18c6c9; --panel-alt: #161d1c; --accent: #3eabc1; --danger: #070603; --text-main: #ffffff; --text-soft: #ffffff; --topbar-bg: #0bb6ef; --topbar-border: #000000; --topbar-height: 100px; --sidebar-width: 435px; --mobile-footer-height: 20vh; --draw-toolbar-height: 45px;"><head>
    <meta charset="UTF-8">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Corporate</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- 
      * ==================================================================================
      * The One File: The Networkening
      * !!!!!!!!!!!!!!!!!!!NOTE: THIS IS THE ONLINE VERSION!!!!!!!!!!!!!!!!!!!!!!
      * Online version uses 3 cdn calls from cdn.jsdelivr.net to display additional icons
      * Since 3.0 Online version uses http as a form of ping to display uptime
      * "There can be only one". A all in one file topology maker.
      * 
      * This is your last backup when all others fail. A completely self-contained
      * network topology visualization tool that works as a single HTML file.
      * Open it anywhere, anytime and the idea lives forever.
      * ==================================================================================
      -->
    <style>
      :root {
      color-scheme: dark;
      --bg: #050608;
      --panel: #0b0e13;
      --panel-alt: #10141b;
      --accent: #4fd1c5;
      --danger: #f56565;
      --text-main: #e2e8f0;
      --text-soft: #94a3b8;
      --edge-main: #475569;
      --node-min: 35px;
      --node-max: 70px;
      --topbar-bg: rgba(9, 12, 20, 0.9);
      --topbar-border: #1f2533;
      }
      * {
      box-sizing: border-box;
      user-select: none;
      }
      input,
      textarea,
      [contenteditable="true"] {
      user-select: text;
      -webkit-user-select: text;
      }
      body {
      margin: 0;
      font-family: system-ui, sans-serif;
      background: radial-gradient(circle at top, #1e2532 0, #050608 70%);
      color: var(--text-main);
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
      }
      header {
      padding: 0 20px;
      height: var(--topbar-height, 52px);
      min-height: var(--topbar-height, 52px);
      background: var(--topbar-bg);
      backdrop-filter: blur(6px);
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid var(--topbar-border);
      gap: 16px;
      }
      .title-block {
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-width: 0;
      }
      header h1 {
      font-size: clamp(22px, 3vw, 32px);
      margin: 0;
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
      }
      .editable-page-title {
      cursor: pointer;
      transition: opacity 0.2s;
      }
      .editable-page-title:hover {
      opacity: 0.7;
      }
      .save-row {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      }
      .save-btn {
      padding: 6px 12px;
      background: var(--accent);
      color: var(--bg);
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      white-space: nowrap;
      }
      .save-btn:hover {
      opacity: 0.9;
      }
      .help-icon {
      width: 22px;
      height: 22px;
      border-radius: 50%;
      border: 1px solid var(--edge-main);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      cursor: pointer;
      color: var(--text-soft);
      background: rgba(15, 23, 42, 0.9);
      flex-shrink: 0;
      }
      .help-icon:hover {
      color: var(--accent);
      border-color: var(--accent);
      }
      #settings-btn {
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 16px;
      flex-shrink: 0;
      }
      #settings-btn:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .header-resizer {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 6px;
      background: transparent;
      cursor: row-resize;
      z-index: 1000;
      transition: background 0.2s;
      }
      .header-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .header-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      .sidebar-resizer {
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 6px;
      background: transparent;
      cursor: col-resize;
      z-index: 1000;
      transition: background 0.2s;
      }
      .sidebar-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .sidebar-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      .mobile-footer-resizer {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 6px;
      background: transparent;
      cursor: row-resize;
      z-index: 1000;
      transition: background 0.2s;
      display: none;
      }
      .mobile-footer-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .mobile-footer-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      @media (max-width: 900px) {
      .mobile-footer-resizer {
      display: block;
      height: 12px;
      }
      .sidebar-resizer {
      display: none;
      }
      .header-resizer {
      height: 12px;
      }
      }
      @media (pointer: coarse) {
      .header-resizer {
      height: 16px;
      }
      .mobile-footer-resizer {
      height: 16px;
      }
      .sidebar-resizer {
      width: 16px;
      }
      }
      .resizer-icon {
      position: absolute;
      opacity: 0.5;
      transition: opacity 0.2s, transform 0.2s;
      pointer-events: none;
      fill: var(--accent);
      }
      .header-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .sidebar-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .mobile-footer-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .header-resizer:hover .resizer-icon,
      .sidebar-resizer:hover .resizer-icon,
      .mobile-footer-resizer:hover .resizer-icon {
      opacity: 1;
      }
      .header-resizer.resizing .resizer-icon,
      .sidebar-resizer.resizing .resizer-icon,
      .mobile-footer-resizer.resizing .resizer-icon {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1.2);
      }
      body.resizing {
      user-select: none;
      }
      body.resizing * {
      cursor: inherit !important;
      pointer-events: none;
      }
      header {
      position: relative;
      }
      .details-panel {
      position: relative;
      }
      main {
      display: grid;
      grid-template-columns: 1fr var(--sidebar-width, 350px);
      flex: 1;
      }
      main.sidebar-collapsed {
      grid-template-columns: 1fr 0;
      }
      @media (max-width: 900px) {
      main {
      grid-template-columns: 1fr;
      grid-template-rows: calc(100vh - var(--topbar-height, 52px) - var(--mobile-footer-height, 40vh)) var(--mobile-footer-height, 40vh);
      }
      main.sidebar-collapsed {
      grid-template-rows: 1fr 0;
      }
      .details-panel {
      max-height: var(--mobile-footer-height, 40vh);
      height: 100%;
      }
      }
      .topology-panel {
      background: var(--panel);
      border-right: 1px solid #111827;
      position: relative;
      overflow: hidden;
      }
      .topology-toolbar {
      position: absolute;
      top: 10px;
      right: 10px;
      display: none;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      background: rgba(15, 23, 42, 0.92);
      border: 1px solid #1f2937;
      border-radius: 6px;
      z-index: 20;
      font-size: 13px;
      }
      .topology-toolbar label {
      color: var(--text-soft);
      }
      .topology-toolbar select {
      padding: 4px 6px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: 13px;
      cursor: pointer;
      }
      .topology-toolbar button {
      padding: 4px 10px;
      background: var(--accent);
      color: var(--bg);
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      }
      .bulk-toolbar-desktop,
      .bulk-toolbar-mobile {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 9999;
      }
      .bulk-toolbar-desktop {
      position: absolute;
      top: 10px;
      right: 10px;
      bottom: auto;
      left: auto;
      transform: none;
      }
      @media (min-width: 768px) {
      .bulk-toolbar-mobile {
      display: none !important;
      }
      }	  
      .bulk-action-btn {
      padding: 16px;
      background: var(--panel-main);
      border: 1px solid var(--edge-main);
      border-radius: 8px;
      color: var(--text-main);
      font-size: 24px;
      cursor: pointer;
      text-align: center;
      line-height: 1.2;
      }
      .bulk-action-btn:active {
      transform: scale(0.95);
      background: var(--accent);
      }
      .draw-toolbar {
      position: absolute;
      top: 10px;
      left: 10px;
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 8px;
      background: rgba(15, 23, 42, 0.92);
      border: 1px solid #1f2937;
      border-radius: 6px;
      z-index: 20;
      font-size: 13px;
      pointer-events: auto;
      }
      .draw-toolbar button {
      padding: 4px 8px;
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      }
      .draw-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .draw-toolbar input[type="color"] {
      width: 30px;
      height: 22px;
      border-radius: 4px;
      border: 1px solid var(--edge-main);
      padding: 0;
      background: transparent;
      cursor: pointer;
      }
      .draw-toolbar select {
      padding: 4px 6px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: 13px;
      cursor: pointer;
      }
      .legend-container {
      position: absolute;
      left: 10px;
      bottom: 10px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      padding: 8px 10px;
      background: rgba(15, 23, 42, 0.92);
      border: 1px solid #1f2937;
      border-radius: 6px;
      font-size: 12px;
      z-index: 20;
      max-width: 260px;
      pointer-events: auto;
      }
      .legend-container {
      padding-right: 22px;
      }
      @media (max-width: 900px) {
      .legend-container {
      max-height: calc(100vh - var(--topbar-height, 100px) - 120px);
      overflow-y: auto;
      }
      }
      @media (max-width: 900px) {
      .bulk-toolbar-desktop,
      .topology-toolbar {
      display: none !important;
      }
      }
      .legend-close-btn {
      position: absolute;
      top: 5px;
      right: 5px;
      width: 18px;
      height: 18px;
      border-radius: 999px;
      border: 1px solid var(--edge-main);
      background: var(--panel-alt);
      color: var(--text-soft);
      font-size: 11px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      }
      .legend-close-btn:hover {
      background: var(--danger);
      color: #fff;
      }
      .legend-mini-btn {
      position: absolute;
      left: 10px;
      padding: 4px 8px;
      border-radius: 4px;
      border: 1px solid #1f2937;
      background: rgba(15, 23, 42, 0.92);
      color: var(--text-main);
      font-size: 11px;
      cursor: pointer;
      z-index: 20;
      display: none;
      transition: all 0.2s;
      }
      .legend-mini-btn:hover,
      .legend-mini-btn:active {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
      }
      .legend-title {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: var(--text-soft);
      margin-bottom: 2px;
      }
      .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      }
      .legend-swatch {
      width: 14px;
      height: 14px;
      border-radius: 3px;
      border: 1px solid #020617;
      flex-shrink: 0;
      }
      .legend-label {
      outline: none;
      cursor: text;
      flex: 1;
      min-width: 60px;
      user-select: text;
      -webkit-user-select: text;
      }
      .legend-label.editing {
      border-bottom: 1px dashed var(--accent);
      }
      .canvas-viewport {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      overflow: hidden;
      }
      .canvas-viewport.panning {
      cursor: grabbing !important;
      }
      .canvas-viewport.panning * {
      cursor: grabbing !important;
      }
      .canvas-viewport svg {
      width: 100%;
      height: 100%;
      display: block;
      background: linear-gradient(rgba(71, 85, 105, 0.1) 1px,
      transparent 1px),
      linear-gradient(90deg,
      rgba(71, 85, 105, 0.1) 1px,
      transparent 1px),
      linear-gradient(rgba(71, 85, 105, 0.05) 1px, transparent 1px),
      linear-gradient(90deg,
      rgba(71, 85, 105, 0.05) 1px,
      transparent 1px);
      background-size:
      100px 100px,
      100px 100px,
      20px 20px,
      20px 20px;
      background-position:
      -1px -1px,
      -1px -1px,
      -1px -1px,
      -1px -1px;
      }
      .zoom-toolbar {
      display: flex;
      gap: 4px;
      padding: 6px;
      background: rgba(15, 23, 42, 0.92);
      border: 1px solid #1f2937;
      border-radius: 6px;
      }
      .zoom-toolbar button {
      width: 32px;
      height: 32px;
      padding: 0;
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      font-size: 18px;
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
      }
      .zoom-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .zoom-toolbar .zoom-level {
      font-size: 11px;
      color: var(--text-soft);
      text-align: center;
      padding: 2px 0;
      min-width: 32px;
      }
      .zoom-toolbar .divider {
      height: 1px;
      background: var(--edge-main);
      margin: 2px 0;
      }
      .minimap-zoom-wrapper {
      position: absolute;
      bottom: 10px;
      right: 10px;
      z-index: 99;
      }
      .minimap-container {
      background: rgba(15, 23, 42, 0.92);
      border: 1px solid #1f2937;
      border-radius: 6px;
      overflow: hidden;
      margin-bottom: 4px;
      }
      .minimap-container svg {
      width: 100%;
      height: 100%;
      }
      .minimap-viewport {
      fill: rgba(79, 209, 197, 0.2);
      stroke: var(--accent);
      stroke-width: 2;
      cursor: move;
      }
      .minimap-node {
      fill: var(--text-soft);
      }
      .minimap-edge {
      stroke: var(--edge-main);
      stroke-width: 1;
      }
      .minimap-close-btn {
      position: absolute;
      top: 2px;
      right: 2px;
      width: 18px;
      height: 18px;
      background: rgba(15, 23, 42, 0.9);
      border: 1px solid var(--edge-main);
      border-radius: 3px;
      color: var(--text-soft);
      font-size: 11px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
      padding: 0;
      line-height: 1;
      }
      .minimap-close-btn:hover {
      background: var(--danger);
      color: white;
      border-color: var(--danger);
      }
      .toolbar-close-btn {
      width: 24px;
      height: 24px;
      background: rgba(15, 23, 42, 0.9);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-soft);
      font-size: 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      line-height: 1;
      flex-shrink: 0;
      }
      .toolbar-close-btn:hover {
      background: var(--danger);
      color: white;
      border-color: var(--danger);
      }
      .canvas-hint {
      position: absolute;
      top: 50px;
      left: 50%;
      transform: translateX(-50%);
      padding: 8px 16px;
      background: rgba(15, 23, 42, 0.92);
      border: 1px solid #1f2937;
      border-radius: 6px;
      font-size: 12px;
      color: var(--text-soft);
      z-index: 18;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
      }
      .canvas-hint.visible {
      opacity: 1;
      }
      .edge {
      stroke: var(--edge-main);
      stroke-width: 4;
      opacity: 0.75;
      transition: 0.25s ease-in-out;
      cursor: pointer;
      }
      .edge.backup {
      stroke: var(--danger);
      stroke-width: 5;
      }
      .edge.active {
      opacity: 1;
      stroke-width: 7;
      }
      .free-preview {
      fill: none;
      stroke-dasharray: 4 4;
      pointer-events: none;
      }
      .free-point {
      fill: #e5e7eb;
      stroke: #0f172a;
      stroke-width: 1.5;
      cursor: grab;
      }
      .node-circle {
      fill: #1e293b;
      stroke: #475569;
      stroke-width: 2;
      transition: 0.25s ease;
      transform-origin: center center;
      }
      .node-hit-area {
      cursor: grab;
      pointer-events: all;
      }
      .node-group:hover .node-circle {
      filter: drop-shadow(0 0 10px rgba(79, 209, 197, 0.45));
      }
      .node-group.active .node-circle {
      stroke: var(--accent);
      animation: pulse 1.2s infinite ease-in-out;
      }
      @keyframes pulse {
      0% {
      filter: drop-shadow(0 0 4px #4fd1c5);
      }
      50% {
      filter: drop-shadow(0 0 14px #4fd1c5);
      }
      100% {
      filter: drop-shadow(0 0 4px #4fd1c5);
      }
      }
      .node-label {
      fill: var(--text-main);
      font-size: 18px;
      text-anchor: middle;
      font-weight: 600;
      }
      .node-sub {
      fill: var(--text-soft);
      font-size: 13px;
      text-anchor: middle;
      }
      .ping-indicator {
      fill: #6b7280;
      stroke: #4b5563;
      stroke-width: 1;
      }
      .ping-indicator.online {
      fill: #10b981;
      stroke: #059669;
      }
      .ping-indicator.offline {
      fill: #ef4444;
      stroke: #dc2626;
      }
      .ping-indicator.checking {
      fill: #f59e0b;
      stroke: #d97706;
      }
      @media (max-width: 1024px) {
      .node-label {
      font-size: 28px;
      }
      .node-sub {
      font-size: 20px;
      }
      }
      @media (max-width: 768px) {
      .node-label {
      font-size: 70px;
      }
      .node-sub {
      font-size: 50px;
      }
      }
      @media (max-width: 380px) {
      .node-label {
      font-size: 60px;
      }
      .node-sub {
      font-size: 42px;
      }
      }
      .details-panel {
      background: var(--panel-alt);
      padding: 22px;
      padding-bottom: 80px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 15px;
      position: relative;
      transition:
      width 0.3s ease,
      min-width 0.3s ease,
      padding 0.3s ease,
      opacity 0.3s ease;
      }
      .details-panel {
      min-width: 260px !important;
      }
      .details-panel {
      overflow-y: auto !important;
      overflow-x: hidden;
      }
      .details-panel.collapsed {
      width: 0 !important;
      min-width: 0 !important;
      padding: 0 !important;
      overflow: hidden;
      opacity: 0;
      }
      body {
      overflow-x: hidden;
      overflow-y: hidden;
      }
      main {
      overflow-x: hidden;
      overflow-y: visible;
      }
      .details-panel {
      overflow-y: auto !important;
      overflow-x: hidden;
      }
      .details-panel.collapsed {
      min-width: 0 !important;
      }
      .sidebar-toggle {
      position: absolute;
      left: -16px;
      top: 50%;
      transform: translateY(-50%);
      width: 16px;
      height: 60px;
      background: var(--panel-alt);
      border: 1px solid var(--edge-main);
      border-right: none;
      border-radius: 8px 0 0 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text-soft);
      font-size: 10px;
      z-index: 25;
      transition:
      background 0.2s,
      color 0.2s;
      }
      .sidebar-toggle:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .sidebar-toggle.collapsed {
      left: 0;
      border-right: 1px solid var(--edge-main);
      border-radius: 0 8px 8px 0;
      position: fixed;
      right: 0;
      left: auto;
      }
      .details-name {
      font-size: clamp(22px, 2.5vw, 30px);
      font-weight: 700;
      }
      .details-ip {
      font-size: clamp(16px, 2vw, 22px);
      color: var(--text-soft);
      }
      .details-role {
      font-size: clamp(16px, 2vw, 22px);
      color: var(--accent);
      }
      .size-controls {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-top: 10px;
      }
      .size-controls label {
      font-size: clamp(14px, 1.6vw, 18px);
      color: var(--text-soft);
      }
      .size-controls input[type="range"] {
      flex: 1;
      accent-color: var(--accent);
      }
      .size-controls button {
      padding: 6px 12px;
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      font-size: clamp(12px, 1.4vw, 16px);
      }
      .size-controls button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .style-section {
      margin-top: 15px;
      padding-top: 15px;
      border-top: 1px solid var(--edge-main);
      }
      .style-section summary {
      cursor: pointer;
      font-size: clamp(14px, 1.6vw, 20px);
      text-transform: uppercase;
      color: var(--text-soft);
      list-style: none;
      display: flex;
      justify-content: space-between;
      align-items: center;
      user-select: none;
      }
      .style-section summary::-webkit-details-marker {
      display: none;
      }
      .password-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #ffffff;
      z-index: 9999;
      }
      .style-section summary::after {
      content: "‚ñº";
      transition: transform 0.2s;
      }
      .style-section[open] summary::after {
      transform: rotate(180deg);
      }
      .style-content {
      margin-top: 10px;
      }
      .style-row {
      display: flex;
      gap: 10px;
      align-items: center;
      margin: 8px 0;
      }
      .style-row label {
      font-size: clamp(13px, 1.5vw, 17px);
      color: var(--text-soft);
      min-width: 80px;
      }
      .style-row input[type="color"] {
      width: 50px;
      height: 30px;
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      background: transparent;
      }
      .style-row input[type="number"] {
      width: 70px;
      padding: 4px 8px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(12px, 1.4vw, 16px);
      }
      .style-row select {
      flex: 1;
      padding: 4px 8px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(12px, 1.4vw, 16px);
      cursor: pointer;
      }
      .editable-text {
      cursor: pointer;
      transition: opacity 0.2s;
      }
      .editable-text:hover {
      opacity: 0.7;
      }
      .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      z-index: 999999;
      justify-content: center;
      align-items: center;
      overflow: auto;
      }
      .modal.active {
      display: inline-grid;
      }
      .modal-content {
      background: var(--panel-alt);
      padding: 25px;
      border-radius: 8px;
      border: 1px solid var(--edge-main);
      min-width: 300px;
      max-width: 90%;
      }
      .modal-content h3 {
      margin: 0 0 15px 0;
      color: var(--text-main);
      font-size: clamp(18px, 2vw, 24px);
      }
      .modal-content p {
      color: var(--text-soft);
      font-size: clamp(14px, 1.6vw, 18px);
      margin: 0 0 20px 0;
      }
      .modal-content input:not([type="color"]),
      .modal-content select {
      width: 100%;
      padding: 10px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(14px, 1.6vw, 18px);
      margin-bottom: 15px;
      user-select: text;
      -webkit-user-select: text;
      }
      .modal-content input[type="color"] {
      width: 60px;
      height: 36px;
      padding: 2px;
      border: 2px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      background: none;
      -webkit-appearance: none;
      appearance: none;
      }
      .modal-content input[type="color"]::-webkit-color-swatch-wrapper {
      padding: 0;
      }
      .modal-content input[type="color"]::-webkit-color-swatch {
      border: none;
      border-radius: 4px;
      }
      .modal-buttons {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
      margin-top: 10px;
      }
      .modal-buttons button {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: clamp(14px, 1.6vw, 18px);
      font-weight: 600;
      }
      .modal-buttons .btn-cancel {
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      }
      .modal-buttons .btn-save {
      background: var(--accent);
      color: var(--bg);
      }
      .modal-buttons .btn-delete {
      background: var(--danger);
      color: white;
      }
      .confirm-modal p {
      color: var(--text-soft);
      font-size: clamp(14px, 1.6vw, 18px);
      margin: 0 0 20px 0;
      }
      .context-menu-item {
      transition: background 0.15s;
      }
      .context-menu-item:hover {
      background: var(--panel);
      }
      .details-info-row {
      display: flex;
      align-items: center;
      margin: 6px 0;
      }
      .node-group.selected .node-circle,
      .node-group.selected rect,
      .node-group.selected polygon {
      stroke: #f59e0b;
      stroke-width: 3;
      }
      .node-group.search-highlight .node-circle,
      .node-group.search-highlight rect,
      .node-group.search-highlight polygon {
      stroke: #10b981;
      stroke-width: 3;
      filter: drop-shadow(0 0 8px #10b981);
      }
      .badge-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      }
      .badge {
      border: 1px solid var(--edge-main);
      padding: 5px 12px;
      border-radius: 22px;
      font-size: clamp(12px, 1.4vw, 18px);
      }
      .badge.wg {
      color: var(--accent);
      border-color: var(--accent);
      }
      .section-label {
      margin-top: 8px;
      font-size: clamp(14px, 1.6vw, 20px);
      text-transform: uppercase;
      color: var(--text-soft);
      }
      .list li {
      margin: 6px 0;
      font-size: clamp(14px, 1.6vw, 20px);
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      }
      .list li:hover {
      color: var(--accent);
      }
      .delete-note {
      color: var(--danger);
      font-size: 18px;
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.2s;
      flex-shrink: 0;
      }
      .list li:hover .delete-note {
      opacity: 1;
      }
      .editing {
      outline: 2px solid var(--accent);
      background: #0d141f;
      padding: 4px;
      border-radius: 6px;
      user-select: text;
      -webkit-user-select: text;
      }
      .mobile-menu-btn {
      display: none;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      color: var(--text-main);
      font-size: 22px;
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      }
      #topbar-menu {
      gap: 8px;
      }
      @media (min-width: 721px) {
      #topbar-menu {
      display: flex !important;
      }
      }
      @media (max-width: 720px) {
      #topbar-menu {
      display: none;
      }
      #topbar-menu.open {
      display: flex;
      }
      }
      @media (max-width: 720px) {
      .mobile-menu-btn {
      display: block;
      }
      #topbar-menu {
      position: absolute;
      top: var(--topbar-height);
      right: 0;
      background: var(--panel-alt);
      border-left: 1px solid var(--topbar-border);
      border-bottom: 1px solid var(--topbar-border);
      padding: 12px;
      display: none;
      flex-direction: column;
      width: 180px;
      z-index: 999;
      }
      #topbar-menu.open {
      display: flex;
      }
      header {
      position: relative;
      z-index: 9999;
      }
      }
      @media (max-width: 720px) {
      .draw-toolbar {
      position: absolute;
      top: auto;
      bottom: auto;
      left: 10px !important;
      right: auto !important;
      width: auto;
      gap: 6px;
      padding: 8px;
      }	  
      .topology-toolbar {
      position: absolute;
      top: auto;
      bottom: auto;
      width: auto;
      gap: 6px;
      padding: 8px;
      }
      .draw-toolbar {
      top: 10px !important;
      }
      .topology-toolbar {
      top: calc(10px + var(--draw-toolbar-height, 50px)) !important;
      }
      .canvas-hint {
      top: calc(10px + 120px);
      }
      }
      .icon-picker-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      z-index: 999999999;
      justify-content: center;
      align-items: center;
      }
      .icon-picker-modal.active {
      display: flex;
      }
      .icon-picker-content {
      background: var(--panel);
      border-radius: 12px;
      width: 90%;
      max-width: 800px;
      max-height: 80vh;
      display: flex;
      flex-direction: column;
      border: 1px solid var(--edge-main);
      }
      .icon-picker-header {
      padding: 20px;
      border-bottom: 1px solid var(--edge-main);
      }
      .icon-picker-header h3 {
      margin: 0 0 15px 0;
      color: var(--text-main);
      }
      .icon-picker-tabs {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
      flex-wrap: wrap;
      }
      .icon-picker-tab {
      padding: 8px 16px;
      background: var(--panel-alt);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      color: var(--text-soft);
      font-size: 14px;
      transition: all 0.2s;
      }
      .icon-picker-tab:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .icon-picker-tab.active {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
      }
      .icon-picker-search {
      width: 100%;
      padding: 10px 15px;
      background: var(--panel-alt);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      color: var(--text-main);
      font-size: 14px;
      }
      .icon-picker-search::placeholder {
      color: var(--text-soft);
      }
      .icon-picker-body {
      padding: 20px;
      overflow-y: auto;
      flex: 1;
      }
      .icon-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
      gap: 10px;
      }
      .icon-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 15px 10px;
      background: var(--panel-alt);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .icon-item:hover {
      background: var(--accent);
      border-color: var(--accent);
      transform: scale(1.05);
      }
      .icon-item svg {
      width: 32px;
      height: 32px;
      fill: var(--text-main);
      }
      .icon-item:hover svg {
      fill: var(--bg);
      }
      .icon-item-name {
      margin-top: 8px;
      font-size: 10px;
      color: var(--text-soft);
      text-align: center;
      word-break: break-word;
      }
      .icon-item:hover .icon-item-name {
      color: var(--bg);
      }
      .icon-picker-loading {
      text-align: center;
      padding: 40px;
      color: var(--text-soft);
      }
      .icon-picker-footer {
      padding: 15px 20px;
      border-top: 1px solid var(--edge-main);
      display: flex;
      justify-content: flex-end;
      }
      .icon-btn-cancel {
      padding: 8px 20px;
      background: var(--panel-alt);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      }
      .icon-btn-cancel:hover {
      background: var(--edge-main);
      }
      .icon-badge {
      display: inline-flex;
      align-items: center;
      gap: 5px;
      padding: 4px 8px;
      background: var(--panel-alt);
      border-radius: 4px;
      font-size: 12px;
      margin: 2px;
      }
      .icon-badge svg {
      width: 16px;
      height: 16px;
      fill: currentColor;
      }
      .pick-icon-btn {
      padding: 6px 12px;
      background: var(--accent);
      color: var(--bg);
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      margin-top: 8px;
      width: 100%;
      }
      .pick-icon-btn:hover {
      opacity: 0.9;
      }
      @media (max-width: 768px) {
      .icon-picker-content {
      width: 95%;
      max-height: 90vh;	
      }
      .modal-content {
      background: var(--panel-alt);
      }
      #search-input {
      width: 100%;
      }
      }
      .version-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .version-item:hover {
      background: var(--panel-alt);
      border-color: var(--accent);
      }
      .version-item.current {
      border-color: var(--accent);
      background: rgba(79, 209, 197, 0.1);
      }
      .version-info {
      flex: 1;
      }
      .version-info .timestamp {
      font-size: 13px;
      color: var(--text-main);
      font-weight: 600;
      }
      .version-info .details {
      font-size: 11px;
      color: var(--text-soft);
      margin-top: 4px;
      }
      .version-actions {
      display: flex;
      gap: 6px;
      }
      .audit-entry {
      padding: 8px 12px;
      background: var(--panel);
      border-left: 3px solid var(--edge-main);
      border-radius: 4px;
      font-size: 12px;
      }
      .audit-entry.node { border-left-color: #4fd1c5; }
      .audit-entry.connection { border-left-color: #9f7aea; }
      .audit-entry.style { border-left-color: #ed8936; }
      .audit-entry.rack { border-left-color: #48bb78; }
      .audit-entry.layer { border-left-color: #4299e1; }
      .audit-entry .time {
      color: var(--text-soft);
      font-size: 10px;
      }
      .audit-entry .action {
      color: var(--text-main);
      font-weight: 500;
      }
      .tab-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .tab-item:hover {
      background: var(--panel-alt);
      }
      .tab-item.active {
      border-color: var(--accent);
      background: rgba(79, 209, 197, 0.1);
      }
      .tab-item .tab-name {
      font-weight: 600;
      color: var(--text-main);
      flex: 1;
      }
      .tab-item .tab-stats {
      font-size: 11px;
      color: var(--text-soft);
      margin-right: 10px;
      }
      .tab-actions {
      display: flex;
      gap: 6px;
      }
      .secret-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      border-left: 3px solid var(--danger);
      }
      .secret-item .secret-name {
      font-weight: 600;
      color: var(--text-main);
      flex: 1;
      }
      .secret-item .secret-status {
      font-size: 11px;
      color: var(--text-soft);
      margin-right: 10px;
      }   
    </style>
  </head>
  <body style="background: rgb(5, 5, 5);" class="">
    <div class="icon-picker-modal" id="icon-picker-modal">
      <div class="icon-picker-content">
        <div class="icon-picker-header">
          <h3>Select Icon</h3>
          <div class="icon-picker-tabs">
            <button class="icon-picker-tab" data-library="mdi">MDI</button>
            <button class="icon-picker-tab" data-library="simple">Simple Icons</button>
            <button class="icon-picker-tab active" data-library="selfhst">selfh.st/icons</button>
          </div>
          <input type="text" class="icon-picker-search" id="icon-search" placeholder="Search icons..." style="display: none;">
        </div>
        <div class="icon-picker-body" id="icon-picker-body">
        </div>
        <div class="icon-picker-footer">
          <button class="icon-btn-cancel" id="icon-picker-cancel">Cancel</button>
        </div>
      </div>
    </div>
    <div class="modal" id="tabs-modal">
      <div class="modal-content" style="max-width: 600px;">
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Manage multiple topologies</p>
        <div id="tabs-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 400px; overflow-y: auto; margin-bottom: 15px;">
            <div class="tab-item active" onclick="switchTab(0)">
              <div class="tab-name">Corporate</div>
              <div class="tab-stats">21 nodes ‚Ä¢ 22 connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(0)" title="Rename tab">‚úèÔ∏è</button>
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(${index})" title="Delete tab">üóëÔ∏è</button>
              </div>
            </div>
          
            <div class="tab-item " onclick="switchTab(1)">
              <div class="tab-name">Homelab</div>
              <div class="tab-stats">20 nodes ‚Ä¢ 22 connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(1)" title="Rename tab">‚úèÔ∏è</button>
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(${index})" title="Delete tab">üóëÔ∏è</button>
              </div>
            </div>
          </div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="new-tab-name" placeholder="New tab name..." style="flex: 1; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <button class="btn-save" onclick="createNewTab()">+ Add Tab</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="tabs-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="rollback-modal">
      <div class="modal-content" style="max-width: 700px;">
        <h3>Version History</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Limit: Snapshots</p>
        <div id="rollback-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 450px; overflow-y: auto; margin-bottom: 15px;">
          <div style="text-align: center; padding: 40px; color: var(--text-soft);">No version history yet. Versions are saved automatically when you save the file.</div>
        </div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <button class="btn-cancel" onclick="clearRollbackHistory()">Clear History</button>
          <button class="btn-save" onclick="createManualSnapshot()">Create Snapshot</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="rollback-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="audit-log-modal">
      <div class="modal-content" style="max-width: 800px;">
        <h3>Audit Log</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Track all changes made to your topology</p>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <select id="audit-filter" style="padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
            <option value="all">All Events</option>
            <option value="node">Node Operations</option>
            <option value="connection">Connections</option>
            <option value="style">Style Changes</option>
            <option value="rack">Rack Operations</option>
            <option value="layer">Layer Changes</option>
          </select>
          <button class="btn-save" onclick="exportAuditLog()">Export</button>
        </div>
        <div id="audit-log-list" style="display: flex; flex-direction: column; gap: 4px; max-height: 450px; overflow-y: auto; margin-bottom: 15px; font-family: monospace; font-size: 12px;">
          <div style="text-align: center; padding: 40px; color: var(--text-soft);">No audit entries yet</div>
        </div>
        <div style="display: flex; gap: 8px;">
          <button class="btn-cancel" onclick="clearAuditLog()">Clear Log</button>
          <button class="btn-cancel" id="audit-log-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="secrets-modal">
      <div class="modal-content" style="max-width: 600px;">
        <h3>Notes</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Notes can also be stored with AES 256 encryption</p>
        <div id="secrets-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 350px; overflow-y: auto; margin-bottom: 15px;">
        </div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="new-secret-name" placeholder="Section name (e.g., 'Root Passwords')..." style="flex: 1; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <button class="btn-save" onclick="createNewSecret()">+ Add Note</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="secrets-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="secret-editor-modal">
      <div class="modal-content" style="max-width: 600px;">
        <h3 id="secret-editor-title">Edit Note</h3>
        <textarea id="secret-editor-content" placeholder="Enter sensitive information here..." style="width: 100%; height: 200px; padding: 12px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main); font-family: monospace; resize: vertical; margin-bottom: 15px;"></textarea>
        <div style="margin-bottom: 15px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
          <input type="checkbox" id="secret-auto-encrypt" checked="" style="cursor: pointer;">
          <span>Encrypt Note</span>
          </label>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" onclick="closeSecretEditor()">Cancel</button>
          <button class="btn-save" onclick="saveSecret()">Save</button>
        </div>
      </div>
    </div>
    <div class="modal" id="edit-modal">
      <div class="modal-content">
        <h3 id="modal-title">Edit Name</h3>
        <input type="text" id="modal-input">
        <div class="modal-buttons">
          <button class="btn-cancel" id="modal-cancel">Cancel</button>
          <button class="btn-save" id="modal-save">Save</button>
        </div>
      </div>
    </div>
    <div class="modal confirm-modal" id="confirm-modal">
      <div class="modal-content">
        <h3>Confirm</h3>
        <p id="confirm-message"> Are you sure you want to delete this line? </p>
        <div class="modal-buttons">
          <button class="btn-cancel" id="confirm-cancel">Cancel</button>
          <button class="btn-delete" id="confirm-delete">Delete</button>
        </div>
      </div>
    </div>
    <div class="modal" id="save-info-modal">
      <div class="modal-content">
        <h3>Why do I need to save?</h3>
        <p> Browsers are not allowed to overwrite local files automatically. When you click <strong>Save File</strong>, this page generates a new updated HTML file that contains all of your changes. Replace your old file with the new one to keep your edits. </p>
        <p style="margin-top: 12px;padding-top: 12px;border-top: 1px solid var(--edge-main);">
          <strong>Encryption:</strong> Check the "Encrypt" box before saving to password protect your data. You'll need the password to open the file later. No recovery possible!!
        </p>
				<p style="margin-top: 12px;padding-top: 12px;border-top: 1px solid var(--edge-main);">
          <strong>Decrpytion:</strong> Want to decrpyt your data? Simply export it using json export in top menu after successful password validation
        </p>
        <div class="modal-buttons">
          <button class="btn-cancel" id="save-info-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="settings-modal">
      <div class="modal-content" style="max-width: 400px">
        <h3>Page Settings</h3>
        <details class="style-section" open="">
          <summary>Background</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Solid Color</label>
              <input type="color" id="page-bg-color" value="#050608">
            </div>
            <p style="margin-top: 4px;font-size: 12px;color: var(--text-soft);">Change to apply a flat background color.</p>
          </div>
        </details>
        <details class="style-section" open="">
          <summary>Top Bar</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="topbar-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="topbar-border-color" value="#1f2533">
            </div>
          </div>
        </details>
        <details class="style-section" open="">
          <summary>Theme Colors</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Panel</label>
              <input type="color" id="panel-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Panel Alt</label>
              <input type="color" id="panel-alt-color" value="#10141b">
            </div>
            <div class="style-row">
              <label>Accent</label>
              <input type="color" id="accent-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Danger</label>
              <input type="color" id="danger-color" value="#f56565">
            </div>
            <div class="style-row">
              <label>Text Main</label>
              <input type="color" id="text-main-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Text Soft</label>
              <input type="color" id="text-soft-color" value="#94a3b8">
            </div>
          </div>
        </details>
        <details class="style-section" open="">
          <summary>Auto Status Checking</summary>
          <div class="style-content">
            <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 16px; cursor: pointer;">
            <input type="checkbox" id="auto-ping-enabled" style="cursor: pointer;">
            <span style="font-size: 14px; font-weight: 600;">Enable automatic status checking</span>
            </label>
            <div id="auto-ping-settings" style="display: none; padding-left: 20px; border-left: 2px solid var(--edge-main);">
              <div class="style-row" style="margin-bottom: 12px;">
                <label>Check Interval (seconds):</label>
                <input type="number" id="auto-ping-interval" min="5" max="3600" value="30" style="width: 80px; padding: 6px; background: var(--panel); border: 1px solid var(--edge-main); border-radius: 4px; color: var(--text-main);">
              </div>
              <div style="padding: 10px; background: var(--panel); border-radius: 6px; border: 1px solid var(--edge-main); font-size: 12px; color: var(--text-soft);">
                <div style="margin-bottom: 4px;"><span id="auto-ping-next-check">Next check in: --</span></div>
                <div><span id="auto-ping-last-run">Last run: 1:15:07 PM</span></div>
              </div>
            </div>
            <p style="margin-top: 12px; font-size: 12px; color: var(--text-soft); font-style: italic;">
              Automatically checks all ping enabled nodes at the specified interval. I recommend 30 to 60 seconds for local networks.
            </p>
          </div>
        </details>
        <details class="style-section" open="">
          <summary>Import / Export Data</summary>
          <div class="style-content">
            <p style="margin-bottom: 12px;font-size: 13px;color: var(--text-soft);">Export / Import your data to upgrade/downgrade versions of The One File.</p>
            <button id="export-data-btn" style="width: 100%;margin-bottom: 10px;padding: 10px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Export Data (JSON)</button>
            <button id="import-data-btn" style="width: 100%;padding: 10px;background: var(--panel);color: var(--text-main);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Import Data (JSON)</button>
            <input type="file" id="import-data-file" accept=".json" style="display: none">
          </div>
        </details>
        <details class="style-section" open="">
          <summary>Clear All</summary>
          <div class="style-content">
            <p style="margin-bottom: 12px;font-size: 13px;color: var(--text-soft);">This deletes everything on the canvas!</p>
            <button id="clear-all-btn" title="Clear all nodes" style="padding: 6px 12px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Clear All</button>
            <input type="file" id="import-data-file" accept=".json" style="display: none">
          </div>
        </details>
        <div class="modal-buttons">
          <button class="btn-cancel" id="settings-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="add-node-modal">
      <div class="modal-content">
        <h3>Add New Node</h3>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Basic Information</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Name</label>
          <input type="text" id="new-node-name" placeholder="e.g. web server, jellyfin">
          <label style="display: block;margin-bottom: 4px;margin-top: 12px;color: var(--text-soft);font-size: 13px;">IP / Subtitle</label>
          <input type="text" id="new-node-ip" placeholder="e.g. 192.168.1.100">
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Tags</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Text Tags (comma separated)</label>
          <input type="text" id="new-node-tags" placeholder="e.g. Docker, nginx, WG: vpn">
          <button class="pick-icon-btn" id="pick-new-node-tag-icon-btn" style="margin-top: 10px;">Add Icon Tag</button>
          <div id="new-node-icon-tags" style="margin-top: 10px; display: none;">
            <label style="display: block; margin-bottom: 8px; color: var(--text-soft); font-size: 13px;">Icon Tags:</label>
            <div id="new-node-icon-tags-list" style="display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 10px;"></div>
          </div>
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Node Appearance</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Basic Shapes</label>
          <select id="new-node-shape">
            <optgroup label="Basic Shapes">
              <option value="circle">Circle</option>
              <option value="square">Square</option>
              <option value="rectangle">Rectangle</option>
              <option value="triangle">Triangle</option>
              <option value="hexagon">Hexagon</option>
              <option value="diamond">Diamond</option>
              <option value="star">Star</option>
              <option value="stop-sign">Stop Sign</option>
            </optgroup>
            <optgroup label="Network Equipment">
              <option value="server">Server</option>
              <option value="pc">PC / Desktop</option>
              <option value="laptop">Laptop</option>
              <option value="phone">Phone / Mobile</option>
              <option value="router">Router</option>
              <option value="switch">Switch</option>
              <option value="firewall">Firewall</option>
              <option value="cloud">Cloud</option>
              <option value="database">Database</option>
              <option value="printer">Printer</option>
            </optgroup>
          </select>
          <button class="pick-icon-btn" id="pick-node-icon-btn" style="margin-top: 10px;"> Or search web icons</button>
          <div id="selected-node-icon" style="margin-top: 10px; display: none;">
            <label style="display: block; margin-bottom: 8px; color: var(--text-soft); font-size: 13px;">Selected Icon:</label>
            <div class="icon-badge" id="selected-node-icon-preview">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24">
                <image href="https://cdn.jsdelivr.net/gh/selfhst/icons@master/png/docker.png" width="24" height="24"></image>
              </svg>
              <span>docker</span>
            </div>
          </div>
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Ping / Status Monitoring</div>
          <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px; cursor: pointer;">
          <input type="checkbox" id="new-node-pingable" style="cursor: pointer;">
          <span style="color: var(--text-soft); font-size: 13px;">Enable ping/status check for this node</span>
          </label>
          <div id="new-node-ping-options" style="display: block; padding-left: 24px; border-left: 2px solid var(--edge-main);">
            <label style="display: block; margin-bottom: 4px; color: var(--text-soft); font-size: 13px;">Protocol</label>
            <select id="new-node-ping-protocol" style="margin-bottom: 12px;">
              <option value="http">HTTP (port 80) uses IP field</option>
              <option value="https">HTTPS (port 443) uses IP field</option>
              <option value="custom">Custom URL</option>
            </select>
            <div id="new-node-custom-url-container" style="display: block;">
              <label style="display: block; margin-bottom: 4px; color: var(--text-soft); font-size: 13px;">Custom URL</label>
              <input type="text" id="new-node-custom-url" placeholder="e.g. http://192.168.1.1:8080">
            </div>
            <label style="display: block; margin-bottom: 4px; margin-top: 8px; color: var(--text-soft); font-size: 13px;">
            Timeout (ms)
            </label>
            <input type="number" id="new-node-ping-timeout" value="3000" min="1000" max="10000" step="500">
          </div>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="add-node-cancel">Cancel</button>
          <button class="btn-save" id="add-node-save">Add Node</button>
        </div>
      </div>
    </div>
    <div class="modal" id="add-rack-modal">
      <div class="modal-content">
        <h3>Add New Rack</h3>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Basic Information</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Rack Name</label>
          <input type="text" id="new-rack-name" placeholder="e.g. Rack-A, DC1-R01, Production-01">
          <label style="display: block;margin-bottom: 4px;margin-top: 12px;color: var(--text-soft);font-size: 13px;">IP / Network Range (optional)</label>
          <input type="text" id="new-rack-ip" placeholder="e.g. 192.168.1.0/24">
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Tags</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Text Tags (comma separated)</label>
          <input type="text" id="new-rack-tags" placeholder="e.g. Production, Data Center 1, Row A">
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Rack Appearance</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Icon / Shape</label>
          <select id="new-rack-shape">
            <optgroup label="Basic Shapes">
              <option value="circle">Circle</option>
              <option value="square">Square</option>
              <option value="rectangle">Rectangle</option>
              <option value="triangle">Triangle</option>
              <option value="hexagon">Hexagon</option>
              <option value="diamond">Diamond</option>
              <option value="star">Star</option>
              <option value="stop-sign">Stop Sign</option>
            </optgroup>
            <optgroup label="Network Equipment">
              <option value="server" selected="">Server</option>
              <option value="pc">PC / Desktop</option>
              <option value="laptop">Laptop</option>
              <option value="phone">Phone / Mobile</option>
              <option value="router">Router</option>
              <option value="switch">Switch</option>
              <option value="firewall">Firewall</option>
              <option value="cloud">Cloud</option>
              <option value="database">Database</option>
              <option value="printer">Printer</option>
            </optgroup>
          </select>
          <button class="pick-icon-btn" id="pick-rack-icon-btn" style="margin-top: 10px;">Or Search Web Icons</button>
          <div id="selected-rack-icon" style="margin-top: 10px; display: none;">
            <label style="display: block; margin-bottom: 8px; color: var(--text-soft); font-size: 13px;">Selected Icon:</label>
            <div class="icon-badge" id="selected-rack-icon-preview">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24">
                <image href="" width="24" height="24"></image>
              </svg>
              <span></span>
            </div>
          </div>
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Rack Configuration</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Rack Capacity</label>
          <select id="new-rack-capacity">
            <option value="42" selected="">42U (Standard Full Rack)</option>
            <option value="48">48U (Large Rack)</option>
            <option value="24">24U (Half Rack)</option>
            <option value="12">12U (Small/Wall Mount)</option>
            <option value="6">6U (Mini Rack)</option>
          </select>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="add-rack-cancel">Cancel</button>
          <button class="btn-save" id="add-rack-save">Add Rack</button>
        </div>
      </div>
    </div>
    <div class="modal confirm-modal" id="clear-all-modal">
      <div class="modal-content">
        <h3>Clear All Nodes</h3>
        <p> This will remove ALL nodes and connections. This cannot be undone until you reload without saving. Are you sure? </p>
        <div class="modal-buttons">
          <button class="btn-cancel" id="clear-all-cancel">Cancel</button>
          <button class="btn-delete" id="clear-all-confirm">Clear Everything</button>
        </div>
      </div>
    </div>
    <div class="modal" id="layer-modal">
      <div class="modal-content" style="max-width: 400px;">
        <h3>Layer Visibility</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Toggle which layers are visible on the canvas</p>
        <div style="display: flex; flex-direction: column; gap: 10px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-physical" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Physical Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-logical" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Logical Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-security" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Security Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-application" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Application Layer</span>
          </label>
        </div>
        <div style="margin-top: 15px; display: flex; gap: 8px;">
          <button class="btn-cancel" style="flex: 1;" onclick="document.querySelectorAll('#layer-modal input[type=checkbox]').forEach(cb =&gt; cb.checked = false); applyLayerFilter();">Hide All</button>
          <button class="btn-save" style="flex: 1;" onclick="document.querySelectorAll('#layer-modal input[type=checkbox]').forEach(cb =&gt; cb.checked = true); applyLayerFilter();">Show All</button>
        </div>
        <div class="modal-buttons" style="margin-top: 10px;">
          <button class="btn-cancel" id="layer-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div id="context-menu" style="display: none !important;">
    </div>
    <header>
      <div class="title-block">
        <h1 id="page-title" class="editable-page-title">Corporate</h1>
        <div class="save-row">
          <button id="save-file-btn" class="save-btn" type="button">Save File</button>
          <label style="display: flex;align-items: center;gap: 4px;font-size: 12px;color: var(--text-soft);cursor: pointer;user-select: none;">
          <input type="checkbox" id="encrypt-toggle" style="cursor: pointer">
          <span title="Encrypt data with password">Encrypt</span>
          </label>
          <span id="save-help-btn" class="help-icon" title="Why save?">?</span>
        </div>
      </div>
      <div id="topbar-menu">
        <button id="back-to-topology-btn" title="Exit rack view and return to topology" style="padding: 6px 12px; background: var(--accent); color: var(--bg); border: none; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600; display: none;">‚Üê Back to Topology</button>
        <button id="add-node-btn" class="save-btn" title="Add new node" style="background: var(--accent)">+ Node</button>
        <button id="add-rack-btn" class="save-btn" title="Add new rack" style="background: var(--accent); margin-left: 8px;">+ Rack</button>
        <button id="undo-btn" title="Undo (Ctrl+Z)" style="padding: 6px 12px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600; opacity: 1;">‚Ü∂</button>
        <button id="redo-btn" title="Redo (Ctrl+Y)" disabled="" style="padding: 6px 12px;background: var(--panel);color: var(--text-main);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;opacity: 0.5;">‚Ü∑</button>
        <input id="search-input" type="text" placeholder="Search nodes..." style="padding: 6px 12px;background: var(--panel);color: var(--text-main);border: 1px solid var(--edge-main);border-radius: 6px;font-size: 14px;">
        <button id="check-all-ping-btn" title="Check status of all enabled nodes" style="padding: 6px 12px;background: var(--panel);color: var(--text-main);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Check Pings</button>
        <button id="layers-btn" title="Toggle layer visibility" style="padding: 6px 12px;background: var(--panel);color: var(--text-main);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Layers</button>
        <button id="tabs-btn" title="Manage document tabs" style="padding: 6px 12px;background: var(--panel);color: var(--text-main);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Tabs</button>
        <button id="rollback-btn" title="View version history" style="padding: 6px 12px;background: var(--panel);color: var(--text-main);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Snapshots</button>
        <button id="audit-log-btn" title="View audit log" style="padding: 6px 12px;background: var(--panel);color: var(--text-main);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Audit</button>
        <button id="secrets-btn" title="Manage encrypted notes" style="padding: 6px 12px;background: var(--panel);color: var(--text-main);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Notes</button>
        <button onclick="screenshotCanvas()" title="Export canvas as PNG image" style="padding: 6px 12px;background: var(--panel);color: var(--text-main);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">PNG</button>
        <button onclick="exportCanvasSVG()" title="Export canvas as SVG vector" style="padding: 6px 12px;background: var(--panel);color: var(--text-main);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">SVG</button>
        <button id="settings-btn" title="Page settings">‚öôÔ∏è</button>
      </div>
      <button id="mobile-menu-toggle" class="mobile-menu-btn">‚ò∞</button>
      <div class="header-resizer" id="header-resizer">
        <svg class="resizer-icon" width="40" height="6" viewBox="0 0 40 6" xmlns="http://www.w3.org/2000/svg">
          <circle cx="14" cy="3" r="2"></circle>
          <circle cx="20" cy="3" r="2"></circle>
          <circle cx="26" cy="3" r="2"></circle>
        </svg>
      </div>
    </header>
    <main>
      <section class="topology-panel">
        <div class="draw-toolbar" id="draw-toolbar" style="display: flex !important;">
          <button type="button" class="toolbar-close-btn" id="draw-toolbar-close-btn" title="Hide draw toolbar">‚úï</button>
          <button id="draw-toggle" title="Draw custom line">‚úèÔ∏è</button>
          <button id="rect-toggle" title="Draw rectangle">‚ñ≠</button>
          <button id="text-toggle" title="Add text">T</button>
          <select id="rect-style" title="Rectangle style">
            <option value="filled">Filled</option>
            <option value="outlined">Outlined</option>
          </select>
          <input type="color" id="draw-color" value="#f97316" title="Line color">
          <select id="draw-style" title="Line style">
            <option value="solid">Solid</option>
            <option value="dashed">Dashed</option>
            <option value="dotted">Dotted</option>
          </select>
          <select id="draw-arrow" title="Arrow direction">
            <option value="none">No arrows</option>
            <option value="forward">‚Üí Right</option>
            <option value="backward">‚Üê Left</option>
            <option value="both">‚Üî Both</option>
          </select>
          <button id="draw-undo" style="display: none" title="Undo last point">Undo</button>
        </div>
        <div class="topology-toolbar" id="topology-toolbar" style="display: flex !important;">
          <button type="button" class="toolbar-close-btn" id="topology-toolbar-close-btn" title="Hide add line toolbar">‚úï</button>
          <label for="add-line-select">Add line to:</label>
          <select id="add-line-select"><option value="edge-firewall">Edge Firewall</option><option value="core-switch-1">Core Switch 1</option><option value="core-switch-2">Core Switch 2</option><option value="dmz-firewall">DMZ Firewall</option><option value="web-server">Web Server</option><option value="mail-server">Mail Server</option><option value="dist-switch-1">Distribution SW 1</option><option value="dist-switch-2">Distribution SW 2</option><option value="access-switch-1">Access SW 1-1</option><option value="access-switch-2">Access SW 1-2</option><option value="access-switch-3">Access SW 2-1</option><option value="domain-controller">Domain Controller</option><option value="file-server">File Server</option><option value="db-server">Database Server</option><option value="backup-server">Backup Server</option><option value="wifi-controller">WiFi Controller</option><option value="vpn-gateway">VPN Gateway</option><option value="im-a-rack">IM A RACK</option></select>
          <input type="color" id="add-line-color" value="#475569" title="Line color" style="width: 30px;height: 24px;border: 1px solid var(--edge-main);border-radius: 4px;cursor: pointer;background: transparent;padding: 0;">
          <select id="add-line-direction" title="Line direction">
            <option value="none">No arrows</option>
            <option value="forward">‚Üí Forward</option>
            <option value="backward">‚Üê Backward</option>
            <option value="both">‚Üî Both</option>
          </select>
          <button id="add-line-btn">Add</button>
        </div>
        <div class="topology-toolbar bulk-toolbar-desktop" id="bulk-toolbar" style="display: none">
          <button type="button" class="toolbar-close-btn" id="bulk-toolbar-close" title="Clear selection">‚úï</button>
          <label style="font-weight: 600; color: var(--accent)">Selected: <span id="bulk-count">0</span></label>
          <button id="bulk-align-left" title="Align left">‚¨Ö Left</button>
          <button id="bulk-align-right" title="Align right">‚û° Right</button>
          <button id="bulk-align-top" title="Align top">‚¨Ü Top</button>
          <button id="bulk-align-bottom" title="Align bottom">‚¨á Bottom</button>
          <button id="bulk-distribute-h" title="Distribute horizontally">‚Üî Distribute H</button>
          <button id="bulk-distribute-v" title="Distribute vertically">‚Üï Distribute V</button>
          <button id="bulk-clone" title="Clone selected">üìã Clone</button>
          <button id="bulk-delete" title="Delete selected" style="background: var(--danger); color: white;">Delete</button>
        </div>
        <div class="bulk-toolbar-mobile" id="bulk-toolbar-mobile" style="display: none">
          <button type="button" id="bulk-mobile-btn" style="background: var(--accent);color: white;padding: 12px 20px;border-radius: 25px;font-weight: 600;font-size: 16px;box-shadow: 0 4px 12px rgba(0,0,0,0.3);border: none;cursor: pointer;display: flex;align-items: center;gap: 8px;">
          <span id="bulk-count-mobile">0</span>Selected</button>
        </div>
        <div id="bulk-actions-modal" style="display: none;position: fixed;bottom: 0;left: 0;right: 0;background: var(--panel-alt);border-top-left-radius:20px;border-top-right-radius:20px;padding:20px;padding-bottom:(safe-area-inset-bottom, 20px);box-shadow: 0 -4px 20px rgba(0,0,0,0.5);z-index: 10000;max-height: calc(100vh - 80px);overflow-y: auto;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            <h3 style="margin: 0; color: var(--accent); font-size: 20px;">
              <span id="bulk-count-modal">0</span> Nodes Selected
            </h3>
            <button id="bulk-modal-close" style="background: none;border: none;font-size: 24px;cursor: pointer;color: var(--text-main);padding: 0;width: 32px;height: 32px;">‚úï</button>
          </div>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
            <button id="bulk-align-left-mobile" class="bulk-action-btn">‚¨Ö<br><span style="font-size: 12px;">Align Left</span></button>
            <button id="bulk-align-right-mobile" class="bulk-action-btn">‚û°<br><span style="font-size: 12px;">Align Right</span></button>
            <button id="bulk-align-top-mobile" class="bulk-action-btn">‚¨Ü<br><span style="font-size: 12px;">Align Top</span></button>
            <button id="bulk-align-bottom-mobile" class="bulk-action-btn">‚¨á<br><span style="font-size: 12px;">Align Bottom</span></button>
            <button id="bulk-distribute-h-mobile" class="bulk-action-btn">‚Üî<br><span style="font-size: 12px;">Distribute H</span></button>
            <button id="bulk-distribute-v-mobile" class="bulk-action-btn">‚Üï<br><span style="font-size: 12px;">Distribute V</span></button>
            <button id="bulk-lock-mobile" class="bulk-action-btn">üîí<br><span style="font-size: 12px;">Lock Toggle</span></button>
            <button id="bulk-group-mobile" class="bulk-action-btn">‚≠ï<br><span style="font-size: 12px;">Group Toggle</span></button>
            <button id="bulk-clone-mobile" class="bulk-action-btn">üìã<br><span style="font-size: 12px;">Clone All</span></button>
            <button id="bulk-delete-mobile" class="bulk-action-btn" style="background: var(--danger); color: white;">üóë<br><span style="font-size: 12px;">Delete All</span></button>
          </div>
          <button id="bulk-clear-mobile" style="width: 100%;margin-top: 16px;padding: 14px;background: var(--panel-main);border: 1px solid var(--edge-main);border-radius: 8px;color: var(--text-main);font-size: 16px;cursor: pointer;">Clear Selection</button>
        </div>
        <div class="canvas-hint" id="canvas-hint"><ul><li>Scroll to zoom</li><li>Drag to pan</li><li>Right-click to select multiple</li><li>Your time is NOW!</li></ul></div>
        <div class="legend-container" id="edge-legend" style="display: flex;"><div class="legend-title">Line Legend</div><button type="button" class="legend-close-btn">‚úï</button><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(239, 68, 68); cursor: pointer;"></span><span class="legend-label" contenteditable="true">WAN / DMZ</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(245, 158, 11); cursor: pointer;"></span><span class="legend-label" contenteditable="true">Trunk / Uplink</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(16, 185, 129); cursor: pointer;"></span><span class="legend-label" contenteditable="true">Core / Distribution</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(59, 130, 246); cursor: pointer;"></span><span class="legend-label" contenteditable="true">Access Layer</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(139, 92, 246); cursor: pointer;"></span><span class="legend-label" contenteditable="true">Server VLAN</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(6, 182, 212); cursor: pointer;"></span><span class="legend-label" contenteditable="true">Management</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(249, 115, 22); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div></div>
        <div class="canvas-viewport" id="canvas-viewport">
          <svg id="map" viewBox="563.4450887044272 95.16763305664074 2673.1098225911455 2004.8323669433591" style=""><defs><marker id="arrow-forward" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto" markerUnits="strokeWidth"><path d="M0,0 L0,6 L9,3 z" fill="context-stroke"></path></marker><marker id="arrow-backward" markerWidth="10" markerHeight="10" refX="0" refY="3" orient="auto" markerUnits="strokeWidth"><path d="M9,0 L9,6 L0,3 z" fill="context-stroke"></path></marker></defs><rect x="100" y="100" width="3800" height="2800" fill="none" stroke="rgba(71, 85, 105, 0.3)" stroke-width="2" stroke-dasharray="10 5" rx="8"></rect><path d="M 2107.5723876953125 295.1676330566406 Q 2053.7861938476562 397.5838165283203 2000 500" fill="none" class="edge active" data-edge-id="edge-1" data-from="internet" data-to="edge-firewall" style="stroke: rgb(239, 68, 68); stroke-width: 6;"></path><path d="M 2107.5723876953125 295.1676330566406 Q 2053.7861938476562 397.5838165283203 2000 500" fill="none" data-edge-id="edge-1" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2000 500 Q 1850 700 1700 900" fill="none" class="edge" data-edge-id="edge-2" data-from="edge-firewall" data-to="core-switch-1" style="stroke: rgb(245, 158, 11); stroke-width: 5;"></path><path d="M 2000 500 Q 1850 700 1700 900" fill="none" data-edge-id="edge-2" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2000 500 Q 2150 700 2300 900" fill="none" class="edge" data-edge-id="edge-3" data-from="edge-firewall" data-to="core-switch-2" style="stroke: rgb(245, 158, 11); stroke-width: 5;"></path><path d="M 2000 500 Q 2150 700 2300 900" fill="none" data-edge-id="edge-3" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 1700 900 Q 2000 900 2300 900" fill="none" class="edge" data-edge-id="edge-4" data-from="core-switch-1" data-to="core-switch-2" style="stroke: rgb(16, 185, 129); stroke-width: 6;"></path><path d="M 1700 900 Q 2000 900 2300 900" fill="none" data-edge-id="edge-4" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 1700 900 Q 2250 900 2800 900" fill="none" class="edge" data-edge-id="edge-5" data-from="core-switch-1" data-to="dmz-firewall" style="stroke: rgb(239, 68, 68); stroke-width: 4;"></path><path d="M 1700 900 Q 2250 900 2800 900" fill="none" data-edge-id="edge-5" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2800 900 Q 2800 1075 2800 1250" fill="none" class="edge" data-edge-id="edge-6" data-from="dmz-firewall" data-to="web-server" style="stroke: rgb(239, 68, 68); stroke-width: 4;"></path><path d="M 2800 900 Q 2800 1075 2800 1250" fill="none" data-edge-id="edge-6" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2800 900 Q 2800 1225 2800 1550" fill="none" class="edge" data-edge-id="edge-7" data-from="dmz-firewall" data-to="mail-server" style="stroke: rgb(239, 68, 68); stroke-width: 4;"></path><path d="M 2800 900 Q 2800 1225 2800 1550" fill="none" data-edge-id="edge-7" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 1700 900 Q 1450 1150 1200 1400" fill="none" class="edge" data-edge-id="edge-8" data-from="core-switch-1" data-to="dist-switch-1" style="stroke: rgb(16, 185, 129); stroke-width: 5;"></path><path d="M 1700 900 Q 1450 1150 1200 1400" fill="none" data-edge-id="edge-8" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2300 900 Q 1750 1150 1200 1400" fill="none" class="edge" data-edge-id="edge-9" data-from="core-switch-2" data-to="dist-switch-1" style="stroke: rgb(16, 185, 129); stroke-width: 5;"></path><path d="M 2300 900 Q 1750 1150 1200 1400" fill="none" data-edge-id="edge-9" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 1700 900 Q 2100 1150 2500 1400" fill="none" class="edge" data-edge-id="edge-10" data-from="core-switch-1" data-to="dist-switch-2" style="stroke: rgb(16, 185, 129); stroke-width: 5;"></path><path d="M 1700 900 Q 2100 1150 2500 1400" fill="none" data-edge-id="edge-10" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2300 900 Q 2400 1150 2500 1400" fill="none" class="edge" data-edge-id="edge-11" data-from="core-switch-2" data-to="dist-switch-2" style="stroke: rgb(16, 185, 129); stroke-width: 5;"></path><path d="M 2300 900 Q 2400 1150 2500 1400" fill="none" data-edge-id="edge-11" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 1200 1400 Q 1000 1650 800 1900" fill="none" class="edge" data-edge-id="edge-12" data-from="dist-switch-1" data-to="access-switch-1" style="stroke: rgb(59, 130, 246); stroke-width: 4;"></path><path d="M 1200 1400 Q 1000 1650 800 1900" fill="none" data-edge-id="edge-12" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 1200 1400 Q 1200 1650 1200 1900" fill="none" class="edge" data-edge-id="edge-13" data-from="dist-switch-1" data-to="access-switch-2" style="stroke: rgb(59, 130, 246); stroke-width: 4;"></path><path d="M 1200 1400 Q 1200 1650 1200 1900" fill="none" data-edge-id="edge-13" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2500 1400 Q 2500 1650 2500 1900" fill="none" class="edge" data-edge-id="edge-14" data-from="dist-switch-2" data-to="access-switch-3" style="stroke: rgb(59, 130, 246); stroke-width: 4;"></path><path d="M 2500 1400 Q 2500 1650 2500 1900" fill="none" data-edge-id="edge-14" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 1700 900 Q 1400 900 1100 900" fill="none" class="edge" data-edge-id="edge-15" data-from="core-switch-1" data-to="domain-controller" style="stroke: rgb(139, 92, 246); stroke-width: 4;"></path><path d="M 1700 900 Q 1400 900 1100 900" fill="none" data-edge-id="edge-15" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 1700 900 Q 1150 900 600 900" fill="none" class="edge" data-edge-id="edge-16" data-from="core-switch-1" data-to="file-server" style="stroke: rgb(139, 92, 246); stroke-width: 4;"></path><path d="M 1700 900 Q 1150 900 600 900" fill="none" data-edge-id="edge-16" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 1700 900 Q 1150 1100 600 1300" fill="none" class="edge" data-edge-id="edge-17" data-from="core-switch-1" data-to="db-server" style="stroke: rgb(139, 92, 246); stroke-width: 4;"></path><path d="M 1700 900 Q 1150 1100 600 1300" fill="none" data-edge-id="edge-17" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 1700 900 Q 1400 1100 1100 1300" fill="none" class="edge" data-edge-id="edge-18" data-from="core-switch-1" data-to="backup-server" style="stroke: rgb(139, 92, 246); stroke-width: 4;"></path><path d="M 1700 900 Q 1400 1100 1100 1300" fill="none" data-edge-id="edge-18" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 1700 900 Q 2450 1150 3200 1400" fill="none" class="edge" data-edge-id="edge-19" data-from="core-switch-1" data-to="wifi-controller" style="stroke: rgb(6, 182, 212); stroke-width: 4;"></path><path d="M 1700 900 Q 2450 1150 3200 1400" fill="none" data-edge-id="edge-19" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2000 500 Q 1721.3592529296875 496.2307434082031 1442.718505859375 492.46148681640625" fill="none" class="edge" data-edge-id="edge-20" data-from="edge-firewall" data-to="vpn-gateway" style="stroke: rgb(245, 158, 11); stroke-width: 4;"></path><path d="M 2000 500 Q 1721.3592529296875 496.2307434082031 1442.718505859375 492.46148681640625" fill="none" data-edge-id="edge-20" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><polyline class="edge" data-edge-id="custom-1764789640610" fill="none" marker-end="url(#arrow-forward)" points="1692.203125,87.20563507080078 1797.742919921875,-18.33414649963379 1870.6156005859375,62.07711410522461" style="stroke: rgb(249, 115, 22); stroke-width: 4; stroke-dasharray: none;"></polyline><polyline points="1692.203125,87.20563507080078 1797.742919921875,-18.33414649963379 1870.6156005859375,62.07711410522461" data-edge-id="custom-1764789640610" style="fill: none; stroke: transparent; stroke-width: 20; cursor: pointer;"></polyline><polyline class="edge" data-edge-id="custom-1764789700766" fill="none" marker-start="url(#arrow-backward)" marker-end="url(#arrow-forward)" points="3094.37451171875,531.9804077148438 2848.114990234375,396.2864074707031" style="stroke: rgb(249, 115, 22); stroke-width: 4; stroke-dasharray: none;"></polyline><polyline points="3094.37451171875,531.9804077148438 2848.114990234375,396.2864074707031" data-edge-id="custom-1764789700766" style="fill: none; stroke: transparent; stroke-width: 20; cursor: pointer;"></polyline><g class="node-group active" data-node-id="internet" transform="translate(2107.5723876953125,295.1676330566406)" style="cursor: grab;"><circle r="220.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><path d="
             M -117.60000000000001 29.400000000000002
             Q -161.70000000000002 29.400000000000002 -161.70000000000002 -14.700000000000001
             Q -161.70000000000002 -73.5 -102.89999999999999 -73.5
             Q -102.89999999999999 -132.3 -29.400000000000002 -132.3
             Q 14.700000000000001 -161.70000000000002 73.5 -117.60000000000001
             Q 147 -117.60000000000001 161.70000000000002 -44.1
             Q 191.1 -14.700000000000001 161.70000000000002 29.400000000000002
             Q 161.70000000000002 73.5 102.89999999999999 73.5
             L -73.5 73.5
             Q -132.3 73.5 -132.3 29.400000000000002
             Z
            " class="node-circle" style="stroke: rgb(235, 0, 0);"></path><text class="node-label" x="0" y="-41.160000000000004" style="font-size: 48.51px; pointer-events: none;">Internet</text><text class="node-sub" x="0" y="58.800000000000004" style="font-size: 35.28px; pointer-events: none;">google.com</text><circle class="ping-indicator online" r="8.82" cx="-139.04058489990234" cy="-117.334"></circle></g><g class="node-group" data-node-id="edge-firewall" transform="translate(2000,500)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-55" y="-44" width="110" height="88" rx="4"></rect><line x1="-46.75" y1="-27.5" x2="46.75" y2="-27.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="-2.75" x2="46.75" y2="-2.75" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="22" x2="46.75" y2="22" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="-44" x2="-27.5" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="-44" x2="11" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="-19.25" x2="-8.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="-19.25" x2="30.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="5.5" x2="-27.5" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="5.5" x2="11" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="30.25" x2="-8.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="30.25" x2="30.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18.15px; pointer-events: none;">Edge Firewall</text><text class="node-sub" x="0" y="22" style="font-size: 13.2px; pointer-events: none;">192.168.1.1</text></g><g class="node-group" data-node-id="core-switch-1" transform="translate(1700,900)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-77" y="-22" width="154" height="44" rx="4"></rect><rect x="-66" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-48.4" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-30.799999999999997" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-13.199999999999996" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="4.400000000000006" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="22" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="39.60000000000001" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="57.2" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18.15px; pointer-events: none;">Core Switch 1</text><text class="node-sub" x="0" y="22" style="font-size: 13.2px; pointer-events: none;">10.0.0.1</text></g><g class="node-group" data-node-id="core-switch-2" transform="translate(2300,900)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-77" y="-22" width="154" height="44" rx="4"></rect><rect x="-66" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-48.4" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-30.799999999999997" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-13.199999999999996" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="4.400000000000006" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="22" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="39.60000000000001" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="57.2" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18.15px; pointer-events: none;">Core Switch 2</text><text class="node-sub" x="0" y="22" style="font-size: 13.2px; pointer-events: none;">10.0.0.2</text></g><g class="node-group" data-node-id="dmz-firewall" transform="translate(2800,900)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-55" y="-44" width="110" height="88" rx="4"></rect><line x1="-46.75" y1="-27.5" x2="46.75" y2="-27.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="-2.75" x2="46.75" y2="-2.75" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="22" x2="46.75" y2="22" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="-44" x2="-27.5" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="-44" x2="11" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="-19.25" x2="-8.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="-19.25" x2="30.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="5.5" x2="-27.5" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="5.5" x2="11" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="30.25" x2="-8.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="30.25" x2="30.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18.15px; pointer-events: none;">DMZ Firewall</text><text class="node-sub" x="0" y="22" style="font-size: 13.2px; pointer-events: none;">10.10.0.1</text></g><g class="node-group" data-node-id="web-server" transform="translate(2800,1250)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-66" y="-33" width="132" height="66" rx="4"></rect><line x1="-49.5" y1="-16.5" x2="-49.5" y2="16.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="-22" y1="-16.5" x2="-22" y2="16.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="5.5" y1="-16.5" x2="5.5" y2="16.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><circle cx="49.5" cy="0" r="5.5" style="fill: rgb(74, 222, 128);"></circle></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18.15px; pointer-events: none;">Web Server</text><text class="node-sub" x="0" y="22" style="font-size: 13.2px; pointer-events: none;">10.10.1.10</text></g><g class="node-group" data-node-id="mail-server" transform="translate(2800,1550)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-66" y="-33" width="132" height="66" rx="4"></rect><line x1="-49.5" y1="-16.5" x2="-49.5" y2="16.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="-22" y1="-16.5" x2="-22" y2="16.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="5.5" y1="-16.5" x2="5.5" y2="16.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><circle cx="49.5" cy="0" r="5.5" style="fill: rgb(74, 222, 128);"></circle></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18.15px; pointer-events: none;">Mail Server</text><text class="node-sub" x="0" y="22" style="font-size: 13.2px; pointer-events: none;">10.10.1.20</text></g><g class="node-group" data-node-id="dist-switch-1" transform="translate(1200,1400)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-77" y="-22" width="154" height="44" rx="4"></rect><rect x="-66" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-48.4" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-30.799999999999997" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-13.199999999999996" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="4.400000000000006" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="22" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="39.60000000000001" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="57.2" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18.15px; pointer-events: none;">Distribution SW 1</text><text class="node-sub" x="0" y="22" style="font-size: 13.2px; pointer-events: none;">10.1.0.1</text></g><g class="node-group" data-node-id="dist-switch-2" transform="translate(2500,1400)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-77" y="-22" width="154" height="44" rx="4"></rect><rect x="-66" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-48.4" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-30.799999999999997" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-13.199999999999996" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="4.400000000000006" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="22" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="39.60000000000001" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="57.2" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18.15px; pointer-events: none;">Distribution SW 2</text><text class="node-sub" x="0" y="22" style="font-size: 13.2px; pointer-events: none;">10.2.0.1</text></g><g class="node-group" data-node-id="access-switch-1" transform="translate(800,1900)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-77" y="-22" width="154" height="44" rx="4"></rect><rect x="-66" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-48.4" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-30.799999999999997" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-13.199999999999996" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="4.400000000000006" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="22" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="39.60000000000001" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="57.2" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18.15px; pointer-events: none;">Access SW 1-1</text><text class="node-sub" x="0" y="22" style="font-size: 13.2px; pointer-events: none;">10.1.1.1</text></g><g class="node-group" data-node-id="access-switch-2" transform="translate(1200,1900)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-77" y="-22" width="154" height="44" rx="4"></rect><rect x="-66" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-48.4" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-30.799999999999997" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-13.199999999999996" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="4.400000000000006" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="22" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="39.60000000000001" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="57.2" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18.15px; pointer-events: none;">Access SW 1-2</text><text class="node-sub" x="0" y="22" style="font-size: 13.2px; pointer-events: none;">10.1.2.1</text></g><g class="node-group" data-node-id="access-switch-3" transform="translate(2500,1900)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-77" y="-22" width="154" height="44" rx="4"></rect><rect x="-66" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-48.4" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-30.799999999999997" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-13.199999999999996" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="4.400000000000006" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="22" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="39.60000000000001" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="57.2" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18.15px; pointer-events: none;">Access SW 2-1</text><text class="node-sub" x="0" y="22" style="font-size: 13.2px; pointer-events: none;">10.2.1.1</text></g><g class="node-group" data-node-id="domain-controller" transform="translate(1100,900)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-66" y="-33" width="132" height="66" rx="4"></rect><line x1="-49.5" y1="-16.5" x2="-49.5" y2="16.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="-22" y1="-16.5" x2="-22" y2="16.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="5.5" y1="-16.5" x2="5.5" y2="16.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><circle cx="49.5" cy="0" r="5.5" style="fill: rgb(74, 222, 128);"></circle></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18.15px; pointer-events: none;">Domain Controller</text><text class="node-sub" x="0" y="22" style="font-size: 13.2px; pointer-events: none;">10.1.10.10</text></g><g class="node-group" data-node-id="file-server" transform="translate(600,900)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-66" y="-33" width="132" height="66" rx="4"></rect><line x1="-49.5" y1="-16.5" x2="-49.5" y2="16.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="-22" y1="-16.5" x2="-22" y2="16.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="5.5" y1="-16.5" x2="5.5" y2="16.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><circle cx="49.5" cy="0" r="5.5" style="fill: rgb(74, 222, 128);"></circle></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18.15px; pointer-events: none;">File Server</text><text class="node-sub" x="0" y="22" style="font-size: 13.2px; pointer-events: none;">10.1.10.20</text></g><g class="node-group" data-node-id="db-server" transform="translate(600,1300)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-38.5" y="-33" width="77" height="77"></rect><ellipse cx="0" cy="-33" rx="38.5" ry="13.75"></ellipse><ellipse cx="0" cy="44" rx="38.5" ry="13.75"></ellipse><ellipse cx="0" cy="-8.25" rx="38.5" ry="11" style="fill: none; stroke: rgb(71, 85, 105); stroke-width: 2;"></ellipse><ellipse cx="0" cy="19.25" rx="38.5" ry="11" style="fill: none; stroke: rgb(71, 85, 105); stroke-width: 2;"></ellipse></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18.15px; pointer-events: none;">Database Server</text><text class="node-sub" x="0" y="22" style="font-size: 13.2px; pointer-events: none;">10.1.10.30</text></g><g class="node-group" data-node-id="backup-server" transform="translate(1100,1300)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-66" y="-33" width="132" height="66" rx="4"></rect><line x1="-49.5" y1="-16.5" x2="-49.5" y2="16.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="-22" y1="-16.5" x2="-22" y2="16.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="5.5" y1="-16.5" x2="5.5" y2="16.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><circle cx="49.5" cy="0" r="5.5" style="fill: rgb(74, 222, 128);"></circle></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18.15px; pointer-events: none;">Backup Server</text><text class="node-sub" x="0" y="22" style="font-size: 13.2px; pointer-events: none;">10.1.10.40</text></g><g class="node-group" data-node-id="wifi-controller" transform="translate(3200,1400)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-60.50000000000001" y="-16.5" width="121.00000000000001" height="44" rx="6"></rect><rect x="-35.75" y="-49.5" width="5.5" height="33" rx="2"></rect><circle cx="-33" cy="-52.25" r="4.4"></circle><rect x="-2.75" y="-49.5" width="5.5" height="33" rx="2"></rect><circle cx="0" cy="-52.25" r="4.4"></circle><rect x="30.25" y="-49.5" width="5.5" height="33" rx="2"></rect><circle cx="33" cy="-52.25" r="4.4"></circle><circle cx="-38.5" cy="5.5" r="3.3" style="fill: rgb(74, 222, 128);"></circle><circle cx="-19.25" cy="5.5" r="3.3" style="fill: rgb(74, 222, 128);"></circle><circle cx="0" cy="5.5" r="3.3" style="fill: rgb(250, 204, 21);"></circle><circle cx="19.249999999999993" cy="5.5" r="3.3" style="fill: rgb(250, 204, 21);"></circle></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18.15px; pointer-events: none;">WiFi Controller</text><text class="node-sub" x="0" y="22" style="font-size: 13.2px; pointer-events: none;">10.0.0.100</text></g><g class="node-group" data-node-id="vpn-gateway" transform="translate(1442.718505859375,492.46148681640625)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-60.50000000000001" y="-16.5" width="121.00000000000001" height="44" rx="6"></rect><rect x="-35.75" y="-49.5" width="5.5" height="33" rx="2"></rect><circle cx="-33" cy="-52.25" r="4.4"></circle><rect x="-2.75" y="-49.5" width="5.5" height="33" rx="2"></rect><circle cx="0" cy="-52.25" r="4.4"></circle><rect x="30.25" y="-49.5" width="5.5" height="33" rx="2"></rect><circle cx="33" cy="-52.25" r="4.4"></circle><circle cx="-38.5" cy="5.5" r="3.3" style="fill: rgb(74, 222, 128);"></circle><circle cx="-19.25" cy="5.5" r="3.3" style="fill: rgb(74, 222, 128);"></circle><circle cx="0" cy="5.5" r="3.3" style="fill: rgb(250, 204, 21);"></circle><circle cx="19.249999999999993" cy="5.5" r="3.3" style="fill: rgb(250, 204, 21);"></circle></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18.15px; pointer-events: none;">VPN Gateway</text><text class="node-sub" x="0" y="22" style="font-size: 13.2px; pointer-events: none;">10.0.0.50</text></g><g class="node-group" data-node-id="im-a-rack" transform="translate(2704.9699135614965,335.6130504631501)" style="cursor: grab;"><circle r="300" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" id="mdi-airplane" viewBox="0 0 24 24" width="240" height="240" x="-120" y="-120" style="fill: rgb(219, 0, 0);"><path d="M20.56 3.91C21.15 4.5 21.15 5.45 20.56 6.03L16.67 9.92L18.79 19.11L17.38 20.53L13.5 13.1L9.6 17L9.96 19.47L8.89 20.53L7.13 17.35L3.94 15.58L5 14.5L7.5 14.87L11.37 11L3.94 7.09L5.36 5.68L14.55 7.8L18.44 3.91C19 3.33 20 3.33 20.56 3.91Z"></path></svg></g><text class="node-label" x="0" y="-56.00000000000001" style="font-size: 52px; pointer-events: none;">IM A RACK</text><text class="node-sub" x="0" y="80" style="font-size: 48px; pointer-events: none;"></text></g><g class="text-group" data-text-id="text-1764789614780"><text class="text-element" x="1511.4969482421875" y="142.70753479003906" dominant-baseline="middle" style="fill: rgb(10, 10, 10); font-size: 48px; font-weight: normal; font-style: normal; text-anchor: start; text-decoration: none; opacity: 1; cursor: move; user-select: none;">Google is live!</text><g class="text-delete-btn" style="cursor: pointer; display: none;"><circle cx="1531.4969482421875" cy="94.70753479003906" r="12" style="fill: rgb(245, 101, 101); stroke: white; stroke-width: 2;"></circle><text x="1531.4969482421875" y="94.70753479003906" text-anchor="middle" dominant-baseline="middle" style="fill: white; font-size: 16px; font-weight: bold; pointer-events: none;">√ó</text></g></g><g class="text-group" data-text-id="text-1764789667151"><text class="text-element" x="2755.139404296875" y="592.2888336181641" dominant-baseline="middle" style="fill: rgb(226, 232, 240); font-size: 43px; font-weight: normal; font-style: normal; text-anchor: start; text-decoration: none; opacity: 1; cursor: move; user-select: none;"><tspan x="2755.139404296875" dy="0">Double click me on desktop</tspan><tspan x="2755.139404296875" dy="51.6">or long press on mobile</tspan><tspan x="2755.139404296875" dy="51.6">to open the rack view</tspan></text><g class="text-delete-btn" style="cursor: pointer; display: none;"><circle cx="2775.139404296875" cy="549.2888336181641" r="12" style="fill: rgb(245, 101, 101); stroke: white; stroke-width: 2;"></circle><text x="2775.139404296875" y="549.2888336181641" text-anchor="middle" dominant-baseline="middle" style="fill: white; font-size: 16px; font-weight: bold; pointer-events: none;">√ó</text></g></g></svg>
        </div>
        <div class="minimap-zoom-wrapper" id="minimap-zoom-wrapper" style="display: block;">
          <button type="button" class="minimap-close-btn" id="minimap-close-btn" title="Hide map &amp; zoom">‚úï</button>
          <div class="minimap-container" id="minimap-container">
            <svg id="minimap" viewBox="0 0 4000 3000">
              <line x1="2107.5723876953125" y1="295.1676330566406" x2="2000" y2="500" class="minimap-edge"></line><line x1="2000" y1="500" x2="1700" y2="900" class="minimap-edge"></line><line x1="2000" y1="500" x2="2300" y2="900" class="minimap-edge"></line><line x1="1700" y1="900" x2="2300" y2="900" class="minimap-edge"></line><line x1="1700" y1="900" x2="2800" y2="900" class="minimap-edge"></line><line x1="2800" y1="900" x2="2800" y2="1250" class="minimap-edge"></line><line x1="2800" y1="900" x2="2800" y2="1550" class="minimap-edge"></line><line x1="1700" y1="900" x2="1200" y2="1400" class="minimap-edge"></line><line x1="2300" y1="900" x2="1200" y2="1400" class="minimap-edge"></line><line x1="1700" y1="900" x2="2500" y2="1400" class="minimap-edge"></line><line x1="2300" y1="900" x2="2500" y2="1400" class="minimap-edge"></line><line x1="1200" y1="1400" x2="800" y2="1900" class="minimap-edge"></line><line x1="1200" y1="1400" x2="1200" y2="1900" class="minimap-edge"></line><line x1="2500" y1="1400" x2="2500" y2="1900" class="minimap-edge"></line><line x1="1700" y1="900" x2="1100" y2="900" class="minimap-edge"></line><line x1="1700" y1="900" x2="600" y2="900" class="minimap-edge"></line><line x1="1700" y1="900" x2="600" y2="1300" class="minimap-edge"></line><line x1="1700" y1="900" x2="1100" y2="1300" class="minimap-edge"></line><line x1="1700" y1="900" x2="3200" y2="1400" class="minimap-edge"></line><line x1="2000" y1="500" x2="1442.718505859375" y2="492.46148681640625" class="minimap-edge"></line><circle cx="2107.5723876953125" cy="295.1676330566406" r="40" class="minimap-node"></circle><circle cx="2000" cy="500" r="40" class="minimap-node"></circle><circle cx="1700" cy="900" r="40" class="minimap-node"></circle><circle cx="2300" cy="900" r="40" class="minimap-node"></circle><circle cx="2800" cy="900" r="40" class="minimap-node"></circle><circle cx="2800" cy="1250" r="40" class="minimap-node"></circle><circle cx="2800" cy="1550" r="40" class="minimap-node"></circle><circle cx="1200" cy="1400" r="40" class="minimap-node"></circle><circle cx="2500" cy="1400" r="40" class="minimap-node"></circle><circle cx="800" cy="1900" r="40" class="minimap-node"></circle><circle cx="1200" cy="1900" r="40" class="minimap-node"></circle><circle cx="2500" cy="1900" r="40" class="minimap-node"></circle><circle cx="1100" cy="900" r="40" class="minimap-node"></circle><circle cx="600" cy="900" r="40" class="minimap-node"></circle><circle cx="600" cy="1300" r="40" class="minimap-node"></circle><circle cx="1100" cy="1300" r="40" class="minimap-node"></circle><circle cx="3200" cy="1400" r="40" class="minimap-node"></circle><circle cx="1442.718505859375" cy="492.46148681640625" r="40" class="minimap-node"></circle><circle cx="2704.9699135614965" cy="335.6130504631501" r="40" class="minimap-node"></circle><rect class="minimap-viewport" id="minimap-viewport" x="563.4450887044272" y="95.16763305664074" width="2673.1098225911455" height="2004.8323669433591"></rect>
            </svg>
          </div>
          <div class="zoom-toolbar" id="zoom-toolbar">
            <button id="zoom-in-btn" title="Zoom in">+</button>
            <div class="zoom-level" id="zoom-level">150%</div>
            <button id="zoom-out-btn" title="Zoom out">-</button>
            <div class="divider"></div>
            <button id="zoom-fit-btn" title="Fit to view">[ ]</button>
            <button id="zoom-reset-btn" title="Reset view">R</button>
          </div>
        </div>
        <button type="button" id="edge-legend-mini" class="legend-mini-btn" style="bottom: 10px; display: none;">Line Legend</button>
        <button type="button" id="minimap-mini" class="legend-mini-btn" style="right: 10px; left: auto; bottom: 10px; display: none;">Map</button>
        <button type="button" id="draw-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: 10px; right: auto; display: none;">Draw</button>
        <button type="button" id="topology-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: auto; right: 40px; display: none;">Add Line</button>
      <button type="button" id="edge-legend-mini" class="legend-mini-btn" style="bottom: 10px; display: none;">Legend</button><button type="button" id="minimap-mini" class="legend-mini-btn" style="right: 10px; left: auto; bottom: 10px; display: none;">Map</button><button type="button" id="draw-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: 10px; right: auto; display: none;">Draw</button><button type="button" id="topology-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: auto; right: 40px; display: none;">Add Line</button><button type="button" id="edge-legend-mini" class="legend-mini-btn" style="bottom: 10px; display: none;">Legend</button><button type="button" id="topology-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: auto; right: 40px; display: none;">Add Line</button><button type="button" id="minimap-mini" class="legend-mini-btn" style="right: 10px; left: auto; bottom: 10px; display: none;">Map</button><button type="button" id="draw-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: 10px; right: auto; display: none;">Draw</button></section>
      <aside class="details-panel" id="details-panel">
        <div class="sidebar-resizer" id="sidebar-resizer">
          <svg class="resizer-icon" width="6" height="40" viewBox="0 0 6 40" xmlns="http://www.w3.org/2000/svg">
            <circle cx="3" cy="14" r="2"></circle>
            <circle cx="3" cy="20" r="2"></circle>
            <circle cx="3" cy="26" r="2"></circle>
          </svg>
        </div>
        <div class="mobile-footer-resizer" id="mobile-footer-resizer">
          <svg class="resizer-icon" width="40" height="6" viewBox="0 0 40 6" xmlns="http://www.w3.org/2000/svg">
            <circle cx="14" cy="3" r="2"></circle>
            <circle cx="20" cy="3" r="2"></circle>
            <circle cx="26" cy="3" r="2"></circle>
          </svg>
        </div>
        <div id="node-panel" style="display: block;">
          <div class="details-name editable-text" id="node-name">Internet</div>
          <div class="details-ip editable-text" id="node-ip">google.com</div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">MAC:</span>
            <span class="editable-text" id="node-mac" style="flex: 1; cursor: pointer; color: var(--text-main);">--</span>
          </div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">Rack Unit:</span>
            <span class="editable-text" id="node-rack" style="flex: 1; cursor: pointer; color: var(--text-main);">--</span>
          </div>
          <div class="details-info-row" id="uheight-row" style="display: none;">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">U Height:</span>
            <span class="editable-text" id="node-uheight" style="flex: 1; cursor: pointer; color: var(--text-main);">1U</span>
          </div>
          <div class="details-info-row" id="assigned-rack-row" style="display: flex;">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">Assigned Rack:</span>
            <select id="node-assigned-rack" style="flex: 1; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;"><option value="">None</option><option value="im-a-rack">IM A RACK</option></select>
          </div>
          <div class="details-info-row" id="rack-capacity-row" style="display: none;">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">Rack Capacity:</span>
            <select id="node-rack-capacity" style="flex: 1; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;">
              <option value="42">42U</option>
              <option value="48">48U</option>
              <option value="24">24U</option>
              <option value="12">12U</option>
              <option value="6">6U</option>
            </select>
          </div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">Layer:</span>
            <select id="node-layer" style="flex: 1; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;">
              <option value="physical">Physical</option>
              <option value="logical">Logical</option>
              <option value="security">Security</option>
              <option value="application">Application</option>
            </select>
          </div>
          <div class="details-role" id="node-role">WAN</div>
          <div class="badge-row" id="node-tags"><span class="badge" style="cursor: pointer; position: relative;"><span>1Gbps</span><span style="opacity: 0.6; margin-left: 4px; font-size: 10px;"> ‚úï</span></span><span class="badge" style="cursor: pointer; position: relative;"><span>Redundant</span><span style="opacity: 0.6; margin-left: 4px; font-size: 10px;"> ‚úï</span></span><span class="badge" style="cursor: pointer; opacity: 0.6; border-style: dashed;">+ Add</span></div>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-tag-input" placeholder="Add tag..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-tag-btn" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button class="pick-icon-btn" id="pick-tag-icon-btn">Add Icon Tag</button>
          <div class="section-label">Size</div>
          <div class="size-controls">
            <label>Size:</label>
            <input type="range" id="size-slider" min="20" max="200" value="55">
            <span id="size-value">147</span>
            <button id="reset-size">Reset</button>
          </div>
          <details class="style-section" open="">
            <summary>Styling</summary>
            <div class="style-content">
              <div class="style-row">
                <label>Screen:</label>
                <select id="style-scope">
                  <option value="all">All</option>
                  <option value="desktop">Desktop</option>
                  <option value="tablet">Tablet</option>
                  <option value="mobile">Mobile</option>
                  <option value="fold">Fold</option>
                </select>
              </div>
              <div class="style-row">
                <label>Shape:</label>
                <select id="shape-select">
                  <optgroup label="Basic Shapes">
                    <option value="circle">Circle</option>
                    <option value="square">Square</option>
                    <option value="rectangle">Rectangle</option>
                    <option value="triangle">Triangle</option>
                    <option value="hexagon">Hexagon</option>
                    <option value="diamond">Diamond</option>
                    <option value="star">Star</option>
                    <option value="stop-sign">Stop Sign</option>
                  </optgroup>
                  <optgroup label="Network Equipment">
                    <option value="server">Server</option>
                    <option value="pc">PC / Desktop</option>
                    <option value="laptop">Laptop</option>
                    <option value="phone">Phone / Mobile</option>
                    <option value="router">Router</option>
                    <option value="switch">Switch</option>
                    <option value="firewall">Firewall</option>
                    <option value="cloud">Cloud</option>
                    <option value="database">Database</option>
                    <option value="printer">Printer</option>
                  </optgroup>
                </select>
              </div>
              <button class="pick-icon-btn" id="pick-shape-icon-btn">Or Search Web Icons</button>
			  <div class="style-row">
                <label>Fill Color:</label>
                <input type="color" id="circle-color" value="#1e293b">
              </div>
              <div class="style-row">
                <label>Border Color:</label>
                <input type="color" id="circle-border" value="#475569">
              </div>
              <div class="style-row">
                <label>Title Color:</label>
                <input type="color" id="title-color" value="#e2e8f0">
              </div>
              <div class="style-row">
                <label>Title Font:</label>
                <select id="title-font">
                  <option value="system-ui, sans-serif"> System UI </option>
                  <option value="monospace">Monospace</option>
                  <option value="serif">Serif</option>
                  <option value="cursive">Cursive</option>
                  <option value="'Courier New', monospace"> Courier </option>
                  <option value="Arial, sans-serif">Arial</option>
                  <option value="'Times New Roman', serif"> Times </option>
                </select>
              </div>
              <div class="style-row">
                <label>Title Size:</label>
                <input type="number" id="title-size" min="8" max="100" value="18">
              </div>
              <div class="style-row">
                <label>Sub Color:</label>
                <input type="color" id="sub-color" value="#94a3b8">
              </div>
              <div class="style-row">
                <label>Sub Font:</label>
                <select id="sub-font">
                  <option value="system-ui, sans-serif">System UI</option>
                  <option value="monospace">Monospace</option>
                  <option value="serif">Serif</option>
                  <option value="cursive">Cursive</option>
                  <option value="'Courier New', monospace">Courier</option>
                  <option value="Arial, sans-serif">Arial</option>
                  <option value="'Times New Roman', serif">Times</option>
                </select>
              </div>
              <div class="style-row">
                <label>Sub Size:</label>
                <input type="number" id="sub-size" min="6" max="80" value="13">
              </div>
              <div style="
                margin-top: 12px;
                padding-top: 10px;
                border-top: 1px solid var(--edge-main);
                ">
                <div style="font-size: 12px;color: var(--text-soft);margin-bottom: 8px;text-transform: uppercase;">Text Position</div>
                <div class="style-row">
                  <label>Name Y:</label>
                  <input type="number" id="title-offset-y" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>Name X:</label>
                  <input type="number" id="title-offset-x" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>IP Y:</label>
                  <input type="number" id="sub-offset-y" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>IP X:</label>
                  <input type="number" id="sub-offset-x" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div style="margin-top: 16px; font-size: 12px; color: var(--text-soft); text-transform: uppercase;">
                  Ping Indicator Position
                </div>
                <div class="style-row">
                  <label>Ping X:</label>
                  <input type="number" id="ping-offset-x" min="-200" max="200" value="0" style="width: 60px;">
                </div>
                <div class="style-row">
                  <label>Ping Y:</label>
                  <input type="number" id="ping-offset-y" min="-200" max="200" value="0" style="width: 60px;">
                </div>
              </div>
              <button id="reset-styles" style="width: 100%;margin-top: 10px;padding: 8px;background: var(--panel);color: var(--text-main);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: clamp(13px, 1.5vw, 17px);">Reset Styles</button>
            </div>
          </details>
          <details class="style-section">
            <summary>Ping / Status Monitoring</summary>
            <div class="style-content">
              <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px; cursor: pointer;">
              <input type="checkbox" id="node-pingable" style="cursor: pointer;">
              <span style="font-size: 14px;">Enable status check for this node</span>
              </label>
              <div id="node-ping-options" style="display: block;">
                <div class="style-row">
                  <label>Protocol:</label>
                  <select id="node-ping-protocol">
                    <option value="http">HTTP (port 80)</option>
                    <option value="https">HTTPS (port 443)</option>
                    <option value="custom">Custom URL</option>
                  </select>
                </div>
                <div id="node-custom-url-container" style="display: block; margin-top: 8px;">
                  <label style="display: block; margin-bottom: 4px; font-size: 13px;">Custom URL:</label>
                  <input type="text" id="node-custom-url" placeholder="e.g. http://192.168.1.1:8080" style="width: 100%;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: 14px;">
                </div>
                <div class="style-row" style="margin-top: 8px;">
                  <label>Timeout (ms):</label>
                  <input type="number" id="node-ping-timeout" value="3000" min="1000" max="10000" step="500" style="width: 100px;">
                </div>
                <div style="margin-top: 12px; padding: 10px; background: var(--panel); border-radius: 6px; border: 1px solid var(--edge-main);">
                  <div style="font-size: 12px; color: var(--text-soft); margin-bottom: 8px;">Current Status:</div>
                  <div id="node-ping-status" style="font-size: 14px; font-weight: 600; color: var(--accent);">‚óè Online</div>
                  <div id="node-ping-last-check" style="font-size: 11px; color: var(--text-soft); margin-top: 4px;">Last checked: 5:31:50 PM</div>
                </div>
                <button id="check-ping-now" style="width: 100%;margin-top: 10px;padding: 8px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Check Status Now</button>
              </div>
            </div>
          </details>
          <div class="section-label">Notes</div>
          <ul class="list" id="node-notes"><li><span style="flex: 1 1 0%;">Primary: Fiber</span><span class="delete-note">‚úï</span></li><li><span style="flex: 1 1 0%;">Backup: Cable</span><span class="delete-note">‚úï</span></li></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-note-input" placeholder="Type new note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-note-btn" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-node-btn" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: rgb(255, 255, 255);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;width: 100%;">Delete Node</button>
        </div>
        <div id="edge-panel" style="display: none">
          <div class="details-name" id="edge-title">Custom line</div>
          <div class="style-row" style="margin-top: 10px">
            <label>Width:</label>
            <input type="number" id="edge-width" min="1" max="20" value="4">
          </div>
          <div class="style-row">
            <label>Color:</label>
            <input type="color" id="edge-color" value="#475569">
          </div>
          <div class="style-row">
            <label>Line Style:</label>
            <select id="edge-line-style">
              <option value="solid">Solid</option>
              <option value="dashed">Dashed</option>
              <option value="dotted">Dotted</option>
            </select>
          </div>
          <div class="style-row">
            <label>Direction:</label>
            <select id="edge-direction">
              <option value="none">No arrows</option>
              <option value="forward">‚Üí Forward</option>
              <option value="backward">‚Üê Backward</option>
              <option value="both">‚Üî Bidirectional</option>
            </select>
          </div>
          <div class="style-row" id="edge-port-fields">
            <label>From Port:</label>
            <input type="text" id="edge-from-port" placeholder="e.g. eth0, gi0/1" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);font-size: 14px;">
          </div>
          <div class="style-row" id="edge-port-fields-to">
            <label>To Port:</label>
            <input type="text" id="edge-to-port" placeholder="e.g. eth1, gi0/2" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);font-size: 14px;">
          </div>
          <div class="section-label">Line Notes</div>
          <ul class="list" id="edge-notes"></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-edge-note" placeholder="Add note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-edge-note" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-edge" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Delete Line</button>
        </div>
        <div id="text-panel" style="display: none">
          <div class="details-name" id="text-title">Text Element</div>
          <div class="style-row" style="margin-top: 10px">
            <label>Content:</label>
            <textarea id="text-content" placeholder="Enter text..." style="width: 100%;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: 14px;min-height: 80px;resize: vertical;font-family: inherit;"></textarea>
          </div>
          <div class="style-row">
            <label>Font Size:</label>
            <input type="number" id="text-font-size" min="8" max="200" value="18" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);">
          </div>
          <div class="style-row">
            <label>Color:</label>
            <input type="color" id="text-color" value="#e2e8f0">
          </div>
          <div class="style-row">
            <label>Font Weight:</label>
            <select id="text-font-weight" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="normal">Normal</option>
              <option value="bold">Bold</option>
              <option value="600">Semi-Bold</option>
              <option value="300">Light</option>
            </select>
          </div>
          <div class="style-row">
            <label>Font Style:</label>
            <select id="text-font-style" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="normal">Normal</option>
              <option value="italic">Italic</option>
            </select>
          </div>
          <div class="style-row">
            <label>Text Align:</label>
            <select id="text-align" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="start">Left</option>
              <option value="middle">Center</option>
              <option value="end">Right</option>
            </select>
          </div>
          <div class="style-row">
            <label>Text Decoration:</label>
            <select id="text-decoration" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="none">None</option>
              <option value="underline">Underline</option>
              <option value="line-through">Strike Through</option>
            </select>
          </div>
          <div class="style-row">
            <label>Background:</label>
            <input type="color" id="text-bg-color" value="#000000">
            <label style="margin-left: 10px; display: flex; align-items: center; gap: 6px;">
            <input type="checkbox" id="text-bg-enabled" style="cursor: pointer;">
            <span style="font-size: 13px;">Enable</span>
            </label>
          </div>
          <div class="style-row">
            <label>Opacity:</label>
            <input type="range" id="text-opacity" min="0" max="1" step="0.1" value="1" style="flex: 1">
            <span id="text-opacity-val" style="min-width: 35px; text-align: right">100%</span>
          </div>
          <button id="delete-text" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;width: 100%;">Delete Text</button>
        </div>
        <details class="style-section" open="">
          <summary>Page Layout</summary>
          <div class="style-content">
            <div style="padding: 12px; background: var(--panel-alt); border-radius: 6px; color: var(--text-soft); font-size: 13px; line-height: 1.6;">
              <strong style="color: var(--accent); display: block; margin-bottom: 8px;">Drag to Resize:</strong>
              ‚Ä¢ <strong>Header:</strong> Drag the bottom edge of the header bar<br>
              ‚Ä¢ <strong>Sidebar:</strong> Drag the left edge of the sidebar panel<br>
              ‚Ä¢ <strong>Mobile:</strong> Drag the top edge of the footer panel<br>
              <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--edge-main); font-size: 12px;">
                Hover over panel edges to see resize handles
              </div>
            </div>
          </div>
        </details>
      </aside>
    </main>
    <script id="nodes-json" type="application/json">{}</script>
    <script id="topology-state" type="application/json">ENCRYPTED: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</script>
    <script>
      const IconLibrary = {
       libraries: {
        mdi: {
         name: 'Material Design Icons',
         cdnBase: 'https://cdn.jsdelivr.net/npm/@mdi/svg@latest/svg/',
         metaUrl: 'https://cdn.jsdelivr.net/npm/@mdi/svg@latest/meta.json',
         icons: []
        },
        simple: {
         name: 'Simple Icons',
         cdnBase: 'https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/',
         indexUrl: 'https://cdn.jsdelivr.net/npm/@iconify-json/simple-icons@latest/icons.json',
         icons: []
        },
        selfhst: {
         name: 'selfh.st/icons',
         cdnBase: 'https://cdn.jsdelivr.net/gh/selfhst/icons@master/png/',
         indexUrl: 'https://raw.githubusercontent.com/selfhst/icons/refs/heads/main/index.json',
         icons: []
        }
       },
       currentLibrary: 'selfhst',
       iconCache: {},
       indexCache: {},
       indexLoading: {},
       async loadLibraryIndex(library) {
        if (this.indexCache[library]) {
         return this.indexCache[library];
        }
        if (this.indexLoading[library]) {
         return this.indexLoading[library];
        }
        const lib = this.libraries[library];
        this.indexLoading[library] = (async () => {
         try {
          if (library === 'selfhst') {
           const response = await fetch(lib.indexUrl);
           const data = await response.json();
           const icons = data.map(item => ({
            name: item.Reference,
            displayName: item.Name,
            tags: item.Tags ? item.Tags.split(',').map(t => t.trim()).filter(t => t) : [],
            category: item.Category
           }));
           this.indexCache[library] = icons;
           lib.icons = icons;
           return icons;
          } else if (library === 'simple') {
           const response = await fetch('https://cdn.jsdelivr.net/npm/@iconify-json/simple-icons@latest/icons.json');
           const data = await response.json();
           const icons = Object.keys(data.icons).map(slug => ({
            name: slug,
            displayName: data.icons[slug].title || slug,
            tags: data.aliases && data.aliases[slug] ? [data.aliases[slug].parent] : [],
            hex: data.icons[slug].hex
           }));
           this.indexCache[library] = icons;
           lib.icons = icons;
           return icons;
          } else if (library === 'mdi') {
           const response = await fetch(lib.metaUrl);
           const data = await response.json();
           const icons = data.map(item => ({
            name: item.name,
            displayName: item.name,
            tags: item.tags || [],
            author: item.author
           }));
           this.indexCache[library] = icons;
           lib.icons = icons;
           return icons;
          }
         } catch (error) {
          console.error(`Failed to load index for ${library}:`, error);
          this.indexCache[library] = [];
          lib.icons = [];
          return [];
         } finally {
          delete this.indexLoading[library];
         }
        })();
        return this.indexLoading[library];
       },
       async getIcon(library, name) {
        const cacheKey = `${library}-${name}`;
        if (this.iconCache[cacheKey]) {
         return this.iconCache[cacheKey];
        }
        const cached = localStorage.getItem(`icon-${cacheKey}`);
        if (cached) {
         this.iconCache[cacheKey] = cached;
         return cached;
        }
        const lib = this.libraries[library];
        if (library === 'selfhst') {
         const pngUrl = `${lib.cdnBase}${name}.png`;
         const svgWrapper = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><image href="${pngUrl}" width="24" height="24"/></svg>`;
         this.iconCache[cacheKey] = svgWrapper;
         localStorage.setItem(`icon-${cacheKey}`, svgWrapper);
         return svgWrapper;
        }
        const url = `${lib.cdnBase}${name}.svg`;
        try {
         const response = await fetch(url);
         if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
         }
         const svg = await response.text();
         this.iconCache[cacheKey] = svg;
         localStorage.setItem(`icon-${cacheKey}`, svg);
         return svg;
        } catch (error) {
         console.error(`Failed to fetch icon ${cacheKey}:`, error);
         return null;
        }
       },
       searchIcons(library, query) {
        const lib = this.libraries[library];
        if (!lib.icons.length) return [];
        const q = query.toLowerCase();
        return lib.icons.filter(icon => {
         const nameMatch = icon.name.toLowerCase().includes(q);
         const displayMatch = icon.displayName && icon.displayName.toLowerCase().includes(q);
         const tagMatch = icon.tags && icon.tags.some(t => t.toLowerCase().includes(q));
         const categoryMatch = icon.category && icon.category.toLowerCase().includes(q);
         return nameMatch || displayMatch || tagMatch || categoryMatch;
        }).slice(0, 50);
       }
      };
      let iconPickerCallback = null;
      let selectedNodeIconData = null;
      let selectedRackIconData = null;
      let newNodeIconTags = [];
      
      async function checkNodeStatus(nodeId) {
       const data = NODE_DATA[nodeId];
       if (!data || !data.ping || !data.ping.enabled) return;
       
       data.ping.status = 'checking';
       data.ping.lastCheck = new Date().toISOString();
       updatePingIndicator(nodeId);
       if (currentNodeId === nodeId) {
        updatePingStatusDisplay(nodeId);
       }
       
       let url;
       if (data.ping.protocol === 'custom') {
        url = data.ping.customUrl;
       } else {
        const ip = data.ip || '0.0.0.0';
        const protocol = data.ping.protocol || 'http';
        url = `${protocol}://${ip}`;
       }
       
       if (!url) {
        data.ping.status = 'unknown';
        updatePingIndicator(nodeId);
        if (currentNodeId === nodeId) {
         updatePingStatusDisplay(nodeId);
        }
        return;
       }
       
       try {
        const controller = new AbortController();
        const timeout = data.ping.timeout || 3000;
        const timeoutId = setTimeout(() => controller.abort(), timeout);
        
        const response = await fetch(url, {
         method: 'HEAD',
         mode: 'no-cors', 
         signal: controller.signal
        });
        
        clearTimeout(timeoutId);
        
        data.ping.status = 'online';
       } catch (error) {
        data.ping.status = 'offline';
       }
       
       data.ping.lastCheck = new Date().toISOString();
       updatePingIndicator(nodeId);
       if (currentNodeId === nodeId) {
        updatePingStatusDisplay(nodeId);
       }
      }
      function rgbaToHex(val) {
      if (!val) return "#000000";
      if (val.startsWith("#")) return val;
      
      const m = val.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
      if (!m) return "#000000";
      
      const r = Number(m[1]).toString(16).padStart(2, "0");
      const g = Number(m[2]).toString(16).padStart(2, "0");
      const b = Number(m[3]).toString(16).padStart(2, "0");
      
      return `#${r}${g}${b}`;
      }
      function updatePingIndicator(nodeId) {
      const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
      if (!nodeGroup) return;
      
      const data = NODE_DATA[nodeId];
      if (!data || !data.ping || !data.ping.enabled) {
       const existingIndicator = nodeGroup.querySelector('.ping-indicator');
       if (existingIndicator) existingIndicator.remove();
       return;
      }
      
      let indicator = nodeGroup.querySelector('.ping-indicator');
      const label = nodeGroup.querySelector('.node-label');
      
      if (!indicator && label) {
       indicator = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
       indicator.classList.add('ping-indicator');
       nodeGroup.appendChild(indicator);
      }
      
      if (indicator && label) {
       const size = savedSizes[nodeId] || getDefaultSize();
       const radius = Math.max(4, size * 0.06);
      
       indicator.setAttribute('r', radius);
      
       const labelBBox = label.getBBox();
       const labelX = parseFloat(label.getAttribute('x') || 0);
       const labelY = parseFloat(label.getAttribute('y') || 0);
      
       const styles = resolveStylesForNode(nodeId);
      const offX = styles.pingOffsetX || 0;
      const offY = styles.pingOffsetY || 0;
      
      indicator.setAttribute('cx', (labelX - labelBBox.width / 2 - radius * 1.1) + offX);
      indicator.setAttribute('cy', (labelY - radius * 0.7) + offY);
      }
      
      if (indicator) {
       indicator.classList.remove('online', 'offline', 'checking');
       if (data.ping.status) indicator.classList.add(data.ping.status);
      }
      }
      
      
      function checkAllNodesStatus() {
       Object.keys(NODE_DATA).forEach(nodeId => {
        const data = NODE_DATA[nodeId];
        if (data && data.ping && data.ping.enabled) {
         checkNodeStatus(nodeId);
        }
       });
      }
      
      function startAutoPing() {
       stopAutoPing();
       
       checkAllNodesStatus();
       updateAutoPingLastRun();
       
       autoPingSecondsRemaining = autoPingInterval;
       
      
       autoPingTimer = setInterval(() => {
        checkAllNodesStatus();
        updateAutoPingLastRun();
        autoPingSecondsRemaining = autoPingInterval;
       }, autoPingInterval * 1000);
       
       autoPingCountdown = setInterval(() => {
        autoPingSecondsRemaining--;
        updateAutoPingCountdown();
        if (autoPingSecondsRemaining <= 0) {
         autoPingSecondsRemaining = autoPingInterval;
        }
       }, 1000);
       
       updateAutoPingCountdown();
      }
      
      function stopAutoPing() {
       if (autoPingTimer) {
        clearInterval(autoPingTimer);
        autoPingTimer = null;
       }
       if (autoPingCountdown) {
        clearInterval(autoPingCountdown);
        autoPingCountdown = null;
       }
       autoPingSecondsRemaining = 0;
       updateAutoPingCountdown();
      }
      
      function updateAutoPingCountdown() {
       const nextCheckEl = document.getElementById('auto-ping-next-check');
       if (nextCheckEl) {
        if (autoPingSecondsRemaining > 0 && autoPingEnabled) {
         const mins = Math.floor(autoPingSecondsRemaining / 60);
         const secs = autoPingSecondsRemaining % 60;
         if (mins > 0) {
          nextCheckEl.textContent = `Next check in: ${mins}m ${secs}s`;
         } else {
          nextCheckEl.textContent = `Next check in: ${secs}s`;
         }
        } else {
         nextCheckEl.textContent = 'Next check in: --';
        }
       }
      }
      
      function updateAutoPingLastRun() {
       const lastRunEl = document.getElementById('auto-ping-last-run');
       if (lastRunEl) {
        const now = new Date();
        lastRunEl.textContent = `Last run: ${now.toLocaleTimeString()}`;
       }
      }
      
      function openIconPicker(callback) {
       iconPickerCallback = callback;
       const modal = document.getElementById('icon-picker-modal');
       modal.classList.add('active');
       const searchInput = document.getElementById('icon-search');
       searchInput.style.display = 'none';
       loadIconsForCurrentLibrary();
      }
      
      function closeIconPicker() {
       const modal = document.getElementById('icon-picker-modal');
       modal.classList.remove('active');
       iconPickerCallback = null;
      }
      async function loadIconsForCurrentLibrary() {
       const body = document.getElementById('icon-picker-body');
       const libNames = {
        mdi: 'MDI (Material Design Icons)',
        simple: 'Simple Icons',
        selfhst: 'selfh.st/icons'
       };
       body.innerHTML = `<div style="padding: 20px;"><p style="color: var(--text-soft); margin-bottom: 15px; text-align: center;">Search ${libNames[IconLibrary.currentLibrary]}:</p><input type="text" id="icon-search-field" placeholder="Search icons..." style="width: 100%; padding: 12px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main); font-size: 16px; margin-bottom: 20px;"><div id="icon-grid-container" style="max-height: 400px; overflow-y: auto;"><div style="text-align: center; color: var(--text-soft); padding: 40px;">Loading icons...</div></div></div>`;
       const searchField = document.getElementById('icon-search-field');
       const gridContainer = document.getElementById('icon-grid-container');
       await IconLibrary.loadLibraryIndex(IconLibrary.currentLibrary);
       const renderIcons = (icons) => {
        if (!icons || icons.length === 0) {
         gridContainer.innerHTML = '<div style="text-align: center; color: var(--text-soft); padding: 40px;">No icons found</div>';
         return;
        }
        const grid = document.createElement('div');
        grid.style.cssText = 'display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 15px; padding: 10px;';
        icons.forEach(icon => {
         const item = document.createElement('div');
         item.style.cssText = 'display: flex; flex-direction: column; align-items: center; gap: 8px; padding: 15px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; cursor: pointer; transition: all 0.2s;';
         item.onmouseover = () => {
          item.style.background = 'var(--panel)';
          item.style.borderColor = 'var(--accent)';
         };
         item.onmouseout = () => {
          item.style.background = 'var(--panel-alt)';
          item.style.borderColor = 'var(--edge-main)';
         };
         const iconPreview = document.createElement('div');
         iconPreview.style.cssText = 'width: 48px; height: 48px; display: flex; align-items: center; justify-content: center;';
         iconPreview.innerHTML = '<div style="color: var(--text-soft); font-size: 12px;">...</div>';
         IconLibrary.getIcon(IconLibrary.currentLibrary, icon.name).then(svg => {
          if (svg) {
           const parser = new DOMParser();
           const doc = parser.parseFromString(svg, 'image/svg+xml');
           const svgEl = doc.querySelector('svg');
           if (svgEl) {
            svgEl.setAttribute('width', '48');
            svgEl.setAttribute('height', '48');
            svgEl.style.fill = 'var(--text-main)';
            iconPreview.innerHTML = '';
            iconPreview.appendChild(svgEl);
           }
          }
         });
         const name = document.createElement('div');
         name.textContent = icon.displayName || icon.name;
         name.style.cssText = 'font-size: 11px; color: var(--text-soft); text-align: center; word-break: break-word; max-width: 100%;';
         item.appendChild(iconPreview);
         item.appendChild(name);
         item.addEventListener('click', async () => {
          const svg = await IconLibrary.getIcon(IconLibrary.currentLibrary, icon.name);
          if (iconPickerCallback && svg) {
           iconPickerCallback({
            library: IconLibrary.currentLibrary,
            name: icon.name,
            svg: svg
           });
          }
          closeIconPicker();
         });
         grid.appendChild(item);
        });
        gridContainer.innerHTML = '';
        gridContainer.appendChild(grid);
       };
       gridContainer.innerHTML = '<div style="text-align: center; color: var(--text-soft); padding: 40px;">Type to search icons</div>';
       let searchTimeout;
       searchField.addEventListener('input', (e) => {
        clearTimeout(searchTimeout);
        const query = e.target.value.trim();
        searchTimeout = setTimeout(() => {
         if (!query) {
          gridContainer.innerHTML = '<div style="text-align: center; color: var(--text-soft); padding: 40px;">Type to search icons</div>';
          return;
         }
         const results = IconLibrary.searchIcons(IconLibrary.currentLibrary, query);
         renderIcons(results);
        }, 300);
       });
       searchField.focus();
      }
      async function displayIcons(icons) {
       const body = document.getElementById('icon-picker-body');
       const grid = document.createElement('div');
       grid.className = 'icon-grid';
       for (const icon of icons) {
        const item = document.createElement('div');
        item.className = 'icon-item';
        const svg = await IconLibrary.getIcon(icon.library, icon.name);
        if (svg) {
         const parser = new DOMParser();
         const doc = parser.parseFromString(svg, 'image/svg+xml');
         const svgEl = doc.querySelector('svg');
         if (svgEl) {
          item.innerHTML = svgEl.outerHTML;
         }
        } else {
         item.innerHTML = '<svg width = "32" height = "32"><rect width = "32" height = "32" fill = "currentColor"/> </svg>';
        }
        const name = document.createElement('div');
        name.className = 'icon-item-name';
        name.textContent = icon.name;
        item.appendChild(name);
        item.addEventListener('click', () => {
         if (iconPickerCallback) {
          iconPickerCallback({
           library: icon.library,
           name: icon.name,
           svg: svg
          });
         }
         closeIconPicker();
        });
        grid.appendChild(item);
       }
       body.innerHTML = '';
       body.appendChild(grid);
      }
      window.addEventListener('DOMContentLoaded', () => {
       document.querySelectorAll('.icon-picker-tab').forEach(tab => {
        tab.addEventListener('click', () => {
         document.querySelectorAll('.icon-picker-tab').forEach(t => t.classList.remove('active'));
         tab.classList.add('active');
         IconLibrary.currentLibrary = tab.dataset.library;
         loadIconsForCurrentLibrary();
        });
       });
       document.getElementById('icon-picker-cancel').addEventListener('click', closeIconPicker);
       document.getElementById('icon-picker-modal').addEventListener('click', (e) => {
        if (e.target.id === 'icon-picker-modal') {
         closeIconPicker();
        }
       });
      });
      let textDrawMode = false;
      const BASE_NODE_DATA = JSON.parse(document.getElementById("nodes-json").textContent, );
      let currentNodeId = "host";
      let currentEdgeId = null;
      let currentStyleScope = "all";
      let NODE_DATA = {};
      let EDGE_DATA = {
       list: []
      };
      let RECT_DATA = {
       list: []
      };
      let TEXT_DATA = {
       list: []
      };
      let EDGE_LEGEND = {};
      let savedPositions = {};
      let savedSizes = {};
      let savedStyles = {};
      let legendCollapsed = false;
      let minimapCollapsed = false;
      let drawToolbarCollapsed = false;
      let currentView = {
       mode: "topology",
       rackId: null
      };
      let savedTopologyView = null;
      let activeLayers = new Set(["physical", "logical", "security", "application"]);
      let topologyToolbarCollapsed = false;
      let legendMiniBtn = null;
      let minimapMiniBtn = null;
      let drawToolbarMiniBtn = null;
      let topologyToolbarMiniBtn = null;
      
      let autoPingEnabled = false;
      let autoPingInterval = 30;
      let autoPingTimer = null;
      let autoPingCountdown = null;
      let autoPingSecondsRemaining = 0;
      
      const ROLLBACK_STORAGE_KEY = "theonefile_rollback_history";
      let rollbackVersions = [];
      const MAX_ROLLBACK_VERSIONS = 50;
      let currentRollbackIndex = -1;
      
      const AUDIT_STORAGE_KEY = "theonefile_audit_log";
      let auditLog = [];
      const MAX_AUDIT_ENTRIES = 1000;
      
      let documentTabs = [{
        id: "main",
        name: "Main Topology",
        nodes: {},
        edges: { list: [] },
        positions: {},
        sizes: {},
        styles: {},
        legend: {},
        rects: { list: [] },
        texts: { list: [] },
		pageState: null
      }];
      let currentTabIndex = 0;
      
      let encryptedSections = {};
      
      let undoStack = [];
      let redoStack = [];
      const MAX_UNDO_STACK = 50;
      let selectedNodes = new Set();
      let isSelecting = false;
      let selectionStart = null;
      let selectionRect = null;
      let isDraggingSelection = false;
      let dragSelectionStart = null;
      let clipboard = null;
      
      const MobileManager = {
        isMobile: false,
        detect() {
      
          if (navigator.userAgentData?.mobile === true) {
            this.isMobile = true;
            return true;
          }
          const coarse = matchMedia("(pointer: coarse)").matches;
          const width = window.innerWidth <= 900;
          const portrait = matchMedia("(orientation: portrait)").matches;
          this.isMobile = coarse && (width || portrait);
          return this.isMobile;
        },
        applyInitialCollapse() {
          if (!this.isMobile) return;
          legendCollapsed = true;
          minimapCollapsed = true;
          drawToolbarCollapsed = true;
          topologyToolbarCollapsed = true;
          if (typeof updateLegendVisibility === "function") updateLegendVisibility();
          if (typeof updateMinimapVisibility === "function") updateMinimapVisibility();
          if (typeof updateDrawToolbarVisibility === "function") updateDrawToolbarVisibility();
          if (typeof updateTopologyToolbarVisibility === "function") updateTopologyToolbarVisibility();
        },
        updateBulkToolbar() {
          const desktop = document.getElementById("bulk-toolbar");
          const mobile = document.getElementById("bulk-toolbar-mobile");
          if (!desktop || !mobile) return;
          
          const isVisible = desktop.style.display !== "none" || mobile.style.display !== "none";
          
          if (this.isMobile) {
            desktop.style.display = "none";
            if (isVisible) {
              mobile.style.display = "flex";
            }
          } else {
            mobile.style.display = "none";
            if (isVisible) {
              desktop.style.display = "flex";
            }
          }
        },
        updateLayout() {
          const main = document.querySelector("main");
          if (!main) return;
        },
        updateCanvasHint() {
      const hint = document.getElementById("canvas-hint");
      if (!hint) return;
      
      const items = this.isMobile
      ? [
        "Pinch to zoom",
        "Drag to pan",
        "Double tap to select multiple",
        "Double tap to select multiple",
        "Your time is NOW!",
      ]
      : [
        "Scroll to zoom",
        "Drag to pan",
        "Right-click to select multiple",
        "Your time is NOW!",
      ];
      
      const list = document.createElement("ul");
      for (const item of items) {
      const li = document.createElement("li");
      li.textContent = item;
      list.appendChild(li);
      }
      
      hint.replaceChildren(list);
      },
        autoSelectStyleScope() {
          const scope = document.getElementById("style-scope");
          if (!scope) return;
          if (this.isMobile) scope.value = "mobile";
        },
        updateToolbarStack() {
          if (!this.isMobile) return;
          const draw = document.getElementById("draw-toolbar");
          const topo = document.getElementById("topology-toolbar");
          if (!draw || !topo) return;
          const h = draw.getBoundingClientRect().height;
          document.documentElement.style.setProperty("--draw-toolbar-height", h + "px");
        },
        updateLayoutControls() {
          const sidebarRow = document.getElementById("sidebar-width-row");
          const footerRow = document.getElementById("mobile-footer-row");
          if (sidebarRow && footerRow) {
            if (this.isMobile) {
              sidebarRow.style.display = "none";
              footerRow.style.display = "flex";
            } else {
              sidebarRow.style.display = "flex";
              footerRow.style.display = "none";
            }
          }
        },
        applyAll() {
          this.detect();
          this.applyInitialCollapse();
          this.updateBulkToolbar();
          this.updateLayout();
          this.updateCanvasHint();
          this.autoSelectStyleScope();
          this.updateToolbarStack();
          this.updateLayoutControls();
        }
      };
      function isMobileDevice() {
        return MobileManager.isMobile;
      }
      
      function ensureLegendMiniButton() {
       if (legendMiniBtn) return legendMiniBtn;
      
       const panel = document.querySelector(".topology-panel");
       if (!panel) return null;
       const btn = document.createElement("button");
       btn.type = "button";
       btn.id = "edge-legend-mini";
       btn.className = "legend-mini-btn";
       btn.textContent = "Legend";
       btn.style.bottom = "10px";
       const handleClick = (e) => {
        e.stopPropagation();
        e.preventDefault();
        legendCollapsed = false;
        updateLegendVisibility();
       };
       btn.addEventListener("click", handleClick);
       btn.addEventListener("touchend", handleClick);
       panel.appendChild(btn);
       legendMiniBtn = btn;
       return btn;
      }
      
      function ensureMinimapMiniButton() {
       if (minimapMiniBtn) return minimapMiniBtn;
       const panel = document.querySelector(".topology-panel");
       if (!panel) return null;
       const btn = document.createElement("button");
       btn.type = "button";
       btn.id = "minimap-mini";
       btn.className = "legend-mini-btn";
       btn.textContent = "Map";
       btn.style.right = "10px";
       btn.style.left = "auto";
       btn.style.bottom = "10px";
       const handleClick = (e) => {
        e.stopPropagation();
        e.preventDefault();
        minimapCollapsed = false;
        updateMinimapVisibility();
       };
       btn.addEventListener("click", handleClick);
       btn.addEventListener("touchend", handleClick);
       panel.appendChild(btn);
       minimapMiniBtn = btn;
       return btn;
      }
      
      function ensureDrawToolbarMiniButton() {
       if (drawToolbarMiniBtn) return drawToolbarMiniBtn;
       const panel = document.querySelector(".topology-panel");
       if (!panel) return null;
       const btn = document.createElement("button");
       btn.type = "button";
       btn.id = "draw-toolbar-mini";
       btn.className = "legend-mini-btn";
       btn.textContent = "Draw";
       btn.style.top = "10px";
       btn.style.left = "10px";
       btn.style.right = "auto";
       const handleClick = (e) => {
        e.stopPropagation();
        e.preventDefault();
        drawToolbarCollapsed = false;
        updateDrawToolbarVisibility();
       };
       btn.addEventListener("click", handleClick);
       btn.addEventListener("touchend", handleClick);
       panel.appendChild(btn);
       drawToolbarMiniBtn = btn;
       return btn;
      }
      
      function ensureTopologyToolbarMiniButton() {
       if (topologyToolbarMiniBtn) return topologyToolbarMiniBtn;
       const panel = document.querySelector(".topology-panel");
       if (!panel) return null;
       const btn = document.createElement("button");
       btn.type = "button";
       btn.id = "topology-toolbar-mini";
       btn.className = "legend-mini-btn";
       btn.textContent = "Add Line";
       btn.style.top = "10px";
       btn.style.left = "auto";
       btn.style.right = "40px";
       const handleClick = (e) => {
        e.stopPropagation();
        e.preventDefault();
        topologyToolbarCollapsed = false;
        updateTopologyToolbarVisibility();
       };
       btn.addEventListener("click", handleClick);
       btn.addEventListener("touchend", handleClick);
       panel.appendChild(btn);
       topologyToolbarMiniBtn = btn;
       return btn;
      }
      
      function updateToolbarStack() {
       if (!isMobileDevice()) return;
       const draw = document.getElementById("draw-toolbar");
       const topo = document.getElementById("topology-toolbar");
       if (!draw || !topo) return;
       const h = draw.getBoundingClientRect().height;
       document.documentElement.style.setProperty("--draw-toolbar-height", h + "px");
      }
      window.addEventListener("resize", updateToolbarStack);
      window.addEventListener("DOMContentLoaded", updateToolbarStack);
      updateToolbarStack();
      
      function updateLegendVisibility() {
       const legend = document.getElementById("edge-legend");
       const mini = ensureLegendMiniButton();
       if (!legend || !mini) return;
       const hasItems = legend.querySelectorAll(".legend-item").length > 0;
       if (!hasItems) {
        legend.style.display = "none";
        mini.style.display = "none";
        return;
       }
       if (legendCollapsed) {
        legend.style.display = "none";
        mini.style.display = "inline-flex";
       } else {
        legend.style.display = "flex";
        mini.style.display = "none";
       }
      }
      
      function updateMinimapVisibility() {
       const wrapper = document.getElementById("minimap-zoom-wrapper");
       const mini = ensureMinimapMiniButton();
       if (!wrapper || !mini) return;
       if (minimapCollapsed) {
        wrapper.style.display = "none";
        mini.style.display = "inline-flex";
       } else {
        wrapper.style.display = "block";
        mini.style.display = "none";
       }
      }
      
      function updateDrawToolbarVisibility() {
       const toolbar = document.getElementById("draw-toolbar");
       const mini = ensureDrawToolbarMiniButton();
       if (!toolbar || !mini) return;
       if (drawToolbarCollapsed) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "inline-flex";
       } else {
      if (isMobileDevice()) {    	   
        toolbar.style.setProperty('display', 'grid', 'important');
        mini.style.display = "none";
        } else {   
        toolbar.style.setProperty('display', 'flex', 'important');
        mini.style.display = "none";	  
      }
       }
      }
      
      function u8ToBase64(u8) {
      let binary = "";
      for (let i = 0; i < u8.length; i++) binary += String.fromCharCode(u8[i]);
      return btoa(binary);
      }
      
      function base64ToU8(base64) {
      const binary = atob(base64);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
      return bytes;
      }  
      
      function updateTopologyToolbarVisibility() {
       const toolbar = document.getElementById("topology-toolbar");
       const mini = ensureTopologyToolbarMiniButton();
       if (!toolbar || !mini) return;
       const hasSelectedNode = currentNodeId !== null;
       if (!hasSelectedNode) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "none";
       } else if (topologyToolbarCollapsed) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "inline-flex";
       } else {   
      if (isMobileDevice()) {    	   
        toolbar.style.setProperty('display', 'grid', 'important');
        mini.style.display = "none";
        } else {   
        toolbar.style.setProperty('display', 'flex', 'important');
        mini.style.display = "none";	  
      }
       }
      }
      
      const DEFAULT_PAGE_STATE = {
       title: "The One File: The Networkening",
       background: "",
       topbarBg: "rgba(9, 12, 20, 0.9)",
       topbarBorder: "#1f2533",
       panel: "#0b0e13",
       panelAlt: "#10141b",
       accent: "#4fd1c5",
       danger: "#f56565",
       textMain: "#e2e8f0",
       textSoft: "#94a3b8",
       topbarHeight: 52,
       sidebarWidth: 350,
       mobileFooterHeight: 40,
       sidebarCollapsed: false,
       autoPingEnabled: false,
       autoPingInterval: 30,
      };
      let PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE);
      const CANVAS_WIDTH = 4000;
      let CANVAS_HEIGHT = 3000;
      const BASE_CANVAS_HEIGHT = 3000;
      const CANVAS_PADDING = 100;
      
      const RACK_U_HEIGHT = 70;
      const RACK_WIDTH = 600;
      const RACK_START_X = CANVAS_WIDTH / 2;
      const RACK_START_Y = CANVAS_PADDING + 100;
      function getRackUHeight(rackId) {
      const capacity = getRackCapacity(rackId);
      const availableHeight = CANVAS_HEIGHT - RACK_START_Y - 200;
      return Math.floor(availableHeight / capacity);
      }
      let canvasState = {
       zoom: 1,
       panX: 0,
       panY: 0,
       minZoom: 0.25,
       maxZoom: 4,
       isPanning: false,
       panStartX: 0,
       panStartY: 0,
       spacePressed: false,
      };
      
      function getViewBox() {
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       return {
        x: canvasState.panX,
        y: canvasState.panY,
        width: viewWidth,
        height: viewHeight,
       };
      }
      
      function updateViewBox() {
       const svg = document.getElementById("map");
       const vb = getViewBox();
       svg.setAttribute("viewBox", `${vb.x} ${vb.y} ${vb.width} ${vb.height}`, );
       const zoomLevel = document.getElementById("zoom-level");
       if (zoomLevel) {
        zoomLevel.textContent = Math.round(canvasState.zoom * 100) + "%";
       }
       updateMinimap();
      }
      
      function updateMinimap() {
       const minimapViewport = document.getElementById("minimap-viewport");
       const minimapSvg = document.getElementById("minimap");
       if (!minimapViewport || !minimapSvg) return;
       const vb = getViewBox();
       minimapViewport.setAttribute("x", vb.x);
       minimapViewport.setAttribute("y", vb.y);
       minimapViewport.setAttribute("width", vb.width);
       minimapViewport.setAttribute("height", vb.height);
       const minimapNodes = minimapSvg.querySelectorAll(".minimap-node");
       minimapNodes.forEach((n) => n.remove());
       const minimapEdges = minimapSvg.querySelectorAll(".minimap-edge");
       minimapEdges.forEach((e) => e.remove());
       
       EDGE_DATA.list.forEach((edge) => {
        if (edge.type === "custom") return;
        
        const fromNode = NODE_DATA[edge.from];
        const toNode = NODE_DATA[edge.to];
        if (!fromNode || !toNode) return;
        
        if (currentView.mode === "rack") {
         if (fromNode.assignedRack !== currentView.rackId || 
             toNode.assignedRack !== currentView.rackId) {
          return;
         }
        } else {
         if (fromNode.assignedRack || toNode.assignedRack) {
          return;
         }
        }
        
        const p1 = savedPositions[edge.from];
        const p2 = savedPositions[edge.to];
        if (!p1 || !p2) return;
        const line = document.createElementNS("http://www.w3.org/2000/svg", "line", );
        line.setAttribute("x1", p1.x);
        line.setAttribute("y1", p1.y);
        line.setAttribute("x2", p2.x);
        line.setAttribute("y2", p2.y);
        line.classList.add("minimap-edge");
        minimapSvg.insertBefore(line, minimapViewport);
       });
      
       Object.entries(savedPositions).forEach(([id, pos]) => {
        const node = NODE_DATA[id];
        if (!node) return;
        
        if (currentView.mode === "rack") {
         if (node.assignedRack !== currentView.rackId) {
          return;
         }
        } else {
         if (node.assignedRack) {
          return;
         }
        }
        
        const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle", );
        circle.setAttribute("cx", pos.x);
        circle.setAttribute("cy", pos.y);
        circle.setAttribute("r", 40);
        circle.classList.add("minimap-node");
        minimapSvg.insertBefore(circle, minimapViewport);
       });
      }
      
      function zoomTo(newZoom, centerX, centerY) {
       const oldZoom = canvasState.zoom;
       newZoom = Math.max(canvasState.minZoom, Math.min(canvasState.maxZoom, newZoom), );
       if (centerX !== undefined && centerY !== undefined) {
        const oldWidth = CANVAS_WIDTH / oldZoom;
        const oldHeight = CANVAS_HEIGHT / oldZoom;
        const newWidth = CANVAS_WIDTH / newZoom;
        const newHeight = CANVAS_HEIGHT / newZoom;
        const pointX = canvasState.panX + centerX * oldWidth;
        const pointY = canvasState.panY + centerY * oldHeight;
        canvasState.panX = pointX - centerX * newWidth;
        canvasState.panY = pointY - centerY * newHeight;
       }
       canvasState.zoom = newZoom;
       constrainPan();
       updateViewBox();
      }
      
      function constrainPan() {
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       const minVisiblePortion = 0.1;
       const maxPanX = CANVAS_WIDTH - viewWidth * minVisiblePortion;
       const maxPanY = CANVAS_HEIGHT - viewHeight * minVisiblePortion;
       const minPanX = -viewWidth * (1 - minVisiblePortion);
       const minPanY = -viewHeight * (1 - minVisiblePortion);
       canvasState.panX = Math.max(minPanX, Math.min(maxPanX, canvasState.panX), );
       canvasState.panY = Math.max(minPanY, Math.min(maxPanY, canvasState.panY), );
      }
      
      function fitToContent() {
       const positions = Object.values(savedPositions);
       if (positions.length === 0) {
        resetView();
        return;
       }
       let minX = Infinity,
        minY = Infinity,
        maxX = -Infinity,
        maxY = -Infinity;
       positions.forEach((pos) => {
        minX = Math.min(minX, pos.x - 100);
        minY = Math.min(minY, pos.y - 100);
        maxX = Math.max(maxX, pos.x + 100);
        maxY = Math.max(maxY, pos.y + 100);
       });
       const contentWidth = maxX - minX + 200;
       const contentHeight = maxY - minY + 200;
       const viewport = document.getElementById("canvas-viewport");
       const vpRect = viewport.getBoundingClientRect();
       const aspectRatio = vpRect.width / vpRect.height;
       const contentAspect = contentWidth / contentHeight;
       let newZoom;
       if (contentAspect > aspectRatio) {
        newZoom = (vpRect.width / contentWidth) * (CANVAS_WIDTH / vpRect.width);
       } else {
        newZoom = (vpRect.height / contentHeight) * (CANVAS_HEIGHT / vpRect.height);
       }
       newZoom = Math.max(canvasState.minZoom, Math.min(2, newZoom));
       const viewWidth = CANVAS_WIDTH / newZoom;
       const viewHeight = CANVAS_HEIGHT / newZoom;
       canvasState.zoom = newZoom;
       canvasState.panX = minX - 100 - (viewWidth - contentWidth) / 2;
       canvasState.panY = minY - 100 - (viewHeight - contentHeight) / 2;
       constrainPan();
       updateViewBox();
      }
      
      function resetView() {
       canvasState.zoom = 1;
       canvasState.panX = 0;
       canvasState.panY = 0;
       updateViewBox();
      }
      window.addEventListener("DOMContentLoaded", () => {
       const toggle = document.getElementById("mobile-menu-toggle");
       const menu = document.getElementById("topbar-menu");
       if (!toggle || !menu) return;
       toggle.addEventListener("click", () => {
        menu.classList.toggle("open");
       });
       menu.addEventListener("click", (e) => {
        const target = e.target.closest("a, button");
        if (!target) return;
        if (isMobileDevice()) {
       menu.classList.remove("open");
      }
       });
       const minimapCloseBtn = document.getElementById("minimap-close-btn");
       if (minimapCloseBtn) {
        const handleMinimapClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         minimapCollapsed = true;
         updateMinimapVisibility();
        };
        minimapCloseBtn.addEventListener("click", handleMinimapClose);
        minimapCloseBtn.addEventListener("touchend", handleMinimapClose);
       }
       const drawToolbarCloseBtn = document.getElementById("draw-toolbar-close-btn");
       if (drawToolbarCloseBtn) {
        const handleDrawClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         drawToolbarCollapsed = true;
         updateDrawToolbarVisibility();
        };
        drawToolbarCloseBtn.addEventListener("click", handleDrawClose);
        drawToolbarCloseBtn.addEventListener("touchend", handleDrawClose);
       }
       const topologyToolbarCloseBtn = document.getElementById("topology-toolbar-close-btn");
       if (topologyToolbarCloseBtn) {
        const handleTopologyClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         topologyToolbarCollapsed = true;
         updateTopologyToolbarVisibility();
        };
        topologyToolbarCloseBtn.addEventListener("click", handleTopologyClose);
        topologyToolbarCloseBtn.addEventListener("touchstart", (e) => e.preventDefault(), {
         passive: false
        });
        topologyToolbarCloseBtn.addEventListener("touchend", handleTopologyClose);
       }
      
       updateMinimapVisibility();
       updateDrawToolbarVisibility();
       updateTopologyToolbarVisibility();
      });
      
      function applyLayerFilter() {  
       activeLayers.clear(); 
       if (document.getElementById("layer-physical").checked) activeLayers.add("physical");    
       if (document.getElementById("layer-logical").checked) activeLayers.add("logical");    
       if (document.getElementById("layer-security").checked) activeLayers.add("security");     
       if (document.getElementById("layer-application").checked) activeLayers.add("application");
       forgeTheTopology();    
      }
      
      function isNodeVisible(nodeId) {  
       const node = NODE_DATA[nodeId];    
       if (!node) return false;     
       const nodeLayer = node.layer || "physical";     
       return activeLayers.has(nodeLayer);     
      }
      
      function enterRack(rackId) {
      if (!NODE_DATA[rackId] || !NODE_DATA[rackId].isRack) return;
      const rackCapacity = getRackCapacity(rackId);
      const neededHeight = RACK_START_Y + (rackCapacity * RACK_U_HEIGHT) + 200;
      if (neededHeight > BASE_CANVAS_HEIGHT) {
      CANVAS_HEIGHT = neededHeight;
      }
       
       currentView.mode = "rack";
       currentView.rackId = rackId;
       
       const backBtn = document.getElementById("back-to-topology-btn");
       if (backBtn) backBtn.style.display = "inline-block";
       
       const hint = document.getElementById("canvas-hint");
       if (hint) {
        hint.textContent = `Viewing: ${NODE_DATA[rackId].name} | Double-click empty space to exit`;
        hint.classList.add("visible");
       }
       
      
      const rackUHeight = getRackUHeight(rackId);
      const rackHeight = rackCapacity * rackUHeight;
      const rackCenterX = RACK_START_X;
      const rackCenterY = RACK_START_Y + (rackHeight / 2);
       
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       
       canvasState.panX = rackCenterX - (viewWidth / 2);
       canvasState.panY = rackCenterY - (viewHeight / 2);
       
       constrainPan();
       updateViewBox();
       
       forgeTheTopology();
      }
      
      function exitRack() {
      CANVAS_HEIGHT = BASE_CANVAS_HEIGHT;
      currentView.mode = "topology";
      currentView.rackId = null;
       
       const backBtn = document.getElementById("back-to-topology-btn");
       if (backBtn) backBtn.style.display = "none";
       
       const hint = document.getElementById("canvas-hint");
       if (hint) {
        hint.classList.remove("visible");
       }
       
       if (savedTopologyView) {
        canvasState.zoom = savedTopologyView.zoom;
        canvasState.panX = savedTopologyView.panX;
        canvasState.panY = savedTopologyView.panY;
        updateViewBox();
       }
       
       forgeTheTopology();
      }
      
      function getRackCapacity(rackId) {
       const node = NODE_DATA[rackId];
       return node && node.rackCapacity ? parseInt(node.rackCapacity) : 42;
      }
      
      function populateRackDropdown() {
       const dropdown = document.getElementById("node-assigned-rack");
       if (!dropdown) return;
       
       dropdown.innerHTML = '<option value="">None</option>';
       
       Object.keys(NODE_DATA).forEach(id => {
        if (NODE_DATA[id].isRack) {
         const option = document.createElement("option");
         option.value = id;
         option.textContent = NODE_DATA[id].name;
         dropdown.appendChild(option);
        }
       });
      }
      
      function wieldThePower() {
       const root = document.documentElement;
       root.style.setProperty("--panel", PAGE_STATE.panel);
       root.style.setProperty("--panel-alt", PAGE_STATE.panelAlt);
       root.style.setProperty("--accent", PAGE_STATE.accent);
       root.style.setProperty("--danger", PAGE_STATE.danger);
       root.style.setProperty("--text-main", PAGE_STATE.textMain);
       root.style.setProperty("--text-soft", PAGE_STATE.textSoft);
       root.style.setProperty("--topbar-bg", PAGE_STATE.topbarBg);
       root.style.setProperty("--topbar-border", PAGE_STATE.topbarBorder);
       const topbarHeight = PAGE_STATE.topbarHeight || 52;
       const sidebarWidth = PAGE_STATE.sidebarWidth || 350;
       const mobileFooterHeight = PAGE_STATE.mobileFooterHeight || 40;
       root.style.setProperty("--topbar-height", topbarHeight + "px");
       root.style.setProperty("--sidebar-width", sidebarWidth + "px");
       root.style.setProperty("--mobile-footer-height", mobileFooterHeight + "vh", );
       const mainEl = document.querySelector("main");
       const detailsPanel = document.getElementById("details-panel");
       const sidebarToggle = document.getElementById("sidebar-toggle");
       if (PAGE_STATE.sidebarCollapsed) {
        if (mainEl) mainEl.classList.add("sidebar-collapsed");
        if (detailsPanel) detailsPanel.classList.add("collapsed");
        if (sidebarToggle) {
         sidebarToggle.classList.add("collapsed");
         sidebarToggle.textContent = "‚ñ∂";
        }
       } else {
        if (mainEl) mainEl.classList.remove("sidebar-collapsed");
        if (detailsPanel) detailsPanel.classList.remove("collapsed");
        if (sidebarToggle) {
         sidebarToggle.classList.remove("collapsed");
         sidebarToggle.textContent = "‚óÄ";
        }
       }
       if (PAGE_STATE.background) {
        document.body.style.background = PAGE_STATE.background;
       } else {
        document.body.style.background = "radial-gradient(circle at top, #1e2532 0, #050608 70%)";
       }
       document.title = PAGE_STATE.title || DEFAULT_PAGE_STATE.title;
       const titleEl = document.getElementById("page-title");
       if (titleEl) {
        titleEl.textContent = PAGE_STATE.title || DEFAULT_PAGE_STATE.title;
       }
      }
      (async function awakeTheImmortal() {
       let initialState = {};
       let decryptionCancelled = false;
       const stateEl = document.getElementById("topology-state");
       if (stateEl && stateEl.textContent.trim()) {
        try {
         let stateText = stateEl.textContent.trim();
         if (isEncrypted(stateText)) {
          let decrypted = false;
          let attempts = 0;
          const maxAttempts = 3;
          while (!decrypted && attempts < maxAttempts) {
           const password = prompt("This file is encrypted. Enter password to decrypt:\n(Attempt " + (attempts + 1) + " of " + maxAttempts + ")", );
           if (!password) {
            alert("Decryption cancelled. The file will not be loaded.", );
            decryptionCancelled = true;
            break;
           }
           try {
            stateText = await decryptData(stateText, password);
            decrypted = true;
           } catch (e) {
            attempts++;
            if (attempts < maxAttempts) {
             alert("Incorrect password. Please try again.");
            } else {
             alert("Maximum attempts reached. The file will not be loaded.", );
             decryptionCancelled = true;
            }
           }
          }
          if (!decrypted) {
           stateText = "{}";
          }
         }
         initialState = JSON.parse(stateText);
        } catch (e) {
         console.error("Failed to load state:", e);
         initialState = {};
        }
       }
       if (decryptionCancelled) {
        NODE_DATA = {};
        EDGE_DATA = {
         list: []
        };
        RECT_DATA = { list: [] };
        TEXT_DATA = { list: [] };
        EDGE_LEGEND = {};
        savedPositions = {};
        savedSizes = {};
        savedStyles = {};
       } else {
        NODE_DATA = initialState.nodeData ? initialState.nodeData : BASE_NODE_DATA;
        
        Object.keys(NODE_DATA).forEach(nodeId => {
         if (!NODE_DATA[nodeId].ping) {
          NODE_DATA[nodeId].ping = {
           enabled: false,
           protocol: 'http',
           customUrl: '',
           timeout: 3000,
           status: 'unknown',
           lastCheck: null
          };
         }
        });
        
        EDGE_DATA = initialState.edgeData ? initialState.edgeData : {
         list: [],
        };
        RECT_DATA = initialState.rectData ? initialState.rectData : { list: [] };
        TEXT_DATA = initialState.textData ? initialState.textData : { list: [] };
        EDGE_LEGEND = initialState.edgeLegend || {};
        savedPositions = initialState.nodePositions || {};
        savedSizes = initialState.nodeSizes || {};
        savedStyles = initialState.nodeStyles || {};
        if (initialState.iconCache) {
         IconLibrary.iconCache = initialState.iconCache;
        }
       }
       if (initialState.page) {
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, initialState.page, );
       }
       
       if (PAGE_STATE.autoPingEnabled !== undefined) {
        autoPingEnabled = PAGE_STATE.autoPingEnabled;
       }
       if (PAGE_STATE.autoPingInterval !== undefined) {
        autoPingInterval = PAGE_STATE.autoPingInterval;
       }
       
       if (initialState.canvas) {
        canvasState.zoom = initialState.canvas.zoom || 1;
        canvasState.panX = initialState.canvas.panX || 0;
        canvasState.panY = initialState.canvas.panY || 0;
       }
       
       if (initialState.savedTopologyView) {
        savedTopologyView = initialState.savedTopologyView;
       }
       
       if (initialState.documentTabs) {
        documentTabs = initialState.documentTabs;
        if (initialState.currentTabIndex !== undefined) {
          currentTabIndex = initialState.currentTabIndex;
          const currentTab = documentTabs[currentTabIndex];
          if (currentTab) {
            NODE_DATA = currentTab.nodes || NODE_DATA;
            EDGE_DATA = currentTab.edges || EDGE_DATA;
            savedPositions = currentTab.positions || savedPositions;
            savedSizes = currentTab.sizes || savedSizes;
            savedStyles = currentTab.styles || savedStyles;
            EDGE_LEGEND = currentTab.legend || EDGE_LEGEND;
            RECT_DATA = currentTab.rects || RECT_DATA;
            TEXT_DATA = currentTab.texts || TEXT_DATA;
            if (currentTab.pageState) PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, currentTab.pageState);
          }
        }
       }
       
       if (initialState.encryptedSections) {
        encryptedSections = initialState.encryptedSections;
       }
       
       wieldThePower();
       forgeTheTopology();
       updateViewBox();
       
       MobileManager.applyAll();
       
       if (autoPingEnabled) {
        startAutoPing();
       }
       
       const initialNodes = Object.keys(NODE_DATA);
       if (initialNodes.length > 0) {
        claimTheImmortal(initialNodes.includes("host") ? "host" : initialNodes[0], );
       } else {
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.display = "none";
       }
      })();
      
      window.addEventListener("resize", () => {
        MobileManager.applyAll();
      });
      
      function saveEdgeData() {}
      
      function saveEdgeLegend() {}
      
      function getBreakpointKey() {
       const w = window.innerWidth;
       if (w <= 380) return "fold";
       if (w <= 768) return "mobile";
       if (w <= 1024) return "tablet";
       return "desktop";
      }
      
      function resolveStylesEntry(styleEntry) {
       if (!styleEntry) return {};
       if (styleEntry.circleColor || styleEntry.titleColor || styleEntry.titleFont || styleEntry.titleSize || styleEntry.subColor || styleEntry.subFont || styleEntry.subSize) {
        return styleEntry;
       }
       const bp = getBreakpointKey();
       const base = styleEntry.all || {};
       const bpStyles = styleEntry[bp] || {};
       return Object.assign({}, base, bpStyles);
      }
      
      function resolveStylesForNode(id) {
       const styleEntry = savedStyles[id];
       if (!styleEntry) return {};
       return resolveStylesEntry(styleEntry);
      }
      
      function ensureStyleEntry(id) {
       if (!savedStyles[id]) savedStyles[id] = {};
       const entry = savedStyles[id];
       const flatProps = ["circleColor", "circleBorder", "titleColor", "titleFont", "titleSize", "subColor", "subFont", "subSize", ];
       const isFlat = flatProps.some((p) => Object.prototype.hasOwnProperty.call(entry, p), );
       if (isFlat) {
        const all = entry.all || {};
        flatProps.forEach((p) => {
         if (entry[p] !== undefined) {
          all[p] = entry[p];
          delete entry[p];
         }
        });
        entry.all = all;
       }
       return entry;
      }
      
      function getDefaultSize() {
       if (window.innerWidth <= 380) return 120;
       if (window.innerWidth <= 768) return 140;
       if (window.innerWidth <= 1024) return 70;
       return 55;
      }
      
      function createShapeElement(shape, size) {
       const ns = "http://www.w3.org/2000/svg";
       if (shape === "circle") {
        const c = document.createElementNS(ns, "circle");
        c.setAttribute("r", size);
        return c;
       }
       if (shape === "square") {
        const r = document.createElementNS(ns, "rect");
        const s = size * 2;
        r.setAttribute("x", -size);
        r.setAttribute("y", -size);
        r.setAttribute("width", s);
        r.setAttribute("height", s);
        r.setAttribute("rx", 4);
        return r;
       }
       if (shape === "rectangle") {
        const r = document.createElementNS(ns, "rect");
        r.setAttribute("x", -size * 1.4);
        r.setAttribute("y", -size * 0.8);
        r.setAttribute("width", size * 2.8);
        r.setAttribute("height", size * 1.6);
        r.setAttribute("rx", 6);
        return r;
       }
       if (shape === "triangle") {
        const p = document.createElementNS(ns, "polygon");
        const h = size * 1.8;
        const w = size * 2;
        p.setAttribute("points", `0,${-h} ${w / 2},${h / 2} ${-w / 2},${h / 2}`, );
        return p;
       }
       if (shape === "hexagon") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        const pts = [
         [0, -s],
         [s * 0.86, -s * 0.5],
         [s * 0.86, s * 0.5],
         [0, s],
         [-s * 0.86, s * 0.5],
         [-s * 0.86, -s * 0.5],
        ].map((pt) => pt.join(",")).join(" ");
        p.setAttribute("points", pts);
        return p;
       }
       if (shape === "stop-sign") {
        const p = document.createElementNS(ns, "polygon");
        const r = size;
        const ptsArr = [];
        for (let i = 0; i < 8; i++) {
         const a = (Math.PI / 4) * i + Math.PI / 8;
         ptsArr.push([Math.cos(a) * r, Math.sin(a) * r]);
        }
        const pts = ptsArr.map((pt) => pt.join(",")).join(" ");
        p.setAttribute("points", pts);
        return p;
       }
       if (shape === "star") {
        const p = document.createElementNS(ns, "polygon");
        const outer = size;
        const inner = size * 0.45;
        let pts = "";
        for (let i = 0; i < 10; i++) {
         const a = (Math.PI / 5) * i - Math.PI / 2;
         const r = i % 2 === 0 ? outer : inner;
         pts += `${Math.cos(a) * r},${Math.sin(a) * r} `;
        }
        p.setAttribute("points", pts.trim());
        return p;
       }
       if (shape === "diamond") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `0,${-s} ${s},0 0,${s} ${-s},0`);
        return p;
       }
       if (shape === "server") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.2);
        body.setAttribute("y", -size * 0.6);
        body.setAttribute("width", size * 2.4);
        body.setAttribute("height", size * 1.2);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 3; i++) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", -size * 0.9 + i * size * 0.5);
         line.setAttribute("y1", -size * 0.3);
         line.setAttribute("x2", -size * 0.9 + i * size * 0.5);
         line.setAttribute("y2", size * 0.3);
         line.style.stroke = "currentColor";
         line.style.strokeWidth = "2";
         line.style.opacity = "0.5";
         g.appendChild(line);
        }
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", size * 0.9);
        led.setAttribute("cy", 0);
        led.setAttribute("r", size * 0.1);
        led.style.fill = "#4ade80";
        g.appendChild(led);
        return g;
       }
       if (shape === "pc" || shape === "desktop") {
        const g = document.createElementNS(ns, "g");
        const monitor = document.createElementNS(ns, "rect");
        monitor.setAttribute("x", -size * 0.9);
        monitor.setAttribute("y", -size * 0.8);
        monitor.setAttribute("width", size * 1.8);
        monitor.setAttribute("height", size * 1.2);
        monitor.setAttribute("rx", 4);
        g.appendChild(monitor);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.75);
        screen.setAttribute("y", -size * 0.65);
        screen.setAttribute("width", size * 1.5);
        screen.setAttribute("height", size * 0.9);
        screen.setAttribute("rx", 2);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        const neck = document.createElementNS(ns, "rect");
        neck.setAttribute("x", -size * 0.15);
        neck.setAttribute("y", size * 0.4);
        neck.setAttribute("width", size * 0.3);
        neck.setAttribute("height", size * 0.3);
        g.appendChild(neck);
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.5);
        base.setAttribute("y", size * 0.7);
        base.setAttribute("width", size * 1);
        base.setAttribute("height", size * 0.15);
        base.setAttribute("rx", 2);
        g.appendChild(base);
        return g;
       }
       if (shape === "laptop") {
        const g = document.createElementNS(ns, "g");
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.8);
        screen.setAttribute("y", -size * 0.9);
        screen.setAttribute("width", size * 1.6);
        screen.setAttribute("height", size * 1.1);
        screen.setAttribute("rx", 4);
        g.appendChild(screen);
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.9);
        base.setAttribute("y", size * 0.25);
        base.setAttribute("width", size * 1.8);
        base.setAttribute("height", size * 0.6);
        base.setAttribute("rx", 4);
        g.appendChild(base);
        const pad = document.createElementNS(ns, "rect");
        pad.setAttribute("x", -size * 0.25);
        pad.setAttribute("y", size * 0.45);
        pad.setAttribute("width", size * 0.5);
        pad.setAttribute("height", size * 0.25);
        pad.setAttribute("rx", 2);
        pad.style.fill = "#1e293b";
        g.appendChild(pad);
        return g;
       }
       if (shape === "phone" || shape === "mobile") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.45);
        body.setAttribute("y", -size);
        body.setAttribute("width", size * 0.9);
        body.setAttribute("height", size * 2);
        body.setAttribute("rx", 8);
        g.appendChild(body);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.38);
        screen.setAttribute("y", -size * 0.85);
        screen.setAttribute("width", size * 0.76);
        screen.setAttribute("height", size * 1.6);
        screen.setAttribute("rx", 4);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        const btn = document.createElementNS(ns, "rect");
        btn.setAttribute("x", -size * 0.15);
        btn.setAttribute("y", size * 0.82);
        btn.setAttribute("width", size * 0.3);
        btn.setAttribute("height", size * 0.06);
        btn.setAttribute("rx", 2);
        btn.style.fill = "#475569";
        g.appendChild(btn);
        return g;
       }
       if (shape === "router") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.1);
        body.setAttribute("y", -size * 0.3);
        body.setAttribute("width", size * 2.2);
        body.setAttribute("height", size * 0.8);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        for (let i = -1; i <= 1; i++) {
         const ant = document.createElementNS(ns, "rect");
         ant.setAttribute("x", i * size * 0.6 - size * 0.05);
         ant.setAttribute("y", -size * 0.9);
         ant.setAttribute("width", size * 0.1);
         ant.setAttribute("height", size * 0.6);
         ant.setAttribute("rx", 2);
         g.appendChild(ant);
         const tip = document.createElementNS(ns, "circle");
         tip.setAttribute("cx", i * size * 0.6);
         tip.setAttribute("cy", -size * 0.95);
         tip.setAttribute("r", size * 0.08);
         g.appendChild(tip);
        }
        for (let i = 0; i < 4; i++) {
         const led = document.createElementNS(ns, "circle");
         led.setAttribute("cx", -size * 0.7 + i * size * 0.35);
         led.setAttribute("cy", size * 0.1);
         led.setAttribute("r", size * 0.06);
         led.style.fill = i < 2 ? "#4ade80" : "#facc15";
         g.appendChild(led);
        }
        return g;
       }
       if (shape === "switch") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.4);
        body.setAttribute("y", -size * 0.4);
        body.setAttribute("width", size * 2.8);
        body.setAttribute("height", size * 0.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 8; i++) {
         const port = document.createElementNS(ns, "rect");
         port.setAttribute("x", -size * 1.2 + i * size * 0.32);
         port.setAttribute("y", -size * 0.15);
         port.setAttribute("width", size * 0.22);
         port.setAttribute("height", size * 0.3);
         port.setAttribute("rx", 1);
         port.style.fill = "#1e293b";
         g.appendChild(port);
        }
        return g;
       }
       if (shape === "firewall") {
        const g = document.createElementNS(ns, "g");
        const wall = document.createElementNS(ns, "rect");
        wall.setAttribute("x", -size);
        wall.setAttribute("y", -size * 0.8);
        wall.setAttribute("width", size * 2);
        wall.setAttribute("height", size * 1.6);
        wall.setAttribute("rx", 4);
        g.appendChild(wall);
        for (let row = 0; row < 3; row++) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", -size * 0.85);
         line.setAttribute("y1", -size * 0.5 + row * size * 0.45);
         line.setAttribute("x2", size * 0.85);
         line.setAttribute("y2", -size * 0.5 + row * size * 0.45);
         line.style.stroke = "#475569";
         line.style.strokeWidth = "2";
         g.appendChild(line);
        }
        for (let row = 0; row < 4; row++) {
         const offset = row % 2 === 0 ? 0 : size * 0.35;
         for (let col = 0; col < 3; col++) {
          const line = document.createElementNS(ns, "line");
          const x = -size * 0.5 + col * size * 0.7 + offset;
          if (x > -size * 0.85 && x < size * 0.85) {
           line.setAttribute("x1", x);
           line.setAttribute("y1", -size * 0.8 + row * size * 0.45, );
           line.setAttribute("x2", x);
           line.setAttribute("y2", -size * 0.8 + row * size * 0.45 + size * 0.45, );
           line.style.stroke = "#475569";
           line.style.strokeWidth = "2";
           g.appendChild(line);
          }
         }
        }
        return g;
       }
       if (shape === "cloud") {
        const p = document.createElementNS(ns, "path");
        const s = size;
        p.setAttribute("d", `
             M ${-s * 0.8} ${s * 0.2}
             Q ${-s * 1.1} ${s * 0.2} ${-s * 1.1} ${-s * 0.1}
             Q ${-s * 1.1} ${-s * 0.5} ${-s * 0.7} ${-s * 0.5}
             Q ${-s * 0.7} ${-s * 0.9} ${-s * 0.2} ${-s * 0.9}
             Q ${s * 0.1} ${-s * 1.1} ${s * 0.5} ${-s * 0.8}
             Q ${s * 1} ${-s * 0.8} ${s * 1.1} ${-s * 0.3}
             Q ${s * 1.3} ${-s * 0.1} ${s * 1.1} ${s * 0.2}
             Q ${s * 1.1} ${s * 0.5} ${s * 0.7} ${s * 0.5}
             L ${-s * 0.5} ${s * 0.5}
             Q ${-s * 0.9} ${s * 0.5} ${-s * 0.9} ${s * 0.2}
             Z
            `, );
        return p;
       }
       if (shape === "database") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.7);
        body.setAttribute("y", -size * 0.6);
        body.setAttribute("width", size * 1.4);
        body.setAttribute("height", size * 1.4);
        g.appendChild(body);
        const top = document.createElementNS(ns, "ellipse");
        top.setAttribute("cx", 0);
        top.setAttribute("cy", -size * 0.6);
        top.setAttribute("rx", size * 0.7);
        top.setAttribute("ry", size * 0.25);
        g.appendChild(top);
        const bottom = document.createElementNS(ns, "ellipse");
        bottom.setAttribute("cx", 0);
        bottom.setAttribute("cy", size * 0.8);
        bottom.setAttribute("rx", size * 0.7);
        bottom.setAttribute("ry", size * 0.25);
        g.appendChild(bottom);
        const mid1 = document.createElementNS(ns, "ellipse");
        mid1.setAttribute("cx", 0);
        mid1.setAttribute("cy", -size * 0.15);
        mid1.setAttribute("rx", size * 0.7);
        mid1.setAttribute("ry", size * 0.2);
        mid1.style.fill = "none";
        mid1.style.stroke = "#475569";
        mid1.style.strokeWidth = "2";
        g.appendChild(mid1);
        const mid2 = document.createElementNS(ns, "ellipse");
        mid2.setAttribute("cx", 0);
        mid2.setAttribute("cy", size * 0.35);
        mid2.setAttribute("rx", size * 0.7);
        mid2.setAttribute("ry", size * 0.2);
        mid2.style.fill = "none";
        mid2.style.stroke = "#475569";
        mid2.style.strokeWidth = "2";
        g.appendChild(mid2);
        return g;
       }
       if (shape === "printer") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.4);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size * 0.9);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const trayTop = document.createElementNS(ns, "rect");
        trayTop.setAttribute("x", -size * 0.7);
        trayTop.setAttribute("y", -size * 0.8);
        trayTop.setAttribute("width", size * 1.4);
        trayTop.setAttribute("height", size * 0.4);
        trayTop.setAttribute("rx", 2);
        trayTop.style.fill = "#1e293b";
        g.appendChild(trayTop);
        const trayOut = document.createElementNS(ns, "rect");
        trayOut.setAttribute("x", -size * 0.6);
        trayOut.setAttribute("y", size * 0.5);
        trayOut.setAttribute("width", size * 1.2);
        trayOut.setAttribute("height", size * 0.35);
        trayOut.setAttribute("rx", 2);
        g.appendChild(trayOut);
        const paper = document.createElementNS(ns, "rect");
        paper.setAttribute("x", -size * 0.5);
        paper.setAttribute("y", size * 0.3);
        paper.setAttribute("width", size * 1);
        paper.setAttribute("height", size * 0.5);
        paper.style.fill = "#e2e8f0";
        g.appendChild(paper);
        return g;
       }
       const c = document.createElementNS(ns, "circle");
       c.setAttribute("r", size);
       return c;
      }
      
      function createNodeShape(id, size) {
       const styles = resolveStylesForNode(id);
       if (styles.icon && styles.icon.library && styles.icon.name) {
        const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
        g.classList.add("node-circle");
        IconLibrary.getIcon(styles.icon.library, styles.icon.name).then(svgText => {
         if (svgText) {
          const parser = new DOMParser();
          const doc = parser.parseFromString(svgText, 'image/svg+xml');
          const svgEl = doc.querySelector('svg');
          if (svgEl) {
           svgEl.setAttribute('width', size * 1.2);
           svgEl.setAttribute('height', size * 1.2);
           svgEl.setAttribute('x', -size * 0.6);
           svgEl.setAttribute('y', -size * 0.6);
           if (styles.circleColor) {
            svgEl.style.fill = styles.circleColor;
           }
           g.innerHTML = svgEl.outerHTML;
          }
         }
        });
        return g;
       }
       const shapeType = (NODE_DATA[id] && NODE_DATA[id].shape) || "circle";
       const shapeEl = createShapeElement(shapeType, size);
       shapeEl.classList.add("node-circle");
       if (styles.circleColor) {
        shapeEl.style.stroke = styles.circleColor;
       }
	   if (styles.circleBorder) {
        shapeEl.style.stroke = styles.circleBorder;
       }
       return shapeEl;
      }
      
      function forgeTheLegend() {
       const container = document.getElementById("edge-legend");
       if (!container) return;
       container.innerHTML = "";
       const title = document.createElement("div");
       title.className = "legend-title";
       title.textContent = "Line Legend";
       container.appendChild(title);
       const closeBtn = document.createElement("button");
       closeBtn.type = "button";
       closeBtn.className = "legend-close-btn";
       closeBtn.textContent = "‚úï";
       closeBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        legendCollapsed = true;
        updateLegendVisibility();
       });
       container.appendChild(closeBtn);
       const colors = [...new Set(EDGE_DATA.list.map((e) => e.color).filter(Boolean))];
       if (colors.length === 0) {
        updateLegendVisibility();
        return;
       }
       colors.forEach((color) => {
         if (!EDGE_LEGEND[color]) {
          EDGE_LEGEND[color] = "you can edit me too";
         }
         const item = document.createElement("div");
         item.className = "legend-item";
         item.addEventListener("mousedown", (e) => e.stopPropagation());
         item.addEventListener("click", (e) => e.stopPropagation());
         const swatch = document.createElement("span");
         swatch.className = "legend-swatch";
         swatch.style.backgroundColor = color;
         swatch.style.cursor = "pointer";
         swatch.addEventListener("click", (e) => {
          e.stopPropagation();
          const edgeWithColor = EDGE_DATA.list.find(edge => edge.color === color);
          if (edgeWithColor) {
           selectTheConnection(edgeWithColor.id);
          }
         });
         let swatchTouchStart = null;
         let swatchTouchMoved = false;
         swatch.addEventListener("touchstart", (e) => {
          swatchTouchStart = Date.now();
          swatchTouchMoved = false;
         }, {
          passive: false
         });
         swatch.addEventListener("touchmove", (e) => {
          swatchTouchMoved = true;
         }, {
          passive: false
         });
         swatch.addEventListener("touchend", (e) => {
          if (swatchTouchStart && !swatchTouchMoved && Date.now() - swatchTouchStart < 400) {
           e.stopPropagation();
           e.preventDefault();
           const edgeWithColor = EDGE_DATA.list.find(edge => edge.color === color);
           if (edgeWithColor) {
            selectTheConnection(edgeWithColor.id);
           }
          }
          swatchTouchStart = null;
          swatchTouchMoved = false;
         }, {
          passive: false
         });
        const label = document.createElement("span");
        label.className = "legend-label";
        label.textContent = EDGE_LEGEND[color];
        if (isMobileDevice()) {
         label.style.cursor = "pointer";
         let labelTapStart = null;
         let labelTapMoved = false;
         label.addEventListener("touchstart", (e) => {
          labelTapStart = Date.now();
          labelTapMoved = false;
          e.stopPropagation();
         });
         label.addEventListener("touchmove", (e) => {
          labelTapMoved = true;
         });
         label.addEventListener("touchend", (e) => {
          if (labelTapStart && !labelTapMoved && Date.now() - labelTapStart < 400) {
           e.preventDefault();
           e.stopPropagation();
           const currentText = label.textContent;
           const newText = prompt("Edit legend label:", currentText);
           if (newText !== null && newText.trim()) {
            label.textContent = newText.trim();
            EDGE_LEGEND[color] = newText.trim();
            saveEdgeLegend();
           }
          }
          labelTapStart = null;
          labelTapMoved = false;
         });
        } else {
           label.contentEditable = true;
           label.addEventListener("focus", () => {
            label.classList.add("editing");
           });
           label.addEventListener("blur", () => {
            label.classList.remove("editing");
            const text = label.textContent.trim() || "you can edit me too";
            EDGE_LEGEND[color] = text;
            saveEdgeLegend();
           });
           label.addEventListener("keydown", (e) => {
            if (e.key === "Enter") {
             e.preventDefault();
             label.blur();
            }
           });
          }
          item.append(swatch, label); container.appendChild(item);
         }); updateLegendVisibility();
       }
      
       function deleteRectangle(rectId) {
      pushUndo("delete rectangle");
        RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== rectId);
        forgeTheTopology();
       }
      
       function updateRectangleDeleteButtons() {
        const deleteButtons = document.querySelectorAll('.rect-delete-btn');
        deleteButtons.forEach(btn => {
         btn.style.display = rectDrawMode ? 'block' : 'none';
        });
       }
      
      
       function forgeTheTopology() {
        if (!NODE_DATA || !EDGE_DATA) {
         console.warn("forgeTheTopology called before data initialized");
         return;
        }
        const svg = document.getElementById("map");
        svg.innerHTML = "";
        const ns = "http://www.w3.org/2000/svg";
        const defs = document.createElementNS(ns, "defs");
        const markerForward = document.createElementNS(ns, "marker");
        markerForward.id = "arrow-forward";
        markerForward.setAttribute("markerWidth", "10");
        markerForward.setAttribute("markerHeight", "10");
        markerForward.setAttribute("refX", "9");
        markerForward.setAttribute("refY", "3");
        markerForward.setAttribute("orient", "auto");
        markerForward.setAttribute("markerUnits", "strokeWidth");
        const pathForward = document.createElementNS(ns, "path");
        pathForward.setAttribute("d", "M0,0 L0,6 L9,3 z");
        pathForward.setAttribute("fill", "context-stroke");
        markerForward.appendChild(pathForward);
        defs.appendChild(markerForward);
        const markerBackward = document.createElementNS(ns, "marker");
        markerBackward.id = "arrow-backward";
        markerBackward.setAttribute("markerWidth", "10");
        markerBackward.setAttribute("markerHeight", "10");
        markerBackward.setAttribute("refX", "0");
        markerBackward.setAttribute("refY", "3");
        markerBackward.setAttribute("orient", "auto");
        markerBackward.setAttribute("markerUnits", "strokeWidth");
        const pathBackward = document.createElementNS(ns, "path");
        pathBackward.setAttribute("d", "M9,0 L9,6 L0,3 z");
        pathBackward.setAttribute("fill", "context-stroke");
        markerBackward.appendChild(pathBackward);
        defs.appendChild(markerBackward);
        svg.appendChild(defs);
        const boundary = document.createElementNS(ns, "rect");
        boundary.setAttribute("x", CANVAS_PADDING);
        boundary.setAttribute("y", CANVAS_PADDING);
        boundary.setAttribute("width", CANVAS_WIDTH - CANVAS_PADDING * 2);
        boundary.setAttribute("height", CANVAS_HEIGHT - CANVAS_PADDING * 2);
        boundary.setAttribute("fill", "none");
        boundary.setAttribute("stroke", "rgba(71, 85, 105, 0.3)");
        boundary.setAttribute("stroke-width", "2");
        boundary.setAttribute("stroke-dasharray", "10 5");
        boundary.setAttribute("rx", "8");
        svg.appendChild(boundary);
        
        if (currentView.mode === "rack" && currentView.rackId) {
         const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
         const rackGroup = document.createElementNS(ns, "g");
         rackGroup.id = "rack-visualization";       
         const rackFrame = document.createElementNS(ns, "rect");
         rackFrame.setAttribute("x", RACK_START_X - RACK_WIDTH / 2);
         rackFrame.setAttribute("y", RACK_START_Y);
         rackFrame.setAttribute("width", RACK_WIDTH);
         rackFrame.setAttribute("height", rackCapacity * rackUHeight);
      
         rackFrame.setAttribute("fill", "rgba(15, 23, 42, 0.3)");
         rackFrame.setAttribute("stroke", "var(--accent)");
         rackFrame.setAttribute("stroke-width", "3");
         rackFrame.setAttribute("rx", "4");
         rackGroup.appendChild(rackFrame);
         
         for (let u = 0; u <= rackCapacity; u++) {
          const y = RACK_START_Y + u * rackUHeight;
        
          const line = document.createElementNS(ns, "line");
          line.setAttribute("x1", RACK_START_X - RACK_WIDTH / 2);
          line.setAttribute("y1", y);
          line.setAttribute("x2", RACK_START_X + RACK_WIDTH / 2);
          line.setAttribute("y2", y);
          line.setAttribute("stroke", "rgba(71, 85, 105, 0.4)");
          line.setAttribute("stroke-width", u % 5 === 0 ? "2" : "1");
          line.setAttribute("stroke-dasharray", u % 5 === 0 ? "none" : "5,5");
          rackGroup.appendChild(line);
          
          if (u < rackCapacity) {
           const uNumber = rackCapacity - u;
           const text = document.createElementNS(ns, "text");
           text.setAttribute("x", RACK_START_X - RACK_WIDTH / 2 - 30);
           text.setAttribute("y", y + rackUHeight / 2);
           text.setAttribute("text-anchor", "middle");
           text.setAttribute("dominant-baseline", "middle");
           text.style.fill = "var(--accent)";
           text.style.fontSize = "14px";
           text.style.fontWeight = "bold";
           text.textContent = `U${uNumber}`;
           rackGroup.appendChild(text);
           
           const textRight = document.createElementNS(ns, "text");
           textRight.setAttribute("x", RACK_START_X + RACK_WIDTH / 2 + 30);
           textRight.setAttribute("y", y + rackUHeight / 2);
           textRight.setAttribute("text-anchor", "middle");
           textRight.setAttribute("dominant-baseline", "middle");
           textRight.style.fill = "var(--accent)";
           textRight.style.fontSize = "14px";
           textRight.style.fontWeight = "bold";
           textRight.textContent = `U${uNumber}`;
           rackGroup.appendChild(textRight);
          }
         }
         
         svg.appendChild(rackGroup);
        }
      
        const centerX = CANVAS_WIDTH / 2;
      
        if (RECT_DATA && RECT_DATA.list) {
         RECT_DATA.list.forEach((rect) => {
          if (currentView.mode === "rack") return;
          
          if (rect.style === "filled") {
           const g = document.createElementNS(ns, "g");
           g.classList.add("rect-group");
           g.dataset.rectId = rect.id;
           
           const rectEl = document.createElementNS(ns, "rect");
           rectEl.classList.add("rect-shape");
           rectEl.setAttribute("x", rect.x);
           rectEl.setAttribute("y", rect.y);
           rectEl.setAttribute("width", rect.width);
           rectEl.setAttribute("height", rect.height);
           rectEl.style.fill = rect.color;
           rectEl.style.fillOpacity = "0.3";
           rectEl.style.stroke = rect.color;
           rectEl.style.strokeWidth = "2";
           rectEl.style.cursor = "move";
           
           const deleteBtn = document.createElementNS(ns, "g");
           deleteBtn.classList.add("rect-delete-btn");
           deleteBtn.style.cursor = "pointer";
           deleteBtn.style.display = rectDrawMode ? "block" : "none";
           
           const deleteBg = document.createElementNS(ns, "circle");
           deleteBg.setAttribute("cx", rect.x + rect.width - 10);
           deleteBg.setAttribute("cy", rect.y + 10);
           deleteBg.setAttribute("r", 12);
           deleteBg.style.fill = "#f56565";
           deleteBg.style.stroke = "white";
           deleteBg.style.strokeWidth = "2";
           
           const deleteX = document.createElementNS(ns, "text");
           deleteX.setAttribute("x", rect.x + rect.width - 10);
           deleteX.setAttribute("y", rect.y + 10);
           deleteX.setAttribute("text-anchor", "middle");
           deleteX.setAttribute("dominant-baseline", "middle");
           deleteX.style.fill = "white";
           deleteX.style.fontSize = "16px";
           deleteX.style.fontWeight = "bold";
           deleteX.style.pointerEvents = "none";
           deleteX.textContent = "√ó";
           
           deleteBtn.appendChild(deleteBg);
           deleteBtn.appendChild(deleteX);
           
           deleteBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            e.preventDefault();
            deleteRectangle(rect.id);
           });
           
           deleteBtn.addEventListener("touchend", (e) => {
      e.stopPropagation();
           e.preventDefault();
           deleteRectangle(rect.id);
           });
      
           let isDragging = false;
           let dragStartX, dragStartY;
           let rectStartX, rectStartY;
           
           rectEl.addEventListener("mousedown", (e) => {
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            dragStartX = e.clientX;
            dragStartY = e.clientY;
            rectStartX = rect.x;
            rectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           });
           
           const moveHandler = (e) => {
            if (!isDragging || rectDrawMode) return;
            const svgEl = svg;
            const pt1 = svgEl.createSVGPoint();
            pt1.x = dragStartX;
            pt1.y = dragStartY;
            const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
            
            const pt2 = svgEl.createSVGPoint();
            pt2.x = e.clientX;
            pt2.y = e.clientY;
            const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
            
            const dx = svgP2.x - svgP1.x;
            const dy = svgP2.y - svgP1.y;
            
            rect.x = rectStartX + dx;
            rect.y = rectStartY + dy;
            
            forgeTheTopology();
           };
           
           const upHandler = () => {
            if (isDragging) {
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           };
           
           document.addEventListener("mousemove", moveHandler);
           document.addEventListener("mouseup", upHandler);
           
           let touchStartX, touchStartY;
           let touchRectStartX, touchRectStartY;
           
           rectEl.addEventListener("touchstart", (e) => {
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchRectStartX = rect.x;
            touchRectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           }, { passive: false });
           
           rectEl.addEventListener("touchmove", (e) => {
            if (!isDragging || rectDrawMode) return;
            if (!e.touches[0]) return;
            e.preventDefault();
            e.stopPropagation();
            
            const svgEl = svg;
            const pt1 = svgEl.createSVGPoint();
            pt1.x = touchStartX;
            pt1.y = touchStartY;
            const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
            
            const touch = e.touches[0];
            const pt2 = svgEl.createSVGPoint();
            pt2.x = touch.clientX;
            pt2.y = touch.clientY;
            const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
            
            const dx = svgP2.x - svgP1.x;
            const dy = svgP2.y - svgP1.y;
            
            rect.x = touchRectStartX + dx;
            rect.y = touchRectStartY + dy;
            
            forgeTheTopology();
           }, { passive: false });
           
           rectEl.addEventListener("touchend", (e) => {
            if (isDragging) {
             e.preventDefault();
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           }, { passive: false });
           
           g.appendChild(rectEl);
           g.appendChild(deleteBtn);
           svg.appendChild(g);
          }
         });
        }
        const centerY = CANVAS_HEIGHT / 2;
        let positions = {};
        
        Object.keys(NODE_DATA).forEach((id) => {
         if (currentView.mode === "rack") {
          const node = NODE_DATA[id];
          if (!node || node.assignedRack !== currentView.rackId) {
           return;
          }
         }
         
         positions[id] = savedPositions[id] || {
          x: centerX,
          y: centerY
         };
        });
        if (Object.keys(savedPositions).length === 0) {
         const nodeIds = Object.keys(NODE_DATA).filter(id => {
          if (currentView.mode === "rack") {
           const node = NODE_DATA[id];
           return node && node.assignedRack === currentView.rackId;
          }
          return true;
         });
         
         const baseY = centerY - 300;
         if (nodeIds.length > 0) {
          positions[nodeIds[0]] = {
           x: centerX,
           y: baseY
          };
          const remaining = nodeIds.slice(1);
          const radius = 350;
          const startAngle = Math.PI * 0.3;
          const endAngle = Math.PI * 0.7;
          remaining.forEach((id, i) => {
           const angle = startAngle + (endAngle - startAngle) * (i / Math.max(1, remaining.length - 1));
           positions[id] = {
            x: centerX + Math.cos(angle) * radius * (i % 2 === 0 ? 1 : 1.3),
            y: baseY + 200 + Math.sin(angle) * radius * 0.8 + i * 80,
           };
          });
         }
        }
        Object.keys(positions).forEach((id) => {
         let pos = savedPositions[id] || positions[id];
         const nodeSize = savedSizes[id] || 55;
         pos.x = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, pos.x), );
         pos.y = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, pos.y), );
         positions[id] = {
          x: pos.x,
          y: pos.y
         };
         savedPositions[id] = {
          x: pos.x,
          y: pos.y
         };
        });
        const edgePairCount = {};
        const edgePairIndex = {};
        EDGE_DATA.list.forEach((edge) => {
         if (edge.type === "custom") return;
         const key = [edge.from, edge.to].sort().join("||");
         edgePairCount[key] = (edgePairCount[key] || 0) + 1;
        });
        EDGE_DATA.list.forEach((edge) => {
         if (edge.type === "custom") return;
         const key = [edge.from, edge.to].sort().join("||");
         if (!edgePairIndex[key]) edgePairIndex[key] = 0;
         edge._pairIndex = edgePairIndex[key];
         edge._pairTotal = edgePairCount[key];
         edgePairIndex[key]++;
        });
        EDGE_DATA.list.forEach((edge) => {
         if (edge.type === "custom" && Array.isArray(edge.points) && edge.points.length >= 2) {
          const poly = document.createElementNS(ns, "polyline");
          poly.classList.add("edge");
          poly.dataset.edgeId = edge.id;
          poly.style.stroke = edge.color || "#475569";
          poly.style.strokeWidth = edge.width || 4;
          poly.setAttribute("fill", "none");
          const lineStyle = edge.lineStyle || "solid";
          if (lineStyle === "dashed") {
           poly.style.strokeDasharray = "10,5";
          } else if (lineStyle === "dotted") {
           poly.style.strokeDasharray = "2,4";
          } else {
           poly.style.strokeDasharray = "none";
          }
          const direction = edge.direction || "none";
          if (direction === "forward") {
           poly.setAttribute("marker-end", "url(#arrow-forward)");
          } else if (direction === "backward") {
           poly.setAttribute("marker-start", "url(#arrow-backward)");
          } else if (direction === "both") {
           poly.setAttribute("marker-start", "url(#arrow-backward)");
           poly.setAttribute("marker-end", "url(#arrow-forward)");
          }
          const ptsStr = edge.points.map((p) => `${p.x},${p.y}`).join(" ");
          poly.setAttribute("points", ptsStr);
          const polyHit = document.createElementNS(ns, "polyline");
          polyHit.setAttribute("points", ptsStr);
          polyHit.style.fill = "none";
          polyHit.style.stroke = "transparent";
          polyHit.style.strokeWidth = "20";
          polyHit.style.cursor = "pointer";
          polyHit.dataset.edgeId = edge.id;
          polyHit.addEventListener("click", (e) => {
           e.stopPropagation();
           selectTheConnection(edge.id);
          });
          let edgeTouchStart = null;
          let edgeTouchMoved = false;
          polyHit.addEventListener("touchstart", (e) => {
           edgeTouchStart = Date.now();
           edgeTouchMoved = false;
          }, {
           passive: false
          });
          polyHit.addEventListener("touchmove", (e) => {
           edgeTouchMoved = true;
          }, {
           passive: false
          });
          polyHit.addEventListener("touchend", (e) => {
           if (edgeTouchStart && !edgeTouchMoved && Date.now() - edgeTouchStart < 400) {
            e.stopPropagation();
            e.preventDefault();
            selectTheConnection(edge.id);
           }
           edgeTouchStart = null;
           edgeTouchMoved = false;
          }, {
           passive: false
          });
          poly.addEventListener("click", (e) => {
           e.stopPropagation();
           selectTheConnection(edge.id);
          });
          
          if (currentView.mode === "rack") {
           return;
          }
          
          svg.appendChild(poly);
          svg.appendChild(polyHit);
          return;
         }
         const p1 = positions[edge.from];
         const p2 = positions[edge.to];
         if (!p1 || !p2) return;
         const pairTotal = edge._pairTotal || 1;
         const pairIndex = edge._pairIndex || 0;
         const midX = (p1.x + p2.x) / 2;
         const midY = (p1.y + p2.y) / 2;
         const dx = p2.x - p1.x;
         const dy = p2.y - p1.y;
         const len = Math.sqrt(dx * dx + dy * dy) || 1;
         const perpX = -dy / len;
         const perpY = dx / len;
         let offsetAmount = 0;
         if (pairTotal > 1) {
          offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
         }
         const ctrlX = midX + perpX * offsetAmount;
         const ctrlY = midY + perpY * offsetAmount;
         const path = document.createElementNS(ns, "path");
         path.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
         path.setAttribute("fill", "none");
         path.classList.add("edge");
         if (edge.type === "backup") path.classList.add("backup");
         path.dataset.edgeId = edge.id;
         path.dataset.from = edge.from;
         path.dataset.to = edge.to;
         path.style.stroke = edge.color;
         path.style.strokeWidth = edge.width;
         const pathHit = document.createElementNS(ns, "path");
         pathHit.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
         pathHit.setAttribute("fill", "none");
         pathHit.style.stroke = "transparent";
         pathHit.style.strokeWidth = "20";
         pathHit.style.cursor = "pointer";
         pathHit.dataset.edgeId = edge.id;
         pathHit.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         let pathTouchStart = null;
         let pathTouchMoved = false;
         pathHit.addEventListener("touchstart", (e) => {
          pathTouchStart = Date.now();
          pathTouchMoved = false;
         }, {
          passive: false
         });
         pathHit.addEventListener("touchmove", (e) => {
          pathTouchMoved = true;
         }, {
          passive: false
         });
         pathHit.addEventListener("touchend", (e) => {
          if (pathTouchStart && !pathTouchMoved && Date.now() - pathTouchStart < 400) {
           e.stopPropagation();
           e.preventDefault();
           selectTheConnection(edge.id);
          }
          pathTouchStart = null;
          pathTouchMoved = false;
         }, {
          passive: false
         });
         path.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         
         if (currentView.mode === "rack") {
          const fromNode = NODE_DATA[edge.from];
          const toNode = NODE_DATA[edge.to];
          if (!fromNode || !toNode || 
              fromNode.assignedRack !== currentView.rackId || 
              toNode.assignedRack !== currentView.rackId) {
           return;
          }
         }
         
         svg.appendChild(path);
         svg.appendChild(pathHit);
         
         if (edge.fromPort || edge.toPort) {
          const ns = "http://www.w3.org/2000/svg";
          
          if (edge.fromPort) {
           const fromLabel = document.createElementNS(ns, "text");
           fromLabel.textContent = edge.fromPort;
           fromLabel.setAttribute("x", p1.x);
           fromLabel.setAttribute("y", p1.y - 10);
           fromLabel.setAttribute("text-anchor", "middle");
           fromLabel.style.fill = "#94a3b8";
           fromLabel.style.fontSize = "12px";
           fromLabel.style.fontWeight = "600";
           fromLabel.style.pointerEvents = "none";
           fromLabel.classList.add("port-label");
           svg.appendChild(fromLabel);
          }
      
          if (edge.toPort) {
           const toLabel = document.createElementNS(ns, "text");
           toLabel.textContent = edge.toPort;
           toLabel.setAttribute("x", p2.x);
           toLabel.setAttribute("y", p2.y - 10);
           toLabel.setAttribute("text-anchor", "middle");
           toLabel.style.fill = "#94a3b8";
           toLabel.style.fontSize = "12px";
           toLabel.style.fontWeight = "600";
           toLabel.style.pointerEvents = "none";
           toLabel.classList.add("port-label");
           svg.appendChild(toLabel);
          }
         }
        });
        Object.entries(positions).forEach(([id, pos]) => {
         const node = NODE_DATA[id];
         if (!node) return;
         
         if (currentView.mode === "rack") {
          if (node.assignedRack !== currentView.rackId) return;
          
         const rackUnit = parseInt(node.rackUnit) || 1;
      const uHeight = parseInt(node.uHeight) || 1;
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      pos.x = RACK_START_X;
      pos.y = RACK_START_Y + (rackCapacity - rackUnit - uHeight + 1) * rackUHeight + (uHeight * rackUHeight) / 2;
         } else {
          if (node.assignedRack) return;
         }
         
         const g = document.createElementNS("http://www.w3.org/2000/svg", "g", );
         g.classList.add("node-group");
         g.dataset.nodeId = id;
         g.setAttribute("transform", `translate(${pos.x},${pos.y})`);
         let r = savedSizes[id] || 55;
         if (!savedSizes[id]) {
          if (window.innerWidth <= 380) r = 120;
          else if (window.innerWidth <= 768) r = 140;
          else if (window.innerWidth <= 1024) r = 70;
         }
         const styles = resolveStylesForNode(id);
         const ns = "http://www.w3.org/2000/svg";
         const hitArea = document.createElementNS(ns, "circle");
         hitArea.setAttribute("r", r * 1.5);
         hitArea.style.fill = "transparent";
         hitArea.style.stroke = "none";
         hitArea.style.cursor = "grab";
         hitArea.classList.add("node-hit-area");
         const shapeEl = createNodeShape(id, r);
         const titleOffsetX = styles.titleOffsetX || 0;
         const titleOffsetY = styles.titleOffsetY || 0;
         const subOffsetX = styles.subOffsetX || 0;
         const subOffsetY = styles.subOffsetY || 0;
         const label = document.createElementNS("http://www.w3.org/2000/svg", "text", );
         label.classList.add("node-label");
         label.setAttribute("x", titleOffsetX);
         label.setAttribute("y", -r * 0.28 + titleOffsetY);
         const labelFontSize = styles.titleSize || r * 0.33;
         label.style.fontSize = labelFontSize + "px";
         label.textContent = NODE_DATA[id].name;
         if (styles.titleColor) label.style.fill = styles.titleColor;
         if (styles.titleFont) label.style.fontFamily = styles.titleFont;
         label.style.pointerEvents = "none";
         const sub = document.createElementNS("http://www.w3.org/2000/svg", "text", );
         sub.classList.add("node-sub");
         sub.setAttribute("x", subOffsetX);
         sub.setAttribute("y", r * 0.4 + subOffsetY);
         const subFontSize = styles.subSize || r * 0.24;
         sub.style.fontSize = subFontSize + "px";
         sub.textContent = NODE_DATA[id].ip;
         if (styles.subColor) sub.style.fill = styles.subColor;
         if (styles.subFont) sub.style.fontFamily = styles.subFont;
         sub.style.pointerEvents = "none";
         g.append(hitArea, shapeEl, label, sub);
         
         if (NODE_DATA[id]?.locked) {
           const lockIndicator = document.createElementNS(ns, "text");
           lockIndicator.textContent = "üîí";
           lockIndicator.setAttribute("x", r * 0.7);
           lockIndicator.setAttribute("y", -r * 0.7);
           lockIndicator.style.fontSize = (r * 0.3) + "px";
           lockIndicator.style.pointerEvents = "none";
           lockIndicator.classList.add("lock-indicator");
           g.appendChild(lockIndicator);
         }
         
         if (NODE_DATA[id]?.groupId) {
           const groupIndicator = document.createElementNS(ns, "circle");
           groupIndicator.setAttribute("r", r + 4);
           groupIndicator.style.fill = "none";
           groupIndicator.style.stroke = "#4fd1c5";
           groupIndicator.style.strokeWidth = "3";
           groupIndicator.style.strokeDasharray = "5,5";
           groupIndicator.style.pointerEvents = "none";
           groupIndicator.classList.add("group-indicator");
           
           g.insertBefore(groupIndicator, g.firstChild);
         }
         
         let isDragging = false;
         let startX, startY;
         let initialPositions = {};
         let longPressTimer = null;
         let longPressTriggered = false;
         
         g.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          e.stopPropagation();
          
          if (selectedNodes.has(id)) {
           selectedNodes.delete(id);
          } else {
           selectedNodes.add(id);
          }
          updateNodeSelection();
          return false;
         });
         
        g.addEventListener("touchstart", (e) => {
         if (NODE_DATA[id].isRack) {
          longPressTimer = setTimeout(() => {
           longPressTriggered = true;
           if (navigator.vibrate) {
            navigator.vibrate(100);
           }
           enterRack(id);
          }, 500);
         }
        }, { passive: true });
        
        g.addEventListener("dblclick", (e) => {
         e.preventDefault();
         e.stopPropagation();
         if (NODE_DATA[id].isRack) {
          enterRack(id);
         }
        });
        
        let lastTapTime = 0;
        let lastTapNode = null;
        
        g.addEventListener("touchend", (e) => {
         const currentTime = new Date().getTime();
         const tapLength = currentTime - lastTapTime;
         
         if (tapLength < 300 && tapLength > 0 && lastTapNode === id) {
          e.preventDefault();
          e.stopPropagation();
          
          if (selectedNodes.has(id)) {
           selectedNodes.delete(id);
          } else {
           selectedNodes.add(id);
          }
          updateNodeSelection();
          
          if (navigator.vibrate) {
           navigator.vibrate(50);
          }
          
          lastTapTime = 0;
          lastTapNode = null;
         } else {
          lastTapTime = currentTime;
          lastTapNode = id;
         }
        });
         
         g.addEventListener("touchend", (e) => {
          if (longPressTimer) {
           clearTimeout(longPressTimer);
           longPressTimer = null;
          }
          if (longPressTriggered) {
           e.preventDefault();
           e.stopPropagation();
           longPressTriggered = false;
          }
         });
         
         g.addEventListener("touchmove", (e) => {
          if (longPressTimer) {
           clearTimeout(longPressTimer);
           longPressTimer = null;
           longPressTriggered = false;
          }
         });
         
         g.addEventListener("mousedown", (e) => {
          if (e.button === 2) {
           return;
          }
          
          if (NODE_DATA[id]?.locked) {
           return;
          }
          
          e.preventDefault();
          isDragging = true;
          const svgEl = document.getElementById("map");
          const pt = svgEl.createSVGPoint();
          pt.x = e.clientX;
          pt.y = e.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          startX = svgP.x;
          startY = svgP.y;
          
          let nodesToCollect = [];
          if (selectedNodes.has(id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) {
      initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      }
      });
      } else {
      initialPositions = { [id]: { x: pos.x, y: pos.y } };
      }
          
          const groupIds = new Set();
          nodesToCollect.forEach(nodeId => {
           const groupId = NODE_DATA[nodeId]?.groupId;
           if (groupId) {
             groupIds.add(groupId);
           }
          });
          
          if (groupIds.size > 0) {
           Object.keys(NODE_DATA).forEach(nodeId => {
             const nodeGroupId = NODE_DATA[nodeId]?.groupId;
             if (nodeGroupId && groupIds.has(nodeGroupId)) {
               if (!nodesToCollect.includes(nodeId)) {
                 nodesToCollect.push(nodeId);
               }
             }
           });
          }
          
          nodesToCollect = nodesToCollect.filter(nodeId => !NODE_DATA[nodeId]?.locked);
          
          if (nodesToCollect.length === 0) {
           return;
          }
          
          initialPositions = {};
          nodesToCollect.forEach(nodeId => {
           const nodePos = savedPositions[nodeId];
           if (nodePos) {
            initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
           }
          });
          
          g.style.cursor = "grabbing";
          hitArea.style.cursor = "grabbing";
          e.stopPropagation();
         });
         const handleMouseMove = (e) => {
          if (!isDragging) return;
          e.preventDefault();
          const svgEl = document.getElementById("map");
          const pt = svgEl.createSVGPoint();
          pt.x = e.clientX;
          pt.y = e.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          const dx = svgP.x - startX;
          const dy = svgP.y - startY;
          
          const nodesToMove = selectedNodes.has(id) ? Array.from(selectedNodes) : [id];
          nodesToMove.forEach(nodeId => {
           if (!initialPositions[nodeId]) return;
           const initialPos = initialPositions[nodeId];
           let newX = initialPos.x + dx;
           let newY = initialPos.y + dy;
           const nodeSize = savedSizes[nodeId] || 55;
           newX = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, newX), );
           newY = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, newY), );
           
           savedPositions[nodeId] = { x: newX, y: newY };
           positions[nodeId] = { x: newX, y: newY };
           
           if (nodeId === id) {
            pos.x = newX;
            pos.y = newY;
           }
           
           const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
           if (nodeGroup) {
            nodeGroup.setAttribute("transform", `translate(${newX},${newY})`);
           }
          });
          
          updateMinimap();
          document.querySelectorAll(".edge").forEach((edgeEl) => {
           const fromId = edgeEl.dataset.from;
           const toId = edgeEl.dataset.to;
           if (nodesToMove.includes(fromId) || nodesToMove.includes(toId)) {
            const p1 = savedPositions[fromId] || positions[fromId] || {
             x: 600,
             y: 350
            };
            const p2 = savedPositions[toId] || positions[toId] || {
             x: 600,
             y: 350
            };
            if (edgeEl.tagName === "line") {
             edgeEl.setAttribute("x1", p1.x);
             edgeEl.setAttribute("y1", p1.y);
             edgeEl.setAttribute("x2", p2.x);
             edgeEl.setAttribute("y2", p2.y);
            } else if (edgeEl.tagName === "path") {
             const edgeId = edgeEl.dataset.edgeId;
             const edge = EDGE_DATA.list.find(
              (e) => e.id === edgeId, );
             if (edge) {
              const pairTotal = edge._pairTotal || 1;
              const pairIndex = edge._pairIndex || 0;
              const midX = (p1.x + p2.x) / 2;
              const midY = (p1.y + p2.y) / 2;
              const dx = p2.x - p1.x;
              const dy = p2.y - p1.y;
              const len = Math.sqrt(dx * dx + dy * dy) || 1;
              const perpX = -dy / len;
              const perpY = dx / len;
              let offsetAmount = 0;
              if (pairTotal > 1) {
               offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
              }
              const ctrlX = midX + perpX * offsetAmount;
              const ctrlY = midY + perpY * offsetAmount;
              edgeEl.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
             }
            }
           }
          });
         };
      const handleMouseUp = () => {
      if (isDragging) {
      pushUndo("move nodes");
      isDragging = false;
      g.style.cursor = "grab";
      hitArea.style.cursor = "grab";
      if (currentView.mode === "rack" && NODE_DATA[id]?.assignedRack === currentView.rackId) {
      const draggedY = savedPositions[id]?.y || pos.y;
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      let newUnit = rackCapacity - Math.round((draggedY - RACK_START_Y) / rackUHeight);
      newUnit = Math.max(1, Math.min(newUnit, rackCapacity));
      NODE_DATA[id].rackUnit = newUnit;
      forgeTheTopology();
      claimTheImmortal(id);
      }
      }
      };
         document.addEventListener("mousemove", handleMouseMove);
         document.addEventListener("mouseup", handleMouseUp);
         let touchStartTime = 0;
         let touchStartX = 0;
         let touchStartY = 0;
         let touchMoved = false;
       g.addEventListener("touchstart",
         (e) => {
          if (NODE_DATA[id]?.locked) {
           return;
          }
          
          e.preventDefault();
          touchStartTime = Date.now();
          touchMoved = false;
          const svgEl = document.getElementById("map");
          const pt = svgEl.createSVGPoint();
          const touch = e.touches[0];
          pt.x = touch.clientX;
          pt.y = touch.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          touchStartX = svgP.x;
          touchStartY = svgP.y;
          startX = svgP.x;
          startY = svgP.y;
          
          let nodesToCollect = [];
          if (selectedNodes.has(id)) {
           nodesToCollect = Array.from(selectedNodes);
          } else {
           nodesToCollect = [id];
          }
          
          const groupIds = new Set();
          nodesToCollect.forEach(nodeId => {
           const groupId = NODE_DATA[nodeId]?.groupId;
           if (groupId) {
             groupIds.add(groupId);
           }
          });
          
          if (groupIds.size > 0) {
           Object.keys(NODE_DATA).forEach(nodeId => {
             const nodeGroupId = NODE_DATA[nodeId]?.groupId;
             if (nodeGroupId && groupIds.has(nodeGroupId)) {
               if (!nodesToCollect.includes(nodeId)) {
                 nodesToCollect.push(nodeId);
               }
             }
           });
          }
          
          nodesToCollect = nodesToCollect.filter(nodeId => !NODE_DATA[nodeId]?.locked);
          
          if (nodesToCollect.length === 0) {
           return;
          }
          
          initialPositions = {};
          nodesToCollect.forEach(nodeId => {
           const nodePos = savedPositions[nodeId];
           if (nodePos) {
            initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
           }
          });
          
          e.stopPropagation();
         }, {
          passive: false
         }, );
         g.addEventListener("touchmove", (e) => {
         e.preventDefault();
         const svgEl = document.getElementById("map");
         const pt = svgEl.createSVGPoint();
         const touch = e.touches[0];
         pt.x = touch.clientX;
         pt.y = touch.clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
         const dx = Math.abs(svgP.x - touchStartX);
         const dy = Math.abs(svgP.y - touchStartY);
         if (dx > (isMobileDevice() ? 4 : 10) || dy > (isMobileDevice() ? 4 : 10)) {
      touchMoved = true;
      isDragging = true;
      }
         if (!isDragging) return;
         
         const deltaX = svgP.x - startX;
         const deltaY = svgP.y - startY;
         
         const nodesToMove = selectedNodes.has(id) ? Array.from(selectedNodes) : [id];
         nodesToMove.forEach(nodeId => {
          if (!initialPositions[nodeId]) return;
          const initialPos = initialPositions[nodeId];
          let newX = initialPos.x + deltaX;
          let newY = initialPos.y + deltaY;
          const nodeSize = savedSizes[nodeId] || 55;
          newX = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, newX), );
          newY = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, newY), );
          
          savedPositions[nodeId] = { x: newX, y: newY };
          positions[nodeId] = { x: newX, y: newY };
          
          if (nodeId === id) {
           pos.x = newX;
           pos.y = newY;
          }
          
          const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
          if (nodeGroup) {
           nodeGroup.setAttribute("transform", `translate(${newX},${newY})`);
          }
         });
         
         updateMinimap();
         document.querySelectorAll(".edge").forEach((edgeEl) => {
          const fromId = edgeEl.dataset.from;
          const toId = edgeEl.dataset.to;
          if (nodesToMove.includes(fromId) || nodesToMove.includes(toId)) {
            const p1 = savedPositions[fromId] || positions[fromId] || {
             x: 600,
             y: 350
            };
            const p2 = savedPositions[toId] || positions[toId] || {
             x: 600,
             y: 350
            };
            if (edgeEl.tagName === "line") {
             edgeEl.setAttribute("x1", p1.x);
             edgeEl.setAttribute("y1", p1.y);
             edgeEl.setAttribute("x2", p2.x);
             edgeEl.setAttribute("y2", p2.y);
            } else if (edgeEl.tagName === "path") {
             const edgeId = edgeEl.dataset.edgeId;
             const edge = EDGE_DATA.list.find(
              (e) => e.id === edgeId, );
             if (edge) {
              const pairTotal = edge._pairTotal || 1;
              const pairIndex = edge._pairIndex || 0;
              const midX = (p1.x + p2.x) / 2;
              const midY = (p1.y + p2.y) / 2;
              const dx = p2.x - p1.x;
              const dy = p2.y - p1.y;
              const len = Math.sqrt(dx * dx + dy * dy) || 1;
              const perpX = -dy / len;
              const perpY = dx / len;
              let offsetAmount = 0;
              if (pairTotal > 1) {
               offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
              }
              const ctrlX = midX + perpX * offsetAmount;
              const ctrlY = midY + perpY * offsetAmount;
              edgeEl.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
             }
            }
           }
          });
         }, {
          passive: false
         });
      g.addEventListener("touchend", (e) => {
      const touchDuration = Date.now() - touchStartTime;
      if (!touchMoved && touchDuration < 400) {
      claimTheImmortal(id);
      }
      if (isDragging) {
      const draggedY = pos.y;
      isDragging = false;
      savedPositions[id] = {
      x: pos.x,
      y: pos.y
      };
      if (currentView.mode === "rack" && NODE_DATA[id]?.assignedRack === currentView.rackId) {
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      let newUnit = rackCapacity - Math.round((draggedY - RACK_START_Y) / rackUHeight);
      newUnit = Math.max(1, Math.min(newUnit, rackCapacity));
      NODE_DATA[id].rackUnit = newUnit;
      forgeTheTopology();
      claimTheImmortal(id);
      }
      }
      touchMoved = false;
      });
         g.style.cursor = "grab";
         g.addEventListener("click", (e) => {
          if (!isDragging) {
           claimTheImmortal(id);
          }
         });
         svg.appendChild(g);
        });
        
        if (RECT_DATA && RECT_DATA.list) {
         RECT_DATA.list.forEach((rect) => {
          if (rect.style === "outlined") {
           const g = document.createElementNS(ns, "g");
           g.classList.add("rect-group");
           g.dataset.rectId = rect.id;
           
           const rectEl = document.createElementNS(ns, "rect");
           rectEl.classList.add("rect-shape");
           rectEl.setAttribute("x", rect.x);
           rectEl.setAttribute("y", rect.y);
           rectEl.setAttribute("width", rect.width);
           rectEl.setAttribute("height", rect.height);
           rectEl.style.fill = "none";
           rectEl.style.stroke = rect.color;
           rectEl.style.strokeWidth = "3";
           rectEl.style.cursor = "move";
           
           const deleteBtn = document.createElementNS(ns, "g");
           deleteBtn.classList.add("rect-delete-btn");
           deleteBtn.style.cursor = "pointer";
           deleteBtn.style.display = rectDrawMode ? "block" : "none";
           
           const deleteBg = document.createElementNS(ns, "circle");
           deleteBg.setAttribute("cx", rect.x + rect.width - 10);
           deleteBg.setAttribute("cy", rect.y + 10);
           deleteBg.setAttribute("r", 12);
           deleteBg.style.fill = "#f56565";
           deleteBg.style.stroke = "white";
           deleteBg.style.strokeWidth = "2";
           
           const deleteX = document.createElementNS(ns, "text");
           deleteX.setAttribute("x", rect.x + rect.width - 10);
           deleteX.setAttribute("y", rect.y + 10);
           deleteX.setAttribute("text-anchor", "middle");
           deleteX.setAttribute("dominant-baseline", "middle");
           deleteX.style.fill = "white";
           deleteX.style.fontSize = "16px";
           deleteX.style.fontWeight = "bold";
           deleteX.style.pointerEvents = "none";
           deleteX.textContent = "√ó";
           
           deleteBtn.appendChild(deleteBg);
           deleteBtn.appendChild(deleteX);
           
           deleteBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            e.preventDefault();
            deleteRectangle(rect.id);
           });
           
           let isDragging = false;
           let dragStartX, dragStartY;
           let rectStartX, rectStartY;
           
           rectEl.addEventListener("mousedown", (e) => {
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            dragStartX = e.clientX;
            dragStartY = e.clientY;
            rectStartX = rect.x;
            rectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           });
           
           const moveHandler = (e) => {
            if (!isDragging || rectDrawMode) return;
            const svgEl = svg;
            const pt1 = svgEl.createSVGPoint();
            pt1.x = dragStartX;
            pt1.y = dragStartY;
            const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
            
            const pt2 = svgEl.createSVGPoint();
            pt2.x = e.clientX;
            pt2.y = e.clientY;
            const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
            
            const dx = svgP2.x - svgP1.x;
            const dy = svgP2.y - svgP1.y;
            
            rect.x = rectStartX + dx;
            rect.y = rectStartY + dy;
            
            forgeTheTopology();
           };
           
           const upHandler = () => {
            if (isDragging) {
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           };
           
           document.addEventListener("mousemove", moveHandler);
           document.addEventListener("mouseup", upHandler);
           
           let touchStartX, touchStartY;
           let touchRectStartX, touchRectStartY;
           
           rectEl.addEventListener("touchstart", (e) => {
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchRectStartX = rect.x;
            touchRectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           }, { passive: false });
           
           rectEl.addEventListener("touchmove", (e) => {
            if (!isDragging || rectDrawMode) return;
            if (!e.touches[0]) return;
            e.preventDefault();
            e.stopPropagation();
            
            const svgEl = svg;
            const pt1 = svgEl.createSVGPoint();
            pt1.x = touchStartX;
            pt1.y = touchStartY;
            const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
            
            const touch = e.touches[0];
            const pt2 = svgEl.createSVGPoint();
            pt2.x = touch.clientX;
            pt2.y = touch.clientY;
            const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
            
            const dx = svgP2.x - svgP1.x;
            const dy = svgP2.y - svgP1.y;
            
            rect.x = touchRectStartX + dx;
            rect.y = touchRectStartY + dy;
            
            forgeTheTopology();
           }, { passive: false });
           
           rectEl.addEventListener("touchend", (e) => {
            if (isDragging) {
             e.preventDefault();
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           }, { passive: false });
           
           g.appendChild(rectEl);
           g.appendChild(deleteBtn);
           svg.appendChild(g);
          }
         });
        }
        
        if (TEXT_DATA && TEXT_DATA.list) {
         TEXT_DATA.list.forEach((textItem) => {
          if (currentView.mode === "rack") return;
          
          const g = document.createElementNS(ns, "g");
          g.classList.add("text-group");
          g.dataset.textId = textItem.id;
          
          if (textItem.bgEnabled) {
           const bgRect = document.createElementNS(ns, "rect");
           bgRect.classList.add("text-bg");
      
           bgRect.setAttribute("x", textItem.x - 5);
           bgRect.setAttribute("y", textItem.y - textItem.fontSize - 2);
           bgRect.setAttribute("width", 100);
           bgRect.setAttribute("height", textItem.fontSize + 10);
           bgRect.style.fill = textItem.bgColor;
           bgRect.style.opacity = "0.7";
           bgRect.style.rx = "4";
           g.appendChild(bgRect);
          }
          
          const textEl = document.createElementNS(ns, "text");
          textEl.classList.add("text-element");
          textEl.setAttribute("x", textItem.x);
          textEl.setAttribute("y", textItem.y);
          textEl.style.fill = textItem.color;
          textEl.style.fontSize = textItem.fontSize + "px";
          textEl.style.fontWeight = textItem.fontWeight;
          textEl.style.fontStyle = textItem.fontStyle;
          textEl.style.textAnchor = textItem.textAlign;
          textEl.style.textDecoration = textItem.textDecoration;
          textEl.style.opacity = textItem.opacity;
          textEl.style.cursor = "move";
          textEl.style.userSelect = "none";
          textEl.setAttribute("dominant-baseline", "middle");
          
          const lines = textItem.content.split('\n');
          if (lines.length === 1) {
           textEl.textContent = textItem.content;
          } else {
           lines.forEach((line, i) => {
            const tspan = document.createElementNS(ns, "tspan");
            tspan.textContent = line;
            tspan.setAttribute("x", textItem.x);
            tspan.setAttribute("dy", i === 0 ? 0 : textItem.fontSize * 1.2);
            textEl.appendChild(tspan);
           });
          }
          
          g.appendChild(textEl);
          
          if (textItem.bgEnabled) {
           setTimeout(() => {
            try {
             const bbox = textEl.getBBox();
             const bgRect = g.querySelector('.text-bg');
             if (bgRect && bbox) {
              bgRect.setAttribute("x", bbox.x - 5);
              bgRect.setAttribute("y", bbox.y - 2);
              bgRect.setAttribute("width", bbox.width + 10);
              bgRect.setAttribute("height", bbox.height + 4);
             }
            } catch (e) {
            }
           }, 0);
          }
          
          const deleteBtn = document.createElementNS(ns, "g");
          deleteBtn.classList.add("text-delete-btn");
          deleteBtn.style.cursor = "pointer";
          deleteBtn.style.display = textDrawMode ? "block" : "none";
          
          const deleteBg = document.createElementNS(ns, "circle");
          deleteBg.setAttribute("cx", textItem.x + 20);
          deleteBg.setAttribute("cy", textItem.y - textItem.fontSize);
          deleteBg.setAttribute("r", 12);
          deleteBg.style.fill = "#f56565";
          deleteBg.style.stroke = "white";
          deleteBg.style.strokeWidth = "2";
          
          const deleteX = document.createElementNS(ns, "text");
          deleteX.setAttribute("x", textItem.x + 20);
          deleteX.setAttribute("y", textItem.y - textItem.fontSize);
          deleteX.setAttribute("text-anchor", "middle");
          deleteX.setAttribute("dominant-baseline", "middle");
          deleteX.style.fill = "white";
          deleteX.style.fontSize = "16px";
          deleteX.style.fontWeight = "bold";
          deleteX.style.pointerEvents = "none";
          deleteX.textContent = "√ó";
          
          deleteBtn.appendChild(deleteBg);
          deleteBtn.appendChild(deleteX);
          
          deleteBtn.addEventListener("click", (e) => {
           e.stopPropagation();
           e.preventDefault();
           deleteText(textItem.id);
          });
          
          let isDragging = false;
          let dragStartX, dragStartY;
          let textStartX, textStartY;
          
          textEl.addEventListener("mousedown", (e) => {
           if (textDrawMode) return;
           e.preventDefault();
           e.stopPropagation();
           isDragging = true;
           dragStartX = e.clientX;
           dragStartY = e.clientY;
           textStartX = textItem.x;
           textStartY = textItem.y;
           textEl.style.cursor = "grabbing";
           
           showTextPanel(textItem.id);
          });
          
          const moveHandler = (e) => {
           if (!isDragging || textDrawMode) return;
           const svgEl = svg;
           const pt1 = svgEl.createSVGPoint();
           pt1.x = dragStartX;
           pt1.y = dragStartY;
           const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
           
           const pt2 = svgEl.createSVGPoint();
           pt2.x = e.clientX;
           pt2.y = e.clientY;
           const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
           
           const dx = svgP2.x - svgP1.x;
           const dy = svgP2.y - svgP1.y;
           
           textItem.x = textStartX + dx;
           textItem.y = textStartY + dy;
           
           forgeTheTopology();
          };
          
          const upHandler = () => {
           if (isDragging) {
            isDragging = false;
            textEl.style.cursor = "move";
           }
          };
          
          document.addEventListener("mousemove", moveHandler);
          document.addEventListener("mouseup", upHandler);
          
          let touchStartX = 0, touchStartY = 0;
          let textTouchStartX = 0, textTouchStartY = 0;
          
          textEl.addEventListener("touchstart", (e) => {
           if (textDrawMode) return;
           if (e.touches.length !== 1) return;
           
           e.preventDefault();
           e.stopPropagation();
           const touch = e.touches[0];
           isDragging = true;
           touchStartX = touch.clientX;
           touchStartY = touch.clientY;
           textTouchStartX = textItem.x;
           textTouchStartY = textItem.y;
           
           showTextPanel(textItem.id);
          }, { passive: false });
          
          textEl.addEventListener("touchmove", (e) => {
           if (!isDragging || textDrawMode) return;
           if (e.touches.length !== 1) return;
           
           e.preventDefault();
           const touch = e.touches[0];
           const svgEl = svg;
           
           const pt1 = svgEl.createSVGPoint();
           pt1.x = touchStartX;
           pt1.y = touchStartY;
           const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
           
           const pt2 = svgEl.createSVGPoint();
           pt2.x = touch.clientX;
           pt2.y = touch.clientY;
           const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
           
           const dx = svgP2.x - svgP1.x;
           const dy = svgP2.y - svgP1.y;
           
           textItem.x = textTouchStartX + dx;
           textItem.y = textTouchStartY + dy;
           
           forgeTheTopology();
          }, { passive: false });
          
          textEl.addEventListener("touchend", () => {
           if (isDragging) {
            isDragging = false;
           }
          }, { passive: false });
          
          g.appendChild(deleteBtn);
          svg.appendChild(g);
         });
        }
        
        
        Object.keys(NODE_DATA).forEach(nodeId => {
         updatePingIndicator(nodeId);
        });
        
        forgeTheLegend();
        updateMinimap();
       }
      
       function showEditModal(title, currentValue, onSave) {
        const modal = document.getElementById("edit-modal");
        const input = document.getElementById("modal-input");
        const titleEl = document.getElementById("modal-title");
        const saveBtn = document.getElementById("modal-save");
        const cancelBtn = document.getElementById("modal-cancel");
        titleEl.textContent = title;
        input.value = currentValue;
        modal.classList.add("active");
        input.focus();
        input.select();
        const handleSave = () => {
         if (input.value.trim()) {
          onSave(input.value.trim());
         }
         modal.classList.remove("active");
         saveBtn.removeEventListener("click", handleSave);
         cancelBtn.removeEventListener("click", handleCancel);
         input.removeEventListener("keypress", handleEnter);
        };
        const handleCancel = () => {
         modal.classList.remove("active");
         saveBtn.removeEventListener("click", handleSave);
         cancelBtn.removeEventListener("click", handleCancel);
         input.removeEventListener("keypress", handleEnter);
        };
        const handleEnter = (e) => {
         if (e.key === "Enter") handleSave();
        };
        saveBtn.addEventListener("click", handleSave);
        cancelBtn.addEventListener("click", handleCancel);
        input.addEventListener("keypress", handleEnter);
        modal.addEventListener("click", function bgHandler(e) {
         if (e.target === modal) {
          handleCancel();
          modal.removeEventListener("click", bgHandler);
         }
        });
       }
      
       function challengeTheImmortal(message, onConfirm) {
        const modal = document.getElementById("confirm-modal");
        const messageEl = document.getElementById("confirm-message");
        const deleteBtn = document.getElementById("confirm-delete");
        const cancelBtn = document.getElementById("confirm-cancel");
        messageEl.textContent = message;
        modal.classList.add("active");
        const handleConfirm = () => {
         onConfirm();
         modal.classList.remove("active");
         deleteBtn.removeEventListener("click", handleConfirm);
         cancelBtn.removeEventListener("click", handleCancel);
        };
        const handleCancel = () => {
         modal.classList.remove("active");
         deleteBtn.removeEventListener("click", handleConfirm);
         cancelBtn.removeEventListener("click", handleCancel);
        };
        deleteBtn.addEventListener("click", handleConfirm);
        cancelBtn.addEventListener("click", handleCancel);
        modal.addEventListener("click", function bgHandler(e) {
         if (e.target === modal) {
          handleCancel();
          modal.removeEventListener("click", bgHandler);
         }
        });
       }
       const pageTitleEl = document.getElementById("page-title");
       if (pageTitleEl) {
        pageTitleEl.addEventListener("click", () => {
         showEditModal("Edit Title", PAGE_STATE.title || DEFAULT_PAGE_STATE.title,
          (newTitle) => {
           PAGE_STATE.title = newTitle;
           wieldThePower();
          }, );
        });
       }
      
       function editNodeName(id) {
        if (!NODE_DATA[id]) return;
        showEditModal("Edit Name", NODE_DATA[id].name, (newName) => {
         if (!NODE_DATA[id]) return;
         NODE_DATA[id].name = newName;
         const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`, );
         if (nodeGroup) {
          const label = nodeGroup.querySelector(".node-label");
          if (label) label.textContent = newName;
         }
         if (currentNodeId === id) {
          document.getElementById("node-name").textContent = newName;
         }
        });
       }
      
       function editNodeIp(id) {
        if (!NODE_DATA[id]) return;
        showEditModal("Edit IP/Subtitle", NODE_DATA[id].ip, (newIp) => {
         if (!NODE_DATA[id]) return;
         NODE_DATA[id].ip = newIp;
         const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`, );
         if (nodeGroup) {
          const sub = nodeGroup.querySelector(".node-sub");
          if (sub) sub.textContent = newIp;
         }
         if (currentNodeId === id) {
          document.getElementById("node-ip").textContent = newIp;
         }
        });
       }
      
       function claimTheImmortal(id) {
        if (!NODE_DATA[id]) return;
        currentNodeId = id;
        currentEdgeId = null;
        const data = NODE_DATA[id];
        document.querySelectorAll(".node-group").forEach((n) => {
         n.classList.toggle("active", n.dataset.nodeId === id);
        });
        document.querySelectorAll(".edge").forEach((e) => {
         const active = e.dataset.from === id || e.dataset.to === id;
         e.classList.toggle("active", active);
        });
        document.getElementById("node-panel").style.display = "block";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        const toolbar = document.getElementById("topology-toolbar");
        if (!topologyToolbarCollapsed) {
         toolbar.style.display = "flex";
        }
        updateTopologyToolbarVisibility();
        document.getElementById("node-name").textContent = data.name;
        document.getElementById("node-ip").textContent = data.ip;
        document.getElementById("node-mac").textContent = data.mac || "--";
        document.getElementById("node-rack").textContent = data.rackUnit || "--";
        document.getElementById("node-uheight").textContent = (data.uHeight || "1") + "U";
        document.getElementById("node-role").textContent = data.role;
      
        populateRackDropdown();
        const assignedRackSelect = document.getElementById("node-assigned-rack");
        if (assignedRackSelect) {
         assignedRackSelect.value = data.assignedRack || "";
        }
        
        const rackCapacitySelect = document.getElementById("node-rack-capacity");
        if (rackCapacitySelect) {
         rackCapacitySelect.value = data.rackCapacity || "42";
        }
        
        const isRack = data.isRack === true;
        const isAssignedToRack = !!data.assignedRack;
        const assignedRackRow = document.getElementById("assigned-rack-row");
        const rackCapacityRow = document.getElementById("rack-capacity-row");
        const uheightRow = document.getElementById("uheight-row");
        if (assignedRackRow) assignedRackRow.style.display = isRack ? "none" : "flex";
        if (rackCapacityRow) rackCapacityRow.style.display = isRack ? "flex" : "none";
        if (uheightRow) uheightRow.style.display = isAssignedToRack ? "flex" : "none";
        
        document.getElementById("node-name").onclick = () => editNodeName(id);
        document.getElementById("node-ip").onclick = () => editNodeIp(id);
        document.getElementById("node-mac").onclick = () => editNodeMac(id);
        document.getElementById("node-rack").onclick = () => editNodeRack(id);
        document.getElementById("node-uheight").onclick = () => editNodeUHeight(id);
        const currentSize = savedSizes[id] || getDefaultSize();
        document.getElementById("size-slider").value = currentSize;
        document.getElementById("size-value").textContent = currentSize;
        const styleEntry = savedStyles[id] || {};
        const resolvedStyles = resolveStylesEntry(styleEntry);
        const scopeKey = currentStyleScope || "all";
        const flatProps = ["circleColor", "circleBorder", "titleColor", "titleFont", "titleSize", "subColor", "subFont", "subSize", ];
        const isFlat = flatProps.some((p) => Object.prototype.hasOwnProperty.call(styleEntry, p), );
        const scopedStyles = isFlat ? styleEntry : styleEntry[scopeKey] || {};
        const circleColorInput = document.getElementById("circle-color");
        const titleColorInput = document.getElementById("title-color");
        const titleFontSelect = document.getElementById("title-font");
        const titleSizeInput = document.getElementById("title-size");
        const subColorInput = document.getElementById("sub-color");
        const subFontSelect = document.getElementById("sub-font");
        const subSizeInput = document.getElementById("sub-size");
        const shapeSelect = document.getElementById("shape-select");
        const scopeSelect = document.getElementById("style-scope");
        circleColorInput.value = scopedStyles.circleColor || resolvedStyles.circleColor || "#1e293b";
        const circleBorderInput = document.getElementById("circle-border");
        circleBorderInput.value = scopedStyles.circleBorder || resolvedStyles.circleBorder || "#475569";
        titleColorInput.value = scopedStyles.titleColor || resolvedStyles.titleColor || "#e2e8f0";
        titleFontSelect.value = scopedStyles.titleFont || resolvedStyles.titleFont || "system-ui, sans-serif";
        titleSizeInput.value = scopedStyles.titleSize || resolvedStyles.titleSize || 18;
        subColorInput.value = scopedStyles.subColor || resolvedStyles.subColor || "#94a3b8";
        subFontSelect.value = scopedStyles.subFont || resolvedStyles.subFont || "system-ui, sans-serif";
        subSizeInput.value = scopedStyles.subSize || resolvedStyles.subSize || 13;
        shapeSelect.value = data.shape || "circle";
        scopeSelect.value = currentStyleScope || "all";
        document.getElementById("title-offset-y").value = scopedStyles.titleOffsetY || resolvedStyles.titleOffsetY || 0;
        document.getElementById("title-offset-x").value = scopedStyles.titleOffsetX || resolvedStyles.titleOffsetX || 0;
        document.getElementById("sub-offset-y").value = scopedStyles.subOffsetY || resolvedStyles.subOffsetY || 0;
        document.getElementById("sub-offset-x").value = scopedStyles.subOffsetX || resolvedStyles.subOffsetX || 0;
      
      const pingOffsetXInput = document.getElementById("ping-offset-x");
      const pingOffsetYInput = document.getElementById("ping-offset-y");
      
      if (pingOffsetXInput && pingOffsetYInput) {
      pingOffsetXInput.value =
       (scopedStyles.pingOffsetX !== undefined
         ? scopedStyles.pingOffsetX
         : (resolvedStyles.pingOffsetX !== undefined
             ? resolvedStyles.pingOffsetX
             : 0));
      
      pingOffsetYInput.value =
       (scopedStyles.pingOffsetY !== undefined
         ? scopedStyles.pingOffsetY
         : (resolvedStyles.pingOffsetY !== undefined
             ? resolvedStyles.pingOffsetY
             : 0));
      }
        const tagEl = document.getElementById("node-tags");
        tagEl.innerHTML = "";
        data.tags.forEach((tag, i) => {
         const b = document.createElement("span");
         b.className = "badge";
         const isIconTag = typeof tag === 'object' && tag.type === 'icon';
         if (!isIconTag && typeof tag === 'string' && tag.toLowerCase().includes("wg")) b.classList.add("wg");
         b.style.cursor = "pointer";
         b.style.position = "relative";
         const tagContent = document.createElement("span");
         if (isIconTag) {
          b.classList.add("icon-badge");
          IconLibrary.getIcon(tag.library, tag.name).then(svgText => {
           if (svgText) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(svgText, 'image/svg+xml');
            const svgEl = doc.querySelector('svg');
            if (svgEl) {
             svgEl.setAttribute('width', '16');
             svgEl.setAttribute('height', '16');
             tagContent.innerHTML = '';
             tagContent.appendChild(svgEl);
             const nameSpan = document.createElement('span');
             nameSpan.textContent = tag.name;
             nameSpan.style.marginLeft = '4px';
             tagContent.appendChild(nameSpan);
            }
           }
          });
         } else {
          tagContent.textContent = tag;
          tagContent.addEventListener("click", (e) => {
           e.stopPropagation();
           showEditModal("Edit Tag", tag, (newTag) => {
            if (newTag) {
             data.tags[i] = newTag;
             claimTheImmortal(id);
            }
           });
          });
         }
         const deleteTag = document.createElement("span");
         deleteTag.textContent = " ‚úï";
         deleteTag.style.opacity = "0.6";
         deleteTag.style.marginLeft = "4px";
         deleteTag.style.fontSize = "10px";
         deleteTag.addEventListener("click", (e) => {
          e.stopPropagation();
          data.tags.splice(i, 1);
          claimTheImmortal(id);
         });
         b.append(tagContent, deleteTag);
         tagEl.append(b);
        });
        const addTagBtn = document.createElement("span");
        addTagBtn.className = "badge";
        addTagBtn.style.cursor = "pointer";
        addTagBtn.style.opacity = "0.6";
        addTagBtn.style.borderStyle = "dashed";
        addTagBtn.textContent = "+ Add";
        addTagBtn.addEventListener("click", () => {
         showEditModal("Add Tag(s) : comma separated", "",
          (newTagStr) => {
           if (newTagStr) {
            const newTags = newTagStr.split(",").map((t) => t.trim()).filter((t) => t);
            newTags.forEach((t) => data.tags.push(t));
            claimTheImmortal(id);
           }
          }, );
        });
        tagEl.append(addTagBtn);
        const notesEl = document.getElementById("node-notes");
        notesEl.innerHTML = "";
        data.notes.forEach((note, i) => {
         const li = document.createElement("li");
         const noteText = document.createElement("span");
         noteText.textContent = note;
         noteText.style.flex = "1";
         const deleteBtn = document.createElement("span");
         deleteBtn.className = "delete-note";
         deleteBtn.textContent = "‚úï";
         deleteBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          challengeTheImmortal("Are you sure you want to delete this note?",
           () => {
            data.notes.splice(i, 1);
            claimTheImmortal(id);
           }, );
         });
         li.append(noteText, deleteBtn);
         noteText.addEventListener("dblclick", () => {
          noteText.classList.add("editing");
          noteText.contentEditable = true;
          noteText.focus();
         });
         noteText.addEventListener("blur", () => {
          noteText.classList.remove("editing");
          noteText.contentEditable = false;
          data.notes[i] = noteText.textContent;
         });
         notesEl.append(li);
        });
        const addLineSelect = document.getElementById("add-line-select");
      addLineSelect.innerHTML = "";
      const currentRack = data.assignedRack || "";
      Object.entries(NODE_DATA).forEach(([nodeId, node]) => {
      if (nodeId !== id) {
      const nodeRack = node.assignedRack || "";
      if (currentRack === nodeRack) {
      const opt = document.createElement("option");
      opt.value = nodeId;
      opt.textContent = node.name;
      addLineSelect.appendChild(opt);
      }
      }
      });
        
        const pingEnabled = data.ping && data.ping.enabled;
        document.getElementById('node-pingable').checked = pingEnabled;
        document.getElementById('node-ping-options').style.display = pingEnabled ? 'block' : 'none';
        
        if (data.ping) {
         document.getElementById('node-ping-protocol').value = data.ping.protocol || 'http';
         document.getElementById('node-custom-url').value = data.ping.customUrl || '';
         document.getElementById('node-ping-timeout').value = data.ping.timeout || 3000;
         document.getElementById('node-custom-url-container').style.display = 
          data.ping.protocol === 'custom' ? 'block' : 'none';
         
         updatePingStatusDisplay(id);
        }
       }
      
       function updatePingStatusDisplay(nodeId) {
        const data = NODE_DATA[nodeId];
        if (!data || !data.ping) return;
        
        const statusEl = document.getElementById('node-ping-status');
        const lastCheckEl = document.getElementById('node-ping-last-check');
        
        const statusColors = {
         online: 'var(--accent)',
         offline: 'var(--danger)',
         checking: '#f59e0b',
         unknown: 'var(--text-soft)'
        };
        
        const statusTexts = {
         online: '‚óè Online',
         offline: '‚óè Offline',
         checking: '‚óè Checking...',
         unknown: '‚óè Unknown'
        };
        
        statusEl.textContent = statusTexts[data.ping.status] || statusTexts.unknown;
        statusEl.style.color = statusColors[data.ping.status] || statusColors.unknown;
        
        if (data.ping.lastCheck) {
         const checkTime = new Date(data.ping.lastCheck);
         lastCheckEl.textContent = `Last checked: ${checkTime.toLocaleTimeString()}`;
        } else {
         lastCheckEl.textContent = 'Never checked';
        }
       }
      
       function selectTheConnection(id) {
        currentEdgeId = id;
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "block";
        document.getElementById("text-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.display = "none";
        document.querySelectorAll(".node-group").forEach((n) => n.classList.remove("active"));
        document.querySelectorAll(".edge").forEach((e) => {
         e.classList.toggle("active", e.dataset.edgeId === id);
        });
        const edge = EDGE_DATA.list.find((e) => e.id === id);
        if (!edge) return;
        const directionSymbols = {
         none: "‚áÑ",
         forward: "‚Üí",
         backward: "‚Üê",
         both: "‚Üî",
        };
        const dirSymbol = directionSymbols[edge.direction] || "‚áÑ";
        let titleText = "Custom line";
        if (edge.from || edge.to) {
         const fromName = edge.from ? NODE_DATA[edge.from]?.name || edge.from : "";
         const toName = edge.to ? NODE_DATA[edge.to]?.name || edge.to : "";
         titleText = `${fromName || "?"} ${dirSymbol} ${toName || "?"}`;
        }
        document.getElementById("edge-title").textContent = titleText;
        const widthInput = document.getElementById("edge-width");
        const colorInput = document.getElementById("edge-color");
        const directionSelect = document.getElementById("edge-direction");
        const lineStyleSelect = document.getElementById("edge-line-style");
        widthInput.value = edge.width;
        colorInput.value = edge.color;
        directionSelect.value = edge.direction || "none";
        lineStyleSelect.value = edge.lineStyle || "solid";
        
        const fromPortInput = document.getElementById("edge-from-port");
        const toPortInput = document.getElementById("edge-to-port");
        const portFieldsFrom = document.getElementById("edge-port-fields");
        const portFieldsTo = document.getElementById("edge-port-fields-to");
        
        if (edge.type === "custom") {
         if (portFieldsFrom) portFieldsFrom.style.display = "none";
         if (portFieldsTo) portFieldsTo.style.display = "none";
        } else {
         if (portFieldsFrom) portFieldsFrom.style.display = "flex";
         if (portFieldsTo) portFieldsTo.style.display = "flex";
         if (fromPortInput) {
          fromPortInput.value = edge.fromPort || "";
          fromPortInput.onchange = () => updateEdgePortLabels(id);
         }
         if (toPortInput) {
          toPortInput.value = edge.toPort || "";
          toPortInput.onchange = () => updateEdgePortLabels(id);
         }
        }
        
        const list = document.getElementById("edge-notes");
        list.innerHTML = "";
        edge.notes.forEach((note, i) => {
         const li = document.createElement("li");
         const txt = document.createElement("span");
         txt.textContent = note;
         txt.style.flex = "1";
         const del = document.createElement("span");
         del.className = "delete-note";
         del.textContent = "‚úï";
         del.addEventListener("click", (e) => {
          e.stopPropagation();
          challengeTheImmortal("Delete this line note?", () => {
           edge.notes.splice(i, 1);
           saveEdgeData();
           selectTheConnection(id);
          });
         });
         txt.addEventListener("dblclick", () => {
          txt.classList.add("editing");
          txt.contentEditable = true;
          txt.focus();
         });
         txt.addEventListener("blur", () => {
          txt.classList.remove("editing");
          txt.contentEditable = false;
          edge.notes[i] = txt.textContent;
          saveEdgeData();
         });
         li.append(txt, del);
         list.appendChild(li);
        });
       }
       window.addEventListener("resize", () => {
        forgeTheTopology();
        if (currentEdgeId) {
         selectTheConnection(currentEdgeId);
        } else if (currentNodeId && NODE_DATA[currentNodeId]) {
         claimTheImmortal(currentNodeId);
        } else {
         const availableNodes = Object.keys(NODE_DATA);
         if (availableNodes.length > 0) {
          claimTheImmortal(availableNodes[0]);
         }
        }
       });
       (function initZoomPan() {
        const viewport = document.getElementById("canvas-viewport");
        const svg = document.getElementById("map");
        const hint = document.getElementById("canvas-hint");
        setTimeout(() => {
         hint.classList.add("visible");
         setTimeout(() => hint.classList.remove("visible"), 4000);
        }, 1000);
        viewport.addEventListener("wheel",
         (e) => {
          e.preventDefault();
          const rect = viewport.getBoundingClientRect();
          const mouseX = (e.clientX - rect.left) / rect.width;
          const mouseY = (e.clientY - rect.top) / rect.height;
          const delta = e.deltaY > 0 ? 0.9 : 1.1;
          zoomTo(canvasState.zoom * delta, mouseX, mouseY);
         }, {
          passive: false
         }, );
        let initialPinchDistance = 0;
        let initialPinchZoom = 1;
        let pinchCenter = {
         x: 0.5,
         y: 0.5
        };
        viewport.addEventListener("touchstart",
         (e) => {
          if (e.touches.length === 2) {
           e.preventDefault();
           const touch1 = e.touches[0];
           const touch2 = e.touches[1];
           initialPinchDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY, );
           initialPinchZoom = canvasState.zoom;
           const rect = viewport.getBoundingClientRect();
           const centerX = (touch1.clientX + touch2.clientX) / 2;
           const centerY = (touch1.clientY + touch2.clientY) / 2;
           pinchCenter.x = (centerX - rect.left) / rect.width;
           pinchCenter.y = (centerY - rect.top) / rect.height;
          }
         }, {
          passive: false
         }, );
        viewport.addEventListener("touchmove",
         (e) => {
          if (e.touches.length === 2) {
           e.preventDefault();
           const touch1 = e.touches[0];
           const touch2 = e.touches[1];
           const currentDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY, );
           if (initialPinchDistance > 0) {
            const scale = currentDistance / initialPinchDistance;
            const newZoom = initialPinchZoom * scale;
            zoomTo(newZoom, pinchCenter.x, pinchCenter.y);
           }
          }
         }, {
          passive: false
         }, );
        let panStartViewX = 0;
        let panStartViewY = 0;
        
        let lastEmptyTapTime = 0;
        let emptyTapTimeout = null;
        let emptyTapMoved = false;
        
        viewport.addEventListener("touchend", (e) => {
          if (currentView.mode !== "rack") return;
          
          if (e.changedTouches.length !== 1) return;
          
          const isEmptySpace = e.target === svg || e.target === viewport || e.target.tagName === "svg";
          if (!isEmptySpace) return;
          
          if (emptyTapMoved) {
            emptyTapMoved = false;
            return;
          }
          
          const currentTime = new Date().getTime();
          const tapGap = currentTime - lastEmptyTapTime;
          
          if (tapGap < 300 && tapGap > 0) {
            e.preventDefault();
            
            exitRack();
            
            if (navigator.vibrate) {
              navigator.vibrate(50);
            }
            
            lastEmptyTapTime = 0;
            if (emptyTapTimeout) {
              clearTimeout(emptyTapTimeout);
              emptyTapTimeout = null;
            }
          } else {
            lastEmptyTapTime = currentTime;
            
            if (emptyTapTimeout) clearTimeout(emptyTapTimeout);
            emptyTapTimeout = setTimeout(() => {
              lastEmptyTapTime = 0;
            }, 300);
          }
        }, { passive: false });
        
        viewport.addEventListener("mousedown", (e) => {
         if (e.target.closest(".draw-toolbar") || e.target.closest(".topology-toolbar") || e.target.closest(".legend-container")) {
          return;
         }
         if (freeDrawMode || rectDrawMode) {
          return;
         }
         const isEmptySpace = e.target === svg || e.target === viewport || e.target.tagName === "svg";
         if (isEmptySpace || e.button === 2 || e.button === 1) {
          e.preventDefault();
          canvasState.isPanning = true;
          canvasState.panStartX = e.clientX;
          canvasState.panStartY = e.clientY;
          panStartViewX = canvasState.panX;
          panStartViewY = canvasState.panY;
          viewport.classList.add("panning");
         }
        });
        viewport.addEventListener("touchstart",
         (e) => {
          if (e.target.closest(".draw-toolbar") || e.target.closest(".topology-toolbar") || e.target.closest(".legend-container")) {
           return;
          }
          if (freeDrawMode || rectDrawMode) {
           return;
          }
          const isEmptySpace = e.target === svg || e.target === viewport || e.target.tagName === "svg";
          if (isEmptySpace && e.touches.length === 1) {
           e.preventDefault();
           emptyTapMoved = false;
           canvasState.isPanning = true;
           canvasState.panStartX = e.touches[0].clientX;
           canvasState.panStartY = e.touches[0].clientY;
           panStartViewX = canvasState.panX;
           panStartViewY = canvasState.panY;
           viewport.classList.add("panning");
          }
         }, {
          passive: false
         }, );
        document.addEventListener("mousemove", (e) => {
         if (!canvasState.isPanning) return;
         const dx = e.clientX - canvasState.panStartX;
         const dy = e.clientY - canvasState.panStartY;
         const rect = viewport.getBoundingClientRect();
         const viewWidth = CANVAS_WIDTH / canvasState.zoom;
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         const canvasDx = (dx / rect.width) * viewWidth;
         const canvasDy = (dy / rect.height) * viewHeight;
         canvasState.panX = panStartViewX - canvasDx;
         canvasState.panY = panStartViewY - canvasDy;
         constrainPan();
         updateViewBox();
        });
        document.addEventListener("touchmove", (e) => {
         if (!canvasState.isPanning || !e.touches[0]) return;
         emptyTapMoved = true; 
         const dx = e.touches[0].clientX - canvasState.panStartX;
         const dy = e.touches[0].clientY - canvasState.panStartY;
         const rect = viewport.getBoundingClientRect();
         const viewWidth = CANVAS_WIDTH / canvasState.zoom;
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         const canvasDx = (dx / rect.width) * viewWidth;
         const canvasDy = (dy / rect.height) * viewHeight;
         canvasState.panX = panStartViewX - canvasDx;
         canvasState.panY = panStartViewY - canvasDy;
         constrainPan();
         updateViewBox();
        });
        document.addEventListener("mouseup", () => {
         if (canvasState.isPanning) {
          canvasState.isPanning = false;
          viewport.classList.remove("panning");
         }
        });
        document.addEventListener("touchend", () => {
         if (canvasState.isPanning) {
          canvasState.isPanning = false;
          viewport.classList.remove("panning");
         }
        });
        document.addEventListener("keydown", (e) => {
         const isEditing = document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "TEXTAREA" || document.activeElement.isContentEditable;
         if (e.code === "Space" && !e.repeat && !isEditing) {
          e.preventDefault();
          canvasState.spacePressed = true;
          viewport.style.cursor = "grab";
         }
        });
        document.addEventListener("keyup", (e) => {
         if (e.code === "Space") {
          canvasState.spacePressed = false;
          viewport.style.cursor = "";
         }
        });
        document.getElementById("zoom-in-btn").addEventListener("click", () => {
         zoomTo(canvasState.zoom * 1.25, 0.5, 0.5);
        });
        document.getElementById("zoom-out-btn").addEventListener("click", () => {
         zoomTo(canvasState.zoom * 0.8, 0.5, 0.5);
        });
        document.getElementById("zoom-fit-btn").addEventListener("click", fitToContent);
        document.getElementById("zoom-reset-btn").addEventListener("click", resetView);
        const minimapContainer = document.getElementById("minimap-container");
        const minimapSvg = document.getElementById("minimap");
        let minimapDragging = false;
        minimapContainer.addEventListener("mousedown", (e) => {
         e.preventDefault();
         minimapDragging = true;
         updatePanFromMinimap(e);
        });
        minimapContainer.addEventListener("touchstart",
         (e) => {
          e.preventDefault();
          minimapDragging = true;
          updatePanFromMinimapTouch(e);
         }, {
          passive: false
         }, );
        document.addEventListener("mousemove", (e) => {
         if (minimapDragging) {
          updatePanFromMinimap(e);
         }
        });
        document.addEventListener("touchmove", (e) => {
         if (minimapDragging && e.touches[0]) {
          updatePanFromMinimapTouch(e);
         }
        });
        document.addEventListener("mouseup", () => {
         minimapDragging = false;
        });
        document.addEventListener("touchend", () => {
         minimapDragging = false;
        });
      
        function updatePanFromMinimap(e) {
         const rect = minimapContainer.getBoundingClientRect();
         const x = (e.clientX - rect.left) / rect.width;
         const y = (e.clientY - rect.top) / rect.height;
         const viewWidth = CANVAS_WIDTH / canvasState.zoom;
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         canvasState.panX = x * CANVAS_WIDTH - viewWidth / 2;
         canvasState.panY = y * CANVAS_HEIGHT - viewHeight / 2;
         constrainPan();
         updateViewBox();
        }
      
        function updatePanFromMinimapTouch(e) {
         const rect = minimapContainer.getBoundingClientRect();
         const touch = e.touches[0];
         const x = (touch.clientX - rect.left) / rect.width;
         const y = (touch.clientY - rect.top) / rect.height;
         const viewWidth = CANVAS_WIDTH / canvasState.zoom;
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         canvasState.panX = x * CANVAS_WIDTH - viewWidth / 2;
         canvasState.panY = y * CANVAS_HEIGHT - viewHeight / 2;
         constrainPan();
         updateViewBox();
        }
        document.addEventListener("keydown", (e) => {
         if (document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "TEXTAREA") return;
         if (
          (e.key === "+" || e.key === "=") && (e.ctrlKey || e.metaKey)) {
          e.preventDefault();
          zoomTo(canvasState.zoom * 1.25, 0.5, 0.5);
         } else if (e.key === "-" && (e.ctrlKey || e.metaKey)) {
          e.preventDefault();
          zoomTo(canvasState.zoom * 0.8, 0.5, 0.5);
         } else if (e.key === "0" && (e.ctrlKey || e.metaKey)) {
          e.preventDefault();
          resetView();
         }
        });
        setTimeout(() => {
         fitToContent();
        }, 100);
       })();
       const sizeSlider = document.getElementById("size-slider");
       const sizeValue = document.getElementById("size-value");
       const resetSizeBtn = document.getElementById("reset-size");
       sizeSlider.addEventListener("input", () => {
        const newSize = parseInt(sizeSlider.value, 10);
        sizeValue.textContent = newSize;
        savedSizes[currentNodeId] = newSize;
        const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
        if (nodeGroup) {
         const oldShape = nodeGroup.querySelector(".node-circle");
         if (oldShape) oldShape.remove();
         const newShape = createNodeShape(currentNodeId, newSize);
         nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
         const styles = resolveStylesForNode(currentNodeId);
         if (styles.circleColor) newShape.style.fill = styles.circleColor;
		 if (styles.circleBorder) newShape.style.stroke = styles.circleBorder;
         const label = nodeGroup.querySelector(".node-label");
         const sub = nodeGroup.querySelector(".node-sub");
         if (label) {
          label.setAttribute("y", -newSize * 0.28);
          const labelSize = styles.titleSize || newSize * 0.33;
          label.style.fontSize = labelSize + "px";
         }
         if (sub) {
          sub.setAttribute("y", newSize * 0.4);
          const subSize = styles.subSize || newSize * 0.24;
          sub.style.fontSize = subSize + "px";
         }
       updatePingIndicator(currentNodeId);
        }
       });
       resetSizeBtn.addEventListener("click", () => {
        delete savedSizes[currentNodeId];
        const defaultSize = getDefaultSize();
        sizeSlider.value = defaultSize;
        sizeValue.textContent = defaultSize;
        const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
        if (nodeGroup) {
         const oldShape = nodeGroup.querySelector(".node-circle");
         if (oldShape) oldShape.remove();
         const shapeType = (NODE_DATA[currentNodeId] && NODE_DATA[currentNodeId].shape) || "circle";
         const newShape = createNodeShape(currentNodeId, defaultSize);
         nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
         const styles = resolveStylesForNode(currentNodeId);
         if (styles.circleColor) newShape.style.fill = styles.circleColor;
		 if (styles.circleBorder) newShape.style.stroke = styles.circleBorder;
         const label = nodeGroup.querySelector(".node-label");
         const sub = nodeGroup.querySelector(".node-sub");
         if (label) {
          label.setAttribute("y", -defaultSize * 0.28);
          const labelSize = styles.titleSize || defaultSize * 0.33;
          label.style.fontSize = labelSize + "px";
         }
         if (sub) {
          sub.setAttribute("y", defaultSize * 0.4);
          const subSize = styles.subSize || defaultSize * 0.24;
          sub.style.fontSize = subSize + "px";
         }
          updatePingIndicator(currentNodeId);
      
        }
       });
       const applyStyle = (property, value) => {
        const styleEntry = ensureStyleEntry(currentNodeId);
        const scopeKey = currentStyleScope || "all";
        if (!styleEntry[scopeKey]) styleEntry[scopeKey] = {};
        styleEntry[scopeKey][property] = value;
        const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
        if (!nodeGroup) return;
        const shapeEl = nodeGroup.querySelector(".node-circle");
        const label = nodeGroup.querySelector(".node-label");
        const sub = nodeGroup.querySelector(".node-sub");
        if (property === "circleColor" && shapeEl) shapeEl.style.fill = value;
		else if (property === "circleBorder" && shapeEl) shapeEl.style.stroke = value;
        else if (property === "titleColor" && label) label.style.fill = value;
        else if (property === "titleFont" && label) label.style.fontFamily = value;
        else if (property === "titleSize" && label) label.style.fontSize = value + "px";
        else if (property === "subColor" && sub) sub.style.fill = value;
        else if (property === "subFont" && sub) sub.style.fontFamily = value;
        else if (property === "subSize" && sub) sub.style.fontSize = value + "px";
       };
       document.getElementById("circle-color").addEventListener("input", (e) => applyStyle("circleColor", e.target.value), );
	   document.getElementById("circle-border").addEventListener("input", (e) => applyStyle("circleBorder", e.target.value), );
       document.getElementById("title-color").addEventListener("input", (e) => applyStyle("titleColor", e.target.value), );
       document.getElementById("title-font").addEventListener("change", (e) => applyStyle("titleFont", e.target.value), );
       document.getElementById("title-size").addEventListener("input", (e) => applyStyle("titleSize", parseInt(e.target.value, 10)), );
       document.getElementById("sub-color").addEventListener("input", (e) => applyStyle("subColor", e.target.value), );
       document.getElementById("sub-font").addEventListener("change", (e) => applyStyle("subFont", e.target.value), );
       document.getElementById("sub-size").addEventListener("input", (e) => applyStyle("subSize", parseInt(e.target.value, 10)), );
       document.getElementById("title-offset-y").addEventListener("input", (e) => {
        applyStyle("titleOffsetY", parseInt(e.target.value, 10) || 0);
        forgeTheTopology();
        if (currentNodeId) claimTheImmortal(currentNodeId);
       });
       document.getElementById("title-offset-x").addEventListener("input", (e) => {
        applyStyle("titleOffsetX", parseInt(e.target.value, 10) || 0);
        forgeTheTopology();
        if (currentNodeId) claimTheImmortal(currentNodeId);
       });
       document.getElementById("sub-offset-y").addEventListener("input", (e) => {
        applyStyle("subOffsetY", parseInt(e.target.value, 10) || 0);
        forgeTheTopology();
        if (currentNodeId) claimTheImmortal(currentNodeId);
       });
       document.getElementById("sub-offset-x").addEventListener("input", (e) => {
        applyStyle("subOffsetX", parseInt(e.target.value, 10) || 0);
        forgeTheTopology();
        if (currentNodeId) claimTheImmortal(currentNodeId);
       });
      document.getElementById("ping-offset-x").addEventListener("input", (e) => {
      applyStyle("pingOffsetX", parseInt(e.target.value, 10) || 0);
      updatePingIndicator(currentNodeId);
      if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      
      document.getElementById("ping-offset-y").addEventListener("input", (e) => {
      applyStyle("pingOffsetY", parseInt(e.target.value, 10) || 0);
      updatePingIndicator(currentNodeId);
      if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      
       document.getElementById("reset-styles").addEventListener("click", () => {
        delete savedStyles[currentNodeId];
        forgeTheTopology();
        claimTheImmortal(currentNodeId);
       });
       document.getElementById("style-scope").addEventListener("change", (e) => {
        currentStyleScope = e.target.value || "all";
        claimTheImmortal(currentNodeId);
       });
       document.getElementById("shape-select").addEventListener("change", (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId]) return;
        const shape = e.target.value || "circle";
        NODE_DATA[currentNodeId].shape = shape;
        const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
        if (!nodeGroup) return;
        const oldShape = nodeGroup.querySelector(".node-circle");
        if (oldShape) oldShape.remove();
        const size = savedSizes[currentNodeId] || getDefaultSize();
        const newShape = createNodeShape(currentNodeId, size);
        nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
       });
       const addNoteBtn = document.getElementById("add-note-btn");
       const noteInput = document.getElementById("new-note-input");
       addNoteBtn.addEventListener("click", () => {
        const newNote = noteInput.value.trim();
        if (newNote && currentNodeId && NODE_DATA[currentNodeId]) {
         NODE_DATA[currentNodeId].notes.push(newNote);
         claimTheImmortal(currentNodeId);
         noteInput.value = "";
        }
       });
       noteInput.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
         addNoteBtn.click();
        }
       });
       
       document.getElementById('node-pingable').addEventListener('change', (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId]) return;
        if (!NODE_DATA[currentNodeId].ping) {
         NODE_DATA[currentNodeId].ping = {
          enabled: false,
          protocol: 'http',
          customUrl: '',
          timeout: 3000,
          status: 'unknown',
          lastCheck: null
         };
        }
        NODE_DATA[currentNodeId].ping.enabled = e.target.checked;
        document.getElementById('node-ping-options').style.display = e.target.checked ? 'block' : 'none';
        forgeTheTopology();
       });
       
       document.getElementById('node-ping-protocol').addEventListener('change', (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId].ping) return;
        NODE_DATA[currentNodeId].ping.protocol = e.target.value;
        document.getElementById('node-custom-url-container').style.display = 
         e.target.value === 'custom' ? 'block' : 'none';
       });
       
       document.getElementById('node-custom-url').addEventListener('change', (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId].ping) return;
        NODE_DATA[currentNodeId].ping.customUrl = e.target.value.trim();
       });
       
       document.getElementById('node-ping-timeout').addEventListener('change', (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId].ping) return;
        NODE_DATA[currentNodeId].ping.timeout = parseInt(e.target.value) || 3000;
       });
       
       document.getElementById('check-ping-now').addEventListener('click', () => {
        if (!currentNodeId) return;
        checkNodeStatus(currentNodeId);
       });
       
       document.getElementById("edge-width").addEventListener("input", () => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        const v = parseInt(document.getElementById("edge-width").value, 10);
        if (Number.isNaN(v) || v <= 0) return;
        edge.width = v;
        saveEdgeData();
        const el = document.querySelector(`.edge[data-edge-id="${currentEdgeId}"]`, );
        if (el) el.style.strokeWidth = v;
       });
       document.getElementById("edge-color").addEventListener("input", () => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        const color = document.getElementById("edge-color").value;
        edge.color = color;
        saveEdgeData();
        const el = document.querySelector(`.edge[data-edge-id="${currentEdgeId}"]`, );
        if (el) el.style.stroke = color;
        forgeTheLegend();
       });
       document.getElementById("edge-direction").addEventListener("change", () => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        edge.direction = document.getElementById("edge-direction").value;
        saveEdgeData();
        forgeTheTopology();
        selectTheConnection(currentEdgeId);
       });
       document.getElementById("edge-line-style").addEventListener("change", () => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        edge.lineStyle = document.getElementById("edge-line-style").value;
        saveEdgeData();
        forgeTheTopology();
        selectTheConnection(currentEdgeId);
       });
       const addEdgeNoteBtn = document.getElementById("add-edge-note");
       const newEdgeNoteInput = document.getElementById("new-edge-note");
       addEdgeNoteBtn.addEventListener("click", () => {
        const txt = newEdgeNoteInput.value.trim();
        if (!txt || !currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        edge.notes.push(txt);
        saveEdgeData();
        newEdgeNoteInput.value = "";
        selectTheConnection(currentEdgeId);
       });
       newEdgeNoteInput.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
         addEdgeNoteBtn.click();
        }
       });
       document.getElementById("delete-edge").addEventListener("click", () => {
        if (!currentEdgeId) return;
        challengeTheImmortal("Are you sure you want to delete this line?",
         () => {
          EDGE_DATA.list = EDGE_DATA.list.filter(
           (e) => e.id !== currentEdgeId, );
          saveEdgeData();
          currentEdgeId = null;
          forgeTheTopology();
          const availableNodes = Object.keys(NODE_DATA);
          if (availableNodes.length > 0) {
           claimTheImmortal(availableNodes[0]);
          } else {
           document.getElementById("node-panel").style.display = "none";
           document.getElementById("edge-panel").style.display = "none";
           document.getElementById("topology-toolbar", ).style.display = "none";
          }
         }, );
       });
       document.getElementById("add-line-btn").addEventListener("click", () => {
        if (!currentNodeId) return;
        const select = document.getElementById("add-line-select");
        const directionSelect = document.getElementById("add-line-direction");
        const colorInput = document.getElementById("add-line-color");
        const targetId = select.value;
        if (!targetId || targetId === currentNodeId) return;
        const direction = directionSelect.value || "none";
        const lineColor = colorInput.value || "#475569";
        const newId = `${currentNodeId}-${targetId}-${Date.now()}`;
        const newEdge = {
         id: newId,
         from: currentNodeId,
         to: targetId,
         width: 4,
         color: lineColor,
         direction: direction,
         type: "main",
         notes: [],
         fromPort: "",
         toPort: "",
        };
        EDGE_DATA.list.push(newEdge);
        saveEdgeData();
        forgeTheTopology();
        claimTheImmortal(currentNodeId);
       });
       let freeDrawMode = false;
       let rectDrawMode = false;
       let currentTextId = null;
       let rectStartPoint = null;
       let rectPreviewEl = null;
       let rectStyle = "filled";
       let freeDrawPoints = [];
       let freeDrawPolylineEl = null;
       let freeDrawPointEls = [];
       const drawToggleBtn = document.getElementById("draw-toggle");
       const drawUndoBtn = document.getElementById("draw-undo");
       const drawColorInput = document.getElementById("draw-color");
       const drawStyleSelect = document.getElementById("draw-style");
       const drawArrowSelect = document.getElementById("draw-arrow");
       const svgMap = document.getElementById("map");
      
       function updateFreeDrawGraphics() {
        const ns = "http://www.w3.org/2000/svg";
        const svg = svgMap;
        if (!freeDrawPolylineEl && freeDrawPoints.length > 0) {
         freeDrawPolylineEl = document.createElementNS(ns, "polyline");
         freeDrawPolylineEl.classList.add("edge", "free-preview");
         freeDrawPolylineEl.setAttribute("fill", "none");
         svg.appendChild(freeDrawPolylineEl);
        }
        if (freeDrawPolylineEl) {
         if (freeDrawPoints.length === 0) {
          freeDrawPolylineEl.remove();
          freeDrawPolylineEl = null;
         } else {
          const ptsStr = freeDrawPoints.map((p) => `${p.x},${p.y}`).join(" ");
          freeDrawPolylineEl.setAttribute("points", ptsStr);
          freeDrawPolylineEl.style.stroke = drawColorInput.value || "#475569";
          freeDrawPolylineEl.style.strokeWidth = 3;
          const lineStyle = drawStyleSelect.value || "solid";
          if (lineStyle === "dashed") {
           freeDrawPolylineEl.style.strokeDasharray = "10,5";
          } else if (lineStyle === "dotted") {
           freeDrawPolylineEl.style.strokeDasharray = "2,4";
          } else {
           freeDrawPolylineEl.style.strokeDasharray = "none";
          }
         }
        }
        freeDrawPointEls.forEach((el) => el.remove());
        freeDrawPointEls = [];
        freeDrawPoints.forEach((p, idx) => {
         const c = document.createElementNS(ns, "circle");
         c.classList.add("free-point");
         c.setAttribute("cx", p.x);
         c.setAttribute("cy", p.y);
         c.setAttribute("r", 5);
         c.dataset.index = String(idx);
         c.addEventListener("mousedown", (e) => {
          if (!freeDrawMode) return;
          e.preventDefault();
          e.stopPropagation();
          let dragging = true;
          const svgEl = svgMap;
          const moveHandler = (ev) => {
           if (!dragging) return;
           const pt = svgEl.createSVGPoint();
           pt.x = ev.clientX;
           pt.y = ev.clientY;
           const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
           const i = parseInt(c.dataset.index, 10);
           if (Number.isNaN(i) || !freeDrawPoints[i]) return;
           freeDrawPoints[i].x = svgP.x;
           freeDrawPoints[i].y = svgP.y;
           updateFreeDrawGraphics();
          };
          const upHandler = () => {
           dragging = false;
           document.removeEventListener("mousemove", moveHandler);
           document.removeEventListener("mouseup", upHandler);
          };
          document.addEventListener("mousemove", moveHandler);
          document.addEventListener("mouseup", upHandler);
         });
         c.addEventListener("touchstart",
          (e) => {
           if (!freeDrawMode) return;
           e.preventDefault();
           e.stopPropagation();
           let dragging = true;
           const svgEl = svgMap;
           const touchMoveHandler = (ev) => {
            if (!dragging || !ev.touches[0]) return;
            const pt = svgEl.createSVGPoint();
            pt.x = ev.touches[0].clientX;
            pt.y = ev.touches[0].clientY;
            const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
            const i = parseInt(c.dataset.index, 10);
            if (Number.isNaN(i) || !freeDrawPoints[i]) return;
            freeDrawPoints[i].x = svgP.x;
            freeDrawPoints[i].y = svgP.y;
            updateFreeDrawGraphics();
           };
           const touchUpHandler = () => {
            dragging = false;
            document.removeEventListener("touchmove", touchMoveHandler, );
            document.removeEventListener("touchend", touchUpHandler, );
           };
           document.addEventListener("touchmove", touchMoveHandler);
           document.addEventListener("touchend", touchUpHandler);
          }, {
           passive: false
          }, );
         svg.appendChild(c);
         freeDrawPointEls.push(c);
        });
        drawUndoBtn.style.display = freeDrawPoints.length ? "inline-block" : "none";
       }
      
       function addFreeDrawPoint(x, y) {
        freeDrawPoints.push({
         x,
         y
        });
        updateFreeDrawGraphics();
       }
      
       function startFreeDraw() {
        freeDrawMode = true;
        freeDrawPoints = [];
        if (freeDrawPolylineEl) {
         freeDrawPolylineEl.remove();
         freeDrawPolylineEl = null;
        }
        freeDrawPointEls.forEach((el) => el.remove());
        freeDrawPointEls = [];
        svgMap.style.cursor = "crosshair";
        drawToggleBtn.textContent = "Done";
        drawUndoBtn.style.display = "none";
       }
      
       function finishFreeDraw() {
        freeDrawMode = false;
        svgMap.style.cursor = "";
        drawToggleBtn.textContent = "‚úèÔ∏è";
        if (freeDrawPoints.length >= 2) {
         const color = drawColorInput.value || "#475569";
         const lineStyle = drawStyleSelect.value || "solid";
         const arrowDir = drawArrowSelect.value || "none";
         const newId = "custom-" + Date.now();
         const pointsCopy = freeDrawPoints.map((p) => ({
          x: p.x,
          y: p.y,
         }));
         EDGE_DATA.list.push({
          id: newId,
          type: "custom",
          color,
          width: 4,
          lineStyle: lineStyle,
          direction: arrowDir,
          points: pointsCopy,
          notes: [],
         });
         saveEdgeData();
         freeDrawPoints = [];
         if (freeDrawPolylineEl) {
          freeDrawPolylineEl.remove();
          freeDrawPolylineEl = null;
         }
         freeDrawPointEls.forEach((el) => el.remove());
         freeDrawPointEls = [];
         forgeTheTopology();
         selectTheConnection(newId);
        } else {
         freeDrawPoints = [];
         if (freeDrawPolylineEl) {
          freeDrawPolylineEl.remove();
          freeDrawPolylineEl = null;
         }
         freeDrawPointEls.forEach((el) => el.remove());
         freeDrawPointEls = [];
         forgeTheLegend();
        }
        drawUndoBtn.style.display = "none";
       }
       drawToggleBtn.addEventListener("click", () => {
        if (currentView.mode === "rack") {
         alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
         return;
        }
        
        if (freeDrawMode) {
         finishFreeDraw();
        } else {
         startFreeDraw();
        }
       });
       drawUndoBtn.addEventListener("click", () => {
        if (!freeDrawMode || !freeDrawPoints.length) return;
        freeDrawPoints.pop();
        updateFreeDrawGraphics();
       });
       const drawToolbar = document.getElementById("draw-toolbar");
       drawToolbar.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       drawToolbar.addEventListener("click", (e) => {
        if (e.target !== drawToggleBtn && e.target !== drawUndoBtn) {
         e.stopPropagation();
        }
       });
       drawStyleSelect.addEventListener("change", () => {
        if (freeDrawMode) {
         updateFreeDrawGraphics();
        }
       });
       drawArrowSelect.addEventListener("change", () => {
        if (freeDrawMode) {
         updateFreeDrawGraphics();
        }
       });
       drawColorInput.addEventListener("input", () => {
        if (freeDrawMode) {
         updateFreeDrawGraphics();
        }
       });
       drawStyleSelect.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       drawStyleSelect.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       drawArrowSelect.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       drawArrowSelect.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       drawColorInput.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       drawColorInput.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       svgMap.addEventListener("click", (e) => {
        if (!freeDrawMode) return;
        if (e.button !== 0) return;
        const target = e.target;
        if (target && target.classList && target.classList.contains("free-point")) return;
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        addFreeDrawPoint(svgP.x, svgP.y);
       });
       svgMap.addEventListener("touchend",
        (e) => {
         if (!freeDrawMode) return;
         const target = e.target;
         if (target && target.classList && target.classList.contains("free-point")) return;
         if (e.changedTouches && e.changedTouches[0]) {
          e.preventDefault();
          const svgEl = svgMap;
          const pt = svgEl.createSVGPoint();
          pt.x = e.changedTouches[0].clientX;
          pt.y = e.changedTouches[0].clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          addFreeDrawPoint(svgP.x, svgP.y);
         }
        }, {
         passive: false
        }, );
       const settingsBtn = document.getElementById("settings-btn");
      
       const rectToggleBtn = document.getElementById("rect-toggle");
       const rectStyleSelect = document.getElementById("rect-style");
      
       function updateRectPreview() {
        if (!rectPreviewEl || !rectStartPoint) return;
        
        const ns = "http://www.w3.org/2000/svg";
        const svg = svgMap;
        
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
       }
      
       function startRectDraw() {
        rectDrawMode = true;
        rectStartPoint = null;
        rectPreviewEl = null;
        svgMap.style.cursor = "crosshair";
        rectToggleBtn.textContent = "Done";
        rectStyle = rectStyleSelect.value || "filled";
        
        if (freeDrawMode) {
         finishFreeDraw();
        }
        updateRectangleDeleteButtons();
       }
      
       function finishRectDraw() {
        rectDrawMode = false;
        svgMap.style.cursor = "";
        rectToggleBtn.textContent = "‚ñ≠";
        
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
       }
        updateRectangleDeleteButtons();
      
       rectToggleBtn.addEventListener("click", () => {
        if (currentView.mode === "rack") {
         alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
         return;
        }
        
        if (rectDrawMode) {
         finishRectDraw();
        } else {
         startRectDraw();
        }
       });
      
       rectStyleSelect.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       rectStyleSelect.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       rectStyleSelect.addEventListener("change", () => {
        if (rectDrawMode) {
         rectStyle = rectStyleSelect.value || "filled";
        }
       });
      
       svgMap.addEventListener("mousedown", (e) => {
        if (!rectDrawMode) return;
        if (e.button !== 0) return;
        e.preventDefault();
        e.stopPropagation();
        
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        rectStartPoint = { x: svgP.x, y: svgP.y };
        
        const ns = "http://www.w3.org/2000/svg";
        rectPreviewEl = document.createElementNS(ns, "rect");
        rectPreviewEl.classList.add("rect-preview");
        rectPreviewEl.setAttribute("x", svgP.x);
        rectPreviewEl.setAttribute("y", svgP.y);
        rectPreviewEl.setAttribute("width", 0);
        rectPreviewEl.setAttribute("height", 0);
        
        const color = drawColorInput.value || "#f97316";
        rectPreviewEl.style.stroke = color;
        rectPreviewEl.style.strokeWidth = 2;
        rectPreviewEl.style.strokeDasharray = "5,5";
        
        if (rectStyle === "filled") {
         rectPreviewEl.style.fill = color;
         rectPreviewEl.style.fillOpacity = "0.3";
        } else {
         rectPreviewEl.style.fill = "none";
        }
        
        svgEl.appendChild(rectPreviewEl);
       });
      
       svgMap.addEventListener("mousemove", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        
        rectPreviewEl.setAttribute("x", x);
        rectPreviewEl.setAttribute("y", y);
        rectPreviewEl.setAttribute("width", width);
        rectPreviewEl.setAttribute("height", height);
       });
      
       svgMap.addEventListener("mouseup", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        
        if (width > 10 && height > 10) {
      pushUndo("draw rectangle"); 
         const color = drawColorInput.value || "#f97316";
         const newId = "rect-" + Date.now();
         
         RECT_DATA.list.push({
          id: newId,
          x: x,
          y: y,
          width: width,
          height: height,
          color: color,
          style: rectStyle,
          notes: []
         });
         
         forgeTheTopology();
        }
        
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
       });
      
       let rectTouchStart = null;
       
       svgMap.addEventListener("touchstart", (e) => {
        if (!rectDrawMode) return;
        if (e.touches.length !== 1) return;
        
        e.preventDefault();
        const touch = e.touches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        rectStartPoint = { x: svgP.x, y: svgP.y };
        rectTouchStart = { x: svgP.x, y: svgP.y };
        
        const ns = "http://www.w3.org/2000/svg";
        rectPreviewEl = document.createElementNS(ns, "rect");
        rectPreviewEl.classList.add("rect-preview");
        rectPreviewEl.setAttribute("x", svgP.x);
        rectPreviewEl.setAttribute("y", svgP.y);
        rectPreviewEl.setAttribute("width", 0);
        rectPreviewEl.setAttribute("height", 0);
        
        const color = drawColorInput.value || "#f97316";
        rectPreviewEl.style.stroke = color;
        rectPreviewEl.style.strokeWidth = 2;
        rectPreviewEl.style.strokeDasharray = "5,5";
        
        if (rectStyle === "filled") {
         rectPreviewEl.style.fill = color;
         rectPreviewEl.style.fillOpacity = "0.3";
        } else {
         rectPreviewEl.style.fill = "none";
        }
        
        svgEl.appendChild(rectPreviewEl);
       }, { passive: false });
      
       svgMap.addEventListener("touchmove", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        if (e.touches.length !== 1) return;
        
        e.preventDefault();
        const touch = e.touches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        
        rectPreviewEl.setAttribute("x", x);
        rectPreviewEl.setAttribute("y", y);
        rectPreviewEl.setAttribute("width", width);
        rectPreviewEl.setAttribute("height", height);
       }, { passive: false });
      
       svgMap.addEventListener("touchend", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        if (!rectTouchStart) return;
        
        e.preventDefault();
        const touch = e.changedTouches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        
        if (width > 10 && height > 10) {
      pushUndo("draw rectangle");
         const color = drawColorInput.value || "#f97316";
         const newId = "rect-" + Date.now();
         
         RECT_DATA.list.push({
          id: newId,
          x: x,
          y: y,
          width: width,
          height: height,
          color: color,
          style: rectStyle,
          notes: []
         });
         
         forgeTheTopology();
        }
        
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
        rectTouchStart = null;
       }, { passive: false });
      
       const textToggleBtn = document.getElementById("text-toggle");
       
       function startTextMode() {
        textDrawMode = true;
        svgMap.style.cursor = "crosshair";
        textToggleBtn.textContent = "Done";
        textToggleBtn.style.background = "var(--accent)";
        textToggleBtn.style.color = "var(--bg)";
        
        if (freeDrawMode) {
         finishFreeDraw();
        }
        if (rectDrawMode) {
         finishRectDraw();
        }
        
        updateTextDeleteButtons();
       }
       
       function finishTextMode() {
        textDrawMode = false;
        svgMap.style.cursor = "";
        textToggleBtn.textContent = "T";
        textToggleBtn.style.background = "";
        textToggleBtn.style.color = "";
        updateTextDeleteButtons();
       }
       
       textToggleBtn.addEventListener("click", () => {
        if (currentView.mode === "rack") {
         alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
         return;
        }
        
        if (textDrawMode) {
         finishTextMode();
        } else {
         startTextMode();
        }
       });
       
       function handleTextPlacement(e) {
        if (!textDrawMode) return;
        
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        const newId = "text-" + Date.now();
      pushUndo("add text");
        TEXT_DATA.list.push({
         id: newId,
         x: svgP.x,
         y: svgP.y,
         content: "New Text",
         fontSize: 18,
         color: "#e2e8f0",
         fontWeight: "normal",
         fontStyle: "normal",
         textAlign: "start",
         textDecoration: "none",
         bgColor: "#000000",
         bgEnabled: false,
         opacity: 1
        });
        
        forgeTheTopology();
        
        showTextPanel(newId);
       }
       
       svgMap.addEventListener("click", (e) => {
        if (!textDrawMode) return;
        if (e.target.closest('.text-delete-btn')) return;
        if (e.target.closest('.text-group')) return;
        
        e.preventDefault();
        e.stopPropagation();
        handleTextPlacement(e);
       });
       
       svgMap.addEventListener("touchend", (e) => {
        if (!textDrawMode) return;
        if (e.target.closest('.text-delete-btn')) return;
        if (e.target.closest('.text-group')) return;
        if (e.touches.length > 0) return;
        
        e.preventDefault();
        const touch = e.changedTouches[0];
        const fakeEvent = {
         clientX: touch.clientX,
         clientY: touch.clientY,
         preventDefault: () => {},
         stopPropagation: () => {}
        };
        handleTextPlacement(fakeEvent);
       }, { passive: false });
       
       function showTextPanel(textId) {
        currentTextId = textId;
        const textItem = TEXT_DATA.list.find(t => t.id === textId);
        if (!textItem) return;
        
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        
        const textPanel = document.getElementById("text-panel");
        textPanel.style.display = "block";
        
        document.getElementById("text-content").value = textItem.content;
        document.getElementById("text-font-size").value = textItem.fontSize;
        document.getElementById("text-color").value = textItem.color;
        document.getElementById("text-font-weight").value = textItem.fontWeight;
        document.getElementById("text-font-style").value = textItem.fontStyle;
        document.getElementById("text-align").value = textItem.textAlign;
        document.getElementById("text-decoration").value = textItem.textDecoration;
        document.getElementById("text-bg-color").value = textItem.bgColor;
        document.getElementById("text-bg-enabled").checked = textItem.bgEnabled;
        document.getElementById("text-opacity").value = textItem.opacity;
        document.getElementById("text-opacity-val").textContent = Math.round(textItem.opacity * 100) + "%";
       }
       
       function updateTextDeleteButtons() {
        const deleteButtons = document.querySelectorAll('.text-delete-btn');
        deleteButtons.forEach(btn => {
         btn.style.display = textDrawMode ? 'block' : 'none';
        });
       }
       
       function deleteText(textId) {
      pushUndo("delete text");
        TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== textId);
        forgeTheTopology();
        
        if (currentTextId === textId) {
         document.getElementById("text-panel").style.display = "none";
         currentTextId = null;
        }
       }
       
       document.getElementById("text-content").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
      pushUndo("edit text");
         textItem.content = e.target.value;
         forgeTheTopology();
        }
       });
       
       document.getElementById("text-font-size").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         textItem.fontSize = parseInt(e.target.value);
         forgeTheTopology();
        }
       });
       
       document.getElementById("text-color").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         textItem.color = e.target.value;
         forgeTheTopology();
        }
       });
       
       document.getElementById("text-font-weight").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         textItem.fontWeight = e.target.value;
         forgeTheTopology();
        }
       });
       
       document.getElementById("text-font-style").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         textItem.fontStyle = e.target.value;
         forgeTheTopology();
        }
       });
       
       document.getElementById("text-align").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         textItem.textAlign = e.target.value;
         forgeTheTopology();
        }
       });
       
       document.getElementById("text-decoration").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         textItem.textDecoration = e.target.value;
         forgeTheTopology();
        }
       });
       
       document.getElementById("text-bg-color").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         textItem.bgColor = e.target.value;
         forgeTheTopology();
        }
       });
       
       document.getElementById("text-bg-enabled").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         textItem.bgEnabled = e.target.checked;
         forgeTheTopology();
        }
       });
       
       document.getElementById("text-opacity").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         textItem.opacity = parseFloat(e.target.value);
         document.getElementById("text-opacity-val").textContent = Math.round(textItem.opacity * 100) + "%";
         forgeTheTopology();
        }
       });
       
       document.getElementById("delete-text").addEventListener("click", () => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         challengeTheImmortal(`Delete text "${textItem.content.substring(0, 30)}..."?`, () => {
          deleteText(currentTextId);
         });
        }
       });
      
       const settingsModal = document.getElementById("settings-modal");
       const settingsClose = document.getElementById("settings-close");
       settingsBtn.addEventListener("click", () => {	 
      document.getElementById("page-bg-color").value = rgbaToHex(PAGE_STATE.background) || "#050608";
        document.getElementById("topbar-bg-color").value = rgbaToHex(PAGE_STATE.topbarBg) || "#0b0e13";
        document.getElementById("topbar-border-color").value = rgbaToHex(PAGE_STATE.topbarBorder) || "#1f2533";	 
      document.getElementById("panel-color").value = rgbaToHex(PAGE_STATE.panel) || "#0b0e13";
      document.getElementById("panel-alt-color").value = rgbaToHex(PAGE_STATE.panelAlt) || "#10141b";
      document.getElementById("accent-color").value = rgbaToHex(PAGE_STATE.accent) || "#4fd1c5";
      document.getElementById("danger-color").value = rgbaToHex(PAGE_STATE.danger) || "#f56565";
      document.getElementById("text-main-color").value = rgbaToHex(PAGE_STATE.textMain) || "#e2e8f0";
      document.getElementById("text-soft-color").value = rgbaToHex(PAGE_STATE.textSoft) || "#94a3b8";
      
        
        document.getElementById("auto-ping-enabled").checked = autoPingEnabled;
        document.getElementById("auto-ping-interval").value = autoPingInterval;
        document.getElementById("auto-ping-settings").style.display = autoPingEnabled ? 'block' : 'none';
        
        settingsModal.classList.add("active");
       });
       settingsClose.addEventListener("click", () => {
        settingsModal.classList.remove("active");
       });
       settingsModal.addEventListener("click", (e) => {
        if (e.target === settingsModal) {
         settingsModal.classList.remove("active");
        }
       });
       document.getElementById("page-bg-color").addEventListener("input", (e) => {
        PAGE_STATE.background = e.target.value;
        wieldThePower();
       });
       document.getElementById("topbar-bg-color").addEventListener("input", (e) => {
        PAGE_STATE.topbarBg = e.target.value;
        wieldThePower();
       });
       document.getElementById("topbar-border-color").addEventListener("input", (e) => {
        PAGE_STATE.topbarBorder = e.target.value;
        wieldThePower();
       });
       document.getElementById("panel-color").addEventListener("input", (e) => {
        PAGE_STATE.panel = e.target.value;
        wieldThePower();
       });
       document.getElementById("panel-alt-color").addEventListener("input", (e) => {
        PAGE_STATE.panelAlt = e.target.value;
        wieldThePower();
       });
       document.getElementById("accent-color").addEventListener("input", (e) => {
        PAGE_STATE.accent = e.target.value;
        wieldThePower();
       });
       document.getElementById("danger-color").addEventListener("input", (e) => {
        PAGE_STATE.danger = e.target.value;
        wieldThePower();
       });
       document.getElementById("text-main-color").addEventListener("input", (e) => {
        PAGE_STATE.textMain = e.target.value;
        wieldThePower();
       });
       document.getElementById("text-soft-color").addEventListener("input", (e) => {
        PAGE_STATE.textSoft = e.target.value;
        wieldThePower();
       });
       
       (function initializeResizers() {
         const headerResizer = document.getElementById('header-resizer');
         const sidebarResizer = document.getElementById('sidebar-resizer');
         const mobileFooterResizer = document.getElementById('mobile-footer-resizer');
         
         let isResizing = false;
         let currentResizer = null;
         let startY = 0;
         let startX = 0;
         let startHeight = 0;
         let startWidth = 0;
         
         function getClientPos(e) {
           if (e.touches && e.touches.length > 0) {
             return { x: e.touches[0].clientX, y: e.touches[0].clientY };
           }
           return { x: e.clientX, y: e.clientY };
         }
         
         function startResize(resizer, type, e) {
           isResizing = true;
           currentResizer = type;
           const pos = getClientPos(e);
           
           if (type === 'header') {
             startY = pos.y;
             startHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--topbar-height'));
           } else if (type === 'sidebar') {
             startX = pos.x;
             startWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width'));
           } else if (type === 'mobile-footer') {
             startY = pos.y;
             const currentVh = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--mobile-footer-height'));
             startHeight = (currentVh / 100) * window.innerHeight;
           }
           
           resizer.classList.add('resizing');
           document.body.classList.add('resizing');
           document.body.style.cursor = (type === 'sidebar') ? 'col-resize' : 'row-resize';
           e.preventDefault();
         }
         
         if (headerResizer) {
           headerResizer.addEventListener('mousedown', (e) => startResize(headerResizer, 'header', e));
           headerResizer.addEventListener('touchstart', (e) => startResize(headerResizer, 'header', e), { passive: false });
         }
         
         if (sidebarResizer) {
           sidebarResizer.addEventListener('mousedown', (e) => startResize(sidebarResizer, 'sidebar', e));
           sidebarResizer.addEventListener('touchstart', (e) => startResize(sidebarResizer, 'sidebar', e), { passive: false });
         }
         
         if (mobileFooterResizer) {
           mobileFooterResizer.addEventListener('mousedown', (e) => startResize(mobileFooterResizer, 'mobile-footer', e));
           mobileFooterResizer.addEventListener('touchstart', (e) => startResize(mobileFooterResizer, 'mobile-footer', e), { passive: false });
         }
         
         function handleMove(e) {
           if (!isResizing) return;
           
           const pos = getClientPos(e);
           
           if (currentResizer === 'header') {
             const deltaY = pos.y - startY;
             const newHeight = Math.max(40, Math.min(150, startHeight + deltaY));
             document.documentElement.style.setProperty('--topbar-height', newHeight + 'px');
           } else if (currentResizer === 'sidebar') {
             const deltaX = startX - pos.x;
             const newWidth = Math.max(200, Math.min(800, startWidth + deltaX));
             document.documentElement.style.setProperty('--sidebar-width', newWidth + 'px');
           } else if (currentResizer === 'mobile-footer') {
             const deltaY = startY - pos.y;
             const newHeight = startHeight + deltaY;
             const newVh = Math.max(15, Math.min(80, (newHeight / window.innerHeight) * 100));
             document.documentElement.style.setProperty('--mobile-footer-height', newVh + 'vh');
           }
           
           e.preventDefault();
         }
         
         document.addEventListener('mousemove', handleMove);
         document.addEventListener('touchmove', handleMove, { passive: false });
         
         function handleEnd() {
           if (isResizing) {
             isResizing = false;
             
             if (currentResizer === 'header') {
               PAGE_STATE.topbarHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--topbar-height'));
               headerResizer.classList.remove('resizing');
             } else if (currentResizer === 'sidebar') {
               PAGE_STATE.sidebarWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width'));
               sidebarResizer.classList.remove('resizing');
             } else if (currentResizer === 'mobile-footer') {
               PAGE_STATE.mobileFooterHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--mobile-footer-height'));
               mobileFooterResizer.classList.remove('resizing');
             }
             
             document.body.classList.remove('resizing');
             document.body.style.cursor = '';
             currentResizer = null;
           }
         }
         
         document.addEventListener('mouseup', handleEnd);
         document.addEventListener('touchend', handleEnd);
         document.addEventListener('touchcancel', handleEnd);
       })();
       
       document.getElementById("auto-ping-enabled").addEventListener("change", (e) => {
        autoPingEnabled = e.target.checked;
        PAGE_STATE.autoPingEnabled = autoPingEnabled;
        document.getElementById("auto-ping-settings").style.display = autoPingEnabled ? 'block' : 'none';
        
        if (autoPingEnabled) {
         startAutoPing();
        } else {
         stopAutoPing();
        }
       });
       
       document.getElementById("auto-ping-interval").addEventListener("change", (e) => {
        const newInterval = parseInt(e.target.value, 10);
        if (newInterval >= 5 && newInterval <= 3600) {
         autoPingInterval = newInterval;
         PAGE_STATE.autoPingInterval = autoPingInterval;
         
         if (autoPingEnabled) {
          startAutoPing();
         }
        }
       });
       
       document.getElementById("export-data-btn").addEventListener("click", () => {
        const data = captureTheQuickening();
        const jsonStr = JSON.stringify(data, null, 2);
        const blob = new Blob([jsonStr], {
         type: "application/json"
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        const safeTitle = (PAGE_STATE.title || "network-topology").toLowerCase().replace(/[^a-z0-9\-]+/g, "-");
        const timestamp = new Date().toISOString().split("T")[0];
        a.download = `${safeTitle}-data-${timestamp}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
       });
       document.getElementById("import-data-btn").addEventListener("click", () => {
        document.getElementById("import-data-file").click();
       });
       document.getElementById("import-data-file").addEventListener("change", async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        try {
         const text = await file.text();
         const data = JSON.parse(text);
         if (!data.nodeData || !data.edgeData) {
          alert("Invalid data file. Missing required fields.");
          return;
         }
         const confirmMsg = `This will replace all current data with the imported data.\n\nImporting:\n- ${Object.keys(data.nodeData).length} nodes\n- ${data.edgeData.list?.length || 0} connections\n\nContinue?`;
         if (!confirm(confirmMsg)) {
          e.target.value = "";
          return;
         }
         NODE_DATA = data.nodeData || {};
         EDGE_DATA = data.edgeData || {
          list: []
         };
         EDGE_LEGEND = data.edgeLegend || {};
         RECT_DATA = data.rectData || { list: [] };
         TEXT_DATA = data.textData || { list: [] };
         savedPositions = data.nodePositions || {};
         savedSizes = data.nodeSizes || {};
         savedStyles = data.nodeStyles || {};
         if (data.page) {
          PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, data.page, );
          wieldThePower();
         }
      
      if (data.autoPingEnabled !== undefined) {
      autoPingEnabled = data.autoPingEnabled;
      PAGE_STATE.autoPingEnabled = autoPingEnabled;
      document.getElementById("auto-ping-enabled").checked = autoPingEnabled;
      }
      
      if (data.autoPingInterval !== undefined) {
      autoPingInterval = data.autoPingInterval;
      PAGE_STATE.autoPingInterval = autoPingInterval;
      document.getElementById("auto-ping-interval").value = autoPingInterval;
      }
         if (data.canvas) {
          canvasState.zoom = data.canvas.zoom || 1;
          canvasState.panX = data.canvas.panX || 0;
          canvasState.panY = data.canvas.panY || 0;
         }
         if (data.page?.title) {
          document.title = data.page.title;
          document.querySelector(".editable-page-title", ).textContent = data.page.title;
         }
         forgeTheTopology();
         forgeTheLegend();
         updateViewBox();
      
      if (autoPingEnabled) {
      startAutoPing();
      } else {
      stopAutoPing();
      }
      
         const nodeIds = Object.keys(NODE_DATA);
         if (nodeIds.length > 0) {
          claimTheImmortal(nodeIds[0]);
         } else {
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("topology-toolbar").style.display = "none";
         }
         alert("Data imported successfully!");
         e.target.value = "";
        } catch (err) {
         console.error("Import error:", err);
         alert(`Failed to import data: ${err.message}`);
         e.target.value = "";
        }
       });
       const saveHelpBtn = document.getElementById("save-help-btn");
       const saveInfoModal = document.getElementById("save-info-modal");
       const saveInfoClose = document.getElementById("save-info-close");
       saveHelpBtn.addEventListener("click", () => {
        saveInfoModal.classList.add("active");
       });
       saveInfoClose.addEventListener("click", () => {
        saveInfoModal.classList.remove("active");
       });
       saveInfoModal.addEventListener("click", (e) => {
        if (e.target === saveInfoModal) {
         saveInfoModal.classList.remove("active");
        }
       });
       async function deriveKey(password, salt) {
      const encoder = new TextEncoder();
      
      const keyMaterial = await crypto.subtle.importKey(
      "raw",
      encoder.encode(password),
      "PBKDF2",
      false,
      ["deriveKey"]
      );
      
      return crypto.subtle.deriveKey(
      {
      name: "PBKDF2",
      salt: salt,
      iterations: 200000,  
      hash: "SHA-256"
      },
      keyMaterial,
      {
      name: "AES-GCM",
      length: 256
      },
      false,
      ["encrypt", "decrypt"]
      );
      }
      
       async function encryptData(data, password) {
      const encoder = new TextEncoder();
      const salt = crypto.getRandomValues(new Uint8Array(16));
      const iv   = crypto.getRandomValues(new Uint8Array(12));
      
      const key = await deriveKey(password, salt);
      const encrypted = await crypto.subtle.encrypt(
      { name: "AES-GCM", iv },
      key,
      encoder.encode(data)
      );
      
      const encryptedU8 = new Uint8Array(encrypted);
      
      const result = new Uint8Array(salt.length + iv.length + encryptedU8.length);
      result.set(salt, 0);
      result.set(iv, salt.length);
      result.set(encryptedU8, salt.length + iv.length);
      
      return "ENCRYPTED:" + u8ToBase64(result);
      }
      
       async function decryptData(encryptedData, password) {
      const base64Data = encryptedData.replace("ENCRYPTED:", "");
      const fullData   = base64ToU8(base64Data);
      
      const salt      = fullData.slice(0, 16);
      const iv        = fullData.slice(16, 28);
      const encrypted = fullData.slice(28);
      
      const key = await deriveKey(password, salt);
      
      const decrypted = await crypto.subtle.decrypt(
      { name: "AES-GCM", iv },
      key,
      encrypted
      );
      
      const decoder = new TextDecoder();
      return decoder.decode(decrypted);
      }
      
      
       function isEncrypted(data) {
        return typeof data === "string" && data.startsWith("ENCRYPTED:");
       }
      
       function captureTheQuickening() {
      const currentTab = documentTabs[currentTabIndex];
      currentTab.nodes = JSON.parse(JSON.stringify(NODE_DATA));
      currentTab.edges = JSON.parse(JSON.stringify(EDGE_DATA));
      currentTab.positions = JSON.parse(JSON.stringify(savedPositions));
      currentTab.sizes = JSON.parse(JSON.stringify(savedSizes));
      currentTab.styles = JSON.parse(JSON.stringify(savedStyles));
      currentTab.legend = JSON.parse(JSON.stringify(EDGE_LEGEND));
      currentTab.rects = JSON.parse(JSON.stringify(RECT_DATA));
      currentTab.texts = JSON.parse(JSON.stringify(TEXT_DATA));
      currentTab.pageState = JSON.parse(JSON.stringify(PAGE_STATE));
       
      return {
      nodeData: NODE_DATA,
       edgeData: EDGE_DATA,
       rectData: RECT_DATA,
       textData: TEXT_DATA,
       edgeLegend: EDGE_LEGEND,
       nodePositions: savedPositions,
       nodeSizes: savedSizes,
       nodeStyles: savedStyles,
       iconCache: IconLibrary.iconCache,
      
       page: PAGE_STATE,
      
       autoPingEnabled: autoPingEnabled,
       autoPingInterval: autoPingInterval,
      
       canvas: {
         zoom: canvasState.zoom,
         panX: canvasState.panX,
         panY: canvasState.panY,
       },
       
       savedTopologyView: savedTopologyView,
       
       documentTabs: documentTabs,
       currentTabIndex: currentTabIndex,
       encryptedSections: encryptedSections,
      };
      }
      
       function assembleTheImmortalForm() {
        const clone = document.documentElement.cloneNode(true);
        const nodeScript = clone.querySelector("#nodes-json");
        if (nodeScript) {
         nodeScript.textContent = JSON.stringify(NODE_DATA, null, 2);
        }
        let stateScript = clone.querySelector("#topology-state");
        if (!stateScript) {
         stateScript = document.createElement("script");
         stateScript.id = "topology-state";
         stateScript.type = "application/json";
         const body = clone.querySelector("body") || clone;
         body.appendChild(stateScript);
        }
        stateScript.textContent = JSON.stringify(captureTheQuickening(), null, 2, );
        return " <!DOCTYPE html> \n " + clone.outerHTML;
       }
       async function becomeImmortal() {
        const encryptEnabled = document.getElementById("encrypt-toggle").checked;
        let stateData = JSON.stringify(captureTheQuickening(), null, 2);
        if (encryptEnabled) {
         const password = prompt("Enter a password to encrypt your data:\n(Remember this password! You will need it to open this file and its non recoverable!)", );
         if (!password) {
          alert("Encryption cancelled. File not saved.");
          return;
         }
         const confirmPassword = prompt("Confirm your password:");
         if (password !== confirmPassword) {
          alert("Passwords do not match. File not saved.");
          return;
         }
         try {
          stateData = await encryptData(stateData, password);
         } catch (e) {
          alert("Encryption failed: " + e.message);
          return;
         }
        }
        const clone = document.documentElement.cloneNode(true);
        const nodeScript = clone.querySelector("#nodes-json");
        if (nodeScript) {
         if (encryptEnabled) {
          nodeScript.textContent = JSON.stringify({}, null, 2);
         } else {
          nodeScript.textContent = JSON.stringify(NODE_DATA, null, 2);
         }
        }
        let stateScript = clone.querySelector("#topology-state");
        if (!stateScript) {
         stateScript = document.createElement("script");
         stateScript.id = "topology-state";
         stateScript.type = "application/json";
         const body = clone.querySelector("body") || clone;
         body.appendChild(stateScript);
        }
        stateScript.textContent = stateData;
        const html = "<!DOCTYPE html> \n " + clone.outerHTML;
        const blob = new Blob([html], {
         type: "text/html"
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        const safeTitle = (PAGE_STATE.title || document.title || "network-topology").toLowerCase().replace(/[^a-z0-9\-]+/g, "-");
        a.download = safeTitle + ".html";
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        saveRollbackVersion("Manual save");
       }
       
      function captureState() {
      return {
        nodes: JSON.parse(JSON.stringify(NODE_DATA)),
        edges: JSON.parse(JSON.stringify(EDGE_DATA)),
        positions: JSON.parse(JSON.stringify(savedPositions)),
        sizes: JSON.parse(JSON.stringify(savedSizes)),
        styles: JSON.parse(JSON.stringify(savedStyles)),
        legend: JSON.parse(JSON.stringify(EDGE_LEGEND)),
        rects: JSON.parse(JSON.stringify(RECT_DATA)),
        texts: JSON.parse(JSON.stringify(TEXT_DATA))
        };
      }
      
      function pushUndo(action = "") {
       const state = captureState();
       undoStack.push(state);
       if (undoStack.length > MAX_UNDO_STACK) {
        undoStack.shift();
       }
       redoStack = [];
       updateUndoButtons();
      }
      
      function undo() {
       if (undoStack.length === 0) return;
       const currentState = captureState();
       redoStack.push(currentState);
       const previousState = undoStack.pop();
       restoreState(previousState);
       updateUndoButtons();
      }
      
      function redo() {
       if (redoStack.length === 0) return;
       const currentState = captureState();
       undoStack.push(currentState);
       const nextState = redoStack.pop();
       restoreState(nextState);
       updateUndoButtons();
      }
      
      function restoreState(state) {
      NODE_DATA = state.nodes;
       EDGE_DATA = state.edges;
       savedPositions = state.positions;
       savedSizes = state.sizes;
       savedStyles = state.styles;
       EDGE_LEGEND = state.legend;
       RECT_DATA = state.rects || { list: [] };
       TEXT_DATA = state.texts || { list: [] };
       forgeTheTopology();
       if (currentNodeId && NODE_DATA[currentNodeId]) {
       claimTheImmortal(currentNodeId);
       } else if (currentEdgeId) {
       selectTheConnection(currentEdgeId);
       }
      }
      
      function updateUndoButtons() {
       const undoBtn = document.getElementById("undo-btn");
       const redoBtn = document.getElementById("redo-btn");
       if (undoBtn) {
        undoBtn.disabled = undoStack.length === 0;
        undoBtn.style.opacity = undoStack.length === 0 ? "0.5" : "1";
       }
       if (redoBtn) {
        redoBtn.disabled = redoStack.length === 0;
        redoBtn.style.opacity = redoStack.length === 0 ? "0.5" : "1";
       }
      }
      
      function selectNode(nodeId, addToSelection = false) {
       if (!addToSelection) {
        selectedNodes.clear();
       }
       selectedNodes.add(nodeId);
       updateNodeSelection();
      }
      
      function clearSelection() {
       selectedNodes.clear();
       updateNodeSelection();
       clearSearchHighlight();
      }
      
      function updateNodeSelection() {
       document.querySelectorAll(".node-group").forEach(node => {
        const nodeId = node.dataset.nodeId;
        if (selectedNodes.has(nodeId)) {
         node.classList.add("selected");
        } else {
         node.classList.remove("selected");
        }
       });
       
       const bulkToolbar = document.getElementById("bulk-toolbar");
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       const bulkCount = document.getElementById("bulk-count");
       const bulkCountMobile = document.getElementById("bulk-count-mobile");
       const bulkCountModal = document.getElementById("bulk-count-modal");
       
       if (selectedNodes.size > 0) {
        if (bulkToolbar) bulkToolbar.style.display = "flex";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
        if (bulkCount) bulkCount.textContent = selectedNodes.size;
        if (bulkCountMobile) bulkCountMobile.textContent = selectedNodes.size;
        if (bulkCountModal) bulkCountModal.textContent = selectedNodes.size;
       } else {
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        const modal = document.getElementById("bulk-actions-modal");
        if (modal) modal.style.display = "none";
       }
      }
      
      function deleteSelected() {
       if (selectedNodes.size === 0) return;
       const count = selectedNodes.size;
       challengeTheImmortal(`Delete ${count} selected node${count > 1 ? 's' : ''}?`, () => {
        pushUndo("delete selected");
        selectedNodes.forEach(nodeId => {
         delete NODE_DATA[nodeId];
         delete savedPositions[nodeId];
         delete savedSizes[nodeId];
         delete savedStyles[nodeId];
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== nodeId && e.to !== nodeId);
        });
        selectedNodes.clear();
        saveEdgeData();
        forgeTheTopology();
        if (currentNodeId && !NODE_DATA[currentNodeId]) {
         currentNodeId = null;
         document.getElementById("node-panel").style.display = "none";
        }
        updateNodeSelection();
       });
      }
      
      function startSelection(event) {
       const svgEl = document.getElementById("map");
       const pt = svgEl.createSVGPoint();
       pt.x = event.clientX;
       pt.y = event.clientY;
       const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
       
       isSelecting = true;
       selectionStart = { x: svgP.x, y: svgP.y };
       
       if (!selectionRect) {
        selectionRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        selectionRect.setAttribute("fill", "rgba(79, 209, 197, 0.1)");
        selectionRect.setAttribute("stroke", "#4fd1c5");
        selectionRect.setAttribute("stroke-width", "2");
        selectionRect.setAttribute("stroke-dasharray", "5,5");
        selectionRect.style.pointerEvents = "none";
        svgEl.appendChild(selectionRect);
       }
       
       if (!event.shiftKey) {
        selectedNodes.clear();
       }
      }
      
      function updateSelection(event) {
       if (!isSelecting || !selectionStart) return;
       
       const svgEl = document.getElementById("map");
       const pt = svgEl.createSVGPoint();
       pt.x = event.clientX;
       pt.y = event.clientY;
       const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
       
       const x = Math.min(selectionStart.x, svgP.x);
       const y = Math.min(selectionStart.y, svgP.y);
       const width = Math.abs(svgP.x - selectionStart.x);
       const height = Math.abs(svgP.y - selectionStart.y);
       
       selectionRect.setAttribute("x", x);
       selectionRect.setAttribute("y", y);
       selectionRect.setAttribute("width", width);
       selectionRect.setAttribute("height", height);
       selectionRect.style.display = "block";
       
       document.querySelectorAll(".node-group").forEach(node => {
        const nodeId = node.dataset.nodeId;
        const pos = savedPositions[nodeId];
        if (pos && pos.x >= x && pos.x <= x + width && pos.y >= y && pos.y <= y + height) {
         selectedNodes.add(nodeId);
        } else if (!event.shiftKey) {
         selectedNodes.delete(nodeId);
        }
       });
       
       updateNodeSelection();
      }
      
      function endSelection() {
       isSelecting = false;
       selectionStart = null;
       if (selectionRect) {
        selectionRect.style.display = "none";
       }
      }
      
      function cloneNode(sourceId) {
       const source = NODE_DATA[sourceId];
       if (!source) return;
       
       pushUndo("clone node");
       
       let baseName = source.name;
       let copyNum = 0;
       let newName = baseName + " copy";
       while (Object.values(NODE_DATA).some(n => n.name === newName)) {
        copyNum++;
        newName = baseName + " copy " + copyNum;
       }
       
       const newId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
       
       NODE_DATA[newId] = {
        shape: source.shape,
        name: newName,
        ip: source.ip,
        role: source.role,
        tags: [...source.tags],
        notes: [...source.notes],
        mac: source.mac || "",
        rackUnit: source.rackUnit || "",
        uHeight: source.uHeight || "1",
        ping: source.ping ? JSON.parse(JSON.stringify(source.ping)) : {
         enabled: false,
         protocol: 'http',
         customUrl: '',
         timeout: 3000,
         status: 'unknown',
         lastCheck: null
        }
       };
       
       if (savedSizes[sourceId]) {
        savedSizes[newId] = savedSizes[sourceId];
       }
       
       if (savedStyles[sourceId]) {
        savedStyles[newId] = JSON.parse(JSON.stringify(savedStyles[sourceId]));
       }
       
       const sourcePos = savedPositions[sourceId];
       savedPositions[newId] = {
        x: sourcePos.x + 100,
        y: sourcePos.y + 100
       };
       
       forgeTheTopology();
       claimTheImmortal(newId);
      }
      
      function alignSelectedNodes(direction) {
       if (selectedNodes.size < 2) return;
       
       pushUndo("align nodes");
       
       const nodeIds = Array.from(selectedNodes);
       const positions = nodeIds.map(id => ({ id, pos: savedPositions[id] }));
       
       switch(direction) {
        case "left":
         const minX = Math.min(...positions.map(p => p.pos.x));
         positions.forEach(p => savedPositions[p.id].x = minX);
         break;
        case "right":
         const maxX = Math.max(...positions.map(p => p.pos.x));
         positions.forEach(p => savedPositions[p.id].x = maxX);
         break;
        case "top":
         const minY = Math.min(...positions.map(p => p.pos.y));
         positions.forEach(p => savedPositions[p.id].y = minY);
         break;
        case "bottom":
         const maxY = Math.max(...positions.map(p => p.pos.y));
         positions.forEach(p => savedPositions[p.id].y = maxY);
         break;
        case "center-h":
         const avgX = positions.reduce((sum, p) => sum + p.pos.x, 0) / positions.length;
         positions.forEach(p => savedPositions[p.id].x = avgX);
         break;
        case "center-v":
         const avgY = positions.reduce((sum, p) => sum + p.pos.y, 0) / positions.length;
         positions.forEach(p => savedPositions[p.id].y = avgY);
         break;
       }
       
       forgeTheTopology();
      }
      
      function distributeSelectedNodes(direction) {
       if (selectedNodes.size < 3) return;
       
       pushUndo("distribute nodes");
       
       const nodeIds = Array.from(selectedNodes);
       const positions = nodeIds.map(id => ({ id, pos: savedPositions[id] }));
       
       if (direction === "horizontal") {
        positions.sort((a, b) => a.pos.x - b.pos.x);
        const minX = positions[0].pos.x;
        const maxX = positions[positions.length - 1].pos.x;
        const gap = (maxX - minX) / (positions.length - 1);
        positions.forEach((p, i) => {
         savedPositions[p.id].x = minX + (gap * i);
        });
       } else if (direction === "vertical") {
        positions.sort((a, b) => a.pos.y - b.pos.y);
        const minY = positions[0].pos.y;
        const maxY = positions[positions.length - 1].pos.y;
        const gap = (maxY - minY) / (positions.length - 1);
        positions.forEach((p, i) => {
         savedPositions[p.id].y = minY + (gap * i);
        });
       }
       
       forgeTheTopology();
      }
      
      function snapToGrid(nodeId, gridSize = 50) {
       if (!savedPositions[nodeId]) return;
       
       pushUndo("snap to grid");
       
       const pos = savedPositions[nodeId];
       pos.x = Math.round(pos.x / gridSize) * gridSize;
       pos.y = Math.round(pos.y / gridSize) * gridSize;
       
       forgeTheTopology();
      }
      
      function nudgeSelectedNodes(direction, distance) {
        const nodesToNudge = selectedNodes.size > 0 
          ? Array.from(selectedNodes) 
          : (currentNodeId ? [currentNodeId] : []);
        
        if (nodesToNudge.length === 0) return;
        
        const unlockedNodes = nodesToNudge.filter(id => !NODE_DATA[id]?.locked);
        
        if (unlockedNodes.length === 0) {
          return;
        }
        
        pushUndo("nudge nodes");
        
        unlockedNodes.forEach(id => {
          if (!savedPositions[id]) {
            savedPositions[id] = { x: 0, y: 0 };
          }
          
          switch(direction) {
            case "ArrowUp":
              savedPositions[id].y -= distance;
              break;
            case "ArrowDown":
              savedPositions[id].y += distance;
              break;
            case "ArrowLeft":
              savedPositions[id].x -= distance;
              break;
            case "ArrowRight":
              savedPositions[id].x += distance;
              break;
          }
        });
        
        forgeTheTopology();
      }
      
      function cycleNodes(reverse = false) {
        const nodeIds = Object.keys(NODE_DATA).filter(id => {
          if (currentView.mode === "rack" && currentView.rackId) {
            return NODE_DATA[id].assignedRack === currentView.rackId;
          }
          return !NODE_DATA[id].assignedRack;
        });
        
        if (nodeIds.length === 0) return;
        
        let currentIndex = nodeIds.indexOf(currentNodeId);
        
        if (reverse) {
          currentIndex = currentIndex <= 0 ? nodeIds.length - 1 : currentIndex - 1;
        } else {
          currentIndex = currentIndex >= nodeIds.length - 1 ? 0 : currentIndex + 1;
        }
        
        const nextNodeId = nodeIds[currentIndex];
        claimTheImmortal(nextNodeId);
        
        selectedNodes.clear();
        updateNodeSelection();
      }
      
      function focusOnSelected() {
        const nodesToFocus = selectedNodes.size > 0 
          ? Array.from(selectedNodes) 
          : (currentNodeId ? [currentNodeId] : []);
        
        if (nodesToFocus.length === 0) return;
        
        let minX = Infinity, minY = Infinity;
        let maxX = -Infinity, maxY = -Infinity;
        
        nodesToFocus.forEach(id => {
          const pos = savedPositions[id];
          if (pos) {
            const size = savedSizes[id] || 50;
            minX = Math.min(minX, pos.x - size/2);
            minY = Math.min(minY, pos.y - size/2);
            maxX = Math.max(maxX, pos.x + size/2);
            maxY = Math.max(maxY, pos.y + size/2);
          }
        });
        
        if (!isFinite(minX)) return;
        
        const padding = 100;
        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;
        const width = maxX - minX + padding * 2;
        const height = maxY - minY + padding * 2;
        
        const zoomX = CANVAS_WIDTH / width;
        const zoomY = CANVAS_HEIGHT / height;
        const targetZoom = Math.min(zoomX, zoomY, 2);
        
        canvasState.zoom = targetZoom;
        canvasState.panX = centerX - (CANVAS_WIDTH / targetZoom) / 2;
        canvasState.panY = centerY - (CANVAS_HEIGHT / targetZoom) / 2;
        
        forgeTheTopology();
      }
      
      function toggleLockSelected() {
        const nodesToToggle = selectedNodes.size > 0 
          ? Array.from(selectedNodes) 
          : (currentNodeId ? [currentNodeId] : []);
        
        if (nodesToToggle.length === 0) return;
        
        pushUndo("toggle lock");
        
        const hasUnlocked = nodesToToggle.some(id => !NODE_DATA[id]?.locked);
        
        nodesToToggle.forEach(id => {
          if (NODE_DATA[id]) {
            NODE_DATA[id].locked = hasUnlocked;
          }
        });
        
        forgeTheTopology();
      
        const lockState = hasUnlocked ? "locked" : "unlocked";
      }
      
      function toggleGroupSelected() {
        const nodesToGroup = Array.from(selectedNodes);
        if (nodesToGroup.length < 2) {
          return;
        }
        
        pushUndo("toggle group");
        
        const groupIds = nodesToGroup.map(id => NODE_DATA[id]?.groupId).filter(g => g !== null && g !== undefined);
        const uniqueGroups = [...new Set(groupIds)];
        
        if (uniqueGroups.length === 1 && groupIds.length === nodesToGroup.length) {
          nodesToGroup.forEach(id => {
            if (NODE_DATA[id]) {
              NODE_DATA[id].groupId = null;
            }
          });
        } else {
          const newGroupId = "group-" + Date.now();
          nodesToGroup.forEach(id => {
            if (NODE_DATA[id]) {
              NODE_DATA[id].groupId = newGroupId;
            }
          });
        }
        
        forgeTheTopology();
      }
      
      function handleKeyDown(event) {
       if (event.target.tagName === "INPUT" || event.target.tagName === "TEXTAREA" || event.target.isContentEditable) {
        return;
       }
      
       if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(event.key)) {
        event.preventDefault();
        const distance = event.shiftKey ? 10 : 1;
        nudgeSelectedNodes(event.key, distance);
       }
       
       if (event.key === "Tab") {
        event.preventDefault();
        cycleNodes(event.shiftKey);
       }
       
       if (event.key === "f" || event.key === "F") {
        event.preventDefault();
        focusOnSelected();
       }
       
       if (event.key === "l" || event.key === "L") {
        event.preventDefault();
        toggleLockSelected();
       }
       
       if (event.key === "g" || event.key === "G") {
        event.preventDefault();
        toggleGroupSelected();
       }
       
       if (event.ctrlKey && event.key === "z" && !event.shiftKey) {
        event.preventDefault();
        undo();
       }
       
       if ((event.ctrlKey && event.key === "y") || (event.ctrlKey && event.shiftKey && event.key === "z")) {
        event.preventDefault();
        redo();
       }
       
       if (event.ctrlKey && event.key === "c" && currentNodeId) {
        event.preventDefault();
        const node = NODE_DATA[currentNodeId];
        if (node) {
         clipboard = {
          type: "node",
          data: JSON.parse(JSON.stringify(node)),
          size: savedSizes[currentNodeId],
          style: savedStyles[currentNodeId] ? JSON.parse(JSON.stringify(savedStyles[currentNodeId])) : null
         };
        }
       }
       
       if (event.ctrlKey && event.key === "v" && clipboard && clipboard.type === "node") {
        event.preventDefault();
        pushUndo("paste node");
        
        let baseName = clipboard.data.name;
        let copyNum = 0;
        let newName = baseName + " copy";
        while (Object.values(NODE_DATA).some(n => n.name === newName)) {
         copyNum++;
         newName = baseName + " copy " + copyNum;
        }
        
        const newId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
        NODE_DATA[newId] = JSON.parse(JSON.stringify(clipboard.data));
        NODE_DATA[newId].name = newName;
        
        if (clipboard.size) savedSizes[newId] = clipboard.size;
        if (clipboard.style) savedStyles[newId] = JSON.parse(JSON.stringify(clipboard.style));
        
        const svgEl = document.getElementById("map");
        const rect = svgEl.getBoundingClientRect();
        const pt = svgEl.createSVGPoint();
        pt.x = rect.left + rect.width / 2;
        pt.y = rect.top + rect.height / 2;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        savedPositions[newId] = { x: svgP.x, y: svgP.y };
        
        forgeTheTopology();
        claimTheImmortal(newId);
       }
       
       if (event.ctrlKey && event.key === "d" && currentNodeId) {
        event.preventDefault();
        cloneNode(currentNodeId);
       }
       
       if (event.key === "Delete") {
        event.preventDefault();
        if (selectedNodes.size > 0) {
         deleteSelected();
        } else if (currentNodeId && NODE_DATA[currentNodeId]) {
         challengeTheImmortal(`Delete node "${NODE_DATA[currentNodeId].name}"?`, () => {
          pushUndo("delete node");
          delete NODE_DATA[currentNodeId];
          delete savedPositions[currentNodeId];
          delete savedSizes[currentNodeId];
          delete savedStyles[currentNodeId];
          EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== currentNodeId && e.to !== currentNodeId);
          saveEdgeData();
          forgeTheTopology();
          currentNodeId = null;
          document.getElementById("node-panel").style.display = "none";
         });
        } else if (currentEdgeId) {
         const edge = EDGE_DATA.list.find(e => e.id === currentEdgeId);
         if (edge) {
          challengeTheImmortal("Delete this line?", () => {
           pushUndo("delete edge");
           EDGE_DATA.list = EDGE_DATA.list.filter(e => e.id !== currentEdgeId);
           saveEdgeData();
           forgeTheTopology();
           currentEdgeId = null;
           document.getElementById("edge-panel").style.display = "none";
          });
         }
        }
       }
       
       if (event.ctrlKey && event.key === "a") {
        event.preventDefault();
        selectedNodes.clear();
        Object.keys(NODE_DATA).forEach(id => selectedNodes.add(id));
        updateNodeSelection();
       }
       
       if (event.key === "Escape") {
        clearSelection();
       }
      }
      
      function searchNodes(query) {
       clearSearchHighlight();
       
       if (!query || query.trim() === "") return;
       
       const lowerQuery = query.toLowerCase();
       const matchingIds = [];
       
       Object.entries(NODE_DATA).forEach(([id, node]) => {
        const searchableText = [
         node.name,
         node.ip,
         node.role,
         ...(node.tags || []),
         node.mac || "",
         node.rackUnit || ""
        ].join(" ").toLowerCase();
        
        if (searchableText.includes(lowerQuery)) {
         matchingIds.push(id);
        }
       });
       
       highlightSearchResults(matchingIds);
      }
      
      function highlightSearchResults(nodeIds) {
       clearSearchHighlight();
       nodeIds.forEach(id => {
        const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`);
        if (nodeGroup) {
         nodeGroup.classList.add("search-highlight");
        }
       });
      }
      
      function clearSearchHighlight() {
       document.querySelectorAll(".node-group").forEach(node => {
        node.classList.remove("search-highlight");
       });
      }
      
      function editNodeMac(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       
       document.getElementById("modal-title").textContent = "Edit MAC Address";
       document.getElementById("modal-input").value = node.mac || "";
       document.getElementById("edit-modal").style.display = "flex";
       document.getElementById("modal-input").focus();
       
       const saveHandler = () => {
        pushUndo("edit mac");
        const value = document.getElementById("modal-input").value.trim();
        node.mac = value;
        document.getElementById("edit-modal").style.display = "none";
        claimTheImmortal(id);
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       
       const cancelHandler = () => {
        document.getElementById("edit-modal").style.display = "none";
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       
       document.getElementById("edit-modal").addEventListener("click", function bgHandler(e) {
        if (e.target === document.getElementById("edit-modal")) {
         cancelHandler();
         document.getElementById("edit-modal").removeEventListener("click", bgHandler);
        }
       });
      }
      
      function editNodeRack(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       
       document.getElementById("modal-title").textContent = "Edit Rack Unit";
       document.getElementById("modal-input").value = node.rackUnit || "";
       document.getElementById("edit-modal").style.display = "flex";
       document.getElementById("modal-input").focus();
       
       const saveHandler = () => {
        pushUndo("edit rack");
        const value = document.getElementById("modal-input").value.trim();
        node.rackUnit = value;
        document.getElementById("edit-modal").style.display = "none";
        claimTheImmortal(id);
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       
       const cancelHandler = () => {
        document.getElementById("edit-modal").style.display = "none";
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       
       document.getElementById("edit-modal").addEventListener("click", function bgHandler(e) {
        if (e.target === document.getElementById("edit-modal")) {
         cancelHandler();
         document.getElementById("edit-modal").removeEventListener("click", bgHandler);
        }
       });
      }
      
      function editNodeUHeight(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       
       document.getElementById("modal-title").textContent = "Edit U Height";
       document.getElementById("modal-input").value = node.uHeight || "1";
       document.getElementById("edit-modal").style.display = "flex";
       document.getElementById("modal-input").focus();
       
       const saveHandler = () => {
        pushUndo("edit U height");
        const value = document.getElementById("modal-input").value.trim();
        node.uHeight = value;
        document.getElementById("edit-modal").style.display = "none";
        claimTheImmortal(id);
        forgeTheTopology();
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       
       const cancelHandler = () => {
        document.getElementById("edit-modal").style.display = "none";
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       
       document.getElementById("edit-modal").addEventListener("click", function bgHandler(e) {
        if (e.target === document.getElementById("edit-modal")) {
         cancelHandler();
         document.getElementById("edit-modal").removeEventListener("click", bgHandler);
        }
       });
      }
      
      function updateEdgePortLabels(edgeId) {
       const edge = EDGE_DATA.list.find(e => e.id === edgeId);
       if (!edge) return;
       
       const fromPortInput = document.getElementById("edge-from-port");
       const toPortInput = document.getElementById("edge-to-port");
       
       edge.fromPort = fromPortInput ? fromPortInput.value.trim() : "";
       edge.toPort = toPortInput ? toPortInput.value.trim() : "";
       
       saveEdgeData();
       forgeTheTopology();
      }
      
      document.addEventListener("keydown", handleKeyDown);
      
      const undoBtn = document.getElementById("undo-btn");
      const redoBtn = document.getElementById("redo-btn");
      if (undoBtn) undoBtn.addEventListener("click", undo);
      if (redoBtn) redoBtn.addEventListener("click", redo);
      
      const backToTopologyBtn = document.getElementById("back-to-topology-btn");
      if (backToTopologyBtn) {
       backToTopologyBtn.addEventListener("click", exitRack);
      }
      
      const bulkToolbarClose = document.getElementById("bulk-toolbar-close");
      if (bulkToolbarClose) {
       bulkToolbarClose.addEventListener("click", clearSelection);
      }
      
      const bulkAlignLeft = document.getElementById("bulk-align-left");
      if (bulkAlignLeft) {
       bulkAlignLeft.addEventListener("click", () => alignSelectedNodes("left"));
      }
      
      const bulkAlignRight = document.getElementById("bulk-align-right");
      if (bulkAlignRight) {
       bulkAlignRight.addEventListener("click", () => alignSelectedNodes("right"));
      }
      
      const bulkAlignTop = document.getElementById("bulk-align-top");
      if (bulkAlignTop) {
       bulkAlignTop.addEventListener("click", () => alignSelectedNodes("top"));
      }
      
      const bulkAlignBottom = document.getElementById("bulk-align-bottom");
      if (bulkAlignBottom) {
       bulkAlignBottom.addEventListener("click", () => alignSelectedNodes("bottom"));
      }
      
      const bulkDistributeH = document.getElementById("bulk-distribute-h");
      if (bulkDistributeH) {
       bulkDistributeH.addEventListener("click", () => distributeSelectedNodes("horizontal"));
      }
      
      const bulkDistributeV = document.getElementById("bulk-distribute-v");
      if (bulkDistributeV) {
       bulkDistributeV.addEventListener("click", () => distributeSelectedNodes("vertical"));
      }
      
      const bulkClone = document.getElementById("bulk-clone");
      if (bulkClone) {
       bulkClone.addEventListener("click", () => {
        if (selectedNodes.size === 0) return;
        pushUndo("clone selected");
        const nodesToClone = Array.from(selectedNodes);
        selectedNodes.clear();
        nodesToClone.forEach(id => {
         cloneNode(id);
         selectedNodes.add(currentNodeId);
        });
        updateNodeSelection();
       });
      }
      
      const bulkDelete = document.getElementById("bulk-delete");
      if (bulkDelete) {
       bulkDelete.addEventListener("click", deleteSelected);
      }
      
      const bulkMobileBtn = document.getElementById("bulk-mobile-btn");
      const bulkActionsModal = document.getElementById("bulk-actions-modal");
      const bulkModalClose = document.getElementById("bulk-modal-close");
      
      if (bulkMobileBtn) {
       bulkMobileBtn.addEventListener("click", () => {
        if (bulkActionsModal) bulkActionsModal.style.display = "block";
       });
      }
      
      if (bulkModalClose) {
       bulkModalClose.addEventListener("click", () => {
        if (bulkActionsModal) bulkActionsModal.style.display = "none";
       });
      }
      
      const closeModalAfterAction = () => {
       if (bulkActionsModal) bulkActionsModal.style.display = "none";
      };
      
      const bulkAlignLeftMobile = document.getElementById("bulk-align-left-mobile");
      if (bulkAlignLeftMobile) {
       bulkAlignLeftMobile.addEventListener("click", () => {
        alignSelectedNodes("left");
        closeModalAfterAction();
       });
      }
      
      const bulkAlignRightMobile = document.getElementById("bulk-align-right-mobile");
      if (bulkAlignRightMobile) {
       bulkAlignRightMobile.addEventListener("click", () => {
        alignSelectedNodes("right");
        closeModalAfterAction();
       });
      }
      
      const bulkAlignTopMobile = document.getElementById("bulk-align-top-mobile");
      if (bulkAlignTopMobile) {
       bulkAlignTopMobile.addEventListener("click", () => {
        alignSelectedNodes("top");
        closeModalAfterAction();
       });
      }
      
      const bulkAlignBottomMobile = document.getElementById("bulk-align-bottom-mobile");
      if (bulkAlignBottomMobile) {
       bulkAlignBottomMobile.addEventListener("click", () => {
        alignSelectedNodes("bottom");
        closeModalAfterAction();
       });
      }
      
      const bulkDistributeHMobile = document.getElementById("bulk-distribute-h-mobile");
      if (bulkDistributeHMobile) {
       bulkDistributeHMobile.addEventListener("click", () => {
        distributeSelectedNodes("horizontal");
        closeModalAfterAction();
       });
      }
      
      const bulkDistributeVMobile = document.getElementById("bulk-distribute-v-mobile");
      if (bulkDistributeVMobile) {
       bulkDistributeVMobile.addEventListener("click", () => {
        distributeSelectedNodes("vertical");
        closeModalAfterAction();
       });
      }
      
      const bulkCloneMobile = document.getElementById("bulk-clone-mobile");
      if (bulkCloneMobile) {
       bulkCloneMobile.addEventListener("click", () => {
        if (selectedNodes.size === 0) return;
        pushUndo("clone selected");
        const nodesToClone = Array.from(selectedNodes);
        selectedNodes.clear();
        nodesToClone.forEach(id => {
         cloneNode(id);
         selectedNodes.add(currentNodeId);
        });
        updateNodeSelection();
        closeModalAfterAction();
       });
      }
      
      const bulkDeleteMobile = document.getElementById("bulk-delete-mobile");
      if (bulkDeleteMobile) {
       bulkDeleteMobile.addEventListener("click", () => {
        deleteSelected();
        closeModalAfterAction();
       });
      }
      
      const bulkLockMobile = document.getElementById("bulk-lock-mobile");
      if (bulkLockMobile) {
       bulkLockMobile.addEventListener("click", () => {
        toggleLockSelected();
        closeModalAfterAction();
       });
      }
      
      const bulkGroupMobile = document.getElementById("bulk-group-mobile");
      if (bulkGroupMobile) {
       bulkGroupMobile.addEventListener("click", () => {
        toggleGroupSelected();
        closeModalAfterAction();
       });
      }
      
      const bulkClearMobile = document.getElementById("bulk-clear-mobile");
      if (bulkClearMobile) {
       bulkClearMobile.addEventListener("click", () => {
        clearSelection();
        closeModalAfterAction();
       });
      }
      
      const searchInput = document.getElementById("search-input");
      if (searchInput) {
       searchInput.addEventListener("input", (e) => {
        searchNodes(e.target.value);
       });
      }
      
       document.getElementById("save-file-btn").addEventListener("click", becomeImmortal);
       document.getElementById("check-all-ping-btn").addEventListener("click", checkAllNodesStatus);
       const addNodeBtn = document.getElementById("add-node-btn");
       const addNodeModal = document.getElementById("add-node-modal");
       const addNodeCancel = document.getElementById("add-node-cancel");
       const addNodeSave = document.getElementById("add-node-save");
       addNodeBtn.addEventListener("click", () => {
        document.getElementById("new-node-name").value = "";
        document.getElementById("new-node-ip").value = "";
        document.getElementById("new-node-tags").value = "";
        document.getElementById("new-node-shape").value = "circle";
        document.getElementById("new-node-pingable").checked = false;
        document.getElementById("new-node-ping-protocol").value = "http";
        document.getElementById("new-node-custom-url").value = "";
        document.getElementById("new-node-ping-timeout").value = "3000";
        document.getElementById("new-node-ping-options").style.display = "none";
        document.getElementById("new-node-custom-url-container").style.display = "none";
        newNodeIconTags = [];
        document.getElementById("new-node-icon-tags").style.display = "none";
        document.getElementById("new-node-icon-tags-list").innerHTML = "";
        addNodeModal.classList.add("active");
        document.getElementById("new-node-name").focus();
       });
       
       const canvasViewport = document.getElementById("canvas-viewport");
       if (canvasViewport) {
        canvasViewport.addEventListener("dblclick", (e) => {
         if (currentView.mode === "rack" && e.target.id === "map") {
          exitRack();
         }
        });
       }
       
       const layersBtn = document.getElementById("layers-btn");
       const layerModal = document.getElementById("layer-modal");
       const layerModalClose = document.getElementById("layer-modal-close");
       if (layersBtn && layerModal) {
        layersBtn.addEventListener("click", () => {
         layerModal.classList.add("active");
        });
       }
       if (layerModalClose && layerModal) {
        layerModalClose.addEventListener("click", () => {
         layerModal.classList.remove("active");
        });
       }
       if (layerModal) {
        layerModal.addEventListener("click", (e) => {
         if (e.target === layerModal) {
          layerModal.classList.remove("active");
         }
        });
       }
      
       const tabsBtn = document.getElementById("tabs-btn");
       const tabsModal = document.getElementById("tabs-modal");
       const tabsModalClose = document.getElementById("tabs-modal-close");
       if (tabsBtn && tabsModal) {
         tabsBtn.addEventListener("click", () => {
           displayTabs();
           tabsModal.classList.add("active");
         });
       }
       if (tabsModalClose && tabsModal) {
         tabsModalClose.addEventListener("click", () => {
           tabsModal.classList.remove("active");
         });
       }
       if (tabsModal) {
         tabsModal.addEventListener("click", (e) => {
           if (e.target === tabsModal) {
             tabsModal.classList.remove("active");
           }
         });
       }
       
       const rollbackBtn = document.getElementById("rollback-btn");
       const rollbackModal = document.getElementById("rollback-modal");
       const rollbackModalClose = document.getElementById("rollback-modal-close");
       if (rollbackBtn && rollbackModal) {
         rollbackBtn.addEventListener("click", () => {
           loadRollbackVersions();
           rollbackModal.classList.add("active");
         });
       }
       if (rollbackModalClose && rollbackModal) {
         rollbackModalClose.addEventListener("click", () => {
           rollbackModal.classList.remove("active");
         });
       }
       if (rollbackModal) {
         rollbackModal.addEventListener("click", (e) => {
           if (e.target === rollbackModal) {
             rollbackModal.classList.remove("active");
           }
         });
       }
       
       const auditLogBtn = document.getElementById("audit-log-btn");
       const auditLogModal = document.getElementById("audit-log-modal");
       const auditLogModalClose = document.getElementById("audit-log-modal-close");
       if (auditLogBtn && auditLogModal) {
         auditLogBtn.addEventListener("click", () => {
           loadAuditLog();
           displayAuditLog();
           auditLogModal.classList.add("active");
         });
       }
       if (auditLogModalClose && auditLogModal) {
         auditLogModalClose.addEventListener("click", () => {
           auditLogModal.classList.remove("active");
         });
       }
       if (auditLogModal) {
         auditLogModal.addEventListener("click", (e) => {
           if (e.target === auditLogModal) {
             auditLogModal.classList.remove("active");
           }
         });
       }
      
       const auditFilter = document.getElementById("audit-filter");
       if (auditFilter) {
         auditFilter.addEventListener("change", (e) => {
           displayAuditLog(e.target.value);
         });
       }
       
       const secretsBtn = document.getElementById("secrets-btn");
       const secretsModal = document.getElementById("secrets-modal");
       const secretsModalClose = document.getElementById("secrets-modal-close");
       if (secretsBtn && secretsModal) {
         secretsBtn.addEventListener("click", () => {
           displaySecrets();
           secretsModal.classList.add("active");
         });
       }
       if (secretsModalClose && secretsModal) {
         secretsModalClose.addEventListener("click", () => {
           secretsModal.classList.remove("active");
         });
       }
       if (secretsModal) {
         secretsModal.addEventListener("click", (e) => {
           if (e.target === secretsModal) {
             secretsModal.classList.remove("active");
           }
         });
       }
       
       const secretEditorModal = document.getElementById("secret-editor-modal");
       if (secretEditorModal) {
         secretEditorModal.addEventListener("click", (e) => {
           if (e.target === secretEditorModal) {
             closeSecretEditor();
           }
         });
       }
       
       ["physical", "logical", "security", "application"].forEach(layer => {
        const checkbox = document.getElementById(`layer-${layer}`);
        if (checkbox) {
         checkbox.addEventListener("change", applyLayerFilter);
        }
       });
       
       const layerSelect = document.getElementById("node-layer");
       if (layerSelect) {
        layerSelect.addEventListener("change", (e) => {
         if (currentNodeId) {
          pushUndo("change layer");
          NODE_DATA[currentNodeId].layer = e.target.value;
          forgeTheTopology();
         }
        });
       }
       
       const assignedRackSelect = document.getElementById("node-assigned-rack");
       if (assignedRackSelect) {
        assignedRackSelect.addEventListener("change", (e) => {
      if (currentNodeId) {
      pushUndo("change assigned rack");
      EDGE_DATA.list = EDGE_DATA.list.filter(edge => edge.from !== currentNodeId && edge.to !== currentNodeId);
      NODE_DATA[currentNodeId].assignedRack = e.target.value;
      forgeTheTopology();
      claimTheImmortal(currentNodeId);
      }
      });
       }
       
       const rackCapacitySelect = document.getElementById("node-rack-capacity");
       if (rackCapacitySelect) {
        rackCapacitySelect.addEventListener("change", (e) => {
         if (currentNodeId) {
          pushUndo("change rack capacity");
          NODE_DATA[currentNodeId].rackCapacity = e.target.value;
          forgeTheTopology();
         }
        });
       }
       
       const addRackBtn = document.getElementById("add-rack-btn");
       const addRackModal = document.getElementById("add-rack-modal");
       const addRackCancel = document.getElementById("add-rack-cancel");
       const addRackSave = document.getElementById("add-rack-save");
       
       if (addRackBtn && addRackModal) {
        addRackBtn.addEventListener("click", () => {
         document.getElementById("new-rack-name").value = "";
         document.getElementById("new-rack-ip").value = "";
         document.getElementById("new-rack-tags").value = "";
         document.getElementById("new-rack-shape").value = "server";
         document.getElementById("new-rack-capacity").value = "42";
         selectedRackIconData = null;
         document.getElementById('selected-rack-icon').style.display = 'none';
         addRackModal.classList.add("active");
         document.getElementById("new-rack-name").focus();
        });
       }
       
       if (addRackCancel && addRackModal) {
        addRackCancel.addEventListener("click", () => {
         addRackModal.classList.remove("active");
        });
       }
       
       if (addRackModal) {
        addRackModal.addEventListener("click", (e) => {
         if (e.target === addRackModal) {
          addRackModal.classList.remove("active");
         }
        });
       }
       
       if (addRackSave && addRackModal) {
        addRackSave.addEventListener("click", () => {
         const name = document.getElementById("new-rack-name").value.trim();
         const ip = document.getElementById("new-rack-ip").value.trim();
         const tagsStr = document.getElementById("new-rack-tags").value.trim();
         const shape = document.getElementById("new-rack-shape").value;
         const capacity = document.getElementById("new-rack-capacity").value;
         
         if (!name) {
          alert("Please enter a rack name.");
          return;
         }
         
         const tags = tagsStr ? tagsStr.split(",").map((t) => t.trim()).filter((t) => t) : [];
         let baseId = name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");
         if (!baseId) baseId = "rack";
         let nodeId = baseId;
         let counter = 1;
         while (NODE_DATA[nodeId]) {
          nodeId = baseId + "-" + counter;
          counter++;
         }
         
         pushUndo("add rack");
         
         NODE_DATA[nodeId] = {
          shape: shape,
          name: name,
          ip: ip || "",
          role: "Rack",
          tags: tags,
          notes: [],
          mac: "",
          rackUnit: "",
          uHeight: "1",
          layer: "physical",
          assignedRack: "",
          rackCapacity: capacity,
          isRack: true,
          locked: false,
          groupId: null
         };
         
         const viewWidth = CANVAS_WIDTH / canvasState.zoom;
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         const centerX = canvasState.panX + (viewWidth / 2);
         const centerY = canvasState.panY + (viewHeight / 2);
         savedPositions[nodeId] = {
          x: centerX,
          y: centerY
         };
         
         if (selectedRackIconData) {
          if (!savedStyles[nodeId]) {
           savedStyles[nodeId] = {};
          }
          if (!savedStyles[nodeId]['all']) {
           savedStyles[nodeId]['all'] = {};
          }
          savedStyles[nodeId]['all'].icon = {
           library: selectedRackIconData.library,
           name: selectedRackIconData.name
          };
          selectedRackIconData = null;
          document.getElementById('selected-rack-icon').style.display = 'none';
         }
         
         addRackModal.classList.remove("active");
         forgeTheTopology();
         claimTheImmortal(nodeId);
        });
        
        ["new-rack-name", "new-rack-ip", "new-rack-tags"].forEach((inputId) => {
         const input = document.getElementById(inputId);
         if (input) {
          input.addEventListener("keypress", (e) => {
           if (e.key === "Enter") {
            addRackSave.click();
           }
          });
         }
        });
       }
       
       addNodeCancel.addEventListener("click", () => {
        addNodeModal.classList.remove("active");
       });
       addNodeModal.addEventListener("click", (e) => {
        if (e.target === addNodeModal) {
         addNodeModal.classList.remove("active");
        }
       });
       addNodeSave.addEventListener("click", () => {
        const name = document.getElementById("new-node-name").value.trim();
        const ip = document.getElementById("new-node-ip").value.trim();
        const tagsStr = document.getElementById("new-node-tags").value.trim();
        const shape = document.getElementById("new-node-shape").value;
        const pingable = document.getElementById("new-node-pingable").checked;
        const pingProtocol = document.getElementById("new-node-ping-protocol").value;
        const pingCustomUrl = document.getElementById("new-node-custom-url").value.trim();
        const pingTimeout = parseInt(document.getElementById("new-node-ping-timeout").value) || 3000;
        
        if (!name) {
         alert("Please enter a node name.");
         return;
        }
        const tags = tagsStr ? tagsStr.split(",").map((t) => t.trim()).filter((t) => t) : [];
        if (newNodeIconTags.length > 0) {
         tags.push(...newNodeIconTags);
        }
        let baseId = name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");
        if (!baseId) baseId = "node";
        let nodeId = baseId;
        let counter = 1;
        while (NODE_DATA[nodeId]) {
         nodeId = baseId + "-" + counter;
         counter++;
        }
        NODE_DATA[nodeId] = {
         shape: shape || "circle",
         name: name,
         ip: ip || "0.0.0.0",
         role: "",
         tags: tags,
         notes: [],
         mac: "",
         rackUnit: "",
         uHeight: "1",
         ping: {
          enabled: pingable,
          protocol: pingProtocol,
          customUrl: pingCustomUrl,
          timeout: pingTimeout,
          status: 'unknown',
          lastCheck: null
         },
         locked: false, 
         groupId: null 
        };
        
        if (currentView.mode === "rack" && currentView.rackId) {
         NODE_DATA[nodeId].assignedRack = currentView.rackId;
         NODE_DATA[nodeId].layer = "physical";
        }
        
        if (selectedNodeIconData) {
         if (!savedStyles[nodeId]) savedStyles[nodeId] = {};
         if (!savedStyles[nodeId]['all']) savedStyles[nodeId]['all'] = {};
         savedStyles[nodeId]['all'].icon = {
          library: selectedNodeIconData.library,
          name: selectedNodeIconData.name
         };
         selectedNodeIconData = null;
         document.getElementById('selected-node-icon').style.display = 'none';
        }
        newNodeIconTags = [];
      const viewWidth = CANVAS_WIDTH / canvasState.zoom;
      const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
      const centerX = canvasState.panX + (viewWidth / 2);
      const centerY = canvasState.panY + (viewHeight / 2);
      savedPositions[nodeId] = {
      x: centerX,
      y: centerY
      };
        addNodeModal.classList.remove("active");
        forgeTheTopology();
        claimTheImmortal(nodeId);
       });
       ["new-node-name", "new-node-ip", "new-node-tags"].forEach(
        (inputId) => {
         document.getElementById(inputId).addEventListener("keypress", (e) => {
          if (e.key === "Enter") {
           addNodeSave.click();
          }
         });
        }, );
       
       document.getElementById('new-node-pingable').addEventListener('change', (e) => {
        const pingOptions = document.getElementById('new-node-ping-options');
        pingOptions.style.display = e.target.checked ? 'block' : 'none';
       });
       
       document.getElementById('new-node-ping-protocol').addEventListener('change', (e) => {
        const customUrlContainer = document.getElementById('new-node-custom-url-container');
        customUrlContainer.style.display = e.target.value === 'custom' ? 'block' : 'none';
       });
       
       document.getElementById('pick-rack-icon-btn').addEventListener('click', () => {
        openIconPicker((iconData) => {
         selectedRackIconData = iconData;
         const preview = document.getElementById('selected-rack-icon-preview');
         const container = document.getElementById('selected-rack-icon');
         const parser = new DOMParser();
         const doc = parser.parseFromString(iconData.svg, 'image/svg+xml');
         const svgEl = doc.querySelector('svg');
         preview.innerHTML = '';
         if (svgEl) {
          preview.appendChild(svgEl.cloneNode(true));
         }
         const nameSpan = document.createElement('span');
         nameSpan.textContent = iconData.name;
         preview.appendChild(nameSpan);
         container.style.display = 'block';
        });
       });
       
       document.getElementById('pick-node-icon-btn').addEventListener('click', () => {
        openIconPicker((iconData) => {
         selectedNodeIconData = iconData;
         const preview = document.getElementById('selected-node-icon-preview');
         const container = document.getElementById('selected-node-icon');
         const parser = new DOMParser();
         const doc = parser.parseFromString(iconData.svg, 'image/svg+xml');
         const svgEl = doc.querySelector('svg');
         preview.innerHTML = '';
         if (svgEl) {
          preview.appendChild(svgEl.cloneNode(true));
         }
         const nameSpan = document.createElement('span');
         nameSpan.textContent = iconData.name;
         preview.appendChild(nameSpan);
         container.style.display = 'block';
        });
       });
       document.getElementById('pick-tag-icon-btn').addEventListener('click', () => {
        if (!currentNodeId) return;
        openIconPicker((iconData) => {
         if (!currentNodeId || !NODE_DATA[currentNodeId]) return;
         if (!NODE_DATA[currentNodeId].tags) {
          NODE_DATA[currentNodeId].tags = [];
         }
         NODE_DATA[currentNodeId].tags.push({
          type: 'icon',
          library: iconData.library,
          name: iconData.name
         });
         forgeTheTopology();
         claimTheImmortal(currentNodeId);
        });
       });
       document.getElementById('pick-new-node-tag-icon-btn').addEventListener('click', () => {
        openIconPicker((iconData) => {
         newNodeIconTags.push({
          type: 'icon',
          library: iconData.library,
          name: iconData.name
         });
         const container = document.getElementById('new-node-icon-tags');
         const list = document.getElementById('new-node-icon-tags-list');
         const badge = document.createElement('div');
         badge.className = 'icon-badge';
         badge.style.cssText = 'display: inline-flex; align-items: center; gap: 6px; padding: 6px 10px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; font-size: 13px;';
         const iconPreview = document.createElement('div');
         iconPreview.style.cssText = 'width: 16px; height: 16px; display: flex; align-items: center; justify-content: center;';
         IconLibrary.getIcon(iconData.library, iconData.name).then(svg => {
          if (svg) {
           const parser = new DOMParser();
           const doc = parser.parseFromString(svg, 'image/svg+xml');
           const svgEl = doc.querySelector('svg');
           if (svgEl) {
            svgEl.setAttribute('width', '16');
            svgEl.setAttribute('height', '16');
            svgEl.style.fill = 'var(--text-main)';
            iconPreview.appendChild(svgEl);
           }
          }
         });
         const name = document.createElement('span');
         name.textContent = iconData.name;
         name.style.color = 'var(--text-soft)';
         const removeBtn = document.createElement('button');
         removeBtn.textContent = '√ó';
         removeBtn.style.cssText = 'background: none; border: none; color: var(--danger); cursor: pointer; font-size: 18px; line-height: 1; padding: 0 4px;';
         removeBtn.addEventListener('click', () => {
          const index = newNodeIconTags.findIndex(t => t.type === 'icon' && t.library === iconData.library && t.name === iconData.name);
          if (index > -1) {
           newNodeIconTags.splice(index, 1);
          }
          badge.remove();
          if (list.children.length === 0) {
           container.style.display = 'none';
          }
         });
         badge.appendChild(iconPreview);
         badge.appendChild(name);
         badge.appendChild(removeBtn);
         list.appendChild(badge);
         container.style.display = 'block';
        });
       });
       document.getElementById('pick-shape-icon-btn').addEventListener('click', () => {
        if (!currentNodeId) return;
        openIconPicker((iconData) => {
         if (!savedStyles[currentNodeId]) {
          savedStyles[currentNodeId] = {};
         }
         if (!savedStyles[currentNodeId][currentStyleScope]) {
          savedStyles[currentNodeId][currentStyleScope] = {};
         }
         savedStyles[currentNodeId][currentStyleScope].icon = {
          library: iconData.library,
          name: iconData.name
         };
         forgeTheTopology();
        });
       });
       document.getElementById('add-tag-btn').addEventListener('click', () => {
        if (!currentNodeId) return;
        if (!NODE_DATA[currentNodeId]) return;
        const input = document.getElementById('new-tag-input');
        const tagText = input.value.trim();
        if (!tagText) return;
        if (!NODE_DATA[currentNodeId].tags) {
         NODE_DATA[currentNodeId].tags = [];
        }
        NODE_DATA[currentNodeId].tags.push(tagText);
        input.value = '';
        forgeTheTopology();
        claimTheImmortal(currentNodeId);
       });
      
      function saveRollbackVersion(description = "Auto-save") {
        const version = {
          timestamp: Date.now(),
          description,
          data: captureTheQuickening()
        };
        
        try {
          const stored = localStorage.getItem(ROLLBACK_STORAGE_KEY);
          rollbackVersions = stored ? JSON.parse(stored) : [];
        } catch (e) {
          rollbackVersions = [];
        }
        
        rollbackVersions.unshift(version);
        
        if (rollbackVersions.length > MAX_ROLLBACK_VERSIONS) {
          rollbackVersions = rollbackVersions.slice(0, MAX_ROLLBACK_VERSIONS);
        }
        
        try {
          localStorage.setItem(ROLLBACK_STORAGE_KEY, JSON.stringify(rollbackVersions));
        } catch (e) {
          console.warn("Failed to save rollback version:", e);
        }
      }
      
      function loadRollbackVersions() {
        try {
          const stored = localStorage.getItem(ROLLBACK_STORAGE_KEY);
          rollbackVersions = stored ? JSON.parse(stored) : [];
          displayRollbackVersions();
        } catch (e) {
          console.warn("Failed to load rollback versions:", e);
          rollbackVersions = [];
        }
      }
      
      function displayRollbackVersions() {
        const listEl = document.getElementById("rollback-list");
        if (!listEl) return;
        
        if (rollbackVersions.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No version history yet. Versions are saved automatically when you save the file.</div>';
          return;
        }
        
        listEl.innerHTML = rollbackVersions.map((version, index) => {
          const date = new Date(version.timestamp);
          const timeStr = date.toLocaleString();
          const nodeCount = Object.keys(version.data.nodeData || {}).length;
          const edgeCount = (version.data.edgeData?.list || []).length;
          
          return `
            <div class="version-item" onclick="restoreRollbackVersion(${index})">
              <div class="version-info">
                <div class="timestamp">${timeStr}</div>
                <div class="details">${version.description} ‚Ä¢ ${nodeCount} nodes ‚Ä¢ ${edgeCount} connections</div>
              </div>
              <div class="version-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteRollbackVersion(${index})" title="Delete this version">üóëÔ∏è</button>
              </div>
            </div>
          `;
        }).join('');
      }
      
      function restoreRollbackVersion(index) {
        if (!confirm(`Restore version from ${new Date(rollbackVersions[index].timestamp).toLocaleString()}?\n\nYour current work will be lost unless you save first.`)) {
          return;
        }
        
        const version = rollbackVersions[index];
        const data = version.data;
        
        NODE_DATA = data.nodeData || {};
        EDGE_DATA = data.edgeData || { list: [] };
        RECT_DATA = data.rectData || { list: [] };
        TEXT_DATA = data.textData || { list: [] };
        EDGE_LEGEND = data.edgeLegend || {};
        savedPositions = data.nodePositions || {};
        savedSizes = data.nodeSizes || {};
        savedStyles = data.nodeStyles || {};
        PAGE_STATE = data.page || PAGE_STATE;
        
        if (data.canvas) {
          canvasState.zoom = data.canvas.zoom;
          canvasState.panX = data.canvas.panX;
          canvasState.panY = data.canvas.panY;
        }
        
        wieldThePower();
        forgeTheTopology();
        
        document.getElementById("rollback-modal").classList.remove("active");
        
        logAuditEvent("rollback", `Restored version from ${new Date(version.timestamp).toLocaleString()}`);
      }
      
      function deleteRollbackVersion(index) {
        if (!confirm("Delete this version from history?")) return;
        
        rollbackVersions.splice(index, 1);
        try {
          localStorage.setItem(ROLLBACK_STORAGE_KEY, JSON.stringify(rollbackVersions));
        } catch (e) {
          console.warn("Failed to delete version:", e);
        }
        displayRollbackVersions();
      }
      
      function clearRollbackHistory() {
        if (!confirm("Clear all version history?\n\nThis cannot be undone.")) return;
        
        rollbackVersions = [];
        localStorage.removeItem(ROLLBACK_STORAGE_KEY);
        displayRollbackVersions();
      }
      
      function createManualSnapshot() {
        const description = prompt("Enter a description for this snapshot:", "Manual snapshot");
        if (!description) return;
        
        saveRollbackVersion(description);
        displayRollbackVersions();
      }
      
      function switchTab(index) {
        if (index === currentTabIndex) return;
        
        const currentTab = documentTabs[currentTabIndex];
        currentTab.nodes = JSON.parse(JSON.stringify(NODE_DATA));
        currentTab.edges = JSON.parse(JSON.stringify(EDGE_DATA));
        currentTab.positions = JSON.parse(JSON.stringify(savedPositions));
        currentTab.sizes = JSON.parse(JSON.stringify(savedSizes));
        currentTab.styles = JSON.parse(JSON.stringify(savedStyles));
        currentTab.legend = JSON.parse(JSON.stringify(EDGE_LEGEND));
        currentTab.rects = JSON.parse(JSON.stringify(RECT_DATA));
        currentTab.texts = JSON.parse(JSON.stringify(TEXT_DATA));
        currentTab.pageState = JSON.parse(JSON.stringify(PAGE_STATE));

        currentTabIndex = index;
        const newTab = documentTabs[index];
        NODE_DATA = JSON.parse(JSON.stringify(newTab.nodes));
        EDGE_DATA = JSON.parse(JSON.stringify(newTab.edges));
        savedPositions = JSON.parse(JSON.stringify(newTab.positions));
        savedSizes = JSON.parse(JSON.stringify(newTab.sizes));
        savedStyles = JSON.parse(JSON.stringify(newTab.styles));
        EDGE_LEGEND = JSON.parse(JSON.stringify(newTab.legend));
        RECT_DATA = JSON.parse(JSON.stringify(newTab.rects));
        TEXT_DATA = JSON.parse(JSON.stringify(newTab.texts));
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, newTab.pageState || {});
        wieldThePower();
        document.title = newTab.name;
        document.getElementById("page-title").textContent = newTab.name;
        forgeTheTopology();
        displayTabs();
        
        logAuditEvent("tab", `Switched to tab: ${newTab.name}`);
      }
      
      function createNewTab() {
        const nameInput = document.getElementById("new-tab-name");
        const name = nameInput.value.trim();
        
        if (!name) {
          alert("Please enter a tab name");
          return;
        }
        
        const newTab = {
          id: `tab-${Date.now()}`,
          name,
          nodes: {},
          edges: { list: [] },
          positions: {},
          sizes: {},
          styles: {},
          legend: {},
          rects: { list: [] },
          texts: { list: [] },
		  pageState: null
        };
        
        documentTabs.push(newTab);
        nameInput.value = "";
        displayTabs();
        
        logAuditEvent("tab", `Created new tab: ${name}`);
      }
      
      function renameTab(index) {
        const tab = documentTabs[index];
        const newName = prompt("Enter new name:", tab.name);
        if (!newName || newName === tab.name) return;
        
        tab.name = newName;
        displayTabs();
        
        logAuditEvent("tab", `Renamed tab to: ${newName}`);
      }
      
      function deleteTab(index) {
        if (documentTabs.length === 1) {
          alert("Cannot delete the last tab");
          return;
        }
        
        if (!confirm(`Delete tab "${documentTabs[index].name}"?`)) return;
        
        documentTabs.splice(index, 1);
        
        if (currentTabIndex >= documentTabs.length) {
          currentTabIndex = documentTabs.length - 1;
        }
        
        if (currentTabIndex === index) {
          switchTab(currentTabIndex);
        }
        
        displayTabs();
      }
      
      function displayTabs() {
        const listEl = document.getElementById("tabs-list");
        if (!listEl) return;
        
        listEl.innerHTML = documentTabs.map((tab, index) => {
          const nodeCount = Object.keys(tab.nodes).length;
          const edgeCount = tab.edges.list.length;
          const isActive = index === currentTabIndex;
          
          return `
            <div class="tab-item ${isActive ? 'active' : ''}" onclick="switchTab(${index})">
              <div class="tab-name">${tab.name}</div>
              <div class="tab-stats">${nodeCount} nodes ‚Ä¢ ${edgeCount} connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(${index})" title="Rename tab">‚úèÔ∏è</button>
                ${documentTabs.length > 1 ? '<button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(${index})" title="Delete tab">üóëÔ∏è</button>' : ''}
              </div>
            </div>
          `;
        }).join('');
      }
      
      function logAuditEvent(type, description, details = {}) {
        const event = {
          timestamp: Date.now(),
          type,
          description,
          details,
          tab: documentTabs[currentTabIndex]?.name || "Main"
        };
        
        auditLog.unshift(event);
        
        if (auditLog.length > MAX_AUDIT_ENTRIES) {
          auditLog = auditLog.slice(0, MAX_AUDIT_ENTRIES);
        }
        
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to save audit log:", e);
        }
      }
      
      function loadAuditLog() {
        try {
          const stored = localStorage.getItem(AUDIT_STORAGE_KEY);
          auditLog = stored ? JSON.parse(stored) : [];
        } catch (e) {
          console.warn("Failed to load audit log:", e);
          auditLog = [];
        }
      }
      
      function displayAuditLog(filter = "all") {
        const listEl = document.getElementById("audit-log-list");
        if (!listEl) return;
        
        const filtered = filter === "all" ? auditLog : auditLog.filter(e => e.type === filter);
        
        if (filtered.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No audit entries yet</div>';
          return;
        }
        
        listEl.innerHTML = filtered.map(event => {
          const date = new Date(event.timestamp);
          const timeStr = date.toLocaleString();
          
          return `<div class="audit-entry ${event.type}">
              <div class="time">[${timeStr}] ${event.tab}</div>
              <div class="action">[${event.type.toUpperCase()}] ${event.description}</div>
            </div>
          `;
        }).join('');
      }
      
      function clearAuditLog() {
        if (!confirm("Clear all audit log entries?\n\nThis cannot be undone.")) return;
        
        auditLog = [];
        localStorage.removeItem(AUDIT_STORAGE_KEY);
        displayAuditLog();
      }
      
      function exportAuditLog() {
        if (auditLog.length === 0) {
          alert("No audit entries to export");
          return;
        }
        
        const csv = [
          ["Timestamp", "Tab", "Type", "Description"],
          ...auditLog.map(e => [
            new Date(e.timestamp).toISOString(),
            e.tab,
            e.type,
            e.description
          ])
        ].map(row => row.map(cell => `"${cell}"`).join(",")).join("\n");
        
        const blob = new Blob([csv], { type: "text/csv" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `audit-log-${Date.now()}.csv`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }
      
      let currentSecretName = null;
      
      function createNewSecret() {
        const nameInput = document.getElementById("new-secret-name");
        const name = nameInput.value.trim();
        
        if (!name) {
          alert("Please enter a note name");
          return;
        }
        
        if (encryptedSections[name]) {
          alert("A note note with this name already exists");
          return;
        }
        
        currentSecretName = name;
        encryptedSections[name] = { encrypted: false, data: "" };
        nameInput.value = "";
        
        document.getElementById("secret-editor-title").textContent = `New note: ${name}`;
        document.getElementById("secret-editor-content").value = "";
        document.getElementById("secrets-modal").classList.remove("active");
        document.getElementById("secret-editor-modal").classList.add("active");
        
        displaySecrets();
      }
      
      function editSecret(name) {
        currentSecretName = name;
        const section = encryptedSections[name];
        
        if (section.encrypted) {
          const password = prompt(`Enter password to decrypt "${name}":`);
          if (!password) return;
          
          try {
            decryptData(section.data, password).then(decrypted => {
              document.getElementById("secret-editor-title").textContent = `Edit Secret: ${name}`;
              document.getElementById("secret-editor-content").value = decrypted;
              document.getElementById("secrets-modal").classList.remove("active");
              document.getElementById("secret-editor-modal").classList.add("active");
            }).catch(e => {
              alert("Failed to decrypt. Wrong password?");
            });
          } catch (e) {
            alert("Failed to decrypt. Wrong password?");
          }
        } else {
          document.getElementById("secret-editor-title").textContent = `Edit note: ${name}`;
          document.getElementById("secret-editor-content").value = section.data;
          document.getElementById("secrets-modal").classList.remove("active");
          document.getElementById("secret-editor-modal").classList.add("active");
        }
      }
      
      async function saveSecret() {
        if (!currentSecretName) return;
        
        const content = document.getElementById("secret-editor-content").value;
        const autoEncrypt = document.getElementById("secret-auto-encrypt").checked;
        
        if (autoEncrypt) {
          const password = prompt(`Enter password to encrypt "${currentSecretName}":`);
          if (!password) return;
          
          const confirmPassword = prompt("Confirm password:");
          if (password !== confirmPassword) {
            alert("Passwords do not match");
            return;
          }
          
          try {
            const encrypted = await encryptData(content, password);
            encryptedSections[currentSecretName] = { encrypted: true, data: encrypted };
          } catch (e) {
            alert("Encryption failed: " + e.message);
            return;
          }
        } else {
          encryptedSections[currentSecretName] = { encrypted: false, data: content };
        }
        
        closeSecretEditor();
        displaySecrets();
        
        logAuditEvent("secret", `Saved note section: ${currentSecretName}`);
      }
      
      function closeSecretEditor() {
        document.getElementById("secret-editor-modal").classList.remove("active");
        document.getElementById("secrets-modal").classList.add("active");
        currentSecretName = null;
      }
      
      function deleteSecret(name) {
        if (!confirm(`Delete note "${name}"?`)) return;
        
        delete encryptedSections[name];
        displaySecrets();
        
        logAuditEvent("secret", `Deleted note: ${name}`);
      }
      
      function displaySecrets() {
        const listEl = document.getElementById("secrets-list");
        if (!listEl) return;
        
        const secrets = Object.keys(encryptedSections);
        
        if (secrets.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No notes yet</div>';
          return;
        }
        
        listEl.innerHTML = secrets.map(name => {
          const section = encryptedSections[name];
          const status = section.encrypted ? "üîí Encrypted" : "üîì Plaintext";
          
          return `
            <div class="secret-item">
              <div class="secret-name">${name}</div>
              <div class="secret-status">${status}</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="editSecret('${name}')" title="Edit note">‚úèÔ∏è</button>
                <button class="btn-cancel" onclick="deleteSecret('${name}')" title="Delete note">üóëÔ∏è</button>
              </div>
            </div>
          `;
        }).join('');
      }
      
       const clearAllBtn = document.getElementById("clear-all-btn");
       const clearAllModal = document.getElementById("clear-all-modal");
       const clearAllCancel = document.getElementById("clear-all-cancel");
       const clearAllConfirm = document.getElementById("clear-all-confirm");
       clearAllBtn.addEventListener("click", () => {
        clearAllModal.classList.add("active");
       });
       clearAllCancel.addEventListener("click", () => {
        clearAllModal.classList.remove("active");
       });
       clearAllModal.addEventListener("click", (e) => {
        if (e.target === clearAllModal) {
         clearAllModal.classList.remove("active");
        }
       });
       clearAllConfirm.addEventListener("click", () => {
        NODE_DATA = {};
        EDGE_DATA = {
         list: []
        };
        EDGE_LEGEND = {};
        RECT_DATA = { list: [] };
        TEXT_DATA = { list: [] };
        savedPositions = {};
        savedSizes = {};
        savedStyles = {};
        clearAllModal.classList.remove("active");
      
      autoPingEnabled = false;
      autoPingInterval = 30;
      PAGE_STATE.autoPingEnabled = false;
      PAGE_STATE.autoPingInterval = autoPingInterval;
      
      stopAutoPing();
      
      document.getElementById("auto-ping-enabled").checked = false;
      document.getElementById("auto-ping-settings").style.display = "none";
      document.getElementById("auto-ping-interval").value = autoPingInterval;
        forgeTheTopology();
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.display = "none";
        currentNodeId = null;
        currentEdgeId = null;
        currentTextId = null;
       });
       (function addDeleteNodeButton() {
        const nodePanel = document.getElementById("node-panel");
        if (!nodePanel) return;
        if (document.getElementById("delete-node-btn")) return;
        const deleteBtn = document.createElement("button");
        deleteBtn.id = "delete-node-btn";
        deleteBtn.textContent = "Delete Node";
        deleteBtn.style.cssText = "margin-top:15px; padding:10px 16px; background:var(--danger); color:#fff; border:none; border-radius:6px; cursor:pointer; font-size:clamp(14px,1.6vw,18px); font-weight:600; width:100%;";
        deleteBtn.addEventListener("click", () => {
         if (!currentNodeId) return;
         challengeTheImmortal(`Delete node "${NODE_DATA[currentNodeId]?.name || currentNodeId}" and all its connections?`,
          () => {
           EDGE_DATA.list = EDGE_DATA.list.filter(
            (e) => e.from !== currentNodeId && e.to !== currentNodeId, );
           delete NODE_DATA[currentNodeId];
           delete savedPositions[currentNodeId];
           delete savedSizes[currentNodeId];
           delete savedStyles[currentNodeId];
           currentNodeId = null;
           currentEdgeId = null;
           forgeTheTopology();
           const remainingNodes = Object.keys(NODE_DATA);
           if (remainingNodes.length > 0) {
            claimTheImmortal(remainingNodes[0]);
           } else {
            document.getElementById("node-panel").style.display = "none";
            document.getElementById("edge-panel").style.display = "none";
            document.getElementById("topology-toolbar", ).style.display = "none";
           }
          }, );
        });
        nodePanel.appendChild(deleteBtn);
       })();
      
       function screenshotCanvas() {
        const svg = document.getElementById("map");
        const svgClone = svg.cloneNode(true);
        const viewBox = svg.getAttribute("viewBox").split(" ").map(Number);
        const [x, y, width, height] = viewBox;
        svgClone.setAttribute("width", width);
        svgClone.setAttribute("height", height);
        svgClone.setAttribute("viewBox", `${x} ${y} ${width} ${height}`);
        const wrapper = document.createElement("div");
        wrapper.style.position = "absolute";
        wrapper.style.left = "-9999px";
        wrapper.appendChild(svgClone);
        document.body.appendChild(wrapper);
      
        function inlineStyles(original, clone) {
         const elements = original.querySelectorAll("*");
         const clonedElements = clone.querySelectorAll("*");
         const rootStyles = getComputedStyle(document.documentElement);
         const bgColor = rootStyles.getPropertyValue("--bg").trim() || "#050608";
         const bgRect = document.createElementNS("http://www.w3.org/2000/svg", "rect", );
         bgRect.setAttribute("x", x);
         bgRect.setAttribute("y", y);
         bgRect.setAttribute("width", width);
         bgRect.setAttribute("height", height);
         bgRect.setAttribute("fill", bgColor);
         clone.insertBefore(bgRect, clone.firstChild);
         elements.forEach((el, index) => {
          const clonedEl = clonedElements[index];
          if (!clonedEl) return;
          const computedStyle = getComputedStyle(el);
          const svgProps = ["fill", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin", "opacity", "font-family", "font-size", "font-weight", "font-style", "text-anchor", "dominant-baseline", "marker-start", "marker-end", ];
          svgProps.forEach((prop) => {
           const value = computedStyle.getPropertyValue(prop);
           if (value && value !== "none" && value !== "normal") {
            clonedEl.style[prop] = value;
           }
          });
          clonedEl.removeAttribute("class");
         });
        }
        inlineStyles(svg, svgClone);
        const svgData = new XMLSerializer().serializeToString(svgClone);
        document.body.removeChild(wrapper);
        const svgBlob = new Blob([svgData], {
         type: "image/svg+xml;charset=utf-8",
        });
        const url = URL.createObjectURL(svgBlob);
        const img = new Image();
        img.onload = function() {
         const canvas = document.createElement("canvas");
         canvas.width = width;
         canvas.height = height;
         const ctx = canvas.getContext("2d");
         ctx.drawImage(img, 0, 0);
         canvas.toBlob(function(blob) {
          const link = document.createElement("a");
          const timestamp = new Date().toISOString().slice(0, 10);
          link.download = `topology-${timestamp}.png`;
          link.href = URL.createObjectURL(blob);
          link.click();
          URL.revokeObjectURL(url);
          URL.revokeObjectURL(link.href);
         }, "image/png");
        };
        img.onerror = function() {
         console.error("Failed to load SVG image");
         alert("Screenshot failed. Please try again.");
         URL.revokeObjectURL(url);
        };
        img.src = url;
       }
      
       function exportCanvasSVG() {
        const svg = document.getElementById("map");
        const svgClone = svg.cloneNode(true);
        const viewBox = svg.getAttribute("viewBox").split(" ").map(Number);
        const [x, y, width, height] = viewBox;
        svgClone.setAttribute("width", width);
        svgClone.setAttribute("height", height);
        const rootStyles = getComputedStyle(document.documentElement);
        const bgColor = rootStyles.getPropertyValue("--bg").trim() || "#050608";
        const bgRect = document.createElementNS("http://www.w3.org/2000/svg", "rect", );
        bgRect.setAttribute("x", x);
        bgRect.setAttribute("y", y);
        bgRect.setAttribute("width", width);
        bgRect.setAttribute("height", height);
        bgRect.setAttribute("fill", bgColor);
        svgClone.insertBefore(bgRect, svgClone.firstChild);
        const wrapper = document.createElement("div");
        wrapper.style.position = "absolute";
        wrapper.style.left = "-9999px";
        wrapper.appendChild(svgClone);
        document.body.appendChild(wrapper);
        const elements = svg.querySelectorAll("*");
        const clonedElements = svgClone.querySelectorAll("*");
        elements.forEach((el, index) => {
         const clonedEl = clonedElements[index];
         if (!clonedEl) return;
         const computedStyle = getComputedStyle(el);
         const svgProps = ["fill", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin", "opacity", "font-family", "font-size", "font-weight", "font-style", "text-anchor", "dominant-baseline", "marker-start", "marker-end", ];
         svgProps.forEach((prop) => {
          const value = computedStyle.getPropertyValue(prop);
          if (value && value !== "none" && value !== "normal") {
           clonedEl.setAttribute(prop, value);
          }
         });
         clonedEl.removeAttribute("class");
        });
        const svgData = new XMLSerializer().serializeToString(svgClone);
        document.body.removeChild(wrapper);
        const blob = new Blob([svgData], {
         type: "image/svg+xml;charset=utf-8",
        });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        const timestamp = new Date().toISOString().slice(0, 10);
        link.download = `topology-${timestamp}.svg`;
        link.href = url;
        link.click();
        URL.revokeObjectURL(url);
       }
      let resizeTimeout;
       window.addEventListener('resize', () => {
       clearTimeout(resizeTimeout);
       resizeTimeout = setTimeout(() => {
       updateDrawToolbarVisibility();
       updateTopologyToolbarVisibility();
       }, 100);
      });	   
    </script>
  
</body></html>