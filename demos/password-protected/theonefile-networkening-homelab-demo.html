<!DOCTYPE html> 
 <html lang="en" style="--panel: #2f0e0e; --panel-alt: #10141b; --accent: #a75252; --danger: #f56565; --text-main: #e2e8f0; --text-soft: #94a3b8; --topbar-bg: rgba(9, 12, 20, 0.9); --topbar-border: #1f2533; --topbar-height: 112px; --sidebar-width: 350px; --mobile-footer-height: 40vh; --draw-toolbar-height: 45px; --sidebar-bg: #10141b; --btn-bg: #0b0e13; --btn-text: #e2e8f0; --tag-fill: #1e293b; --tag-text: #e2e8f0; --tag-border: #475569; --input-bg: #0b0e13; --input-text: #e2e8f0; --input-border: #1f2937; --input-font: Inter, system-ui, sans-serif; --input-font-size: 14px; --toolbar-bg: #441215; --toolbar-border: #1f2937; --toolbar-text: #94a3b8; --toolbar-btn-bg: #0b0e13; --toolbar-btn-text: #e2e8f0; --minimap-dots: #94a3b8; --canvas-hint-bg: #0f172a; --canvas-hint-color: #94a3b8; --node-fill: #1e293b; --node-stroke: #475569; --node-title: #e2e8f0; --node-sub: #94a3b8; --node-title-size: 18px; --node-sub-size: 13px; --node-font: Inter, system-ui, sans-serif; --default-edge: #475569; --selection-handle: #f59e0b; --selection-handle-size: 8px; --group-indicator: #4fd1c5;"><head>
    <meta charset="UTF-8">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>The One File</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!--
      * ==================================================================================
      * The One File: The Networkening
      * !!!!!!!!!!!!!!!!!!!NOTE: THIS IS THE ONLINE VERSION!!!!!!!!!!!!!!!!!!!!!!
      * Online version uses 3 cdn calls from cdn.jsdelivr.net to display additional icons
      * Since 3.0 Online version uses http as a form of ping to display uptime
      * "There can be only one". A all in one file topology maker.
      *
      * This is your last backup when all others fail. A completely self-contained
      * network topology visualization tool that works as a single HTML file.
      * Open it anywhere, anytime and the idea lives forever.
      * ==================================================================================
      -->
    <style>
      :root {
      color-scheme: dark;
      --bg: #050608;
      --panel: #0b0e13;
      --panel-alt: #10141b;
      --accent: #4fd1c5;
      --danger: #f56565;
      --text-main: #e2e8f0;
      --text-soft: #94a3b8;
      --edge-main: #475569;
      --node-min: 35px;
      --node-max: 70px;
      --topbar-bg: rgba(9, 12, 20, 0.9);
      --topbar-border: #1f2533;
      }
	  html, body, svg, .map-container {
      touch-action: none;
      }
      * {
      box-sizing: border-box;
      user-select: none;
      }
      input,
      textarea,
      [contenteditable="true"] {
      user-select: text;
      -webkit-user-select: text;
      }
      body {
      margin: 0;
      font-family: system-ui, sans-serif;
      background: radial-gradient(circle at top, #1e2532 0, #050608 70%);
      color: var(--text-main);
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
      }
      header {
      padding: 0 20px;
      height: var(--topbar-height, 52px);
      min-height: var(--topbar-height, 52px);
      background: var(--topbar-bg);
      backdrop-filter: blur(6px);
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid var(--topbar-border);
      gap: 16px;
      }
      .title-block {
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-width: 0;
      }
      header h1 {
      font-size: clamp(22px, 3vw, 32px);
      margin: 0;
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
      }
      .editable-page-title {
      cursor: pointer;
      transition: opacity 0.2s;
      }
      .editable-page-title:hover {
      opacity: 0.7;
      }
      .save-row {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      }
      .save-btn {
      padding: 6px 12px;
      background: var(--accent);
      color: var(--bg);
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      white-space: nowrap;
      }
      .save-btn:hover {
      opacity: 0.9;
      }
      .help-icon {
      width: 22px;
      height: 22px;
      border-radius: 50%;
      border: 1px solid var(--edge-main);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      cursor: pointer;
      color: var(--text-soft);
      background: rgba(15, 23, 42, 0.9);
      flex-shrink: 0;
      }
      .help-icon:hover {
      color: var(--accent);
      border-color: var(--accent);
      }
      #settings-btn {
      background: var(--btn-bg, var(--panel));
      color: var(--btn-text, var(--text-main));
      border: 1px solid var(--edge-main);
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 16px;
      flex-shrink: 0;
      }
      #settings-btn:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .header-resizer {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 6px;
      background: transparent;
      cursor: row-resize;
      z-index: 1000;
      transition: background 0.2s;
      }
      .header-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .header-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      .sidebar-resizer {
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 6px;
      background: transparent;
      cursor: col-resize;
      z-index: 1000;
      transition: background 0.2s;
      }
      .sidebar-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .sidebar-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      .mobile-footer-resizer {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 6px;
      background: transparent;
      cursor: row-resize;
      z-index: 1000;
      transition: background 0.2s;
      display: none;
      }
      .mobile-footer-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .mobile-footer-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      @media (max-width: 900px) {
      .mobile-footer-resizer {
      display: block;
      height: 12px;
      }
      .sidebar-resizer {
      display: none;
      }
      .header-resizer {
      height: 12px;
      }
      }
      @media (pointer: coarse) {
      .header-resizer {
      height: 16px;
      }
      .mobile-footer-resizer {
      height: 16px;
      }
      .sidebar-resizer {
      width: 16px;
      }
      }
      .resizer-icon {
      position: absolute;
      opacity: 0.5;
      transition: opacity 0.2s, transform 0.2s;
      pointer-events: none;
      fill: var(--accent);
      }
      .header-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .sidebar-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .mobile-footer-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .header-resizer:hover .resizer-icon,
      .sidebar-resizer:hover .resizer-icon,
      .mobile-footer-resizer:hover .resizer-icon {
      opacity: 1;
      }
      .header-resizer.resizing .resizer-icon,
      .sidebar-resizer.resizing .resizer-icon,
      .mobile-footer-resizer.resizing .resizer-icon {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1.2);
      }
      body.resizing {
      user-select: none;
      }
      body.resizing * {
      cursor: inherit !important;
      pointer-events: none;
      }
      header {
      position: relative;
      }
      .details-panel {
      position: relative;
      }
      main {
      display: grid;
      grid-template-columns: 1fr var(--sidebar-width, 350px);
      flex: 1;
      }
      main.sidebar-collapsed {
      grid-template-columns: 1fr 0;
      }
      @media (max-width: 900px) {
      main {
      grid-template-columns: 1fr;
      grid-template-rows: calc(100vh - var(--topbar-height, 52px) - var(--mobile-footer-height, 40vh)) var(--mobile-footer-height, 40vh);
      }
      main.sidebar-collapsed {
      grid-template-rows: 1fr 0;
      }
      .details-panel {
      max-height: var(--mobile-footer-height, 40vh);
      height: 100%;
      }
      }
      .topology-panel {
      background: var(--panel);
      border-right: 1px solid #111827;
      position: relative;
      overflow: hidden;
      }
      .topology-toolbar {
      position: absolute;
      top: 10px;
      right: 10px;
      display: none;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      z-index: 99;
      font-size: 13px;
      color: var(--toolbar-text, #94a3b8);
      }
      .topology-toolbar label {
      color: var(--toolbar-text, var(--text-soft));
      }
      .topology-toolbar select {
      padding: 4px 6px;
      background: var(--toolbar-btn-bg, var(--panel));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 13px;
      cursor: pointer;
      }
      .topology-toolbar button {
      padding: 4px 10px;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      }
      .topology-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .bulk-toolbar-desktop,
      .bulk-toolbar-mobile {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 9999;
      }
      .bulk-toolbar-desktop {
      position: absolute;
      top: 10px;
      right: 10px;
      bottom: auto;
      left: auto;
      transform: none;
      }
      @media (min-width: 768px) {
      .bulk-toolbar-mobile {
      display: none !important;
      }
      }
      .bulk-action-btn {
      padding: 16px;
      background: var(--panel-main);
      border: 1px solid var(--edge-main);
      border-radius: 8px;
      color: var(--text-main);
      font-size: 24px;
      cursor: pointer;
      text-align: center;
      line-height: 1.2;
      }
      .bulk-action-btn:active {
      transform: scale(0.95);
      background: var(--accent);
      }
      .draw-toolbar {
      position: absolute;
      top: 10px;
      left: 10px;
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 8px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      z-index: 99;
      font-size: 13px;
      pointer-events: auto;
      color: var(--toolbar-text, #94a3b8);
      }
      .draw-toolbar button {
      padding: 4px 8px;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      }
      .draw-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .draw-toolbar input[type="color"] {
      width: 30px;
      height: 22px;
      border-radius: 4px;
      border: 1px solid var(--edge-main);
      padding: 0;
      background: transparent;
      cursor: pointer;
      }
      .draw-toolbar select {
      padding: 4px 6px;
      background: var(--toolbar-btn-bg, var(--panel));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 13px;
      cursor: pointer;
      }
      .legend-container {
      position: absolute;
      left: 10px;
      bottom: 10px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      padding: 8px 10px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      font-size: 12px;
      z-index: 20;
      max-width: 260px;
      pointer-events: auto;
      color: var(--toolbar-text, #94a3b8);
      }
      .legend-container {
      padding-right: 22px;
      }
      @media (max-width: 900px) {
      .legend-container {
      max-height: calc(100vh - var(--topbar-height, 100px) - 120px);
      overflow-y: auto;
      }
      }
      @media (max-width: 900px) {
      .bulk-toolbar-desktop,
      .topology-toolbar {
      display: none !important;
      }
      }
      .legend-close-btn {
      position: absolute;
      top: 5px;
      right: 5px;
      width: 18px;
      height: 18px;
      border-radius: 999px;
      border: 1px solid var(--edge-main);
      background: var(--panel-alt);
      color: var(--text-soft);
      font-size: 11px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      }
      .legend-close-btn:hover {
      background: var(--danger);
      color: #fff;
      }
      .legend-mini-btn {
      position: absolute;
      left: 10px;
      padding: 4px 8px;
      border-radius: 4px;
      border: 1px solid var(--toolbar-border, #1f2937);
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 11px;
      cursor: pointer;
      z-index: 20;
      display: none;
      transition: all 0.2s;
      }
      .legend-mini-btn:hover,
      .legend-mini-btn:active {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
      }
      .legend-title {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: var(--toolbar-text, var(--text-soft));
      margin-bottom: 2px;
      }
      .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      }
      .legend-swatch {
      width: 14px;
      height: 14px;
      border-radius: 3px;
      border: 1px solid #020617;
      flex-shrink: 0;
      }
      .legend-label {
      outline: none;
      cursor: text;
      flex: 1;
      min-width: 60px;
      user-select: text;
      -webkit-user-select: text;
      }
      .legend-label.editing {
      border-bottom: 1px dashed var(--accent);
      }
      .canvas-viewport {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      overflow: hidden;
      }
      .canvas-viewport.panning {
      cursor: grabbing !important;
      }
      .canvas-viewport.panning * {
      cursor: grabbing !important;
      }
      .canvas-viewport svg {
      width: 100%;
      height: 100%;
      display: block;
      background: linear-gradient(rgba(71, 85, 105, 0.1) 1px,
      transparent 1px),
      linear-gradient(90deg,
      rgba(71, 85, 105, 0.1) 1px,
      transparent 1px),
      linear-gradient(rgba(71, 85, 105, 0.05) 1px, transparent 1px),
      linear-gradient(90deg,
      rgba(71, 85, 105, 0.05) 1px,
      transparent 1px);
      background-size:
      100px 100px,
      100px 100px,
      20px 20px,
      20px 20px;
      background-position:
      -1px -1px,
      -1px -1px,
      -1px -1px,
      -1px -1px;
      }
      .zoom-toolbar {
      display: flex;
      gap: 4px;
      padding: 6px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      }
      .zoom-toolbar button {
      width: 32px;
      height: 32px;
      padding: 0;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 18px;
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
      }
      .zoom-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .zoom-toolbar .zoom-level {
      font-size: 11px;
      color: var(--toolbar-text, var(--text-soft));
      text-align: center;
      padding: 2px 0;
      min-width: 32px;
      }
      .zoom-toolbar .divider {
      height: 1px;
      background: var(--toolbar-border, var(--edge-main));
      margin: 2px 0;
      }
      .minimap-zoom-wrapper {
      position: absolute;
      bottom: 10px;
      right: 10px;
      z-index: 99;
      }
      .minimap-container {
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      overflow: hidden;
      margin-bottom: 4px;
      }
      .minimap-container svg {
      width: 100%;
      height: 100%;
      }
      .minimap-viewport {
      fill: rgba(79, 209, 197, 0.2);
      stroke: var(--accent);
      stroke-width: 2;
      cursor: move;
      }
      .minimap-node {
      fill: var(--minimap-dots, var(--text-soft));
      }
      .minimap-edge {
      stroke: var(--edge-main);
      stroke-width: 1;
      }
	  .minimap-close-btn {
      position: absolute;
      top: 2px;
      right: 2px;
      width: 18px;
      height: 18px;
      background: var(--toolbar-btn-bg, rgba(15, 23, 42, 0.9));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 3px;
      color: var(--toolbar-text, var(--text-soft));
      font-size: 11px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
      padding: 0;
      line-height: 1;
      }
      .minimap-close-btn:hover {
      background: var(--danger);
      color: white;
      border-color: var(--danger);
      }
	  .toolbar-close-btn {
      width: 24px;
      height: 24px;
      background: var(--toolbar-btn-bg, rgba(15, 23, 42, 0.9));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-text, var(--text-soft));
      font-size: 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      line-height: 1;
      flex-shrink: 0;
      }
      .toolbar-close-btn:hover {
      background: var(--danger);
      color: white;
      border-color: var(--danger);
      }
	  .canvas-hint {
      position: absolute;
      top: 50px;
      left: 50%;
      transform: translateX(-50%);
      padding: 8px 16px;
      background: var(--canvas-hint-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      font-size: 12px;
      color: var(--canvas-hint-color, var(--text-soft));
      z-index: 18;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
      }
      .canvas-hint.visible {
      opacity: 1;
      }
      .edge {
      stroke: var(--edge-main);
      stroke-width: 4;
      opacity: 0.75;
      transition: 0.25s ease-in-out;
      cursor: pointer;
      }
      .edge.backup {
      stroke: var(--danger);
      stroke-width: 5;
      }
      .edge.active {
      opacity: 1;
      stroke-width: 7;
      filter: drop-shadow(0 0 8px var(--accent, #4fd1c5));
      }
      .rect-group.active .rect-shape {
      filter: drop-shadow(0 0 10px var(--accent, #4fd1c5));
      animation: pulse 1.2s infinite ease-in-out;
      }
      .text-element.active {
      filter: drop-shadow(0 0 10px var(--accent, #4fd1c5));
      animation: pulse 1.2s infinite ease-in-out;
      }
      .free-preview {
      fill: none;
      stroke-dasharray: 4 4;
      pointer-events: none;
      }
      .free-point {
      fill: #e5e7eb;
      stroke: #0f172a;
      stroke-width: 1.5;
      cursor: grab;
      }
      .node-circle {
      fill: var(--node-fill, #1e293b);
      stroke: var(--node-stroke, #475569);
      stroke-width: 2;
      transition: 0.25s ease;
      transform-origin: center center;
      }
      .node-hit-area {
      cursor: grab;
      pointer-events: all;
      }
      .node-group:hover .node-circle {
      filter: drop-shadow(0 0 10px rgba(79, 209, 197, 0.45));
      }
      .node-group.active .node-circle {
      stroke: var(--accent);
      animation: pulse 1.2s infinite ease-in-out;
      }
      @keyframes pulse {
      0% {
      filter: drop-shadow(0 0 4px #4fd1c5);
      }
      50% {
      filter: drop-shadow(0 0 14px #4fd1c5);
      }
      100% {
      filter: drop-shadow(0 0 4px #4fd1c5);
      }
      }
      .node-label {
      fill: var(--text-main);
      font-size: 18px;
      text-anchor: middle;
      font-weight: 600;
      }
      .node-sub {
      fill: var(--text-soft);
      font-size: 13px;
      text-anchor: middle;
      }
      .ping-indicator {
      fill: #6b7280;
      stroke: #4b5563;
      stroke-width: 1;
      }
      .ping-indicator.online {
      fill: #10b981;
      stroke: #059669;
      }
      .ping-indicator.offline {
      fill: #ef4444;
      stroke: #dc2626;
      }
      .ping-indicator.checking {
      fill: #f59e0b;
      stroke: #d97706;
      }
      @media (max-width: 1024px) {
      .node-label {
      font-size: 28px;
      }
      .node-sub {
      font-size: 20px;
      }
      }
      @media (max-width: 768px) {
      .node-label {
      font-size: 70px;
      }
      .node-sub {
      font-size: 50px;
      }
      }
      @media (max-width: 380px) {
      .node-label {
      font-size: 60px;
      }
      .node-sub {
      font-size: 42px;
      }
      }
      .details-panel {
      background: var(--sidebar-bg, var(--panel-alt));
      padding: 22px;
      padding-bottom: 80px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 15px;
      position: relative;
      transition:
      width 0.3s ease,
      min-width 0.3s ease,
      padding 0.3s ease,
      opacity 0.3s ease;
      }
      .details-panel {
      min-width: 260px !important;
      }
      .details-panel {
      overflow-y: auto !important;
      overflow-x: hidden;
      }
      .details-panel.collapsed {
      width: 0 !important;
      min-width: 0 !important;
      padding: 0 !important;
      overflow: hidden;
      opacity: 0;
      }
      body {
      overflow-x: hidden;
      overflow-y: hidden;
      }
      main {
      overflow-x: hidden;
      overflow-y: visible;
      }
      .details-panel {
      overflow-y: auto !important;
      overflow-x: hidden;
      }
      .details-panel.collapsed {
      min-width: 0 !important;
      }
      .sidebar-toggle {
      position: absolute;
      left: -16px;
      top: 50%;
      transform: translateY(-50%);
      width: 16px;
      height: 60px;
      background: var(--sidebar-bg, var(--panel-alt));
      border: 1px solid var(--edge-main);
      border-right: none;
      border-radius: 8px 0 0 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text-soft);
      font-size: 10px;
      z-index: 25;
      transition:
      background 0.2s,
      color 0.2s;
      }
      .sidebar-toggle:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .sidebar-toggle.collapsed {
      left: 0;
      border-right: 1px solid var(--edge-main);
      border-radius: 0 8px 8px 0;
      position: fixed;
      right: 0;
      left: auto;
      }
      .details-name {
      font-size: clamp(22px, 2.5vw, 30px);
      font-weight: 700;
      }
      .details-ip {
      font-size: clamp(16px, 2vw, 22px);
      color: var(--text-soft);
      }
      .details-role {
      font-size: clamp(16px, 2vw, 22px);
      color: var(--accent);
      }
      .size-controls {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-top: 10px;
      }
      .size-controls label {
      font-size: clamp(14px, 1.6vw, 18px);
      color: var(--text-soft);
      }
      .size-controls input[type="range"] {
      flex: 1;
      accent-color: var(--accent);
      }
      .size-controls button {
      padding: 6px 12px;
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      font-size: clamp(12px, 1.4vw, 16px);
      }
      .size-controls button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .style-section {
      margin-top: 15px;
      padding-top: 15px;
      border-top: 1px solid var(--edge-main);
      }
      .style-section summary {
      cursor: pointer;
      font-size: clamp(14px, 1.6vw, 20px);
      text-transform: uppercase;
      color: var(--text-soft);
      list-style: none;
      display: flex;
      justify-content: space-between;
      align-items: center;
      user-select: none;
      }
      .style-section summary::-webkit-details-marker {
      display: none;
      }
      .password-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #ffffff;
      z-index: 9999;
      }
      .style-section summary::after {
      content: "‚ñº";
      transition: transform 0.2s;
      }
      .style-section[open] summary::after {
      transform: rotate(180deg);
      }
      .style-content {
      margin-top: 10px;
      }
      .style-row {
      display: flex;
      gap: 10px;
      align-items: center;
      margin: 8px 0;
      }
      .style-row label {
      font-size: clamp(13px, 1.5vw, 17px);
      color: var(--text-soft);
      min-width: 80px;
      }
      .style-row input[type="color"] {
      width: 50px;
      height: 30px;
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      background: transparent;
      }
      .style-row input[type="number"] {
      width: 70px;
      padding: 4px 8px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(12px, 1.4vw, 16px);
      }
      .style-row select {
      flex: 1;
      padding: 4px 8px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(12px, 1.4vw, 16px);
      cursor: pointer;
      }
      .editable-text {
      cursor: pointer;
      transition: opacity 0.2s;
      }
      .editable-text:hover {
      opacity: 0.7;
      }
      .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 999999;
      justify-content: center;
      align-items: center;
      overflow: auto;
      }
      .modal.active {
      display: inline-grid;
      }
      .modal-content {
      background: var(--panel-alt);
      padding: 25px;
      border-radius: 8px;
      border: 1px solid var(--edge-main);
      min-width: 300px;
      max-width: 90%;
      }
      .modal-content h3 {
      margin: 0 0 15px 0;
      color: var(--text-main);
      font-size: clamp(18px, 2vw, 24px);
      }
      .modal-content p {
      color: var(--text-soft);
      font-size: clamp(14px, 1.6vw, 18px);
      margin: 0 0 20px 0;
      }
      .modal-content input:not([type="color"]),
      .modal-content select {
      width: 100%;
      padding: 10px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(14px, 1.6vw, 18px);
      margin-bottom: 15px;
      user-select: text;
      -webkit-user-select: text;
      }
      .modal-content input[type="color"] {
      width: 60px;
      height: 36px;
      padding: 2px;
      border: 2px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      background: none;
      -webkit-appearance: none;
      appearance: none;
      }
      .modal-content input[type="color"]::-webkit-color-swatch-wrapper {
      padding: 0;
      }
      .modal-content input[type="color"]::-webkit-color-swatch {
      border: none;
      border-radius: 4px;
      }
      .modal-buttons {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
      margin-top: 10px;
      }
      .modal-buttons button {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: clamp(14px, 1.6vw, 18px);
      font-weight: 600;
      }
      .modal-buttons .btn-cancel {
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      }
      .modal-buttons .btn-save {
      background: var(--accent);
      color: var(--bg);
      }
      .modal-buttons .btn-delete {
      background: var(--danger);
      color: white;
      }
      .confirm-modal p {
      color: var(--text-soft);
      font-size: clamp(14px, 1.6vw, 18px);
      margin: 0 0 20px 0;
      }
      .context-menu-item {
      transition: background 0.15s;
      }
      .context-menu-item:hover {
      background: var(--panel);
      }
      .details-info-row {
      display: flex;
      align-items: center;
      margin: 6px 0;
      }
	 .node-group.selected .node-circle {
      stroke: var(--selection-handle, #f59e0b);
      stroke-width: 3;
      }
	  .node-group.layer-faded {
      pointer-events: none;
      }
      .edge.layer-faded {
      pointer-events: none;
      }
      .node-group.search-highlight .node-circle,
      .node-group.search-highlight rect,
      .node-group.search-highlight polygon {
      stroke: #10b981;
      stroke-width: 3;
      filter: drop-shadow(0 0 8px #10b981);
      }
	  .node-group.search-faded {
  opacity: 0.15;
  pointer-events: none;
}
.node-group.search-faded .node-label,
.node-group.search-faded .node-sub {
  opacity: 0.3;
}
.edge-group.search-faded,
.edge.search-faded {
  opacity: 0.1;
}
      .badge-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      }
     .badge {
      background: var(--tag-fill, #1e293b);
      color: var(--tag-text, #e2e8f0);
      border: 1px solid var(--tag-border, var(--edge-main));
      padding: 5px 12px;
      border-radius: 22px;
      font-size: clamp(12px, 1.4vw, 18px);
      }
	  .badge.wg {
      color: var(--accent);
      border-color: var(--accent);
      }
	  input[type="text"],
      input[type="number"],
      input[type="password"],
      textarea,
      select {
      background: var(--input-bg, #0b0e13) !important;
      color: var(--input-text, #e2e8f0) !important;
      border-color: var(--input-border, #1f2937) !important;
      font-family: var(--input-font, Inter, system-ui, sans-serif) !important;
      font-size: var(--input-font-size, 14px) !important;
      }
      .section-label {
      margin-top: 8px;
      font-size: clamp(14px, 1.6vw, 20px);
      text-transform: uppercase;
      color: var(--text-soft);
      }
      .list li {
      margin: 6px 0;
      font-size: clamp(14px, 1.6vw, 20px);
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      }
      .list li:hover {
      color: var(--accent);
      }
      .delete-note {
      color: var(--danger);
      font-size: 18px;
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.2s;
      flex-shrink: 0;
      }
      .list li:hover .delete-note {
      opacity: 1;
      }
      .editing {
      outline: 2px solid var(--accent);
      background: #0d141f;
      padding: 4px;
      border-radius: 6px;
      user-select: text;
      -webkit-user-select: text;
      }
      .mobile-menu-btn {
      display: none;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      color: var(--text-main);
      font-size: 22px;
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      }
      #topbar-menu {
      gap: 8px;
      }
      @media (min-width: 721px) {
      #topbar-menu {
      display: flex !important;
      }
      }
      @media (max-width: 720px) {
      #topbar-menu {
      display: none;
      }
      #topbar-menu.open {
      display: flex;
      }
      }
      @media (max-width: 720px) {
      .mobile-menu-btn {
      display: block;
      }
      #topbar-menu {
      position: absolute;
      top: var(--topbar-height);
      right: 0;
      background: var(--panel-alt);
      border-left: 1px solid var(--topbar-border);
      border-bottom: 1px solid var(--topbar-border);
      padding: 12px;
      display: none;
      flex-direction: column;
      width: 180px;
      z-index: 999;
      }
      #topbar-menu.open {
      display: flex;
      }
      header {
      position: relative;
      z-index: 9999;
      }
      }
      @media (max-width: 720px) {
      .draw-toolbar {
      position: absolute;
      top: auto;
      bottom: auto;
      left: 10px !important;
      right: auto !important;
      width: auto;
      gap: 6px;
      padding: 8px;
      }
      .topology-toolbar {
      position: absolute;
      top: auto;
      bottom: auto;
      width: auto;
      gap: 6px;
      padding: 8px;
      }
      .draw-toolbar {
      top: 10px !important;
      }
      .topology-toolbar {
      top: calc(10px + var(--draw-toolbar-height, 50px)) !important;
      }
      .canvas-hint {
      top: calc(10px + 120px);
      }
      }
      .icon-picker-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      z-index: 999999999;
      justify-content: center;
      align-items: center;
      }
      .icon-picker-modal.active {
      display: flex;
      }
      .icon-picker-content {
      background: var(--panel);
      border-radius: 12px;
      width: 90%;
      max-width: 800px;
      max-height: 80vh;
      display: flex;
      flex-direction: column;
      border: 1px solid var(--edge-main);
      }
      .icon-picker-header {
      padding: 20px;
      border-bottom: 1px solid var(--edge-main);
      }
      .icon-picker-header h3 {
      margin: 0 0 15px 0;
      color: var(--text-main);
      }
      .icon-picker-tabs {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
      flex-wrap: wrap;
      }
      .icon-picker-tab {
      padding: 8px 16px;
      background: var(--panel-alt);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      color: var(--text-soft);
      font-size: 14px;
      transition: all 0.2s;
      }
      .icon-picker-tab:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .icon-picker-tab.active {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
      }
      .icon-picker-search {
      width: 100%;
      padding: 10px 15px;
      background: var(--panel-alt);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      color: var(--text-main);
      font-size: 14px;
      }
      .icon-picker-search::placeholder {
      color: var(--text-soft);
      }
      .icon-picker-body {
      padding: 20px;
      overflow-y: auto;
      flex: 1;
      }
      .icon-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
      gap: 10px;
      }
      .icon-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 15px 10px;
      background: var(--panel-alt);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .icon-item:hover {
      background: var(--accent);
      border-color: var(--accent);
      transform: scale(1.05);
      }
      .icon-item svg {
      width: 32px;
      height: 32px;
      fill: var(--text-main);
      }
      .icon-item:hover svg {
      fill: var(--bg);
      }
      .icon-item-name {
      margin-top: 8px;
      font-size: 10px;
      color: var(--text-soft);
      text-align: center;
      word-break: break-word;
      }
      .icon-item:hover .icon-item-name {
      color: var(--bg);
      }
      .icon-picker-loading {
      text-align: center;
      padding: 40px;
      color: var(--text-soft);
      }
      .icon-picker-footer {
      padding: 15px 20px;
      border-top: 1px solid var(--edge-main);
      display: flex;
      justify-content: flex-end;
      }
      .icon-btn-cancel {
      padding: 8px 20px;
      background: var(--panel-alt);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      }
      .icon-btn-cancel:hover {
      background: var(--edge-main);
      }
      .icon-badge {
      display: inline-flex;
      align-items: center;
      gap: 5px;
      padding: 4px 8px;
      background: var(--panel-alt);
      border-radius: 4px;
      font-size: 12px;
      margin: 2px;
      }
      .icon-badge svg {
      width: 16px;
      height: 16px;
      fill: currentColor;
      }
      .pick-icon-btn {
      padding: 6px 12px;
      background: var(--accent);
      color: var(--bg);
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      margin-top: 8px;
      width: 100%;
      }
      .pick-icon-btn:hover {
      opacity: 0.9;
      }
      @media (max-width: 768px) {
      .icon-picker-content {
      width: 95%;
      max-height: 90vh;
      }
      .modal-content {
      background: var(--panel-alt);
      }
      #search-input {
      width: 100%;
      }
      }
      .version-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .version-item:hover {
      background: var(--panel-alt);
      border-color: var(--accent);
      }
      .version-item.current {
      border-color: var(--accent);
      background: rgba(79, 209, 197, 0.1);
      }
      .version-info {
      flex: 1;
      }
      .version-info .timestamp {
      font-size: 13px;
      color: var(--text-main);
      font-weight: 600;
      }
      .version-info .details {
      font-size: 11px;
      color: var(--text-soft);
      margin-top: 4px;
      }
      .version-actions {
      display: flex;
      gap: 6px;
      }
      .audit-entry {
      padding: 8px 12px;
      background: var(--panel);
      border-left: 3px solid var(--edge-main);
      border-radius: 4px;
      font-size: 12px;
      }
      .audit-entry.node { border-left-color: #4fd1c5; }
      .audit-entry.connection { border-left-color: #9f7aea; }
      .audit-entry.style { border-left-color: #ed8936; }
      .audit-entry.rack { border-left-color: #48bb78; }
      .audit-entry.layer { border-left-color: #4299e1; }
      .audit-entry .time {
      color: var(--text-soft);
      font-size: 10px;
      }
      .audit-entry .action {
      color: var(--text-main);
      font-weight: 500;
      }
      .tab-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .tab-item:hover {
      background: var(--panel-alt);
      }
      .tab-item.active {
      border-color: var(--accent);
      background: rgba(79, 209, 197, 0.1);
      }
      .tab-item .tab-name {
      font-weight: 600;
      color: var(--text-main);
      flex: 1;
      }
      .tab-item .tab-stats {
      font-size: 11px;
      color: var(--text-soft);
      margin-right: 10px;
      }
      .tab-actions {
      display: flex;
      gap: 6px;
      }
      .secret-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      border-left: 3px solid var(--danger);
      }
      .secret-item .secret-name {
      font-weight: 600;
      color: var(--text-main);
      flex: 1;
      }
      .secret-item .secret-status {
      font-size: 11px;
      color: var(--text-soft);
      margin-right: 10px;
      }
	  body.view-only-mode:not(.view-only-inspect) #node-panel,
      body.view-only-mode:not(.view-only-inspect) #edge-panel,
      body.view-only-mode:not(.view-only-inspect) #text-panel,
      body.view-only-mode:not(.view-only-inspect) #rect-panel {
        display: none !important;
      }
      body.view-only-mode .node-group,
      body.view-only-mode .edge,
      body.view-only-mode .rect-group,
      body.view-only-mode .text-element {
        cursor: default !important;
      }
      body.view-only-mode .resize-handle,
      body.view-only-mode .edge-control-point {
        display: none !important;
      }
      body.view-only-mode #bulk-toolbar,
      body.view-only-mode #bulk-toolbar-mobile,
      body.view-only-mode #bulk-actions-modal {
        display: none !important;
      }
      body.view-only-mode::after {
        content: "VIEW ONLY ‚Ä¢ click 5√ó to inspect";
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(245, 101, 101, 0.9);
        color: white;
        padding: 6px 16px;
        border-radius: 20px;
        font-size: 12px;
        font-weight: 600;
        letter-spacing: 1px;
        z-index: 9999;
        pointer-events: none;
      }
    </style>
  </head>
  <body style="background: radial-gradient(circle at center top, rgb(30, 37, 50) 0px, rgb(5, 6, 8) 70%);" class="">
    <div class="icon-picker-modal" id="icon-picker-modal">
      <div class="icon-picker-content">
        <div class="icon-picker-header">
          <h3>Select Icon</h3>
          <div class="icon-picker-tabs">
            <button class="icon-picker-tab" data-library="mdi">MDI</button>
            <button class="icon-picker-tab" data-library="simple">Simple Icons</button>
            <button class="icon-picker-tab active" data-library="selfhst">selfh.st/icons</button>
          </div>
          <input type="text" class="icon-picker-search" id="icon-search" placeholder="Search icons..." style="display: none;">
        </div>
        <div class="icon-picker-body" id="icon-picker-body">
        </div>
        <div class="icon-picker-footer">
          <button class="icon-btn-cancel" id="icon-picker-cancel">Cancel</button>
        </div>
      </div>
    </div>
    <div class="modal" id="tabs-modal">
      <div class="modal-content" style="max-width: 600px;">
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Manage multiple topologies</p>
        <div id="tabs-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 400px; overflow-y: auto; margin-bottom: 15px;">
            <div class="tab-item " onclick="switchTab(0)">
              <div class="tab-name">Corporate Site B</div>
              <div class="tab-stats">105 nodes ‚Ä¢ 65 connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(0)" title="Rename tab">‚úèÔ∏è</button>
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(0)" title="Delete tab">üóëÔ∏è</button>
              </div>
            </div>
          
            <div class="tab-item active" onclick="switchTab(1)">
              <div class="tab-name">Homelab 2</div>
              <div class="tab-stats">11 nodes ‚Ä¢ 10 connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(1)" title="Rename tab">‚úèÔ∏è</button>
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(1)" title="Delete tab">üóëÔ∏è</button>
              </div>
            </div>
          </div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="new-tab-name" placeholder="New tab name..." style="flex: 1; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <button class="btn-save" onclick="createNewTab()">+ Add Tab</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="tabs-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="rollback-modal">
      <div class="modal-content" style="max-width: 700px;">
        <h3>Version History</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Limit: Snapshots</p>
        <div id="rollback-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 450px; overflow-y: auto; margin-bottom: 15px;">
          <div style="text-align: center; padding: 40px; color: var(--text-soft);">No version history yet. Versions are saved automatically when you save the file.</div>
        </div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <button class="btn-cancel" onclick="clearRollbackHistory()">Clear History</button>
          <button class="btn-save" onclick="createManualSnapshot()">Create Snapshot</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="rollback-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="audit-log-modal">
      <div class="modal-content" style="max-width: 800px;">
        <h3>Audit Log</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Track all changes made to your topology</p>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <select id="audit-filter" style="padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
            <option value="all">All Events</option>
            <option value="node">Node Operations</option>
            <option value="connection">Connections</option>
            <option value="style">Style Changes</option>
            <option value="rack">Rack Operations</option>
            <option value="layer">Layer Changes</option>
          </select>
          <button class="btn-save" onclick="exportAuditLog()">Export</button>
        </div>
        <div id="audit-log-list" style="display: flex; flex-direction: column; gap: 4px; max-height: 450px; overflow-y: auto; margin-bottom: 15px; font-family: monospace; font-size: 12px;"><div style="text-align: center; padding: 40px; color: var(--text-soft);">No audit entries yet</div></div>
        <div style="display: flex; gap: 8px;">
          <button class="btn-cancel" onclick="clearAuditLog()">Clear Log</button>
          <button class="btn-cancel" id="audit-log-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="port-map-modal">
      <div class="modal-content" style="max-width: 900px;">
        <h3>Port Map</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">All connections with port assignments</p>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="port-map-search" placeholder="Search devices or ports..." style="flex: 1; min-width: 200px; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <select id="port-map-filter" style="padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
            <option value="all">All Connections</option>
            <option value="with-ports">With Ports Only</option>
            <option value="without-ports">Missing Ports</option>
          </select>
        </div>
        <div id="port-map-table" style="max-height: 450px; overflow-y: auto; margin-bottom: 15px;"></div>
        <div style="display: flex; gap: 8px;">
          <button class="btn-save" onclick="exportPortMap()">Export CSV</button>
          <button class="btn-cancel" id="port-map-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="secrets-modal">
      <div class="modal-content" style="max-width: 600px;">
        <h3>Notes</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Notes can also be stored with AES 256 encryption</p>
        <div id="secrets-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 350px; overflow-y: auto; margin-bottom: 15px;">
        </div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="new-secret-name" placeholder="Section name (e.g., 'Root Passwords')..." style="flex: 1; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <button class="btn-save" onclick="createNewSecret()">+ Add Note</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="secrets-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="secret-editor-modal">
      <div class="modal-content" style="max-width: 600px;">
        <h3 id="secret-editor-title">Edit Note</h3>
        <textarea id="secret-editor-content" placeholder="Enter sensitive information here..." style="width: 100%; height: 200px; padding: 12px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main); font-family: monospace; resize: vertical; margin-bottom: 15px;"></textarea>
        <div style="margin-bottom: 15px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
          <input type="checkbox" id="secret-auto-encrypt" checked="" style="cursor: pointer;">
          <span>Encrypt Note</span>
          </label>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" onclick="closeSecretEditor()">Cancel</button>
          <button class="btn-save" onclick="saveSecret()">Save</button>
        </div>
      </div>
    </div>
    <div class="modal" id="edit-modal">
      <div class="modal-content">
        <h3 id="modal-title">Edit Name</h3>
        <input type="text" id="modal-input">
        <div class="modal-buttons">
          <button class="btn-cancel" id="modal-cancel">Cancel</button>
          <button class="btn-save" id="modal-save">Save</button>
        </div>
      </div>
    </div>
    <div class="modal confirm-modal" id="confirm-modal">
      <div class="modal-content">
        <h3>Confirm</h3>
        <p id="confirm-message"> Are you sure you want to delete this line? </p>
        <div class="modal-buttons">
          <button class="btn-cancel" id="confirm-cancel">Cancel</button>
          <button class="btn-delete" id="confirm-delete">Delete</button>
        </div>
      </div>
    </div>
    <div class="modal" id="save-info-modal">
      <div class="modal-content" style="max-width: 700px; max-height: 80vh; overflow-y: auto;">
        <h3 style="margin-bottom: 16px;">Help</h3>
        <div style="display: flex; gap: 8px; margin-bottom: 16px; flex-wrap: wrap;">
          <button class="help-tab active" data-tab="general" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--accent); color: var(--bg); border-radius: 6px; cursor: pointer; font-weight: 600;">General</button>
          <button class="help-tab" data-tab="desktop" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--panel); color: var(--text-main); border-radius: 6px; cursor: pointer; font-weight: 600;">Desktop</button>
          <button class="help-tab" data-tab="mobile" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--panel); color: var(--text-main); border-radius: 6px; cursor: pointer; font-weight: 600;">Mobile</button>
        </div>
        <div id="help-tab-general" class="help-tab-content" style="display: block;">
          <ul style="margin-left: 20px; margin-bottom: 12px; line-height: 1.8;">
            <li><strong>Add Nodes:</strong> Click "+ Node" or "+ Rack" in the top menu</li>
            <li><strong>Connect Nodes:</strong> Select a node, then use "Add Connection" in the panel</li>
            <li><strong>Move Nodes:</strong> Drag nodes to reposition them</li>
            <li><strong>Enter Rack View:</strong> Double click on desktop or Long press on mobile</li>
            <li><strong>Multi Select:</strong> Right click (desktop) or double tap (mobile)</li>
            <li><strong>Pan Canvas:</strong> Drag empty space or hold Space + drag</li>
            <li><strong>Zoom:</strong> Scroll wheel or pinch gesture</li>
            <li><strong>Free Draw:</strong> Use draw toolbar for drawing lines, boxes/zones , and text</li>
          </ul>
          <h4 style="color: var(--accent); margin-bottom: 8px;">Saving &amp; Encryption</h4>
          <p style="margin-bottom: 8px;">Browsers cannot overwrite local files. Click <strong>Save File</strong> to download an updated HTML with all changes. Replace your old file to keep edits.</p>
          <p style="margin-bottom: 8px;"><strong>Encryption of data:</strong> Check "Encrypt" before saving to password protect your data. Beware! No recovery possible without password!!</p>
          <p><strong>Decryption of data:</strong> Export via JSON in top settings menu after successful password validation to decrypt your data. You can then reimport back into the same file and save!</p>
        </div>
        <div id="help-tab-desktop" class="help-tab-content" style="display: none;">
          <h4 style="color: var(--accent); margin-bottom: 12px;">Navigation</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Arrow Keys</code></td>
              <td style="padding: 8px;">Move selected 1px</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Shift + Arrows</code></td>
              <td style="padding: 8px;">Move selected 10px</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Tab / Shift+Tab</code></td>
              <td style="padding: 8px;">Cycle through nodes</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">F</code></td>
              <td style="padding: 8px;">Focus on selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Space + Drag</code></td>
              <td style="padding: 8px;">Pan canvas</td>
            </tr>
          </tbody></table>
          <h4 style="color: var(--accent); margin-bottom: 12px;">Management</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">L</code></td>
              <td style="padding: 8px;">Lock/unlock selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">G</code></td>
              <td style="padding: 8px;">Group/ungroup selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+C / Ctrl+V</code></td>
              <td style="padding: 8px;">Copy / Paste</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+D</code></td>
              <td style="padding: 8px;">Duplicate</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+A</code></td>
              <td style="padding: 8px;">Select all</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Delete</code></td>
              <td style="padding: 8px;">Delete selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Escape</code></td>
              <td style="padding: 8px;">Clear selection</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+Z / Ctrl+Y</code></td>
              <td style="padding: 8px;">Undo / Redo</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Right Click</code></td>
              <td style="padding: 8px;">Multi select toggle</td>
            </tr>
          </tbody></table>
        </div>
        <div id="help-tab-mobile" class="help-tab-content" style="display: none;">
          <h4 style="color: var(--accent); margin-bottom: 12px;">Basic Gestures</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Tap node</strong></td>
              <td style="padding: 8px;">Select &amp; open properties</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Tap empty</strong></td>
              <td style="padding: 8px;">Deselect all</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Drag node</strong></td>
              <td style="padding: 8px;">Move node</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Drag empty</strong></td>
              <td style="padding: 8px;">Pan canvas</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Pinch</strong></td>
              <td style="padding: 8px;">Zoom in/out</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Double-tap node</strong></td>
              <td style="padding: 8px;">Add/remove from selection</td>
            </tr>
          </tbody></table>
          <h4 style="color: var(--accent); margin-bottom: 12px;">Rack View</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Long-press rack</strong></td>
              <td style="padding: 8px;">Enter rack view</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Double-tap empty</strong></td>
              <td style="padding: 8px;">Exit rack view</td>
            </tr>
          </tbody></table>
        </div>
        <div class="modal-buttons" style="margin-top: 16px;">
          <button class="btn-cancel" id="save-info-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="settings-modal">
	<div class="modal-content">
        <h2>Settings</h2>
        <details class="style-section">
          <summary>View Only Mode</summary>
          <div class="style-content">
            <div class="style-row">
              <label>View Only (disable all editing)</label>
              <input type="checkbox" id="view-only-mode" style="width:auto;">
            </div>
            <p style="margin-top:4px;font-size:12px;color:var(--text-soft);">When enabled, all editing of the canvas is disabled. Pan and zoom still work.</p>
          </div>
        </details>
        <details class="style-section">
          <summary>General Theme</summary>
          <div class="style-content">
		    <div class="style-row">
              <label>Main Background</label>
              <input type="color" id="panel-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Modal Window (popup) Background</label>
              <input type="color" id="panel-alt-color" value="#10141b">
            </div>
            <div class="style-row">
              <label>Accent Buttons</label>
              <input type="color" id="accent-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Danger Buttons</label>
              <input type="color" id="danger-color" value="#f56565">
            </div>
            <div class="style-row">
              <label>Primary Text</label>
              <input type="color" id="text-main-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Secondary Text</label>
              <input type="color" id="text-soft-color" value="#94a3b8">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Top Bar</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="topbar-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="topbar-border-color" value="#1f2533">
            </div>
          </div>
		  <div class="style-content">
            <div class="style-row">
              <label>Button Fill</label>
              <input type="color" id="btn-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Button Text</label>
              <input type="color" id="btn-text-color" value="#e2e8f0">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Main Canvas</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="canvas-border-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Grid Lines</label>
              <input type="color" id="canvas-grid-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Grid Size</label>
              <input type="number" id="canvas-grid-size" value="50" min="20" max="200" style="width:60px;">
            </div>
		    <div class="style-row">
              <label>Background Top</label>
              <input type="color" id="canvas-gradient-top" value="#1e2532">
            </div>
            <div class="style-row">
              <label>Background Bottom</label>
              <input type="color" id="canvas-gradient-bottom" value="#050608">
            </div>
            <div class="style-row">
              <label>Solid Background</label>
              <input type="color" id="page-bg-color" value="#050608">
            </div>
            <p style="margin-top:4px;font-size:12px;color:var(--text-soft);">Set solid background to override gradient.</p>
          </div>
        </details>
        <details class="style-section">
          <summary>Rack Canvas</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Frame Fill</label>
              <input type="color" id="rack-frame-fill" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Frame Border</label>
              <input type="color" id="rack-frame-stroke" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Grid Lines</label>
              <input type="color" id="rack-line-color" value="#475569">
            </div>
            <div class="style-row">
              <label>U Labels</label>
              <input type="color" id="rack-text-color" value="#4fd1c5">
            </div>
          </div>
       </details>
	   <details class="style-section">
          <summary>Canvas Toolbars</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="toolbar-bg-color" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="toolbar-border-color" value="#1f2937">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="toolbar-text-color" value="#94a3b8">
            </div>
            <div class="style-row">
              <label>Button Fill</label>
              <input type="color" id="toolbar-btn-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Button Text</label>
              <input type="color" id="toolbar-btn-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Minimap Dots</label>
              <input type="color" id="minimap-dots-color" value="#94a3b8">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Nodes</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Fill</label>
              <input type="color" id="node-fill-color" value="#1e293b">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="node-stroke-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Title Color</label>
              <input type="color" id="node-title-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Title Size</label>
              <input type="number" id="node-title-size" value="18" min="8" max="48" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Subtitle Color</label>
              <input type="color" id="node-sub-color" value="#94a3b8">
            </div>
            <div class="style-row">
              <label>Subtitle Size</label>
              <input type="number" id="node-sub-size" value="13" min="8" max="48" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Font</label>
              <select id="node-font-family" style="flex:1;padding:4px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;">
                <option value="Inter, system-ui, sans-serif">Inter</option>
                <option value="Arial, sans-serif">Arial</option>
                <option value="Helvetica, sans-serif">Helvetica</option>
                <option value="Georgia, serif">Georgia</option>
                <option value="monospace">Monospace</option>
              </select>
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Connections</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Default Color</label>
              <input type="color" id="default-edge-color" value="#475569">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Groups &amp; Editing</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Resize handle Color</label>
              <input type="color" id="selection-handle-color" value="#f59e0b">
            </div>
            <div class="style-row">
              <label>Resize Handle Size</label>
              <input type="number" id="selection-handle-size" value="8" min="4" max="16" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Grouped Icon Outline</label>
              <input type="color" id="group-indicator-color" value="#4fd1c5">
            </div>
          </div>
		  <div class="style-content">
            <div class="style-row">
              <label>Multiselect Fill Color (Desktop)</label>
              <input type="color" id="selection-fill-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Multiselect Fill Opacity (Desktop)</label>
              <input type="range" id="selection-fill-opacity" min="0" max="1" step="0.05" value="0.1">
              <span id="selection-fill-opacity-val" style="min-width:35px;text-align:right;">10%</span>
            </div>
            <div class="style-row">
              <label>Multiselect Border Color (Desktop)</label>
              <input type="color" id="selection-stroke-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Multiselect Border Width (Desktop)</label>
              <input type="number" id="selection-stroke-width" min="1" max="10" value="2">
            </div>
            <div class="style-row">
              <label>Multiselect Border Style (Desktop)</label>
              <select id="selection-stroke-style">
                <option value="5,5">Dashed</option>
                <option value="2,4">Dotted</option>
                <option value="none">Solid</option>
              </select>
            </div>
          </div>
        </details>
		<details class="style-section">
          <summary>Inputs &amp; Dropdowns</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="input-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="input-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="input-border-color" value="#1f2937">
            </div>
            <div class="style-row">
              <label>Font</label>
              <select id="input-font-family" style="flex:1;padding:4px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;">
                <option value="Inter, system-ui, sans-serif">Inter</option>
                <option value="Arial, sans-serif">Arial</option>
                <option value="Helvetica, sans-serif">Helvetica</option>
                <option value="Georgia, serif">Georgia</option>
                <option value="monospace">Monospace</option>
              </select>
            </div>
            <div class="style-row">
              <label>Font Size</label>
              <input type="number" id="input-font-size" value="14" min="10" max="24" style="width:60px;">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Welcome Message</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Enabled</label>
              <input type="checkbox" id="canvas-hint-enabled" checked="" style="width:auto;">
            </div>
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="canvas-hint-bg-color" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Text Color</label>
              <input type="color" id="canvas-hint-text-color" value="#94a3b8">
            </div>
            <div class="style-row" style="flex-direction:column;align-items:stretch;">
              <label>Custom Text (HTML)</label>
              <textarea id="canvas-hint-text" rows="4" style="width:100%;margin-top:4px;padding:6px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;font-size:12px;resize:vertical;" placeholder="Leave empty for default"></textarea>
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Sidebar / Mobile Footer</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="sidebar-bg-color" value="#10141b">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Tags</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Fill</label>
              <input type="color" id="tag-fill-color" value="#1e293b">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="tag-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="tag-border-color" value="#475569">
            </div>
          </div>
        </details>
        <details class="style-section" open="">
          <summary>Import / Export / Upgrade JSON</summary>
          <div class="style-content">
            <button id="export-data-btn" style="width:100%;margin-bottom:10px;padding:10px;background:var(--accent);color:var(--bg);border:none;border-radius:6px;cursor:pointer;font-size:14px;font-weight:600;">Export JSON</button>
            <button id="import-data-btn" style="width:100%;padding:10px;background:var(--panel);color:var(--text-main);border:1px solid var(--edge-main);border-radius:6px;cursor:pointer;font-size:14px;font-weight:600;">Import JSON</button>
            <input type="file" id="import-data-file" accept=".json" style="display:none">
          </div>
        </details>
         <details class="style-section">
          <summary>Auto Status Checking</summary>
          <div class="style-content">
            <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 16px; cursor: pointer;">
            <input type="checkbox" id="auto-ping-enabled" style="cursor: pointer;">
            <span style="font-size: 14px; font-weight: 600;">Enable automatic status checking</span>
            </label>
            <div id="auto-ping-settings" style="display: none; padding-left: 20px; border-left: 2px solid var(--edge-main);">
              <div class="style-row" style="margin-bottom: 12px;">
                <label>Check Interval (seconds):</label>
                <input type="number" id="auto-ping-interval" min="5" max="3600" value="30" style="width: 80px; padding: 6px; background: var(--panel); border: 1px solid var(--edge-main); border-radius: 4px; color: var(--text-main);">
              </div>
              <div style="padding: 10px; background: var(--panel); border-radius: 6px; border: 1px solid var(--edge-main); font-size: 12px; color: var(--text-soft);">
                <div style="margin-bottom: 4px;"><span id="auto-ping-next-check">Next check in: --</span></div>
                <div><span id="auto-ping-last-run">Last run: 1:15:07 PM</span></div>
              </div>
            </div>
            <p style="margin-top: 12px; font-size: 12px; color: var(--text-soft); font-style: italic;">
              Automatically checks all ping enabled nodes at the specified interval. I recommend 30 to 60 seconds for local networks.
            </p>
			</div>
        </details>
        <details class="style-section" open="">
          <summary>Danger Zone</summary>
          <div class="style-content">
            <p style="margin-bottom:12px;font-size:13px;color:var(--text-soft);">Permanently delete everything on the canvas.</p>
            <button id="clear-all-btn" title="Clear all nodes" style="padding:6px 12px;background:var(--danger);color:#fff;border:none;border-radius:6px;cursor:pointer;font-size:14px;font-weight:600;">Clear All</button>
            <input type="file" id="import-data-file" accept=".json" style="display:none">
          </div>
        </details>
        <div class="modal-buttons">
          <button class="btn-cancel" id="settings-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="add-node-modal">
      <div class="modal-content">
        <h3>Add New Node</h3>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Basic Information</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Name</label>
          <input type="text" id="new-node-name" placeholder="e.g. web server, jellyfin">
          <label style="display: block;margin-bottom: 4px;margin-top: 12px;color: var(--text-soft);font-size: 13px;">IP / Subtitle</label>
          <input type="text" id="new-node-ip" placeholder="e.g. 192.168.1.100">
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Tags</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Text Tags (comma separated)</label>
          <input type="text" id="new-node-tags" placeholder="e.g. Docker, nginx, WG: vpn">
          <button class="pick-icon-btn" id="pick-new-node-tag-icon-btn" style="margin-top: 10px;">Add Icon Tag</button>
          <div id="new-node-icon-tags" style="margin-top: 10px; display: none;">
            <label style="display: block; margin-bottom: 8px; color: var(--text-soft); font-size: 13px;">Icon Tags:</label>
            <div id="new-node-icon-tags-list" style="display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 10px;"></div>
          </div>
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Node Appearance</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Basic Shapes</label>
          <select id="new-node-shape">
            <optgroup label="Basic Shapes">
            <option value="circle">Circle</option>
            <option value="square">Square</option>
            <option value="rectangle">Rectangle</option>
            <option value="triangle">Triangle</option>
            <option value="hexagon">Hexagon</option>
            <option value="diamond">Diamond</option>
            <option value="star">Star</option>
            <option value="stop-sign">Stop Sign</option>
            <option value="octagon">Octagon</option>
            <option value="pentagon">Pentagon</option>
            <option value="cross">Cross</option>
            <option value="rounded-square">Rounded Square</option>
            <option value="pill">Pill</option>
            <option value="parallelogram">Parallelogram</option>
            <option value="trapezoid">Trapezoid</option>
          </optgroup>
          <optgroup label="Computers &amp; Devices">
            <option value="server">Server</option>
            <option value="pc">PC / Desktop</option>
            <option value="laptop">Laptop</option>
            <option value="phone">Phone / Mobile</option>
            <option value="printer">Printer</option>
            <option value="pi">Raspberry Pi</option>
            <option value="sensor">Sensor / IoT</option>
          </optgroup>
          <optgroup label="Network Equipment">
            <option value="router">Router</option>
            <option value="switch">Switch</option>
            <option value="firewall">Firewall</option>
            <option value="access-point">Access Point</option>
            <option value="load-balancer">Load Balancer</option>
            <option value="gateway">Gateway</option>
            <option value="vpn">VPN / Tunnel</option>
            <option value="nas">NAS / Storage</option>
          </optgroup>
          <optgroup label="Cloud &amp; Services">
            <option value="cloud">Cloud</option>
            <option value="database">Database</option>
			<option value="docker">Docker</option>
            <option value="container">Container</option>
            <option value="vm">Virtual Machine</option>
            <option value="kubernetes">Kubernetes</option>
            <option value="api">API / Endpoint</option>
            <option value="queue">Queue / Message</option>
            <option value="lambda">Lambda / Function</option>
            <option value="bucket">Bucket / S3</option>
          </optgroup>
          <optgroup label="Security &amp; Monitoring">
            <option value="shield">Shield</option>
            <option value="camera">Camera / CCTV</option>
            <option value="monitor">Monitor / Dashboard</option>
          </optgroup>
          </select>
          <button class="pick-icon-btn" id="pick-node-icon-btn" style="margin-top: 10px;"> Or search web icons</button>
          <div id="selected-node-icon" style="margin-top: 10px; display: none;">
            <label style="display: block; margin-bottom: 8px; color: var(--text-soft); font-size: 13px;">Selected Icon:</label>
            <div class="icon-badge" id="selected-node-icon-preview">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24">
                <image href="https://cdn.jsdelivr.net/gh/selfhst/icons@master/png/docker.png" width="24" height="24"></image>
              </svg>
              <span>docker</span>
            </div>
          </div>
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Ping / Status Monitoring</div>
          <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px; cursor: pointer;">
          <input type="checkbox" id="new-node-pingable" style="cursor: pointer;">
          <span style="color: var(--text-soft); font-size: 13px;">Enable ping/status check for this node</span>
          </label>
          <div id="new-node-ping-options" style="display: block; padding-left: 24px; border-left: 2px solid var(--edge-main);">
            <label style="display: block; margin-bottom: 4px; color: var(--text-soft); font-size: 13px;">Protocol</label>
            <select id="new-node-ping-protocol" style="margin-bottom: 12px;">
              <option value="http">HTTP (port 80) uses IP field</option>
              <option value="https">HTTPS (port 443) uses IP field</option>
              <option value="custom">Custom URL</option>
            </select>
            <div id="new-node-custom-url-container" style="display: block;">
              <label style="display: block; margin-bottom: 4px; color: var(--text-soft); font-size: 13px;">Custom URL</label>
              <input type="text" id="new-node-custom-url" placeholder="e.g. http://192.168.1.1:8080">
            </div>
            <label style="display: block; margin-bottom: 4px; margin-top: 8px; color: var(--text-soft); font-size: 13px;">
            Timeout (ms)
            </label>
            <input type="number" id="new-node-ping-timeout" value="3000" min="1000" max="10000" step="500">
          </div>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="add-node-cancel">Cancel</button>
          <button class="btn-save" id="add-node-save">Add Node</button>
        </div>
      </div>
    </div>
    <div class="modal" id="add-rack-modal">
      <div class="modal-content">
        <h3>Add New Rack</h3>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Basic Information</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Rack Name</label>
          <input type="text" id="new-rack-name" placeholder="e.g. Rack-A, DC1-R01, Production-01">
          <label style="display: block;margin-bottom: 4px;margin-top: 12px;color: var(--text-soft);font-size: 13px;">IP / Network Range (optional)</label>
          <input type="text" id="new-rack-ip" placeholder="e.g. 192.168.1.0/24">
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Tags</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Text Tags (comma separated)</label>
          <input type="text" id="new-rack-tags" placeholder="e.g. Production, Data Center 1, Row A">
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Rack Appearance</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Icon / Shape</label>
          <select id="new-rack-shape">
            <optgroup label="Basic Shapes">
            <option value="circle">Circle</option>
            <option value="square">Square</option>
            <option value="rectangle">Rectangle</option>
            <option value="triangle">Triangle</option>
            <option value="hexagon">Hexagon</option>
            <option value="diamond">Diamond</option>
            <option value="star">Star</option>
            <option value="stop-sign">Stop Sign</option>
            <option value="octagon">Octagon</option>
            <option value="pentagon">Pentagon</option>
            <option value="cross">Cross</option>
            <option value="rounded-square">Rounded Square</option>
            <option value="pill">Pill</option>
            <option value="parallelogram">Parallelogram</option>
            <option value="trapezoid">Trapezoid</option>
          </optgroup>
          <optgroup label="Computers &amp; Devices">
            <option value="server">Server</option>
            <option value="pc">PC / Desktop</option>
            <option value="laptop">Laptop</option>
            <option value="phone">Phone / Mobile</option>
            <option value="printer">Printer</option>
            <option value="pi">Raspberry Pi</option>
            <option value="sensor">Sensor / IoT</option>
          </optgroup>
          <optgroup label="Network Equipment">
            <option value="router">Router</option>
            <option value="switch">Switch</option>
            <option value="firewall">Firewall</option>
            <option value="access-point">Access Point</option>
            <option value="load-balancer">Load Balancer</option>
            <option value="gateway">Gateway</option>
            <option value="vpn">VPN / Tunnel</option>
            <option value="nas">NAS / Storage</option>
          </optgroup>
          <optgroup label="Cloud &amp; Services">
            <option value="cloud">Cloud</option>
            <option value="database">Database</option>
			<option value="docker">Docker</option>
            <option value="container">Container</option>
            <option value="vm">Virtual Machine</option>
            <option value="kubernetes">Kubernetes</option>
            <option value="api">API / Endpoint</option>
            <option value="queue">Queue / Message</option>
            <option value="lambda">Lambda / Function</option>
            <option value="bucket">Bucket / S3</option>
          </optgroup>
          <optgroup label="Security &amp; Monitoring">
            <option value="shield">Shield</option>
            <option value="camera">Camera / CCTV</option>
            <option value="monitor">Monitor / Dashboard</option>
          </optgroup>
          </select>
          <button class="pick-icon-btn" id="pick-rack-icon-btn" style="margin-top: 10px;">Or Search Web Icons</button>
          <div id="selected-rack-icon" style="margin-top: 10px; display: none;">
            <label style="display: block; margin-bottom: 8px; color: var(--text-soft); font-size: 13px;">Selected Icon:</label>
            <div class="icon-badge" id="selected-rack-icon-preview">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24">
                <image href="" width="24" height="24"></image>
              </svg>
              <span></span>
            </div>
          </div>
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Rack Configuration</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Rack Capacity</label>
          <select id="new-rack-capacity">
            <option value="42" selected="">42U (Standard Full Rack)</option>
            <option value="48">48U (Large Rack)</option>
            <option value="24">24U (Half Rack)</option>
            <option value="12">12U (Small/Wall Mount)</option>
            <option value="6">6U (Mini Rack)</option>
          </select>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="add-rack-cancel">Cancel</button>
          <button class="btn-save" id="add-rack-save">Add Rack</button>
        </div>
      </div>
    </div>
    <div class="modal confirm-modal" id="clear-all-modal">
      <div class="modal-content">
        <h3>Clear All Nodes</h3>
        <p> This will remove ALL nodes and connections. This cannot be undone until you reload without saving. Are you sure? </p>
        <div class="modal-buttons">
          <button class="btn-cancel" id="clear-all-cancel">Cancel</button>
          <button class="btn-delete" id="clear-all-confirm">Clear Everything</button>
        </div>
      </div>
    </div>
    <div class="modal" id="layer-modal">
      <div class="modal-content" style="max-width: 400px;">
        <h3>Layer Visibility</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Toggle which layers are visible on the canvas</p>
        <div style="display: flex; flex-direction: column; gap: 10px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-physical" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Physical Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-logical" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Logical Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-security" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Security Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-application" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Application Layer</span>
          </label>
        </div>
        <div style="margin-top: 15px; display: flex; gap: 8px;">
          <button class="btn-cancel" style="flex: 1;" onclick="document.querySelectorAll('#layer-modal input[type=checkbox]').forEach(cb =&gt; cb.checked = false); applyLayerFilter();">Hide All</button>
          <button class="btn-save" style="flex: 1;" onclick="document.querySelectorAll('#layer-modal input[type=checkbox]').forEach(cb =&gt; cb.checked = true); applyLayerFilter();">Show All</button>
        </div>
        <div class="modal-buttons" style="margin-top: 10px;">
          <button class="btn-cancel" id="layer-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div id="context-menu" style="display: none !important;">
    </div>
    <header>
      <div class="title-block">
        <h1 id="page-title" class="editable-page-title">The One File</h1>
        <div class="save-row">
          <button id="save-file-btn" class="save-btn" type="button">Save File</button>
          <label style="display: flex;align-items: center;gap: 4px;font-size: 12px;color: var(--text-soft);cursor: pointer;user-select: none;">
          <input type="checkbox" id="encrypt-toggle" style="cursor: pointer">
          <span title="Encrypt data with password">Encrypt</span>
          </label>
          <span id="save-help-btn" class="help-icon" title="Why save?">?</span>
        </div>
      </div>
      <div id="topbar-menu">
        <button id="back-to-topology-btn" title="Exit rack view and return to topology" style="padding: 6px 12px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;display: none;">‚Üê Back to Topology</button>
        <button id="add-node-btn" class="save-btn" title="Add new node" style="background: var(--accent)">+ Node</button>
        <button id="add-rack-btn" class="save-btn" title="Add new rack" style="background: var(--accent); margin-left: 8px;">+ Rack</button>
        <button id="undo-btn" title="Undo (Ctrl+Z)" style="padding: 6px 12px; background: var(--btn-bg); color: var(--btn-text); border: 1px solid var(--edge-main); border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600; opacity: 1;">‚Ü∂</button>
        <button id="redo-btn" title="Redo (Ctrl+Y)" style="padding: 6px 12px; background: var(--btn-bg); color: var(--btn-text); border: 1px solid var(--edge-main); border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600; opacity: 0.5;" disabled="">‚Ü∑</button>
<input type="text" id="search-nodes" placeholder="Search nodes..." title="Search by name, IP, MAC, role, or tag" style="padding: 6px 12px;background: var(--input-bg);color: var(--input-text);border: 1px solid var(--input-border);border-radius: 6px;font-family: var(--input-font);font-size: var(--input-font-size);width: 180px;">
        <button id="check-all-ping-btn" title="Check status of all enabled nodes" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600">Check Pings</button>
        <button id="layers-btn" title="Toggle layer visibility" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Layers</button>
        <button id="tabs-btn" title="Manage document tabs" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Tabs</button>
        <button id="rollback-btn" title="View version history" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Snapshots</button>
        <button id="audit-log-btn" title="View audit log" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Audit</button>
        <button id="port-map-btn" title="View all port connections" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Ports</button>
        <button id="secrets-btn" title="Manage encrypted notes" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Notes</button>
        <button onclick="screenshotCanvas()" title="Export canvas as PNG image" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">PNG</button>
        <button onclick="exportCanvasSVG()" title="Export canvas as SVG vector" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">SVG</button>
        <button id="settings-btn" title="Page settings">‚öôÔ∏è</button>
      </div>
      <button id="mobile-menu-toggle" class="mobile-menu-btn">‚ò∞</button>
      <div class="header-resizer" id="header-resizer">
        <svg class="resizer-icon" width="40" height="6" viewBox="0 0 40 6" xmlns="http://www.w3.org/2000/svg">
          <circle cx="14" cy="3" r="2"></circle>
          <circle cx="20" cy="3" r="2"></circle>
          <circle cx="26" cy="3" r="2"></circle>
        </svg>
      </div>
    </header>
    <main>
      <section class="topology-panel">
        <div class="draw-toolbar" id="draw-toolbar" style="display: flex !important;">
          <button type="button" class="toolbar-close-btn" id="draw-toolbar-close-btn" title="Hide draw toolbar">‚úï</button>
          <button id="draw-toggle" title="Draw custom line">‚úèÔ∏è</button>
          <button id="rect-toggle" title="Draw zone">‚ñ≠</button>
          <button id="text-toggle" title="Add text">T</button>
          <select id="rect-style" title="zone style">
            <option value="filled">Filled</option>
            <option value="outlined">Outlined</option>
          </select>
          <input type="color" id="draw-color" value="#f97316" title="Line color">
          <select id="draw-style" title="Line style">
            <option value="solid">Solid</option>
            <option value="dashed">Dashed</option>
            <option value="dotted">Dotted</option>
          </select>
          <select id="draw-arrow" title="Arrow direction">
            <option value="none">No arrows</option>
            <option value="forward">‚Üí Right</option>
            <option value="backward">‚Üê Left</option>
            <option value="both">‚Üî Both</option>
          </select>
          <button id="draw-undo" style="display: none" title="Undo last point">Undo</button>
        </div>
        <div class="topology-toolbar" id="topology-toolbar" style="display: flex !important;">
          <button type="button" class="toolbar-close-btn" id="topology-toolbar-close-btn" title="Hide add line toolbar">‚úï</button>
          <label for="add-line-select">Add line to:</label>
          <select id="add-line-select"><option value="core-router-2">Core Router 2</option><option value="fw-external-1">External FW 1</option><option value="fw-external-2">External FW 2</option><option value="fw-internal">Internal FW</option><option value="core-switch-1">Core Switch 1</option><option value="core-switch-2">Core Switch 2</option><option value="dc-rack-a1">DC Rack A1</option><option value="dc-rack-a2">DC Rack A2</option><option value="dc-rack-b1">DC Rack B1</option><option value="dc-rack-b2">DC Rack B2</option><option value="dmz-rack">DMZ Rack</option><option value="mgmt-rack">Management Rack</option><option value="wlc-primary">WLC Primary</option><option value="wlc-secondary">WLC Secondary</option><option value="mobile-zone-hq">HQ Mobile Zone</option><option value="mobile-zone-guest">Guest WiFi Zone</option><option value="mobile-zone-iot">IoT Device Zone</option><option value="branch-router-ny">NYC Branch Router</option><option value="branch-router-la">LA Branch Router</option><option value="branch-router-chi">Chicago Branch Router</option><option value="branch-router-lon">London Branch Router</option><option value="branch-router-tokyo">Tokyo Branch Router</option><option value="cloud-aws">AWS Cloud</option><option value="cloud-azure">Azure Cloud</option><option value="cloud-gcp">GCP Cloud</option><option value="isp-primary">ISP Primary</option><option value="isp-secondary">ISP Secondary</option><option value="proxy-server-1">Proxy Server 1</option><option value="proxy-server-2">Proxy Server 2</option><option value="vpn-concentrator">VPN Concentrator</option><option value="nac-server">NAC Server</option><option value="voip-cluster">VoIP Cluster</option><option value="video-conf">Video Conference</option><option value="security-cameras">Security Cameras</option><option value="dev-server-1">Dev Server 1</option><option value="dev-server-2">Dev Server 2</option><option value="test-environment">Test Environment</option><option value="erp-system">ERP System</option><option value="crm-system">CRM System</option><option value="endpoint-1000">Corporate Endpoints</option><option value="dist-switch-floor1">Floor 1 Switch</option><option value="dist-switch-floor2">Floor 2 Switch</option><option value="dist-switch-floor3">Floor 3 Switch</option><option value="dist-switch-floor4">Floor 4 Switch</option><option value="ap-floor1-zone1">AP Floor 1 Zone 1</option><option value="ap-floor2-zone1">AP Floor 2 Zone 1</option><option value="ap-floor3-zone1">AP Floor 3 Zone 1</option><option value="ap-floor4-zone1">AP Floor 4 Zone 1</option><option value="ups-dc-1">UPS DC-1</option><option value="ups-dc-2">UPS DC-2</option><option value="cooling-1">CRAC Unit 1</option><option value="cooling-2">CRAC Unit 2</option></select>
<input type="color" id="add-line-color" value="#475569" title="Line color" style="width: 30px;height: 24px;border: 1px solid var(--toolbar-border);border-radius: 4px;cursor: pointer;background: transparent;padding: 0;">          <select id="add-line-direction" title="Line direction">
            <option value="none">No arrows</option>
            <option value="forward">‚Üí Forward</option>
            <option value="backward">‚Üê Backward</option>
            <option value="both">‚Üî Both</option>
          </select>
          <button id="add-line-btn">Add</button>
        </div>
        <div class="topology-toolbar bulk-toolbar-desktop" id="bulk-toolbar" style="display: none">
          <button type="button" class="toolbar-close-btn" id="bulk-toolbar-close" title="Clear selection">‚úï</button>
          <label style="font-weight: 600; color: var(--accent)">Selected: <span id="bulk-count">0</span></label>
          <button id="bulk-align-left" title="Align left">‚¨Ö Left</button>
          <button id="bulk-align-right" title="Align right">‚û° Right</button>
          <button id="bulk-align-top" title="Align top">‚¨Ü Top</button>
          <button id="bulk-align-bottom" title="Align bottom">‚¨á Bottom</button>
          <button id="bulk-distribute-h" title="Distribute horizontally">‚Üî Distribute H</button>
          <button id="bulk-distribute-v" title="Distribute vertically">‚Üï Distribute V</button>
          <button id="bulk-clone" title="Clone selected">üìã Clone</button>
          <button id="bulk-delete" title="Delete selected" style="background: var(--danger); color: white;">Delete</button>
        </div>
        <div class="bulk-toolbar-mobile" id="bulk-toolbar-mobile" style="display: none">
          <button type="button" id="bulk-mobile-btn" style="background: var(--accent);color: white;padding: 12px 20px;border-radius: 25px;font-weight: 600;font-size: 16px;box-shadow: 0 4px 12px rgba(0,0,0,0.3);border: none;cursor: pointer;display: flex;align-items: center;gap: 8px;">
          <span id="bulk-count-mobile">0</span>Selected</button>
        </div>
        <div id="bulk-actions-modal" style="display: none;position: fixed;bottom: 0;left: 0;right: 0;background: var(--panel-alt);border-top-left-radius:20px;border-top-right-radius:20px;padding:20px;padding-bottom:(safe-area-inset-bottom, 20px);box-shadow: 0 -4px 20px rgba(0,0,0,0.5);z-index: 10000;max-height: calc(100vh - 80px);overflow-y: auto;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            <h3 style="margin: 0; color: var(--accent); font-size: 20px;">
              <span id="bulk-count-modal">0</span> Nodes Selected
            </h3>
            <button id="bulk-modal-close" style="background: none;border: none;font-size: 24px;cursor: pointer;color: var(--text-main);padding: 0;width: 32px;height: 32px;">‚úï</button>
          </div>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
            <button id="bulk-align-left-mobile" class="bulk-action-btn">‚¨Ö<br><span style="font-size: 12px;">Align Left</span></button>
            <button id="bulk-align-right-mobile" class="bulk-action-btn">‚û°<br><span style="font-size: 12px;">Align Right</span></button>
            <button id="bulk-align-top-mobile" class="bulk-action-btn">‚¨Ü<br><span style="font-size: 12px;">Align Top</span></button>
            <button id="bulk-align-bottom-mobile" class="bulk-action-btn">‚¨á<br><span style="font-size: 12px;">Align Bottom</span></button>
            <button id="bulk-distribute-h-mobile" class="bulk-action-btn">‚Üî<br><span style="font-size: 12px;">Distribute H</span></button>
            <button id="bulk-distribute-v-mobile" class="bulk-action-btn">‚Üï<br><span style="font-size: 12px;">Distribute V</span></button>
            <button id="bulk-lock-mobile" class="bulk-action-btn">üîí<br><span style="font-size: 12px;">Lock Toggle</span></button>
            <button id="bulk-group-mobile" class="bulk-action-btn">‚≠ï<br><span style="font-size: 12px;">Group Toggle</span></button>
            <button id="bulk-clone-mobile" class="bulk-action-btn">üìã<br><span style="font-size: 12px;">Clone All</span></button>
            <button id="bulk-delete-mobile" class="bulk-action-btn" style="background: var(--danger); color: white;">üóë<br><span style="font-size: 12px;">Delete All</span></button>
          </div>
          <button id="bulk-clear-mobile" style="width: 100%;margin-top: 16px;padding: 14px;background: var(--panel-main);border: 1px solid var(--edge-main);border-radius: 8px;color: var(--text-main);font-size: 16px;cursor: pointer;">Clear Selection</button>
        </div>
        <div class="canvas-hint" id="canvas-hint"></div>
        <div class="legend-container" id="edge-legend" style="display: flex;"><div class="legend-title">Line Legend</div><button type="button" class="legend-close-btn">‚úï</button><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(85, 226, 8); cursor: pointer;"></span><span class="legend-label" contenteditable="true">ISP LINE</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(76, 0, 255); cursor: pointer;"></span><span class="legend-label" contenteditable="true">MY Guest NETWORK</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(128, 255, 0); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(251, 0, 255); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(255, 0, 208); cursor: pointer;"></span><span class="legend-label" contenteditable="true">iPhone (always guest iPhone)</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(249, 115, 22); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div></div>
        <div class="canvas-viewport" id="canvas-viewport">
          <svg id="map" viewBox="1254.5197896196048 -147.55422459755366 2648.185035176588 1986.138776382441" style=""><defs><marker id="arrow-forward" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto" markerUnits="strokeWidth"><path d="M0,0 L0,6 L9,3 z" fill="context-stroke"></path></marker><marker id="arrow-backward" markerWidth="10" markerHeight="10" refX="0" refY="3" orient="auto" markerUnits="strokeWidth"><path d="M9,0 L9,6 L0,3 z" fill="context-stroke"></path></marker></defs><rect x="100" y="100" width="3800" height="2800" fill="none" stroke="#4755694D" stroke-width="20" stroke-dasharray="10 5" rx="8"></rect><g id="canvas-grid"><line x1="100" y1="100" x2="100" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="150" y1="100" x2="150" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="200" y1="100" x2="200" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="250" y1="100" x2="250" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="300" y1="100" x2="300" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="350" y1="100" x2="350" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="400" y1="100" x2="400" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="450" y1="100" x2="450" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="500" y1="100" x2="500" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="550" y1="100" x2="550" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="600" y1="100" x2="600" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="650" y1="100" x2="650" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="700" y1="100" x2="700" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="750" y1="100" x2="750" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="800" y1="100" x2="800" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="850" y1="100" x2="850" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="900" y1="100" x2="900" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="950" y1="100" x2="950" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1000" y1="100" x2="1000" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1050" y1="100" x2="1050" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1100" y1="100" x2="1100" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="1150" y1="100" x2="1150" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1200" y1="100" x2="1200" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1250" y1="100" x2="1250" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1300" y1="100" x2="1300" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1350" y1="100" x2="1350" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="1400" y1="100" x2="1400" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1450" y1="100" x2="1450" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1500" y1="100" x2="1500" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1550" y1="100" x2="1550" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1600" y1="100" x2="1600" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="1650" y1="100" x2="1650" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1700" y1="100" x2="1700" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1750" y1="100" x2="1750" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1800" y1="100" x2="1800" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1850" y1="100" x2="1850" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="1900" y1="100" x2="1900" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1950" y1="100" x2="1950" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2000" y1="100" x2="2000" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2050" y1="100" x2="2050" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2100" y1="100" x2="2100" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="2150" y1="100" x2="2150" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2200" y1="100" x2="2200" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2250" y1="100" x2="2250" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2300" y1="100" x2="2300" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2350" y1="100" x2="2350" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="2400" y1="100" x2="2400" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2450" y1="100" x2="2450" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2500" y1="100" x2="2500" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2550" y1="100" x2="2550" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2600" y1="100" x2="2600" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="2650" y1="100" x2="2650" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2700" y1="100" x2="2700" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2750" y1="100" x2="2750" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2800" y1="100" x2="2800" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2850" y1="100" x2="2850" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="2900" y1="100" x2="2900" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2950" y1="100" x2="2950" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3000" y1="100" x2="3000" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3050" y1="100" x2="3050" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3100" y1="100" x2="3100" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="3150" y1="100" x2="3150" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3200" y1="100" x2="3200" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3250" y1="100" x2="3250" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3300" y1="100" x2="3300" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3350" y1="100" x2="3350" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="3400" y1="100" x2="3400" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3450" y1="100" x2="3450" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3500" y1="100" x2="3500" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3550" y1="100" x2="3550" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3600" y1="100" x2="3600" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="3650" y1="100" x2="3650" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3700" y1="100" x2="3700" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3750" y1="100" x2="3750" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3800" y1="100" x2="3800" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3850" y1="100" x2="3850" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="3900" y1="100" x2="3900" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="100" x2="3900" y2="100" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="150" x2="3900" y2="150" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="200" x2="3900" y2="200" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="250" x2="3900" y2="250" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="300" x2="3900" y2="300" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="350" x2="3900" y2="350" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="400" x2="3900" y2="400" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="450" x2="3900" y2="450" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="500" x2="3900" y2="500" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="550" x2="3900" y2="550" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="600" x2="3900" y2="600" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="650" x2="3900" y2="650" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="700" x2="3900" y2="700" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="750" x2="3900" y2="750" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="800" x2="3900" y2="800" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="850" x2="3900" y2="850" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="900" x2="3900" y2="900" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="950" x2="3900" y2="950" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1000" x2="3900" y2="1000" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1050" x2="3900" y2="1050" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1100" x2="3900" y2="1100" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="1150" x2="3900" y2="1150" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1200" x2="3900" y2="1200" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1250" x2="3900" y2="1250" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1300" x2="3900" y2="1300" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1350" x2="3900" y2="1350" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="1400" x2="3900" y2="1400" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1450" x2="3900" y2="1450" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1500" x2="3900" y2="1500" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1550" x2="3900" y2="1550" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1600" x2="3900" y2="1600" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="1650" x2="3900" y2="1650" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1700" x2="3900" y2="1700" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1750" x2="3900" y2="1750" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1800" x2="3900" y2="1800" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1850" x2="3900" y2="1850" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="1900" x2="3900" y2="1900" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1950" x2="3900" y2="1950" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2000" x2="3900" y2="2000" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2050" x2="3900" y2="2050" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2100" x2="3900" y2="2100" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="2150" x2="3900" y2="2150" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2200" x2="3900" y2="2200" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2250" x2="3900" y2="2250" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2300" x2="3900" y2="2300" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2350" x2="3900" y2="2350" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="2400" x2="3900" y2="2400" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2450" x2="3900" y2="2450" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2500" x2="3900" y2="2500" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2550" x2="3900" y2="2550" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2600" x2="3900" y2="2600" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="2650" x2="3900" y2="2650" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2700" x2="3900" y2="2700" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2750" x2="3900" y2="2750" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2800" x2="3900" y2="2800" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2850" x2="3900" y2="2850" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="2900" x2="3900" y2="2900" stroke="#47556933" stroke-width="1"></line></g><g class="rect-group" data-rect-id="rect-1765238219615"><rect class="rect-shape" x="2680.053955078125" y="251.44879150390625" width="814.10400390625" height="389.26678466796875" style="fill: rgb(236, 9, 153); fill-opacity: 0.3; stroke: rgb(236, 9, 153); stroke-width: 2px; stroke-dasharray: none; cursor: move;"></rect><g class="rect-delete-btn" style="cursor: pointer; display: none;"><circle cx="3484.157958984375" cy="261.44879150390625" r="12" style="fill: rgb(245, 101, 101); stroke: white; stroke-width: 2;"></circle><text x="3484.157958984375" y="261.44879150390625" text-anchor="middle" dominant-baseline="middle" style="fill: white; font-size: 16px; font-weight: bold; pointer-events: none;">√ó</text></g></g><path d="M 2103.968290880771 268 Q 2085.4680212352528 370.70595670887826 2066.9677515897347 473.4119134177565" fill="none" class="edge" data-edge-id="internet-internet-copy-1765238145151" data-from="internet" data-to="internet-copy" style="stroke: rgb(85, 226, 8); stroke-width: 4;"></path><path d="M 2103.968290880771 268 Q 2085.4680212352528 370.70595670887826 2066.9677515897347 473.4119134177565" fill="none" data-edge-id="internet-internet-copy-1765238145151" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 1920.4039088162972 569.9938683738112 1773.8400660428597 666.5758233298659" fill="none" class="edge" data-edge-id="internet-copy-opnsense-copy-1765238187451" data-from="internet-copy" data-to="opnsense-copy" style="stroke: rgb(76, 0, 255); stroke-width: 4;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 1920.4039088162972 569.9938683738112 1773.8400660428597 666.5758233298659" fill="none" data-edge-id="internet-copy-opnsense-copy-1765238187451" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 1999.08282329894 627.8447547749242 1931.1978950081452 782.2775961320921" fill="none" class="edge" data-edge-id="internet-copy-docker-copy-1765238242477" data-from="internet-copy" data-to="docker-copy" style="stroke: rgb(76, 0, 255); stroke-width: 4;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 1999.08282329894 627.8447547749242 1931.1978950081452 782.2775961320921" fill="none" data-edge-id="internet-copy-docker-copy-1765238242477" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2112.546995662221 620.5620704487524 2158.1262397347077 767.7122274797483" fill="none" class="edge" data-edge-id="internet-copy-docker-copy-1-1765238244637" data-from="internet-copy" data-to="docker-copy-1" style="stroke: rgb(76, 0, 255); stroke-width: 4;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2112.546995662221 620.5620704487524 2158.1262397347077 767.7122274797483" fill="none" data-edge-id="internet-copy-docker-copy-1-1765238244637" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2204.617064021596 552.590055067893 2342.2663764534577 631.7681967180296" fill="none" class="edge" data-edge-id="internet-copy-docker-copy-2-1765238246233" data-from="internet-copy" data-to="docker-copy-2" style="stroke: rgb(76, 0, 255); stroke-width: 4;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2204.617064021596 552.590055067893 2342.2663764534577 631.7681967180296" fill="none" data-edge-id="internet-copy-docker-copy-2-1765238246233" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2103.968290880771 268 Q 2430.923885484287 287.80585580459456 2757.879480087803 307.6117116091891" fill="none" class="edge" data-edge-id="internet-opnsense-copy-1-1765238266117" data-from="internet" data-to="opnsense-copy-1" style="stroke: rgb(128, 255, 0); stroke-width: 4;"></path><path d="M 2103.968290880771 268 Q 2430.923885484287 287.80585580459456 2757.879480087803 307.6117116091891" fill="none" data-edge-id="internet-opnsense-copy-1-1765238266117" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2757.879480087803 307.6117116091891 Q 2979.171899521397 314.04065142852505 3200.4643189549906 320.469591247861" fill="none" class="edge" data-edge-id="opnsense-copy-1-dns-1765238347996" data-from="opnsense-copy-1" data-to="dns" style="stroke: rgb(251, 0, 255); stroke-width: 4;"></path><path d="M 2757.879480087803 307.6117116091891 Q 2979.171899521397 314.04065142852505 3200.4643189549906 320.469591247861" fill="none" data-edge-id="opnsense-copy-1-dns-1765238347996" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 3200.4643189549906 320.469591247861 Q 3086.0821778417094 400.59916888457974 2971.700036728428 480.7287465212985" fill="none" class="edge" data-edge-id="dns-desktop-1765238386101" data-from="dns" data-to="desktop" style="stroke: rgb(255, 0, 208); stroke-width: 4;"></path><path d="M 3200.4643189549906 320.469591247861 Q 3086.0821778417094 400.59916888457974 2971.700036728428 480.7287465212985" fill="none" data-edge-id="dns-desktop-1765238386101" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 3312.857751572178 502.58220111114224 Q 3256.6610352635844 411.5258961795016 3200.4643189549906 320.469591247861" fill="none" class="edge" data-edge-id="phone-dns-1765238391156" data-from="phone" data-to="dns" style="stroke: rgb(255, 0, 208); stroke-width: 4;"></path><path d="M 3312.857751572178 502.58220111114224 Q 3256.6610352635844 411.5258961795016 3200.4643189549906 320.469591247861" fill="none" data-edge-id="phone-dns-1765238391156" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><polyline class="edge" data-edge-id="custom-1765239449323" fill="none" marker-end="url(#arrow-forward)" points="2936.464111328125,786.07958984375 3184.112060546875,887.6153564453125 2763.110107421875,981.7216796875" style="stroke: rgb(249, 115, 22); stroke-width: 4; stroke-dasharray: none;"></polyline><polyline points="2936.464111328125,786.07958984375 3184.112060546875,887.6153564453125 2763.110107421875,981.7216796875" data-edge-id="custom-1765239449323" style="fill: none; stroke: transparent; stroke-width: 20; cursor: pointer;"></polyline><g class="node-group" data-node-id="internet" transform="translate(2103.968290880771,268)" style="cursor: grab;"><circle r="252" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" viewBox="0 0 512 512" width="201.6" height="201.6" x="-100.8" y="-100.8" style="fill: rgb(255, 255, 255); stroke: rgb(255, 255, 255);"><path d="M144.3 214.1c0 6.3.7 11.4 1.9 15.2 1.4 3.7 3.1 7.8 5.4 12.3.9 1.4 1.2 2.7 1.2 3.9 0 1.7-1 3.4-3.2 5.1l-10.7 7.2c-1.5 1-3.1 1.5-4.4 1.5-1.7 0-3.4-.9-5.1-2.4-2.4-2.6-4.4-5.3-6.1-8-1.7-2.9-3.4-6.1-5.3-10-13.3 15.7-30 23.5-50.1 23.5-14.3 0-25.7-4.1-34.1-12.3-8.3-8.2-12.6-19.1-12.6-32.7 0-14.5 5.1-26.2 15.5-35.1S60.8 169 78.4 169c5.8 0 11.7.5 18.1 1.4s12.8 2.2 19.6 3.7v-12.4c0-12.9-2.7-22-8-27.2-5.4-5.3-14.6-7.8-27.8-7.8-6 0-12.1.7-18.4 2.2s-12.4 3.4-18.4 5.8c-2.7 1.2-4.8 1.9-6 2.2s-2 .5-2.7.5c-2.4 0-3.6-1.7-3.6-5.3v-8.3c0-2.7.3-4.8 1.2-6s2.4-2.4 4.8-3.6c6-3.1 13.1-5.6 21.5-7.7 8.3-2.2 17.2-3.2 26.6-3.2 20.3 0 35.1 4.6 44.6 13.8 9.4 9.2 14.1 23.2 14.1 41.9v55.2zM75.2 240c5.6 0 11.4-1 17.5-3.1 6.1-2 11.6-5.8 16.2-10.9 2.7-3.2 4.8-6.8 5.8-10.9s1.7-9 1.7-14.8v-7.2c-4.9-1.2-10.2-2.2-15.7-2.9-5.4-.7-10.7-1-16-1-11.4 0-19.8 2.2-25.4 6.8S51 207.1 51 215.6c0 8 2 14 6.3 18.1 4.1 4.2 10 6.3 17.9 6.3m136.7 18.4c-3.1 0-5.1-.5-6.5-1.7-1.4-1-2.6-3.4-3.6-6.6l-40-131.6c-1-3.4-1.5-5.6-1.5-6.8 0-2.7 1.4-4.3 4.1-4.3h16.7c3.2 0 5.4.5 6.6 1.7 1.4 1 2.4 3.4 3.4 6.6l28.6 112.7 26.6-112.7c.9-3.4 1.9-5.6 3.2-6.6 1.4-1 3.7-1.7 6.8-1.7H270c3.2 0 5.4.5 6.8 1.7 1.4 1 2.6 3.4 3.2 6.6l26.9 114.1 29.5-114.1c1-3.4 2.2-5.6 3.4-6.6 1.4-1 3.6-1.7 6.6-1.7h15.8c2.7 0 4.3 1.4 4.3 4.3 0 .9-.2 1.7-.3 2.7-.2 1-.5 2.4-1.2 4.3l-41 131.6q-1.5 5.1-3.6 6.6c-1.4 1-3.6 1.7-6.5 1.7h-14.6c-3.2 0-5.4-.5-6.8-1.7s-2.6-3.4-3.2-6.8l-26.4-109.8L236.7 250c-.9 3.4-1.9 5.6-3.2 6.8-1.4 1.2-3.7 1.7-6.8 1.7zm218.8 4.6c-8.9 0-17.7-1-26.2-3.1-8.5-2-15.2-4.3-19.6-6.8-2.7-1.5-4.6-3.2-5.3-4.8s-1-3.2-1-4.8v-8.7c0-3.6 1.4-5.3 3.9-5.3 1 0 2 .2 3.1.5 1 .3 2.6 1 4.3 1.7 5.8 2.6 12.1 4.6 18.7 6 6.8 1.4 13.5 2 20.3 2 10.7 0 19.1-1.9 24.9-5.6s8.9-9.2 8.9-16.2c0-4.8-1.5-8.7-4.6-11.9s-8.9-6.1-17.2-8.9l-24.7-7.7c-12.4-3.9-21.6-9.7-27.2-17.4-5.6-7.5-8.5-15.8-8.5-24.7 0-7.2 1.5-13.5 4.6-18.9s7.2-10.2 12.3-14c5.1-3.9 10.9-6.8 17.7-8.9 6.8-2 14-2.9 21.5-2.9 3.7 0 7.7.2 11.4.7 3.9.5 7.5 1.2 11.1 1.9 3.4.9 6.6 1.7 9.7 2.7s5.4 2 7.2 3.1c2.4 1.4 4.1 2.7 5.1 4.3 1 1.4 1.5 3.2 1.5 5.6v8c0 3.6-1.4 5.4-3.9 5.4-1.4 0-3.6-.7-6.5-2q-14.55-6.6-32.7-6.6c-9.7 0-17.4 1.5-22.6 4.8s-8 8.2-8 15.2c0 4.8 1.7 8.9 5.1 12.1s9.7 6.5 18.7 9.4l24.2 7.7c12.3 3.9 21.1 9.4 26.4 16.3s7.8 15 7.8 23.8c0 7.3-1.5 14-4.4 19.8-3.1 5.8-7.2 10.9-12.4 15-5.3 4.3-11.6 7.3-18.9 9.5-8 2.5-16 3.7-24.7 3.7" style="fill: rgb(255, 255, 255); stroke: rgb(255, 255, 255);"></path><path d="M462.9 345.7c-56 41.4-137.4 63.3-207.4 63.3-98.1 0-186.5-36.3-253.2-96.6-5.3-4.8-.5-11.2 5.8-7.5 72.2 41.9 161.3 67.3 253.4 67.3 62.2 0 130.4-12.9 193.3-39.5 9.3-4.2 17.3 6.2 8.1 13m23.3-26.5c-7.2-9.2-47.3-4.4-65.6-2.2-5.4.7-6.3-4.1-1.4-7.7 32-22.5 84.6-16 90.8-8.5 6.1 7.7-1.7 60.3-31.7 85.5-4.6 3.9-9 1.9-7-3.2 6.9-16.9 22.1-54.9 14.9-63.9" style="fill-rule: evenodd; clip-rule: evenodd; fill: rgb(255, 255, 255); stroke: rgb(255, 255, 255);"></path></svg></g><text class="node-label" x="0" y="-47.040000000000006" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Internet</text><text class="node-sub" x="0" y="67.2" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="internet-copy" transform="translate(2066.9677515897347,473.4119134177565)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" viewBox="0 0 512 512" width="66" height="66" x="-33" y="-33"><path d="M512 160.2V400H400V112H112V0h240.4zM112 112H0v240.4L160.2 512H400V400H112z" style="fill:#de3c07"></path></svg></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">OPNSENSE</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="opnsense-copy" transform="translate(1773.8400660428597,666.5758233298659)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" viewBox="0 0 512 512" width="66" height="66" x="-33" y="-33"><path d="M462.2 512H49.8C22.3 512 0 489.7 0 462.2V49.8C0 22.3 22.3 0 49.8 0h412.4C489.7 0 512 22.3 512 49.8v412.4c0 27.5-22.3 49.8-49.8 49.8" style="fill:#2e2f33"></path><path d="M108.2 63.9h140.9c97.2 0 154.6 30.4 154.6 129.5v3.4c0 99.4-57.2 129.5-154.5 129.5h-30.7V447H108.2zm134.5 177.8c30.1 0 46-11.2 46-44.6v-3.9c0-33.2-15.8-44.6-46-44.6h-24.2v93.1zM313 358h90.3v90.1H313z" style="fill:#f7f6f3"></path></svg></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Docker</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="docker-copy" transform="translate(1931.1978950081452,782.2775961320921)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" viewBox="0 0 512 512" width="66" height="66" x="-33" y="-33"><path d="M438.6 0H73.4C33.1 0 .3 32.8.3 73.1v365.7c0 40.3 32.8 73.1 73.1 73.1h365.3c40.3 0 73.1-32.8 73.1-73.1V73.1C511.7 32.8 478.9 0 438.6 0" style="fill-rule:evenodd;clip-rule:evenodd;fill:#8b3bd0"></path><path d="M356.8 53.6v261.3c0 39.3-13.9 72.8-41.8 100.7s-61.4 41.8-100.7 41.8l-23.8-95h23.8c13 0 24.1-4.6 33.2-13.8 9.5-9.5 14.3-20.7 14.3-33.7V148.6H157.3v-95z" style="fill:#fff"></path></svg></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Docker2</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="docker-copy-1" transform="translate(2158.1262397347077,767.7122274797483)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" viewBox="0 0 512 512" width="66" height="66" x="-33" y="-33"><path d="M0 0h512v512H0z" style="fill:#111827"></path><path d="M170.7 85.3 369.8 256 170.7 426.7z" style="fill:#f59e0b"></path></svg></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Docker3</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="docker-copy-2" transform="translate(2342.2663764534577,631.7681967180296)" style="cursor: grab;"><circle r="123" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" viewBox="0 0 512 512" width="98.39999999999999" height="98.39999999999999" x="-49.199999999999996" y="-49.199999999999996"><path d="M501.4 212.3c-11.5-8-38-11-58.6-7-2.4-20-13.5-37.5-32.7-53l-11-8-7.7 11.5c-9.6 15-14.4 36-13 56 .5 7 2.9 19.5 10.1 30.5-6.7 4-20.7 9-38.9 9H2.3l-1 4c-3.4 20-3.4 82.5 36 130.5 29.8 36.5 74 55 132.1 55 125.9 0 219.1-60.5 262.8-170 17.3.5 54.3 0 73-37.5.5-1 1.4-3 4.8-10.5l1.9-4zM280 71.3h-52.8v50H280zm0 60h-52.8v50H280zm-62.5 0h-52.8v50h52.8zm-62.4 0h-52.8v50h52.8zm-62.5 60H39.8v50h52.8zm62.5 0h-52.8v50h52.8zm62.4 0h-52.8v50h52.8zm62.5 0h-52.8v50H280zm62.4 0h-52.8v50h52.8z" style="fill:#2396ed"></path></svg></g><text class="node-label" x="0" y="-22.96" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Docker 4</text><text class="node-sub" x="0" y="32.800000000000004" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="opnsense-copy-1" transform="translate(2757.879480087803,307.6117116091891)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" viewBox="0 0 512 512" width="66" height="66" x="-33" y="-33"><path d="M503.1 465.4v2.1c-6 25.5-28.4 44.5-55 44.5H7.3v-46.6h38.3v7.3h403c1.1 0 2 0 2.9-.1 1.8-.1 3.6-.6 5.2-1.3 2.9-1.3 5.3-3.3 7-5.9zM63.9 0c-26.5 0-49 19-55 44.5V47H48c2.7-4.3 7.3-7.2 12.6-7.6 1-.1 2-.1 3.2-.1h402.6V47h38.3V0z" style="fill:#898b8d"></path><path d="M466.1 157.7V197H319.5v-39.3zM45.9 315.4v39.3h146.6v-39.3zm0-157.7V197h146.6v-39.3zm273.6 157.7v39.3h146.6v-39.3z" style="fill:#58595b"></path><path d="M83.8 78.6H428v39.3H83.8zm0 315.9H428v39.3H83.8z" style="fill:#403f41"></path><linearGradient id="opnsense-v1_svg__a" x1="-1460.617" x2="-1375.11" y1="1248.095" y2="1248.095" gradientTransform="matrix(.1853 .356 .6722 -.353 -90.66 993.802)" gradientUnits="userSpaceOnUse"><stop offset="0" style="stop-color:#737373"></stop><stop offset="1" style="stop-color:#333"></stop></linearGradient><path d="m466.5 78.6 38.2-20.5.1-39.5-38.3 20.7" style="fill:url(#opnsense-v1_svg__a)"></path><linearGradient id="opnsense-v1_svg__b" x1="4.634" x2="50.301" y1="462.6" y2="462.6" gradientTransform="matrix(1 0 0 -1 0 514)" gradientUnits="userSpaceOnUse"><stop offset="0" style="stop-color:#737373"></stop><stop offset="1" style="stop-color:#333"></stop></linearGradient><path d="M45.6 64.5v-8.9c0-5.3 2.6-10 6.5-13l-34-18.5c-6.7 9.5-10.8 21.3-10.9 34l38.3 20.6v-14c.1-.1.1-.2.1-.2" style="fill:url(#opnsense-v1_svg__b)"></path><linearGradient id="opnsense-v1_svg__c" x1="-1587.887" x2="-1498.137" y1="-2208.165" y2="-2208.165" gradientTransform="matrix(-.1853 -.356 -.6722 .353 -1743.836 694.098)" gradientUnits="userSpaceOnUse"><stop offset="0" style="stop-color:#737373"></stop><stop offset="1" style="stop-color:#333"></stop></linearGradient><path d="M45.6 472.7v-38.9L7.3 454.5v39.7l39.9-21.5z" style="fill:url(#opnsense-v1_svg__c)"></path><linearGradient id="opnsense-v1_svg__d" x1="460.439" x2="504.436" y1="53" y2="53" gradientTransform="matrix(1 0 0 -1 0 514)" gradientUnits="userSpaceOnUse"><stop offset="0" style="stop-color:#737373"></stop><stop offset="1" style="stop-color:#333"></stop></linearGradient><path d="M466.5 456.4c0 5.5-2.7 10.3-6.9 13.2l34.2 18.4c6.8-9.5 10.8-21.2 10.9-33.8L466.5 434v12.8" style="fill:url(#opnsense-v1_svg__d)"></path><linearGradient id="opnsense-v1_svg__e" x1="2521.902" x2="2684.464" y1="-2476.233" y2="-2476.233" gradientTransform="matrix(-1.508 -1.0166 -3.1265 -1.519 -3697.438 -937.952)" gradientUnits="userSpaceOnUse"><stop offset=".107" style="stop-color:#58595b"></stop><stop offset="1" style="stop-color:#000"></stop></linearGradient><path d="M192.5 197v-.4l-72.4-38.9H45.9v.2l72.5 39.1z" style="fill:url(#opnsense-v1_svg__e)"></path><linearGradient id="opnsense-v1_svg__f" x1="-1594.953" x2="-1432.391" y1="278.458" y2="278.458" gradientTransform="matrix(1.508 -1.0166 3.1265 -1.519 1804.196 -937.952)" gradientUnits="userSpaceOnUse"><stop offset=".107" style="stop-color:#58595b"></stop><stop offset="1" style="stop-color:#000"></stop></linearGradient><path d="M466.1 157.7h-74l-72.6 39.1v.2h74.2l72.4-38.9z" style="fill:url(#opnsense-v1_svg__f)"></path><linearGradient id="opnsense-v1_svg__g" x1="-4327.142" x2="-4164.581" y1="1572.387" y2="1572.387" gradientTransform="matrix(1.508 1.0166 3.1265 1.519 1863.938 2252.352)" gradientUnits="userSpaceOnUse"><stop offset=".107" style="stop-color:#58595b"></stop><stop offset="1" style="stop-color:#000"></stop></linearGradient><path d="M466.1 354.7v-.4l-72.4-38.9h-74.2v.2l72.6 39.1z" style="fill:url(#opnsense-v1_svg__g)"></path><linearGradient id="opnsense-v1_svg__h" x1="-413.668" x2="-246.99" y1="-1046.618" y2="-1046.618" gradientTransform="matrix(-1.508 1.0166 -3.1265 1.519 -3638.692 2252.352)" gradientUnits="userSpaceOnUse"><stop offset=".107" style="stop-color:#58595b"></stop><stop offset="1" style="stop-color:#000"></stop></linearGradient><path d="M192.5 315.4h-74.1l-72.5 39.1v.2h74.2l72.4-38.9z" style="fill:url(#opnsense-v1_svg__h)"></path><linearGradient id="opnsense-v1_svg__i" x1="74.725" x2="261.062" y1="132.65" y2="132.65" gradientTransform="matrix(.9914 0 0 -1 -66.782 260.2)" gradientUnits="userSpaceOnUse"><stop offset=".237" style="stop-color:#a6a8ab"></stop><stop offset="1" style="stop-color:#404040"></stop></linearGradient><path d="M192.8 157.7V197L7.3 97.4V58.1z" style="fill:url(#opnsense-v1_svg__i)"></path><linearGradient id="opnsense-v1_svg__j" x1="-2461.056" x2="-2274.718" y1="132.65" y2="132.65" gradientTransform="matrix(-.9914 0 0 -1 -1935.19 260.2)" gradientUnits="userSpaceOnUse"><stop offset=".237" style="stop-color:#a6a8ab"></stop><stop offset="1" style="stop-color:#404040"></stop></linearGradient><path d="M319.2 157.7V197l185.5-99.6V58.1z" style="fill:url(#opnsense-v1_svg__j)"></path><linearGradient id="opnsense-v1_svg__k" x1="-2291.845" x2="-2105.508" y1="-739.55" y2="-739.55" gradientTransform="matrix(-.9914 0 0 1 -1767.435 1124.6)" gradientUnits="userSpaceOnUse"><stop offset=".237" style="stop-color:#a6a8ab"></stop><stop offset="1" style="stop-color:#404040"></stop></linearGradient><path d="M319.2 355.2v-39.8L504.7 415v39.7z" style="fill:url(#opnsense-v1_svg__k)"></path><linearGradient id="opnsense-v1_svg__l" x1="-94.103" x2="91.934" y1="-739.55" y2="-739.55" gradientTransform="matrix(.9914 0 0 1 100.993 1124.6)" gradientUnits="userSpaceOnUse"><stop offset=".237" style="stop-color:#a6a8ab"></stop><stop offset="1" style="stop-color:#404040"></stop></linearGradient><path d="M192.8 355.2v-39.8L7.3 415v39.7z" style="fill:url(#opnsense-v1_svg__l)"></path><path d="m319.2 276.1 108.9 58.5v-39.7l-35.3-18.8h111.9v-39.8H392.8l35.3-18.8v-39.3l-108.9 58.1zM83.8 334.6l109-58.5v-39.8l-109-58.1v39.3l35.7 18.8H7.3v39.8h111.9l-35.3 18.8v39.7z" style="fill:#e24525"></path></svg></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">OPNSENSE GUEST</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="phone" transform="translate(3312.857751572178,502.58220111114224)" style="cursor: grab;"><circle r="181.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-54.45" y="-121" width="108.9" height="242" rx="8"></rect><rect x="-45.980000000000004" y="-102.85" width="91.96000000000001" height="193.60000000000002" rx="4" style="fill: rgb(30, 41, 59);"></rect><rect x="-18.15" y="99.22" width="36.3" height="7.26" rx="2" style="fill: rgb(71, 85, 105);"></rect></g><text class="node-label" x="0" y="-33.88" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Phone</text><text class="node-sub" x="0" y="48.400000000000006" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="desktop" transform="translate(2971.700036728428,480.7287465212985)" style="cursor: grab;"><circle r="220.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-132.3" y="-117.60000000000001" width="264.6" height="176.4" rx="4"></rect><rect x="-110.25" y="-95.55" width="220.5" height="132.3" rx="2" style="fill: rgb(30, 41, 59);"></rect><rect x="-22.05" y="58.800000000000004" width="44.1" height="44.1"></rect><rect x="-73.5" y="102.89999999999999" width="147" height="22.05" rx="2"></rect></g><text class="node-label" x="0" y="-41.160000000000004" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Desktop</text><text class="node-sub" x="0" y="58.800000000000004" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="dns" transform="translate(3200.4643189549906,320.469591247861)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><path d="
             M -44 11
             Q -60.50000000000001 11 -60.50000000000001 -5.5
             Q -60.50000000000001 -27.5 -38.5 -27.5
             Q -38.5 -49.5 -11 -49.5
             Q 5.5 -60.50000000000001 27.5 -44
             Q 55 -44 60.50000000000001 -16.5
             Q 71.5 -5.5 60.50000000000001 11
             Q 60.50000000000001 27.5 38.5 27.5
             L -27.5 27.5
             Q -49.5 27.5 -49.5 11
             Z
            " class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"></path><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">DNS</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="racked" transform="translate(2645.5845448279656,970.7820678889219)" style="cursor: grab;"><circle r="205.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" id="mdi-server-security" viewBox="0 0 24 24" width="164.4" height="164.4" x="-82.2" y="-82.2" style="fill: rgb(1, 8, 19); stroke: rgb(255, 255, 255);"><path d="M3,1H19A1,1 0 0,1 20,2V6A1,1 0 0,1 19,7H3A1,1 0 0,1 2,6V2A1,1 0 0,1 3,1M3,9H19A1,1 0 0,1 20,10V10.67L17.5,9.56L11,12.44V15H3A1,1 0 0,1 2,14V10A1,1 0 0,1 3,9M3,17H11C11.06,19.25 12,21.4 13.46,23H3A1,1 0 0,1 2,22V18A1,1 0 0,1 3,17M8,5H9V3H8V5M8,13H9V11H8V13M8,21H9V19H8V21M4,3V5H6V3H4M4,11V13H6V11H4M4,19V21H6V19H4M17.5,12L22,14V17C22,19.78 20.08,22.37 17.5,23C14.92,22.37 13,19.78 13,17V14L17.5,12M17.5,13.94L15,15.06V17.72C15,19.26 16.07,20.7 17.5,21.06V13.94Z" style="fill: rgb(1, 8, 19); stroke: rgb(255, 255, 255);"></path></svg></g><text class="node-label" x="0" y="-38.36000000000001" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Racked</text><text class="node-sub" x="0" y="54.800000000000004" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;"></text></g><g class="text-group" data-text-id="text-1765238422602"><text class="text-element" x="2466.35986328125" y="741.6801147460938" dominant-baseline="middle" style="fill: rgb(226, 232, 240); font-size: 40px; font-weight: normal; font-style: normal; text-anchor: start; text-decoration: none; opacity: 1; cursor: move; user-select: none;"><tspan x="2466.35986328125" dy="0">Double click on desktop</tspan><tspan x="2466.35986328125" dy="48">or long press on mobile</tspan><tspan x="2466.35986328125" dy="48">to enter rack canvas view</tspan></text><g class="text-delete-btn" style="cursor: pointer; display: none;"><circle cx="2486.35986328125" cy="701.6801147460938" r="12" style="fill: rgb(245, 101, 101); stroke: white; stroke-width: 2;"></circle><text x="2486.35986328125" y="701.6801147460938" text-anchor="middle" dominant-baseline="middle" style="fill: white; font-size: 16px; font-weight: bold; pointer-events: none;">√ó</text></g></g></svg>
        </div>
        <div class="minimap-zoom-wrapper" id="minimap-zoom-wrapper" style="display: block;">
          <button type="button" class="minimap-close-btn" id="minimap-close-btn" title="Hide map &amp; zoom">‚úï</button>
          <div class="minimap-container" id="minimap-container">
            <svg id="minimap" viewBox="0 0 4000 3000">
              <line x1="2103.968290880771" y1="268" x2="2066.9677515897347" y2="473.4119134177565" class="minimap-edge"></line><line x1="2066.9677515897347" y1="473.4119134177565" x2="1773.8400660428597" y2="666.5758233298659" class="minimap-edge"></line><line x1="2066.9677515897347" y1="473.4119134177565" x2="1931.1978950081452" y2="782.2775961320921" class="minimap-edge"></line><line x1="2066.9677515897347" y1="473.4119134177565" x2="2158.1262397347077" y2="767.7122274797483" class="minimap-edge"></line><line x1="2066.9677515897347" y1="473.4119134177565" x2="2342.2663764534577" y2="631.7681967180296" class="minimap-edge"></line><line x1="2103.968290880771" y1="268" x2="2757.879480087803" y2="307.6117116091891" class="minimap-edge"></line><line x1="2757.879480087803" y1="307.6117116091891" x2="3200.4643189549906" y2="320.469591247861" class="minimap-edge"></line><line x1="3200.4643189549906" y1="320.469591247861" x2="2971.700036728428" y2="480.7287465212985" class="minimap-edge"></line><line x1="3312.857751572178" y1="502.58220111114224" x2="3200.4643189549906" y2="320.469591247861" class="minimap-edge"></line><circle cx="2103.968290880771" cy="268" r="40" class="minimap-node"></circle><circle cx="2066.9677515897347" cy="473.4119134177565" r="40" class="minimap-node"></circle><circle cx="1773.8400660428597" cy="666.5758233298659" r="40" class="minimap-node"></circle><circle cx="1931.1978950081452" cy="782.2775961320921" r="40" class="minimap-node"></circle><circle cx="2158.1262397347077" cy="767.7122274797483" r="40" class="minimap-node"></circle><circle cx="2342.2663764534577" cy="631.7681967180296" r="40" class="minimap-node"></circle><circle cx="2757.879480087803" cy="307.6117116091891" r="40" class="minimap-node"></circle><circle cx="3312.857751572178" cy="502.58220111114224" r="40" class="minimap-node"></circle><circle cx="2971.700036728428" cy="480.7287465212985" r="40" class="minimap-node"></circle><circle cx="3200.4643189549906" cy="320.469591247861" r="40" class="minimap-node"></circle><circle cx="2645.5845448279656" cy="970.7820678889219" r="40" class="minimap-node"></circle><rect class="minimap-viewport" id="minimap-viewport" x="1254.5197896196048" y="-147.55422459755366" width="2648.185035176588" height="1986.138776382441"></rect>
            </svg>
          </div>
          <div class="zoom-toolbar" id="zoom-toolbar">
            <button id="zoom-in-btn" title="Zoom in">+</button>
            <div class="zoom-level" id="zoom-level">151%</div>
            <button id="zoom-out-btn" title="Zoom out">-</button>
            <div class="divider"></div>
            <button id="zoom-fit-btn" title="Fit to view">[ ]</button>
            <button id="zoom-reset-btn" title="Reset view">R</button>
          </div>
        </div>
        <button type="button" id="edge-legend-mini" class="legend-mini-btn" style="bottom: 10px; display: none;">Line Legend</button>
        <button type="button" id="minimap-mini" class="legend-mini-btn" style="right: 10px; left: auto; bottom: 10px; display: none;">Map</button>
        <button type="button" id="draw-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: 10px; right: auto; display: none;">Draw</button>
        <button type="button" id="topology-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: auto; right: 40px; display: none;">Add Line</button>
     </section>
      <aside class="details-panel" id="details-panel">
        <div class="sidebar-resizer" id="sidebar-resizer">
          <svg class="resizer-icon" width="6" height="40" viewBox="0 0 6 40" xmlns="http://www.w3.org/2000/svg">
            <circle cx="3" cy="14" r="2"></circle>
            <circle cx="3" cy="20" r="2"></circle>
            <circle cx="3" cy="26" r="2"></circle>
          </svg>
        </div>
        <div class="mobile-footer-resizer" id="mobile-footer-resizer">
          <svg class="resizer-icon" width="40" height="6" viewBox="0 0 40 6" xmlns="http://www.w3.org/2000/svg">
            <circle cx="14" cy="3" r="2"></circle>
            <circle cx="20" cy="3" r="2"></circle>
            <circle cx="26" cy="3" r="2"></circle>
          </svg>
        </div>
        <div id="node-panel" style="display: none;">
          <div class="details-name editable-text" id="node-name">Core Router 1</div>
          <div class="details-ip editable-text" id="node-ip">10.0.0.1</div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">MAC:</span>
            <span class="editable-text" id="node-mac" style="flex: 1; cursor: pointer; color: var(--text-main);">00:1A:2B:3C:4D:01</span>
          </div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">Rack Unit:</span>
            <span class="editable-text" id="node-rack" style="flex: 1; cursor: pointer; color: var(--text-main);">--</span>
          </div>
          <div class="details-info-row" id="uheight-row" style="display: none;">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">U Height:</span>
            <span class="editable-text" id="node-uheight" style="flex: 1; cursor: pointer; color: var(--text-main);">2U</span>
          </div>
          <div class="details-info-row" id="assigned-rack-row" style="display: flex;">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">Assigned Rack:</span>
            <select id="node-assigned-rack" style="flex: 1; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;"><option value="">None</option><option value="dc-rack-a1">DC Rack A1</option><option value="dc-rack-a2">DC Rack A2</option><option value="dc-rack-b1">DC Rack B1</option><option value="dc-rack-b2">DC Rack B2</option><option value="dmz-rack">DMZ Rack</option><option value="mgmt-rack">Management Rack</option></select>
          </div>
          <div class="details-info-row" id="rack-capacity-row" style="display: none;">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">Rack Capacity:</span>
            <select id="node-rack-capacity" style="flex: 1; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;">
              <option value="42">42U</option>
              <option value="48">48U</option>
              <option value="24">24U</option>
              <option value="12">12U</option>
              <option value="6">6U</option>
            </select>
          </div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">Layer:</span>
            <select id="node-layer" style="flex: 1; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;">
              <option value="physical">Physical</option>
              <option value="logical">Logical</option>
              <option value="security">Security</option>
              <option value="application">Application</option>
            </select>
          </div>
          <div class="details-role" id="node-role">Core Routing</div>
		  <details id="rack-contents-section" style="display: none; margin-top: 12px; margin-bottom: 12px; padding: 10px; background: var(--panel-alt); border-radius: 6px;" open="">
            <summary style="color: var(--accent); font-weight: 600; font-size: 14px; cursor: pointer;">Nodes in Rack (<span id="rack-contents-count">0</span>)</summary>
            <div id="rack-contents-list" style="max-height: 200px; overflow-y: auto; margin-top: 8px;"></div>
          </details>
          <div class="badge-row" id="node-tags"><span class="badge" style="cursor: pointer; position: relative;"><span>core</span><span style="opacity: 0.6; margin-left: 4px; font-size: 10px;"> ‚úï</span></span><span class="badge" style="cursor: pointer; position: relative;"><span>tier-1</span><span style="opacity: 0.6; margin-left: 4px; font-size: 10px;"> ‚úï</span></span><span class="badge" style="cursor: pointer; position: relative;"><span>redundant</span><span style="opacity: 0.6; margin-left: 4px; font-size: 10px;"> ‚úï</span></span><span class="badge" style="cursor: pointer; opacity: 0.6; border-style: dashed;">+ Add Tag</span></div>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-tag-input" placeholder="Add tag..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-tag-btn" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button class="pick-icon-btn" id="pick-tag-icon-btn">Add Icon Tag</button>
          <div class="section-label">Size</div>
          <div class="size-controls">
            <label>Size:</label>
            <input type="range" id="size-slider" min="20" max="200" value="55">
            <span id="size-value">55</span>
            <button id="reset-size">Reset</button>
          </div>
          <details class="style-section">
            <summary>Styling</summary>
            <div class="style-content">
              <div class="style-row">
                <label>Screen:</label>
                <select id="style-scope">
                  <option value="all">All</option>
                  <option value="desktop">Desktop</option>
                  <option value="tablet">Tablet</option>
                  <option value="mobile">Mobile</option>
                  <option value="fold">Fold</option>
                </select>
              </div>
              <div class="style-row">
                <label>Shape:</label>
                <select id="shape-select"><option value="custom-icon">Custom Icon</option>
                  <optgroup label="Basic Shapes">
            <option value="circle">Circle</option>
            <option value="square">Square</option>
            <option value="rectangle">Rectangle</option>
            <option value="triangle">Triangle</option>
            <option value="hexagon">Hexagon</option>
            <option value="diamond">Diamond</option>
            <option value="star">Star</option>
            <option value="stop-sign">Stop Sign</option>
            <option value="octagon">Octagon</option>
            <option value="pentagon">Pentagon</option>
            <option value="cross">Cross</option>
            <option value="rounded-square">Rounded Square</option>
            <option value="pill">Pill</option>
            <option value="parallelogram">Parallelogram</option>
            <option value="trapezoid">Trapezoid</option>
          </optgroup>
          <optgroup label="Computers &amp; Devices">
            <option value="server">Server</option>
            <option value="pc">PC / Desktop</option>
            <option value="laptop">Laptop</option>
            <option value="phone">Phone / Mobile</option>
            <option value="printer">Printer</option>
            <option value="pi">Raspberry Pi</option>
            <option value="sensor">Sensor / IoT</option>
          </optgroup>
          <optgroup label="Network Equipment">
            <option value="router">Router</option>
            <option value="switch">Switch</option>
            <option value="firewall">Firewall</option>
            <option value="access-point">Access Point</option>
            <option value="load-balancer">Load Balancer</option>
            <option value="gateway">Gateway</option>
            <option value="vpn">VPN / Tunnel</option>
            <option value="nas">NAS / Storage</option>
          </optgroup>
          <optgroup label="Cloud &amp; Services">
            <option value="cloud">Cloud</option>
            <option value="database">Database</option>
			<option value="docker">Docker</option>
            <option value="container">Container</option>
            <option value="vm">Virtual Machine</option>
            <option value="kubernetes">Kubernetes</option>
            <option value="api">API / Endpoint</option>
            <option value="queue">Queue / Message</option>
            <option value="lambda">Lambda / Function</option>
            <option value="bucket">Bucket / S3</option>
          </optgroup>
          <optgroup label="Security &amp; Monitoring">
            <option value="shield">Shield</option>
            <option value="camera">Camera / CCTV</option>
            <option value="monitor">Monitor / Dashboard</option>
          </optgroup>
                </select>
              </div>
              <button class="pick-icon-btn" id="pick-shape-icon-btn">Or Search Web Icons</button>
              <div class="style-row">
                <label>Fill Color:</label>
                <input type="color" id="circle-color" value="#1e293b">
              </div>
              <div class="style-row">
                <label>Border Color:</label>
                <input type="color" id="circle-border" value="#475569">
              </div>
              <div class="style-row">
                <label>Title Color:</label>
                <input type="color" id="title-color" value="#e2e8f0">
              </div>
              <div class="style-row">
                <label>Title Font:</label>
                <select id="title-font">
                  <option value="system-ui, sans-serif">System UI</option>
                  <option value="monospace">Monospace</option>
                  <option value="serif">Serif</option>
                  <option value="cursive">Cursive</option>
                  <option value="'Courier New', monospace">Courier</option>
                  <option value="Arial, sans-serif">Arial</option>
                  <option value="'Times New Roman', serif">Times</option>
                </select>
              </div>
              <div class="style-row">
                <label>Title Size:</label>
                <input type="number" id="title-size" min="8" max="100" value="18">
              </div>
              <div class="style-row">
                <label>Sub Color:</label>
                <input type="color" id="sub-color" value="#94a3b8">
              </div>
              <div class="style-row">
                <label>Sub Font:</label>
                <select id="sub-font">
                  <option value="system-ui, sans-serif">System UI</option>
                  <option value="monospace">Monospace</option>
                  <option value="serif">Serif</option>
                  <option value="cursive">Cursive</option>
                  <option value="'Courier New', monospace">Courier</option>
                  <option value="Arial, sans-serif">Arial</option>
                  <option value="'Times New Roman', serif">Times</option>
                </select>
              </div>
              <div class="style-row">
                <label>Sub Size:</label>
                <input type="number" id="sub-size" min="6" max="80" value="13">
              </div>
              <div style="
                margin-top: 12px;
                padding-top: 10px;
                border-top: 1px solid var(--edge-main);
                ">
                <div style="font-size: 12px;color: var(--text-soft);margin-bottom: 8px;text-transform: uppercase;">Text Position</div>
                <div class="style-row">
                  <label>Name Y:</label>
                  <input type="number" id="title-offset-y" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>Name X:</label>
                  <input type="number" id="title-offset-x" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>IP Y:</label>
                  <input type="number" id="sub-offset-y" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>IP X:</label>
                  <input type="number" id="sub-offset-x" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div style="margin-top: 16px; font-size: 12px; color: var(--text-soft); text-transform: uppercase;">
                  Ping Indicator Position
                </div>
                <div class="style-row">
                  <label>Ping X:</label>
                  <input type="number" id="ping-offset-x" min="-200" max="200" value="0" style="width: 60px;">
                </div>
                <div class="style-row">
                  <label>Ping Y:</label>
                  <input type="number" id="ping-offset-y" min="-200" max="200" value="0" style="width: 60px;">
                </div>
              </div>
              <button id="reset-styles" style="width: 100%;margin-top: 10px;padding: 8px;background: var(--panel);color: var(--text-main);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: clamp(13px, 1.5vw, 17px);">Reset Styles</button>
            </div>
          </details>
          <details class="style-section">
            <summary>Ping / Status Monitoring</summary>
            <div class="style-content">
              <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px; cursor: pointer;">
              <input type="checkbox" id="node-pingable" style="cursor: pointer;">
              <span style="font-size: 14px;">Enable status check for this node</span>
              </label>
              <div id="node-ping-options" style="display: none;">
                <div class="style-row">
                  <label>Protocol:</label>
                  <select id="node-ping-protocol">
                    <option value="http">HTTP (port 80)</option>
                    <option value="https">HTTPS (port 443)</option>
                    <option value="custom">Custom URL</option>
                  </select>
                </div>
                <div id="node-custom-url-container" style="display: block; margin-top: 8px;">
                  <label style="display: block; margin-bottom: 4px; font-size: 13px;">Custom URL:</label>
                  <input type="text" id="node-custom-url" placeholder="e.g. http://192.168.1.1:8080" style="width: 100%;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: 14px;">
                </div>
                <div class="style-row" style="margin-top: 8px;">
                  <label>Timeout (ms):</label>
                  <input type="number" id="node-ping-timeout" value="3000" min="1000" max="10000" step="500" style="width: 100px;">
                </div>
                <div style="margin-top: 12px; padding: 10px; background: var(--panel); border-radius: 6px; border: 1px solid var(--edge-main);">
                  <div style="font-size: 12px; color: var(--text-soft); margin-bottom: 8px;">Current Status:</div>
                  <div id="node-ping-status" style="font-size: 14px; font-weight: 600; color: var(--accent);">‚óè Online</div>
                  <div id="node-ping-last-check" style="font-size: 11px; color: var(--text-soft); margin-top: 4px;">Last checked: 2:25:19 PM</div>
                </div>
                <button id="check-ping-now" style="width: 100%;margin-top: 10px;padding: 8px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Check Status Now</button>
              </div>
            </div>
          </details>
          <div class="section-label">Notes</div>
          <ul class="list" id="node-notes"><li><span style="flex: 1 1 0%;">Primary core router</span><span class="delete-note">‚úï</span></li><li><span style="flex: 1 1 0%;">BGP peering enabled</span><span class="delete-note">‚úï</span></li></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-note-input" placeholder="Type new note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-note-btn" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-node-btn" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: rgb(255, 255, 255);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;width: 100%;">Delete Node</button>
        </div>
        <div id="edge-panel" style="display: none">
          <div class="details-name" id="edge-title">Custom line</div>
          <div class="style-row" style="margin-top: 10px">
            <label>Width:</label>
            <input type="number" id="edge-width" min="1" max="20" value="4">
          </div>
          <div class="style-row">
            <label>Color:</label>
            <input type="color" id="edge-color" value="#475569">
          </div>
          <div class="style-row">
            <label>Line Style:</label>
            <select id="edge-line-style">
              <option value="solid">Solid</option>
              <option value="dashed">Dashed</option>
              <option value="dotted">Dotted</option>
            </select>
          </div>
          <div class="style-row">
            <label>Direction:</label>
            <select id="edge-direction">
              <option value="none">No arrows</option>
              <option value="forward">‚Üí Forward</option>
              <option value="backward">‚Üê Backward</option>
              <option value="both">‚Üî Bidirectional</option>
            </select>
          </div>
          <div class="style-row" id="edge-port-fields">
            <label>From Port:</label>
            <input type="text" id="edge-from-port" placeholder="e.g. eth0, gi0/1" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);font-size: 14px;">
          </div>
          <div class="style-row" id="edge-port-fields-to">
            <label>To Port:</label>
            <input type="text" id="edge-to-port" placeholder="e.g. eth1, gi0/2" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);font-size: 14px;">
          </div>
          <div class="section-label">Line Notes</div>
          <ul class="list" id="edge-notes"></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-edge-note" placeholder="Add note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-edge-note" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-edge" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Delete Line</button>
        </div>
        <div id="rect-panel" style="display: none">
          <div class="details-name" id="rect-title">Zone</div>
          <div class="style-row" id="rect-fill-row" style="margin-top: 10px">
            <label>Fill Color:</label>
            <input type="color" id="rect-color" value="#f97316">
          </div>
          <div class="style-row">
            <label>Border Color:</label>
            <input type="color" id="rect-border-color" value="#f97316">
          </div>
          <div class="style-row">
            <label>Border Width:</label>
            <input type="number" id="rect-border-width" min="0" max="20" value="2">
          </div>
          <div class="style-row">
            <label>Style:</label>
            <select id="rect-style-select">
              <option value="filled">Filled</option>
              <option value="outlined">Outlined</option>
            </select>
          </div>
		  <div class="style-row">
            <label>Line Style:</label>
            <select id="rect-line-style">
              <option value="solid">Solid</option>
              <option value="dashed">Dashed</option>
              <option value="dotted">Dotted</option>
            </select>
          </div>
          <div class="section-label">Zone Notes</div>
          <ul class="list" id="rect-notes"></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-rect-note" placeholder="Add note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-rect-note" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-rect" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Delete Zone</button>
        </div>
        <div id="text-panel" style="display: none">
          <div class="details-name" id="text-title">Text Element</div>
          <div class="style-row" style="margin-top: 10px">
            <label>Content:</label>
            <textarea id="text-content" placeholder="Enter text..." style="width: 100%;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: 14px;min-height: 80px;resize: vertical;font-family: inherit;"></textarea>
          </div>
          <div class="style-row">
            <label>Font Size:</label>
            <input type="number" id="text-font-size" min="8" max="200" value="18" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);">
          </div>
          <div class="style-row">
            <label>Color:</label>
            <input type="color" id="text-color" value="#e2e8f0">
          </div>
          <div class="style-row">
            <label>Font Weight:</label>
            <select id="text-font-weight" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="normal">Normal</option>
              <option value="bold">Bold</option>
              <option value="600">Semi-Bold</option>
              <option value="300">Light</option>
            </select>
          </div>
          <div class="style-row">
            <label>Font Style:</label>
            <select id="text-font-style" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="normal">Normal</option>
              <option value="italic">Italic</option>
            </select>
          </div>
          <div class="style-row">
            <label>Text Align:</label>
            <select id="text-align" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="start">Left</option>
              <option value="middle">Center</option>
              <option value="end">Right</option>
            </select>
          </div>
          <div class="style-row">
            <label>Text Decoration:</label>
            <select id="text-decoration" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="none">None</option>
              <option value="underline">Underline</option>
              <option value="line-through">Strike Through</option>
            </select>
          </div>
          <div class="style-row">
            <label>Background:</label>
            <input type="color" id="text-bg-color" value="#000000">
            <label style="margin-left: 10px; display: flex; align-items: center; gap: 6px;">
            <input type="checkbox" id="text-bg-enabled" style="cursor: pointer;">
            <span style="font-size: 13px;">Enable</span>
            </label>
          </div>
          <div class="style-row">
            <label>Opacity:</label>
            <input type="range" id="text-opacity" min="0" max="1" step="0.1" value="1" style="flex: 1">
            <span id="text-opacity-val" style="min-width: 35px; text-align: right">100%</span>
          </div>
          <button id="delete-text" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;width: 100%;">Delete Text</button>
        </div>
     <details class="style-section" open="">
          <summary>Page Layout</summary>
          <div class="style-content">
            <div style="padding: 12px; background: var(--panel-alt); border-radius: 6px; color: var(--text-soft); font-size: 13px; line-height: 1.6;">
              <strong style="color: var(--accent); display: block; margin-bottom: 8px;">Drag to Resize:</strong>
              ‚Ä¢ <strong>Header:</strong> Drag the bottom edge of the header bar<br>
              ‚Ä¢ <strong>Sidebar:</strong> Drag the left edge of the sidebar panel<br>
              ‚Ä¢ <strong>Mobile:</strong> Drag the top edge of the footer panel<br>
              <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--edge-main); font-size: 12px;">
                Hover over panel edges to see resize handles
              </div>
            </div>
          </div>
        </details>
      </aside>
    </main>
    <script id="nodes-json" type="application/json">{}</script>
    <script id="topology-state" type="application/json">ENCRYPTED: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</script>
    <script>
	Object.keys(localStorage).forEach(key => {
       if (key.startsWith('icon-selfhst-')) {
        const val = localStorage.getItem(key);
        if (val && val.includes('<image href=')) {
         localStorage.removeItem(key);
        }
       }
      });
      const IconLibrary = {
       libraries: {
        mdi: {
         name: 'Material Design Icons',
         cdnBase: 'https://cdn.jsdelivr.net/npm/@mdi/svg@latest/svg/',
         metaUrl: 'https://cdn.jsdelivr.net/npm/@mdi/svg@latest/meta.json',
         icons: []
        },
        simple: {
         name: 'Simple Icons',
         cdnBase: 'https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/',
         indexUrl: 'https://cdn.jsdelivr.net/npm/@iconify-json/simple-icons@latest/icons.json',
         icons: []
        },
        selfhst: {
         name: 'selfh.st/icons',
         cdnBase: 'https://cdn.jsdelivr.net/gh/selfhst/icons@master/svg/',
         indexUrl: 'https://raw.githubusercontent.com/selfhst/icons/refs/heads/main/index.json',
         icons: []
        }
       },
       currentLibrary: 'selfhst',
       iconCache: {},
       indexCache: {},
       indexLoading: {},
       async loadLibraryIndex(library) {
        if (this.indexCache[library]) {
         return this.indexCache[library];
        }
        if (this.indexLoading[library]) {
         return this.indexLoading[library];
        }
        const lib = this.libraries[library];
        this.indexLoading[library] = (async () => {
         try {
          if (library === 'selfhst') {
           const response = await fetch(lib.indexUrl);
           const data = await response.json();
           const icons = data.filter(item => item.SVG === "Yes").map(item => ({
            name: item.Reference,
            displayName: item.Name,
            tags: item.Tags ? item.Tags.split(',').map(t => t.trim()).filter(t => t) : [],
            category: item.Category
           }));
           this.indexCache[library] = icons;
           lib.icons = icons;
           return icons;
          } else if (library === 'simple') {
           const response = await fetch('https://cdn.jsdelivr.net/npm/@iconify-json/simple-icons@latest/icons.json');
           const data = await response.json();
           const icons = Object.keys(data.icons).map(slug => ({
            name: slug,
            displayName: data.icons[slug].title || slug,
            tags: data.aliases && data.aliases[slug] ? [data.aliases[slug].parent] : [],
            hex: data.icons[slug].hex
           }));
           this.indexCache[library] = icons;
           lib.icons = icons;
           return icons;
          } else if (library === 'mdi') {
           const response = await fetch(lib.metaUrl);
           const data = await response.json();
           const icons = data.map(item => ({
            name: item.name,
            displayName: item.name,
            tags: item.tags || [],
            author: item.author
           }));
           this.indexCache[library] = icons;
           lib.icons = icons;
           return icons;
          }
         } catch (error) {
          console.error(`Failed to load index for ${library}:`, error);
          this.indexCache[library] = [];
          lib.icons = [];
          return [];
         } finally {
          delete this.indexLoading[library];
         }
        })();
        return this.indexLoading[library];
       },
       async getIcon(library, name) {
        const cacheKey = `${library}-${name}`;
        if (this.iconCache[cacheKey]) {
         return this.iconCache[cacheKey];
        }
        const cached = localStorage.getItem(`icon-${cacheKey}`);
        if (cached) {
         this.iconCache[cacheKey] = cached;
         return cached;
        }
        const lib = this.libraries[library];
        const url = `${lib.cdnBase}${name}.svg`;
        try {
         const response = await fetch(url);
         if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
         }
         const svg = await response.text();
         this.iconCache[cacheKey] = svg;
         localStorage.setItem(`icon-${cacheKey}`, svg);
         return svg;
        } catch (error) {
         console.error(`Failed to fetch icon ${cacheKey}:`, error);
         return null;
        }
       },
       searchIcons(library, query) {
        const lib = this.libraries[library];
        if (!lib.icons.length) return [];
        const q = query.toLowerCase();
        return lib.icons.filter(icon => {
         const nameMatch = icon.name.toLowerCase().includes(q);
         const displayMatch = icon.displayName && icon.displayName.toLowerCase().includes(q);
         const tagMatch = icon.tags && icon.tags.some(t => t.toLowerCase().includes(q));
         const categoryMatch = icon.category && icon.category.toLowerCase().includes(q);
         return nameMatch || displayMatch || tagMatch || categoryMatch;
        }).slice(0, 50);
       }
      };
      let iconPickerCallback = null;
      let selectedNodeIconData = null;
      let selectedRackIconData = null;
      let newNodeIconTags = [];
      let freeDrawMode = false;
      async function checkNodeStatus(nodeId) {
       const data = NODE_DATA[nodeId];
       if (!data || !data.ping || !data.ping.enabled) return;
       data.ping.status = 'checking';
       data.ping.lastCheck = new Date().toISOString();
       updatePingIndicator(nodeId);
       if (currentNodeId === nodeId) {
        updatePingStatusDisplay(nodeId);
       }
       let url;
       if (data.ping.protocol === 'custom') {
        url = data.ping.customUrl;
       } else {
        const ip = data.ip || '0.0.0.0';
        const protocol = data.ping.protocol || 'http';
        url = `${protocol}://${ip}`;
       }
       if (!url) {
        data.ping.status = 'unknown';
        updatePingIndicator(nodeId);
        if (currentNodeId === nodeId) {
         updatePingStatusDisplay(nodeId);
        }
        return;
       }
       try {
        const controller = new AbortController();
        const timeout = data.ping.timeout || 3000;
        const timeoutId = setTimeout(() => controller.abort(), timeout);
        const response = await fetch(url, {
         method: 'HEAD',
         mode: 'no-cors',
         signal: controller.signal
        });
        clearTimeout(timeoutId);
        data.ping.status = 'online';
       } catch (error) {
        data.ping.status = 'offline';
       }
       data.ping.lastCheck = new Date().toISOString();
       updatePingIndicator(nodeId);
       if (currentNodeId === nodeId) {
        updatePingStatusDisplay(nodeId);
       }
      }
      function rgbaToHex(val) {
      if (!val) return "#000000";
      if (val.startsWith("#")) return val;
      const m = val.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
      if (!m) return "#000000";
      const r = Number(m[1]).toString(16).padStart(2, "0");
      const g = Number(m[2]).toString(16).padStart(2, "0");
      const b = Number(m[3]).toString(16).padStart(2, "0");
      return `#${r}${g}${b}`;
      }
      function updatePingIndicator(nodeId) {
      const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
      if (!nodeGroup) return;
      const data = NODE_DATA[nodeId];
      if (!data || !data.ping || !data.ping.enabled) {
       const existingIndicator = nodeGroup.querySelector('.ping-indicator');
       if (existingIndicator) existingIndicator.remove();
       return;
      }
      let indicator = nodeGroup.querySelector('.ping-indicator');
      const label = nodeGroup.querySelector('.node-label');
      if (!indicator && label) {
       indicator = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
       indicator.classList.add('ping-indicator');
       nodeGroup.appendChild(indicator);
      }
      if (indicator && label) {
       const size = savedSizes[nodeId] || getDefaultSize();
       const radius = Math.max(4, size * 0.06);
       indicator.setAttribute('r', radius);
       const labelBBox = label.getBBox();
       const labelX = parseFloat(label.getAttribute('x') || 0);
       const labelY = parseFloat(label.getAttribute('y') || 0);
       const styles = resolveStylesForNode(nodeId);
      const offX = styles.pingOffsetX || 0;
      const offY = styles.pingOffsetY || 0;
      indicator.setAttribute('cx', (labelX - labelBBox.width / 2 - radius * 1.1) + offX);
      indicator.setAttribute('cy', (labelY - radius * 0.7) + offY);
      }
      if (indicator) {
       indicator.classList.remove('online', 'offline', 'checking');
       if (data.ping.status) indicator.classList.add(data.ping.status);
      }
      }
      function checkAllNodesStatus() {
       Object.keys(NODE_DATA).forEach(nodeId => {
        const data = NODE_DATA[nodeId];
        if (data && data.ping && data.ping.enabled) {
         checkNodeStatus(nodeId);
        }
       });
      }
      function startAutoPing() {
       stopAutoPing();
       checkAllNodesStatus();
       updateAutoPingLastRun();
       autoPingSecondsRemaining = autoPingInterval;
       autoPingTimer = setInterval(() => {
        checkAllNodesStatus();
        updateAutoPingLastRun();
        autoPingSecondsRemaining = autoPingInterval;
       }, autoPingInterval * 1000);
       autoPingCountdown = setInterval(() => {
        autoPingSecondsRemaining--;
        updateAutoPingCountdown();
        if (autoPingSecondsRemaining <= 0) {
         autoPingSecondsRemaining = autoPingInterval;
        }
       }, 1000);
       updateAutoPingCountdown();
      }
      function stopAutoPing() {
       if (autoPingTimer) {
        clearInterval(autoPingTimer);
        autoPingTimer = null;
       }
       if (autoPingCountdown) {
        clearInterval(autoPingCountdown);
        autoPingCountdown = null;
       }
       autoPingSecondsRemaining = 0;
       updateAutoPingCountdown();
      }
      function updateAutoPingCountdown() {
       const nextCheckEl = document.getElementById('auto-ping-next-check');
       if (nextCheckEl) {
        if (autoPingSecondsRemaining > 0 && autoPingEnabled) {
         const mins = Math.floor(autoPingSecondsRemaining / 60);
         const secs = autoPingSecondsRemaining % 60;
         if (mins > 0) {
          nextCheckEl.textContent = `Next check in: ${mins}m ${secs}s`;
         } else {
          nextCheckEl.textContent = `Next check in: ${secs}s`;
         }
        } else {
         nextCheckEl.textContent = 'Next check in: --';
        }
       }
      }
      function updateAutoPingLastRun() {
       const lastRunEl = document.getElementById('auto-ping-last-run');
       if (lastRunEl) {
        const now = new Date();
        lastRunEl.textContent = `Last run: ${now.toLocaleTimeString()}`;
       }
      }
      function openIconPicker(callback) {
       iconPickerCallback = callback;
       const modal = document.getElementById('icon-picker-modal');
       modal.classList.add('active');
       const searchInput = document.getElementById('icon-search');
       searchInput.style.display = 'none';
       loadIconsForCurrentLibrary();
      }
      function closeIconPicker() {
       const modal = document.getElementById('icon-picker-modal');
       modal.classList.remove('active');
       iconPickerCallback = null;
      }
      async function loadIconsForCurrentLibrary() {
       const body = document.getElementById('icon-picker-body');
       const libNames = {
        mdi: 'MDI (Material Design Icons)',
        simple: 'Simple Icons',
        selfhst: 'selfh.st/icons'
       };
       body.innerHTML = `<div style="padding: 20px;"><p style="color: var(--text-soft); margin-bottom: 15px; text-align: center;">Search ${libNames[IconLibrary.currentLibrary]}:</p><input type="text" id="icon-search-field" placeholder="Search icons..." style="width: 100%; padding: 12px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main); font-size: 16px; margin-bottom: 20px;"><div id="icon-grid-container" style="max-height: 400px; overflow-y: auto;"><div style="text-align: center; color: var(--text-soft); padding: 40px;">Loading icons...</div></div></div>`;
       const searchField = document.getElementById('icon-search-field');
       const gridContainer = document.getElementById('icon-grid-container');
       await IconLibrary.loadLibraryIndex(IconLibrary.currentLibrary);
       const renderIcons = (icons) => {
        if (!icons || icons.length === 0) {
         gridContainer.innerHTML = '<div style="text-align: center; color: var(--text-soft); padding: 40px;">No icons found</div>';
         return;
        }
        const grid = document.createElement('div');
        grid.style.cssText = 'display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 15px; padding: 10px;';
        icons.forEach(icon => {
         const item = document.createElement('div');
         item.style.cssText = 'display: flex; flex-direction: column; align-items: center; gap: 8px; padding: 15px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; cursor: pointer; transition: all 0.2s;';
         item.onmouseover = () => {
          item.style.background = 'var(--panel)';
          item.style.borderColor = 'var(--accent)';
         };
         item.onmouseout = () => {
          item.style.background = 'var(--panel-alt)';
          item.style.borderColor = 'var(--edge-main)';
         };
         const iconPreview = document.createElement('div');
         iconPreview.style.cssText = 'width: 48px; height: 48px; display: flex; align-items: center; justify-content: center;';
         iconPreview.innerHTML = '<div style="color: var(--text-soft); font-size: 12px;">...</div>';
         IconLibrary.getIcon(IconLibrary.currentLibrary, icon.name).then(svg => {
          if (svg) {
           const parser = new DOMParser();
           const doc = parser.parseFromString(svg, 'image/svg+xml');
           const svgEl = doc.querySelector('svg');
           if (svgEl) {
            svgEl.setAttribute('width', '48');
            svgEl.setAttribute('height', '48');
            svgEl.style.fill = 'var(--text-main)';
            iconPreview.innerHTML = '';
            iconPreview.appendChild(svgEl);
           }
          }
         });
         const name = document.createElement('div');
         name.textContent = icon.displayName || icon.name;
         name.style.cssText = 'font-size: 11px; color: var(--text-soft); text-align: center; word-break: break-word; max-width: 100%;';
         item.appendChild(iconPreview);
         item.appendChild(name);
         item.addEventListener('click', async () => {
          const svg = await IconLibrary.getIcon(IconLibrary.currentLibrary, icon.name);
          if (iconPickerCallback && svg) {
           iconPickerCallback({
            library: IconLibrary.currentLibrary,
            name: icon.name,
            svg: svg
           });
          }
          closeIconPicker();
         });
         grid.appendChild(item);
        });
        gridContainer.innerHTML = '';
        gridContainer.appendChild(grid);
       };
       gridContainer.innerHTML = '<div style="text-align: center; color: var(--text-soft); padding: 40px;">Type to search icons</div>';
       let searchTimeout;
       searchField.addEventListener('input', (e) => {
        clearTimeout(searchTimeout);
        const query = e.target.value.trim();
        searchTimeout = setTimeout(() => {
         if (!query) {
          gridContainer.innerHTML = '<div style="text-align: center; color: var(--text-soft); padding: 40px;">Type to search icons</div>';
          return;
         }
         const results = IconLibrary.searchIcons(IconLibrary.currentLibrary, query);
         renderIcons(results);
        }, 300);
       });
       searchField.focus();
      }
      async function displayIcons(icons) {
       const body = document.getElementById('icon-picker-body');
       const grid = document.createElement('div');
       grid.className = 'icon-grid';
       for (const icon of icons) {
        const item = document.createElement('div');
        item.className = 'icon-item';
        const svg = await IconLibrary.getIcon(icon.library, icon.name);
        if (svg) {
         const parser = new DOMParser();
         const doc = parser.parseFromString(svg, 'image/svg+xml');
         const svgEl = doc.querySelector('svg');
         if (svgEl) {
          item.innerHTML = svgEl.outerHTML;
         }
        } else {
         item.innerHTML = '<svg width = "32" height = "32"><rect width = "32" height = "32" fill = "currentColor"/> </svg>';
        }
        const name = document.createElement('div');
        name.className = 'icon-item-name';
        name.textContent = icon.name;
        item.appendChild(name);
        item.addEventListener('click', () => {
         if (iconPickerCallback) {
          iconPickerCallback({
           library: icon.library,
           name: icon.name,
           svg: svg
          });
         }
         closeIconPicker();
        });
        grid.appendChild(item);
       }
       body.innerHTML = '';
       body.appendChild(grid);
      }
      window.addEventListener('DOMContentLoaded', () => {
       document.querySelectorAll('.icon-picker-tab').forEach(tab => {
        tab.addEventListener('click', () => {
         document.querySelectorAll('.icon-picker-tab').forEach(t => t.classList.remove('active'));
         tab.classList.add('active');
         IconLibrary.currentLibrary = tab.dataset.library;
         loadIconsForCurrentLibrary();
        });
       });
       document.getElementById('icon-picker-cancel').addEventListener('click', closeIconPicker);
       document.getElementById('icon-picker-modal').addEventListener('click', (e) => {
        if (e.target.id === 'icon-picker-modal') {
         closeIconPicker();
        }
       });
      });
      let textDrawMode = false;
      const BASE_NODE_DATA = JSON.parse(document.getElementById("nodes-json").textContent, );
      let currentNodeId = "host";
      let currentEdgeId = null;
      let currentStyleScope = "all";
      let NODE_DATA = {};
      let EDGE_DATA = {
       list: []
      };
      let currentRectId = null;
      let currentTextId = null;
      let rectDrawMode = false;
      let RECT_DATA = {
       list: []
      };
      let TEXT_DATA = {
       list: []
      };
      let EDGE_LEGEND = {};
      let savedPositions = {};
      let savedSizes = {};
      let savedStyles = {};
      let legendCollapsed = false;
      let minimapCollapsed = false;
      let drawToolbarCollapsed = false;
      let currentView = {
       mode: "topology",
       rackId: null
      };
      let savedTopologyView = null;
      let activeLayers = new Set(["physical", "logical", "security", "application"]);
      let topologyToolbarCollapsed = false;
      let legendMiniBtn = null;
      let minimapMiniBtn = null;
      let drawToolbarMiniBtn = null;
      let topologyToolbarMiniBtn = null;
      let autoPingEnabled = false;
      let autoPingInterval = 30;
      let autoPingTimer = null;
      let autoPingCountdown = null;
      let autoPingSecondsRemaining = 0;
      const ROLLBACK_STORAGE_KEY = "theonefile_rollback_history";
      let rollbackVersions = [];
      const MAX_ROLLBACK_VERSIONS = 50;
      let currentRollbackIndex = -1;
      const AUDIT_STORAGE_KEY = "theonefile_audit_log";
      let auditLog = [];
      const MAX_AUDIT_ENTRIES = 1000;
      let documentTabs = [{
        id: "main",
        name: "Main Topology",
        nodes: {},
        edges: { list: [] },
        positions: {},
        sizes: {},
        styles: {},
        legend: {},
        rects: { list: [] },
        texts: { list: [] },
      pageState: null
      }];
      let currentTabIndex = 0;
      let encryptedSections = {};
      let undoStack = [];
      let redoStack = [];
      const MAX_UNDO_STACK = 50;
      let selectedNodes = new Set();
      let selectedEdges = new Set();
      let selectedRects = new Set();
      let selectedTexts = new Set();
      let isSelecting = false;
      let selectionStart = null;
      let preDragSelectedNodes = new Set();
      let preDragSelectedEdges = new Set();
      let preDragSelectedRects = new Set();
      let preDragSelectedTexts = new Set();
      let selectionRect = null;
      let isDraggingSelection = false;
      let dragSelectionStart = null;
      let selectionBoxStyle = {
       fillColor: "#4fd1c5",
       fillOpacity: 0.1,
       strokeColor: "#4fd1c5",
       strokeWidth: 2,
       strokeDasharray: "5,5"
      };
      let clipboard = null;
      const MobileManager = {
        isMobile: false,
        detect() {
          if (navigator.userAgentData?.mobile === true) {
            this.isMobile = true;
            return true;
          }
          const coarse = matchMedia("(pointer: coarse)").matches;
          const width = window.innerWidth <= 900;
          const portrait = matchMedia("(orientation: portrait)").matches;
          this.isMobile = coarse;
          return this.isMobile;
        },
        applyInitialCollapse() {
          if (!this.isMobile) return;
          legendCollapsed = true;
          minimapCollapsed = true;
          drawToolbarCollapsed = true;
          topologyToolbarCollapsed = true;
          if (typeof updateLegendVisibility === "function") updateLegendVisibility();
          if (typeof updateMinimapVisibility === "function") updateMinimapVisibility();
          if (typeof updateDrawToolbarVisibility === "function") updateDrawToolbarVisibility();
          if (typeof updateTopologyToolbarVisibility === "function") updateTopologyToolbarVisibility();
        },
        updateBulkToolbar() {
          const desktop = document.getElementById("bulk-toolbar");
          const mobile = document.getElementById("bulk-toolbar-mobile");
          if (!desktop || !mobile) return;
          if (typeof isViewOnly === 'function' && isViewOnly()) {
           desktop.style.display = "none";
           mobile.style.display = "none";
           return;
          }
          if (typeof selectedNodes === 'undefined' || selectedNodes.size === 0) {
           desktop.style.display = "none";
           mobile.style.display = "none";
           return;
          }
          const isVisible = desktop.style.display !== "none" || mobile.style.display !== "none";
          if (this.isMobile) {
            desktop.style.display = "none";
            if (isVisible) {
              mobile.style.display = "flex";
            }
          } else {
            mobile.style.display = "none";
            if (isVisible) {
              desktop.style.display = "flex";
            }
          }
        },
        updateLayout() {
          const main = document.querySelector("main");
          if (!main) return;
        },
        updateCanvasHint() {
      const hint = document.getElementById("canvas-hint");
      if (!hint) return;
      if (PAGE_STATE.canvasHintText !== undefined && PAGE_STATE.canvasHintText !== "") {
        hint.innerHTML = PAGE_STATE.canvasHintText;
        return;
      }
      const items = this.isMobile
      ? [
        "Pinch to zoom",
        "Drag to pan",
        "Add node from top menu",
        "Double tap to clone and align",
        "Double tap to select multiple",
        "You have the power",
        "Your time is NOW!",
      ]
      : [
        "Scroll to zoom",
        "Drag to pan",
        "Right click to clone and align",
        "Right click to select multiple",
        "You have the power",
        "Your time is NOW!",
      ];
      const list = document.createElement("ul");
      for (const item of items) {
      const li = document.createElement("li");
      li.textContent = item;
      list.appendChild(li);
      }
      hint.replaceChildren(list);
      },
        autoSelectStyleScope() {
          const scope = document.getElementById("style-scope");
          if (!scope) return;
          if (this.isMobile) scope.value = "mobile";
        },
        updateToolbarStack() {
          if (!this.isMobile) return;
          const draw = document.getElementById("draw-toolbar");
          const topo = document.getElementById("topology-toolbar");
          if (!draw || !topo) return;
          const h = draw.getBoundingClientRect().height;
          document.documentElement.style.setProperty("--draw-toolbar-height", h + "px");
        },
        updateLayoutControls() {
          const sidebarRow = document.getElementById("sidebar-width-row");
          const footerRow = document.getElementById("mobile-footer-row");
          if (sidebarRow && footerRow) {
            if (this.isMobile) {
              sidebarRow.style.display = "none";
              footerRow.style.display = "flex";
            } else {
              sidebarRow.style.display = "flex";
              footerRow.style.display = "none";
            }
          }
        },
        applyAll() {
          this.detect();
          this.applyInitialCollapse();
          this.updateBulkToolbar();
          this.updateLayout();
          this.updateCanvasHint();
          this.autoSelectStyleScope();
          this.updateToolbarStack();
          this.updateLayoutControls();
        }
      };
      function isMobileDevice() {
        return MobileManager.isMobile;
      }
      function ensureLegendMiniButton() {
		if (legendMiniBtn) return legendMiniBtn;
		const handleClick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			legendCollapsed = false;
			updateLegendVisibility();
		};
		const preventTouch = (e) => { e.preventDefault(); };
		const existing = document.getElementById("edge-legend-mini");
		if (existing) {
			existing.addEventListener("click", handleClick);
			existing.addEventListener("touchstart", preventTouch, { passive: false });
			existing.addEventListener("touchend", handleClick);
			legendMiniBtn = existing;
			return existing;
		}
		const panel = document.querySelector(".topology-panel");
		if (!panel) return null;
		   const btn = document.createElement("button");
		   btn.type = "button";
		   btn.id = "edge-legend-mini";
		   btn.className = "legend-mini-btn";
		   btn.textContent = "Legend";
		   btn.style.bottom = "10px";
		   btn.addEventListener("click", handleClick);
		   btn.addEventListener("touchstart", preventTouch, { passive: false });
		   btn.addEventListener("touchend", handleClick);
		   panel.appendChild(btn);
		   legendMiniBtn = btn;
		   return btn;
		}
			 function ensureMinimapMiniButton() {
		   if (minimapMiniBtn) return minimapMiniBtn;
		   const handleClick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			minimapCollapsed = false;
			updateMinimapVisibility();
		   };
		   const preventTouch = (e) => { e.preventDefault(); };
		   const existing = document.getElementById("minimap-mini");
		   if (existing) {
			existing.addEventListener("click", handleClick);
			existing.addEventListener("touchstart", preventTouch, { passive: false });
			existing.addEventListener("touchend", handleClick);
			minimapMiniBtn = existing;
			return existing;
		   }
		   const panel = document.querySelector(".topology-panel");
		   if (!panel) return null;
		   const btn = document.createElement("button");
		   btn.type = "button";
		   btn.id = "minimap-mini";
		   btn.className = "legend-mini-btn";
		   btn.textContent = "Map";
		   btn.style.right = "10px";
		   btn.style.left = "auto";
		   btn.style.bottom = "10px";
		   btn.addEventListener("click", handleClick);
		   btn.addEventListener("touchstart", preventTouch, { passive: false });
		   btn.addEventListener("touchend", handleClick);
		   panel.appendChild(btn);
		   minimapMiniBtn = btn;
		   return btn;
		}
			  function ensureDrawToolbarMiniButton() {
		   if (drawToolbarMiniBtn) return drawToolbarMiniBtn;
		   const handleClick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			drawToolbarCollapsed = false;
			updateDrawToolbarVisibility();
		   };
		   const preventTouch = (e) => { e.preventDefault(); };
		   const existing = document.getElementById("draw-toolbar-mini");
		   if (existing) {
			existing.addEventListener("click", handleClick);
			existing.addEventListener("touchstart", preventTouch, { passive: false });
			existing.addEventListener("touchend", handleClick);
			drawToolbarMiniBtn = existing;
			return existing;
		   }
		   const panel = document.querySelector(".topology-panel");
		   if (!panel) return null;
		   const btn = document.createElement("button");
		   btn.type = "button";
		   btn.id = "draw-toolbar-mini";
		   btn.className = "legend-mini-btn";
		   btn.textContent = "Draw";
		   btn.style.top = "10px";
		   btn.style.left = "10px";
		   btn.style.right = "auto";
		   btn.addEventListener("click", handleClick);
		   btn.addEventListener("touchstart", preventTouch, { passive: false });
		   btn.addEventListener("touchend", handleClick);
		   panel.appendChild(btn);
		   drawToolbarMiniBtn = btn;
		   return btn;
		}
		  function ensureTopologyToolbarMiniButton() {
	   if (topologyToolbarMiniBtn) return topologyToolbarMiniBtn;
	   const handleClick = (e) => {
		e.stopPropagation();
		e.preventDefault();
		topologyToolbarCollapsed = false;
		updateTopologyToolbarVisibility();
	   };
	   const preventTouch = (e) => { e.preventDefault(); };
	   const existing = document.getElementById("topology-toolbar-mini");
	   if (existing) {
		existing.addEventListener("click", handleClick);
		existing.addEventListener("touchstart", preventTouch, { passive: false });
		existing.addEventListener("touchend", handleClick);
		topologyToolbarMiniBtn = existing;
		return existing;
	   }
	   const panel = document.querySelector(".topology-panel");
	   if (!panel) return null;
	   const btn = document.createElement("button");
	   btn.type = "button";
	   btn.id = "topology-toolbar-mini";
	   btn.className = "legend-mini-btn";
	   btn.textContent = "Add Line";
	   btn.style.top = "10px";
	   btn.style.left = "auto";
	   btn.style.right = "40px";
	   btn.addEventListener("click", handleClick);
	   btn.addEventListener("touchstart", preventTouch, { passive: false });
	   btn.addEventListener("touchend", handleClick);
	   panel.appendChild(btn);
	   topologyToolbarMiniBtn = btn;
	   return btn;
	}
      function updateToolbarStack() {
       if (!isMobileDevice()) return;
       const draw = document.getElementById("draw-toolbar");
       const topo = document.getElementById("topology-toolbar");
       if (!draw || !topo) return;
       const h = draw.getBoundingClientRect().height;
       document.documentElement.style.setProperty("--draw-toolbar-height", h + "px");
      }
      window.addEventListener("resize", updateToolbarStack);
      window.addEventListener("DOMContentLoaded", updateToolbarStack);
      updateToolbarStack();
      function updateLegendVisibility() {
       const legend = document.getElementById("edge-legend");
       const mini = ensureLegendMiniButton();
       if (!legend || !mini) return;
       const hasItems = legend.querySelectorAll(".legend-item").length > 0;
       if (!hasItems) {
        legend.style.display = "none";
        mini.style.display = "none";
        return;
       }
       if (legendCollapsed) {
        legend.style.display = "none";
        mini.style.display = "inline-flex";
       } else {
        legend.style.display = "flex";
        mini.style.display = "none";
       }
      }
      function updateMinimapVisibility() {
       const wrapper = document.getElementById("minimap-zoom-wrapper");
       const mini = ensureMinimapMiniButton();
       if (!wrapper || !mini) return;
       if (minimapCollapsed) {
        wrapper.style.display = "none";
        mini.style.display = "inline-flex";
       } else {
        wrapper.style.display = "block";
        mini.style.display = "none";
       }
      }
      function updateDrawToolbarVisibility() {
       const toolbar = document.getElementById("draw-toolbar");
       const mini = ensureDrawToolbarMiniButton();
       if (!toolbar || !mini) return;
       if (typeof isViewOnly === 'function' && isViewOnly()) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "none";
        return;
       }
       if (drawToolbarCollapsed) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "inline-flex";
       } else {
      if (isMobileDevice()) {
        toolbar.style.setProperty('display', 'grid', 'important');
        mini.style.display = "none";
        } else {
        toolbar.style.setProperty('display', 'flex', 'important');
        mini.style.display = "none";
      }
       }
      }
      function u8ToBase64(u8) {
      let binary = "";
      for (let i = 0; i < u8.length; i++) binary += String.fromCharCode(u8[i]);
      return btoa(binary);
      }
      function base64ToU8(base64) {
      const binary = atob(base64);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
      return bytes;
      }
      function updateTopologyToolbarVisibility() {
       const toolbar = document.getElementById("topology-toolbar");
       const mini = ensureTopologyToolbarMiniButton();
       if (!toolbar || !mini) return;
       if (typeof isViewOnly === 'function' && isViewOnly()) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "none";
        return;
       }
       const hasSelectedNode = currentNodeId !== null;
       if (!hasSelectedNode) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "none";
       } else if (topologyToolbarCollapsed) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "inline-flex";
       } else {
      if (isMobileDevice()) {
        toolbar.style.setProperty('display', 'grid', 'important');
        mini.style.display = "none";
        } else {
        toolbar.style.setProperty('display', 'flex', 'important');
        mini.style.display = "none";
      }
       }
      }
      const DEFAULT_CANVAS_HINT = document.getElementById("canvas-hint")?.innerHTML || "";
      const DEFAULT_PAGE_STATE = {
       title: "The One File: The Networkening",
       background: "",
       topbarBg: "rgba(9, 12, 20, 0.9)",
       topbarBorder: "#1f2533",
       panel: "#0b0e13",
       panelAlt: "#10141b",
       accent: "#4fd1c5",
       sidebarBg: "#10141b",
       btnBg: "#0b0e13",
       btnText: "#e2e8f0",
       tagFill: "#1e293b",
       tagText: "#e2e8f0",
       tagBorder: "#475569",
       inputBg: "#0b0e13",
       inputText: "#e2e8f0",
       inputBorder: "#1f2937",
       inputFont: "Inter, system-ui, sans-serif",
       inputFontSize: 14,
       toolbarBg: "#0f172a",
       toolbarBorder: "#1f2937",
       toolbarText: "#94a3b8",
       toolbarBtnBg: "#0b0e13",
       toolbarBtnText: "#e2e8f0",
       minimapDots: "#94a3b8",
       canvasHintEnabled: true,
       canvasHintText: "",
       canvasHintBg: "#0f172a",
       canvasHintColor: "#94a3b8",
       danger: "#f56565",
       textMain: "#e2e8f0",
       textSoft: "#94a3b8",
       topbarHeight: 52,
       sidebarWidth: 350,
       mobileFooterHeight: 40,
       sidebarCollapsed: false,
       nodeFill: "#1e293b",
       nodeStroke: "#475569",
       nodeTitle: "#e2e8f0",
       nodeSub: "#94a3b8",
       nodeTitleSize: 18,
       nodeSubSize: 13,
       nodeFont: "Inter, system-ui, sans-serif",
       defaultEdge: "#475569",
       selectionHandle: "#f59e0b",
       selectionHandleSize: 8,
       groupIndicator: "#4fd1c5",
       canvasGradientTop: "#1e2532",
       canvasGradientBottom: "#050608",
       canvasBorder: "#475569",
       canvasGrid: "#475569",
       canvasGridSize: 50,
       rackFrameFill: "#0f172a",
       rackFrameStroke: "#4fd1c5",
       rackLineColor: "#475569",
       rackTextColor: "#4fd1c5",
	   viewOnly: false,
      };
      let PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE);
	  function isViewOnly() {
       return PAGE_STATE.viewOnly === true;
      }
      let viewOnlyClickCount = 0;
      let viewOnlyClickTimer = null;
      let viewOnlyClickTarget = null;
      function handleViewOnlyClick(id, type) {
       if (!isViewOnly()) return false;
       if (viewOnlyClickTarget !== id) {
        viewOnlyClickCount = 0;
        viewOnlyClickTarget = id;
       }
       viewOnlyClickCount++;
       clearTimeout(viewOnlyClickTimer);
       viewOnlyClickTimer = setTimeout(() => {
        viewOnlyClickCount = 0;
        viewOnlyClickTarget = null;
       }, 2000);
       if (viewOnlyClickCount >= 5) {
        viewOnlyClickCount = 0;
        viewOnlyClickTarget = null;
        document.body.classList.add("view-only-inspect");
        if (type === 'node') {
         currentNodeId = id;
         const data = NODE_DATA[id];
         if (data) {
          document.querySelectorAll(".node-group").forEach((n) => {
           n.classList.toggle("active", n.dataset.nodeId === id);
          });
          document.getElementById("node-panel").style.display = "block";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("node-name").textContent = data.name;
          document.getElementById("node-ip").textContent = data.ip;
          document.getElementById("node-role").textContent = data.role;
          document.getElementById("node-mac").textContent = data.mac || "--";
          document.getElementById("node-rack").textContent = data.rackUnit || "--";
          document.getElementById("node-uheight").textContent = (data.uHeight || "1") + "U";
          const tagList = document.getElementById("node-tags");
          if (tagList) {
           tagList.innerHTML = "";
           if (data.tags && data.tags.length > 0) {
            data.tags.forEach((tag) => {
             const li = document.createElement("li");
             li.textContent = tag;
             tagList.appendChild(li);
            });
           }
          }
          const noteList = document.getElementById("node-notes");
          if (noteList) {
           noteList.innerHTML = "";
           if (data.notes && data.notes.length > 0) {
            data.notes.forEach((note) => {
             const li = document.createElement("li");
             li.textContent = note;
             noteList.appendChild(li);
            });
           }
          }
         }
        } else if (type === 'edge') {
         currentEdgeId = id;
         const edge = EDGE_DATA.list.find(e => e.id === id);
         if (edge) {
          document.querySelectorAll(".edge").forEach((e) => {
           e.classList.toggle("active", e.dataset.edgeId === id);
          });
          document.getElementById("edge-panel").style.display = "block";
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-from").textContent = NODE_DATA[edge.from]?.name || edge.from;
          document.getElementById("edge-to").textContent = NODE_DATA[edge.to]?.name || edge.to;
          document.getElementById("edge-label").value = edge.label || "";
         }
        }
        return true;
       }
       return false;
      }
      const CANVAS_WIDTH = 4000;
      let CANVAS_HEIGHT = 3000;
      const BASE_CANVAS_HEIGHT = 3000;
      const CANVAS_PADDING = 100;
      const RACK_U_HEIGHT = 70;
      const RACK_WIDTH = 600;
      const RACK_START_X = CANVAS_WIDTH / 2;
      const RACK_START_Y = CANVAS_PADDING + 100;
      function getRackUHeight(rackId) {
      const capacity = getRackCapacity(rackId);
      const availableHeight = CANVAS_HEIGHT - RACK_START_Y - 200;
      return Math.floor(availableHeight / capacity);
      }
      let canvasState = {
       zoom: 1,
       panX: 0,
       panY: 0,
       minZoom: 0.25,
       maxZoom: 4,
       isPanning: false,
       panStartX: 0,
       panStartY: 0,
       spacePressed: false,
      };
      function getViewBox() {
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       return {
        x: canvasState.panX,
        y: canvasState.panY,
        width: viewWidth,
        height: viewHeight,
       };
      }
      function updateViewBox() {
       const svg = document.getElementById("map");
       const vb = getViewBox();
       svg.setAttribute("viewBox", `${vb.x} ${vb.y} ${vb.width} ${vb.height}`, );
       const zoomLevel = document.getElementById("zoom-level");
       if (zoomLevel) {
        zoomLevel.textContent = Math.round(canvasState.zoom * 100) + "%";
       }
       updateMinimap();
      }
      function updateMinimap() {
       const minimapViewport = document.getElementById("minimap-viewport");
       const minimapSvg = document.getElementById("minimap");
       if (!minimapViewport || !minimapSvg) return;
       const vb = getViewBox();
       minimapViewport.setAttribute("x", vb.x);
       minimapViewport.setAttribute("y", vb.y);
       minimapViewport.setAttribute("width", vb.width);
       minimapViewport.setAttribute("height", vb.height);
       const minimapNodes = minimapSvg.querySelectorAll(".minimap-node");
       minimapNodes.forEach((n) => n.remove());
       const minimapEdges = minimapSvg.querySelectorAll(".minimap-edge");
       minimapEdges.forEach((e) => e.remove());
       EDGE_DATA.list.forEach((edge) => {
        if (edge.type === "custom") return;
        const fromNode = NODE_DATA[edge.from];
        const toNode = NODE_DATA[edge.to];
        if (!fromNode || !toNode) return;
        if (currentView.mode === "rack") {
         if (fromNode.assignedRack !== currentView.rackId ||
             toNode.assignedRack !== currentView.rackId) {
          return;
         }
        } else {
         if (fromNode.assignedRack || toNode.assignedRack) {
          return;
         }
        }
        const p1 = savedPositions[edge.from];
        const p2 = savedPositions[edge.to];
        if (!p1 || !p2) return;
        const line = document.createElementNS("http://www.w3.org/2000/svg", "line", );
        line.setAttribute("x1", p1.x);
        line.setAttribute("y1", p1.y);
        line.setAttribute("x2", p2.x);
        line.setAttribute("y2", p2.y);
        line.classList.add("minimap-edge");
        minimapSvg.insertBefore(line, minimapViewport);
       });
       Object.entries(savedPositions).forEach(([id, pos]) => {
        const node = NODE_DATA[id];
        if (!node) return;
        if (currentView.mode === "rack") {
         if (node.assignedRack !== currentView.rackId) {
          return;
         }
        } else {
         if (node.assignedRack) {
          return;
         }
        }
        const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle", );
        circle.setAttribute("cx", pos.x);
        circle.setAttribute("cy", pos.y);
        circle.setAttribute("r", 40);
        circle.classList.add("minimap-node");
        minimapSvg.insertBefore(circle, minimapViewport);
       });
      }
      function zoomTo(newZoom, centerX, centerY) {
       const oldZoom = canvasState.zoom;
       newZoom = Math.max(canvasState.minZoom, Math.min(canvasState.maxZoom, newZoom), );
       if (centerX !== undefined && centerY !== undefined) {
        const oldWidth = CANVAS_WIDTH / oldZoom;
        const oldHeight = CANVAS_HEIGHT / oldZoom;
        const newWidth = CANVAS_WIDTH / newZoom;
        const newHeight = CANVAS_HEIGHT / newZoom;
        const pointX = canvasState.panX + centerX * oldWidth;
        const pointY = canvasState.panY + centerY * oldHeight;
        canvasState.panX = pointX - centerX * newWidth;
        canvasState.panY = pointY - centerY * newHeight;
       }
       canvasState.zoom = newZoom;
       constrainPan();
       updateViewBox();
      }
      function constrainPan() {
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       const minVisiblePortion = 0.1;
       const maxPanX = CANVAS_WIDTH - viewWidth * minVisiblePortion;
       const maxPanY = CANVAS_HEIGHT - viewHeight * minVisiblePortion;
       const minPanX = -viewWidth * (1 - minVisiblePortion);
       const minPanY = -viewHeight * (1 - minVisiblePortion);
       canvasState.panX = Math.max(minPanX, Math.min(maxPanX, canvasState.panX), );
       canvasState.panY = Math.max(minPanY, Math.min(maxPanY, canvasState.panY), );
      }
      function fitToContent() {
       const positions = Object.values(savedPositions);
       if (positions.length === 0) {
        resetView();
        return;
       }
       let minX = Infinity,
        minY = Infinity,
        maxX = -Infinity,
        maxY = -Infinity;
       positions.forEach((pos) => {
        minX = Math.min(minX, pos.x - 100);
        minY = Math.min(minY, pos.y - 100);
        maxX = Math.max(maxX, pos.x + 100);
        maxY = Math.max(maxY, pos.y + 100);
       });
       const contentWidth = maxX - minX + 200;
       const contentHeight = maxY - minY + 200;
       const viewport = document.getElementById("canvas-viewport");
       const vpRect = viewport.getBoundingClientRect();
       const aspectRatio = vpRect.width / vpRect.height;
       const contentAspect = contentWidth / contentHeight;
       let newZoom;
       if (contentAspect > aspectRatio) {
        newZoom = (vpRect.width / contentWidth) * (CANVAS_WIDTH / vpRect.width);
       } else {
        newZoom = (vpRect.height / contentHeight) * (CANVAS_HEIGHT / vpRect.height);
       }
       newZoom = Math.max(canvasState.minZoom, Math.min(2, newZoom));
       const viewWidth = CANVAS_WIDTH / newZoom;
       const viewHeight = CANVAS_HEIGHT / newZoom;
       canvasState.zoom = newZoom;
       canvasState.panX = minX - 100 - (viewWidth - contentWidth) / 2;
       canvasState.panY = minY - 100 - (viewHeight - contentHeight) / 2;
       constrainPan();
       updateViewBox();
      }
      function resetView() {
       canvasState.zoom = 1;
       canvasState.panX = 0;
       canvasState.panY = 0;
       updateViewBox();
      }
      window.addEventListener("DOMContentLoaded", () => {
       const toggle = document.getElementById("mobile-menu-toggle");
       const menu = document.getElementById("topbar-menu");
       if (!toggle || !menu) return;
       toggle.addEventListener("click", () => {
        menu.classList.toggle("open");
       });
       menu.addEventListener("click", (e) => {
        const target = e.target.closest("a, button");
        if (!target) return;
        if (isMobileDevice()) {
       menu.classList.remove("open");
      }
       });
       const minimapCloseBtn = document.getElementById("minimap-close-btn");
       if (minimapCloseBtn) {
        const handleMinimapClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         minimapCollapsed = true;
         updateMinimapVisibility();
        };
        minimapCloseBtn.addEventListener("click", handleMinimapClose);
        minimapCloseBtn.addEventListener("touchend", handleMinimapClose);
       }
       const drawToolbarCloseBtn = document.getElementById("draw-toolbar-close-btn");
       if (drawToolbarCloseBtn) {
        const handleDrawClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         drawToolbarCollapsed = true;
         updateDrawToolbarVisibility();
        };
        drawToolbarCloseBtn.addEventListener("click", handleDrawClose);
        drawToolbarCloseBtn.addEventListener("touchend", handleDrawClose);
       }
       const topologyToolbarCloseBtn = document.getElementById("topology-toolbar-close-btn");
       if (topologyToolbarCloseBtn) {
        const handleTopologyClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         topologyToolbarCollapsed = true;
         updateTopologyToolbarVisibility();
        };
        topologyToolbarCloseBtn.addEventListener("click", handleTopologyClose);
        topologyToolbarCloseBtn.addEventListener("touchstart", (e) => e.preventDefault(), {
         passive: false
        });
        topologyToolbarCloseBtn.addEventListener("touchend", handleTopologyClose);
       }
       updateMinimapVisibility();
       updateDrawToolbarVisibility();
       updateTopologyToolbarVisibility();
      });
      function applyLayerFilter() {
       activeLayers.clear();
       if (document.getElementById("layer-physical").checked) activeLayers.add("physical");
       if (document.getElementById("layer-logical").checked) activeLayers.add("logical");
       if (document.getElementById("layer-security").checked) activeLayers.add("security");
       if (document.getElementById("layer-application").checked) activeLayers.add("application");
       forgeTheTopology();
      }
      function isNodeVisible(nodeId) {
       const node = NODE_DATA[nodeId];
       if (!node) return false;
       const nodeLayer = node.layer || "physical";
       return activeLayers.has(nodeLayer);
      }
      function enterRack(rackId) {
      if (!NODE_DATA[rackId] || !NODE_DATA[rackId].isRack) return;
      const rackCapacity = getRackCapacity(rackId);
      const neededHeight = RACK_START_Y + (rackCapacity * RACK_U_HEIGHT) + 200;
      if (neededHeight > BASE_CANVAS_HEIGHT) {
      CANVAS_HEIGHT = neededHeight;
      }
       currentView.mode = "rack";
       currentView.rackId = rackId;
       const backBtn = document.getElementById("back-to-topology-btn");
       if (backBtn) backBtn.style.display = "inline-block";
       const hint = document.getElementById("canvas-hint");
       if (hint) {
        hint.textContent = `Viewing: ${NODE_DATA[rackId].name} | Double click empty space to exit`;
        hint.classList.add("visible");
       }
      const rackUHeight = getRackUHeight(rackId);
      const rackHeight = rackCapacity * rackUHeight;
      const rackCenterX = RACK_START_X;
      const rackCenterY = RACK_START_Y + (rackHeight / 2);
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       canvasState.panX = rackCenterX - (viewWidth / 2);
       canvasState.panY = rackCenterY - (viewHeight / 2);
       constrainPan();
       updateViewBox();
       forgeTheTopology();
      }
      function exitRack() {
      CANVAS_HEIGHT = BASE_CANVAS_HEIGHT;
      currentView.mode = "topology";
      currentView.rackId = null;
       const backBtn = document.getElementById("back-to-topology-btn");
       if (backBtn) backBtn.style.display = "none";
       const hint = document.getElementById("canvas-hint");
       if (hint) {
        hint.classList.remove("visible");
       }
       if (savedTopologyView) {
        canvasState.zoom = savedTopologyView.zoom;
        canvasState.panX = savedTopologyView.panX;
        canvasState.panY = savedTopologyView.panY;
        updateViewBox();
       }
       forgeTheTopology();
      }
      function getRackCapacity(rackId) {
       const node = NODE_DATA[rackId];
       return node && node.rackCapacity ? parseInt(node.rackCapacity) : 42;
      }
      function populateRackDropdown() {
       const dropdown = document.getElementById("node-assigned-rack");
       if (!dropdown) return;
       dropdown.innerHTML = '<option value="">None</option>';
       Object.keys(NODE_DATA).forEach(id => {
        if (NODE_DATA[id].isRack) {
         const option = document.createElement("option");
         option.value = id;
         option.textContent = NODE_DATA[id].name;
         dropdown.appendChild(option);
        }
       });
      }
      function wieldThePower() {
       const root = document.documentElement;
       root.style.setProperty("--panel", PAGE_STATE.panel);
       root.style.setProperty("--panel-alt", PAGE_STATE.panelAlt);
       root.style.setProperty("--sidebar-bg", PAGE_STATE.sidebarBg || PAGE_STATE.panelAlt);
       root.style.setProperty("--btn-bg", PAGE_STATE.btnBg || PAGE_STATE.panel);
       root.style.setProperty("--btn-text", PAGE_STATE.btnText || "#e2e8f0");
       root.style.setProperty("--tag-fill", PAGE_STATE.tagFill || "#1e293b");
       root.style.setProperty("--tag-text", PAGE_STATE.tagText || "#e2e8f0");
       root.style.setProperty("--tag-border", PAGE_STATE.tagBorder || "#475569");
       root.style.setProperty("--input-bg", PAGE_STATE.inputBg || "#0b0e13");
       root.style.setProperty("--input-text", PAGE_STATE.inputText || "#e2e8f0");
       root.style.setProperty("--input-border", PAGE_STATE.inputBorder || "#1f2937");
       root.style.setProperty("--input-font", PAGE_STATE.inputFont || "Inter, system-ui, sans-serif");
       root.style.setProperty("--input-font-size", (PAGE_STATE.inputFontSize || 14) + "px");
       root.style.setProperty("--toolbar-bg", PAGE_STATE.toolbarBg || "#0f172a");
       root.style.setProperty("--toolbar-border", PAGE_STATE.toolbarBorder || "#1f2937");
       root.style.setProperty("--toolbar-text", PAGE_STATE.toolbarText || "#94a3b8");
       root.style.setProperty("--toolbar-btn-bg", PAGE_STATE.toolbarBtnBg || "#0b0e13");
       root.style.setProperty("--toolbar-btn-text", PAGE_STATE.toolbarBtnText || "#e2e8f0");
       root.style.setProperty("--minimap-dots", PAGE_STATE.minimapDots || "#94a3b8");
       root.style.setProperty("--canvas-hint-bg", PAGE_STATE.canvasHintBg || "#0f172a");
       root.style.setProperty("--canvas-hint-color", PAGE_STATE.canvasHintColor || "#94a3b8");
       const canvasHint = document.getElementById("canvas-hint");
       if (canvasHint) {
        canvasHint.style.display = PAGE_STATE.canvasHintEnabled === false ? "none" : "";
        if (PAGE_STATE.canvasHintText !== undefined && PAGE_STATE.canvasHintText !== "") {
         canvasHint.innerHTML = PAGE_STATE.canvasHintText;
        } else {
         canvasHint.innerHTML = DEFAULT_CANVAS_HINT;
        }
       }
       root.style.setProperty("--accent", PAGE_STATE.accent);
       root.style.setProperty("--danger", PAGE_STATE.danger);
       root.style.setProperty("--text-main", PAGE_STATE.textMain);
       root.style.setProperty("--text-soft", PAGE_STATE.textSoft);
       root.style.setProperty("--topbar-bg", PAGE_STATE.topbarBg);
       root.style.setProperty("--topbar-border", PAGE_STATE.topbarBorder);
       root.style.setProperty("--node-fill", PAGE_STATE.nodeFill || "#1e293b");
       root.style.setProperty("--node-stroke", PAGE_STATE.nodeStroke || "#475569");
       root.style.setProperty("--node-title", PAGE_STATE.nodeTitle || "#e2e8f0");
       root.style.setProperty("--node-sub", PAGE_STATE.nodeSub || "#94a3b8");
       root.style.setProperty("--node-title-size", (PAGE_STATE.nodeTitleSize || 18) + "px");
       root.style.setProperty("--node-sub-size", (PAGE_STATE.nodeSubSize || 13) + "px");
       root.style.setProperty("--node-font", PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif");
       root.style.setProperty("--default-edge", PAGE_STATE.defaultEdge || "#475569");
       root.style.setProperty("--selection-handle", PAGE_STATE.selectionHandle || "#f59e0b");
       root.style.setProperty("--selection-handle-size", (PAGE_STATE.selectionHandleSize || 8) + "px");
       root.style.setProperty("--group-indicator", PAGE_STATE.groupIndicator || "#4fd1c5");
       const topbarHeight = PAGE_STATE.topbarHeight || 52;
       const sidebarWidth = PAGE_STATE.sidebarWidth || 350;
       const mobileFooterHeight = PAGE_STATE.mobileFooterHeight || 40;
       root.style.setProperty("--topbar-height", topbarHeight + "px");
       root.style.setProperty("--sidebar-width", sidebarWidth + "px");
       root.style.setProperty("--mobile-footer-height", mobileFooterHeight + "vh", );
       const mainEl = document.querySelector("main");
       const detailsPanel = document.getElementById("details-panel");
       const sidebarToggle = document.getElementById("sidebar-toggle");
       if (PAGE_STATE.sidebarCollapsed) {
        if (mainEl) mainEl.classList.add("sidebar-collapsed");
        if (detailsPanel) detailsPanel.classList.add("collapsed");
        if (sidebarToggle) {
         sidebarToggle.classList.add("collapsed");
         sidebarToggle.textContent = "‚ñ∂";
        }
       } else {
        if (mainEl) mainEl.classList.remove("sidebar-collapsed");
        if (detailsPanel) detailsPanel.classList.remove("collapsed");
        if (sidebarToggle) {
         sidebarToggle.classList.remove("collapsed");
         sidebarToggle.textContent = "‚óÄ";
        }
       }
       if (PAGE_STATE.background) {
        document.body.style.background = PAGE_STATE.background;
       } else {
        document.body.style.background = `radial-gradient(circle at top, ${PAGE_STATE.canvasGradientTop || "#1e2532"} 0, ${PAGE_STATE.canvasGradientBottom || "#050608"} 70%)`;
       }
       document.title = PAGE_STATE.title || DEFAULT_PAGE_STATE.title;
       const titleEl = document.getElementById("page-title");
       if (titleEl) {
        titleEl.textContent = PAGE_STATE.title || DEFAULT_PAGE_STATE.title;
       }
       const viewOnlyMode = PAGE_STATE.viewOnly === true;
       const addNodeBtn = document.getElementById("add-node-btn");
       const addRackBtn = document.getElementById("add-rack-btn");
       const bulkToolbar = document.getElementById("bulk-toolbar");
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       if (viewOnlyMode) {
        if (addNodeBtn) addNodeBtn.style.display = "none";
        if (addRackBtn) addRackBtn.style.display = "none";
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        ["draw-toolbar-mini", "topology-toolbar-mini"].forEach(id => {
         const el = document.getElementById(id);
         if (el) el.style.display = "none";
        });
        document.body.classList.remove("view-only-inspect");
       } else {
        if (addNodeBtn) addNodeBtn.style.display = "";
        if (addRackBtn) addRackBtn.style.display = "";
       }
       document.body.classList.toggle("view-only-mode", viewOnlyMode);
       if (!viewOnlyMode) {
        if (typeof updateDrawToolbarVisibility === 'function') updateDrawToolbarVisibility();
        if (typeof updateTopologyToolbarVisibility === 'function') updateTopologyToolbarVisibility();
       }
      }
      (async function awakeTheImmortal() {
       let initialState = {};
       let decryptionCancelled = false;
       const stateEl = document.getElementById("topology-state");
       if (stateEl && stateEl.textContent.trim()) {
        try {
         let stateText = stateEl.textContent.trim();
         if (isEncrypted(stateText)) {
          let decrypted = false;
          let attempts = 0;
          const maxAttempts = 3;
          while (!decrypted && attempts < maxAttempts) {
           const password = prompt("This file is encrypted. Enter password to decrypt:\n(Attempt " + (attempts + 1) + " of " + maxAttempts + ")", );
           if (!password) {
            alert("Decryption cancelled. The file will not be loaded.", );
            decryptionCancelled = true;
            break;
           }
           try {
            stateText = await decryptData(stateText, password);
            decrypted = true;
           } catch (e) {
            attempts++;
            if (attempts < maxAttempts) {
             alert("Incorrect password. Please try again.");
            } else {
             alert("Maximum attempts reached. The file will not be loaded.", );
             decryptionCancelled = true;
            }
           }
          }
          if (!decrypted) {
           stateText = "{}";
          }
         }
         initialState = JSON.parse(stateText);
        } catch (e) {
         console.error("Failed to load state:", e);
         initialState = {};
        }
       }
       if (decryptionCancelled) {
        NODE_DATA = {};
        EDGE_DATA = {
         list: []
        };
        RECT_DATA = { list: [] };
        TEXT_DATA = { list: [] };
        EDGE_LEGEND = {};
        savedPositions = {};
        savedSizes = {};
        savedStyles = {};
       } else {
        NODE_DATA = initialState.nodeData ? initialState.nodeData : BASE_NODE_DATA;
        Object.keys(NODE_DATA).forEach(nodeId => {
         if (!NODE_DATA[nodeId].ping) {
          NODE_DATA[nodeId].ping = {
           enabled: false,
           protocol: 'http',
           customUrl: '',
           timeout: 3000,
           status: 'unknown',
           lastCheck: null
          };
         }
        });
        EDGE_DATA = initialState.edgeData ? initialState.edgeData : {
         list: [],
        };
        RECT_DATA = initialState.rectData ? initialState.rectData : { list: [] };
        TEXT_DATA = initialState.textData ? initialState.textData : { list: [] };
        EDGE_LEGEND = initialState.edgeLegend || {};
        savedPositions = initialState.nodePositions || {};
        savedSizes = initialState.nodeSizes || {};
        savedStyles = initialState.nodeStyles || {};
        if (initialState.iconCache) {
         IconLibrary.iconCache = initialState.iconCache;
        }
       }
       if (initialState.page) {
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, initialState.page, );
       }
       if (PAGE_STATE.autoPingEnabled !== undefined) {
        autoPingEnabled = PAGE_STATE.autoPingEnabled;
       }
       if (PAGE_STATE.autoPingInterval !== undefined) {
        autoPingInterval = PAGE_STATE.autoPingInterval;
       }
       if (initialState.canvas) {
        canvasState.zoom = initialState.canvas.zoom || 1;
        canvasState.panX = initialState.canvas.panX || 0;
        canvasState.panY = initialState.canvas.panY || 0;
       }
       if (initialState.savedTopologyView) {
        savedTopologyView = initialState.savedTopologyView;
       }
       if (initialState.documentTabs) {
        documentTabs = initialState.documentTabs;
        if (initialState.currentTabIndex !== undefined) {
          currentTabIndex = initialState.currentTabIndex;
          const currentTab = documentTabs[currentTabIndex];
          if (currentTab) {
            NODE_DATA = currentTab.nodes || NODE_DATA;
            EDGE_DATA = currentTab.edges || EDGE_DATA;
            savedPositions = currentTab.positions || savedPositions;
            savedSizes = currentTab.sizes || savedSizes;
            savedStyles = currentTab.styles || savedStyles;
            EDGE_LEGEND = currentTab.legend || EDGE_LEGEND;
            RECT_DATA = currentTab.rects || RECT_DATA;
            TEXT_DATA = currentTab.texts || TEXT_DATA;
            if (currentTab.pageState) PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, currentTab.pageState);
          }
        }
       }
       if (initialState.encryptedSections) {
        encryptedSections = initialState.encryptedSections;
       }
       wieldThePower();
       forgeTheTopology();
       updateViewBox();
       MobileManager.applyAll();
       if (autoPingEnabled) {
        startAutoPing();
       }
       const initialNodes = Object.keys(NODE_DATA);
       if (initialNodes.length > 0) {
        claimTheImmortal(initialNodes.includes("host") ? "host" : initialNodes[0], );
       } else {
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.display = "none";
       }
      })();
      let resizeDebounceTimer = null;
      window.addEventListener("resize", () => {
        clearTimeout(resizeDebounceTimer);
        resizeDebounceTimer = setTimeout(() => {
          MobileManager.applyAll();
          if (typeof updateDrawToolbarVisibility === 'function') updateDrawToolbarVisibility();
          if (typeof updateTopologyToolbarVisibility === 'function') updateTopologyToolbarVisibility();
        }, 100);
      });
      function getBreakpointKey() {
       const w = window.innerWidth;
       if (w <= 380) return "fold";
       if (w <= 768) return "mobile";
       if (w <= 1024) return "tablet";
       return "desktop";
      }
      function resolveStylesEntry(styleEntry) {
       if (!styleEntry) return {};
       if (styleEntry.circleColor || styleEntry.titleColor || styleEntry.titleFont || styleEntry.titleSize || styleEntry.subColor || styleEntry.subFont || styleEntry.subSize) {
        return styleEntry;
       }
       const bp = getBreakpointKey();
       const base = styleEntry.all || {};
       const bpStyles = styleEntry[bp] || {};
       return Object.assign({}, base, bpStyles);
      }
      function resolveStylesForNode(id) {
       const styleEntry = savedStyles[id];
       if (!styleEntry) return {};
       return resolveStylesEntry(styleEntry);
      }
      function ensureStyleEntry(id) {
       if (!savedStyles[id]) savedStyles[id] = {};
       const entry = savedStyles[id];
       const flatProps = ["circleColor", "circleBorder", "titleColor", "titleFont", "titleSize", "subColor", "subFont", "subSize", ];
       const isFlat = flatProps.some((p) => Object.prototype.hasOwnProperty.call(entry, p), );
       if (isFlat) {
        const all = entry.all || {};
        flatProps.forEach((p) => {
         if (entry[p] !== undefined) {
          all[p] = entry[p];
          delete entry[p];
         }
        });
        entry.all = all;
       }
       return entry;
      }
      function getDefaultSize() {
       if (window.innerWidth <= 380) return 120;
       if (window.innerWidth <= 768) return 140;
       if (window.innerWidth <= 1024) return 70;
       return 55;
      }
      function createShapeElement(shape, size) {
       const ns = "http://www.w3.org/2000/svg";
       if (shape === "circle") {
        const c = document.createElementNS(ns, "circle");
        c.setAttribute("r", size);
        return c;
       }
       if (shape === "square") {
        const r = document.createElementNS(ns, "rect");
        const s = size * 2;
        r.setAttribute("x", -size);
        r.setAttribute("y", -size);
        r.setAttribute("width", s);
        r.setAttribute("height", s);
        r.setAttribute("rx", 4);
        return r;
       }
       if (shape === "rectangle") {
        const r = document.createElementNS(ns, "rect");
        r.setAttribute("x", -size * 1.4);
        r.setAttribute("y", -size * 0.8);
        r.setAttribute("width", size * 2.8);
        r.setAttribute("height", size * 1.6);
        r.setAttribute("rx", 6);
        return r;
       }
       if (shape === "triangle") {
        const p = document.createElementNS(ns, "polygon");
        const h = size * 1.8;
        const w = size * 2;
        p.setAttribute("points", `0,${-h} ${w / 2},${h / 2} ${-w / 2},${h / 2}`, );
        return p;
       }
       if (shape === "hexagon") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        const pts = [
         [0, -s],
         [s * 0.86, -s * 0.5],
         [s * 0.86, s * 0.5],
         [0, s],
         [-s * 0.86, s * 0.5],
         [-s * 0.86, -s * 0.5],
        ].map((pt) => pt.join(",")).join(" ");
        p.setAttribute("points", pts);
        return p;
       }
       if (shape === "stop-sign") {
        const p = document.createElementNS(ns, "polygon");
        const r = size;
        const ptsArr = [];
        for (let i = 0; i < 8; i++) {
         const a = (Math.PI / 4) * i + Math.PI / 8;
         ptsArr.push([Math.cos(a) * r, Math.sin(a) * r]);
        }
        const pts = ptsArr.map((pt) => pt.join(",")).join(" ");
        p.setAttribute("points", pts);
        return p;
       }
       if (shape === "star") {
        const p = document.createElementNS(ns, "polygon");
        const outer = size;
        const inner = size * 0.45;
        let pts = "";
        for (let i = 0; i < 10; i++) {
         const a = (Math.PI / 5) * i - Math.PI / 2;
         const r = i % 2 === 0 ? outer : inner;
         pts += `${Math.cos(a) * r},${Math.sin(a) * r} `;
        }
        p.setAttribute("points", pts.trim());
        return p;
       }
       if (shape === "diamond") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `0,${-s} ${s},0 0,${s} ${-s},0`);
        return p;
       }
       if (shape === "server") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.2);
        body.setAttribute("y", -size * 0.6);
        body.setAttribute("width", size * 2.4);
        body.setAttribute("height", size * 1.2);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 3; i++) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", -size * 0.9 + i * size * 0.5);
         line.setAttribute("y1", -size * 0.3);
         line.setAttribute("x2", -size * 0.9 + i * size * 0.5);
         line.setAttribute("y2", size * 0.3);
         line.style.stroke = "currentColor";
         line.style.strokeWidth = "2";
         line.style.opacity = "0.5";
         g.appendChild(line);
        }
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", size * 0.9);
        led.setAttribute("cy", 0);
        led.setAttribute("r", size * 0.1);
        led.style.fill = "#4ade80";
        g.appendChild(led);
        return g;
       }
       if (shape === "pc" || shape === "desktop") {
        const g = document.createElementNS(ns, "g");
        const monitor = document.createElementNS(ns, "rect");
        monitor.setAttribute("x", -size * 0.9);
        monitor.setAttribute("y", -size * 0.8);
        monitor.setAttribute("width", size * 1.8);
        monitor.setAttribute("height", size * 1.2);
        monitor.setAttribute("rx", 4);
        g.appendChild(monitor);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.75);
        screen.setAttribute("y", -size * 0.65);
        screen.setAttribute("width", size * 1.5);
        screen.setAttribute("height", size * 0.9);
        screen.setAttribute("rx", 2);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        const neck = document.createElementNS(ns, "rect");
        neck.setAttribute("x", -size * 0.15);
        neck.setAttribute("y", size * 0.4);
        neck.setAttribute("width", size * 0.3);
        neck.setAttribute("height", size * 0.3);
        g.appendChild(neck);
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.5);
        base.setAttribute("y", size * 0.7);
        base.setAttribute("width", size * 1);
        base.setAttribute("height", size * 0.15);
        base.setAttribute("rx", 2);
        g.appendChild(base);
        return g;
       }
       if (shape === "laptop") {
        const g = document.createElementNS(ns, "g");
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.8);
        screen.setAttribute("y", -size * 0.9);
        screen.setAttribute("width", size * 1.6);
        screen.setAttribute("height", size * 1.1);
        screen.setAttribute("rx", 4);
        g.appendChild(screen);
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.9);
        base.setAttribute("y", size * 0.25);
        base.setAttribute("width", size * 1.8);
        base.setAttribute("height", size * 0.6);
        base.setAttribute("rx", 4);
        g.appendChild(base);
        const pad = document.createElementNS(ns, "rect");
        pad.setAttribute("x", -size * 0.25);
        pad.setAttribute("y", size * 0.45);
        pad.setAttribute("width", size * 0.5);
        pad.setAttribute("height", size * 0.25);
        pad.setAttribute("rx", 2);
        pad.style.fill = "#1e293b";
        g.appendChild(pad);
        return g;
       }
       if (shape === "phone" || shape === "mobile") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.45);
        body.setAttribute("y", -size);
        body.setAttribute("width", size * 0.9);
        body.setAttribute("height", size * 2);
        body.setAttribute("rx", 8);
        g.appendChild(body);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.38);
        screen.setAttribute("y", -size * 0.85);
        screen.setAttribute("width", size * 0.76);
        screen.setAttribute("height", size * 1.6);
        screen.setAttribute("rx", 4);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        const btn = document.createElementNS(ns, "rect");
        btn.setAttribute("x", -size * 0.15);
        btn.setAttribute("y", size * 0.82);
        btn.setAttribute("width", size * 0.3);
        btn.setAttribute("height", size * 0.06);
        btn.setAttribute("rx", 2);
        btn.style.fill = "#475569";
        g.appendChild(btn);
        return g;
       }
       if (shape === "router") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.1);
        body.setAttribute("y", -size * 0.3);
        body.setAttribute("width", size * 2.2);
        body.setAttribute("height", size * 0.8);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        for (let i = -1; i <= 1; i++) {
         const ant = document.createElementNS(ns, "rect");
         ant.setAttribute("x", i * size * 0.6 - size * 0.05);
         ant.setAttribute("y", -size * 0.9);
         ant.setAttribute("width", size * 0.1);
         ant.setAttribute("height", size * 0.6);
         ant.setAttribute("rx", 2);
         g.appendChild(ant);
         const tip = document.createElementNS(ns, "circle");
         tip.setAttribute("cx", i * size * 0.6);
         tip.setAttribute("cy", -size * 0.95);
         tip.setAttribute("r", size * 0.08);
         g.appendChild(tip);
        }
        for (let i = 0; i < 4; i++) {
         const led = document.createElementNS(ns, "circle");
         led.setAttribute("cx", -size * 0.7 + i * size * 0.35);
         led.setAttribute("cy", size * 0.1);
         led.setAttribute("r", size * 0.06);
         led.style.fill = i < 2 ? "#4ade80" : "#facc15";
         g.appendChild(led);
        }
        return g;
       }
       if (shape === "switch") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.4);
        body.setAttribute("y", -size * 0.4);
        body.setAttribute("width", size * 2.8);
        body.setAttribute("height", size * 0.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 8; i++) {
         const port = document.createElementNS(ns, "rect");
         port.setAttribute("x", -size * 1.2 + i * size * 0.32);
         port.setAttribute("y", -size * 0.15);
         port.setAttribute("width", size * 0.22);
         port.setAttribute("height", size * 0.3);
         port.setAttribute("rx", 1);
         port.style.fill = "#1e293b";
         g.appendChild(port);
        }
        return g;
       }
       if (shape === "firewall") {
        const g = document.createElementNS(ns, "g");
        const wall = document.createElementNS(ns, "rect");
        wall.setAttribute("x", -size);
        wall.setAttribute("y", -size * 0.8);
        wall.setAttribute("width", size * 2);
        wall.setAttribute("height", size * 1.6);
        wall.setAttribute("rx", 4);
        g.appendChild(wall);
        for (let row = 0; row < 3; row++) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", -size * 0.85);
         line.setAttribute("y1", -size * 0.5 + row * size * 0.45);
         line.setAttribute("x2", size * 0.85);
         line.setAttribute("y2", -size * 0.5 + row * size * 0.45);
         line.style.stroke = "#475569";
         line.style.strokeWidth = "2";
         g.appendChild(line);
        }
        for (let row = 0; row < 4; row++) {
         const offset = row % 2 === 0 ? 0 : size * 0.35;
         for (let col = 0; col < 3; col++) {
          const line = document.createElementNS(ns, "line");
          const x = -size * 0.5 + col * size * 0.7 + offset;
          if (x > -size * 0.85 && x < size * 0.85) {
           line.setAttribute("x1", x);
           line.setAttribute("y1", -size * 0.8 + row * size * 0.45, );
           line.setAttribute("x2", x);
           line.setAttribute("y2", -size * 0.8 + row * size * 0.45 + size * 0.45, );
           line.style.stroke = "#475569";
           line.style.strokeWidth = "2";
           g.appendChild(line);
          }
         }
        }
        return g;
       }
       if (shape === "cloud") {
        const p = document.createElementNS(ns, "path");
        const s = size;
        p.setAttribute("d", `
             M ${-s * 0.8} ${s * 0.2}
             Q ${-s * 1.1} ${s * 0.2} ${-s * 1.1} ${-s * 0.1}
             Q ${-s * 1.1} ${-s * 0.5} ${-s * 0.7} ${-s * 0.5}
             Q ${-s * 0.7} ${-s * 0.9} ${-s * 0.2} ${-s * 0.9}
             Q ${s * 0.1} ${-s * 1.1} ${s * 0.5} ${-s * 0.8}
             Q ${s * 1} ${-s * 0.8} ${s * 1.1} ${-s * 0.3}
             Q ${s * 1.3} ${-s * 0.1} ${s * 1.1} ${s * 0.2}
             Q ${s * 1.1} ${s * 0.5} ${s * 0.7} ${s * 0.5}
             L ${-s * 0.5} ${s * 0.5}
             Q ${-s * 0.9} ${s * 0.5} ${-s * 0.9} ${s * 0.2}
             Z
            `, );
        return p;
       }
       if (shape === "database") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.7);
        body.setAttribute("y", -size * 0.6);
        body.setAttribute("width", size * 1.4);
        body.setAttribute("height", size * 1.4);
        g.appendChild(body);
        const top = document.createElementNS(ns, "ellipse");
        top.setAttribute("cx", 0);
        top.setAttribute("cy", -size * 0.6);
        top.setAttribute("rx", size * 0.7);
        top.setAttribute("ry", size * 0.25);
        g.appendChild(top);
        const bottom = document.createElementNS(ns, "ellipse");
        bottom.setAttribute("cx", 0);
        bottom.setAttribute("cy", size * 0.8);
        bottom.setAttribute("rx", size * 0.7);
        bottom.setAttribute("ry", size * 0.25);
        g.appendChild(bottom);
        const mid1 = document.createElementNS(ns, "ellipse");
        mid1.setAttribute("cx", 0);
        mid1.setAttribute("cy", -size * 0.15);
        mid1.setAttribute("rx", size * 0.7);
        mid1.setAttribute("ry", size * 0.2);
        mid1.style.fill = "none";
        mid1.style.stroke = "#475569";
        mid1.style.strokeWidth = "2";
        g.appendChild(mid1);
        const mid2 = document.createElementNS(ns, "ellipse");
        mid2.setAttribute("cx", 0);
        mid2.setAttribute("cy", size * 0.35);
        mid2.setAttribute("rx", size * 0.7);
        mid2.setAttribute("ry", size * 0.2);
        mid2.style.fill = "none";
        mid2.style.stroke = "#475569";
        mid2.style.strokeWidth = "2";
        g.appendChild(mid2);
        return g;
       }
       if (shape === "printer") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.4);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size * 0.9);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const trayTop = document.createElementNS(ns, "rect");
        trayTop.setAttribute("x", -size * 0.7);
        trayTop.setAttribute("y", -size * 0.8);
        trayTop.setAttribute("width", size * 1.4);
        trayTop.setAttribute("height", size * 0.4);
        trayTop.setAttribute("rx", 2);
        trayTop.style.fill = "#1e293b";
        g.appendChild(trayTop);
        const trayOut = document.createElementNS(ns, "rect");
        trayOut.setAttribute("x", -size * 0.6);
        trayOut.setAttribute("y", size * 0.5);
        trayOut.setAttribute("width", size * 1.2);
        trayOut.setAttribute("height", size * 0.35);
        trayOut.setAttribute("rx", 2);
        g.appendChild(trayOut);
        const paper = document.createElementNS(ns, "rect");
        paper.setAttribute("x", -size * 0.5);
        paper.setAttribute("y", size * 0.3);
        paper.setAttribute("width", size * 1);
        paper.setAttribute("height", size * 0.5);
        paper.style.fill = "#e2e8f0";
        g.appendChild(paper);
        return g;
       }
       if (shape === "access-point" || shape === "wifi") {
        const g = document.createElementNS(ns, "g");
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.3);
        base.setAttribute("y", size * 0.2);
        base.setAttribute("width", size * 0.6);
        base.setAttribute("height", size * 0.3);
        base.setAttribute("rx", 3);
        g.appendChild(base);
        for (let i = 1; i <= 3; i++) {
         const arc = document.createElementNS(ns, "path");
         const r = size * 0.3 * i;
         arc.setAttribute("d", `M ${-r * 0.7} ${size * 0.1 - r * 0.5} A ${r} ${r} 0 0 1 ${r * 0.7} ${size * 0.1 - r * 0.5}`);
         arc.style.fill = "none";
         arc.style.stroke = "currentColor";
         arc.style.strokeWidth = "2";
         arc.style.opacity = 1 - (i * 0.2);
         g.appendChild(arc);
        }
        return g;
       }
       if (shape === "load-balancer") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.5);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        const bar = document.createElementNS(ns, "line");
        bar.setAttribute("x1", -size * 0.6);
        bar.setAttribute("y1", 0);
        bar.setAttribute("x2", size * 0.6);
        bar.setAttribute("y2", 0);
        bar.style.stroke = "#4ade80";
        bar.style.strokeWidth = "3";
        g.appendChild(bar);
        [-1, 1].forEach(dir => {
         const arrow = document.createElementNS(ns, "path");
         arrow.setAttribute("d", `M ${dir * size * 0.3} ${-size * 0.2} L ${dir * size * 0.6} 0 L ${dir * size * 0.3} ${size * 0.2}`);
         arrow.style.fill = "none";
         arrow.style.stroke = "#4ade80";
         arrow.style.strokeWidth = "2";
         g.appendChild(arrow);
        });
        return g;
       }
       if (shape === "nas" || shape === "storage") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.8);
        body.setAttribute("y", -size * 0.9);
        body.setAttribute("width", size * 1.6);
        body.setAttribute("height", size * 1.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 4; i++) {
         const bay = document.createElementNS(ns, "rect");
         bay.setAttribute("x", -size * 0.6);
         bay.setAttribute("y", -size * 0.7 + i * size * 0.4);
         bay.setAttribute("width", size * 1.2);
         bay.setAttribute("height", size * 0.3);
         bay.setAttribute("rx", 2);
         bay.style.fill = "#1e293b";
         g.appendChild(bay);
        }
        return g;
       }
       if (shape === "gateway" || shape === "modem") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.5);
        body.setAttribute("y", -size * 0.9);
        body.setAttribute("width", size);
        body.setAttribute("height", size * 1.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 4; i++) {
         const led = document.createElementNS(ns, "circle");
         led.setAttribute("cx", 0);
         led.setAttribute("cy", -size * 0.6 + i * size * 0.35);
         led.setAttribute("r", size * 0.08);
         led.style.fill = ["#4ade80", "#4ade80", "#facc15", "#60a5fa"][i];
         g.appendChild(led);
        }
        return g;
       }
       if (shape === "vpn" || shape === "tunnel") {
        const g = document.createElementNS(ns, "g");
        const outer = document.createElementNS(ns, "ellipse");
        outer.setAttribute("cx", 0);
        outer.setAttribute("cy", 0);
        outer.setAttribute("rx", size);
        outer.setAttribute("ry", size * 0.6);
        g.appendChild(outer);
        const inner = document.createElementNS(ns, "ellipse");
        inner.setAttribute("cx", 0);
        inner.setAttribute("cy", 0);
        inner.setAttribute("rx", size * 0.5);
        inner.setAttribute("ry", size * 0.3);
        inner.style.fill = "#1e293b";
        g.appendChild(inner);
        const lock = document.createElementNS(ns, "rect");
        lock.setAttribute("x", -size * 0.15);
        lock.setAttribute("y", -size * 0.1);
        lock.setAttribute("width", size * 0.3);
        lock.setAttribute("height", size * 0.25);
        lock.setAttribute("rx", 2);
        lock.style.fill = "#4ade80";
        g.appendChild(lock);
        return g;
       }
       if (shape === "container") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.5);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 3; i++) {
         const block = document.createElementNS(ns, "rect");
         block.setAttribute("x", -size * 0.8 + i * size * 0.55);
         block.setAttribute("y", -size * 0.3);
         block.setAttribute("width", size * 0.45);
         block.setAttribute("height", size * 0.6);
         block.setAttribute("rx", 2);
         block.style.fill = "#1e293b";
         g.appendChild(block);
        }
        return g;
       }
       if (shape === "vm" || shape === "virtual") {
        const g = document.createElementNS(ns, "g");
        const shadow = document.createElementNS(ns, "rect");
        shadow.setAttribute("x", -size * 0.85 + 4);
        shadow.setAttribute("y", -size * 0.65 + 4);
        shadow.setAttribute("width", size * 1.7);
        shadow.setAttribute("height", size * 1.3);
        shadow.setAttribute("rx", 4);
        shadow.style.opacity = "0.3";
        g.appendChild(shadow);
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.85);
        body.setAttribute("y", -size * 0.65);
        body.setAttribute("width", size * 1.7);
        body.setAttribute("height", size * 1.3);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.65);
        screen.setAttribute("y", -size * 0.45);
        screen.setAttribute("width", size * 1.3);
        screen.setAttribute("height", size * 0.7);
        screen.setAttribute("rx", 2);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        return g;
       }
       if (shape === "kubernetes" || shape === "k8s") {
        const g = document.createElementNS(ns, "g");
        const outer = document.createElementNS(ns, "circle");
        outer.setAttribute("cx", 0);
        outer.setAttribute("cy", 0);
        outer.setAttribute("r", size);
        g.appendChild(outer);
        const inner = document.createElementNS(ns, "circle");
        inner.setAttribute("cx", 0);
        inner.setAttribute("cy", 0);
        inner.setAttribute("r", size * 0.4);
        inner.style.fill = "#1e293b";
        g.appendChild(inner);
        for (let i = 0; i < 7; i++) {
         const angle = (Math.PI * 2 / 7) * i - Math.PI / 2;
         const spoke = document.createElementNS(ns, "line");
         spoke.setAttribute("x1", Math.cos(angle) * size * 0.4);
         spoke.setAttribute("y1", Math.sin(angle) * size * 0.4);
         spoke.setAttribute("x2", Math.cos(angle) * size * 0.85);
         spoke.setAttribute("y2", Math.sin(angle) * size * 0.85);
         spoke.style.stroke = "#326ce5";
         spoke.style.strokeWidth = "3";
         g.appendChild(spoke);
        }
        return g;
       }
       if (shape === "shield" || shape === "security") {
        const p = document.createElementNS(ns, "path");
        const s = size;
        p.setAttribute("d", `M 0 ${-s} L ${s * 0.85} ${-s * 0.5} L ${s * 0.85} ${s * 0.2} Q ${s * 0.7} ${s * 0.9} 0 ${s} Q ${-s * 0.7} ${s * 0.9} ${-s * 0.85} ${s * 0.2} L ${-s * 0.85} ${-s * 0.5} Z`);
        return p;
       }
       if (shape === "camera" || shape === "cctv") {
        const g = document.createElementNS(ns, "g");
        const mount = document.createElementNS(ns, "rect");
        mount.setAttribute("x", -size * 1.1);
        mount.setAttribute("y", -size * 0.5);
        mount.setAttribute("width", size * 0.25);
        mount.setAttribute("height", size * 0.6);
        mount.setAttribute("rx", 2);
        g.appendChild(mount);
        const arm = document.createElementNS(ns, "rect");
        arm.setAttribute("x", -size * 0.9);
        arm.setAttribute("y", -size * 0.15);
        arm.setAttribute("width", size * 0.5);
        arm.setAttribute("height", size * 0.15);
        g.appendChild(arm);
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.45);
        body.setAttribute("y", -size * 0.35);
        body.setAttribute("width", size * 1.1);
        body.setAttribute("height", size * 0.7);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const lensHousing = document.createElementNS(ns, "circle");
        lensHousing.setAttribute("cx", size * 0.85);
        lensHousing.setAttribute("cy", 0);
        lensHousing.setAttribute("r", size * 0.4);
        g.appendChild(lensHousing);
        const lensOuter = document.createElementNS(ns, "circle");
        lensOuter.setAttribute("cx", size * 0.85);
        lensOuter.setAttribute("cy", 0);
        lensOuter.setAttribute("r", size * 0.28);
        lensOuter.style.fill = "#1e293b";
        g.appendChild(lensOuter);
        const lensInner = document.createElementNS(ns, "circle");
        lensInner.setAttribute("cx", size * 0.85);
        lensInner.setAttribute("cy", 0);
        lensInner.setAttribute("r", size * 0.15);
        lensInner.style.fill = "#3b82f6";
        g.appendChild(lensInner);
        const reflection = document.createElementNS(ns, "circle");
        reflection.setAttribute("cx", size * 0.8);
        reflection.setAttribute("cy", -size * 0.05);
        reflection.setAttribute("r", size * 0.05);
        reflection.style.fill = "#93c5fd";
        g.appendChild(reflection);
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", -size * 0.2);
        led.setAttribute("cy", -size * 0.15);
        led.setAttribute("r", size * 0.06);
        led.style.fill = "#ef4444";
        g.appendChild(led);
        return g;
       }
       if (shape === "monitor" || shape === "dashboard") {
        const g = document.createElementNS(ns, "g");
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size);
        screen.setAttribute("y", -size * 0.7);
        screen.setAttribute("width", size * 2);
        screen.setAttribute("height", size * 1.2);
        screen.setAttribute("rx", 4);
        g.appendChild(screen);
        const graph = document.createElementNS(ns, "polyline");
        graph.setAttribute("points", `${-size * 0.8},${size * 0.2} ${-size * 0.3},${-size * 0.2} ${size * 0.2},${size * 0.1} ${size * 0.7},${-size * 0.3}`);
        graph.style.fill = "none";
        graph.style.stroke = "#4ade80";
        graph.style.strokeWidth = "3";
        g.appendChild(graph);
        return g;
       }
       if (shape === "docker" || shape === "whale") {
        const g = document.createElementNS(ns, "g");
        const s = size;
        const body = document.createElementNS(ns, "path");
        body.setAttribute("d", `
         M ${-s * 0.9} ${s * 0.2}
         Q ${-s * 1.1} ${s * 0.5} ${-s * 0.7} ${s * 0.7}
         Q ${-s * 0.3} ${s * 0.85} ${s * 0.3} ${s * 0.75}
         Q ${s * 0.8} ${s * 0.6} ${s * 1.0} ${s * 0.3}
         Q ${s * 1.1} ${s * 0.1} ${s * 1.0} ${-s * 0.1}
         L ${s * 0.85} ${-s * 0.1}
         Q ${s * 0.7} ${-s * 0.15} ${s * 0.4} ${-s * 0.2}
         L ${-s * 0.5} ${-s * 0.2}
         Q ${-s * 0.8} ${-s * 0.1} ${-s * 0.9} ${s * 0.2}
         Z
        `);
        body.style.fill = "#0db7ed";
        g.appendChild(body);
        const tail = document.createElementNS(ns, "path");
        tail.setAttribute("d", `
         M ${-s * 0.85} ${s * 0.1}
         Q ${-s * 1.2} ${-s * 0.2} ${-s * 1.0} ${-s * 0.55}
         Q ${-s * 0.95} ${-s * 0.35} ${-s * 0.8} ${-s * 0.15}
         Z
        `);
        tail.style.fill = "#0db7ed";
        g.appendChild(tail);
        const belly = document.createElementNS(ns, "path");
        belly.setAttribute("d", `
         M ${-s * 0.5} ${s * 0.65}
         Q ${s * 0.1} ${s * 0.75} ${s * 0.6} ${s * 0.55}
         Q ${s * 0.8} ${s * 0.45} ${s * 0.9} ${s * 0.25}
         Q ${s * 0.7} ${s * 0.5} ${s * 0.3} ${s * 0.6}
         Q ${-s * 0.1} ${s * 0.7} ${-s * 0.5} ${s * 0.65}
         Z
        `);
        belly.style.fill = "#ffffff";
        belly.style.opacity = "0.3";
        g.appendChild(belly);
        for (let row = 0; row < 2; row++) {
         for (let col = 0; col < 3; col++) {
          const container = document.createElementNS(ns, "rect");
          container.setAttribute("x", -s * 0.45 + col * s * 0.35);
          container.setAttribute("y", -s * 0.7 + row * s * 0.28);
          container.setAttribute("width", s * 0.3);
          container.setAttribute("height", s * 0.23);
          container.setAttribute("rx", 2);
          container.style.fill = "#0db7ed";
          container.style.stroke = "#0a9ed8";
          container.style.strokeWidth = "1.5";
          g.appendChild(container);
         }
        }
        const topContainer = document.createElementNS(ns, "rect");
        topContainer.setAttribute("x", -s * 0.1);
        topContainer.setAttribute("y", -s * 0.95);
        topContainer.setAttribute("width", s * 0.3);
        topContainer.setAttribute("height", s * 0.23);
        topContainer.setAttribute("rx", 2);
        topContainer.style.fill = "#0db7ed";
        topContainer.style.stroke = "#0a9ed8";
        topContainer.style.strokeWidth = "1.5";
        g.appendChild(topContainer);
        const eye = document.createElementNS(ns, "circle");
        eye.setAttribute("cx", s * 0.65);
        eye.setAttribute("cy", s * 0.25);
        eye.setAttribute("r", s * 0.08);
        eye.style.fill = "#0a5f7a";
        g.appendChild(eye);
        return g;
       }
       if (shape === "rounded-square") {
        const r = document.createElementNS(ns, "rect");
        const s = size * 1.6;
        r.setAttribute("x", -s / 2);
        r.setAttribute("y", -s / 2);
        r.setAttribute("width", s);
        r.setAttribute("height", s);
        r.setAttribute("rx", size * 0.4);
        return r;
       }
       if (shape === "pill" || shape === "capsule") {
        const r = document.createElementNS(ns, "rect");
        r.setAttribute("x", -size * 1.2);
        r.setAttribute("y", -size * 0.5);
        r.setAttribute("width", size * 2.4);
        r.setAttribute("height", size);
        r.setAttribute("rx", size * 0.5);
        return r;
       }
       if (shape === "octagon") {
        const p = document.createElementNS(ns, "polygon");
        const r = size;
        const pts = [];
        for (let i = 0; i < 8; i++) {
         const a = (Math.PI / 4) * i - Math.PI / 8;
         pts.push([Math.cos(a) * r, Math.sin(a) * r]);
        }
        p.setAttribute("points", pts.map(pt => pt.join(",")).join(" "));
        return p;
       }
       if (shape === "pentagon") {
        const p = document.createElementNS(ns, "polygon");
        const pts = [];
        for (let i = 0; i < 5; i++) {
         const a = (Math.PI * 2 / 5) * i - Math.PI / 2;
         pts.push([Math.cos(a) * size, Math.sin(a) * size]);
        }
        p.setAttribute("points", pts.map(pt => pt.join(",")).join(" "));
        return p;
       }
       if (shape === "cross" || shape === "plus") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        const t = size * 0.35;
        p.setAttribute("points", `${-t},${-s} ${t},${-s} ${t},${-t} ${s},${-t} ${s},${t} ${t},${t} ${t},${s} ${-t},${s} ${-t},${t} ${-s},${t} ${-s},${-t} ${-t},${-t}`);
        return p;
       }
       if (shape === "parallelogram") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `${-s * 0.6},${-s * 0.6} ${s * 1.2},${-s * 0.6} ${s * 0.6},${s * 0.6} ${-s * 1.2},${s * 0.6}`);
        return p;
       }
       if (shape === "trapezoid") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `${-s * 0.6},${-s * 0.6} ${s * 0.6},${-s * 0.6} ${s},${s * 0.6} ${-s},${s * 0.6}`);
        return p;
       }
       if (shape === "sensor" || shape === "iot") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "circle");
        body.setAttribute("cx", 0);
        body.setAttribute("cy", 0);
        body.setAttribute("r", size * 0.7);
        g.appendChild(body);
        const ant = document.createElementNS(ns, "line");
        ant.setAttribute("x1", 0);
        ant.setAttribute("y1", -size * 0.7);
        ant.setAttribute("x2", 0);
        ant.setAttribute("y2", -size);
        ant.style.stroke = "currentColor";
        ant.style.strokeWidth = "2";
        g.appendChild(ant);
        const tip = document.createElementNS(ns, "circle");
        tip.setAttribute("cx", 0);
        tip.setAttribute("cy", -size);
        tip.setAttribute("r", size * 0.1);
        tip.style.fill = "#4ade80";
        g.appendChild(tip);
        return g;
       }
       if (shape === "pi" || shape === "sbc" || shape === "raspberry") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.65);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size * 1.3);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 10; i++) {
         const pin = document.createElementNS(ns, "rect");
         pin.setAttribute("x", -size * 0.85 + i * size * 0.19);
         pin.setAttribute("y", -size * 0.8);
         pin.setAttribute("width", size * 0.08);
         pin.setAttribute("height", size * 0.15);
         pin.style.fill = "#facc15";
         g.appendChild(pin);
        }
        const port = document.createElementNS(ns, "rect");
        port.setAttribute("x", size * 0.6);
        port.setAttribute("y", -size * 0.2);
        port.setAttribute("width", size * 0.35);
        port.setAttribute("height", size * 0.4);
        port.style.fill = "#1e293b";
        g.appendChild(port);
        return g;
       }
       if (shape === "api" || shape === "endpoint") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.9);
        body.setAttribute("y", -size * 0.7);
        body.setAttribute("width", size * 1.8);
        body.setAttribute("height", size * 1.4);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        const left = document.createElementNS(ns, "text");
        left.setAttribute("x", -size * 0.5);
        left.setAttribute("y", size * 0.15);
        left.setAttribute("font-size", size * 0.9);
        left.setAttribute("fill", "#4ade80");
        left.setAttribute("font-family", "monospace");
        left.textContent = "{";
        g.appendChild(left);
        const right = document.createElementNS(ns, "text");
        right.setAttribute("x", size * 0.15);
        right.setAttribute("y", size * 0.15);
        right.setAttribute("font-size", size * 0.9);
        right.setAttribute("fill", "#4ade80");
        right.setAttribute("font-family", "monospace");
        right.textContent = "}";
        g.appendChild(right);
        return g;
       }
       if (shape === "queue" || shape === "message") {
        const g = document.createElementNS(ns, "g");
        for (let i = 2; i >= 0; i--) {
         const card = document.createElementNS(ns, "rect");
         card.setAttribute("x", -size * 0.7 + i * 4);
         card.setAttribute("y", -size * 0.5 + i * 4);
         card.setAttribute("width", size * 1.4);
         card.setAttribute("height", size * 0.8);
         card.setAttribute("rx", 3);
         card.style.opacity = 1 - i * 0.25;
         g.appendChild(card);
        }
        return g;
       }
       if (shape === "lambda" || shape === "function") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.8);
        body.setAttribute("y", -size * 0.8);
        body.setAttribute("width", size * 1.6);
        body.setAttribute("height", size * 1.6);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const lambda = document.createElementNS(ns, "text");
        lambda.setAttribute("x", 0);
        lambda.setAttribute("y", size * 0.2);
        lambda.setAttribute("font-size", size * 1.2);
        lambda.setAttribute("fill", "#f59e0b");
        lambda.setAttribute("text-anchor", "middle");
        lambda.setAttribute("font-family", "serif");
        lambda.textContent = "Œª";
        g.appendChild(lambda);
        return g;
       }
       if (shape === "bucket" || shape === "s3") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "path");
        body.setAttribute("d", `M ${-size * 0.8} ${-size * 0.7} L ${-size * 0.6} ${size * 0.8} Q ${-size * 0.5} ${size} 0 ${size} Q ${size * 0.5} ${size} ${size * 0.6} ${size * 0.8} L ${size * 0.8} ${-size * 0.7} Z`);
        g.appendChild(body);
        const rim = document.createElementNS(ns, "ellipse");
        rim.setAttribute("cx", 0);
        rim.setAttribute("cy", -size * 0.7);
        rim.setAttribute("rx", size * 0.8);
        rim.setAttribute("ry", size * 0.25);
        g.appendChild(rim);
        return g;
       }
       const c = document.createElementNS(ns, "circle");
       c.setAttribute("r", size);
       return c;
      }
      function createNodeShape(id, size) {
       const styles = resolveStylesForNode(id);
       if (styles.icon && styles.icon.library && styles.icon.name) {
        const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
        g.classList.add("node-circle");
        IconLibrary.getIcon(styles.icon.library, styles.icon.name).then(svgText => {
         if (svgText) {
          const parser = new DOMParser();
          const doc = parser.parseFromString(svgText, 'image/svg+xml');
          const svgEl = doc.querySelector('svg');
          if (svgEl) {
           svgEl.setAttribute('width', size * 1.2);
           svgEl.setAttribute('height', size * 1.2);
           svgEl.setAttribute('x', -size * 0.6);
           svgEl.setAttribute('y', -size * 0.6);
           if (styles.circleColor) {
            svgEl.style.fill = styles.circleColor;
            svgEl.querySelectorAll('path, circle, rect, polygon, ellipse').forEach(el => {
             el.style.fill = styles.circleColor;
            });
           }
           if (styles.circleBorder) {
            svgEl.style.stroke = styles.circleBorder;
            svgEl.querySelectorAll('path, circle, rect, polygon, ellipse').forEach(el => {
             el.style.stroke = styles.circleBorder;
            });
           }
           g.innerHTML = svgEl.outerHTML;
          }
         }
        });
        return g;
       }
       const shapeType = (NODE_DATA[id] && NODE_DATA[id].shape) || "circle";
       const shapeEl = createShapeElement(shapeType, size);
       shapeEl.classList.add("node-circle");
       shapeEl.style.fill = styles.circleColor || PAGE_STATE.nodeFill || "#1e293b";
       shapeEl.style.stroke = styles.circleBorder || PAGE_STATE.nodeStroke || "#475569";
       return shapeEl;
      }
      function forgeTheLegend() {
       const container = document.getElementById("edge-legend");
       if (!container) return;
       container.innerHTML = "";
       const title = document.createElement("div");
       title.className = "legend-title";
       title.textContent = "Line Legend";
       container.appendChild(title);
       const closeBtn = document.createElement("button");
       closeBtn.type = "button";
       closeBtn.className = "legend-close-btn";
       closeBtn.textContent = "‚úï";
       closeBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        legendCollapsed = true;
        updateLegendVisibility();
       });
       container.appendChild(closeBtn);
       const colors = [...new Set(EDGE_DATA.list.map((e) => e.color).filter(Boolean))];
       if (colors.length === 0) {
        updateLegendVisibility();
        return;
       }
       colors.forEach((color) => {
         if (!EDGE_LEGEND[color]) {
          EDGE_LEGEND[color] = "you can edit me too";
         }
         const item = document.createElement("div");
         item.className = "legend-item";
         item.addEventListener("mousedown", (e) => e.stopPropagation());
         item.addEventListener("click", (e) => e.stopPropagation());
         const swatch = document.createElement("span");
         swatch.className = "legend-swatch";
         swatch.style.backgroundColor = color;
         swatch.style.cursor = "pointer";
         swatch.addEventListener("click", (e) => {
          e.stopPropagation();
          const edgeWithColor = EDGE_DATA.list.find(edge => edge.color === color);
          if (edgeWithColor) {
           selectTheConnection(edgeWithColor.id);
          }
         });
         let swatchTouchStart = null;
         let swatchTouchMoved = false;
         swatch.addEventListener("touchstart", (e) => {
         swatchTouchStart = Date.now();
         swatchTouchMoved = false;
         if (e.touches[0]) {
          swatchTouchStartX = e.touches[0].clientX;
          swatchTouchStartY = e.touches[0].clientY;
         }
        }, {
          passive: false
         });
         let swatchTouchStartX = 0, swatchTouchStartY = 0;
        swatch.addEventListener("touchmove", (e) => {
         if (e.touches[0]) {
          const dx = Math.abs(e.touches[0].clientX - swatchTouchStartX);
          const dy = Math.abs(e.touches[0].clientY - swatchTouchStartY);
          if (dx > 10 || dy > 10) swatchTouchMoved = true;
         }
        }, {
          passive: false
         });
         swatch.addEventListener("touchend", (e) => {
          if (swatchTouchStart && !swatchTouchMoved && Date.now() - swatchTouchStart < 400) {
           e.stopPropagation();
           e.preventDefault();
           const edgeWithColor = EDGE_DATA.list.find(edge => edge.color === color);
           if (edgeWithColor) {
            selectTheConnection(edgeWithColor.id);
           }
          }
          swatchTouchStart = null;
          swatchTouchMoved = false;
         }, {
          passive: false
         });
        const label = document.createElement("span");
        label.className = "legend-label";
        label.textContent = EDGE_LEGEND[color];
        if (isMobileDevice()) {
         label.style.cursor = "pointer";
         let labelTapStart = null;
         let labelTapMoved = false;
         label.addEventListener("touchstart", (e) => {
          labelTapStart = Date.now();
          labelTapMoved = false;
          if (e.touches[0]) {
           labelTapStartX = e.touches[0].clientX;
           labelTapStartY = e.touches[0].clientY;
          }
          e.stopPropagation();
         });
         let labelTapStartX = 0, labelTapStartY = 0;
         label.addEventListener("touchmove", (e) => {
          if (e.touches[0]) {
           const dx = Math.abs(e.touches[0].clientX - labelTapStartX);
           const dy = Math.abs(e.touches[0].clientY - labelTapStartY);
           if (dx > 10 || dy > 10) labelTapMoved = true;
          }
         });
         label.addEventListener("touchend", (e) => {
          if (labelTapStart && !labelTapMoved && Date.now() - labelTapStart < 400) {
           e.preventDefault();
           e.stopPropagation();
           const currentText = label.textContent;
           const newText = prompt("Edit legend label:", currentText);
           if (newText !== null && newText.trim()) {
            label.textContent = newText.trim();
            EDGE_LEGEND[color] = newText.trim();
           }
          }
          labelTapStart = null;
          labelTapMoved = false;
         });
        } else {
           label.contentEditable = true;
           label.addEventListener("focus", () => {
            label.classList.add("editing");
           });
           label.addEventListener("blur", () => {
            label.classList.remove("editing");
            const text = label.textContent.trim() || "you can edit me too";
            EDGE_LEGEND[color] = text;
           });
           label.addEventListener("keydown", (e) => {
            if (e.key === "Enter") {
             e.preventDefault();
             label.blur();
            }
           });
          }
          item.append(swatch, label); container.appendChild(item);
         }); updateLegendVisibility();
       }
       function deleteRectangle(rectId) {
      pushUndo("delete zone");
        RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== rectId);
        forgeTheTopology();
       }
       function updateRectangleDeleteButtons() {
        const deleteButtons = document.querySelectorAll('.rect-delete-btn');
        deleteButtons.forEach(btn => {
         btn.style.display = rectDrawMode ? 'block' : 'none';
        });
       }
       function forgeTheTopology() {
        if (!NODE_DATA || !EDGE_DATA) {
         console.warn("forgeTheTopology called before data initialized");
         return;
        }
        const svg = document.getElementById("map");
        svg.innerHTML = "";
        const ns = "http://www.w3.org/2000/svg";
        const defs = document.createElementNS(ns, "defs");
        const markerForward = document.createElementNS(ns, "marker");
        markerForward.id = "arrow-forward";
        markerForward.setAttribute("markerWidth", "10");
        markerForward.setAttribute("markerHeight", "10");
        markerForward.setAttribute("refX", "9");
        markerForward.setAttribute("refY", "3");
        markerForward.setAttribute("orient", "auto");
        markerForward.setAttribute("markerUnits", "strokeWidth");
        const pathForward = document.createElementNS(ns, "path");
        pathForward.setAttribute("d", "M0,0 L0,6 L9,3 z");
        pathForward.setAttribute("fill", "context-stroke");
        markerForward.appendChild(pathForward);
        defs.appendChild(markerForward);
        const markerBackward = document.createElementNS(ns, "marker");
        markerBackward.id = "arrow-backward";
        markerBackward.setAttribute("markerWidth", "10");
        markerBackward.setAttribute("markerHeight", "10");
        markerBackward.setAttribute("refX", "0");
        markerBackward.setAttribute("refY", "3");
        markerBackward.setAttribute("orient", "auto");
        markerBackward.setAttribute("markerUnits", "strokeWidth");
        const pathBackward = document.createElementNS(ns, "path");
        pathBackward.setAttribute("d", "M9,0 L9,6 L0,3 z");
        pathBackward.setAttribute("fill", "context-stroke");
        markerBackward.appendChild(pathBackward);
        defs.appendChild(markerBackward);
        svg.appendChild(defs);
        const boundary = document.createElementNS(ns, "rect");
        boundary.setAttribute("x", CANVAS_PADDING);
        boundary.setAttribute("y", CANVAS_PADDING);
        boundary.setAttribute("width", CANVAS_WIDTH - CANVAS_PADDING * 2);
        boundary.setAttribute("height", CANVAS_HEIGHT - CANVAS_PADDING * 2);
        boundary.setAttribute("fill", "none");
        boundary.setAttribute("stroke", (PAGE_STATE.canvasBorder || "#475569") + "4D");
        boundary.setAttribute("stroke-width", "20");
        boundary.setAttribute("stroke-dasharray", "10 5");
        boundary.setAttribute("rx", "8");
        svg.appendChild(boundary);
       if (currentView.mode !== "rack") {
        const gridGroup = document.createElementNS(ns, "g");
        gridGroup.id = "canvas-grid";
        const gridSize = PAGE_STATE.canvasGridSize || 50;
        const gridColor = (PAGE_STATE.canvasGrid || "#475569") + "33";
        const majorGridColor = (PAGE_STATE.canvasGrid || "#475569") + "66";
        for (let x = CANVAS_PADDING; x <= CANVAS_WIDTH - CANVAS_PADDING; x += gridSize) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", x);
         line.setAttribute("y1", CANVAS_PADDING);
         line.setAttribute("x2", x);
         line.setAttribute("y2", CANVAS_HEIGHT - CANVAS_PADDING);
         line.setAttribute("stroke", (x - CANVAS_PADDING) % (gridSize * 5) === 0 ? majorGridColor : gridColor);
         line.setAttribute("stroke-width", (x - CANVAS_PADDING) % (gridSize * 5) === 0 ? "2" : "1");
         gridGroup.appendChild(line);
        }
        for (let y = CANVAS_PADDING; y <= CANVAS_HEIGHT - CANVAS_PADDING; y += gridSize) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", CANVAS_PADDING);
         line.setAttribute("y1", y);
         line.setAttribute("x2", CANVAS_WIDTH - CANVAS_PADDING);
         line.setAttribute("y2", y);
         line.setAttribute("stroke", (y - CANVAS_PADDING) % (gridSize * 5) === 0 ? majorGridColor : gridColor);
         line.setAttribute("stroke-width", (y - CANVAS_PADDING) % (gridSize * 5) === 0 ? "2" : "1");
         gridGroup.appendChild(line);
        }
        svg.appendChild(gridGroup);
       }
       if (currentView.mode === "rack" && currentView.rackId) {
         const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
         const rackGroup = document.createElementNS(ns, "g");
         rackGroup.id = "rack-visualization";
         const rackFrame = document.createElementNS(ns, "rect");
         rackFrame.setAttribute("x", RACK_START_X - RACK_WIDTH / 2);
         rackFrame.setAttribute("y", RACK_START_Y);
         rackFrame.setAttribute("width", RACK_WIDTH);
         rackFrame.setAttribute("height", rackCapacity * rackUHeight);
         rackFrame.setAttribute("fill", (PAGE_STATE.rackFrameFill || "#0f172a") + "4D");
         rackFrame.setAttribute("stroke", PAGE_STATE.rackFrameStroke || "#4fd1c5");
         rackFrame.setAttribute("stroke-width", "3");
         rackFrame.setAttribute("rx", "4");
         rackGroup.appendChild(rackFrame);
         for (let u = 0; u <= rackCapacity; u++) {
          const y = RACK_START_Y + u * rackUHeight;
          const line = document.createElementNS(ns, "line");
          line.setAttribute("x1", RACK_START_X - RACK_WIDTH / 2);
          line.setAttribute("y1", y);
          line.setAttribute("x2", RACK_START_X + RACK_WIDTH / 2);
          line.setAttribute("y2", y);
          line.setAttribute("stroke", (PAGE_STATE.rackLineColor || "#475569") + "66");
          line.setAttribute("stroke-width", u % 5 === 0 ? "2" : "1");
          line.setAttribute("stroke-dasharray", u % 5 === 0 ? "none" : "5,5");
          rackGroup.appendChild(line);
          if (u < rackCapacity) {
           const uNumber = rackCapacity - u;
           const text = document.createElementNS(ns, "text");
           text.setAttribute("x", RACK_START_X - RACK_WIDTH / 2 - 30);
           text.setAttribute("y", y + rackUHeight / 2);
           text.setAttribute("text-anchor", "middle");
           text.setAttribute("dominant-baseline", "middle");
           text.style.fill = PAGE_STATE.rackTextColor || "#4fd1c5";
           text.style.fontSize = "14px";
           text.style.fontWeight = "bold";
           text.textContent = `U${uNumber}`;
           rackGroup.appendChild(text);
           const textRight = document.createElementNS(ns, "text");
           textRight.setAttribute("x", RACK_START_X + RACK_WIDTH / 2 + 30);
           textRight.setAttribute("y", y + rackUHeight / 2);
           textRight.setAttribute("text-anchor", "middle");
           textRight.setAttribute("dominant-baseline", "middle");
           textRight.style.fill = PAGE_STATE.rackTextColor || "#4fd1c5";
           textRight.style.fontSize = "14px";
           textRight.style.fontWeight = "bold";
           textRight.textContent = `U${uNumber}`;
           rackGroup.appendChild(textRight);
          }
         }
         svg.appendChild(rackGroup);
        }
        const centerX = CANVAS_WIDTH / 2;
        if (RECT_DATA && RECT_DATA.list) {
         RECT_DATA.list.forEach((rect) => {
          if (currentView.mode === "rack") return;
          if (rect.style === "filled") {
           const g = document.createElementNS(ns, "g");
           g.classList.add("rect-group");
           g.dataset.rectId = rect.id;
           const rectEl = document.createElementNS(ns, "rect");
           rectEl.classList.add("rect-shape");
           rectEl.setAttribute("x", rect.x);
           rectEl.setAttribute("y", rect.y);
           rectEl.setAttribute("width", rect.width);
           rectEl.setAttribute("height", rect.height);
           rectEl.style.fill = rect.color;
           rectEl.style.fillOpacity = "0.3";
           rectEl.style.stroke = rect.borderColor || rect.color;
           rectEl.style.strokeWidth = (rect.borderWidth !== undefined ? rect.borderWidth : 2) + "px";
           if (rect.lineStyle === "dashed") { rectEl.style.strokeDasharray = "10,5"; }
           else if (rect.lineStyle === "dotted") { rectEl.style.strokeDasharray = "2,4"; }
           else { rectEl.style.strokeDasharray = "none"; }
           rectEl.style.cursor = "move";
           rectEl.addEventListener("click", (e) => {
		   if (isViewOnly()) return;
             if (rectDrawMode) return;
             e.stopPropagation();
             currentRectId = rect.id;
             selectTheRect(rect.id);
           });
           rectEl.addEventListener("contextmenu", (e) => {
		    if (isViewOnly()) return;
             e.preventDefault();
             e.stopPropagation();
             if (selectedRects.has(rect.id)) {
               selectedRects.delete(rect.id);
             } else {
               selectedRects.add(rect.id);
             }
             updateAllSelections();
           });
           let rectLastTap = 0;
           rectEl.addEventListener("touchend", (e) => {
             const now = Date.now();
             if (now - rectLastTap < 300) {
               e.preventDefault();
               if (selectedRects.has(rect.id)) {
                 selectedRects.delete(rect.id);
               } else {
                 selectedRects.add(rect.id);
               }
               updateAllSelections();
               if (navigator.vibrate) navigator.vibrate(50);
               rectLastTap = 0;
             } else {
               rectLastTap = now;
             }
           }, { passive: false });
           const deleteBtn = document.createElementNS(ns, "g");
           deleteBtn.classList.add("rect-delete-btn");
           deleteBtn.style.cursor = "pointer";
           deleteBtn.style.display = rectDrawMode ? "block" : "none";
           const deleteBg = document.createElementNS(ns, "circle");
           deleteBg.setAttribute("cx", rect.x + rect.width - 10);
           deleteBg.setAttribute("cy", rect.y + 10);
           deleteBg.setAttribute("r", 12);
           deleteBg.style.fill = "#f56565";
           deleteBg.style.stroke = "white";
           deleteBg.style.strokeWidth = "2";
           const deleteX = document.createElementNS(ns, "text");
           deleteX.setAttribute("x", rect.x + rect.width - 10);
           deleteX.setAttribute("y", rect.y + 10);
           deleteX.setAttribute("text-anchor", "middle");
           deleteX.setAttribute("dominant-baseline", "middle");
           deleteX.style.fill = "white";
           deleteX.style.fontSize = "16px";
           deleteX.style.fontWeight = "bold";
           deleteX.style.pointerEvents = "none";
           deleteX.textContent = "√ó";
           deleteBtn.appendChild(deleteBg);
           deleteBtn.appendChild(deleteX);
           deleteBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            e.preventDefault();
            deleteRectangle(rect.id);
           });
           deleteBtn.addEventListener("touchend", (e) => {
      e.stopPropagation();
           e.preventDefault();
           deleteRectangle(rect.id);
           });
           let isDragging = false;
           let dragStartX, dragStartY;
           let rectStartX, rectStartY;
           rectEl.addEventListener("mousedown", (e) => {
      if (rectDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      rectStartX = rect.x;
      rectStartY = rect.y;
      rectEl.style.cursor = "grabbing";
      if (selectedRects.has(rect.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
      const moveHandler = (e) => {
      if (!isDragging || rectDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      rect.x = rectStartX + dx;
      rect.y = rectStartY + dy;
      if (selectedRects.has(rect.id)) {
      selectedNodes.forEach(nodeId => { if (initialPositions[nodeId]) { savedPositions[nodeId] = { x: initialPositions[nodeId].x + dx, y: initialPositions[nodeId].y + dy }; } });
      selectedRects.forEach(rectId => { if (rectId === rect.id) return; const r = RECT_DATA.list.find(x => x.id === rectId); if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; } });
      selectedTexts.forEach(textId => { const t = TEXT_DATA.list.find(x => x.id === textId); if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; } });
      selectedEdges.forEach(edgeId => { const ed = EDGE_DATA.list.find(x => x.id === edgeId); if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); } });
      }
      forgeTheTopology();
      };
           const upHandler = () => {
            if (isDragging) {
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           };
           document.addEventListener("mousemove", moveHandler);
           document.addEventListener("mouseup", upHandler);
           let touchStartX, touchStartY;
           let touchRectStartX, touchRectStartY;
           rectEl.addEventListener("touchstart", (e) => {
		   if (isViewOnly()) return;
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchRectStartX = rect.x;
            touchRectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           }, { passive: false });
           rectEl.addEventListener("touchmove", (e) => {
		   if (isViewOnly()) return;
            if (!isDragging || rectDrawMode) return;
            if (!e.touches[0]) return;
            e.preventDefault();
            e.stopPropagation();
            const svgEl = svg;
            const pt1 = svgEl.createSVGPoint();
            pt1.x = touchStartX;
            pt1.y = touchStartY;
            const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
            const touch = e.touches[0];
            const pt2 = svgEl.createSVGPoint();
            pt2.x = touch.clientX;
            pt2.y = touch.clientY;
            const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
            const dx = svgP2.x - svgP1.x;
            const dy = svgP2.y - svgP1.y;
            rect.x = touchRectStartX + dx;
            rect.y = touchRectStartY + dy;
            forgeTheTopology();
           }, { passive: false });
           rectEl.addEventListener("touchend", (e) => {
            if (isDragging) {
             e.preventDefault();
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           }, { passive: false });
            if (currentRectId === rect.id) {
      const corners = [
      { cx: rect.x, cy: rect.y, cursor: 'nwse-resize', dx: -1, dy: -1 },
      { cx: rect.x + rect.width, cy: rect.y, cursor: 'nesw-resize', dx: 1, dy: -1 },
      { cx: rect.x, cy: rect.y + rect.height, cursor: 'nesw-resize', dx: -1, dy: 1 },
      { cx: rect.x + rect.width, cy: rect.y + rect.height, cursor: 'nwse-resize', dx: 1, dy: 1 }
      ];
      corners.forEach((corner, idx) => {
      const handle = document.createElementNS(ns, "circle");
      handle.setAttribute("cx", corner.cx);
      handle.setAttribute("cy", corner.cy);
      handle.setAttribute("r", 8);
      handle.style.fill = "#f59e0b";
      handle.style.stroke = "#fff";
      handle.style.strokeWidth = "2";
      handle.style.cursor = corner.cursor;
      handle.addEventListener("mousedown", (e) => {
      e.preventDefault();
      e.stopPropagation();
	  pushUndo("resize zone");
      let dragging = true;
      const startX = e.clientX, startY = e.clientY;
      const origX = rect.x, origY = rect.y, origW = rect.width, origH = rect.height;
      const moveHandler = (ev) => {
        if (!dragging) return;
        const pt1 = svg.createSVGPoint(); pt1.x = startX; pt1.y = startY;
        const pt2 = svg.createSVGPoint(); pt2.x = ev.clientX; pt2.y = ev.clientY;
        const svgP1 = pt1.matrixTransform(svg.getScreenCTM().inverse());
        const svgP2 = pt2.matrixTransform(svg.getScreenCTM().inverse());
        const dx = svgP2.x - svgP1.x, dy = svgP2.y - svgP1.y;
        if (corner.dx < 0) { rect.x = origX + dx; rect.width = origW - dx; }
        else { rect.width = origW + dx; }
        if (corner.dy < 0) { rect.y = origY + dy; rect.height = origH - dy; }
        else { rect.height = origH + dy; }
        if (rect.width < 20) rect.width = 20;
        if (rect.height < 20) rect.height = 20;
        forgeTheTopology();
      };
      const upHandler = () => { dragging = false; document.removeEventListener("mousemove", moveHandler); document.removeEventListener("mouseup", upHandler); };
      document.addEventListener("mousemove", moveHandler);
      document.addEventListener("mouseup", upHandler);
      });
      g.appendChild(handle);
      });
      }
            if (rect.groupId) {
             const groupIndicator = document.createElementNS(ns, "rect");
             groupIndicator.setAttribute("x", rect.x - 4);
             groupIndicator.setAttribute("y", rect.y - 4);
             groupIndicator.setAttribute("width", rect.width + 8);
             groupIndicator.setAttribute("height", rect.height + 8);
             groupIndicator.style.fill = "none";
        groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
             groupIndicator.style.strokeWidth = "3";
             groupIndicator.style.strokeDasharray = "5,5";
             groupIndicator.style.pointerEvents = "none";
             g.insertBefore(groupIndicator, g.firstChild);
           }
           g.appendChild(rectEl);
           g.appendChild(deleteBtn);
           svg.appendChild(g);
          }
         });
        }
        const centerY = CANVAS_HEIGHT / 2;
        let positions = {};
        Object.keys(NODE_DATA).forEach((id) => {
         if (currentView.mode === "rack") {
          const node = NODE_DATA[id];
          if (!node || node.assignedRack !== currentView.rackId) {
           return;
          }
         }
         positions[id] = savedPositions[id] || {
          x: centerX,
          y: centerY
         };
        });
        if (Object.keys(savedPositions).length === 0) {
         const nodeIds = Object.keys(NODE_DATA).filter(id => {
          if (currentView.mode === "rack") {
           const node = NODE_DATA[id];
           return node && node.assignedRack === currentView.rackId;
          }
          return true;
         });
         const baseY = centerY - 300;
         if (nodeIds.length > 0) {
          positions[nodeIds[0]] = {
           x: centerX,
           y: baseY
          };
          const remaining = nodeIds.slice(1);
          const radius = 350;
          const startAngle = Math.PI * 0.3;
          const endAngle = Math.PI * 0.7;
          remaining.forEach((id, i) => {
           const angle = startAngle + (endAngle - startAngle) * (i / Math.max(1, remaining.length - 1));
           positions[id] = {
            x: centerX + Math.cos(angle) * radius * (i % 2 === 0 ? 1 : 1.3),
            y: baseY + 200 + Math.sin(angle) * radius * 0.8 + i * 80,
           };
          });
         }
        }
        Object.keys(positions).forEach((id) => {
         let pos = savedPositions[id] || positions[id];
         const nodeSize = savedSizes[id] || 55;
         pos.x = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, pos.x), );
         pos.y = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, pos.y), );
         positions[id] = {
          x: pos.x,
          y: pos.y
         };
         savedPositions[id] = {
          x: pos.x,
          y: pos.y
         };
        });
        const edgePairCount = {};
        const edgePairIndex = {};
        EDGE_DATA.list.forEach((edge) => {
         if (edge.type === "custom") return;
         const key = [edge.from, edge.to].sort().join("||");
         edgePairCount[key] = (edgePairCount[key] || 0) + 1;
        });
        EDGE_DATA.list.forEach((edge) => {
         if (edge.type === "custom") return;
         const key = [edge.from, edge.to].sort().join("||");
         if (!edgePairIndex[key]) edgePairIndex[key] = 0;
         edge._pairIndex = edgePairIndex[key];
         edge._pairTotal = edgePairCount[key];
         edgePairIndex[key]++;
        });
        EDGE_DATA.list.forEach((edge) => {
         if (edge.type === "custom" && Array.isArray(edge.points) && edge.points.length >= 2) {
          const customEdgeFaded = currentView.mode !== "rack" && edge.from && edge.to && (!isNodeVisible(edge.from) || !isNodeVisible(edge.to));
          const poly = document.createElementNS(ns, "polyline");
          poly.classList.add("edge");
          if (customEdgeFaded) {
           poly.style.opacity = "0.25";
           poly.classList.add("layer-faded");
          }
          poly.dataset.edgeId = edge.id;
poly.style.stroke = edge.color || PAGE_STATE.defaultEdge || "#475569";
          poly.style.strokeWidth = edge.width || 4;
          poly.setAttribute("fill", "none");
          const lineStyle = edge.lineStyle || "solid";
          if (lineStyle === "dashed") {
           poly.style.strokeDasharray = "10,5";
          } else if (lineStyle === "dotted") {
           poly.style.strokeDasharray = "2,4";
          } else {
           poly.style.strokeDasharray = "none";
          }
          const direction = edge.direction || "none";
          if (direction === "forward") {
           poly.setAttribute("marker-end", "url(#arrow-forward)");
          } else if (direction === "backward") {
           poly.setAttribute("marker-start", "url(#arrow-backward)");
          } else if (direction === "both") {
           poly.setAttribute("marker-start", "url(#arrow-backward)");
           poly.setAttribute("marker-end", "url(#arrow-forward)");
          }
          const ptsStr = edge.points.map((p) => `${p.x},${p.y}`).join(" ");
          poly.setAttribute("points", ptsStr);
          const polyHit = document.createElementNS(ns, "polyline");
          polyHit.setAttribute("points", ptsStr);
          polyHit.style.fill = "none";
          polyHit.style.stroke = "transparent";
          polyHit.style.strokeWidth = "20";
          polyHit.style.cursor = "pointer";
          polyHit.dataset.edgeId = edge.id;
          polyHit.addEventListener("click", (e) => {
           e.stopPropagation();
           selectTheConnection(edge.id);
          });
          let edgeTouchStart = null;
          let edgeTouchMoved = false;
          polyHit.addEventListener("touchstart", (e) => {
          edgeTouchStart = Date.now();
          edgeTouchMoved = false;
          if (e.touches[0]) {
           edgeTouchStartX = e.touches[0].clientX;
           edgeTouchStartY = e.touches[0].clientY;
          }
         }, {
           passive: false
          });
          let edgeTouchStartX = 0, edgeTouchStartY = 0;
         polyHit.addEventListener("touchmove", (e) => {
          if (e.touches[0]) {
           const dx = Math.abs(e.touches[0].clientX - edgeTouchStartX);
           const dy = Math.abs(e.touches[0].clientY - edgeTouchStartY);
           if (dx > 10 || dy > 10) edgeTouchMoved = true;
          }
         }, {
           passive: false
          });
          polyHit.addEventListener("touchend", (e) => {
           if (edgeTouchStart && !edgeTouchMoved && Date.now() - edgeTouchStart < 400) {
            e.stopPropagation();
            e.preventDefault();
            selectTheConnection(edge.id);
           }
           edgeTouchStart = null;
           edgeTouchMoved = false;
          }, {
           passive: false
          });
          poly.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         polyHit.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (selectedEdges.has(edge.id)) {
           selectedEdges.delete(edge.id);
          } else {
           selectedEdges.add(edge.id);
          }
          updateAllSelections();
         });
         let customEdgeLastTap = 0;
         polyHit.addEventListener("touchend", (e) => {
          const now = Date.now();
          if (now - customEdgeLastTap < 300) {
           e.preventDefault();
           if (selectedEdges.has(edge.id)) {
            selectedEdges.delete(edge.id);
           } else {
            selectedEdges.add(edge.id);
           }
           updateAllSelections();
           if (navigator.vibrate) navigator.vibrate(50);
           customEdgeLastTap = 0;
          } else {
           customEdgeLastTap = now;
          }
         }, { passive: false });
         poly.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (selectedEdges.has(edge.id)) {
           selectedEdges.delete(edge.id);
          } else {
           selectedEdges.add(edge.id);
          }
          updateAllSelections();
         });
         let edgeLastTap = 0;
         poly.addEventListener("touchend", (e) => {
          const now = Date.now();
          if (now - edgeLastTap < 300) {
           e.preventDefault();
           if (selectedEdges.has(edge.id)) {
            selectedEdges.delete(edge.id);
           } else {
            selectedEdges.add(edge.id);
           }
           updateAllSelections();
           if (navigator.vibrate) navigator.vibrate(50);
           edgeLastTap = 0;
          } else {
           edgeLastTap = now;
          }
         });
          if (currentView.mode === "rack") {
           return;
          }
          if (edge.groupId) {
      const bounds = edge.points.reduce((acc, p) => ({ minX: Math.min(acc.minX, p.x), minY: Math.min(acc.minY, p.y), maxX: Math.max(acc.maxX, p.x), maxY: Math.max(acc.maxY, p.y) }), { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity });
      const groupIndicator = document.createElementNS(ns, "rect");
      groupIndicator.setAttribute("x", bounds.minX - 8);
      groupIndicator.setAttribute("y", bounds.minY - 8);
      groupIndicator.setAttribute("width", bounds.maxX - bounds.minX + 16);
      groupIndicator.setAttribute("height", bounds.maxY - bounds.minY + 16);
      groupIndicator.setAttribute("rx", "4");
      groupIndicator.style.fill = "none";
  groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
      groupIndicator.style.strokeWidth = "3";
      groupIndicator.style.strokeDasharray = "5,5";
      groupIndicator.style.pointerEvents = "none";
      svg.appendChild(groupIndicator);
      }
         let lineDragging = false;
      let lineDragStartX, lineDragStartY;
      let linePointsStart = [];
      polyHit.addEventListener("mousedown", (e) => {
      if (freeDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      lineDragging = true;
      lineDragStartX = e.clientX;
      lineDragStartY = e.clientY;
      linePointsStart = edge.points.map(p => ({x: p.x, y: p.y}));
      if (selectedEdges.has(edge.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
      const lineMoveHandler = (e) => {
      if (!lineDragging || freeDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = lineDragStartX;
      pt1.y = lineDragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      edge.points.forEach((p, i) => { p.x = linePointsStart[i].x + dx; p.y = linePointsStart[i].y + dy; });
      if (selectedEdges.has(edge.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       savedPositions[nodeId] = { x: initialPositions[nodeId].x + dx, y: initialPositions[nodeId].y + dy };
      }
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      if (edgeId === edge.id) return;
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      forgeTheTopology();
      };
      const lineUpHandler = () => { lineDragging = false; };
      document.addEventListener("mousemove", lineMoveHandler);
      document.addEventListener("mouseup", lineUpHandler);
      svg.appendChild(poly);
      svg.appendChild(polyHit);
         if (currentEdgeId === edge.id) {
          edge.points.forEach((p, idx) => {
           const c = document.createElementNS(ns, "circle");
           c.classList.add("edge-edit-point");
           c.setAttribute("cx", p.x);
           c.setAttribute("cy", p.y);
		   c.setAttribute("r", PAGE_STATE.selectionHandleSize || 8);
           c.style.fill = PAGE_STATE.selectionHandle || "#f59e0b";
           c.style.stroke = "#fff";
           c.style.strokeWidth = "2";
           c.style.cursor = "move";
           c.dataset.edgeId = edge.id;
           c.dataset.pointIndex = String(idx);
           c.addEventListener("mousedown", (e) => {
            e.preventDefault();
            e.stopPropagation();
            pushUndo("edit edge point");
            let dragging = true;
            const svgEl = svg;
            const moveHandler = (ev) => {
             if (!dragging) return;
             const pt = svgEl.createSVGPoint();
             pt.x = ev.clientX;
             pt.y = ev.clientY;
             const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
             edge.points[idx].x = svgP.x;
             edge.points[idx].y = svgP.y;
             forgeTheTopology();
            };
            const upHandler = () => {
             dragging = false;
             document.removeEventListener("mousemove", moveHandler);
             document.removeEventListener("mouseup", upHandler);
            };
            document.addEventListener("mousemove", moveHandler);
            document.addEventListener("mouseup", upHandler);
           });
           c.addEventListener("touchstart", (e) => {
            e.preventDefault();
            e.stopPropagation();
            pushUndo("edit edge point");
            let dragging = true;
            const svgEl = svg;
            const touchMoveHandler = (ev) => {
             if (!dragging || !ev.touches[0]) return;
             const pt = svgEl.createSVGPoint();
             pt.x = ev.touches[0].clientX;
             pt.y = ev.touches[0].clientY;
             const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
             edge.points[idx].x = svgP.x;
             edge.points[idx].y = svgP.y;
             forgeTheTopology();
            };
            const touchUpHandler = () => {
             dragging = false;
             document.removeEventListener("touchmove", touchMoveHandler);
             document.removeEventListener("touchend", touchUpHandler);
            };
            document.addEventListener("touchmove", touchMoveHandler);
            document.addEventListener("touchend", touchUpHandler);
           }, { passive: false });
           svg.appendChild(c);
          });
         }
         return;
         }
         const p1 = positions[edge.from];
         const p2 = positions[edge.to];
         if (!p1 || !p2) return;
         const edgeFaded = currentView.mode !== "rack" && (!isNodeVisible(edge.from) || !isNodeVisible(edge.to));
         const pairTotal = edge._pairTotal || 1;
         const pairIndex = edge._pairIndex || 0;
         const midX = (p1.x + p2.x) / 2;
         const midY = (p1.y + p2.y) / 2;
         const dx = p2.x - p1.x;
         const dy = p2.y - p1.y;
         const len = Math.sqrt(dx * dx + dy * dy) || 1;
         const perpX = -dy / len;
         const perpY = dx / len;
         let offsetAmount = 0;
         if (pairTotal > 1) {
          offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
         }
         const ctrlX = midX + perpX * offsetAmount;
         const ctrlY = midY + perpY * offsetAmount;
         const path = document.createElementNS(ns, "path");
         path.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
         path.setAttribute("fill", "none");
         path.classList.add("edge");
         if (edgeFaded) {
          path.style.opacity = "0.25";
          path.classList.add("layer-faded");
         }
         if (edge.type === "backup") path.classList.add("backup");
         path.dataset.edgeId = edge.id;
         path.dataset.from = edge.from;
         path.dataset.to = edge.to;
         path.style.stroke = edge.color;
         path.style.strokeWidth = edge.width;
         const pathHit = document.createElementNS(ns, "path");
         pathHit.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
         pathHit.setAttribute("fill", "none");
         pathHit.style.stroke = "transparent";
         pathHit.style.strokeWidth = "20";
         pathHit.style.cursor = "pointer";
         pathHit.dataset.edgeId = edge.id;
         pathHit.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         let pathTouchStart = null;
         let pathTouchMoved = false;
         pathHit.addEventListener("touchstart", (e) => {
         pathTouchStart = Date.now();
         pathTouchMoved = false;
         if (e.touches[0]) {
          pathTouchStartX = e.touches[0].clientX;
          pathTouchStartY = e.touches[0].clientY;
         }
        }, {
          passive: false
         });
         let pathTouchStartX = 0, pathTouchStartY = 0;
        pathHit.addEventListener("touchmove", (e) => {
         if (e.touches[0]) {
          const dx = Math.abs(e.touches[0].clientX - pathTouchStartX);
          const dy = Math.abs(e.touches[0].clientY - pathTouchStartY);
          if (dx > 10 || dy > 10) pathTouchMoved = true;
         }
        }, {
          passive: false
         });
         pathHit.addEventListener("touchend", (e) => {
          if (pathTouchStart && !pathTouchMoved && Date.now() - pathTouchStart < 400) {
           e.stopPropagation();
           e.preventDefault();
           selectTheConnection(edge.id);
          }
          pathTouchStart = null;
          pathTouchMoved = false;
         }, {
          passive: false
         });
         path.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         if (currentView.mode === "rack") {
          const fromNode = NODE_DATA[edge.from];
          const toNode = NODE_DATA[edge.to];
          if (!fromNode || !toNode ||
              fromNode.assignedRack !== currentView.rackId ||
              toNode.assignedRack !== currentView.rackId) {
           return;
          }
         }
         svg.appendChild(path);
         svg.appendChild(pathHit);
         if (edge.fromPort || edge.toPort) {
          const ns = "http://www.w3.org/2000/svg";
          if (edge.fromPort) {
           const fromLabel = document.createElementNS(ns, "text");
           fromLabel.textContent = edge.fromPort;
           fromLabel.setAttribute("x", p1.x);
           fromLabel.setAttribute("y", p1.y - 10);
           fromLabel.setAttribute("text-anchor", "middle");
           fromLabel.style.fill = "#94a3b8";
           fromLabel.style.fontSize = "12px";
           fromLabel.style.fontWeight = "600";
           fromLabel.style.pointerEvents = "none";
           fromLabel.classList.add("port-label");
           svg.appendChild(fromLabel);
          }
          if (edge.toPort) {
           const toLabel = document.createElementNS(ns, "text");
           toLabel.textContent = edge.toPort;
           toLabel.setAttribute("x", p2.x);
           toLabel.setAttribute("y", p2.y - 10);
           toLabel.setAttribute("text-anchor", "middle");
           toLabel.style.fill = "#94a3b8";
           toLabel.style.fontSize = "12px";
           toLabel.style.fontWeight = "600";
           toLabel.style.pointerEvents = "none";
           toLabel.classList.add("port-label");
           svg.appendChild(toLabel);
          }
         }
        });
        Object.entries(positions).forEach(([id, pos]) => {
         const node = NODE_DATA[id];
         if (!node) return;
         if (currentView.mode === "rack") {
          if (node.assignedRack !== currentView.rackId) return;
         const rackUnit = parseInt(node.rackUnit) || 1;
      const uHeight = parseInt(node.uHeight) || 1;
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      pos.x = RACK_START_X;
      pos.y = RACK_START_Y + (rackCapacity - rackUnit - uHeight + 1) * rackUHeight + (uHeight * rackUHeight) / 2;
         } else {
          if (node.assignedRack) return;
         }
         const g = document.createElementNS("http://www.w3.org/2000/svg", "g", );
         g.classList.add("node-group");
         g.dataset.nodeId = id;
         g.setAttribute("transform", `translate(${pos.x},${pos.y})`);
         if (currentView.mode !== "rack" && !isNodeVisible(id)) {
          g.style.opacity = "0.25";
          g.classList.add("layer-faded");
         }
         let r = savedSizes[id] || 55;
		if (!savedSizes[id]) {
		 if (window.innerWidth <= 480) r = 45;
		 else if (window.innerWidth <= 768) r = 50;
		}
         const styles = resolveStylesForNode(id);
         const ns = "http://www.w3.org/2000/svg";
         const hitArea = document.createElementNS(ns, "circle");
         hitArea.setAttribute("r", r * 1.5);
         hitArea.style.fill = "transparent";
         hitArea.style.stroke = "none";
         hitArea.style.cursor = "grab";
         hitArea.classList.add("node-hit-area");
         const shapeEl = createNodeShape(id, r);
         const titleOffsetX = styles.titleOffsetX || 0;
         const titleOffsetY = styles.titleOffsetY || 0;
         const subOffsetX = styles.subOffsetX || 0;
         const subOffsetY = styles.subOffsetY || 0;
         const label = document.createElementNS("http://www.w3.org/2000/svg", "text", );
         label.classList.add("node-label");
         label.setAttribute("x", titleOffsetX);
         label.setAttribute("y", -r * 0.28 + titleOffsetY);
         const labelFontSize = styles.titleSize || PAGE_STATE.nodeTitleSize || r * 0.33;
        label.style.fontSize = labelFontSize + "px";
         label.textContent = NODE_DATA[id].name;
		label.style.fill = styles.titleColor || PAGE_STATE.nodeTitle || "#e2e8f0";
        label.style.fontFamily = styles.titleFont || PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
         label.style.pointerEvents = "none";
         const sub = document.createElementNS("http://www.w3.org/2000/svg", "text", );
         sub.classList.add("node-sub");
         sub.setAttribute("x", subOffsetX);
         sub.setAttribute("y", r * 0.4 + subOffsetY);
         const subFontSize = styles.subSize || PAGE_STATE.nodeSubSize || r * 0.24;
        sub.style.fontSize = subFontSize + "px";
         sub.textContent = NODE_DATA[id].ip;
		sub.style.fill = styles.subColor || PAGE_STATE.nodeSub || "#94a3b8";
        sub.style.fontFamily = styles.subFont || PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
         sub.style.pointerEvents = "none";
         g.append(hitArea, shapeEl, label, sub);
         if (NODE_DATA[id]?.locked) {
           const lockIndicator = document.createElementNS(ns, "text");
           lockIndicator.textContent = "üîí";
           lockIndicator.setAttribute("x", r * 0.7);
           lockIndicator.setAttribute("y", -r * 0.7);
           lockIndicator.style.fontSize = (r * 0.3) + "px";
           lockIndicator.style.pointerEvents = "none";
           lockIndicator.classList.add("lock-indicator");
           g.appendChild(lockIndicator);
         }
         if (NODE_DATA[id]?.groupId) {
           const groupIndicator = document.createElementNS(ns, "circle");
           groupIndicator.setAttribute("r", r + 4);
           groupIndicator.style.fill = "none";
         groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
           groupIndicator.style.strokeWidth = "3";
           groupIndicator.style.strokeDasharray = "5,5";
           groupIndicator.style.pointerEvents = "none";
           groupIndicator.classList.add("group-indicator");
           g.insertBefore(groupIndicator, g.firstChild);
         }
         let isDragging = false;
         let startX, startY;
         let initialPositions = {};
         let longPressTimer = null;
         let longPressTriggered = false;
         g.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (isViewOnly()) return;
          if (selectedNodes.has(id)) {
           selectedNodes.delete(id);
          } else {
           selectedNodes.add(id);
          }
          updateNodeSelection();
          return false;
         });
        g.addEventListener("touchstart", (e) => {
         if (NODE_DATA[id].isRack) {
          const touch = e.touches[0];
          longPressStartX = touch.clientX;
          longPressStartY = touch.clientY;
          longPressTimer = setTimeout(() => {
           longPressTriggered = true;
           if (navigator.vibrate) {
            navigator.vibrate(100);
           }
           enterRack(id);
          }, 500);
         }
        }, { passive: true });
        g.addEventListener("dblclick", (e) => {
         e.preventDefault();
         e.stopPropagation();
         if (NODE_DATA[id].isRack) {
          enterRack(id);
         }
        });
        let lastTapTime = 0;
        let lastTapNode = null;
        g.addEventListener("touchend", (e) => {
         const currentTime = new Date().getTime();
         const tapLength = currentTime - lastTapTime;
         if (tapLength < 300 && tapLength > 0 && lastTapNode === id) {
          e.preventDefault();
          e.stopPropagation();
          if (isViewOnly()) return;
          if (selectedNodes.has(id)) {
           selectedNodes.delete(id);
          } else {
           selectedNodes.add(id);
          }
          updateNodeSelection();
          if (navigator.vibrate) {
           navigator.vibrate(50);
          }
          lastTapTime = 0;
          lastTapNode = null;
         } else {
          lastTapTime = currentTime;
          lastTapNode = id;
         }
        });
         g.addEventListener("touchend", (e) => {
          if (longPressTimer) {
           clearTimeout(longPressTimer);
           longPressTimer = null;
          }
          if (longPressTriggered) {
           e.preventDefault();
           e.stopPropagation();
           longPressTriggered = false;
          }
         });
         let longPressStartX = 0;
        let longPressStartY = 0;
        g.addEventListener("touchmove", (e) => {
         if (longPressTimer) {
          const touch = e.touches[0];
          const dx = Math.abs(touch.clientX - longPressStartX);
          const dy = Math.abs(touch.clientY - longPressStartY);
          if (dx > 15 || dy > 15) {
           clearTimeout(longPressTimer);
           longPressTimer = null;
           longPressTriggered = false;
          }
         }
        }, { passive: true });
         g.addEventListener("mousedown", (e) => {
          if (isViewOnly()) return;
          if (e.button === 2) {
           return;
          }
          if (NODE_DATA[id]?.locked) {
           return;
          }
          e.preventDefault();
          isDragging = true;
		  pushUndo("move nodes");
          const svgEl = document.getElementById("map");
          const pt = svgEl.createSVGPoint();
          pt.x = e.clientX;
          pt.y = e.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          startX = svgP.x;
          startY = svgP.y;
          let nodesToCollect = [];
      if (selectedNodes.has(id)) {
      initialPositions = {};
      const allSelectedRects = Array.from(selectedRects);
      const allSelectedTexts = Array.from(selectedTexts);
      const allSelectedEdges = Array.from(selectedEdges).map(eid => EDGE_DATA.list.find(e => e.id === eid)).filter(Boolean);
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) {
      initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      }
      });
      Array.from(selectedRects).forEach(rectId => {
        const rect = RECT_DATA.list.find(r => r.id === rectId);
        if (rect) { rect._dragStartX = rect.x; rect._dragStartY = rect.y; }
      });
      Array.from(selectedTexts).forEach(textId => {
        const text = TEXT_DATA.list.find(t => t.id === textId);
        if (text) { text._dragStartX = text.x; text._dragStartY = text.y; }
      });
      Array.from(selectedEdges).forEach(edgeId => {
        const edge = EDGE_DATA.list.find(e => e.id === edgeId);
        if (edge && edge.points) { edge._dragStartPoints = edge.points.map(p => ({x: p.x, y: p.y})); }
      });
      } else {
      initialPositions = { [id]: { x: pos.x, y: pos.y } };
      }
          const groupIds = new Set();
          nodesToCollect.forEach(nodeId => {
           const groupId = NODE_DATA[nodeId]?.groupId;
           if (groupId) {
             groupIds.add(groupId);
           }
          });
          if (groupIds.size > 0) {
           Object.keys(NODE_DATA).forEach(nodeId => {
             const nodeGroupId = NODE_DATA[nodeId]?.groupId;
             if (nodeGroupId && groupIds.has(nodeGroupId)) {
               if (!nodesToCollect.includes(nodeId)) {
                 nodesToCollect.push(nodeId);
               }
             }
           });
          }
          nodesToCollect = nodesToCollect.filter(nodeId => !NODE_DATA[nodeId]?.locked);
          if (nodesToCollect.length === 0) {
           return;
          }
          initialPositions = {};
          nodesToCollect.forEach(nodeId => {
           const nodePos = savedPositions[nodeId];
           if (nodePos) {
            initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
           }
          });
          g.style.cursor = "grabbing";
          hitArea.style.cursor = "grabbing";
          e.stopPropagation();
         });
         const handleMouseMove = (e) => {
          if (!isDragging) return;
          e.preventDefault();
          const svgEl = document.getElementById("map");
          const pt = svgEl.createSVGPoint();
          pt.x = e.clientX;
          pt.y = e.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          const dx = svgP.x - startX;
          const dy = svgP.y - startY;
          const nodesToMove = selectedNodes.has(id) ? Array.from(selectedNodes) : [id];
          nodesToMove.forEach(nodeId => {
           if (!initialPositions[nodeId]) return;
           const initialPos = initialPositions[nodeId];
           let newX = initialPos.x + dx;
           let newY = initialPos.y + dy;
           const nodeSize = savedSizes[nodeId] || 55;
           newX = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, newX), );
           newY = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, newY), );
           savedPositions[nodeId] = { x: newX, y: newY };
           positions[nodeId] = { x: newX, y: newY };
           if (nodeId === id) {
            pos.x = newX;
            pos.y = newY;
           }
           const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
          if (nodeGroup) {
           nodeGroup.setAttribute("transform", `translate(${newX},${newY})`);
          }
         });
         Array.from(selectedRects).forEach(rectId => {
           const rect = RECT_DATA.list.find(r => r.id === rectId);
           if (rect && rect._dragStartX !== undefined) {
             rect.x = rect._dragStartX + dx;
             rect.y = rect._dragStartY + dy;
           }
         });
         Array.from(selectedTexts).forEach(textId => {
           const text = TEXT_DATA.list.find(t => t.id === textId);
           if (text && text._dragStartX !== undefined) {
             text.x = text._dragStartX + dx;
             text.y = text._dragStartY + dy;
           }
         });
         Array.from(selectedEdges).forEach(edgeId => {
           const edge = EDGE_DATA.list.find(e => e.id === edgeId);
           if (edge && edge._dragStartPoints) {
             edge.points.forEach((p, i) => {
               p.x = edge._dragStartPoints[i].x + dx;
               p.y = edge._dragStartPoints[i].y + dy;
             });
           }
         });
         forgeTheTopology();
         updateMinimap();
          document.querySelectorAll(".edge").forEach((edgeEl) => {
           const fromId = edgeEl.dataset.from;
           const toId = edgeEl.dataset.to;
           if (nodesToMove.includes(fromId) || nodesToMove.includes(toId)) {
            const p1 = savedPositions[fromId] || positions[fromId] || {
             x: 600,
             y: 350
            };
            const p2 = savedPositions[toId] || positions[toId] || {
             x: 600,
             y: 350
            };
            if (edgeEl.tagName === "line") {
             edgeEl.setAttribute("x1", p1.x);
             edgeEl.setAttribute("y1", p1.y);
             edgeEl.setAttribute("x2", p2.x);
             edgeEl.setAttribute("y2", p2.y);
            } else if (edgeEl.tagName === "path") {
             const edgeId = edgeEl.dataset.edgeId;
             const edge = EDGE_DATA.list.find(
              (e) => e.id === edgeId, );
             if (edge) {
              const pairTotal = edge._pairTotal || 1;
              const pairIndex = edge._pairIndex || 0;
              const midX = (p1.x + p2.x) / 2;
              const midY = (p1.y + p2.y) / 2;
              const dx = p2.x - p1.x;
              const dy = p2.y - p1.y;
              const len = Math.sqrt(dx * dx + dy * dy) || 1;
              const perpX = -dy / len;
              const perpY = dx / len;
              let offsetAmount = 0;
              if (pairTotal > 1) {
               offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
              }
              const ctrlX = midX + perpX * offsetAmount;
              const ctrlY = midY + perpY * offsetAmount;
              edgeEl.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
             }
            }
           }
          });
         };
      const handleMouseUp = () => {
      if (isDragging) {
      isDragging = false;
      g.style.cursor = "grab";
      hitArea.style.cursor = "grab";
      if (currentView.mode === "rack" && NODE_DATA[id]?.assignedRack === currentView.rackId) {
      const draggedY = savedPositions[id]?.y || pos.y;
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      let newUnit = rackCapacity - Math.round((draggedY - RACK_START_Y) / rackUHeight);
      newUnit = Math.max(1, Math.min(newUnit, rackCapacity));
      NODE_DATA[id].rackUnit = newUnit;
      forgeTheTopology();
      claimTheImmortal(id);
      }
      }
      };
         document.addEventListener("mousemove", handleMouseMove);
         document.addEventListener("mouseup", handleMouseUp);
         let touchStartTime = 0;
         let touchStartX = 0;
         let touchStartY = 0;
         let touchMoved = false;
       g.addEventListener("touchstart",
         (e) => {
          if (NODE_DATA[id]?.locked) {
           return;
          }
          e.preventDefault();
          touchStartTime = Date.now();
          touchMoved = false;
          const svgEl = document.getElementById("map");
          const pt = svgEl.createSVGPoint();
          const touch = e.touches[0];
          pt.x = touch.clientX;
          pt.y = touch.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          touchStartX = svgP.x;
          touchStartY = svgP.y;
          startX = svgP.x;
          startY = svgP.y;
          let nodesToCollect = [];
          if (selectedNodes.has(id)) {
           nodesToCollect = Array.from(selectedNodes);
          } else {
           nodesToCollect = [id];
          }
          const groupIds = new Set();
          nodesToCollect.forEach(nodeId => {
           const groupId = NODE_DATA[nodeId]?.groupId;
           if (groupId) {
             groupIds.add(groupId);
           }
          });
          if (groupIds.size > 0) {
           Object.keys(NODE_DATA).forEach(nodeId => {
             const nodeGroupId = NODE_DATA[nodeId]?.groupId;
             if (nodeGroupId && groupIds.has(nodeGroupId)) {
               if (!nodesToCollect.includes(nodeId)) {
                 nodesToCollect.push(nodeId);
               }
             }
           });
          }
          nodesToCollect = nodesToCollect.filter(nodeId => !NODE_DATA[nodeId]?.locked);
          if (nodesToCollect.length === 0) {
           return;
          }
          initialPositions = {};
          nodesToCollect.forEach(nodeId => {
           const nodePos = savedPositions[nodeId];
           if (nodePos) {
            initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
           }
          });
          e.stopPropagation();
         }, {
          passive: false
         }, );
         g.addEventListener("touchmove", (e) => {
		  if (isViewOnly()) return;
         e.preventDefault();
         const svgEl = document.getElementById("map");
         const pt = svgEl.createSVGPoint();
         const touch = e.touches[0];
         pt.x = touch.clientX;
         pt.y = touch.clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
         const dx = Math.abs(svgP.x - touchStartX);
         const dy = Math.abs(svgP.y - touchStartY);
         if (dx > (isMobileDevice() ? 4 : 10) || dy > (isMobileDevice() ? 4 : 10)) {
      touchMoved = true;
      isDragging = true;
      }
         if (!isDragging) return;
         const deltaX = svgP.x - startX;
         const deltaY = svgP.y - startY;
         const nodesToMove = selectedNodes.has(id) ? Array.from(selectedNodes) : [id];
         nodesToMove.forEach(nodeId => {
          if (!initialPositions[nodeId]) return;
          const initialPos = initialPositions[nodeId];
          let newX = initialPos.x + deltaX;
          let newY = initialPos.y + deltaY;
          const nodeSize = savedSizes[nodeId] || 55;
          newX = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, newX), );
          newY = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, newY), );
          savedPositions[nodeId] = { x: newX, y: newY };
          positions[nodeId] = { x: newX, y: newY };
          if (nodeId === id) {
           pos.x = newX;
           pos.y = newY;
          }
          const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
          if (nodeGroup) {
           nodeGroup.setAttribute("transform", `translate(${newX},${newY})`);
          }
         });
         updateMinimap();
         document.querySelectorAll(".edge").forEach((edgeEl) => {
          const fromId = edgeEl.dataset.from;
          const toId = edgeEl.dataset.to;
          if (nodesToMove.includes(fromId) || nodesToMove.includes(toId)) {
            const p1 = savedPositions[fromId] || positions[fromId] || {
             x: 600,
             y: 350
            };
            const p2 = savedPositions[toId] || positions[toId] || {
             x: 600,
             y: 350
            };
            if (edgeEl.tagName === "line") {
             edgeEl.setAttribute("x1", p1.x);
             edgeEl.setAttribute("y1", p1.y);
             edgeEl.setAttribute("x2", p2.x);
             edgeEl.setAttribute("y2", p2.y);
            } else if (edgeEl.tagName === "path") {
             const edgeId = edgeEl.dataset.edgeId;
             const edge = EDGE_DATA.list.find(
              (e) => e.id === edgeId, );
             if (edge) {
              const pairTotal = edge._pairTotal || 1;
              const pairIndex = edge._pairIndex || 0;
              const midX = (p1.x + p2.x) / 2;
              const midY = (p1.y + p2.y) / 2;
              const dx = p2.x - p1.x;
              const dy = p2.y - p1.y;
              const len = Math.sqrt(dx * dx + dy * dy) || 1;
              const perpX = -dy / len;
              const perpY = dx / len;
              let offsetAmount = 0;
              if (pairTotal > 1) {
               offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
              }
              const ctrlX = midX + perpX * offsetAmount;
              const ctrlY = midY + perpY * offsetAmount;
              edgeEl.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
             }
            }
           }
          });
         }, {
          passive: false
         });
      g.addEventListener("touchend", (e) => {
      const touchDuration = Date.now() - touchStartTime;
      if (!touchMoved && touchDuration < 400) {
       if (isViewOnly()) {
        handleViewOnlyClick(id, 'node');
        return;
       }
       claimTheImmortal(id);
      }
      if (isDragging) {
      const draggedY = pos.y;
      isDragging = false;
      savedPositions[id] = {
      x: pos.x,
      y: pos.y
      };
      if (currentView.mode === "rack" && NODE_DATA[id]?.assignedRack === currentView.rackId) {
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      let newUnit = rackCapacity - Math.round((draggedY - RACK_START_Y) / rackUHeight);
      newUnit = Math.max(1, Math.min(newUnit, rackCapacity));
      NODE_DATA[id].rackUnit = newUnit;
      forgeTheTopology();
      claimTheImmortal(id);
      }
      }
      touchMoved = false;
      });
         g.style.cursor = "grab";
         g.addEventListener("click", (e) => {
          if (!isDragging) {
           if (isViewOnly()) {
            handleViewOnlyClick(id, 'node');
            return;
           }
           claimTheImmortal(id);
          }
         });
         svg.appendChild(g);
        });
        if (RECT_DATA && RECT_DATA.list) {
         RECT_DATA.list.forEach((rect) => {
          if (currentView.mode === "rack") return;
          if (rect.style === "outlined") {
           const g = document.createElementNS(ns, "g");
           g.classList.add("rect-group");
           g.dataset.rectId = rect.id;
           const rectEl = document.createElementNS(ns, "rect");
           rectEl.classList.add("rect-shape");
           rectEl.setAttribute("x", rect.x);
           rectEl.setAttribute("y", rect.y);
           rectEl.setAttribute("width", rect.width);
           rectEl.setAttribute("height", rect.height);
           rectEl.style.fill = "none";
           rectEl.style.stroke = rect.borderColor || rect.color;
           rectEl.style.strokeWidth = (rect.borderWidth !== undefined ? rect.borderWidth : 3) + "px";
      if (rect.lineStyle === "dashed") { rectEl.style.strokeDasharray = "10,5"; }
           else if (rect.lineStyle === "dotted") { rectEl.style.strokeDasharray = "2,4"; }
           else { rectEl.style.strokeDasharray = "none"; }
           rectEl.style.cursor = "move";
           rectEl.addEventListener("click", (e) => {
             if (rectDrawMode) return;
             e.stopPropagation();
             currentRectId = rect.id;
             selectTheRect(rect.id);
           });
           rectEl.addEventListener("contextmenu", (e) => {
             e.preventDefault();
             e.stopPropagation();
             if (selectedRects.has(rect.id)) {
               selectedRects.delete(rect.id);
             } else {
               selectedRects.add(rect.id);
             }
             updateAllSelections();
           });
           let rectLastTap = 0;
           rectEl.addEventListener("touchend", (e) => {
             const now = Date.now();
             if (now - rectLastTap < 300) {
               e.preventDefault();
               if (selectedRects.has(rect.id)) {
                 selectedRects.delete(rect.id);
               } else {
                 selectedRects.add(rect.id);
               }
               updateAllSelections();
               if (navigator.vibrate) navigator.vibrate(50);
               rectLastTap = 0;
             } else {
               rectLastTap = now;
             }
           }, { passive: false });
           const deleteBtn = document.createElementNS(ns, "g");
           deleteBtn.classList.add("rect-delete-btn");
           deleteBtn.style.cursor = "pointer";
           deleteBtn.style.display = rectDrawMode ? "block" : "none";
           const deleteBg = document.createElementNS(ns, "circle");
           deleteBg.setAttribute("cx", rect.x + rect.width - 10);
           deleteBg.setAttribute("cy", rect.y + 10);
           deleteBg.setAttribute("r", 12);
           deleteBg.style.fill = "#f56565";
           deleteBg.style.stroke = "white";
           deleteBg.style.strokeWidth = "2";
           const deleteX = document.createElementNS(ns, "text");
           deleteX.setAttribute("x", rect.x + rect.width - 10);
           deleteX.setAttribute("y", rect.y + 10);
           deleteX.setAttribute("text-anchor", "middle");
           deleteX.setAttribute("dominant-baseline", "middle");
           deleteX.style.fill = "white";
           deleteX.style.fontSize = "16px";
           deleteX.style.fontWeight = "bold";
           deleteX.style.pointerEvents = "none";
           deleteX.textContent = "√ó";
           deleteBtn.appendChild(deleteBg);
           deleteBtn.appendChild(deleteX);
           deleteBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            e.preventDefault();
            deleteRectangle(rect.id);
           });
           let isDragging = false;
           let dragStartX, dragStartY;
           let rectStartX, rectStartY;
           rectEl.addEventListener("mousedown", (e) => {
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            dragStartX = e.clientX;
            dragStartY = e.clientY;
            rectStartX = rect.x;
            rectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           });
      const moveHandler = (e) => {
      if (!isDragging || rectDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      rect.x = rectStartX + dx;
      rect.y = rectStartY + dy;
      if (selectedRects.has(rect.id)) {
      selectedNodes.forEach(nodeId => { if (initialPositions[nodeId]) { savedPositions[nodeId] = { x: initialPositions[nodeId].x + dx, y: initialPositions[nodeId].y + dy }; } });
      selectedRects.forEach(rectId => { if (rectId === rect.id) return; const r = RECT_DATA.list.find(x => x.id === rectId); if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; } });
      selectedTexts.forEach(textId => { const t = TEXT_DATA.list.find(x => x.id === textId); if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; } });
      selectedEdges.forEach(edgeId => { const ed = EDGE_DATA.list.find(x => x.id === edgeId); if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); } });
      }
      forgeTheTopology();
      };
           const upHandler = () => {
            if (isDragging) {
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           };
           document.addEventListener("mousemove", moveHandler);
           document.addEventListener("mouseup", upHandler);
           let touchStartX, touchStartY;
           let touchRectStartX, touchRectStartY;
           rectEl.addEventListener("touchstart", (e) => {
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchRectStartX = rect.x;
            touchRectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           }, { passive: false });
           rectEl.addEventListener("touchmove", (e) => {
		   if (isViewOnly()) return;
            if (!isDragging || rectDrawMode) return;
            if (!e.touches[0]) return;
            e.preventDefault();
            e.stopPropagation();
            const svgEl = svg;
            const pt1 = svgEl.createSVGPoint();
            pt1.x = touchStartX;
            pt1.y = touchStartY;
            const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
            const touch = e.touches[0];
            const pt2 = svgEl.createSVGPoint();
            pt2.x = touch.clientX;
            pt2.y = touch.clientY;
            const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
            const dx = svgP2.x - svgP1.x;
            const dy = svgP2.y - svgP1.y;
            rect.x = touchRectStartX + dx;
            rect.y = touchRectStartY + dy;
            forgeTheTopology();
           }, { passive: false });
           rectEl.addEventListener("touchend", (e) => {
            if (isDragging) {
             e.preventDefault();
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           }, { passive: false });
           if (currentRectId === rect.id) {
             const corners = [
               { cx: rect.x, cy: rect.y, cursor: 'nwse-resize', dx: -1, dy: -1 },
               { cx: rect.x + rect.width, cy: rect.y, cursor: 'nesw-resize', dx: 1, dy: -1 },
               { cx: rect.x, cy: rect.y + rect.height, cursor: 'nesw-resize', dx: -1, dy: 1 },
               { cx: rect.x + rect.width, cy: rect.y + rect.height, cursor: 'nwse-resize', dx: 1, dy: 1 }
             ];
             corners.forEach((corner) => {
               const handle = document.createElementNS(ns, "circle");
               handle.setAttribute("cx", corner.cx);
               handle.setAttribute("cy", corner.cy);
handle.setAttribute("r", PAGE_STATE.selectionHandleSize || 8);
      handle.style.fill = PAGE_STATE.selectionHandle || "#f59e0b";
               handle.style.stroke = "#fff";
               handle.style.strokeWidth = "2";
               handle.style.cursor = corner.cursor;
               handle.addEventListener("mousedown", (e) => {
                 e.preventDefault();
                 e.stopPropagation();
				 pushUndo("resize zone");
                 let dragging = true;
                 const startX = e.clientX, startY = e.clientY;
                 const origX = rect.x, origY = rect.y, origW = rect.width, origH = rect.height;
                 const moveHandler = (ev) => {
                   if (!dragging) return;
                   const pt1 = svg.createSVGPoint(); pt1.x = startX; pt1.y = startY;
                   const pt2 = svg.createSVGPoint(); pt2.x = ev.clientX; pt2.y = ev.clientY;
                   const svgP1 = pt1.matrixTransform(svg.getScreenCTM().inverse());
                   const svgP2 = pt2.matrixTransform(svg.getScreenCTM().inverse());
                   const dx = svgP2.x - svgP1.x, dy = svgP2.y - svgP1.y;
                   if (corner.dx < 0) { rect.x = origX + dx; rect.width = origW - dx; }
                   else { rect.width = origW + dx; }
                   if (corner.dy < 0) { rect.y = origY + dy; rect.height = origH - dy; }
                   else { rect.height = origH + dy; }
                   if (rect.width < 20) rect.width = 20;
                   if (rect.height < 20) rect.height = 20;
                   forgeTheTopology();
                 };
                 const upHandler = () => { dragging = false; document.removeEventListener("mousemove", moveHandler); document.removeEventListener("mouseup", upHandler); };
                 document.addEventListener("mousemove", moveHandler);
                 document.addEventListener("mouseup", upHandler);
               });
               g.appendChild(handle);
             });
           }
           if (rect.groupId) {
             const groupIndicator = document.createElementNS(ns, "rect");
             groupIndicator.setAttribute("x", rect.x - 4);
             groupIndicator.setAttribute("y", rect.y - 4);
             groupIndicator.setAttribute("width", rect.width + 8);
             groupIndicator.setAttribute("height", rect.height + 8);
             groupIndicator.style.fill = "none";
         groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
             groupIndicator.style.strokeWidth = "3";
             groupIndicator.style.strokeDasharray = "5,5";
             groupIndicator.style.pointerEvents = "none";
             g.insertBefore(groupIndicator, g.firstChild);
           }
           g.appendChild(rectEl);
           g.appendChild(deleteBtn);
           svg.appendChild(g);
          }
         });
        }
        if (TEXT_DATA && TEXT_DATA.list) {
         TEXT_DATA.list.forEach((textItem) => {
          if (currentView.mode === "rack") return;
          const g = document.createElementNS(ns, "g");
          g.classList.add("text-group");
          g.dataset.textId = textItem.id;
          if (textItem.bgEnabled) {
           const bgRect = document.createElementNS(ns, "rect");
           bgRect.classList.add("text-bg");
           bgRect.setAttribute("x", textItem.x - 5);
           bgRect.setAttribute("y", textItem.y - textItem.fontSize - 2);
           bgRect.setAttribute("width", 100);
           bgRect.setAttribute("height", textItem.fontSize + 10);
           bgRect.style.fill = textItem.bgColor;
           bgRect.style.opacity = "0.7";
           bgRect.style.rx = "4";
           g.appendChild(bgRect);
          }
          const textEl = document.createElementNS(ns, "text");
          textEl.classList.add("text-element");
          textEl.setAttribute("x", textItem.x);
          textEl.setAttribute("y", textItem.y);
          textEl.style.fill = textItem.color;
          textEl.style.fontSize = textItem.fontSize + "px";
          textEl.style.fontWeight = textItem.fontWeight;
          textEl.style.fontStyle = textItem.fontStyle;
          textEl.style.textAnchor = textItem.textAlign;
          textEl.style.textDecoration = textItem.textDecoration;
          textEl.style.opacity = textItem.opacity;
          textEl.style.cursor = "move";
          textEl.style.userSelect = "none";
          textEl.setAttribute("dominant-baseline", "middle");
          const lines = textItem.content.split('\n');
          if (lines.length === 1) {
           textEl.textContent = textItem.content;
          } else {
           lines.forEach((line, i) => {
            const tspan = document.createElementNS(ns, "tspan");
            tspan.textContent = line;
            tspan.setAttribute("x", textItem.x);
            tspan.setAttribute("dy", i === 0 ? 0 : textItem.fontSize * 1.2);
            textEl.appendChild(tspan);
           });
          }
          g.appendChild(textEl);
          if (textItem.bgEnabled) {
           setTimeout(() => {
            try {
             const bbox = textEl.getBBox();
             const bgRect = g.querySelector('.text-bg');
             if (bgRect && bbox) {
              bgRect.setAttribute("x", bbox.x - 5);
              bgRect.setAttribute("y", bbox.y - 2);
              bgRect.setAttribute("width", bbox.width + 10);
              bgRect.setAttribute("height", bbox.height + 4);
             }
            } catch (e) {
            }
           }, 0);
          }
          const deleteBtn = document.createElementNS(ns, "g");
          deleteBtn.classList.add("text-delete-btn");
          deleteBtn.style.cursor = "pointer";
          deleteBtn.style.display = textDrawMode ? "block" : "none";
          const deleteBg = document.createElementNS(ns, "circle");
          deleteBg.setAttribute("cx", textItem.x + 20);
          deleteBg.setAttribute("cy", textItem.y - textItem.fontSize);
          deleteBg.setAttribute("r", 12);
          deleteBg.style.fill = "#f56565";
          deleteBg.style.stroke = "white";
          deleteBg.style.strokeWidth = "2";
          const deleteX = document.createElementNS(ns, "text");
          deleteX.setAttribute("x", textItem.x + 20);
          deleteX.setAttribute("y", textItem.y - textItem.fontSize);
          deleteX.setAttribute("text-anchor", "middle");
          deleteX.setAttribute("dominant-baseline", "middle");
          deleteX.style.fill = "white";
          deleteX.style.fontSize = "16px";
          deleteX.style.fontWeight = "bold";
          deleteX.style.pointerEvents = "none";
          deleteX.textContent = "√ó";
          deleteBtn.appendChild(deleteBg);
          deleteBtn.appendChild(deleteX);
          deleteBtn.addEventListener("click", (e) => {
           e.stopPropagation();
           e.preventDefault();
           deleteText(textItem.id);
          });
          let isDragging = false;
          let dragStartX, dragStartY;
          let textStartX, textStartY;
          textEl.addEventListener("mousedown", (e) => {
      if (textDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      textStartX = textItem.x;
      textStartY = textItem.y;
      textEl.style.cursor = "grabbing";
      showTextPanel(textItem.id);
      if (selectedTexts.has(textItem.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
          const moveHandler = (e) => {
      if (!isDragging || textDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      textItem.x = textStartX + dx;
      textItem.y = textStartY + dy;
      if (selectedTexts.has(textItem.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       const newX = initialPositions[nodeId].x + dx;
       const newY = initialPositions[nodeId].y + dy;
       savedPositions[nodeId] = { x: newX, y: newY };
      }
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      if (textId === textItem.id) return;
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      forgeTheTopology();
      };
          const upHandler = () => {
           if (isDragging) {
            isDragging = false;
            textEl.style.cursor = "move";
           }
          };
          document.addEventListener("mousemove", moveHandler);
          document.addEventListener("mouseup", upHandler);
          let touchStartX = 0, touchStartY = 0;
          let textTouchStartX = 0, textTouchStartY = 0;
          textEl.addEventListener("touchstart", (e) => {
           if (textDrawMode) return;
           if (e.touches.length !== 1) return;
           e.preventDefault();
           e.stopPropagation();
           const touch = e.touches[0];
           isDragging = true;
           touchStartX = touch.clientX;
           touchStartY = touch.clientY;
           textTouchStartX = textItem.x;
           textTouchStartY = textItem.y;
           showTextPanel(textItem.id);
          }, { passive: false });
          textEl.addEventListener("touchmove", (e) => {
           if (!isDragging || textDrawMode) return;
           if (e.touches.length !== 1) return;
           e.preventDefault();
           const touch = e.touches[0];
           const svgEl = svg;
           const pt1 = svgEl.createSVGPoint();
           pt1.x = touchStartX;
           pt1.y = touchStartY;
           const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
           const pt2 = svgEl.createSVGPoint();
           pt2.x = touch.clientX;
           pt2.y = touch.clientY;
           const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
           const dx = svgP2.x - svgP1.x;
           const dy = svgP2.y - svgP1.y;
           textItem.x = textTouchStartX + dx;
           textItem.y = textTouchStartY + dy;
           forgeTheTopology();
          }, { passive: false });
          textEl.addEventListener("touchend", () => {
           if (isDragging) {
            isDragging = false;
           }
          }, { passive: false });
          textEl.addEventListener("contextmenu", (e) => {
           e.preventDefault();
           e.stopPropagation();
           if (selectedTexts.has(textItem.id)) {
            selectedTexts.delete(textItem.id);
           } else {
            selectedTexts.add(textItem.id);
           }
           updateAllSelections();
          });
          let textLastTap = 0;
          g.addEventListener("touchend", (e) => {
           const now = Date.now();
           if (now - textLastTap < 300) {
            e.preventDefault();
            if (selectedTexts.has(textItem.id)) {
             selectedTexts.delete(textItem.id);
            } else {
             selectedTexts.add(textItem.id);
            }
            updateAllSelections();
            if (navigator.vibrate) navigator.vibrate(50);
            textLastTap = 0;
           } else {
            textLastTap = now;
           }
          }, { passive: false });
          if (textItem.groupId) {
            const groupIndicator = document.createElementNS(ns, "rect");
            groupIndicator.setAttribute("x", textItem.x - 54);
            groupIndicator.setAttribute("y", textItem.y - 24);
            groupIndicator.setAttribute("width", 108);
            groupIndicator.setAttribute("height", 48);
            groupIndicator.setAttribute("rx", "8");
            groupIndicator.style.fill = "none";
       groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
            groupIndicator.style.strokeWidth = "3";
            groupIndicator.style.strokeDasharray = "5,5";
            groupIndicator.style.pointerEvents = "none";
            g.insertBefore(groupIndicator, g.firstChild);
          }
          g.appendChild(deleteBtn);
          svg.appendChild(g);
         });
        }
        Object.keys(NODE_DATA).forEach(nodeId => {
         updatePingIndicator(nodeId);
        });
        forgeTheLegend();
        updateMinimap();
       }
       function showEditModal(title, currentValue, onSave) {
        const modal = document.getElementById("edit-modal");
        const input = document.getElementById("modal-input");
        const titleEl = document.getElementById("modal-title");
        const saveBtn = document.getElementById("modal-save");
        const cancelBtn = document.getElementById("modal-cancel");
        titleEl.textContent = title;
        input.value = currentValue;
        modal.classList.add("active");
        input.focus();
        input.select();
        const cleanup = () => {
         modal.classList.remove("active");
         saveBtn.removeEventListener("click", handleSave);
         cancelBtn.removeEventListener("click", handleCancel);
         input.removeEventListener("keypress", handleEnter);
         modal.removeEventListener("click", bgHandler);
        };
        const handleSave = () => {
         if (input.value.trim()) {
          onSave(input.value.trim());
         }
         cleanup();
        };
        const handleCancel = () => {
         cleanup();
        };
        const handleEnter = (e) => {
         if (e.key === "Enter") handleSave();
        };
        const bgHandler = (e) => {
         if (e.target === modal) handleCancel();
        };
        saveBtn.addEventListener("click", handleSave);
        cancelBtn.addEventListener("click", handleCancel);
        input.addEventListener("keypress", handleEnter);
        modal.addEventListener("click", bgHandler);
       }
       function challengeTheImmortal(message, onConfirm) {
        const modal = document.getElementById("confirm-modal");
        const messageEl = document.getElementById("confirm-message");
        const deleteBtn = document.getElementById("confirm-delete");
        const cancelBtn = document.getElementById("confirm-cancel");
        messageEl.textContent = message;
        modal.classList.add("active");
	    const cleanup = () => {
         modal.classList.remove("active");
         deleteBtn.removeEventListener("click", handleConfirm);
         cancelBtn.removeEventListener("click", handleCancel);
         modal.removeEventListener("click", bgHandler);
        };
        const handleConfirm = () => {
         onConfirm();
         cleanup();
        };
        const handleCancel = () => {
         cleanup();
        };
        const bgHandler = (e) => {
         if (e.target === modal) handleCancel();
        };
        deleteBtn.addEventListener("click", handleConfirm);
        cancelBtn.addEventListener("click", handleCancel);
        modal.addEventListener("click", bgHandler);
       }
       const pageTitleEl = document.getElementById("page-title");
       if (pageTitleEl) {
        pageTitleEl.addEventListener("click", () => {
         showEditModal("Edit Title", PAGE_STATE.title || DEFAULT_PAGE_STATE.title,
          (newTitle) => {
           PAGE_STATE.title = newTitle;
           wieldThePower();
          }, );
        });
       }
       function editNodeName(id) {
        if (!NODE_DATA[id]) return;
        showEditModal("Edit Name", NODE_DATA[id].name, (newName) => {
         if (!NODE_DATA[id]) return;
         pushUndo("edit node name");
         NODE_DATA[id].name = newName;
         const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`, );
         if (nodeGroup) {
          const label = nodeGroup.querySelector(".node-label");
          if (label) label.textContent = newName;
         }
         if (currentNodeId === id) {
          document.getElementById("node-name").textContent = newName;
         }
        });
       }
       function editNodeIp(id) {
        if (!NODE_DATA[id]) return;
        showEditModal("Edit IP/Subtitle", NODE_DATA[id].ip, (newIp) => {
         if (!NODE_DATA[id]) return;
         pushUndo("edit node ip");
         NODE_DATA[id].ip = newIp;
         const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`, );
         if (nodeGroup) {
          const sub = nodeGroup.querySelector(".node-sub");
          if (sub) sub.textContent = newIp;
         }
         if (currentNodeId === id) {
          document.getElementById("node-ip").textContent = newIp;
         }
        });
       }
       function claimTheImmortal(id) {
	   if (isViewOnly()) return;
        if (!NODE_DATA[id]) return;
        currentNodeId = id;
        currentEdgeId = null;
        currentRectId = null;
        currentTextId = null;
        const data = NODE_DATA[id];
        document.querySelectorAll(".node-group").forEach((n) => {
         n.classList.toggle("active", n.dataset.nodeId === id);
        });
        document.querySelectorAll(".edge").forEach((e) => {
        const active = e.dataset.from === id || e.dataset.to === id;
        e.classList.toggle("active", active);
       });
       document.querySelectorAll(".rect-group").forEach((r) => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach((t) => t.classList.remove("active"));
       document.getElementById("node-panel").style.display = "block";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        const toolbar = document.getElementById("topology-toolbar");
        if (!topologyToolbarCollapsed) {
         toolbar.style.display = "flex";
        }
        updateTopologyToolbarVisibility();
        document.getElementById("node-name").textContent = data.name;
        document.getElementById("node-ip").textContent = data.ip;
        document.getElementById("node-mac").textContent = data.mac || "--";
        document.getElementById("node-rack").textContent = data.rackUnit || "--";
        document.getElementById("node-uheight").textContent = (data.uHeight || "1") + "U";
        document.getElementById("node-role").textContent = data.role;
        populateRackDropdown();
        const assignedRackSelect = document.getElementById("node-assigned-rack");
        if (assignedRackSelect) {
         assignedRackSelect.value = data.assignedRack || "";
        }
        const rackCapacitySelect = document.getElementById("node-rack-capacity");
        if (rackCapacitySelect) {
         rackCapacitySelect.value = data.rackCapacity || "42";
        }
        const isRack = data.isRack === true;
        const isAssignedToRack = !!data.assignedRack;
        const assignedRackRow = document.getElementById("assigned-rack-row");
        const rackCapacityRow = document.getElementById("rack-capacity-row");
        const uheightRow = document.getElementById("uheight-row");
        if (assignedRackRow) assignedRackRow.style.display = isRack ? "none" : "flex";
        if (rackCapacityRow) rackCapacityRow.style.display = isRack ? "flex" : "none";
        if (uheightRow) uheightRow.style.display = isAssignedToRack ? "flex" : "none";
		const delBtn = document.getElementById("delete-node-btn");
        if (delBtn) delBtn.textContent = isRack ? "Delete Rack" : "Delete Node";
		const rackContentsSection = document.getElementById("rack-contents-section");
        const rackContentsList = document.getElementById("rack-contents-list");
        const rackContentsCount = document.getElementById("rack-contents-count");
        if (rackContentsSection && rackContentsList) {
        if (isRack) {
         const nodesInRack = Object.entries(NODE_DATA).filter(([nid, n]) => n.assignedRack === id);
         rackContentsCount.textContent = nodesInRack.length;
         if (nodesInRack.length > 0) {
          rackContentsList.innerHTML = nodesInRack.map(([nid, n]) => {
           const tags = (n.tags || []).map(t => `<span style="background: var(--accent); color: var(--bg); padding: 2px 6px; border-radius: 4px; font-size: 11px; margin-left: 4px;">${t}</span>`).join('');
           return `<div style="padding: 8px 4px; border-bottom: 1px solid var(--edge-main); cursor: pointer;" onclick="claimTheImmortal('${nid}')">
            <span style="color: var(--text-main);">${n.name}</span>${tags}
           </div>`;
          }).join('');
         } else {
          rackContentsList.innerHTML = '<div style="color: var(--text-soft); font-style: italic; padding: 8px 4px;">No nodes assigned</div>';
         }
         rackContentsSection.style.display = "block";
         } else {
         rackContentsSection.style.display = "none";
         }
        }
        document.getElementById("node-name").onclick = () => editNodeName(id);
        document.getElementById("node-ip").onclick = () => editNodeIp(id);
        document.getElementById("node-mac").onclick = () => editNodeMac(id);
        document.getElementById("node-rack").onclick = () => editNodeRack(id);
        document.getElementById("node-uheight").onclick = () => editNodeUHeight(id);
        const currentSize = savedSizes[id] || getDefaultSize();
        document.getElementById("size-slider").value = currentSize;
        document.getElementById("size-value").textContent = currentSize;
        const styleEntry = savedStyles[id] || {};
        const resolvedStyles = resolveStylesEntry(styleEntry);
        const scopeKey = currentStyleScope || "all";
        const flatProps = ["circleColor", "circleBorder", "titleColor", "titleFont", "titleSize", "subColor", "subFont", "subSize", ];
        const isFlat = flatProps.some((p) => Object.prototype.hasOwnProperty.call(styleEntry, p), );
        const scopedStyles = isFlat ? styleEntry : styleEntry[scopeKey] || {};
        const circleColorInput = document.getElementById("circle-color");
        const titleColorInput = document.getElementById("title-color");
        const titleFontSelect = document.getElementById("title-font");
        const titleSizeInput = document.getElementById("title-size");
        const subColorInput = document.getElementById("sub-color");
        const subFontSelect = document.getElementById("sub-font");
        const subSizeInput = document.getElementById("sub-size");
        const shapeSelect = document.getElementById("shape-select");
        const scopeSelect = document.getElementById("style-scope");
        circleColorInput.value = scopedStyles.circleColor || resolvedStyles.circleColor || PAGE_STATE.nodeFill || "#1e293b";
       const circleBorderInput = document.getElementById("circle-border");
       circleBorderInput.value = scopedStyles.circleBorder || resolvedStyles.circleBorder || PAGE_STATE.nodeStroke || "#475569";
        titleColorInput.value = scopedStyles.titleColor || resolvedStyles.titleColor || PAGE_STATE.textMain || "#e2e8f0";
        titleFontSelect.value = scopedStyles.titleFont || resolvedStyles.titleFont || "system-ui, sans-serif";
        titleSizeInput.value = scopedStyles.titleSize || resolvedStyles.titleSize || 18;
        subColorInput.value = scopedStyles.subColor || resolvedStyles.subColor || PAGE_STATE.textSoft || "#94a3b8";
        subFontSelect.value = scopedStyles.subFont || resolvedStyles.subFont || "system-ui, sans-serif";
        subSizeInput.value = scopedStyles.subSize || resolvedStyles.subSize || 13;
        const hasWebIcon = resolvedStyles.icon && resolvedStyles.icon.library;
        const customOpt = shapeSelect.querySelector('option[value="custom-icon"]');
        if (hasWebIcon) {
         if (!customOpt) {
          const opt = document.createElement('option');
          opt.value = 'custom-icon';
          opt.textContent = 'Custom Icon';
          shapeSelect.insertBefore(opt, shapeSelect.firstChild);
         }
         shapeSelect.value = 'custom-icon';
        } else {
         if (customOpt) customOpt.remove();
         shapeSelect.value = data.shape || "circle";
        }
        const layerSelect = document.getElementById("node-layer");
        if (layerSelect) {
         layerSelect.value = data.layer || "physical";
        }
        scopeSelect.value = currentStyleScope || "all";
        document.getElementById("title-offset-y").value = scopedStyles.titleOffsetY || resolvedStyles.titleOffsetY || 0;
        document.getElementById("title-offset-x").value = scopedStyles.titleOffsetX || resolvedStyles.titleOffsetX || 0;
        document.getElementById("sub-offset-y").value = scopedStyles.subOffsetY || resolvedStyles.subOffsetY || 0;
        document.getElementById("sub-offset-x").value = scopedStyles.subOffsetX || resolvedStyles.subOffsetX || 0;
      const pingOffsetXInput = document.getElementById("ping-offset-x");
      const pingOffsetYInput = document.getElementById("ping-offset-y");
      if (pingOffsetXInput && pingOffsetYInput) {
      pingOffsetXInput.value =
       (scopedStyles.pingOffsetX !== undefined
         ? scopedStyles.pingOffsetX
         : (resolvedStyles.pingOffsetX !== undefined
             ? resolvedStyles.pingOffsetX
             : 0));
      pingOffsetYInput.value =
       (scopedStyles.pingOffsetY !== undefined
         ? scopedStyles.pingOffsetY
         : (resolvedStyles.pingOffsetY !== undefined
             ? resolvedStyles.pingOffsetY
             : 0));
      }
        const tagEl = document.getElementById("node-tags");
        tagEl.innerHTML = "";
        data.tags.forEach((tag, i) => {
         const b = document.createElement("span");
         b.className = "badge";
         const isIconTag = typeof tag === 'object' && tag.type === 'icon';
         if (!isIconTag && typeof tag === 'string' && tag.toLowerCase().includes("wg")) b.classList.add("wg");
         b.style.cursor = "pointer";
         b.style.position = "relative";
         const tagContent = document.createElement("span");
         if (isIconTag) {
          b.classList.add("icon-badge");
          IconLibrary.getIcon(tag.library, tag.name).then(svgText => {
           if (svgText) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(svgText, 'image/svg+xml');
            const svgEl = doc.querySelector('svg');
            if (svgEl) {
             svgEl.setAttribute('width', '16');
             svgEl.setAttribute('height', '16');
             tagContent.innerHTML = '';
             tagContent.appendChild(svgEl);
             const nameSpan = document.createElement('span');
             nameSpan.textContent = tag.name;
             nameSpan.style.marginLeft = '4px';
             tagContent.appendChild(nameSpan);
            }
           }
          });
         } else {
          tagContent.textContent = tag;
          tagContent.addEventListener("click", (e) => {
           e.stopPropagation();
           showEditModal("Edit Tag", tag, (newTag) => {
            if (newTag) {
             pushUndo("edit tag");
             data.tags[i] = newTag;
             claimTheImmortal(id);
            }
           });
          });
         }
         const deleteTag = document.createElement("span");
         deleteTag.textContent = " ‚úï";
         deleteTag.style.opacity = "0.6";
         deleteTag.style.marginLeft = "4px";
         deleteTag.style.fontSize = "10px";
         deleteTag.addEventListener("click", (e) => {
          e.stopPropagation();
          pushUndo("delete tag");
          data.tags.splice(i, 1);
          claimTheImmortal(id);
         });
         b.append(tagContent, deleteTag);
         tagEl.append(b);
        });
        const addTagBtn = document.createElement("span");
        addTagBtn.className = "badge";
        addTagBtn.style.cursor = "pointer";
        addTagBtn.style.opacity = "0.6";
        addTagBtn.style.borderStyle = "dashed";
        addTagBtn.textContent = "+ Add Tag";
        addTagBtn.addEventListener("click", () => {
         showEditModal("Add Tag(s) : comma separated", "",
          (newTagStr) => {
           if (newTagStr) {
            pushUndo("add tags");
            const newTags = newTagStr.split(",").map((t) => t.trim()).filter((t) => t);
            newTags.forEach((t) => data.tags.push(t));
            claimTheImmortal(id);
           }
          }, );
        });
        tagEl.append(addTagBtn);
        const notesEl = document.getElementById("node-notes");
        notesEl.innerHTML = "";
        data.notes.forEach((note, i) => {
         const li = document.createElement("li");
         const noteText = document.createElement("span");
         noteText.textContent = note;
         noteText.style.flex = "1";
         const deleteBtn = document.createElement("span");
         deleteBtn.className = "delete-note";
         deleteBtn.textContent = "‚úï";
         deleteBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          challengeTheImmortal("Are you sure you want to delete this note?",
           () => {
            pushUndo("delete note");
            data.notes.splice(i, 1);
            claimTheImmortal(id);
           }, );
         });
         li.append(noteText, deleteBtn);
         noteText.addEventListener("dblclick", () => {
          noteText.classList.add("editing");
          noteText.contentEditable = true;
          noteText.focus();
         });
         noteText.addEventListener("blur", () => {
          noteText.classList.remove("editing");
          noteText.contentEditable = false;
          pushUndo("edit note");
          data.notes[i] = noteText.textContent;
         });
         notesEl.append(li);
        });
        const addLineSelect = document.getElementById("add-line-select");
      addLineSelect.innerHTML = "";
      const currentRack = data.assignedRack || "";
      Object.entries(NODE_DATA).forEach(([nodeId, node]) => {
      if (nodeId !== id) {
      const nodeRack = node.assignedRack || "";
      if (currentRack === nodeRack) {
      const opt = document.createElement("option");
      opt.value = nodeId;
      opt.textContent = node.name;
      addLineSelect.appendChild(opt);
      }
      }
      });
        const pingEnabled = data.ping && data.ping.enabled;
        document.getElementById('node-pingable').checked = pingEnabled;
        document.getElementById('node-ping-options').style.display = pingEnabled ? 'block' : 'none';
        if (data.ping) {
         document.getElementById('node-ping-protocol').value = data.ping.protocol || 'http';
         document.getElementById('node-custom-url').value = data.ping.customUrl || '';
         document.getElementById('node-ping-timeout').value = data.ping.timeout || 3000;
         document.getElementById('node-custom-url-container').style.display =
          data.ping.protocol === 'custom' ? 'block' : 'none';
         updatePingStatusDisplay(id);
        }
       }
       function updatePingStatusDisplay(nodeId) {
        const data = NODE_DATA[nodeId];
        if (!data || !data.ping) return;
        const statusEl = document.getElementById('node-ping-status');
        const lastCheckEl = document.getElementById('node-ping-last-check');
        const statusColors = {
         online: 'var(--accent)',
         offline: 'var(--danger)',
         checking: '#f59e0b',
         unknown: 'var(--text-soft)'
        };
        const statusTexts = {
         online: '‚óè Online',
         offline: '‚óè Offline',
         checking: '‚óè Checking...',
         unknown: '‚óè Unknown'
        };
        statusEl.textContent = statusTexts[data.ping.status] || statusTexts.unknown;
        statusEl.style.color = statusColors[data.ping.status] || statusColors.unknown;
        if (data.ping.lastCheck) {
         const checkTime = new Date(data.ping.lastCheck);
         lastCheckEl.textContent = `Last checked: ${checkTime.toLocaleTimeString()}`;
        } else {
         lastCheckEl.textContent = 'Never checked';
        }
       }
       function selectTheConnection(id) {
	   if (isViewOnly()) return;
        currentEdgeId = id;
        currentNodeId = null;
        currentRectId = null;
        currentTextId = null;
		if (isMobileDevice()) {
        const currentHeight = PAGE_STATE.mobileFooterHeight || 40;
        if (currentHeight <= 20) {
         PAGE_STATE.mobileFooterHeight = 80;
         const root = document.documentElement;
         root.style.setProperty("--mobile-footer-height", "80vh");
         const mobileFooterHeightInput = document.getElementById("mobile-footer-height");
         const mobileFooterHeightVal = document.getElementById("mobile-footer-height-val");
         if (mobileFooterHeightInput) mobileFooterHeightInput.value = 80;
         if (mobileFooterHeightVal) mobileFooterHeightVal.textContent = "80%";
        }
       }
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "block";
        document.getElementById("text-panel").style.display = "none";
       document.getElementById("rect-panel").style.display = "none";
       document.getElementById("topology-toolbar").style.display = "none";
       document.querySelectorAll(".node-group").forEach((n) => n.classList.remove("active"));
       document.querySelectorAll(".rect-group").forEach((r) => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach((t) => t.classList.remove("active"));
       document.querySelectorAll(".edge").forEach((e) => {
        e.classList.toggle("active", e.dataset.edgeId === id);
       });
        const edge = EDGE_DATA.list.find((e) => e.id === id);
        if (!edge) return;
        const directionSymbols = {
         none: "‚áÑ",
         forward: "‚Üí",
         backward: "‚Üê",
         both: "‚Üî",
        };
        const dirSymbol = directionSymbols[edge.direction] || "‚áÑ";
        let titleText = "Custom line";
        if (edge.from || edge.to) {
         const fromName = edge.from ? NODE_DATA[edge.from]?.name || edge.from : "";
         const toName = edge.to ? NODE_DATA[edge.to]?.name || edge.to : "";
         titleText = `${fromName || "?"} ${dirSymbol} ${toName || "?"}`;
        }
        document.getElementById("edge-title").textContent = titleText;
        const widthInput = document.getElementById("edge-width");
        const colorInput = document.getElementById("edge-color");
        const directionSelect = document.getElementById("edge-direction");
        const lineStyleSelect = document.getElementById("edge-line-style");
        widthInput.value = edge.width;
        colorInput.value = edge.color;
        directionSelect.value = edge.direction || "none";
        lineStyleSelect.value = edge.lineStyle || "solid";
        const fromPortInput = document.getElementById("edge-from-port");
        const toPortInput = document.getElementById("edge-to-port");
        const portFieldsFrom = document.getElementById("edge-port-fields");
        const portFieldsTo = document.getElementById("edge-port-fields-to");
        if (edge.type === "custom") {
         if (portFieldsFrom) portFieldsFrom.style.display = "none";
         if (portFieldsTo) portFieldsTo.style.display = "none";
        } else {
         if (portFieldsFrom) portFieldsFrom.style.display = "flex";
         if (portFieldsTo) portFieldsTo.style.display = "flex";
         if (fromPortInput) {
          fromPortInput.value = edge.fromPort || "";
          fromPortInput.onchange = () => updateEdgePortLabels(id);
         }
         if (toPortInput) {
          toPortInput.value = edge.toPort || "";
          toPortInput.onchange = () => updateEdgePortLabels(id);
         }
        }
        const list = document.getElementById("edge-notes");
        list.innerHTML = "";
        edge.notes.forEach((note, i) => {
         const li = document.createElement("li");
         const txt = document.createElement("span");
         txt.textContent = note;
         txt.style.flex = "1";
         const del = document.createElement("span");
         del.className = "delete-note";
         del.textContent = "‚úï";
         del.addEventListener("click", (e) => {
          e.stopPropagation();
         challengeTheImmortal("Delete this line note?", () => {
           pushUndo("delete edge note");
           edge.notes.splice(i, 1);
           selectTheConnection(id);
          });
         });
         txt.addEventListener("dblclick", () => {
          txt.classList.add("editing");
          txt.contentEditable = true;
          txt.focus();
         });
        txt.addEventListener("blur", () => {
          txt.classList.remove("editing");
          txt.contentEditable = false;
          pushUndo("edit edge note");
          edge.notes[i] = txt.textContent;
         });
         li.append(txt, del);
         list.appendChild(li);
       });
       if (edge.type === "custom" && Array.isArray(edge.points)) {
        forgeTheTopology();
       }
      }
       window.addEventListener("resize", () => {
        forgeTheTopology();
        if (currentEdgeId) {
         selectTheConnection(currentEdgeId);
        } else if (currentNodeId && NODE_DATA[currentNodeId]) {
         claimTheImmortal(currentNodeId);
        } else {
         const availableNodes = Object.keys(NODE_DATA);
         if (availableNodes.length > 0) {
          claimTheImmortal(availableNodes[0]);
         }
        }
       });
       (function initZoomPan() {
        const viewport = document.getElementById("canvas-viewport");
        const svg = document.getElementById("map");
        const hint = document.getElementById("canvas-hint");
        setTimeout(() => {
         hint.classList.add("visible");
         setTimeout(() => hint.classList.remove("visible"), 4000);
        }, 1000);
        viewport.addEventListener("wheel",
         (e) => {
          e.preventDefault();
          const rect = viewport.getBoundingClientRect();
          const mouseX = (e.clientX - rect.left) / rect.width;
          const mouseY = (e.clientY - rect.top) / rect.height;
          const delta = e.deltaY > 0 ? 0.9 : 1.1;
          zoomTo(canvasState.zoom * delta, mouseX, mouseY);
         }, {
          passive: false
         }, );
        let initialPinchDistance = 0;
        let initialPinchZoom = 1;
        let pinchCenter = {
         x: 0.5,
         y: 0.5
        };
        viewport.addEventListener("touchstart",
         (e) => {
          if (e.touches.length === 2) {
           e.preventDefault();
           const touch1 = e.touches[0];
           const touch2 = e.touches[1];
           initialPinchDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY, );
           initialPinchZoom = canvasState.zoom;
           const rect = viewport.getBoundingClientRect();
           const centerX = (touch1.clientX + touch2.clientX) / 2;
           const centerY = (touch1.clientY + touch2.clientY) / 2;
           pinchCenter.x = (centerX - rect.left) / rect.width;
           pinchCenter.y = (centerY - rect.top) / rect.height;
          }
         }, {
          passive: false
         }, );
        viewport.addEventListener("touchmove",
         (e) => {
          if (e.touches.length === 2) {
           e.preventDefault();
           const touch1 = e.touches[0];
           const touch2 = e.touches[1];
           const currentDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY, );
           if (initialPinchDistance > 0) {
            const scale = currentDistance / initialPinchDistance;
            const newZoom = initialPinchZoom * scale;
            zoomTo(newZoom, pinchCenter.x, pinchCenter.y);
           }
          }
         }, {
          passive: false
         }, );
        let panStartViewX = 0;
        let panStartViewY = 0;
        let lastEmptyTapTime = 0;
        let emptyTapTimeout = null;
        let emptyTapMoved = false;
        let emptyTapStartX = 0;
        let emptyTapStartY = 0;
        viewport.addEventListener("touchend", (e) => {
          if (currentView.mode !== "rack") return;
          if (e.changedTouches.length !== 1) return;
      const isNodeOrEdge = e.target.closest(".node-group") || e.target.closest(".edge-group");
         if (isNodeOrEdge) return;
          if (emptyTapMoved) {
            emptyTapMoved = false;
            return;
          }
          const currentTime = new Date().getTime();
          const tapGap = currentTime - lastEmptyTapTime;
          if (tapGap < 300 && tapGap > 0) {
            e.preventDefault();
            exitRack();
            if (navigator.vibrate) {
              navigator.vibrate(50);
            }
            lastEmptyTapTime = 0;
            if (emptyTapTimeout) {
              clearTimeout(emptyTapTimeout);
              emptyTapTimeout = null;
            }
          } else {
            lastEmptyTapTime = currentTime;
            if (emptyTapTimeout) clearTimeout(emptyTapTimeout);
            emptyTapTimeout = setTimeout(() => {
              lastEmptyTapTime = 0;
            }, 300);
          }
        }, { passive: false });
        viewport.addEventListener("mousedown", (e) => {
         if (e.target.closest(".draw-toolbar") || e.target.closest(".topology-toolbar") || e.target.closest(".legend-container")) {
          return;
         }
         if (freeDrawMode || rectDrawMode) {
          return;
         }
      const isEmptySpace = e.target === svg || e.target === viewport || e.target.tagName === "svg";
      const isEdgeElement = e.target.closest('.edge') || e.target.classList.contains('edge-edit-point');
      const isTextElement = e.target.closest('.text-group') || e.target.closest('.text-element');
      const isRectElement = e.target.closest('.rect-group');
      if (!isEdgeElement && !isTextElement && !isRectElement && currentEdgeId) {
      currentEdgeId = null;
      forgeTheTopology();
      }
      if (!isRectElement && currentRectId) {
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      }
         if (isViewOnly()) {
         document.body.classList.remove("view-only-inspect");
         document.getElementById("node-panel").style.display = "none";
         document.getElementById("edge-panel").style.display = "none";
        }
         if (isEmptySpace && e.shiftKey && e.button === 0) {
         if (isViewOnly()) return;
         e.preventDefault();
         startSelection(e);
         return;
        }
        if (isEmptySpace || e.button === 2 || e.button === 1) {
          e.preventDefault();
          canvasState.isPanning = true;
          canvasState.panStartX = e.clientX;
          canvasState.panStartY = e.clientY;
          panStartViewX = canvasState.panX;
          panStartViewY = canvasState.panY;
          viewport.classList.add("panning");
         }
        });
        viewport.addEventListener("touchstart",
         (e) => {
          if (e.target.closest(".draw-toolbar") || e.target.closest(".topology-toolbar") || e.target.closest(".legend-container")) {
           return;
          }
          if (freeDrawMode || rectDrawMode) {
           return;
          }
      const isEmptySpace = e.target === svg || e.target === viewport || e.target.tagName === "svg";
      const isEdgeElement = e.target.closest('.edge') || e.target.classList.contains('edge-edit-point');
      const isTextElement = e.target.closest('.text-group') || e.target.closest('.text-element');
      const isRectElement = e.target.closest('.rect-group');
      if (!isEdgeElement && !isTextElement && !isRectElement && currentEdgeId) {
      currentEdgeId = null;
      forgeTheTopology();
      }
      if (!isRectElement && currentRectId) {
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      }
          if (isEmptySpace && e.touches.length === 1) {
           e.preventDefault();
           emptyTapMoved = false;
           emptyTapStartX = e.touches[0].clientX;
           emptyTapStartY = e.touches[0].clientY;
           canvasState.isPanning = true;
           canvasState.panStartX = e.touches[0].clientX;
           canvasState.panStartY = e.touches[0].clientY;
           panStartViewX = canvasState.panX;
           panStartViewY = canvasState.panY;
           viewport.classList.add("panning");
          }
         }, {
          passive: false
         }, );
        document.addEventListener("mousemove", (e) => {
         if (isSelecting) {
          updateSelection(e);
          return;
         }
         if (!canvasState.isPanning) return;
         const dx = e.clientX - canvasState.panStartX;
         const dy = e.clientY - canvasState.panStartY;
         const rect = viewport.getBoundingClientRect();
         const viewWidth = CANVAS_WIDTH / canvasState.zoom;
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         const canvasDx = (dx / rect.width) * viewWidth;
         const canvasDy = (dy / rect.height) * viewHeight;
         canvasState.panX = panStartViewX - canvasDx;
         canvasState.panY = panStartViewY - canvasDy;
         constrainPan();
         updateViewBox();
        });
       document.addEventListener("touchmove", (e) => {
        if (!canvasState.isPanning || !e.touches[0]) return;
        const moveDx = Math.abs(e.touches[0].clientX - emptyTapStartX);
        const moveDy = Math.abs(e.touches[0].clientY - emptyTapStartY);
        if (moveDx > 15 || moveDy > 15) {
         emptyTapMoved = true;
        }
        const dx = e.touches[0].clientX - canvasState.panStartX;
         const dy = e.touches[0].clientY - canvasState.panStartY;
         const rect = viewport.getBoundingClientRect();
         const viewWidth = CANVAS_WIDTH / canvasState.zoom;
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         const canvasDx = (dx / rect.width) * viewWidth;
         const canvasDy = (dy / rect.height) * viewHeight;
         canvasState.panX = panStartViewX - canvasDx;
         canvasState.panY = panStartViewY - canvasDy;
         constrainPan();
         updateViewBox();
        });
        document.addEventListener("mouseup", () => {
         if (isSelecting) {
          endSelection();
         }
         if (canvasState.isPanning) {
          canvasState.isPanning = false;
          viewport.classList.remove("panning");
         }
        });
        document.addEventListener("touchend", () => {
         if (canvasState.isPanning) {
          canvasState.isPanning = false;
          viewport.classList.remove("panning");
         }
        });
        document.addEventListener("keydown", (e) => {
         const isEditing = document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "TEXTAREA" || document.activeElement.isContentEditable;
         if (e.code === "Space" && !e.repeat && !isEditing) {
          e.preventDefault();
          canvasState.spacePressed = true;
          viewport.style.cursor = "grab";
         }
        });
        document.addEventListener("keyup", (e) => {
         if (e.code === "Space") {
          canvasState.spacePressed = false;
          viewport.style.cursor = "";
         }
        });
        document.getElementById("zoom-in-btn").addEventListener("click", () => {
         zoomTo(canvasState.zoom * 1.25, 0.5, 0.5);
        });
        document.getElementById("zoom-out-btn").addEventListener("click", () => {
         zoomTo(canvasState.zoom * 0.8, 0.5, 0.5);
        });
        document.getElementById("zoom-fit-btn").addEventListener("click", fitToContent);
        document.getElementById("zoom-reset-btn").addEventListener("click", resetView);
        const minimapContainer = document.getElementById("minimap-container");
        const minimapSvg = document.getElementById("minimap");
        let minimapDragging = false;
        minimapContainer.addEventListener("mousedown", (e) => {
         e.preventDefault();
         minimapDragging = true;
         updatePanFromMinimap(e);
        });
        minimapContainer.addEventListener("touchstart",
         (e) => {
          e.preventDefault();
          minimapDragging = true;
          updatePanFromMinimapTouch(e);
         }, {
          passive: false
         }, );
        document.addEventListener("mousemove", (e) => {
         if (minimapDragging) {
          updatePanFromMinimap(e);
         }
        });
        document.addEventListener("touchmove", (e) => {
         if (minimapDragging && e.touches[0]) {
          updatePanFromMinimapTouch(e);
         }
        });
        document.addEventListener("mouseup", () => {
         minimapDragging = false;
        });
        document.addEventListener("touchend", () => {
         minimapDragging = false;
        });
        function updatePanFromMinimap(e) {
         const rect = minimapContainer.getBoundingClientRect();
         const x = (e.clientX - rect.left) / rect.width;
         const y = (e.clientY - rect.top) / rect.height;
         const viewWidth = CANVAS_WIDTH / canvasState.zoom;
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         canvasState.panX = x * CANVAS_WIDTH - viewWidth / 2;
         canvasState.panY = y * CANVAS_HEIGHT - viewHeight / 2;
         constrainPan();
         updateViewBox();
        }
        function updatePanFromMinimapTouch(e) {
         const rect = minimapContainer.getBoundingClientRect();
         const touch = e.touches[0];
         const x = (touch.clientX - rect.left) / rect.width;
         const y = (touch.clientY - rect.top) / rect.height;
         const viewWidth = CANVAS_WIDTH / canvasState.zoom;
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         canvasState.panX = x * CANVAS_WIDTH - viewWidth / 2;
         canvasState.panY = y * CANVAS_HEIGHT - viewHeight / 2;
         constrainPan();
         updateViewBox();
        }
        document.addEventListener("keydown", (e) => {
         if (document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "TEXTAREA") return;
         if (
          (e.key === "+" || e.key === "=") && (e.ctrlKey || e.metaKey)) {
          e.preventDefault();
          zoomTo(canvasState.zoom * 1.25, 0.5, 0.5);
         } else if (e.key === "-" && (e.ctrlKey || e.metaKey)) {
          e.preventDefault();
          zoomTo(canvasState.zoom * 0.8, 0.5, 0.5);
         } else if (e.key === "0" && (e.ctrlKey || e.metaKey)) {
          e.preventDefault();
          resetView();
         }
        });
        setTimeout(() => {
         fitToContent();
        }, 100);
       })();
       const sizeSlider = document.getElementById("size-slider");
       const sizeValue = document.getElementById("size-value");
       const resetSizeBtn = document.getElementById("reset-size");
       sizeSlider.addEventListener("input", () => {
        const newSize = parseInt(sizeSlider.value, 10);
        sizeValue.textContent = newSize;
        pushUndo("resize node");
        savedSizes[currentNodeId] = newSize;
        const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
        if (nodeGroup) {
         const oldShape = nodeGroup.querySelector(".node-circle");
         if (oldShape) oldShape.remove();
         const newShape = createNodeShape(currentNodeId, newSize);
         nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
         const styles = resolveStylesForNode(currentNodeId);
         if (styles.circleColor) newShape.style.fill = styles.circleColor;
      if (styles.circleBorder) newShape.style.stroke = styles.circleBorder;
         const label = nodeGroup.querySelector(".node-label");
         const sub = nodeGroup.querySelector(".node-sub");
         if (label) {
          label.setAttribute("y", -newSize * 0.28);
          const labelSize = styles.titleSize || newSize * 0.33;
          label.style.fontSize = labelSize + "px";
         }
         if (sub) {
          sub.setAttribute("y", newSize * 0.4);
          const subSize = styles.subSize || newSize * 0.24;
          sub.style.fontSize = subSize + "px";
         }
       updatePingIndicator(currentNodeId);
        }
       });
       resetSizeBtn.addEventListener("click", () => {
        pushUndo("reset size");
        delete savedSizes[currentNodeId];
        const defaultSize = getDefaultSize();
        sizeSlider.value = defaultSize;
        sizeValue.textContent = defaultSize;
        const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
        if (nodeGroup) {
         const oldShape = nodeGroup.querySelector(".node-circle");
         if (oldShape) oldShape.remove();
         const shapeType = (NODE_DATA[currentNodeId] && NODE_DATA[currentNodeId].shape) || "circle";
         const newShape = createNodeShape(currentNodeId, defaultSize);
         nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
         const styles = resolveStylesForNode(currentNodeId);
         if (styles.circleColor) newShape.style.fill = styles.circleColor;
      if (styles.circleBorder) newShape.style.stroke = styles.circleBorder;
         const label = nodeGroup.querySelector(".node-label");
         const sub = nodeGroup.querySelector(".node-sub");
         if (label) {
          label.setAttribute("y", -defaultSize * 0.28);
          const labelSize = styles.titleSize || defaultSize * 0.33;
          label.style.fontSize = labelSize + "px";
         }
         if (sub) {
          sub.setAttribute("y", defaultSize * 0.4);
          const subSize = styles.subSize || defaultSize * 0.24;
          sub.style.fontSize = subSize + "px";
         }
          updatePingIndicator(currentNodeId);
        }
       });
       const applyStyle = (property, value) => {
        pushUndo("style change");
        const styleEntry = ensureStyleEntry(currentNodeId);
        const scopeKey = currentStyleScope || "all";
        if (!styleEntry[scopeKey]) styleEntry[scopeKey] = {};
        styleEntry[scopeKey][property] = value;
        const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
        if (!nodeGroup) return;
        const shapeEl = nodeGroup.querySelector(".node-circle");
        const label = nodeGroup.querySelector(".node-label");
        const sub = nodeGroup.querySelector(".node-sub");
        const isWebIcon = shapeEl && shapeEl.querySelector('svg');
        if (property === "circleColor" && shapeEl) {
         if (isWebIcon) {
          shapeEl.querySelectorAll('svg, path, circle, rect, polygon, ellipse').forEach(el => el.style.fill = value);
         } else {
          shapeEl.style.fill = value;
         }
        } else if (property === "circleBorder" && shapeEl) {
         if (isWebIcon) {
          shapeEl.querySelectorAll('svg, path, circle, rect, polygon, ellipse').forEach(el => el.style.stroke = value);
         } else {
          shapeEl.style.stroke = value;
         }
        } else if (property === "titleColor" && label) label.style.fill = value;
        else if (property === "titleFont" && label) label.style.fontFamily = value;
        else if (property === "titleSize" && label) label.style.fontSize = value + "px";
        else if (property === "subColor" && sub) sub.style.fill = value;
        else if (property === "subFont" && sub) sub.style.fontFamily = value;
        else if (property === "subSize" && sub) sub.style.fontSize = value + "px";
       };
       document.getElementById("circle-color").addEventListener("input", (e) => applyStyle("circleColor", e.target.value), );
      document.getElementById("circle-border").addEventListener("input", (e) => applyStyle("circleBorder", e.target.value), );
       document.getElementById("title-color").addEventListener("input", (e) => applyStyle("titleColor", e.target.value), );
       document.getElementById("title-font").addEventListener("change", (e) => applyStyle("titleFont", e.target.value), );
       document.getElementById("title-size").addEventListener("input", (e) => applyStyle("titleSize", parseInt(e.target.value, 10)), );
       document.getElementById("sub-color").addEventListener("input", (e) => applyStyle("subColor", e.target.value), );
       document.getElementById("sub-font").addEventListener("change", (e) => applyStyle("subFont", e.target.value), );
       document.getElementById("sub-size").addEventListener("input", (e) => applyStyle("subSize", parseInt(e.target.value, 10)), );
       document.getElementById("title-offset-y").addEventListener("input", (e) => {
        applyStyle("titleOffsetY", parseInt(e.target.value, 10) || 0);
        forgeTheTopology();
        if (currentNodeId) claimTheImmortal(currentNodeId);
       });
       document.getElementById("title-offset-x").addEventListener("input", (e) => {
        applyStyle("titleOffsetX", parseInt(e.target.value, 10) || 0);
        forgeTheTopology();
        if (currentNodeId) claimTheImmortal(currentNodeId);
       });
       document.getElementById("sub-offset-y").addEventListener("input", (e) => {
        applyStyle("subOffsetY", parseInt(e.target.value, 10) || 0);
        forgeTheTopology();
        if (currentNodeId) claimTheImmortal(currentNodeId);
       });
       document.getElementById("sub-offset-x").addEventListener("input", (e) => {
        applyStyle("subOffsetX", parseInt(e.target.value, 10) || 0);
        forgeTheTopology();
        if (currentNodeId) claimTheImmortal(currentNodeId);
       });
      document.getElementById("ping-offset-x").addEventListener("input", (e) => {
      applyStyle("pingOffsetX", parseInt(e.target.value, 10) || 0);
      updatePingIndicator(currentNodeId);
      if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      document.getElementById("ping-offset-y").addEventListener("input", (e) => {
      applyStyle("pingOffsetY", parseInt(e.target.value, 10) || 0);
      updatePingIndicator(currentNodeId);
      if (currentNodeId) claimTheImmortal(currentNodeId);
      });
       document.getElementById("reset-styles").addEventListener("click", () => {
        delete savedStyles[currentNodeId];
        forgeTheTopology();
        claimTheImmortal(currentNodeId);
       });
       document.getElementById("style-scope").addEventListener("change", (e) => {
        currentStyleScope = e.target.value || "all";
        claimTheImmortal(currentNodeId);
       });
       document.getElementById("shape-select").addEventListener("change", (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId]) return;
        const shape = e.target.value || "circle";
        if (shape === 'custom-icon') return;
        pushUndo("change shape");
        NODE_DATA[currentNodeId].shape = shape;
        if (savedStyles[currentNodeId]) {
         Object.keys(savedStyles[currentNodeId]).forEach(scope => {
          if (savedStyles[currentNodeId][scope] && savedStyles[currentNodeId][scope].icon) {
           delete savedStyles[currentNodeId][scope].icon;
          }
         });
        }
        const customOpt = e.target.querySelector('option[value="custom-icon"]');
        if (customOpt) customOpt.remove();
        forgeTheTopology();
       });
       const addNoteBtn = document.getElementById("add-note-btn");
       const noteInput = document.getElementById("new-note-input");
       addNoteBtn.addEventListener("click", () => {
        const newNote = noteInput.value.trim();
        if (newNote && currentNodeId && NODE_DATA[currentNodeId]) {
         pushUndo("add note");
         NODE_DATA[currentNodeId].notes.push(newNote);
         claimTheImmortal(currentNodeId);
         noteInput.value = "";
        }
       });
       noteInput.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
         addNoteBtn.click();
        }
       });
       document.getElementById('node-pingable').addEventListener('change', (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId]) return;
        if (!NODE_DATA[currentNodeId].ping) {
         NODE_DATA[currentNodeId].ping = {
          enabled: false,
          protocol: 'http',
          customUrl: '',
          timeout: 3000,
          status: 'unknown',
          lastCheck: null
         };
        }
        NODE_DATA[currentNodeId].ping.enabled = e.target.checked;
        document.getElementById('node-ping-options').style.display = e.target.checked ? 'block' : 'none';
        forgeTheTopology();
       });
       document.getElementById('node-ping-protocol').addEventListener('change', (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId].ping) return;
        NODE_DATA[currentNodeId].ping.protocol = e.target.value;
        document.getElementById('node-custom-url-container').style.display =
         e.target.value === 'custom' ? 'block' : 'none';
       });
       document.getElementById('node-custom-url').addEventListener('change', (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId].ping) return;
        NODE_DATA[currentNodeId].ping.customUrl = e.target.value.trim();
       });
       document.getElementById('node-ping-timeout').addEventListener('change', (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId].ping) return;
        NODE_DATA[currentNodeId].ping.timeout = parseInt(e.target.value) || 3000;
       });
       document.getElementById('check-ping-now').addEventListener('click', () => {
        if (!currentNodeId) return;
        checkNodeStatus(currentNodeId);
       });
       document.getElementById("edge-width").addEventListener("input", () => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        const v = parseInt(document.getElementById("edge-width").value, 10);
        if (Number.isNaN(v) || v <= 0) return;
        pushUndo("edit edge");
        edge.width = v;
        const el = document.querySelector(`.edge[data-edge-id="${currentEdgeId}"]`, );
        if (el) el.style.strokeWidth = v;
       });
       document.getElementById("edge-color").addEventListener("input", () => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        const color = document.getElementById("edge-color").value;
        pushUndo("edit edge");
        edge.color = color;
        const el = document.querySelector(`.edge[data-edge-id="${currentEdgeId}"]`, );
        if (el) el.style.stroke = color;
        forgeTheLegend();
       });
       document.getElementById("edge-direction").addEventListener("change", () => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        pushUndo("edit edge");
        edge.direction = document.getElementById("edge-direction").value;
        forgeTheTopology();
        selectTheConnection(currentEdgeId);
       });
       document.getElementById("edge-line-style").addEventListener("change", () => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        pushUndo("edit edge");
        edge.lineStyle = document.getElementById("edge-line-style").value;
        forgeTheTopology();
        selectTheConnection(currentEdgeId);
       });
       const addEdgeNoteBtn = document.getElementById("add-edge-note");
       const newEdgeNoteInput = document.getElementById("new-edge-note");
       addEdgeNoteBtn.addEventListener("click", () => {
        const txt = newEdgeNoteInput.value.trim();
        if (!txt || !currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
		pushUndo("add edge note");
        edge.notes.push(txt);
        newEdgeNoteInput.value = "";
        selectTheConnection(currentEdgeId);
       });
       newEdgeNoteInput.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
         addEdgeNoteBtn.click();
        }
       });
      function selectTheRect(id) {
	  if (isViewOnly()) return;
      currentRectId = id;
      currentNodeId = null;
      currentEdgeId = null;
      currentTextId = null;
      document.getElementById("node-panel").style.display = "none";
      document.getElementById("edge-panel").style.display = "none";
      document.getElementById("text-panel").style.display = "none";
      document.getElementById("rect-panel").style.display = "block";
      document.getElementById("topology-toolbar").style.display = "none";
      document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active"));
      document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
      document.querySelectorAll(".text-element").forEach(t => t.classList.remove("active"));
      document.querySelectorAll(".rect-group").forEach(r => r.classList.toggle("active", r.dataset.rectId === id));
      const rect = RECT_DATA.list.find(r => r.id === id);
      if (!rect) return;
      document.getElementById("rect-title").textContent = "";
      document.getElementById("rect-color").value = rect.color || "#f97316";
      document.getElementById("rect-border-color").value = rect.borderColor || rect.color || "#f97316";
      document.getElementById("rect-border-width").value = rect.borderWidth !== undefined ? rect.borderWidth : 2;
      document.getElementById("rect-style-select").value = rect.style || "filled";
      document.getElementById("rect-line-style").value = rect.lineStyle || "solid";
      document.getElementById("rect-fill-row").style.display = (rect.style === "outlined") ? "none" : "flex";
      const list = document.getElementById("rect-notes");
      list.innerHTML = "";
      (rect.notes || []).forEach((note, i) => {
      const li = document.createElement("li");
      const txt = document.createElement("span");
      txt.textContent = note;
      txt.style.flex = "1";
      const del = document.createElement("span");
      del.className = "delete-note";
      del.textContent = "‚úï";
      del.addEventListener("click", (e) => {
      e.stopPropagation();
      challengeTheImmortal("Delete this note?", () => {
        pushUndo("delete zone note");
        rect.notes.splice(i, 1);
        selectTheRect(id);
      });
      });
      li.appendChild(txt);
      li.appendChild(del);
      list.appendChild(li);
      });
      forgeTheTopology();
      }
      document.getElementById("rect-color").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.color = document.getElementById("rect-color").value;
      forgeTheTopology();
      });
      document.getElementById("rect-border-color").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.borderColor = document.getElementById("rect-border-color").value;
      forgeTheTopology();
      });
      document.getElementById("rect-border-width").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.borderWidth = parseInt(document.getElementById("rect-border-width").value) || 2;
      forgeTheTopology();
      });
      document.getElementById("rect-style-select").addEventListener("change", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.style = document.getElementById("rect-style-select").value;
      forgeTheTopology();
      selectTheRect(currentRectId);
      });
	  document.getElementById("rect-line-style").addEventListener("change", () => {
      if (!currentRectId) return;
      pushUndo("change zone line style");
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      rect.lineStyle = document.getElementById("rect-line-style").value;
      forgeTheTopology();
      });
      document.getElementById("add-rect-note").addEventListener("click", () => {
      const input = document.getElementById("new-rect-note");
      const txt = input.value.trim();
      if (!txt || !currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      if (!rect.notes) rect.notes = [];
	  pushUndo("add zone note");
      rect.notes.push(txt);
      input.value = "";
      selectTheRect(currentRectId);
      });
      document.getElementById("new-rect-note").addEventListener("keypress", (e) => {
      if (e.key === "Enter") {
      document.getElementById("add-rect-note").click();
      }
      });
      document.getElementById("delete-rect").addEventListener("click", () => {
      if (!currentRectId) return;
      challengeTheImmortal("Delete this box?", () => {
      pushUndo("delete zone");
      RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== currentRectId);
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      });
      });
       document.getElementById("delete-edge").addEventListener("click", () => {
        if (!currentEdgeId) return;
        challengeTheImmortal("Are you sure you want to delete this line?",
         () => {
          pushUndo("delete edge");
          EDGE_DATA.list = EDGE_DATA.list.filter(
           (e) => e.id !== currentEdgeId, );
          currentEdgeId = null;
          forgeTheTopology();
          const availableNodes = Object.keys(NODE_DATA);
          if (availableNodes.length > 0) {
           claimTheImmortal(availableNodes[0]);
          } else {
           document.getElementById("node-panel").style.display = "none";
           document.getElementById("edge-panel").style.display = "none";
           document.getElementById("topology-toolbar", ).style.display = "none";
          }
         }, );
       });
       document.getElementById("add-line-btn").addEventListener("click", () => {
        if (!currentNodeId) return;
        const select = document.getElementById("add-line-select");
        const directionSelect = document.getElementById("add-line-direction");
        const colorInput = document.getElementById("add-line-color");
        const targetId = select.value;
        if (!targetId || targetId === currentNodeId) return;
        const direction = directionSelect.value || "none";
        const lineColor = colorInput.value || "#475569";
        const newId = `${currentNodeId}-${targetId}-${Date.now()}`;
        const newEdge = {
         id: newId,
         from: currentNodeId,
         to: targetId,
         width: 4,
         color: lineColor,
         direction: direction,
         type: "main",
         notes: [],
         fromPort: "",
         toPort: "",
        };
		pushUndo("add edge");
        EDGE_DATA.list.push(newEdge);
        forgeTheTopology();
        claimTheImmortal(currentNodeId);
       });
       let rectStartPoint = null;
       let rectPreviewEl = null;
       let rectStyle = "filled";
       let freeDrawPoints = [];
       let freeDrawPolylineEl = null;
       let freeDrawPointEls = [];
       const drawToggleBtn = document.getElementById("draw-toggle");
       const drawUndoBtn = document.getElementById("draw-undo");
       const drawColorInput = document.getElementById("draw-color");
       const drawStyleSelect = document.getElementById("draw-style");
       const drawArrowSelect = document.getElementById("draw-arrow");
       const svgMap = document.getElementById("map");
       function updateFreeDrawGraphics() {
        const ns = "http://www.w3.org/2000/svg";
        const svg = svgMap;
        if (!freeDrawPolylineEl && freeDrawPoints.length > 0) {
         freeDrawPolylineEl = document.createElementNS(ns, "polyline");
         freeDrawPolylineEl.classList.add("edge", "free-preview");
         freeDrawPolylineEl.setAttribute("fill", "none");
         svg.appendChild(freeDrawPolylineEl);
        }
        if (freeDrawPolylineEl) {
         if (freeDrawPoints.length === 0) {
          freeDrawPolylineEl.remove();
          freeDrawPolylineEl = null;
         } else {
          const ptsStr = freeDrawPoints.map((p) => `${p.x},${p.y}`).join(" ");
          freeDrawPolylineEl.setAttribute("points", ptsStr);
          freeDrawPolylineEl.style.stroke = drawColorInput.value || "#475569";
          freeDrawPolylineEl.style.strokeWidth = 3;
          const lineStyle = drawStyleSelect.value || "solid";
          if (lineStyle === "dashed") {
           freeDrawPolylineEl.style.strokeDasharray = "10,5";
          } else if (lineStyle === "dotted") {
           freeDrawPolylineEl.style.strokeDasharray = "2,4";
          } else {
           freeDrawPolylineEl.style.strokeDasharray = "none";
          }
         }
        }
        freeDrawPointEls.forEach((el) => el.remove());
        freeDrawPointEls = [];
        freeDrawPoints.forEach((p, idx) => {
         const c = document.createElementNS(ns, "circle");
         c.classList.add("free-point");
         c.setAttribute("cx", p.x);
         c.setAttribute("cy", p.y);
         c.setAttribute("r", 5);
         c.dataset.index = String(idx);
         c.addEventListener("mousedown", (e) => {
          if (!freeDrawMode) return;
          e.preventDefault();
          e.stopPropagation();
          let dragging = true;
          const svgEl = svgMap;
          const moveHandler = (ev) => {
           if (!dragging) return;
           const pt = svgEl.createSVGPoint();
           pt.x = ev.clientX;
           pt.y = ev.clientY;
           const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
           const i = parseInt(c.dataset.index, 10);
           if (Number.isNaN(i) || !freeDrawPoints[i]) return;
           freeDrawPoints[i].x = svgP.x;
           freeDrawPoints[i].y = svgP.y;
           updateFreeDrawGraphics();
          };
          const upHandler = () => {
           dragging = false;
           document.removeEventListener("mousemove", moveHandler);
           document.removeEventListener("mouseup", upHandler);
          };
          document.addEventListener("mousemove", moveHandler);
          document.addEventListener("mouseup", upHandler);
         });
         c.addEventListener("touchstart",
          (e) => {
           if (!freeDrawMode) return;
           e.preventDefault();
           e.stopPropagation();
           let dragging = true;
           const svgEl = svgMap;
           const touchMoveHandler = (ev) => {
            if (!dragging || !ev.touches[0]) return;
            const pt = svgEl.createSVGPoint();
            pt.x = ev.touches[0].clientX;
            pt.y = ev.touches[0].clientY;
            const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
            const i = parseInt(c.dataset.index, 10);
            if (Number.isNaN(i) || !freeDrawPoints[i]) return;
            freeDrawPoints[i].x = svgP.x;
            freeDrawPoints[i].y = svgP.y;
            updateFreeDrawGraphics();
           };
           const touchUpHandler = () => {
            dragging = false;
            document.removeEventListener("touchmove", touchMoveHandler, );
            document.removeEventListener("touchend", touchUpHandler, );
           };
           document.addEventListener("touchmove", touchMoveHandler);
           document.addEventListener("touchend", touchUpHandler);
          }, {
           passive: false
          }, );
         svg.appendChild(c);
         freeDrawPointEls.push(c);
        });
        drawUndoBtn.style.display = freeDrawPoints.length ? "inline-block" : "none";
       }
       function addFreeDrawPoint(x, y) {
        freeDrawPoints.push({
         x,
         y
        });
        updateFreeDrawGraphics();
       }
       function startFreeDraw() {
        freeDrawMode = true;
        freeDrawPoints = [];
        if (freeDrawPolylineEl) {
         freeDrawPolylineEl.remove();
         freeDrawPolylineEl = null;
        }
        freeDrawPointEls.forEach((el) => el.remove());
        freeDrawPointEls = [];
        svgMap.style.cursor = "crosshair";
        drawToggleBtn.textContent = "Done";
        drawUndoBtn.style.display = "none";
       }
       function finishFreeDraw() {
        freeDrawMode = false;
        svgMap.style.cursor = "";
        drawToggleBtn.textContent = "‚úèÔ∏è";
        if (freeDrawPoints.length >= 2) {
         const color = drawColorInput.value || "#475569";
         const lineStyle = drawStyleSelect.value || "solid";
         const arrowDir = drawArrowSelect.value || "none";
         const newId = "custom-" + Date.now();
         const pointsCopy = freeDrawPoints.map((p) => ({
          x: p.x,
          y: p.y,
         }));
         EDGE_DATA.list.push({
          id: newId,
          type: "custom",
          color,
          width: 4,
          lineStyle: lineStyle,
          direction: arrowDir,
          points: pointsCopy,
          notes: [],
         });
         freeDrawPoints = [];
         if (freeDrawPolylineEl) {
          freeDrawPolylineEl.remove();
          freeDrawPolylineEl = null;
         }
         freeDrawPointEls.forEach((el) => el.remove());
         freeDrawPointEls = [];
         forgeTheTopology();
         selectTheConnection(newId);
        } else {
         freeDrawPoints = [];
         if (freeDrawPolylineEl) {
          freeDrawPolylineEl.remove();
          freeDrawPolylineEl = null;
         }
         freeDrawPointEls.forEach((el) => el.remove());
         freeDrawPointEls = [];
         forgeTheLegend();
        }
        drawUndoBtn.style.display = "none";
       }
       drawToggleBtn.addEventListener("click", () => {
        if (currentView.mode === "rack") {
         alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
         return;
        }
        if (freeDrawMode) {
         finishFreeDraw();
        } else {
         startFreeDraw();
        }
       });
       drawUndoBtn.addEventListener("click", () => {
        if (!freeDrawMode || !freeDrawPoints.length) return;
        freeDrawPoints.pop();
        updateFreeDrawGraphics();
       });
       const drawToolbar = document.getElementById("draw-toolbar");
       drawToolbar.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       drawToolbar.addEventListener("click", (e) => {
        if (e.target !== drawToggleBtn && e.target !== drawUndoBtn) {
         e.stopPropagation();
        }
       });
       drawStyleSelect.addEventListener("change", () => {
        if (freeDrawMode) {
         updateFreeDrawGraphics();
        }
       });
       drawArrowSelect.addEventListener("change", () => {
        if (freeDrawMode) {
         updateFreeDrawGraphics();
        }
       });
       drawColorInput.addEventListener("input", () => {
        if (freeDrawMode) {
         updateFreeDrawGraphics();
        }
       });
       drawStyleSelect.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       drawStyleSelect.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       drawArrowSelect.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       drawArrowSelect.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       drawColorInput.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       drawColorInput.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       svgMap.addEventListener("click", (e) => {
        if (!freeDrawMode) return;
        if (e.button !== 0) return;
        const target = e.target;
        if (target && target.classList && target.classList.contains("free-point")) return;
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        addFreeDrawPoint(svgP.x, svgP.y);
       });
       svgMap.addEventListener("touchend",
        (e) => {
         if (!freeDrawMode) return;
         const target = e.target;
         if (target && target.classList && target.classList.contains("free-point")) return;
         if (e.changedTouches && e.changedTouches[0]) {
          e.preventDefault();
          const svgEl = svgMap;
          const pt = svgEl.createSVGPoint();
          pt.x = e.changedTouches[0].clientX;
          pt.y = e.changedTouches[0].clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          addFreeDrawPoint(svgP.x, svgP.y);
         }
        }, {
         passive: false
        }, );
       const settingsBtn = document.getElementById("settings-btn");
       const rectToggleBtn = document.getElementById("rect-toggle");
       const rectStyleSelect = document.getElementById("rect-style");
       function updateRectPreview() {
        if (!rectPreviewEl || !rectStartPoint) return;
        const ns = "http://www.w3.org/2000/svg";
        const svg = svgMap;
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
       }
       function startRectDraw() {
        rectDrawMode = true;
        rectStartPoint = null;
        rectPreviewEl = null;
        svgMap.style.cursor = "crosshair";
        rectToggleBtn.textContent = "Done";
        rectStyle = rectStyleSelect.value || "filled";
        if (freeDrawMode) {
         finishFreeDraw();
        }
        updateRectangleDeleteButtons();
       }
       function finishRectDraw() {
        rectDrawMode = false;
        svgMap.style.cursor = "";
        rectToggleBtn.textContent = "‚ñ≠";
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
		updateRectangleDeleteButtons();
       }
       rectToggleBtn.addEventListener("click", () => {
        if (currentView.mode === "rack") {
         alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
         return;
        }
        if (rectDrawMode) {
         finishRectDraw();
        } else {
         startRectDraw();
        }
       });
       rectStyleSelect.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       rectStyleSelect.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       rectStyleSelect.addEventListener("change", () => {
        if (rectDrawMode) {
         rectStyle = rectStyleSelect.value || "filled";
        }
       });
       svgMap.addEventListener("mousedown", (e) => {
        if (!rectDrawMode) return;
        if (e.button !== 0) return;
        e.preventDefault();
        e.stopPropagation();
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        rectStartPoint = { x: svgP.x, y: svgP.y };
        const ns = "http://www.w3.org/2000/svg";
        rectPreviewEl = document.createElementNS(ns, "rect");
        rectPreviewEl.classList.add("rect-preview");
        rectPreviewEl.setAttribute("x", svgP.x);
        rectPreviewEl.setAttribute("y", svgP.y);
        rectPreviewEl.setAttribute("width", 0);
        rectPreviewEl.setAttribute("height", 0);
        const color = drawColorInput.value || "#f97316";
        rectPreviewEl.style.stroke = color;
        rectPreviewEl.style.strokeWidth = 2;
        rectPreviewEl.style.strokeDasharray = "5,5";
        if (rectStyle === "filled") {
         rectPreviewEl.style.fill = color;
         rectPreviewEl.style.fillOpacity = "0.3";
        } else {
         rectPreviewEl.style.fill = "none";
        }
        svgEl.appendChild(rectPreviewEl);
       });
       svgMap.addEventListener("mousemove", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        rectPreviewEl.setAttribute("x", x);
        rectPreviewEl.setAttribute("y", y);
        rectPreviewEl.setAttribute("width", width);
        rectPreviewEl.setAttribute("height", height);
       });
       svgMap.addEventListener("mouseup", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        if (width > 10 && height > 10) {
      pushUndo("draw zone");
         const color = drawColorInput.value || "#f97316";
         const newId = "rect-" + Date.now();
         const lineStyle = document.getElementById("draw-style").value || "solid";
         RECT_DATA.list.push({
          id: newId,
          x: x,
          y: y,
          width: width,
          height: height,
          color: color,
          style: rectStyle,
          lineStyle: lineStyle,
          notes: []
         });
         forgeTheTopology();
        }
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
       });
       let rectTouchStart = null;
       svgMap.addEventListener("touchstart", (e) => {
        if (!rectDrawMode) return;
        if (e.touches.length !== 1) return;
        e.preventDefault();
        const touch = e.touches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        rectStartPoint = { x: svgP.x, y: svgP.y };
        rectTouchStart = { x: svgP.x, y: svgP.y };
        const ns = "http://www.w3.org/2000/svg";
        rectPreviewEl = document.createElementNS(ns, "rect");
        rectPreviewEl.classList.add("rect-preview");
        rectPreviewEl.setAttribute("x", svgP.x);
        rectPreviewEl.setAttribute("y", svgP.y);
        rectPreviewEl.setAttribute("width", 0);
        rectPreviewEl.setAttribute("height", 0);
        const color = drawColorInput.value || "#f97316";
        rectPreviewEl.style.stroke = color;
        rectPreviewEl.style.strokeWidth = 2;
        rectPreviewEl.style.strokeDasharray = "5,5";
        if (rectStyle === "filled") {
         rectPreviewEl.style.fill = color;
         rectPreviewEl.style.fillOpacity = "0.3";
        } else {
         rectPreviewEl.style.fill = "none";
        }
        svgEl.appendChild(rectPreviewEl);
       }, { passive: false });
       svgMap.addEventListener("touchmove", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        if (e.touches.length !== 1) return;
        e.preventDefault();
        const touch = e.touches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        rectPreviewEl.setAttribute("x", x);
        rectPreviewEl.setAttribute("y", y);
        rectPreviewEl.setAttribute("width", width);
        rectPreviewEl.setAttribute("height", height);
       }, { passive: false });
       svgMap.addEventListener("touchend", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        if (!rectTouchStart) return;
        e.preventDefault();
        const touch = e.changedTouches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        if (width > 10 && height > 10) {
      pushUndo("draw zone");
         const color = drawColorInput.value || "#f97316";
         const newId = "rect-" + Date.now();
         const lineStyle = document.getElementById("draw-style").value || "solid";
         RECT_DATA.list.push({
          id: newId,
          x: x,
          y: y,
          width: width,
          height: height,
          color: color,
          style: rectStyle,
          lineStyle: lineStyle,
          notes: []
         });
         forgeTheTopology();
        }
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
        rectTouchStart = null;
       }, { passive: false });
       const textToggleBtn = document.getElementById("text-toggle");
       function startTextMode() {
        textDrawMode = true;
        svgMap.style.cursor = "crosshair";
        textToggleBtn.textContent = "Done";
        textToggleBtn.style.background = "var(--accent)";
        textToggleBtn.style.color = "var(--bg)";
        if (freeDrawMode) {
         finishFreeDraw();
        }
        if (rectDrawMode) {
         finishRectDraw();
        }
        updateTextDeleteButtons();
       }
       function finishTextMode() {
        textDrawMode = false;
        svgMap.style.cursor = "";
        textToggleBtn.textContent = "T";
        textToggleBtn.style.background = "";
        textToggleBtn.style.color = "";
        updateTextDeleteButtons();
       }
       textToggleBtn.addEventListener("click", () => {
        if (currentView.mode === "rack") {
         alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
         return;
        }
        if (textDrawMode) {
         finishTextMode();
        } else {
         startTextMode();
        }
       });
       function handleTextPlacement(e) {
        if (!textDrawMode) return;
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const newId = "text-" + Date.now();
      pushUndo("add text");
        TEXT_DATA.list.push({
         id: newId,
         x: svgP.x,
         y: svgP.y,
         content: "New Text",
         fontSize: 18,
         color: "#e2e8f0",
         fontWeight: "normal",
         fontStyle: "normal",
         textAlign: "start",
         textDecoration: "none",
         bgColor: "#000000",
         bgEnabled: false,
         opacity: 1
        });
        forgeTheTopology();
        showTextPanel(newId);
       }
       svgMap.addEventListener("click", (e) => {
        if (!textDrawMode) return;
        if (e.target.closest('.text-delete-btn')) return;
        if (e.target.closest('.text-group')) return;
        e.preventDefault();
        e.stopPropagation();
        handleTextPlacement(e);
       });
       svgMap.addEventListener("touchend", (e) => {
        if (!textDrawMode) return;
        if (e.target.closest('.text-delete-btn')) return;
        if (e.target.closest('.text-group')) return;
        if (e.touches.length > 0) return;
        e.preventDefault();
        const touch = e.changedTouches[0];
        const fakeEvent = {
         clientX: touch.clientX,
         clientY: touch.clientY,
         preventDefault: () => {},
         stopPropagation: () => {}
        };
        handleTextPlacement(fakeEvent);
       }, { passive: false });
       function showTextPanel(textId) {
	   if (isViewOnly()) return;
       currentTextId = textId;
       currentNodeId = null;
       currentEdgeId = null;
       currentRectId = null;
       const textItem = TEXT_DATA.list.find(t => t.id === textId);
       if (!textItem) return;
       document.getElementById("node-panel").style.display = "none";
       document.getElementById("edge-panel").style.display = "none";
       document.getElementById("rect-panel").style.display = "none";
       const textPanel = document.getElementById("text-panel");
       textPanel.style.display = "block";
       document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active"));
       document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
       document.querySelectorAll(".rect-group").forEach(r => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach(t => t.classList.toggle("active", t.dataset.textId === textId));
        document.getElementById("text-content").value = textItem.content;
        document.getElementById("text-font-size").value = textItem.fontSize;
        document.getElementById("text-color").value = textItem.color;
        document.getElementById("text-font-weight").value = textItem.fontWeight;
        document.getElementById("text-font-style").value = textItem.fontStyle;
        document.getElementById("text-align").value = textItem.textAlign;
        document.getElementById("text-decoration").value = textItem.textDecoration;
        document.getElementById("text-bg-color").value = textItem.bgColor;
        document.getElementById("text-bg-enabled").checked = textItem.bgEnabled;
        document.getElementById("text-opacity").value = textItem.opacity;
        document.getElementById("text-opacity-val").textContent = Math.round(textItem.opacity * 100) + "%";
       }
       function updateTextDeleteButtons() {
        const deleteButtons = document.querySelectorAll('.text-delete-btn');
        deleteButtons.forEach(btn => {
         btn.style.display = textDrawMode ? 'block' : 'none';
        });
       }
       function deleteText(textId) {
      pushUndo("delete text");
        TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== textId);
        forgeTheTopology();
        if (currentTextId === textId) {
         document.getElementById("text-panel").style.display = "none";
         currentTextId = null;
        }
       }
       document.getElementById("text-content").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
      pushUndo("edit text");
         textItem.content = e.target.value;
         forgeTheTopology();
        }
       });
       document.getElementById("text-font-size").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.fontSize = parseInt(e.target.value);
         forgeTheTopology();
        }
       });
       document.getElementById("text-color").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.color = e.target.value;
         forgeTheTopology();
        }
       });
       document.getElementById("text-font-weight").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.fontWeight = e.target.value;
         forgeTheTopology();
        }
       });
       document.getElementById("text-font-style").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.fontStyle = e.target.value;
         forgeTheTopology();
        }
       });
       document.getElementById("text-align").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.textAlign = e.target.value;
         forgeTheTopology();
        }
       });
        document.getElementById("text-decoration").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.textDecoration = e.target.value;
         forgeTheTopology();
        }
       });
       document.getElementById("text-bg-color").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.bgColor = e.target.value;
         forgeTheTopology();
        }
       });
       document.getElementById("text-bg-enabled").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.bgEnabled = e.target.checked;
         forgeTheTopology();
        }
       });
       document.getElementById("text-opacity").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.opacity = parseFloat(e.target.value);
         document.getElementById("text-opacity-val").textContent = Math.round(textItem.opacity * 100) + "%";
         forgeTheTopology();
        }
       });
       document.getElementById("delete-text").addEventListener("click", () => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         challengeTheImmortal(`Delete text "${textItem.content.substring(0, 30)}..."?`, () => {
          deleteText(currentTextId);
         });
        }
       });
       const settingsModal = document.getElementById("settings-modal");
       const settingsClose = document.getElementById("settings-close");
       settingsBtn.addEventListener("click", () => {
       document.getElementById("page-bg-color").value = rgbaToHex(PAGE_STATE.background) || "#050608";
       document.getElementById("topbar-bg-color").value = rgbaToHex(PAGE_STATE.topbarBg) || "#0b0e13";
       document.getElementById("topbar-border-color").value = rgbaToHex(PAGE_STATE.topbarBorder) || "#1f2533";
       document.getElementById("panel-color").value = rgbaToHex(PAGE_STATE.panel) || "#0b0e13";
       document.getElementById("panel-alt-color").value = PAGE_STATE.panelAlt || "#10141b";
       document.getElementById("sidebar-bg-color").value = PAGE_STATE.sidebarBg || "#10141b";
       document.getElementById("btn-bg-color").value = PAGE_STATE.btnBg || "#0b0e13";
       document.getElementById("btn-text-color").value = PAGE_STATE.btnText || "#e2e8f0";
       document.getElementById("tag-fill-color").value = PAGE_STATE.tagFill || "#1e293b";
       document.getElementById("tag-text-color").value = PAGE_STATE.tagText || "#e2e8f0";
       document.getElementById("tag-border-color").value = PAGE_STATE.tagBorder || "#475569";
       document.getElementById("input-bg-color").value = PAGE_STATE.inputBg || "#0b0e13";
       document.getElementById("input-text-color").value = PAGE_STATE.inputText || "#e2e8f0";
	   document.getElementById("input-border-color").value = PAGE_STATE.inputBorder || "#1f2937";
       document.getElementById("input-font-family").value = PAGE_STATE.inputFont || "Inter, system-ui, sans-serif";
       document.getElementById("input-font-size").value = PAGE_STATE.inputFontSize || 14;
       document.getElementById("toolbar-bg-color").value = PAGE_STATE.toolbarBg || "#0f172a";
       document.getElementById("toolbar-border-color").value = PAGE_STATE.toolbarBorder || "#1f2937";
       document.getElementById("toolbar-text-color").value = PAGE_STATE.toolbarText || "#94a3b8";
       document.getElementById("toolbar-btn-bg-color").value = PAGE_STATE.toolbarBtnBg || "#0b0e13";
       document.getElementById("toolbar-btn-text-color").value = PAGE_STATE.toolbarBtnText || "#e2e8f0";
       document.getElementById("minimap-dots-color").value = PAGE_STATE.minimapDots || "#94a3b8";
       document.getElementById("canvas-hint-enabled").checked = PAGE_STATE.canvasHintEnabled !== false;
       document.getElementById("canvas-hint-bg-color").value = PAGE_STATE.canvasHintBg || "#0f172a";
       document.getElementById("canvas-hint-text-color").value = PAGE_STATE.canvasHintColor || "#94a3b8";
       document.getElementById("canvas-hint-text").value = PAGE_STATE.canvasHintText || "";
       document.getElementById("accent-color").value = rgbaToHex(PAGE_STATE.accent) || "#4fd1c5";
       document.getElementById("danger-color").value = rgbaToHex(PAGE_STATE.danger) || "#f56565";
       document.getElementById("text-main-color").value = rgbaToHex(PAGE_STATE.textMain) || "#e2e8f0";
       document.getElementById("text-soft-color").value = PAGE_STATE.textSoft || "#94a3b8";
       document.getElementById("node-fill-color").value = PAGE_STATE.nodeFill || "#1e293b";
       document.getElementById("node-stroke-color").value = PAGE_STATE.nodeStroke || "#475569";
       document.getElementById("node-title-color").value = PAGE_STATE.nodeTitle || "#e2e8f0";
       document.getElementById("node-sub-color").value = PAGE_STATE.nodeSub || "#94a3b8";
       document.getElementById("node-title-size").value = PAGE_STATE.nodeTitleSize || 18;
       document.getElementById("node-sub-size").value = PAGE_STATE.nodeSubSize || 13;
       document.getElementById("node-font-family").value = PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
       document.getElementById("default-edge-color").value = PAGE_STATE.defaultEdge || "#475569";
       document.getElementById("selection-handle-color").value = PAGE_STATE.selectionHandle || "#f59e0b";
       document.getElementById("selection-handle-size").value = PAGE_STATE.selectionHandleSize || 8;
       document.getElementById("group-indicator-color").value = PAGE_STATE.groupIndicator || "#4fd1c5";
       document.getElementById("canvas-gradient-top").value = PAGE_STATE.canvasGradientTop || "#1e2532";
       document.getElementById("canvas-gradient-bottom").value = PAGE_STATE.canvasGradientBottom || "#050608";
       document.getElementById("canvas-border-color").value = PAGE_STATE.canvasBorder || "#475569";
       document.getElementById("canvas-grid-color").value = PAGE_STATE.canvasGrid || "#475569";
       document.getElementById("canvas-grid-size").value = PAGE_STATE.canvasGridSize || 50;
       document.getElementById("rack-frame-fill").value = PAGE_STATE.rackFrameFill || "#0f172a";
       document.getElementById("rack-frame-stroke").value = PAGE_STATE.rackFrameStroke || "#4fd1c5";
       document.getElementById("rack-line-color").value = PAGE_STATE.rackLineColor || "#475569";
       document.getElementById("rack-text-color").value = PAGE_STATE.rackTextColor || "#4fd1c5";
        document.getElementById("auto-ping-enabled").checked = autoPingEnabled;
        document.getElementById("auto-ping-interval").value = autoPingInterval;
        document.getElementById("auto-ping-settings").style.display = autoPingEnabled ? 'block' : 'none';
        document.getElementById("view-only-mode").checked = PAGE_STATE.viewOnly === true;
        settingsModal.classList.add("active");
       });
       settingsClose.addEventListener("click", () => {
        settingsModal.classList.remove("active");
       });
	   document.getElementById("view-only-mode").addEventListener("change", (e) => {
       PAGE_STATE.viewOnly = e.target.checked;
       if (e.target.checked) {
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        document.getElementById("rect-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.setProperty('display', 'none', 'important');
        document.getElementById("draw-toolbar").style.setProperty('display', 'none', 'important');
        currentNodeId = null;
        currentEdgeId = null;
        currentRectId = null;
        currentTextId = null;
        selectedNodes.clear();
        selectedRects.clear();
        selectedTexts.clear();
        selectedEdges.clear();
        const bulkToolbar = document.getElementById("bulk-toolbar");
        const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active", "selected"));
        document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
        document.querySelectorAll(".rect-group").forEach(r => r.classList.remove("active"));
        document.querySelectorAll(".text-element").forEach(t => t.classList.remove("active"));
       }
       wieldThePower();
       if (!e.target.checked) {
        updateDrawToolbarVisibility();
        updateTopologyToolbarVisibility();
       }
       forgeTheTopology();
      });
       settingsModal.addEventListener("click", (e) => {
        if (e.target === settingsModal) {
         settingsModal.classList.remove("active");
        }
       });
       document.getElementById("page-bg-color").addEventListener("input", (e) => {
        PAGE_STATE.background = e.target.value;
        wieldThePower();
       });
       document.getElementById("topbar-bg-color").addEventListener("input", (e) => {
        PAGE_STATE.topbarBg = e.target.value;
        wieldThePower();
       });
       document.getElementById("topbar-border-color").addEventListener("input", (e) => {
        PAGE_STATE.topbarBorder = e.target.value;
        wieldThePower();
       });
       document.getElementById("panel-color").addEventListener("input", (e) => {
        PAGE_STATE.panel = e.target.value;
        wieldThePower();
       });
       document.getElementById("panel-alt-color").addEventListener("input", (e) => {
       PAGE_STATE.panelAlt = e.target.value;
       wieldThePower();
      });
      document.getElementById("sidebar-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.sidebarBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("btn-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.btnBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("btn-text-color").addEventListener("input", (e) => {
       PAGE_STATE.btnText = e.target.value;
       wieldThePower();
      });
      document.getElementById("tag-fill-color").addEventListener("input", (e) => {
       PAGE_STATE.tagFill = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("tag-text-color").addEventListener("input", (e) => {
       PAGE_STATE.tagText = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("tag-border-color").addEventListener("input", (e) => {
       PAGE_STATE.tagBorder = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("selection-fill-color").addEventListener("input", function() {
       selectionBoxStyle.fillColor = this.value;
      });
      document.getElementById("selection-fill-opacity").addEventListener("input", function() {
       selectionBoxStyle.fillOpacity = parseFloat(this.value);
       document.getElementById("selection-fill-opacity-val").textContent = Math.round(this.value * 100) + "%";
      });
      document.getElementById("selection-stroke-color").addEventListener("input", function() {
       selectionBoxStyle.strokeColor = this.value;
      });
      document.getElementById("selection-stroke-width").addEventListener("input", function() {
       selectionBoxStyle.strokeWidth = parseInt(this.value) || 2;
      });
      document.getElementById("selection-stroke-style").addEventListener("change", function() {
       selectionBoxStyle.strokeDasharray = this.value;
      });
      document.getElementById("input-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.inputBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-text-color").addEventListener("input", (e) => {
       PAGE_STATE.inputText = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-border-color").addEventListener("input", (e) => {
       PAGE_STATE.inputBorder = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-font-family").addEventListener("change", (e) => {
       PAGE_STATE.inputFont = e.target.value;
       wieldThePower();
      });
	  document.getElementById("input-font-size").addEventListener("input", (e) => {
       PAGE_STATE.inputFontSize = parseInt(e.target.value) || 14;
       wieldThePower();
      });
      document.getElementById("toolbar-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-border-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBorder = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-text-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarText = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-btn-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBtnBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-btn-text-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBtnText = e.target.value;
       wieldThePower();
      });
      document.getElementById("minimap-dots-color").addEventListener("input", (e) => {
       PAGE_STATE.minimapDots = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("canvas-hint-enabled").addEventListener("change", (e) => {
       PAGE_STATE.canvasHintEnabled = e.target.checked;
       wieldThePower();
      });
      document.getElementById("canvas-hint-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-hint-text-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintColor = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-hint-text").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintText = e.target.value;
       wieldThePower();
      });
       document.getElementById("accent-color").addEventListener("input", (e) => {
        PAGE_STATE.accent = e.target.value;
        wieldThePower();
       });
       document.getElementById("danger-color").addEventListener("input", (e) => {
        PAGE_STATE.danger = e.target.value;
        wieldThePower();
       });
       document.getElementById("text-main-color").addEventListener("input", (e) => {
        PAGE_STATE.textMain = e.target.value;
        wieldThePower();
       });
       document.getElementById("text-soft-color").addEventListener("input", (e) => {
       PAGE_STATE.textSoft = e.target.value;
       wieldThePower();
      });
      document.getElementById("node-fill-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeFill = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-stroke-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeStroke = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-title-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeTitle = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-sub-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeSub = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-title-size").addEventListener("input", (e) => {
       PAGE_STATE.nodeTitleSize = parseInt(e.target.value) || 18;
       forgeTheTopology();
      });
      document.getElementById("node-sub-size").addEventListener("input", (e) => {
       PAGE_STATE.nodeSubSize = parseInt(e.target.value) || 13;
       forgeTheTopology();
      });
      document.getElementById("node-font-family").addEventListener("change", (e) => {
       PAGE_STATE.nodeFont = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("default-edge-color").addEventListener("input", (e) => {
       PAGE_STATE.defaultEdge = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("selection-handle-color").addEventListener("input", (e) => {
       PAGE_STATE.selectionHandle = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("selection-handle-size").addEventListener("input", (e) => {
       PAGE_STATE.selectionHandleSize = parseInt(e.target.value) || 8;
       forgeTheTopology();
      });
      document.getElementById("group-indicator-color").addEventListener("input", (e) => {
       PAGE_STATE.groupIndicator = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-gradient-top").addEventListener("input", (e) => {
       PAGE_STATE.canvasGradientTop = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-gradient-bottom").addEventListener("input", (e) => {
       PAGE_STATE.canvasGradientBottom = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-border-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasBorder = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-grid-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasGrid = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-grid-size").addEventListener("input", (e) => {
       PAGE_STATE.canvasGridSize = parseInt(e.target.value) || 50;
       forgeTheTopology();
      });
      document.getElementById("rack-frame-fill").addEventListener("input", (e) => {
       PAGE_STATE.rackFrameFill = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-frame-stroke").addEventListener("input", (e) => {
       PAGE_STATE.rackFrameStroke = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-line-color").addEventListener("input", (e) => {
       PAGE_STATE.rackLineColor = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-text-color").addEventListener("input", (e) => {
       PAGE_STATE.rackTextColor = e.target.value;
       forgeTheTopology();
      });
      (function initializeResizers() {
         const headerResizer = document.getElementById('header-resizer');
         const sidebarResizer = document.getElementById('sidebar-resizer');
         const mobileFooterResizer = document.getElementById('mobile-footer-resizer');
         let isResizing = false;
         let currentResizer = null;
         let startY = 0;
         let startX = 0;
         let startHeight = 0;
         let startWidth = 0;
         function getClientPos(e) {
           if (e.touches && e.touches.length > 0) {
             return { x: e.touches[0].clientX, y: e.touches[0].clientY };
           }
           return { x: e.clientX, y: e.clientY };
         }
         function startResize(resizer, type, e) {
           isResizing = true;
           currentResizer = type;
           const pos = getClientPos(e);
           if (type === 'header') {
             startY = pos.y;
             startHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--topbar-height'));
           } else if (type === 'sidebar') {
             startX = pos.x;
             startWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width'));
           } else if (type === 'mobile-footer') {
             startY = pos.y;
             const currentVh = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--mobile-footer-height'));
             startHeight = (currentVh / 100) * window.innerHeight;
           }
           resizer.classList.add('resizing');
           document.body.classList.add('resizing');
           document.body.style.cursor = (type === 'sidebar') ? 'col-resize' : 'row-resize';
           e.preventDefault();
         }
         if (headerResizer) {
           headerResizer.addEventListener('mousedown', (e) => startResize(headerResizer, 'header', e));
           headerResizer.addEventListener('touchstart', (e) => startResize(headerResizer, 'header', e), { passive: false });
         }
         if (sidebarResizer) {
           sidebarResizer.addEventListener('mousedown', (e) => startResize(sidebarResizer, 'sidebar', e));
           sidebarResizer.addEventListener('touchstart', (e) => startResize(sidebarResizer, 'sidebar', e), { passive: false });
         }
         if (mobileFooterResizer) {
           mobileFooterResizer.addEventListener('mousedown', (e) => startResize(mobileFooterResizer, 'mobile-footer', e));
           mobileFooterResizer.addEventListener('touchstart', (e) => startResize(mobileFooterResizer, 'mobile-footer', e), { passive: false });
         }
         function handleMove(e) {
           if (!isResizing) return;
           const pos = getClientPos(e);
           if (currentResizer === 'header') {
             const deltaY = pos.y - startY;
             const newHeight = Math.max(40, Math.min(150, startHeight + deltaY));
             document.documentElement.style.setProperty('--topbar-height', newHeight + 'px');
           } else if (currentResizer === 'sidebar') {
             const deltaX = startX - pos.x;
             const newWidth = Math.max(200, Math.min(800, startWidth + deltaX));
             document.documentElement.style.setProperty('--sidebar-width', newWidth + 'px');
           } else if (currentResizer === 'mobile-footer') {
             const deltaY = startY - pos.y;
             const newHeight = startHeight + deltaY;
             const newVh = Math.max(15, Math.min(80, (newHeight / window.innerHeight) * 100));
             document.documentElement.style.setProperty('--mobile-footer-height', newVh + 'vh');
           }
           e.preventDefault();
         }
         document.addEventListener('mousemove', handleMove);
         document.addEventListener('touchmove', handleMove, { passive: false });
         function handleEnd() {
           if (isResizing) {
             isResizing = false;
             if (currentResizer === 'header') {
               PAGE_STATE.topbarHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--topbar-height'));
               headerResizer.classList.remove('resizing');
             } else if (currentResizer === 'sidebar') {
               PAGE_STATE.sidebarWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width'));
               sidebarResizer.classList.remove('resizing');
             } else if (currentResizer === 'mobile-footer') {
               PAGE_STATE.mobileFooterHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--mobile-footer-height'));
               mobileFooterResizer.classList.remove('resizing');
             }
             document.body.classList.remove('resizing');
             document.body.style.cursor = '';
             currentResizer = null;
           }
         }
         document.addEventListener('mouseup', handleEnd);
         document.addEventListener('touchend', handleEnd);
         document.addEventListener('touchcancel', handleEnd);
       })();
       document.getElementById("auto-ping-enabled").addEventListener("change", (e) => {
        autoPingEnabled = e.target.checked;
        PAGE_STATE.autoPingEnabled = autoPingEnabled;
        document.getElementById("auto-ping-settings").style.display = autoPingEnabled ? 'block' : 'none';
        if (autoPingEnabled) {
         startAutoPing();
        } else {
         stopAutoPing();
        }
       });
       document.getElementById("auto-ping-interval").addEventListener("change", (e) => {
        const newInterval = parseInt(e.target.value, 10);
        if (newInterval >= 5 && newInterval <= 3600) {
         autoPingInterval = newInterval;
         PAGE_STATE.autoPingInterval = autoPingInterval;
         if (autoPingEnabled) {
          startAutoPing();
         }
        }
       });
       document.getElementById("export-data-btn").addEventListener("click", () => {
        const data = captureTheQuickening();
        const jsonStr = JSON.stringify(data, null, 2);
        const blob = new Blob([jsonStr], {
         type: "application/json"
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        const safeTitle = (PAGE_STATE.title || "network-topology").toLowerCase().replace(/[^a-z0-9\-]+/g, "-");
        const timestamp = new Date().toISOString().split("T")[0];
        a.download = `${safeTitle}-data-${timestamp}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
		logAuditEvent("export", `Exported JSON: ${a.download}`);
       });
       document.getElementById("import-data-btn").addEventListener("click", () => {
        document.getElementById("import-data-file").click();
       });
       document.getElementById("import-data-file").addEventListener("change", async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        try {
         const text = await file.text();
         const data = JSON.parse(text);
         if (!data.nodeData || !data.edgeData) {
          alert("Invalid data file. Missing required fields.");
          return;
         }
         const confirmMsg = `This will replace all current data with the imported data.\n\nImporting:\n- ${Object.keys(data.nodeData).length} nodes\n- ${data.edgeData.list?.length || 0} connections\n- ${data.documentTabs?.length || 1} tab(s)\n\nContinue?`;         if (!confirm(confirmMsg)) {
          e.target.value = "";
          return;
         }
         NODE_DATA = data.nodeData || {};
         EDGE_DATA = data.edgeData || {
          list: []
         };
         EDGE_LEGEND = data.edgeLegend || {};
         RECT_DATA = data.rectData || { list: [] };
         TEXT_DATA = data.textData || { list: [] };
         savedPositions = data.nodePositions || {};
         savedSizes = data.nodeSizes || {};
         savedStyles = data.nodeStyles || {};
         if (data.page) {
          PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, data.page, );
          wieldThePower();
         }
      if (data.autoPingEnabled !== undefined) {
      autoPingEnabled = data.autoPingEnabled;
      PAGE_STATE.autoPingEnabled = autoPingEnabled;
      document.getElementById("auto-ping-enabled").checked = autoPingEnabled;
      }
      if (data.autoPingInterval !== undefined) {
      autoPingInterval = data.autoPingInterval;
      PAGE_STATE.autoPingInterval = autoPingInterval;
      document.getElementById("auto-ping-interval").value = autoPingInterval;
      }
         if (data.canvas) {
          canvasState.zoom = data.canvas.zoom || 1;
          canvasState.panX = data.canvas.panX || 0;
          canvasState.panY = data.canvas.panY || 0;
         }
         if (data.page?.title) {
         document.title = data.page.title;
         document.querySelector(".editable-page-title", ).textContent = data.page.title;
        }
        if (data.documentTabs) {
         documentTabs = data.documentTabs;
         currentTabIndex = data.currentTabIndex || 0;
        }
        if (data.savedTopologyView) {
         savedTopologyView = data.savedTopologyView;
        }
        if (data.encryptedSections) {
         encryptedSections = data.encryptedSections;
        }
        if (data.auditLog && Array.isArray(data.auditLog)) {
         auditLog = data.auditLog;
         try {
           localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
         } catch (e) {
           console.warn("Failed to sync audit log to localStorage:", e);
         }
        }
        forgeTheTopology();
        forgeTheLegend();
        logAuditEvent("import", `Imported JSON: ${file.name} (${Object.keys(data.nodeData).length} nodes, ${data.edgeData.list?.length || 0} connections)`);
        updateViewBox();
      if (autoPingEnabled) {
      startAutoPing();
      } else {
      stopAutoPing();
      }
         const nodeIds = Object.keys(NODE_DATA);
         if (nodeIds.length > 0) {
          claimTheImmortal(nodeIds[0]);
         } else {
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("topology-toolbar").style.display = "none";
         }
         alert("Data imported successfully!");
         e.target.value = "";
        } catch (err) {
         console.error("Import error:", err);
         alert(`Failed to import data: ${err.message}`);
         e.target.value = "";
        }
       });
       const saveHelpBtn = document.getElementById("save-help-btn");
       const saveInfoModal = document.getElementById("save-info-modal");
       const saveInfoClose = document.getElementById("save-info-close");
       saveHelpBtn.addEventListener("click", () => {
        saveInfoModal.classList.add("active");
       });
       saveInfoClose.addEventListener("click", () => {
        saveInfoModal.classList.remove("active");
       });
       saveInfoModal.addEventListener("click", (e) => {
       if (e.target === saveInfoModal) {
        saveInfoModal.classList.remove("active");
       }
      });
      document.querySelectorAll(".help-tab").forEach(tab => {
        tab.addEventListener("click", () => {
          document.querySelectorAll(".help-tab").forEach(t => { t.style.background = "var(--panel)"; t.style.color = "var(--text-main)"; });
          tab.style.background = "var(--accent)"; tab.style.color = "var(--bg)";
          document.querySelectorAll(".help-tab-content").forEach(c => c.style.display = "none");
          document.getElementById("help-tab-" + tab.dataset.tab).style.display = "block";
        });
      });
      async function deriveKey(password, salt) {
      const encoder = new TextEncoder();
      const keyMaterial = await crypto.subtle.importKey(
      "raw",
      encoder.encode(password),
      "PBKDF2",
      false,
      ["deriveKey"]
      );
      return crypto.subtle.deriveKey(
      {
      name: "PBKDF2",
      salt: salt,
      iterations: 200000,
      hash: "SHA-256"
      },
      keyMaterial,
      {
      name: "AES-GCM",
      length: 256
      },
      false,
      ["encrypt", "decrypt"]
      );
      }
       async function encryptData(data, password) {
      const encoder = new TextEncoder();
      const salt = crypto.getRandomValues(new Uint8Array(16));
      const iv   = crypto.getRandomValues(new Uint8Array(12));
      const key = await deriveKey(password, salt);
      const encrypted = await crypto.subtle.encrypt(
      { name: "AES-GCM", iv },
      key,
      encoder.encode(data)
      );
      const encryptedU8 = new Uint8Array(encrypted);
      const result = new Uint8Array(salt.length + iv.length + encryptedU8.length);
      result.set(salt, 0);
      result.set(iv, salt.length);
      result.set(encryptedU8, salt.length + iv.length);
      return "ENCRYPTED:" + u8ToBase64(result);
      }
       async function decryptData(encryptedData, password) {
      const base64Data = encryptedData.replace("ENCRYPTED:", "");
      const fullData   = base64ToU8(base64Data);
      const salt      = fullData.slice(0, 16);
      const iv        = fullData.slice(16, 28);
      const encrypted = fullData.slice(28);
      const key = await deriveKey(password, salt);
      const decrypted = await crypto.subtle.decrypt(
      { name: "AES-GCM", iv },
      key,
      encrypted
      );
      const decoder = new TextDecoder();
      return decoder.decode(decrypted);
      }
       function isEncrypted(data) {
        return typeof data === "string" && data.startsWith("ENCRYPTED:");
       }
       function captureTheQuickening() {
      const currentTab = documentTabs[currentTabIndex];
      currentTab.nodes = JSON.parse(JSON.stringify(NODE_DATA));
      currentTab.edges = JSON.parse(JSON.stringify(EDGE_DATA));
      currentTab.positions = JSON.parse(JSON.stringify(savedPositions));
      currentTab.sizes = JSON.parse(JSON.stringify(savedSizes));
      currentTab.styles = JSON.parse(JSON.stringify(savedStyles));
      currentTab.legend = JSON.parse(JSON.stringify(EDGE_LEGEND));
      currentTab.rects = JSON.parse(JSON.stringify(RECT_DATA));
      currentTab.texts = JSON.parse(JSON.stringify(TEXT_DATA));
      currentTab.pageState = JSON.parse(JSON.stringify(PAGE_STATE));
      return {
      nodeData: NODE_DATA,
       edgeData: EDGE_DATA,
       rectData: RECT_DATA,
       textData: TEXT_DATA,
       edgeLegend: EDGE_LEGEND,
       nodePositions: savedPositions,
       nodeSizes: savedSizes,
       nodeStyles: savedStyles,
       iconCache: IconLibrary.iconCache,
       page: PAGE_STATE,
       autoPingEnabled: autoPingEnabled,
       autoPingInterval: autoPingInterval,
       canvas: {
         zoom: canvasState.zoom,
         panX: canvasState.panX,
         panY: canvasState.panY,
       },
       savedTopologyView: savedTopologyView,
       documentTabs: documentTabs,
       currentTabIndex: currentTabIndex,
       encryptedSections: encryptedSections,
	   auditLog: auditLog,
       };
      }
       function assembleTheImmortalForm() {
	   const canvasHintEl = document.getElementById("canvas-hint");
       const savedHintHTML = canvasHintEl ? canvasHintEl.innerHTML : "";
       if (canvasHintEl) canvasHintEl.innerHTML = DEFAULT_CANVAS_HINT;
        const clone = document.documentElement.cloneNode(true);
       ["edge-legend-mini", "minimap-mini", "draw-toolbar-mini", "topology-toolbar-mini"].forEach(id => {
        const all = clone.querySelectorAll("#" + id);
        for (let i = 1; i < all.length; i++) {
         all[i].remove();
        }
       });
       const nodeScript = clone.querySelector("#nodes-json");
        if (nodeScript) {
         nodeScript.textContent = JSON.stringify(NODE_DATA, null, 2);
        }
        let stateScript = clone.querySelector("#topology-state");
        if (!stateScript) {
         stateScript = document.createElement("script");
         stateScript.id = "topology-state";
         stateScript.type = "application/json";
         const body = clone.querySelector("body") || clone;
         body.appendChild(stateScript);
        }
        stateScript.textContent = JSON.stringify(captureTheQuickening(), null, 2, );
        return " <!DOCTYPE html> \n " + clone.outerHTML;
       }
       async function becomeImmortal() {
        const encryptEnabled = document.getElementById("encrypt-toggle").checked;
        let stateData = JSON.stringify(captureTheQuickening(), null, 2);
        if (encryptEnabled) {
         const password = prompt("Enter a password to encrypt your data:\n(Remember this password! You will need it to open this file and its non recoverable!)", );
         if (!password) {
          alert("Encryption cancelled. File not saved.");
          return;
         }
         const confirmPassword = prompt("Confirm your password:");
         if (password !== confirmPassword) {
          alert("Passwords do not match. File not saved.");
          return;
         }
         try {
          stateData = await encryptData(stateData, password);
         } catch (e) {
          alert("Encryption failed: " + e.message);
          return;
         }
        }
       const canvasHintEl = document.getElementById("canvas-hint");
       const savedHintHTML = canvasHintEl ? canvasHintEl.innerHTML : "";
       if (canvasHintEl) canvasHintEl.innerHTML = DEFAULT_CANVAS_HINT;
       const clone = document.documentElement.cloneNode(true);
       ["edge-legend-mini", "minimap-mini", "draw-toolbar-mini", "topology-toolbar-mini"].forEach(id => {
        const all = clone.querySelectorAll("#" + id);
        for (let i = 1; i < all.length; i++) {
         all[i].remove();
        }
       });
       const nodeScript = clone.querySelector("#nodes-json");
        if (nodeScript) {
         if (encryptEnabled) {
          nodeScript.textContent = JSON.stringify({}, null, 2);
         } else {
          nodeScript.textContent = JSON.stringify(NODE_DATA, null, 2);
         }
        }
        let stateScript = clone.querySelector("#topology-state");
        if (!stateScript) {
         stateScript = document.createElement("script");
         stateScript.id = "topology-state";
         stateScript.type = "application/json";
         const body = clone.querySelector("body") || clone;
         body.appendChild(stateScript);
        }
        stateScript.textContent = stateData;
        const html = "<!DOCTYPE html> \n " + clone.outerHTML;
        const blob = new Blob([html], {
         type: "text/html"
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        const safeTitle = (PAGE_STATE.title || document.title || "network-topology").toLowerCase().replace(/[^a-z0-9\-]+/g, "-");
        a.download = safeTitle + ".html";
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
		if (canvasHintEl) canvasHintEl.innerHTML = savedHintHTML;
        saveRollbackVersion("Manual save");
		logAuditEvent("save", `File saved: ${safeTitle}.html`);
       }
      function captureState() {
      return {
        nodes: JSON.parse(JSON.stringify(NODE_DATA)),
        edges: JSON.parse(JSON.stringify(EDGE_DATA)),
        positions: JSON.parse(JSON.stringify(savedPositions)),
        sizes: JSON.parse(JSON.stringify(savedSizes)),
        styles: JSON.parse(JSON.stringify(savedStyles)),
        legend: JSON.parse(JSON.stringify(EDGE_LEGEND)),
        rects: JSON.parse(JSON.stringify(RECT_DATA)),
        texts: JSON.parse(JSON.stringify(TEXT_DATA))
        };
      }
      function pushUndo(action = "") {
       const state = captureState();
       undoStack.push(state);
       if (undoStack.length > MAX_UNDO_STACK) {
        undoStack.shift();
       }
       redoStack = [];
       updateUndoButtons();
       if (action) {
        const actionTypeMap = {
          "create node": "node",
          "delete node": "node",
          "add node": "node",
          "edit": "node",
          "clone node": "node",
          "paste node": "node",
          "move nodes": "node",
          "nudge": "node",
          "nudge nodes": "node",
          "align nodes": "node",
          "distribute nodes": "node",
          "snap to grid": "node",
          "toggle group": "node",
          "toggle lock": "node",
          "create rack": "rack",
          "add rack": "rack",
          "edit rack": "rack",
          "edit mac": "rack",
          "edit U height": "rack",
          "change rack capacity": "rack",
          "change assigned rack": "rack",
          "add connection": "connection",
          "delete connection": "connection",
          "delete edge": "connection",
          "clone edge": "connection",
          "paste edge": "connection",
          "style change": "style",
          "change layer": "layer",
          "add text": "text",
          "edit text": "text",
          "delete text": "text",
          "clone text": "text",
          "paste text": "text",
          "draw zone": "zone",
          "delete zone": "zone",
          "delete rect": "zone",
          "clone rect": "zone",
          "paste rect": "zone",
          "change zone line style": "zone",
          "delete selected": "bulk",
          "clone selected": "bulk",
        };
        const type = actionTypeMap[action] || "edit";
        logAuditEvent(type, action);
       }
      }
      function undo() {
       if (undoStack.length === 0) return;
       const currentState = captureState();
       redoStack.push(currentState);
       const previousState = undoStack.pop();
       restoreState(previousState);
       updateUndoButtons();
       logAuditEvent("undo", "Undo action performed");
      }
      function redo() {
       if (redoStack.length === 0) return;
       logAuditEvent("redo", "Redo action performed");
       const currentState = captureState();
       undoStack.push(currentState);
       const nextState = redoStack.pop();
       restoreState(nextState);
       updateUndoButtons();
      }
      function restoreState(state) {
      NODE_DATA = state.nodes;
       EDGE_DATA = state.edges;
       savedPositions = state.positions;
       savedSizes = state.sizes;
       savedStyles = state.styles;
       EDGE_LEGEND = state.legend;
       RECT_DATA = state.rects || { list: [] };
       TEXT_DATA = state.texts || { list: [] };
       forgeTheTopology();
       if (currentNodeId && NODE_DATA[currentNodeId]) {
       claimTheImmortal(currentNodeId);
       } else if (currentEdgeId) {
       selectTheConnection(currentEdgeId);
       }
      }
      function updateUndoButtons() {
       const undoBtn = document.getElementById("undo-btn");
       const redoBtn = document.getElementById("redo-btn");
       if (undoBtn) {
        undoBtn.disabled = undoStack.length === 0;
        undoBtn.style.opacity = undoStack.length === 0 ? "0.5" : "1";
       }
       if (redoBtn) {
        redoBtn.disabled = redoStack.length === 0;
        redoBtn.style.opacity = redoStack.length === 0 ? "0.5" : "1";
       }
      }
      function clearSelection() {
       selectedNodes.clear();
       selectedEdges.clear();
       selectedRects.clear();
       selectedTexts.clear();
       updateAllSelections();
      }
      function updateAllSelections() {
      updateNodeSelection();
      clearSearchHighlight();
      document.querySelectorAll(".edge").forEach(el => {
      const edgeId = el.dataset.edgeId;
      if (selectedEdges.has(edgeId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      document.querySelectorAll(".rect-group").forEach(el => {
      const rectId = el.dataset.rectId;
      if (selectedRects.has(rectId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      document.querySelectorAll(".text-group").forEach(el => {
      const textId = el.dataset.textId;
      if (selectedTexts.has(textId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
      const bulkToolbar = document.getElementById("bulk-toolbar");
      const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
      const bulkCount = document.getElementById("bulk-count");
      const bulkCountMobile = document.getElementById("bulk-count-mobile");
      if (total > 0) {
      if (bulkToolbar) bulkToolbar.style.display = "flex";
      if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
      if (bulkCount) bulkCount.textContent = total;
      if (bulkCountMobile) bulkCountMobile.textContent = total;
      } else {
      if (bulkToolbar) bulkToolbar.style.display = "none";
      if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
      }
      }
      function updateNodeSelection() {
       if (isViewOnly()) {
        selectedNodes.clear();
        selectedRects.clear();
        selectedTexts.clear();
        const bulkToolbar = document.getElementById("bulk-toolbar");
        const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        return;
       }
       document.querySelectorAll(".node-group").forEach(node => {
        const nodeId = node.dataset.nodeId;
        if (selectedNodes.has(nodeId)) {
         node.classList.add("selected");
        } else {
         node.classList.remove("selected");
        }
       });
       const bulkToolbar = document.getElementById("bulk-toolbar");
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       const bulkCount = document.getElementById("bulk-count");
       const bulkCountMobile = document.getElementById("bulk-count-mobile");
       const bulkCountModal = document.getElementById("bulk-count-modal");
       if (selectedNodes.size > 0) {
        if (bulkToolbar) bulkToolbar.style.display = "flex";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
        if (bulkCount) bulkCount.textContent = selectedNodes.size;
        if (bulkCountMobile) bulkCountMobile.textContent = selectedNodes.size;
        if (bulkCountModal) bulkCountModal.textContent = selectedNodes.size;
       } else {
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        const modal = document.getElementById("bulk-actions-modal");
        if (modal) modal.style.display = "none";
       }
      }
      function deleteSelected() {
       const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
       if (total === 0) return;
       let nodesInsideRacks = [];
       selectedNodes.forEach(nodeId => {
        if (NODE_DATA[nodeId]?.isRack) {
         Object.entries(NODE_DATA).forEach(([id, n]) => {
          if (n.assignedRack === nodeId) nodesInsideRacks.push(n.name || id);
         });
        }
       });
       let message = `Delete ${total} selected item(s)?`;
       if (nodesInsideRacks.length > 0) {
        message += `\n\nThis will also delete ${nodesInsideRacks.length} node(s) inside rack(s):\n‚Ä¢ ${nodesInsideRacks.join('\n‚Ä¢ ')}`;
       }
       challengeTheImmortal(message, () => {
        pushUndo("delete selected");
        selectedNodes.forEach(nodeId => {
         if (NODE_DATA[nodeId]?.isRack) {
          Object.keys(NODE_DATA).forEach(id => {
           if (NODE_DATA[id]?.assignedRack === nodeId) {
            EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== id && e.to !== id);
            delete NODE_DATA[id];
            delete savedPositions[id];
            delete savedSizes[id];
            delete savedStyles[id];
           }
          });
         }
         delete NODE_DATA[nodeId];
         delete savedPositions[nodeId];
         delete savedSizes[nodeId];
         delete savedStyles[nodeId];
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== nodeId && e.to !== nodeId);
        });
        selectedEdges.forEach(edgeId => {
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.id !== edgeId);
        });
        selectedRects.forEach(rectId => {
         RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== rectId);
        });
        selectedTexts.forEach(textId => {
         TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== textId);
        });
        clearSelection();
        forgeTheTopology();
       });
      }
      function startSelection(event) {
       const svgEl = document.getElementById("map");
       const pt = svgEl.createSVGPoint();
       pt.x = event.clientX;
       pt.y = event.clientY;
       const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
       isSelecting = true;
       selectionStart = { x: svgP.x, y: svgP.y };
       if (!selectionRect || !selectionRect.parentNode) {
        selectionRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        selectionRect.setAttribute("fill", selectionBoxStyle.fillColor);
        selectionRect.setAttribute("fill-opacity", selectionBoxStyle.fillOpacity);
        selectionRect.setAttribute("stroke", selectionBoxStyle.strokeColor);
        selectionRect.setAttribute("stroke-width", selectionBoxStyle.strokeWidth);
        selectionRect.setAttribute("stroke-dasharray", selectionBoxStyle.strokeDasharray);
        selectionRect.style.pointerEvents = "none";
        svgEl.appendChild(selectionRect);
       }
       clearSelection();
       preDragSelectedNodes = new Set(selectedNodes);
       preDragSelectedEdges = new Set(selectedEdges);
       preDragSelectedRects = new Set(selectedRects);
       preDragSelectedTexts = new Set(selectedTexts);
      }
      function updateSelection(event) {
       if (!isSelecting || !selectionStart) return;
       const svgEl = document.getElementById("map");
       const pt = svgEl.createSVGPoint();
       pt.x = event.clientX;
       pt.y = event.clientY;
       const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
       const x = Math.min(selectionStart.x, svgP.x);
       const y = Math.min(selectionStart.y, svgP.y);
       const width = Math.abs(svgP.x - selectionStart.x);
       const height = Math.abs(svgP.y - selectionStart.y);
       selectionRect.setAttribute("x", x);
       selectionRect.setAttribute("y", y);
       selectionRect.setAttribute("width", width);
       selectionRect.setAttribute("height", height);
       selectionRect.style.display = "block";
       const box = { x, y, width, height };
       Object.entries(savedPositions).forEach(([nodeId, pos]) => {
        const size = savedSizes[nodeId] || 50;
        const halfSize = size / 2;
        const nodeBox = { x: pos.x - halfSize, y: pos.y - halfSize, width: size, height: size };
        if (boxesIntersect(box, nodeBox)) {
         selectedNodes.add(nodeId);
        } else if (!preDragSelectedNodes.has(nodeId)) {
         selectedNodes.delete(nodeId);
        }
       });
       EDGE_DATA.list.forEach(edge => {
        if (!edge.points || edge.points.length === 0) return;
        for (let i = 0; i < edge.points.length - 1; i++) {
         const p1 = edge.points[i];
         const p2 = edge.points[i + 1];
         if (lineIntersectsBox(p1.x, p1.y, p2.x, p2.y, box)) {
          selectedEdges.add(edge.id);
          return;
         }
        }
        if (!preDragSelectedEdges.has(edge.id)) {
         selectedEdges.delete(edge.id);
        }
       });
       RECT_DATA.list.forEach(rect => {
        const rectBox = { x: rect.x, y: rect.y, width: rect.width, height: rect.height };
        if (boxesIntersect(box, rectBox)) {
         selectedRects.add(rect.id);
        } else if (!preDragSelectedRects.has(rect.id)) {
         selectedRects.delete(rect.id);
        }
       });
       TEXT_DATA.list.forEach(text => {
        const fontSize = text.fontSize || 18;
        const textBox = { x: text.x - 50, y: text.y - fontSize, width: 100, height: fontSize * 1.5 };
        if (boxesIntersect(box, textBox)) {
         selectedTexts.add(text.id);
        } else if (!preDragSelectedTexts.has(text.id)) {
         selectedTexts.delete(text.id);
        }
       });
       updateAllSelectionVisuals();
      }
      function endSelection() {
       isSelecting = false;
       selectionStart = null;
       if (selectionRect) {
        selectionRect.style.display = "none";
       }
      }
      function boxesIntersect(a, b) {
       return !(a.x + a.width < b.x || b.x + b.width < a.x || a.y + a.height < b.y || b.y + b.height < a.y);
      }
      function lineIntersectsBox(x1, y1, x2, y2, box) {
       if (pointInBox(x1, y1, box) || pointInBox(x2, y2, box)) return true;
       const lines = [
        [box.x, box.y, box.x + box.width, box.y],
        [box.x + box.width, box.y, box.x + box.width, box.y + box.height],
        [box.x + box.width, box.y + box.height, box.x, box.y + box.height],
        [box.x, box.y + box.height, box.x, box.y]
       ];
       for (const [bx1, by1, bx2, by2] of lines) {
        if (linesIntersect(x1, y1, x2, y2, bx1, by1, bx2, by2)) return true;
       }
       return false;
      }
      function pointInBox(x, y, box) {
       return x >= box.x && x <= box.x + box.width && y >= box.y && y <= box.y + box.height;
      }
      function linesIntersect(x1, y1, x2, y2, x3, y3, x4, y4) {
       const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
       if (Math.abs(denom) < 0.0001) return false;
       const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom;
       const ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denom;
       return ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1;
      }
      function updateAllSelectionVisuals() {
       document.querySelectorAll(".node-group").forEach(node => {
        const nodeId = node.dataset.nodeId;
        if (selectedNodes.has(nodeId)) {
         node.classList.add("selected");
        } else {
         node.classList.remove("selected");
        }
       });
       document.querySelectorAll(".edge").forEach(edge => {
        const edgeId = edge.dataset.edgeId;
        if (selectedEdges.has(edgeId)) {
         edge.style.filter = "drop-shadow(0 0 6px #4fd1c5)";
        } else {
         edge.style.filter = "";
        }
       });
       document.querySelectorAll(".rect-group rect").forEach(el => {
        const rectId = el.closest(".rect-group")?.dataset?.rectId;
        if (selectedRects.has(rectId)) {
         el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
        } else {
         el.style.filter = "";
        }
       });
       document.querySelectorAll(".text-group, .text-element").forEach(el => {
        const textId = el.dataset?.textId;
        if (selectedTexts.has(textId)) {
         el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
        } else {
         el.style.filter = "";
        }
       });
       const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
       const bulkToolbar = document.getElementById("bulk-toolbar");
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       const bulkCount = document.getElementById("bulk-count");
       const bulkCountMobile = document.getElementById("bulk-count-mobile");
       if (total > 0) {
        if (bulkToolbar) bulkToolbar.style.display = "flex";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
        if (bulkCount) bulkCount.textContent = total;
        if (bulkCountMobile) bulkCountMobile.textContent = total;
       } else {
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
       }
      }
      function cloneNode(sourceId, skipUndo) {
       const source = NODE_DATA[sourceId];
       if (!source) return;
       if (!skipUndo) pushUndo("clone node");
       let baseName = source.name;
       let copyNum = 0;
       let newName = baseName + " copy";
       while (Object.values(NODE_DATA).some(n => n.name === newName)) {
        copyNum++;
        newName = baseName + " copy " + copyNum;
       }
       const newId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
       NODE_DATA[newId] = {
        shape: source.shape,
        name: newName,
        ip: source.ip,
        role: source.role,
        tags: [...source.tags],
        notes: [...source.notes],
        mac: source.mac || "",
        rackUnit: source.rackUnit || "",
        uHeight: source.uHeight || "1",
        ping: source.ping ? JSON.parse(JSON.stringify(source.ping)) : {
         enabled: false,
         protocol: 'http',
         customUrl: '',
         timeout: 3000,
         status: 'unknown',
         lastCheck: null
        },
        layer: source.layer || "physical",
        assignedRack: source.assignedRack || "",
        rackCapacity: source.rackCapacity || "42",
        isRack: source.isRack || false
       };
       if (source.isRack) {
        const childNodes = Object.entries(NODE_DATA).filter(([id, n]) =>
         id !== newId && n.assignedRack === sourceId
        );
        childNodes.forEach(([childId, childNode]) => {
         let childBaseName = childNode.name;
         let c = 0;
         let childNewName = childBaseName + " copy";
         while (Object.values(NODE_DATA).some(n => n.name === childNewName)) {
          c++;
          childNewName = childBaseName + " copy " + c;
         }
         const childNewId = childNewName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
         NODE_DATA[childNewId] = {
          ...JSON.parse(JSON.stringify(childNode)),
          name: childNewName,
          assignedRack: newId
         };
         if (savedPositions[childId]) {
          savedPositions[childNewId] = { ...savedPositions[childId] };
         }
         if (savedSizes[childId]) {
          savedSizes[childNewId] = savedSizes[childId];
         }
         if (savedStyles[childId]) {
          savedStyles[childNewId] = JSON.parse(JSON.stringify(savedStyles[childId]));
         }
        });
       }
       if (savedSizes[sourceId]) {
        savedSizes[newId] = savedSizes[sourceId];
       }
       if (savedStyles[sourceId]) {
        savedStyles[newId] = JSON.parse(JSON.stringify(savedStyles[sourceId]));
       }
      if (currentView.mode === "rack" && currentView.rackId) {
        NODE_DATA[newId].assignedRack = currentView.rackId;
       }
       const sourcePos = savedPositions[sourceId];
       savedPositions[newId] = {
        x: sourcePos.x + 100,
        y: sourcePos.y + 100
       };
       forgeTheTopology();
       claimTheImmortal(newId);
      }
      function alignSelectedNodes(direction) {
       if (selectedNodes.size < 2) return;
       pushUndo("align nodes");
       const nodeIds = Array.from(selectedNodes);
       const positions = nodeIds.map(id => ({ id, pos: savedPositions[id] }));
       switch(direction) {
        case "left":
         const minX = Math.min(...positions.map(p => p.pos.x));
         positions.forEach(p => savedPositions[p.id].x = minX);
         break;
        case "right":
         const maxX = Math.max(...positions.map(p => p.pos.x));
         positions.forEach(p => savedPositions[p.id].x = maxX);
         break;
        case "top":
         const minY = Math.min(...positions.map(p => p.pos.y));
         positions.forEach(p => savedPositions[p.id].y = minY);
         break;
        case "bottom":
         const maxY = Math.max(...positions.map(p => p.pos.y));
         positions.forEach(p => savedPositions[p.id].y = maxY);
         break;
        case "center-h":
         const avgX = positions.reduce((sum, p) => sum + p.pos.x, 0) / positions.length;
         positions.forEach(p => savedPositions[p.id].x = avgX);
         break;
        case "center-v":
         const avgY = positions.reduce((sum, p) => sum + p.pos.y, 0) / positions.length;
         positions.forEach(p => savedPositions[p.id].y = avgY);
         break;
       }
       forgeTheTopology();
      }
      function distributeSelectedNodes(direction) {
       if (selectedNodes.size < 3) return;
       pushUndo("distribute nodes");
       const nodeIds = Array.from(selectedNodes);
       const positions = nodeIds.map(id => ({ id, pos: savedPositions[id] }));
       if (direction === "horizontal") {
        positions.sort((a, b) => a.pos.x - b.pos.x);
        const minX = positions[0].pos.x;
        const maxX = positions[positions.length - 1].pos.x;
        const gap = (maxX - minX) / (positions.length - 1);
        positions.forEach((p, i) => {
         savedPositions[p.id].x = minX + (gap * i);
        });
       } else if (direction === "vertical") {
        positions.sort((a, b) => a.pos.y - b.pos.y);
        const minY = positions[0].pos.y;
        const maxY = positions[positions.length - 1].pos.y;
        const gap = (maxY - minY) / (positions.length - 1);
        positions.forEach((p, i) => {
         savedPositions[p.id].y = minY + (gap * i);
        });
       }
       forgeTheTopology();
      }
      function snapToGrid(nodeId, gridSize = 50) {
       if (!savedPositions[nodeId]) return;
       pushUndo("snap to grid");
       const pos = savedPositions[nodeId];
       pos.x = Math.round(pos.x / gridSize) * gridSize;
       pos.y = Math.round(pos.y / gridSize) * gridSize;
       forgeTheTopology();
      }
      function nudgeSelectedNodes(direction, distance) {
        const nodesToNudge = selectedNodes.size > 0
          ? Array.from(selectedNodes)
          : (currentNodeId ? [currentNodeId] : []);
        if (nodesToNudge.length === 0) return;
        const unlockedNodes = nodesToNudge.filter(id => !NODE_DATA[id]?.locked);
        if (unlockedNodes.length === 0) {
          return;
        }
        pushUndo("nudge nodes");
        unlockedNodes.forEach(id => {
          if (!savedPositions[id]) {
            savedPositions[id] = { x: 0, y: 0 };
          }
          switch(direction) {
            case "ArrowUp":
              savedPositions[id].y -= distance;
              break;
            case "ArrowDown":
              savedPositions[id].y += distance;
              break;
            case "ArrowLeft":
              savedPositions[id].x -= distance;
              break;
            case "ArrowRight":
              savedPositions[id].x += distance;
              break;
          }
        });
        forgeTheTopology();
      }
      function cycleNodes(reverse = false) {
        const nodeIds = Object.keys(NODE_DATA).filter(id => {
          if (currentView.mode === "rack") {
           const node = NODE_DATA[id];
           return node && node.assignedRack === currentView.rackId;
          }
          return isNodeVisible(id);
         });
        if (nodeIds.length === 0) return;
        let currentIndex = nodeIds.indexOf(currentNodeId);
        if (reverse) {
          currentIndex = currentIndex <= 0 ? nodeIds.length - 1 : currentIndex - 1;
        } else {
          currentIndex = currentIndex >= nodeIds.length - 1 ? 0 : currentIndex + 1;
        }
        const nextNodeId = nodeIds[currentIndex];
        claimTheImmortal(nextNodeId);
        selectedNodes.clear();
        updateNodeSelection();
      }
      function focusOnSelected() {
        let minX = Infinity, minY = Infinity;
        let maxX = -Infinity, maxY = -Infinity;
        let hasItems = false;
        const nodesToFocus = selectedNodes.size > 0
          ? Array.from(selectedNodes)
          : (currentNodeId ? [currentNodeId] : []);
        nodesToFocus.forEach(id => {
          const pos = savedPositions[id];
          if (pos) {
            hasItems = true;
            const size = savedSizes[id] || 50;
            minX = Math.min(minX, pos.x - size/2);
            minY = Math.min(minY, pos.y - size/2);
            maxX = Math.max(maxX, pos.x + size/2);
            maxY = Math.max(maxY, pos.y + size/2);
          }
        });
        const rectsToFocus = selectedRects.size > 0 ? Array.from(selectedRects) : (currentRectId ? [currentRectId] : []);
        rectsToFocus.forEach(id => {
          const r = RECT_DATA.list.find(x => x.id === id);
          if (r) {
            hasItems = true;
            minX = Math.min(minX, r.x);
            minY = Math.min(minY, r.y);
            maxX = Math.max(maxX, r.x + r.width);
            maxY = Math.max(maxY, r.y + r.height);
          }
        });
        const textsToFocus = selectedTexts.size > 0 ? Array.from(selectedTexts) : (currentTextId ? [currentTextId] : []);
        textsToFocus.forEach(id => {
          const t = TEXT_DATA.list.find(x => x.id === id);
          if (t) {
            hasItems = true;
            minX = Math.min(minX, t.x - 50);
            minY = Math.min(minY, t.y - 20);
            maxX = Math.max(maxX, t.x + 50);
            maxY = Math.max(maxY, t.y + 20);
          }
        });
        const edgesToFocus = selectedEdges.size > 0 ? Array.from(selectedEdges) : (currentEdgeId ? [currentEdgeId] : []);
        edgesToFocus.forEach(id => {
          const e = EDGE_DATA.list.find(x => x.id === id);
          if (e) {
            const fromPos = savedPositions[e.from];
            const toPos = savedPositions[e.to];
            if (fromPos && toPos) {
              hasItems = true;
              minX = Math.min(minX, fromPos.x, toPos.x);
              minY = Math.min(minY, fromPos.y, toPos.y);
              maxX = Math.max(maxX, fromPos.x, toPos.x);
              maxY = Math.max(maxY, fromPos.y, toPos.y);
            }
          }
        });
        if (!hasItems || !isFinite(minX)) return;
        const padding = 100;
        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;
        const width = maxX - minX + padding * 2;
        const height = maxY - minY + padding * 2;
        const zoomX = CANVAS_WIDTH / width;
        const zoomY = CANVAS_HEIGHT / height;
        const targetZoom = Math.min(zoomX, zoomY, 2);
        canvasState.zoom = targetZoom;
        canvasState.panX = centerX - (CANVAS_WIDTH / targetZoom) / 2;
        canvasState.panY = centerY - (CANVAS_HEIGHT / targetZoom) / 2;
		// forgeTheTopology(); getting ready to implement new core canvas performance system
        updateViewBox();
      }
      function toggleLockSelected() {
        const nodesToToggle = selectedNodes.size > 0
          ? Array.from(selectedNodes)
          : (currentNodeId ? [currentNodeId] : []);
        const rectsToToggle = selectedRects.size > 0
          ? Array.from(selectedRects)
          : (currentRectId ? [currentRectId] : []);
        const textsToToggle = selectedTexts.size > 0
          ? Array.from(selectedTexts)
          : (currentTextId ? [currentTextId] : []);
        if (nodesToToggle.length === 0 && rectsToToggle.length === 0 && textsToToggle.length === 0) return;
        pushUndo("toggle lock");
        let hasUnlocked = nodesToToggle.some(id => !NODE_DATA[id]?.locked);
        hasUnlocked = hasUnlocked || rectsToToggle.some(id => { const r = RECT_DATA.list.find(x => x.id === id); return r && !r.locked; });
        hasUnlocked = hasUnlocked || textsToToggle.some(id => { const t = TEXT_DATA.list.find(x => x.id === id); return t && !t.locked; });
        nodesToToggle.forEach(id => {
          if (NODE_DATA[id]) NODE_DATA[id].locked = hasUnlocked;
        });
        rectsToToggle.forEach(id => {
          const r = RECT_DATA.list.find(x => x.id === id);
          if (r) r.locked = hasUnlocked;
        });
        textsToToggle.forEach(id => {
          const t = TEXT_DATA.list.find(x => x.id === id);
          if (t) t.locked = hasUnlocked;
        });
        forgeTheTopology();
      }
      function toggleGroupSelected() {
      const nodesToGroup = Array.from(selectedNodes);
      const rectsToGroup = Array.from(selectedRects);
      const textsToGroup = Array.from(selectedTexts);
      const edgesToGroup = Array.from(selectedEdges);
      const totalItems = nodesToGroup.length + rectsToGroup.length + textsToGroup.length + edgesToGroup.length;
      if (totalItems < 2) return;
      pushUndo("toggle group");
      const allGroupIds = [];
      nodesToGroup.forEach(id => { if (NODE_DATA[id]?.groupId) allGroupIds.push(NODE_DATA[id].groupId); });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r?.groupId) allGroupIds.push(r.groupId); });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t?.groupId) allGroupIds.push(t.groupId); });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e?.groupId) allGroupIds.push(e.groupId); });
      const uniqueGroups = [...new Set(allGroupIds)];
      if (uniqueGroups.length === 1 && allGroupIds.length === totalItems) {
      nodesToGroup.forEach(id => { if (NODE_DATA[id]) NODE_DATA[id].groupId = null; });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r) r.groupId = null; });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t) t.groupId = null; });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e) e.groupId = null; });
      } else {
      const newGroupId = "group-" + Date.now();
      nodesToGroup.forEach(id => { if (NODE_DATA[id]) NODE_DATA[id].groupId = newGroupId; });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r) r.groupId = newGroupId; });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t) t.groupId = newGroupId; });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e) e.groupId = newGroupId; });
      }
      forgeTheTopology();
      }
      function handleKeyDown(event) {
       if (event.target.tagName === "INPUT" || event.target.tagName === "TEXTAREA" || event.target.isContentEditable) {
        return;
       }
       if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(event.key)) {
        event.preventDefault();
        const distance = event.shiftKey ? 10 : 1;
        nudgeSelectedNodes(event.key, distance);
       }
       if (event.key === "Tab") {
        event.preventDefault();
        cycleNodes(event.shiftKey);
       }
       if (event.key === "f" || event.key === "F") {
        event.preventDefault();
        focusOnSelected();
       }
       if (event.key === "l" || event.key === "L") {
        event.preventDefault();
        toggleLockSelected();
       }
       if (event.key === "g" || event.key === "G") {
        event.preventDefault();
        toggleGroupSelected();
       }
       if (event.ctrlKey && event.key === "z" && !event.shiftKey) {
        event.preventDefault();
        undo();
       }
       if ((event.ctrlKey && event.key === "y") || (event.ctrlKey && event.shiftKey && event.key === "z")) {
        event.preventDefault();
        redo();
       }
       if (event.ctrlKey && event.key === "c") {
        event.preventDefault();
        clipboard = null;
        if (currentNodeId && NODE_DATA[currentNodeId]) {
         clipboard = {
          type: "node",
          data: JSON.parse(JSON.stringify(NODE_DATA[currentNodeId])),
          size: savedSizes[currentNodeId],
          style: savedStyles[currentNodeId] ? JSON.parse(JSON.stringify(savedStyles[currentNodeId])) : null
         };
        } else if (currentEdgeId) {
         const edge = EDGE_DATA.list.find(e => e.id === currentEdgeId);
         if (edge) clipboard = { type: "edge", data: JSON.parse(JSON.stringify(edge)) };
        } else if (currentRectId) {
         const rect = RECT_DATA.list.find(r => r.id === currentRectId);
         if (rect) clipboard = { type: "rect", data: JSON.parse(JSON.stringify(rect)) };
        } else if (currentTextId) {
         const text = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (text) clipboard = { type: "text", data: JSON.parse(JSON.stringify(text)) };
        }
       }
       if (event.ctrlKey && event.key === "v") {
        event.preventDefault();
        if (!clipboard) return;
        const svgEl = document.getElementById("map");
        const rect = svgEl.getBoundingClientRect();
        const pt = svgEl.createSVGPoint();
        pt.x = rect.left + rect.width / 2;
        pt.y = rect.top + rect.height / 2;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const centerX = svgP.x;
        const centerY = svgP.y;
        if (clipboard.type === "node") {
         let newName = clipboard.data.name + " copy";
         let counter = 1;
         while (Object.values(NODE_DATA).some(n => n.name === newName)) {
          newName = clipboard.data.name + " copy " + counter;
          counter++;
         }
         let newId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
         counter = 1;
         while (NODE_DATA[newId]) {
          newId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-") + "-" + counter;
          counter++;
         }
         pushUndo("paste node");
         NODE_DATA[newId] = { ...JSON.parse(JSON.stringify(clipboard.data)), name: newName };
         savedPositions[newId] = { x: centerX, y: centerY };
         if (clipboard.size) savedSizes[newId] = clipboard.size;
         if (clipboard.style) savedStyles[newId] = JSON.parse(JSON.stringify(clipboard.style));
         forgeTheTopology();
         claimTheImmortal(newId);
        } else if (clipboard.type === "edge") {
         pushUndo("paste edge");
         const newEdge = { ...clipboard.data, id: "edge-" + Date.now() };
         EDGE_DATA.list.push(newEdge);
         forgeTheTopology();
         selectTheConnection(newEdge.id);
        } else if (clipboard.type === "rect") {
         pushUndo("paste rect");
         const newRect = { ...clipboard.data, id: "rect-" + Date.now(), x: centerX - (clipboard.data.width || 100) / 2, y: centerY - (clipboard.data.height || 100) / 2 };
         RECT_DATA.list.push(newRect);
         forgeTheTopology();
         selectTheRect(newRect.id);
        } else if (clipboard.type === "text") {
         pushUndo("paste text");
         const newText = { ...clipboard.data, id: "text-" + Date.now(), x: centerX, y: centerY };
         TEXT_DATA.list.push(newText);
         forgeTheTopology();
         showTextPanel(newText.id);
        }
       }
       if (event.ctrlKey && event.key === "d") {
        event.preventDefault();
        if (currentNodeId && NODE_DATA[currentNodeId]) {
         cloneNode(currentNodeId);
        } else if (currentEdgeId) {
         const edge = EDGE_DATA.list.find(e => e.id === currentEdgeId);
         if (edge) {
          pushUndo("clone edge");
          const newEdge = { ...JSON.parse(JSON.stringify(edge)), id: "edge-" + Date.now() };
          EDGE_DATA.list.push(newEdge);
          forgeTheTopology();
          selectTheConnection(newEdge.id);
         }
        } else if (currentRectId) {
         const rect = RECT_DATA.list.find(r => r.id === currentRectId);
         if (rect) {
          pushUndo("clone rect");
          const newRect = { ...JSON.parse(JSON.stringify(rect)), id: "rect-" + Date.now(), x: rect.x + 50, y: rect.y + 50 };
          RECT_DATA.list.push(newRect);
          forgeTheTopology();
          selectTheRect(newRect.id);
         }
        } else if (currentTextId) {
         const text = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (text) {
          pushUndo("clone text");
          const newText = { ...JSON.parse(JSON.stringify(text)), id: "text-" + Date.now(), x: text.x + 50, y: text.y + 50 };
          TEXT_DATA.list.push(newText);
          forgeTheTopology();
          showTextPanel(newText.id);
         }
        }
       }
       if (event.key === "Delete") {
        event.preventDefault();
        const totalSelected = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
        if (totalSelected > 0) {
         deleteSelected();
        } else if (currentNodeId && NODE_DATA[currentNodeId]) {
         challengeTheImmortal(`Delete node "${NODE_DATA[currentNodeId].name}"?`, () => {
          pushUndo("delete node");
          delete NODE_DATA[currentNodeId];
          delete savedPositions[currentNodeId];
          delete savedSizes[currentNodeId];
          delete savedStyles[currentNodeId];
          EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== currentNodeId && e.to !== currentNodeId);
          currentNodeId = null;
          forgeTheTopology();
          document.getElementById("node-panel").style.display = "none";
         });
        } else if (currentEdgeId) {
         challengeTheImmortal("Delete this line?", () => {
          pushUndo("delete edge");
          EDGE_DATA.list = EDGE_DATA.list.filter(e => e.id !== currentEdgeId);
          currentEdgeId = null;
          forgeTheTopology();
          document.getElementById("edge-panel").style.display = "none";
         });
        } else if (currentRectId) {
         challengeTheImmortal("Delete this zone?", () => {
          pushUndo("delete rect");
          RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== currentRectId);
          currentRectId = null;
          forgeTheTopology();
          document.getElementById("rect-panel").style.display = "none";
         });
        } else if (currentTextId) {
         const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (textItem) {
          challengeTheImmortal(`Delete text "${textItem.content.substring(0, 30)}..."?`, () => {
           pushUndo("delete text");
           TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== currentTextId);
           currentTextId = null;
           forgeTheTopology();
           document.getElementById("text-panel").style.display = "none";
          });
         }
        }
       }
       if (event.ctrlKey && event.key === "a") {
        event.preventDefault();
        Object.keys(NODE_DATA).forEach(id => selectedNodes.add(id));
        EDGE_DATA.list.forEach(e => selectedEdges.add(e.id));
        RECT_DATA.list.forEach(r => selectedRects.add(r.id));
        TEXT_DATA.list.forEach(t => selectedTexts.add(t.id));
        updateAllSelections();
       }
       if (event.key === "Escape") {
        clearSelection();
       }
      }
      function searchNodes(query) {
   if (!query) {
    clearSearchHighlight();
    return [];
   }
   query = query.toLowerCase();
   const results = [];
   Object.entries(NODE_DATA).forEach(([id, data]) => {
    try {
     const nameMatch = data.name && data.name.toLowerCase().includes(query);
     const ipMatch = data.ip && data.ip.toLowerCase().includes(query);
     const roleMatch = data.role && data.role.toLowerCase().includes(query);
     const tagsMatch = data.tags && Array.isArray(data.tags) && data.tags.some(tag => tag && tag.toLowerCase().includes(query));
     const macMatch = data.mac && data.mac.toLowerCase().includes(query);
     const rackUnitMatch = data.rackUnit && String(data.rackUnit).toLowerCase().includes(query);
     if (nameMatch || ipMatch || roleMatch || tagsMatch || macMatch || rackUnitMatch) {
      results.push(id);
     }
    } catch (e) {
     console.warn("Search error for node:", id, e);
    }
   });
   highlightSearchResults(results);
   return results;
}
		function highlightSearchResults(nodeIds, hasQuery = true) {
		   document.querySelectorAll(".node-group").forEach(node => {
			const nodeId = node.dataset.nodeId;
			if (nodeIds.includes(nodeId)) {
			 node.classList.add("search-highlight");
			 node.classList.remove("search-faded");
			} else {
			 node.classList.remove("search-highlight");
			 if (hasQuery) {
			  node.classList.add("search-faded");
			 } else {
			  node.classList.remove("search-faded");
			 }
			}
		   });
		   document.querySelectorAll(".edge-group, .edge").forEach(edge => {
			if (hasQuery) {
			 edge.classList.add("search-faded");
			} else {
			 edge.classList.remove("search-faded");
			}
		   });
		}
		function clearSearchHighlight() {
		   document.querySelectorAll(".search-highlight").forEach(node => {
			node.classList.remove("search-highlight");
		   });
		   document.querySelectorAll(".search-faded").forEach(el => {
			el.classList.remove("search-faded");
		   });
		}
      function editNodeMac(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       document.getElementById("modal-title").textContent = "Edit MAC Address";
       document.getElementById("modal-input").value = node.mac || "";
       document.getElementById("edit-modal").style.display = "";
	   document.getElementById("edit-modal").classList.add("active");
       document.getElementById("modal-input").focus();
       const modal = document.getElementById("edit-modal");
       const cleanup = () => {
        modal.classList.remove("active");
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
        modal.removeEventListener("click", bgHandler);
       };
       const saveHandler = () => {
        pushUndo("edit mac");
        const value = document.getElementById("modal-input").value.trim();
        node.mac = value;
        cleanup();
        claimTheImmortal(id);
       };
       const cancelHandler = () => {
        cleanup();
       };
       const bgHandler = (e) => {
        if (e.target === modal) cancelHandler();
       };
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       modal.addEventListener("click", bgHandler);
      }
      function editNodeRack(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       document.getElementById("modal-title").textContent = "Edit Rack Unit";
       document.getElementById("modal-input").value = node.rackUnit || "";
       document.getElementById("edit-modal").style.display = "";
       document.getElementById("edit-modal").classList.add("active");
       document.getElementById("modal-input").focus();
	   const modal = document.getElementById("edit-modal");
       const cleanup = () => {
        modal.classList.remove("active");
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
        modal.removeEventListener("click", bgHandler);
       };
       const saveHandler = () => {
        pushUndo("edit rack");
        const value = document.getElementById("modal-input").value.trim();
        node.rackUnit = value;
        cleanup();
        claimTheImmortal(id);
       };
       const cancelHandler = () => {
        cleanup();
       };
       const bgHandler = (e) => {
        if (e.target === modal) cancelHandler();
       };
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       modal.addEventListener("click", bgHandler);
      }
      function editNodeUHeight(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       document.getElementById("modal-title").textContent = "Edit U Height";
       document.getElementById("modal-input").value = node.uHeight || "1";
       document.getElementById("edit-modal").style.display = "";
       document.getElementById("edit-modal").classList.add("active");
       document.getElementById("modal-input").focus();
	   const modal = document.getElementById("edit-modal");
       const cleanup = () => {
        modal.classList.remove("active");
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
        modal.removeEventListener("click", bgHandler);
       };
       const saveHandler = () => {
        pushUndo("edit U height");
        const value = document.getElementById("modal-input").value.trim();
        node.uHeight = value;
        cleanup();
        claimTheImmortal(id);
        forgeTheTopology();
       };
       const cancelHandler = () => {
        cleanup();
       };
       const bgHandler = (e) => {
        if (e.target === modal) cancelHandler();
       };
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       modal.addEventListener("click", bgHandler);
      }
      function updateEdgePortLabels(edgeId) {
       const edge = EDGE_DATA.list.find(e => e.id === edgeId);
       if (!edge) return;
       const fromPortInput = document.getElementById("edge-from-port");
       const toPortInput = document.getElementById("edge-to-port");
       edge.fromPort = fromPortInput ? fromPortInput.value.trim() : "";
       edge.toPort = toPortInput ? toPortInput.value.trim() : "";
       forgeTheTopology();
      }
      document.addEventListener("keydown", handleKeyDown);
      const undoBtn = document.getElementById("undo-btn");
      const redoBtn = document.getElementById("redo-btn");
      if (undoBtn) undoBtn.addEventListener("click", undo);
      if (redoBtn) redoBtn.addEventListener("click", redo);
      const backToTopologyBtn = document.getElementById("back-to-topology-btn");
      if (backToTopologyBtn) {
       backToTopologyBtn.addEventListener("click", exitRack);
      }
      const bulkToolbarClose = document.getElementById("bulk-toolbar-close");
      if (bulkToolbarClose) {
       bulkToolbarClose.addEventListener("click", clearSelection);
      }
      const bulkAlignLeft = document.getElementById("bulk-align-left");
      if (bulkAlignLeft) {
       bulkAlignLeft.addEventListener("click", () => alignSelectedNodes("left"));
      }
      const bulkAlignRight = document.getElementById("bulk-align-right");
      if (bulkAlignRight) {
       bulkAlignRight.addEventListener("click", () => alignSelectedNodes("right"));
      }
      const bulkAlignTop = document.getElementById("bulk-align-top");
      if (bulkAlignTop) {
       bulkAlignTop.addEventListener("click", () => alignSelectedNodes("top"));
      }
      const bulkAlignBottom = document.getElementById("bulk-align-bottom");
      if (bulkAlignBottom) {
       bulkAlignBottom.addEventListener("click", () => alignSelectedNodes("bottom"));
      }
      const bulkDistributeH = document.getElementById("bulk-distribute-h");
      if (bulkDistributeH) {
       bulkDistributeH.addEventListener("click", () => distributeSelectedNodes("horizontal"));
      }
      const bulkDistributeV = document.getElementById("bulk-distribute-v");
      if (bulkDistributeV) {
       bulkDistributeV.addEventListener("click", () => distributeSelectedNodes("vertical"));
      }
      const bulkClone = document.getElementById("bulk-clone");
      if (bulkClone) {
       bulkClone.addEventListener("click", () => {
        if (selectedNodes.size === 0) return;
        pushUndo("clone selected");
        const nodesToClone = Array.from(selectedNodes);
        selectedNodes.clear();
       nodesToClone.forEach(id => {
         cloneNode(id, true);
         selectedNodes.add(currentNodeId);
        });
        updateNodeSelection();
       });
      }
      const bulkDelete = document.getElementById("bulk-delete");
      if (bulkDelete) {
       bulkDelete.addEventListener("click", deleteSelected);
      }
      const bulkMobileBtn = document.getElementById("bulk-mobile-btn");
      const bulkActionsModal = document.getElementById("bulk-actions-modal");
      const bulkModalClose = document.getElementById("bulk-modal-close");
      if (bulkMobileBtn) {
       bulkMobileBtn.addEventListener("click", () => {
        if (bulkActionsModal) bulkActionsModal.style.display = "block";
       });
      }
      if (bulkModalClose) {
       bulkModalClose.addEventListener("click", () => {
        if (bulkActionsModal) bulkActionsModal.style.display = "none";
       });
      }
      const closeModalAfterAction = () => {
       if (bulkActionsModal) bulkActionsModal.style.display = "none";
      };
      const bulkAlignLeftMobile = document.getElementById("bulk-align-left-mobile");
      if (bulkAlignLeftMobile) {
       bulkAlignLeftMobile.addEventListener("click", () => {
        alignSelectedNodes("left");
        closeModalAfterAction();
       });
      }
      const bulkAlignRightMobile = document.getElementById("bulk-align-right-mobile");
      if (bulkAlignRightMobile) {
       bulkAlignRightMobile.addEventListener("click", () => {
        alignSelectedNodes("right");
        closeModalAfterAction();
       });
      }
      const bulkAlignTopMobile = document.getElementById("bulk-align-top-mobile");
      if (bulkAlignTopMobile) {
       bulkAlignTopMobile.addEventListener("click", () => {
        alignSelectedNodes("top");
        closeModalAfterAction();
       });
      }
      const bulkAlignBottomMobile = document.getElementById("bulk-align-bottom-mobile");
      if (bulkAlignBottomMobile) {
       bulkAlignBottomMobile.addEventListener("click", () => {
        alignSelectedNodes("bottom");
        closeModalAfterAction();
       });
      }
      const bulkDistributeHMobile = document.getElementById("bulk-distribute-h-mobile");
      if (bulkDistributeHMobile) {
       bulkDistributeHMobile.addEventListener("click", () => {
        distributeSelectedNodes("horizontal");
        closeModalAfterAction();
       });
      }
      const bulkDistributeVMobile = document.getElementById("bulk-distribute-v-mobile");
      if (bulkDistributeVMobile) {
       bulkDistributeVMobile.addEventListener("click", () => {
        distributeSelectedNodes("vertical");
        closeModalAfterAction();
       });
      }
      const bulkCloneMobile = document.getElementById("bulk-clone-mobile");
      if (bulkCloneMobile) {
       bulkCloneMobile.addEventListener("click", () => {
        if (selectedNodes.size === 0) return;
        pushUndo("clone selected");
        const nodesToClone = Array.from(selectedNodes);
        selectedNodes.clear();
        nodesToClone.forEach(id => {
         cloneNode(id, true);
         selectedNodes.add(currentNodeId);
        });
        updateNodeSelection();
        closeModalAfterAction();
       });
      }
      const bulkDeleteMobile = document.getElementById("bulk-delete-mobile");
      if (bulkDeleteMobile) {
       bulkDeleteMobile.addEventListener("click", () => {
        deleteSelected();
        closeModalAfterAction();
       });
      }
      const bulkLockMobile = document.getElementById("bulk-lock-mobile");
      if (bulkLockMobile) {
       bulkLockMobile.addEventListener("click", () => {
        toggleLockSelected();
        closeModalAfterAction();
       });
      }
      const bulkGroupMobile = document.getElementById("bulk-group-mobile");
      if (bulkGroupMobile) {
       bulkGroupMobile.addEventListener("click", () => {
        toggleGroupSelected();
        closeModalAfterAction();
       });
      }
      const bulkClearMobile = document.getElementById("bulk-clear-mobile");
      if (bulkClearMobile) {
       bulkClearMobile.addEventListener("click", () => {
        clearSelection();
        closeModalAfterAction();
       });
      }
      const searchInput = document.getElementById("search-nodes");
if (searchInput) {
 searchInput.addEventListener("input", (e) => {
  searchNodes(e.target.value);
 });
}
       document.getElementById("save-file-btn").addEventListener("click", becomeImmortal);
       document.getElementById("check-all-ping-btn").addEventListener("click", checkAllNodesStatus);
       const addNodeBtn = document.getElementById("add-node-btn");
       const addNodeModal = document.getElementById("add-node-modal");
       const addNodeCancel = document.getElementById("add-node-cancel");
       const addNodeSave = document.getElementById("add-node-save");
       addNodeBtn.addEventListener("click", () => {
	    if (isViewOnly()) return;
        document.getElementById("new-node-name").value = "";
        document.getElementById("new-node-ip").value = "";
        document.getElementById("new-node-tags").value = "";
        document.getElementById("new-node-shape").value = "circle";
        document.getElementById("new-node-pingable").checked = false;
        document.getElementById("new-node-ping-protocol").value = "http";
        document.getElementById("new-node-custom-url").value = "";
        document.getElementById("new-node-ping-timeout").value = "3000";
        document.getElementById("new-node-ping-options").style.display = "none";
        document.getElementById("new-node-custom-url-container").style.display = "none";
        newNodeIconTags = [];
        document.getElementById("new-node-icon-tags").style.display = "none";
        document.getElementById("new-node-icon-tags-list").innerHTML = "";
        addNodeModal.classList.add("active");
        document.getElementById("new-node-name").focus();
       });
       const canvasViewport = document.getElementById("canvas-viewport");
       if (canvasViewport) {
        canvasViewport.addEventListener("dblclick", (e) => {
         if (currentView.mode === "rack" && e.target.id === "map") {
          exitRack();
         }
        });
       }
       const layersBtn = document.getElementById("layers-btn");
       const layerModal = document.getElementById("layer-modal");
       const layerModalClose = document.getElementById("layer-modal-close");
       if (layersBtn && layerModal) {
        layersBtn.addEventListener("click", () => {
         layerModal.classList.add("active");
        });
       }
       if (layerModalClose && layerModal) {
        layerModalClose.addEventListener("click", () => {
         layerModal.classList.remove("active");
        });
       }
       if (layerModal) {
        layerModal.addEventListener("click", (e) => {
         if (e.target === layerModal) {
          layerModal.classList.remove("active");
         }
        });
       }
       const tabsBtn = document.getElementById("tabs-btn");
       const tabsModal = document.getElementById("tabs-modal");
       const tabsModalClose = document.getElementById("tabs-modal-close");
       if (tabsBtn && tabsModal) {
         tabsBtn.addEventListener("click", () => {
           displayTabs();
           tabsModal.classList.add("active");
         });
       }
       if (tabsModalClose && tabsModal) {
         tabsModalClose.addEventListener("click", () => {
           tabsModal.classList.remove("active");
         });
       }
       if (tabsModal) {
         tabsModal.addEventListener("click", (e) => {
           if (e.target === tabsModal) {
             tabsModal.classList.remove("active");
           }
         });
       }
       const rollbackBtn = document.getElementById("rollback-btn");
       const rollbackModal = document.getElementById("rollback-modal");
       const rollbackModalClose = document.getElementById("rollback-modal-close");
       if (rollbackBtn && rollbackModal) {
         rollbackBtn.addEventListener("click", () => {
           loadRollbackVersions();
           rollbackModal.classList.add("active");
         });
       }
       if (rollbackModalClose && rollbackModal) {
         rollbackModalClose.addEventListener("click", () => {
           rollbackModal.classList.remove("active");
         });
       }
       if (rollbackModal) {
         rollbackModal.addEventListener("click", (e) => {
           if (e.target === rollbackModal) {
             rollbackModal.classList.remove("active");
           }
         });
       }
       const auditLogBtn = document.getElementById("audit-log-btn");
       const auditLogModal = document.getElementById("audit-log-modal");
       const auditLogModalClose = document.getElementById("audit-log-modal-close");
       if (auditLogBtn && auditLogModal) {
         auditLogBtn.addEventListener("click", () => {
           loadAuditLog();
           displayAuditLog();
           auditLogModal.classList.add("active");
         });
       }
       if (auditLogModalClose && auditLogModal) {
         auditLogModalClose.addEventListener("click", () => {
           auditLogModal.classList.remove("active");
         });
       }
	   const portMapBtn = document.getElementById("port-map-btn");
      const portMapModal = document.getElementById("port-map-modal");
      const portMapClose = document.getElementById("port-map-modal-close");
      const portMapSearch = document.getElementById("port-map-search");
      const portMapFilter = document.getElementById("port-map-filter");
      function renderPortMap() {
        const container = document.getElementById("port-map-table");
        const search = (document.getElementById("port-map-search")?.value || "").toLowerCase();
        const filter = document.getElementById("port-map-filter")?.value || "all";
        let edges = EDGE_DATA.list || [];
        if (filter === "with-ports") edges = edges.filter(e => e.fromPort || e.toPort);
        if (filter === "without-ports") edges = edges.filter(e => !e.fromPort && !e.toPort);
        if (search) {
          edges = edges.filter(e => {
            const fromName = (NODE_DATA[e.from]?.name || e.from || "").toLowerCase();
            const toName = (NODE_DATA[e.to]?.name || e.to || "").toLowerCase();
            return fromName.includes(search) || toName.includes(search) || (e.fromPort || "").toLowerCase().includes(search) || (e.toPort || "").toLowerCase().includes(search) || (e.notes || []).join(" ").toLowerCase().includes(search);
          });
        }
        if (edges.length === 0) {
          container.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No connections found</div>';
          return;
        }
        let html = '<table style="width: 100%; border-collapse: collapse; font-size: 13px;">';
        html += '<thead><tr style="background: var(--panel-alt); position: sticky; top: 0;"><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">From Device</th><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">From Port</th><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">To Device</th><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">To Port</th><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">Notes</th></tr></thead><tbody>';
        edges.forEach(e => {
          const fromName = NODE_DATA[e.from]?.name || e.from;
          const toName = NODE_DATA[e.to]?.name || e.to;
          const notes = (e.notes || []).join(", ");
          html += `<tr style="border-bottom: 1px solid var(--edge-main);"><td style="padding: 10px; cursor: pointer; text-decoration: underline;" onclick="document.getElementById('port-map-modal').classList.remove('active'); claimTheImmortal('${e.from}'); focusOnSelected()">${fromName}</td><td style="padding: 10px; font-family: monospace; color: var(--accent); cursor: pointer;" onclick="document.getElementById('port-map-modal').classList.remove('active'); selectTheConnection('${e.id}'); focusOnSelected()">${e.fromPort || "-"}</td><td style="padding: 10px; cursor: pointer; text-decoration: underline;" onclick="document.getElementById('port-map-modal').classList.remove('active'); claimTheImmortal('${e.to}'); focusOnSelected()">${toName}</td><td style="padding: 10px; font-family: monospace; color: var(--accent); cursor: pointer;" onclick="document.getElementById('port-map-modal').classList.remove('active'); selectTheConnection('${e.id}'); focusOnSelected()">${e.toPort || "-"}</td><td style="padding: 10px; color: var(--text-soft); font-size: 12px;">${notes || "-"}</td></tr>`;
        });
        html += '</tbody></table>';
        container.innerHTML = html;
      }
      window.exportPortMap = function() {
        let csv = "From Device,From Port,To Device,To Port,Notes\n";
        (EDGE_DATA.list || []).forEach(e => {
          const fromName = (NODE_DATA[e.from]?.name || e.from || "").replace(/,/g, ";");
          const toName = (NODE_DATA[e.to]?.name || e.to || "").replace(/,/g, ";");
          const notes = (e.notes || []).join("; ").replace(/,/g, ";");
          csv += `"${fromName}","${e.fromPort || ""}","${toName}","${e.toPort || ""}","${notes}"\n`;
        });
        const blob = new Blob([csv], { type: "text/csv" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "port-map.csv";
        a.click();
        URL.revokeObjectURL(url);
      };
      if (portMapBtn && portMapModal) {
        portMapBtn.addEventListener("click", () => { renderPortMap(); portMapModal.classList.add("active"); });
      }
      if (portMapClose && portMapModal) {
        portMapClose.addEventListener("click", () => { portMapModal.classList.remove("active"); });
      }
      if (portMapSearch) { portMapSearch.addEventListener("input", renderPortMap); }
      if (portMapFilter) { portMapFilter.addEventListener("change", renderPortMap); }
      if (portMapModal) {
        portMapModal.addEventListener("click", (e) => { if (e.target === portMapModal) portMapModal.classList.remove("active"); });
      }
       if (auditLogModal) {
         auditLogModal.addEventListener("click", (e) => {
           if (e.target === auditLogModal) {
             auditLogModal.classList.remove("active");
           }
         });
       }
       const auditFilter = document.getElementById("audit-filter");
       if (auditFilter) {
         auditFilter.addEventListener("change", (e) => {
           displayAuditLog(e.target.value);
         });
       }
       const secretsBtn = document.getElementById("secrets-btn");
       const secretsModal = document.getElementById("secrets-modal");
       const secretsModalClose = document.getElementById("secrets-modal-close");
       if (secretsBtn && secretsModal) {
         secretsBtn.addEventListener("click", () => {
           displaySecrets();
           secretsModal.classList.add("active");
         });
       }
       if (secretsModalClose && secretsModal) {
         secretsModalClose.addEventListener("click", () => {
           secretsModal.classList.remove("active");
         });
       }
       if (secretsModal) {
         secretsModal.addEventListener("click", (e) => {
           if (e.target === secretsModal) {
             secretsModal.classList.remove("active");
           }
         });
       }
       const secretEditorModal = document.getElementById("secret-editor-modal");
       if (secretEditorModal) {
         secretEditorModal.addEventListener("click", (e) => {
           if (e.target === secretEditorModal) {
             closeSecretEditor();
           }
         });
       }
       ["physical", "logical", "security", "application"].forEach(layer => {
        const checkbox = document.getElementById(`layer-${layer}`);
        if (checkbox) {
         checkbox.addEventListener("change", applyLayerFilter);
        }
       });
       const layerSelect = document.getElementById("node-layer");
       if (layerSelect) {
        layerSelect.addEventListener("change", (e) => {
         if (currentNodeId) {
          pushUndo("change layer");
          NODE_DATA[currentNodeId].layer = e.target.value;
          forgeTheTopology();
         }
        });
       }
       const assignedRackSelect = document.getElementById("node-assigned-rack");
       if (assignedRackSelect) {
        assignedRackSelect.addEventListener("change", (e) => {
      if (currentNodeId) {
      pushUndo("change assigned rack");
      EDGE_DATA.list = EDGE_DATA.list.filter(edge => edge.from !== currentNodeId && edge.to !== currentNodeId);
      NODE_DATA[currentNodeId].assignedRack = e.target.value;
      forgeTheTopology();
      claimTheImmortal(currentNodeId);
      }
      });
       }
       const rackCapacitySelect = document.getElementById("node-rack-capacity");
       if (rackCapacitySelect) {
        rackCapacitySelect.addEventListener("change", (e) => {
         if (currentNodeId) {
          pushUndo("change rack capacity");
          NODE_DATA[currentNodeId].rackCapacity = e.target.value;
          forgeTheTopology();
         }
        });
       }
       const addRackBtn = document.getElementById("add-rack-btn");
       const addRackModal = document.getElementById("add-rack-modal");
       const addRackCancel = document.getElementById("add-rack-cancel");
       const addRackSave = document.getElementById("add-rack-save");
       if (addRackBtn && addRackModal) {
        addRackBtn.addEventListener("click", () => {
		if (isViewOnly()) return;
         document.getElementById("new-rack-name").value = "";
         document.getElementById("new-rack-ip").value = "";
         document.getElementById("new-rack-tags").value = "";
         document.getElementById("new-rack-shape").value = "server";
         document.getElementById("new-rack-capacity").value = "42";
         selectedRackIconData = null;
         document.getElementById('selected-rack-icon').style.display = 'none';
         addRackModal.classList.add("active");
         document.getElementById("new-rack-name").focus();
        });
       }
       if (addRackCancel && addRackModal) {
        addRackCancel.addEventListener("click", () => {
         addRackModal.classList.remove("active");
        });
       }
       if (addRackModal) {
        addRackModal.addEventListener("click", (e) => {
         if (e.target === addRackModal) {
          addRackModal.classList.remove("active");
         }
        });
       }
       if (addRackSave && addRackModal) {
        addRackSave.addEventListener("click", () => {
         const name = document.getElementById("new-rack-name").value.trim();
         const ip = document.getElementById("new-rack-ip").value.trim();
         const tagsStr = document.getElementById("new-rack-tags").value.trim();
         const shape = document.getElementById("new-rack-shape").value;
         const capacity = document.getElementById("new-rack-capacity").value;
         if (!name) {
          alert("Please enter a rack name.");
          return;
         }
         const tags = tagsStr ? tagsStr.split(",").map((t) => t.trim()).filter((t) => t) : [];
         let baseId = name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");
         if (!baseId) baseId = "rack";
         let nodeId = baseId;
         let counter = 1;
         while (NODE_DATA[nodeId]) {
          nodeId = baseId + "-" + counter;
          counter++;
         }
         pushUndo("add rack");
         NODE_DATA[nodeId] = {
          shape: shape,
          name: name,
          ip: ip || "",
          role: "Rack",
          tags: tags,
          notes: [],
          mac: "",
          rackUnit: "",
          uHeight: "1",
          layer: "physical",
          assignedRack: "",
          rackCapacity: capacity,
          isRack: true,
          locked: false,
          groupId: null
         };
         const viewWidth = CANVAS_WIDTH / canvasState.zoom;
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         const centerX = canvasState.panX + (viewWidth / 2);
         const centerY = canvasState.panY + (viewHeight / 2);
         savedPositions[nodeId] = {
          x: centerX,
          y: centerY
         };
         if (selectedRackIconData) {
          if (!savedStyles[nodeId]) {
           savedStyles[nodeId] = {};
          }
          if (!savedStyles[nodeId]['all']) {
           savedStyles[nodeId]['all'] = {};
          }
          savedStyles[nodeId]['all'].icon = {
           library: selectedRackIconData.library,
           name: selectedRackIconData.name
          };
          selectedRackIconData = null;
          document.getElementById('selected-rack-icon').style.display = 'none';
         }
         addRackModal.classList.remove("active");
         forgeTheTopology();
         claimTheImmortal(nodeId);
        });
        ["new-rack-name", "new-rack-ip", "new-rack-tags"].forEach((inputId) => {
         const input = document.getElementById(inputId);
         if (input) {
          input.addEventListener("keypress", (e) => {
           if (e.key === "Enter") {
            addRackSave.click();
           }
          });
         }
        });
       }
       addNodeCancel.addEventListener("click", () => {
        addNodeModal.classList.remove("active");
       });
       addNodeModal.addEventListener("click", (e) => {
        if (e.target === addNodeModal) {
         addNodeModal.classList.remove("active");
        }
       });
       addNodeSave.addEventListener("click", () => {
        const name = document.getElementById("new-node-name").value.trim();
        const ip = document.getElementById("new-node-ip").value.trim();
        const tagsStr = document.getElementById("new-node-tags").value.trim();
        const shape = document.getElementById("new-node-shape").value;
        const pingable = document.getElementById("new-node-pingable").checked;
        const pingProtocol = document.getElementById("new-node-ping-protocol").value;
        const pingCustomUrl = document.getElementById("new-node-custom-url").value.trim();
        const pingTimeout = parseInt(document.getElementById("new-node-ping-timeout").value) || 3000;
        if (!name) {
         alert("Please enter a node name.");
         return;
        }
        const tags = tagsStr ? tagsStr.split(",").map((t) => t.trim()).filter((t) => t) : [];
        if (newNodeIconTags.length > 0) {
         tags.push(...newNodeIconTags);
        }
        let baseId = name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");
        if (!baseId) baseId = "node";
        let nodeId = baseId;
        let counter = 1;
        while (NODE_DATA[nodeId]) {
         nodeId = baseId + "-" + counter;
         counter++;
        }
		pushUndo("add node");
        NODE_DATA[nodeId] = {
         shape: shape || "circle",
         name: name,
         ip: ip || "0.0.0.0",
         role: "",
         tags: tags,
         notes: [],
         mac: "",
         rackUnit: "",
         uHeight: "1",
         ping: {
          enabled: pingable,
          protocol: pingProtocol,
          customUrl: pingCustomUrl,
          timeout: pingTimeout,
          status: 'unknown',
          lastCheck: null
         },
         locked: false,
         groupId: null
        };
        if (currentView.mode === "rack" && currentView.rackId) {
         NODE_DATA[nodeId].assignedRack = currentView.rackId;
         NODE_DATA[nodeId].layer = "physical";
         const rackCapacity = getRackCapacity(currentView.rackId);
         const rackUHeight = getRackUHeight(currentView.rackId);
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         const centerY = canvasState.panY + (viewHeight / 2);
         let unit = rackCapacity - Math.round((centerY - RACK_START_Y) / rackUHeight);
         unit = Math.max(1, Math.min(rackCapacity, unit));
         NODE_DATA[nodeId].rackUnit = String(unit);
        }
        if (selectedNodeIconData) {
         if (!savedStyles[nodeId]) savedStyles[nodeId] = {};
         if (!savedStyles[nodeId]['all']) savedStyles[nodeId]['all'] = {};
         savedStyles[nodeId]['all'].icon = {
          library: selectedNodeIconData.library,
          name: selectedNodeIconData.name
         };
         selectedNodeIconData = null;
         document.getElementById('selected-node-icon').style.display = 'none';
        }
        newNodeIconTags = [];
      const viewWidth = CANVAS_WIDTH / canvasState.zoom;
      const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
      const centerX = canvasState.panX + (viewWidth / 2);
      const centerY = canvasState.panY + (viewHeight / 2);
      savedPositions[nodeId] = {
      x: centerX,
      y: centerY
      };
        addNodeModal.classList.remove("active");
        forgeTheTopology();
        claimTheImmortal(nodeId);
       });
       ["new-node-name", "new-node-ip", "new-node-tags"].forEach(
        (inputId) => {
         document.getElementById(inputId).addEventListener("keypress", (e) => {
          if (e.key === "Enter") {
           addNodeSave.click();
          }
         });
        }, );
       document.getElementById('new-node-pingable').addEventListener('change', (e) => {
        const pingOptions = document.getElementById('new-node-ping-options');
        pingOptions.style.display = e.target.checked ? 'block' : 'none';
       });
       document.getElementById('new-node-ping-protocol').addEventListener('change', (e) => {
        const customUrlContainer = document.getElementById('new-node-custom-url-container');
        customUrlContainer.style.display = e.target.value === 'custom' ? 'block' : 'none';
       });
       document.getElementById('pick-rack-icon-btn').addEventListener('click', () => {
        openIconPicker((iconData) => {
         selectedRackIconData = iconData;
         const preview = document.getElementById('selected-rack-icon-preview');
         const container = document.getElementById('selected-rack-icon');
         const parser = new DOMParser();
         const doc = parser.parseFromString(iconData.svg, 'image/svg+xml');
         const svgEl = doc.querySelector('svg');
         preview.innerHTML = '';
         if (svgEl) {
          preview.appendChild(svgEl.cloneNode(true));
         }
         const nameSpan = document.createElement('span');
         nameSpan.textContent = iconData.name;
         preview.appendChild(nameSpan);
         container.style.display = 'block';
        });
       });
       document.getElementById('pick-node-icon-btn').addEventListener('click', () => {
        openIconPicker((iconData) => {
         selectedNodeIconData = iconData;
         const preview = document.getElementById('selected-node-icon-preview');
         const container = document.getElementById('selected-node-icon');
         const parser = new DOMParser();
         const doc = parser.parseFromString(iconData.svg, 'image/svg+xml');
         const svgEl = doc.querySelector('svg');
         preview.innerHTML = '';
         if (svgEl) {
          preview.appendChild(svgEl.cloneNode(true));
         }
         const nameSpan = document.createElement('span');
         nameSpan.textContent = iconData.name;
         preview.appendChild(nameSpan);
         container.style.display = 'block';
        });
       });
       document.getElementById('pick-tag-icon-btn').addEventListener('click', () => {
        if (!currentNodeId) return;
        openIconPicker((iconData) => {
         if (!currentNodeId || !NODE_DATA[currentNodeId]) return;
         if (!NODE_DATA[currentNodeId].tags) {
          NODE_DATA[currentNodeId].tags = [];
         }
         NODE_DATA[currentNodeId].tags.push({
          type: 'icon',
          library: iconData.library,
          name: iconData.name
         });
         forgeTheTopology();
         claimTheImmortal(currentNodeId);
        });
       });
       document.getElementById('pick-new-node-tag-icon-btn').addEventListener('click', () => {
        openIconPicker((iconData) => {
         newNodeIconTags.push({
          type: 'icon',
          library: iconData.library,
          name: iconData.name
         });
         const container = document.getElementById('new-node-icon-tags');
         const list = document.getElementById('new-node-icon-tags-list');
         const badge = document.createElement('div');
         badge.className = 'icon-badge';
         badge.style.cssText = 'display: inline-flex; align-items: center; gap: 6px; padding: 6px 10px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; font-size: 13px;';
         const iconPreview = document.createElement('div');
         iconPreview.style.cssText = 'width: 16px; height: 16px; display: flex; align-items: center; justify-content: center;';
         IconLibrary.getIcon(iconData.library, iconData.name).then(svg => {
          if (svg) {
           const parser = new DOMParser();
           const doc = parser.parseFromString(svg, 'image/svg+xml');
           const svgEl = doc.querySelector('svg');
           if (svgEl) {
            svgEl.setAttribute('width', '16');
            svgEl.setAttribute('height', '16');
            svgEl.style.fill = 'var(--text-main)';
            iconPreview.appendChild(svgEl);
           }
          }
         });
         const name = document.createElement('span');
         name.textContent = iconData.name;
         name.style.color = 'var(--text-soft)';
         const removeBtn = document.createElement('button');
         removeBtn.textContent = '√ó';
         removeBtn.style.cssText = 'background: none; border: none; color: var(--danger); cursor: pointer; font-size: 18px; line-height: 1; padding: 0 4px;';
         removeBtn.addEventListener('click', () => {
          const index = newNodeIconTags.findIndex(t => t.type === 'icon' && t.library === iconData.library && t.name === iconData.name);
          if (index > -1) {
           newNodeIconTags.splice(index, 1);
          }
          badge.remove();
          if (list.children.length === 0) {
           container.style.display = 'none';
          }
         });
         badge.appendChild(iconPreview);
         badge.appendChild(name);
         badge.appendChild(removeBtn);
         list.appendChild(badge);
         container.style.display = 'block';
        });
       });
       document.getElementById('pick-shape-icon-btn').addEventListener('click', () => {
        if (!currentNodeId) return;
        openIconPicker((iconData) => {
         if (!savedStyles[currentNodeId]) {
          savedStyles[currentNodeId] = {};
         }
         if (!savedStyles[currentNodeId][currentStyleScope]) {
          savedStyles[currentNodeId][currentStyleScope] = {};
         }
         savedStyles[currentNodeId][currentStyleScope].icon = {
          library: iconData.library,
          name: iconData.name
         };
		 delete savedStyles[currentNodeId][currentStyleScope].circleColor;
         delete savedStyles[currentNodeId][currentStyleScope].circleBorder;
         const shapeSelect = document.getElementById('shape-select');
         if (!shapeSelect.querySelector('option[value="custom-icon"]')) {
          const opt = document.createElement('option');
          opt.value = 'custom-icon';
          opt.textContent = 'Custom Icon';
          shapeSelect.insertBefore(opt, shapeSelect.firstChild);
         }
         shapeSelect.value = 'custom-icon';
         forgeTheTopology();
        });
       });
       document.getElementById('add-tag-btn').addEventListener('click', () => {
        if (!currentNodeId) return;
        if (!NODE_DATA[currentNodeId]) return;
        const input = document.getElementById('new-tag-input');
        const tagText = input.value.trim();
        if (!tagText) return;
        if (!NODE_DATA[currentNodeId].tags) {
         NODE_DATA[currentNodeId].tags = [];
        }
        NODE_DATA[currentNodeId].tags.push(tagText);
        input.value = '';
        forgeTheTopology();
        claimTheImmortal(currentNodeId);
       });
      function saveRollbackVersion(description = "Auto-save") {
        const version = {
          timestamp: Date.now(),
          description,
          data: captureTheQuickening()
        };
        try {
          const stored = localStorage.getItem(ROLLBACK_STORAGE_KEY);
          rollbackVersions = stored ? JSON.parse(stored) : [];
        } catch (e) {
          rollbackVersions = [];
        }
        rollbackVersions.unshift(version);
        if (rollbackVersions.length > MAX_ROLLBACK_VERSIONS) {
          rollbackVersions = rollbackVersions.slice(0, MAX_ROLLBACK_VERSIONS);
        }
        try {
          localStorage.setItem(ROLLBACK_STORAGE_KEY, JSON.stringify(rollbackVersions));
        } catch (e) {
          console.warn("Failed to save rollback version:", e);
        }
      }
      function loadRollbackVersions() {
        try {
          const stored = localStorage.getItem(ROLLBACK_STORAGE_KEY);
          rollbackVersions = stored ? JSON.parse(stored) : [];
          displayRollbackVersions();
        } catch (e) {
          console.warn("Failed to load rollback versions:", e);
          rollbackVersions = [];
        }
      }
      function displayRollbackVersions() {
        const listEl = document.getElementById("rollback-list");
        if (!listEl) return;
        if (rollbackVersions.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No version history yet. Versions are saved automatically when you save the file.</div>';
          return;
        }
        listEl.innerHTML = rollbackVersions.map((version, index) => {
          const date = new Date(version.timestamp);
          const timeStr = date.toLocaleString();
          const nodeCount = Object.keys(version.data.nodeData || {}).length;
          const edgeCount = (version.data.edgeData?.list || []).length;
          return `
            <div class="version-item" onclick="restoreRollbackVersion(${index})">
              <div class="version-info">
                <div class="timestamp">${timeStr}</div>
                <div class="details">${version.description} ‚Ä¢ ${nodeCount} nodes ‚Ä¢ ${edgeCount} connections</div>
              </div>
              <div class="version-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteRollbackVersion(${index})" title="Delete this version">üóëÔ∏è</button>
              </div>
            </div>
          `;
        }).join('');
      }
      function restoreRollbackVersion(index) {
        if (!confirm(`Restore version from ${new Date(rollbackVersions[index].timestamp).toLocaleString()}?\n\nYour current work will be lost unless you save first.`)) {
          return;
        }
        const version = rollbackVersions[index];
        const data = version.data;
        NODE_DATA = data.nodeData || {};
        EDGE_DATA = data.edgeData || { list: [] };
        RECT_DATA = data.rectData || { list: [] };
        TEXT_DATA = data.textData || { list: [] };
        EDGE_LEGEND = data.edgeLegend || {};
        savedPositions = data.nodePositions || {};
        savedSizes = data.nodeSizes || {};
        savedStyles = data.nodeStyles || {};
        PAGE_STATE = data.page || PAGE_STATE;
        if (data.canvas) {
          canvasState.zoom = data.canvas.zoom;
          canvasState.panX = data.canvas.panX;
          canvasState.panY = data.canvas.panY;
        }
        wieldThePower();
        forgeTheTopology();
        document.getElementById("rollback-modal").classList.remove("active");
        logAuditEvent("rollback", `Restored version from ${new Date(version.timestamp).toLocaleString()}`);
      }
      function deleteRollbackVersion(index) {
        if (!confirm("Delete this version from history?")) return;
        rollbackVersions.splice(index, 1);
        try {
          localStorage.setItem(ROLLBACK_STORAGE_KEY, JSON.stringify(rollbackVersions));
        } catch (e) {
          console.warn("Failed to delete version:", e);
        }
        displayRollbackVersions();
      }
      function clearRollbackHistory() {
        if (!confirm("Clear all version history?\n\nThis cannot be undone.")) return;
        rollbackVersions = [];
        localStorage.removeItem(ROLLBACK_STORAGE_KEY);
        displayRollbackVersions();
      }
      function createManualSnapshot() {
        const description = prompt("Enter a description for this snapshot:", "Manual snapshot");
        if (!description) return;
        saveRollbackVersion(description);
        displayRollbackVersions();
      }
      function switchTab(index) {
        if (index === currentTabIndex) return;
        const currentTab = documentTabs[currentTabIndex];
        currentTab.nodes = JSON.parse(JSON.stringify(NODE_DATA));
        currentTab.edges = JSON.parse(JSON.stringify(EDGE_DATA));
        currentTab.positions = JSON.parse(JSON.stringify(savedPositions));
        currentTab.sizes = JSON.parse(JSON.stringify(savedSizes));
        currentTab.styles = JSON.parse(JSON.stringify(savedStyles));
        currentTab.legend = JSON.parse(JSON.stringify(EDGE_LEGEND));
        currentTab.rects = JSON.parse(JSON.stringify(RECT_DATA));
        currentTab.texts = JSON.parse(JSON.stringify(TEXT_DATA));
        currentTab.pageState = JSON.parse(JSON.stringify(PAGE_STATE));
        currentTabIndex = index;
        const newTab = documentTabs[index];
        NODE_DATA = JSON.parse(JSON.stringify(newTab.nodes));
        EDGE_DATA = JSON.parse(JSON.stringify(newTab.edges));
        savedPositions = JSON.parse(JSON.stringify(newTab.positions));
        savedSizes = JSON.parse(JSON.stringify(newTab.sizes));
        savedStyles = JSON.parse(JSON.stringify(newTab.styles));
        EDGE_LEGEND = JSON.parse(JSON.stringify(newTab.legend));
        RECT_DATA = JSON.parse(JSON.stringify(newTab.rects));
        TEXT_DATA = JSON.parse(JSON.stringify(newTab.texts));
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, newTab.pageState || {});
        wieldThePower();
        document.title = PAGE_STATE.title || newTab.name;
        document.getElementById("page-title").textContent = PAGE_STATE.title || newTab.name;
        forgeTheTopology();
        currentNodeId = null;
        currentEdgeId = null;
        currentTextId = null;
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        displayTabs();
        logAuditEvent("tab", `Switched to tab: ${newTab.name}`);
      }
      function createNewTab() {
        const nameInput = document.getElementById("new-tab-name");
        const name = nameInput.value.trim();
        if (!name) {
          alert("Please enter a tab name");
          return;
        }
        const newTab = {
          id: `tab-${Date.now()}`,
          name,
          nodes: {},
          edges: { list: [] },
          positions: {},
          sizes: {},
          styles: {},
          legend: {},
          rects: { list: [] },
          texts: { list: [] },
      pageState: null
        };
        documentTabs.push(newTab);
        nameInput.value = "";
        displayTabs();
        logAuditEvent("tab", `Created new tab: ${name}`);
      }
      function renameTab(index) {
        const tab = documentTabs[index];
        const newName = prompt("Enter new name:", tab.name);
        if (!newName || newName === tab.name) return;
        tab.name = newName;
        displayTabs();
        logAuditEvent("tab", `Renamed tab to: ${newName}`);
      }
      function deleteTab(index) {
        if (documentTabs.length === 1) {
          alert("Cannot delete the last tab");
          return;
        }
        if (!confirm(`Delete tab "${documentTabs[index].name}"?`)) return;
        const wasCurrentTab = (index === currentTabIndex);
        documentTabs.splice(index, 1);
        if (currentTabIndex >= documentTabs.length) {
          currentTabIndex = documentTabs.length - 1;
        } else if (index < currentTabIndex) {
          currentTabIndex--;
        }
        if (wasCurrentTab) {
          const newTab = documentTabs[currentTabIndex];
          NODE_DATA = JSON.parse(JSON.stringify(newTab.nodes));
          EDGE_DATA = JSON.parse(JSON.stringify(newTab.edges));
          savedPositions = JSON.parse(JSON.stringify(newTab.positions));
          savedSizes = JSON.parse(JSON.stringify(newTab.sizes));
          savedStyles = JSON.parse(JSON.stringify(newTab.styles));
          EDGE_LEGEND = JSON.parse(JSON.stringify(newTab.legend));
          RECT_DATA = JSON.parse(JSON.stringify(newTab.rects));
          TEXT_DATA = JSON.parse(JSON.stringify(newTab.texts));
          PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, newTab.pageState || {});
          wieldThePower();
          forgeTheTopology();
          currentNodeId = null;
          currentEdgeId = null;
          currentTextId = null;
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("text-panel").style.display = "none";
        }
        displayTabs();
        logAuditEvent("tab", `Deleted tab`);
      }
      function displayTabs() {
        const listEl = document.getElementById("tabs-list");
        if (!listEl) return;
        listEl.innerHTML = documentTabs.map((tab, index) => {
          const nodeCount = Object.keys(tab.nodes).length;
          const edgeCount = tab.edges.list.length;
          const isActive = index === currentTabIndex;
          return `
            <div class="tab-item ${isActive ? 'active' : ''}" onclick="switchTab(${index})">
              <div class="tab-name">${tab.name}</div>
              <div class="tab-stats">${nodeCount} nodes ‚Ä¢ ${edgeCount} connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(${index})" title="Rename tab">‚úèÔ∏è</button>
                ${documentTabs.length > 1 ? '<button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(' + index + ')" title="Delete tab">üóëÔ∏è</button>' : ''}
              </div>
            </div>
          `;
        }).join('');
      }
      function logAuditEvent(type, description, details = {}) {
        const event = {
          timestamp: Date.now(),
          type,
          description,
          details,
          tab: documentTabs[currentTabIndex]?.name || "Main"
        };
        auditLog.unshift(event);
        if (auditLog.length > MAX_AUDIT_ENTRIES) {
          auditLog = auditLog.slice(0, MAX_AUDIT_ENTRIES);
        }
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to save audit log:", e);
        }
      }
      function loadAuditLog() {
        let embeddedLog = [];
        let localLog = [];
        try {
          const stateScript = document.getElementById("topology-state");
          if (stateScript) {
            const stateData = JSON.parse(stateScript.textContent);
            if (stateData.auditLog && Array.isArray(stateData.auditLog)) {
              embeddedLog = stateData.auditLog;
            }
          }
        } catch (e) {
          console.warn("Failed to load embedded audit log:", e);
        }
        try {
          const stored = localStorage.getItem(AUDIT_STORAGE_KEY);
          if (stored) {
            localLog = JSON.parse(stored);
          }
        } catch (e) {
          console.warn("Failed to load localStorage audit log:", e);
        }
        const merged = [...embeddedLog, ...localLog];
        const seen = new Set();
        auditLog = merged.filter(entry => {
          const key = entry.timestamp + entry.description;
          if (seen.has(key)) return false;
          seen.add(key);
          return true;
        }).sort((a, b) => b.timestamp - a.timestamp);
        if (auditLog.length > MAX_AUDIT_ENTRIES) {
          auditLog = auditLog.slice(0, MAX_AUDIT_ENTRIES);
        }
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to sync audit log:", e);
        }
      }
      function displayAuditLog(filter = "all") {
        const listEl = document.getElementById("audit-log-list");
        if (!listEl) return;
        const filtered = filter === "all" ? auditLog : auditLog.filter(e => e.type === filter);
        if (filtered.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No audit entries yet</div>';
          return;
        }
        listEl.innerHTML = filtered.map(event => {
          const date = new Date(event.timestamp);
          const timeStr = date.toLocaleString();
          return `<div class="audit-entry ${event.type}">
              <div class="time">[${timeStr}] ${event.tab}</div>
              <div class="action">[${event.type.toUpperCase()}] ${event.description}</div>
            </div>
          `;
        }).join('');
      }
      function clearAuditLog() {
        if (!confirm("Clear all audit log entries?\n\nThis cannot be undone.")) return;
        auditLog = [];
        localStorage.removeItem(AUDIT_STORAGE_KEY);
        displayAuditLog();
      }
      function exportAuditLog() {
        if (auditLog.length === 0) {
          alert("No audit entries to export");
          return;
        }
        const csv = [
          ["Timestamp", "Tab", "Type", "Description"],
          ...auditLog.map(e => [
            new Date(e.timestamp).toISOString(),
            e.tab,
            e.type,
            e.description
          ])
        ].map(row => row.map(cell => `"${cell}"`).join(",")).join("\n");
        const blob = new Blob([csv], { type: "text/csv" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `audit-log-${Date.now()}.csv`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }
      let currentSecretName = null;
      function createNewSecret() {
        const nameInput = document.getElementById("new-secret-name");
        const name = nameInput.value.trim();
        if (!name) {
          alert("Please enter a note name");
          return;
        }
        if (encryptedSections[name]) {
          alert("A note note with this name already exists");
          return;
        }
        currentSecretName = name;
        encryptedSections[name] = { encrypted: false, data: "" };
        nameInput.value = "";
        document.getElementById("secret-editor-title").textContent = `New note: ${name}`;
        document.getElementById("secret-editor-content").value = "";
        document.getElementById("secrets-modal").classList.remove("active");
        document.getElementById("secret-editor-modal").classList.add("active");
        displaySecrets();
      }
      function editSecret(name) {
        currentSecretName = name;
        const section = encryptedSections[name];
        if (section.encrypted) {
          const password = prompt(`Enter password to decrypt "${name}":`);
          if (!password) return;
          try {
            decryptData(section.data, password).then(decrypted => {
              document.getElementById("secret-editor-title").textContent = `Edit Secret: ${name}`;
              document.getElementById("secret-editor-content").value = decrypted;
              document.getElementById("secrets-modal").classList.remove("active");
              document.getElementById("secret-editor-modal").classList.add("active");
            }).catch(e => {
              alert("Failed to decrypt. Wrong password?");
            });
          } catch (e) {
            alert("Failed to decrypt. Wrong password?");
          }
        } else {
          document.getElementById("secret-editor-title").textContent = `Edit note: ${name}`;
          document.getElementById("secret-editor-content").value = section.data;
          document.getElementById("secrets-modal").classList.remove("active");
          document.getElementById("secret-editor-modal").classList.add("active");
        }
      }
      async function saveSecret() {
        if (!currentSecretName) return;
        const content = document.getElementById("secret-editor-content").value;
        const autoEncrypt = document.getElementById("secret-auto-encrypt").checked;
        if (autoEncrypt) {
          const password = prompt(`Enter password to encrypt "${currentSecretName}":`);
          if (!password) return;
          const confirmPassword = prompt("Confirm password:");
          if (password !== confirmPassword) {
            alert("Passwords do not match");
            return;
          }
          try {
            const encrypted = await encryptData(content, password);
            encryptedSections[currentSecretName] = { encrypted: true, data: encrypted };
          } catch (e) {
            alert("Encryption failed: " + e.message);
            return;
          }
        } else {
          encryptedSections[currentSecretName] = { encrypted: false, data: content };
        }
        closeSecretEditor();
        displaySecrets();
        logAuditEvent("secret", `Saved note section: ${currentSecretName}`);
      }
      function closeSecretEditor() {
        document.getElementById("secret-editor-modal").classList.remove("active");
        document.getElementById("secrets-modal").classList.add("active");
        currentSecretName = null;
      }
      function deleteSecret(name) {
        if (!confirm(`Delete note "${name}"?`)) return;
        delete encryptedSections[name];
        displaySecrets();
        logAuditEvent("secret", `Deleted note: ${name}`);
      }
      function displaySecrets() {
        const listEl = document.getElementById("secrets-list");
        if (!listEl) return;
        const secrets = Object.keys(encryptedSections);
        if (secrets.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No notes yet</div>';
          return;
        }
        listEl.innerHTML = secrets.map(name => {
          const section = encryptedSections[name];
          const status = section.encrypted ? "üîí Encrypted" : "üîì Plaintext";
          return `
            <div class="secret-item">
              <div class="secret-name">${name}</div>
              <div class="secret-status">${status}</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="editSecret('${name}')" title="Edit note">‚úèÔ∏è</button>
                <button class="btn-cancel" onclick="deleteSecret('${name}')" title="Delete note">üóëÔ∏è</button>
              </div>
            </div>
          `;
        }).join('');
      }
       const clearAllBtn = document.getElementById("clear-all-btn");
       const clearAllModal = document.getElementById("clear-all-modal");
       const clearAllCancel = document.getElementById("clear-all-cancel");
       const clearAllConfirm = document.getElementById("clear-all-confirm");
       clearAllBtn.addEventListener("click", () => {
        clearAllModal.classList.add("active");
       });
       clearAllCancel.addEventListener("click", () => {
        clearAllModal.classList.remove("active");
       });
       clearAllModal.addEventListener("click", (e) => {
        if (e.target === clearAllModal) {
         clearAllModal.classList.remove("active");
        }
       });
       clearAllConfirm.addEventListener("click", () => {
        pushUndo("clear all");
        NODE_DATA = {};
        EDGE_DATA = {
         list: []
        };
        EDGE_LEGEND = {};
        RECT_DATA = { list: [] };
        TEXT_DATA = { list: [] };
        savedPositions = {};
        savedSizes = {};
        savedStyles = {};
		logAuditEvent("clear", "Cleared all data from canvas");
        clearAllModal.classList.remove("active");
      autoPingEnabled = false;
      autoPingInterval = 30;
      PAGE_STATE.autoPingEnabled = false;
      PAGE_STATE.autoPingInterval = autoPingInterval;
      stopAutoPing();
      document.getElementById("auto-ping-enabled").checked = false;
      document.getElementById("auto-ping-settings").style.display = "none";
      document.getElementById("auto-ping-interval").value = autoPingInterval;
        forgeTheTopology();
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.display = "none";
        currentNodeId = null;
        currentEdgeId = null;
        currentTextId = null;
       });
       (function addDeleteNodeButton() {
       const nodePanel = document.getElementById("node-panel");
       if (!nodePanel) return;
       let deleteBtn = document.getElementById("delete-node-btn");
       if (!deleteBtn) {
        deleteBtn = document.createElement("button");
        deleteBtn.id = "delete-node-btn";
        deleteBtn.textContent = "Delete Node";
        deleteBtn.style.cssText = "margin-top:15px; padding:10px 16px; background:var(--danger); color:#fff; border:none; border-radius:6px; cursor:pointer; font-size:clamp(14px,1.6vw,18px); font-weight:600; width:100%;";
        nodePanel.appendChild(deleteBtn);
       }
       deleteBtn.addEventListener("click", () => {
        if (!currentNodeId) return;
        const nodeData = NODE_DATA[currentNodeId];
        let confirmMessage;
        let nodesInsideRack = [];
        if (nodeData?.isRack) {
         nodesInsideRack = Object.entries(NODE_DATA)
          .filter(([id, n]) => n.assignedRack === currentNodeId)
          .map(([id, n]) => n.name || id);
         if (nodesInsideRack.length > 0) {
          confirmMessage = `Delete rack "${nodeData.name}"?\n\nThis will also delete ${nodesInsideRack.length} node(s) inside:\n‚Ä¢ ${nodesInsideRack.join('\n‚Ä¢ ')}`;
         } else {
          confirmMessage = `Delete rack "${nodeData.name}"? (empty rack)`;
         }
        } else {
         confirmMessage = `Delete node "${nodeData?.name || currentNodeId}" and all its connections?`;
        }
        challengeTheImmortal(confirmMessage, () => {
         pushUndo("delete node");
         if (nodeData?.isRack) {
          Object.keys(NODE_DATA).forEach(id => {
           if (NODE_DATA[id]?.assignedRack === currentNodeId) {
            EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== id && e.to !== id);
            delete NODE_DATA[id];
            delete savedPositions[id];
            delete savedSizes[id];
            delete savedStyles[id];
           }
          });
         }
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== currentNodeId && e.to !== currentNodeId);
         delete NODE_DATA[currentNodeId];
         delete savedPositions[currentNodeId];
         delete savedSizes[currentNodeId];
         delete savedStyles[currentNodeId];
         currentNodeId = null;
         currentEdgeId = null;
         forgeTheTopology();
         const remainingNodes = Object.keys(NODE_DATA);
         if (remainingNodes.length > 0) {
          claimTheImmortal(remainingNodes[0]);
         } else {
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("topology-toolbar").style.display = "none";
         }
        });
       });
      })();
       function screenshotCanvas() {
        const svg = document.getElementById("map");
        const svgClone = svg.cloneNode(true);
        const viewBox = svg.getAttribute("viewBox").split(" ").map(Number);
        const [x, y, width, height] = viewBox;
        svgClone.setAttribute("width", width);
        svgClone.setAttribute("height", height);
        svgClone.setAttribute("viewBox", `${x} ${y} ${width} ${height}`);
        const wrapper = document.createElement("div");
        wrapper.style.position = "absolute";
        wrapper.style.left = "-9999px";
        wrapper.appendChild(svgClone);
        document.body.appendChild(wrapper);
        function inlineStyles(original, clone) {
         const elements = original.querySelectorAll("*");
         const clonedElements = clone.querySelectorAll("*");
         const rootStyles = getComputedStyle(document.documentElement);
         const bgColor = rootStyles.getPropertyValue("--bg").trim() || "#050608";
         const bgRect = document.createElementNS("http://www.w3.org/2000/svg", "rect", );
         bgRect.setAttribute("x", x);
         bgRect.setAttribute("y", y);
         bgRect.setAttribute("width", width);
         bgRect.setAttribute("height", height);
         bgRect.setAttribute("fill", bgColor);
         clone.insertBefore(bgRect, clone.firstChild);
         elements.forEach((el, index) => {
          const clonedEl = clonedElements[index];
          if (!clonedEl) return;
          const computedStyle = getComputedStyle(el);
          const svgProps = ["fill", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin", "opacity", "font-family", "font-size", "font-weight", "font-style", "text-anchor", "dominant-baseline", "marker-start", "marker-end", ];
          svgProps.forEach((prop) => {
           const value = computedStyle.getPropertyValue(prop);
           if (value && value !== "none" && value !== "normal") {
            clonedEl.style[prop] = value;
           }
          });
          clonedEl.removeAttribute("class");
         });
        }
        inlineStyles(svg, svgClone);
        const svgData = new XMLSerializer().serializeToString(svgClone);
        document.body.removeChild(wrapper);
        const svgBlob = new Blob([svgData], {
         type: "image/svg+xml;charset=utf-8",
        });
        const url = URL.createObjectURL(svgBlob);
        const img = new Image();
        img.onload = function() {
         const canvas = document.createElement("canvas");
         canvas.width = width;
         canvas.height = height;
         const ctx = canvas.getContext("2d");
         ctx.drawImage(img, 0, 0);
         canvas.toBlob(function(blob) {
          const link = document.createElement("a");
          const timestamp = new Date().toISOString().slice(0, 10);
          link.download = `topology-${timestamp}.png`;
          link.href = URL.createObjectURL(blob);
          link.click();
          URL.revokeObjectURL(url);
          URL.revokeObjectURL(link.href);
         }, "image/png");
        };
        img.onerror = function() {
         console.error("Failed to load SVG image");
         alert("Screenshot failed. Please try again.");
         URL.revokeObjectURL(url);
        };
        img.src = url;
       }
       function exportCanvasSVG() {
        const svg = document.getElementById("map");
        const svgClone = svg.cloneNode(true);
        const viewBox = svg.getAttribute("viewBox").split(" ").map(Number);
        const [x, y, width, height] = viewBox;
        svgClone.setAttribute("width", width);
        svgClone.setAttribute("height", height);
        const rootStyles = getComputedStyle(document.documentElement);
        const bgColor = rootStyles.getPropertyValue("--bg").trim() || "#050608";
        const bgRect = document.createElementNS("http://www.w3.org/2000/svg", "rect", );
        bgRect.setAttribute("x", x);
        bgRect.setAttribute("y", y);
        bgRect.setAttribute("width", width);
        bgRect.setAttribute("height", height);
        bgRect.setAttribute("fill", bgColor);
        svgClone.insertBefore(bgRect, svgClone.firstChild);
        const wrapper = document.createElement("div");
        wrapper.style.position = "absolute";
        wrapper.style.left = "-9999px";
        wrapper.appendChild(svgClone);
        document.body.appendChild(wrapper);
        const elements = svg.querySelectorAll("*");
        const clonedElements = svgClone.querySelectorAll("*");
        elements.forEach((el, index) => {
         const clonedEl = clonedElements[index];
         if (!clonedEl) return;
         const computedStyle = getComputedStyle(el);
         const svgProps = ["fill", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin", "opacity", "font-family", "font-size", "font-weight", "font-style", "text-anchor", "dominant-baseline", "marker-start", "marker-end", ];
         svgProps.forEach((prop) => {
          const value = computedStyle.getPropertyValue(prop);
          if (value && value !== "none" && value !== "normal") {
           clonedEl.setAttribute(prop, value);
          }
         });
         clonedEl.removeAttribute("class");
        });
        const svgData = new XMLSerializer().serializeToString(svgClone);
        document.body.removeChild(wrapper);
        const blob = new Blob([svgData], {
         type: "image/svg+xml;charset=utf-8",
        });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        const timestamp = new Date().toISOString().slice(0, 10);
        link.download = `topology-${timestamp}.svg`;
        link.href = url;
        link.click();
        URL.revokeObjectURL(url);
       }
      let resizeTimeout;
       window.addEventListener('resize', () => {
       clearTimeout(resizeTimeout);
       resizeTimeout = setTimeout(() => {
       updateDrawToolbarVisibility();
       updateTopologyToolbarVisibility();
       }, 100);
      });
    </script>
</body></html>