<!DOCTYPE html> 
 <html lang="en" style="--panel: #2f0e0e; --panel-alt: #10141b; --accent: #a75252; --danger: #f56565; --text-main: #e2e8f0; --text-soft: #94a3b8; --topbar-bg: rgba(9, 12, 20, 0.9); --topbar-border: #1f2533; --topbar-height: 112px; --sidebar-width: 350px; --mobile-footer-height: 40vh; --draw-toolbar-height: 45px; --sidebar-bg: #10141b; --btn-bg: #0b0e13; --btn-text: #e2e8f0; --tag-fill: #1e293b; --tag-text: #e2e8f0; --tag-border: #475569; --input-bg: #0b0e13; --input-text: #e2e8f0; --input-border: #1f2937; --input-font: Inter, system-ui, sans-serif; --input-font-size: 14px; --toolbar-bg: #441215; --toolbar-border: #1f2937; --toolbar-text: #94a3b8; --toolbar-btn-bg: #0b0e13; --toolbar-btn-text: #e2e8f0; --minimap-dots: #94a3b8; --canvas-hint-bg: #0f172a; --canvas-hint-color: #94a3b8; --node-fill: #1e293b; --node-stroke: #475569; --node-title: #e2e8f0; --node-sub: #94a3b8; --node-title-size: 18px; --node-sub-size: 13px; --node-font: Inter, system-ui, sans-serif; --default-edge: #475569; --selection-handle: #f59e0b; --selection-handle-size: 8px; --group-indicator: #4fd1c5;"><head>
    <meta charset="UTF-8">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>The One File</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- 
      * ==================================================================================
      * The One File: The Networkening
      * !!!!!!!!!!!!!!!!!!!NOTE: THIS IS THE ONLINE VERSION!!!!!!!!!!!!!!!!!!!!!!
      * Online version uses 3 cdn calls from cdn.jsdelivr.net to display additional icons
      * Since 3.0 Online version uses http as a form of ping to display uptime
      * "There can be only one". A all in one file topology maker.
      * 
      * This is your last backup when all others fail. A completely self-contained
      * network topology visualization tool that works as a single HTML file.
      * Open it anywhere, anytime and the idea lives forever.
      * ==================================================================================
      -->
    <style>
      :root {
      color-scheme: dark;
      --bg: #050608;
      --panel: #0b0e13;
      --panel-alt: #10141b;
      --accent: #4fd1c5;
      --danger: #f56565;
      --text-main: #e2e8f0;
      --text-soft: #94a3b8;
      --edge-main: #475569;
      --node-min: 35px;
      --node-max: 70px;
      --topbar-bg: rgba(9, 12, 20, 0.9);
      --topbar-border: #1f2533;
      }
	  html, body, svg, .map-container {
      touch-action: none;
      }
      * {
      box-sizing: border-box;
      user-select: none;
      }
      input,
      textarea,
      [contenteditable="true"] {
      user-select: text;
      -webkit-user-select: text;
      }
      body {
      margin: 0;
      font-family: system-ui, sans-serif;
      background: radial-gradient(circle at top, #1e2532 0, #050608 70%);
      color: var(--text-main);
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
      }
      header {
      padding: 0 20px;
      height: var(--topbar-height, 52px);
      min-height: var(--topbar-height, 52px);
      background: var(--topbar-bg);
      backdrop-filter: blur(6px);
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid var(--topbar-border);
      gap: 16px;
      }
      .title-block {
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-width: 0;
      }
      header h1 {
      font-size: clamp(22px, 3vw, 32px);
      margin: 0;
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
      }
      .editable-page-title {
      cursor: pointer;
      transition: opacity 0.2s;
      }
      .editable-page-title:hover {
      opacity: 0.7;
      }
      .save-row {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      }
      .save-btn {
      padding: 6px 12px;
      background: var(--accent);
      color: var(--bg);
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      white-space: nowrap;
      }
      .save-btn:hover {
      opacity: 0.9;
      }
      .help-icon {
      width: 22px;
      height: 22px;
      border-radius: 50%;
      border: 1px solid var(--edge-main);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      cursor: pointer;
      color: var(--text-soft);
      background: rgba(15, 23, 42, 0.9);
      flex-shrink: 0;
      }
      .help-icon:hover {
      color: var(--accent);
      border-color: var(--accent);
      }
      #settings-btn {
      background: var(--btn-bg, var(--panel));
      color: var(--btn-text, var(--text-main));
      border: 1px solid var(--edge-main);
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 16px;
      flex-shrink: 0;
      }
      #settings-btn:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .header-resizer {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 6px;
      background: transparent;
      cursor: row-resize;
      z-index: 1000;
      transition: background 0.2s;
      }
      .header-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .header-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      .sidebar-resizer {
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 6px;
      background: transparent;
      cursor: col-resize;
      z-index: 1000;
      transition: background 0.2s;
      }
      .sidebar-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .sidebar-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      .mobile-footer-resizer {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 6px;
      background: transparent;
      cursor: row-resize;
      z-index: 1000;
      transition: background 0.2s;
      display: none;
      }
      .mobile-footer-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .mobile-footer-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      @media (max-width: 900px) {
      .mobile-footer-resizer {
      display: block;
      height: 12px;
      }
      .sidebar-resizer {
      display: none;
      }
      .header-resizer {
      height: 12px;
      }
      }
      @media (pointer: coarse) {
      .header-resizer {
      height: 16px;
      }
      .mobile-footer-resizer {
      height: 16px;
      }
      .sidebar-resizer {
      width: 16px;
      }
      }
      .resizer-icon {
      position: absolute;
      opacity: 0.5;
      transition: opacity 0.2s, transform 0.2s;
      pointer-events: none;
      fill: var(--accent);
      }
      .header-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .sidebar-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .mobile-footer-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .header-resizer:hover .resizer-icon,
      .sidebar-resizer:hover .resizer-icon,
      .mobile-footer-resizer:hover .resizer-icon {
      opacity: 1;
      }
      .header-resizer.resizing .resizer-icon,
      .sidebar-resizer.resizing .resizer-icon,
      .mobile-footer-resizer.resizing .resizer-icon {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1.2);
      }
      body.resizing {
      user-select: none;
      }
      body.resizing * {
      cursor: inherit !important;
      pointer-events: none;
      }
      header {
      position: relative;
      }
      .details-panel {
      position: relative;
      }
      main {
      display: grid;
      grid-template-columns: 1fr var(--sidebar-width, 350px);
      flex: 1;
      }
      main.sidebar-collapsed {
      grid-template-columns: 1fr 0;
      }
      @media (max-width: 900px) {
      main {
      grid-template-columns: 1fr;
      grid-template-rows: calc(100vh - var(--topbar-height, 52px) - var(--mobile-footer-height, 40vh)) var(--mobile-footer-height, 40vh);
      }
      main.sidebar-collapsed {
      grid-template-rows: 1fr 0;
      }
      .details-panel {
      max-height: var(--mobile-footer-height, 40vh);
      height: 100%;
      }
      }
      .topology-panel {
      background: var(--panel);
      border-right: 1px solid #111827;
      position: relative;
      overflow: hidden;
      }
      .topology-toolbar {
      position: absolute;
      top: 10px;
      right: 10px;
      display: none;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      z-index: 99;
      font-size: 13px;
      color: var(--toolbar-text, #94a3b8);
      }
      .topology-toolbar label {
      color: var(--toolbar-text, var(--text-soft));
      }
      .topology-toolbar select {
      padding: 4px 6px;
      background: var(--toolbar-btn-bg, var(--panel));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 13px;
      cursor: pointer;
      }
      .topology-toolbar button {
      padding: 4px 10px;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      }
      .topology-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .bulk-toolbar-desktop,
      .bulk-toolbar-mobile {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 9999;
      }
      .bulk-toolbar-desktop {
      position: absolute;
      top: 10px;
      right: 10px;
      bottom: auto;
      left: auto;
      transform: none;
      }
      @media (min-width: 768px) {
      .bulk-toolbar-mobile {
      display: none !important;
      }
      }	  
      .bulk-action-btn {
      padding: 16px;
      background: var(--panel-main);
      border: 1px solid var(--edge-main);
      border-radius: 8px;
      color: var(--text-main);
      font-size: 24px;
      cursor: pointer;
      text-align: center;
      line-height: 1.2;
      }
      .bulk-action-btn:active {
      transform: scale(0.95);
      background: var(--accent);
      }
      .draw-toolbar {
      position: absolute;
      top: 10px;
      left: 10px;
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 8px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      z-index: 99;
      font-size: 13px;
      pointer-events: auto;
      color: var(--toolbar-text, #94a3b8);
      }
      .draw-toolbar button {
      padding: 4px 8px;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      }
      .draw-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .draw-toolbar input[type="color"] {
      width: 30px;
      height: 22px;
      border-radius: 4px;
      border: 1px solid var(--edge-main);
      padding: 0;
      background: transparent;
      cursor: pointer;
      }
      .draw-toolbar select {
      padding: 4px 6px;
      background: var(--toolbar-btn-bg, var(--panel));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 13px;
      cursor: pointer;
      }
      .legend-container {
      position: absolute;
      left: 10px;
      bottom: 10px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      padding: 8px 10px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      font-size: 12px;
      z-index: 20;
      max-width: 260px;
      pointer-events: auto;
      color: var(--toolbar-text, #94a3b8);
      }
      .legend-container {
      padding-right: 22px;
      }
      @media (max-width: 900px) {
      .legend-container {
      max-height: calc(100vh - var(--topbar-height, 100px) - 120px);
      overflow-y: auto;
      }
      }
      @media (max-width: 900px) {
      .bulk-toolbar-desktop,
      .topology-toolbar {
      display: none !important;
      }
      }
      .legend-close-btn {
      position: absolute;
      top: 5px;
      right: 5px;
      width: 18px;
      height: 18px;
      border-radius: 999px;
      border: 1px solid var(--edge-main);
      background: var(--panel-alt);
      color: var(--text-soft);
      font-size: 11px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      }
      .legend-close-btn:hover {
      background: var(--danger);
      color: #fff;
      }
      .legend-mini-btn {
      position: absolute;
      left: 10px;
      padding: 4px 8px;
      border-radius: 4px;
      border: 1px solid var(--toolbar-border, #1f2937);
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 11px;
      cursor: pointer;
      z-index: 20;
      display: none;
      transition: all 0.2s;
      }
      .legend-mini-btn:hover,
      .legend-mini-btn:active {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
      }
      .legend-title {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: var(--toolbar-text, var(--text-soft));
      margin-bottom: 2px;
      }
      .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      }
      .legend-swatch {
      width: 14px;
      height: 14px;
      border-radius: 3px;
      border: 1px solid #020617;
      flex-shrink: 0;
      }
      .legend-label {
      outline: none;
      cursor: text;
      flex: 1;
      min-width: 60px;
      user-select: text;
      -webkit-user-select: text;
      }
      .legend-label.editing {
      border-bottom: 1px dashed var(--accent);
      }
      .canvas-viewport {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      overflow: hidden;
      }
      .canvas-viewport.panning {
      cursor: grabbing !important;
      }
      .canvas-viewport.panning * {
      cursor: grabbing !important;
      }
      .canvas-viewport svg {
      width: 100%;
      height: 100%;
      display: block;
      background: linear-gradient(rgba(71, 85, 105, 0.1) 1px,
      transparent 1px),
      linear-gradient(90deg,
      rgba(71, 85, 105, 0.1) 1px,
      transparent 1px),
      linear-gradient(rgba(71, 85, 105, 0.05) 1px, transparent 1px),
      linear-gradient(90deg,
      rgba(71, 85, 105, 0.05) 1px,
      transparent 1px);
      background-size:
      100px 100px,
      100px 100px,
      20px 20px,
      20px 20px;
      background-position:
      -1px -1px,
      -1px -1px,
      -1px -1px,
      -1px -1px;
      }
      .zoom-toolbar {
      display: flex;
      gap: 4px;
      padding: 6px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      }
      .zoom-toolbar button {
      width: 32px;
      height: 32px;
      padding: 0;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 18px;
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
      }
      .zoom-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .zoom-toolbar .zoom-level {
      font-size: 11px;
      color: var(--toolbar-text, var(--text-soft));
      text-align: center;
      padding: 2px 0;
      min-width: 32px;
      }
      .zoom-toolbar .divider {
      height: 1px;
      background: var(--toolbar-border, var(--edge-main));
      margin: 2px 0;
      }
      .minimap-zoom-wrapper {
      position: absolute;
      bottom: 10px;
      right: 10px;
      z-index: 99;
      }
      .minimap-container {
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      overflow: hidden;
      margin-bottom: 4px;
      }
      .minimap-container svg {
      width: 100%;
      height: 100%;
      }
      .minimap-viewport {
      fill: rgba(79, 209, 197, 0.2);
      stroke: var(--accent);
      stroke-width: 2;
      cursor: move;
      }
      .minimap-node {
      fill: var(--minimap-dots, var(--text-soft));
      }
      .minimap-edge {
      stroke: var(--edge-main);
      stroke-width: 1;
      }
	  .minimap-close-btn {
      position: absolute;
      top: 2px;
      right: 2px;
      width: 18px;
      height: 18px;
      background: var(--toolbar-btn-bg, rgba(15, 23, 42, 0.9));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 3px;
      color: var(--toolbar-text, var(--text-soft));
      font-size: 11px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
      padding: 0;
      line-height: 1;
      }
      .minimap-close-btn:hover {
      background: var(--danger);
      color: white;
      border-color: var(--danger);
      }
	  .toolbar-close-btn {
      width: 24px;
      height: 24px;
      background: var(--toolbar-btn-bg, rgba(15, 23, 42, 0.9));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-text, var(--text-soft));
      font-size: 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      line-height: 1;
      flex-shrink: 0;
      }
      .toolbar-close-btn:hover {
      background: var(--danger);
      color: white;
      border-color: var(--danger);
      }
	  .canvas-hint {
      position: absolute;
      top: 50px;
      left: 50%;
      transform: translateX(-50%);
      padding: 8px 16px;
      background: var(--canvas-hint-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      font-size: 12px;
      color: var(--canvas-hint-color, var(--text-soft));
      z-index: 18;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
      }
      .canvas-hint.visible {
      opacity: 1;
      }
      .edge {
      stroke: var(--edge-main);
      stroke-width: 4;
      opacity: 0.75;
      transition: 0.25s ease-in-out;
      cursor: pointer;
      }
      .edge.backup {
      stroke: var(--danger);
      stroke-width: 5;
      }
      .edge.active {
      opacity: 1;
      stroke-width: 7;
      filter: drop-shadow(0 0 8px var(--accent, #4fd1c5));
      }
      .rect-group.active .rect-shape {
      filter: drop-shadow(0 0 10px var(--accent, #4fd1c5));
      animation: pulse 1.2s infinite ease-in-out;
      }
      .text-element.active {
      filter: drop-shadow(0 0 10px var(--accent, #4fd1c5));
      animation: pulse 1.2s infinite ease-in-out;
      }
      .free-preview {
      fill: none;
      stroke-dasharray: 4 4;
      pointer-events: none;
      }
      .free-point {
      fill: #e5e7eb;
      stroke: #0f172a;
      stroke-width: 1.5;
      cursor: grab;
      }
      .node-circle {
      fill: var(--node-fill, #1e293b);
      stroke: var(--node-stroke, #475569);
      stroke-width: 2;
      transition: 0.25s ease;
      transform-origin: center center;
      }
      .node-hit-area {
      cursor: grab;
      pointer-events: all;
      }
      .node-group:hover .node-circle {
      filter: drop-shadow(0 0 10px rgba(79, 209, 197, 0.45));
      }
      .node-group.active .node-circle {
      stroke: var(--accent);
      animation: pulse 1.2s infinite ease-in-out;
      }
      @keyframes pulse {
      0% {
      filter: drop-shadow(0 0 4px #4fd1c5);
      }
      50% {
      filter: drop-shadow(0 0 14px #4fd1c5);
      }
      100% {
      filter: drop-shadow(0 0 4px #4fd1c5);
      }
      }
      .node-label {
      fill: var(--text-main);
      font-size: 18px;
      text-anchor: middle;
      font-weight: 600;
      }
      .node-sub {
      fill: var(--text-soft);
      font-size: 13px;
      text-anchor: middle;
      }
      .ping-indicator {
      fill: #6b7280;
      stroke: #4b5563;
      stroke-width: 1;
      }
      .ping-indicator.online {
      fill: #10b981;
      stroke: #059669;
      }
      .ping-indicator.offline {
      fill: #ef4444;
      stroke: #dc2626;
      }
      .ping-indicator.checking {
      fill: #f59e0b;
      stroke: #d97706;
      }
      @media (max-width: 1024px) {
      .node-label {
      font-size: 28px;
      }
      .node-sub {
      font-size: 20px;
      }
      }
      @media (max-width: 768px) {
      .node-label {
      font-size: 70px;
      }
      .node-sub {
      font-size: 50px;
      }
      }
      @media (max-width: 380px) {
      .node-label {
      font-size: 60px;
      }
      .node-sub {
      font-size: 42px;
      }
      }
      .details-panel {
      background: var(--sidebar-bg, var(--panel-alt));
      padding: 22px;
      padding-bottom: 80px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 15px;
      position: relative;
      transition:
      width 0.3s ease,
      min-width 0.3s ease,
      padding 0.3s ease,
      opacity 0.3s ease;
      }
      .details-panel {
      min-width: 260px !important;
      }
      .details-panel {
      overflow-y: auto !important;
      overflow-x: hidden;
      }
      .details-panel.collapsed {
      width: 0 !important;
      min-width: 0 !important;
      padding: 0 !important;
      overflow: hidden;
      opacity: 0;
      }
      body {
      overflow-x: hidden;
      overflow-y: hidden;
      }
      main {
      overflow-x: hidden;
      overflow-y: visible;
      }
      .details-panel {
      overflow-y: auto !important;
      overflow-x: hidden;
      }
      .details-panel.collapsed {
      min-width: 0 !important;
      }
      .sidebar-toggle {
      position: absolute;
      left: -16px;
      top: 50%;
      transform: translateY(-50%);
      width: 16px;
      height: 60px;
      background: var(--sidebar-bg, var(--panel-alt));
      border: 1px solid var(--edge-main);
      border-right: none;
      border-radius: 8px 0 0 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text-soft);
      font-size: 10px;
      z-index: 25;
      transition:
      background 0.2s,
      color 0.2s;
      }
      .sidebar-toggle:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .sidebar-toggle.collapsed {
      left: 0;
      border-right: 1px solid var(--edge-main);
      border-radius: 0 8px 8px 0;
      position: fixed;
      right: 0;
      left: auto;
      }
      .details-name {
      font-size: clamp(22px, 2.5vw, 30px);
      font-weight: 700;
      }
      .details-ip {
      font-size: clamp(16px, 2vw, 22px);
      color: var(--text-soft);
      }
      .details-role {
      font-size: clamp(16px, 2vw, 22px);
      color: var(--accent);
      }
      .size-controls {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-top: 10px;
      }
      .size-controls label {
      font-size: clamp(14px, 1.6vw, 18px);
      color: var(--text-soft);
      }
      .size-controls input[type="range"] {
      flex: 1;
      accent-color: var(--accent);
      }
      .size-controls button {
      padding: 6px 12px;
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      font-size: clamp(12px, 1.4vw, 16px);
      }
      .size-controls button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .style-section {
      margin-top: 15px;
      padding-top: 15px;
      border-top: 1px solid var(--edge-main);
      }
      .style-section summary {
      cursor: pointer;
      font-size: clamp(14px, 1.6vw, 20px);
      text-transform: uppercase;
      color: var(--text-soft);
      list-style: none;
      display: flex;
      justify-content: space-between;
      align-items: center;
      user-select: none;
      }
      .style-section summary::-webkit-details-marker {
      display: none;
      }
      .password-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #ffffff;
      z-index: 9999;
      }
      .style-section summary::after {
      content: "▼";
      transition: transform 0.2s;
      }
      .style-section[open] summary::after {
      transform: rotate(180deg);
      }
      .style-content {
      margin-top: 10px;
      }
      .style-row {
      display: flex;
      gap: 10px;
      align-items: center;
      margin: 8px 0;
      }
      .style-row label {
      font-size: clamp(13px, 1.5vw, 17px);
      color: var(--text-soft);
      min-width: 80px;
      }
      .style-row input[type="color"] {
      width: 50px;
      height: 30px;
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      background: transparent;
      }
      .style-row input[type="number"] {
      width: 70px;
      padding: 4px 8px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(12px, 1.4vw, 16px);
      }
      .style-row select {
      flex: 1;
      padding: 4px 8px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(12px, 1.4vw, 16px);
      cursor: pointer;
      }
      .editable-text {
      cursor: pointer;
      transition: opacity 0.2s;
      }
      .editable-text:hover {
      opacity: 0.7;
      }
      .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 999999;
      justify-content: center;
      align-items: center;
      overflow: auto;
      }
      .modal.active {
      display: inline-grid;
      }
      .modal-content {
      background: var(--panel-alt);
      padding: 25px;
      border-radius: 8px;
      border: 1px solid var(--edge-main);
      min-width: 300px;
      max-width: 90%;
      }
      .modal-content h3 {
      margin: 0 0 15px 0;
      color: var(--text-main);
      font-size: clamp(18px, 2vw, 24px);
      }
      .modal-content p {
      color: var(--text-soft);
      font-size: clamp(14px, 1.6vw, 18px);
      margin: 0 0 20px 0;
      }
      .modal-content input:not([type="color"]),
      .modal-content select {
      width: 100%;
      padding: 10px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(14px, 1.6vw, 18px);
      margin-bottom: 15px;
      user-select: text;
      -webkit-user-select: text;
      }
      .modal-content input[type="color"] {
      width: 60px;
      height: 36px;
      padding: 2px;
      border: 2px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      background: none;
      -webkit-appearance: none;
      appearance: none;
      }
      .modal-content input[type="color"]::-webkit-color-swatch-wrapper {
      padding: 0;
      }
      .modal-content input[type="color"]::-webkit-color-swatch {
      border: none;
      border-radius: 4px;
      }
      .modal-buttons {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
      margin-top: 10px;
      }
      .modal-buttons button {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: clamp(14px, 1.6vw, 18px);
      font-weight: 600;
      }
      .modal-buttons .btn-cancel {
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      }
      .modal-buttons .btn-save {
      background: var(--accent);
      color: var(--bg);
      }
      .modal-buttons .btn-delete {
      background: var(--danger);
      color: white;
      }
      .confirm-modal p {
      color: var(--text-soft);
      font-size: clamp(14px, 1.6vw, 18px);
      margin: 0 0 20px 0;
      }
      .context-menu-item {
      transition: background 0.15s;
      }
      .context-menu-item:hover {
      background: var(--panel);
      }
      .details-info-row {
      display: flex;
      align-items: center;
      margin: 6px 0;
      }
	 .node-group.selected .node-circle {
      stroke: var(--selection-handle, #f59e0b);
      stroke-width: 3;
      }
	  .node-group.layer-faded {
      pointer-events: none;
      }
      .edge.layer-faded {
      pointer-events: none;
      }
      .node-group.search-highlight .node-circle,
      .node-group.search-highlight rect,
      .node-group.search-highlight polygon {
      stroke: #10b981;
      stroke-width: 3;
      filter: drop-shadow(0 0 8px #10b981);
      }
      .badge-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      }
     .badge {
      background: var(--tag-fill, #1e293b);
      color: var(--tag-text, #e2e8f0);
      border: 1px solid var(--tag-border, var(--edge-main));
      padding: 5px 12px;
      border-radius: 22px;
      font-size: clamp(12px, 1.4vw, 18px);
      }
	  .badge.wg {
      color: var(--accent);
      border-color: var(--accent);
      }
	  input[type="text"],
      input[type="number"],
      input[type="password"],
      textarea,
      select {
      background: var(--input-bg, #0b0e13) !important;
      color: var(--input-text, #e2e8f0) !important;
      border-color: var(--input-border, #1f2937) !important;
      font-family: var(--input-font, Inter, system-ui, sans-serif) !important;
      font-size: var(--input-font-size, 14px) !important;
      }
      .section-label {
      margin-top: 8px;
      font-size: clamp(14px, 1.6vw, 20px);
      text-transform: uppercase;
      color: var(--text-soft);
      }
      .list li {
      margin: 6px 0;
      font-size: clamp(14px, 1.6vw, 20px);
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      }
      .list li:hover {
      color: var(--accent);
      }
      .delete-note {
      color: var(--danger);
      font-size: 18px;
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.2s;
      flex-shrink: 0;
      }
      .list li:hover .delete-note {
      opacity: 1;
      }
      .editing {
      outline: 2px solid var(--accent);
      background: #0d141f;
      padding: 4px;
      border-radius: 6px;
      user-select: text;
      -webkit-user-select: text;
      }
      .mobile-menu-btn {
      display: none;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      color: var(--text-main);
      font-size: 22px;
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      }
      #topbar-menu {
      gap: 8px;
      }
      @media (min-width: 721px) {
      #topbar-menu {
      display: flex !important;
      }
      }
      @media (max-width: 720px) {
      #topbar-menu {
      display: none;
      }
      #topbar-menu.open {
      display: flex;
      }
      }
      @media (max-width: 720px) {
      .mobile-menu-btn {
      display: block;
      }
      #topbar-menu {
      position: absolute;
      top: var(--topbar-height);
      right: 0;
      background: var(--panel-alt);
      border-left: 1px solid var(--topbar-border);
      border-bottom: 1px solid var(--topbar-border);
      padding: 12px;
      display: none;
      flex-direction: column;
      width: 180px;
      z-index: 999;
      }
      #topbar-menu.open {
      display: flex;
      }
      header {
      position: relative;
      z-index: 9999;
      }
      }
      @media (max-width: 720px) {
      .draw-toolbar {
      position: absolute;
      top: auto;
      bottom: auto;
      left: 10px !important;
      right: auto !important;
      width: auto;
      gap: 6px;
      padding: 8px;
      }	  
      .topology-toolbar {
      position: absolute;
      top: auto;
      bottom: auto;
      width: auto;
      gap: 6px;
      padding: 8px;
      }
      .draw-toolbar {
      top: 10px !important;
      }
      .topology-toolbar {
      top: calc(10px + var(--draw-toolbar-height, 50px)) !important;
      }
      .canvas-hint {
      top: calc(10px + 120px);
      }
      }
      .icon-picker-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      z-index: 999999999;
      justify-content: center;
      align-items: center;
      }
      .icon-picker-modal.active {
      display: flex;
      }
      .icon-picker-content {
      background: var(--panel);
      border-radius: 12px;
      width: 90%;
      max-width: 800px;
      max-height: 80vh;
      display: flex;
      flex-direction: column;
      border: 1px solid var(--edge-main);
      }
      .icon-picker-header {
      padding: 20px;
      border-bottom: 1px solid var(--edge-main);
      }
      .icon-picker-header h3 {
      margin: 0 0 15px 0;
      color: var(--text-main);
      }
      .icon-picker-tabs {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
      flex-wrap: wrap;
      }
      .icon-picker-tab {
      padding: 8px 16px;
      background: var(--panel-alt);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      color: var(--text-soft);
      font-size: 14px;
      transition: all 0.2s;
      }
      .icon-picker-tab:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .icon-picker-tab.active {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
      }
      .icon-picker-search {
      width: 100%;
      padding: 10px 15px;
      background: var(--panel-alt);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      color: var(--text-main);
      font-size: 14px;
      }
      .icon-picker-search::placeholder {
      color: var(--text-soft);
      }
      .icon-picker-body {
      padding: 20px;
      overflow-y: auto;
      flex: 1;
      }
      .icon-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
      gap: 10px;
      }
      .icon-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 15px 10px;
      background: var(--panel-alt);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .icon-item:hover {
      background: var(--accent);
      border-color: var(--accent);
      transform: scale(1.05);
      }
      .icon-item svg {
      width: 32px;
      height: 32px;
      fill: var(--text-main);
      }
      .icon-item:hover svg {
      fill: var(--bg);
      }
      .icon-item-name {
      margin-top: 8px;
      font-size: 10px;
      color: var(--text-soft);
      text-align: center;
      word-break: break-word;
      }
      .icon-item:hover .icon-item-name {
      color: var(--bg);
      }
      .icon-picker-loading {
      text-align: center;
      padding: 40px;
      color: var(--text-soft);
      }
      .icon-picker-footer {
      padding: 15px 20px;
      border-top: 1px solid var(--edge-main);
      display: flex;
      justify-content: flex-end;
      }
      .icon-btn-cancel {
      padding: 8px 20px;
      background: var(--panel-alt);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      }
      .icon-btn-cancel:hover {
      background: var(--edge-main);
      }
      .icon-badge {
      display: inline-flex;
      align-items: center;
      gap: 5px;
      padding: 4px 8px;
      background: var(--panel-alt);
      border-radius: 4px;
      font-size: 12px;
      margin: 2px;
      }
      .icon-badge svg {
      width: 16px;
      height: 16px;
      fill: currentColor;
      }
      .pick-icon-btn {
      padding: 6px 12px;
      background: var(--accent);
      color: var(--bg);
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      margin-top: 8px;
      width: 100%;
      }
      .pick-icon-btn:hover {
      opacity: 0.9;
      }
      @media (max-width: 768px) {
      .icon-picker-content {
      width: 95%;
      max-height: 90vh;	
      }
      .modal-content {
      background: var(--panel-alt);
      }
      #search-input {
      width: 100%;
      }
      }
      .version-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .version-item:hover {
      background: var(--panel-alt);
      border-color: var(--accent);
      }
      .version-item.current {
      border-color: var(--accent);
      background: rgba(79, 209, 197, 0.1);
      }
      .version-info {
      flex: 1;
      }
      .version-info .timestamp {
      font-size: 13px;
      color: var(--text-main);
      font-weight: 600;
      }
      .version-info .details {
      font-size: 11px;
      color: var(--text-soft);
      margin-top: 4px;
      }
      .version-actions {
      display: flex;
      gap: 6px;
      }
      .audit-entry {
      padding: 8px 12px;
      background: var(--panel);
      border-left: 3px solid var(--edge-main);
      border-radius: 4px;
      font-size: 12px;
      }
      .audit-entry.node { border-left-color: #4fd1c5; }
      .audit-entry.connection { border-left-color: #9f7aea; }
      .audit-entry.style { border-left-color: #ed8936; }
      .audit-entry.rack { border-left-color: #48bb78; }
      .audit-entry.layer { border-left-color: #4299e1; }
      .audit-entry .time {
      color: var(--text-soft);
      font-size: 10px;
      }
      .audit-entry .action {
      color: var(--text-main);
      font-weight: 500;
      }
      .tab-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .tab-item:hover {
      background: var(--panel-alt);
      }
      .tab-item.active {
      border-color: var(--accent);
      background: rgba(79, 209, 197, 0.1);
      }
      .tab-item .tab-name {
      font-weight: 600;
      color: var(--text-main);
      flex: 1;
      }
      .tab-item .tab-stats {
      font-size: 11px;
      color: var(--text-soft);
      margin-right: 10px;
      }
      .tab-actions {
      display: flex;
      gap: 6px;
      }
      .secret-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      border-left: 3px solid var(--danger);
      }
      .secret-item .secret-name {
      font-weight: 600;
      color: var(--text-main);
      flex: 1;
      }
      .secret-item .secret-status {
      font-size: 11px;
      color: var(--text-soft);
      margin-right: 10px;
      }   
	  body.view-only-mode:not(.view-only-inspect) #node-panel,
      body.view-only-mode:not(.view-only-inspect) #edge-panel,
      body.view-only-mode:not(.view-only-inspect) #text-panel,
      body.view-only-mode:not(.view-only-inspect) #rect-panel {
        display: none !important;
      }
      body.view-only-mode .node-group,
      body.view-only-mode .edge,
      body.view-only-mode .rect-group,
      body.view-only-mode .text-element {
        cursor: default !important;
      }
      body.view-only-mode .resize-handle,
      body.view-only-mode .edge-control-point {
        display: none !important;
      }
      body.view-only-mode #bulk-toolbar,
      body.view-only-mode #bulk-toolbar-mobile,
      body.view-only-mode #bulk-actions-modal {
        display: none !important;
      }
      body.view-only-mode::after {
        content: "VIEW ONLY • click 5× to inspect";
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(245, 101, 101, 0.9);
        color: white;
        padding: 6px 16px;
        border-radius: 20px;
        font-size: 12px;
        font-weight: 600;
        letter-spacing: 1px;
        z-index: 9999;
        pointer-events: none;
      }
    </style>
  </head>
  <body style="background: radial-gradient(circle at center top, rgb(30, 37, 50) 0px, rgb(5, 6, 8) 70%);" class="">
    <div class="icon-picker-modal" id="icon-picker-modal">
      <div class="icon-picker-content">
        <div class="icon-picker-header">
          <h3>Select Icon</h3>
          <div class="icon-picker-tabs">
            <button class="icon-picker-tab" data-library="mdi">MDI</button>
            <button class="icon-picker-tab" data-library="simple">Simple Icons</button>
            <button class="icon-picker-tab active" data-library="selfhst">selfh.st/icons</button>
          </div>
          <input type="text" class="icon-picker-search" id="icon-search" placeholder="Search icons..." style="display: none;">
        </div>
        <div class="icon-picker-body" id="icon-picker-body">
        </div>
        <div class="icon-picker-footer">
          <button class="icon-btn-cancel" id="icon-picker-cancel">Cancel</button>
        </div>
      </div>
    </div>
    <div class="modal" id="tabs-modal">
      <div class="modal-content" style="max-width: 600px;">
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Manage multiple topologies</p>
        <div id="tabs-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 400px; overflow-y: auto; margin-bottom: 15px;">
        </div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="new-tab-name" placeholder="New tab name..." style="flex: 1; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <button class="btn-save" onclick="createNewTab()">+ Add Tab</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="tabs-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="rollback-modal">
      <div class="modal-content" style="max-width: 700px;">
        <h3>Version History</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Limit: Snapshots</p>
        <div id="rollback-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 450px; overflow-y: auto; margin-bottom: 15px;">
          <div style="text-align: center; padding: 40px; color: var(--text-soft);">No version history yet. Versions are saved automatically when you save the file.</div>
        </div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <button class="btn-cancel" onclick="clearRollbackHistory()">Clear History</button>
          <button class="btn-save" onclick="createManualSnapshot()">Create Snapshot</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="rollback-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="audit-log-modal">
      <div class="modal-content" style="max-width: 800px;">
        <h3>Audit Log</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Track all changes made to your topology</p>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <select id="audit-filter" style="padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
            <option value="all">All Events</option>
            <option value="node">Node Operations</option>
            <option value="connection">Connections</option>
            <option value="style">Style Changes</option>
            <option value="rack">Rack Operations</option>
            <option value="layer">Layer Changes</option>
          </select>
          <button class="btn-save" onclick="exportAuditLog()">Export</button>
        </div>
        <div id="audit-log-list" style="display: flex; flex-direction: column; gap: 4px; max-height: 450px; overflow-y: auto; margin-bottom: 15px; font-family: monospace; font-size: 12px;">
          <div style="text-align: center; padding: 40px; color: var(--text-soft);">No audit entries yet</div>
        </div>
        <div style="display: flex; gap: 8px;">
          <button class="btn-cancel" onclick="clearAuditLog()">Clear Log</button>
          <button class="btn-cancel" id="audit-log-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="secrets-modal">
      <div class="modal-content" style="max-width: 600px;">
        <h3>Notes</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Notes can also be stored with AES 256 encryption</p>
        <div id="secrets-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 350px; overflow-y: auto; margin-bottom: 15px;">
        </div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="new-secret-name" placeholder="Section name (e.g., 'Root Passwords')..." style="flex: 1; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <button class="btn-save" onclick="createNewSecret()">+ Add Note</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="secrets-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="secret-editor-modal">
      <div class="modal-content" style="max-width: 600px;">
        <h3 id="secret-editor-title">Edit Note</h3>
        <textarea id="secret-editor-content" placeholder="Enter sensitive information here..." style="width: 100%; height: 200px; padding: 12px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main); font-family: monospace; resize: vertical; margin-bottom: 15px;"></textarea>
        <div style="margin-bottom: 15px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
          <input type="checkbox" id="secret-auto-encrypt" checked="" style="cursor: pointer;">
          <span>Encrypt Note</span>
          </label>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" onclick="closeSecretEditor()">Cancel</button>
          <button class="btn-save" onclick="saveSecret()">Save</button>
        </div>
      </div>
    </div>
    <div class="modal" id="edit-modal">
      <div class="modal-content">
        <h3 id="modal-title">Edit Name</h3>
        <input type="text" id="modal-input">
        <div class="modal-buttons">
          <button class="btn-cancel" id="modal-cancel">Cancel</button>
          <button class="btn-save" id="modal-save">Save</button>
        </div>
      </div>
    </div>
    <div class="modal confirm-modal" id="confirm-modal">
      <div class="modal-content">
        <h3>Confirm</h3>
        <p id="confirm-message"> Are you sure you want to delete this line? </p>
        <div class="modal-buttons">
          <button class="btn-cancel" id="confirm-cancel">Cancel</button>
          <button class="btn-delete" id="confirm-delete">Delete</button>
        </div>
      </div>
    </div>
    <div class="modal" id="save-info-modal">
      <div class="modal-content" style="max-width: 700px; max-height: 80vh; overflow-y: auto;">
        <h3 style="margin-bottom: 16px;">Help</h3>
        <div style="display: flex; gap: 8px; margin-bottom: 16px; flex-wrap: wrap;">
          <button class="help-tab active" data-tab="general" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--accent); color: var(--bg); border-radius: 6px; cursor: pointer; font-weight: 600;">General</button>
          <button class="help-tab" data-tab="desktop" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--panel); color: var(--text-main); border-radius: 6px; cursor: pointer; font-weight: 600;">Desktop</button>
          <button class="help-tab" data-tab="mobile" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--panel); color: var(--text-main); border-radius: 6px; cursor: pointer; font-weight: 600;">Mobile</button>
        </div>
        <div id="help-tab-general" class="help-tab-content" style="display: block;">
          <ul style="margin-left: 20px; margin-bottom: 12px; line-height: 1.8;">
            <li><strong>Add Nodes:</strong> Click "+ Node" or "+ Rack" in the top menu</li>
            <li><strong>Connect Nodes:</strong> Select a node, then use "Add Connection" in the panel</li>
            <li><strong>Move Nodes:</strong> Drag nodes to reposition them</li>
            <li><strong>Enter Rack View:</strong> Double click on desktop or Long press on mobile</li>
            <li><strong>Multi Select:</strong> Right click (desktop) or double tap (mobile)</li>
            <li><strong>Pan Canvas:</strong> Drag empty space or hold Space + drag</li>
            <li><strong>Zoom:</strong> Scroll wheel or pinch gesture</li>
            <li><strong>Free Draw:</strong> Use draw toolbar for drawing lines, boxes/zones , and text</li>
          </ul>
          <h4 style="color: var(--accent); margin-bottom: 8px;">Saving &amp; Encryption</h4>
          <p style="margin-bottom: 8px;">Browsers cannot overwrite local files. Click <strong>Save File</strong> to download an updated HTML with all changes. Replace your old file to keep edits.</p>
          <p style="margin-bottom: 8px;"><strong>Encryption of data:</strong> Check "Encrypt" before saving to password protect your data. Beware! No recovery possible without password!!</p>
          <p><strong>Decryption of data:</strong> Export via JSON in top settings menu after successful password validation to decrypt your data. You can then reimport back into the same file and save!</p>
        </div>
        <div id="help-tab-desktop" class="help-tab-content" style="display: none;">
          <h4 style="color: var(--accent); margin-bottom: 12px;">Navigation</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Arrow Keys</code></td>
              <td style="padding: 8px;">Move selected 1px</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Shift + Arrows</code></td>
              <td style="padding: 8px;">Move selected 10px</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Tab / Shift+Tab</code></td>
              <td style="padding: 8px;">Cycle through nodes</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">F</code></td>
              <td style="padding: 8px;">Focus on selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Space + Drag</code></td>
              <td style="padding: 8px;">Pan canvas</td>
            </tr>
          </tbody></table>
          <h4 style="color: var(--accent); margin-bottom: 12px;">Management</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">L</code></td>
              <td style="padding: 8px;">Lock/unlock selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">G</code></td>
              <td style="padding: 8px;">Group/ungroup selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+C / Ctrl+V</code></td>
              <td style="padding: 8px;">Copy / Paste</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+D</code></td>
              <td style="padding: 8px;">Duplicate</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+A</code></td>
              <td style="padding: 8px;">Select all</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Delete</code></td>
              <td style="padding: 8px;">Delete selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Escape</code></td>
              <td style="padding: 8px;">Clear selection</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+Z / Ctrl+Y</code></td>
              <td style="padding: 8px;">Undo / Redo</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Right Click</code></td>
              <td style="padding: 8px;">Multi select toggle</td>
            </tr>
          </tbody></table>
        </div>
        <div id="help-tab-mobile" class="help-tab-content" style="display: none;">
          <h4 style="color: var(--accent); margin-bottom: 12px;">Basic Gestures</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Tap node</strong></td>
              <td style="padding: 8px;">Select &amp; open properties</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Tap empty</strong></td>
              <td style="padding: 8px;">Deselect all</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Drag node</strong></td>
              <td style="padding: 8px;">Move node</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Drag empty</strong></td>
              <td style="padding: 8px;">Pan canvas</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Pinch</strong></td>
              <td style="padding: 8px;">Zoom in/out</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Double-tap node</strong></td>
              <td style="padding: 8px;">Add/remove from selection</td>
            </tr>
          </tbody></table>
          <h4 style="color: var(--accent); margin-bottom: 12px;">Rack View</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Long-press rack</strong></td>
              <td style="padding: 8px;">Enter rack view</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Double-tap empty</strong></td>
              <td style="padding: 8px;">Exit rack view</td>
            </tr>
          </tbody></table>
        </div>
        <div class="modal-buttons" style="margin-top: 16px;">
          <button class="btn-cancel" id="save-info-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="settings-modal">
	
	
	<div class="modal-content">
        <h2>Settings</h2>
        <details class="style-section">
          <summary>View Only Mode</summary>
          <div class="style-content">
            <div class="style-row">
              <label>View Only (disable all editing)</label>
              <input type="checkbox" id="view-only-mode" style="width:auto;">
            </div>
            <p style="margin-top:4px;font-size:12px;color:var(--text-soft);">When enabled, all editing of the canvas is disabled. Pan and zoom still work.</p>
          </div>
        </details>
        <details class="style-section">
          <summary>General Theme</summary>
          <div class="style-content">
		    <div class="style-row">
              <label>Main Background</label>
              <input type="color" id="panel-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Modal Window (popup) Background</label>
              <input type="color" id="panel-alt-color" value="#10141b">
            </div>
            <div class="style-row">
              <label>Accent Buttons</label>
              <input type="color" id="accent-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Danger Buttons</label>
              <input type="color" id="danger-color" value="#f56565">
            </div>
            <div class="style-row">
              <label>Primary Text</label>
              <input type="color" id="text-main-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Secondary Text</label>
              <input type="color" id="text-soft-color" value="#94a3b8">
            </div>
          </div>
        </details>
		
        <details class="style-section">
          <summary>Top Bar</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="topbar-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="topbar-border-color" value="#1f2533">
            </div>
          </div>
		  <div class="style-content">
            <div class="style-row">
              <label>Button Fill</label>
              <input type="color" id="btn-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Button Text</label>
              <input type="color" id="btn-text-color" value="#e2e8f0">
            </div>
          </div>
        </details>
		
        <details class="style-section">
          <summary>Main Canvas</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="canvas-border-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Grid Lines</label>
              <input type="color" id="canvas-grid-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Grid Size</label>
              <input type="number" id="canvas-grid-size" value="50" min="20" max="200" style="width:60px;">
            </div>
		    <div class="style-row">
              <label>Background Top</label>
              <input type="color" id="canvas-gradient-top" value="#1e2532">
            </div>
            <div class="style-row">
              <label>Background Bottom</label>
              <input type="color" id="canvas-gradient-bottom" value="#050608">
            </div>
            <div class="style-row">
              <label>Solid Background</label>
              <input type="color" id="page-bg-color" value="#050608">
            </div>
            <p style="margin-top:4px;font-size:12px;color:var(--text-soft);">Set solid background to override gradient.</p>
          </div>
        </details>
        <details class="style-section">
          <summary>Rack Canvas</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Frame Fill</label>
              <input type="color" id="rack-frame-fill" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Frame Border</label>
              <input type="color" id="rack-frame-stroke" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Grid Lines</label>
              <input type="color" id="rack-line-color" value="#475569">
            </div>
            <div class="style-row">
              <label>U Labels</label>
              <input type="color" id="rack-text-color" value="#4fd1c5">
            </div>
          </div>
       </details>
	   <details class="style-section">
          <summary>Canvas Toolbars</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="toolbar-bg-color" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="toolbar-border-color" value="#1f2937">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="toolbar-text-color" value="#94a3b8">
            </div>
            <div class="style-row">
              <label>Button Fill</label>
              <input type="color" id="toolbar-btn-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Button Text</label>
              <input type="color" id="toolbar-btn-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Minimap Dots</label>
              <input type="color" id="minimap-dots-color" value="#94a3b8">
            </div>
          </div>
        </details>
		
        <details class="style-section">
          <summary>Nodes</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Fill</label>
              <input type="color" id="node-fill-color" value="#1e293b">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="node-stroke-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Title Color</label>
              <input type="color" id="node-title-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Title Size</label>
              <input type="number" id="node-title-size" value="18" min="8" max="48" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Subtitle Color</label>
              <input type="color" id="node-sub-color" value="#94a3b8">
            </div>
            <div class="style-row">
              <label>Subtitle Size</label>
              <input type="number" id="node-sub-size" value="13" min="8" max="48" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Font</label>
              <select id="node-font-family" style="flex:1;padding:4px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;">
                <option value="Inter, system-ui, sans-serif">Inter</option>
                <option value="Arial, sans-serif">Arial</option>
                <option value="Helvetica, sans-serif">Helvetica</option>
                <option value="Georgia, serif">Georgia</option>
                <option value="monospace">Monospace</option>
              </select>
            </div>
          </div>
        </details>
        
        <details class="style-section">
          <summary>Connections</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Default Color</label>
              <input type="color" id="default-edge-color" value="#475569">
            </div>
          </div>
        </details>
        
        <details class="style-section">
          <summary>Groups &amp; Editing</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Resize handle Color</label>
              <input type="color" id="selection-handle-color" value="#f59e0b">
            </div>
            <div class="style-row">
              <label>Resize Handle Size</label>
              <input type="number" id="selection-handle-size" value="8" min="4" max="16" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Grouped Icon Outline</label>
              <input type="color" id="group-indicator-color" value="#4fd1c5">
            </div>
          </div>
		  <div class="style-content">
            <div class="style-row">
              <label>Multiselect Fill Color (Desktop)</label>
              <input type="color" id="selection-fill-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Multiselect Fill Opacity (Desktop)</label>
              <input type="range" id="selection-fill-opacity" min="0" max="1" step="0.05" value="0.1">
              <span id="selection-fill-opacity-val" style="min-width:35px;text-align:right;">10%</span>
            </div>
            <div class="style-row">
              <label>Multiselect Border Color (Desktop)</label>
              <input type="color" id="selection-stroke-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Multiselect Border Width (Desktop)</label>
              <input type="number" id="selection-stroke-width" min="1" max="10" value="2">
            </div>
            <div class="style-row">
              <label>Multiselect Border Style (Desktop)</label>
              <select id="selection-stroke-style">
                <option value="5,5">Dashed</option>
                <option value="2,4">Dotted</option>
                <option value="none">Solid</option>
              </select>
            </div>
          </div>
        </details>
   
		<details class="style-section">
          <summary>Inputs &amp; Dropdowns</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="input-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="input-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="input-border-color" value="#1f2937">
            </div>
            <div class="style-row">
              <label>Font</label>
              <select id="input-font-family" style="flex:1;padding:4px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;">
                <option value="Inter, system-ui, sans-serif">Inter</option>
                <option value="Arial, sans-serif">Arial</option>
                <option value="Helvetica, sans-serif">Helvetica</option>
                <option value="Georgia, serif">Georgia</option>
                <option value="monospace">Monospace</option>
              </select>
            </div>
            <div class="style-row">
              <label>Font Size</label>
              <input type="number" id="input-font-size" value="14" min="10" max="24" style="width:60px;">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Welcome Message</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Enabled</label>
              <input type="checkbox" id="canvas-hint-enabled" checked="" style="width:auto;">
            </div>
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="canvas-hint-bg-color" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Text Color</label>
              <input type="color" id="canvas-hint-text-color" value="#94a3b8">
            </div>
            <div class="style-row" style="flex-direction:column;align-items:stretch;">
              <label>Custom Text (HTML)</label>
              <textarea id="canvas-hint-text" rows="4" style="width:100%;margin-top:4px;padding:6px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;font-size:12px;resize:vertical;" placeholder="Leave empty for default"></textarea>
            </div>
          </div>
        </details>
        
        <details class="style-section">
          <summary>Sidebar / Mobile Footer</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="sidebar-bg-color" value="#10141b">
            </div>
          </div>
        </details>
        
        <details class="style-section">
          <summary>Tags</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Fill</label>
              <input type="color" id="tag-fill-color" value="#1e293b">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="tag-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="tag-border-color" value="#475569">
            </div>
          </div>
        </details>     
        <details class="style-section" open="">
          <summary>Import / Export / Upgrade JSON</summary>
          <div class="style-content">
            <button id="export-data-btn" style="width:100%;margin-bottom:10px;padding:10px;background:var(--accent);color:var(--bg);border:none;border-radius:6px;cursor:pointer;font-size:14px;font-weight:600;">Export JSON</button>
            <button id="import-data-btn" style="width:100%;padding:10px;background:var(--panel);color:var(--text-main);border:1px solid var(--edge-main);border-radius:6px;cursor:pointer;font-size:14px;font-weight:600;">Import JSON</button>
            <input type="file" id="import-data-file" accept=".json" style="display:none">
          </div>
        </details>
         <details class="style-section">
          <summary>Auto Status Checking</summary>
          <div class="style-content">
            <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 16px; cursor: pointer;">
            <input type="checkbox" id="auto-ping-enabled" style="cursor: pointer;">
            <span style="font-size: 14px; font-weight: 600;">Enable automatic status checking</span>
            </label>
            <div id="auto-ping-settings" style="display: none; padding-left: 20px; border-left: 2px solid var(--edge-main);">
              <div class="style-row" style="margin-bottom: 12px;">
                <label>Check Interval (seconds):</label>
                <input type="number" id="auto-ping-interval" min="5" max="3600" value="30" style="width: 80px; padding: 6px; background: var(--panel); border: 1px solid var(--edge-main); border-radius: 4px; color: var(--text-main);">
              </div>
              <div style="padding: 10px; background: var(--panel); border-radius: 6px; border: 1px solid var(--edge-main); font-size: 12px; color: var(--text-soft);">
                <div style="margin-bottom: 4px;"><span id="auto-ping-next-check">Next check in: --</span></div>
                <div><span id="auto-ping-last-run">Last run: 1:15:07 PM</span></div>
              </div>
            </div>
            <p style="margin-top: 12px; font-size: 12px; color: var(--text-soft); font-style: italic;">
              Automatically checks all ping enabled nodes at the specified interval. I recommend 30 to 60 seconds for local networks.
            </p>
			</div>
        </details>
        <details class="style-section" open="">
          <summary>Danger Zone</summary>
          <div class="style-content">
            <p style="margin-bottom:12px;font-size:13px;color:var(--text-soft);">Permanently delete everything on the canvas.</p>
            <button id="clear-all-btn" title="Clear all nodes" style="padding:6px 12px;background:var(--danger);color:#fff;border:none;border-radius:6px;cursor:pointer;font-size:14px;font-weight:600;">Clear All</button>
            <input type="file" id="import-data-file" accept=".json" style="display:none">
          </div>
        </details>
        
        <div class="modal-buttons">
          <button class="btn-cancel" id="settings-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="add-node-modal">
      <div class="modal-content">
        <h3>Add New Node</h3>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Basic Information</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Name</label>
          <input type="text" id="new-node-name" placeholder="e.g. web server, jellyfin">
          <label style="display: block;margin-bottom: 4px;margin-top: 12px;color: var(--text-soft);font-size: 13px;">IP / Subtitle</label>
          <input type="text" id="new-node-ip" placeholder="e.g. 192.168.1.100">
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Tags</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Text Tags (comma separated)</label>
          <input type="text" id="new-node-tags" placeholder="e.g. Docker, nginx, WG: vpn">
          <button class="pick-icon-btn" id="pick-new-node-tag-icon-btn" style="margin-top: 10px;">Add Icon Tag</button>
          <div id="new-node-icon-tags" style="margin-top: 10px; display: none;">
            <label style="display: block; margin-bottom: 8px; color: var(--text-soft); font-size: 13px;">Icon Tags:</label>
            <div id="new-node-icon-tags-list" style="display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 10px;"></div>
          </div>
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Node Appearance</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Basic Shapes</label>
          <select id="new-node-shape">
            <optgroup label="Basic Shapes">
            <option value="circle">Circle</option>
            <option value="square">Square</option>
            <option value="rectangle">Rectangle</option>
            <option value="triangle">Triangle</option>
            <option value="hexagon">Hexagon</option>
            <option value="diamond">Diamond</option>
            <option value="star">Star</option>
            <option value="stop-sign">Stop Sign</option>
            <option value="octagon">Octagon</option>
            <option value="pentagon">Pentagon</option>
            <option value="cross">Cross</option>
            <option value="rounded-square">Rounded Square</option>
            <option value="pill">Pill</option>
            <option value="parallelogram">Parallelogram</option>
            <option value="trapezoid">Trapezoid</option>
          </optgroup>
          <optgroup label="Computers &amp; Devices">
            <option value="server">Server</option>
            <option value="pc">PC / Desktop</option>
            <option value="laptop">Laptop</option>
            <option value="phone">Phone / Mobile</option>
            <option value="printer">Printer</option>
            <option value="pi">Raspberry Pi</option>
            <option value="sensor">Sensor / IoT</option>
          </optgroup>
          <optgroup label="Network Equipment">
            <option value="router">Router</option>
            <option value="switch">Switch</option>
            <option value="firewall">Firewall</option>
            <option value="access-point">Access Point</option>
            <option value="load-balancer">Load Balancer</option>
            <option value="gateway">Gateway</option>
            <option value="vpn">VPN / Tunnel</option>
            <option value="nas">NAS / Storage</option>
          </optgroup>
          <optgroup label="Cloud &amp; Services">
            <option value="cloud">Cloud</option>
            <option value="database">Database</option>
			<option value="docker">Docker</option>
            <option value="container">Container</option>
            <option value="vm">Virtual Machine</option>
            <option value="kubernetes">Kubernetes</option>
            <option value="api">API / Endpoint</option>
            <option value="queue">Queue / Message</option>
            <option value="lambda">Lambda / Function</option>
            <option value="bucket">Bucket / S3</option>
          </optgroup>
          <optgroup label="Security &amp; Monitoring">
            <option value="shield">Shield</option>
            <option value="camera">Camera / CCTV</option>
            <option value="monitor">Monitor / Dashboard</option>
          </optgroup>
          </select>
          <button class="pick-icon-btn" id="pick-node-icon-btn" style="margin-top: 10px;"> Or search web icons</button>
          <div id="selected-node-icon" style="margin-top: 10px; display: none;">
            <label style="display: block; margin-bottom: 8px; color: var(--text-soft); font-size: 13px;">Selected Icon:</label>
            <div class="icon-badge" id="selected-node-icon-preview">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24">
                <image href="https://cdn.jsdelivr.net/gh/selfhst/icons@master/png/docker.png" width="24" height="24"></image>
              </svg>
              <span>docker</span>
            </div>
          </div>
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Ping / Status Monitoring</div>
          <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px; cursor: pointer;">
          <input type="checkbox" id="new-node-pingable" style="cursor: pointer;">
          <span style="color: var(--text-soft); font-size: 13px;">Enable ping/status check for this node</span>
          </label>
          <div id="new-node-ping-options" style="display: block; padding-left: 24px; border-left: 2px solid var(--edge-main);">
            <label style="display: block; margin-bottom: 4px; color: var(--text-soft); font-size: 13px;">Protocol</label>
            <select id="new-node-ping-protocol" style="margin-bottom: 12px;">
              <option value="http">HTTP (port 80) uses IP field</option>
              <option value="https">HTTPS (port 443) uses IP field</option>
              <option value="custom">Custom URL</option>
            </select>
            <div id="new-node-custom-url-container" style="display: block;">
              <label style="display: block; margin-bottom: 4px; color: var(--text-soft); font-size: 13px;">Custom URL</label>
              <input type="text" id="new-node-custom-url" placeholder="e.g. http://192.168.1.1:8080">
            </div>
            <label style="display: block; margin-bottom: 4px; margin-top: 8px; color: var(--text-soft); font-size: 13px;">
            Timeout (ms)
            </label>
            <input type="number" id="new-node-ping-timeout" value="3000" min="1000" max="10000" step="500">
          </div>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="add-node-cancel">Cancel</button>
          <button class="btn-save" id="add-node-save">Add Node</button>
        </div>
      </div>
    </div>
    <div class="modal" id="add-rack-modal">
      <div class="modal-content">
        <h3>Add New Rack</h3>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Basic Information</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Rack Name</label>
          <input type="text" id="new-rack-name" placeholder="e.g. Rack-A, DC1-R01, Production-01">
          <label style="display: block;margin-bottom: 4px;margin-top: 12px;color: var(--text-soft);font-size: 13px;">IP / Network Range (optional)</label>
          <input type="text" id="new-rack-ip" placeholder="e.g. 192.168.1.0/24">
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Tags</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Text Tags (comma separated)</label>
          <input type="text" id="new-rack-tags" placeholder="e.g. Production, Data Center 1, Row A">
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Rack Appearance</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Icon / Shape</label>
          <select id="new-rack-shape">
            <optgroup label="Basic Shapes">
            <option value="circle">Circle</option>
            <option value="square">Square</option>
            <option value="rectangle">Rectangle</option>
            <option value="triangle">Triangle</option>
            <option value="hexagon">Hexagon</option>
            <option value="diamond">Diamond</option>
            <option value="star">Star</option>
            <option value="stop-sign">Stop Sign</option>
            <option value="octagon">Octagon</option>
            <option value="pentagon">Pentagon</option>
            <option value="cross">Cross</option>
            <option value="rounded-square">Rounded Square</option>
            <option value="pill">Pill</option>
            <option value="parallelogram">Parallelogram</option>
            <option value="trapezoid">Trapezoid</option>
          </optgroup>
          <optgroup label="Computers &amp; Devices">
            <option value="server">Server</option>
            <option value="pc">PC / Desktop</option>
            <option value="laptop">Laptop</option>
            <option value="phone">Phone / Mobile</option>
            <option value="printer">Printer</option>
            <option value="pi">Raspberry Pi</option>
            <option value="sensor">Sensor / IoT</option>
          </optgroup>
          <optgroup label="Network Equipment">
            <option value="router">Router</option>
            <option value="switch">Switch</option>
            <option value="firewall">Firewall</option>
            <option value="access-point">Access Point</option>
            <option value="load-balancer">Load Balancer</option>
            <option value="gateway">Gateway</option>
            <option value="vpn">VPN / Tunnel</option>
            <option value="nas">NAS / Storage</option>
          </optgroup>
          <optgroup label="Cloud &amp; Services">
            <option value="cloud">Cloud</option>
            <option value="database">Database</option>
			<option value="docker">Docker</option>
            <option value="container">Container</option>
            <option value="vm">Virtual Machine</option>
            <option value="kubernetes">Kubernetes</option>
            <option value="api">API / Endpoint</option>
            <option value="queue">Queue / Message</option>
            <option value="lambda">Lambda / Function</option>
            <option value="bucket">Bucket / S3</option>
          </optgroup>
          <optgroup label="Security &amp; Monitoring">
            <option value="shield">Shield</option>
            <option value="camera">Camera / CCTV</option>
            <option value="monitor">Monitor / Dashboard</option>
          </optgroup>
          </select>
          <button class="pick-icon-btn" id="pick-rack-icon-btn" style="margin-top: 10px;">Or Search Web Icons</button>
          <div id="selected-rack-icon" style="margin-top: 10px; display: none;">
            <label style="display: block; margin-bottom: 8px; color: var(--text-soft); font-size: 13px;">Selected Icon:</label>
            <div class="icon-badge" id="selected-rack-icon-preview">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24">
                <image href="" width="24" height="24"></image>
              </svg>
              <span></span>
            </div>
          </div>
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Rack Configuration</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Rack Capacity</label>
          <select id="new-rack-capacity">
            <option value="42" selected="">42U (Standard Full Rack)</option>
            <option value="48">48U (Large Rack)</option>
            <option value="24">24U (Half Rack)</option>
            <option value="12">12U (Small/Wall Mount)</option>
            <option value="6">6U (Mini Rack)</option>
          </select>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="add-rack-cancel">Cancel</button>
          <button class="btn-save" id="add-rack-save">Add Rack</button>
        </div>
      </div>
    </div>
    <div class="modal confirm-modal" id="clear-all-modal">
      <div class="modal-content">
        <h3>Clear All Nodes</h3>
        <p> This will remove ALL nodes and connections. This cannot be undone until you reload without saving. Are you sure? </p>
        <div class="modal-buttons">
          <button class="btn-cancel" id="clear-all-cancel">Cancel</button>
          <button class="btn-delete" id="clear-all-confirm">Clear Everything</button>
        </div>
      </div>
    </div>
    <div class="modal" id="layer-modal">
      <div class="modal-content" style="max-width: 400px;">
        <h3>Layer Visibility</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Toggle which layers are visible on the canvas</p>
        <div style="display: flex; flex-direction: column; gap: 10px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-physical" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Physical Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-logical" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Logical Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-security" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Security Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-application" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Application Layer</span>
          </label>
        </div>
        <div style="margin-top: 15px; display: flex; gap: 8px;">
          <button class="btn-cancel" style="flex: 1;" onclick="document.querySelectorAll('#layer-modal input[type=checkbox]').forEach(cb =&gt; cb.checked = false); applyLayerFilter();">Hide All</button>
          <button class="btn-save" style="flex: 1;" onclick="document.querySelectorAll('#layer-modal input[type=checkbox]').forEach(cb =&gt; cb.checked = true); applyLayerFilter();">Show All</button>
        </div>
        <div class="modal-buttons" style="margin-top: 10px;">
          <button class="btn-cancel" id="layer-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div id="context-menu" style="display: none !important;">
    </div>
    <header>
      <div class="title-block">
        <h1 id="page-title" class="editable-page-title">The One File</h1>
        <div class="save-row">
          <button id="save-file-btn" class="save-btn" type="button">Save File</button>
          <label style="display: flex;align-items: center;gap: 4px;font-size: 12px;color: var(--text-soft);cursor: pointer;user-select: none;">
          <input type="checkbox" id="encrypt-toggle" style="cursor: pointer">
          <span title="Encrypt data with password">Encrypt</span>
          </label>
          <span id="save-help-btn" class="help-icon" title="Why save?">?</span>
        </div>
      </div>
      <div id="topbar-menu">
        <button id="back-to-topology-btn" title="Exit rack view and return to topology" style="padding: 6px 12px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;display: none;">← Back to Topology</button>
        <button id="add-node-btn" class="save-btn" title="Add new node" style="background: var(--accent)">+ Node</button>
        <button id="add-rack-btn" class="save-btn" title="Add new rack" style="background: var(--accent); margin-left: 8px;">+ Rack</button>
        <button id="undo-btn" title="Undo (Ctrl+Z)" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;" disabled="">↶</button>
        <button id="redo-btn" title="Redo (Ctrl+Y)" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;" disabled="">↷</button>
<input type="text" id="search-nodes" placeholder="Search nodes..." title="Search by name, IP, MAC, role, or tag" style="padding: 6px 12px;background: var(--input-bg);color: var(--input-text);border: 1px solid var(--input-border);border-radius: 6px;font-family: var(--input-font);font-size: var(--input-font-size);width: 180px;">
        <button id="check-all-ping-btn" title="Check status of all enabled nodes" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600">Check Pings</button>
        <button id="layers-btn" title="Toggle layer visibility" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Layers</button>
        <button id="tabs-btn" title="Manage document tabs" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Tabs</button>
        <button id="rollback-btn" title="View version history" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Snapshots</button>
        <button id="audit-log-btn" title="View audit log" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Audit</button>
        <button id="secrets-btn" title="Manage encrypted notes" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Notes</button>
        <button onclick="screenshotCanvas()" title="Export canvas as PNG image" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">PNG</button>
        <button onclick="exportCanvasSVG()" title="Export canvas as SVG vector" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">SVG</button>
        <button id="settings-btn" title="Page settings">⚙️</button>
      </div>
      <button id="mobile-menu-toggle" class="mobile-menu-btn">☰</button>
      <div class="header-resizer" id="header-resizer">
        <svg class="resizer-icon" width="40" height="6" viewBox="0 0 40 6" xmlns="http://www.w3.org/2000/svg">
          <circle cx="14" cy="3" r="2"></circle>
          <circle cx="20" cy="3" r="2"></circle>
          <circle cx="26" cy="3" r="2"></circle>
        </svg>
      </div>
    </header>
    <main>
      <section class="topology-panel">
        <div class="draw-toolbar" id="draw-toolbar" style="display: flex !important;">
          <button type="button" class="toolbar-close-btn" id="draw-toolbar-close-btn" title="Hide draw toolbar">✕</button>
          <button id="draw-toggle" title="Draw custom line">✏️</button>
          <button id="rect-toggle" title="Draw zone">▭</button>
          <button id="text-toggle" title="Add text">T</button>
          <select id="rect-style" title="zone style">
            <option value="filled">Filled</option>
            <option value="outlined">Outlined</option>
          </select>
          <input type="color" id="draw-color" value="#f97316" title="Line color">
          <select id="draw-style" title="Line style">
            <option value="solid">Solid</option>
            <option value="dashed">Dashed</option>
            <option value="dotted">Dotted</option>
          </select>
          <select id="draw-arrow" title="Arrow direction">
            <option value="none">No arrows</option>
            <option value="forward">→ Right</option>
            <option value="backward">← Left</option>
            <option value="both">↔ Both</option>
          </select>
          <button id="draw-undo" style="display: none" title="Undo last point">Undo</button>
        </div>
        <div class="topology-toolbar" id="topology-toolbar" style="display: flex !important;">
          <button type="button" class="toolbar-close-btn" id="topology-toolbar-close-btn" title="Hide add line toolbar">✕</button>
          <label for="add-line-select">Add line to:</label>
          <select id="add-line-select"><option value="internet-copy">OPNSENSE</option><option value="opnsense-copy">Docker</option><option value="docker-copy">Docker2</option><option value="docker-copy-1">Docker3</option><option value="docker-copy-2">Docker 4</option><option value="opnsense-copy-1">OPNSENSE GUEST</option><option value="phone">Phone</option><option value="desktop">Desktop</option><option value="dns">DNS</option><option value="racked">Racked</option></select>
<input type="color" id="add-line-color" value="#475569" title="Line color" style="width: 30px;height: 24px;border: 1px solid var(--toolbar-border);border-radius: 4px;cursor: pointer;background: transparent;padding: 0;">          <select id="add-line-direction" title="Line direction">
            <option value="none">No arrows</option>
            <option value="forward">→ Forward</option>
            <option value="backward">← Backward</option>
            <option value="both">↔ Both</option>
          </select>
          <button id="add-line-btn">Add</button>
        </div>
        <div class="topology-toolbar bulk-toolbar-desktop" id="bulk-toolbar" style="display: none">
          <button type="button" class="toolbar-close-btn" id="bulk-toolbar-close" title="Clear selection">✕</button>
          <label style="font-weight: 600; color: var(--accent)">Selected: <span id="bulk-count">0</span></label>
          <button id="bulk-align-left" title="Align left">⬅ Left</button>
          <button id="bulk-align-right" title="Align right">➡ Right</button>
          <button id="bulk-align-top" title="Align top">⬆ Top</button>
          <button id="bulk-align-bottom" title="Align bottom">⬇ Bottom</button>
          <button id="bulk-distribute-h" title="Distribute horizontally">↔ Distribute H</button>
          <button id="bulk-distribute-v" title="Distribute vertically">↕ Distribute V</button>
          <button id="bulk-clone" title="Clone selected">📋 Clone</button>
          <button id="bulk-delete" title="Delete selected" style="background: var(--danger); color: white;">Delete</button>
        </div>
        <div class="bulk-toolbar-mobile" id="bulk-toolbar-mobile" style="display: none">
          <button type="button" id="bulk-mobile-btn" style="background: var(--accent);color: white;padding: 12px 20px;border-radius: 25px;font-weight: 600;font-size: 16px;box-shadow: 0 4px 12px rgba(0,0,0,0.3);border: none;cursor: pointer;display: flex;align-items: center;gap: 8px;">
          <span id="bulk-count-mobile">0</span>Selected</button>
        </div>
        <div id="bulk-actions-modal" style="display: none;position: fixed;bottom: 0;left: 0;right: 0;background: var(--panel-alt);border-top-left-radius:20px;border-top-right-radius:20px;padding:20px;padding-bottom:(safe-area-inset-bottom, 20px);box-shadow: 0 -4px 20px rgba(0,0,0,0.5);z-index: 10000;max-height: calc(100vh - 80px);overflow-y: auto;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            <h3 style="margin: 0; color: var(--accent); font-size: 20px;">
              <span id="bulk-count-modal">0</span> Nodes Selected
            </h3>
            <button id="bulk-modal-close" style="background: none;border: none;font-size: 24px;cursor: pointer;color: var(--text-main);padding: 0;width: 32px;height: 32px;">✕</button>
          </div>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
            <button id="bulk-align-left-mobile" class="bulk-action-btn">⬅<br><span style="font-size: 12px;">Align Left</span></button>
            <button id="bulk-align-right-mobile" class="bulk-action-btn">➡<br><span style="font-size: 12px;">Align Right</span></button>
            <button id="bulk-align-top-mobile" class="bulk-action-btn">⬆<br><span style="font-size: 12px;">Align Top</span></button>
            <button id="bulk-align-bottom-mobile" class="bulk-action-btn">⬇<br><span style="font-size: 12px;">Align Bottom</span></button>
            <button id="bulk-distribute-h-mobile" class="bulk-action-btn">↔<br><span style="font-size: 12px;">Distribute H</span></button>
            <button id="bulk-distribute-v-mobile" class="bulk-action-btn">↕<br><span style="font-size: 12px;">Distribute V</span></button>
            <button id="bulk-lock-mobile" class="bulk-action-btn">🔒<br><span style="font-size: 12px;">Lock Toggle</span></button>
            <button id="bulk-group-mobile" class="bulk-action-btn">⭕<br><span style="font-size: 12px;">Group Toggle</span></button>
            <button id="bulk-clone-mobile" class="bulk-action-btn">📋<br><span style="font-size: 12px;">Clone All</span></button>
            <button id="bulk-delete-mobile" class="bulk-action-btn" style="background: var(--danger); color: white;">🗑<br><span style="font-size: 12px;">Delete All</span></button>
          </div>
          <button id="bulk-clear-mobile" style="width: 100%;margin-top: 16px;padding: 14px;background: var(--panel-main);border: 1px solid var(--edge-main);border-radius: 8px;color: var(--text-main);font-size: 16px;cursor: pointer;">Clear Selection</button>
        </div>
        <div class="canvas-hint" id="canvas-hint"></div>
        <div class="legend-container" id="edge-legend" style="display: flex;"><div class="legend-title">Line Legend</div><button type="button" class="legend-close-btn">✕</button><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(85, 226, 8); cursor: pointer;"></span><span class="legend-label" contenteditable="true">ISP LINE</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(76, 0, 255); cursor: pointer;"></span><span class="legend-label" contenteditable="true">MY Guest NETWORK</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(128, 255, 0); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(251, 0, 255); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(255, 0, 208); cursor: pointer;"></span><span class="legend-label" contenteditable="true">iPhone (always guest iPhone)</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(249, 115, 22); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div></div>
        <div class="canvas-viewport" id="canvas-viewport">
          <svg id="map" viewBox="1254.5197896196048 -147.55422459755366 2648.185035176588 1986.138776382441" style=""><defs><marker id="arrow-forward" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto" markerUnits="strokeWidth"><path d="M0,0 L0,6 L9,3 z" fill="context-stroke"></path></marker><marker id="arrow-backward" markerWidth="10" markerHeight="10" refX="0" refY="3" orient="auto" markerUnits="strokeWidth"><path d="M9,0 L9,6 L0,3 z" fill="context-stroke"></path></marker></defs><rect x="100" y="100" width="3800" height="2800" fill="none" stroke="#4755694D" stroke-width="20" stroke-dasharray="10 5" rx="8"></rect><g id="canvas-grid"><line x1="100" y1="100" x2="100" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="150" y1="100" x2="150" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="200" y1="100" x2="200" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="250" y1="100" x2="250" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="300" y1="100" x2="300" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="350" y1="100" x2="350" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="400" y1="100" x2="400" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="450" y1="100" x2="450" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="500" y1="100" x2="500" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="550" y1="100" x2="550" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="600" y1="100" x2="600" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="650" y1="100" x2="650" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="700" y1="100" x2="700" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="750" y1="100" x2="750" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="800" y1="100" x2="800" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="850" y1="100" x2="850" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="900" y1="100" x2="900" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="950" y1="100" x2="950" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1000" y1="100" x2="1000" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1050" y1="100" x2="1050" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1100" y1="100" x2="1100" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="1150" y1="100" x2="1150" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1200" y1="100" x2="1200" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1250" y1="100" x2="1250" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1300" y1="100" x2="1300" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1350" y1="100" x2="1350" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="1400" y1="100" x2="1400" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1450" y1="100" x2="1450" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1500" y1="100" x2="1500" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1550" y1="100" x2="1550" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1600" y1="100" x2="1600" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="1650" y1="100" x2="1650" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1700" y1="100" x2="1700" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1750" y1="100" x2="1750" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1800" y1="100" x2="1800" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1850" y1="100" x2="1850" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="1900" y1="100" x2="1900" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1950" y1="100" x2="1950" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2000" y1="100" x2="2000" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2050" y1="100" x2="2050" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2100" y1="100" x2="2100" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="2150" y1="100" x2="2150" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2200" y1="100" x2="2200" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2250" y1="100" x2="2250" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2300" y1="100" x2="2300" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2350" y1="100" x2="2350" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="2400" y1="100" x2="2400" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2450" y1="100" x2="2450" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2500" y1="100" x2="2500" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2550" y1="100" x2="2550" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2600" y1="100" x2="2600" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="2650" y1="100" x2="2650" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2700" y1="100" x2="2700" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2750" y1="100" x2="2750" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2800" y1="100" x2="2800" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2850" y1="100" x2="2850" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="2900" y1="100" x2="2900" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2950" y1="100" x2="2950" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3000" y1="100" x2="3000" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3050" y1="100" x2="3050" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3100" y1="100" x2="3100" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="3150" y1="100" x2="3150" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3200" y1="100" x2="3200" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3250" y1="100" x2="3250" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3300" y1="100" x2="3300" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3350" y1="100" x2="3350" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="3400" y1="100" x2="3400" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3450" y1="100" x2="3450" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3500" y1="100" x2="3500" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3550" y1="100" x2="3550" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3600" y1="100" x2="3600" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="3650" y1="100" x2="3650" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3700" y1="100" x2="3700" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3750" y1="100" x2="3750" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3800" y1="100" x2="3800" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3850" y1="100" x2="3850" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="3900" y1="100" x2="3900" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="100" x2="3900" y2="100" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="150" x2="3900" y2="150" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="200" x2="3900" y2="200" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="250" x2="3900" y2="250" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="300" x2="3900" y2="300" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="350" x2="3900" y2="350" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="400" x2="3900" y2="400" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="450" x2="3900" y2="450" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="500" x2="3900" y2="500" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="550" x2="3900" y2="550" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="600" x2="3900" y2="600" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="650" x2="3900" y2="650" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="700" x2="3900" y2="700" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="750" x2="3900" y2="750" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="800" x2="3900" y2="800" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="850" x2="3900" y2="850" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="900" x2="3900" y2="900" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="950" x2="3900" y2="950" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1000" x2="3900" y2="1000" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1050" x2="3900" y2="1050" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1100" x2="3900" y2="1100" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="1150" x2="3900" y2="1150" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1200" x2="3900" y2="1200" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1250" x2="3900" y2="1250" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1300" x2="3900" y2="1300" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1350" x2="3900" y2="1350" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="1400" x2="3900" y2="1400" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1450" x2="3900" y2="1450" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1500" x2="3900" y2="1500" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1550" x2="3900" y2="1550" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1600" x2="3900" y2="1600" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="1650" x2="3900" y2="1650" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1700" x2="3900" y2="1700" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1750" x2="3900" y2="1750" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1800" x2="3900" y2="1800" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1850" x2="3900" y2="1850" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="1900" x2="3900" y2="1900" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1950" x2="3900" y2="1950" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2000" x2="3900" y2="2000" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2050" x2="3900" y2="2050" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2100" x2="3900" y2="2100" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="2150" x2="3900" y2="2150" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2200" x2="3900" y2="2200" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2250" x2="3900" y2="2250" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2300" x2="3900" y2="2300" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2350" x2="3900" y2="2350" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="2400" x2="3900" y2="2400" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2450" x2="3900" y2="2450" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2500" x2="3900" y2="2500" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2550" x2="3900" y2="2550" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2600" x2="3900" y2="2600" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="2650" x2="3900" y2="2650" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2700" x2="3900" y2="2700" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2750" x2="3900" y2="2750" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2800" x2="3900" y2="2800" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2850" x2="3900" y2="2850" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="2900" x2="3900" y2="2900" stroke="#47556933" stroke-width="1"></line></g><g class="rect-group" data-rect-id="rect-1765238219615"><rect class="rect-shape" x="2680.053955078125" y="251.44879150390625" width="814.10400390625" height="389.26678466796875" style="fill: rgb(236, 9, 153); fill-opacity: 0.3; stroke: rgb(236, 9, 153); stroke-width: 2px; stroke-dasharray: none; cursor: move;"></rect><g class="rect-delete-btn" style="cursor: pointer; display: none;"><circle cx="3484.157958984375" cy="261.44879150390625" r="12" style="fill: rgb(245, 101, 101); stroke: white; stroke-width: 2;"></circle><text x="3484.157958984375" y="261.44879150390625" text-anchor="middle" dominant-baseline="middle" style="fill: white; font-size: 16px; font-weight: bold; pointer-events: none;">×</text></g></g><path d="M 2103.968290880771 268 Q 2085.4680212352528 370.70595670887826 2066.9677515897347 473.4119134177565" fill="none" class="edge active" data-edge-id="internet-internet-copy-1765238145151" data-from="internet" data-to="internet-copy" style="stroke: rgb(85, 226, 8); stroke-width: 4;"></path><path d="M 2103.968290880771 268 Q 2085.4680212352528 370.70595670887826 2066.9677515897347 473.4119134177565" fill="none" data-edge-id="internet-internet-copy-1765238145151" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 1920.4039088162972 569.9938683738112 1773.8400660428597 666.5758233298659" fill="none" class="edge" data-edge-id="internet-copy-opnsense-copy-1765238187451" data-from="internet-copy" data-to="opnsense-copy" style="stroke: rgb(76, 0, 255); stroke-width: 4;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 1920.4039088162972 569.9938683738112 1773.8400660428597 666.5758233298659" fill="none" data-edge-id="internet-copy-opnsense-copy-1765238187451" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 1999.08282329894 627.8447547749242 1931.1978950081452 782.2775961320921" fill="none" class="edge" data-edge-id="internet-copy-docker-copy-1765238242477" data-from="internet-copy" data-to="docker-copy" style="stroke: rgb(76, 0, 255); stroke-width: 4;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 1999.08282329894 627.8447547749242 1931.1978950081452 782.2775961320921" fill="none" data-edge-id="internet-copy-docker-copy-1765238242477" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2112.546995662221 620.5620704487524 2158.1262397347077 767.7122274797483" fill="none" class="edge" data-edge-id="internet-copy-docker-copy-1-1765238244637" data-from="internet-copy" data-to="docker-copy-1" style="stroke: rgb(76, 0, 255); stroke-width: 4;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2112.546995662221 620.5620704487524 2158.1262397347077 767.7122274797483" fill="none" data-edge-id="internet-copy-docker-copy-1-1765238244637" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2204.617064021596 552.590055067893 2342.2663764534577 631.7681967180296" fill="none" class="edge" data-edge-id="internet-copy-docker-copy-2-1765238246233" data-from="internet-copy" data-to="docker-copy-2" style="stroke: rgb(76, 0, 255); stroke-width: 4;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2204.617064021596 552.590055067893 2342.2663764534577 631.7681967180296" fill="none" data-edge-id="internet-copy-docker-copy-2-1765238246233" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2103.968290880771 268 Q 2430.923885484287 287.80585580459456 2757.879480087803 307.6117116091891" fill="none" class="edge active" data-edge-id="internet-opnsense-copy-1-1765238266117" data-from="internet" data-to="opnsense-copy-1" style="stroke: rgb(128, 255, 0); stroke-width: 4;"></path><path d="M 2103.968290880771 268 Q 2430.923885484287 287.80585580459456 2757.879480087803 307.6117116091891" fill="none" data-edge-id="internet-opnsense-copy-1-1765238266117" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2757.879480087803 307.6117116091891 Q 2979.171899521397 314.04065142852505 3200.4643189549906 320.469591247861" fill="none" class="edge" data-edge-id="opnsense-copy-1-dns-1765238347996" data-from="opnsense-copy-1" data-to="dns" style="stroke: rgb(251, 0, 255); stroke-width: 4;"></path><path d="M 2757.879480087803 307.6117116091891 Q 2979.171899521397 314.04065142852505 3200.4643189549906 320.469591247861" fill="none" data-edge-id="opnsense-copy-1-dns-1765238347996" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 3200.4643189549906 320.469591247861 Q 3086.0821778417094 400.59916888457974 2971.700036728428 480.7287465212985" fill="none" class="edge" data-edge-id="dns-desktop-1765238386101" data-from="dns" data-to="desktop" style="stroke: rgb(255, 0, 208); stroke-width: 4;"></path><path d="M 3200.4643189549906 320.469591247861 Q 3086.0821778417094 400.59916888457974 2971.700036728428 480.7287465212985" fill="none" data-edge-id="dns-desktop-1765238386101" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 3312.857751572178 502.58220111114224 Q 3256.6610352635844 411.5258961795016 3200.4643189549906 320.469591247861" fill="none" class="edge" data-edge-id="phone-dns-1765238391156" data-from="phone" data-to="dns" style="stroke: rgb(255, 0, 208); stroke-width: 4;"></path><path d="M 3312.857751572178 502.58220111114224 Q 3256.6610352635844 411.5258961795016 3200.4643189549906 320.469591247861" fill="none" data-edge-id="phone-dns-1765238391156" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><polyline class="edge" data-edge-id="custom-1765239449323" fill="none" marker-end="url(#arrow-forward)" points="2936.464111328125,786.07958984375 3184.112060546875,887.6153564453125 2763.110107421875,981.7216796875" style="stroke: rgb(249, 115, 22); stroke-width: 4; stroke-dasharray: none;"></polyline><polyline points="2936.464111328125,786.07958984375 3184.112060546875,887.6153564453125 2763.110107421875,981.7216796875" data-edge-id="custom-1765239449323" style="fill: none; stroke: transparent; stroke-width: 20; cursor: pointer;"></polyline><g class="node-group active" data-node-id="internet" transform="translate(2103.968290880771,268)" style="cursor: grab;"><circle r="252" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" viewBox="0 0 512 512" width="201.6" height="201.6" x="-100.8" y="-100.8" style="fill: rgb(255, 255, 255); stroke: rgb(255, 255, 255);"><path d="M144.3 214.1c0 6.3.7 11.4 1.9 15.2 1.4 3.7 3.1 7.8 5.4 12.3.9 1.4 1.2 2.7 1.2 3.9 0 1.7-1 3.4-3.2 5.1l-10.7 7.2c-1.5 1-3.1 1.5-4.4 1.5-1.7 0-3.4-.9-5.1-2.4-2.4-2.6-4.4-5.3-6.1-8-1.7-2.9-3.4-6.1-5.3-10-13.3 15.7-30 23.5-50.1 23.5-14.3 0-25.7-4.1-34.1-12.3-8.3-8.2-12.6-19.1-12.6-32.7 0-14.5 5.1-26.2 15.5-35.1S60.8 169 78.4 169c5.8 0 11.7.5 18.1 1.4s12.8 2.2 19.6 3.7v-12.4c0-12.9-2.7-22-8-27.2-5.4-5.3-14.6-7.8-27.8-7.8-6 0-12.1.7-18.4 2.2s-12.4 3.4-18.4 5.8c-2.7 1.2-4.8 1.9-6 2.2s-2 .5-2.7.5c-2.4 0-3.6-1.7-3.6-5.3v-8.3c0-2.7.3-4.8 1.2-6s2.4-2.4 4.8-3.6c6-3.1 13.1-5.6 21.5-7.7 8.3-2.2 17.2-3.2 26.6-3.2 20.3 0 35.1 4.6 44.6 13.8 9.4 9.2 14.1 23.2 14.1 41.9v55.2zM75.2 240c5.6 0 11.4-1 17.5-3.1 6.1-2 11.6-5.8 16.2-10.9 2.7-3.2 4.8-6.8 5.8-10.9s1.7-9 1.7-14.8v-7.2c-4.9-1.2-10.2-2.2-15.7-2.9-5.4-.7-10.7-1-16-1-11.4 0-19.8 2.2-25.4 6.8S51 207.1 51 215.6c0 8 2 14 6.3 18.1 4.1 4.2 10 6.3 17.9 6.3m136.7 18.4c-3.1 0-5.1-.5-6.5-1.7-1.4-1-2.6-3.4-3.6-6.6l-40-131.6c-1-3.4-1.5-5.6-1.5-6.8 0-2.7 1.4-4.3 4.1-4.3h16.7c3.2 0 5.4.5 6.6 1.7 1.4 1 2.4 3.4 3.4 6.6l28.6 112.7 26.6-112.7c.9-3.4 1.9-5.6 3.2-6.6 1.4-1 3.7-1.7 6.8-1.7H270c3.2 0 5.4.5 6.8 1.7 1.4 1 2.6 3.4 3.2 6.6l26.9 114.1 29.5-114.1c1-3.4 2.2-5.6 3.4-6.6 1.4-1 3.6-1.7 6.6-1.7h15.8c2.7 0 4.3 1.4 4.3 4.3 0 .9-.2 1.7-.3 2.7-.2 1-.5 2.4-1.2 4.3l-41 131.6q-1.5 5.1-3.6 6.6c-1.4 1-3.6 1.7-6.5 1.7h-14.6c-3.2 0-5.4-.5-6.8-1.7s-2.6-3.4-3.2-6.8l-26.4-109.8L236.7 250c-.9 3.4-1.9 5.6-3.2 6.8-1.4 1.2-3.7 1.7-6.8 1.7zm218.8 4.6c-8.9 0-17.7-1-26.2-3.1-8.5-2-15.2-4.3-19.6-6.8-2.7-1.5-4.6-3.2-5.3-4.8s-1-3.2-1-4.8v-8.7c0-3.6 1.4-5.3 3.9-5.3 1 0 2 .2 3.1.5 1 .3 2.6 1 4.3 1.7 5.8 2.6 12.1 4.6 18.7 6 6.8 1.4 13.5 2 20.3 2 10.7 0 19.1-1.9 24.9-5.6s8.9-9.2 8.9-16.2c0-4.8-1.5-8.7-4.6-11.9s-8.9-6.1-17.2-8.9l-24.7-7.7c-12.4-3.9-21.6-9.7-27.2-17.4-5.6-7.5-8.5-15.8-8.5-24.7 0-7.2 1.5-13.5 4.6-18.9s7.2-10.2 12.3-14c5.1-3.9 10.9-6.8 17.7-8.9 6.8-2 14-2.9 21.5-2.9 3.7 0 7.7.2 11.4.7 3.9.5 7.5 1.2 11.1 1.9 3.4.9 6.6 1.7 9.7 2.7s5.4 2 7.2 3.1c2.4 1.4 4.1 2.7 5.1 4.3 1 1.4 1.5 3.2 1.5 5.6v8c0 3.6-1.4 5.4-3.9 5.4-1.4 0-3.6-.7-6.5-2q-14.55-6.6-32.7-6.6c-9.7 0-17.4 1.5-22.6 4.8s-8 8.2-8 15.2c0 4.8 1.7 8.9 5.1 12.1s9.7 6.5 18.7 9.4l24.2 7.7c12.3 3.9 21.1 9.4 26.4 16.3s7.8 15 7.8 23.8c0 7.3-1.5 14-4.4 19.8-3.1 5.8-7.2 10.9-12.4 15-5.3 4.3-11.6 7.3-18.9 9.5-8 2.5-16 3.7-24.7 3.7" style="fill: rgb(255, 255, 255); stroke: rgb(255, 255, 255);"></path><path d="M462.9 345.7c-56 41.4-137.4 63.3-207.4 63.3-98.1 0-186.5-36.3-253.2-96.6-5.3-4.8-.5-11.2 5.8-7.5 72.2 41.9 161.3 67.3 253.4 67.3 62.2 0 130.4-12.9 193.3-39.5 9.3-4.2 17.3 6.2 8.1 13m23.3-26.5c-7.2-9.2-47.3-4.4-65.6-2.2-5.4.7-6.3-4.1-1.4-7.7 32-22.5 84.6-16 90.8-8.5 6.1 7.7-1.7 60.3-31.7 85.5-4.6 3.9-9 1.9-7-3.2 6.9-16.9 22.1-54.9 14.9-63.9" style="fill-rule: evenodd; clip-rule: evenodd; fill: rgb(255, 255, 255); stroke: rgb(255, 255, 255);"></path></svg></g><text class="node-label" x="0" y="-47.040000000000006" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Internet</text><text class="node-sub" x="0" y="67.2" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="internet-copy" transform="translate(2066.9677515897347,473.4119134177565)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" viewBox="0 0 512 512" width="66" height="66" x="-33" y="-33"><path d="M512 160.2V400H400V112H112V0h240.4zM112 112H0v240.4L160.2 512H400V400H112z" style="fill:#de3c07"></path></svg></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">OPNSENSE</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="opnsense-copy" transform="translate(1773.8400660428597,666.5758233298659)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" viewBox="0 0 512 512" width="66" height="66" x="-33" y="-33"><path d="M462.2 512H49.8C22.3 512 0 489.7 0 462.2V49.8C0 22.3 22.3 0 49.8 0h412.4C489.7 0 512 22.3 512 49.8v412.4c0 27.5-22.3 49.8-49.8 49.8" style="fill:#2e2f33"></path><path d="M108.2 63.9h140.9c97.2 0 154.6 30.4 154.6 129.5v3.4c0 99.4-57.2 129.5-154.5 129.5h-30.7V447H108.2zm134.5 177.8c30.1 0 46-11.2 46-44.6v-3.9c0-33.2-15.8-44.6-46-44.6h-24.2v93.1zM313 358h90.3v90.1H313z" style="fill:#f7f6f3"></path></svg></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Docker</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="docker-copy" transform="translate(1931.1978950081452,782.2775961320921)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" viewBox="0 0 512 512" width="66" height="66" x="-33" y="-33"><path d="M438.6 0H73.4C33.1 0 .3 32.8.3 73.1v365.7c0 40.3 32.8 73.1 73.1 73.1h365.3c40.3 0 73.1-32.8 73.1-73.1V73.1C511.7 32.8 478.9 0 438.6 0" style="fill-rule:evenodd;clip-rule:evenodd;fill:#8b3bd0"></path><path d="M356.8 53.6v261.3c0 39.3-13.9 72.8-41.8 100.7s-61.4 41.8-100.7 41.8l-23.8-95h23.8c13 0 24.1-4.6 33.2-13.8 9.5-9.5 14.3-20.7 14.3-33.7V148.6H157.3v-95z" style="fill:#fff"></path></svg></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Docker2</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="docker-copy-1" transform="translate(2158.1262397347077,767.7122274797483)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" viewBox="0 0 512 512" width="66" height="66" x="-33" y="-33"><path d="M0 0h512v512H0z" style="fill:#111827"></path><path d="M170.7 85.3 369.8 256 170.7 426.7z" style="fill:#f59e0b"></path></svg></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Docker3</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="docker-copy-2" transform="translate(2342.2663764534577,631.7681967180296)" style="cursor: grab;"><circle r="123" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" viewBox="0 0 512 512" width="98.39999999999999" height="98.39999999999999" x="-49.199999999999996" y="-49.199999999999996"><path d="M501.4 212.3c-11.5-8-38-11-58.6-7-2.4-20-13.5-37.5-32.7-53l-11-8-7.7 11.5c-9.6 15-14.4 36-13 56 .5 7 2.9 19.5 10.1 30.5-6.7 4-20.7 9-38.9 9H2.3l-1 4c-3.4 20-3.4 82.5 36 130.5 29.8 36.5 74 55 132.1 55 125.9 0 219.1-60.5 262.8-170 17.3.5 54.3 0 73-37.5.5-1 1.4-3 4.8-10.5l1.9-4zM280 71.3h-52.8v50H280zm0 60h-52.8v50H280zm-62.5 0h-52.8v50h52.8zm-62.4 0h-52.8v50h52.8zm-62.5 60H39.8v50h52.8zm62.5 0h-52.8v50h52.8zm62.4 0h-52.8v50h52.8zm62.5 0h-52.8v50H280zm62.4 0h-52.8v50h52.8z" style="fill:#2396ed"></path></svg></g><text class="node-label" x="0" y="-22.96" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Docker 4</text><text class="node-sub" x="0" y="32.800000000000004" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="opnsense-copy-1" transform="translate(2757.879480087803,307.6117116091891)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" viewBox="0 0 512 512" width="66" height="66" x="-33" y="-33"><path d="M503.1 465.4v2.1c-6 25.5-28.4 44.5-55 44.5H7.3v-46.6h38.3v7.3h403c1.1 0 2 0 2.9-.1 1.8-.1 3.6-.6 5.2-1.3 2.9-1.3 5.3-3.3 7-5.9zM63.9 0c-26.5 0-49 19-55 44.5V47H48c2.7-4.3 7.3-7.2 12.6-7.6 1-.1 2-.1 3.2-.1h402.6V47h38.3V0z" style="fill:#898b8d"></path><path d="M466.1 157.7V197H319.5v-39.3zM45.9 315.4v39.3h146.6v-39.3zm0-157.7V197h146.6v-39.3zm273.6 157.7v39.3h146.6v-39.3z" style="fill:#58595b"></path><path d="M83.8 78.6H428v39.3H83.8zm0 315.9H428v39.3H83.8z" style="fill:#403f41"></path><linearGradient id="opnsense-v1_svg__a" x1="-1460.617" x2="-1375.11" y1="1248.095" y2="1248.095" gradientTransform="matrix(.1853 .356 .6722 -.353 -90.66 993.802)" gradientUnits="userSpaceOnUse"><stop offset="0" style="stop-color:#737373"></stop><stop offset="1" style="stop-color:#333"></stop></linearGradient><path d="m466.5 78.6 38.2-20.5.1-39.5-38.3 20.7" style="fill:url(#opnsense-v1_svg__a)"></path><linearGradient id="opnsense-v1_svg__b" x1="4.634" x2="50.301" y1="462.6" y2="462.6" gradientTransform="matrix(1 0 0 -1 0 514)" gradientUnits="userSpaceOnUse"><stop offset="0" style="stop-color:#737373"></stop><stop offset="1" style="stop-color:#333"></stop></linearGradient><path d="M45.6 64.5v-8.9c0-5.3 2.6-10 6.5-13l-34-18.5c-6.7 9.5-10.8 21.3-10.9 34l38.3 20.6v-14c.1-.1.1-.2.1-.2" style="fill:url(#opnsense-v1_svg__b)"></path><linearGradient id="opnsense-v1_svg__c" x1="-1587.887" x2="-1498.137" y1="-2208.165" y2="-2208.165" gradientTransform="matrix(-.1853 -.356 -.6722 .353 -1743.836 694.098)" gradientUnits="userSpaceOnUse"><stop offset="0" style="stop-color:#737373"></stop><stop offset="1" style="stop-color:#333"></stop></linearGradient><path d="M45.6 472.7v-38.9L7.3 454.5v39.7l39.9-21.5z" style="fill:url(#opnsense-v1_svg__c)"></path><linearGradient id="opnsense-v1_svg__d" x1="460.439" x2="504.436" y1="53" y2="53" gradientTransform="matrix(1 0 0 -1 0 514)" gradientUnits="userSpaceOnUse"><stop offset="0" style="stop-color:#737373"></stop><stop offset="1" style="stop-color:#333"></stop></linearGradient><path d="M466.5 456.4c0 5.5-2.7 10.3-6.9 13.2l34.2 18.4c6.8-9.5 10.8-21.2 10.9-33.8L466.5 434v12.8" style="fill:url(#opnsense-v1_svg__d)"></path><linearGradient id="opnsense-v1_svg__e" x1="2521.902" x2="2684.464" y1="-2476.233" y2="-2476.233" gradientTransform="matrix(-1.508 -1.0166 -3.1265 -1.519 -3697.438 -937.952)" gradientUnits="userSpaceOnUse"><stop offset=".107" style="stop-color:#58595b"></stop><stop offset="1" style="stop-color:#000"></stop></linearGradient><path d="M192.5 197v-.4l-72.4-38.9H45.9v.2l72.5 39.1z" style="fill:url(#opnsense-v1_svg__e)"></path><linearGradient id="opnsense-v1_svg__f" x1="-1594.953" x2="-1432.391" y1="278.458" y2="278.458" gradientTransform="matrix(1.508 -1.0166 3.1265 -1.519 1804.196 -937.952)" gradientUnits="userSpaceOnUse"><stop offset=".107" style="stop-color:#58595b"></stop><stop offset="1" style="stop-color:#000"></stop></linearGradient><path d="M466.1 157.7h-74l-72.6 39.1v.2h74.2l72.4-38.9z" style="fill:url(#opnsense-v1_svg__f)"></path><linearGradient id="opnsense-v1_svg__g" x1="-4327.142" x2="-4164.581" y1="1572.387" y2="1572.387" gradientTransform="matrix(1.508 1.0166 3.1265 1.519 1863.938 2252.352)" gradientUnits="userSpaceOnUse"><stop offset=".107" style="stop-color:#58595b"></stop><stop offset="1" style="stop-color:#000"></stop></linearGradient><path d="M466.1 354.7v-.4l-72.4-38.9h-74.2v.2l72.6 39.1z" style="fill:url(#opnsense-v1_svg__g)"></path><linearGradient id="opnsense-v1_svg__h" x1="-413.668" x2="-246.99" y1="-1046.618" y2="-1046.618" gradientTransform="matrix(-1.508 1.0166 -3.1265 1.519 -3638.692 2252.352)" gradientUnits="userSpaceOnUse"><stop offset=".107" style="stop-color:#58595b"></stop><stop offset="1" style="stop-color:#000"></stop></linearGradient><path d="M192.5 315.4h-74.1l-72.5 39.1v.2h74.2l72.4-38.9z" style="fill:url(#opnsense-v1_svg__h)"></path><linearGradient id="opnsense-v1_svg__i" x1="74.725" x2="261.062" y1="132.65" y2="132.65" gradientTransform="matrix(.9914 0 0 -1 -66.782 260.2)" gradientUnits="userSpaceOnUse"><stop offset=".237" style="stop-color:#a6a8ab"></stop><stop offset="1" style="stop-color:#404040"></stop></linearGradient><path d="M192.8 157.7V197L7.3 97.4V58.1z" style="fill:url(#opnsense-v1_svg__i)"></path><linearGradient id="opnsense-v1_svg__j" x1="-2461.056" x2="-2274.718" y1="132.65" y2="132.65" gradientTransform="matrix(-.9914 0 0 -1 -1935.19 260.2)" gradientUnits="userSpaceOnUse"><stop offset=".237" style="stop-color:#a6a8ab"></stop><stop offset="1" style="stop-color:#404040"></stop></linearGradient><path d="M319.2 157.7V197l185.5-99.6V58.1z" style="fill:url(#opnsense-v1_svg__j)"></path><linearGradient id="opnsense-v1_svg__k" x1="-2291.845" x2="-2105.508" y1="-739.55" y2="-739.55" gradientTransform="matrix(-.9914 0 0 1 -1767.435 1124.6)" gradientUnits="userSpaceOnUse"><stop offset=".237" style="stop-color:#a6a8ab"></stop><stop offset="1" style="stop-color:#404040"></stop></linearGradient><path d="M319.2 355.2v-39.8L504.7 415v39.7z" style="fill:url(#opnsense-v1_svg__k)"></path><linearGradient id="opnsense-v1_svg__l" x1="-94.103" x2="91.934" y1="-739.55" y2="-739.55" gradientTransform="matrix(.9914 0 0 1 100.993 1124.6)" gradientUnits="userSpaceOnUse"><stop offset=".237" style="stop-color:#a6a8ab"></stop><stop offset="1" style="stop-color:#404040"></stop></linearGradient><path d="M192.8 355.2v-39.8L7.3 415v39.7z" style="fill:url(#opnsense-v1_svg__l)"></path><path d="m319.2 276.1 108.9 58.5v-39.7l-35.3-18.8h111.9v-39.8H392.8l35.3-18.8v-39.3l-108.9 58.1zM83.8 334.6l109-58.5v-39.8l-109-58.1v39.3l35.7 18.8H7.3v39.8h111.9l-35.3 18.8v39.7z" style="fill:#e24525"></path></svg></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">OPNSENSE GUEST</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="phone" transform="translate(3312.857751572178,502.58220111114224)" style="cursor: grab;"><circle r="181.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-54.45" y="-121" width="108.9" height="242" rx="8"></rect><rect x="-45.980000000000004" y="-102.85" width="91.96000000000001" height="193.60000000000002" rx="4" style="fill: rgb(30, 41, 59);"></rect><rect x="-18.15" y="99.22" width="36.3" height="7.26" rx="2" style="fill: rgb(71, 85, 105);"></rect></g><text class="node-label" x="0" y="-33.88" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Phone</text><text class="node-sub" x="0" y="48.400000000000006" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="desktop" transform="translate(2971.700036728428,480.7287465212985)" style="cursor: grab;"><circle r="220.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-132.3" y="-117.60000000000001" width="264.6" height="176.4" rx="4"></rect><rect x="-110.25" y="-95.55" width="220.5" height="132.3" rx="2" style="fill: rgb(30, 41, 59);"></rect><rect x="-22.05" y="58.800000000000004" width="44.1" height="44.1"></rect><rect x="-73.5" y="102.89999999999999" width="147" height="22.05" rx="2"></rect></g><text class="node-label" x="0" y="-41.160000000000004" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Desktop</text><text class="node-sub" x="0" y="58.800000000000004" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="dns" transform="translate(3200.4643189549906,320.469591247861)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><path d="
             M -44 11
             Q -60.50000000000001 11 -60.50000000000001 -5.5
             Q -60.50000000000001 -27.5 -38.5 -27.5
             Q -38.5 -49.5 -11 -49.5
             Q 5.5 -60.50000000000001 27.5 -44
             Q 55 -44 60.50000000000001 -16.5
             Q 71.5 -5.5 60.50000000000001 11
             Q 60.50000000000001 27.5 38.5 27.5
             L -27.5 27.5
             Q -49.5 27.5 -49.5 11
             Z
            " class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"></path><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">DNS</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="racked" transform="translate(2645.5845448279656,970.7820678889219)" style="cursor: grab;"><circle r="205.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" id="mdi-server-security" viewBox="0 0 24 24" width="164.4" height="164.4" x="-82.2" y="-82.2" style="fill: rgb(1, 8, 19); stroke: rgb(255, 255, 255);"><path d="M3,1H19A1,1 0 0,1 20,2V6A1,1 0 0,1 19,7H3A1,1 0 0,1 2,6V2A1,1 0 0,1 3,1M3,9H19A1,1 0 0,1 20,10V10.67L17.5,9.56L11,12.44V15H3A1,1 0 0,1 2,14V10A1,1 0 0,1 3,9M3,17H11C11.06,19.25 12,21.4 13.46,23H3A1,1 0 0,1 2,22V18A1,1 0 0,1 3,17M8,5H9V3H8V5M8,13H9V11H8V13M8,21H9V19H8V21M4,3V5H6V3H4M4,11V13H6V11H4M4,19V21H6V19H4M17.5,12L22,14V17C22,19.78 20.08,22.37 17.5,23C14.92,22.37 13,19.78 13,17V14L17.5,12M17.5,13.94L15,15.06V17.72C15,19.26 16.07,20.7 17.5,21.06V13.94Z" style="fill: rgb(1, 8, 19); stroke: rgb(255, 255, 255);"></path></svg></g><text class="node-label" x="0" y="-38.36000000000001" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Racked</text><text class="node-sub" x="0" y="54.800000000000004" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;"></text></g><g class="text-group" data-text-id="text-1765238422602"><text class="text-element" x="2466.35986328125" y="741.6801147460938" dominant-baseline="middle" style="fill: rgb(226, 232, 240); font-size: 40px; font-weight: normal; font-style: normal; text-anchor: start; text-decoration: none; opacity: 1; cursor: move; user-select: none;"><tspan x="2466.35986328125" dy="0">Double click on desktop</tspan><tspan x="2466.35986328125" dy="48">or long press on mobile</tspan><tspan x="2466.35986328125" dy="48">to enter rack canvas view</tspan></text><g class="text-delete-btn" style="cursor: pointer; display: none;"><circle cx="2486.35986328125" cy="701.6801147460938" r="12" style="fill: rgb(245, 101, 101); stroke: white; stroke-width: 2;"></circle><text x="2486.35986328125" y="701.6801147460938" text-anchor="middle" dominant-baseline="middle" style="fill: white; font-size: 16px; font-weight: bold; pointer-events: none;">×</text></g></g></svg>
        </div>
        <div class="minimap-zoom-wrapper" id="minimap-zoom-wrapper" style="display: block;">
          <button type="button" class="minimap-close-btn" id="minimap-close-btn" title="Hide map &amp; zoom">✕</button>
          <div class="minimap-container" id="minimap-container">
            <svg id="minimap" viewBox="0 0 4000 3000">
              <line x1="2103.968290880771" y1="268" x2="2066.9677515897347" y2="473.4119134177565" class="minimap-edge"></line><line x1="2066.9677515897347" y1="473.4119134177565" x2="1773.8400660428597" y2="666.5758233298659" class="minimap-edge"></line><line x1="2066.9677515897347" y1="473.4119134177565" x2="1931.1978950081452" y2="782.2775961320921" class="minimap-edge"></line><line x1="2066.9677515897347" y1="473.4119134177565" x2="2158.1262397347077" y2="767.7122274797483" class="minimap-edge"></line><line x1="2066.9677515897347" y1="473.4119134177565" x2="2342.2663764534577" y2="631.7681967180296" class="minimap-edge"></line><line x1="2103.968290880771" y1="268" x2="2757.879480087803" y2="307.6117116091891" class="minimap-edge"></line><line x1="2757.879480087803" y1="307.6117116091891" x2="3200.4643189549906" y2="320.469591247861" class="minimap-edge"></line><line x1="3200.4643189549906" y1="320.469591247861" x2="2971.700036728428" y2="480.7287465212985" class="minimap-edge"></line><line x1="3312.857751572178" y1="502.58220111114224" x2="3200.4643189549906" y2="320.469591247861" class="minimap-edge"></line><circle cx="2103.968290880771" cy="268" r="40" class="minimap-node"></circle><circle cx="2066.9677515897347" cy="473.4119134177565" r="40" class="minimap-node"></circle><circle cx="1773.8400660428597" cy="666.5758233298659" r="40" class="minimap-node"></circle><circle cx="1931.1978950081452" cy="782.2775961320921" r="40" class="minimap-node"></circle><circle cx="2158.1262397347077" cy="767.7122274797483" r="40" class="minimap-node"></circle><circle cx="2342.2663764534577" cy="631.7681967180296" r="40" class="minimap-node"></circle><circle cx="2757.879480087803" cy="307.6117116091891" r="40" class="minimap-node"></circle><circle cx="3312.857751572178" cy="502.58220111114224" r="40" class="minimap-node"></circle><circle cx="2971.700036728428" cy="480.7287465212985" r="40" class="minimap-node"></circle><circle cx="3200.4643189549906" cy="320.469591247861" r="40" class="minimap-node"></circle><circle cx="2645.5845448279656" cy="970.7820678889219" r="40" class="minimap-node"></circle><rect class="minimap-viewport" id="minimap-viewport" x="1254.5197896196048" y="-147.55422459755366" width="2648.185035176588" height="1986.138776382441"></rect>
            </svg>
          </div>
          <div class="zoom-toolbar" id="zoom-toolbar">
            <button id="zoom-in-btn" title="Zoom in">+</button>
            <div class="zoom-level" id="zoom-level">151%</div>
            <button id="zoom-out-btn" title="Zoom out">-</button>
            <div class="divider"></div>
            <button id="zoom-fit-btn" title="Fit to view">[ ]</button>
            <button id="zoom-reset-btn" title="Reset view">R</button>
          </div>
        </div>
        <button type="button" id="edge-legend-mini" class="legend-mini-btn" style="bottom: 10px; display: none;">Line Legend</button>
        <button type="button" id="minimap-mini" class="legend-mini-btn" style="right: 10px; left: auto; bottom: 10px; display: none;">Map</button>
        <button type="button" id="draw-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: 10px; right: auto; display: none;">Draw</button>
        <button type="button" id="topology-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: auto; right: 40px; display: none;">Add Line</button>
     </section>
      <aside class="details-panel" id="details-panel">
        <div class="sidebar-resizer" id="sidebar-resizer">
          <svg class="resizer-icon" width="6" height="40" viewBox="0 0 6 40" xmlns="http://www.w3.org/2000/svg">
            <circle cx="3" cy="14" r="2"></circle>
            <circle cx="3" cy="20" r="2"></circle>
            <circle cx="3" cy="26" r="2"></circle>
          </svg>
        </div>
        <div class="mobile-footer-resizer" id="mobile-footer-resizer">
          <svg class="resizer-icon" width="40" height="6" viewBox="0 0 40 6" xmlns="http://www.w3.org/2000/svg">
            <circle cx="14" cy="3" r="2"></circle>
            <circle cx="20" cy="3" r="2"></circle>
            <circle cx="26" cy="3" r="2"></circle>
          </svg>
        </div>
        <div id="node-panel" style="display: block;">
          <div class="details-name editable-text" id="node-name">Internet</div>
          <div class="details-ip editable-text" id="node-ip">0.0.0.0</div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">MAC:</span>
            <span class="editable-text" id="node-mac" style="flex: 1; cursor: pointer; color: var(--text-main);">--</span>
          </div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">Rack Unit:</span>
            <span class="editable-text" id="node-rack" style="flex: 1; cursor: pointer; color: var(--text-main);">--</span>
          </div>
          <div class="details-info-row" id="uheight-row" style="display: none;">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">U Height:</span>
            <span class="editable-text" id="node-uheight" style="flex: 1; cursor: pointer; color: var(--text-main);">1U</span>
          </div>
          <div class="details-info-row" id="assigned-rack-row" style="display: flex;">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">Assigned Rack:</span>
            <select id="node-assigned-rack" style="flex: 1; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;"><option value="">None</option><option value="racked">Racked</option></select>
          </div>
          <div class="details-info-row" id="rack-capacity-row" style="display: none;">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">Rack Capacity:</span>
            <select id="node-rack-capacity" style="flex: 1; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;">
              <option value="42">42U</option>
              <option value="48">48U</option>
              <option value="24">24U</option>
              <option value="12">12U</option>
              <option value="6">6U</option>
            </select>
          </div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">Layer:</span>
            <select id="node-layer" style="flex: 1; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;">
              <option value="physical">Physical</option>
              <option value="logical">Logical</option>
              <option value="security">Security</option>
              <option value="application">Application</option>
            </select>
          </div>
          <div class="details-role" id="node-role"></div>
		  <details id="rack-contents-section" style="display: none; margin-top: 12px; margin-bottom: 12px; padding: 10px; background: var(--panel-alt); border-radius: 6px;" open="">
            <summary style="color: var(--accent); font-weight: 600; font-size: 14px; cursor: pointer;">Nodes in Rack (<span id="rack-contents-count">0</span>)</summary>
            <div id="rack-contents-list" style="max-height: 200px; overflow-y: auto; margin-top: 8px;"></div>
          </details>
          <div class="badge-row" id="node-tags"><span class="badge" style="cursor: pointer; opacity: 0.6; border-style: dashed;">+ Add Tag</span></div>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-tag-input" placeholder="Add tag..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-tag-btn" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button class="pick-icon-btn" id="pick-tag-icon-btn">Add Icon Tag</button>
          <div class="section-label">Size</div>
          <div class="size-controls">
            <label>Size:</label>
            <input type="range" id="size-slider" min="20" max="200" value="55">
            <span id="size-value">168</span>
            <button id="reset-size">Reset</button>
          </div>
          <details class="style-section">
            <summary>Styling</summary>
            <div class="style-content">
              <div class="style-row">
                <label>Screen:</label>
                <select id="style-scope">
                  <option value="all">All</option>
                  <option value="desktop">Desktop</option>
                  <option value="tablet">Tablet</option>
                  <option value="mobile">Mobile</option>
                  <option value="fold">Fold</option>
                </select>
              </div>
              <div class="style-row">
                <label>Shape:</label>
                <select id="shape-select"><option value="custom-icon">Custom Icon</option>
                  <optgroup label="Basic Shapes">
            <option value="circle">Circle</option>
            <option value="square">Square</option>
            <option value="rectangle">Rectangle</option>
            <option value="triangle">Triangle</option>
            <option value="hexagon">Hexagon</option>
            <option value="diamond">Diamond</option>
            <option value="star">Star</option>
            <option value="stop-sign">Stop Sign</option>
            <option value="octagon">Octagon</option>
            <option value="pentagon">Pentagon</option>
            <option value="cross">Cross</option>
            <option value="rounded-square">Rounded Square</option>
            <option value="pill">Pill</option>
            <option value="parallelogram">Parallelogram</option>
            <option value="trapezoid">Trapezoid</option>
          </optgroup>
          <optgroup label="Computers &amp; Devices">
            <option value="server">Server</option>
            <option value="pc">PC / Desktop</option>
            <option value="laptop">Laptop</option>
            <option value="phone">Phone / Mobile</option>
            <option value="printer">Printer</option>
            <option value="pi">Raspberry Pi</option>
            <option value="sensor">Sensor / IoT</option>
          </optgroup>
          <optgroup label="Network Equipment">
            <option value="router">Router</option>
            <option value="switch">Switch</option>
            <option value="firewall">Firewall</option>
            <option value="access-point">Access Point</option>
            <option value="load-balancer">Load Balancer</option>
            <option value="gateway">Gateway</option>
            <option value="vpn">VPN / Tunnel</option>
            <option value="nas">NAS / Storage</option>
          </optgroup>
          <optgroup label="Cloud &amp; Services">
            <option value="cloud">Cloud</option>
            <option value="database">Database</option>
			<option value="docker">Docker</option>
            <option value="container">Container</option>
            <option value="vm">Virtual Machine</option>
            <option value="kubernetes">Kubernetes</option>
            <option value="api">API / Endpoint</option>
            <option value="queue">Queue / Message</option>
            <option value="lambda">Lambda / Function</option>
            <option value="bucket">Bucket / S3</option>
          </optgroup>
          <optgroup label="Security &amp; Monitoring">
            <option value="shield">Shield</option>
            <option value="camera">Camera / CCTV</option>
            <option value="monitor">Monitor / Dashboard</option>
          </optgroup>
                </select>
              </div>
              <button class="pick-icon-btn" id="pick-shape-icon-btn">Or Search Web Icons</button>
              <div class="style-row">
                <label>Fill Color:</label>
                <input type="color" id="circle-color" value="#1e293b">
              </div>
              <div class="style-row">
                <label>Border Color:</label>
                <input type="color" id="circle-border" value="#475569">
              </div>
              <div class="style-row">
                <label>Title Color:</label>
                <input type="color" id="title-color" value="#e2e8f0">
              </div>
              <div class="style-row">
                <label>Title Font:</label>
                <select id="title-font">
                  <option value="system-ui, sans-serif">System UI</option>
                  <option value="monospace">Monospace</option>
                  <option value="serif">Serif</option>
                  <option value="cursive">Cursive</option>
                  <option value="'Courier New', monospace">Courier</option>
                  <option value="Arial, sans-serif">Arial</option>
                  <option value="'Times New Roman', serif">Times</option>
                </select>
              </div>
              <div class="style-row">
                <label>Title Size:</label>
                <input type="number" id="title-size" min="8" max="100" value="18">
              </div>
              <div class="style-row">
                <label>Sub Color:</label>
                <input type="color" id="sub-color" value="#94a3b8">
              </div>
              <div class="style-row">
                <label>Sub Font:</label>
                <select id="sub-font">
                  <option value="system-ui, sans-serif">System UI</option>
                  <option value="monospace">Monospace</option>
                  <option value="serif">Serif</option>
                  <option value="cursive">Cursive</option>
                  <option value="'Courier New', monospace">Courier</option>
                  <option value="Arial, sans-serif">Arial</option>
                  <option value="'Times New Roman', serif">Times</option>
                </select>
              </div>
              <div class="style-row">
                <label>Sub Size:</label>
                <input type="number" id="sub-size" min="6" max="80" value="13">
              </div>
              <div style="
                margin-top: 12px;
                padding-top: 10px;
                border-top: 1px solid var(--edge-main);
                ">
                <div style="font-size: 12px;color: var(--text-soft);margin-bottom: 8px;text-transform: uppercase;">Text Position</div>
                <div class="style-row">
                  <label>Name Y:</label>
                  <input type="number" id="title-offset-y" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>Name X:</label>
                  <input type="number" id="title-offset-x" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>IP Y:</label>
                  <input type="number" id="sub-offset-y" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>IP X:</label>
                  <input type="number" id="sub-offset-x" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div style="margin-top: 16px; font-size: 12px; color: var(--text-soft); text-transform: uppercase;">
                  Ping Indicator Position
                </div>
                <div class="style-row">
                  <label>Ping X:</label>
                  <input type="number" id="ping-offset-x" min="-200" max="200" value="0" style="width: 60px;">
                </div>
                <div class="style-row">
                  <label>Ping Y:</label>
                  <input type="number" id="ping-offset-y" min="-200" max="200" value="0" style="width: 60px;">
                </div>
              </div>
              <button id="reset-styles" style="width: 100%;margin-top: 10px;padding: 8px;background: var(--panel);color: var(--text-main);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: clamp(13px, 1.5vw, 17px);">Reset Styles</button>
            </div>
          </details>
          <details class="style-section">
            <summary>Ping / Status Monitoring</summary>
            <div class="style-content">
              <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px; cursor: pointer;">
              <input type="checkbox" id="node-pingable" style="cursor: pointer;">
              <span style="font-size: 14px;">Enable status check for this node</span>
              </label>
              <div id="node-ping-options" style="display: none;">
                <div class="style-row">
                  <label>Protocol:</label>
                  <select id="node-ping-protocol">
                    <option value="http">HTTP (port 80)</option>
                    <option value="https">HTTPS (port 443)</option>
                    <option value="custom">Custom URL</option>
                  </select>
                </div>
                <div id="node-custom-url-container" style="display: block; margin-top: 8px;">
                  <label style="display: block; margin-bottom: 4px; font-size: 13px;">Custom URL:</label>
                  <input type="text" id="node-custom-url" placeholder="e.g. http://192.168.1.1:8080" style="width: 100%;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: 14px;">
                </div>
                <div class="style-row" style="margin-top: 8px;">
                  <label>Timeout (ms):</label>
                  <input type="number" id="node-ping-timeout" value="3000" min="1000" max="10000" step="500" style="width: 100px;">
                </div>
                <div style="margin-top: 12px; padding: 10px; background: var(--panel); border-radius: 6px; border: 1px solid var(--edge-main);">
                  <div style="font-size: 12px; color: var(--text-soft); margin-bottom: 8px;">Current Status:</div>
                  <div id="node-ping-status" style="font-size: 14px; font-weight: 600; color: var(--accent);">● Online</div>
                  <div id="node-ping-last-check" style="font-size: 11px; color: var(--text-soft); margin-top: 4px;">Last checked: 2:25:19 PM</div>
                </div>
                <button id="check-ping-now" style="width: 100%;margin-top: 10px;padding: 8px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Check Status Now</button>
              </div>
            </div>
          </details>
          <div class="section-label">Notes</div>
          <ul class="list" id="node-notes"></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-note-input" placeholder="Type new note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-note-btn" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-node-btn" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: rgb(255, 255, 255);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;width: 100%;">Delete Node</button>
        </div>
        <div id="edge-panel" style="display: none">
          <div class="details-name" id="edge-title">Custom line</div>
          <div class="style-row" style="margin-top: 10px">
            <label>Width:</label>
            <input type="number" id="edge-width" min="1" max="20" value="4">
          </div>
          <div class="style-row">
            <label>Color:</label>
            <input type="color" id="edge-color" value="#475569">
          </div>
          <div class="style-row">
            <label>Line Style:</label>
            <select id="edge-line-style">
              <option value="solid">Solid</option>
              <option value="dashed">Dashed</option>
              <option value="dotted">Dotted</option>
            </select>
          </div>
          <div class="style-row">
            <label>Direction:</label>
            <select id="edge-direction">
              <option value="none">No arrows</option>
              <option value="forward">→ Forward</option>
              <option value="backward">← Backward</option>
              <option value="both">↔ Bidirectional</option>
            </select>
          </div>
          <div class="style-row" id="edge-port-fields">
            <label>From Port:</label>
            <input type="text" id="edge-from-port" placeholder="e.g. eth0, gi0/1" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);font-size: 14px;">
          </div>
          <div class="style-row" id="edge-port-fields-to">
            <label>To Port:</label>
            <input type="text" id="edge-to-port" placeholder="e.g. eth1, gi0/2" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);font-size: 14px;">
          </div>
          <div class="section-label">Line Notes</div>
          <ul class="list" id="edge-notes"></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-edge-note" placeholder="Add note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-edge-note" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-edge" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Delete Line</button>
        </div>
        <div id="rect-panel" style="display: none">
          <div class="details-name" id="rect-title">Zone</div>
          <div class="style-row" id="rect-fill-row" style="margin-top: 10px">
            <label>Fill Color:</label>
            <input type="color" id="rect-color" value="#f97316">
          </div>
          <div class="style-row">
            <label>Border Color:</label>
            <input type="color" id="rect-border-color" value="#f97316">
          </div>
          <div class="style-row">
            <label>Border Width:</label>
            <input type="number" id="rect-border-width" min="0" max="20" value="2">
          </div>
          <div class="style-row">
            <label>Style:</label>
            <select id="rect-style-select">
              <option value="filled">Filled</option>
              <option value="outlined">Outlined</option>
            </select>
          </div>
		  <div class="style-row">
            <label>Line Style:</label>
            <select id="rect-line-style">
              <option value="solid">Solid</option>
              <option value="dashed">Dashed</option>
              <option value="dotted">Dotted</option>
            </select>
          </div>
          <div class="section-label">Zone Notes</div>
          <ul class="list" id="rect-notes"></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-rect-note" placeholder="Add note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-rect-note" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-rect" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Delete Zone</button>
        </div>
        <div id="text-panel" style="display: none">
          <div class="details-name" id="text-title">Text Element</div>
          <div class="style-row" style="margin-top: 10px">
            <label>Content:</label>
            <textarea id="text-content" placeholder="Enter text..." style="width: 100%;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: 14px;min-height: 80px;resize: vertical;font-family: inherit;"></textarea>
          </div>
          <div class="style-row">
            <label>Font Size:</label>
            <input type="number" id="text-font-size" min="8" max="200" value="18" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);">
          </div>
          <div class="style-row">
            <label>Color:</label>
            <input type="color" id="text-color" value="#e2e8f0">
          </div>
          <div class="style-row">
            <label>Font Weight:</label>
            <select id="text-font-weight" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="normal">Normal</option>
              <option value="bold">Bold</option>
              <option value="600">Semi-Bold</option>
              <option value="300">Light</option>
            </select>
          </div>
          <div class="style-row">
            <label>Font Style:</label>
            <select id="text-font-style" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="normal">Normal</option>
              <option value="italic">Italic</option>
            </select>
          </div>
          <div class="style-row">
            <label>Text Align:</label>
            <select id="text-align" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="start">Left</option>
              <option value="middle">Center</option>
              <option value="end">Right</option>
            </select>
          </div>
          <div class="style-row">
            <label>Text Decoration:</label>
            <select id="text-decoration" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="none">None</option>
              <option value="underline">Underline</option>
              <option value="line-through">Strike Through</option>
            </select>
          </div>
          <div class="style-row">
            <label>Background:</label>
            <input type="color" id="text-bg-color" value="#000000">
            <label style="margin-left: 10px; display: flex; align-items: center; gap: 6px;">
            <input type="checkbox" id="text-bg-enabled" style="cursor: pointer;">
            <span style="font-size: 13px;">Enable</span>
            </label>
          </div>
          <div class="style-row">
            <label>Opacity:</label>
            <input type="range" id="text-opacity" min="0" max="1" step="0.1" value="1" style="flex: 1">
            <span id="text-opacity-val" style="min-width: 35px; text-align: right">100%</span>
          </div>
          <button id="delete-text" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;width: 100%;">Delete Text</button>
        </div>
     <details class="style-section">
          <summary>Page Layout</summary>
          <div class="style-content">
            <div style="padding: 12px; background: var(--panel-alt); border-radius: 6px; color: var(--text-soft); font-size: 13px; line-height: 1.6;">
              <strong style="color: var(--accent); display: block; margin-bottom: 8px;">Drag to Resize:</strong>
              • <strong>Header:</strong> Drag the bottom edge of the header bar<br>
              • <strong>Sidebar:</strong> Drag the left edge of the sidebar panel<br>
              • <strong>Mobile:</strong> Drag the top edge of the footer panel<br>
              <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--edge-main); font-size: 12px;">
                Hover over panel edges to see resize handles
              </div>
            </div>
          </div>
        </details>
      </aside>
    </main>
    <script id="nodes-json" type="application/json">{}</script>
    <script id="topology-state" type="application/json">ENCRYPTED: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</script>
    <script>
	Object.keys(localStorage).forEach(key => {
       if (key.startsWith('icon-selfhst-')) {
        const val = localStorage.getItem(key);
        if (val && val.includes('<image href=')) {
         localStorage.removeItem(key);
        }
       }
      });
      const IconLibrary = {
       libraries: {
        mdi: {
         name: 'Material Design Icons',
         cdnBase: 'https://cdn.jsdelivr.net/npm/@mdi/svg@latest/svg/',
         metaUrl: 'https://cdn.jsdelivr.net/npm/@mdi/svg@latest/meta.json',
         icons: []
        },
        simple: {
         name: 'Simple Icons',
         cdnBase: 'https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/',
         indexUrl: 'https://cdn.jsdelivr.net/npm/@iconify-json/simple-icons@latest/icons.json',
         icons: []
        },
        selfhst: {
         name: 'selfh.st/icons',
         cdnBase: 'https://cdn.jsdelivr.net/gh/selfhst/icons@master/svg/',
         indexUrl: 'https://raw.githubusercontent.com/selfhst/icons/refs/heads/main/index.json',
         icons: []
        }
       },
       currentLibrary: 'selfhst',
       iconCache: {},
       indexCache: {},
       indexLoading: {},
       async loadLibraryIndex(library) {
        if (this.indexCache[library]) {
         return this.indexCache[library];
        }
        if (this.indexLoading[library]) {
         return this.indexLoading[library];
        }
        const lib = this.libraries[library];
        this.indexLoading[library] = (async () => {
         try {
          if (library === 'selfhst') {
           const response = await fetch(lib.indexUrl);
           const data = await response.json();
           const icons = data.filter(item => item.SVG === "Yes").map(item => ({
            name: item.Reference,
            displayName: item.Name,
            tags: item.Tags ? item.Tags.split(',').map(t => t.trim()).filter(t => t) : [],
            category: item.Category
           }));
           this.indexCache[library] = icons;
           lib.icons = icons;
           return icons;
          } else if (library === 'simple') {
           const response = await fetch('https://cdn.jsdelivr.net/npm/@iconify-json/simple-icons@latest/icons.json');
           const data = await response.json();
           const icons = Object.keys(data.icons).map(slug => ({
            name: slug,
            displayName: data.icons[slug].title || slug,
            tags: data.aliases && data.aliases[slug] ? [data.aliases[slug].parent] : [],
            hex: data.icons[slug].hex
           }));
           this.indexCache[library] = icons;
           lib.icons = icons;
           return icons;
          } else if (library === 'mdi') {
           const response = await fetch(lib.metaUrl);
           const data = await response.json();
           const icons = data.map(item => ({
            name: item.name,
            displayName: item.name,
            tags: item.tags || [],
            author: item.author
           }));
           this.indexCache[library] = icons;
           lib.icons = icons;
           return icons;
          }
         } catch (error) {
          console.error(`Failed to load index for ${library}:`, error);
          this.indexCache[library] = [];
          lib.icons = [];
          return [];
         } finally {
          delete this.indexLoading[library];
         }
        })();
        return this.indexLoading[library];
       },
       async getIcon(library, name) {
        const cacheKey = `${library}-${name}`;
        if (this.iconCache[cacheKey]) {
         return this.iconCache[cacheKey];
        }
        const cached = localStorage.getItem(`icon-${cacheKey}`);
        if (cached) {
         this.iconCache[cacheKey] = cached;
         return cached;
        }
        const lib = this.libraries[library];
        const url = `${lib.cdnBase}${name}.svg`;
        try {
         const response = await fetch(url);
         if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
         }
         const svg = await response.text();
         this.iconCache[cacheKey] = svg;
         localStorage.setItem(`icon-${cacheKey}`, svg);
         return svg;
        } catch (error) {
         console.error(`Failed to fetch icon ${cacheKey}:`, error);
         return null;
        }
       },
       searchIcons(library, query) {
        const lib = this.libraries[library];
        if (!lib.icons.length) return [];
        const q = query.toLowerCase();
        return lib.icons.filter(icon => {
         const nameMatch = icon.name.toLowerCase().includes(q);
         const displayMatch = icon.displayName && icon.displayName.toLowerCase().includes(q);
         const tagMatch = icon.tags && icon.tags.some(t => t.toLowerCase().includes(q));
         const categoryMatch = icon.category && icon.category.toLowerCase().includes(q);
         return nameMatch || displayMatch || tagMatch || categoryMatch;
        }).slice(0, 50);
       }
      };
      let iconPickerCallback = null;
      let selectedNodeIconData = null;
      let selectedRackIconData = null;
      let newNodeIconTags = [];
      let freeDrawMode = false;
      async function checkNodeStatus(nodeId) {
       const data = NODE_DATA[nodeId];
       if (!data || !data.ping || !data.ping.enabled) return;
       
       data.ping.status = 'checking';
       data.ping.lastCheck = new Date().toISOString();
       updatePingIndicator(nodeId);
       if (currentNodeId === nodeId) {
        updatePingStatusDisplay(nodeId);
       }
       
       let url;
       if (data.ping.protocol === 'custom') {
        url = data.ping.customUrl;
       } else {
        const ip = data.ip || '0.0.0.0';
        const protocol = data.ping.protocol || 'http';
        url = `${protocol}://${ip}`;
       }
       
       if (!url) {
        data.ping.status = 'unknown';
        updatePingIndicator(nodeId);
        if (currentNodeId === nodeId) {
         updatePingStatusDisplay(nodeId);
        }
        return;
       }
       
       try {
        const controller = new AbortController();
        const timeout = data.ping.timeout || 3000;
        const timeoutId = setTimeout(() => controller.abort(), timeout);
        
        const response = await fetch(url, {
         method: 'HEAD',
         mode: 'no-cors', 
         signal: controller.signal
        });
        
        clearTimeout(timeoutId);
        
        data.ping.status = 'online';
       } catch (error) {
        data.ping.status = 'offline';
       }
       
       data.ping.lastCheck = new Date().toISOString();
       updatePingIndicator(nodeId);
       if (currentNodeId === nodeId) {
        updatePingStatusDisplay(nodeId);
       }
      }
      function rgbaToHex(val) {
      if (!val) return "#000000";
      if (val.startsWith("#")) return val;
      
      const m = val.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
      if (!m) return "#000000";
      
      const r = Number(m[1]).toString(16).padStart(2, "0");
      const g = Number(m[2]).toString(16).padStart(2, "0");
      const b = Number(m[3]).toString(16).padStart(2, "0");
      
      return `#${r}${g}${b}`;
      }
      function updatePingIndicator(nodeId) {
      const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
      if (!nodeGroup) return;
      
      const data = NODE_DATA[nodeId];
      if (!data || !data.ping || !data.ping.enabled) {
       const existingIndicator = nodeGroup.querySelector('.ping-indicator');
       if (existingIndicator) existingIndicator.remove();
       return;
      }
      
      let indicator = nodeGroup.querySelector('.ping-indicator');
      const label = nodeGroup.querySelector('.node-label');
      
      if (!indicator && label) {
       indicator = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
       indicator.classList.add('ping-indicator');
       nodeGroup.appendChild(indicator);
      }
      
      if (indicator && label) {
       const size = savedSizes[nodeId] || getDefaultSize();
       const radius = Math.max(4, size * 0.06);
      
       indicator.setAttribute('r', radius);
      
       const labelBBox = label.getBBox();
       const labelX = parseFloat(label.getAttribute('x') || 0);
       const labelY = parseFloat(label.getAttribute('y') || 0);
      
       const styles = resolveStylesForNode(nodeId);
      const offX = styles.pingOffsetX || 0;
      const offY = styles.pingOffsetY || 0;
      
      indicator.setAttribute('cx', (labelX - labelBBox.width / 2 - radius * 1.1) + offX);
      indicator.setAttribute('cy', (labelY - radius * 0.7) + offY);
      }
      
      if (indicator) {
       indicator.classList.remove('online', 'offline', 'checking');
       if (data.ping.status) indicator.classList.add(data.ping.status);
      }
      }
      
      
      function checkAllNodesStatus() {
       Object.keys(NODE_DATA).forEach(nodeId => {
        const data = NODE_DATA[nodeId];
        if (data && data.ping && data.ping.enabled) {
         checkNodeStatus(nodeId);
        }
       });
      }
      
      function startAutoPing() {
       stopAutoPing();
       
       checkAllNodesStatus();
       updateAutoPingLastRun();
       
       autoPingSecondsRemaining = autoPingInterval;
       
      
       autoPingTimer = setInterval(() => {
        checkAllNodesStatus();
        updateAutoPingLastRun();
        autoPingSecondsRemaining = autoPingInterval;
       }, autoPingInterval * 1000);
       
       autoPingCountdown = setInterval(() => {
        autoPingSecondsRemaining--;
        updateAutoPingCountdown();
        if (autoPingSecondsRemaining <= 0) {
         autoPingSecondsRemaining = autoPingInterval;
        }
       }, 1000);
       
       updateAutoPingCountdown();
      }
      
      function stopAutoPing() {
       if (autoPingTimer) {
        clearInterval(autoPingTimer);
        autoPingTimer = null;
       }
       if (autoPingCountdown) {
        clearInterval(autoPingCountdown);
        autoPingCountdown = null;
       }
       autoPingSecondsRemaining = 0;
       updateAutoPingCountdown();
      }
      
      function updateAutoPingCountdown() {
       const nextCheckEl = document.getElementById('auto-ping-next-check');
       if (nextCheckEl) {
        if (autoPingSecondsRemaining > 0 && autoPingEnabled) {
         const mins = Math.floor(autoPingSecondsRemaining / 60);
         const secs = autoPingSecondsRemaining % 60;
         if (mins > 0) {
          nextCheckEl.textContent = `Next check in: ${mins}m ${secs}s`;
         } else {
          nextCheckEl.textContent = `Next check in: ${secs}s`;
         }
        } else {
         nextCheckEl.textContent = 'Next check in: --';
        }
       }
      }
      
      function updateAutoPingLastRun() {
       const lastRunEl = document.getElementById('auto-ping-last-run');
       if (lastRunEl) {
        const now = new Date();
        lastRunEl.textContent = `Last run: ${now.toLocaleTimeString()}`;
       }
      }
      
      function openIconPicker(callback) {
       iconPickerCallback = callback;
       const modal = document.getElementById('icon-picker-modal');
       modal.classList.add('active');
       const searchInput = document.getElementById('icon-search');
       searchInput.style.display = 'none';
       loadIconsForCurrentLibrary();
      }
      
      function closeIconPicker() {
       const modal = document.getElementById('icon-picker-modal');
       modal.classList.remove('active');
       iconPickerCallback = null;
      }
      async function loadIconsForCurrentLibrary() {
       const body = document.getElementById('icon-picker-body');
       const libNames = {
        mdi: 'MDI (Material Design Icons)',
        simple: 'Simple Icons',
        selfhst: 'selfh.st/icons'
       };
       body.innerHTML = `<div style="padding: 20px;"><p style="color: var(--text-soft); margin-bottom: 15px; text-align: center;">Search ${libNames[IconLibrary.currentLibrary]}:</p><input type="text" id="icon-search-field" placeholder="Search icons..." style="width: 100%; padding: 12px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main); font-size: 16px; margin-bottom: 20px;"><div id="icon-grid-container" style="max-height: 400px; overflow-y: auto;"><div style="text-align: center; color: var(--text-soft); padding: 40px;">Loading icons...</div></div></div>`;
       const searchField = document.getElementById('icon-search-field');
       const gridContainer = document.getElementById('icon-grid-container');
       await IconLibrary.loadLibraryIndex(IconLibrary.currentLibrary);
       const renderIcons = (icons) => {
        if (!icons || icons.length === 0) {
         gridContainer.innerHTML = '<div style="text-align: center; color: var(--text-soft); padding: 40px;">No icons found</div>';
         return;
        }
        const grid = document.createElement('div');
        grid.style.cssText = 'display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 15px; padding: 10px;';
        icons.forEach(icon => {
         const item = document.createElement('div');
         item.style.cssText = 'display: flex; flex-direction: column; align-items: center; gap: 8px; padding: 15px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; cursor: pointer; transition: all 0.2s;';
         item.onmouseover = () => {
          item.style.background = 'var(--panel)';
          item.style.borderColor = 'var(--accent)';
         };
         item.onmouseout = () => {
          item.style.background = 'var(--panel-alt)';
          item.style.borderColor = 'var(--edge-main)';
         };
         const iconPreview = document.createElement('div');
         iconPreview.style.cssText = 'width: 48px; height: 48px; display: flex; align-items: center; justify-content: center;';
         iconPreview.innerHTML = '<div style="color: var(--text-soft); font-size: 12px;">...</div>';
         IconLibrary.getIcon(IconLibrary.currentLibrary, icon.name).then(svg => {
          if (svg) {
           const parser = new DOMParser();
           const doc = parser.parseFromString(svg, 'image/svg+xml');
           const svgEl = doc.querySelector('svg');
           if (svgEl) {
            svgEl.setAttribute('width', '48');
            svgEl.setAttribute('height', '48');
            svgEl.style.fill = 'var(--text-main)';
            iconPreview.innerHTML = '';
            iconPreview.appendChild(svgEl);
           }
          }
         });
         const name = document.createElement('div');
         name.textContent = icon.displayName || icon.name;
         name.style.cssText = 'font-size: 11px; color: var(--text-soft); text-align: center; word-break: break-word; max-width: 100%;';
         item.appendChild(iconPreview);
         item.appendChild(name);
         item.addEventListener('click', async () => {
          const svg = await IconLibrary.getIcon(IconLibrary.currentLibrary, icon.name);
          if (iconPickerCallback && svg) {
           iconPickerCallback({
            library: IconLibrary.currentLibrary,
            name: icon.name,
            svg: svg
           });
          }
          closeIconPicker();
         });
         grid.appendChild(item);
        });
        gridContainer.innerHTML = '';
        gridContainer.appendChild(grid);
       };
       gridContainer.innerHTML = '<div style="text-align: center; color: var(--text-soft); padding: 40px;">Type to search icons</div>';
       let searchTimeout;
       searchField.addEventListener('input', (e) => {
        clearTimeout(searchTimeout);
        const query = e.target.value.trim();
        searchTimeout = setTimeout(() => {
         if (!query) {
          gridContainer.innerHTML = '<div style="text-align: center; color: var(--text-soft); padding: 40px;">Type to search icons</div>';
          return;
         }
         const results = IconLibrary.searchIcons(IconLibrary.currentLibrary, query);
         renderIcons(results);
        }, 300);
       });
       searchField.focus();
      }
      async function displayIcons(icons) {
       const body = document.getElementById('icon-picker-body');
       const grid = document.createElement('div');
       grid.className = 'icon-grid';
       for (const icon of icons) {
        const item = document.createElement('div');
        item.className = 'icon-item';
        const svg = await IconLibrary.getIcon(icon.library, icon.name);
        if (svg) {
         const parser = new DOMParser();
         const doc = parser.parseFromString(svg, 'image/svg+xml');
         const svgEl = doc.querySelector('svg');
         if (svgEl) {
          item.innerHTML = svgEl.outerHTML;
         }
        } else {
         item.innerHTML = '<svg width = "32" height = "32"><rect width = "32" height = "32" fill = "currentColor"/> </svg>';
        }
        const name = document.createElement('div');
        name.className = 'icon-item-name';
        name.textContent = icon.name;
        item.appendChild(name);
        item.addEventListener('click', () => {
         if (iconPickerCallback) {
          iconPickerCallback({
           library: icon.library,
           name: icon.name,
           svg: svg
          });
         }
         closeIconPicker();
        });
        grid.appendChild(item);
       }
       body.innerHTML = '';
       body.appendChild(grid);
      }
      window.addEventListener('DOMContentLoaded', () => {
       document.querySelectorAll('.icon-picker-tab').forEach(tab => {
        tab.addEventListener('click', () => {
         document.querySelectorAll('.icon-picker-tab').forEach(t => t.classList.remove('active'));
         tab.classList.add('active');
         IconLibrary.currentLibrary = tab.dataset.library;
         loadIconsForCurrentLibrary();
        });
       });
       document.getElementById('icon-picker-cancel').addEventListener('click', closeIconPicker);
       document.getElementById('icon-picker-modal').addEventListener('click', (e) => {
        if (e.target.id === 'icon-picker-modal') {
         closeIconPicker();
        }
       });
      });
      let textDrawMode = false;
      const BASE_NODE_DATA = JSON.parse(document.getElementById("nodes-json").textContent, );
      let currentNodeId = "host";
      let currentEdgeId = null;
      let currentStyleScope = "all";
      let NODE_DATA = {};
      let EDGE_DATA = {
       list: []
      };
      let currentRectId = null;
      let currentTextId = null;
      let rectDrawMode = false;
      let RECT_DATA = {
       list: []
      };
      let TEXT_DATA = {
       list: []
      };
      let EDGE_LEGEND = {};
      let savedPositions = {};
      let savedSizes = {};
      let savedStyles = {};
      let legendCollapsed = false;
      let minimapCollapsed = false;
      let drawToolbarCollapsed = false;
      let currentView = {
       mode: "topology",
       rackId: null
      };
      let savedTopologyView = null;
      let activeLayers = new Set(["physical", "logical", "security", "application"]);
      let topologyToolbarCollapsed = false;
      let legendMiniBtn = null;
      let minimapMiniBtn = null;
      let drawToolbarMiniBtn = null;
      let topologyToolbarMiniBtn = null;
      
      let autoPingEnabled = false;
      let autoPingInterval = 30;
      let autoPingTimer = null;
      let autoPingCountdown = null;
      let autoPingSecondsRemaining = 0;
      
      const ROLLBACK_STORAGE_KEY = "theonefile_rollback_history";
      let rollbackVersions = [];
      const MAX_ROLLBACK_VERSIONS = 50;
      let currentRollbackIndex = -1;
      
      const AUDIT_STORAGE_KEY = "theonefile_audit_log";
      let auditLog = [];
      const MAX_AUDIT_ENTRIES = 1000;
      
      let documentTabs = [{
        id: "main",
        name: "Main Topology",
        nodes: {},
        edges: { list: [] },
        positions: {},
        sizes: {},
        styles: {},
        legend: {},
        rects: { list: [] },
        texts: { list: [] },
      pageState: null
      }];
      let currentTabIndex = 0;
      
      let encryptedSections = {};
      
      let undoStack = [];
      let redoStack = [];
      const MAX_UNDO_STACK = 50;
      let selectedNodes = new Set();
      let selectedEdges = new Set();
      let selectedRects = new Set();
      let selectedTexts = new Set();
      let isSelecting = false;
      let selectionStart = null;
      let preDragSelectedNodes = new Set();
      let preDragSelectedEdges = new Set();
      let preDragSelectedRects = new Set();
      let preDragSelectedTexts = new Set();
      let selectionRect = null;
      let isDraggingSelection = false;
      let dragSelectionStart = null;
      let selectionBoxStyle = {
       fillColor: "#4fd1c5",
       fillOpacity: 0.1,
       strokeColor: "#4fd1c5",
       strokeWidth: 2,
       strokeDasharray: "5,5"
      };
      let clipboard = null;
      
      const MobileManager = {
        isMobile: false,
        detect() {
      
          if (navigator.userAgentData?.mobile === true) {
            this.isMobile = true;
            return true;
          }
          const coarse = matchMedia("(pointer: coarse)").matches;
          const width = window.innerWidth <= 900;
          const portrait = matchMedia("(orientation: portrait)").matches;
          this.isMobile = coarse && (width || portrait);
          return this.isMobile;
        },
        applyInitialCollapse() {
          if (!this.isMobile) return;
          legendCollapsed = true;
          minimapCollapsed = true;
          drawToolbarCollapsed = true;
          topologyToolbarCollapsed = true;
          if (typeof updateLegendVisibility === "function") updateLegendVisibility();
          if (typeof updateMinimapVisibility === "function") updateMinimapVisibility();
          if (typeof updateDrawToolbarVisibility === "function") updateDrawToolbarVisibility();
          if (typeof updateTopologyToolbarVisibility === "function") updateTopologyToolbarVisibility();
        },
        updateBulkToolbar() {
          const desktop = document.getElementById("bulk-toolbar");
          const mobile = document.getElementById("bulk-toolbar-mobile");
          if (!desktop || !mobile) return;
          
          if (typeof isViewOnly === 'function' && isViewOnly()) {
           desktop.style.display = "none";
           mobile.style.display = "none";
           return;
          }
          
          if (typeof selectedNodes === 'undefined' || selectedNodes.size === 0) {
           desktop.style.display = "none";
           mobile.style.display = "none";
           return;
          }
          
          const isVisible = desktop.style.display !== "none" || mobile.style.display !== "none";
          
          if (this.isMobile) {
            desktop.style.display = "none";
            if (isVisible) {
              mobile.style.display = "flex";
            }
          } else {
            mobile.style.display = "none";
            if (isVisible) {
              desktop.style.display = "flex";
            }
          }
        },
        updateLayout() {
          const main = document.querySelector("main");
          if (!main) return;
        },
        updateCanvasHint() {
      const hint = document.getElementById("canvas-hint");
      if (!hint) return;
      
      if (PAGE_STATE.canvasHintText !== undefined && PAGE_STATE.canvasHintText !== "") {
        hint.innerHTML = PAGE_STATE.canvasHintText;
        return;
      }
      
      const items = this.isMobile
      ? [
        "Pinch to zoom",
        "Drag to pan",
        "Add node from top menu",
        "Double tap to clone and align",
        "Double tap to select multiple",
        "You have the power",	
        "Your time is NOW!",
      ]
      : [
        "Scroll to zoom",
        "Drag to pan",
        "Right click to clone and align",
        "Right click to select multiple",
        "You have the power",
        "Your time is NOW!",
      ];
      
      const list = document.createElement("ul");
      for (const item of items) {
      const li = document.createElement("li");
      li.textContent = item;
      list.appendChild(li);
      }
      
      hint.replaceChildren(list);
      },
        autoSelectStyleScope() {
          const scope = document.getElementById("style-scope");
          if (!scope) return;
          if (this.isMobile) scope.value = "mobile";
        },
        updateToolbarStack() {
          if (!this.isMobile) return;
          const draw = document.getElementById("draw-toolbar");
          const topo = document.getElementById("topology-toolbar");
          if (!draw || !topo) return;
          const h = draw.getBoundingClientRect().height;
          document.documentElement.style.setProperty("--draw-toolbar-height", h + "px");
        },
        updateLayoutControls() {
          const sidebarRow = document.getElementById("sidebar-width-row");
          const footerRow = document.getElementById("mobile-footer-row");
          if (sidebarRow && footerRow) {
            if (this.isMobile) {
              sidebarRow.style.display = "none";
              footerRow.style.display = "flex";
            } else {
              sidebarRow.style.display = "flex";
              footerRow.style.display = "none";
            }
          }
        },
        applyAll() {
          this.detect();
          this.applyInitialCollapse();
          this.updateBulkToolbar();
          this.updateLayout();
          this.updateCanvasHint();
          this.autoSelectStyleScope();
          this.updateToolbarStack();
          this.updateLayoutControls();
        }
      };
      function isMobileDevice() {
        return MobileManager.isMobile;
      }
      
      function ensureLegendMiniButton() {
       if (legendMiniBtn) return legendMiniBtn;
       const existing = document.getElementById("minimap-mini");
       if (existing) { minimapMiniBtn = existing; return existing; }
       const panel = document.querySelector(".topology-panel");
       if (!panel) return null;
       const btn = document.createElement("button");
       btn.type = "button";
       btn.id = "edge-legend-mini";
       btn.className = "legend-mini-btn";
       btn.textContent = "Legend";
       btn.style.bottom = "10px";
       const handleClick = (e) => {
        e.stopPropagation();
        e.preventDefault();
        legendCollapsed = false;
        updateLegendVisibility();
       };
       btn.addEventListener("click", handleClick);
       btn.addEventListener("touchend", handleClick);
       panel.appendChild(btn);
       legendMiniBtn = btn;
       return btn;
      }
      
      function ensureMinimapMiniButton() {
       if (minimapMiniBtn) return minimapMiniBtn;
       const panel = document.querySelector(".topology-panel");
       if (!panel) return null;
       const btn = document.createElement("button");
       btn.type = "button";
       btn.id = "minimap-mini";
       btn.className = "legend-mini-btn";
       btn.textContent = "Map";
       btn.style.right = "10px";
       btn.style.left = "auto";
       btn.style.bottom = "10px";
       const handleClick = (e) => {
        e.stopPropagation();
        e.preventDefault();
        minimapCollapsed = false;
        updateMinimapVisibility();
       };
       btn.addEventListener("click", handleClick);
       btn.addEventListener("touchend", handleClick);
       panel.appendChild(btn);
       minimapMiniBtn = btn;
       return btn;
      }
      
      function ensureDrawToolbarMiniButton() {
       if (drawToolbarMiniBtn) return drawToolbarMiniBtn;
	   const existing = document.getElementById("draw-toolbar-mini");
       if (existing) { drawToolbarMiniBtn = existing; return existing; }
       const panel = document.querySelector(".topology-panel");
       if (!panel) return null;
       const btn = document.createElement("button");
       btn.type = "button";
       btn.id = "draw-toolbar-mini";
       btn.className = "legend-mini-btn";
       btn.textContent = "Draw";
       btn.style.top = "10px";
       btn.style.left = "10px";
       btn.style.right = "auto";
       const handleClick = (e) => {
        e.stopPropagation();
        e.preventDefault();
        drawToolbarCollapsed = false;
        updateDrawToolbarVisibility();
       };
       btn.addEventListener("click", handleClick);
       btn.addEventListener("touchend", handleClick);
       panel.appendChild(btn);
       drawToolbarMiniBtn = btn;
       return btn;
      }
      
      function ensureTopologyToolbarMiniButton() {
       if (topologyToolbarMiniBtn) return topologyToolbarMiniBtn;
	   const existing = document.getElementById("topology-toolbar-mini");
       if (existing) { topologyToolbarMiniBtn = existing; return existing; }
       const panel = document.querySelector(".topology-panel");
       if (!panel) return null;
       const btn = document.createElement("button");
       btn.type = "button";
       btn.id = "topology-toolbar-mini";
       btn.className = "legend-mini-btn";
       btn.textContent = "Add Line";
       btn.style.top = "10px";
       btn.style.left = "auto";
       btn.style.right = "40px";
       const handleClick = (e) => {
        e.stopPropagation();
        e.preventDefault();
        topologyToolbarCollapsed = false;
        updateTopologyToolbarVisibility();
       };
       btn.addEventListener("click", handleClick);
       btn.addEventListener("touchend", handleClick);
       panel.appendChild(btn);
       topologyToolbarMiniBtn = btn;
       return btn;
      }
      
      function updateToolbarStack() {
       if (!isMobileDevice()) return;
       const draw = document.getElementById("draw-toolbar");
       const topo = document.getElementById("topology-toolbar");
       if (!draw || !topo) return;
       const h = draw.getBoundingClientRect().height;
       document.documentElement.style.setProperty("--draw-toolbar-height", h + "px");
      }
      window.addEventListener("resize", updateToolbarStack);
      window.addEventListener("DOMContentLoaded", updateToolbarStack);
      updateToolbarStack();
      
      function updateLegendVisibility() {
       const legend = document.getElementById("edge-legend");
       const mini = ensureLegendMiniButton();
       if (!legend || !mini) return;
       const hasItems = legend.querySelectorAll(".legend-item").length > 0;
       if (!hasItems) {
        legend.style.display = "none";
        mini.style.display = "none";
        return;
       }
       if (legendCollapsed) {
        legend.style.display = "none";
        mini.style.display = "inline-flex";
       } else {
        legend.style.display = "flex";
        mini.style.display = "none";
       }
      }
      
      function updateMinimapVisibility() {
       const wrapper = document.getElementById("minimap-zoom-wrapper");
       const mini = ensureMinimapMiniButton();
       if (!wrapper || !mini) return;
       if (minimapCollapsed) {
        wrapper.style.display = "none";
        mini.style.display = "inline-flex";
       } else {
        wrapper.style.display = "block";
        mini.style.display = "none";
       }
      }
      
      function updateDrawToolbarVisibility() {
       const toolbar = document.getElementById("draw-toolbar");
       const mini = ensureDrawToolbarMiniButton();
       if (!toolbar || !mini) return;
       if (typeof isViewOnly === 'function' && isViewOnly()) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "none";
        return;
       }
       if (drawToolbarCollapsed) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "inline-flex";
       } else {
      if (isMobileDevice()) {    	   
        toolbar.style.setProperty('display', 'grid', 'important');
        mini.style.display = "none";
        } else {   
        toolbar.style.setProperty('display', 'flex', 'important');
        mini.style.display = "none";	  
      }
       }
      }
      
      function u8ToBase64(u8) {
      let binary = "";
      for (let i = 0; i < u8.length; i++) binary += String.fromCharCode(u8[i]);
      return btoa(binary);
      }
      
      function base64ToU8(base64) {
      const binary = atob(base64);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
      return bytes;
      }  
      
      function updateTopologyToolbarVisibility() {
       const toolbar = document.getElementById("topology-toolbar");
       const mini = ensureTopologyToolbarMiniButton();
       if (!toolbar || !mini) return;
       if (typeof isViewOnly === 'function' && isViewOnly()) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "none";
        return;
       }
       const hasSelectedNode = currentNodeId !== null;
       if (!hasSelectedNode) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "none";
       } else if (topologyToolbarCollapsed) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "inline-flex";
       } else {   
      if (isMobileDevice()) {    	   
        toolbar.style.setProperty('display', 'grid', 'important');
        mini.style.display = "none";
        } else {   
        toolbar.style.setProperty('display', 'flex', 'important');
        mini.style.display = "none";	  
      }
       }
      }
      const DEFAULT_CANVAS_HINT = document.getElementById("canvas-hint")?.innerHTML || "";
      const DEFAULT_PAGE_STATE = {
       title: "The One File: The Networkening",
       background: "",
       topbarBg: "rgba(9, 12, 20, 0.9)",
       topbarBorder: "#1f2533",
       panel: "#0b0e13",
       panelAlt: "#10141b",
       accent: "#4fd1c5",
       sidebarBg: "#10141b",
       btnBg: "#0b0e13",
       btnText: "#e2e8f0",
       tagFill: "#1e293b",
       tagText: "#e2e8f0",
       tagBorder: "#475569",
       inputBg: "#0b0e13",
       inputText: "#e2e8f0",
       inputBorder: "#1f2937",
       inputFont: "Inter, system-ui, sans-serif",
       inputFontSize: 14,
       toolbarBg: "#0f172a",
       toolbarBorder: "#1f2937",
       toolbarText: "#94a3b8",
       toolbarBtnBg: "#0b0e13",
       toolbarBtnText: "#e2e8f0",
       minimapDots: "#94a3b8",
       canvasHintEnabled: true,
       canvasHintText: "",
       canvasHintBg: "#0f172a",
       canvasHintColor: "#94a3b8",
       danger: "#f56565",
       textMain: "#e2e8f0",
       textSoft: "#94a3b8",
       topbarHeight: 52,
       sidebarWidth: 350,
       mobileFooterHeight: 40,
       sidebarCollapsed: false,
       nodeFill: "#1e293b",
       nodeStroke: "#475569",
       nodeTitle: "#e2e8f0",
       nodeSub: "#94a3b8",
       nodeTitleSize: 18,
       nodeSubSize: 13,
       nodeFont: "Inter, system-ui, sans-serif",
       defaultEdge: "#475569",
       selectionHandle: "#f59e0b",
       selectionHandleSize: 8,
       groupIndicator: "#4fd1c5",
       canvasGradientTop: "#1e2532",
       canvasGradientBottom: "#050608",
       canvasBorder: "#475569",
       canvasGrid: "#475569",
       canvasGridSize: 50,
       rackFrameFill: "#0f172a",
       rackFrameStroke: "#4fd1c5",
       rackLineColor: "#475569",
       rackTextColor: "#4fd1c5",
	   viewOnly: false,
      };
      let PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE);
	  function isViewOnly() {
       return PAGE_STATE.viewOnly === true;
      }
      
      let viewOnlyClickCount = 0;
      let viewOnlyClickTimer = null;
      let viewOnlyClickTarget = null;
      
      function handleViewOnlyClick(id, type) {
       if (!isViewOnly()) return false;
       
       if (viewOnlyClickTarget !== id) {
        viewOnlyClickCount = 0;
        viewOnlyClickTarget = id;
       }
       
       viewOnlyClickCount++;
       
       clearTimeout(viewOnlyClickTimer);
       viewOnlyClickTimer = setTimeout(() => {
        viewOnlyClickCount = 0;
        viewOnlyClickTarget = null;
       }, 2000);
       
       if (viewOnlyClickCount >= 5) {
        viewOnlyClickCount = 0;
        viewOnlyClickTarget = null;
        
        document.body.classList.add("view-only-inspect");
        
        if (type === 'node') {
         currentNodeId = id;
         const data = NODE_DATA[id];
         if (data) {
          document.querySelectorAll(".node-group").forEach((n) => {
           n.classList.toggle("active", n.dataset.nodeId === id);
          });
          document.getElementById("node-panel").style.display = "block";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("node-name").textContent = data.name;
          document.getElementById("node-ip").textContent = data.ip;
          document.getElementById("node-role").textContent = data.role;
          document.getElementById("node-mac").textContent = data.mac || "--";
          document.getElementById("node-rack").textContent = data.rackUnit || "--";
          document.getElementById("node-uheight").textContent = (data.uHeight || "1") + "U";
          
          const tagList = document.getElementById("node-tags");
          if (tagList) {
           tagList.innerHTML = "";
           if (data.tags && data.tags.length > 0) {
            data.tags.forEach((tag) => {
             const li = document.createElement("li");
             li.textContent = tag;
             tagList.appendChild(li);
            });
           }
          }
          
          const noteList = document.getElementById("node-notes");
          if (noteList) {
           noteList.innerHTML = "";
           if (data.notes && data.notes.length > 0) {
            data.notes.forEach((note) => {
             const li = document.createElement("li");
             li.textContent = note;
             noteList.appendChild(li);
            });
           }
          }
         }
        } else if (type === 'edge') {
         currentEdgeId = id;
         const edge = EDGE_DATA.list.find(e => e.id === id);
         if (edge) {
          document.querySelectorAll(".edge").forEach((e) => {
           e.classList.toggle("active", e.dataset.edgeId === id);
          });
          document.getElementById("edge-panel").style.display = "block";
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-from").textContent = NODE_DATA[edge.from]?.name || edge.from;
          document.getElementById("edge-to").textContent = NODE_DATA[edge.to]?.name || edge.to;
          document.getElementById("edge-label").value = edge.label || "";
         }
        }
        return true;
       }
       return false;
      }
      const CANVAS_WIDTH = 4000;
      let CANVAS_HEIGHT = 3000;
      const BASE_CANVAS_HEIGHT = 3000;
      const CANVAS_PADDING = 100;
      
      const RACK_U_HEIGHT = 70;
      const RACK_WIDTH = 600;
      const RACK_START_X = CANVAS_WIDTH / 2;
      const RACK_START_Y = CANVAS_PADDING + 100;
      function getRackUHeight(rackId) {
      const capacity = getRackCapacity(rackId);
      const availableHeight = CANVAS_HEIGHT - RACK_START_Y - 200;
      return Math.floor(availableHeight / capacity);
      }
      let canvasState = {
       zoom: 1,
       panX: 0,
       panY: 0,
       minZoom: 0.25,
       maxZoom: 4,
       isPanning: false,
       panStartX: 0,
       panStartY: 0,
       spacePressed: false,
      };
      
      function getViewBox() {
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       return {
        x: canvasState.panX,
        y: canvasState.panY,
        width: viewWidth,
        height: viewHeight,
       };
      }
      
      function updateViewBox() {
       const svg = document.getElementById("map");
       const vb = getViewBox();
       svg.setAttribute("viewBox", `${vb.x} ${vb.y} ${vb.width} ${vb.height}`, );
       const zoomLevel = document.getElementById("zoom-level");
       if (zoomLevel) {
        zoomLevel.textContent = Math.round(canvasState.zoom * 100) + "%";
       }
       updateMinimap();
      }
      
      function updateMinimap() {
       const minimapViewport = document.getElementById("minimap-viewport");
       const minimapSvg = document.getElementById("minimap");
       if (!minimapViewport || !minimapSvg) return;
       const vb = getViewBox();
       minimapViewport.setAttribute("x", vb.x);
       minimapViewport.setAttribute("y", vb.y);
       minimapViewport.setAttribute("width", vb.width);
       minimapViewport.setAttribute("height", vb.height);
       const minimapNodes = minimapSvg.querySelectorAll(".minimap-node");
       minimapNodes.forEach((n) => n.remove());
       const minimapEdges = minimapSvg.querySelectorAll(".minimap-edge");
       minimapEdges.forEach((e) => e.remove());
       
       EDGE_DATA.list.forEach((edge) => {
        if (edge.type === "custom") return;
        
        const fromNode = NODE_DATA[edge.from];
        const toNode = NODE_DATA[edge.to];
        if (!fromNode || !toNode) return;
        
        if (currentView.mode === "rack") {
         if (fromNode.assignedRack !== currentView.rackId || 
             toNode.assignedRack !== currentView.rackId) {
          return;
         }
        } else {
         if (fromNode.assignedRack || toNode.assignedRack) {
          return;
         }
        }
        
        const p1 = savedPositions[edge.from];
        const p2 = savedPositions[edge.to];
        if (!p1 || !p2) return;
        const line = document.createElementNS("http://www.w3.org/2000/svg", "line", );
        line.setAttribute("x1", p1.x);
        line.setAttribute("y1", p1.y);
        line.setAttribute("x2", p2.x);
        line.setAttribute("y2", p2.y);
        line.classList.add("minimap-edge");
        minimapSvg.insertBefore(line, minimapViewport);
       });
      
       Object.entries(savedPositions).forEach(([id, pos]) => {
        const node = NODE_DATA[id];
        if (!node) return;
        
        if (currentView.mode === "rack") {
         if (node.assignedRack !== currentView.rackId) {
          return;
         }
        } else {
         if (node.assignedRack) {
          return;
         }
        }
        
        const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle", );
        circle.setAttribute("cx", pos.x);
        circle.setAttribute("cy", pos.y);
        circle.setAttribute("r", 40);
        circle.classList.add("minimap-node");
        minimapSvg.insertBefore(circle, minimapViewport);
       });
      }
      
      function zoomTo(newZoom, centerX, centerY) {
       const oldZoom = canvasState.zoom;
       newZoom = Math.max(canvasState.minZoom, Math.min(canvasState.maxZoom, newZoom), );
       if (centerX !== undefined && centerY !== undefined) {
        const oldWidth = CANVAS_WIDTH / oldZoom;
        const oldHeight = CANVAS_HEIGHT / oldZoom;
        const newWidth = CANVAS_WIDTH / newZoom;
        const newHeight = CANVAS_HEIGHT / newZoom;
        const pointX = canvasState.panX + centerX * oldWidth;
        const pointY = canvasState.panY + centerY * oldHeight;
        canvasState.panX = pointX - centerX * newWidth;
        canvasState.panY = pointY - centerY * newHeight;
       }
       canvasState.zoom = newZoom;
       constrainPan();
       updateViewBox();
      }
      
      function constrainPan() {
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       const minVisiblePortion = 0.1;
       const maxPanX = CANVAS_WIDTH - viewWidth * minVisiblePortion;
       const maxPanY = CANVAS_HEIGHT - viewHeight * minVisiblePortion;
       const minPanX = -viewWidth * (1 - minVisiblePortion);
       const minPanY = -viewHeight * (1 - minVisiblePortion);
       canvasState.panX = Math.max(minPanX, Math.min(maxPanX, canvasState.panX), );
       canvasState.panY = Math.max(minPanY, Math.min(maxPanY, canvasState.panY), );
      }
      
      function fitToContent() {
       const positions = Object.values(savedPositions);
       if (positions.length === 0) {
        resetView();
        return;
       }
       let minX = Infinity,
        minY = Infinity,
        maxX = -Infinity,
        maxY = -Infinity;
       positions.forEach((pos) => {
        minX = Math.min(minX, pos.x - 100);
        minY = Math.min(minY, pos.y - 100);
        maxX = Math.max(maxX, pos.x + 100);
        maxY = Math.max(maxY, pos.y + 100);
       });
       const contentWidth = maxX - minX + 200;
       const contentHeight = maxY - minY + 200;
       const viewport = document.getElementById("canvas-viewport");
       const vpRect = viewport.getBoundingClientRect();
       const aspectRatio = vpRect.width / vpRect.height;
       const contentAspect = contentWidth / contentHeight;
       let newZoom;
       if (contentAspect > aspectRatio) {
        newZoom = (vpRect.width / contentWidth) * (CANVAS_WIDTH / vpRect.width);
       } else {
        newZoom = (vpRect.height / contentHeight) * (CANVAS_HEIGHT / vpRect.height);
       }
       newZoom = Math.max(canvasState.minZoom, Math.min(2, newZoom));
       const viewWidth = CANVAS_WIDTH / newZoom;
       const viewHeight = CANVAS_HEIGHT / newZoom;
       canvasState.zoom = newZoom;
       canvasState.panX = minX - 100 - (viewWidth - contentWidth) / 2;
       canvasState.panY = minY - 100 - (viewHeight - contentHeight) / 2;
       constrainPan();
       updateViewBox();
      }
      
      function resetView() {
       canvasState.zoom = 1;
       canvasState.panX = 0;
       canvasState.panY = 0;
       updateViewBox();
      }
      window.addEventListener("DOMContentLoaded", () => {
       const toggle = document.getElementById("mobile-menu-toggle");
       const menu = document.getElementById("topbar-menu");
       if (!toggle || !menu) return;
       toggle.addEventListener("click", () => {
        menu.classList.toggle("open");
       });
       menu.addEventListener("click", (e) => {
        const target = e.target.closest("a, button");
        if (!target) return;
        if (isMobileDevice()) {
       menu.classList.remove("open");
      }
       });
       const minimapCloseBtn = document.getElementById("minimap-close-btn");
       if (minimapCloseBtn) {
        const handleMinimapClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         minimapCollapsed = true;
         updateMinimapVisibility();
        };
        minimapCloseBtn.addEventListener("click", handleMinimapClose);
        minimapCloseBtn.addEventListener("touchend", handleMinimapClose);
       }
       const drawToolbarCloseBtn = document.getElementById("draw-toolbar-close-btn");
       if (drawToolbarCloseBtn) {
        const handleDrawClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         drawToolbarCollapsed = true;
         updateDrawToolbarVisibility();
        };
        drawToolbarCloseBtn.addEventListener("click", handleDrawClose);
        drawToolbarCloseBtn.addEventListener("touchend", handleDrawClose);
       }
       const topologyToolbarCloseBtn = document.getElementById("topology-toolbar-close-btn");
       if (topologyToolbarCloseBtn) {
        const handleTopologyClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         topologyToolbarCollapsed = true;
         updateTopologyToolbarVisibility();
        };
        topologyToolbarCloseBtn.addEventListener("click", handleTopologyClose);
        topologyToolbarCloseBtn.addEventListener("touchstart", (e) => e.preventDefault(), {
         passive: false
        });
        topologyToolbarCloseBtn.addEventListener("touchend", handleTopologyClose);
       }
      
       updateMinimapVisibility();
       updateDrawToolbarVisibility();
       updateTopologyToolbarVisibility();
      });
      
      function applyLayerFilter() {  
       activeLayers.clear(); 
       if (document.getElementById("layer-physical").checked) activeLayers.add("physical");    
       if (document.getElementById("layer-logical").checked) activeLayers.add("logical");    
       if (document.getElementById("layer-security").checked) activeLayers.add("security");     
       if (document.getElementById("layer-application").checked) activeLayers.add("application");
       forgeTheTopology();    
      }
      
      function isNodeVisible(nodeId) {  
       const node = NODE_DATA[nodeId];    
       if (!node) return false;     
       const nodeLayer = node.layer || "physical";     
       return activeLayers.has(nodeLayer);     
      }
      
      function enterRack(rackId) {
      if (!NODE_DATA[rackId] || !NODE_DATA[rackId].isRack) return;
      const rackCapacity = getRackCapacity(rackId);
      const neededHeight = RACK_START_Y + (rackCapacity * RACK_U_HEIGHT) + 200;
      if (neededHeight > BASE_CANVAS_HEIGHT) {
      CANVAS_HEIGHT = neededHeight;
      }
       
       currentView.mode = "rack";
       currentView.rackId = rackId;
       
       const backBtn = document.getElementById("back-to-topology-btn");
       if (backBtn) backBtn.style.display = "inline-block";
       
       const hint = document.getElementById("canvas-hint");
       if (hint) {
        hint.textContent = `Viewing: ${NODE_DATA[rackId].name} | Double click empty space to exit`;
        hint.classList.add("visible");
       }
       
      
      const rackUHeight = getRackUHeight(rackId);
      const rackHeight = rackCapacity * rackUHeight;
      const rackCenterX = RACK_START_X;
      const rackCenterY = RACK_START_Y + (rackHeight / 2);
       
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       
       canvasState.panX = rackCenterX - (viewWidth / 2);
       canvasState.panY = rackCenterY - (viewHeight / 2);
       
       constrainPan();
       updateViewBox();
       
       forgeTheTopology();
      }
      
      function exitRack() {
      CANVAS_HEIGHT = BASE_CANVAS_HEIGHT;
      currentView.mode = "topology";
      currentView.rackId = null;
       
       const backBtn = document.getElementById("back-to-topology-btn");
       if (backBtn) backBtn.style.display = "none";
       
       const hint = document.getElementById("canvas-hint");
       if (hint) {
        hint.classList.remove("visible");
       }
       
       if (savedTopologyView) {
        canvasState.zoom = savedTopologyView.zoom;
        canvasState.panX = savedTopologyView.panX;
        canvasState.panY = savedTopologyView.panY;
        updateViewBox();
       }
       
       forgeTheTopology();
      }
      
      function getRackCapacity(rackId) {
       const node = NODE_DATA[rackId];
       return node && node.rackCapacity ? parseInt(node.rackCapacity) : 42;
      }
      
      function populateRackDropdown() {
       const dropdown = document.getElementById("node-assigned-rack");
       if (!dropdown) return;
       
       dropdown.innerHTML = '<option value="">None</option>';
       
       Object.keys(NODE_DATA).forEach(id => {
        if (NODE_DATA[id].isRack) {
         const option = document.createElement("option");
         option.value = id;
         option.textContent = NODE_DATA[id].name;
         dropdown.appendChild(option);
        }
       });
      }
      
      function wieldThePower() {
       const root = document.documentElement;
       root.style.setProperty("--panel", PAGE_STATE.panel);
       root.style.setProperty("--panel-alt", PAGE_STATE.panelAlt);
       root.style.setProperty("--sidebar-bg", PAGE_STATE.sidebarBg || PAGE_STATE.panelAlt);
       root.style.setProperty("--btn-bg", PAGE_STATE.btnBg || PAGE_STATE.panel);
       root.style.setProperty("--btn-text", PAGE_STATE.btnText || "#e2e8f0");
       root.style.setProperty("--tag-fill", PAGE_STATE.tagFill || "#1e293b");
       root.style.setProperty("--tag-text", PAGE_STATE.tagText || "#e2e8f0");
       root.style.setProperty("--tag-border", PAGE_STATE.tagBorder || "#475569");
       root.style.setProperty("--input-bg", PAGE_STATE.inputBg || "#0b0e13");
       root.style.setProperty("--input-text", PAGE_STATE.inputText || "#e2e8f0");
       root.style.setProperty("--input-border", PAGE_STATE.inputBorder || "#1f2937");
       root.style.setProperty("--input-font", PAGE_STATE.inputFont || "Inter, system-ui, sans-serif");
       root.style.setProperty("--input-font-size", (PAGE_STATE.inputFontSize || 14) + "px");
       root.style.setProperty("--toolbar-bg", PAGE_STATE.toolbarBg || "#0f172a");
       root.style.setProperty("--toolbar-border", PAGE_STATE.toolbarBorder || "#1f2937");
       root.style.setProperty("--toolbar-text", PAGE_STATE.toolbarText || "#94a3b8");
       root.style.setProperty("--toolbar-btn-bg", PAGE_STATE.toolbarBtnBg || "#0b0e13");
       root.style.setProperty("--toolbar-btn-text", PAGE_STATE.toolbarBtnText || "#e2e8f0");
       root.style.setProperty("--minimap-dots", PAGE_STATE.minimapDots || "#94a3b8");
       root.style.setProperty("--canvas-hint-bg", PAGE_STATE.canvasHintBg || "#0f172a");
       root.style.setProperty("--canvas-hint-color", PAGE_STATE.canvasHintColor || "#94a3b8");
       
       const canvasHint = document.getElementById("canvas-hint");
       if (canvasHint) {
        canvasHint.style.display = PAGE_STATE.canvasHintEnabled === false ? "none" : "";
        if (PAGE_STATE.canvasHintText !== undefined && PAGE_STATE.canvasHintText !== "") {
         canvasHint.innerHTML = PAGE_STATE.canvasHintText;
        } else {
         canvasHint.innerHTML = DEFAULT_CANVAS_HINT;
        }
       }
       root.style.setProperty("--accent", PAGE_STATE.accent);
       root.style.setProperty("--danger", PAGE_STATE.danger);
       root.style.setProperty("--text-main", PAGE_STATE.textMain);
       root.style.setProperty("--text-soft", PAGE_STATE.textSoft);
       root.style.setProperty("--topbar-bg", PAGE_STATE.topbarBg);
       root.style.setProperty("--topbar-border", PAGE_STATE.topbarBorder);
       root.style.setProperty("--node-fill", PAGE_STATE.nodeFill || "#1e293b");
       root.style.setProperty("--node-stroke", PAGE_STATE.nodeStroke || "#475569");
       root.style.setProperty("--node-title", PAGE_STATE.nodeTitle || "#e2e8f0");
       root.style.setProperty("--node-sub", PAGE_STATE.nodeSub || "#94a3b8");
       root.style.setProperty("--node-title-size", (PAGE_STATE.nodeTitleSize || 18) + "px");
       root.style.setProperty("--node-sub-size", (PAGE_STATE.nodeSubSize || 13) + "px");
       root.style.setProperty("--node-font", PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif");
       root.style.setProperty("--default-edge", PAGE_STATE.defaultEdge || "#475569");
       root.style.setProperty("--selection-handle", PAGE_STATE.selectionHandle || "#f59e0b");
       root.style.setProperty("--selection-handle-size", (PAGE_STATE.selectionHandleSize || 8) + "px");
       root.style.setProperty("--group-indicator", PAGE_STATE.groupIndicator || "#4fd1c5");
       const topbarHeight = PAGE_STATE.topbarHeight || 52;
       const sidebarWidth = PAGE_STATE.sidebarWidth || 350;
       const mobileFooterHeight = PAGE_STATE.mobileFooterHeight || 40;
       root.style.setProperty("--topbar-height", topbarHeight + "px");
       root.style.setProperty("--sidebar-width", sidebarWidth + "px");
       root.style.setProperty("--mobile-footer-height", mobileFooterHeight + "vh", );
       const mainEl = document.querySelector("main");
       const detailsPanel = document.getElementById("details-panel");
       const sidebarToggle = document.getElementById("sidebar-toggle");
       if (PAGE_STATE.sidebarCollapsed) {
        if (mainEl) mainEl.classList.add("sidebar-collapsed");
        if (detailsPanel) detailsPanel.classList.add("collapsed");
        if (sidebarToggle) {
         sidebarToggle.classList.add("collapsed");
         sidebarToggle.textContent = "▶";
        }
       } else {
        if (mainEl) mainEl.classList.remove("sidebar-collapsed");
        if (detailsPanel) detailsPanel.classList.remove("collapsed");
        if (sidebarToggle) {
         sidebarToggle.classList.remove("collapsed");
         sidebarToggle.textContent = "◀";
        }
       }
       if (PAGE_STATE.background) {
        document.body.style.background = PAGE_STATE.background;
       } else {
        document.body.style.background = `radial-gradient(circle at top, ${PAGE_STATE.canvasGradientTop || "#1e2532"} 0, ${PAGE_STATE.canvasGradientBottom || "#050608"} 70%)`;
       }
       document.title = PAGE_STATE.title || DEFAULT_PAGE_STATE.title;
       const titleEl = document.getElementById("page-title");
       if (titleEl) {
        titleEl.textContent = PAGE_STATE.title || DEFAULT_PAGE_STATE.title;
       }
       const viewOnlyMode = PAGE_STATE.viewOnly === true;
       const addNodeBtn = document.getElementById("add-node-btn");
       const addRackBtn = document.getElementById("add-rack-btn");
       const bulkToolbar = document.getElementById("bulk-toolbar");
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       
       if (viewOnlyMode) {
        if (addNodeBtn) addNodeBtn.style.display = "none";
        if (addRackBtn) addRackBtn.style.display = "none";
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        ["draw-toolbar-mini", "topology-toolbar-mini"].forEach(id => {
         const el = document.getElementById(id);
         if (el) el.style.display = "none";
        });
        document.body.classList.remove("view-only-inspect");
       } else {
        if (addNodeBtn) addNodeBtn.style.display = "";
        if (addRackBtn) addRackBtn.style.display = "";
       }
       
       document.body.classList.toggle("view-only-mode", viewOnlyMode);
       
       if (!viewOnlyMode) {
        if (typeof updateDrawToolbarVisibility === 'function') updateDrawToolbarVisibility();
        if (typeof updateTopologyToolbarVisibility === 'function') updateTopologyToolbarVisibility();
       }
      }
      (async function awakeTheImmortal() {
       let initialState = {};
       let decryptionCancelled = false;
       const stateEl = document.getElementById("topology-state");
       if (stateEl && stateEl.textContent.trim()) {
        try {
         let stateText = stateEl.textContent.trim();
         if (isEncrypted(stateText)) {
          let decrypted = false;
          let attempts = 0;
          const maxAttempts = 3;
          while (!decrypted && attempts < maxAttempts) {
           const password = prompt("This file is encrypted. Enter password to decrypt:\n(Attempt " + (attempts + 1) + " of " + maxAttempts + ")", );
           if (!password) {
            alert("Decryption cancelled. The file will not be loaded.", );
            decryptionCancelled = true;
            break;
           }
           try {
            stateText = await decryptData(stateText, password);
            decrypted = true;
           } catch (e) {
            attempts++;
            if (attempts < maxAttempts) {
             alert("Incorrect password. Please try again.");
            } else {
             alert("Maximum attempts reached. The file will not be loaded.", );
             decryptionCancelled = true;
            }
           }
          }
          if (!decrypted) {
           stateText = "{}";
          }
         }
         initialState = JSON.parse(stateText);
        } catch (e) {
         console.error("Failed to load state:", e);
         initialState = {};
        }
       }
       if (decryptionCancelled) {
        NODE_DATA = {};
        EDGE_DATA = {
         list: []
        };
        RECT_DATA = { list: [] };
        TEXT_DATA = { list: [] };
        EDGE_LEGEND = {};
        savedPositions = {};
        savedSizes = {};
        savedStyles = {};
       } else {
        NODE_DATA = initialState.nodeData ? initialState.nodeData : BASE_NODE_DATA;
        
        Object.keys(NODE_DATA).forEach(nodeId => {
         if (!NODE_DATA[nodeId].ping) {
          NODE_DATA[nodeId].ping = {
           enabled: false,
           protocol: 'http',
           customUrl: '',
           timeout: 3000,
           status: 'unknown',
           lastCheck: null
          };
         }
        });
        
        EDGE_DATA = initialState.edgeData ? initialState.edgeData : {
         list: [],
        };
        RECT_DATA = initialState.rectData ? initialState.rectData : { list: [] };
        TEXT_DATA = initialState.textData ? initialState.textData : { list: [] };
        EDGE_LEGEND = initialState.edgeLegend || {};
        savedPositions = initialState.nodePositions || {};
        savedSizes = initialState.nodeSizes || {};
        savedStyles = initialState.nodeStyles || {};
        if (initialState.iconCache) {
         IconLibrary.iconCache = initialState.iconCache;
        }
       }
       if (initialState.page) {
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, initialState.page, );
       }
       
       if (PAGE_STATE.autoPingEnabled !== undefined) {
        autoPingEnabled = PAGE_STATE.autoPingEnabled;
       }
       if (PAGE_STATE.autoPingInterval !== undefined) {
        autoPingInterval = PAGE_STATE.autoPingInterval;
       }
       
       if (initialState.canvas) {
        canvasState.zoom = initialState.canvas.zoom || 1;
        canvasState.panX = initialState.canvas.panX || 0;
        canvasState.panY = initialState.canvas.panY || 0;
       }
       
       if (initialState.savedTopologyView) {
        savedTopologyView = initialState.savedTopologyView;
       }
       
       if (initialState.documentTabs) {
        documentTabs = initialState.documentTabs;
        if (initialState.currentTabIndex !== undefined) {
          currentTabIndex = initialState.currentTabIndex;
          const currentTab = documentTabs[currentTabIndex];
          if (currentTab) {
            NODE_DATA = currentTab.nodes || NODE_DATA;
            EDGE_DATA = currentTab.edges || EDGE_DATA;
            savedPositions = currentTab.positions || savedPositions;
            savedSizes = currentTab.sizes || savedSizes;
            savedStyles = currentTab.styles || savedStyles;
            EDGE_LEGEND = currentTab.legend || EDGE_LEGEND;
            RECT_DATA = currentTab.rects || RECT_DATA;
            TEXT_DATA = currentTab.texts || TEXT_DATA;
            if (currentTab.pageState) PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, currentTab.pageState);
          }
        }
       }
       
       if (initialState.encryptedSections) {
        encryptedSections = initialState.encryptedSections;
       }
       
       wieldThePower();
       forgeTheTopology();
       updateViewBox();
       
       MobileManager.applyAll();
       
       if (autoPingEnabled) {
        startAutoPing();
       }
       
       const initialNodes = Object.keys(NODE_DATA);
       if (initialNodes.length > 0) {
        claimTheImmortal(initialNodes.includes("host") ? "host" : initialNodes[0], );
       } else {
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.display = "none";
       }
      })();
      
      let resizeDebounceTimer = null;
      window.addEventListener("resize", () => {
        clearTimeout(resizeDebounceTimer);
        resizeDebounceTimer = setTimeout(() => {
          MobileManager.applyAll();
          if (typeof updateDrawToolbarVisibility === 'function') updateDrawToolbarVisibility();
          if (typeof updateTopologyToolbarVisibility === 'function') updateTopologyToolbarVisibility();
        }, 100);
      });
      
      function getBreakpointKey() {
       const w = window.innerWidth;
       if (w <= 380) return "fold";
       if (w <= 768) return "mobile";
       if (w <= 1024) return "tablet";
       return "desktop";
      }
      
      function resolveStylesEntry(styleEntry) {
       if (!styleEntry) return {};
       if (styleEntry.circleColor || styleEntry.titleColor || styleEntry.titleFont || styleEntry.titleSize || styleEntry.subColor || styleEntry.subFont || styleEntry.subSize) {
        return styleEntry;
       }
       const bp = getBreakpointKey();
       const base = styleEntry.all || {};
       const bpStyles = styleEntry[bp] || {};
       return Object.assign({}, base, bpStyles);
      }
      
      function resolveStylesForNode(id) {
       const styleEntry = savedStyles[id];
       if (!styleEntry) return {};
       return resolveStylesEntry(styleEntry);
      }
      
      function ensureStyleEntry(id) {
       if (!savedStyles[id]) savedStyles[id] = {};
       const entry = savedStyles[id];
       const flatProps = ["circleColor", "circleBorder", "titleColor", "titleFont", "titleSize", "subColor", "subFont", "subSize", ];
       const isFlat = flatProps.some((p) => Object.prototype.hasOwnProperty.call(entry, p), );
       if (isFlat) {
        const all = entry.all || {};
        flatProps.forEach((p) => {
         if (entry[p] !== undefined) {
          all[p] = entry[p];
          delete entry[p];
         }
        });
        entry.all = all;
       }
       return entry;
      }
      
      function getDefaultSize() {
       if (window.innerWidth <= 380) return 120;
       if (window.innerWidth <= 768) return 140;
       if (window.innerWidth <= 1024) return 70;
       return 55;
      }
      
      function createShapeElement(shape, size) {
       const ns = "http://www.w3.org/2000/svg";
       if (shape === "circle") {
        const c = document.createElementNS(ns, "circle");
        c.setAttribute("r", size);
        return c;
       }
       if (shape === "square") {
        const r = document.createElementNS(ns, "rect");
        const s = size * 2;
        r.setAttribute("x", -size);
        r.setAttribute("y", -size);
        r.setAttribute("width", s);
        r.setAttribute("height", s);
        r.setAttribute("rx", 4);
        return r;
       }
       if (shape === "rectangle") {
        const r = document.createElementNS(ns, "rect");
        r.setAttribute("x", -size * 1.4);
        r.setAttribute("y", -size * 0.8);
        r.setAttribute("width", size * 2.8);
        r.setAttribute("height", size * 1.6);
        r.setAttribute("rx", 6);
        return r;
       }
       if (shape === "triangle") {
        const p = document.createElementNS(ns, "polygon");
        const h = size * 1.8;
        const w = size * 2;
        p.setAttribute("points", `0,${-h} ${w / 2},${h / 2} ${-w / 2},${h / 2}`, );
        return p;
       }
       if (shape === "hexagon") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        const pts = [
         [0, -s],
         [s * 0.86, -s * 0.5],
         [s * 0.86, s * 0.5],
         [0, s],
         [-s * 0.86, s * 0.5],
         [-s * 0.86, -s * 0.5],
        ].map((pt) => pt.join(",")).join(" ");
        p.setAttribute("points", pts);
        return p;
       }
       if (shape === "stop-sign") {
        const p = document.createElementNS(ns, "polygon");
        const r = size;
        const ptsArr = [];
        for (let i = 0; i < 8; i++) {
         const a = (Math.PI / 4) * i + Math.PI / 8;
         ptsArr.push([Math.cos(a) * r, Math.sin(a) * r]);
        }
        const pts = ptsArr.map((pt) => pt.join(",")).join(" ");
        p.setAttribute("points", pts);
        return p;
       }
       if (shape === "star") {
        const p = document.createElementNS(ns, "polygon");
        const outer = size;
        const inner = size * 0.45;
        let pts = "";
        for (let i = 0; i < 10; i++) {
         const a = (Math.PI / 5) * i - Math.PI / 2;
         const r = i % 2 === 0 ? outer : inner;
         pts += `${Math.cos(a) * r},${Math.sin(a) * r} `;
        }
        p.setAttribute("points", pts.trim());
        return p;
       }
       if (shape === "diamond") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `0,${-s} ${s},0 0,${s} ${-s},0`);
        return p;
       }
       if (shape === "server") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.2);
        body.setAttribute("y", -size * 0.6);
        body.setAttribute("width", size * 2.4);
        body.setAttribute("height", size * 1.2);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 3; i++) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", -size * 0.9 + i * size * 0.5);
         line.setAttribute("y1", -size * 0.3);
         line.setAttribute("x2", -size * 0.9 + i * size * 0.5);
         line.setAttribute("y2", size * 0.3);
         line.style.stroke = "currentColor";
         line.style.strokeWidth = "2";
         line.style.opacity = "0.5";
         g.appendChild(line);
        }
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", size * 0.9);
        led.setAttribute("cy", 0);
        led.setAttribute("r", size * 0.1);
        led.style.fill = "#4ade80";
        g.appendChild(led);
        return g;
       }
       if (shape === "pc" || shape === "desktop") {
        const g = document.createElementNS(ns, "g");
        const monitor = document.createElementNS(ns, "rect");
        monitor.setAttribute("x", -size * 0.9);
        monitor.setAttribute("y", -size * 0.8);
        monitor.setAttribute("width", size * 1.8);
        monitor.setAttribute("height", size * 1.2);
        monitor.setAttribute("rx", 4);
        g.appendChild(monitor);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.75);
        screen.setAttribute("y", -size * 0.65);
        screen.setAttribute("width", size * 1.5);
        screen.setAttribute("height", size * 0.9);
        screen.setAttribute("rx", 2);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        const neck = document.createElementNS(ns, "rect");
        neck.setAttribute("x", -size * 0.15);
        neck.setAttribute("y", size * 0.4);
        neck.setAttribute("width", size * 0.3);
        neck.setAttribute("height", size * 0.3);
        g.appendChild(neck);
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.5);
        base.setAttribute("y", size * 0.7);
        base.setAttribute("width", size * 1);
        base.setAttribute("height", size * 0.15);
        base.setAttribute("rx", 2);
        g.appendChild(base);
        return g;
       }
       if (shape === "laptop") {
        const g = document.createElementNS(ns, "g");
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.8);
        screen.setAttribute("y", -size * 0.9);
        screen.setAttribute("width", size * 1.6);
        screen.setAttribute("height", size * 1.1);
        screen.setAttribute("rx", 4);
        g.appendChild(screen);
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.9);
        base.setAttribute("y", size * 0.25);
        base.setAttribute("width", size * 1.8);
        base.setAttribute("height", size * 0.6);
        base.setAttribute("rx", 4);
        g.appendChild(base);
        const pad = document.createElementNS(ns, "rect");
        pad.setAttribute("x", -size * 0.25);
        pad.setAttribute("y", size * 0.45);
        pad.setAttribute("width", size * 0.5);
        pad.setAttribute("height", size * 0.25);
        pad.setAttribute("rx", 2);
        pad.style.fill = "#1e293b";
        g.appendChild(pad);
        return g;
       }
       if (shape === "phone" || shape === "mobile") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.45);
        body.setAttribute("y", -size);
        body.setAttribute("width", size * 0.9);
        body.setAttribute("height", size * 2);
        body.setAttribute("rx", 8);
        g.appendChild(body);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.38);
        screen.setAttribute("y", -size * 0.85);
        screen.setAttribute("width", size * 0.76);
        screen.setAttribute("height", size * 1.6);
        screen.setAttribute("rx", 4);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        const btn = document.createElementNS(ns, "rect");
        btn.setAttribute("x", -size * 0.15);
        btn.setAttribute("y", size * 0.82);
        btn.setAttribute("width", size * 0.3);
        btn.setAttribute("height", size * 0.06);
        btn.setAttribute("rx", 2);
        btn.style.fill = "#475569";
        g.appendChild(btn);
        return g;
       }
       if (shape === "router") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.1);
        body.setAttribute("y", -size * 0.3);
        body.setAttribute("width", size * 2.2);
        body.setAttribute("height", size * 0.8);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        for (let i = -1; i <= 1; i++) {
         const ant = document.createElementNS(ns, "rect");
         ant.setAttribute("x", i * size * 0.6 - size * 0.05);
         ant.setAttribute("y", -size * 0.9);
         ant.setAttribute("width", size * 0.1);
         ant.setAttribute("height", size * 0.6);
         ant.setAttribute("rx", 2);
         g.appendChild(ant);
         const tip = document.createElementNS(ns, "circle");
         tip.setAttribute("cx", i * size * 0.6);
         tip.setAttribute("cy", -size * 0.95);
         tip.setAttribute("r", size * 0.08);
         g.appendChild(tip);
        }
        for (let i = 0; i < 4; i++) {
         const led = document.createElementNS(ns, "circle");
         led.setAttribute("cx", -size * 0.7 + i * size * 0.35);
         led.setAttribute("cy", size * 0.1);
         led.setAttribute("r", size * 0.06);
         led.style.fill = i < 2 ? "#4ade80" : "#facc15";
         g.appendChild(led);
        }
        return g;
       }
       if (shape === "switch") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.4);
        body.setAttribute("y", -size * 0.4);
        body.setAttribute("width", size * 2.8);
        body.setAttribute("height", size * 0.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 8; i++) {
         const port = document.createElementNS(ns, "rect");
         port.setAttribute("x", -size * 1.2 + i * size * 0.32);
         port.setAttribute("y", -size * 0.15);
         port.setAttribute("width", size * 0.22);
         port.setAttribute("height", size * 0.3);
         port.setAttribute("rx", 1);
         port.style.fill = "#1e293b";
         g.appendChild(port);
        }
        return g;
       }
       if (shape === "firewall") {
        const g = document.createElementNS(ns, "g");
        const wall = document.createElementNS(ns, "rect");
        wall.setAttribute("x", -size);
        wall.setAttribute("y", -size * 0.8);
        wall.setAttribute("width", size * 2);
        wall.setAttribute("height", size * 1.6);
        wall.setAttribute("rx", 4);
        g.appendChild(wall);
        for (let row = 0; row < 3; row++) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", -size * 0.85);
         line.setAttribute("y1", -size * 0.5 + row * size * 0.45);
         line.setAttribute("x2", size * 0.85);
         line.setAttribute("y2", -size * 0.5 + row * size * 0.45);
         line.style.stroke = "#475569";
         line.style.strokeWidth = "2";
         g.appendChild(line);
        }
        for (let row = 0; row < 4; row++) {
         const offset = row % 2 === 0 ? 0 : size * 0.35;
         for (let col = 0; col < 3; col++) {
          const line = document.createElementNS(ns, "line");
          const x = -size * 0.5 + col * size * 0.7 + offset;
          if (x > -size * 0.85 && x < size * 0.85) {
           line.setAttribute("x1", x);
           line.setAttribute("y1", -size * 0.8 + row * size * 0.45, );
           line.setAttribute("x2", x);
           line.setAttribute("y2", -size * 0.8 + row * size * 0.45 + size * 0.45, );
           line.style.stroke = "#475569";
           line.style.strokeWidth = "2";
           g.appendChild(line);
          }
         }
        }
        return g;
       }
       if (shape === "cloud") {
        const p = document.createElementNS(ns, "path");
        const s = size;
        p.setAttribute("d", `
             M ${-s * 0.8} ${s * 0.2}
             Q ${-s * 1.1} ${s * 0.2} ${-s * 1.1} ${-s * 0.1}
             Q ${-s * 1.1} ${-s * 0.5} ${-s * 0.7} ${-s * 0.5}
             Q ${-s * 0.7} ${-s * 0.9} ${-s * 0.2} ${-s * 0.9}
             Q ${s * 0.1} ${-s * 1.1} ${s * 0.5} ${-s * 0.8}
             Q ${s * 1} ${-s * 0.8} ${s * 1.1} ${-s * 0.3}
             Q ${s * 1.3} ${-s * 0.1} ${s * 1.1} ${s * 0.2}
             Q ${s * 1.1} ${s * 0.5} ${s * 0.7} ${s * 0.5}
             L ${-s * 0.5} ${s * 0.5}
             Q ${-s * 0.9} ${s * 0.5} ${-s * 0.9} ${s * 0.2}
             Z
            `, );
        return p;
       }
       if (shape === "database") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.7);
        body.setAttribute("y", -size * 0.6);
        body.setAttribute("width", size * 1.4);
        body.setAttribute("height", size * 1.4);
        g.appendChild(body);
        const top = document.createElementNS(ns, "ellipse");
        top.setAttribute("cx", 0);
        top.setAttribute("cy", -size * 0.6);
        top.setAttribute("rx", size * 0.7);
        top.setAttribute("ry", size * 0.25);
        g.appendChild(top);
        const bottom = document.createElementNS(ns, "ellipse");
        bottom.setAttribute("cx", 0);
        bottom.setAttribute("cy", size * 0.8);
        bottom.setAttribute("rx", size * 0.7);
        bottom.setAttribute("ry", size * 0.25);
        g.appendChild(bottom);
        const mid1 = document.createElementNS(ns, "ellipse");
        mid1.setAttribute("cx", 0);
        mid1.setAttribute("cy", -size * 0.15);
        mid1.setAttribute("rx", size * 0.7);
        mid1.setAttribute("ry", size * 0.2);
        mid1.style.fill = "none";
        mid1.style.stroke = "#475569";
        mid1.style.strokeWidth = "2";
        g.appendChild(mid1);
        const mid2 = document.createElementNS(ns, "ellipse");
        mid2.setAttribute("cx", 0);
        mid2.setAttribute("cy", size * 0.35);
        mid2.setAttribute("rx", size * 0.7);
        mid2.setAttribute("ry", size * 0.2);
        mid2.style.fill = "none";
        mid2.style.stroke = "#475569";
        mid2.style.strokeWidth = "2";
        g.appendChild(mid2);
        return g;
       }
       if (shape === "printer") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.4);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size * 0.9);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const trayTop = document.createElementNS(ns, "rect");
        trayTop.setAttribute("x", -size * 0.7);
        trayTop.setAttribute("y", -size * 0.8);
        trayTop.setAttribute("width", size * 1.4);
        trayTop.setAttribute("height", size * 0.4);
        trayTop.setAttribute("rx", 2);
        trayTop.style.fill = "#1e293b";
        g.appendChild(trayTop);
        const trayOut = document.createElementNS(ns, "rect");
        trayOut.setAttribute("x", -size * 0.6);
        trayOut.setAttribute("y", size * 0.5);
        trayOut.setAttribute("width", size * 1.2);
        trayOut.setAttribute("height", size * 0.35);
        trayOut.setAttribute("rx", 2);
        g.appendChild(trayOut);
        const paper = document.createElementNS(ns, "rect");
        paper.setAttribute("x", -size * 0.5);
        paper.setAttribute("y", size * 0.3);
        paper.setAttribute("width", size * 1);
        paper.setAttribute("height", size * 0.5);
        paper.style.fill = "#e2e8f0";
        g.appendChild(paper);
        return g;
       }
       if (shape === "access-point" || shape === "wifi") {
        const g = document.createElementNS(ns, "g");
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.3);
        base.setAttribute("y", size * 0.2);
        base.setAttribute("width", size * 0.6);
        base.setAttribute("height", size * 0.3);
        base.setAttribute("rx", 3);
        g.appendChild(base);
        for (let i = 1; i <= 3; i++) {
         const arc = document.createElementNS(ns, "path");
         const r = size * 0.3 * i;
         arc.setAttribute("d", `M ${-r * 0.7} ${size * 0.1 - r * 0.5} A ${r} ${r} 0 0 1 ${r * 0.7} ${size * 0.1 - r * 0.5}`);
         arc.style.fill = "none";
         arc.style.stroke = "currentColor";
         arc.style.strokeWidth = "2";
         arc.style.opacity = 1 - (i * 0.2);
         g.appendChild(arc);
        }
        return g;
       }
       if (shape === "load-balancer") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.5);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        const bar = document.createElementNS(ns, "line");
        bar.setAttribute("x1", -size * 0.6);
        bar.setAttribute("y1", 0);
        bar.setAttribute("x2", size * 0.6);
        bar.setAttribute("y2", 0);
        bar.style.stroke = "#4ade80";
        bar.style.strokeWidth = "3";
        g.appendChild(bar);
        [-1, 1].forEach(dir => {
         const arrow = document.createElementNS(ns, "path");
         arrow.setAttribute("d", `M ${dir * size * 0.3} ${-size * 0.2} L ${dir * size * 0.6} 0 L ${dir * size * 0.3} ${size * 0.2}`);
         arrow.style.fill = "none";
         arrow.style.stroke = "#4ade80";
         arrow.style.strokeWidth = "2";
         g.appendChild(arrow);
        });
        return g;
       }
       if (shape === "nas" || shape === "storage") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.8);
        body.setAttribute("y", -size * 0.9);
        body.setAttribute("width", size * 1.6);
        body.setAttribute("height", size * 1.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 4; i++) {
         const bay = document.createElementNS(ns, "rect");
         bay.setAttribute("x", -size * 0.6);
         bay.setAttribute("y", -size * 0.7 + i * size * 0.4);
         bay.setAttribute("width", size * 1.2);
         bay.setAttribute("height", size * 0.3);
         bay.setAttribute("rx", 2);
         bay.style.fill = "#1e293b";
         g.appendChild(bay);
        }
        return g;
       }
       if (shape === "gateway" || shape === "modem") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.5);
        body.setAttribute("y", -size * 0.9);
        body.setAttribute("width", size);
        body.setAttribute("height", size * 1.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 4; i++) {
         const led = document.createElementNS(ns, "circle");
         led.setAttribute("cx", 0);
         led.setAttribute("cy", -size * 0.6 + i * size * 0.35);
         led.setAttribute("r", size * 0.08);
         led.style.fill = ["#4ade80", "#4ade80", "#facc15", "#60a5fa"][i];
         g.appendChild(led);
        }
        return g;
       }
       if (shape === "vpn" || shape === "tunnel") {
        const g = document.createElementNS(ns, "g");
        const outer = document.createElementNS(ns, "ellipse");
        outer.setAttribute("cx", 0);
        outer.setAttribute("cy", 0);
        outer.setAttribute("rx", size);
        outer.setAttribute("ry", size * 0.6);
        g.appendChild(outer);
        const inner = document.createElementNS(ns, "ellipse");
        inner.setAttribute("cx", 0);
        inner.setAttribute("cy", 0);
        inner.setAttribute("rx", size * 0.5);
        inner.setAttribute("ry", size * 0.3);
        inner.style.fill = "#1e293b";
        g.appendChild(inner);
        const lock = document.createElementNS(ns, "rect");
        lock.setAttribute("x", -size * 0.15);
        lock.setAttribute("y", -size * 0.1);
        lock.setAttribute("width", size * 0.3);
        lock.setAttribute("height", size * 0.25);
        lock.setAttribute("rx", 2);
        lock.style.fill = "#4ade80";
        g.appendChild(lock);
        return g;
       }
       
       if (shape === "container") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.5);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 3; i++) {
         const block = document.createElementNS(ns, "rect");
         block.setAttribute("x", -size * 0.8 + i * size * 0.55);
         block.setAttribute("y", -size * 0.3);
         block.setAttribute("width", size * 0.45);
         block.setAttribute("height", size * 0.6);
         block.setAttribute("rx", 2);
         block.style.fill = "#1e293b";
         g.appendChild(block);
        }
        return g;
       }
       if (shape === "vm" || shape === "virtual") {
        const g = document.createElementNS(ns, "g");
        const shadow = document.createElementNS(ns, "rect");
        shadow.setAttribute("x", -size * 0.85 + 4);
        shadow.setAttribute("y", -size * 0.65 + 4);
        shadow.setAttribute("width", size * 1.7);
        shadow.setAttribute("height", size * 1.3);
        shadow.setAttribute("rx", 4);
        shadow.style.opacity = "0.3";
        g.appendChild(shadow);
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.85);
        body.setAttribute("y", -size * 0.65);
        body.setAttribute("width", size * 1.7);
        body.setAttribute("height", size * 1.3);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.65);
        screen.setAttribute("y", -size * 0.45);
        screen.setAttribute("width", size * 1.3);
        screen.setAttribute("height", size * 0.7);
        screen.setAttribute("rx", 2);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        return g;
       }
       if (shape === "kubernetes" || shape === "k8s") {
        const g = document.createElementNS(ns, "g");
        const outer = document.createElementNS(ns, "circle");
        outer.setAttribute("cx", 0);
        outer.setAttribute("cy", 0);
        outer.setAttribute("r", size);
        g.appendChild(outer);
        const inner = document.createElementNS(ns, "circle");
        inner.setAttribute("cx", 0);
        inner.setAttribute("cy", 0);
        inner.setAttribute("r", size * 0.4);
        inner.style.fill = "#1e293b";
        g.appendChild(inner);
        for (let i = 0; i < 7; i++) {
         const angle = (Math.PI * 2 / 7) * i - Math.PI / 2;
         const spoke = document.createElementNS(ns, "line");
         spoke.setAttribute("x1", Math.cos(angle) * size * 0.4);
         spoke.setAttribute("y1", Math.sin(angle) * size * 0.4);
         spoke.setAttribute("x2", Math.cos(angle) * size * 0.85);
         spoke.setAttribute("y2", Math.sin(angle) * size * 0.85);
         spoke.style.stroke = "#326ce5";
         spoke.style.strokeWidth = "3";
         g.appendChild(spoke);
        }
        return g;
       }
       if (shape === "shield" || shape === "security") {
        const p = document.createElementNS(ns, "path");
        const s = size;
        p.setAttribute("d", `M 0 ${-s} L ${s * 0.85} ${-s * 0.5} L ${s * 0.85} ${s * 0.2} Q ${s * 0.7} ${s * 0.9} 0 ${s} Q ${-s * 0.7} ${s * 0.9} ${-s * 0.85} ${s * 0.2} L ${-s * 0.85} ${-s * 0.5} Z`);
        return p;
       }
       if (shape === "camera" || shape === "cctv") {
        const g = document.createElementNS(ns, "g");
        const mount = document.createElementNS(ns, "rect");
        mount.setAttribute("x", -size * 1.1);
        mount.setAttribute("y", -size * 0.5);
        mount.setAttribute("width", size * 0.25);
        mount.setAttribute("height", size * 0.6);
        mount.setAttribute("rx", 2);
        g.appendChild(mount);
        const arm = document.createElementNS(ns, "rect");
        arm.setAttribute("x", -size * 0.9);
        arm.setAttribute("y", -size * 0.15);
        arm.setAttribute("width", size * 0.5);
        arm.setAttribute("height", size * 0.15);
        g.appendChild(arm);
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.45);
        body.setAttribute("y", -size * 0.35);
        body.setAttribute("width", size * 1.1);
        body.setAttribute("height", size * 0.7);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const lensHousing = document.createElementNS(ns, "circle");
        lensHousing.setAttribute("cx", size * 0.85);
        lensHousing.setAttribute("cy", 0);
        lensHousing.setAttribute("r", size * 0.4);
        g.appendChild(lensHousing);
        const lensOuter = document.createElementNS(ns, "circle");
        lensOuter.setAttribute("cx", size * 0.85);
        lensOuter.setAttribute("cy", 0);
        lensOuter.setAttribute("r", size * 0.28);
        lensOuter.style.fill = "#1e293b";
        g.appendChild(lensOuter);
        const lensInner = document.createElementNS(ns, "circle");
        lensInner.setAttribute("cx", size * 0.85);
        lensInner.setAttribute("cy", 0);
        lensInner.setAttribute("r", size * 0.15);
        lensInner.style.fill = "#3b82f6";
        g.appendChild(lensInner);
        const reflection = document.createElementNS(ns, "circle");
        reflection.setAttribute("cx", size * 0.8);
        reflection.setAttribute("cy", -size * 0.05);
        reflection.setAttribute("r", size * 0.05);
        reflection.style.fill = "#93c5fd";
        g.appendChild(reflection);
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", -size * 0.2);
        led.setAttribute("cy", -size * 0.15);
        led.setAttribute("r", size * 0.06);
        led.style.fill = "#ef4444";
        g.appendChild(led);
        return g;
       }
       if (shape === "monitor" || shape === "dashboard") {
        const g = document.createElementNS(ns, "g");
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size);
        screen.setAttribute("y", -size * 0.7);
        screen.setAttribute("width", size * 2);
        screen.setAttribute("height", size * 1.2);
        screen.setAttribute("rx", 4);
        g.appendChild(screen);
        const graph = document.createElementNS(ns, "polyline");
        graph.setAttribute("points", `${-size * 0.8},${size * 0.2} ${-size * 0.3},${-size * 0.2} ${size * 0.2},${size * 0.1} ${size * 0.7},${-size * 0.3}`);
        graph.style.fill = "none";
        graph.style.stroke = "#4ade80";
        graph.style.strokeWidth = "3";
        g.appendChild(graph);
        return g;
       }
       if (shape === "docker" || shape === "whale") {
        const g = document.createElementNS(ns, "g");
        const s = size;
        const body = document.createElementNS(ns, "path");
        body.setAttribute("d", `
         M ${-s * 0.9} ${s * 0.2}
         Q ${-s * 1.1} ${s * 0.5} ${-s * 0.7} ${s * 0.7}
         Q ${-s * 0.3} ${s * 0.85} ${s * 0.3} ${s * 0.75}
         Q ${s * 0.8} ${s * 0.6} ${s * 1.0} ${s * 0.3}
         Q ${s * 1.1} ${s * 0.1} ${s * 1.0} ${-s * 0.1}
         L ${s * 0.85} ${-s * 0.1}
         Q ${s * 0.7} ${-s * 0.15} ${s * 0.4} ${-s * 0.2}
         L ${-s * 0.5} ${-s * 0.2}
         Q ${-s * 0.8} ${-s * 0.1} ${-s * 0.9} ${s * 0.2}
         Z
        `);
        body.style.fill = "#0db7ed";
        g.appendChild(body);
        const tail = document.createElementNS(ns, "path");
        tail.setAttribute("d", `
         M ${-s * 0.85} ${s * 0.1}
         Q ${-s * 1.2} ${-s * 0.2} ${-s * 1.0} ${-s * 0.55}
         Q ${-s * 0.95} ${-s * 0.35} ${-s * 0.8} ${-s * 0.15}
         Z
        `);
        tail.style.fill = "#0db7ed";
        g.appendChild(tail);
        const belly = document.createElementNS(ns, "path");
        belly.setAttribute("d", `
         M ${-s * 0.5} ${s * 0.65}
         Q ${s * 0.1} ${s * 0.75} ${s * 0.6} ${s * 0.55}
         Q ${s * 0.8} ${s * 0.45} ${s * 0.9} ${s * 0.25}
         Q ${s * 0.7} ${s * 0.5} ${s * 0.3} ${s * 0.6}
         Q ${-s * 0.1} ${s * 0.7} ${-s * 0.5} ${s * 0.65}
         Z
        `);
        belly.style.fill = "#ffffff";
        belly.style.opacity = "0.3";
        g.appendChild(belly);
        for (let row = 0; row < 2; row++) {
         for (let col = 0; col < 3; col++) {
          const container = document.createElementNS(ns, "rect");
          container.setAttribute("x", -s * 0.45 + col * s * 0.35);
          container.setAttribute("y", -s * 0.7 + row * s * 0.28);
          container.setAttribute("width", s * 0.3);
          container.setAttribute("height", s * 0.23);
          container.setAttribute("rx", 2);
          container.style.fill = "#0db7ed";
          container.style.stroke = "#0a9ed8";
          container.style.strokeWidth = "1.5";
          g.appendChild(container);
         }
        }
        const topContainer = document.createElementNS(ns, "rect");
        topContainer.setAttribute("x", -s * 0.1);
        topContainer.setAttribute("y", -s * 0.95);
        topContainer.setAttribute("width", s * 0.3);
        topContainer.setAttribute("height", s * 0.23);
        topContainer.setAttribute("rx", 2);
        topContainer.style.fill = "#0db7ed";
        topContainer.style.stroke = "#0a9ed8";
        topContainer.style.strokeWidth = "1.5";
        g.appendChild(topContainer);
        const eye = document.createElementNS(ns, "circle");
        eye.setAttribute("cx", s * 0.65);
        eye.setAttribute("cy", s * 0.25);
        eye.setAttribute("r", s * 0.08);
        eye.style.fill = "#0a5f7a";
        g.appendChild(eye);
        
        return g;
       }
       if (shape === "rounded-square") {
        const r = document.createElementNS(ns, "rect");
        const s = size * 1.6;
        r.setAttribute("x", -s / 2);
        r.setAttribute("y", -s / 2);
        r.setAttribute("width", s);
        r.setAttribute("height", s);
        r.setAttribute("rx", size * 0.4);
        return r;
       }
       if (shape === "pill" || shape === "capsule") {
        const r = document.createElementNS(ns, "rect");
        r.setAttribute("x", -size * 1.2);
        r.setAttribute("y", -size * 0.5);
        r.setAttribute("width", size * 2.4);
        r.setAttribute("height", size);
        r.setAttribute("rx", size * 0.5);
        return r;
       }
       if (shape === "octagon") {
        const p = document.createElementNS(ns, "polygon");
        const r = size;
        const pts = [];
        for (let i = 0; i < 8; i++) {
         const a = (Math.PI / 4) * i - Math.PI / 8;
         pts.push([Math.cos(a) * r, Math.sin(a) * r]);
        }
        p.setAttribute("points", pts.map(pt => pt.join(",")).join(" "));
        return p;
       }
       if (shape === "pentagon") {
        const p = document.createElementNS(ns, "polygon");
        const pts = [];
        for (let i = 0; i < 5; i++) {
         const a = (Math.PI * 2 / 5) * i - Math.PI / 2;
         pts.push([Math.cos(a) * size, Math.sin(a) * size]);
        }
        p.setAttribute("points", pts.map(pt => pt.join(",")).join(" "));
        return p;
       }
       if (shape === "cross" || shape === "plus") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        const t = size * 0.35;
        p.setAttribute("points", `${-t},${-s} ${t},${-s} ${t},${-t} ${s},${-t} ${s},${t} ${t},${t} ${t},${s} ${-t},${s} ${-t},${t} ${-s},${t} ${-s},${-t} ${-t},${-t}`);
        return p;
       }
       if (shape === "parallelogram") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `${-s * 0.6},${-s * 0.6} ${s * 1.2},${-s * 0.6} ${s * 0.6},${s * 0.6} ${-s * 1.2},${s * 0.6}`);
        return p;
       }
       if (shape === "trapezoid") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `${-s * 0.6},${-s * 0.6} ${s * 0.6},${-s * 0.6} ${s},${s * 0.6} ${-s},${s * 0.6}`);
        return p;
       }
       if (shape === "sensor" || shape === "iot") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "circle");
        body.setAttribute("cx", 0);
        body.setAttribute("cy", 0);
        body.setAttribute("r", size * 0.7);
        g.appendChild(body);
        const ant = document.createElementNS(ns, "line");
        ant.setAttribute("x1", 0);
        ant.setAttribute("y1", -size * 0.7);
        ant.setAttribute("x2", 0);
        ant.setAttribute("y2", -size);
        ant.style.stroke = "currentColor";
        ant.style.strokeWidth = "2";
        g.appendChild(ant);
        const tip = document.createElementNS(ns, "circle");
        tip.setAttribute("cx", 0);
        tip.setAttribute("cy", -size);
        tip.setAttribute("r", size * 0.1);
        tip.style.fill = "#4ade80";
        g.appendChild(tip);
        return g;
       }
       if (shape === "pi" || shape === "sbc" || shape === "raspberry") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.65);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size * 1.3);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 10; i++) {
         const pin = document.createElementNS(ns, "rect");
         pin.setAttribute("x", -size * 0.85 + i * size * 0.19);
         pin.setAttribute("y", -size * 0.8);
         pin.setAttribute("width", size * 0.08);
         pin.setAttribute("height", size * 0.15);
         pin.style.fill = "#facc15";
         g.appendChild(pin);
        }
        const port = document.createElementNS(ns, "rect");
        port.setAttribute("x", size * 0.6);
        port.setAttribute("y", -size * 0.2);
        port.setAttribute("width", size * 0.35);
        port.setAttribute("height", size * 0.4);
        port.style.fill = "#1e293b";
        g.appendChild(port);
        return g;
       }
       if (shape === "api" || shape === "endpoint") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.9);
        body.setAttribute("y", -size * 0.7);
        body.setAttribute("width", size * 1.8);
        body.setAttribute("height", size * 1.4);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        const left = document.createElementNS(ns, "text");
        left.setAttribute("x", -size * 0.5);
        left.setAttribute("y", size * 0.15);
        left.setAttribute("font-size", size * 0.9);
        left.setAttribute("fill", "#4ade80");
        left.setAttribute("font-family", "monospace");
        left.textContent = "{";
        g.appendChild(left);
        const right = document.createElementNS(ns, "text");
        right.setAttribute("x", size * 0.15);
        right.setAttribute("y", size * 0.15);
        right.setAttribute("font-size", size * 0.9);
        right.setAttribute("fill", "#4ade80");
        right.setAttribute("font-family", "monospace");
        right.textContent = "}";
        g.appendChild(right);
        return g;
       }
       if (shape === "queue" || shape === "message") {
        const g = document.createElementNS(ns, "g");
        for (let i = 2; i >= 0; i--) {
         const card = document.createElementNS(ns, "rect");
         card.setAttribute("x", -size * 0.7 + i * 4);
         card.setAttribute("y", -size * 0.5 + i * 4);
         card.setAttribute("width", size * 1.4);
         card.setAttribute("height", size * 0.8);
         card.setAttribute("rx", 3);
         card.style.opacity = 1 - i * 0.25;
         g.appendChild(card);
        }
        return g;
       }
       if (shape === "lambda" || shape === "function") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.8);
        body.setAttribute("y", -size * 0.8);
        body.setAttribute("width", size * 1.6);
        body.setAttribute("height", size * 1.6);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const lambda = document.createElementNS(ns, "text");
        lambda.setAttribute("x", 0);
        lambda.setAttribute("y", size * 0.2);
        lambda.setAttribute("font-size", size * 1.2);
        lambda.setAttribute("fill", "#f59e0b");
        lambda.setAttribute("text-anchor", "middle");
        lambda.setAttribute("font-family", "serif");
        lambda.textContent = "λ";
        g.appendChild(lambda);
        return g;
       }
       if (shape === "bucket" || shape === "s3") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "path");
        body.setAttribute("d", `M ${-size * 0.8} ${-size * 0.7} L ${-size * 0.6} ${size * 0.8} Q ${-size * 0.5} ${size} 0 ${size} Q ${size * 0.5} ${size} ${size * 0.6} ${size * 0.8} L ${size * 0.8} ${-size * 0.7} Z`);
        g.appendChild(body);
        const rim = document.createElementNS(ns, "ellipse");
        rim.setAttribute("cx", 0);
        rim.setAttribute("cy", -size * 0.7);
        rim.setAttribute("rx", size * 0.8);
        rim.setAttribute("ry", size * 0.25);
        g.appendChild(rim);
        return g;
       }
       const c = document.createElementNS(ns, "circle");
       c.setAttribute("r", size);
       return c;
      }
      
      function createNodeShape(id, size) {
       const styles = resolveStylesForNode(id);
       if (styles.icon && styles.icon.library && styles.icon.name) {
        const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
        g.classList.add("node-circle");
        IconLibrary.getIcon(styles.icon.library, styles.icon.name).then(svgText => {
         if (svgText) {
          const parser = new DOMParser();
          const doc = parser.parseFromString(svgText, 'image/svg+xml');
          const svgEl = doc.querySelector('svg');
          if (svgEl) {
           svgEl.setAttribute('width', size * 1.2);
           svgEl.setAttribute('height', size * 1.2);
           svgEl.setAttribute('x', -size * 0.6);
           svgEl.setAttribute('y', -size * 0.6);
           if (styles.circleColor) {
            svgEl.style.fill = styles.circleColor;
            svgEl.querySelectorAll('path, circle, rect, polygon, ellipse').forEach(el => {
             el.style.fill = styles.circleColor;
            });
           }
           if (styles.circleBorder) {
            svgEl.style.stroke = styles.circleBorder;
            svgEl.querySelectorAll('path, circle, rect, polygon, ellipse').forEach(el => {
             el.style.stroke = styles.circleBorder;
            });
           }
           g.innerHTML = svgEl.outerHTML;
          }
         }
        });
        return g;
       }
       const shapeType = (NODE_DATA[id] && NODE_DATA[id].shape) || "circle";
       const shapeEl = createShapeElement(shapeType, size);
       shapeEl.classList.add("node-circle");
       shapeEl.style.fill = styles.circleColor || PAGE_STATE.nodeFill || "#1e293b";
       shapeEl.style.stroke = styles.circleBorder || PAGE_STATE.nodeStroke || "#475569";
       return shapeEl;
      }
      
      function forgeTheLegend() {
       const container = document.getElementById("edge-legend");
       if (!container) return;
       container.innerHTML = "";
       const title = document.createElement("div");
       title.className = "legend-title";
       title.textContent = "Line Legend";
       container.appendChild(title);
       const closeBtn = document.createElement("button");
       closeBtn.type = "button";
       closeBtn.className = "legend-close-btn";
       closeBtn.textContent = "✕";
       closeBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        legendCollapsed = true;
        updateLegendVisibility();
       });
       container.appendChild(closeBtn);
       const colors = [...new Set(EDGE_DATA.list.map((e) => e.color).filter(Boolean))];
       if (colors.length === 0) {
        updateLegendVisibility();
        return;
       }
       colors.forEach((color) => {
         if (!EDGE_LEGEND[color]) {
          EDGE_LEGEND[color] = "you can edit me too";
         }
         const item = document.createElement("div");
         item.className = "legend-item";
         item.addEventListener("mousedown", (e) => e.stopPropagation());
         item.addEventListener("click", (e) => e.stopPropagation());
         const swatch = document.createElement("span");
         swatch.className = "legend-swatch";
         swatch.style.backgroundColor = color;
         swatch.style.cursor = "pointer";
         swatch.addEventListener("click", (e) => {
          e.stopPropagation();
          const edgeWithColor = EDGE_DATA.list.find(edge => edge.color === color);
          if (edgeWithColor) {
           selectTheConnection(edgeWithColor.id);
          }
         });
         let swatchTouchStart = null;
         let swatchTouchMoved = false;
         swatch.addEventListener("touchstart", (e) => {
         swatchTouchStart = Date.now();
         swatchTouchMoved = false;
         if (e.touches[0]) {
          swatchTouchStartX = e.touches[0].clientX;
          swatchTouchStartY = e.touches[0].clientY;
         }
        }, {
          passive: false
         });
         let swatchTouchStartX = 0, swatchTouchStartY = 0;
        swatch.addEventListener("touchmove", (e) => {
         if (e.touches[0]) {
          const dx = Math.abs(e.touches[0].clientX - swatchTouchStartX);
          const dy = Math.abs(e.touches[0].clientY - swatchTouchStartY);
          if (dx > 10 || dy > 10) swatchTouchMoved = true;
         }
        }, {
          passive: false
         });
         swatch.addEventListener("touchend", (e) => {
          if (swatchTouchStart && !swatchTouchMoved && Date.now() - swatchTouchStart < 400) {
           e.stopPropagation();
           e.preventDefault();
           const edgeWithColor = EDGE_DATA.list.find(edge => edge.color === color);
           if (edgeWithColor) {
            selectTheConnection(edgeWithColor.id);
           }
          }
          swatchTouchStart = null;
          swatchTouchMoved = false;
         }, {
          passive: false
         });
        const label = document.createElement("span");
        label.className = "legend-label";
        label.textContent = EDGE_LEGEND[color];
        if (isMobileDevice()) {
         label.style.cursor = "pointer";
         let labelTapStart = null;
         let labelTapMoved = false;
         label.addEventListener("touchstart", (e) => {
          labelTapStart = Date.now();
          labelTapMoved = false;
          if (e.touches[0]) {
           labelTapStartX = e.touches[0].clientX;
           labelTapStartY = e.touches[0].clientY;
          }
          e.stopPropagation();
         });
         let labelTapStartX = 0, labelTapStartY = 0;
         label.addEventListener("touchmove", (e) => {
          if (e.touches[0]) {
           const dx = Math.abs(e.touches[0].clientX - labelTapStartX);
           const dy = Math.abs(e.touches[0].clientY - labelTapStartY);
           if (dx > 10 || dy > 10) labelTapMoved = true;
          }
         });
         label.addEventListener("touchend", (e) => {
          if (labelTapStart && !labelTapMoved && Date.now() - labelTapStart < 400) {
           e.preventDefault();
           e.stopPropagation();
           const currentText = label.textContent;
           const newText = prompt("Edit legend label:", currentText);
           if (newText !== null && newText.trim()) {
            label.textContent = newText.trim();
            EDGE_LEGEND[color] = newText.trim();
            
           }
          }
          labelTapStart = null;
          labelTapMoved = false;
         });
        } else {
           label.contentEditable = true;
           label.addEventListener("focus", () => {
            label.classList.add("editing");
           });
           label.addEventListener("blur", () => {
            label.classList.remove("editing");
            const text = label.textContent.trim() || "you can edit me too";
            EDGE_LEGEND[color] = text;
            
           });
           label.addEventListener("keydown", (e) => {
            if (e.key === "Enter") {
             e.preventDefault();
             label.blur();
            }
           });
          }
          item.append(swatch, label); container.appendChild(item);
         }); updateLegendVisibility();
       }
      
       function deleteRectangle(rectId) {
      pushUndo("delete zone");
        RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== rectId);
        forgeTheTopology();
       }
      
       function updateRectangleDeleteButtons() {
        const deleteButtons = document.querySelectorAll('.rect-delete-btn');
        deleteButtons.forEach(btn => {
         btn.style.display = rectDrawMode ? 'block' : 'none';
        });
       }
      
      
       function forgeTheTopology() {
        if (!NODE_DATA || !EDGE_DATA) {
         console.warn("forgeTheTopology called before data initialized");
         return;
        }
        const svg = document.getElementById("map");
        svg.innerHTML = "";
        const ns = "http://www.w3.org/2000/svg";
        const defs = document.createElementNS(ns, "defs");
        const markerForward = document.createElementNS(ns, "marker");
        markerForward.id = "arrow-forward";
        markerForward.setAttribute("markerWidth", "10");
        markerForward.setAttribute("markerHeight", "10");
        markerForward.setAttribute("refX", "9");
        markerForward.setAttribute("refY", "3");
        markerForward.setAttribute("orient", "auto");
        markerForward.setAttribute("markerUnits", "strokeWidth");
        const pathForward = document.createElementNS(ns, "path");
        pathForward.setAttribute("d", "M0,0 L0,6 L9,3 z");
        pathForward.setAttribute("fill", "context-stroke");
        markerForward.appendChild(pathForward);
        defs.appendChild(markerForward);
        const markerBackward = document.createElementNS(ns, "marker");
        markerBackward.id = "arrow-backward";
        markerBackward.setAttribute("markerWidth", "10");
        markerBackward.setAttribute("markerHeight", "10");
        markerBackward.setAttribute("refX", "0");
        markerBackward.setAttribute("refY", "3");
        markerBackward.setAttribute("orient", "auto");
        markerBackward.setAttribute("markerUnits", "strokeWidth");
        const pathBackward = document.createElementNS(ns, "path");
        pathBackward.setAttribute("d", "M9,0 L9,6 L0,3 z");
        pathBackward.setAttribute("fill", "context-stroke");
        markerBackward.appendChild(pathBackward);
        defs.appendChild(markerBackward);
        svg.appendChild(defs);
        const boundary = document.createElementNS(ns, "rect");
        boundary.setAttribute("x", CANVAS_PADDING);
        boundary.setAttribute("y", CANVAS_PADDING);
        boundary.setAttribute("width", CANVAS_WIDTH - CANVAS_PADDING * 2);
        boundary.setAttribute("height", CANVAS_HEIGHT - CANVAS_PADDING * 2);
        boundary.setAttribute("fill", "none");
        boundary.setAttribute("stroke", (PAGE_STATE.canvasBorder || "#475569") + "4D");
        boundary.setAttribute("stroke-width", "20");
        boundary.setAttribute("stroke-dasharray", "10 5");
        boundary.setAttribute("rx", "8");
        svg.appendChild(boundary);
       
       if (currentView.mode !== "rack") {
        const gridGroup = document.createElementNS(ns, "g");
        gridGroup.id = "canvas-grid";
        const gridSize = PAGE_STATE.canvasGridSize || 50;
        const gridColor = (PAGE_STATE.canvasGrid || "#475569") + "33";
        const majorGridColor = (PAGE_STATE.canvasGrid || "#475569") + "66";
        
        for (let x = CANVAS_PADDING; x <= CANVAS_WIDTH - CANVAS_PADDING; x += gridSize) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", x);
         line.setAttribute("y1", CANVAS_PADDING);
         line.setAttribute("x2", x);
         line.setAttribute("y2", CANVAS_HEIGHT - CANVAS_PADDING);
         line.setAttribute("stroke", (x - CANVAS_PADDING) % (gridSize * 5) === 0 ? majorGridColor : gridColor);
         line.setAttribute("stroke-width", (x - CANVAS_PADDING) % (gridSize * 5) === 0 ? "2" : "1");
         gridGroup.appendChild(line);
        }
        
        for (let y = CANVAS_PADDING; y <= CANVAS_HEIGHT - CANVAS_PADDING; y += gridSize) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", CANVAS_PADDING);
         line.setAttribute("y1", y);
         line.setAttribute("x2", CANVAS_WIDTH - CANVAS_PADDING);
         line.setAttribute("y2", y);
         line.setAttribute("stroke", (y - CANVAS_PADDING) % (gridSize * 5) === 0 ? majorGridColor : gridColor);
         line.setAttribute("stroke-width", (y - CANVAS_PADDING) % (gridSize * 5) === 0 ? "2" : "1");
         gridGroup.appendChild(line);
        }
        
        svg.appendChild(gridGroup);
       }
       
       if (currentView.mode === "rack" && currentView.rackId) {
         const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
         const rackGroup = document.createElementNS(ns, "g");
         rackGroup.id = "rack-visualization";       
         const rackFrame = document.createElementNS(ns, "rect");
         rackFrame.setAttribute("x", RACK_START_X - RACK_WIDTH / 2);
         rackFrame.setAttribute("y", RACK_START_Y);
         rackFrame.setAttribute("width", RACK_WIDTH);
         rackFrame.setAttribute("height", rackCapacity * rackUHeight);
      
         rackFrame.setAttribute("fill", (PAGE_STATE.rackFrameFill || "#0f172a") + "4D");
         rackFrame.setAttribute("stroke", PAGE_STATE.rackFrameStroke || "#4fd1c5");
         rackFrame.setAttribute("stroke-width", "3");
         rackFrame.setAttribute("rx", "4");
         rackGroup.appendChild(rackFrame);
         
         for (let u = 0; u <= rackCapacity; u++) {
          const y = RACK_START_Y + u * rackUHeight;
        
          const line = document.createElementNS(ns, "line");
          line.setAttribute("x1", RACK_START_X - RACK_WIDTH / 2);
          line.setAttribute("y1", y);
          line.setAttribute("x2", RACK_START_X + RACK_WIDTH / 2);
          line.setAttribute("y2", y);
          line.setAttribute("stroke", (PAGE_STATE.rackLineColor || "#475569") + "66");
          line.setAttribute("stroke-width", u % 5 === 0 ? "2" : "1");
          line.setAttribute("stroke-dasharray", u % 5 === 0 ? "none" : "5,5");
          rackGroup.appendChild(line);
          
          if (u < rackCapacity) {
           const uNumber = rackCapacity - u;
           const text = document.createElementNS(ns, "text");
           text.setAttribute("x", RACK_START_X - RACK_WIDTH / 2 - 30);
           text.setAttribute("y", y + rackUHeight / 2);
           text.setAttribute("text-anchor", "middle");
           text.setAttribute("dominant-baseline", "middle");
           text.style.fill = PAGE_STATE.rackTextColor || "#4fd1c5";
           text.style.fontSize = "14px";
           text.style.fontWeight = "bold";
           text.textContent = `U${uNumber}`;
           rackGroup.appendChild(text);
           
           const textRight = document.createElementNS(ns, "text");
           textRight.setAttribute("x", RACK_START_X + RACK_WIDTH / 2 + 30);
           textRight.setAttribute("y", y + rackUHeight / 2);
           textRight.setAttribute("text-anchor", "middle");
           textRight.setAttribute("dominant-baseline", "middle");
           textRight.style.fill = PAGE_STATE.rackTextColor || "#4fd1c5";
           textRight.style.fontSize = "14px";
           textRight.style.fontWeight = "bold";
           textRight.textContent = `U${uNumber}`;
           rackGroup.appendChild(textRight);
          }
         }
         
         svg.appendChild(rackGroup);
        }
      
        const centerX = CANVAS_WIDTH / 2;
      
        if (RECT_DATA && RECT_DATA.list) {
         RECT_DATA.list.forEach((rect) => {
          if (currentView.mode === "rack") return;
          
          if (rect.style === "filled") {
           const g = document.createElementNS(ns, "g");
           g.classList.add("rect-group");
           g.dataset.rectId = rect.id;
           
           const rectEl = document.createElementNS(ns, "rect");
           rectEl.classList.add("rect-shape");
           rectEl.setAttribute("x", rect.x);
           rectEl.setAttribute("y", rect.y);
           rectEl.setAttribute("width", rect.width);
           rectEl.setAttribute("height", rect.height);
           rectEl.style.fill = rect.color;
           rectEl.style.fillOpacity = "0.3";
           rectEl.style.stroke = rect.borderColor || rect.color;
           rectEl.style.strokeWidth = (rect.borderWidth !== undefined ? rect.borderWidth : 2) + "px";
           if (rect.lineStyle === "dashed") { rectEl.style.strokeDasharray = "10,5"; }
           else if (rect.lineStyle === "dotted") { rectEl.style.strokeDasharray = "2,4"; }
           else { rectEl.style.strokeDasharray = "none"; }
           rectEl.style.cursor = "move";
           
           rectEl.addEventListener("click", (e) => {
		   if (isViewOnly()) return;
             if (rectDrawMode) return;
             e.stopPropagation();
             currentRectId = rect.id;
             selectTheRect(rect.id);
           });
           
           rectEl.addEventListener("contextmenu", (e) => {
		    if (isViewOnly()) return;
             e.preventDefault();
             e.stopPropagation();
             if (selectedRects.has(rect.id)) {
               selectedRects.delete(rect.id);
             } else {
               selectedRects.add(rect.id);
             }
             updateAllSelections();
           });
           
           let rectLastTap = 0;
           rectEl.addEventListener("touchend", (e) => {
             const now = Date.now();
             if (now - rectLastTap < 300) {
               e.preventDefault();
               if (selectedRects.has(rect.id)) {
                 selectedRects.delete(rect.id);
               } else {
                 selectedRects.add(rect.id);
               }
               updateAllSelections();
               if (navigator.vibrate) navigator.vibrate(50);
               rectLastTap = 0;
             } else {
               rectLastTap = now;
             }
           }, { passive: false });
           
           const deleteBtn = document.createElementNS(ns, "g");
           deleteBtn.classList.add("rect-delete-btn");
           deleteBtn.style.cursor = "pointer";
           deleteBtn.style.display = rectDrawMode ? "block" : "none";
           
           const deleteBg = document.createElementNS(ns, "circle");
           deleteBg.setAttribute("cx", rect.x + rect.width - 10);
           deleteBg.setAttribute("cy", rect.y + 10);
           deleteBg.setAttribute("r", 12);
           deleteBg.style.fill = "#f56565";
           deleteBg.style.stroke = "white";
           deleteBg.style.strokeWidth = "2";
           
           const deleteX = document.createElementNS(ns, "text");
           deleteX.setAttribute("x", rect.x + rect.width - 10);
           deleteX.setAttribute("y", rect.y + 10);
           deleteX.setAttribute("text-anchor", "middle");
           deleteX.setAttribute("dominant-baseline", "middle");
           deleteX.style.fill = "white";
           deleteX.style.fontSize = "16px";
           deleteX.style.fontWeight = "bold";
           deleteX.style.pointerEvents = "none";
           deleteX.textContent = "×";
           
           deleteBtn.appendChild(deleteBg);
           deleteBtn.appendChild(deleteX);
           
           deleteBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            e.preventDefault();
            deleteRectangle(rect.id);
           });
           
           deleteBtn.addEventListener("touchend", (e) => {
      e.stopPropagation();
           e.preventDefault();
           deleteRectangle(rect.id);
           });
      
           let isDragging = false;
           let dragStartX, dragStartY;
           let rectStartX, rectStartY;
           
           rectEl.addEventListener("mousedown", (e) => {
      if (rectDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      rectStartX = rect.x;
      rectStartY = rect.y;
      rectEl.style.cursor = "grabbing";
      
      if (selectedRects.has(rect.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
           
      const moveHandler = (e) => {
      if (!isDragging || rectDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      rect.x = rectStartX + dx;
      rect.y = rectStartY + dy;
      if (selectedRects.has(rect.id)) {
      selectedNodes.forEach(nodeId => { if (initialPositions[nodeId]) { savedPositions[nodeId] = { x: initialPositions[nodeId].x + dx, y: initialPositions[nodeId].y + dy }; } });
      selectedRects.forEach(rectId => { if (rectId === rect.id) return; const r = RECT_DATA.list.find(x => x.id === rectId); if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; } });
      selectedTexts.forEach(textId => { const t = TEXT_DATA.list.find(x => x.id === textId); if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; } });
      selectedEdges.forEach(edgeId => { const ed = EDGE_DATA.list.find(x => x.id === edgeId); if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); } });
      }
      forgeTheTopology();
      };
           
           const upHandler = () => {
            if (isDragging) {
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           };
           
           document.addEventListener("mousemove", moveHandler);
           document.addEventListener("mouseup", upHandler);
           
           let touchStartX, touchStartY;
           let touchRectStartX, touchRectStartY;
           
           rectEl.addEventListener("touchstart", (e) => {
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchRectStartX = rect.x;
            touchRectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           }, { passive: false });
           
           rectEl.addEventListener("touchmove", (e) => {
            if (!isDragging || rectDrawMode) return;
            if (!e.touches[0]) return;
            e.preventDefault();
            e.stopPropagation();
            
            const svgEl = svg;
            const pt1 = svgEl.createSVGPoint();
            pt1.x = touchStartX;
            pt1.y = touchStartY;
            const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
            
            const touch = e.touches[0];
            const pt2 = svgEl.createSVGPoint();
            pt2.x = touch.clientX;
            pt2.y = touch.clientY;
            const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
            
            const dx = svgP2.x - svgP1.x;
            const dy = svgP2.y - svgP1.y;
            
            rect.x = touchRectStartX + dx;
            rect.y = touchRectStartY + dy;
            
            forgeTheTopology();
           }, { passive: false });
           
           rectEl.addEventListener("touchend", (e) => {
            if (isDragging) {
             e.preventDefault();
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           }, { passive: false });
            if (currentRectId === rect.id) {
      const corners = [
      { cx: rect.x, cy: rect.y, cursor: 'nwse-resize', dx: -1, dy: -1 },
      { cx: rect.x + rect.width, cy: rect.y, cursor: 'nesw-resize', dx: 1, dy: -1 },
      { cx: rect.x, cy: rect.y + rect.height, cursor: 'nesw-resize', dx: -1, dy: 1 },
      { cx: rect.x + rect.width, cy: rect.y + rect.height, cursor: 'nwse-resize', dx: 1, dy: 1 }
      ];
      corners.forEach((corner, idx) => {
      const handle = document.createElementNS(ns, "circle");
      handle.setAttribute("cx", corner.cx);
      handle.setAttribute("cy", corner.cy);
      handle.setAttribute("r", 8);
      handle.style.fill = "#f59e0b";
      handle.style.stroke = "#fff";
      handle.style.strokeWidth = "2";
      handle.style.cursor = corner.cursor;
      handle.addEventListener("mousedown", (e) => {
      e.preventDefault();
      e.stopPropagation();
      let dragging = true;
      const startX = e.clientX, startY = e.clientY;
      const origX = rect.x, origY = rect.y, origW = rect.width, origH = rect.height;
      const moveHandler = (ev) => {
        if (!dragging) return;
        const pt1 = svg.createSVGPoint(); pt1.x = startX; pt1.y = startY;
        const pt2 = svg.createSVGPoint(); pt2.x = ev.clientX; pt2.y = ev.clientY;
        const svgP1 = pt1.matrixTransform(svg.getScreenCTM().inverse());
        const svgP2 = pt2.matrixTransform(svg.getScreenCTM().inverse());
        const dx = svgP2.x - svgP1.x, dy = svgP2.y - svgP1.y;
        if (corner.dx < 0) { rect.x = origX + dx; rect.width = origW - dx; }
        else { rect.width = origW + dx; }
        if (corner.dy < 0) { rect.y = origY + dy; rect.height = origH - dy; }
        else { rect.height = origH + dy; }
        if (rect.width < 20) rect.width = 20;
        if (rect.height < 20) rect.height = 20;
        forgeTheTopology();
      };
      const upHandler = () => { dragging = false; document.removeEventListener("mousemove", moveHandler); document.removeEventListener("mouseup", upHandler); };
      document.addEventListener("mousemove", moveHandler);
      document.addEventListener("mouseup", upHandler);
      });
      g.appendChild(handle);
      });
      }
            if (rect.groupId) {
             const groupIndicator = document.createElementNS(ns, "rect");
             groupIndicator.setAttribute("x", rect.x - 4);
             groupIndicator.setAttribute("y", rect.y - 4);
             groupIndicator.setAttribute("width", rect.width + 8);
             groupIndicator.setAttribute("height", rect.height + 8);
             groupIndicator.style.fill = "none";
        groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
             groupIndicator.style.strokeWidth = "3";
             groupIndicator.style.strokeDasharray = "5,5";
             groupIndicator.style.pointerEvents = "none";
             g.insertBefore(groupIndicator, g.firstChild);
           }
           g.appendChild(rectEl);
           g.appendChild(deleteBtn);
           svg.appendChild(g);
          }
         });
        }
        const centerY = CANVAS_HEIGHT / 2;
        let positions = {};
        
        Object.keys(NODE_DATA).forEach((id) => {
         if (currentView.mode === "rack") {
          const node = NODE_DATA[id];
          if (!node || node.assignedRack !== currentView.rackId) {
           return;
          }
         }
         
         positions[id] = savedPositions[id] || {
          x: centerX,
          y: centerY
         };
        });
        if (Object.keys(savedPositions).length === 0) {
         const nodeIds = Object.keys(NODE_DATA).filter(id => {
          if (currentView.mode === "rack") {
           const node = NODE_DATA[id];
           return node && node.assignedRack === currentView.rackId;
          }
          return true;
         });
         
         const baseY = centerY - 300;
         if (nodeIds.length > 0) {
          positions[nodeIds[0]] = {
           x: centerX,
           y: baseY
          };
          const remaining = nodeIds.slice(1);
          const radius = 350;
          const startAngle = Math.PI * 0.3;
          const endAngle = Math.PI * 0.7;
          remaining.forEach((id, i) => {
           const angle = startAngle + (endAngle - startAngle) * (i / Math.max(1, remaining.length - 1));
           positions[id] = {
            x: centerX + Math.cos(angle) * radius * (i % 2 === 0 ? 1 : 1.3),
            y: baseY + 200 + Math.sin(angle) * radius * 0.8 + i * 80,
           };
          });
         }
        }
        Object.keys(positions).forEach((id) => {
         let pos = savedPositions[id] || positions[id];
         const nodeSize = savedSizes[id] || 55;
         pos.x = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, pos.x), );
         pos.y = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, pos.y), );
         positions[id] = {
          x: pos.x,
          y: pos.y
         };
         savedPositions[id] = {
          x: pos.x,
          y: pos.y
         };
        });
        const edgePairCount = {};
        const edgePairIndex = {};
        EDGE_DATA.list.forEach((edge) => {
         if (edge.type === "custom") return;
         const key = [edge.from, edge.to].sort().join("||");
         edgePairCount[key] = (edgePairCount[key] || 0) + 1;
        });
        EDGE_DATA.list.forEach((edge) => {
         if (edge.type === "custom") return;
         const key = [edge.from, edge.to].sort().join("||");
         if (!edgePairIndex[key]) edgePairIndex[key] = 0;
         edge._pairIndex = edgePairIndex[key];
         edge._pairTotal = edgePairCount[key];
         edgePairIndex[key]++;
        });
        EDGE_DATA.list.forEach((edge) => {
         if (edge.type === "custom" && Array.isArray(edge.points) && edge.points.length >= 2) {
          const customEdgeFaded = currentView.mode !== "rack" && edge.from && edge.to && (!isNodeVisible(edge.from) || !isNodeVisible(edge.to));
          const poly = document.createElementNS(ns, "polyline");
          poly.classList.add("edge");
          if (customEdgeFaded) {
           poly.style.opacity = "0.25";
           poly.classList.add("layer-faded");
          }
          poly.dataset.edgeId = edge.id;
poly.style.stroke = edge.color || PAGE_STATE.defaultEdge || "#475569";
          poly.style.strokeWidth = edge.width || 4;
          poly.setAttribute("fill", "none");
          const lineStyle = edge.lineStyle || "solid";
          if (lineStyle === "dashed") {
           poly.style.strokeDasharray = "10,5";
          } else if (lineStyle === "dotted") {
           poly.style.strokeDasharray = "2,4";
          } else {
           poly.style.strokeDasharray = "none";
          }
          const direction = edge.direction || "none";
          if (direction === "forward") {
           poly.setAttribute("marker-end", "url(#arrow-forward)");
          } else if (direction === "backward") {
           poly.setAttribute("marker-start", "url(#arrow-backward)");
          } else if (direction === "both") {
           poly.setAttribute("marker-start", "url(#arrow-backward)");
           poly.setAttribute("marker-end", "url(#arrow-forward)");
          }
          const ptsStr = edge.points.map((p) => `${p.x},${p.y}`).join(" ");
          poly.setAttribute("points", ptsStr);
          const polyHit = document.createElementNS(ns, "polyline");
          polyHit.setAttribute("points", ptsStr);
          polyHit.style.fill = "none";
          polyHit.style.stroke = "transparent";
          polyHit.style.strokeWidth = "20";
          polyHit.style.cursor = "pointer";
          polyHit.dataset.edgeId = edge.id;
          polyHit.addEventListener("click", (e) => {
           e.stopPropagation();
           selectTheConnection(edge.id);
          });
          let edgeTouchStart = null;
          let edgeTouchMoved = false;
          polyHit.addEventListener("touchstart", (e) => {
          edgeTouchStart = Date.now();
          edgeTouchMoved = false;
          if (e.touches[0]) {
           edgeTouchStartX = e.touches[0].clientX;
           edgeTouchStartY = e.touches[0].clientY;
          }
         }, {
           passive: false
          });
          let edgeTouchStartX = 0, edgeTouchStartY = 0;
         polyHit.addEventListener("touchmove", (e) => {
          if (e.touches[0]) {
           const dx = Math.abs(e.touches[0].clientX - edgeTouchStartX);
           const dy = Math.abs(e.touches[0].clientY - edgeTouchStartY);
           if (dx > 10 || dy > 10) edgeTouchMoved = true;
          }
         }, {
           passive: false
          });
          polyHit.addEventListener("touchend", (e) => {
           if (edgeTouchStart && !edgeTouchMoved && Date.now() - edgeTouchStart < 400) {
            e.stopPropagation();
            e.preventDefault();
            selectTheConnection(edge.id);
           }
           edgeTouchStart = null;
           edgeTouchMoved = false;
          }, {
           passive: false
          });
          poly.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         
         polyHit.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (selectedEdges.has(edge.id)) {
           selectedEdges.delete(edge.id);
          } else {
           selectedEdges.add(edge.id);
          }
          updateAllSelections();
         });
         
         let customEdgeLastTap = 0;
         polyHit.addEventListener("touchend", (e) => {
          const now = Date.now();
          if (now - customEdgeLastTap < 300) {
           e.preventDefault();
           if (selectedEdges.has(edge.id)) {
            selectedEdges.delete(edge.id);
           } else {
            selectedEdges.add(edge.id);
           }
           updateAllSelections();
           if (navigator.vibrate) navigator.vibrate(50);
           customEdgeLastTap = 0;
          } else {
           customEdgeLastTap = now;
          }
         }, { passive: false });
         
         poly.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (selectedEdges.has(edge.id)) {
           selectedEdges.delete(edge.id);
          } else {
           selectedEdges.add(edge.id);
          }
          updateAllSelections();
         });
         
         let edgeLastTap = 0;
         poly.addEventListener("touchend", (e) => {
          const now = Date.now();
          if (now - edgeLastTap < 300) {
           e.preventDefault();
           if (selectedEdges.has(edge.id)) {
            selectedEdges.delete(edge.id);
           } else {
            selectedEdges.add(edge.id);
           }
           updateAllSelections();
           if (navigator.vibrate) navigator.vibrate(50);
           edgeLastTap = 0;
          } else {
           edgeLastTap = now;
          }
         });
          
          if (currentView.mode === "rack") {
           return;
          }
          if (edge.groupId) {
      const bounds = edge.points.reduce((acc, p) => ({ minX: Math.min(acc.minX, p.x), minY: Math.min(acc.minY, p.y), maxX: Math.max(acc.maxX, p.x), maxY: Math.max(acc.maxY, p.y) }), { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity });
      const groupIndicator = document.createElementNS(ns, "rect");
      groupIndicator.setAttribute("x", bounds.minX - 8);
      groupIndicator.setAttribute("y", bounds.minY - 8);
      groupIndicator.setAttribute("width", bounds.maxX - bounds.minX + 16);
      groupIndicator.setAttribute("height", bounds.maxY - bounds.minY + 16);
      groupIndicator.setAttribute("rx", "4");
      groupIndicator.style.fill = "none";
  groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
      groupIndicator.style.strokeWidth = "3";
      groupIndicator.style.strokeDasharray = "5,5";
      groupIndicator.style.pointerEvents = "none";
      svg.appendChild(groupIndicator);
      }
         let lineDragging = false;
      let lineDragStartX, lineDragStartY;
      let linePointsStart = [];
      
      polyHit.addEventListener("mousedown", (e) => {
      if (freeDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      lineDragging = true;
      lineDragStartX = e.clientX;
      lineDragStartY = e.clientY;
      linePointsStart = edge.points.map(p => ({x: p.x, y: p.y}));
      
      if (selectedEdges.has(edge.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
      
      const lineMoveHandler = (e) => {
      if (!lineDragging || freeDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = lineDragStartX;
      pt1.y = lineDragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      
      edge.points.forEach((p, i) => { p.x = linePointsStart[i].x + dx; p.y = linePointsStart[i].y + dy; });
      
      if (selectedEdges.has(edge.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       savedPositions[nodeId] = { x: initialPositions[nodeId].x + dx, y: initialPositions[nodeId].y + dy };
      }
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      if (edgeId === edge.id) return;
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      forgeTheTopology();
      };
      
      const lineUpHandler = () => { lineDragging = false; };
      document.addEventListener("mousemove", lineMoveHandler);
      document.addEventListener("mouseup", lineUpHandler);
      
      svg.appendChild(poly);
      svg.appendChild(polyHit);
         
         if (currentEdgeId === edge.id) {
          edge.points.forEach((p, idx) => {
           const c = document.createElementNS(ns, "circle");
           c.classList.add("edge-edit-point");
           c.setAttribute("cx", p.x);
           c.setAttribute("cy", p.y);
		   c.setAttribute("r", PAGE_STATE.selectionHandleSize || 8);
           c.style.fill = PAGE_STATE.selectionHandle || "#f59e0b";
           c.style.stroke = "#fff";
           c.style.strokeWidth = "2";
           c.style.cursor = "move";
           c.dataset.edgeId = edge.id;
           c.dataset.pointIndex = String(idx);
           
           c.addEventListener("mousedown", (e) => {
            e.preventDefault();
            e.stopPropagation();
            let dragging = true;
            const svgEl = svg;
            const moveHandler = (ev) => {
             if (!dragging) return;
             const pt = svgEl.createSVGPoint();
             pt.x = ev.clientX;
             pt.y = ev.clientY;
             const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
             edge.points[idx].x = svgP.x;
             edge.points[idx].y = svgP.y;
             forgeTheTopology();
            };
            const upHandler = () => {
             dragging = false;
             document.removeEventListener("mousemove", moveHandler);
             document.removeEventListener("mouseup", upHandler);
            };
            document.addEventListener("mousemove", moveHandler);
            document.addEventListener("mouseup", upHandler);
           });
           
           c.addEventListener("touchstart", (e) => {
            e.preventDefault();
            e.stopPropagation();
            let dragging = true;
            const svgEl = svg;
            const touchMoveHandler = (ev) => {
             if (!dragging || !ev.touches[0]) return;
             const pt = svgEl.createSVGPoint();
             pt.x = ev.touches[0].clientX;
             pt.y = ev.touches[0].clientY;
             const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
             edge.points[idx].x = svgP.x;
             edge.points[idx].y = svgP.y;
             forgeTheTopology();
            };
            const touchUpHandler = () => {
             dragging = false;
             document.removeEventListener("touchmove", touchMoveHandler);
             document.removeEventListener("touchend", touchUpHandler);
            };
            document.addEventListener("touchmove", touchMoveHandler);
            document.addEventListener("touchend", touchUpHandler);
           }, { passive: false });
           
           svg.appendChild(c);
          });
         }
         
         return;
         }
         const p1 = positions[edge.from];
         const p2 = positions[edge.to];
         if (!p1 || !p2) return;
         const edgeFaded = currentView.mode !== "rack" && (!isNodeVisible(edge.from) || !isNodeVisible(edge.to));
         const pairTotal = edge._pairTotal || 1;
         const pairIndex = edge._pairIndex || 0;
         const midX = (p1.x + p2.x) / 2;
         const midY = (p1.y + p2.y) / 2;
         const dx = p2.x - p1.x;
         const dy = p2.y - p1.y;
         const len = Math.sqrt(dx * dx + dy * dy) || 1;
         const perpX = -dy / len;
         const perpY = dx / len;
         let offsetAmount = 0;
         if (pairTotal > 1) {
          offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
         }
         const ctrlX = midX + perpX * offsetAmount;
         const ctrlY = midY + perpY * offsetAmount;
         const path = document.createElementNS(ns, "path");
         path.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
         path.setAttribute("fill", "none");
         path.classList.add("edge");
         if (edgeFaded) {
          path.style.opacity = "0.25";
          path.classList.add("layer-faded");
         }
         if (edge.type === "backup") path.classList.add("backup");
         path.dataset.edgeId = edge.id;
         path.dataset.from = edge.from;
         path.dataset.to = edge.to;
         path.style.stroke = edge.color;
         path.style.strokeWidth = edge.width;
         const pathHit = document.createElementNS(ns, "path");
         pathHit.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
         pathHit.setAttribute("fill", "none");
         pathHit.style.stroke = "transparent";
         pathHit.style.strokeWidth = "20";
         pathHit.style.cursor = "pointer";
         pathHit.dataset.edgeId = edge.id;
         pathHit.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         let pathTouchStart = null;
         let pathTouchMoved = false;
         pathHit.addEventListener("touchstart", (e) => {
         pathTouchStart = Date.now();
         pathTouchMoved = false;
         if (e.touches[0]) {
          pathTouchStartX = e.touches[0].clientX;
          pathTouchStartY = e.touches[0].clientY;
         }
        }, {
          passive: false
         });
         let pathTouchStartX = 0, pathTouchStartY = 0;
        pathHit.addEventListener("touchmove", (e) => {
         if (e.touches[0]) {
          const dx = Math.abs(e.touches[0].clientX - pathTouchStartX);
          const dy = Math.abs(e.touches[0].clientY - pathTouchStartY);
          if (dx > 10 || dy > 10) pathTouchMoved = true;
         }
        }, {
          passive: false
         });
         pathHit.addEventListener("touchend", (e) => {
          if (pathTouchStart && !pathTouchMoved && Date.now() - pathTouchStart < 400) {
           e.stopPropagation();
           e.preventDefault();
           selectTheConnection(edge.id);
          }
          pathTouchStart = null;
          pathTouchMoved = false;
         }, {
          passive: false
         });
         path.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         
         if (currentView.mode === "rack") {
          const fromNode = NODE_DATA[edge.from];
          const toNode = NODE_DATA[edge.to];
          if (!fromNode || !toNode || 
              fromNode.assignedRack !== currentView.rackId || 
              toNode.assignedRack !== currentView.rackId) {
           return;
          }
         }
         
         svg.appendChild(path);
         svg.appendChild(pathHit);
         
         if (edge.fromPort || edge.toPort) {
          const ns = "http://www.w3.org/2000/svg";
          
          if (edge.fromPort) {
           const fromLabel = document.createElementNS(ns, "text");
           fromLabel.textContent = edge.fromPort;
           fromLabel.setAttribute("x", p1.x);
           fromLabel.setAttribute("y", p1.y - 10);
           fromLabel.setAttribute("text-anchor", "middle");
           fromLabel.style.fill = "#94a3b8";
           fromLabel.style.fontSize = "12px";
           fromLabel.style.fontWeight = "600";
           fromLabel.style.pointerEvents = "none";
           fromLabel.classList.add("port-label");
           svg.appendChild(fromLabel);
          }
      
          if (edge.toPort) {
           const toLabel = document.createElementNS(ns, "text");
           toLabel.textContent = edge.toPort;
           toLabel.setAttribute("x", p2.x);
           toLabel.setAttribute("y", p2.y - 10);
           toLabel.setAttribute("text-anchor", "middle");
           toLabel.style.fill = "#94a3b8";
           toLabel.style.fontSize = "12px";
           toLabel.style.fontWeight = "600";
           toLabel.style.pointerEvents = "none";
           toLabel.classList.add("port-label");
           svg.appendChild(toLabel);
          }
         }
        });
        Object.entries(positions).forEach(([id, pos]) => {
         const node = NODE_DATA[id];
         if (!node) return;
         
         if (currentView.mode === "rack") {
          if (node.assignedRack !== currentView.rackId) return;
          
         const rackUnit = parseInt(node.rackUnit) || 1;
      const uHeight = parseInt(node.uHeight) || 1;
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      pos.x = RACK_START_X;
      pos.y = RACK_START_Y + (rackCapacity - rackUnit - uHeight + 1) * rackUHeight + (uHeight * rackUHeight) / 2;
         } else {
          if (node.assignedRack) return;
         }
         
         const g = document.createElementNS("http://www.w3.org/2000/svg", "g", );
         g.classList.add("node-group");
         g.dataset.nodeId = id;
         g.setAttribute("transform", `translate(${pos.x},${pos.y})`);
         if (currentView.mode !== "rack" && !isNodeVisible(id)) {
          g.style.opacity = "0.25";
          g.classList.add("layer-faded");
         }
         let r = savedSizes[id] || 55;
         if (!savedSizes[id]) {
          if (window.innerWidth <= 380) r = 120;
          else if (window.innerWidth <= 768) r = 140;
          else if (window.innerWidth <= 1024) r = 70;
         }
         const styles = resolveStylesForNode(id);
         const ns = "http://www.w3.org/2000/svg";
         const hitArea = document.createElementNS(ns, "circle");
         hitArea.setAttribute("r", r * 1.5);
         hitArea.style.fill = "transparent";
         hitArea.style.stroke = "none";
         hitArea.style.cursor = "grab";
         hitArea.classList.add("node-hit-area");
         const shapeEl = createNodeShape(id, r);
         const titleOffsetX = styles.titleOffsetX || 0;
         const titleOffsetY = styles.titleOffsetY || 0;
         const subOffsetX = styles.subOffsetX || 0;
         const subOffsetY = styles.subOffsetY || 0;
         const label = document.createElementNS("http://www.w3.org/2000/svg", "text", );
         label.classList.add("node-label");
         label.setAttribute("x", titleOffsetX);
         label.setAttribute("y", -r * 0.28 + titleOffsetY);
         const labelFontSize = styles.titleSize || PAGE_STATE.nodeTitleSize || r * 0.33;
        label.style.fontSize = labelFontSize + "px";
         label.textContent = NODE_DATA[id].name;
label.style.fill = styles.titleColor || PAGE_STATE.nodeTitle || "#e2e8f0";
        label.style.fontFamily = styles.titleFont || PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
         label.style.pointerEvents = "none";
         const sub = document.createElementNS("http://www.w3.org/2000/svg", "text", );
         sub.classList.add("node-sub");
         sub.setAttribute("x", subOffsetX);
         sub.setAttribute("y", r * 0.4 + subOffsetY);
         const subFontSize = styles.subSize || PAGE_STATE.nodeSubSize || r * 0.24;
        sub.style.fontSize = subFontSize + "px";
         sub.textContent = NODE_DATA[id].ip;
sub.style.fill = styles.subColor || PAGE_STATE.nodeSub || "#94a3b8";
        sub.style.fontFamily = styles.subFont || PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
         sub.style.pointerEvents = "none";
         g.append(hitArea, shapeEl, label, sub);
         
         if (NODE_DATA[id]?.locked) {
           const lockIndicator = document.createElementNS(ns, "text");
           lockIndicator.textContent = "🔒";
           lockIndicator.setAttribute("x", r * 0.7);
           lockIndicator.setAttribute("y", -r * 0.7);
           lockIndicator.style.fontSize = (r * 0.3) + "px";
           lockIndicator.style.pointerEvents = "none";
           lockIndicator.classList.add("lock-indicator");
           g.appendChild(lockIndicator);
         }
         
         if (NODE_DATA[id]?.groupId) {
           const groupIndicator = document.createElementNS(ns, "circle");
           groupIndicator.setAttribute("r", r + 4);
           groupIndicator.style.fill = "none";
         groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
           groupIndicator.style.strokeWidth = "3";
           groupIndicator.style.strokeDasharray = "5,5";
           groupIndicator.style.pointerEvents = "none";
           groupIndicator.classList.add("group-indicator");
           
           g.insertBefore(groupIndicator, g.firstChild);
         }
         
         let isDragging = false;
         let startX, startY;
         let initialPositions = {};
         let longPressTimer = null;
         let longPressTriggered = false;
         
         g.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (isViewOnly()) return;
          
          if (selectedNodes.has(id)) {
           selectedNodes.delete(id);
          } else {
           selectedNodes.add(id);
          }
          updateNodeSelection();
          return false;
         });
         
        g.addEventListener("touchstart", (e) => {
         if (NODE_DATA[id].isRack) {
          const touch = e.touches[0];
          longPressStartX = touch.clientX;
          longPressStartY = touch.clientY;
          longPressTimer = setTimeout(() => {
           longPressTriggered = true;
           if (navigator.vibrate) {
            navigator.vibrate(100);
           }
           enterRack(id);
          }, 500);
         }
        }, { passive: true });
        
        g.addEventListener("dblclick", (e) => {
         e.preventDefault();
         e.stopPropagation();
         if (NODE_DATA[id].isRack) {
          enterRack(id);
         }
        });
        
        let lastTapTime = 0;
        let lastTapNode = null;
        
        g.addEventListener("touchend", (e) => {
         const currentTime = new Date().getTime();
         const tapLength = currentTime - lastTapTime;
         
         if (tapLength < 300 && tapLength > 0 && lastTapNode === id) {
          e.preventDefault();
          e.stopPropagation();
          if (isViewOnly()) return;
          
          if (selectedNodes.has(id)) {
           selectedNodes.delete(id);
          } else {
           selectedNodes.add(id);
          }
          updateNodeSelection();
          
          if (navigator.vibrate) {
           navigator.vibrate(50);
          }
          
          lastTapTime = 0;
          lastTapNode = null;
         } else {
          lastTapTime = currentTime;
          lastTapNode = id;
         }
        });
         
         g.addEventListener("touchend", (e) => {
          if (longPressTimer) {
           clearTimeout(longPressTimer);
           longPressTimer = null;
          }
          if (longPressTriggered) {
           e.preventDefault();
           e.stopPropagation();
           longPressTriggered = false;
          }
         });
         
         let longPressStartX = 0;
        let longPressStartY = 0;
        g.addEventListener("touchmove", (e) => {
         if (longPressTimer) {
          const touch = e.touches[0];
          const dx = Math.abs(touch.clientX - longPressStartX);
          const dy = Math.abs(touch.clientY - longPressStartY);
          if (dx > 15 || dy > 15) {
           clearTimeout(longPressTimer);
           longPressTimer = null;
           longPressTriggered = false;
          }
         }
        });
         
         g.addEventListener("mousedown", (e) => {
          if (isViewOnly()) return;
          if (e.button === 2) {
           return;
          }
          
          if (NODE_DATA[id]?.locked) {
           return;
          }
          
          e.preventDefault();
          isDragging = true;
          const svgEl = document.getElementById("map");
          const pt = svgEl.createSVGPoint();
          pt.x = e.clientX;
          pt.y = e.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          startX = svgP.x;
          startY = svgP.y;
          
          let nodesToCollect = [];
      
      
      if (selectedNodes.has(id)) {
      initialPositions = {};
      const allSelectedRects = Array.from(selectedRects);
      const allSelectedTexts = Array.from(selectedTexts);
      const allSelectedEdges = Array.from(selectedEdges).map(eid => EDGE_DATA.list.find(e => e.id === eid)).filter(Boolean);
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) {
      initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      }
      });
      Array.from(selectedRects).forEach(rectId => {
        const rect = RECT_DATA.list.find(r => r.id === rectId);
        if (rect) { rect._dragStartX = rect.x; rect._dragStartY = rect.y; }
      });
      Array.from(selectedTexts).forEach(textId => {
        const text = TEXT_DATA.list.find(t => t.id === textId);
        if (text) { text._dragStartX = text.x; text._dragStartY = text.y; }
      });
      Array.from(selectedEdges).forEach(edgeId => {
        const edge = EDGE_DATA.list.find(e => e.id === edgeId);
        if (edge && edge.points) { edge._dragStartPoints = edge.points.map(p => ({x: p.x, y: p.y})); }
      });
      
      
      } else {
      initialPositions = { [id]: { x: pos.x, y: pos.y } };
      }
          
          const groupIds = new Set();
          nodesToCollect.forEach(nodeId => {
           const groupId = NODE_DATA[nodeId]?.groupId;
           if (groupId) {
             groupIds.add(groupId);
           }
          });
          
          if (groupIds.size > 0) {
           Object.keys(NODE_DATA).forEach(nodeId => {
             const nodeGroupId = NODE_DATA[nodeId]?.groupId;
             if (nodeGroupId && groupIds.has(nodeGroupId)) {
               if (!nodesToCollect.includes(nodeId)) {
                 nodesToCollect.push(nodeId);
               }
             }
           });
          }
          
          nodesToCollect = nodesToCollect.filter(nodeId => !NODE_DATA[nodeId]?.locked);
          
          if (nodesToCollect.length === 0) {
           return;
          }
          
          initialPositions = {};
          nodesToCollect.forEach(nodeId => {
           const nodePos = savedPositions[nodeId];
           if (nodePos) {
            initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
           }
          });
          
          g.style.cursor = "grabbing";
          hitArea.style.cursor = "grabbing";
          e.stopPropagation();
         });
         const handleMouseMove = (e) => {
          if (!isDragging) return;
          e.preventDefault();
          const svgEl = document.getElementById("map");
          const pt = svgEl.createSVGPoint();
          pt.x = e.clientX;
          pt.y = e.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          const dx = svgP.x - startX;
          const dy = svgP.y - startY;
          
          const nodesToMove = selectedNodes.has(id) ? Array.from(selectedNodes) : [id];
          nodesToMove.forEach(nodeId => {
           if (!initialPositions[nodeId]) return;
           const initialPos = initialPositions[nodeId];
           let newX = initialPos.x + dx;
           let newY = initialPos.y + dy;
           const nodeSize = savedSizes[nodeId] || 55;
           newX = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, newX), );
           newY = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, newY), );
           
           savedPositions[nodeId] = { x: newX, y: newY };
           positions[nodeId] = { x: newX, y: newY };
           
           if (nodeId === id) {
            pos.x = newX;
            pos.y = newY;
           }
           
           const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
          if (nodeGroup) {
           nodeGroup.setAttribute("transform", `translate(${newX},${newY})`);
          }
         });
         
         Array.from(selectedRects).forEach(rectId => {
           const rect = RECT_DATA.list.find(r => r.id === rectId);
           if (rect && rect._dragStartX !== undefined) {
             rect.x = rect._dragStartX + dx;
             rect.y = rect._dragStartY + dy;
           }
         });
         Array.from(selectedTexts).forEach(textId => {
           const text = TEXT_DATA.list.find(t => t.id === textId);
           if (text && text._dragStartX !== undefined) {
             text.x = text._dragStartX + dx;
             text.y = text._dragStartY + dy;
           }
         });
         Array.from(selectedEdges).forEach(edgeId => {
           const edge = EDGE_DATA.list.find(e => e.id === edgeId);
           if (edge && edge._dragStartPoints) {
             edge.points.forEach((p, i) => {
               p.x = edge._dragStartPoints[i].x + dx;
               p.y = edge._dragStartPoints[i].y + dy;
             });
           }
         });
         forgeTheTopology();
         
         updateMinimap();
          document.querySelectorAll(".edge").forEach((edgeEl) => {
           const fromId = edgeEl.dataset.from;
           const toId = edgeEl.dataset.to;
           if (nodesToMove.includes(fromId) || nodesToMove.includes(toId)) {
            const p1 = savedPositions[fromId] || positions[fromId] || {
             x: 600,
             y: 350
            };
            const p2 = savedPositions[toId] || positions[toId] || {
             x: 600,
             y: 350
            };
            if (edgeEl.tagName === "line") {
             edgeEl.setAttribute("x1", p1.x);
             edgeEl.setAttribute("y1", p1.y);
             edgeEl.setAttribute("x2", p2.x);
             edgeEl.setAttribute("y2", p2.y);
            } else if (edgeEl.tagName === "path") {
             const edgeId = edgeEl.dataset.edgeId;
             const edge = EDGE_DATA.list.find(
              (e) => e.id === edgeId, );
             if (edge) {
              const pairTotal = edge._pairTotal || 1;
              const pairIndex = edge._pairIndex || 0;
              const midX = (p1.x + p2.x) / 2;
              const midY = (p1.y + p2.y) / 2;
              const dx = p2.x - p1.x;
              const dy = p2.y - p1.y;
              const len = Math.sqrt(dx * dx + dy * dy) || 1;
              const perpX = -dy / len;
              const perpY = dx / len;
              let offsetAmount = 0;
              if (pairTotal > 1) {
               offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
              }
              const ctrlX = midX + perpX * offsetAmount;
              const ctrlY = midY + perpY * offsetAmount;
              edgeEl.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
             }
            }
           }
          });
         };
      const handleMouseUp = () => {
      if (isDragging) {
      pushUndo("move nodes");
      isDragging = false;
      g.style.cursor = "grab";
      hitArea.style.cursor = "grab";
      if (currentView.mode === "rack" && NODE_DATA[id]?.assignedRack === currentView.rackId) {
      const draggedY = savedPositions[id]?.y || pos.y;
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      let newUnit = rackCapacity - Math.round((draggedY - RACK_START_Y) / rackUHeight);
      newUnit = Math.max(1, Math.min(newUnit, rackCapacity));
      NODE_DATA[id].rackUnit = newUnit;
      forgeTheTopology();
      claimTheImmortal(id);
      }
      }
      };
         document.addEventListener("mousemove", handleMouseMove);
         document.addEventListener("mouseup", handleMouseUp);
         let touchStartTime = 0;
         let touchStartX = 0;
         let touchStartY = 0;
         let touchMoved = false;
       g.addEventListener("touchstart",
         (e) => {
          if (NODE_DATA[id]?.locked) {
           return;
          }
          
          e.preventDefault();
          touchStartTime = Date.now();
          touchMoved = false;
          const svgEl = document.getElementById("map");
          const pt = svgEl.createSVGPoint();
          const touch = e.touches[0];
          pt.x = touch.clientX;
          pt.y = touch.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          touchStartX = svgP.x;
          touchStartY = svgP.y;
          startX = svgP.x;
          startY = svgP.y;
          
          let nodesToCollect = [];
          if (selectedNodes.has(id)) {
           nodesToCollect = Array.from(selectedNodes);
          } else {
           nodesToCollect = [id];
          }
          
          const groupIds = new Set();
          nodesToCollect.forEach(nodeId => {
           const groupId = NODE_DATA[nodeId]?.groupId;
           if (groupId) {
             groupIds.add(groupId);
           }
          });
          
          if (groupIds.size > 0) {
           Object.keys(NODE_DATA).forEach(nodeId => {
             const nodeGroupId = NODE_DATA[nodeId]?.groupId;
             if (nodeGroupId && groupIds.has(nodeGroupId)) {
               if (!nodesToCollect.includes(nodeId)) {
                 nodesToCollect.push(nodeId);
               }
             }
           });
          }
          
          nodesToCollect = nodesToCollect.filter(nodeId => !NODE_DATA[nodeId]?.locked);
          
          if (nodesToCollect.length === 0) {
           return;
          }
          
          initialPositions = {};
          nodesToCollect.forEach(nodeId => {
           const nodePos = savedPositions[nodeId];
           if (nodePos) {
            initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
           }
          });
          
          e.stopPropagation();
         }, {
          passive: false
         }, );
         g.addEventListener("touchmove", (e) => {
         e.preventDefault();
         const svgEl = document.getElementById("map");
         const pt = svgEl.createSVGPoint();
         const touch = e.touches[0];
         pt.x = touch.clientX;
         pt.y = touch.clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
         const dx = Math.abs(svgP.x - touchStartX);
         const dy = Math.abs(svgP.y - touchStartY);
         if (dx > (isMobileDevice() ? 4 : 10) || dy > (isMobileDevice() ? 4 : 10)) {
      touchMoved = true;
      isDragging = true;
      }
         if (!isDragging) return;
         
         const deltaX = svgP.x - startX;
         const deltaY = svgP.y - startY;
         
         const nodesToMove = selectedNodes.has(id) ? Array.from(selectedNodes) : [id];
         nodesToMove.forEach(nodeId => {
          if (!initialPositions[nodeId]) return;
          const initialPos = initialPositions[nodeId];
          let newX = initialPos.x + deltaX;
          let newY = initialPos.y + deltaY;
          const nodeSize = savedSizes[nodeId] || 55;
          newX = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, newX), );
          newY = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, newY), );
          
          savedPositions[nodeId] = { x: newX, y: newY };
          positions[nodeId] = { x: newX, y: newY };
          
          if (nodeId === id) {
           pos.x = newX;
           pos.y = newY;
          }
          
          const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
          if (nodeGroup) {
           nodeGroup.setAttribute("transform", `translate(${newX},${newY})`);
          }
         });
         
         updateMinimap();
         document.querySelectorAll(".edge").forEach((edgeEl) => {
          const fromId = edgeEl.dataset.from;
          const toId = edgeEl.dataset.to;
          if (nodesToMove.includes(fromId) || nodesToMove.includes(toId)) {
            const p1 = savedPositions[fromId] || positions[fromId] || {
             x: 600,
             y: 350
            };
            const p2 = savedPositions[toId] || positions[toId] || {
             x: 600,
             y: 350
            };
            if (edgeEl.tagName === "line") {
             edgeEl.setAttribute("x1", p1.x);
             edgeEl.setAttribute("y1", p1.y);
             edgeEl.setAttribute("x2", p2.x);
             edgeEl.setAttribute("y2", p2.y);
            } else if (edgeEl.tagName === "path") {
             const edgeId = edgeEl.dataset.edgeId;
             const edge = EDGE_DATA.list.find(
              (e) => e.id === edgeId, );
             if (edge) {
              const pairTotal = edge._pairTotal || 1;
              const pairIndex = edge._pairIndex || 0;
              const midX = (p1.x + p2.x) / 2;
              const midY = (p1.y + p2.y) / 2;
              const dx = p2.x - p1.x;
              const dy = p2.y - p1.y;
              const len = Math.sqrt(dx * dx + dy * dy) || 1;
              const perpX = -dy / len;
              const perpY = dx / len;
              let offsetAmount = 0;
              if (pairTotal > 1) {
               offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
              }
              const ctrlX = midX + perpX * offsetAmount;
              const ctrlY = midY + perpY * offsetAmount;
              edgeEl.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
             }
            }
           }
          });
         }, {
          passive: false
         });
      g.addEventListener("touchend", (e) => {
      const touchDuration = Date.now() - touchStartTime;
      if (!touchMoved && touchDuration < 400) {
       if (isViewOnly()) {
        handleViewOnlyClick(id, 'node');
        return;
       }
       claimTheImmortal(id);
      }
      if (isDragging) {
      const draggedY = pos.y;
      isDragging = false;
      savedPositions[id] = {
      x: pos.x,
      y: pos.y
      };
      if (currentView.mode === "rack" && NODE_DATA[id]?.assignedRack === currentView.rackId) {
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      let newUnit = rackCapacity - Math.round((draggedY - RACK_START_Y) / rackUHeight);
      newUnit = Math.max(1, Math.min(newUnit, rackCapacity));
      NODE_DATA[id].rackUnit = newUnit;
      forgeTheTopology();
      claimTheImmortal(id);
      }
      }
      touchMoved = false;
      });
         g.style.cursor = "grab";
         g.addEventListener("click", (e) => {
          if (!isDragging) {
           if (isViewOnly()) {
            handleViewOnlyClick(id, 'node');
            return;
           }
           claimTheImmortal(id);
          }
         });
         svg.appendChild(g);
        });
        
        if (RECT_DATA && RECT_DATA.list) {
         RECT_DATA.list.forEach((rect) => {
          if (currentView.mode === "rack") return;
          if (rect.style === "outlined") {
           const g = document.createElementNS(ns, "g");
           g.classList.add("rect-group");
           g.dataset.rectId = rect.id;
           
           const rectEl = document.createElementNS(ns, "rect");
           rectEl.classList.add("rect-shape");
           rectEl.setAttribute("x", rect.x);
           rectEl.setAttribute("y", rect.y);
           rectEl.setAttribute("width", rect.width);
           rectEl.setAttribute("height", rect.height);
           rectEl.style.fill = "none";
           rectEl.style.stroke = rect.borderColor || rect.color;
           rectEl.style.strokeWidth = (rect.borderWidth !== undefined ? rect.borderWidth : 3) + "px";
      if (rect.lineStyle === "dashed") { rectEl.style.strokeDasharray = "10,5"; }
           else if (rect.lineStyle === "dotted") { rectEl.style.strokeDasharray = "2,4"; }
           else { rectEl.style.strokeDasharray = "none"; }
           rectEl.style.cursor = "move";
           
           rectEl.addEventListener("click", (e) => {
             if (rectDrawMode) return;
             e.stopPropagation();
             currentRectId = rect.id;
             selectTheRect(rect.id);
           });
           
           rectEl.addEventListener("contextmenu", (e) => {
             e.preventDefault();
             e.stopPropagation();
             if (selectedRects.has(rect.id)) {
               selectedRects.delete(rect.id);
             } else {
               selectedRects.add(rect.id);
             }
             updateAllSelections();
           });
           
           let rectLastTap = 0;
           rectEl.addEventListener("touchend", (e) => {
             const now = Date.now();
             if (now - rectLastTap < 300) {
               e.preventDefault();
               if (selectedRects.has(rect.id)) {
                 selectedRects.delete(rect.id);
               } else {
                 selectedRects.add(rect.id);
               }
               updateAllSelections();
               if (navigator.vibrate) navigator.vibrate(50);
               rectLastTap = 0;
             } else {
               rectLastTap = now;
             }
           }, { passive: false });
           
           const deleteBtn = document.createElementNS(ns, "g");
           deleteBtn.classList.add("rect-delete-btn");
           deleteBtn.style.cursor = "pointer";
           deleteBtn.style.display = rectDrawMode ? "block" : "none";
           
           const deleteBg = document.createElementNS(ns, "circle");
           deleteBg.setAttribute("cx", rect.x + rect.width - 10);
           deleteBg.setAttribute("cy", rect.y + 10);
           deleteBg.setAttribute("r", 12);
           deleteBg.style.fill = "#f56565";
           deleteBg.style.stroke = "white";
           deleteBg.style.strokeWidth = "2";
           
           const deleteX = document.createElementNS(ns, "text");
           deleteX.setAttribute("x", rect.x + rect.width - 10);
           deleteX.setAttribute("y", rect.y + 10);
           deleteX.setAttribute("text-anchor", "middle");
           deleteX.setAttribute("dominant-baseline", "middle");
           deleteX.style.fill = "white";
           deleteX.style.fontSize = "16px";
           deleteX.style.fontWeight = "bold";
           deleteX.style.pointerEvents = "none";
           deleteX.textContent = "×";
           
           deleteBtn.appendChild(deleteBg);
           deleteBtn.appendChild(deleteX);
           
           deleteBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            e.preventDefault();
            deleteRectangle(rect.id);
           });
           
           let isDragging = false;
           let dragStartX, dragStartY;
           let rectStartX, rectStartY;
           
           rectEl.addEventListener("mousedown", (e) => {
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            dragStartX = e.clientX;
            dragStartY = e.clientY;
            rectStartX = rect.x;
            rectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           });
           
      const moveHandler = (e) => {
      if (!isDragging || rectDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      rect.x = rectStartX + dx;
      rect.y = rectStartY + dy;
      if (selectedRects.has(rect.id)) {
      selectedNodes.forEach(nodeId => { if (initialPositions[nodeId]) { savedPositions[nodeId] = { x: initialPositions[nodeId].x + dx, y: initialPositions[nodeId].y + dy }; } });
      selectedRects.forEach(rectId => { if (rectId === rect.id) return; const r = RECT_DATA.list.find(x => x.id === rectId); if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; } });
      selectedTexts.forEach(textId => { const t = TEXT_DATA.list.find(x => x.id === textId); if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; } });
      selectedEdges.forEach(edgeId => { const ed = EDGE_DATA.list.find(x => x.id === edgeId); if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); } });
      }
      forgeTheTopology();
      };
           
           const upHandler = () => {
            if (isDragging) {
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           };
           
           document.addEventListener("mousemove", moveHandler);
           document.addEventListener("mouseup", upHandler);
           
           let touchStartX, touchStartY;
           let touchRectStartX, touchRectStartY;
           
           rectEl.addEventListener("touchstart", (e) => {
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchRectStartX = rect.x;
            touchRectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           }, { passive: false });
           
           rectEl.addEventListener("touchmove", (e) => {
            if (!isDragging || rectDrawMode) return;
            if (!e.touches[0]) return;
            e.preventDefault();
            e.stopPropagation();
            
            const svgEl = svg;
            const pt1 = svgEl.createSVGPoint();
            pt1.x = touchStartX;
            pt1.y = touchStartY;
            const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
            
            const touch = e.touches[0];
            const pt2 = svgEl.createSVGPoint();
            pt2.x = touch.clientX;
            pt2.y = touch.clientY;
            const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
            
            const dx = svgP2.x - svgP1.x;
            const dy = svgP2.y - svgP1.y;
            
            rect.x = touchRectStartX + dx;
            rect.y = touchRectStartY + dy;
            
            forgeTheTopology();
           }, { passive: false });
           
           rectEl.addEventListener("touchend", (e) => {
            if (isDragging) {
             e.preventDefault();
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           }, { passive: false });
           
           if (currentRectId === rect.id) {
             const corners = [
               { cx: rect.x, cy: rect.y, cursor: 'nwse-resize', dx: -1, dy: -1 },
               { cx: rect.x + rect.width, cy: rect.y, cursor: 'nesw-resize', dx: 1, dy: -1 },
               { cx: rect.x, cy: rect.y + rect.height, cursor: 'nesw-resize', dx: -1, dy: 1 },
               { cx: rect.x + rect.width, cy: rect.y + rect.height, cursor: 'nwse-resize', dx: 1, dy: 1 }
             ];
             corners.forEach((corner) => {
               const handle = document.createElementNS(ns, "circle");
               handle.setAttribute("cx", corner.cx);
               handle.setAttribute("cy", corner.cy);
handle.setAttribute("r", PAGE_STATE.selectionHandleSize || 8);
      handle.style.fill = PAGE_STATE.selectionHandle || "#f59e0b";
               handle.style.stroke = "#fff";
               handle.style.strokeWidth = "2";
               handle.style.cursor = corner.cursor;
               handle.addEventListener("mousedown", (e) => {
                 e.preventDefault();
                 e.stopPropagation();
                 let dragging = true;
                 const startX = e.clientX, startY = e.clientY;
                 const origX = rect.x, origY = rect.y, origW = rect.width, origH = rect.height;
                 const moveHandler = (ev) => {
                   if (!dragging) return;
                   const pt1 = svg.createSVGPoint(); pt1.x = startX; pt1.y = startY;
                   const pt2 = svg.createSVGPoint(); pt2.x = ev.clientX; pt2.y = ev.clientY;
                   const svgP1 = pt1.matrixTransform(svg.getScreenCTM().inverse());
                   const svgP2 = pt2.matrixTransform(svg.getScreenCTM().inverse());
                   const dx = svgP2.x - svgP1.x, dy = svgP2.y - svgP1.y;
                   if (corner.dx < 0) { rect.x = origX + dx; rect.width = origW - dx; }
                   else { rect.width = origW + dx; }
                   if (corner.dy < 0) { rect.y = origY + dy; rect.height = origH - dy; }
                   else { rect.height = origH + dy; }
                   if (rect.width < 20) rect.width = 20;
                   if (rect.height < 20) rect.height = 20;
                   forgeTheTopology();
                 };
                 const upHandler = () => { dragging = false; document.removeEventListener("mousemove", moveHandler); document.removeEventListener("mouseup", upHandler); };
                 document.addEventListener("mousemove", moveHandler);
                 document.addEventListener("mouseup", upHandler);
               });
               g.appendChild(handle);
             });
           }
           if (rect.groupId) {
             const groupIndicator = document.createElementNS(ns, "rect");
             groupIndicator.setAttribute("x", rect.x - 4);
             groupIndicator.setAttribute("y", rect.y - 4);
             groupIndicator.setAttribute("width", rect.width + 8);
             groupIndicator.setAttribute("height", rect.height + 8);
             groupIndicator.style.fill = "none";
         groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
             groupIndicator.style.strokeWidth = "3";
             groupIndicator.style.strokeDasharray = "5,5";
             groupIndicator.style.pointerEvents = "none";
             g.insertBefore(groupIndicator, g.firstChild);
           }
           g.appendChild(rectEl);
           g.appendChild(deleteBtn);
           svg.appendChild(g);
          }
         });
        }
        
        if (TEXT_DATA && TEXT_DATA.list) {
         TEXT_DATA.list.forEach((textItem) => {
          if (currentView.mode === "rack") return;
          
          const g = document.createElementNS(ns, "g");
          g.classList.add("text-group");
          g.dataset.textId = textItem.id;
          
          if (textItem.bgEnabled) {
           const bgRect = document.createElementNS(ns, "rect");
           bgRect.classList.add("text-bg");
      
           bgRect.setAttribute("x", textItem.x - 5);
           bgRect.setAttribute("y", textItem.y - textItem.fontSize - 2);
           bgRect.setAttribute("width", 100);
           bgRect.setAttribute("height", textItem.fontSize + 10);
           bgRect.style.fill = textItem.bgColor;
           bgRect.style.opacity = "0.7";
           bgRect.style.rx = "4";
           g.appendChild(bgRect);
          }
          
          const textEl = document.createElementNS(ns, "text");
          textEl.classList.add("text-element");
          textEl.setAttribute("x", textItem.x);
          textEl.setAttribute("y", textItem.y);
          textEl.style.fill = textItem.color;
          textEl.style.fontSize = textItem.fontSize + "px";
          textEl.style.fontWeight = textItem.fontWeight;
          textEl.style.fontStyle = textItem.fontStyle;
          textEl.style.textAnchor = textItem.textAlign;
          textEl.style.textDecoration = textItem.textDecoration;
          textEl.style.opacity = textItem.opacity;
          textEl.style.cursor = "move";
          textEl.style.userSelect = "none";
          textEl.setAttribute("dominant-baseline", "middle");
          
          const lines = textItem.content.split('\n');
          if (lines.length === 1) {
           textEl.textContent = textItem.content;
          } else {
           lines.forEach((line, i) => {
            const tspan = document.createElementNS(ns, "tspan");
            tspan.textContent = line;
            tspan.setAttribute("x", textItem.x);
            tspan.setAttribute("dy", i === 0 ? 0 : textItem.fontSize * 1.2);
            textEl.appendChild(tspan);
           });
          }
          
          g.appendChild(textEl);
          
          if (textItem.bgEnabled) {
           setTimeout(() => {
            try {
             const bbox = textEl.getBBox();
             const bgRect = g.querySelector('.text-bg');
             if (bgRect && bbox) {
              bgRect.setAttribute("x", bbox.x - 5);
              bgRect.setAttribute("y", bbox.y - 2);
              bgRect.setAttribute("width", bbox.width + 10);
              bgRect.setAttribute("height", bbox.height + 4);
             }
            } catch (e) {
            }
           }, 0);
          }
          
          const deleteBtn = document.createElementNS(ns, "g");
          deleteBtn.classList.add("text-delete-btn");
          deleteBtn.style.cursor = "pointer";
          deleteBtn.style.display = textDrawMode ? "block" : "none";
          
          const deleteBg = document.createElementNS(ns, "circle");
          deleteBg.setAttribute("cx", textItem.x + 20);
          deleteBg.setAttribute("cy", textItem.y - textItem.fontSize);
          deleteBg.setAttribute("r", 12);
          deleteBg.style.fill = "#f56565";
          deleteBg.style.stroke = "white";
          deleteBg.style.strokeWidth = "2";
          
          const deleteX = document.createElementNS(ns, "text");
          deleteX.setAttribute("x", textItem.x + 20);
          deleteX.setAttribute("y", textItem.y - textItem.fontSize);
          deleteX.setAttribute("text-anchor", "middle");
          deleteX.setAttribute("dominant-baseline", "middle");
          deleteX.style.fill = "white";
          deleteX.style.fontSize = "16px";
          deleteX.style.fontWeight = "bold";
          deleteX.style.pointerEvents = "none";
          deleteX.textContent = "×";
          
          deleteBtn.appendChild(deleteBg);
          deleteBtn.appendChild(deleteX);
          
          deleteBtn.addEventListener("click", (e) => {
           e.stopPropagation();
           e.preventDefault();
           deleteText(textItem.id);
          });
          
          let isDragging = false;
          let dragStartX, dragStartY;
          let textStartX, textStartY;
          
          textEl.addEventListener("mousedown", (e) => {
      if (textDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      textStartX = textItem.x;
      textStartY = textItem.y;
      textEl.style.cursor = "grabbing";
      
      showTextPanel(textItem.id);
      
      if (selectedTexts.has(textItem.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
          
          const moveHandler = (e) => {
      if (!isDragging || textDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      
      textItem.x = textStartX + dx;
      textItem.y = textStartY + dy;
      
      if (selectedTexts.has(textItem.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       const newX = initialPositions[nodeId].x + dx;
       const newY = initialPositions[nodeId].y + dy;
       savedPositions[nodeId] = { x: newX, y: newY };
      }
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      if (textId === textItem.id) return;
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      
      forgeTheTopology();
      };
          
          const upHandler = () => {
           if (isDragging) {
            isDragging = false;
            textEl.style.cursor = "move";
           }
          };
          
          document.addEventListener("mousemove", moveHandler);
          document.addEventListener("mouseup", upHandler);
          
          let touchStartX = 0, touchStartY = 0;
          let textTouchStartX = 0, textTouchStartY = 0;
          
          textEl.addEventListener("touchstart", (e) => {
           if (textDrawMode) return;
           if (e.touches.length !== 1) return;
           
           e.preventDefault();
           e.stopPropagation();
           const touch = e.touches[0];
           isDragging = true;
           touchStartX = touch.clientX;
           touchStartY = touch.clientY;
           textTouchStartX = textItem.x;
           textTouchStartY = textItem.y;
           
           showTextPanel(textItem.id);
          }, { passive: false });
          
          textEl.addEventListener("touchmove", (e) => {
           if (!isDragging || textDrawMode) return;
           if (e.touches.length !== 1) return;
           
           e.preventDefault();
           const touch = e.touches[0];
           const svgEl = svg;
           
           const pt1 = svgEl.createSVGPoint();
           pt1.x = touchStartX;
           pt1.y = touchStartY;
           const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
           
           const pt2 = svgEl.createSVGPoint();
           pt2.x = touch.clientX;
           pt2.y = touch.clientY;
           const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
           
           const dx = svgP2.x - svgP1.x;
           const dy = svgP2.y - svgP1.y;
           
           textItem.x = textTouchStartX + dx;
           textItem.y = textTouchStartY + dy;
           
           forgeTheTopology();
          }, { passive: false });
          
          textEl.addEventListener("touchend", () => {
           if (isDragging) {
            isDragging = false;
           }
          }, { passive: false });
          
          textEl.addEventListener("contextmenu", (e) => {
           e.preventDefault();
           e.stopPropagation();
           if (selectedTexts.has(textItem.id)) {
            selectedTexts.delete(textItem.id);
           } else {
            selectedTexts.add(textItem.id);
           }
           updateAllSelections();
          });
          
          let textLastTap = 0;
          g.addEventListener("touchend", (e) => {
           const now = Date.now();
           if (now - textLastTap < 300) {
            e.preventDefault();
            if (selectedTexts.has(textItem.id)) {
             selectedTexts.delete(textItem.id);
            } else {
             selectedTexts.add(textItem.id);
            }
            updateAllSelections();
            if (navigator.vibrate) navigator.vibrate(50);
            textLastTap = 0;
           } else {
            textLastTap = now;
           }
          }, { passive: false });
          
          if (textItem.groupId) {
            const groupIndicator = document.createElementNS(ns, "rect");
            groupIndicator.setAttribute("x", textItem.x - 54);
            groupIndicator.setAttribute("y", textItem.y - 24);
            groupIndicator.setAttribute("width", 108);
            groupIndicator.setAttribute("height", 48);
            groupIndicator.setAttribute("rx", "8");
            groupIndicator.style.fill = "none";
       groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
            groupIndicator.style.strokeWidth = "3";
            groupIndicator.style.strokeDasharray = "5,5";
            groupIndicator.style.pointerEvents = "none";
            g.insertBefore(groupIndicator, g.firstChild);
          }
          g.appendChild(deleteBtn);
          svg.appendChild(g);
         });
        }
        
        
        Object.keys(NODE_DATA).forEach(nodeId => {
         updatePingIndicator(nodeId);
        });
        
        forgeTheLegend();
        updateMinimap();
       }
      
       function showEditModal(title, currentValue, onSave) {
        const modal = document.getElementById("edit-modal");
        const input = document.getElementById("modal-input");
        const titleEl = document.getElementById("modal-title");
        const saveBtn = document.getElementById("modal-save");
        const cancelBtn = document.getElementById("modal-cancel");
        titleEl.textContent = title;
        input.value = currentValue;
        modal.classList.add("active");
        input.focus();
        input.select();
        const handleSave = () => {
         if (input.value.trim()) {
          onSave(input.value.trim());
         }
         modal.classList.remove("active");
         saveBtn.removeEventListener("click", handleSave);
         cancelBtn.removeEventListener("click", handleCancel);
         input.removeEventListener("keypress", handleEnter);
        };
        const handleCancel = () => {
         modal.classList.remove("active");
         saveBtn.removeEventListener("click", handleSave);
         cancelBtn.removeEventListener("click", handleCancel);
         input.removeEventListener("keypress", handleEnter);
        };
        const handleEnter = (e) => {
         if (e.key === "Enter") handleSave();
        };
        saveBtn.addEventListener("click", handleSave);
        cancelBtn.addEventListener("click", handleCancel);
        input.addEventListener("keypress", handleEnter);
        modal.addEventListener("click", function bgHandler(e) {
         if (e.target === modal) {
          handleCancel();
          modal.removeEventListener("click", bgHandler);
         }
        });
       }
      
       function challengeTheImmortal(message, onConfirm) {
        const modal = document.getElementById("confirm-modal");
        const messageEl = document.getElementById("confirm-message");
        const deleteBtn = document.getElementById("confirm-delete");
        const cancelBtn = document.getElementById("confirm-cancel");
        messageEl.textContent = message;
        modal.classList.add("active");
        const handleConfirm = () => {
         onConfirm();
         modal.classList.remove("active");
         deleteBtn.removeEventListener("click", handleConfirm);
         cancelBtn.removeEventListener("click", handleCancel);
        };
        const handleCancel = () => {
         modal.classList.remove("active");
         deleteBtn.removeEventListener("click", handleConfirm);
         cancelBtn.removeEventListener("click", handleCancel);
        };
        deleteBtn.addEventListener("click", handleConfirm);
        cancelBtn.addEventListener("click", handleCancel);
        modal.addEventListener("click", function bgHandler(e) {
         if (e.target === modal) {
          handleCancel();
          modal.removeEventListener("click", bgHandler);
         }
        });
       }
       const pageTitleEl = document.getElementById("page-title");
       if (pageTitleEl) {
        pageTitleEl.addEventListener("click", () => {
         showEditModal("Edit Title", PAGE_STATE.title || DEFAULT_PAGE_STATE.title,
          (newTitle) => {
           PAGE_STATE.title = newTitle;
           wieldThePower();
          }, );
        });
       }
      
       function editNodeName(id) {
        if (!NODE_DATA[id]) return;
        showEditModal("Edit Name", NODE_DATA[id].name, (newName) => {
         if (!NODE_DATA[id]) return;
         NODE_DATA[id].name = newName;
         const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`, );
         if (nodeGroup) {
          const label = nodeGroup.querySelector(".node-label");
          if (label) label.textContent = newName;
         }
         if (currentNodeId === id) {
          document.getElementById("node-name").textContent = newName;
         }
        });
       }
      
       function editNodeIp(id) {
        if (!NODE_DATA[id]) return;
        showEditModal("Edit IP/Subtitle", NODE_DATA[id].ip, (newIp) => {
         if (!NODE_DATA[id]) return;
         NODE_DATA[id].ip = newIp;
         const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`, );
         if (nodeGroup) {
          const sub = nodeGroup.querySelector(".node-sub");
          if (sub) sub.textContent = newIp;
         }
         if (currentNodeId === id) {
          document.getElementById("node-ip").textContent = newIp;
         }
        });
       }
      
       function claimTheImmortal(id) {
	   if (isViewOnly()) return;
        if (!NODE_DATA[id]) return;
        currentNodeId = id;
        currentEdgeId = null;
        currentRectId = null;
        currentTextId = null;
        const data = NODE_DATA[id];
        document.querySelectorAll(".node-group").forEach((n) => {
         n.classList.toggle("active", n.dataset.nodeId === id);
        });
        document.querySelectorAll(".edge").forEach((e) => {
        const active = e.dataset.from === id || e.dataset.to === id;
        e.classList.toggle("active", active);
       });
       document.querySelectorAll(".rect-group").forEach((r) => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach((t) => t.classList.remove("active"));
       document.getElementById("node-panel").style.display = "block";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        const toolbar = document.getElementById("topology-toolbar");
        if (!topologyToolbarCollapsed) {
         toolbar.style.display = "flex";
        }
        updateTopologyToolbarVisibility();
        document.getElementById("node-name").textContent = data.name;
        document.getElementById("node-ip").textContent = data.ip;
        document.getElementById("node-mac").textContent = data.mac || "--";
        document.getElementById("node-rack").textContent = data.rackUnit || "--";
        document.getElementById("node-uheight").textContent = (data.uHeight || "1") + "U";
        document.getElementById("node-role").textContent = data.role;
      
        populateRackDropdown();
        const assignedRackSelect = document.getElementById("node-assigned-rack");
        if (assignedRackSelect) {
         assignedRackSelect.value = data.assignedRack || "";
        }
        
        const rackCapacitySelect = document.getElementById("node-rack-capacity");
        if (rackCapacitySelect) {
         rackCapacitySelect.value = data.rackCapacity || "42";
        }
        
        const isRack = data.isRack === true;
        const isAssignedToRack = !!data.assignedRack;
        const assignedRackRow = document.getElementById("assigned-rack-row");
        const rackCapacityRow = document.getElementById("rack-capacity-row");
        const uheightRow = document.getElementById("uheight-row");
        if (assignedRackRow) assignedRackRow.style.display = isRack ? "none" : "flex";
        if (rackCapacityRow) rackCapacityRow.style.display = isRack ? "flex" : "none";
        if (uheightRow) uheightRow.style.display = isAssignedToRack ? "flex" : "none";
		const delBtn = document.getElementById("delete-node-btn");
        if (delBtn) delBtn.textContent = isRack ? "Delete Rack" : "Delete Node";	
		const rackContentsSection = document.getElementById("rack-contents-section");
        const rackContentsList = document.getElementById("rack-contents-list");
        const rackContentsCount = document.getElementById("rack-contents-count");
        if (rackContentsSection && rackContentsList) {
        if (isRack) {
         const nodesInRack = Object.entries(NODE_DATA).filter(([nid, n]) => n.assignedRack === id);
         rackContentsCount.textContent = nodesInRack.length;
         if (nodesInRack.length > 0) {
          rackContentsList.innerHTML = nodesInRack.map(([nid, n]) => {
           const tags = (n.tags || []).map(t => `<span style="background: var(--accent); color: var(--bg); padding: 2px 6px; border-radius: 4px; font-size: 11px; margin-left: 4px;">${t}</span>`).join('');
           return `<div style="padding: 8px 4px; border-bottom: 1px solid var(--edge-main); cursor: pointer;" onclick="claimTheImmortal('${nid}')">
            <span style="color: var(--text-main);">${n.name}</span>${tags}
           </div>`;
          }).join('');
         } else {
          rackContentsList.innerHTML = '<div style="color: var(--text-soft); font-style: italic; padding: 8px 4px;">No nodes assigned</div>';
         }
         rackContentsSection.style.display = "block";
         } else {
         rackContentsSection.style.display = "none";
         }
        }    
        document.getElementById("node-name").onclick = () => editNodeName(id);
        document.getElementById("node-ip").onclick = () => editNodeIp(id);
        document.getElementById("node-mac").onclick = () => editNodeMac(id);
        document.getElementById("node-rack").onclick = () => editNodeRack(id);
        document.getElementById("node-uheight").onclick = () => editNodeUHeight(id);
        const currentSize = savedSizes[id] || getDefaultSize();
        document.getElementById("size-slider").value = currentSize;
        document.getElementById("size-value").textContent = currentSize;
        const styleEntry = savedStyles[id] || {};
        const resolvedStyles = resolveStylesEntry(styleEntry);
        const scopeKey = currentStyleScope || "all";
        const flatProps = ["circleColor", "circleBorder", "titleColor", "titleFont", "titleSize", "subColor", "subFont", "subSize", ];
        const isFlat = flatProps.some((p) => Object.prototype.hasOwnProperty.call(styleEntry, p), );
        const scopedStyles = isFlat ? styleEntry : styleEntry[scopeKey] || {};
        const circleColorInput = document.getElementById("circle-color");
        const titleColorInput = document.getElementById("title-color");
        const titleFontSelect = document.getElementById("title-font");
        const titleSizeInput = document.getElementById("title-size");
        const subColorInput = document.getElementById("sub-color");
        const subFontSelect = document.getElementById("sub-font");
        const subSizeInput = document.getElementById("sub-size");
        const shapeSelect = document.getElementById("shape-select");
        const scopeSelect = document.getElementById("style-scope");
        circleColorInput.value = scopedStyles.circleColor || resolvedStyles.circleColor || PAGE_STATE.nodeFill || "#1e293b";
       const circleBorderInput = document.getElementById("circle-border");
       circleBorderInput.value = scopedStyles.circleBorder || resolvedStyles.circleBorder || PAGE_STATE.nodeStroke || "#475569";
        titleColorInput.value = scopedStyles.titleColor || resolvedStyles.titleColor || PAGE_STATE.textMain || "#e2e8f0";
        titleFontSelect.value = scopedStyles.titleFont || resolvedStyles.titleFont || "system-ui, sans-serif";
        titleSizeInput.value = scopedStyles.titleSize || resolvedStyles.titleSize || 18;
        subColorInput.value = scopedStyles.subColor || resolvedStyles.subColor || PAGE_STATE.textSoft || "#94a3b8";
        subFontSelect.value = scopedStyles.subFont || resolvedStyles.subFont || "system-ui, sans-serif";
        subSizeInput.value = scopedStyles.subSize || resolvedStyles.subSize || 13;
        const hasWebIcon = resolvedStyles.icon && resolvedStyles.icon.library;
        const customOpt = shapeSelect.querySelector('option[value="custom-icon"]');
        if (hasWebIcon) {
         if (!customOpt) {
          const opt = document.createElement('option');
          opt.value = 'custom-icon';
          opt.textContent = 'Custom Icon';
          shapeSelect.insertBefore(opt, shapeSelect.firstChild);
         }
         shapeSelect.value = 'custom-icon';
        } else {
         if (customOpt) customOpt.remove();
         shapeSelect.value = data.shape || "circle";
        }
        const layerSelect = document.getElementById("node-layer");
        if (layerSelect) {
         layerSelect.value = data.layer || "physical";
        }
        scopeSelect.value = currentStyleScope || "all";
        document.getElementById("title-offset-y").value = scopedStyles.titleOffsetY || resolvedStyles.titleOffsetY || 0;
        document.getElementById("title-offset-x").value = scopedStyles.titleOffsetX || resolvedStyles.titleOffsetX || 0;
        document.getElementById("sub-offset-y").value = scopedStyles.subOffsetY || resolvedStyles.subOffsetY || 0;
        document.getElementById("sub-offset-x").value = scopedStyles.subOffsetX || resolvedStyles.subOffsetX || 0;
      
      const pingOffsetXInput = document.getElementById("ping-offset-x");
      const pingOffsetYInput = document.getElementById("ping-offset-y");
      
      if (pingOffsetXInput && pingOffsetYInput) {
      pingOffsetXInput.value =
       (scopedStyles.pingOffsetX !== undefined
         ? scopedStyles.pingOffsetX
         : (resolvedStyles.pingOffsetX !== undefined
             ? resolvedStyles.pingOffsetX
             : 0));
      
      pingOffsetYInput.value =
       (scopedStyles.pingOffsetY !== undefined
         ? scopedStyles.pingOffsetY
         : (resolvedStyles.pingOffsetY !== undefined
             ? resolvedStyles.pingOffsetY
             : 0));
      }
        const tagEl = document.getElementById("node-tags");
        tagEl.innerHTML = "";
        data.tags.forEach((tag, i) => {
         const b = document.createElement("span");
         b.className = "badge";
         const isIconTag = typeof tag === 'object' && tag.type === 'icon';
         if (!isIconTag && typeof tag === 'string' && tag.toLowerCase().includes("wg")) b.classList.add("wg");
         b.style.cursor = "pointer";
         b.style.position = "relative";
         const tagContent = document.createElement("span");
         if (isIconTag) {
          b.classList.add("icon-badge");
          IconLibrary.getIcon(tag.library, tag.name).then(svgText => {
           if (svgText) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(svgText, 'image/svg+xml');
            const svgEl = doc.querySelector('svg');
            if (svgEl) {
             svgEl.setAttribute('width', '16');
             svgEl.setAttribute('height', '16');
             tagContent.innerHTML = '';
             tagContent.appendChild(svgEl);
             const nameSpan = document.createElement('span');
             nameSpan.textContent = tag.name;
             nameSpan.style.marginLeft = '4px';
             tagContent.appendChild(nameSpan);
            }
           }
          });
         } else {
          tagContent.textContent = tag;
          tagContent.addEventListener("click", (e) => {
           e.stopPropagation();
           showEditModal("Edit Tag", tag, (newTag) => {
            if (newTag) {
             data.tags[i] = newTag;
             claimTheImmortal(id);
            }
           });
          });
         }
         const deleteTag = document.createElement("span");
         deleteTag.textContent = " ✕";
         deleteTag.style.opacity = "0.6";
         deleteTag.style.marginLeft = "4px";
         deleteTag.style.fontSize = "10px";
         deleteTag.addEventListener("click", (e) => {
          e.stopPropagation();
          data.tags.splice(i, 1);
          claimTheImmortal(id);
         });
         b.append(tagContent, deleteTag);
         tagEl.append(b);
        });
        const addTagBtn = document.createElement("span");
        addTagBtn.className = "badge";
        addTagBtn.style.cursor = "pointer";
        addTagBtn.style.opacity = "0.6";
        addTagBtn.style.borderStyle = "dashed";
        addTagBtn.textContent = "+ Add Tag";
        addTagBtn.addEventListener("click", () => {
         showEditModal("Add Tag(s) : comma separated", "",
          (newTagStr) => {
           if (newTagStr) {
            const newTags = newTagStr.split(",").map((t) => t.trim()).filter((t) => t);
            newTags.forEach((t) => data.tags.push(t));
            claimTheImmortal(id);
           }
          }, );
        });
        tagEl.append(addTagBtn);
        const notesEl = document.getElementById("node-notes");
        notesEl.innerHTML = "";
        data.notes.forEach((note, i) => {
         const li = document.createElement("li");
         const noteText = document.createElement("span");
         noteText.textContent = note;
         noteText.style.flex = "1";
         const deleteBtn = document.createElement("span");
         deleteBtn.className = "delete-note";
         deleteBtn.textContent = "✕";
         deleteBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          challengeTheImmortal("Are you sure you want to delete this note?",
           () => {
            data.notes.splice(i, 1);
            claimTheImmortal(id);
           }, );
         });
         li.append(noteText, deleteBtn);
         noteText.addEventListener("dblclick", () => {
          noteText.classList.add("editing");
          noteText.contentEditable = true;
          noteText.focus();
         });
         noteText.addEventListener("blur", () => {
          noteText.classList.remove("editing");
          noteText.contentEditable = false;
          data.notes[i] = noteText.textContent;
         });
         notesEl.append(li);
        });
        const addLineSelect = document.getElementById("add-line-select");
      addLineSelect.innerHTML = "";
      const currentRack = data.assignedRack || "";
      Object.entries(NODE_DATA).forEach(([nodeId, node]) => {
      if (nodeId !== id) {
      const nodeRack = node.assignedRack || "";
      if (currentRack === nodeRack) {
      const opt = document.createElement("option");
      opt.value = nodeId;
      opt.textContent = node.name;
      addLineSelect.appendChild(opt);
      }
      }
      });
        
        const pingEnabled = data.ping && data.ping.enabled;
        document.getElementById('node-pingable').checked = pingEnabled;
        document.getElementById('node-ping-options').style.display = pingEnabled ? 'block' : 'none';
        
        if (data.ping) {
         document.getElementById('node-ping-protocol').value = data.ping.protocol || 'http';
         document.getElementById('node-custom-url').value = data.ping.customUrl || '';
         document.getElementById('node-ping-timeout').value = data.ping.timeout || 3000;
         document.getElementById('node-custom-url-container').style.display = 
          data.ping.protocol === 'custom' ? 'block' : 'none';
         
         updatePingStatusDisplay(id);
        }
       }
      
       function updatePingStatusDisplay(nodeId) {
        const data = NODE_DATA[nodeId];
        if (!data || !data.ping) return;
        
        const statusEl = document.getElementById('node-ping-status');
        const lastCheckEl = document.getElementById('node-ping-last-check');
        
        const statusColors = {
         online: 'var(--accent)',
         offline: 'var(--danger)',
         checking: '#f59e0b',
         unknown: 'var(--text-soft)'
        };
        
        const statusTexts = {
         online: '● Online',
         offline: '● Offline',
         checking: '● Checking...',
         unknown: '● Unknown'
        };
        
        statusEl.textContent = statusTexts[data.ping.status] || statusTexts.unknown;
        statusEl.style.color = statusColors[data.ping.status] || statusColors.unknown;
        
        if (data.ping.lastCheck) {
         const checkTime = new Date(data.ping.lastCheck);
         lastCheckEl.textContent = `Last checked: ${checkTime.toLocaleTimeString()}`;
        } else {
         lastCheckEl.textContent = 'Never checked';
        }
       }
      
       function selectTheConnection(id) {
	   if (isViewOnly()) return;
        currentEdgeId = id;
        currentNodeId = null;
        currentRectId = null;
        currentTextId = null;
		
		if (isMobileDevice()) {
        const currentHeight = PAGE_STATE.mobileFooterHeight || 40;
        if (currentHeight <= 20) {
         PAGE_STATE.mobileFooterHeight = 80;
         const root = document.documentElement;
         root.style.setProperty("--mobile-footer-height", "80vh");
         const mobileFooterHeightInput = document.getElementById("mobile-footer-height");
         const mobileFooterHeightVal = document.getElementById("mobile-footer-height-val");
         if (mobileFooterHeightInput) mobileFooterHeightInput.value = 80;
         if (mobileFooterHeightVal) mobileFooterHeightVal.textContent = "80%";
        }
       }
	   
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "block";
        document.getElementById("text-panel").style.display = "none";
       document.getElementById("rect-panel").style.display = "none";
       document.getElementById("topology-toolbar").style.display = "none";
       document.querySelectorAll(".node-group").forEach((n) => n.classList.remove("active"));
       document.querySelectorAll(".rect-group").forEach((r) => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach((t) => t.classList.remove("active"));
       document.querySelectorAll(".edge").forEach((e) => {
        e.classList.toggle("active", e.dataset.edgeId === id);
       });
        const edge = EDGE_DATA.list.find((e) => e.id === id);
        if (!edge) return;
        const directionSymbols = {
         none: "⇄",
         forward: "→",
         backward: "←",
         both: "↔",
        };
        const dirSymbol = directionSymbols[edge.direction] || "⇄";
        let titleText = "Custom line";
        if (edge.from || edge.to) {
         const fromName = edge.from ? NODE_DATA[edge.from]?.name || edge.from : "";
         const toName = edge.to ? NODE_DATA[edge.to]?.name || edge.to : "";
         titleText = `${fromName || "?"} ${dirSymbol} ${toName || "?"}`;
        }
        document.getElementById("edge-title").textContent = titleText;
        const widthInput = document.getElementById("edge-width");
        const colorInput = document.getElementById("edge-color");
        const directionSelect = document.getElementById("edge-direction");
        const lineStyleSelect = document.getElementById("edge-line-style");
        widthInput.value = edge.width;
        colorInput.value = edge.color;
        directionSelect.value = edge.direction || "none";
        lineStyleSelect.value = edge.lineStyle || "solid";
        
        const fromPortInput = document.getElementById("edge-from-port");
        const toPortInput = document.getElementById("edge-to-port");
        const portFieldsFrom = document.getElementById("edge-port-fields");
        const portFieldsTo = document.getElementById("edge-port-fields-to");
        
        if (edge.type === "custom") {
         if (portFieldsFrom) portFieldsFrom.style.display = "none";
         if (portFieldsTo) portFieldsTo.style.display = "none";
        } else {
         if (portFieldsFrom) portFieldsFrom.style.display = "flex";
         if (portFieldsTo) portFieldsTo.style.display = "flex";
         if (fromPortInput) {
          fromPortInput.value = edge.fromPort || "";
          fromPortInput.onchange = () => updateEdgePortLabels(id);
         }
         if (toPortInput) {
          toPortInput.value = edge.toPort || "";
          toPortInput.onchange = () => updateEdgePortLabels(id);
         }
        }
        
        const list = document.getElementById("edge-notes");
        list.innerHTML = "";
        edge.notes.forEach((note, i) => {
         const li = document.createElement("li");
         const txt = document.createElement("span");
         txt.textContent = note;
         txt.style.flex = "1";
         const del = document.createElement("span");
         del.className = "delete-note";
         del.textContent = "✕";
         del.addEventListener("click", (e) => {
          e.stopPropagation();
          challengeTheImmortal("Delete this line note?", () => {
           edge.notes.splice(i, 1);
          
           selectTheConnection(id);
          });
         });
         txt.addEventListener("dblclick", () => {
          txt.classList.add("editing");
          txt.contentEditable = true;
          txt.focus();
         });
         txt.addEventListener("blur", () => {
          txt.classList.remove("editing");
          txt.contentEditable = false;
          edge.notes[i] = txt.textContent;
         
         });
         li.append(txt, del);
         list.appendChild(li);
       });
       
       if (edge.type === "custom" && Array.isArray(edge.points)) {
        forgeTheTopology();
       }
      }
       window.addEventListener("resize", () => {
        forgeTheTopology();
        if (currentEdgeId) {
         selectTheConnection(currentEdgeId);
        } else if (currentNodeId && NODE_DATA[currentNodeId]) {
         claimTheImmortal(currentNodeId);
        } else {
         const availableNodes = Object.keys(NODE_DATA);
         if (availableNodes.length > 0) {
          claimTheImmortal(availableNodes[0]);
         }
        }
       });
       (function initZoomPan() {
        const viewport = document.getElementById("canvas-viewport");
        const svg = document.getElementById("map");
        const hint = document.getElementById("canvas-hint");
        setTimeout(() => {
         hint.classList.add("visible");
         setTimeout(() => hint.classList.remove("visible"), 4000);
        }, 1000);
        viewport.addEventListener("wheel",
         (e) => {
          e.preventDefault();
          const rect = viewport.getBoundingClientRect();
          const mouseX = (e.clientX - rect.left) / rect.width;
          const mouseY = (e.clientY - rect.top) / rect.height;
          const delta = e.deltaY > 0 ? 0.9 : 1.1;
          zoomTo(canvasState.zoom * delta, mouseX, mouseY);
         }, {
          passive: false
         }, );
        let initialPinchDistance = 0;
        let initialPinchZoom = 1;
        let pinchCenter = {
         x: 0.5,
         y: 0.5
        };
        viewport.addEventListener("touchstart",
         (e) => {
          if (e.touches.length === 2) {
           e.preventDefault();
           const touch1 = e.touches[0];
           const touch2 = e.touches[1];
           initialPinchDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY, );
           initialPinchZoom = canvasState.zoom;
           const rect = viewport.getBoundingClientRect();
           const centerX = (touch1.clientX + touch2.clientX) / 2;
           const centerY = (touch1.clientY + touch2.clientY) / 2;
           pinchCenter.x = (centerX - rect.left) / rect.width;
           pinchCenter.y = (centerY - rect.top) / rect.height;
          }
         }, {
          passive: false
         }, );
        viewport.addEventListener("touchmove",
         (e) => {
          if (e.touches.length === 2) {
           e.preventDefault();
           const touch1 = e.touches[0];
           const touch2 = e.touches[1];
           const currentDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY, );
           if (initialPinchDistance > 0) {
            const scale = currentDistance / initialPinchDistance;
            const newZoom = initialPinchZoom * scale;
            zoomTo(newZoom, pinchCenter.x, pinchCenter.y);
           }
          }
         }, {
          passive: false
         }, );
        let panStartViewX = 0;
        let panStartViewY = 0;
        
        let lastEmptyTapTime = 0;
        let emptyTapTimeout = null;
        let emptyTapMoved = false;
        let emptyTapStartX = 0;
        let emptyTapStartY = 0;
        
        viewport.addEventListener("touchend", (e) => {
          if (currentView.mode !== "rack") return;
          
          if (e.changedTouches.length !== 1) return;
          
      const isNodeOrEdge = e.target.closest(".node-group") || e.target.closest(".edge-group");
         if (isNodeOrEdge) return;
          
          if (emptyTapMoved) {
            emptyTapMoved = false;
            return;
          }
          
          const currentTime = new Date().getTime();
          const tapGap = currentTime - lastEmptyTapTime;
          
          if (tapGap < 300 && tapGap > 0) {
            e.preventDefault();
            
            exitRack();
            
            if (navigator.vibrate) {
              navigator.vibrate(50);
            }
            
            lastEmptyTapTime = 0;
            if (emptyTapTimeout) {
              clearTimeout(emptyTapTimeout);
              emptyTapTimeout = null;
            }
          } else {
            lastEmptyTapTime = currentTime;
            
            if (emptyTapTimeout) clearTimeout(emptyTapTimeout);
            emptyTapTimeout = setTimeout(() => {
              lastEmptyTapTime = 0;
            }, 300);
          }
        }, { passive: false });
        
        viewport.addEventListener("mousedown", (e) => {
         if (e.target.closest(".draw-toolbar") || e.target.closest(".topology-toolbar") || e.target.closest(".legend-container")) {
          return;
         }
         if (freeDrawMode || rectDrawMode) {
          return;
         }
      const isEmptySpace = e.target === svg || e.target === viewport || e.target.tagName === "svg";
      const isEdgeElement = e.target.closest('.edge') || e.target.classList.contains('edge-edit-point');
      const isTextElement = e.target.closest('.text-group') || e.target.closest('.text-element');
      const isRectElement = e.target.closest('.rect-group');
      if (!isEdgeElement && !isTextElement && !isRectElement && currentEdgeId) {
      currentEdgeId = null;
      forgeTheTopology();
      }
      if (!isRectElement && currentRectId) {
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      }
         if (isViewOnly()) {
         document.body.classList.remove("view-only-inspect");
         document.getElementById("node-panel").style.display = "none";
         document.getElementById("edge-panel").style.display = "none";
        }
         if (isEmptySpace && e.shiftKey && e.button === 0) {
         if (isViewOnly()) return;
         e.preventDefault();
         startSelection(e);
         return;
        }
        if (isEmptySpace || e.button === 2 || e.button === 1) {
          e.preventDefault();
          canvasState.isPanning = true;
          canvasState.panStartX = e.clientX;
          canvasState.panStartY = e.clientY;
          panStartViewX = canvasState.panX;
          panStartViewY = canvasState.panY;
          viewport.classList.add("panning");
         }
        });
        viewport.addEventListener("touchstart",
         (e) => {
          if (e.target.closest(".draw-toolbar") || e.target.closest(".topology-toolbar") || e.target.closest(".legend-container")) {
           return;
          }
          if (freeDrawMode || rectDrawMode) {
           return;
          }
      const isEmptySpace = e.target === svg || e.target === viewport || e.target.tagName === "svg";
      const isEdgeElement = e.target.closest('.edge') || e.target.classList.contains('edge-edit-point');
      const isTextElement = e.target.closest('.text-group') || e.target.closest('.text-element');
      const isRectElement = e.target.closest('.rect-group');
      if (!isEdgeElement && !isTextElement && !isRectElement && currentEdgeId) {
      currentEdgeId = null;
      forgeTheTopology();
      }
      if (!isRectElement && currentRectId) {
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      }
          if (isEmptySpace && e.touches.length === 1) {
           e.preventDefault();
           emptyTapMoved = false;
           emptyTapStartX = e.touches[0].clientX;
           emptyTapStartY = e.touches[0].clientY;
           canvasState.isPanning = true;
           canvasState.panStartX = e.touches[0].clientX;
           canvasState.panStartY = e.touches[0].clientY;
           panStartViewX = canvasState.panX;
           panStartViewY = canvasState.panY;
           viewport.classList.add("panning");
          }
         }, {
          passive: false
         }, );
        document.addEventListener("mousemove", (e) => {
         if (isSelecting) {
          updateSelection(e);
          return;
         }
         if (!canvasState.isPanning) return;
         const dx = e.clientX - canvasState.panStartX;
         const dy = e.clientY - canvasState.panStartY;
         const rect = viewport.getBoundingClientRect();
         const viewWidth = CANVAS_WIDTH / canvasState.zoom;
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         const canvasDx = (dx / rect.width) * viewWidth;
         const canvasDy = (dy / rect.height) * viewHeight;
         canvasState.panX = panStartViewX - canvasDx;
         canvasState.panY = panStartViewY - canvasDy;
         constrainPan();
         updateViewBox();
        });
       document.addEventListener("touchmove", (e) => {
        if (!canvasState.isPanning || !e.touches[0]) return;
        const moveDx = Math.abs(e.touches[0].clientX - emptyTapStartX);
        const moveDy = Math.abs(e.touches[0].clientY - emptyTapStartY);
        if (moveDx > 15 || moveDy > 15) {
         emptyTapMoved = true;
        }
        const dx = e.touches[0].clientX - canvasState.panStartX;
         const dy = e.touches[0].clientY - canvasState.panStartY;
         const rect = viewport.getBoundingClientRect();
         const viewWidth = CANVAS_WIDTH / canvasState.zoom;
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         const canvasDx = (dx / rect.width) * viewWidth;
         const canvasDy = (dy / rect.height) * viewHeight;
         canvasState.panX = panStartViewX - canvasDx;
         canvasState.panY = panStartViewY - canvasDy;
         constrainPan();
         updateViewBox();
        });
        document.addEventListener("mouseup", () => {
         if (isSelecting) {
          endSelection();
         }
         if (canvasState.isPanning) {
          canvasState.isPanning = false;
          viewport.classList.remove("panning");
         }
        });
        document.addEventListener("touchend", () => {
         if (canvasState.isPanning) {
          canvasState.isPanning = false;
          viewport.classList.remove("panning");
         }
        });
        document.addEventListener("keydown", (e) => {
         const isEditing = document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "TEXTAREA" || document.activeElement.isContentEditable;
         if (e.code === "Space" && !e.repeat && !isEditing) {
          e.preventDefault();
          canvasState.spacePressed = true;
          viewport.style.cursor = "grab";
         }
        });
        document.addEventListener("keyup", (e) => {
         if (e.code === "Space") {
          canvasState.spacePressed = false;
          viewport.style.cursor = "";
         }
        });
        document.getElementById("zoom-in-btn").addEventListener("click", () => {
         zoomTo(canvasState.zoom * 1.25, 0.5, 0.5);
        });
        document.getElementById("zoom-out-btn").addEventListener("click", () => {
         zoomTo(canvasState.zoom * 0.8, 0.5, 0.5);
        });
        document.getElementById("zoom-fit-btn").addEventListener("click", fitToContent);
        document.getElementById("zoom-reset-btn").addEventListener("click", resetView);
        const minimapContainer = document.getElementById("minimap-container");
        const minimapSvg = document.getElementById("minimap");
        let minimapDragging = false;
        minimapContainer.addEventListener("mousedown", (e) => {
         e.preventDefault();
         minimapDragging = true;
         updatePanFromMinimap(e);
        });
        minimapContainer.addEventListener("touchstart",
         (e) => {
          e.preventDefault();
          minimapDragging = true;
          updatePanFromMinimapTouch(e);
         }, {
          passive: false
         }, );
        document.addEventListener("mousemove", (e) => {
         if (minimapDragging) {
          updatePanFromMinimap(e);
         }
        });
        document.addEventListener("touchmove", (e) => {
         if (minimapDragging && e.touches[0]) {
          updatePanFromMinimapTouch(e);
         }
        });
        document.addEventListener("mouseup", () => {
         minimapDragging = false;
        });
        document.addEventListener("touchend", () => {
         minimapDragging = false;
        });
      
        function updatePanFromMinimap(e) {
         const rect = minimapContainer.getBoundingClientRect();
         const x = (e.clientX - rect.left) / rect.width;
         const y = (e.clientY - rect.top) / rect.height;
         const viewWidth = CANVAS_WIDTH / canvasState.zoom;
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         canvasState.panX = x * CANVAS_WIDTH - viewWidth / 2;
         canvasState.panY = y * CANVAS_HEIGHT - viewHeight / 2;
         constrainPan();
         updateViewBox();
        }
      
        function updatePanFromMinimapTouch(e) {
         const rect = minimapContainer.getBoundingClientRect();
         const touch = e.touches[0];
         const x = (touch.clientX - rect.left) / rect.width;
         const y = (touch.clientY - rect.top) / rect.height;
         const viewWidth = CANVAS_WIDTH / canvasState.zoom;
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         canvasState.panX = x * CANVAS_WIDTH - viewWidth / 2;
         canvasState.panY = y * CANVAS_HEIGHT - viewHeight / 2;
         constrainPan();
         updateViewBox();
        }
        document.addEventListener("keydown", (e) => {
         if (document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "TEXTAREA") return;
         if (
          (e.key === "+" || e.key === "=") && (e.ctrlKey || e.metaKey)) {
          e.preventDefault();
          zoomTo(canvasState.zoom * 1.25, 0.5, 0.5);
         } else if (e.key === "-" && (e.ctrlKey || e.metaKey)) {
          e.preventDefault();
          zoomTo(canvasState.zoom * 0.8, 0.5, 0.5);
         } else if (e.key === "0" && (e.ctrlKey || e.metaKey)) {
          e.preventDefault();
          resetView();
         }
        });
        setTimeout(() => {
         fitToContent();
        }, 100);
       })();
       const sizeSlider = document.getElementById("size-slider");
       const sizeValue = document.getElementById("size-value");
       const resetSizeBtn = document.getElementById("reset-size");
       sizeSlider.addEventListener("input", () => {
        const newSize = parseInt(sizeSlider.value, 10);
        sizeValue.textContent = newSize;
        savedSizes[currentNodeId] = newSize;
        const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
        if (nodeGroup) {
         const oldShape = nodeGroup.querySelector(".node-circle");
         if (oldShape) oldShape.remove();
         const newShape = createNodeShape(currentNodeId, newSize);
         nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
         const styles = resolveStylesForNode(currentNodeId);
         if (styles.circleColor) newShape.style.fill = styles.circleColor;
      if (styles.circleBorder) newShape.style.stroke = styles.circleBorder;
         const label = nodeGroup.querySelector(".node-label");
         const sub = nodeGroup.querySelector(".node-sub");
         if (label) {
          label.setAttribute("y", -newSize * 0.28);
          const labelSize = styles.titleSize || newSize * 0.33;
          label.style.fontSize = labelSize + "px";
         }
         if (sub) {
          sub.setAttribute("y", newSize * 0.4);
          const subSize = styles.subSize || newSize * 0.24;
          sub.style.fontSize = subSize + "px";
         }
       updatePingIndicator(currentNodeId);
        }
       });
       resetSizeBtn.addEventListener("click", () => {
        delete savedSizes[currentNodeId];
        const defaultSize = getDefaultSize();
        sizeSlider.value = defaultSize;
        sizeValue.textContent = defaultSize;
        const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
        if (nodeGroup) {
         const oldShape = nodeGroup.querySelector(".node-circle");
         if (oldShape) oldShape.remove();
         const shapeType = (NODE_DATA[currentNodeId] && NODE_DATA[currentNodeId].shape) || "circle";
         const newShape = createNodeShape(currentNodeId, defaultSize);
         nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
         const styles = resolveStylesForNode(currentNodeId);
         if (styles.circleColor) newShape.style.fill = styles.circleColor;
      if (styles.circleBorder) newShape.style.stroke = styles.circleBorder;
         const label = nodeGroup.querySelector(".node-label");
         const sub = nodeGroup.querySelector(".node-sub");
         if (label) {
          label.setAttribute("y", -defaultSize * 0.28);
          const labelSize = styles.titleSize || defaultSize * 0.33;
          label.style.fontSize = labelSize + "px";
         }
         if (sub) {
          sub.setAttribute("y", defaultSize * 0.4);
          const subSize = styles.subSize || defaultSize * 0.24;
          sub.style.fontSize = subSize + "px";
         }
          updatePingIndicator(currentNodeId);
      
        }
       });
       const applyStyle = (property, value) => {
        const styleEntry = ensureStyleEntry(currentNodeId);
        const scopeKey = currentStyleScope || "all";
        if (!styleEntry[scopeKey]) styleEntry[scopeKey] = {};
        styleEntry[scopeKey][property] = value;
        const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
        if (!nodeGroup) return;
        const shapeEl = nodeGroup.querySelector(".node-circle");
        const label = nodeGroup.querySelector(".node-label");
        const sub = nodeGroup.querySelector(".node-sub");
        const isWebIcon = shapeEl && shapeEl.querySelector('svg');
        if (property === "circleColor" && shapeEl) {
         if (isWebIcon) {
          shapeEl.querySelectorAll('svg, path, circle, rect, polygon, ellipse').forEach(el => el.style.fill = value);
         } else {
          shapeEl.style.fill = value;
         }
        } else if (property === "circleBorder" && shapeEl) {
         if (isWebIcon) {
          shapeEl.querySelectorAll('svg, path, circle, rect, polygon, ellipse').forEach(el => el.style.stroke = value);
         } else {
          shapeEl.style.stroke = value;
         }
        } else if (property === "titleColor" && label) label.style.fill = value;
        else if (property === "titleFont" && label) label.style.fontFamily = value;
        else if (property === "titleSize" && label) label.style.fontSize = value + "px";
        else if (property === "subColor" && sub) sub.style.fill = value;
        else if (property === "subFont" && sub) sub.style.fontFamily = value;
        else if (property === "subSize" && sub) sub.style.fontSize = value + "px";
       };
       document.getElementById("circle-color").addEventListener("input", (e) => applyStyle("circleColor", e.target.value), );
      document.getElementById("circle-border").addEventListener("input", (e) => applyStyle("circleBorder", e.target.value), );
       document.getElementById("title-color").addEventListener("input", (e) => applyStyle("titleColor", e.target.value), );
       document.getElementById("title-font").addEventListener("change", (e) => applyStyle("titleFont", e.target.value), );
       document.getElementById("title-size").addEventListener("input", (e) => applyStyle("titleSize", parseInt(e.target.value, 10)), );
       document.getElementById("sub-color").addEventListener("input", (e) => applyStyle("subColor", e.target.value), );
       document.getElementById("sub-font").addEventListener("change", (e) => applyStyle("subFont", e.target.value), );
       document.getElementById("sub-size").addEventListener("input", (e) => applyStyle("subSize", parseInt(e.target.value, 10)), );
       document.getElementById("title-offset-y").addEventListener("input", (e) => {
        applyStyle("titleOffsetY", parseInt(e.target.value, 10) || 0);
        forgeTheTopology();
        if (currentNodeId) claimTheImmortal(currentNodeId);
       });
       document.getElementById("title-offset-x").addEventListener("input", (e) => {
        applyStyle("titleOffsetX", parseInt(e.target.value, 10) || 0);
        forgeTheTopology();
        if (currentNodeId) claimTheImmortal(currentNodeId);
       });
       document.getElementById("sub-offset-y").addEventListener("input", (e) => {
        applyStyle("subOffsetY", parseInt(e.target.value, 10) || 0);
        forgeTheTopology();
        if (currentNodeId) claimTheImmortal(currentNodeId);
       });
       document.getElementById("sub-offset-x").addEventListener("input", (e) => {
        applyStyle("subOffsetX", parseInt(e.target.value, 10) || 0);
        forgeTheTopology();
        if (currentNodeId) claimTheImmortal(currentNodeId);
       });
      document.getElementById("ping-offset-x").addEventListener("input", (e) => {
      applyStyle("pingOffsetX", parseInt(e.target.value, 10) || 0);
      updatePingIndicator(currentNodeId);
      if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      
      document.getElementById("ping-offset-y").addEventListener("input", (e) => {
      applyStyle("pingOffsetY", parseInt(e.target.value, 10) || 0);
      updatePingIndicator(currentNodeId);
      if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      
       document.getElementById("reset-styles").addEventListener("click", () => {
        delete savedStyles[currentNodeId];
        forgeTheTopology();
        claimTheImmortal(currentNodeId);
       });
       document.getElementById("style-scope").addEventListener("change", (e) => {
        currentStyleScope = e.target.value || "all";
        claimTheImmortal(currentNodeId);
       });
       document.getElementById("shape-select").addEventListener("change", (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId]) return;
        const shape = e.target.value || "circle";
        if (shape === 'custom-icon') return;
        NODE_DATA[currentNodeId].shape = shape;
        if (savedStyles[currentNodeId]) {
         Object.keys(savedStyles[currentNodeId]).forEach(scope => {
          if (savedStyles[currentNodeId][scope] && savedStyles[currentNodeId][scope].icon) {
           delete savedStyles[currentNodeId][scope].icon;
          }
         });
        }
        const customOpt = e.target.querySelector('option[value="custom-icon"]');
        if (customOpt) customOpt.remove();
        forgeTheTopology();
       });
       const addNoteBtn = document.getElementById("add-note-btn");
       const noteInput = document.getElementById("new-note-input");
       addNoteBtn.addEventListener("click", () => {
        const newNote = noteInput.value.trim();
        if (newNote && currentNodeId && NODE_DATA[currentNodeId]) {
         NODE_DATA[currentNodeId].notes.push(newNote);
         claimTheImmortal(currentNodeId);
         noteInput.value = "";
        }
       });
       noteInput.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
         addNoteBtn.click();
        }
       });
       
       document.getElementById('node-pingable').addEventListener('change', (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId]) return;
        if (!NODE_DATA[currentNodeId].ping) {
         NODE_DATA[currentNodeId].ping = {
          enabled: false,
          protocol: 'http',
          customUrl: '',
          timeout: 3000,
          status: 'unknown',
          lastCheck: null
         };
        }
        NODE_DATA[currentNodeId].ping.enabled = e.target.checked;
        document.getElementById('node-ping-options').style.display = e.target.checked ? 'block' : 'none';
        forgeTheTopology();
       });
       
       document.getElementById('node-ping-protocol').addEventListener('change', (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId].ping) return;
        NODE_DATA[currentNodeId].ping.protocol = e.target.value;
        document.getElementById('node-custom-url-container').style.display = 
         e.target.value === 'custom' ? 'block' : 'none';
       });
       
       document.getElementById('node-custom-url').addEventListener('change', (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId].ping) return;
        NODE_DATA[currentNodeId].ping.customUrl = e.target.value.trim();
       });
       
       document.getElementById('node-ping-timeout').addEventListener('change', (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId].ping) return;
        NODE_DATA[currentNodeId].ping.timeout = parseInt(e.target.value) || 3000;
       });
       
       document.getElementById('check-ping-now').addEventListener('click', () => {
        if (!currentNodeId) return;
        checkNodeStatus(currentNodeId);
       });
       
       document.getElementById("edge-width").addEventListener("input", () => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        const v = parseInt(document.getElementById("edge-width").value, 10);
        if (Number.isNaN(v) || v <= 0) return;
        edge.width = v;
       
        const el = document.querySelector(`.edge[data-edge-id="${currentEdgeId}"]`, );
        if (el) el.style.strokeWidth = v;
       });
       document.getElementById("edge-color").addEventListener("input", () => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        const color = document.getElementById("edge-color").value;
        edge.color = color;
       
        const el = document.querySelector(`.edge[data-edge-id="${currentEdgeId}"]`, );
        if (el) el.style.stroke = color;
        forgeTheLegend();
       });
       document.getElementById("edge-direction").addEventListener("change", () => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        edge.direction = document.getElementById("edge-direction").value;
       
        forgeTheTopology();
        selectTheConnection(currentEdgeId);
       });
       document.getElementById("edge-line-style").addEventListener("change", () => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        edge.lineStyle = document.getElementById("edge-line-style").value;
       
        forgeTheTopology();
        selectTheConnection(currentEdgeId);
       });
       const addEdgeNoteBtn = document.getElementById("add-edge-note");
       const newEdgeNoteInput = document.getElementById("new-edge-note");
       addEdgeNoteBtn.addEventListener("click", () => {
        const txt = newEdgeNoteInput.value.trim();
        if (!txt || !currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        edge.notes.push(txt);
       
        newEdgeNoteInput.value = "";
        selectTheConnection(currentEdgeId);
       });
       newEdgeNoteInput.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
         addEdgeNoteBtn.click();
        }
       });
	   
      function selectTheRect(id) {
	  if (isViewOnly()) return;
      currentRectId = id;
      currentNodeId = null;
      currentEdgeId = null;
      currentTextId = null;
      document.getElementById("node-panel").style.display = "none";
      document.getElementById("edge-panel").style.display = "none";
      document.getElementById("text-panel").style.display = "none";
      document.getElementById("rect-panel").style.display = "block";
      document.getElementById("topology-toolbar").style.display = "none";
      document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active"));
      document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
      document.querySelectorAll(".text-element").forEach(t => t.classList.remove("active"));
      document.querySelectorAll(".rect-group").forEach(r => r.classList.toggle("active", r.dataset.rectId === id));
      
      const rect = RECT_DATA.list.find(r => r.id === id);
      if (!rect) return;
      
      document.getElementById("rect-title").textContent = "";
      document.getElementById("rect-color").value = rect.color || "#f97316";
      document.getElementById("rect-border-color").value = rect.borderColor || rect.color || "#f97316";
      document.getElementById("rect-border-width").value = rect.borderWidth !== undefined ? rect.borderWidth : 2;
      document.getElementById("rect-style-select").value = rect.style || "filled";
      document.getElementById("rect-line-style").value = rect.lineStyle || "solid";
      document.getElementById("rect-fill-row").style.display = (rect.style === "outlined") ? "none" : "flex";
      
      const list = document.getElementById("rect-notes");
      list.innerHTML = "";
      (rect.notes || []).forEach((note, i) => {
      const li = document.createElement("li");
      const txt = document.createElement("span");
      txt.textContent = note;
      txt.style.flex = "1";
      const del = document.createElement("span");
      del.className = "delete-note";
      del.textContent = "✕";
      del.addEventListener("click", (e) => {
      e.stopPropagation();
      challengeTheImmortal("Delete this note?", () => {
        rect.notes.splice(i, 1);
        selectTheRect(id);
      });
      });
      li.appendChild(txt);
      li.appendChild(del);
      list.appendChild(li);
      });
      
      forgeTheTopology();
      }
      
      document.getElementById("rect-color").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      rect.color = document.getElementById("rect-color").value;
      forgeTheTopology();
      });
      
      document.getElementById("rect-border-color").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      rect.borderColor = document.getElementById("rect-border-color").value;
      forgeTheTopology();
      });
      
      document.getElementById("rect-border-width").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      rect.borderWidth = parseInt(document.getElementById("rect-border-width").value) || 2;
      forgeTheTopology();
      });
      
      document.getElementById("rect-style-select").addEventListener("change", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      rect.style = document.getElementById("rect-style-select").value;
      forgeTheTopology();
      selectTheRect(currentRectId);
      });
      
	  document.getElementById("rect-line-style").addEventListener("change", () => {
      if (!currentRectId) return;
      pushUndo("change zone line style");
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      rect.lineStyle = document.getElementById("rect-line-style").value;
      forgeTheTopology();
      });
	  
      document.getElementById("add-rect-note").addEventListener("click", () => {
      const input = document.getElementById("new-rect-note");
      const txt = input.value.trim();
      if (!txt || !currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      if (!rect.notes) rect.notes = [];
      rect.notes.push(txt);
      input.value = "";
      selectTheRect(currentRectId);
      });
      
      document.getElementById("new-rect-note").addEventListener("keypress", (e) => {
      if (e.key === "Enter") {
      document.getElementById("add-rect-note").click();
      }
      });
      
      document.getElementById("delete-rect").addEventListener("click", () => {
      if (!currentRectId) return;
      challengeTheImmortal("Delete this box?", () => {
      RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== currentRectId);
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      });
      });
       document.getElementById("delete-edge").addEventListener("click", () => {
        if (!currentEdgeId) return;
        challengeTheImmortal("Are you sure you want to delete this line?",
         () => {
          EDGE_DATA.list = EDGE_DATA.list.filter(
           (e) => e.id !== currentEdgeId, );
         
          currentEdgeId = null;
          forgeTheTopology();
          const availableNodes = Object.keys(NODE_DATA);
          if (availableNodes.length > 0) {
           claimTheImmortal(availableNodes[0]);
          } else {
           document.getElementById("node-panel").style.display = "none";
           document.getElementById("edge-panel").style.display = "none";
           document.getElementById("topology-toolbar", ).style.display = "none";
          }
         }, );
       });
       document.getElementById("add-line-btn").addEventListener("click", () => {
        if (!currentNodeId) return;
        const select = document.getElementById("add-line-select");
        const directionSelect = document.getElementById("add-line-direction");
        const colorInput = document.getElementById("add-line-color");
        const targetId = select.value;
        if (!targetId || targetId === currentNodeId) return;
        const direction = directionSelect.value || "none";
        const lineColor = colorInput.value || "#475569";
        const newId = `${currentNodeId}-${targetId}-${Date.now()}`;
        const newEdge = {
         id: newId,
         from: currentNodeId,
         to: targetId,
         width: 4,
         color: lineColor,
         direction: direction,
         type: "main",
         notes: [],
         fromPort: "",
         toPort: "",
        };
        EDGE_DATA.list.push(newEdge);
       
        forgeTheTopology();
        claimTheImmortal(currentNodeId);
       });
       let rectStartPoint = null;
       let rectPreviewEl = null;
       let rectStyle = "filled";
       let freeDrawPoints = [];
       let freeDrawPolylineEl = null;
       let freeDrawPointEls = [];
       const drawToggleBtn = document.getElementById("draw-toggle");
       const drawUndoBtn = document.getElementById("draw-undo");
       const drawColorInput = document.getElementById("draw-color");
       const drawStyleSelect = document.getElementById("draw-style");
       const drawArrowSelect = document.getElementById("draw-arrow");
       const svgMap = document.getElementById("map");
      
       function updateFreeDrawGraphics() {
        const ns = "http://www.w3.org/2000/svg";
        const svg = svgMap;
        if (!freeDrawPolylineEl && freeDrawPoints.length > 0) {
         freeDrawPolylineEl = document.createElementNS(ns, "polyline");
         freeDrawPolylineEl.classList.add("edge", "free-preview");
         freeDrawPolylineEl.setAttribute("fill", "none");
         svg.appendChild(freeDrawPolylineEl);
        }
        if (freeDrawPolylineEl) {
         if (freeDrawPoints.length === 0) {
          freeDrawPolylineEl.remove();
          freeDrawPolylineEl = null;
         } else {
          const ptsStr = freeDrawPoints.map((p) => `${p.x},${p.y}`).join(" ");
          freeDrawPolylineEl.setAttribute("points", ptsStr);
          freeDrawPolylineEl.style.stroke = drawColorInput.value || "#475569";
          freeDrawPolylineEl.style.strokeWidth = 3;
          const lineStyle = drawStyleSelect.value || "solid";
          if (lineStyle === "dashed") {
           freeDrawPolylineEl.style.strokeDasharray = "10,5";
          } else if (lineStyle === "dotted") {
           freeDrawPolylineEl.style.strokeDasharray = "2,4";
          } else {
           freeDrawPolylineEl.style.strokeDasharray = "none";
          }
         }
        }
        freeDrawPointEls.forEach((el) => el.remove());
        freeDrawPointEls = [];
        freeDrawPoints.forEach((p, idx) => {
         const c = document.createElementNS(ns, "circle");
         c.classList.add("free-point");
         c.setAttribute("cx", p.x);
         c.setAttribute("cy", p.y);
         c.setAttribute("r", 5);
         c.dataset.index = String(idx);
         c.addEventListener("mousedown", (e) => {
          if (!freeDrawMode) return;
          e.preventDefault();
          e.stopPropagation();
          let dragging = true;
          const svgEl = svgMap;
          const moveHandler = (ev) => {
           if (!dragging) return;
           const pt = svgEl.createSVGPoint();
           pt.x = ev.clientX;
           pt.y = ev.clientY;
           const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
           const i = parseInt(c.dataset.index, 10);
           if (Number.isNaN(i) || !freeDrawPoints[i]) return;
           freeDrawPoints[i].x = svgP.x;
           freeDrawPoints[i].y = svgP.y;
           updateFreeDrawGraphics();
          };
          const upHandler = () => {
           dragging = false;
           document.removeEventListener("mousemove", moveHandler);
           document.removeEventListener("mouseup", upHandler);
          };
          document.addEventListener("mousemove", moveHandler);
          document.addEventListener("mouseup", upHandler);
         });
         c.addEventListener("touchstart",
          (e) => {
           if (!freeDrawMode) return;
           e.preventDefault();
           e.stopPropagation();
           let dragging = true;
           const svgEl = svgMap;
           const touchMoveHandler = (ev) => {
            if (!dragging || !ev.touches[0]) return;
            const pt = svgEl.createSVGPoint();
            pt.x = ev.touches[0].clientX;
            pt.y = ev.touches[0].clientY;
            const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
            const i = parseInt(c.dataset.index, 10);
            if (Number.isNaN(i) || !freeDrawPoints[i]) return;
            freeDrawPoints[i].x = svgP.x;
            freeDrawPoints[i].y = svgP.y;
            updateFreeDrawGraphics();
           };
           const touchUpHandler = () => {
            dragging = false;
            document.removeEventListener("touchmove", touchMoveHandler, );
            document.removeEventListener("touchend", touchUpHandler, );
           };
           document.addEventListener("touchmove", touchMoveHandler);
           document.addEventListener("touchend", touchUpHandler);
          }, {
           passive: false
          }, );
         svg.appendChild(c);
         freeDrawPointEls.push(c);
        });
        drawUndoBtn.style.display = freeDrawPoints.length ? "inline-block" : "none";
       }
      
       function addFreeDrawPoint(x, y) {
        freeDrawPoints.push({
         x,
         y
        });
        updateFreeDrawGraphics();
       }
      
       function startFreeDraw() {
        freeDrawMode = true;
        freeDrawPoints = [];
        if (freeDrawPolylineEl) {
         freeDrawPolylineEl.remove();
         freeDrawPolylineEl = null;
        }
        freeDrawPointEls.forEach((el) => el.remove());
        freeDrawPointEls = [];
        svgMap.style.cursor = "crosshair";
        drawToggleBtn.textContent = "Done";
        drawUndoBtn.style.display = "none";
       }
      
       function finishFreeDraw() {
        freeDrawMode = false;
        svgMap.style.cursor = "";
        drawToggleBtn.textContent = "✏️";
        if (freeDrawPoints.length >= 2) {
         const color = drawColorInput.value || "#475569";
         const lineStyle = drawStyleSelect.value || "solid";
         const arrowDir = drawArrowSelect.value || "none";
         const newId = "custom-" + Date.now();
         const pointsCopy = freeDrawPoints.map((p) => ({
          x: p.x,
          y: p.y,
         }));
         EDGE_DATA.list.push({
          id: newId,
          type: "custom",
          color,
          width: 4,
          lineStyle: lineStyle,
          direction: arrowDir,
          points: pointsCopy,
          notes: [],
         });
        
         freeDrawPoints = [];
         if (freeDrawPolylineEl) {
          freeDrawPolylineEl.remove();
          freeDrawPolylineEl = null;
         }
         freeDrawPointEls.forEach((el) => el.remove());
         freeDrawPointEls = [];
         forgeTheTopology();
         selectTheConnection(newId);
        } else {
         freeDrawPoints = [];
         if (freeDrawPolylineEl) {
          freeDrawPolylineEl.remove();
          freeDrawPolylineEl = null;
         }
         freeDrawPointEls.forEach((el) => el.remove());
         freeDrawPointEls = [];
         forgeTheLegend();
        }
        drawUndoBtn.style.display = "none";
       }
       drawToggleBtn.addEventListener("click", () => {
        if (currentView.mode === "rack") {
         alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
         return;
        }
        
        if (freeDrawMode) {
         finishFreeDraw();
        } else {
         startFreeDraw();
        }
       });
       drawUndoBtn.addEventListener("click", () => {
        if (!freeDrawMode || !freeDrawPoints.length) return;
        freeDrawPoints.pop();
        updateFreeDrawGraphics();
       });
       const drawToolbar = document.getElementById("draw-toolbar");
       drawToolbar.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       drawToolbar.addEventListener("click", (e) => {
        if (e.target !== drawToggleBtn && e.target !== drawUndoBtn) {
         e.stopPropagation();
        }
       });
       drawStyleSelect.addEventListener("change", () => {
        if (freeDrawMode) {
         updateFreeDrawGraphics();
        }
       });
       drawArrowSelect.addEventListener("change", () => {
        if (freeDrawMode) {
         updateFreeDrawGraphics();
        }
       });
       drawColorInput.addEventListener("input", () => {
        if (freeDrawMode) {
         updateFreeDrawGraphics();
        }
       });
       drawStyleSelect.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       drawStyleSelect.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       drawArrowSelect.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       drawArrowSelect.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       drawColorInput.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       drawColorInput.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       svgMap.addEventListener("click", (e) => {
        if (!freeDrawMode) return;
        if (e.button !== 0) return;
        const target = e.target;
        if (target && target.classList && target.classList.contains("free-point")) return;
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        addFreeDrawPoint(svgP.x, svgP.y);
       });
       svgMap.addEventListener("touchend",
        (e) => {
         if (!freeDrawMode) return;
         const target = e.target;
         if (target && target.classList && target.classList.contains("free-point")) return;
         if (e.changedTouches && e.changedTouches[0]) {
          e.preventDefault();
          const svgEl = svgMap;
          const pt = svgEl.createSVGPoint();
          pt.x = e.changedTouches[0].clientX;
          pt.y = e.changedTouches[0].clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          addFreeDrawPoint(svgP.x, svgP.y);
         }
        }, {
         passive: false
        }, );
       const settingsBtn = document.getElementById("settings-btn");
      
       const rectToggleBtn = document.getElementById("rect-toggle");
       const rectStyleSelect = document.getElementById("rect-style");
      
       function updateRectPreview() {
        if (!rectPreviewEl || !rectStartPoint) return;
        
        const ns = "http://www.w3.org/2000/svg";
        const svg = svgMap;
        
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
       }
      
       function startRectDraw() {
        rectDrawMode = true;
        rectStartPoint = null;
        rectPreviewEl = null;
        svgMap.style.cursor = "crosshair";
        rectToggleBtn.textContent = "Done";
        rectStyle = rectStyleSelect.value || "filled";
        
        if (freeDrawMode) {
         finishFreeDraw();
        }
        updateRectangleDeleteButtons();
       }
      
       function finishRectDraw() {
        rectDrawMode = false;
        svgMap.style.cursor = "";
        rectToggleBtn.textContent = "▭";
        
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
		updateRectangleDeleteButtons();
       }
      
       rectToggleBtn.addEventListener("click", () => {
        if (currentView.mode === "rack") {
         alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
         return;
        }
        
        if (rectDrawMode) {
         finishRectDraw();
        } else {
         startRectDraw();
        }
       });
      
       rectStyleSelect.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       rectStyleSelect.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       rectStyleSelect.addEventListener("change", () => {
        if (rectDrawMode) {
         rectStyle = rectStyleSelect.value || "filled";
        }
       });
      
       svgMap.addEventListener("mousedown", (e) => {
        if (!rectDrawMode) return;
        if (e.button !== 0) return;
        e.preventDefault();
        e.stopPropagation();
        
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        rectStartPoint = { x: svgP.x, y: svgP.y };
        
        const ns = "http://www.w3.org/2000/svg";
        rectPreviewEl = document.createElementNS(ns, "rect");
        rectPreviewEl.classList.add("rect-preview");
        rectPreviewEl.setAttribute("x", svgP.x);
        rectPreviewEl.setAttribute("y", svgP.y);
        rectPreviewEl.setAttribute("width", 0);
        rectPreviewEl.setAttribute("height", 0);
        
        const color = drawColorInput.value || "#f97316";
        rectPreviewEl.style.stroke = color;
        rectPreviewEl.style.strokeWidth = 2;
        rectPreviewEl.style.strokeDasharray = "5,5";
        
        if (rectStyle === "filled") {
         rectPreviewEl.style.fill = color;
         rectPreviewEl.style.fillOpacity = "0.3";
        } else {
         rectPreviewEl.style.fill = "none";
        }
        
        svgEl.appendChild(rectPreviewEl);
       });
      
       svgMap.addEventListener("mousemove", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        
        rectPreviewEl.setAttribute("x", x);
        rectPreviewEl.setAttribute("y", y);
        rectPreviewEl.setAttribute("width", width);
        rectPreviewEl.setAttribute("height", height);
       });
      
       svgMap.addEventListener("mouseup", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        
        if (width > 10 && height > 10) {
      pushUndo("draw zone"); 
         const color = drawColorInput.value || "#f97316";
         const newId = "rect-" + Date.now();
         
         const lineStyle = document.getElementById("draw-style").value || "solid";
         RECT_DATA.list.push({
          id: newId,
          x: x,
          y: y,
          width: width,
          height: height,
          color: color,
          style: rectStyle,
          lineStyle: lineStyle,
          notes: []
         });
         
         forgeTheTopology();
        }
        
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
       });
      
       let rectTouchStart = null;
       
       svgMap.addEventListener("touchstart", (e) => {
        if (!rectDrawMode) return;
        if (e.touches.length !== 1) return;
        
        e.preventDefault();
        const touch = e.touches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        rectStartPoint = { x: svgP.x, y: svgP.y };
        rectTouchStart = { x: svgP.x, y: svgP.y };
        
        const ns = "http://www.w3.org/2000/svg";
        rectPreviewEl = document.createElementNS(ns, "rect");
        rectPreviewEl.classList.add("rect-preview");
        rectPreviewEl.setAttribute("x", svgP.x);
        rectPreviewEl.setAttribute("y", svgP.y);
        rectPreviewEl.setAttribute("width", 0);
        rectPreviewEl.setAttribute("height", 0);
        
        const color = drawColorInput.value || "#f97316";
        rectPreviewEl.style.stroke = color;
        rectPreviewEl.style.strokeWidth = 2;
        rectPreviewEl.style.strokeDasharray = "5,5";
        
        if (rectStyle === "filled") {
         rectPreviewEl.style.fill = color;
         rectPreviewEl.style.fillOpacity = "0.3";
        } else {
         rectPreviewEl.style.fill = "none";
        }
        
        svgEl.appendChild(rectPreviewEl);
       }, { passive: false });
      
       svgMap.addEventListener("touchmove", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        if (e.touches.length !== 1) return;
        
        e.preventDefault();
        const touch = e.touches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        
        rectPreviewEl.setAttribute("x", x);
        rectPreviewEl.setAttribute("y", y);
        rectPreviewEl.setAttribute("width", width);
        rectPreviewEl.setAttribute("height", height);
       }, { passive: false });
      
       svgMap.addEventListener("touchend", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        if (!rectTouchStart) return;
        
        e.preventDefault();
        const touch = e.changedTouches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        
        if (width > 10 && height > 10) {
      pushUndo("draw zone");
         const color = drawColorInput.value || "#f97316";
         const newId = "rect-" + Date.now();
         
         const lineStyle = document.getElementById("draw-style").value || "solid";
         RECT_DATA.list.push({
          id: newId,
          x: x,
          y: y,
          width: width,
          height: height,
          color: color,
          style: rectStyle,
          lineStyle: lineStyle,
          notes: []
         });
         
         forgeTheTopology();
        }
        
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
        rectTouchStart = null;
       }, { passive: false });
      
       const textToggleBtn = document.getElementById("text-toggle");
       
       function startTextMode() {
        textDrawMode = true;
        svgMap.style.cursor = "crosshair";
        textToggleBtn.textContent = "Done";
        textToggleBtn.style.background = "var(--accent)";
        textToggleBtn.style.color = "var(--bg)";
        
        if (freeDrawMode) {
         finishFreeDraw();
        }
        if (rectDrawMode) {
         finishRectDraw();
        }
        
        updateTextDeleteButtons();
       }
       
       function finishTextMode() {
        textDrawMode = false;
        svgMap.style.cursor = "";
        textToggleBtn.textContent = "T";
        textToggleBtn.style.background = "";
        textToggleBtn.style.color = "";
        updateTextDeleteButtons();
       }
       
       textToggleBtn.addEventListener("click", () => {
        if (currentView.mode === "rack") {
         alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
         return;
        }
        
        if (textDrawMode) {
         finishTextMode();
        } else {
         startTextMode();
        }
       });
       
       function handleTextPlacement(e) {
        if (!textDrawMode) return;
        
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        const newId = "text-" + Date.now();
      pushUndo("add text");
        TEXT_DATA.list.push({
         id: newId,
         x: svgP.x,
         y: svgP.y,
         content: "New Text",
         fontSize: 18,
         color: "#e2e8f0",
         fontWeight: "normal",
         fontStyle: "normal",
         textAlign: "start",
         textDecoration: "none",
         bgColor: "#000000",
         bgEnabled: false,
         opacity: 1
        });
        
        forgeTheTopology();
        
        showTextPanel(newId);
       }
       
       svgMap.addEventListener("click", (e) => {
        if (!textDrawMode) return;
        if (e.target.closest('.text-delete-btn')) return;
        if (e.target.closest('.text-group')) return;
        
        e.preventDefault();
        e.stopPropagation();
        handleTextPlacement(e);
       });
       
       svgMap.addEventListener("touchend", (e) => {
        if (!textDrawMode) return;
        if (e.target.closest('.text-delete-btn')) return;
        if (e.target.closest('.text-group')) return;
        if (e.touches.length > 0) return;
        
        e.preventDefault();
        const touch = e.changedTouches[0];
        const fakeEvent = {
         clientX: touch.clientX,
         clientY: touch.clientY,
         preventDefault: () => {},
         stopPropagation: () => {}
        };
        handleTextPlacement(fakeEvent);
       }, { passive: false });
       
       function showTextPanel(textId) {
	   if (isViewOnly()) return;
       currentTextId = textId;
       currentNodeId = null;
       currentEdgeId = null;
       currentRectId = null;
       const textItem = TEXT_DATA.list.find(t => t.id === textId);
       if (!textItem) return;
       
       document.getElementById("node-panel").style.display = "none";
       document.getElementById("edge-panel").style.display = "none";
       document.getElementById("rect-panel").style.display = "none";
       
       const textPanel = document.getElementById("text-panel");
       textPanel.style.display = "block";
       document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active"));
       document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
       document.querySelectorAll(".rect-group").forEach(r => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach(t => t.classList.toggle("active", t.dataset.textId === textId));
        
        document.getElementById("text-content").value = textItem.content;
        document.getElementById("text-font-size").value = textItem.fontSize;
        document.getElementById("text-color").value = textItem.color;
        document.getElementById("text-font-weight").value = textItem.fontWeight;
        document.getElementById("text-font-style").value = textItem.fontStyle;
        document.getElementById("text-align").value = textItem.textAlign;
        document.getElementById("text-decoration").value = textItem.textDecoration;
        document.getElementById("text-bg-color").value = textItem.bgColor;
        document.getElementById("text-bg-enabled").checked = textItem.bgEnabled;
        document.getElementById("text-opacity").value = textItem.opacity;
        document.getElementById("text-opacity-val").textContent = Math.round(textItem.opacity * 100) + "%";
       }
       
       function updateTextDeleteButtons() {
        const deleteButtons = document.querySelectorAll('.text-delete-btn');
        deleteButtons.forEach(btn => {
         btn.style.display = textDrawMode ? 'block' : 'none';
        });
       }
       
       function deleteText(textId) {
      pushUndo("delete text");
        TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== textId);
        forgeTheTopology();
        
        if (currentTextId === textId) {
         document.getElementById("text-panel").style.display = "none";
         currentTextId = null;
        }
       }
       
       document.getElementById("text-content").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
      pushUndo("edit text");
         textItem.content = e.target.value;
         forgeTheTopology();
        }
       });
       
       document.getElementById("text-font-size").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         textItem.fontSize = parseInt(e.target.value);
         forgeTheTopology();
        }
       });
       
       document.getElementById("text-color").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         textItem.color = e.target.value;
         forgeTheTopology();
        }
       });
       
       document.getElementById("text-font-weight").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         textItem.fontWeight = e.target.value;
         forgeTheTopology();
        }
       });
       
       document.getElementById("text-font-style").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         textItem.fontStyle = e.target.value;
         forgeTheTopology();
        }
       });
       
       document.getElementById("text-align").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         textItem.textAlign = e.target.value;
         forgeTheTopology();
        }
       });
       
       document.getElementById("text-decoration").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         textItem.textDecoration = e.target.value;
         forgeTheTopology();
        }
       });
       
       document.getElementById("text-bg-color").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         textItem.bgColor = e.target.value;
         forgeTheTopology();
        }
       });
       
       document.getElementById("text-bg-enabled").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         textItem.bgEnabled = e.target.checked;
         forgeTheTopology();
        }
       });
       
       document.getElementById("text-opacity").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         textItem.opacity = parseFloat(e.target.value);
         document.getElementById("text-opacity-val").textContent = Math.round(textItem.opacity * 100) + "%";
         forgeTheTopology();
        }
       });
       
       document.getElementById("delete-text").addEventListener("click", () => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         challengeTheImmortal(`Delete text "${textItem.content.substring(0, 30)}..."?`, () => {
          deleteText(currentTextId);
         });
        }
       });
      
       const settingsModal = document.getElementById("settings-modal");
       const settingsClose = document.getElementById("settings-close");
       settingsBtn.addEventListener("click", () => {	 
       document.getElementById("page-bg-color").value = rgbaToHex(PAGE_STATE.background) || "#050608";
       document.getElementById("topbar-bg-color").value = rgbaToHex(PAGE_STATE.topbarBg) || "#0b0e13";
       document.getElementById("topbar-border-color").value = rgbaToHex(PAGE_STATE.topbarBorder) || "#1f2533";	 
       document.getElementById("panel-color").value = rgbaToHex(PAGE_STATE.panel) || "#0b0e13";
       document.getElementById("panel-alt-color").value = PAGE_STATE.panelAlt || "#10141b";
       document.getElementById("sidebar-bg-color").value = PAGE_STATE.sidebarBg || "#10141b";
       document.getElementById("btn-bg-color").value = PAGE_STATE.btnBg || "#0b0e13";
       document.getElementById("btn-text-color").value = PAGE_STATE.btnText || "#e2e8f0";
       document.getElementById("tag-fill-color").value = PAGE_STATE.tagFill || "#1e293b";
       document.getElementById("tag-text-color").value = PAGE_STATE.tagText || "#e2e8f0";
       document.getElementById("tag-border-color").value = PAGE_STATE.tagBorder || "#475569";
       document.getElementById("input-bg-color").value = PAGE_STATE.inputBg || "#0b0e13";
       document.getElementById("input-text-color").value = PAGE_STATE.inputText || "#e2e8f0";
	   document.getElementById("input-border-color").value = PAGE_STATE.inputBorder || "#1f2937";
       document.getElementById("input-font-family").value = PAGE_STATE.inputFont || "Inter, system-ui, sans-serif";
       document.getElementById("input-font-size").value = PAGE_STATE.inputFontSize || 14;
       document.getElementById("toolbar-bg-color").value = PAGE_STATE.toolbarBg || "#0f172a";
       document.getElementById("toolbar-border-color").value = PAGE_STATE.toolbarBorder || "#1f2937";
       document.getElementById("toolbar-text-color").value = PAGE_STATE.toolbarText || "#94a3b8";
       document.getElementById("toolbar-btn-bg-color").value = PAGE_STATE.toolbarBtnBg || "#0b0e13";
       document.getElementById("toolbar-btn-text-color").value = PAGE_STATE.toolbarBtnText || "#e2e8f0";
       document.getElementById("minimap-dots-color").value = PAGE_STATE.minimapDots || "#94a3b8";
       document.getElementById("canvas-hint-enabled").checked = PAGE_STATE.canvasHintEnabled !== false;
       document.getElementById("canvas-hint-bg-color").value = PAGE_STATE.canvasHintBg || "#0f172a";
       document.getElementById("canvas-hint-text-color").value = PAGE_STATE.canvasHintColor || "#94a3b8";
       document.getElementById("canvas-hint-text").value = PAGE_STATE.canvasHintText || "";
       document.getElementById("accent-color").value = rgbaToHex(PAGE_STATE.accent) || "#4fd1c5";
       document.getElementById("danger-color").value = rgbaToHex(PAGE_STATE.danger) || "#f56565";
       document.getElementById("text-main-color").value = rgbaToHex(PAGE_STATE.textMain) || "#e2e8f0";
       document.getElementById("text-soft-color").value = PAGE_STATE.textSoft || "#94a3b8";
       document.getElementById("node-fill-color").value = PAGE_STATE.nodeFill || "#1e293b";
       document.getElementById("node-stroke-color").value = PAGE_STATE.nodeStroke || "#475569";
       document.getElementById("node-title-color").value = PAGE_STATE.nodeTitle || "#e2e8f0";
       document.getElementById("node-sub-color").value = PAGE_STATE.nodeSub || "#94a3b8";
       document.getElementById("node-title-size").value = PAGE_STATE.nodeTitleSize || 18;
       document.getElementById("node-sub-size").value = PAGE_STATE.nodeSubSize || 13;
       document.getElementById("node-font-family").value = PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
       document.getElementById("default-edge-color").value = PAGE_STATE.defaultEdge || "#475569";
       document.getElementById("selection-handle-color").value = PAGE_STATE.selectionHandle || "#f59e0b";
       document.getElementById("selection-handle-size").value = PAGE_STATE.selectionHandleSize || 8;
       document.getElementById("group-indicator-color").value = PAGE_STATE.groupIndicator || "#4fd1c5";
       document.getElementById("canvas-gradient-top").value = PAGE_STATE.canvasGradientTop || "#1e2532";
       document.getElementById("canvas-gradient-bottom").value = PAGE_STATE.canvasGradientBottom || "#050608";
       document.getElementById("canvas-border-color").value = PAGE_STATE.canvasBorder || "#475569";
       document.getElementById("canvas-grid-color").value = PAGE_STATE.canvasGrid || "#475569";
       document.getElementById("canvas-grid-size").value = PAGE_STATE.canvasGridSize || 50;
       document.getElementById("rack-frame-fill").value = PAGE_STATE.rackFrameFill || "#0f172a";
       document.getElementById("rack-frame-stroke").value = PAGE_STATE.rackFrameStroke || "#4fd1c5";
       document.getElementById("rack-line-color").value = PAGE_STATE.rackLineColor || "#475569";
       document.getElementById("rack-text-color").value = PAGE_STATE.rackTextColor || "#4fd1c5";
      
        
        document.getElementById("auto-ping-enabled").checked = autoPingEnabled;
        document.getElementById("auto-ping-interval").value = autoPingInterval;
        document.getElementById("auto-ping-settings").style.display = autoPingEnabled ? 'block' : 'none';
        document.getElementById("view-only-mode").checked = PAGE_STATE.viewOnly === true;
        settingsModal.classList.add("active");
       });
       settingsClose.addEventListener("click", () => {
        settingsModal.classList.remove("active");
       });
	   document.getElementById("view-only-mode").addEventListener("change", (e) => {
       PAGE_STATE.viewOnly = e.target.checked;
       
       if (e.target.checked) {
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        document.getElementById("rect-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.setProperty('display', 'none', 'important');
        document.getElementById("draw-toolbar").style.setProperty('display', 'none', 'important');
        currentNodeId = null;
        currentEdgeId = null;
        currentRectId = null;
        currentTextId = null;
        selectedNodes.clear();
        selectedRects.clear();
        selectedTexts.clear();
        selectedEdges.clear();
        const bulkToolbar = document.getElementById("bulk-toolbar");
        const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active", "selected"));
        document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
        document.querySelectorAll(".rect-group").forEach(r => r.classList.remove("active"));
        document.querySelectorAll(".text-element").forEach(t => t.classList.remove("active"));
       }
       
       wieldThePower();
       if (!e.target.checked) {
        updateDrawToolbarVisibility();
        updateTopologyToolbarVisibility();
       }
       forgeTheTopology();
      });
       settingsModal.addEventListener("click", (e) => {
        if (e.target === settingsModal) {
         settingsModal.classList.remove("active");
        }
       });
       document.getElementById("page-bg-color").addEventListener("input", (e) => {
        PAGE_STATE.background = e.target.value;
        wieldThePower();
       });
       document.getElementById("topbar-bg-color").addEventListener("input", (e) => {
        PAGE_STATE.topbarBg = e.target.value;
        wieldThePower();
       });
       document.getElementById("topbar-border-color").addEventListener("input", (e) => {
        PAGE_STATE.topbarBorder = e.target.value;
        wieldThePower();
       });
       document.getElementById("panel-color").addEventListener("input", (e) => {
        PAGE_STATE.panel = e.target.value;
        wieldThePower();
       });
       document.getElementById("panel-alt-color").addEventListener("input", (e) => {
       PAGE_STATE.panelAlt = e.target.value;
       wieldThePower();
      });
      document.getElementById("sidebar-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.sidebarBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("btn-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.btnBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("btn-text-color").addEventListener("input", (e) => {
       PAGE_STATE.btnText = e.target.value;
       wieldThePower();
      });
      document.getElementById("tag-fill-color").addEventListener("input", (e) => {
       PAGE_STATE.tagFill = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("tag-text-color").addEventListener("input", (e) => {
       PAGE_STATE.tagText = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("tag-border-color").addEventListener("input", (e) => {
       PAGE_STATE.tagBorder = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("selection-fill-color").addEventListener("input", function() {
       selectionBoxStyle.fillColor = this.value;
      });
      document.getElementById("selection-fill-opacity").addEventListener("input", function() {
       selectionBoxStyle.fillOpacity = parseFloat(this.value);
       document.getElementById("selection-fill-opacity-val").textContent = Math.round(this.value * 100) + "%";
      });
      document.getElementById("selection-stroke-color").addEventListener("input", function() {
       selectionBoxStyle.strokeColor = this.value;
      });
      document.getElementById("selection-stroke-width").addEventListener("input", function() {
       selectionBoxStyle.strokeWidth = parseInt(this.value) || 2;
      });
      document.getElementById("selection-stroke-style").addEventListener("change", function() {
       selectionBoxStyle.strokeDasharray = this.value;
      });
      document.getElementById("input-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.inputBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-text-color").addEventListener("input", (e) => {
       PAGE_STATE.inputText = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-border-color").addEventListener("input", (e) => {
       PAGE_STATE.inputBorder = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-font-family").addEventListener("change", (e) => {
       PAGE_STATE.inputFont = e.target.value;
       wieldThePower();
      });
	  document.getElementById("input-font-size").addEventListener("input", (e) => {
       PAGE_STATE.inputFontSize = parseInt(e.target.value) || 14;
       wieldThePower();
      });
      document.getElementById("toolbar-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-border-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBorder = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-text-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarText = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-btn-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBtnBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-btn-text-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBtnText = e.target.value;
       wieldThePower();
      });
      document.getElementById("minimap-dots-color").addEventListener("input", (e) => {
       PAGE_STATE.minimapDots = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("canvas-hint-enabled").addEventListener("change", (e) => {
       PAGE_STATE.canvasHintEnabled = e.target.checked;
       wieldThePower();
      });
      document.getElementById("canvas-hint-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-hint-text-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintColor = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-hint-text").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintText = e.target.value;
       wieldThePower();
      });
       document.getElementById("accent-color").addEventListener("input", (e) => {
        PAGE_STATE.accent = e.target.value;
        wieldThePower();
       });
       document.getElementById("danger-color").addEventListener("input", (e) => {
        PAGE_STATE.danger = e.target.value;
        wieldThePower();
       });
       document.getElementById("text-main-color").addEventListener("input", (e) => {
        PAGE_STATE.textMain = e.target.value;
        wieldThePower();
       });
       document.getElementById("text-soft-color").addEventListener("input", (e) => {
       PAGE_STATE.textSoft = e.target.value;
       wieldThePower();
      });
      document.getElementById("node-fill-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeFill = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-stroke-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeStroke = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-title-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeTitle = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-sub-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeSub = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-title-size").addEventListener("input", (e) => {
       PAGE_STATE.nodeTitleSize = parseInt(e.target.value) || 18;
       forgeTheTopology();
      });
      document.getElementById("node-sub-size").addEventListener("input", (e) => {
       PAGE_STATE.nodeSubSize = parseInt(e.target.value) || 13;
       forgeTheTopology();
      });
      document.getElementById("node-font-family").addEventListener("change", (e) => {
       PAGE_STATE.nodeFont = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("default-edge-color").addEventListener("input", (e) => {
       PAGE_STATE.defaultEdge = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("selection-handle-color").addEventListener("input", (e) => {
       PAGE_STATE.selectionHandle = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("selection-handle-size").addEventListener("input", (e) => {
       PAGE_STATE.selectionHandleSize = parseInt(e.target.value) || 8;
       forgeTheTopology();
      });
      document.getElementById("group-indicator-color").addEventListener("input", (e) => {
       PAGE_STATE.groupIndicator = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-gradient-top").addEventListener("input", (e) => {
       PAGE_STATE.canvasGradientTop = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-gradient-bottom").addEventListener("input", (e) => {
       PAGE_STATE.canvasGradientBottom = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-border-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasBorder = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-grid-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasGrid = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-grid-size").addEventListener("input", (e) => {
       PAGE_STATE.canvasGridSize = parseInt(e.target.value) || 50;
       forgeTheTopology();
      });
      document.getElementById("rack-frame-fill").addEventListener("input", (e) => {
       PAGE_STATE.rackFrameFill = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-frame-stroke").addEventListener("input", (e) => {
       PAGE_STATE.rackFrameStroke = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-line-color").addEventListener("input", (e) => {
       PAGE_STATE.rackLineColor = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-text-color").addEventListener("input", (e) => {
       PAGE_STATE.rackTextColor = e.target.value;
       forgeTheTopology();
      });
      
      (function initializeResizers() {
         const headerResizer = document.getElementById('header-resizer');
         const sidebarResizer = document.getElementById('sidebar-resizer');
         const mobileFooterResizer = document.getElementById('mobile-footer-resizer');
         
         let isResizing = false;
         let currentResizer = null;
         let startY = 0;
         let startX = 0;
         let startHeight = 0;
         let startWidth = 0;
         
         function getClientPos(e) {
           if (e.touches && e.touches.length > 0) {
             return { x: e.touches[0].clientX, y: e.touches[0].clientY };
           }
           return { x: e.clientX, y: e.clientY };
         }
         
         function startResize(resizer, type, e) {
           isResizing = true;
           currentResizer = type;
           const pos = getClientPos(e);
           
           if (type === 'header') {
             startY = pos.y;
             startHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--topbar-height'));
           } else if (type === 'sidebar') {
             startX = pos.x;
             startWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width'));
           } else if (type === 'mobile-footer') {
             startY = pos.y;
             const currentVh = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--mobile-footer-height'));
             startHeight = (currentVh / 100) * window.innerHeight;
           }
           
           resizer.classList.add('resizing');
           document.body.classList.add('resizing');
           document.body.style.cursor = (type === 'sidebar') ? 'col-resize' : 'row-resize';
           e.preventDefault();
         }
         
         if (headerResizer) {
           headerResizer.addEventListener('mousedown', (e) => startResize(headerResizer, 'header', e));
           headerResizer.addEventListener('touchstart', (e) => startResize(headerResizer, 'header', e), { passive: false });
         }
         
         if (sidebarResizer) {
           sidebarResizer.addEventListener('mousedown', (e) => startResize(sidebarResizer, 'sidebar', e));
           sidebarResizer.addEventListener('touchstart', (e) => startResize(sidebarResizer, 'sidebar', e), { passive: false });
         }
         
         if (mobileFooterResizer) {
           mobileFooterResizer.addEventListener('mousedown', (e) => startResize(mobileFooterResizer, 'mobile-footer', e));
           mobileFooterResizer.addEventListener('touchstart', (e) => startResize(mobileFooterResizer, 'mobile-footer', e), { passive: false });
         }
         
         function handleMove(e) {
           if (!isResizing) return;
           
           const pos = getClientPos(e);
           
           if (currentResizer === 'header') {
             const deltaY = pos.y - startY;
             const newHeight = Math.max(40, Math.min(150, startHeight + deltaY));
             document.documentElement.style.setProperty('--topbar-height', newHeight + 'px');
           } else if (currentResizer === 'sidebar') {
             const deltaX = startX - pos.x;
             const newWidth = Math.max(200, Math.min(800, startWidth + deltaX));
             document.documentElement.style.setProperty('--sidebar-width', newWidth + 'px');
           } else if (currentResizer === 'mobile-footer') {
             const deltaY = startY - pos.y;
             const newHeight = startHeight + deltaY;
             const newVh = Math.max(15, Math.min(80, (newHeight / window.innerHeight) * 100));
             document.documentElement.style.setProperty('--mobile-footer-height', newVh + 'vh');
           }
           
           e.preventDefault();
         }
         
         document.addEventListener('mousemove', handleMove);
         document.addEventListener('touchmove', handleMove, { passive: false });
         
         function handleEnd() {
           if (isResizing) {
             isResizing = false;
             
             if (currentResizer === 'header') {
               PAGE_STATE.topbarHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--topbar-height'));
               headerResizer.classList.remove('resizing');
             } else if (currentResizer === 'sidebar') {
               PAGE_STATE.sidebarWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width'));
               sidebarResizer.classList.remove('resizing');
             } else if (currentResizer === 'mobile-footer') {
               PAGE_STATE.mobileFooterHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--mobile-footer-height'));
               mobileFooterResizer.classList.remove('resizing');
             }
             
             document.body.classList.remove('resizing');
             document.body.style.cursor = '';
             currentResizer = null;
           }
         }
         
         document.addEventListener('mouseup', handleEnd);
         document.addEventListener('touchend', handleEnd);
         document.addEventListener('touchcancel', handleEnd);
       })();
       
       document.getElementById("auto-ping-enabled").addEventListener("change", (e) => {
        autoPingEnabled = e.target.checked;
        PAGE_STATE.autoPingEnabled = autoPingEnabled;
        document.getElementById("auto-ping-settings").style.display = autoPingEnabled ? 'block' : 'none';
        
        if (autoPingEnabled) {
         startAutoPing();
        } else {
         stopAutoPing();
        }
       });
       
       document.getElementById("auto-ping-interval").addEventListener("change", (e) => {
        const newInterval = parseInt(e.target.value, 10);
        if (newInterval >= 5 && newInterval <= 3600) {
         autoPingInterval = newInterval;
         PAGE_STATE.autoPingInterval = autoPingInterval;
         
         if (autoPingEnabled) {
          startAutoPing();
         }
        }
       });
       
       document.getElementById("export-data-btn").addEventListener("click", () => {
        const data = captureTheQuickening();
        const jsonStr = JSON.stringify(data, null, 2);
        const blob = new Blob([jsonStr], {
         type: "application/json"
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        const safeTitle = (PAGE_STATE.title || "network-topology").toLowerCase().replace(/[^a-z0-9\-]+/g, "-");
        const timestamp = new Date().toISOString().split("T")[0];
        a.download = `${safeTitle}-data-${timestamp}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
		logAuditEvent("export", `Exported JSON: ${a.download}`);
       });
       document.getElementById("import-data-btn").addEventListener("click", () => {
        document.getElementById("import-data-file").click();
       });
       document.getElementById("import-data-file").addEventListener("change", async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        try {
         const text = await file.text();
         const data = JSON.parse(text);
         if (!data.nodeData || !data.edgeData) {
          alert("Invalid data file. Missing required fields.");
          return;
         }
         const confirmMsg = `This will replace all current data with the imported data.\n\nImporting:\n- ${Object.keys(data.nodeData).length} nodes\n- ${data.edgeData.list?.length || 0} connections\n- ${data.documentTabs?.length || 1} tab(s)\n\nContinue?`;         if (!confirm(confirmMsg)) {
          e.target.value = "";
          return;
         }
         NODE_DATA = data.nodeData || {};
         EDGE_DATA = data.edgeData || {
          list: []
         };
         EDGE_LEGEND = data.edgeLegend || {};
         RECT_DATA = data.rectData || { list: [] };
         TEXT_DATA = data.textData || { list: [] };
         savedPositions = data.nodePositions || {};
         savedSizes = data.nodeSizes || {};
         savedStyles = data.nodeStyles || {};
         if (data.page) {
          PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, data.page, );
          wieldThePower();
         }
      
      if (data.autoPingEnabled !== undefined) {
      autoPingEnabled = data.autoPingEnabled;
      PAGE_STATE.autoPingEnabled = autoPingEnabled;
      document.getElementById("auto-ping-enabled").checked = autoPingEnabled;
      }
      
      if (data.autoPingInterval !== undefined) {
      autoPingInterval = data.autoPingInterval;
      PAGE_STATE.autoPingInterval = autoPingInterval;
      document.getElementById("auto-ping-interval").value = autoPingInterval;
      }
         if (data.canvas) {
          canvasState.zoom = data.canvas.zoom || 1;
          canvasState.panX = data.canvas.panX || 0;
          canvasState.panY = data.canvas.panY || 0;
         }
         if (data.page?.title) {
         document.title = data.page.title;
         document.querySelector(".editable-page-title", ).textContent = data.page.title;
        }
        if (data.documentTabs) {
         documentTabs = data.documentTabs;
         currentTabIndex = data.currentTabIndex || 0;
        }
        if (data.savedTopologyView) {
         savedTopologyView = data.savedTopologyView;
        }
        if (data.encryptedSections) {
         encryptedSections = data.encryptedSections;
        }
        if (data.auditLog && Array.isArray(data.auditLog)) {
         auditLog = data.auditLog;
         try {
           localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
         } catch (e) {
           console.warn("Failed to sync audit log to localStorage:", e);
         }
        }
        forgeTheTopology();
        forgeTheLegend();
        logAuditEvent("import", `Imported JSON: ${file.name} (${Object.keys(data.nodeData).length} nodes, ${data.edgeData.list?.length || 0} connections)`);
        updateViewBox();
      
      if (autoPingEnabled) {
      startAutoPing();
      } else {
      stopAutoPing();
      }
      
         const nodeIds = Object.keys(NODE_DATA);
         if (nodeIds.length > 0) {
          claimTheImmortal(nodeIds[0]);
         } else {
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("topology-toolbar").style.display = "none";
         }
         alert("Data imported successfully!");
         e.target.value = "";
        } catch (err) {
         console.error("Import error:", err);
         alert(`Failed to import data: ${err.message}`);
         e.target.value = "";
        }
       });
       const saveHelpBtn = document.getElementById("save-help-btn");
       const saveInfoModal = document.getElementById("save-info-modal");
       const saveInfoClose = document.getElementById("save-info-close");
       saveHelpBtn.addEventListener("click", () => {
        saveInfoModal.classList.add("active");
       });
       saveInfoClose.addEventListener("click", () => {
        saveInfoModal.classList.remove("active");
       });
       saveInfoModal.addEventListener("click", (e) => {
       if (e.target === saveInfoModal) {
        saveInfoModal.classList.remove("active");
       }
      });
      document.querySelectorAll(".help-tab").forEach(tab => {
        tab.addEventListener("click", () => {
          document.querySelectorAll(".help-tab").forEach(t => { t.style.background = "var(--panel)"; t.style.color = "var(--text-main)"; });
          tab.style.background = "var(--accent)"; tab.style.color = "var(--bg)";
          document.querySelectorAll(".help-tab-content").forEach(c => c.style.display = "none");
          document.getElementById("help-tab-" + tab.dataset.tab).style.display = "block";
        });
      });
      async function deriveKey(password, salt) {
      const encoder = new TextEncoder();
      
      const keyMaterial = await crypto.subtle.importKey(
      "raw",
      encoder.encode(password),
      "PBKDF2",
      false,
      ["deriveKey"]
      );
      
      return crypto.subtle.deriveKey(
      {
      name: "PBKDF2",
      salt: salt,
      iterations: 200000,  
      hash: "SHA-256"
      },
      keyMaterial,
      {
      name: "AES-GCM",
      length: 256
      },
      false,
      ["encrypt", "decrypt"]
      );
      }
      
       async function encryptData(data, password) {
      const encoder = new TextEncoder();
      const salt = crypto.getRandomValues(new Uint8Array(16));
      const iv   = crypto.getRandomValues(new Uint8Array(12));
      
      const key = await deriveKey(password, salt);
      const encrypted = await crypto.subtle.encrypt(
      { name: "AES-GCM", iv },
      key,
      encoder.encode(data)
      );
      
      const encryptedU8 = new Uint8Array(encrypted);
      
      const result = new Uint8Array(salt.length + iv.length + encryptedU8.length);
      result.set(salt, 0);
      result.set(iv, salt.length);
      result.set(encryptedU8, salt.length + iv.length);
      
      return "ENCRYPTED:" + u8ToBase64(result);
      }
      
       async function decryptData(encryptedData, password) {
      const base64Data = encryptedData.replace("ENCRYPTED:", "");
      const fullData   = base64ToU8(base64Data);
      
      const salt      = fullData.slice(0, 16);
      const iv        = fullData.slice(16, 28);
      const encrypted = fullData.slice(28);
      
      const key = await deriveKey(password, salt);
      
      const decrypted = await crypto.subtle.decrypt(
      { name: "AES-GCM", iv },
      key,
      encrypted
      );
      
      const decoder = new TextDecoder();
      return decoder.decode(decrypted);
      }
      
      
       function isEncrypted(data) {
        return typeof data === "string" && data.startsWith("ENCRYPTED:");
       }
      
       function captureTheQuickening() {
      const currentTab = documentTabs[currentTabIndex];
      currentTab.nodes = JSON.parse(JSON.stringify(NODE_DATA));
      currentTab.edges = JSON.parse(JSON.stringify(EDGE_DATA));
      currentTab.positions = JSON.parse(JSON.stringify(savedPositions));
      currentTab.sizes = JSON.parse(JSON.stringify(savedSizes));
      currentTab.styles = JSON.parse(JSON.stringify(savedStyles));
      currentTab.legend = JSON.parse(JSON.stringify(EDGE_LEGEND));
      currentTab.rects = JSON.parse(JSON.stringify(RECT_DATA));
      currentTab.texts = JSON.parse(JSON.stringify(TEXT_DATA));
      currentTab.pageState = JSON.parse(JSON.stringify(PAGE_STATE));
       
      return {
      nodeData: NODE_DATA,
       edgeData: EDGE_DATA,
       rectData: RECT_DATA,
       textData: TEXT_DATA,
       edgeLegend: EDGE_LEGEND,
       nodePositions: savedPositions,
       nodeSizes: savedSizes,
       nodeStyles: savedStyles,
       iconCache: IconLibrary.iconCache,
      
       page: PAGE_STATE,
      
       autoPingEnabled: autoPingEnabled,
       autoPingInterval: autoPingInterval,
      
       canvas: {
         zoom: canvasState.zoom,
         panX: canvasState.panX,
         panY: canvasState.panY,
       },
       
       savedTopologyView: savedTopologyView,
       
       documentTabs: documentTabs,
       currentTabIndex: currentTabIndex,
       encryptedSections: encryptedSections,
	   auditLog: auditLog,
       };
      }
      
       function assembleTheImmortalForm() {
	   const canvasHintEl = document.getElementById("canvas-hint");
       const savedHintHTML = canvasHintEl ? canvasHintEl.innerHTML : "";
       if (canvasHintEl) canvasHintEl.innerHTML = DEFAULT_CANVAS_HINT;
        const clone = document.documentElement.cloneNode(true);
       ["edge-legend-mini", "minimap-mini", "draw-toolbar-mini", "topology-toolbar-mini"].forEach(id => {
        const all = clone.querySelectorAll("#" + id);
        for (let i = 1; i < all.length; i++) {
         all[i].remove();
        }
       });
       const nodeScript = clone.querySelector("#nodes-json");
        if (nodeScript) {
         nodeScript.textContent = JSON.stringify(NODE_DATA, null, 2);
        }
        let stateScript = clone.querySelector("#topology-state");
        if (!stateScript) {
         stateScript = document.createElement("script");
         stateScript.id = "topology-state";
         stateScript.type = "application/json";
         const body = clone.querySelector("body") || clone;
         body.appendChild(stateScript);
        }
        stateScript.textContent = JSON.stringify(captureTheQuickening(), null, 2, );
        return " <!DOCTYPE html> \n " + clone.outerHTML;
       }
       async function becomeImmortal() {
        const encryptEnabled = document.getElementById("encrypt-toggle").checked;
        let stateData = JSON.stringify(captureTheQuickening(), null, 2);
        if (encryptEnabled) {
         const password = prompt("Enter a password to encrypt your data:\n(Remember this password! You will need it to open this file and its non recoverable!)", );
         if (!password) {
          alert("Encryption cancelled. File not saved.");
          return;
         }
         const confirmPassword = prompt("Confirm your password:");
         if (password !== confirmPassword) {
          alert("Passwords do not match. File not saved.");
          return;
         }
         try {
          stateData = await encryptData(stateData, password);
         } catch (e) {
          alert("Encryption failed: " + e.message);
          return;
         }
        }
       const canvasHintEl = document.getElementById("canvas-hint");
       const savedHintHTML = canvasHintEl ? canvasHintEl.innerHTML : "";
       if (canvasHintEl) canvasHintEl.innerHTML = DEFAULT_CANVAS_HINT;
       
       const clone = document.documentElement.cloneNode(true);
       ["edge-legend-mini", "minimap-mini", "draw-toolbar-mini", "topology-toolbar-mini"].forEach(id => {
        const all = clone.querySelectorAll("#" + id);
        for (let i = 1; i < all.length; i++) {
         all[i].remove();
        }
       });  
       const nodeScript = clone.querySelector("#nodes-json");
        if (nodeScript) {
         if (encryptEnabled) {
          nodeScript.textContent = JSON.stringify({}, null, 2);
         } else {
          nodeScript.textContent = JSON.stringify(NODE_DATA, null, 2);
         }
        }
        let stateScript = clone.querySelector("#topology-state");
        if (!stateScript) {
         stateScript = document.createElement("script");
         stateScript.id = "topology-state";
         stateScript.type = "application/json";
         const body = clone.querySelector("body") || clone;
         body.appendChild(stateScript);
        }
        stateScript.textContent = stateData;
        const html = "<!DOCTYPE html> \n " + clone.outerHTML;
        const blob = new Blob([html], {
         type: "text/html"
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        const safeTitle = (PAGE_STATE.title || document.title || "network-topology").toLowerCase().replace(/[^a-z0-9\-]+/g, "-");
        a.download = safeTitle + ".html";
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url); 
		if (canvasHintEl) canvasHintEl.innerHTML = savedHintHTML;
        saveRollbackVersion("Manual save");
		logAuditEvent("save", `File saved: ${safeTitle}.html`);
       }
       
      function captureState() {
      return {
        nodes: JSON.parse(JSON.stringify(NODE_DATA)),
        edges: JSON.parse(JSON.stringify(EDGE_DATA)),
        positions: JSON.parse(JSON.stringify(savedPositions)),
        sizes: JSON.parse(JSON.stringify(savedSizes)),
        styles: JSON.parse(JSON.stringify(savedStyles)),
        legend: JSON.parse(JSON.stringify(EDGE_LEGEND)),
        rects: JSON.parse(JSON.stringify(RECT_DATA)),
        texts: JSON.parse(JSON.stringify(TEXT_DATA))
        };
      }
      
      function pushUndo(action = "") {
       const state = captureState();
       undoStack.push(state);
       if (undoStack.length > MAX_UNDO_STACK) {
        undoStack.shift();
       }
       redoStack = [];
       updateUndoButtons();
       
       if (action) {
        const actionTypeMap = {
          "create node": "node",
          "delete node": "node",
          "add node": "node",
          "edit": "node",
          "clone node": "node",
          "paste node": "node",
          "move nodes": "node",
          "nudge": "node",
          "nudge nodes": "node",
          "align nodes": "node",
          "distribute nodes": "node",
          "snap to grid": "node",
          "toggle group": "node",
          "toggle lock": "node",
          "create rack": "rack",
          "add rack": "rack",
          "edit rack": "rack",
          "edit mac": "rack",
          "edit U height": "rack",
          "change rack capacity": "rack",
          "change assigned rack": "rack",
          "add connection": "connection",
          "delete connection": "connection",
          "delete edge": "connection",
          "clone edge": "connection",
          "paste edge": "connection",
          "style change": "style",
          "change layer": "layer",
          "add text": "text",
          "edit text": "text",
          "delete text": "text",
          "clone text": "text",
          "paste text": "text",
          "draw zone": "zone",
          "delete zone": "zone",
          "delete rect": "zone",
          "clone rect": "zone",
          "paste rect": "zone",
          "change zone line style": "zone",
          "delete selected": "bulk",
          "clone selected": "bulk",
        };
        
        const type = actionTypeMap[action] || "edit";
        logAuditEvent(type, action);
       }
      }
      
      function undo() {
       if (undoStack.length === 0) return;
       const currentState = captureState();
       redoStack.push(currentState);
       const previousState = undoStack.pop();
       restoreState(previousState);
       updateUndoButtons();
       logAuditEvent("undo", "Undo action performed");
      }
      
      function redo() {
       if (redoStack.length === 0) return;
       logAuditEvent("redo", "Redo action performed");
       const currentState = captureState();
       undoStack.push(currentState);
       const nextState = redoStack.pop();
       restoreState(nextState);
       updateUndoButtons();
      }
      
      function restoreState(state) {
      NODE_DATA = state.nodes;
       EDGE_DATA = state.edges;
       savedPositions = state.positions;
       savedSizes = state.sizes;
       savedStyles = state.styles;
       EDGE_LEGEND = state.legend;
       RECT_DATA = state.rects || { list: [] };
       TEXT_DATA = state.texts || { list: [] };
       forgeTheTopology();
       if (currentNodeId && NODE_DATA[currentNodeId]) {
       claimTheImmortal(currentNodeId);
       } else if (currentEdgeId) {
       selectTheConnection(currentEdgeId);
       }
      }
      
      function updateUndoButtons() {
       const undoBtn = document.getElementById("undo-btn");
       const redoBtn = document.getElementById("redo-btn");
       if (undoBtn) {
        undoBtn.disabled = undoStack.length === 0;
        undoBtn.style.opacity = undoStack.length === 0 ? "0.5" : "1";
       }
       if (redoBtn) {
        redoBtn.disabled = redoStack.length === 0;
        redoBtn.style.opacity = redoStack.length === 0 ? "0.5" : "1";
       }
      }
      
      function clearSelection() {
       selectedNodes.clear();
       selectedEdges.clear();
       selectedRects.clear();
       selectedTexts.clear();
       updateAllSelections();
      }
      
      function updateAllSelections() {
      updateNodeSelection();
      clearSearchHighlight();
      document.querySelectorAll(".edge").forEach(el => {
      const edgeId = el.dataset.edgeId;
      if (selectedEdges.has(edgeId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      
      document.querySelectorAll(".rect-group").forEach(el => {
      const rectId = el.dataset.rectId;
      if (selectedRects.has(rectId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      
      document.querySelectorAll(".text-group").forEach(el => {
      const textId = el.dataset.textId;
      if (selectedTexts.has(textId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      
      const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
      const bulkToolbar = document.getElementById("bulk-toolbar");
      const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
      const bulkCount = document.getElementById("bulk-count");
      const bulkCountMobile = document.getElementById("bulk-count-mobile");
      
      if (total > 0) {
      if (bulkToolbar) bulkToolbar.style.display = "flex";
      if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
      if (bulkCount) bulkCount.textContent = total;
      if (bulkCountMobile) bulkCountMobile.textContent = total;
      } else {
      if (bulkToolbar) bulkToolbar.style.display = "none";
      if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
      }
      }
      
      
      function updateNodeSelection() {
       if (isViewOnly()) {
        selectedNodes.clear();
        selectedRects.clear();
        selectedTexts.clear();
        const bulkToolbar = document.getElementById("bulk-toolbar");
        const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        return;
       }
       document.querySelectorAll(".node-group").forEach(node => {
        const nodeId = node.dataset.nodeId;
        if (selectedNodes.has(nodeId)) {
         node.classList.add("selected");
        } else {
         node.classList.remove("selected");
        }
       });
       
       const bulkToolbar = document.getElementById("bulk-toolbar");
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       const bulkCount = document.getElementById("bulk-count");
       const bulkCountMobile = document.getElementById("bulk-count-mobile");
       const bulkCountModal = document.getElementById("bulk-count-modal");
       
       if (selectedNodes.size > 0) {
        if (bulkToolbar) bulkToolbar.style.display = "flex";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
        if (bulkCount) bulkCount.textContent = selectedNodes.size;
        if (bulkCountMobile) bulkCountMobile.textContent = selectedNodes.size;
        if (bulkCountModal) bulkCountModal.textContent = selectedNodes.size;
       } else {
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        const modal = document.getElementById("bulk-actions-modal");
        if (modal) modal.style.display = "none";
       }
      }
      
      function deleteSelected() {
       const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
       if (total === 0) return;
       
       let nodesInsideRacks = [];
       selectedNodes.forEach(nodeId => {
        if (NODE_DATA[nodeId]?.isRack) {
         Object.entries(NODE_DATA).forEach(([id, n]) => {
          if (n.assignedRack === nodeId) nodesInsideRacks.push(n.name || id);
         });
        }
       });
       
       let message = `Delete ${total} selected item(s)?`;
       if (nodesInsideRacks.length > 0) {
        message += `\n\nThis will also delete ${nodesInsideRacks.length} node(s) inside rack(s):\n• ${nodesInsideRacks.join('\n• ')}`;
       }
       
       challengeTheImmortal(message, () => {
        pushUndo("delete selected");
        selectedNodes.forEach(nodeId => {
         if (NODE_DATA[nodeId]?.isRack) {
          Object.keys(NODE_DATA).forEach(id => {
           if (NODE_DATA[id]?.assignedRack === nodeId) {
            EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== id && e.to !== id);
            delete NODE_DATA[id];
            delete savedPositions[id];
            delete savedSizes[id];
            delete savedStyles[id];
           }
          });
         }
         delete NODE_DATA[nodeId];
         delete savedPositions[nodeId];
         delete savedSizes[nodeId];
         delete savedStyles[nodeId];
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== nodeId && e.to !== nodeId);
        });
        selectedEdges.forEach(edgeId => {
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.id !== edgeId);
        });
        selectedRects.forEach(rectId => {
         RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== rectId);
        });
        selectedTexts.forEach(textId => {
         TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== textId);
        });
        clearSelection();
       
        forgeTheTopology();
       });
      }
      
      function startSelection(event) {
       const svgEl = document.getElementById("map");
       const pt = svgEl.createSVGPoint();
       pt.x = event.clientX;
       pt.y = event.clientY;
       const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
       
       isSelecting = true;
       selectionStart = { x: svgP.x, y: svgP.y };
       
       if (!selectionRect || !selectionRect.parentNode) {
        selectionRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        selectionRect.setAttribute("fill", selectionBoxStyle.fillColor);
        selectionRect.setAttribute("fill-opacity", selectionBoxStyle.fillOpacity);
        selectionRect.setAttribute("stroke", selectionBoxStyle.strokeColor);
        selectionRect.setAttribute("stroke-width", selectionBoxStyle.strokeWidth);
        selectionRect.setAttribute("stroke-dasharray", selectionBoxStyle.strokeDasharray);
        selectionRect.style.pointerEvents = "none";
        svgEl.appendChild(selectionRect);
       }
       
       if (!event.shiftKey) {
        selectedNodes.clear();
        selectedEdges.clear();
        selectedRects.clear();
        selectedTexts.clear();
       }
       
       preDragSelectedNodes = new Set(selectedNodes);
       preDragSelectedEdges = new Set(selectedEdges);
       preDragSelectedRects = new Set(selectedRects);
       preDragSelectedTexts = new Set(selectedTexts);
      }
      
      function updateSelection(event) {
       if (!isSelecting || !selectionStart) return;
       
       const svgEl = document.getElementById("map");
       const pt = svgEl.createSVGPoint();
       pt.x = event.clientX;
       pt.y = event.clientY;
       const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
       
       const x = Math.min(selectionStart.x, svgP.x);
       const y = Math.min(selectionStart.y, svgP.y);
       const width = Math.abs(svgP.x - selectionStart.x);
       const height = Math.abs(svgP.y - selectionStart.y);
       
       selectionRect.setAttribute("x", x);
       selectionRect.setAttribute("y", y);
       selectionRect.setAttribute("width", width);
       selectionRect.setAttribute("height", height);
       selectionRect.style.display = "block";
       
       const box = { x, y, width, height };
       
       Object.entries(savedPositions).forEach(([nodeId, pos]) => {
        const size = savedSizes[nodeId] || 50;
        const halfSize = size / 2;
        const nodeBox = { x: pos.x - halfSize, y: pos.y - halfSize, width: size, height: size };
        if (boxesIntersect(box, nodeBox)) {
         selectedNodes.add(nodeId);
        } else if (!preDragSelectedNodes.has(nodeId)) {
         selectedNodes.delete(nodeId);
        }
       });
       
       EDGE_DATA.list.forEach(edge => {
        if (!edge.points || edge.points.length === 0) return;
        for (let i = 0; i < edge.points.length - 1; i++) {
         const p1 = edge.points[i];
         const p2 = edge.points[i + 1];
         if (lineIntersectsBox(p1.x, p1.y, p2.x, p2.y, box)) {
          selectedEdges.add(edge.id);
          return;
         }
        }
        if (!preDragSelectedEdges.has(edge.id)) {
         selectedEdges.delete(edge.id);
        }
       });
       
       RECT_DATA.list.forEach(rect => {
        const rectBox = { x: rect.x, y: rect.y, width: rect.width, height: rect.height };
        if (boxesIntersect(box, rectBox)) {
         selectedRects.add(rect.id);
        } else if (!preDragSelectedRects.has(rect.id)) {
         selectedRects.delete(rect.id);
        }
       });
       
       TEXT_DATA.list.forEach(text => {
        const fontSize = text.fontSize || 18;
        const textBox = { x: text.x - 50, y: text.y - fontSize, width: 100, height: fontSize * 1.5 };
        if (boxesIntersect(box, textBox)) {
         selectedTexts.add(text.id);
        } else if (!preDragSelectedTexts.has(text.id)) {
         selectedTexts.delete(text.id);
        }
       });
       
       updateAllSelectionVisuals();
      }
      
      function endSelection() {
       isSelecting = false;
       selectionStart = null;
       if (selectionRect) {
        selectionRect.style.display = "none";
       }
      }
      
      function boxesIntersect(a, b) {
       return !(a.x + a.width < b.x || b.x + b.width < a.x || a.y + a.height < b.y || b.y + b.height < a.y);
      }
      
      function lineIntersectsBox(x1, y1, x2, y2, box) {
       if (pointInBox(x1, y1, box) || pointInBox(x2, y2, box)) return true;
       const lines = [
        [box.x, box.y, box.x + box.width, box.y],
        [box.x + box.width, box.y, box.x + box.width, box.y + box.height],
        [box.x + box.width, box.y + box.height, box.x, box.y + box.height],
        [box.x, box.y + box.height, box.x, box.y]
       ];
       for (const [bx1, by1, bx2, by2] of lines) {
        if (linesIntersect(x1, y1, x2, y2, bx1, by1, bx2, by2)) return true;
       }
       return false;
      }
      
      function pointInBox(x, y, box) {
       return x >= box.x && x <= box.x + box.width && y >= box.y && y <= box.y + box.height;
      }
      
      function linesIntersect(x1, y1, x2, y2, x3, y3, x4, y4) {
       const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
       if (Math.abs(denom) < 0.0001) return false;
       const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom;
       const ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denom;
       return ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1;
      }
      
      function updateAllSelectionVisuals() {
       document.querySelectorAll(".node-group").forEach(node => {
        const nodeId = node.dataset.nodeId;
        if (selectedNodes.has(nodeId)) {
         node.classList.add("selected");
        } else {
         node.classList.remove("selected");
        }
       });
       
       document.querySelectorAll(".edge").forEach(edge => {
        const edgeId = edge.dataset.edgeId;
        if (selectedEdges.has(edgeId)) {
         edge.style.filter = "drop-shadow(0 0 6px #4fd1c5)";
        } else {
         edge.style.filter = "";
        }
       });
       
       document.querySelectorAll(".rect-group rect").forEach(el => {
        const rectId = el.closest(".rect-group")?.dataset?.rectId;
        if (selectedRects.has(rectId)) {
         el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
        } else {
         el.style.filter = "";
        }
       });
       
       document.querySelectorAll(".text-group, .text-element").forEach(el => {
        const textId = el.dataset?.textId;
        if (selectedTexts.has(textId)) {
         el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
        } else {
         el.style.filter = "";
        }
       });
       
       const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
       const bulkToolbar = document.getElementById("bulk-toolbar");
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       const bulkCount = document.getElementById("bulk-count");
       const bulkCountMobile = document.getElementById("bulk-count-mobile");
       
       if (total > 0) {
        if (bulkToolbar) bulkToolbar.style.display = "flex";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
        if (bulkCount) bulkCount.textContent = total;
        if (bulkCountMobile) bulkCountMobile.textContent = total;
       } else {
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
       }
      }
      
      function cloneNode(sourceId) {
       const source = NODE_DATA[sourceId];
       if (!source) return;
       
       pushUndo("clone node");
       
       let baseName = source.name;
       let copyNum = 0;
       let newName = baseName + " copy";
       while (Object.values(NODE_DATA).some(n => n.name === newName)) {
        copyNum++;
        newName = baseName + " copy " + copyNum;
       }
       
       const newId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
       
       NODE_DATA[newId] = {
        shape: source.shape,
        name: newName,
        ip: source.ip,
        role: source.role,
        tags: [...source.tags],
        notes: [...source.notes],
        mac: source.mac || "",
        rackUnit: source.rackUnit || "",
        uHeight: source.uHeight || "1",
        ping: source.ping ? JSON.parse(JSON.stringify(source.ping)) : {
         enabled: false,
         protocol: 'http',
         customUrl: '',
         timeout: 3000,
         status: 'unknown',
         lastCheck: null
        },
        layer: source.layer || "physical",
        assignedRack: source.assignedRack || "",
        rackCapacity: source.rackCapacity || "42",
        isRack: source.isRack || false
       };
      
       if (source.isRack) {
        const childNodes = Object.entries(NODE_DATA).filter(([id, n]) => 
         id !== newId && n.assignedRack === sourceId
        );
        childNodes.forEach(([childId, childNode]) => {
         let childBaseName = childNode.name;
         let c = 0;
         let childNewName = childBaseName + " copy";
         while (Object.values(NODE_DATA).some(n => n.name === childNewName)) {
          c++;
          childNewName = childBaseName + " copy " + c;
         }
         const childNewId = childNewName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
         NODE_DATA[childNewId] = {
          ...JSON.parse(JSON.stringify(childNode)),
          name: childNewName,
          assignedRack: newId
         };
         if (savedPositions[childId]) {
          savedPositions[childNewId] = { ...savedPositions[childId] };
         }
         if (savedSizes[childId]) {
          savedSizes[childNewId] = savedSizes[childId];
         }
         if (savedStyles[childId]) {
          savedStyles[childNewId] = JSON.parse(JSON.stringify(savedStyles[childId]));
         }
        });
       }
       
       if (savedSizes[sourceId]) {
        savedSizes[newId] = savedSizes[sourceId];
       }
       
       if (savedStyles[sourceId]) {
        savedStyles[newId] = JSON.parse(JSON.stringify(savedStyles[sourceId]));
       }
       
      if (currentView.mode === "rack" && currentView.rackId) {
        NODE_DATA[newId].assignedRack = currentView.rackId;
       }
       
       const sourcePos = savedPositions[sourceId];
       savedPositions[newId] = {
        x: sourcePos.x + 100,
        y: sourcePos.y + 100
       };
       
       forgeTheTopology();
       claimTheImmortal(newId);
      }
      
      function alignSelectedNodes(direction) {
       if (selectedNodes.size < 2) return;
       
       pushUndo("align nodes");
       
       const nodeIds = Array.from(selectedNodes);
       const positions = nodeIds.map(id => ({ id, pos: savedPositions[id] }));
       
       switch(direction) {
        case "left":
         const minX = Math.min(...positions.map(p => p.pos.x));
         positions.forEach(p => savedPositions[p.id].x = minX);
         break;
        case "right":
         const maxX = Math.max(...positions.map(p => p.pos.x));
         positions.forEach(p => savedPositions[p.id].x = maxX);
         break;
        case "top":
         const minY = Math.min(...positions.map(p => p.pos.y));
         positions.forEach(p => savedPositions[p.id].y = minY);
         break;
        case "bottom":
         const maxY = Math.max(...positions.map(p => p.pos.y));
         positions.forEach(p => savedPositions[p.id].y = maxY);
         break;
        case "center-h":
         const avgX = positions.reduce((sum, p) => sum + p.pos.x, 0) / positions.length;
         positions.forEach(p => savedPositions[p.id].x = avgX);
         break;
        case "center-v":
         const avgY = positions.reduce((sum, p) => sum + p.pos.y, 0) / positions.length;
         positions.forEach(p => savedPositions[p.id].y = avgY);
         break;
       }
       
       forgeTheTopology();
      }
      
      function distributeSelectedNodes(direction) {
       if (selectedNodes.size < 3) return;
       
       pushUndo("distribute nodes");
       
       const nodeIds = Array.from(selectedNodes);
       const positions = nodeIds.map(id => ({ id, pos: savedPositions[id] }));
       
       if (direction === "horizontal") {
        positions.sort((a, b) => a.pos.x - b.pos.x);
        const minX = positions[0].pos.x;
        const maxX = positions[positions.length - 1].pos.x;
        const gap = (maxX - minX) / (positions.length - 1);
        positions.forEach((p, i) => {
         savedPositions[p.id].x = minX + (gap * i);
        });
       } else if (direction === "vertical") {
        positions.sort((a, b) => a.pos.y - b.pos.y);
        const minY = positions[0].pos.y;
        const maxY = positions[positions.length - 1].pos.y;
        const gap = (maxY - minY) / (positions.length - 1);
        positions.forEach((p, i) => {
         savedPositions[p.id].y = minY + (gap * i);
        });
       }
       
       forgeTheTopology();
      }
      
      function snapToGrid(nodeId, gridSize = 50) {
       if (!savedPositions[nodeId]) return;
       
       pushUndo("snap to grid");
       
       const pos = savedPositions[nodeId];
       pos.x = Math.round(pos.x / gridSize) * gridSize;
       pos.y = Math.round(pos.y / gridSize) * gridSize;
       
       forgeTheTopology();
      }
      
      function nudgeSelectedNodes(direction, distance) {
        const nodesToNudge = selectedNodes.size > 0 
          ? Array.from(selectedNodes) 
          : (currentNodeId ? [currentNodeId] : []);
        
        if (nodesToNudge.length === 0) return;
        
        const unlockedNodes = nodesToNudge.filter(id => !NODE_DATA[id]?.locked);
        
        if (unlockedNodes.length === 0) {
          return;
        }
        
        pushUndo("nudge nodes");
        
        unlockedNodes.forEach(id => {
          if (!savedPositions[id]) {
            savedPositions[id] = { x: 0, y: 0 };
          }
          
          switch(direction) {
            case "ArrowUp":
              savedPositions[id].y -= distance;
              break;
            case "ArrowDown":
              savedPositions[id].y += distance;
              break;
            case "ArrowLeft":
              savedPositions[id].x -= distance;
              break;
            case "ArrowRight":
              savedPositions[id].x += distance;
              break;
          }
        });
        
        forgeTheTopology();
      }
      
      function cycleNodes(reverse = false) {
        const nodeIds = Object.keys(NODE_DATA).filter(id => {
          if (currentView.mode === "rack") {
           const node = NODE_DATA[id];
           return node && node.assignedRack === currentView.rackId;
          }
          return isNodeVisible(id);
         });
        
        if (nodeIds.length === 0) return;
        
        let currentIndex = nodeIds.indexOf(currentNodeId);
        
        if (reverse) {
          currentIndex = currentIndex <= 0 ? nodeIds.length - 1 : currentIndex - 1;
        } else {
          currentIndex = currentIndex >= nodeIds.length - 1 ? 0 : currentIndex + 1;
        }
        
        const nextNodeId = nodeIds[currentIndex];
        claimTheImmortal(nextNodeId);
        
        selectedNodes.clear();
        updateNodeSelection();
      }
      
      function focusOnSelected() {
        let minX = Infinity, minY = Infinity;
        let maxX = -Infinity, maxY = -Infinity;
        let hasItems = false;
        
        const nodesToFocus = selectedNodes.size > 0 
          ? Array.from(selectedNodes) 
          : (currentNodeId ? [currentNodeId] : []);
        nodesToFocus.forEach(id => {
          const pos = savedPositions[id];
          if (pos) {
            hasItems = true;
            const size = savedSizes[id] || 50;
            minX = Math.min(minX, pos.x - size/2);
            minY = Math.min(minY, pos.y - size/2);
            maxX = Math.max(maxX, pos.x + size/2);
            maxY = Math.max(maxY, pos.y + size/2);
          }
        });
        
        const rectsToFocus = selectedRects.size > 0 ? Array.from(selectedRects) : (currentRectId ? [currentRectId] : []);
        rectsToFocus.forEach(id => {
          const r = RECT_DATA.list.find(x => x.id === id);
          if (r) {
            hasItems = true;
            minX = Math.min(minX, r.x);
            minY = Math.min(minY, r.y);
            maxX = Math.max(maxX, r.x + r.width);
            maxY = Math.max(maxY, r.y + r.height);
          }
        });
        
        const textsToFocus = selectedTexts.size > 0 ? Array.from(selectedTexts) : (currentTextId ? [currentTextId] : []);
        textsToFocus.forEach(id => {
          const t = TEXT_DATA.list.find(x => x.id === id);
          if (t) {
            hasItems = true;
            minX = Math.min(minX, t.x - 50);
            minY = Math.min(minY, t.y - 20);
            maxX = Math.max(maxX, t.x + 50);
            maxY = Math.max(maxY, t.y + 20);
          }
        });
        
        const edgesToFocus = selectedEdges.size > 0 ? Array.from(selectedEdges) : (currentEdgeId ? [currentEdgeId] : []);
        edgesToFocus.forEach(id => {
          const e = EDGE_DATA.list.find(x => x.id === id);
          if (e) {
            const fromPos = savedPositions[e.from];
            const toPos = savedPositions[e.to];
            if (fromPos && toPos) {
              hasItems = true;
              minX = Math.min(minX, fromPos.x, toPos.x);
              minY = Math.min(minY, fromPos.y, toPos.y);
              maxX = Math.max(maxX, fromPos.x, toPos.x);
              maxY = Math.max(maxY, fromPos.y, toPos.y);
            }
          }
        });
        
        if (!hasItems || !isFinite(minX)) return;
        
        const padding = 100;
        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;
        const width = maxX - minX + padding * 2;
        const height = maxY - minY + padding * 2;
        
        const zoomX = CANVAS_WIDTH / width;
        const zoomY = CANVAS_HEIGHT / height;
        const targetZoom = Math.min(zoomX, zoomY, 2); 
        
        canvasState.zoom = targetZoom;
        canvasState.panX = centerX - (CANVAS_WIDTH / targetZoom) / 2;
        canvasState.panY = centerY - (CANVAS_HEIGHT / targetZoom) / 2;
        
        forgeTheTopology();
      }
      
      function toggleLockSelected() {
        const nodesToToggle = selectedNodes.size > 0 
          ? Array.from(selectedNodes) 
          : (currentNodeId ? [currentNodeId] : []);
        const rectsToToggle = selectedRects.size > 0 
          ? Array.from(selectedRects) 
          : (currentRectId ? [currentRectId] : []);
        const textsToToggle = selectedTexts.size > 0 
          ? Array.from(selectedTexts) 
          : (currentTextId ? [currentTextId] : []);
        
        if (nodesToToggle.length === 0 && rectsToToggle.length === 0 && textsToToggle.length === 0) return;
        
        pushUndo("toggle lock");
        
        let hasUnlocked = nodesToToggle.some(id => !NODE_DATA[id]?.locked);
        hasUnlocked = hasUnlocked || rectsToToggle.some(id => { const r = RECT_DATA.list.find(x => x.id === id); return r && !r.locked; });
        hasUnlocked = hasUnlocked || textsToToggle.some(id => { const t = TEXT_DATA.list.find(x => x.id === id); return t && !t.locked; });
        
        nodesToToggle.forEach(id => {
          if (NODE_DATA[id]) NODE_DATA[id].locked = hasUnlocked;
        });
        rectsToToggle.forEach(id => {
          const r = RECT_DATA.list.find(x => x.id === id);
          if (r) r.locked = hasUnlocked;
        });
        textsToToggle.forEach(id => {
          const t = TEXT_DATA.list.find(x => x.id === id);
          if (t) t.locked = hasUnlocked;
        });
        
        forgeTheTopology();
      }
      
      function toggleGroupSelected() {
      const nodesToGroup = Array.from(selectedNodes);
      const rectsToGroup = Array.from(selectedRects);
      const textsToGroup = Array.from(selectedTexts);
      const edgesToGroup = Array.from(selectedEdges);
      const totalItems = nodesToGroup.length + rectsToGroup.length + textsToGroup.length + edgesToGroup.length;
      if (totalItems < 2) return;
      
      pushUndo("toggle group");
      
      const allGroupIds = [];
      nodesToGroup.forEach(id => { if (NODE_DATA[id]?.groupId) allGroupIds.push(NODE_DATA[id].groupId); });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r?.groupId) allGroupIds.push(r.groupId); });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t?.groupId) allGroupIds.push(t.groupId); });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e?.groupId) allGroupIds.push(e.groupId); });
      const uniqueGroups = [...new Set(allGroupIds)];
      
      if (uniqueGroups.length === 1 && allGroupIds.length === totalItems) {
      nodesToGroup.forEach(id => { if (NODE_DATA[id]) NODE_DATA[id].groupId = null; });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r) r.groupId = null; });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t) t.groupId = null; });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e) e.groupId = null; });
      } else {
      const newGroupId = "group-" + Date.now();
      nodesToGroup.forEach(id => { if (NODE_DATA[id]) NODE_DATA[id].groupId = newGroupId; });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r) r.groupId = newGroupId; });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t) t.groupId = newGroupId; });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e) e.groupId = newGroupId; });
      }
      
      forgeTheTopology();
      }
      
      function handleKeyDown(event) {
       if (event.target.tagName === "INPUT" || event.target.tagName === "TEXTAREA" || event.target.isContentEditable) {
        return;
       }
      
       if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(event.key)) {
        event.preventDefault();
        const distance = event.shiftKey ? 10 : 1;
        nudgeSelectedNodes(event.key, distance);
       }
       
       if (event.key === "Tab") {
        event.preventDefault();
        cycleNodes(event.shiftKey);
       }
       
       if (event.key === "f" || event.key === "F") {
        event.preventDefault();
        focusOnSelected();
       }
       
       if (event.key === "l" || event.key === "L") {
        event.preventDefault();
        toggleLockSelected();
       }
       
       if (event.key === "g" || event.key === "G") {
        event.preventDefault();
        toggleGroupSelected();
       }
       
       if (event.ctrlKey && event.key === "z" && !event.shiftKey) {
        event.preventDefault();
        undo();
       }
       
       if ((event.ctrlKey && event.key === "y") || (event.ctrlKey && event.shiftKey && event.key === "z")) {
        event.preventDefault();
        redo();
       }
       
       if (event.ctrlKey && event.key === "c") {
        event.preventDefault();
        clipboard = null;
        if (currentNodeId && NODE_DATA[currentNodeId]) {
         clipboard = {
          type: "node",
          data: JSON.parse(JSON.stringify(NODE_DATA[currentNodeId])),
          size: savedSizes[currentNodeId],
          style: savedStyles[currentNodeId] ? JSON.parse(JSON.stringify(savedStyles[currentNodeId])) : null
         };
        } else if (currentEdgeId) {
         const edge = EDGE_DATA.list.find(e => e.id === currentEdgeId);
         if (edge) clipboard = { type: "edge", data: JSON.parse(JSON.stringify(edge)) };
        } else if (currentRectId) {
         const rect = RECT_DATA.list.find(r => r.id === currentRectId);
         if (rect) clipboard = { type: "rect", data: JSON.parse(JSON.stringify(rect)) };
        } else if (currentTextId) {
         const text = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (text) clipboard = { type: "text", data: JSON.parse(JSON.stringify(text)) };
        }
       }
       
       if (event.ctrlKey && event.key === "v") {
        event.preventDefault();
        if (!clipboard) return;
        const svgEl = document.getElementById("map");
        const rect = svgEl.getBoundingClientRect();
        const pt = svgEl.createSVGPoint();
        pt.x = rect.left + rect.width / 2;
        pt.y = rect.top + rect.height / 2;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const centerX = svgP.x;
        const centerY = svgP.y;
        
        if (clipboard.type === "node") {
         let newName = clipboard.data.name + " copy";
         let counter = 1;
         while (Object.values(NODE_DATA).some(n => n.name === newName)) {
          newName = clipboard.data.name + " copy " + counter;
          counter++;
         }
         let newId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
         counter = 1;
         while (NODE_DATA[newId]) {
          newId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-") + "-" + counter;
          counter++;
         }
         pushUndo("paste node");
         NODE_DATA[newId] = { ...JSON.parse(JSON.stringify(clipboard.data)), name: newName };
         savedPositions[newId] = { x: centerX, y: centerY };
         if (clipboard.size) savedSizes[newId] = clipboard.size;
         if (clipboard.style) savedStyles[newId] = JSON.parse(JSON.stringify(clipboard.style));
         forgeTheTopology();
         claimTheImmortal(newId);
        } else if (clipboard.type === "edge") {
         pushUndo("paste edge");
         const newEdge = { ...clipboard.data, id: "edge-" + Date.now() };
         EDGE_DATA.list.push(newEdge);
        
         forgeTheTopology();
         selectTheConnection(newEdge.id);
        } else if (clipboard.type === "rect") {
         pushUndo("paste rect");
         const newRect = { ...clipboard.data, id: "rect-" + Date.now(), x: centerX - (clipboard.data.width || 100) / 2, y: centerY - (clipboard.data.height || 100) / 2 };
         RECT_DATA.list.push(newRect);
         forgeTheTopology();
         selectTheRect(newRect.id);
        } else if (clipboard.type === "text") {
         pushUndo("paste text");
         const newText = { ...clipboard.data, id: "text-" + Date.now(), x: centerX, y: centerY };
         TEXT_DATA.list.push(newText);
         forgeTheTopology();
         showTextPanel(newText.id);
        }
       }
       
       if (event.ctrlKey && event.key === "d") {
        event.preventDefault();
        if (currentNodeId && NODE_DATA[currentNodeId]) {
         cloneNode(currentNodeId);
        } else if (currentEdgeId) {
         const edge = EDGE_DATA.list.find(e => e.id === currentEdgeId);
         if (edge) {
          pushUndo("clone edge");
          const newEdge = { ...JSON.parse(JSON.stringify(edge)), id: "edge-" + Date.now() };
          EDGE_DATA.list.push(newEdge);
         
          forgeTheTopology();
          selectTheConnection(newEdge.id);
         }
        } else if (currentRectId) {
         const rect = RECT_DATA.list.find(r => r.id === currentRectId);
         if (rect) {
          pushUndo("clone rect");
          const newRect = { ...JSON.parse(JSON.stringify(rect)), id: "rect-" + Date.now(), x: rect.x + 50, y: rect.y + 50 };
          RECT_DATA.list.push(newRect);
          forgeTheTopology();
          selectTheRect(newRect.id);
         }
        } else if (currentTextId) {
         const text = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (text) {
          pushUndo("clone text");
          const newText = { ...JSON.parse(JSON.stringify(text)), id: "text-" + Date.now(), x: text.x + 50, y: text.y + 50 };
          TEXT_DATA.list.push(newText);
          forgeTheTopology();
          showTextPanel(newText.id);
         }
        }
       }
       
       if (event.key === "Delete") {
        event.preventDefault();
        const totalSelected = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
        if (totalSelected > 0) {
         deleteSelected();
        } else if (currentNodeId && NODE_DATA[currentNodeId]) {
         challengeTheImmortal(`Delete node "${NODE_DATA[currentNodeId].name}"?`, () => {
          pushUndo("delete node");
          delete NODE_DATA[currentNodeId];
          delete savedPositions[currentNodeId];
          delete savedSizes[currentNodeId];
          delete savedStyles[currentNodeId];
          EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== currentNodeId && e.to !== currentNodeId);
          currentNodeId = null;
         
          forgeTheTopology();
          document.getElementById("node-panel").style.display = "none";
         });
        } else if (currentEdgeId) {
         challengeTheImmortal("Delete this line?", () => {
          pushUndo("delete edge");
          EDGE_DATA.list = EDGE_DATA.list.filter(e => e.id !== currentEdgeId);
          currentEdgeId = null;
         
          forgeTheTopology();
          document.getElementById("edge-panel").style.display = "none";
         });
        } else if (currentRectId) {
         challengeTheImmortal("Delete this zone?", () => {
          pushUndo("delete rect");
          RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== currentRectId);
          currentRectId = null;
          forgeTheTopology();
          document.getElementById("rect-panel").style.display = "none";
         });
        } else if (currentTextId) {
         const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (textItem) {
          challengeTheImmortal(`Delete text "${textItem.content.substring(0, 30)}..."?`, () => {
           pushUndo("delete text");
           TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== currentTextId);
           currentTextId = null;
           forgeTheTopology();
           document.getElementById("text-panel").style.display = "none";
          });
         }
        }
       }
       
       if (event.ctrlKey && event.key === "a") {
        event.preventDefault();
        Object.keys(NODE_DATA).forEach(id => selectedNodes.add(id));
        EDGE_DATA.list.forEach(e => selectedEdges.add(e.id));
        RECT_DATA.list.forEach(r => selectedRects.add(r.id));
        TEXT_DATA.list.forEach(t => selectedTexts.add(t.id));
        updateNodeSelection();
       }
       
       if (event.key === "Escape") {
        clearSelection();
       }
      }
      
      function searchNodes(query) {
       clearSearchHighlight();
       
       if (!query || query.trim() === "") return;
       
       const lowerQuery = query.toLowerCase();
       const matchingIds = [];
       
       Object.entries(NODE_DATA).forEach(([id, node]) => {
        const searchableText = [
         node.name,
         node.ip,
         node.role,
         ...(node.tags || []),
         node.mac || "",
         node.rackUnit || ""
        ].join(" ").toLowerCase();
        
        if (searchableText.includes(lowerQuery)) {
         matchingIds.push(id);
        }
       });
       
       highlightSearchResults(matchingIds);
      }
      
      function highlightSearchResults(nodeIds) {
       clearSearchHighlight();
       nodeIds.forEach(id => {
        const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`);
        if (nodeGroup) {
         nodeGroup.classList.add("search-highlight");
        }
       });
      }
      
      function clearSearchHighlight() {
       document.querySelectorAll(".node-group").forEach(node => {
        node.classList.remove("search-highlight");
       });
      }
      
      function editNodeMac(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       
       document.getElementById("modal-title").textContent = "Edit MAC Address";
       document.getElementById("modal-input").value = node.mac || "";
       document.getElementById("edit-modal").style.display = "flex";
       document.getElementById("modal-input").focus();
       
       const saveHandler = () => {
        pushUndo("edit mac");
        const value = document.getElementById("modal-input").value.trim();
        node.mac = value;
        document.getElementById("edit-modal").style.display = "none";
        claimTheImmortal(id);
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       
       const cancelHandler = () => {
        document.getElementById("edit-modal").style.display = "none";
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       
       document.getElementById("edit-modal").addEventListener("click", function bgHandler(e) {
        if (e.target === document.getElementById("edit-modal")) {
         cancelHandler();
         document.getElementById("edit-modal").removeEventListener("click", bgHandler);
        }
       });
      }
      
      function editNodeRack(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       
       document.getElementById("modal-title").textContent = "Edit Rack Unit";
       document.getElementById("modal-input").value = node.rackUnit || "";
       document.getElementById("edit-modal").style.display = "flex";
       document.getElementById("modal-input").focus();
       
       const saveHandler = () => {
        pushUndo("edit rack");
        const value = document.getElementById("modal-input").value.trim();
        node.rackUnit = value;
        document.getElementById("edit-modal").style.display = "none";
        claimTheImmortal(id);
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       
       const cancelHandler = () => {
        document.getElementById("edit-modal").style.display = "none";
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       
       document.getElementById("edit-modal").addEventListener("click", function bgHandler(e) {
        if (e.target === document.getElementById("edit-modal")) {
         cancelHandler();
         document.getElementById("edit-modal").removeEventListener("click", bgHandler);
        }
       });
      }
      
      function editNodeUHeight(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       
       document.getElementById("modal-title").textContent = "Edit U Height";
       document.getElementById("modal-input").value = node.uHeight || "1";
       document.getElementById("edit-modal").style.display = "flex";
       document.getElementById("modal-input").focus();
       
       const saveHandler = () => {
        pushUndo("edit U height");
        const value = document.getElementById("modal-input").value.trim();
        node.uHeight = value;
        document.getElementById("edit-modal").style.display = "none";
        claimTheImmortal(id);
        forgeTheTopology();
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       
       const cancelHandler = () => {
        document.getElementById("edit-modal").style.display = "none";
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       
       document.getElementById("edit-modal").addEventListener("click", function bgHandler(e) {
        if (e.target === document.getElementById("edit-modal")) {
         cancelHandler();
         document.getElementById("edit-modal").removeEventListener("click", bgHandler);
        }
       });
      }
      
      function updateEdgePortLabels(edgeId) {
       const edge = EDGE_DATA.list.find(e => e.id === edgeId);
       if (!edge) return;
       
       const fromPortInput = document.getElementById("edge-from-port");
       const toPortInput = document.getElementById("edge-to-port");
       
       edge.fromPort = fromPortInput ? fromPortInput.value.trim() : "";
       edge.toPort = toPortInput ? toPortInput.value.trim() : "";
       
      
       forgeTheTopology();
      }
      
      document.addEventListener("keydown", handleKeyDown);
      
      const undoBtn = document.getElementById("undo-btn");
      const redoBtn = document.getElementById("redo-btn");
      if (undoBtn) undoBtn.addEventListener("click", undo);
      if (redoBtn) redoBtn.addEventListener("click", redo);
      
      const backToTopologyBtn = document.getElementById("back-to-topology-btn");
      if (backToTopologyBtn) {
       backToTopologyBtn.addEventListener("click", exitRack);
      }
      
      const bulkToolbarClose = document.getElementById("bulk-toolbar-close");
      if (bulkToolbarClose) {
       bulkToolbarClose.addEventListener("click", clearSelection);
      }
      
      const bulkAlignLeft = document.getElementById("bulk-align-left");
      if (bulkAlignLeft) {
       bulkAlignLeft.addEventListener("click", () => alignSelectedNodes("left"));
      }
      
      const bulkAlignRight = document.getElementById("bulk-align-right");
      if (bulkAlignRight) {
       bulkAlignRight.addEventListener("click", () => alignSelectedNodes("right"));
      }
      
      const bulkAlignTop = document.getElementById("bulk-align-top");
      if (bulkAlignTop) {
       bulkAlignTop.addEventListener("click", () => alignSelectedNodes("top"));
      }
      
      const bulkAlignBottom = document.getElementById("bulk-align-bottom");
      if (bulkAlignBottom) {
       bulkAlignBottom.addEventListener("click", () => alignSelectedNodes("bottom"));
      }
      
      const bulkDistributeH = document.getElementById("bulk-distribute-h");
      if (bulkDistributeH) {
       bulkDistributeH.addEventListener("click", () => distributeSelectedNodes("horizontal"));
      }
      
      const bulkDistributeV = document.getElementById("bulk-distribute-v");
      if (bulkDistributeV) {
       bulkDistributeV.addEventListener("click", () => distributeSelectedNodes("vertical"));
      }
      
      const bulkClone = document.getElementById("bulk-clone");
      if (bulkClone) {
       bulkClone.addEventListener("click", () => {
        if (selectedNodes.size === 0) return;
        pushUndo("clone selected");
        const nodesToClone = Array.from(selectedNodes);
        selectedNodes.clear();
        nodesToClone.forEach(id => {
         cloneNode(id);
         selectedNodes.add(currentNodeId);
        });
        updateNodeSelection();
       });
      }
      
      const bulkDelete = document.getElementById("bulk-delete");
      if (bulkDelete) {
       bulkDelete.addEventListener("click", deleteSelected);
      }
      
      const bulkMobileBtn = document.getElementById("bulk-mobile-btn");
      const bulkActionsModal = document.getElementById("bulk-actions-modal");
      const bulkModalClose = document.getElementById("bulk-modal-close");
      
      if (bulkMobileBtn) {
       bulkMobileBtn.addEventListener("click", () => {
        if (bulkActionsModal) bulkActionsModal.style.display = "block";
       });
      }
      
      if (bulkModalClose) {
       bulkModalClose.addEventListener("click", () => {
        if (bulkActionsModal) bulkActionsModal.style.display = "none";
       });
      }
      
      const closeModalAfterAction = () => {
       if (bulkActionsModal) bulkActionsModal.style.display = "none";
      };
      
      const bulkAlignLeftMobile = document.getElementById("bulk-align-left-mobile");
      if (bulkAlignLeftMobile) {
       bulkAlignLeftMobile.addEventListener("click", () => {
        alignSelectedNodes("left");
        closeModalAfterAction();
       });
      }
      
      const bulkAlignRightMobile = document.getElementById("bulk-align-right-mobile");
      if (bulkAlignRightMobile) {
       bulkAlignRightMobile.addEventListener("click", () => {
        alignSelectedNodes("right");
        closeModalAfterAction();
       });
      }
      
      const bulkAlignTopMobile = document.getElementById("bulk-align-top-mobile");
      if (bulkAlignTopMobile) {
       bulkAlignTopMobile.addEventListener("click", () => {
        alignSelectedNodes("top");
        closeModalAfterAction();
       });
      }
      
      const bulkAlignBottomMobile = document.getElementById("bulk-align-bottom-mobile");
      if (bulkAlignBottomMobile) {
       bulkAlignBottomMobile.addEventListener("click", () => {
        alignSelectedNodes("bottom");
        closeModalAfterAction();
       });
      }
      
      const bulkDistributeHMobile = document.getElementById("bulk-distribute-h-mobile");
      if (bulkDistributeHMobile) {
       bulkDistributeHMobile.addEventListener("click", () => {
        distributeSelectedNodes("horizontal");
        closeModalAfterAction();
       });
      }
      
      const bulkDistributeVMobile = document.getElementById("bulk-distribute-v-mobile");
      if (bulkDistributeVMobile) {
       bulkDistributeVMobile.addEventListener("click", () => {
        distributeSelectedNodes("vertical");
        closeModalAfterAction();
       });
      }
      
      const bulkCloneMobile = document.getElementById("bulk-clone-mobile");
      if (bulkCloneMobile) {
       bulkCloneMobile.addEventListener("click", () => {
        if (selectedNodes.size === 0) return;
        pushUndo("clone selected");
        const nodesToClone = Array.from(selectedNodes);
        selectedNodes.clear();
        nodesToClone.forEach(id => {
         cloneNode(id);
         selectedNodes.add(currentNodeId);
        });
        updateNodeSelection();
        closeModalAfterAction();
       });
      }
      
      const bulkDeleteMobile = document.getElementById("bulk-delete-mobile");
      if (bulkDeleteMobile) {
       bulkDeleteMobile.addEventListener("click", () => {
        deleteSelected();
        closeModalAfterAction();
       });
      }
      
      const bulkLockMobile = document.getElementById("bulk-lock-mobile");
      if (bulkLockMobile) {
       bulkLockMobile.addEventListener("click", () => {
        toggleLockSelected();
        closeModalAfterAction();
       });
      }
      
      const bulkGroupMobile = document.getElementById("bulk-group-mobile");
      if (bulkGroupMobile) {
       bulkGroupMobile.addEventListener("click", () => {
        toggleGroupSelected();
        closeModalAfterAction();
       });
      }
      
      const bulkClearMobile = document.getElementById("bulk-clear-mobile");
      if (bulkClearMobile) {
       bulkClearMobile.addEventListener("click", () => {
        clearSelection();
        closeModalAfterAction();
       });
      }
      
      const searchInput = document.getElementById("search-input");
      if (searchInput) {
       searchInput.addEventListener("input", (e) => {
        searchNodes(e.target.value);
       });
      }
      
       document.getElementById("save-file-btn").addEventListener("click", becomeImmortal);
       document.getElementById("check-all-ping-btn").addEventListener("click", checkAllNodesStatus);
       const addNodeBtn = document.getElementById("add-node-btn");
       const addNodeModal = document.getElementById("add-node-modal");
       const addNodeCancel = document.getElementById("add-node-cancel");
       const addNodeSave = document.getElementById("add-node-save");
       addNodeBtn.addEventListener("click", () => {
	    if (isViewOnly()) return;
        document.getElementById("new-node-name").value = "";
        document.getElementById("new-node-ip").value = "";
        document.getElementById("new-node-tags").value = "";
        document.getElementById("new-node-shape").value = "circle";
        document.getElementById("new-node-pingable").checked = false;
        document.getElementById("new-node-ping-protocol").value = "http";
        document.getElementById("new-node-custom-url").value = "";
        document.getElementById("new-node-ping-timeout").value = "3000";
        document.getElementById("new-node-ping-options").style.display = "none";
        document.getElementById("new-node-custom-url-container").style.display = "none";
        newNodeIconTags = [];
        document.getElementById("new-node-icon-tags").style.display = "none";
        document.getElementById("new-node-icon-tags-list").innerHTML = "";
        addNodeModal.classList.add("active");
        document.getElementById("new-node-name").focus();
       });
       
       const canvasViewport = document.getElementById("canvas-viewport");
       if (canvasViewport) {
        canvasViewport.addEventListener("dblclick", (e) => {
         if (currentView.mode === "rack" && e.target.id === "map") {
          exitRack();
         }
        });
       }
       
       const layersBtn = document.getElementById("layers-btn");
       const layerModal = document.getElementById("layer-modal");
       const layerModalClose = document.getElementById("layer-modal-close");
       if (layersBtn && layerModal) {
        layersBtn.addEventListener("click", () => {
         layerModal.classList.add("active");
        });
       }
       if (layerModalClose && layerModal) {
        layerModalClose.addEventListener("click", () => {
         layerModal.classList.remove("active");
        });
       }
       if (layerModal) {
        layerModal.addEventListener("click", (e) => {
         if (e.target === layerModal) {
          layerModal.classList.remove("active");
         }
        });
       }
      
       const tabsBtn = document.getElementById("tabs-btn");
       const tabsModal = document.getElementById("tabs-modal");
       const tabsModalClose = document.getElementById("tabs-modal-close");
       if (tabsBtn && tabsModal) {
         tabsBtn.addEventListener("click", () => {
           displayTabs();
           tabsModal.classList.add("active");
         });
       }
       if (tabsModalClose && tabsModal) {
         tabsModalClose.addEventListener("click", () => {
           tabsModal.classList.remove("active");
         });
       }
       if (tabsModal) {
         tabsModal.addEventListener("click", (e) => {
           if (e.target === tabsModal) {
             tabsModal.classList.remove("active");
           }
         });
       }
       
       const rollbackBtn = document.getElementById("rollback-btn");
       const rollbackModal = document.getElementById("rollback-modal");
       const rollbackModalClose = document.getElementById("rollback-modal-close");
       if (rollbackBtn && rollbackModal) {
         rollbackBtn.addEventListener("click", () => {
           loadRollbackVersions();
           rollbackModal.classList.add("active");
         });
       }
       if (rollbackModalClose && rollbackModal) {
         rollbackModalClose.addEventListener("click", () => {
           rollbackModal.classList.remove("active");
         });
       }
       if (rollbackModal) {
         rollbackModal.addEventListener("click", (e) => {
           if (e.target === rollbackModal) {
             rollbackModal.classList.remove("active");
           }
         });
       }
       
       const auditLogBtn = document.getElementById("audit-log-btn");
       const auditLogModal = document.getElementById("audit-log-modal");
       const auditLogModalClose = document.getElementById("audit-log-modal-close");
       if (auditLogBtn && auditLogModal) {
         auditLogBtn.addEventListener("click", () => {
           loadAuditLog();
           displayAuditLog();
           auditLogModal.classList.add("active");
         });
       }
       if (auditLogModalClose && auditLogModal) {
         auditLogModalClose.addEventListener("click", () => {
           auditLogModal.classList.remove("active");
         });
       }
       if (auditLogModal) {
         auditLogModal.addEventListener("click", (e) => {
           if (e.target === auditLogModal) {
             auditLogModal.classList.remove("active");
           }
         });
       }
      
       const auditFilter = document.getElementById("audit-filter");
       if (auditFilter) {
         auditFilter.addEventListener("change", (e) => {
           displayAuditLog(e.target.value);
         });
       }
       
       const secretsBtn = document.getElementById("secrets-btn");
       const secretsModal = document.getElementById("secrets-modal");
       const secretsModalClose = document.getElementById("secrets-modal-close");
       if (secretsBtn && secretsModal) {
         secretsBtn.addEventListener("click", () => {
           displaySecrets();
           secretsModal.classList.add("active");
         });
       }
       if (secretsModalClose && secretsModal) {
         secretsModalClose.addEventListener("click", () => {
           secretsModal.classList.remove("active");
         });
       }
       if (secretsModal) {
         secretsModal.addEventListener("click", (e) => {
           if (e.target === secretsModal) {
             secretsModal.classList.remove("active");
           }
         });
       }
       
       const secretEditorModal = document.getElementById("secret-editor-modal");
       if (secretEditorModal) {
         secretEditorModal.addEventListener("click", (e) => {
           if (e.target === secretEditorModal) {
             closeSecretEditor();
           }
         });
       }
       
       ["physical", "logical", "security", "application"].forEach(layer => {
        const checkbox = document.getElementById(`layer-${layer}`);
        if (checkbox) {
         checkbox.addEventListener("change", applyLayerFilter);
        }
       });
       
       const layerSelect = document.getElementById("node-layer");
       if (layerSelect) {
        layerSelect.addEventListener("change", (e) => {
         if (currentNodeId) {
          pushUndo("change layer");
          NODE_DATA[currentNodeId].layer = e.target.value;
          forgeTheTopology();
         }
        });
       }
       
       const assignedRackSelect = document.getElementById("node-assigned-rack");
       if (assignedRackSelect) {
        assignedRackSelect.addEventListener("change", (e) => {
      if (currentNodeId) {
      pushUndo("change assigned rack");
      EDGE_DATA.list = EDGE_DATA.list.filter(edge => edge.from !== currentNodeId && edge.to !== currentNodeId);
      NODE_DATA[currentNodeId].assignedRack = e.target.value;
      forgeTheTopology();
      claimTheImmortal(currentNodeId);
      }
      });
       }
       
       const rackCapacitySelect = document.getElementById("node-rack-capacity");
       if (rackCapacitySelect) {
        rackCapacitySelect.addEventListener("change", (e) => {
         if (currentNodeId) {
          pushUndo("change rack capacity");
          NODE_DATA[currentNodeId].rackCapacity = e.target.value;
          forgeTheTopology();
         }
        });
       }
       
       const addRackBtn = document.getElementById("add-rack-btn");
       const addRackModal = document.getElementById("add-rack-modal");
       const addRackCancel = document.getElementById("add-rack-cancel");
       const addRackSave = document.getElementById("add-rack-save");
       
       if (addRackBtn && addRackModal) {
        addRackBtn.addEventListener("click", () => {
		if (isViewOnly()) return;
         document.getElementById("new-rack-name").value = "";
         document.getElementById("new-rack-ip").value = "";
         document.getElementById("new-rack-tags").value = "";
         document.getElementById("new-rack-shape").value = "server";
         document.getElementById("new-rack-capacity").value = "42";
         selectedRackIconData = null;
         document.getElementById('selected-rack-icon').style.display = 'none';
         addRackModal.classList.add("active");
         document.getElementById("new-rack-name").focus();
        });
       }
       
       if (addRackCancel && addRackModal) {
        addRackCancel.addEventListener("click", () => {
         addRackModal.classList.remove("active");
        });
       }
       
       if (addRackModal) {
        addRackModal.addEventListener("click", (e) => {
         if (e.target === addRackModal) {
          addRackModal.classList.remove("active");
         }
        });
       }
       
       if (addRackSave && addRackModal) {
        addRackSave.addEventListener("click", () => {
         const name = document.getElementById("new-rack-name").value.trim();
         const ip = document.getElementById("new-rack-ip").value.trim();
         const tagsStr = document.getElementById("new-rack-tags").value.trim();
         const shape = document.getElementById("new-rack-shape").value;
         const capacity = document.getElementById("new-rack-capacity").value;
         
         if (!name) {
          alert("Please enter a rack name.");
          return;
         }
         
         const tags = tagsStr ? tagsStr.split(",").map((t) => t.trim()).filter((t) => t) : [];
         let baseId = name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");
         if (!baseId) baseId = "rack";
         let nodeId = baseId;
         let counter = 1;
         while (NODE_DATA[nodeId]) {
          nodeId = baseId + "-" + counter;
          counter++;
         }
         
         pushUndo("add rack");
         
         NODE_DATA[nodeId] = {
          shape: shape,
          name: name,
          ip: ip || "",
          role: "Rack",
          tags: tags,
          notes: [],
          mac: "",
          rackUnit: "",
          uHeight: "1",
          layer: "physical",
          assignedRack: "",
          rackCapacity: capacity,
          isRack: true,
          locked: false,
          groupId: null
         };
         
         const viewWidth = CANVAS_WIDTH / canvasState.zoom;
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         const centerX = canvasState.panX + (viewWidth / 2);
         const centerY = canvasState.panY + (viewHeight / 2);
         savedPositions[nodeId] = {
          x: centerX,
          y: centerY
         };
         
         if (selectedRackIconData) {
          if (!savedStyles[nodeId]) {
           savedStyles[nodeId] = {};
          }
          if (!savedStyles[nodeId]['all']) {
           savedStyles[nodeId]['all'] = {};
          }
          savedStyles[nodeId]['all'].icon = {
           library: selectedRackIconData.library,
           name: selectedRackIconData.name
          };
          selectedRackIconData = null;
          document.getElementById('selected-rack-icon').style.display = 'none';
         }
         
         addRackModal.classList.remove("active");
         forgeTheTopology();
         claimTheImmortal(nodeId);
        });
        
        ["new-rack-name", "new-rack-ip", "new-rack-tags"].forEach((inputId) => {
         const input = document.getElementById(inputId);
         if (input) {
          input.addEventListener("keypress", (e) => {
           if (e.key === "Enter") {
            addRackSave.click();
           }
          });
         }
        });
       }
       
       addNodeCancel.addEventListener("click", () => {
        addNodeModal.classList.remove("active");
       });
       addNodeModal.addEventListener("click", (e) => {
        if (e.target === addNodeModal) {
         addNodeModal.classList.remove("active");
        }
       });
       addNodeSave.addEventListener("click", () => {
        const name = document.getElementById("new-node-name").value.trim();
        const ip = document.getElementById("new-node-ip").value.trim();
        const tagsStr = document.getElementById("new-node-tags").value.trim();
        const shape = document.getElementById("new-node-shape").value;
        const pingable = document.getElementById("new-node-pingable").checked;
        const pingProtocol = document.getElementById("new-node-ping-protocol").value;
        const pingCustomUrl = document.getElementById("new-node-custom-url").value.trim();
        const pingTimeout = parseInt(document.getElementById("new-node-ping-timeout").value) || 3000;
        
        if (!name) {
         alert("Please enter a node name.");
         return;
        }
        const tags = tagsStr ? tagsStr.split(",").map((t) => t.trim()).filter((t) => t) : [];
        if (newNodeIconTags.length > 0) {
         tags.push(...newNodeIconTags);
        }
        let baseId = name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");
        if (!baseId) baseId = "node";
        let nodeId = baseId;
        let counter = 1;
        while (NODE_DATA[nodeId]) {
         nodeId = baseId + "-" + counter;
         counter++;
        }
        NODE_DATA[nodeId] = {
         shape: shape || "circle",
         name: name,
         ip: ip || "0.0.0.0",
         role: "",
         tags: tags,
         notes: [],
         mac: "",
         rackUnit: "",
         uHeight: "1",
         ping: {
          enabled: pingable,
          protocol: pingProtocol,
          customUrl: pingCustomUrl,
          timeout: pingTimeout,
          status: 'unknown',
          lastCheck: null
         },
         locked: false, 
         groupId: null 
        };
        
        if (currentView.mode === "rack" && currentView.rackId) {
         NODE_DATA[nodeId].assignedRack = currentView.rackId;
         NODE_DATA[nodeId].layer = "physical";
         const rackCapacity = getRackCapacity(currentView.rackId);
         const rackUHeight = getRackUHeight(currentView.rackId);
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         const centerY = canvasState.panY + (viewHeight / 2);
         let unit = rackCapacity - Math.round((centerY - RACK_START_Y) / rackUHeight);
         unit = Math.max(1, Math.min(rackCapacity, unit));
         NODE_DATA[nodeId].rackUnit = String(unit);
        }
        
        if (selectedNodeIconData) {
         if (!savedStyles[nodeId]) savedStyles[nodeId] = {};
         if (!savedStyles[nodeId]['all']) savedStyles[nodeId]['all'] = {};
         savedStyles[nodeId]['all'].icon = {
          library: selectedNodeIconData.library,
          name: selectedNodeIconData.name
         };
         selectedNodeIconData = null;
         document.getElementById('selected-node-icon').style.display = 'none';
        }
        newNodeIconTags = [];
      const viewWidth = CANVAS_WIDTH / canvasState.zoom;
      const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
      const centerX = canvasState.panX + (viewWidth / 2);
      const centerY = canvasState.panY + (viewHeight / 2);
      savedPositions[nodeId] = {
      x: centerX,
      y: centerY
      };
        addNodeModal.classList.remove("active");
        forgeTheTopology();
        claimTheImmortal(nodeId);
       });
       ["new-node-name", "new-node-ip", "new-node-tags"].forEach(
        (inputId) => {
         document.getElementById(inputId).addEventListener("keypress", (e) => {
          if (e.key === "Enter") {
           addNodeSave.click();
          }
         });
        }, );
       
       document.getElementById('new-node-pingable').addEventListener('change', (e) => {
        const pingOptions = document.getElementById('new-node-ping-options');
        pingOptions.style.display = e.target.checked ? 'block' : 'none';
       });
       
       document.getElementById('new-node-ping-protocol').addEventListener('change', (e) => {
        const customUrlContainer = document.getElementById('new-node-custom-url-container');
        customUrlContainer.style.display = e.target.value === 'custom' ? 'block' : 'none';
       });
       
       document.getElementById('pick-rack-icon-btn').addEventListener('click', () => {
        openIconPicker((iconData) => {
         selectedRackIconData = iconData;
         const preview = document.getElementById('selected-rack-icon-preview');
         const container = document.getElementById('selected-rack-icon');
         const parser = new DOMParser();
         const doc = parser.parseFromString(iconData.svg, 'image/svg+xml');
         const svgEl = doc.querySelector('svg');
         preview.innerHTML = '';
         if (svgEl) {
          preview.appendChild(svgEl.cloneNode(true));
         }
         const nameSpan = document.createElement('span');
         nameSpan.textContent = iconData.name;
         preview.appendChild(nameSpan);
         container.style.display = 'block';
        });
       });
       
       document.getElementById('pick-node-icon-btn').addEventListener('click', () => {
        openIconPicker((iconData) => {
         selectedNodeIconData = iconData;
         const preview = document.getElementById('selected-node-icon-preview');
         const container = document.getElementById('selected-node-icon');
         const parser = new DOMParser();
         const doc = parser.parseFromString(iconData.svg, 'image/svg+xml');
         const svgEl = doc.querySelector('svg');
         preview.innerHTML = '';
         if (svgEl) {
          preview.appendChild(svgEl.cloneNode(true));
         }
         const nameSpan = document.createElement('span');
         nameSpan.textContent = iconData.name;
         preview.appendChild(nameSpan);
         container.style.display = 'block';
        });
       });
       document.getElementById('pick-tag-icon-btn').addEventListener('click', () => {
        if (!currentNodeId) return;
        openIconPicker((iconData) => {
         if (!currentNodeId || !NODE_DATA[currentNodeId]) return;
         if (!NODE_DATA[currentNodeId].tags) {
          NODE_DATA[currentNodeId].tags = [];
         }
         NODE_DATA[currentNodeId].tags.push({
          type: 'icon',
          library: iconData.library,
          name: iconData.name
         });
         forgeTheTopology();
         claimTheImmortal(currentNodeId);
        });
       });
       document.getElementById('pick-new-node-tag-icon-btn').addEventListener('click', () => {
        openIconPicker((iconData) => {
         newNodeIconTags.push({
          type: 'icon',
          library: iconData.library,
          name: iconData.name
         });
         const container = document.getElementById('new-node-icon-tags');
         const list = document.getElementById('new-node-icon-tags-list');
         const badge = document.createElement('div');
         badge.className = 'icon-badge';
         badge.style.cssText = 'display: inline-flex; align-items: center; gap: 6px; padding: 6px 10px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; font-size: 13px;';
         const iconPreview = document.createElement('div');
         iconPreview.style.cssText = 'width: 16px; height: 16px; display: flex; align-items: center; justify-content: center;';
         IconLibrary.getIcon(iconData.library, iconData.name).then(svg => {
          if (svg) {
           const parser = new DOMParser();
           const doc = parser.parseFromString(svg, 'image/svg+xml');
           const svgEl = doc.querySelector('svg');
           if (svgEl) {
            svgEl.setAttribute('width', '16');
            svgEl.setAttribute('height', '16');
            svgEl.style.fill = 'var(--text-main)';
            iconPreview.appendChild(svgEl);
           }
          }
         });
         const name = document.createElement('span');
         name.textContent = iconData.name;
         name.style.color = 'var(--text-soft)';
         const removeBtn = document.createElement('button');
         removeBtn.textContent = '×';
         removeBtn.style.cssText = 'background: none; border: none; color: var(--danger); cursor: pointer; font-size: 18px; line-height: 1; padding: 0 4px;';
         removeBtn.addEventListener('click', () => {
          const index = newNodeIconTags.findIndex(t => t.type === 'icon' && t.library === iconData.library && t.name === iconData.name);
          if (index > -1) {
           newNodeIconTags.splice(index, 1);
          }
          badge.remove();
          if (list.children.length === 0) {
           container.style.display = 'none';
          }
         });
         badge.appendChild(iconPreview);
         badge.appendChild(name);
         badge.appendChild(removeBtn);
         list.appendChild(badge);
         container.style.display = 'block';
        });
       });
       document.getElementById('pick-shape-icon-btn').addEventListener('click', () => {
        if (!currentNodeId) return;
        openIconPicker((iconData) => {
         if (!savedStyles[currentNodeId]) {
          savedStyles[currentNodeId] = {};
         }
         if (!savedStyles[currentNodeId][currentStyleScope]) {
          savedStyles[currentNodeId][currentStyleScope] = {};
         }
         savedStyles[currentNodeId][currentStyleScope].icon = {
          library: iconData.library,
          name: iconData.name
         };
		 delete savedStyles[currentNodeId][currentStyleScope].circleColor;
         delete savedStyles[currentNodeId][currentStyleScope].circleBorder;
         const shapeSelect = document.getElementById('shape-select');
         if (!shapeSelect.querySelector('option[value="custom-icon"]')) {
          const opt = document.createElement('option');
          opt.value = 'custom-icon';
          opt.textContent = 'Custom Icon';
          shapeSelect.insertBefore(opt, shapeSelect.firstChild);
         }
         shapeSelect.value = 'custom-icon';
         forgeTheTopology();
        });
       });
       document.getElementById('add-tag-btn').addEventListener('click', () => {
        if (!currentNodeId) return;
        if (!NODE_DATA[currentNodeId]) return;
        const input = document.getElementById('new-tag-input');
        const tagText = input.value.trim();
        if (!tagText) return;
        if (!NODE_DATA[currentNodeId].tags) {
         NODE_DATA[currentNodeId].tags = [];
        }
        NODE_DATA[currentNodeId].tags.push(tagText);
        input.value = '';
        forgeTheTopology();
        claimTheImmortal(currentNodeId);
       });
      
      function saveRollbackVersion(description = "Auto-save") {
        const version = {
          timestamp: Date.now(),
          description,
          data: captureTheQuickening()
        };
        
        try {
          const stored = localStorage.getItem(ROLLBACK_STORAGE_KEY);
          rollbackVersions = stored ? JSON.parse(stored) : [];
        } catch (e) {
          rollbackVersions = [];
        }
        
        rollbackVersions.unshift(version);
        
        if (rollbackVersions.length > MAX_ROLLBACK_VERSIONS) {
          rollbackVersions = rollbackVersions.slice(0, MAX_ROLLBACK_VERSIONS);
        }
        
        try {
          localStorage.setItem(ROLLBACK_STORAGE_KEY, JSON.stringify(rollbackVersions));
        } catch (e) {
          console.warn("Failed to save rollback version:", e);
        }
      }
      
      function loadRollbackVersions() {
        try {
          const stored = localStorage.getItem(ROLLBACK_STORAGE_KEY);
          rollbackVersions = stored ? JSON.parse(stored) : [];
          displayRollbackVersions();
        } catch (e) {
          console.warn("Failed to load rollback versions:", e);
          rollbackVersions = [];
        }
      }
      
      function displayRollbackVersions() {
        const listEl = document.getElementById("rollback-list");
        if (!listEl) return;
        
        if (rollbackVersions.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No version history yet. Versions are saved automatically when you save the file.</div>';
          return;
        }
        
        listEl.innerHTML = rollbackVersions.map((version, index) => {
          const date = new Date(version.timestamp);
          const timeStr = date.toLocaleString();
          const nodeCount = Object.keys(version.data.nodeData || {}).length;
          const edgeCount = (version.data.edgeData?.list || []).length;
          
          return `
            <div class="version-item" onclick="restoreRollbackVersion(${index})">
              <div class="version-info">
                <div class="timestamp">${timeStr}</div>
                <div class="details">${version.description} • ${nodeCount} nodes • ${edgeCount} connections</div>
              </div>
              <div class="version-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteRollbackVersion(${index})" title="Delete this version">🗑️</button>
              </div>
            </div>
          `;
        }).join('');
      }
      
      function restoreRollbackVersion(index) {
        if (!confirm(`Restore version from ${new Date(rollbackVersions[index].timestamp).toLocaleString()}?\n\nYour current work will be lost unless you save first.`)) {
          return;
        }
        
        const version = rollbackVersions[index];
        const data = version.data;
        
        NODE_DATA = data.nodeData || {};
        EDGE_DATA = data.edgeData || { list: [] };
        RECT_DATA = data.rectData || { list: [] };
        TEXT_DATA = data.textData || { list: [] };
        EDGE_LEGEND = data.edgeLegend || {};
        savedPositions = data.nodePositions || {};
        savedSizes = data.nodeSizes || {};
        savedStyles = data.nodeStyles || {};
        PAGE_STATE = data.page || PAGE_STATE;
        
        if (data.canvas) {
          canvasState.zoom = data.canvas.zoom;
          canvasState.panX = data.canvas.panX;
          canvasState.panY = data.canvas.panY;
        }
        
        wieldThePower();
        forgeTheTopology();
        
        document.getElementById("rollback-modal").classList.remove("active");
        
        logAuditEvent("rollback", `Restored version from ${new Date(version.timestamp).toLocaleString()}`);
      }
      
      function deleteRollbackVersion(index) {
        if (!confirm("Delete this version from history?")) return;
        
        rollbackVersions.splice(index, 1);
        try {
          localStorage.setItem(ROLLBACK_STORAGE_KEY, JSON.stringify(rollbackVersions));
        } catch (e) {
          console.warn("Failed to delete version:", e);
        }
        displayRollbackVersions();
      }
      
      function clearRollbackHistory() {
        if (!confirm("Clear all version history?\n\nThis cannot be undone.")) return;
        
        rollbackVersions = [];
        localStorage.removeItem(ROLLBACK_STORAGE_KEY);
        displayRollbackVersions();
      }
      
      function createManualSnapshot() {
        const description = prompt("Enter a description for this snapshot:", "Manual snapshot");
        if (!description) return;
        
        saveRollbackVersion(description);
        displayRollbackVersions();
      }
      
      function switchTab(index) {
        if (index === currentTabIndex) return;
        
        const currentTab = documentTabs[currentTabIndex];
        currentTab.nodes = JSON.parse(JSON.stringify(NODE_DATA));
        currentTab.edges = JSON.parse(JSON.stringify(EDGE_DATA));
        currentTab.positions = JSON.parse(JSON.stringify(savedPositions));
        currentTab.sizes = JSON.parse(JSON.stringify(savedSizes));
        currentTab.styles = JSON.parse(JSON.stringify(savedStyles));
        currentTab.legend = JSON.parse(JSON.stringify(EDGE_LEGEND));
        currentTab.rects = JSON.parse(JSON.stringify(RECT_DATA));
        currentTab.texts = JSON.parse(JSON.stringify(TEXT_DATA));
        currentTab.pageState = JSON.parse(JSON.stringify(PAGE_STATE));
      
        currentTabIndex = index;
        const newTab = documentTabs[index];
        NODE_DATA = JSON.parse(JSON.stringify(newTab.nodes));
        EDGE_DATA = JSON.parse(JSON.stringify(newTab.edges));
        savedPositions = JSON.parse(JSON.stringify(newTab.positions));
        savedSizes = JSON.parse(JSON.stringify(newTab.sizes));
        savedStyles = JSON.parse(JSON.stringify(newTab.styles));
        EDGE_LEGEND = JSON.parse(JSON.stringify(newTab.legend));
        RECT_DATA = JSON.parse(JSON.stringify(newTab.rects));
        TEXT_DATA = JSON.parse(JSON.stringify(newTab.texts));
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, newTab.pageState || {});
        wieldThePower();
        document.title = PAGE_STATE.title || newTab.name;
        document.getElementById("page-title").textContent = PAGE_STATE.title || newTab.name;
        forgeTheTopology();
        currentNodeId = null;
        currentEdgeId = null;
        currentTextId = null;
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        displayTabs();
        
        logAuditEvent("tab", `Switched to tab: ${newTab.name}`);
      }
      
      function createNewTab() {
        const nameInput = document.getElementById("new-tab-name");
        const name = nameInput.value.trim();
        
        if (!name) {
          alert("Please enter a tab name");
          return;
        }
        
        const newTab = {
          id: `tab-${Date.now()}`,
          name,
          nodes: {},
          edges: { list: [] },
          positions: {},
          sizes: {},
          styles: {},
          legend: {},
          rects: { list: [] },
          texts: { list: [] },
      pageState: null
        };
        
        documentTabs.push(newTab);
        nameInput.value = "";
        displayTabs();
        
        logAuditEvent("tab", `Created new tab: ${name}`);
      }
      
      function renameTab(index) {
        const tab = documentTabs[index];
        const newName = prompt("Enter new name:", tab.name);
        if (!newName || newName === tab.name) return;
        
        tab.name = newName;
        displayTabs();
        
        logAuditEvent("tab", `Renamed tab to: ${newName}`);
      }
      
      function deleteTab(index) {
        if (documentTabs.length === 1) {
          alert("Cannot delete the last tab");
          return;
        }
        
        if (!confirm(`Delete tab "${documentTabs[index].name}"?`)) return;
        
        documentTabs.splice(index, 1);
        
        if (currentTabIndex >= documentTabs.length) {
          currentTabIndex = documentTabs.length - 1;
        }
        
        if (currentTabIndex === index) {
          switchTab(currentTabIndex);
        }
        
        displayTabs();
      }
      
      function displayTabs() {
        const listEl = document.getElementById("tabs-list");
        if (!listEl) return;
        
        listEl.innerHTML = documentTabs.map((tab, index) => {
          const nodeCount = Object.keys(tab.nodes).length;
          const edgeCount = tab.edges.list.length;
          const isActive = index === currentTabIndex;
          
          return `
            <div class="tab-item ${isActive ? 'active' : ''}" onclick="switchTab(${index})">
              <div class="tab-name">${tab.name}</div>
              <div class="tab-stats">${nodeCount} nodes • ${edgeCount} connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(${index})" title="Rename tab">✏️</button>
                ${documentTabs.length > 1 ? '<button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(${index})" title="Delete tab">🗑️</button>' : ''}
              </div>
            </div>
          `;
        }).join('');
      }
      
      function logAuditEvent(type, description, details = {}) {
        const event = {
          timestamp: Date.now(),
          type,
          description,
          details,
          tab: documentTabs[currentTabIndex]?.name || "Main"
        };
        
        auditLog.unshift(event);
        
        if (auditLog.length > MAX_AUDIT_ENTRIES) {
          auditLog = auditLog.slice(0, MAX_AUDIT_ENTRIES);
        }
        
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to save audit log:", e);
        }
      }
      
      function loadAuditLog() {
        let embeddedLog = [];
        let localLog = [];
        try {
          const stateScript = document.getElementById("topology-state");
          if (stateScript) {
            const stateData = JSON.parse(stateScript.textContent);
            if (stateData.auditLog && Array.isArray(stateData.auditLog)) {
              embeddedLog = stateData.auditLog;
            }
          }
        } catch (e) {
          console.warn("Failed to load embedded audit log:", e);
        }
        try {
          const stored = localStorage.getItem(AUDIT_STORAGE_KEY);
          if (stored) {
            localLog = JSON.parse(stored);
          }
        } catch (e) {
          console.warn("Failed to load localStorage audit log:", e);
        }
        const merged = [...embeddedLog, ...localLog];
        const seen = new Set();
        auditLog = merged.filter(entry => {
          const key = entry.timestamp + entry.description;
          if (seen.has(key)) return false;
          seen.add(key);
          return true;
        }).sort((a, b) => b.timestamp - a.timestamp);
        if (auditLog.length > MAX_AUDIT_ENTRIES) {
          auditLog = auditLog.slice(0, MAX_AUDIT_ENTRIES);
        }
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to sync audit log:", e);
        }
      }
      
      function displayAuditLog(filter = "all") {
        const listEl = document.getElementById("audit-log-list");
        if (!listEl) return;
        
        const filtered = filter === "all" ? auditLog : auditLog.filter(e => e.type === filter);
        
        if (filtered.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No audit entries yet</div>';
          return;
        }
        
        listEl.innerHTML = filtered.map(event => {
          const date = new Date(event.timestamp);
          const timeStr = date.toLocaleString();
          
          return `<div class="audit-entry ${event.type}">
              <div class="time">[${timeStr}] ${event.tab}</div>
              <div class="action">[${event.type.toUpperCase()}] ${event.description}</div>
            </div>
          `;
        }).join('');
      }
      
      function clearAuditLog() {
        if (!confirm("Clear all audit log entries?\n\nThis cannot be undone.")) return;
        
        auditLog = [];
        localStorage.removeItem(AUDIT_STORAGE_KEY);
        displayAuditLog();
      }
      
      function exportAuditLog() {
        if (auditLog.length === 0) {
          alert("No audit entries to export");
          return;
        }
        
        const csv = [
          ["Timestamp", "Tab", "Type", "Description"],
          ...auditLog.map(e => [
            new Date(e.timestamp).toISOString(),
            e.tab,
            e.type,
            e.description
          ])
        ].map(row => row.map(cell => `"${cell}"`).join(",")).join("\n");
        
        const blob = new Blob([csv], { type: "text/csv" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `audit-log-${Date.now()}.csv`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }
      
      let currentSecretName = null;
      
      function createNewSecret() {
        const nameInput = document.getElementById("new-secret-name");
        const name = nameInput.value.trim();
        
        if (!name) {
          alert("Please enter a note name");
          return;
        }
        
        if (encryptedSections[name]) {
          alert("A note note with this name already exists");
          return;
        }
        
        currentSecretName = name;
        encryptedSections[name] = { encrypted: false, data: "" };
        nameInput.value = "";
        
        document.getElementById("secret-editor-title").textContent = `New note: ${name}`;
        document.getElementById("secret-editor-content").value = "";
        document.getElementById("secrets-modal").classList.remove("active");
        document.getElementById("secret-editor-modal").classList.add("active");
        
        displaySecrets();
      }
      
      function editSecret(name) {
        currentSecretName = name;
        const section = encryptedSections[name];
        
        if (section.encrypted) {
          const password = prompt(`Enter password to decrypt "${name}":`);
          if (!password) return;
          
          try {
            decryptData(section.data, password).then(decrypted => {
              document.getElementById("secret-editor-title").textContent = `Edit Secret: ${name}`;
              document.getElementById("secret-editor-content").value = decrypted;
              document.getElementById("secrets-modal").classList.remove("active");
              document.getElementById("secret-editor-modal").classList.add("active");
            }).catch(e => {
              alert("Failed to decrypt. Wrong password?");
            });
          } catch (e) {
            alert("Failed to decrypt. Wrong password?");
          }
        } else {
          document.getElementById("secret-editor-title").textContent = `Edit note: ${name}`;
          document.getElementById("secret-editor-content").value = section.data;
          document.getElementById("secrets-modal").classList.remove("active");
          document.getElementById("secret-editor-modal").classList.add("active");
        }
      }
      
      async function saveSecret() {
        if (!currentSecretName) return;
        
        const content = document.getElementById("secret-editor-content").value;
        const autoEncrypt = document.getElementById("secret-auto-encrypt").checked;
        
        if (autoEncrypt) {
          const password = prompt(`Enter password to encrypt "${currentSecretName}":`);
          if (!password) return;
          
          const confirmPassword = prompt("Confirm password:");
          if (password !== confirmPassword) {
            alert("Passwords do not match");
            return;
          }
          
          try {
            const encrypted = await encryptData(content, password);
            encryptedSections[currentSecretName] = { encrypted: true, data: encrypted };
          } catch (e) {
            alert("Encryption failed: " + e.message);
            return;
          }
        } else {
          encryptedSections[currentSecretName] = { encrypted: false, data: content };
        }
        
        closeSecretEditor();
        displaySecrets();
        
        logAuditEvent("secret", `Saved note section: ${currentSecretName}`);
      }
      
      function closeSecretEditor() {
        document.getElementById("secret-editor-modal").classList.remove("active");
        document.getElementById("secrets-modal").classList.add("active");
        currentSecretName = null;
      }
      
      function deleteSecret(name) {
        if (!confirm(`Delete note "${name}"?`)) return;
        
        delete encryptedSections[name];
        displaySecrets();
        
        logAuditEvent("secret", `Deleted note: ${name}`);
      }
      
      function displaySecrets() {
        const listEl = document.getElementById("secrets-list");
        if (!listEl) return;
        
        const secrets = Object.keys(encryptedSections);
        
        if (secrets.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No notes yet</div>';
          return;
        }
        
        listEl.innerHTML = secrets.map(name => {
          const section = encryptedSections[name];
          const status = section.encrypted ? "🔒 Encrypted" : "🔓 Plaintext";
          
          return `
            <div class="secret-item">
              <div class="secret-name">${name}</div>
              <div class="secret-status">${status}</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="editSecret('${name}')" title="Edit note">✏️</button>
                <button class="btn-cancel" onclick="deleteSecret('${name}')" title="Delete note">🗑️</button>
              </div>
            </div>
          `;
        }).join('');
      }
      
       const clearAllBtn = document.getElementById("clear-all-btn");
       const clearAllModal = document.getElementById("clear-all-modal");
       const clearAllCancel = document.getElementById("clear-all-cancel");
       const clearAllConfirm = document.getElementById("clear-all-confirm");
       clearAllBtn.addEventListener("click", () => {
        clearAllModal.classList.add("active");
       });
       clearAllCancel.addEventListener("click", () => {
        clearAllModal.classList.remove("active");
       });
       clearAllModal.addEventListener("click", (e) => {
        if (e.target === clearAllModal) {
         clearAllModal.classList.remove("active");
        }
       });
       clearAllConfirm.addEventListener("click", () => {
        NODE_DATA = {};
        EDGE_DATA = {
         list: []
        };
        EDGE_LEGEND = {};
        RECT_DATA = { list: [] };
        TEXT_DATA = { list: [] };
        savedPositions = {};
        savedSizes = {};
        savedStyles = {};
		logAuditEvent("clear", "Cleared all data from canvas");
        clearAllModal.classList.remove("active");
      
      autoPingEnabled = false;
      autoPingInterval = 30;
      PAGE_STATE.autoPingEnabled = false;
      PAGE_STATE.autoPingInterval = autoPingInterval;
      
      stopAutoPing();
      
      document.getElementById("auto-ping-enabled").checked = false;
      document.getElementById("auto-ping-settings").style.display = "none";
      document.getElementById("auto-ping-interval").value = autoPingInterval;
        forgeTheTopology();
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.display = "none";
        currentNodeId = null;
        currentEdgeId = null;
        currentTextId = null;
       });
       (function addDeleteNodeButton() {
       const nodePanel = document.getElementById("node-panel");
       if (!nodePanel) return;
       let deleteBtn = document.getElementById("delete-node-btn");
       if (!deleteBtn) {
        deleteBtn = document.createElement("button");
        deleteBtn.id = "delete-node-btn";
        deleteBtn.textContent = "Delete Node";
        deleteBtn.style.cssText = "margin-top:15px; padding:10px 16px; background:var(--danger); color:#fff; border:none; border-radius:6px; cursor:pointer; font-size:clamp(14px,1.6vw,18px); font-weight:600; width:100%;";
        nodePanel.appendChild(deleteBtn);
       }
       deleteBtn.addEventListener("click", () => {
        if (!currentNodeId) return;
        const nodeData = NODE_DATA[currentNodeId];
        let confirmMessage;
        let nodesInsideRack = [];
        
        if (nodeData?.isRack) {
         nodesInsideRack = Object.entries(NODE_DATA)
          .filter(([id, n]) => n.assignedRack === currentNodeId)
          .map(([id, n]) => n.name || id);
         if (nodesInsideRack.length > 0) {
          confirmMessage = `Delete rack "${nodeData.name}"?\n\nThis will also delete ${nodesInsideRack.length} node(s) inside:\n• ${nodesInsideRack.join('\n• ')}`;
         } else {
          confirmMessage = `Delete rack "${nodeData.name}"? (empty rack)`;
         }
        } else {
         confirmMessage = `Delete node "${nodeData?.name || currentNodeId}" and all its connections?`;
        }
        
        challengeTheImmortal(confirmMessage, () => {
         pushUndo("delete node");
         if (nodeData?.isRack) {
          Object.keys(NODE_DATA).forEach(id => {
           if (NODE_DATA[id]?.assignedRack === currentNodeId) {
            EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== id && e.to !== id);
            delete NODE_DATA[id];
            delete savedPositions[id];
            delete savedSizes[id];
            delete savedStyles[id];
           }
          });
         }
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== currentNodeId && e.to !== currentNodeId);
         delete NODE_DATA[currentNodeId];
         delete savedPositions[currentNodeId];
         delete savedSizes[currentNodeId];
         delete savedStyles[currentNodeId];
         currentNodeId = null;
         currentEdgeId = null;
         forgeTheTopology();
         const remainingNodes = Object.keys(NODE_DATA);
         if (remainingNodes.length > 0) {
          claimTheImmortal(remainingNodes[0]);
         } else {
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("topology-toolbar").style.display = "none";
         }
        });
       });
      })();
      
       function screenshotCanvas() {
        const svg = document.getElementById("map");
        const svgClone = svg.cloneNode(true);
        const viewBox = svg.getAttribute("viewBox").split(" ").map(Number);
        const [x, y, width, height] = viewBox;
        svgClone.setAttribute("width", width);
        svgClone.setAttribute("height", height);
        svgClone.setAttribute("viewBox", `${x} ${y} ${width} ${height}`);
        const wrapper = document.createElement("div");
        wrapper.style.position = "absolute";
        wrapper.style.left = "-9999px";
        wrapper.appendChild(svgClone);
        document.body.appendChild(wrapper);
      
        function inlineStyles(original, clone) {
         const elements = original.querySelectorAll("*");
         const clonedElements = clone.querySelectorAll("*");
         const rootStyles = getComputedStyle(document.documentElement);
         const bgColor = rootStyles.getPropertyValue("--bg").trim() || "#050608";
         const bgRect = document.createElementNS("http://www.w3.org/2000/svg", "rect", );
         bgRect.setAttribute("x", x);
         bgRect.setAttribute("y", y);
         bgRect.setAttribute("width", width);
         bgRect.setAttribute("height", height);
         bgRect.setAttribute("fill", bgColor);
         clone.insertBefore(bgRect, clone.firstChild);
         elements.forEach((el, index) => {
          const clonedEl = clonedElements[index];
          if (!clonedEl) return;
          const computedStyle = getComputedStyle(el);
          const svgProps = ["fill", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin", "opacity", "font-family", "font-size", "font-weight", "font-style", "text-anchor", "dominant-baseline", "marker-start", "marker-end", ];
          svgProps.forEach((prop) => {
           const value = computedStyle.getPropertyValue(prop);
           if (value && value !== "none" && value !== "normal") {
            clonedEl.style[prop] = value;
           }
          });
          clonedEl.removeAttribute("class");
         });
        }
        inlineStyles(svg, svgClone);
        const svgData = new XMLSerializer().serializeToString(svgClone);
        document.body.removeChild(wrapper);
        const svgBlob = new Blob([svgData], {
         type: "image/svg+xml;charset=utf-8",
        });
        const url = URL.createObjectURL(svgBlob);
        const img = new Image();
        img.onload = function() {
         const canvas = document.createElement("canvas");
         canvas.width = width;
         canvas.height = height;
         const ctx = canvas.getContext("2d");
         ctx.drawImage(img, 0, 0);
         canvas.toBlob(function(blob) {
          const link = document.createElement("a");
          const timestamp = new Date().toISOString().slice(0, 10);
          link.download = `topology-${timestamp}.png`;
          link.href = URL.createObjectURL(blob);
          link.click();
          URL.revokeObjectURL(url);
          URL.revokeObjectURL(link.href);
         }, "image/png");
        };
        img.onerror = function() {
         console.error("Failed to load SVG image");
         alert("Screenshot failed. Please try again.");
         URL.revokeObjectURL(url);
        };
        img.src = url;
       }
      
       function exportCanvasSVG() {
        const svg = document.getElementById("map");
        const svgClone = svg.cloneNode(true);
        const viewBox = svg.getAttribute("viewBox").split(" ").map(Number);
        const [x, y, width, height] = viewBox;
        svgClone.setAttribute("width", width);
        svgClone.setAttribute("height", height);
        const rootStyles = getComputedStyle(document.documentElement);
        const bgColor = rootStyles.getPropertyValue("--bg").trim() || "#050608";
        const bgRect = document.createElementNS("http://www.w3.org/2000/svg", "rect", );
        bgRect.setAttribute("x", x);
        bgRect.setAttribute("y", y);
        bgRect.setAttribute("width", width);
        bgRect.setAttribute("height", height);
        bgRect.setAttribute("fill", bgColor);
        svgClone.insertBefore(bgRect, svgClone.firstChild);
        const wrapper = document.createElement("div");
        wrapper.style.position = "absolute";
        wrapper.style.left = "-9999px";
        wrapper.appendChild(svgClone);
        document.body.appendChild(wrapper);
        const elements = svg.querySelectorAll("*");
        const clonedElements = svgClone.querySelectorAll("*");
        elements.forEach((el, index) => {
         const clonedEl = clonedElements[index];
         if (!clonedEl) return;
         const computedStyle = getComputedStyle(el);
         const svgProps = ["fill", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin", "opacity", "font-family", "font-size", "font-weight", "font-style", "text-anchor", "dominant-baseline", "marker-start", "marker-end", ];
         svgProps.forEach((prop) => {
          const value = computedStyle.getPropertyValue(prop);
          if (value && value !== "none" && value !== "normal") {
           clonedEl.setAttribute(prop, value);
          }
         });
         clonedEl.removeAttribute("class");
        });
        const svgData = new XMLSerializer().serializeToString(svgClone);
        document.body.removeChild(wrapper);
        const blob = new Blob([svgData], {
         type: "image/svg+xml;charset=utf-8",
        });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        const timestamp = new Date().toISOString().slice(0, 10);
        link.download = `topology-${timestamp}.svg`;
        link.href = url;
        link.click();
        URL.revokeObjectURL(url);
       }
      let resizeTimeout;
       window.addEventListener('resize', () => {
       clearTimeout(resizeTimeout);
       resizeTimeout = setTimeout(() => {
       updateDrawToolbarVisibility();
       updateTopologyToolbarVisibility();
       }, 100);
      });	   
    </script>
  
</body></html>