<!DOCTYPE html> 
 <html lang="en" style="--panel: #541c1c; --panel-alt: #701010; --accent: #feb4b4; --danger: #ff5c5c; --text-main: #ffffff; --text-soft: #ffffff; --topbar-bg: #000000; --topbar-border: #000000; --topbar-height: 100px; --sidebar-width: 435px; --mobile-footer-height: 20vh; --draw-toolbar-height: 45px;"><head>
    <meta charset="UTF-8">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Homelab</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- 
      * ==================================================================================
      * The One File: The Networkening
      * !!!!!!!!!!!!!!!!!!!NOTE: THIS IS THE ONLINE VERSION!!!!!!!!!!!!!!!!!!!!!!
      * Online version uses 3 cdn calls from cdn.jsdelivr.net to display additional icons
      * Since 3.0 Online version uses http as a form of ping to display uptime
      * "There can be only one". A all in one file topology maker.
      * 
      * This is your last backup when all others fail. A completely self-contained
      * network topology visualization tool that works as a single HTML file.
      * Open it anywhere, anytime and the idea lives forever.
      * ==================================================================================
      -->
    <style>
      :root {
      color-scheme: dark;
      --bg: #050608;
      --panel: #0b0e13;
      --panel-alt: #10141b;
      --accent: #4fd1c5;
      --danger: #f56565;
      --text-main: #e2e8f0;
      --text-soft: #94a3b8;
      --edge-main: #475569;
      --node-min: 35px;
      --node-max: 70px;
      --topbar-bg: rgba(9, 12, 20, 0.9);
      --topbar-border: #1f2533;
      }
      * {
      box-sizing: border-box;
      user-select: none;
      }
      input,
      textarea,
      [contenteditable="true"] {
      user-select: text;
      -webkit-user-select: text;
      }
      body {
      margin: 0;
      font-family: system-ui, sans-serif;
      background: radial-gradient(circle at top, #1e2532 0, #050608 70%);
      color: var(--text-main);
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
      }
      header {
      padding: 0 20px;
      height: var(--topbar-height, 52px);
      min-height: var(--topbar-height, 52px);
      background: var(--topbar-bg);
      backdrop-filter: blur(6px);
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid var(--topbar-border);
      gap: 16px;
      }
      .title-block {
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-width: 0;
      }
      header h1 {
      font-size: clamp(22px, 3vw, 32px);
      margin: 0;
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
      }
      .editable-page-title {
      cursor: pointer;
      transition: opacity 0.2s;
      }
      .editable-page-title:hover {
      opacity: 0.7;
      }
      .save-row {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      }
      .save-btn {
      padding: 6px 12px;
      background: var(--accent);
      color: var(--bg);
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      white-space: nowrap;
      }
      .save-btn:hover {
      opacity: 0.9;
      }
      .help-icon {
      width: 22px;
      height: 22px;
      border-radius: 50%;
      border: 1px solid var(--edge-main);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      cursor: pointer;
      color: var(--text-soft);
      background: rgba(15, 23, 42, 0.9);
      flex-shrink: 0;
      }
      .help-icon:hover {
      color: var(--accent);
      border-color: var(--accent);
      }
      #settings-btn {
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 16px;
      flex-shrink: 0;
      }
      #settings-btn:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .header-resizer {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 6px;
      background: transparent;
      cursor: row-resize;
      z-index: 1000;
      transition: background 0.2s;
      }
      .header-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .header-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      .sidebar-resizer {
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 6px;
      background: transparent;
      cursor: col-resize;
      z-index: 1000;
      transition: background 0.2s;
      }
      .sidebar-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .sidebar-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      .mobile-footer-resizer {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 6px;
      background: transparent;
      cursor: row-resize;
      z-index: 1000;
      transition: background 0.2s;
      display: none;
      }
      .mobile-footer-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .mobile-footer-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      @media (max-width: 900px) {
      .mobile-footer-resizer {
      display: block;
      height: 12px;
      }
      .sidebar-resizer {
      display: none;
      }
      .header-resizer {
      height: 12px;
      }
      }
      @media (pointer: coarse) {
      .header-resizer {
      height: 16px;
      }
      .mobile-footer-resizer {
      height: 16px;
      }
      .sidebar-resizer {
      width: 16px;
      }
      }
      .resizer-icon {
      position: absolute;
      opacity: 0.5;
      transition: opacity 0.2s, transform 0.2s;
      pointer-events: none;
      fill: var(--accent);
      }
      .header-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .sidebar-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .mobile-footer-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .header-resizer:hover .resizer-icon,
      .sidebar-resizer:hover .resizer-icon,
      .mobile-footer-resizer:hover .resizer-icon {
      opacity: 1;
      }
      .header-resizer.resizing .resizer-icon,
      .sidebar-resizer.resizing .resizer-icon,
      .mobile-footer-resizer.resizing .resizer-icon {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1.2);
      }
      body.resizing {
      user-select: none;
      }
      body.resizing * {
      cursor: inherit !important;
      pointer-events: none;
      }
      header {
      position: relative;
      }
      .details-panel {
      position: relative;
      }
      main {
      display: grid;
      grid-template-columns: 1fr var(--sidebar-width, 350px);
      flex: 1;
      }
      main.sidebar-collapsed {
      grid-template-columns: 1fr 0;
      }
      @media (max-width: 900px) {
      main {
      grid-template-columns: 1fr;
      grid-template-rows: calc(100vh - var(--topbar-height, 52px) - var(--mobile-footer-height, 40vh)) var(--mobile-footer-height, 40vh);
      }
      main.sidebar-collapsed {
      grid-template-rows: 1fr 0;
      }
      .details-panel {
      max-height: var(--mobile-footer-height, 40vh);
      height: 100%;
      }
      }
      .topology-panel {
      background: var(--panel);
      border-right: 1px solid #111827;
      position: relative;
      overflow: hidden;
      }
      .topology-toolbar {
      position: absolute;
      top: 10px;
      right: 10px;
      display: none;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      background: rgba(15, 23, 42, 0.92);
      border: 1px solid #1f2937;
      border-radius: 6px;
      z-index: 20;
      font-size: 13px;
      }
      .topology-toolbar label {
      color: var(--text-soft);
      }
      .topology-toolbar select {
      padding: 4px 6px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: 13px;
      cursor: pointer;
      }
      .topology-toolbar button {
      padding: 4px 10px;
      background: var(--accent);
      color: var(--bg);
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      }
      .bulk-toolbar-desktop,
      .bulk-toolbar-mobile {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 9999;
      }
      .bulk-toolbar-desktop {
      position: absolute;
      top: 10px;
      right: 10px;
      bottom: auto;
      left: auto;
      transform: none;
      }
      @media (min-width: 768px) {
      .bulk-toolbar-mobile {
      display: none !important;
      }
      }	  
      .bulk-action-btn {
      padding: 16px;
      background: var(--panel-main);
      border: 1px solid var(--edge-main);
      border-radius: 8px;
      color: var(--text-main);
      font-size: 24px;
      cursor: pointer;
      text-align: center;
      line-height: 1.2;
      }
      .bulk-action-btn:active {
      transform: scale(0.95);
      background: var(--accent);
      }
      .draw-toolbar {
      position: absolute;
      top: 10px;
      left: 10px;
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 8px;
      background: rgba(15, 23, 42, 0.92);
      border: 1px solid #1f2937;
      border-radius: 6px;
      z-index: 20;
      font-size: 13px;
      pointer-events: auto;
      }
      .draw-toolbar button {
      padding: 4px 8px;
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      }
      .draw-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .draw-toolbar input[type="color"] {
      width: 30px;
      height: 22px;
      border-radius: 4px;
      border: 1px solid var(--edge-main);
      padding: 0;
      background: transparent;
      cursor: pointer;
      }
      .draw-toolbar select {
      padding: 4px 6px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: 13px;
      cursor: pointer;
      }
      .legend-container {
      position: absolute;
      left: 10px;
      bottom: 10px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      padding: 8px 10px;
      background: rgba(15, 23, 42, 0.92);
      border: 1px solid #1f2937;
      border-radius: 6px;
      font-size: 12px;
      z-index: 20;
      max-width: 260px;
      pointer-events: auto;
      }
      .legend-container {
      padding-right: 22px;
      }
      @media (max-width: 900px) {
      .legend-container {
      max-height: calc(100vh - var(--topbar-height, 100px) - 120px);
      overflow-y: auto;
      }
      }
      @media (max-width: 900px) {
      .bulk-toolbar-desktop,
      .topology-toolbar {
      display: none !important;
      }
      }
      .legend-close-btn {
      position: absolute;
      top: 5px;
      right: 5px;
      width: 18px;
      height: 18px;
      border-radius: 999px;
      border: 1px solid var(--edge-main);
      background: var(--panel-alt);
      color: var(--text-soft);
      font-size: 11px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      }
      .legend-close-btn:hover {
      background: var(--danger);
      color: #fff;
      }
      .legend-mini-btn {
      position: absolute;
      left: 10px;
      padding: 4px 8px;
      border-radius: 4px;
      border: 1px solid #1f2937;
      background: rgba(15, 23, 42, 0.92);
      color: var(--text-main);
      font-size: 11px;
      cursor: pointer;
      z-index: 20;
      display: none;
      transition: all 0.2s;
      }
      .legend-mini-btn:hover,
      .legend-mini-btn:active {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
      }
      .legend-title {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: var(--text-soft);
      margin-bottom: 2px;
      }
      .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      }
      .legend-swatch {
      width: 14px;
      height: 14px;
      border-radius: 3px;
      border: 1px solid #020617;
      flex-shrink: 0;
      }
      .legend-label {
      outline: none;
      cursor: text;
      flex: 1;
      min-width: 60px;
      user-select: text;
      -webkit-user-select: text;
      }
      .legend-label.editing {
      border-bottom: 1px dashed var(--accent);
      }
      .canvas-viewport {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      overflow: hidden;
      }
      .canvas-viewport.panning {
      cursor: grabbing !important;
      }
      .canvas-viewport.panning * {
      cursor: grabbing !important;
      }
      .canvas-viewport svg {
      width: 100%;
      height: 100%;
      display: block;
      background: linear-gradient(rgba(71, 85, 105, 0.1) 1px,
      transparent 1px),
      linear-gradient(90deg,
      rgba(71, 85, 105, 0.1) 1px,
      transparent 1px),
      linear-gradient(rgba(71, 85, 105, 0.05) 1px, transparent 1px),
      linear-gradient(90deg,
      rgba(71, 85, 105, 0.05) 1px,
      transparent 1px);
      background-size:
      100px 100px,
      100px 100px,
      20px 20px,
      20px 20px;
      background-position:
      -1px -1px,
      -1px -1px,
      -1px -1px,
      -1px -1px;
      }
      .zoom-toolbar {
      display: flex;
      gap: 4px;
      padding: 6px;
      background: rgba(15, 23, 42, 0.92);
      border: 1px solid #1f2937;
      border-radius: 6px;
      }
      .zoom-toolbar button {
      width: 32px;
      height: 32px;
      padding: 0;
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      font-size: 18px;
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
      }
      .zoom-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .zoom-toolbar .zoom-level {
      font-size: 11px;
      color: var(--text-soft);
      text-align: center;
      padding: 2px 0;
      min-width: 32px;
      }
      .zoom-toolbar .divider {
      height: 1px;
      background: var(--edge-main);
      margin: 2px 0;
      }
      .minimap-zoom-wrapper {
      position: absolute;
      bottom: 10px;
      right: 10px;
      z-index: 99;
      }
      .minimap-container {
      background: rgba(15, 23, 42, 0.92);
      border: 1px solid #1f2937;
      border-radius: 6px;
      overflow: hidden;
      margin-bottom: 4px;
      }
      .minimap-container svg {
      width: 100%;
      height: 100%;
      }
      .minimap-viewport {
      fill: rgba(79, 209, 197, 0.2);
      stroke: var(--accent);
      stroke-width: 2;
      cursor: move;
      }
      .minimap-node {
      fill: var(--text-soft);
      }
      .minimap-edge {
      stroke: var(--edge-main);
      stroke-width: 1;
      }
      .minimap-close-btn {
      position: absolute;
      top: 2px;
      right: 2px;
      width: 18px;
      height: 18px;
      background: rgba(15, 23, 42, 0.9);
      border: 1px solid var(--edge-main);
      border-radius: 3px;
      color: var(--text-soft);
      font-size: 11px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
      padding: 0;
      line-height: 1;
      }
      .minimap-close-btn:hover {
      background: var(--danger);
      color: white;
      border-color: var(--danger);
      }
      .toolbar-close-btn {
      width: 24px;
      height: 24px;
      background: rgba(15, 23, 42, 0.9);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-soft);
      font-size: 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      line-height: 1;
      flex-shrink: 0;
      }
      .toolbar-close-btn:hover {
      background: var(--danger);
      color: white;
      border-color: var(--danger);
      }
      .canvas-hint {
      position: absolute;
      top: 50px;
      left: 50%;
      transform: translateX(-50%);
      padding: 8px 16px;
      background: rgba(15, 23, 42, 0.92);
      border: 1px solid #1f2937;
      border-radius: 6px;
      font-size: 12px;
      color: var(--text-soft);
      z-index: 18;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
      }
      .canvas-hint.visible {
      opacity: 1;
      }
      .edge {
      stroke: var(--edge-main);
      stroke-width: 4;
      opacity: 0.75;
      transition: 0.25s ease-in-out;
      cursor: pointer;
      }
      .edge.backup {
      stroke: var(--danger);
      stroke-width: 5;
      }
      .edge.active {
      opacity: 1;
      stroke-width: 7;
      }
      .free-preview {
      fill: none;
      stroke-dasharray: 4 4;
      pointer-events: none;
      }
      .free-point {
      fill: #e5e7eb;
      stroke: #0f172a;
      stroke-width: 1.5;
      cursor: grab;
      }
      .node-circle {
      fill: #1e293b;
      stroke: #475569;
      stroke-width: 2;
      transition: 0.25s ease;
      transform-origin: center center;
      }
      .node-hit-area {
      cursor: grab;
      pointer-events: all;
      }
      .node-group:hover .node-circle {
      filter: drop-shadow(0 0 10px rgba(79, 209, 197, 0.45));
      }
      .node-group.active .node-circle {
      stroke: var(--accent);
      animation: pulse 1.2s infinite ease-in-out;
      }
      @keyframes pulse {
      0% {
      filter: drop-shadow(0 0 4px #4fd1c5);
      }
      50% {
      filter: drop-shadow(0 0 14px #4fd1c5);
      }
      100% {
      filter: drop-shadow(0 0 4px #4fd1c5);
      }
      }
      .node-label {
      fill: var(--text-main);
      font-size: 18px;
      text-anchor: middle;
      font-weight: 600;
      }
      .node-sub {
      fill: var(--text-soft);
      font-size: 13px;
      text-anchor: middle;
      }
      .ping-indicator {
      fill: #6b7280;
      stroke: #4b5563;
      stroke-width: 1;
      }
      .ping-indicator.online {
      fill: #10b981;
      stroke: #059669;
      }
      .ping-indicator.offline {
      fill: #ef4444;
      stroke: #dc2626;
      }
      .ping-indicator.checking {
      fill: #f59e0b;
      stroke: #d97706;
      }
      @media (max-width: 1024px) {
      .node-label {
      font-size: 28px;
      }
      .node-sub {
      font-size: 20px;
      }
      }
      @media (max-width: 768px) {
      .node-label {
      font-size: 70px;
      }
      .node-sub {
      font-size: 50px;
      }
      }
      @media (max-width: 380px) {
      .node-label {
      font-size: 60px;
      }
      .node-sub {
      font-size: 42px;
      }
      }
      .details-panel {
      background: var(--panel-alt);
      padding: 22px;
      padding-bottom: 80px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 15px;
      position: relative;
      transition:
      width 0.3s ease,
      min-width 0.3s ease,
      padding 0.3s ease,
      opacity 0.3s ease;
      }
      .details-panel {
      min-width: 260px !important;
      }
      .details-panel {
      overflow-y: auto !important;
      overflow-x: hidden;
      }
      .details-panel.collapsed {
      width: 0 !important;
      min-width: 0 !important;
      padding: 0 !important;
      overflow: hidden;
      opacity: 0;
      }
      body {
      overflow-x: hidden;
      overflow-y: hidden;
      }
      main {
      overflow-x: hidden;
      overflow-y: visible;
      }
      .details-panel {
      overflow-y: auto !important;
      overflow-x: hidden;
      }
      .details-panel.collapsed {
      min-width: 0 !important;
      }
      .sidebar-toggle {
      position: absolute;
      left: -16px;
      top: 50%;
      transform: translateY(-50%);
      width: 16px;
      height: 60px;
      background: var(--panel-alt);
      border: 1px solid var(--edge-main);
      border-right: none;
      border-radius: 8px 0 0 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text-soft);
      font-size: 10px;
      z-index: 25;
      transition:
      background 0.2s,
      color 0.2s;
      }
      .sidebar-toggle:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .sidebar-toggle.collapsed {
      left: 0;
      border-right: 1px solid var(--edge-main);
      border-radius: 0 8px 8px 0;
      position: fixed;
      right: 0;
      left: auto;
      }
      .details-name {
      font-size: clamp(22px, 2.5vw, 30px);
      font-weight: 700;
      }
      .details-ip {
      font-size: clamp(16px, 2vw, 22px);
      color: var(--text-soft);
      }
      .details-role {
      font-size: clamp(16px, 2vw, 22px);
      color: var(--accent);
      }
      .size-controls {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-top: 10px;
      }
      .size-controls label {
      font-size: clamp(14px, 1.6vw, 18px);
      color: var(--text-soft);
      }
      .size-controls input[type="range"] {
      flex: 1;
      accent-color: var(--accent);
      }
      .size-controls button {
      padding: 6px 12px;
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      font-size: clamp(12px, 1.4vw, 16px);
      }
      .size-controls button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .style-section {
      margin-top: 15px;
      padding-top: 15px;
      border-top: 1px solid var(--edge-main);
      }
      .style-section summary {
      cursor: pointer;
      font-size: clamp(14px, 1.6vw, 20px);
      text-transform: uppercase;
      color: var(--text-soft);
      list-style: none;
      display: flex;
      justify-content: space-between;
      align-items: center;
      user-select: none;
      }
      .style-section summary::-webkit-details-marker {
      display: none;
      }
      .password-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #ffffff;
      z-index: 9999;
      }
      .style-section summary::after {
      content: "‚ñº";
      transition: transform 0.2s;
      }
      .style-section[open] summary::after {
      transform: rotate(180deg);
      }
      .style-content {
      margin-top: 10px;
      }
      .style-row {
      display: flex;
      gap: 10px;
      align-items: center;
      margin: 8px 0;
      }
      .style-row label {
      font-size: clamp(13px, 1.5vw, 17px);
      color: var(--text-soft);
      min-width: 80px;
      }
      .style-row input[type="color"] {
      width: 50px;
      height: 30px;
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      background: transparent;
      }
      .style-row input[type="number"] {
      width: 70px;
      padding: 4px 8px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(12px, 1.4vw, 16px);
      }
      .style-row select {
      flex: 1;
      padding: 4px 8px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(12px, 1.4vw, 16px);
      cursor: pointer;
      }
      .editable-text {
      cursor: pointer;
      transition: opacity 0.2s;
      }
      .editable-text:hover {
      opacity: 0.7;
      }
      .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      z-index: 999999;
      justify-content: center;
      align-items: center;
      overflow: auto;
      }
      .modal.active {
      display: inline-grid;
      }
      .modal-content {
      background: var(--panel-alt);
      padding: 25px;
      border-radius: 8px;
      border: 1px solid var(--edge-main);
      min-width: 300px;
      max-width: 90%;
      }
      .modal-content h3 {
      margin: 0 0 15px 0;
      color: var(--text-main);
      font-size: clamp(18px, 2vw, 24px);
      }
      .modal-content p {
      color: var(--text-soft);
      font-size: clamp(14px, 1.6vw, 18px);
      margin: 0 0 20px 0;
      }
      .modal-content input:not([type="color"]),
      .modal-content select {
      width: 100%;
      padding: 10px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(14px, 1.6vw, 18px);
      margin-bottom: 15px;
      user-select: text;
      -webkit-user-select: text;
      }
      .modal-content input[type="color"] {
      width: 60px;
      height: 36px;
      padding: 2px;
      border: 2px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      background: none;
      -webkit-appearance: none;
      appearance: none;
      }
      .modal-content input[type="color"]::-webkit-color-swatch-wrapper {
      padding: 0;
      }
      .modal-content input[type="color"]::-webkit-color-swatch {
      border: none;
      border-radius: 4px;
      }
      .modal-buttons {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
      margin-top: 10px;
      }
      .modal-buttons button {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: clamp(14px, 1.6vw, 18px);
      font-weight: 600;
      }
      .modal-buttons .btn-cancel {
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      }
      .modal-buttons .btn-save {
      background: var(--accent);
      color: var(--bg);
      }
      .modal-buttons .btn-delete {
      background: var(--danger);
      color: white;
      }
      .confirm-modal p {
      color: var(--text-soft);
      font-size: clamp(14px, 1.6vw, 18px);
      margin: 0 0 20px 0;
      }
      .context-menu-item {
      transition: background 0.15s;
      }
      .context-menu-item:hover {
      background: var(--panel);
      }
      .details-info-row {
      display: flex;
      align-items: center;
      margin: 6px 0;
      }
      .node-group.selected .node-circle,
      .node-group.selected rect,
      .node-group.selected polygon {
      stroke: #f59e0b;
      stroke-width: 3;
      }
      .node-group.search-highlight .node-circle,
      .node-group.search-highlight rect,
      .node-group.search-highlight polygon {
      stroke: #10b981;
      stroke-width: 3;
      filter: drop-shadow(0 0 8px #10b981);
      }
      .badge-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      }
      .badge {
      border: 1px solid var(--edge-main);
      padding: 5px 12px;
      border-radius: 22px;
      font-size: clamp(12px, 1.4vw, 18px);
      }
      .badge.wg {
      color: var(--accent);
      border-color: var(--accent);
      }
      .section-label {
      margin-top: 8px;
      font-size: clamp(14px, 1.6vw, 20px);
      text-transform: uppercase;
      color: var(--text-soft);
      }
      .list li {
      margin: 6px 0;
      font-size: clamp(14px, 1.6vw, 20px);
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      }
      .list li:hover {
      color: var(--accent);
      }
      .delete-note {
      color: var(--danger);
      font-size: 18px;
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.2s;
      flex-shrink: 0;
      }
      .list li:hover .delete-note {
      opacity: 1;
      }
      .editing {
      outline: 2px solid var(--accent);
      background: #0d141f;
      padding: 4px;
      border-radius: 6px;
      user-select: text;
      -webkit-user-select: text;
      }
      .mobile-menu-btn {
      display: none;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      color: var(--text-main);
      font-size: 22px;
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      }
      #topbar-menu {
      gap: 8px;
      }
      @media (min-width: 721px) {
      #topbar-menu {
      display: flex !important;
      }
      }
      @media (max-width: 720px) {
      #topbar-menu {
      display: none;
      }
      #topbar-menu.open {
      display: flex;
      }
      }
      @media (max-width: 720px) {
      .mobile-menu-btn {
      display: block;
      }
      #topbar-menu {
      position: absolute;
      top: var(--topbar-height);
      right: 0;
      background: var(--panel-alt);
      border-left: 1px solid var(--topbar-border);
      border-bottom: 1px solid var(--topbar-border);
      padding: 12px;
      display: none;
      flex-direction: column;
      width: 180px;
      z-index: 999;
      }
      #topbar-menu.open {
      display: flex;
      }
      header {
      position: relative;
      z-index: 9999;
      }
      }
      @media (max-width: 720px) {
      .draw-toolbar {
      position: absolute;
      top: auto;
      bottom: auto;
      left: 10px !important;
      right: auto !important;
      width: auto;
      gap: 6px;
      padding: 8px;
      }	  
      .topology-toolbar {
      position: absolute;
      top: auto;
      bottom: auto;
      width: auto;
      gap: 6px;
      padding: 8px;
      }
      .draw-toolbar {
      top: 10px !important;
      }
      .topology-toolbar {
      top: calc(10px + var(--draw-toolbar-height, 50px)) !important;
      }
      .canvas-hint {
      top: calc(10px + 120px);
      }
      }
      .icon-picker-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      z-index: 999999999;
      justify-content: center;
      align-items: center;
      }
      .icon-picker-modal.active {
      display: flex;
      }
      .icon-picker-content {
      background: var(--panel);
      border-radius: 12px;
      width: 90%;
      max-width: 800px;
      max-height: 80vh;
      display: flex;
      flex-direction: column;
      border: 1px solid var(--edge-main);
      }
      .icon-picker-header {
      padding: 20px;
      border-bottom: 1px solid var(--edge-main);
      }
      .icon-picker-header h3 {
      margin: 0 0 15px 0;
      color: var(--text-main);
      }
      .icon-picker-tabs {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
      flex-wrap: wrap;
      }
      .icon-picker-tab {
      padding: 8px 16px;
      background: var(--panel-alt);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      color: var(--text-soft);
      font-size: 14px;
      transition: all 0.2s;
      }
      .icon-picker-tab:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .icon-picker-tab.active {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
      }
      .icon-picker-search {
      width: 100%;
      padding: 10px 15px;
      background: var(--panel-alt);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      color: var(--text-main);
      font-size: 14px;
      }
      .icon-picker-search::placeholder {
      color: var(--text-soft);
      }
      .icon-picker-body {
      padding: 20px;
      overflow-y: auto;
      flex: 1;
      }
      .icon-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
      gap: 10px;
      }
      .icon-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 15px 10px;
      background: var(--panel-alt);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .icon-item:hover {
      background: var(--accent);
      border-color: var(--accent);
      transform: scale(1.05);
      }
      .icon-item svg {
      width: 32px;
      height: 32px;
      fill: var(--text-main);
      }
      .icon-item:hover svg {
      fill: var(--bg);
      }
      .icon-item-name {
      margin-top: 8px;
      font-size: 10px;
      color: var(--text-soft);
      text-align: center;
      word-break: break-word;
      }
      .icon-item:hover .icon-item-name {
      color: var(--bg);
      }
      .icon-picker-loading {
      text-align: center;
      padding: 40px;
      color: var(--text-soft);
      }
      .icon-picker-footer {
      padding: 15px 20px;
      border-top: 1px solid var(--edge-main);
      display: flex;
      justify-content: flex-end;
      }
      .icon-btn-cancel {
      padding: 8px 20px;
      background: var(--panel-alt);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      }
      .icon-btn-cancel:hover {
      background: var(--edge-main);
      }
      .icon-badge {
      display: inline-flex;
      align-items: center;
      gap: 5px;
      padding: 4px 8px;
      background: var(--panel-alt);
      border-radius: 4px;
      font-size: 12px;
      margin: 2px;
      }
      .icon-badge svg {
      width: 16px;
      height: 16px;
      fill: currentColor;
      }
      .pick-icon-btn {
      padding: 6px 12px;
      background: var(--accent);
      color: var(--bg);
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      margin-top: 8px;
      width: 100%;
      }
      .pick-icon-btn:hover {
      opacity: 0.9;
      }
      @media (max-width: 768px) {
      .icon-picker-content {
      width: 95%;
      max-height: 90vh;	
      }
      .modal-content {
      background: var(--panel-alt);
      }
      #search-input {
      width: 100%;
      }
      }
      .version-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .version-item:hover {
      background: var(--panel-alt);
      border-color: var(--accent);
      }
      .version-item.current {
      border-color: var(--accent);
      background: rgba(79, 209, 197, 0.1);
      }
      .version-info {
      flex: 1;
      }
      .version-info .timestamp {
      font-size: 13px;
      color: var(--text-main);
      font-weight: 600;
      }
      .version-info .details {
      font-size: 11px;
      color: var(--text-soft);
      margin-top: 4px;
      }
      .version-actions {
      display: flex;
      gap: 6px;
      }
      .audit-entry {
      padding: 8px 12px;
      background: var(--panel);
      border-left: 3px solid var(--edge-main);
      border-radius: 4px;
      font-size: 12px;
      }
      .audit-entry.node { border-left-color: #4fd1c5; }
      .audit-entry.connection { border-left-color: #9f7aea; }
      .audit-entry.style { border-left-color: #ed8936; }
      .audit-entry.rack { border-left-color: #48bb78; }
      .audit-entry.layer { border-left-color: #4299e1; }
      .audit-entry .time {
      color: var(--text-soft);
      font-size: 10px;
      }
      .audit-entry .action {
      color: var(--text-main);
      font-weight: 500;
      }
      .tab-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .tab-item:hover {
      background: var(--panel-alt);
      }
      .tab-item.active {
      border-color: var(--accent);
      background: rgba(79, 209, 197, 0.1);
      }
      .tab-item .tab-name {
      font-weight: 600;
      color: var(--text-main);
      flex: 1;
      }
      .tab-item .tab-stats {
      font-size: 11px;
      color: var(--text-soft);
      margin-right: 10px;
      }
      .tab-actions {
      display: flex;
      gap: 6px;
      }
      .secret-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      border-left: 3px solid var(--danger);
      }
      .secret-item .secret-name {
      font-weight: 600;
      color: var(--text-main);
      flex: 1;
      }
      .secret-item .secret-status {
      font-size: 11px;
      color: var(--text-soft);
      margin-right: 10px;
      }   
    </style>
  </head>
  <body style="background: radial-gradient(circle at center top, rgb(30, 37, 50) 0px, rgb(5, 6, 8) 70%);" class="">
    <div class="icon-picker-modal" id="icon-picker-modal">
      <div class="icon-picker-content">
        <div class="icon-picker-header">
          <h3>Select Icon</h3>
          <div class="icon-picker-tabs">
            <button class="icon-picker-tab" data-library="mdi">MDI</button>
            <button class="icon-picker-tab" data-library="simple">Simple Icons</button>
            <button class="icon-picker-tab active" data-library="selfhst">selfh.st/icons</button>
          </div>
          <input type="text" class="icon-picker-search" id="icon-search" placeholder="Search icons..." style="display: none;">
        </div>
        <div class="icon-picker-body" id="icon-picker-body">
        </div>
        <div class="icon-picker-footer">
          <button class="icon-btn-cancel" id="icon-picker-cancel">Cancel</button>
        </div>
      </div>
    </div>
    <div class="modal" id="tabs-modal">
      <div class="modal-content" style="max-width: 600px;">
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Manage multiple topologies</p>
        <div id="tabs-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 400px; overflow-y: auto; margin-bottom: 15px;">
            <div class="tab-item " onclick="switchTab(0)">
              <div class="tab-name">Corporate</div>
              <div class="tab-stats">21 nodes ‚Ä¢ 22 connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(0)" title="Rename tab">‚úèÔ∏è</button>
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(${index})" title="Delete tab">üóëÔ∏è</button>
              </div>
            </div>
          
            <div class="tab-item active" onclick="switchTab(1)">
              <div class="tab-name">Homelab</div>
              <div class="tab-stats">0 nodes ‚Ä¢ 0 connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(1)" title="Rename tab">‚úèÔ∏è</button>
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(${index})" title="Delete tab">üóëÔ∏è</button>
              </div>
            </div>
          </div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="new-tab-name" placeholder="New tab name..." style="flex: 1; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <button class="btn-save" onclick="createNewTab()">+ Add Tab</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="tabs-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="rollback-modal">
      <div class="modal-content" style="max-width: 700px;">
        <h3>Version History</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Limit: Snapshots</p>
        <div id="rollback-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 450px; overflow-y: auto; margin-bottom: 15px;">
          <div style="text-align: center; padding: 40px; color: var(--text-soft);">No version history yet. Versions are saved automatically when you save the file.</div>
        </div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <button class="btn-cancel" onclick="clearRollbackHistory()">Clear History</button>
          <button class="btn-save" onclick="createManualSnapshot()">Create Snapshot</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="rollback-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="audit-log-modal">
      <div class="modal-content" style="max-width: 800px;">
        <h3>Audit Log</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Track all changes made to your topology</p>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <select id="audit-filter" style="padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
            <option value="all">All Events</option>
            <option value="node">Node Operations</option>
            <option value="connection">Connections</option>
            <option value="style">Style Changes</option>
            <option value="rack">Rack Operations</option>
            <option value="layer">Layer Changes</option>
          </select>
          <button class="btn-save" onclick="exportAuditLog()">Export</button>
        </div>
        <div id="audit-log-list" style="display: flex; flex-direction: column; gap: 4px; max-height: 450px; overflow-y: auto; margin-bottom: 15px; font-family: monospace; font-size: 12px;">
          <div style="text-align: center; padding: 40px; color: var(--text-soft);">No audit entries yet</div>
        </div>
        <div style="display: flex; gap: 8px;">
          <button class="btn-cancel" onclick="clearAuditLog()">Clear Log</button>
          <button class="btn-cancel" id="audit-log-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="secrets-modal">
      <div class="modal-content" style="max-width: 600px;">
        <h3>Notes</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Notes can also be stored with AES 256 encryption</p>
        <div id="secrets-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 350px; overflow-y: auto; margin-bottom: 15px;">
        </div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="new-secret-name" placeholder="Section name (e.g., 'Root Passwords')..." style="flex: 1; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <button class="btn-save" onclick="createNewSecret()">+ Add Note</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="secrets-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="secret-editor-modal">
      <div class="modal-content" style="max-width: 600px;">
        <h3 id="secret-editor-title">Edit Note</h3>
        <textarea id="secret-editor-content" placeholder="Enter sensitive information here..." style="width: 100%; height: 200px; padding: 12px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main); font-family: monospace; resize: vertical; margin-bottom: 15px;"></textarea>
        <div style="margin-bottom: 15px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
          <input type="checkbox" id="secret-auto-encrypt" checked="" style="cursor: pointer;">
          <span>Encrypt Note</span>
          </label>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" onclick="closeSecretEditor()">Cancel</button>
          <button class="btn-save" onclick="saveSecret()">Save</button>
        </div>
      </div>
    </div>
    <div class="modal" id="edit-modal">
      <div class="modal-content">
        <h3 id="modal-title">Edit Name</h3>
        <input type="text" id="modal-input">
        <div class="modal-buttons">
          <button class="btn-cancel" id="modal-cancel">Cancel</button>
          <button class="btn-save" id="modal-save">Save</button>
        </div>
      </div>
    </div>
    <div class="modal confirm-modal" id="confirm-modal">
      <div class="modal-content">
        <h3>Confirm</h3>
        <p id="confirm-message"> Are you sure you want to delete this line? </p>
        <div class="modal-buttons">
          <button class="btn-cancel" id="confirm-cancel">Cancel</button>
          <button class="btn-delete" id="confirm-delete">Delete</button>
        </div>
      </div>
    </div>
    <div class="modal" id="save-info-modal">
      <div class="modal-content">
        <h3>Why do I need to save?</h3>
        <p> Browsers are not allowed to overwrite local files automatically. When you click <strong>Save File</strong>, this page generates a new updated HTML file that contains all of your changes. Replace your old file with the new one to keep your edits. </p>
        <p style="margin-top: 12px;padding-top: 12px;border-top: 1px solid var(--edge-main);">
          <strong>Encryption:</strong> Check the "Encrypt" box before saving to password protect your data. You'll need the password to open the file later. No recovery possible!!
        </p>
		<p style="margin-top: 12px;padding-top: 12px;border-top: 1px solid var(--edge-main);">
          <strong>Decrpytion:</strong> Want to decrpyt your data? Simply export it using json export in top menu after successful password validation
        </p>
        <div class="modal-buttons">
          <button class="btn-cancel" id="save-info-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="settings-modal">
      <div class="modal-content" style="max-width: 400px">
        <h3>Page Settings</h3>
        <details class="style-section" open="">
          <summary>Background</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Solid Color</label>
              <input type="color" id="page-bg-color" value="#050608">
            </div>
            <p style="margin-top: 4px;font-size: 12px;color: var(--text-soft);">Change to apply a flat background color.</p>
          </div>
        </details>
        <details class="style-section" open="">
          <summary>Top Bar</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="topbar-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="topbar-border-color" value="#1f2533">
            </div>
          </div>
        </details>
        <details class="style-section" open="">
          <summary>Theme Colors</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Panel</label>
              <input type="color" id="panel-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Panel Alt</label>
              <input type="color" id="panel-alt-color" value="#10141b">
            </div>
            <div class="style-row">
              <label>Accent</label>
              <input type="color" id="accent-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Danger</label>
              <input type="color" id="danger-color" value="#f56565">
            </div>
            <div class="style-row">
              <label>Text Main</label>
              <input type="color" id="text-main-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Text Soft</label>
              <input type="color" id="text-soft-color" value="#94a3b8">
            </div>
          </div>
        </details>
        <details class="style-section" open="">
          <summary>Auto Status Checking</summary>
          <div class="style-content">
            <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 16px; cursor: pointer;">
            <input type="checkbox" id="auto-ping-enabled" style="cursor: pointer;">
            <span style="font-size: 14px; font-weight: 600;">Enable automatic status checking</span>
            </label>
            <div id="auto-ping-settings" style="display: none; padding-left: 20px; border-left: 2px solid var(--edge-main);">
              <div class="style-row" style="margin-bottom: 12px;">
                <label>Check Interval (seconds):</label>
                <input type="number" id="auto-ping-interval" min="5" max="3600" value="30" style="width: 80px; padding: 6px; background: var(--panel); border: 1px solid var(--edge-main); border-radius: 4px; color: var(--text-main);">
              </div>
              <div style="padding: 10px; background: var(--panel); border-radius: 6px; border: 1px solid var(--edge-main); font-size: 12px; color: var(--text-soft);">
                <div style="margin-bottom: 4px;"><span id="auto-ping-next-check">Next check in: --</span></div>
                <div><span id="auto-ping-last-run">Last run: 1:15:07 PM</span></div>
              </div>
            </div>
            <p style="margin-top: 12px; font-size: 12px; color: var(--text-soft); font-style: italic;">
              Automatically checks all ping enabled nodes at the specified interval. I recommend 30 to 60 seconds for local networks.
            </p>
          </div>
        </details>
        <details class="style-section" open="">
          <summary>Import / Export Data</summary>
          <div class="style-content">
            <p style="margin-bottom: 12px;font-size: 13px;color: var(--text-soft);">Export / Import your data to upgrade/downgrade versions of The One File.</p>
            <button id="export-data-btn" style="width: 100%;margin-bottom: 10px;padding: 10px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Export Data (JSON)</button>
            <button id="import-data-btn" style="width: 100%;padding: 10px;background: var(--panel);color: var(--text-main);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Import Data (JSON)</button>
            <input type="file" id="import-data-file" accept=".json" style="display: none">
          </div>
        </details>
        <details class="style-section" open="">
          <summary>Clear All</summary>
          <div class="style-content">
            <p style="margin-bottom: 12px;font-size: 13px;color: var(--text-soft);">This deletes everything on the canvas!</p>
            <button id="clear-all-btn" title="Clear all nodes" style="padding: 6px 12px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Clear All</button>
            <input type="file" id="import-data-file" accept=".json" style="display: none">
          </div>
        </details>
        <div class="modal-buttons">
          <button class="btn-cancel" id="settings-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="add-node-modal">
      <div class="modal-content">
        <h3>Add New Node</h3>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Basic Information</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Name</label>
          <input type="text" id="new-node-name" placeholder="e.g. web server, jellyfin">
          <label style="display: block;margin-bottom: 4px;margin-top: 12px;color: var(--text-soft);font-size: 13px;">IP / Subtitle</label>
          <input type="text" id="new-node-ip" placeholder="e.g. 192.168.1.100">
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Tags</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Text Tags (comma separated)</label>
          <input type="text" id="new-node-tags" placeholder="e.g. Docker, nginx, WG: vpn">
          <button class="pick-icon-btn" id="pick-new-node-tag-icon-btn" style="margin-top: 10px;">Add Icon Tag</button>
          <div id="new-node-icon-tags" style="margin-top: 10px; display: none;">
            <label style="display: block; margin-bottom: 8px; color: var(--text-soft); font-size: 13px;">Icon Tags:</label>
            <div id="new-node-icon-tags-list" style="display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 10px;"></div>
          </div>
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Node Appearance</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Basic Shapes</label>
          <select id="new-node-shape">
            <optgroup label="Basic Shapes">
              <option value="circle">Circle</option>
              <option value="square">Square</option>
              <option value="rectangle">Rectangle</option>
              <option value="triangle">Triangle</option>
              <option value="hexagon">Hexagon</option>
              <option value="diamond">Diamond</option>
              <option value="star">Star</option>
              <option value="stop-sign">Stop Sign</option>
            </optgroup>
            <optgroup label="Network Equipment">
              <option value="server">Server</option>
              <option value="pc">PC / Desktop</option>
              <option value="laptop">Laptop</option>
              <option value="phone">Phone / Mobile</option>
              <option value="router">Router</option>
              <option value="switch">Switch</option>
              <option value="firewall">Firewall</option>
              <option value="cloud">Cloud</option>
              <option value="database">Database</option>
              <option value="printer">Printer</option>
            </optgroup>
          </select>
          <button class="pick-icon-btn" id="pick-node-icon-btn" style="margin-top: 10px;"> Or search web icons</button>
          <div id="selected-node-icon" style="margin-top: 10px; display: none;">
            <label style="display: block; margin-bottom: 8px; color: var(--text-soft); font-size: 13px;">Selected Icon:</label>
            <div class="icon-badge" id="selected-node-icon-preview">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24">
                <image href="https://cdn.jsdelivr.net/gh/selfhst/icons@master/png/docker.png" width="24" height="24"></image>
              </svg>
              <span>docker</span>
            </div>
          </div>
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Ping / Status Monitoring</div>
          <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px; cursor: pointer;">
          <input type="checkbox" id="new-node-pingable" style="cursor: pointer;">
          <span style="color: var(--text-soft); font-size: 13px;">Enable ping/status check for this node</span>
          </label>
          <div id="new-node-ping-options" style="display: block; padding-left: 24px; border-left: 2px solid var(--edge-main);">
            <label style="display: block; margin-bottom: 4px; color: var(--text-soft); font-size: 13px;">Protocol</label>
            <select id="new-node-ping-protocol" style="margin-bottom: 12px;">
              <option value="http">HTTP (port 80) uses IP field</option>
              <option value="https">HTTPS (port 443) uses IP field</option>
              <option value="custom">Custom URL</option>
            </select>
            <div id="new-node-custom-url-container" style="display: block;">
              <label style="display: block; margin-bottom: 4px; color: var(--text-soft); font-size: 13px;">Custom URL</label>
              <input type="text" id="new-node-custom-url" placeholder="e.g. http://192.168.1.1:8080">
            </div>
            <label style="display: block; margin-bottom: 4px; margin-top: 8px; color: var(--text-soft); font-size: 13px;">
            Timeout (ms)
            </label>
            <input type="number" id="new-node-ping-timeout" value="3000" min="1000" max="10000" step="500">
          </div>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="add-node-cancel">Cancel</button>
          <button class="btn-save" id="add-node-save">Add Node</button>
        </div>
      </div>
    </div>
    <div class="modal" id="add-rack-modal">
      <div class="modal-content">
        <h3>Add New Rack</h3>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Basic Information</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Rack Name</label>
          <input type="text" id="new-rack-name" placeholder="e.g. Rack-A, DC1-R01, Production-01">
          <label style="display: block;margin-bottom: 4px;margin-top: 12px;color: var(--text-soft);font-size: 13px;">IP / Network Range (optional)</label>
          <input type="text" id="new-rack-ip" placeholder="e.g. 192.168.1.0/24">
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Tags</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Text Tags (comma separated)</label>
          <input type="text" id="new-rack-tags" placeholder="e.g. Production, Data Center 1, Row A">
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Rack Appearance</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Icon / Shape</label>
          <select id="new-rack-shape">
            <optgroup label="Basic Shapes">
              <option value="circle">Circle</option>
              <option value="square">Square</option>
              <option value="rectangle">Rectangle</option>
              <option value="triangle">Triangle</option>
              <option value="hexagon">Hexagon</option>
              <option value="diamond">Diamond</option>
              <option value="star">Star</option>
              <option value="stop-sign">Stop Sign</option>
            </optgroup>
            <optgroup label="Network Equipment">
              <option value="server" selected="">Server</option>
              <option value="pc">PC / Desktop</option>
              <option value="laptop">Laptop</option>
              <option value="phone">Phone / Mobile</option>
              <option value="router">Router</option>
              <option value="switch">Switch</option>
              <option value="firewall">Firewall</option>
              <option value="cloud">Cloud</option>
              <option value="database">Database</option>
              <option value="printer">Printer</option>
            </optgroup>
          </select>
          <button class="pick-icon-btn" id="pick-rack-icon-btn" style="margin-top: 10px;">Or Search Web Icons</button>
          <div id="selected-rack-icon" style="margin-top: 10px; display: none;">
            <label style="display: block; margin-bottom: 8px; color: var(--text-soft); font-size: 13px;">Selected Icon:</label>
            <div class="icon-badge" id="selected-rack-icon-preview">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24">
                <image href="" width="24" height="24"></image>
              </svg>
              <span></span>
            </div>
          </div>
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Rack Configuration</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Rack Capacity</label>
          <select id="new-rack-capacity">
            <option value="42" selected="">42U (Standard Full Rack)</option>
            <option value="48">48U (Large Rack)</option>
            <option value="24">24U (Half Rack)</option>
            <option value="12">12U (Small/Wall Mount)</option>
            <option value="6">6U (Mini Rack)</option>
          </select>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="add-rack-cancel">Cancel</button>
          <button class="btn-save" id="add-rack-save">Add Rack</button>
        </div>
      </div>
    </div>
    <div class="modal confirm-modal" id="clear-all-modal">
      <div class="modal-content">
        <h3>Clear All Nodes</h3>
        <p> This will remove ALL nodes and connections. This cannot be undone until you reload without saving. Are you sure? </p>
        <div class="modal-buttons">
          <button class="btn-cancel" id="clear-all-cancel">Cancel</button>
          <button class="btn-delete" id="clear-all-confirm">Clear Everything</button>
        </div>
      </div>
    </div>
    <div class="modal" id="layer-modal">
      <div class="modal-content" style="max-width: 400px;">
        <h3>Layer Visibility</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Toggle which layers are visible on the canvas</p>
        <div style="display: flex; flex-direction: column; gap: 10px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-physical" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Physical Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-logical" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Logical Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-security" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Security Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-application" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Application Layer</span>
          </label>
        </div>
        <div style="margin-top: 15px; display: flex; gap: 8px;">
          <button class="btn-cancel" style="flex: 1;" onclick="document.querySelectorAll('#layer-modal input[type=checkbox]').forEach(cb =&gt; cb.checked = false); applyLayerFilter();">Hide All</button>
          <button class="btn-save" style="flex: 1;" onclick="document.querySelectorAll('#layer-modal input[type=checkbox]').forEach(cb =&gt; cb.checked = true); applyLayerFilter();">Show All</button>
        </div>
        <div class="modal-buttons" style="margin-top: 10px;">
          <button class="btn-cancel" id="layer-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div id="context-menu" style="display: none !important;">
    </div>
    <header>
      <div class="title-block">
        <h1 id="page-title" class="editable-page-title">Homelab</h1>
        <div class="save-row">
          <button id="save-file-btn" class="save-btn" type="button">Save File</button>
          <label style="display: flex;align-items: center;gap: 4px;font-size: 12px;color: var(--text-soft);cursor: pointer;user-select: none;">
          <input type="checkbox" id="encrypt-toggle" style="cursor: pointer">
          <span title="Encrypt data with password">Encrypt</span>
          </label>
          <span id="save-help-btn" class="help-icon" title="Why save?">?</span>
        </div>
      </div>
      <div id="topbar-menu">
        <button id="back-to-topology-btn" title="Exit rack view and return to topology" style="padding: 6px 12px; background: var(--accent); color: var(--bg); border: none; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600; display: none;">‚Üê Back to Topology</button>
        <button id="add-node-btn" class="save-btn" title="Add new node" style="background: var(--accent)">+ Node</button>
        <button id="add-rack-btn" class="save-btn" title="Add new rack" style="background: var(--accent); margin-left: 8px;">+ Rack</button>
        <button id="undo-btn" title="Undo (Ctrl+Z)" style="padding: 6px 12px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600; opacity: 1;">‚Ü∂</button>
        <button id="redo-btn" title="Redo (Ctrl+Y)" disabled="" style="padding: 6px 12px;background: var(--panel);color: var(--text-main);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;opacity: 0.5;">‚Ü∑</button>
        <input id="search-input" type="text" placeholder="Search nodes..." style="padding: 6px 12px;background: var(--panel);color: var(--text-main);border: 1px solid var(--edge-main);border-radius: 6px;font-size: 14px;">
        <button id="check-all-ping-btn" title="Check status of all enabled nodes" style="padding: 6px 12px;background: var(--panel);color: var(--text-main);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Check Pings</button>
        <button id="layers-btn" title="Toggle layer visibility" style="padding: 6px 12px;background: var(--panel);color: var(--text-main);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Layers</button>
        <button id="tabs-btn" title="Manage document tabs" style="padding: 6px 12px;background: var(--panel);color: var(--text-main);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Tabs</button>
        <button id="rollback-btn" title="View version history" style="padding: 6px 12px;background: var(--panel);color: var(--text-main);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Snapshots</button>
        <button id="audit-log-btn" title="View audit log" style="padding: 6px 12px;background: var(--panel);color: var(--text-main);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Audit</button>
        <button id="secrets-btn" title="Manage encrypted notes" style="padding: 6px 12px;background: var(--panel);color: var(--text-main);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Notes</button>
        <button onclick="screenshotCanvas()" title="Export canvas as PNG image" style="padding: 6px 12px;background: var(--panel);color: var(--text-main);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">PNG</button>
        <button onclick="exportCanvasSVG()" title="Export canvas as SVG vector" style="padding: 6px 12px;background: var(--panel);color: var(--text-main);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">SVG</button>
        <button id="settings-btn" title="Page settings">‚öôÔ∏è</button>
      </div>
      <button id="mobile-menu-toggle" class="mobile-menu-btn">‚ò∞</button>
      <div class="header-resizer" id="header-resizer">
        <svg class="resizer-icon" width="40" height="6" viewBox="0 0 40 6" xmlns="http://www.w3.org/2000/svg">
          <circle cx="14" cy="3" r="2"></circle>
          <circle cx="20" cy="3" r="2"></circle>
          <circle cx="26" cy="3" r="2"></circle>
        </svg>
      </div>
    </header>
    <main>
      <section class="topology-panel">
        <div class="draw-toolbar" id="draw-toolbar" style="display: flex !important;">
          <button type="button" class="toolbar-close-btn" id="draw-toolbar-close-btn" title="Hide draw toolbar">‚úï</button>
          <button id="draw-toggle" title="Draw custom line">‚úèÔ∏è</button>
          <button id="rect-toggle" title="Draw rectangle">‚ñ≠</button>
          <button id="text-toggle" title="Add text">T</button>
          <select id="rect-style" title="Rectangle style">
            <option value="filled">Filled</option>
            <option value="outlined">Outlined</option>
          </select>
          <input type="color" id="draw-color" value="#f97316" title="Line color">
          <select id="draw-style" title="Line style">
            <option value="solid">Solid</option>
            <option value="dashed">Dashed</option>
            <option value="dotted">Dotted</option>
          </select>
          <select id="draw-arrow" title="Arrow direction">
            <option value="none">No arrows</option>
            <option value="forward">‚Üí Right</option>
            <option value="backward">‚Üê Left</option>
            <option value="both">‚Üî Both</option>
          </select>
          <button id="draw-undo" style="display: none" title="Undo last point">Undo</button>
        </div>
        <div class="topology-toolbar" id="topology-toolbar" style="display: flex !important;">
          <button type="button" class="toolbar-close-btn" id="topology-toolbar-close-btn" title="Hide add line toolbar">‚úï</button>
          <label for="add-line-select">Add line to:</label>
          <select id="add-line-select"><option value="opnsense">OPNsense</option><option value="main-switch">Main Switch</option><option value="proxmox">Proxmox</option><option value="truenas">TrueNAS</option><option value="docker-host">Docker Host</option><option value="pi-hole">Pi-hole</option><option value="plex">Plex</option><option value="jellyfin">Jellyfin</option><option value="nextcloud">Nextcloud</option><option value="bitwarden">Vaultwarden</option><option value="homeassistant">Home Assistant</option><option value="portainer">Portainer</option><option value="traefik">Traefik</option><option value="grafana">Grafana</option><option value="prometheus">Prometheus</option><option value="unifi-controller">UniFi Controller</option><option value="wireguard">WireGuard</option><option value="im-a-rack">IM A RACK</option></select>
          <input type="color" id="add-line-color" value="#475569" title="Line color" style="width: 30px;height: 24px;border: 1px solid var(--edge-main);border-radius: 4px;cursor: pointer;background: transparent;padding: 0;">
          <select id="add-line-direction" title="Line direction">
            <option value="none">No arrows</option>
            <option value="forward">‚Üí Forward</option>
            <option value="backward">‚Üê Backward</option>
            <option value="both">‚Üî Both</option>
          </select>
          <button id="add-line-btn">Add</button>
        </div>
        <div class="topology-toolbar bulk-toolbar-desktop" id="bulk-toolbar" style="display: none">
          <button type="button" class="toolbar-close-btn" id="bulk-toolbar-close" title="Clear selection">‚úï</button>
          <label style="font-weight: 600; color: var(--accent)">Selected: <span id="bulk-count">0</span></label>
          <button id="bulk-align-left" title="Align left">‚¨Ö Left</button>
          <button id="bulk-align-right" title="Align right">‚û° Right</button>
          <button id="bulk-align-top" title="Align top">‚¨Ü Top</button>
          <button id="bulk-align-bottom" title="Align bottom">‚¨á Bottom</button>
          <button id="bulk-distribute-h" title="Distribute horizontally">‚Üî Distribute H</button>
          <button id="bulk-distribute-v" title="Distribute vertically">‚Üï Distribute V</button>
          <button id="bulk-clone" title="Clone selected">üìã Clone</button>
          <button id="bulk-delete" title="Delete selected" style="background: var(--danger); color: white;">Delete</button>
        </div>
        <div class="bulk-toolbar-mobile" id="bulk-toolbar-mobile" style="display: none">
          <button type="button" id="bulk-mobile-btn" style="background: var(--accent);color: white;padding: 12px 20px;border-radius: 25px;font-weight: 600;font-size: 16px;box-shadow: 0 4px 12px rgba(0,0,0,0.3);border: none;cursor: pointer;display: flex;align-items: center;gap: 8px;">
          <span id="bulk-count-mobile">0</span>Selected</button>
        </div>
        <div id="bulk-actions-modal" style="display: none;position: fixed;bottom: 0;left: 0;right: 0;background: var(--panel-alt);border-top-left-radius:20px;border-top-right-radius:20px;padding:20px;padding-bottom:(safe-area-inset-bottom, 20px);box-shadow: 0 -4px 20px rgba(0,0,0,0.5);z-index: 10000;max-height: calc(100vh - 80px);overflow-y: auto;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            <h3 style="margin: 0; color: var(--accent); font-size: 20px;">
              <span id="bulk-count-modal">0</span> Nodes Selected
            </h3>
            <button id="bulk-modal-close" style="background: none;border: none;font-size: 24px;cursor: pointer;color: var(--text-main);padding: 0;width: 32px;height: 32px;">‚úï</button>
          </div>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
            <button id="bulk-align-left-mobile" class="bulk-action-btn">‚¨Ö<br><span style="font-size: 12px;">Align Left</span></button>
            <button id="bulk-align-right-mobile" class="bulk-action-btn">‚û°<br><span style="font-size: 12px;">Align Right</span></button>
            <button id="bulk-align-top-mobile" class="bulk-action-btn">‚¨Ü<br><span style="font-size: 12px;">Align Top</span></button>
            <button id="bulk-align-bottom-mobile" class="bulk-action-btn">‚¨á<br><span style="font-size: 12px;">Align Bottom</span></button>
            <button id="bulk-distribute-h-mobile" class="bulk-action-btn">‚Üî<br><span style="font-size: 12px;">Distribute H</span></button>
            <button id="bulk-distribute-v-mobile" class="bulk-action-btn">‚Üï<br><span style="font-size: 12px;">Distribute V</span></button>
            <button id="bulk-lock-mobile" class="bulk-action-btn">üîí<br><span style="font-size: 12px;">Lock Toggle</span></button>
            <button id="bulk-group-mobile" class="bulk-action-btn">‚≠ï<br><span style="font-size: 12px;">Group Toggle</span></button>
            <button id="bulk-clone-mobile" class="bulk-action-btn">üìã<br><span style="font-size: 12px;">Clone All</span></button>
            <button id="bulk-delete-mobile" class="bulk-action-btn" style="background: var(--danger); color: white;">üóë<br><span style="font-size: 12px;">Delete All</span></button>
          </div>
          <button id="bulk-clear-mobile" style="width: 100%;margin-top: 16px;padding: 14px;background: var(--panel-main);border: 1px solid var(--edge-main);border-radius: 8px;color: var(--text-main);font-size: 16px;cursor: pointer;">Clear Selection</button>
        </div>
        <div class="canvas-hint" id="canvas-hint"><ul><li>Scroll to zoom</li><li>Drag to pan</li><li>Right-click to select multiple</li><li>Your time is NOW!</li></ul></div>
        <div class="legend-container" id="edge-legend" style="display: flex;"><div class="legend-title">Line Legend</div><button type="button" class="legend-close-btn">‚úï</button><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(239, 68, 68); cursor: pointer;"></span><span class="legend-label" contenteditable="true">WAN</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(16, 185, 129); cursor: pointer;"></span><span class="legend-label" contenteditable="true">LAN Trunk</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(139, 92, 246); cursor: pointer;"></span><span class="legend-label" contenteditable="true">Server VLAN</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(59, 130, 246); cursor: pointer;"></span><span class="legend-label" contenteditable="true">Management</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(245, 158, 11); cursor: pointer;"></span><span class="legend-label" contenteditable="true">VM Network</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(6, 182, 212); cursor: pointer;"></span><span class="legend-label" contenteditable="true">Containers</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(236, 72, 153); cursor: pointer;"></span><span class="legend-label" contenteditable="true">Storage</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(249, 115, 22); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div></div>
        <div class="canvas-viewport" id="canvas-viewport">
          <svg id="map" viewBox="384.66666666666674 27 3230.6666666666665 2423" style=""><defs><marker id="arrow-forward" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto" markerUnits="strokeWidth"><path d="M0,0 L0,6 L9,3 z" fill="context-stroke"></path></marker><marker id="arrow-backward" markerWidth="10" markerHeight="10" refX="0" refY="3" orient="auto" markerUnits="strokeWidth"><path d="M9,0 L9,6 L0,3 z" fill="context-stroke"></path></marker></defs><rect x="100" y="100" width="3800" height="2800" fill="none" stroke="rgba(71, 85, 105, 0.3)" stroke-width="2" stroke-dasharray="10 5" rx="8"></rect><path d="M 2000 227 Q 1843.414794921875 427.9279479980469 1686.82958984375 628.8558959960938" fill="none" class="edge active" data-edge-id="edge-1" data-from="isp-modem" data-to="opnsense" style="stroke: rgb(239, 68, 68); stroke-width: 6;"></path><path d="M 2000 227 Q 1843.414794921875 427.9279479980469 1686.82958984375 628.8558959960938" fill="none" data-edge-id="edge-1" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 1686.82958984375 628.8558959960938 Q 1843.414794921875 789.4279479980469 2000 950" fill="none" class="edge" data-edge-id="edge-2" data-from="opnsense" data-to="main-switch" style="stroke: rgb(16, 185, 129); stroke-width: 6;"></path><path d="M 1686.82958984375 628.8558959960938 Q 1843.414794921875 789.4279479980469 2000 950" fill="none" data-edge-id="edge-2" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2000 950 Q 1600 1150 1200 1350" fill="none" class="edge" data-edge-id="edge-3" data-from="main-switch" data-to="proxmox" style="stroke: rgb(139, 92, 246); stroke-width: 5;"></path><path d="M 2000 950 Q 1600 1150 1200 1350" fill="none" data-edge-id="edge-3" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2000 950 Q 2400 1150 2800 1350" fill="none" class="edge" data-edge-id="edge-4" data-from="main-switch" data-to="truenas" style="stroke: rgb(139, 92, 246); stroke-width: 5;"></path><path d="M 2000 950 Q 2400 1150 2800 1350" fill="none" data-edge-id="edge-4" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2000 950 Q 2000 1150 2000 1350" fill="none" class="edge" data-edge-id="edge-5" data-from="main-switch" data-to="docker-host" style="stroke: rgb(139, 92, 246); stroke-width: 5;"></path><path d="M 2000 950 Q 2000 1150 2000 1350" fill="none" data-edge-id="edge-5" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2000 950 Q 2000 1300 2000 1650" fill="none" class="edge" data-edge-id="edge-6" data-from="main-switch" data-to="pi-hole" style="stroke: rgb(59, 130, 246); stroke-width: 4;"></path><path d="M 2000 950 Q 2000 1300 2000 1650" fill="none" data-edge-id="edge-6" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 1200 1350 Q 900 1600 600 1850" fill="none" class="edge" data-edge-id="edge-7" data-from="proxmox" data-to="plex" style="stroke: rgb(245, 158, 11); stroke-width: 4;"></path><path d="M 1200 1350 Q 900 1600 600 1850" fill="none" data-edge-id="edge-7" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 1200 1350 Q 1100 1600 1000 1850" fill="none" class="edge" data-edge-id="edge-8" data-from="proxmox" data-to="homeassistant" style="stroke: rgb(245, 158, 11); stroke-width: 4;"></path><path d="M 1200 1350 Q 1100 1600 1000 1850" fill="none" data-edge-id="edge-8" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 1200 1350 Q 1300 1600 1400 1850" fill="none" class="edge" data-edge-id="edge-9" data-from="proxmox" data-to="wireguard" style="stroke: rgb(245, 158, 11); stroke-width: 4;"></path><path d="M 1200 1350 Q 1300 1600 1400 1850" fill="none" data-edge-id="edge-9" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2000 1350 Q 1700 1800 1400 2250" fill="none" class="edge" data-edge-id="edge-10" data-from="docker-host" data-to="jellyfin" style="stroke: rgb(6, 182, 212); stroke-width: 4;"></path><path d="M 2000 1350 Q 1700 1800 1400 2250" fill="none" data-edge-id="edge-10" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2000 1350 Q 1900 1800 1800 2250" fill="none" class="edge" data-edge-id="edge-11" data-from="docker-host" data-to="nextcloud" style="stroke: rgb(6, 182, 212); stroke-width: 4;"></path><path d="M 2000 1350 Q 1900 1800 1800 2250" fill="none" data-edge-id="edge-11" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2000 1350 Q 2100 1800 2200 2250" fill="none" class="edge" data-edge-id="edge-12" data-from="docker-host" data-to="bitwarden" style="stroke: rgb(6, 182, 212); stroke-width: 4;"></path><path d="M 2000 1350 Q 2100 1800 2200 2250" fill="none" data-edge-id="edge-12" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2000 1350 Q 2300 1800 2600 2250" fill="none" class="edge" data-edge-id="edge-13" data-from="docker-host" data-to="portainer" style="stroke: rgb(6, 182, 212); stroke-width: 4;"></path><path d="M 2000 1350 Q 2300 1800 2600 2250" fill="none" data-edge-id="edge-13" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2000 1350 Q 2500 1800 3000 2250" fill="none" class="edge" data-edge-id="edge-14" data-from="docker-host" data-to="traefik" style="stroke: rgb(6, 182, 212); stroke-width: 4;"></path><path d="M 2000 1350 Q 2500 1800 3000 2250" fill="none" data-edge-id="edge-14" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2000 1350 Q 2700 1800 3400 2250" fill="none" class="edge" data-edge-id="edge-15" data-from="docker-host" data-to="grafana" style="stroke: rgb(6, 182, 212); stroke-width: 4;"></path><path d="M 2000 1350 Q 2700 1800 3400 2250" fill="none" data-edge-id="edge-15" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2000 1350 Q 2700 1600 3400 1850" fill="none" class="edge" data-edge-id="edge-16" data-from="docker-host" data-to="prometheus" style="stroke: rgb(6, 182, 212); stroke-width: 4;"></path><path d="M 2000 1350 Q 2700 1600 3400 1850" fill="none" data-edge-id="edge-16" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2000 1350 Q 2500 1600 3000 1850" fill="none" class="edge" data-edge-id="edge-17" data-from="docker-host" data-to="unifi-controller" style="stroke: rgb(6, 182, 212); stroke-width: 4;"></path><path d="M 2000 1350 Q 2500 1600 3000 1850" fill="none" data-edge-id="edge-17" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2800 1350 Q 1700 1600 600 1850" fill="none" class="edge" data-edge-id="edge-18" data-from="truenas" data-to="plex" style="stroke: rgb(236, 72, 153); stroke-width: 3;"></path><path d="M 2800 1350 Q 1700 1600 600 1850" fill="none" data-edge-id="edge-18" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2800 1350 Q 2100 1800 1400 2250" fill="none" class="edge" data-edge-id="edge-19" data-from="truenas" data-to="jellyfin" style="stroke: rgb(236, 72, 153); stroke-width: 3;"></path><path d="M 2800 1350 Q 2100 1800 1400 2250" fill="none" data-edge-id="edge-19" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2800 1350 Q 2300 1800 1800 2250" fill="none" class="edge" data-edge-id="edge-20" data-from="truenas" data-to="nextcloud" style="stroke: rgb(236, 72, 153); stroke-width: 3;"></path><path d="M 2800 1350 Q 2300 1800 1800 2250" fill="none" data-edge-id="edge-20" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><polyline class="edge" data-edge-id="custom-1764789591702" fill="none" marker-end="url(#arrow-forward)" points="2180.72900390625,753.431884765625 2178.278076171875,883.335693359375 2273.86767578125,888.2376708984375" style="stroke: rgb(249, 115, 22); stroke-width: 4; stroke-dasharray: none;"></polyline><polyline points="2180.72900390625,753.431884765625 2178.278076171875,883.335693359375 2273.86767578125,888.2376708984375" data-edge-id="custom-1764789591702" style="fill: none; stroke: transparent; stroke-width: 20; cursor: pointer;"></polyline><polyline class="edge" data-edge-id="custom-1764791338569" fill="none" marker-end="url(#arrow-forward)" points="1178.4932861328125,139.6976776123047 1282.2938232421875,59.62301254272461 1730.1187744140625,127.83476257324219" style="stroke: rgb(249, 115, 22); stroke-width: 4; stroke-dasharray: 10, 5;"></polyline><polyline points="1178.4932861328125,139.6976776123047 1282.2938232421875,59.62301254272461 1730.1187744140625,127.83476257324219" data-edge-id="custom-1764791338569" style="fill: none; stroke: transparent; stroke-width: 20; cursor: pointer;"></polyline><g class="node-group active" data-node-id="isp-modem" transform="translate(2000,227)" style="cursor: grab;"><circle r="190.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" role="img" viewBox="0 0 24 24" width="152.4" height="152.4" x="-76.2" y="-76.2" style="fill: rgb(255, 0, 0);"><title>OPNsense</title><path d="M5.25 0v5.25h13.5v13.5H24V7.5L16.5 0Zm13.5 18.75H5.25V5.25H0V16.5L7.5 24h11.25Z"></path></svg></g><text class="node-label" x="0" y="-35.56" style="font-size: 41.91px; pointer-events: none;">OPNSENSE</text><text class="node-sub" x="0" y="50.800000000000004" style="font-size: 30.48px; pointer-events: none;">192.168.100.1</text><circle class="ping-indicator online" r="7.62" cx="-113.22375109863282" cy="-88.894"></circle></g><g class="node-group" data-node-id="opnsense" transform="translate(1686.82958984375,628.8558959960938)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-55" y="-44" width="110" height="88" rx="4"></rect><line x1="-46.75" y1="-27.5" x2="46.75" y2="-27.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="-2.75" x2="46.75" y2="-2.75" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="22" x2="46.75" y2="22" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="-44" x2="-27.5" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="-44" x2="11" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="-19.25" x2="-8.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="-19.25" x2="30.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="5.5" x2="-27.5" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="5.5" x2="11" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="30.25" x2="-8.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="30.25" x2="30.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18.15px; pointer-events: none;">OPNsense</text><text class="node-sub" x="0" y="22" style="font-size: 13.2px; pointer-events: none;">192.168.1.1</text></g><g class="node-group" data-node-id="main-switch" transform="translate(2000,950)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-77" y="-22" width="154" height="44" rx="4"></rect><rect x="-66" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-48.4" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-30.799999999999997" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-13.199999999999996" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="4.400000000000006" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="22" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="39.60000000000001" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="57.2" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18.15px; pointer-events: none;">Main Switch</text><text class="node-sub" x="0" y="22" style="font-size: 13.2px; pointer-events: none;">192.168.1.2</text></g><g class="node-group" data-node-id="proxmox" transform="translate(1200,1350)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-66" y="-33" width="132" height="66" rx="4"></rect><line x1="-49.5" y1="-16.5" x2="-49.5" y2="16.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="-22" y1="-16.5" x2="-22" y2="16.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="5.5" y1="-16.5" x2="5.5" y2="16.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><circle cx="49.5" cy="0" r="5.5" style="fill: rgb(74, 222, 128);"></circle></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18.15px; pointer-events: none;">Proxmox</text><text class="node-sub" x="0" y="22" style="font-size: 13.2px; pointer-events: none;">192.168.1.10</text></g><g class="node-group" data-node-id="truenas" transform="translate(2800,1350)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-38.5" y="-33" width="77" height="77"></rect><ellipse cx="0" cy="-33" rx="38.5" ry="13.75"></ellipse><ellipse cx="0" cy="44" rx="38.5" ry="13.75"></ellipse><ellipse cx="0" cy="-8.25" rx="38.5" ry="11" style="fill: none; stroke: rgb(71, 85, 105); stroke-width: 2;"></ellipse><ellipse cx="0" cy="19.25" rx="38.5" ry="11" style="fill: none; stroke: rgb(71, 85, 105); stroke-width: 2;"></ellipse></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18.15px; pointer-events: none;">TrueNAS</text><text class="node-sub" x="0" y="22" style="font-size: 13.2px; pointer-events: none;">192.168.1.11</text></g><g class="node-group" data-node-id="docker-host" transform="translate(2000,1350)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-66" y="-33" width="132" height="66" rx="4"></rect><line x1="-49.5" y1="-16.5" x2="-49.5" y2="16.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="-22" y1="-16.5" x2="-22" y2="16.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="5.5" y1="-16.5" x2="5.5" y2="16.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><circle cx="49.5" cy="0" r="5.5" style="fill: rgb(74, 222, 128);"></circle></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18.15px; pointer-events: none;">Docker Host</text><text class="node-sub" x="0" y="22" style="font-size: 13.2px; pointer-events: none;">192.168.1.12</text></g><g class="node-group" data-node-id="pi-hole" transform="translate(2000,1650)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="66" height="66" x="-33" y="-33"><image href="https://cdn.jsdelivr.net/gh/selfhst/icons@master/png/pi-hole.png" width="24" height="24"></image></svg></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18.15px; pointer-events: none;">Pi-hole</text><text class="node-sub" x="0" y="22" style="font-size: 13.2px; pointer-events: none;">192.168.1.53</text></g><g class="node-group" data-node-id="plex" transform="translate(600,1850)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="66" height="66" x="-33" y="-33"><image href="https://cdn.jsdelivr.net/gh/selfhst/icons@master/png/plex.png" width="24" height="24"></image></svg></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18.15px; pointer-events: none;">Plex</text><text class="node-sub" x="0" y="22" style="font-size: 13.2px; pointer-events: none;">192.168.1.20</text></g><g class="node-group" data-node-id="jellyfin" transform="translate(1400,2250)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="66" height="66" x="-33" y="-33"><image href="https://cdn.jsdelivr.net/gh/selfhst/icons@master/png/jellyfin.png" width="24" height="24"></image></svg></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18.15px; pointer-events: none;">Jellyfin</text><text class="node-sub" x="0" y="22" style="font-size: 13.2px; pointer-events: none;">192.168.1.21</text></g><g class="node-group" data-node-id="nextcloud" transform="translate(1800,2250)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" role="img" viewBox="0 0 24 24" width="66" height="66" x="-33" y="-33"><title>Nextcloud</title><path d="M12.018 6.537c-2.5 0-4.6 1.712-5.241 4.015-.56-1.232-1.793-2.105-3.225-2.105A3.569 3.569 0 0 0 0 12a3.569 3.569 0 0 0 3.552 3.553c1.432 0 2.664-.874 3.224-2.106.641 2.304 2.742 4.016 5.242 4.016 2.487 0 4.576-1.693 5.231-3.977.569 1.21 1.783 2.067 3.198 2.067A3.568 3.568 0 0 0 24 12a3.569 3.569 0 0 0-3.553-3.553c-1.416 0-2.63.858-3.199 2.067-.654-2.284-2.743-3.978-5.23-3.977zm0 2.085c1.878 0 3.378 1.5 3.378 3.378 0 1.878-1.5 3.378-3.378 3.378A3.362 3.362 0 0 1 8.641 12c0-1.878 1.5-3.378 3.377-3.378zm-8.466 1.91c.822 0 1.467.645 1.467 1.468s-.644 1.467-1.467 1.468A1.452 1.452 0 0 1 2.085 12c0-.823.644-1.467 1.467-1.467zm16.895 0c.823 0 1.468.645 1.468 1.468s-.645 1.468-1.468 1.468A1.452 1.452 0 0 1 18.98 12c0-.823.644-1.467 1.467-1.467z"></path></svg></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18.15px; pointer-events: none;">Nextcloud</text><text class="node-sub" x="0" y="22" style="font-size: 13.2px; pointer-events: none;">192.168.1.30</text></g><g class="node-group" data-node-id="bitwarden" transform="translate(2200,2250)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" role="img" viewBox="0 0 24 24" width="66" height="66" x="-33" y="-33"><title>Bitwarden</title><path d="M21.722.296A.964.964 0 0 0 21.018 0H2.982a.959.959 0 0 0-.703.296.96.96 0 0 0-.297.702v12c0 .895.174 1.783.523 2.665.349.88.783 1.66 1.3 2.345.517.68 1.132 1.346 1.848 1.993a21.807 21.807 0 0 0 1.98 1.609c.605.427 1.235.83 1.893 1.212.657.381 1.125.638 1.4.772.276.134.5.241.664.311a.916.916 0 0 0 .814 0c.168-.073.389-.177.667-.311.275-.134.743-.394 1.401-.772a25.305 25.305 0 0 0 1.894-1.212A21.891 21.891 0 0 0 18.348 20c.716-.647 1.33-1.31 1.847-1.993s.949-1.463 1.3-2.345c.35-.879.524-1.767.524-2.665V1.001a.95.95 0 0 0-.297-.705zm-2.325 12.815c0 4.344-7.397 8.087-7.397 8.087V2.57h7.397v10.54z"></path></svg></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18.15px; pointer-events: none;">Vaultwarden</text><text class="node-sub" x="0" y="22" style="font-size: 13.2px; pointer-events: none;">192.168.1.31</text></g><g class="node-group" data-node-id="homeassistant" transform="translate(1000,1850)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" role="img" viewBox="0 0 24 24" width="66" height="66" x="-33" y="-33"><title>Home Assistant</title><path d="M22.939 10.627 13.061.749a1.505 1.505 0 0 0-2.121 0l-9.879 9.878C.478 11.21 0 12.363 0 13.187v9c0 .826.675 1.5 1.5 1.5h9.227l-4.063-4.062a2.034 2.034 0 0 1-.664.113c-1.13 0-2.05-.92-2.05-2.05s.92-2.05 2.05-2.05 2.05.92 2.05 2.05c0 .233-.041.456-.113.665l3.163 3.163V9.928a2.05 2.05 0 0 1-1.15-1.84c0-1.13.92-2.05 2.05-2.05s2.05.92 2.05 2.05a2.05 2.05 0 0 1-1.15 1.84v8.127l3.146-3.146A2.051 2.051 0 0 1 18 12.239c1.13 0 2.05.92 2.05 2.05s-.92 2.05-2.05 2.05c-.25 0-.488-.047-.709-.13L12.9 20.602v3.088h9.6c.825 0 1.5-.675 1.5-1.5v-9c0-.825-.477-1.977-1.061-2.561z"></path></svg></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18.15px; pointer-events: none;">Home Assistant</text><text class="node-sub" x="0" y="22" style="font-size: 13.2px; pointer-events: none;">192.168.1.40</text></g><g class="node-group" data-node-id="portainer" transform="translate(2600,2250)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" role="img" viewBox="0 0 24 24" width="66" height="66" x="-33" y="-33"><title>Portainer</title><path d="M12.504 0v1.023l-.01-.015-6.106 3.526H3.417v.751h5.359v3.638h1.942V5.284h1.786v10.416c.027 0 .54-.01.751.091V5.285h.531v10.608c.293.147.55.312.751.54V5.286h6.046v-.75h-1.267l-6.061-3.5V0zm0 1.87v2.664H7.889zm.751.031l4.56 2.633h-4.56zM9.142 5.285h1.21v1.686h-1.21zm-4.736 2.73v1.951h1.942v-1.95zm2.19 0v1.951h1.941v-1.95zm-2.19 2.171v1.951h1.942v-1.95zm2.19 0v1.951h1.941v-1.95zm2.18 0v1.951h1.942v-1.95zM4.36 12.43a3.73 3.73 0 00-.494 1.851c0 1.227.604 2.308 1.52 2.986.239-.064.477-.1.724-.11.1 0 .165.01.266.019.284-1.191 1.383-1.988 2.665-1.988.724 0 1.438.201 1.924.668.229-.476.302-1.007.302-1.575 0-.65-.165-1.292-.494-1.85zm4.828 3.16c-1.21 0-2.226.844-2.492 1.97a.922.922 0 00-.275-.009 2.559 2.559 0 00-2.564 2.556 2.565 2.565 0 003.096 2.5A2.579 2.579 0 009.233 24c.862 0 1.622-.43 2.09-1.081a2.557 2.557 0 004.186-1.97c0-.567-.193-1.099-.504-1.52a2.557 2.557 0 00-3.866-2.94 2.574 2.574 0 00-1.951-.898z"></path></svg></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18.15px; pointer-events: none;">Portainer</text><text class="node-sub" x="0" y="22" style="font-size: 13.2px; pointer-events: none;">192.168.1.50</text></g><g class="node-group" data-node-id="traefik" transform="translate(3000,2250)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" role="img" viewBox="0 0 24 24" width="66" height="66" x="-33" y="-33"><title>Traefik Proxy</title><path d="M12 1.19c1.088 0 2.056.768 2.056 1.714 0 .947-.921 1.715-2.056 1.715-.13 0-.3-.022-.509-.064a.685.685 0 0 0-.475.076l-7.37 4.195a.344.344 0 0 0 .001.597l7.99 4.49c.208.116.461.116.669 0l8.034-4.468a.343.343 0 0 0 .003-.598l-2.507-1.424a.683.683 0 0 0-.67-.003l-2.647 1.468a.234.234 0 0 0-.119.18l-.001.025c0 .946-.921 1.714-2.056 1.714s-2.056-.768-2.056-1.714c0-.947.921-1.715 2.056-1.715.042 0 .09.002.145.007l.087.008.096.013a.685.685 0 0 0 .425-.08l3.913-2.173c.3-.166.662-.171.965-.017l.04.023 5.465 3.104c.686.39.693 1.368.03 1.773l-.037.021-3.656 2.033a.343.343 0 0 0 .007.604l3.62 1.906c.72.378.736 1.402.03 1.804l-10.995 6.272a1.03 1.03 0 0 1-1.019 0L.526 16.43a1.03 1.03 0 0 1 .034-1.806l3.66-1.911a.343.343 0 0 0 .01-.603L.524 10.029a1.03 1.03 0 0 1-.041-1.77l.036-.021L9.618 3.06a.688.688 0 0 0 .308-.369l.011-.036c.32-.952 1.046-1.466 2.063-1.466Zm5.076 12.63-4.492 2.586-.041.022c-.306.158-.671.152-.973-.018l-4.478-2.527a.682.682 0 0 0-.65-.01L3.86 15.224a.343.343 0 0 0-.012.602l7.887 4.515c.21.12.467.121.677 0l7.956-4.547a.343.343 0 0 0-.01-.602l-2.623-1.384a.683.683 0 0 0-.659.012z"></path></svg></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18.15px; pointer-events: none;">Traefik</text><text class="node-sub" x="0" y="22" style="font-size: 13.2px; pointer-events: none;">192.168.1.51</text></g><g class="node-group" data-node-id="grafana" transform="translate(3400,2250)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" role="img" viewBox="0 0 24 24" width="66" height="66" x="-33" y="-33"><title>Grafana</title><path d="M23.02 10.59a8.578 8.578 0 0 0-.862-3.034 8.911 8.911 0 0 0-1.789-2.445c.337-1.342-.413-2.505-.413-2.505-1.292-.08-2.113.4-2.416.62-.052-.02-.102-.044-.154-.064-.22-.089-.446-.172-.677-.247-.231-.073-.47-.14-.711-.197a9.867 9.867 0 0 0-.875-.161C14.557.753 12.94 0 12.94 0c-1.804 1.145-2.147 2.744-2.147 2.744l-.018.093c-.098.029-.2.057-.298.088-.138.042-.275.094-.413.143-.138.055-.275.107-.41.166a8.869 8.869 0 0 0-1.557.87l-.063-.029c-2.497-.955-4.716.195-4.716.195-.203 2.658.996 4.33 1.235 4.636a11.608 11.608 0 0 0-.607 2.635C1.636 12.677.953 15.014.953 15.014c1.926 2.214 4.171 2.351 4.171 2.351.003-.002.006-.002.006-.005.285.509.615.994.986 1.446.156.19.32.371.488.548-.704 2.009.099 3.68.099 3.68 2.144.08 3.553-.937 3.849-1.173a9.784 9.784 0 0 0 3.164.501h.08l.055-.003.107-.002.103-.005.003.002c1.01 1.44 2.788 1.646 2.788 1.646 1.264-1.332 1.337-2.653 1.337-2.94v-.058c0-.02-.003-.039-.003-.06.265-.187.52-.387.758-.6a7.875 7.875 0 0 0 1.415-1.7c1.43.083 2.437-.885 2.437-.885-.236-1.49-1.085-2.216-1.264-2.354l-.018-.013-.016-.013a.217.217 0 0 1-.031-.02c.008-.092.016-.18.02-.27.011-.162.016-.323.016-.48v-.253l-.005-.098-.008-.135a1.891 1.891 0 0 0-.01-.13c-.003-.042-.008-.083-.013-.125l-.016-.124-.018-.122a6.215 6.215 0 0 0-2.032-3.73 6.015 6.015 0 0 0-3.222-1.46 6.292 6.292 0 0 0-.85-.048l-.107.002h-.063l-.044.003-.104.008a4.777 4.777 0 0 0-3.335 1.695c-.332.4-.592.84-.768 1.297a4.594 4.594 0 0 0-.312 1.817l.003.091c.005.055.007.11.013.164a3.615 3.615 0 0 0 .698 1.82 3.53 3.53 0 0 0 1.827 1.282c.33.098.66.14.971.137.039 0 .078 0 .114-.002l.063-.003c.02 0 .041-.003.062-.003.034-.002.065-.007.099-.01.007 0 .018-.003.028-.003l.031-.005.06-.008a1.18 1.18 0 0 0 .112-.02c.036-.008.072-.013.109-.024a2.634 2.634 0 0 0 .914-.415c.028-.02.056-.041.085-.065a.248.248 0 0 0 .039-.35.244.244 0 0 0-.309-.06l-.078.042c-.09.044-.184.083-.283.116a2.476 2.476 0 0 1-.475.096c-.028.003-.054.006-.083.006l-.083.002c-.026 0-.054 0-.08-.002l-.102-.006h-.012l-.024.006c-.016-.003-.031-.003-.044-.006-.031-.002-.06-.007-.091-.01a2.59 2.59 0 0 1-.724-.213 2.557 2.557 0 0 1-.667-.438 2.52 2.52 0 0 1-.805-1.475 2.306 2.306 0 0 1-.029-.444l.006-.122v-.023l.002-.031c.003-.021.003-.04.005-.06a3.163 3.163 0 0 1 1.352-2.29 3.12 3.12 0 0 1 .937-.43 2.946 2.946 0 0 1 .776-.101h.06l.07.002.045.003h.026l.07.005a4.041 4.041 0 0 1 1.635.49 3.94 3.94 0 0 1 1.602 1.662 3.77 3.77 0 0 1 .397 1.414l.005.076.003.075c.002.026.002.05.002.075 0 .024.003.052 0 .07v.065l-.002.073-.008.174a6.195 6.195 0 0 1-.08.639 5.1 5.1 0 0 1-.267.927 5.31 5.31 0 0 1-.624 1.13 5.052 5.052 0 0 1-3.237 2.014 4.82 4.82 0 0 1-.649.066l-.039.003h-.287a6.607 6.607 0 0 1-1.716-.265 6.776 6.776 0 0 1-3.4-2.274 6.75 6.75 0 0 1-.746-1.15 6.616 6.616 0 0 1-.714-2.596l-.005-.083-.002-.02v-.056l-.003-.073v-.096l-.003-.104v-.07l.003-.163c.008-.22.026-.45.054-.678a8.707 8.707 0 0 1 .28-1.355c.128-.444.286-.872.473-1.277a7.04 7.04 0 0 1 1.456-2.1 5.925 5.925 0 0 1 .953-.763c.169-.111.343-.213.524-.306.089-.05.182-.091.273-.135.047-.02.093-.042.138-.062a7.177 7.177 0 0 1 .714-.267l.145-.045c.049-.015.098-.026.148-.041.098-.029.197-.052.296-.076.049-.013.1-.02.15-.033l.15-.032.151-.028.076-.013.075-.01.153-.024c.057-.01.114-.013.171-.023l.169-.021c.036-.003.073-.008.106-.01l.073-.008.036-.003.042-.002c.057-.003.114-.008.171-.01l.086-.006h.023l.037-.003.145-.007a7.999 7.999 0 0 1 1.708.125 7.917 7.917 0 0 1 2.048.68 8.253 8.253 0 0 1 1.672 1.09l.09.077.089.078c.06.052.114.107.171.159.057.052.112.106.166.16.052.055.107.107.159.164a8.671 8.671 0 0 1 1.41 1.978c.012.026.028.052.04.078l.04.078.075.156c.023.051.05.1.07.153l.065.15a8.848 8.848 0 0 1 .45 1.34.19.19 0 0 0 .201.142.186.186 0 0 0 .172-.184c.01-.246.002-.532-.024-.856z"></path></svg></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18.15px; pointer-events: none;">Grafana</text><text class="node-sub" x="0" y="22" style="font-size: 13.2px; pointer-events: none;">192.168.1.60</text></g><g class="node-group" data-node-id="prometheus" transform="translate(3400,1850)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" role="img" viewBox="0 0 24 24" width="66" height="66" x="-33" y="-33"><title>Prometheus</title><path d="M12 0C5.373 0 0 5.372 0 12c0 6.627 5.373 12 12 12s12-5.373 12-12c0-6.628-5.373-12-12-12zm0 22.46c-1.885 0-3.414-1.26-3.414-2.814h6.828c0 1.553-1.528 2.813-3.414 2.813zm5.64-3.745H6.36v-2.046h11.28v2.046zm-.04-3.098H6.391c-.037-.043-.075-.086-.111-.13-1.155-1.401-1.427-2.133-1.69-2.879-.005-.025 1.4.287 2.395.511 0 0 .513.119 1.262.255-.72-.843-1.147-1.915-1.147-3.01 0-2.406 1.845-4.508 1.18-6.207.648.053 1.34 1.367 1.387 3.422.689-.951.977-2.69.977-3.755 0-1.103.727-2.385 1.454-2.429-.648 1.069.168 1.984.894 4.256.272.854.237 2.29.447 3.201.07-1.892.395-4.652 1.595-5.605-.529 1.2.079 2.702.494 3.424.671 1.164 1.078 2.047 1.078 3.716a4.642 4.642 0 01-1.11 2.996c.792-.149 1.34-.283 1.34-.283l2.573-.502s-.374 1.538-1.81 3.019z"></path></svg></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18.15px; pointer-events: none;">Prometheus</text><text class="node-sub" x="0" y="22" style="font-size: 13.2px; pointer-events: none;">192.168.1.61</text></g><g class="node-group" data-node-id="unifi-controller" transform="translate(3000,1850)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" role="img" viewBox="0 0 24 24" width="66" height="66" x="-33" y="-33"><title>Ubiquiti</title><path d="M23.1627 0h-1.4882v1.4882h1.4882zm-5.2072 10.4226V7.4409l.0007.001h2.9755v2.9762h2.9756v.9433c0 1.0906-.0927 2.3827-.306 3.3973-.1194.5672-.3004 1.1308-.5127 1.672-.2175.5537-.468 1.0841-.7408 1.5595a11.6795 11.6795 0 0 1-1.2456 1.7762l-.0253.0294-.0417.0488c-.1148.1347-.2283.2679-.3531.398a11.7612 11.7612 0 0 1-.4494.4492c-1.9046 1.8343-4.3861 2.98-6.9808 3.243-.3122.032-.939.0652-1.2519.0652-.3139-.001-.9397-.0331-1.252-.0651-2.5946-.263-5.0761-1.4097-6.9806-3.243a11.75 11.75 0 0 1-.4495-.4494c-.131-.1356-.249-.2748-.3683-.4154l-.0006-.0004-.0512-.0603a11.6576 11.6576 0 0 1-1.2456-1.7762c-.2727-.4763-.5233-1.0058-.7408-1.5595-.2123-.5414-.3933-1.1048-.5128-1.6718C.1854 13.743.0927 12.452.0927 11.3616V.1864h5.9518v10.2362s0 .7847.0099 1.0415l.0022.0599v.0004c.0127.332.0247.6575.0594.9812.098.919.3014 1.7913.7203 2.5288.1213.213.2443.42.3915.616.8953 1.1939 2.2577 2.0901 3.9573 2.3398.2022.0294.6108.0552.8149.0552.204 0 .6125-.0258.8149-.0552 1.6996-.2497 3.062-1.146 3.9573-2.3398.148-.196.2701-.403.3914-.616.419-.7375.6224-1.6095.7204-2.5288.0346-.3243.047-.6503.0594-.9831l.0022-.0584c.0099-.2568.0099-1.0415.0099-1.0415zm.7427-8.19h2.2326v2.2319h2.9764v2.9764h-2.9764V4.4654h-2.2326V2.2328Z"></path></svg></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18.15px; pointer-events: none;">UniFi Controller</text><text class="node-sub" x="0" y="22" style="font-size: 13.2px; pointer-events: none;">192.168.1.70</text></g><g class="node-group" data-node-id="wireguard" transform="translate(1400,1850)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" role="img" viewBox="0 0 24 24" width="66" height="66" x="-33" y="-33"><title>WireGuard</title><path d="M23.98 11.645S24.533 0 11.735 0C.418 0 .064 11.17.064 11.17S-1.6 24 11.997 24C25.04 24 23.98 11.645 23.98 11.645zM8.155 7.576c2.4-1.47 5.469-.571 6.618 1.638.218.419.246 1.063.108 1.503-.477 1.516-1.601 2.366-3.145 2.728.455-.39.817-.832.933-1.442a2.112 2.112 0 0 0-.364-1.677 2.14 2.14 0 0 0-2.465-.75c-.95.36-1.47 1.228-1.377 2.294.087.99.839 1.632 2.245 1.876-.21.111-.372.193-.53.281a5.113 5.113 0 0 0-1.644 1.43c-.143.192-.24.208-.458.075-2.827-1.729-3.009-6.067.078-7.956zM6.04 18.258c-.455.116-.895.286-1.359.438.227-1.532 2.021-2.943 3.539-2.782a3.91 3.91 0 0 0-.74 2.072c-.504.093-.98.155-1.44.272zM15.703 3.3c.448.017.898.01 1.347.02a2.324 2.324 0 0 1 .334.047 3.249 3.249 0 0 1-.34.434c-.16.15-.341.296-.573.069-.055-.055-.187-.042-.283-.044-.447-.005-.894-.02-1.34-.003a8.323 8.323 0 0 0-1.154.118c-.072.013-.178.25-.146.338.078.207.191.435.359.567.619.49 1.277.928 1.9 1.413.604.472 1.167.99 1.51 1.7.446.928.46 1.9.267 2.877-.322 1.63-1.147 2.98-2.483 3.962-.538.395-1.205.62-1.821.903-.543.25-1.1.465-1.644.712-.98.446-1.53 1.51-1.369 2.615.149 1.015 1.04 1.862 2.059 2.037 1.223.21 2.486-.586 2.785-1.83.336-1.397-.423-2.646-1.845-3.024l-.256-.066c.38-.17.708-.291 1.012-.458q.793-.437 1.558-.925c.15-.096.231-.096.36.014.977.846 1.56 1.898 1.724 3.187.27 2.135-.74 4.096-2.646 5.101-2.948 1.555-6.557-.215-7.208-3.484-.558-2.8 1.418-5.34 3.797-5.83 1.023-.211 1.958-.637 2.685-1.425.47-.508.697-.944.775-1.141a3.165 3.165 0 0 0 .217-1.158 2.71 2.71 0 0 0-.237-.992c-.248-.566-1.2-1.466-1.435-1.656l-2.24-1.754c-.079-.065-.168-.06-.36-.047-.23.016-.815.048-1.067-.018.204-.155.76-.38 1-.56-.726-.49-1.554-.314-2.315-.46.176-.328 1.046-.831 1.541-.888a7.323 7.323 0 0 0-.135-.822c-.03-.111-.154-.22-.263-.283-.262-.154-.541-.281-.843-.434a1.755 1.755 0 0 1 .906-.28 3.385 3.385 0 0 1 .908.088c.54.123.97.042 1.399-.324-.338-.136-.676-.26-1.003-.407a9.843 9.843 0 0 1-.942-.493c.85.118 1.671.437 2.54.32l.022-.118-2.018-.47c1.203-.11 2.323-.128 3.384.388.299.146.61.266.897.432.14.08.233.24.348.365.09.098.164.23.276.29.424.225.89.234 1.366.223l.01-.16c.479.15 1.017.702 1.017 1.105-.776 0-1.55-.003-2.325.004-.083 0-.165.061-.247.094.078.046.155.128.235.131z M14.703 2.153a.118.118 0 0 0-.016.19.179.179 0 0 0 .246.065c.075-.038.148-.078.238-.125-.072-.062-.13-.114-.19-.163-.106-.087-.193-.032-.278.033z"></path></svg></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18.15px; pointer-events: none;">WireGuard</text><text class="node-sub" x="0" y="22" style="font-size: 13.2px; pointer-events: none;">192.168.1.80</text></g><g class="node-group" data-node-id="im-a-rack" transform="translate(2590.18017578125,882.6126098632812)" style="cursor: grab;"><circle r="271.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><rect x="-217.2" y="-108.6" width="434.4" height="217.2" rx="4"></rect><line x1="-162.9" y1="-54.3" x2="-162.9" y2="54.3" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="-72.4" y1="-54.3" x2="-72.4" y2="54.3" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="18.099999999999994" y1="-54.3" x2="18.099999999999994" y2="54.3" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><circle cx="162.9" cy="0" r="18.1" style="fill: rgb(74, 222, 128);"></circle></g><text class="node-label" x="0" y="-50.68000000000001" style="font-size: 59.73px; pointer-events: none;">IM A RACK</text><text class="node-sub" x="0" y="72.4" style="font-size: 43.44px; pointer-events: none;"></text><text x="126.69999999999999" y="-126.69999999999999" class="lock-indicator" style="font-size: 54.3px; pointer-events: none;">üîí</text></g><g class="text-group" data-text-id="text-1764789550897"><text class="text-element" x="2158.669921875" y="621.0770263671875" dominant-baseline="middle" style="fill: rgb(226, 232, 240); font-size: 37px; font-weight: normal; font-style: normal; text-anchor: start; text-decoration: none; opacity: 1; cursor: move; user-select: none;"><tspan x="2158.669921875" dy="0">DOUBLE CLICK ON DESKTOP</tspan><tspan x="2158.669921875" dy="44.4">OR LONG PRESS ON MOBILE</tspan><tspan x="2158.669921875" dy="44.4">TO OPEN RACK VIEW</tspan></text><g class="text-delete-btn" style="cursor: pointer; display: none;"><circle cx="2178.669921875" cy="584.0770263671875" r="12" style="fill: rgb(245, 101, 101); stroke: white; stroke-width: 2;"></circle><text x="2178.669921875" y="584.0770263671875" text-anchor="middle" dominant-baseline="middle" style="fill: white; font-size: 16px; font-weight: bold; pointer-events: none;">√ó</text></g></g><g class="text-group" data-text-id="text-1764791291347"><text class="text-element" x="1065.795654296875" y="187.14932250976562" dominant-baseline="middle" style="fill: rgb(226, 232, 240); font-size: 41px; font-weight: bold; font-style: normal; text-anchor: start; text-decoration: none; opacity: 1; cursor: move; user-select: none;"><tspan x="1065.795654296875" dy="0">Router is live!</tspan><tspan x="1065.795654296875" dy="49.199999999999996">Uses http requests to live ping</tspan></text><g class="text-delete-btn" style="cursor: pointer; display: none;"><circle cx="1085.795654296875" cy="146.14932250976562" r="12" style="fill: rgb(245, 101, 101); stroke: white; stroke-width: 2;"></circle><text x="1085.795654296875" y="146.14932250976562" text-anchor="middle" dominant-baseline="middle" style="fill: white; font-size: 16px; font-weight: bold; pointer-events: none;">√ó</text></g></g></svg>
        </div>
        <div class="minimap-zoom-wrapper" id="minimap-zoom-wrapper" style="display: block;">
          <button type="button" class="minimap-close-btn" id="minimap-close-btn" title="Hide map &amp; zoom">‚úï</button>
          <div class="minimap-container" id="minimap-container">
            <svg id="minimap" viewBox="0 0 4000 3000">
              <line x1="2000" y1="227" x2="1686.82958984375" y2="628.8558959960938" class="minimap-edge"></line><line x1="1686.82958984375" y1="628.8558959960938" x2="2000" y2="950" class="minimap-edge"></line><line x1="2000" y1="950" x2="1200" y2="1350" class="minimap-edge"></line><line x1="2000" y1="950" x2="2800" y2="1350" class="minimap-edge"></line><line x1="2000" y1="950" x2="2000" y2="1350" class="minimap-edge"></line><line x1="2000" y1="950" x2="2000" y2="1650" class="minimap-edge"></line><line x1="1200" y1="1350" x2="600" y2="1850" class="minimap-edge"></line><line x1="1200" y1="1350" x2="1000" y2="1850" class="minimap-edge"></line><line x1="1200" y1="1350" x2="1400" y2="1850" class="minimap-edge"></line><line x1="2000" y1="1350" x2="1400" y2="2250" class="minimap-edge"></line><line x1="2000" y1="1350" x2="1800" y2="2250" class="minimap-edge"></line><line x1="2000" y1="1350" x2="2200" y2="2250" class="minimap-edge"></line><line x1="2000" y1="1350" x2="2600" y2="2250" class="minimap-edge"></line><line x1="2000" y1="1350" x2="3000" y2="2250" class="minimap-edge"></line><line x1="2000" y1="1350" x2="3400" y2="2250" class="minimap-edge"></line><line x1="2000" y1="1350" x2="3400" y2="1850" class="minimap-edge"></line><line x1="2000" y1="1350" x2="3000" y2="1850" class="minimap-edge"></line><line x1="2800" y1="1350" x2="600" y2="1850" class="minimap-edge"></line><line x1="2800" y1="1350" x2="1400" y2="2250" class="minimap-edge"></line><line x1="2800" y1="1350" x2="1800" y2="2250" class="minimap-edge"></line><circle cx="2000" cy="227" r="40" class="minimap-node"></circle><circle cx="1686.82958984375" cy="628.8558959960938" r="40" class="minimap-node"></circle><circle cx="2000" cy="950" r="40" class="minimap-node"></circle><circle cx="1200" cy="1350" r="40" class="minimap-node"></circle><circle cx="2800" cy="1350" r="40" class="minimap-node"></circle><circle cx="2000" cy="1350" r="40" class="minimap-node"></circle><circle cx="2000" cy="1650" r="40" class="minimap-node"></circle><circle cx="600" cy="1850" r="40" class="minimap-node"></circle><circle cx="1400" cy="2250" r="40" class="minimap-node"></circle><circle cx="1800" cy="2250" r="40" class="minimap-node"></circle><circle cx="2200" cy="2250" r="40" class="minimap-node"></circle><circle cx="1000" cy="1850" r="40" class="minimap-node"></circle><circle cx="2600" cy="2250" r="40" class="minimap-node"></circle><circle cx="3000" cy="2250" r="40" class="minimap-node"></circle><circle cx="3400" cy="2250" r="40" class="minimap-node"></circle><circle cx="3400" cy="1850" r="40" class="minimap-node"></circle><circle cx="3000" cy="1850" r="40" class="minimap-node"></circle><circle cx="1400" cy="1850" r="40" class="minimap-node"></circle><circle cx="2590.18017578125" cy="882.6126098632812" r="40" class="minimap-node"></circle><rect class="minimap-viewport" id="minimap-viewport" x="384.66666666666674" y="27" width="3230.6666666666665" height="2423"></rect>
            </svg>
          </div>
          <div class="zoom-toolbar" id="zoom-toolbar">
            <button id="zoom-in-btn" title="Zoom in">+</button>
            <div class="zoom-level" id="zoom-level">124%</div>
            <button id="zoom-out-btn" title="Zoom out">-</button>
            <div class="divider"></div>
            <button id="zoom-fit-btn" title="Fit to view">[ ]</button>
            <button id="zoom-reset-btn" title="Reset view">R</button>
          </div>
        </div>
        <button type="button" id="edge-legend-mini" class="legend-mini-btn" style="bottom: 10px; display: none;">Line Legend</button>
        <button type="button" id="minimap-mini" class="legend-mini-btn" style="right: 10px; left: auto; bottom: 10px; display: none;">Map</button>
        <button type="button" id="draw-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: 10px; right: auto; display: none;">Draw</button>
        <button type="button" id="topology-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: auto; right: 40px; display: none;">Add Line</button>
      <button type="button" id="edge-legend-mini" class="legend-mini-btn" style="bottom: 10px; display: none;">Legend</button><button type="button" id="minimap-mini" class="legend-mini-btn" style="right: 10px; left: auto; bottom: 10px; display: none;">Map</button><button type="button" id="draw-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: 10px; right: auto; display: none;">Draw</button><button type="button" id="topology-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: auto; right: 40px; display: none;">Add Line</button><button type="button" id="edge-legend-mini" class="legend-mini-btn" style="bottom: 10px; display: none;">Legend</button><button type="button" id="topology-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: auto; right: 40px; display: none;">Add Line</button><button type="button" id="minimap-mini" class="legend-mini-btn" style="right: 10px; left: auto; bottom: 10px; display: none;">Map</button><button type="button" id="draw-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: 10px; right: auto; display: none;">Draw</button></section>
      <aside class="details-panel" id="details-panel">
        <div class="sidebar-resizer" id="sidebar-resizer">
          <svg class="resizer-icon" width="6" height="40" viewBox="0 0 6 40" xmlns="http://www.w3.org/2000/svg">
            <circle cx="3" cy="14" r="2"></circle>
            <circle cx="3" cy="20" r="2"></circle>
            <circle cx="3" cy="26" r="2"></circle>
          </svg>
        </div>
        <div class="mobile-footer-resizer" id="mobile-footer-resizer">
          <svg class="resizer-icon" width="40" height="6" viewBox="0 0 40 6" xmlns="http://www.w3.org/2000/svg">
            <circle cx="14" cy="3" r="2"></circle>
            <circle cx="20" cy="3" r="2"></circle>
            <circle cx="26" cy="3" r="2"></circle>
          </svg>
        </div>
        <div id="node-panel" style="display: block;">
          <div class="details-name editable-text" id="node-name">OPNSENSE</div>
          <div class="details-ip editable-text" id="node-ip">192.168.100.1</div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">MAC:</span>
            <span class="editable-text" id="node-mac" style="flex: 1; cursor: pointer; color: var(--text-main);">--</span>
          </div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">Rack Unit:</span>
            <span class="editable-text" id="node-rack" style="flex: 1; cursor: pointer; color: var(--text-main);">--</span>
          </div>
          <div class="details-info-row" id="uheight-row" style="display: none;">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">U Height:</span>
            <span class="editable-text" id="node-uheight" style="flex: 1; cursor: pointer; color: var(--text-main);">1U</span>
          </div>
          <div class="details-info-row" id="assigned-rack-row" style="display: flex;">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">Assigned Rack:</span>
            <select id="node-assigned-rack" style="flex: 1; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;"><option value="">None</option><option value="im-a-rack">IM A RACK</option></select>
          </div>
          <div class="details-info-row" id="rack-capacity-row" style="display: none;">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">Rack Capacity:</span>
            <select id="node-rack-capacity" style="flex: 1; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;">
              <option value="42">42U</option>
              <option value="48">48U</option>
              <option value="24">24U</option>
              <option value="12">12U</option>
              <option value="6">6U</option>
            </select>
          </div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">Layer:</span>
            <select id="node-layer" style="flex: 1; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;">
              <option value="physical">Physical</option>
              <option value="logical">Logical</option>
              <option value="security">Security</option>
              <option value="application">Application</option>
            </select>
          </div>
          <div class="details-role" id="node-role">WAN</div>
          <div class="badge-row" id="node-tags"><span class="badge" style="cursor: pointer; position: relative;"><span>1Gbps Fiber</span><span style="opacity: 0.6; margin-left: 4px; font-size: 10px;"> ‚úï</span></span><span class="badge" style="cursor: pointer; position: relative;"><span>Bridge Mode</span><span style="opacity: 0.6; margin-left: 4px; font-size: 10px;"> ‚úï</span></span><span class="badge" style="cursor: pointer; opacity: 0.6; border-style: dashed;">+ Add</span></div>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-tag-input" placeholder="Add tag..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-tag-btn" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button class="pick-icon-btn" id="pick-tag-icon-btn">Add Icon Tag</button>
          <div class="section-label">Size</div>
          <div class="size-controls">
            <label>Size:</label>
            <input type="range" id="size-slider" min="20" max="200" value="55">
            <span id="size-value">127</span>
            <button id="reset-size">Reset</button>
          </div>
          <details class="style-section" open="">
            <summary>Styling</summary>
            <div class="style-content">
              <div class="style-row">
                <label>Screen:</label>
                <select id="style-scope">
                  <option value="all">All</option>
                  <option value="desktop">Desktop</option>
                  <option value="tablet">Tablet</option>
                  <option value="mobile">Mobile</option>
                  <option value="fold">Fold</option>
                </select>
              </div>
              <div class="style-row">
                <label>Shape:</label>
                <select id="shape-select">
                  <optgroup label="Basic Shapes">
                    <option value="circle">Circle</option>
                    <option value="square">Square</option>
                    <option value="rectangle">Rectangle</option>
                    <option value="triangle">Triangle</option>
                    <option value="hexagon">Hexagon</option>
                    <option value="diamond">Diamond</option>
                    <option value="star">Star</option>
                    <option value="stop-sign">Stop Sign</option>
                  </optgroup>
                  <optgroup label="Network Equipment">
                    <option value="server">Server</option>
                    <option value="pc">PC / Desktop</option>
                    <option value="laptop">Laptop</option>
                    <option value="phone">Phone / Mobile</option>
                    <option value="router">Router</option>
                    <option value="switch">Switch</option>
                    <option value="firewall">Firewall</option>
                    <option value="cloud">Cloud</option>
                    <option value="database">Database</option>
                    <option value="printer">Printer</option>
                  </optgroup>
                </select>
              </div>
              <button class="pick-icon-btn" id="pick-shape-icon-btn">Or Search Web Icons</button>
			  <div class="style-row">
                <label>Fill Color:</label>
                <input type="color" id="circle-color" value="#1e293b">
              </div>
              <div class="style-row">
                <label>Border Color:</label>
                <input type="color" id="circle-border" value="#475569">
              </div>
              <div class="style-row">
                <label>Title Color:</label>
                <input type="color" id="title-color" value="#e2e8f0">
              </div>
              <div class="style-row">
                <label>Title Font:</label>
                <select id="title-font">
                  <option value="system-ui, sans-serif"> System UI </option>
                  <option value="monospace">Monospace</option>
                  <option value="serif">Serif</option>
                  <option value="cursive">Cursive</option>
                  <option value="'Courier New', monospace"> Courier </option>
                  <option value="Arial, sans-serif">Arial</option>
                  <option value="'Times New Roman', serif"> Times </option>
                </select>
              </div>
              <div class="style-row">
                <label>Title Size:</label>
                <input type="number" id="title-size" min="8" max="100" value="18">
              </div>
              <div class="style-row">
                <label>Sub Color:</label>
                <input type="color" id="sub-color" value="#94a3b8">
              </div>
              <div class="style-row">
                <label>Sub Font:</label>
                <select id="sub-font">
                  <option value="system-ui, sans-serif">System UI</option>
                  <option value="monospace">Monospace</option>
                  <option value="serif">Serif</option>
                  <option value="cursive">Cursive</option>
                  <option value="'Courier New', monospace">Courier</option>
                  <option value="Arial, sans-serif">Arial</option>
                  <option value="'Times New Roman', serif">Times</option>
                </select>
              </div>
              <div class="style-row">
                <label>Sub Size:</label>
                <input type="number" id="sub-size" min="6" max="80" value="13">
              </div>
              <div style="
                margin-top: 12px;
                padding-top: 10px;
                border-top: 1px solid var(--edge-main);
                ">
                <div style="font-size: 12px;color: var(--text-soft);margin-bottom: 8px;text-transform: uppercase;">Text Position</div>
                <div class="style-row">
                  <label>Name Y:</label>
                  <input type="number" id="title-offset-y" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>Name X:</label>
                  <input type="number" id="title-offset-x" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>IP Y:</label>
                  <input type="number" id="sub-offset-y" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>IP X:</label>
                  <input type="number" id="sub-offset-x" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div style="margin-top: 16px; font-size: 12px; color: var(--text-soft); text-transform: uppercase;">
                  Ping Indicator Position
                </div>
                <div class="style-row">
                  <label>Ping X:</label>
                  <input type="number" id="ping-offset-x" min="-200" max="200" value="0" style="width: 60px;">
                </div>
                <div class="style-row">
                  <label>Ping Y:</label>
                  <input type="number" id="ping-offset-y" min="-200" max="200" value="0" style="width: 60px;">
                </div>
              </div>
              <button id="reset-styles" style="width: 100%;margin-top: 10px;padding: 8px;background: var(--panel);color: var(--text-main);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: clamp(13px, 1.5vw, 17px);">Reset Styles</button>
            </div>
          </details>
          <details class="style-section">
            <summary>Ping / Status Monitoring</summary>
            <div class="style-content">
              <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px; cursor: pointer;">
              <input type="checkbox" id="node-pingable" style="cursor: pointer;">
              <span style="font-size: 14px;">Enable status check for this node</span>
              </label>
              <div id="node-ping-options" style="display: block;">
                <div class="style-row">
                  <label>Protocol:</label>
                  <select id="node-ping-protocol">
                    <option value="http">HTTP (port 80)</option>
                    <option value="https">HTTPS (port 443)</option>
                    <option value="custom">Custom URL</option>
                  </select>
                </div>
                <div id="node-custom-url-container" style="display: block; margin-top: 8px;">
                  <label style="display: block; margin-bottom: 4px; font-size: 13px;">Custom URL:</label>
                  <input type="text" id="node-custom-url" placeholder="e.g. http://192.168.1.1:8080" style="width: 100%;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: 14px;">
                </div>
                <div class="style-row" style="margin-top: 8px;">
                  <label>Timeout (ms):</label>
                  <input type="number" id="node-ping-timeout" value="3000" min="1000" max="10000" step="500" style="width: 100px;">
                </div>
                <div style="margin-top: 12px; padding: 10px; background: var(--panel); border-radius: 6px; border: 1px solid var(--edge-main);">
                  <div style="font-size: 12px; color: var(--text-soft); margin-bottom: 8px;">Current Status:</div>
                  <div id="node-ping-status" style="font-size: 14px; font-weight: 600; color: var(--accent);">‚óè Online</div>
                  <div id="node-ping-last-check" style="font-size: 11px; color: var(--text-soft); margin-top: 4px;">Last checked: 2:25:19 PM</div>
                </div>
                <button id="check-ping-now" style="width: 100%;margin-top: 10px;padding: 8px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Check Status Now</button>
              </div>
            </div>
          </details>
          <div class="section-label">Notes</div>
          <ul class="list" id="node-notes"><li><span style="flex: 1 1 0%;">ISP: AT&amp;T Fiber</span><span class="delete-note">‚úï</span></li><li><span style="flex: 1 1 0%;">set to google for ping sake</span><span class="delete-note">‚úï</span></li></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-note-input" placeholder="Type new note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-note-btn" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-node-btn" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: rgb(255, 255, 255);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;width: 100%;">Delete Node</button>
        </div>
        <div id="edge-panel" style="display: none">
          <div class="details-name" id="edge-title">Custom line</div>
          <div class="style-row" style="margin-top: 10px">
            <label>Width:</label>
            <input type="number" id="edge-width" min="1" max="20" value="4">
          </div>
          <div class="style-row">
            <label>Color:</label>
            <input type="color" id="edge-color" value="#475569">
          </div>
          <div class="style-row">
            <label>Line Style:</label>
            <select id="edge-line-style">
              <option value="solid">Solid</option>
              <option value="dashed">Dashed</option>
              <option value="dotted">Dotted</option>
            </select>
          </div>
          <div class="style-row">
            <label>Direction:</label>
            <select id="edge-direction">
              <option value="none">No arrows</option>
              <option value="forward">‚Üí Forward</option>
              <option value="backward">‚Üê Backward</option>
              <option value="both">‚Üî Bidirectional</option>
            </select>
          </div>
          <div class="style-row" id="edge-port-fields">
            <label>From Port:</label>
            <input type="text" id="edge-from-port" placeholder="e.g. eth0, gi0/1" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);font-size: 14px;">
          </div>
          <div class="style-row" id="edge-port-fields-to">
            <label>To Port:</label>
            <input type="text" id="edge-to-port" placeholder="e.g. eth1, gi0/2" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);font-size: 14px;">
          </div>
          <div class="section-label">Line Notes</div>
          <ul class="list" id="edge-notes"></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-edge-note" placeholder="Add note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-edge-note" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-edge" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Delete Line</button>
        </div>
        <div id="text-panel" style="display: none">
          <div class="details-name" id="text-title">Text Element</div>
          <div class="style-row" style="margin-top: 10px">
            <label>Content:</label>
            <textarea id="text-content" placeholder="Enter text..." style="width: 100%;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: 14px;min-height: 80px;resize: vertical;font-family: inherit;"></textarea>
          </div>
          <div class="style-row">
            <label>Font Size:</label>
            <input type="number" id="text-font-size" min="8" max="200" value="18" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);">
          </div>
          <div class="style-row">
            <label>Color:</label>
            <input type="color" id="text-color" value="#e2e8f0">
          </div>
          <div class="style-row">
            <label>Font Weight:</label>
            <select id="text-font-weight" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="normal">Normal</option>
              <option value="bold">Bold</option>
              <option value="600">Semi-Bold</option>
              <option value="300">Light</option>
            </select>
          </div>
          <div class="style-row">
            <label>Font Style:</label>
            <select id="text-font-style" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="normal">Normal</option>
              <option value="italic">Italic</option>
            </select>
          </div>
          <div class="style-row">
            <label>Text Align:</label>
            <select id="text-align" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="start">Left</option>
              <option value="middle">Center</option>
              <option value="end">Right</option>
            </select>
          </div>
          <div class="style-row">
            <label>Text Decoration:</label>
            <select id="text-decoration" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="none">None</option>
              <option value="underline">Underline</option>
              <option value="line-through">Strike Through</option>
            </select>
          </div>
          <div class="style-row">
            <label>Background:</label>
            <input type="color" id="text-bg-color" value="#000000">
            <label style="margin-left: 10px; display: flex; align-items: center; gap: 6px;">
            <input type="checkbox" id="text-bg-enabled" style="cursor: pointer;">
            <span style="font-size: 13px;">Enable</span>
            </label>
          </div>
          <div class="style-row">
            <label>Opacity:</label>
            <input type="range" id="text-opacity" min="0" max="1" step="0.1" value="1" style="flex: 1">
            <span id="text-opacity-val" style="min-width: 35px; text-align: right">100%</span>
          </div>
          <button id="delete-text" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;width: 100%;">Delete Text</button>
        </div>
        <details class="style-section" open="">
          <summary>Page Layout</summary>
          <div class="style-content">
            <div style="padding: 12px; background: var(--panel-alt); border-radius: 6px; color: var(--text-soft); font-size: 13px; line-height: 1.6;">
              <strong style="color: var(--accent); display: block; margin-bottom: 8px;">Drag to Resize:</strong>
              ‚Ä¢ <strong>Header:</strong> Drag the bottom edge of the header bar<br>
              ‚Ä¢ <strong>Sidebar:</strong> Drag the left edge of the sidebar panel<br>
              ‚Ä¢ <strong>Mobile:</strong> Drag the top edge of the footer panel<br>
              <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--edge-main); font-size: 12px;">
                Hover over panel edges to see resize handles
              </div>
            </div>
          </div>
        </details>
      </aside>
    </main>
    <script id="nodes-json" type="application/json">{}</script>
    <script id="topology-state" type="application/json">ENCRYPTED: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</script>
    <script>
      const IconLibrary = {
       libraries: {
        mdi: {
         name: 'Material Design Icons',
         cdnBase: 'https://cdn.jsdelivr.net/npm/@mdi/svg@latest/svg/',
         metaUrl: 'https://cdn.jsdelivr.net/npm/@mdi/svg@latest/meta.json',
         icons: []
        },
        simple: {
         name: 'Simple Icons',
         cdnBase: 'https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/',
         indexUrl: 'https://cdn.jsdelivr.net/npm/@iconify-json/simple-icons@latest/icons.json',
         icons: []
        },
        selfhst: {
         name: 'selfh.st/icons',
         cdnBase: 'https://cdn.jsdelivr.net/gh/selfhst/icons@master/png/',
         indexUrl: 'https://raw.githubusercontent.com/selfhst/icons/refs/heads/main/index.json',
         icons: []
        }
       },
       currentLibrary: 'selfhst',
       iconCache: {},
       indexCache: {},
       indexLoading: {},
       async loadLibraryIndex(library) {
        if (this.indexCache[library]) {
         return this.indexCache[library];
        }
        if (this.indexLoading[library]) {
         return this.indexLoading[library];
        }
        const lib = this.libraries[library];
        this.indexLoading[library] = (async () => {
         try {
          if (library === 'selfhst') {
           const response = await fetch(lib.indexUrl);
           const data = await response.json();
           const icons = data.map(item => ({
            name: item.Reference,
            displayName: item.Name,
            tags: item.Tags ? item.Tags.split(',').map(t => t.trim()).filter(t => t) : [],
            category: item.Category
           }));
           this.indexCache[library] = icons;
           lib.icons = icons;
           return icons;
          } else if (library === 'simple') {
           const response = await fetch('https://cdn.jsdelivr.net/npm/@iconify-json/simple-icons@latest/icons.json');
           const data = await response.json();
           const icons = Object.keys(data.icons).map(slug => ({
            name: slug,
            displayName: data.icons[slug].title || slug,
            tags: data.aliases && data.aliases[slug] ? [data.aliases[slug].parent] : [],
            hex: data.icons[slug].hex
           }));
           this.indexCache[library] = icons;
           lib.icons = icons;
           return icons;
          } else if (library === 'mdi') {
           const response = await fetch(lib.metaUrl);
           const data = await response.json();
           const icons = data.map(item => ({
            name: item.name,
            displayName: item.name,
            tags: item.tags || [],
            author: item.author
           }));
           this.indexCache[library] = icons;
           lib.icons = icons;
           return icons;
          }
         } catch (error) {
          console.error(`Failed to load index for ${library}:`, error);
          this.indexCache[library] = [];
          lib.icons = [];
          return [];
         } finally {
          delete this.indexLoading[library];
         }
        })();
        return this.indexLoading[library];
       },
       async getIcon(library, name) {
        const cacheKey = `${library}-${name}`;
        if (this.iconCache[cacheKey]) {
         return this.iconCache[cacheKey];
        }
        const cached = localStorage.getItem(`icon-${cacheKey}`);
        if (cached) {
         this.iconCache[cacheKey] = cached;
         return cached;
        }
        const lib = this.libraries[library];
        if (library === 'selfhst') {
         const pngUrl = `${lib.cdnBase}${name}.png`;
         const svgWrapper = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><image href="${pngUrl}" width="24" height="24"/></svg>`;
         this.iconCache[cacheKey] = svgWrapper;
         localStorage.setItem(`icon-${cacheKey}`, svgWrapper);
         return svgWrapper;
        }
        const url = `${lib.cdnBase}${name}.svg`;
        try {
         const response = await fetch(url);
         if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
         }
         const svg = await response.text();
         this.iconCache[cacheKey] = svg;
         localStorage.setItem(`icon-${cacheKey}`, svg);
         return svg;
        } catch (error) {
         console.error(`Failed to fetch icon ${cacheKey}:`, error);
         return null;
        }
       },
       searchIcons(library, query) {
        const lib = this.libraries[library];
        if (!lib.icons.length) return [];
        const q = query.toLowerCase();
        return lib.icons.filter(icon => {
         const nameMatch = icon.name.toLowerCase().includes(q);
         const displayMatch = icon.displayName && icon.displayName.toLowerCase().includes(q);
         const tagMatch = icon.tags && icon.tags.some(t => t.toLowerCase().includes(q));
         const categoryMatch = icon.category && icon.category.toLowerCase().includes(q);
         return nameMatch || displayMatch || tagMatch || categoryMatch;
        }).slice(0, 50);
       }
      };
      let iconPickerCallback = null;
      let selectedNodeIconData = null;
      let selectedRackIconData = null;
      let newNodeIconTags = [];
      
      async function checkNodeStatus(nodeId) {
       const data = NODE_DATA[nodeId];
       if (!data || !data.ping || !data.ping.enabled) return;
       
       data.ping.status = 'checking';
       data.ping.lastCheck = new Date().toISOString();
       updatePingIndicator(nodeId);
       if (currentNodeId === nodeId) {
        updatePingStatusDisplay(nodeId);
       }
       
       let url;
       if (data.ping.protocol === 'custom') {
        url = data.ping.customUrl;
       } else {
        const ip = data.ip || '0.0.0.0';
        const protocol = data.ping.protocol || 'http';
        url = `${protocol}://${ip}`;
       }
       
       if (!url) {
        data.ping.status = 'unknown';
        updatePingIndicator(nodeId);
        if (currentNodeId === nodeId) {
         updatePingStatusDisplay(nodeId);
        }
        return;
       }
       
       try {
        const controller = new AbortController();
        const timeout = data.ping.timeout || 3000;
        const timeoutId = setTimeout(() => controller.abort(), timeout);
        
        const response = await fetch(url, {
         method: 'HEAD',
         mode: 'no-cors', 
         signal: controller.signal
        });
        
        clearTimeout(timeoutId);
        
        data.ping.status = 'online';
       } catch (error) {
        data.ping.status = 'offline';
       }
       
       data.ping.lastCheck = new Date().toISOString();
       updatePingIndicator(nodeId);
       if (currentNodeId === nodeId) {
        updatePingStatusDisplay(nodeId);
       }
      }
      function rgbaToHex(val) {
      if (!val) return "#000000";
      if (val.startsWith("#")) return val;
      
      const m = val.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
      if (!m) return "#000000";
      
      const r = Number(m[1]).toString(16).padStart(2, "0");
      const g = Number(m[2]).toString(16).padStart(2, "0");
      const b = Number(m[3]).toString(16).padStart(2, "0");
      
      return `#${r}${g}${b}`;
      }
      function updatePingIndicator(nodeId) {
      const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
      if (!nodeGroup) return;
      
      const data = NODE_DATA[nodeId];
      if (!data || !data.ping || !data.ping.enabled) {
       const existingIndicator = nodeGroup.querySelector('.ping-indicator');
       if (existingIndicator) existingIndicator.remove();
       return;
      }
      
      let indicator = nodeGroup.querySelector('.ping-indicator');
      const label = nodeGroup.querySelector('.node-label');
      
      if (!indicator && label) {
       indicator = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
       indicator.classList.add('ping-indicator');
       nodeGroup.appendChild(indicator);
      }
      
      if (indicator && label) {
       const size = savedSizes[nodeId] || getDefaultSize();
       const radius = Math.max(4, size * 0.06);
      
       indicator.setAttribute('r', radius);
      
       const labelBBox = label.getBBox();
       const labelX = parseFloat(label.getAttribute('x') || 0);
       const labelY = parseFloat(label.getAttribute('y') || 0);
      
       const styles = resolveStylesForNode(nodeId);
      const offX = styles.pingOffsetX || 0;
      const offY = styles.pingOffsetY || 0;
      
      indicator.setAttribute('cx', (labelX - labelBBox.width / 2 - radius * 1.1) + offX);
      indicator.setAttribute('cy', (labelY - radius * 0.7) + offY);
      }
      
      if (indicator) {
       indicator.classList.remove('online', 'offline', 'checking');
       if (data.ping.status) indicator.classList.add(data.ping.status);
      }
      }
      
      
      function checkAllNodesStatus() {
       Object.keys(NODE_DATA).forEach(nodeId => {
        const data = NODE_DATA[nodeId];
        if (data && data.ping && data.ping.enabled) {
         checkNodeStatus(nodeId);
        }
       });
      }
      
      function startAutoPing() {
       stopAutoPing();
       
       checkAllNodesStatus();
       updateAutoPingLastRun();
       
       autoPingSecondsRemaining = autoPingInterval;
       
      
       autoPingTimer = setInterval(() => {
        checkAllNodesStatus();
        updateAutoPingLastRun();
        autoPingSecondsRemaining = autoPingInterval;
       }, autoPingInterval * 1000);
       
       autoPingCountdown = setInterval(() => {
        autoPingSecondsRemaining--;
        updateAutoPingCountdown();
        if (autoPingSecondsRemaining <= 0) {
         autoPingSecondsRemaining = autoPingInterval;
        }
       }, 1000);
       
       updateAutoPingCountdown();
      }
      
      function stopAutoPing() {
       if (autoPingTimer) {
        clearInterval(autoPingTimer);
        autoPingTimer = null;
       }
       if (autoPingCountdown) {
        clearInterval(autoPingCountdown);
        autoPingCountdown = null;
       }
       autoPingSecondsRemaining = 0;
       updateAutoPingCountdown();
      }
      
      function updateAutoPingCountdown() {
       const nextCheckEl = document.getElementById('auto-ping-next-check');
       if (nextCheckEl) {
        if (autoPingSecondsRemaining > 0 && autoPingEnabled) {
         const mins = Math.floor(autoPingSecondsRemaining / 60);
         const secs = autoPingSecondsRemaining % 60;
         if (mins > 0) {
          nextCheckEl.textContent = `Next check in: ${mins}m ${secs}s`;
         } else {
          nextCheckEl.textContent = `Next check in: ${secs}s`;
         }
        } else {
         nextCheckEl.textContent = 'Next check in: --';
        }
       }
      }
      
      function updateAutoPingLastRun() {
       const lastRunEl = document.getElementById('auto-ping-last-run');
       if (lastRunEl) {
        const now = new Date();
        lastRunEl.textContent = `Last run: ${now.toLocaleTimeString()}`;
       }
      }
      
      function openIconPicker(callback) {
       iconPickerCallback = callback;
       const modal = document.getElementById('icon-picker-modal');
       modal.classList.add('active');
       const searchInput = document.getElementById('icon-search');
       searchInput.style.display = 'none';
       loadIconsForCurrentLibrary();
      }
      
      function closeIconPicker() {
       const modal = document.getElementById('icon-picker-modal');
       modal.classList.remove('active');
       iconPickerCallback = null;
      }
      async function loadIconsForCurrentLibrary() {
       const body = document.getElementById('icon-picker-body');
       const libNames = {
        mdi: 'MDI (Material Design Icons)',
        simple: 'Simple Icons',
        selfhst: 'selfh.st/icons'
       };
       body.innerHTML = `<div style="padding: 20px;"><p style="color: var(--text-soft); margin-bottom: 15px; text-align: center;">Search ${libNames[IconLibrary.currentLibrary]}:</p><input type="text" id="icon-search-field" placeholder="Search icons..." style="width: 100%; padding: 12px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main); font-size: 16px; margin-bottom: 20px;"><div id="icon-grid-container" style="max-height: 400px; overflow-y: auto;"><div style="text-align: center; color: var(--text-soft); padding: 40px;">Loading icons...</div></div></div>`;
       const searchField = document.getElementById('icon-search-field');
       const gridContainer = document.getElementById('icon-grid-container');
       await IconLibrary.loadLibraryIndex(IconLibrary.currentLibrary);
       const renderIcons = (icons) => {
        if (!icons || icons.length === 0) {
         gridContainer.innerHTML = '<div style="text-align: center; color: var(--text-soft); padding: 40px;">No icons found</div>';
         return;
        }
        const grid = document.createElement('div');
        grid.style.cssText = 'display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 15px; padding: 10px;';
        icons.forEach(icon => {
         const item = document.createElement('div');
         item.style.cssText = 'display: flex; flex-direction: column; align-items: center; gap: 8px; padding: 15px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; cursor: pointer; transition: all 0.2s;';
         item.onmouseover = () => {
          item.style.background = 'var(--panel)';
          item.style.borderColor = 'var(--accent)';
         };
         item.onmouseout = () => {
          item.style.background = 'var(--panel-alt)';
          item.style.borderColor = 'var(--edge-main)';
         };
         const iconPreview = document.createElement('div');
         iconPreview.style.cssText = 'width: 48px; height: 48px; display: flex; align-items: center; justify-content: center;';
         iconPreview.innerHTML = '<div style="color: var(--text-soft); font-size: 12px;">...</div>';
         IconLibrary.getIcon(IconLibrary.currentLibrary, icon.name).then(svg => {
          if (svg) {
           const parser = new DOMParser();
           const doc = parser.parseFromString(svg, 'image/svg+xml');
           const svgEl = doc.querySelector('svg');
           if (svgEl) {
            svgEl.setAttribute('width', '48');
            svgEl.setAttribute('height', '48');
            svgEl.style.fill = 'var(--text-main)';
            iconPreview.innerHTML = '';
            iconPreview.appendChild(svgEl);
           }
          }
         });
         const name = document.createElement('div');
         name.textContent = icon.displayName || icon.name;
         name.style.cssText = 'font-size: 11px; color: var(--text-soft); text-align: center; word-break: break-word; max-width: 100%;';
         item.appendChild(iconPreview);
         item.appendChild(name);
         item.addEventListener('click', async () => {
          const svg = await IconLibrary.getIcon(IconLibrary.currentLibrary, icon.name);
          if (iconPickerCallback && svg) {
           iconPickerCallback({
            library: IconLibrary.currentLibrary,
            name: icon.name,
            svg: svg
           });
          }
          closeIconPicker();
         });
         grid.appendChild(item);
        });
        gridContainer.innerHTML = '';
        gridContainer.appendChild(grid);
       };
       gridContainer.innerHTML = '<div style="text-align: center; color: var(--text-soft); padding: 40px;">Type to search icons</div>';
       let searchTimeout;
       searchField.addEventListener('input', (e) => {
        clearTimeout(searchTimeout);
        const query = e.target.value.trim();
        searchTimeout = setTimeout(() => {
         if (!query) {
          gridContainer.innerHTML = '<div style="text-align: center; color: var(--text-soft); padding: 40px;">Type to search icons</div>';
          return;
         }
         const results = IconLibrary.searchIcons(IconLibrary.currentLibrary, query);
         renderIcons(results);
        }, 300);
       });
       searchField.focus();
      }
      async function displayIcons(icons) {
       const body = document.getElementById('icon-picker-body');
       const grid = document.createElement('div');
       grid.className = 'icon-grid';
       for (const icon of icons) {
        const item = document.createElement('div');
        item.className = 'icon-item';
        const svg = await IconLibrary.getIcon(icon.library, icon.name);
        if (svg) {
         const parser = new DOMParser();
         const doc = parser.parseFromString(svg, 'image/svg+xml');
         const svgEl = doc.querySelector('svg');
         if (svgEl) {
          item.innerHTML = svgEl.outerHTML;
         }
        } else {
         item.innerHTML = '<svg width = "32" height = "32"><rect width = "32" height = "32" fill = "currentColor"/> </svg>';
        }
        const name = document.createElement('div');
        name.className = 'icon-item-name';
        name.textContent = icon.name;
        item.appendChild(name);
        item.addEventListener('click', () => {
         if (iconPickerCallback) {
          iconPickerCallback({
           library: icon.library,
           name: icon.name,
           svg: svg
          });
         }
         closeIconPicker();
        });
        grid.appendChild(item);
       }
       body.innerHTML = '';
       body.appendChild(grid);
      }
      window.addEventListener('DOMContentLoaded', () => {
       document.querySelectorAll('.icon-picker-tab').forEach(tab => {
        tab.addEventListener('click', () => {
         document.querySelectorAll('.icon-picker-tab').forEach(t => t.classList.remove('active'));
         tab.classList.add('active');
         IconLibrary.currentLibrary = tab.dataset.library;
         loadIconsForCurrentLibrary();
        });
       });
       document.getElementById('icon-picker-cancel').addEventListener('click', closeIconPicker);
       document.getElementById('icon-picker-modal').addEventListener('click', (e) => {
        if (e.target.id === 'icon-picker-modal') {
         closeIconPicker();
        }
       });
      });
      let textDrawMode = false;
      const BASE_NODE_DATA = JSON.parse(document.getElementById("nodes-json").textContent, );
      let currentNodeId = "host";
      let currentEdgeId = null;
      let currentStyleScope = "all";
      let NODE_DATA = {};
      let EDGE_DATA = {
       list: []
      };
      let RECT_DATA = {
       list: []
      };
      let TEXT_DATA = {
       list: []
      };
      let EDGE_LEGEND = {};
      let savedPositions = {};
      let savedSizes = {};
      let savedStyles = {};
      let legendCollapsed = false;
      let minimapCollapsed = false;
      let drawToolbarCollapsed = false;
      let currentView = {
       mode: "topology",
       rackId: null
      };
      let savedTopologyView = null;
      let activeLayers = new Set(["physical", "logical", "security", "application"]);
      let topologyToolbarCollapsed = false;
      let legendMiniBtn = null;
      let minimapMiniBtn = null;
      let drawToolbarMiniBtn = null;
      let topologyToolbarMiniBtn = null;
      
      let autoPingEnabled = false;
      let autoPingInterval = 30;
      let autoPingTimer = null;
      let autoPingCountdown = null;
      let autoPingSecondsRemaining = 0;
      
      const ROLLBACK_STORAGE_KEY = "theonefile_rollback_history";
      let rollbackVersions = [];
      const MAX_ROLLBACK_VERSIONS = 50;
      let currentRollbackIndex = -1;
      
      const AUDIT_STORAGE_KEY = "theonefile_audit_log";
      let auditLog = [];
      const MAX_AUDIT_ENTRIES = 1000;
      
      let documentTabs = [{
        id: "main",
        name: "Main Topology",
        nodes: {},
        edges: { list: [] },
        positions: {},
        sizes: {},
        styles: {},
        legend: {},
        rects: { list: [] },
        texts: { list: [] },
		pageState: null
      }];
      let currentTabIndex = 0;
      
      let encryptedSections = {};
      
      let undoStack = [];
      let redoStack = [];
      const MAX_UNDO_STACK = 50;
      let selectedNodes = new Set();
      let isSelecting = false;
      let selectionStart = null;
      let selectionRect = null;
      let isDraggingSelection = false;
      let dragSelectionStart = null;
      let clipboard = null;
      
      const MobileManager = {
        isMobile: false,
        detect() {
      
          if (navigator.userAgentData?.mobile === true) {
            this.isMobile = true;
            return true;
          }
          const coarse = matchMedia("(pointer: coarse)").matches;
          const width = window.innerWidth <= 900;
          const portrait = matchMedia("(orientation: portrait)").matches;
          this.isMobile = coarse && (width || portrait);
          return this.isMobile;
        },
        applyInitialCollapse() {
          if (!this.isMobile) return;
          legendCollapsed = true;
          minimapCollapsed = true;
          drawToolbarCollapsed = true;
          topologyToolbarCollapsed = true;
          if (typeof updateLegendVisibility === "function") updateLegendVisibility();
          if (typeof updateMinimapVisibility === "function") updateMinimapVisibility();
          if (typeof updateDrawToolbarVisibility === "function") updateDrawToolbarVisibility();
          if (typeof updateTopologyToolbarVisibility === "function") updateTopologyToolbarVisibility();
        },
        updateBulkToolbar() {
          const desktop = document.getElementById("bulk-toolbar");
          const mobile = document.getElementById("bulk-toolbar-mobile");
          if (!desktop || !mobile) return;
          
          const isVisible = desktop.style.display !== "none" || mobile.style.display !== "none";
          
          if (this.isMobile) {
            desktop.style.display = "none";
            if (isVisible) {
              mobile.style.display = "flex";
            }
          } else {
            mobile.style.display = "none";
            if (isVisible) {
              desktop.style.display = "flex";
            }
          }
        },
        updateLayout() {
          const main = document.querySelector("main");
          if (!main) return;
        },
        updateCanvasHint() {
      const hint = document.getElementById("canvas-hint");
      if (!hint) return;
      
      const items = this.isMobile
      ? [
        "Pinch to zoom",
        "Drag to pan",
        "Double tap to select multiple",
        "Double tap to select multiple",
        "Your time is NOW!",
      ]
      : [
        "Scroll to zoom",
        "Drag to pan",
        "Right-click to select multiple",
        "Your time is NOW!",
      ];
      
      const list = document.createElement("ul");
      for (const item of items) {
      const li = document.createElement("li");
      li.textContent = item;
      list.appendChild(li);
      }
      
      hint.replaceChildren(list);
      },
        autoSelectStyleScope() {
          const scope = document.getElementById("style-scope");
          if (!scope) return;
          if (this.isMobile) scope.value = "mobile";
        },
        updateToolbarStack() {
          if (!this.isMobile) return;
          const draw = document.getElementById("draw-toolbar");
          const topo = document.getElementById("topology-toolbar");
          if (!draw || !topo) return;
          const h = draw.getBoundingClientRect().height;
          document.documentElement.style.setProperty("--draw-toolbar-height", h + "px");
        },
        updateLayoutControls() {
          const sidebarRow = document.getElementById("sidebar-width-row");
          const footerRow = document.getElementById("mobile-footer-row");
          if (sidebarRow && footerRow) {
            if (this.isMobile) {
              sidebarRow.style.display = "none";
              footerRow.style.display = "flex";
            } else {
              sidebarRow.style.display = "flex";
              footerRow.style.display = "none";
            }
          }
        },
        applyAll() {
          this.detect();
          this.applyInitialCollapse();
          this.updateBulkToolbar();
          this.updateLayout();
          this.updateCanvasHint();
          this.autoSelectStyleScope();
          this.updateToolbarStack();
          this.updateLayoutControls();
        }
      };
      function isMobileDevice() {
        return MobileManager.isMobile;
      }
      
      function ensureLegendMiniButton() {
       if (legendMiniBtn) return legendMiniBtn;
      
       const panel = document.querySelector(".topology-panel");
       if (!panel) return null;
       const btn = document.createElement("button");
       btn.type = "button";
       btn.id = "edge-legend-mini";
       btn.className = "legend-mini-btn";
       btn.textContent = "Legend";
       btn.style.bottom = "10px";
       const handleClick = (e) => {
        e.stopPropagation();
        e.preventDefault();
        legendCollapsed = false;
        updateLegendVisibility();
       };
       btn.addEventListener("click", handleClick);
       btn.addEventListener("touchend", handleClick);
       panel.appendChild(btn);
       legendMiniBtn = btn;
       return btn;
      }
      
      function ensureMinimapMiniButton() {
       if (minimapMiniBtn) return minimapMiniBtn;
       const panel = document.querySelector(".topology-panel");
       if (!panel) return null;
       const btn = document.createElement("button");
       btn.type = "button";
       btn.id = "minimap-mini";
       btn.className = "legend-mini-btn";
       btn.textContent = "Map";
       btn.style.right = "10px";
       btn.style.left = "auto";
       btn.style.bottom = "10px";
       const handleClick = (e) => {
        e.stopPropagation();
        e.preventDefault();
        minimapCollapsed = false;
        updateMinimapVisibility();
       };
       btn.addEventListener("click", handleClick);
       btn.addEventListener("touchend", handleClick);
       panel.appendChild(btn);
       minimapMiniBtn = btn;
       return btn;
      }
      
      function ensureDrawToolbarMiniButton() {
       if (drawToolbarMiniBtn) return drawToolbarMiniBtn;
       const panel = document.querySelector(".topology-panel");
       if (!panel) return null;
       const btn = document.createElement("button");
       btn.type = "button";
       btn.id = "draw-toolbar-mini";
       btn.className = "legend-mini-btn";
       btn.textContent = "Draw";
       btn.style.top = "10px";
       btn.style.left = "10px";
       btn.style.right = "auto";
       const handleClick = (e) => {
        e.stopPropagation();
        e.preventDefault();
        drawToolbarCollapsed = false;
        updateDrawToolbarVisibility();
       };
       btn.addEventListener("click", handleClick);
       btn.addEventListener("touchend", handleClick);
       panel.appendChild(btn);
       drawToolbarMiniBtn = btn;
       return btn;
      }
      
      function ensureTopologyToolbarMiniButton() {
       if (topologyToolbarMiniBtn) return topologyToolbarMiniBtn;
       const panel = document.querySelector(".topology-panel");
       if (!panel) return null;
       const btn = document.createElement("button");
       btn.type = "button";
       btn.id = "topology-toolbar-mini";
       btn.className = "legend-mini-btn";
       btn.textContent = "Add Line";
       btn.style.top = "10px";
       btn.style.left = "auto";
       btn.style.right = "40px";
       const handleClick = (e) => {
        e.stopPropagation();
        e.preventDefault();
        topologyToolbarCollapsed = false;
        updateTopologyToolbarVisibility();
       };
       btn.addEventListener("click", handleClick);
       btn.addEventListener("touchend", handleClick);
       panel.appendChild(btn);
       topologyToolbarMiniBtn = btn;
       return btn;
      }
      
      function updateToolbarStack() {
       if (!isMobileDevice()) return;
       const draw = document.getElementById("draw-toolbar");
       const topo = document.getElementById("topology-toolbar");
       if (!draw || !topo) return;
       const h = draw.getBoundingClientRect().height;
       document.documentElement.style.setProperty("--draw-toolbar-height", h + "px");
      }
      window.addEventListener("resize", updateToolbarStack);
      window.addEventListener("DOMContentLoaded", updateToolbarStack);
      updateToolbarStack();
      
      function updateLegendVisibility() {
       const legend = document.getElementById("edge-legend");
       const mini = ensureLegendMiniButton();
       if (!legend || !mini) return;
       const hasItems = legend.querySelectorAll(".legend-item").length > 0;
       if (!hasItems) {
        legend.style.display = "none";
        mini.style.display = "none";
        return;
       }
       if (legendCollapsed) {
        legend.style.display = "none";
        mini.style.display = "inline-flex";
       } else {
        legend.style.display = "flex";
        mini.style.display = "none";
       }
      }
      
      function updateMinimapVisibility() {
       const wrapper = document.getElementById("minimap-zoom-wrapper");
       const mini = ensureMinimapMiniButton();
       if (!wrapper || !mini) return;
       if (minimapCollapsed) {
        wrapper.style.display = "none";
        mini.style.display = "inline-flex";
       } else {
        wrapper.style.display = "block";
        mini.style.display = "none";
       }
      }
      
      function updateDrawToolbarVisibility() {
       const toolbar = document.getElementById("draw-toolbar");
       const mini = ensureDrawToolbarMiniButton();
       if (!toolbar || !mini) return;
       if (drawToolbarCollapsed) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "inline-flex";
       } else {
      if (isMobileDevice()) {    	   
        toolbar.style.setProperty('display', 'grid', 'important');
        mini.style.display = "none";
        } else {   
        toolbar.style.setProperty('display', 'flex', 'important');
        mini.style.display = "none";	  
      }
       }
      }
      
      function u8ToBase64(u8) {
      let binary = "";
      for (let i = 0; i < u8.length; i++) binary += String.fromCharCode(u8[i]);
      return btoa(binary);
      }
      
      function base64ToU8(base64) {
      const binary = atob(base64);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
      return bytes;
      }  
      
      function updateTopologyToolbarVisibility() {
       const toolbar = document.getElementById("topology-toolbar");
       const mini = ensureTopologyToolbarMiniButton();
       if (!toolbar || !mini) return;
       const hasSelectedNode = currentNodeId !== null;
       if (!hasSelectedNode) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "none";
       } else if (topologyToolbarCollapsed) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "inline-flex";
       } else {   
      if (isMobileDevice()) {    	   
        toolbar.style.setProperty('display', 'grid', 'important');
        mini.style.display = "none";
        } else {   
        toolbar.style.setProperty('display', 'flex', 'important');
        mini.style.display = "none";	  
      }
       }
      }
      
      const DEFAULT_PAGE_STATE = {
       title: "The One File: The Networkening",
       background: "",
       topbarBg: "rgba(9, 12, 20, 0.9)",
       topbarBorder: "#1f2533",
       panel: "#0b0e13",
       panelAlt: "#10141b",
       accent: "#4fd1c5",
       danger: "#f56565",
       textMain: "#e2e8f0",
       textSoft: "#94a3b8",
       topbarHeight: 52,
       sidebarWidth: 350,
       mobileFooterHeight: 40,
       sidebarCollapsed: false,
       autoPingEnabled: false,
       autoPingInterval: 30,
      };
      let PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE);
      const CANVAS_WIDTH = 4000;
      let CANVAS_HEIGHT = 3000;
      const BASE_CANVAS_HEIGHT = 3000;
      const CANVAS_PADDING = 100;
      
      const RACK_U_HEIGHT = 70;
      const RACK_WIDTH = 600;
      const RACK_START_X = CANVAS_WIDTH / 2;
      const RACK_START_Y = CANVAS_PADDING + 100;
      function getRackUHeight(rackId) {
      const capacity = getRackCapacity(rackId);
      const availableHeight = CANVAS_HEIGHT - RACK_START_Y - 200;
      return Math.floor(availableHeight / capacity);
      }
      let canvasState = {
       zoom: 1,
       panX: 0,
       panY: 0,
       minZoom: 0.25,
       maxZoom: 4,
       isPanning: false,
       panStartX: 0,
       panStartY: 0,
       spacePressed: false,
      };
      
      function getViewBox() {
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       return {
        x: canvasState.panX,
        y: canvasState.panY,
        width: viewWidth,
        height: viewHeight,
       };
      }
      
      function updateViewBox() {
       const svg = document.getElementById("map");
       const vb = getViewBox();
       svg.setAttribute("viewBox", `${vb.x} ${vb.y} ${vb.width} ${vb.height}`, );
       const zoomLevel = document.getElementById("zoom-level");
       if (zoomLevel) {
        zoomLevel.textContent = Math.round(canvasState.zoom * 100) + "%";
       }
       updateMinimap();
      }
      
      function updateMinimap() {
       const minimapViewport = document.getElementById("minimap-viewport");
       const minimapSvg = document.getElementById("minimap");
       if (!minimapViewport || !minimapSvg) return;
       const vb = getViewBox();
       minimapViewport.setAttribute("x", vb.x);
       minimapViewport.setAttribute("y", vb.y);
       minimapViewport.setAttribute("width", vb.width);
       minimapViewport.setAttribute("height", vb.height);
       const minimapNodes = minimapSvg.querySelectorAll(".minimap-node");
       minimapNodes.forEach((n) => n.remove());
       const minimapEdges = minimapSvg.querySelectorAll(".minimap-edge");
       minimapEdges.forEach((e) => e.remove());
       
       EDGE_DATA.list.forEach((edge) => {
        if (edge.type === "custom") return;
        
        const fromNode = NODE_DATA[edge.from];
        const toNode = NODE_DATA[edge.to];
        if (!fromNode || !toNode) return;
        
        if (currentView.mode === "rack") {
         if (fromNode.assignedRack !== currentView.rackId || 
             toNode.assignedRack !== currentView.rackId) {
          return;
         }
        } else {
         if (fromNode.assignedRack || toNode.assignedRack) {
          return;
         }
        }
        
        const p1 = savedPositions[edge.from];
        const p2 = savedPositions[edge.to];
        if (!p1 || !p2) return;
        const line = document.createElementNS("http://www.w3.org/2000/svg", "line", );
        line.setAttribute("x1", p1.x);
        line.setAttribute("y1", p1.y);
        line.setAttribute("x2", p2.x);
        line.setAttribute("y2", p2.y);
        line.classList.add("minimap-edge");
        minimapSvg.insertBefore(line, minimapViewport);
       });
      
       Object.entries(savedPositions).forEach(([id, pos]) => {
        const node = NODE_DATA[id];
        if (!node) return;
        
        if (currentView.mode === "rack") {
         if (node.assignedRack !== currentView.rackId) {
          return;
         }
        } else {
         if (node.assignedRack) {
          return;
         }
        }
        
        const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle", );
        circle.setAttribute("cx", pos.x);
        circle.setAttribute("cy", pos.y);
        circle.setAttribute("r", 40);
        circle.classList.add("minimap-node");
        minimapSvg.insertBefore(circle, minimapViewport);
       });
      }
      
      function zoomTo(newZoom, centerX, centerY) {
       const oldZoom = canvasState.zoom;
       newZoom = Math.max(canvasState.minZoom, Math.min(canvasState.maxZoom, newZoom), );
       if (centerX !== undefined && centerY !== undefined) {
        const oldWidth = CANVAS_WIDTH / oldZoom;
        const oldHeight = CANVAS_HEIGHT / oldZoom;
        const newWidth = CANVAS_WIDTH / newZoom;
        const newHeight = CANVAS_HEIGHT / newZoom;
        const pointX = canvasState.panX + centerX * oldWidth;
        const pointY = canvasState.panY + centerY * oldHeight;
        canvasState.panX = pointX - centerX * newWidth;
        canvasState.panY = pointY - centerY * newHeight;
       }
       canvasState.zoom = newZoom;
       constrainPan();
       updateViewBox();
      }
      
      function constrainPan() {
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       const minVisiblePortion = 0.1;
       const maxPanX = CANVAS_WIDTH - viewWidth * minVisiblePortion;
       const maxPanY = CANVAS_HEIGHT - viewHeight * minVisiblePortion;
       const minPanX = -viewWidth * (1 - minVisiblePortion);
       const minPanY = -viewHeight * (1 - minVisiblePortion);
       canvasState.panX = Math.max(minPanX, Math.min(maxPanX, canvasState.panX), );
       canvasState.panY = Math.max(minPanY, Math.min(maxPanY, canvasState.panY), );
      }
      
      function fitToContent() {
       const positions = Object.values(savedPositions);
       if (positions.length === 0) {
        resetView();
        return;
       }
       let minX = Infinity,
        minY = Infinity,
        maxX = -Infinity,
        maxY = -Infinity;
       positions.forEach((pos) => {
        minX = Math.min(minX, pos.x - 100);
        minY = Math.min(minY, pos.y - 100);
        maxX = Math.max(maxX, pos.x + 100);
        maxY = Math.max(maxY, pos.y + 100);
       });
       const contentWidth = maxX - minX + 200;
       const contentHeight = maxY - minY + 200;
       const viewport = document.getElementById("canvas-viewport");
       const vpRect = viewport.getBoundingClientRect();
       const aspectRatio = vpRect.width / vpRect.height;
       const contentAspect = contentWidth / contentHeight;
       let newZoom;
       if (contentAspect > aspectRatio) {
        newZoom = (vpRect.width / contentWidth) * (CANVAS_WIDTH / vpRect.width);
       } else {
        newZoom = (vpRect.height / contentHeight) * (CANVAS_HEIGHT / vpRect.height);
       }
       newZoom = Math.max(canvasState.minZoom, Math.min(2, newZoom));
       const viewWidth = CANVAS_WIDTH / newZoom;
       const viewHeight = CANVAS_HEIGHT / newZoom;
       canvasState.zoom = newZoom;
       canvasState.panX = minX - 100 - (viewWidth - contentWidth) / 2;
       canvasState.panY = minY - 100 - (viewHeight - contentHeight) / 2;
       constrainPan();
       updateViewBox();
      }
      
      function resetView() {
       canvasState.zoom = 1;
       canvasState.panX = 0;
       canvasState.panY = 0;
       updateViewBox();
      }
      window.addEventListener("DOMContentLoaded", () => {
       const toggle = document.getElementById("mobile-menu-toggle");
       const menu = document.getElementById("topbar-menu");
       if (!toggle || !menu) return;
       toggle.addEventListener("click", () => {
        menu.classList.toggle("open");
       });
       menu.addEventListener("click", (e) => {
        const target = e.target.closest("a, button");
        if (!target) return;
        if (isMobileDevice()) {
       menu.classList.remove("open");
      }
       });
       const minimapCloseBtn = document.getElementById("minimap-close-btn");
       if (minimapCloseBtn) {
        const handleMinimapClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         minimapCollapsed = true;
         updateMinimapVisibility();
        };
        minimapCloseBtn.addEventListener("click", handleMinimapClose);
        minimapCloseBtn.addEventListener("touchend", handleMinimapClose);
       }
       const drawToolbarCloseBtn = document.getElementById("draw-toolbar-close-btn");
       if (drawToolbarCloseBtn) {
        const handleDrawClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         drawToolbarCollapsed = true;
         updateDrawToolbarVisibility();
        };
        drawToolbarCloseBtn.addEventListener("click", handleDrawClose);
        drawToolbarCloseBtn.addEventListener("touchend", handleDrawClose);
       }
       const topologyToolbarCloseBtn = document.getElementById("topology-toolbar-close-btn");
       if (topologyToolbarCloseBtn) {
        const handleTopologyClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         topologyToolbarCollapsed = true;
         updateTopologyToolbarVisibility();
        };
        topologyToolbarCloseBtn.addEventListener("click", handleTopologyClose);
        topologyToolbarCloseBtn.addEventListener("touchstart", (e) => e.preventDefault(), {
         passive: false
        });
        topologyToolbarCloseBtn.addEventListener("touchend", handleTopologyClose);
       }
      
       updateMinimapVisibility();
       updateDrawToolbarVisibility();
       updateTopologyToolbarVisibility();
      });
      
      function applyLayerFilter() {  
       activeLayers.clear(); 
       if (document.getElementById("layer-physical").checked) activeLayers.add("physical");    
       if (document.getElementById("layer-logical").checked) activeLayers.add("logical");    
       if (document.getElementById("layer-security").checked) activeLayers.add("security");     
       if (document.getElementById("layer-application").checked) activeLayers.add("application");
       forgeTheTopology();    
      }
      
      function isNodeVisible(nodeId) {  
       const node = NODE_DATA[nodeId];    
       if (!node) return false;     
       const nodeLayer = node.layer || "physical";     
       return activeLayers.has(nodeLayer);     
      }
      
      function enterRack(rackId) {
      if (!NODE_DATA[rackId] || !NODE_DATA[rackId].isRack) return;
      const rackCapacity = getRackCapacity(rackId);
      const neededHeight = RACK_START_Y + (rackCapacity * RACK_U_HEIGHT) + 200;
      if (neededHeight > BASE_CANVAS_HEIGHT) {
      CANVAS_HEIGHT = neededHeight;
      }
       
       currentView.mode = "rack";
       currentView.rackId = rackId;
       
       const backBtn = document.getElementById("back-to-topology-btn");
       if (backBtn) backBtn.style.display = "inline-block";
       
       const hint = document.getElementById("canvas-hint");
       if (hint) {
        hint.textContent = `Viewing: ${NODE_DATA[rackId].name} | Double-click empty space to exit`;
        hint.classList.add("visible");
       }
       
      
      const rackUHeight = getRackUHeight(rackId);
      const rackHeight = rackCapacity * rackUHeight;
      const rackCenterX = RACK_START_X;
      const rackCenterY = RACK_START_Y + (rackHeight / 2);
       
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       
       canvasState.panX = rackCenterX - (viewWidth / 2);
       canvasState.panY = rackCenterY - (viewHeight / 2);
       
       constrainPan();
       updateViewBox();
       
       forgeTheTopology();
      }
      
      function exitRack() {
      CANVAS_HEIGHT = BASE_CANVAS_HEIGHT;
      currentView.mode = "topology";
      currentView.rackId = null;
       
       const backBtn = document.getElementById("back-to-topology-btn");
       if (backBtn) backBtn.style.display = "none";
       
       const hint = document.getElementById("canvas-hint");
       if (hint) {
        hint.classList.remove("visible");
       }
       
       if (savedTopologyView) {
        canvasState.zoom = savedTopologyView.zoom;
        canvasState.panX = savedTopologyView.panX;
        canvasState.panY = savedTopologyView.panY;
        updateViewBox();
       }
       
       forgeTheTopology();
      }
      
      function getRackCapacity(rackId) {
       const node = NODE_DATA[rackId];
       return node && node.rackCapacity ? parseInt(node.rackCapacity) : 42;
      }
      
      function populateRackDropdown() {
       const dropdown = document.getElementById("node-assigned-rack");
       if (!dropdown) return;
       
       dropdown.innerHTML = '<option value="">None</option>';
       
       Object.keys(NODE_DATA).forEach(id => {
        if (NODE_DATA[id].isRack) {
         const option = document.createElement("option");
         option.value = id;
         option.textContent = NODE_DATA[id].name;
         dropdown.appendChild(option);
        }
       });
      }
      
      function wieldThePower() {
       const root = document.documentElement;
       root.style.setProperty("--panel", PAGE_STATE.panel);
       root.style.setProperty("--panel-alt", PAGE_STATE.panelAlt);
       root.style.setProperty("--accent", PAGE_STATE.accent);
       root.style.setProperty("--danger", PAGE_STATE.danger);
       root.style.setProperty("--text-main", PAGE_STATE.textMain);
       root.style.setProperty("--text-soft", PAGE_STATE.textSoft);
       root.style.setProperty("--topbar-bg", PAGE_STATE.topbarBg);
       root.style.setProperty("--topbar-border", PAGE_STATE.topbarBorder);
       const topbarHeight = PAGE_STATE.topbarHeight || 52;
       const sidebarWidth = PAGE_STATE.sidebarWidth || 350;
       const mobileFooterHeight = PAGE_STATE.mobileFooterHeight || 40;
       root.style.setProperty("--topbar-height", topbarHeight + "px");
       root.style.setProperty("--sidebar-width", sidebarWidth + "px");
       root.style.setProperty("--mobile-footer-height", mobileFooterHeight + "vh", );
       const mainEl = document.querySelector("main");
       const detailsPanel = document.getElementById("details-panel");
       const sidebarToggle = document.getElementById("sidebar-toggle");
       if (PAGE_STATE.sidebarCollapsed) {
        if (mainEl) mainEl.classList.add("sidebar-collapsed");
        if (detailsPanel) detailsPanel.classList.add("collapsed");
        if (sidebarToggle) {
         sidebarToggle.classList.add("collapsed");
         sidebarToggle.textContent = "‚ñ∂";
        }
       } else {
        if (mainEl) mainEl.classList.remove("sidebar-collapsed");
        if (detailsPanel) detailsPanel.classList.remove("collapsed");
        if (sidebarToggle) {
         sidebarToggle.classList.remove("collapsed");
         sidebarToggle.textContent = "‚óÄ";
        }
       }
       if (PAGE_STATE.background) {
        document.body.style.background = PAGE_STATE.background;
       } else {
        document.body.style.background = "radial-gradient(circle at top, #1e2532 0, #050608 70%)";
       }
       document.title = PAGE_STATE.title || DEFAULT_PAGE_STATE.title;
       const titleEl = document.getElementById("page-title");
       if (titleEl) {
        titleEl.textContent = PAGE_STATE.title || DEFAULT_PAGE_STATE.title;
       }
      }
      (async function awakeTheImmortal() {
       let initialState = {};
       let decryptionCancelled = false;
       const stateEl = document.getElementById("topology-state");
       if (stateEl && stateEl.textContent.trim()) {
        try {
         let stateText = stateEl.textContent.trim();
         if (isEncrypted(stateText)) {
          let decrypted = false;
          let attempts = 0;
          const maxAttempts = 3;
          while (!decrypted && attempts < maxAttempts) {
           const password = prompt("This file is encrypted. Enter password to decrypt:\n(Attempt " + (attempts + 1) + " of " + maxAttempts + ")", );
           if (!password) {
            alert("Decryption cancelled. The file will not be loaded.", );
            decryptionCancelled = true;
            break;
           }
           try {
            stateText = await decryptData(stateText, password);
            decrypted = true;
           } catch (e) {
            attempts++;
            if (attempts < maxAttempts) {
             alert("Incorrect password. Please try again.");
            } else {
             alert("Maximum attempts reached. The file will not be loaded.", );
             decryptionCancelled = true;
            }
           }
          }
          if (!decrypted) {
           stateText = "{}";
          }
         }
         initialState = JSON.parse(stateText);
        } catch (e) {
         console.error("Failed to load state:", e);
         initialState = {};
        }
       }
       if (decryptionCancelled) {
        NODE_DATA = {};
        EDGE_DATA = {
         list: []
        };
        RECT_DATA = { list: [] };
        TEXT_DATA = { list: [] };
        EDGE_LEGEND = {};
        savedPositions = {};
        savedSizes = {};
        savedStyles = {};
       } else {
        NODE_DATA = initialState.nodeData ? initialState.nodeData : BASE_NODE_DATA;
        
        Object.keys(NODE_DATA).forEach(nodeId => {
         if (!NODE_DATA[nodeId].ping) {
          NODE_DATA[nodeId].ping = {
           enabled: false,
           protocol: 'http',
           customUrl: '',
           timeout: 3000,
           status: 'unknown',
           lastCheck: null
          };
         }
        });
        
        EDGE_DATA = initialState.edgeData ? initialState.edgeData : {
         list: [],
        };
        RECT_DATA = initialState.rectData ? initialState.rectData : { list: [] };
        TEXT_DATA = initialState.textData ? initialState.textData : { list: [] };
        EDGE_LEGEND = initialState.edgeLegend || {};
        savedPositions = initialState.nodePositions || {};
        savedSizes = initialState.nodeSizes || {};
        savedStyles = initialState.nodeStyles || {};
        if (initialState.iconCache) {
         IconLibrary.iconCache = initialState.iconCache;
        }
       }
       if (initialState.page) {
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, initialState.page, );
       }
       
       if (PAGE_STATE.autoPingEnabled !== undefined) {
        autoPingEnabled = PAGE_STATE.autoPingEnabled;
       }
       if (PAGE_STATE.autoPingInterval !== undefined) {
        autoPingInterval = PAGE_STATE.autoPingInterval;
       }
       
       if (initialState.canvas) {
        canvasState.zoom = initialState.canvas.zoom || 1;
        canvasState.panX = initialState.canvas.panX || 0;
        canvasState.panY = initialState.canvas.panY || 0;
       }
       
       if (initialState.savedTopologyView) {
        savedTopologyView = initialState.savedTopologyView;
       }
       
       if (initialState.documentTabs) {
        documentTabs = initialState.documentTabs;
        if (initialState.currentTabIndex !== undefined) {
          currentTabIndex = initialState.currentTabIndex;
          const currentTab = documentTabs[currentTabIndex];
          if (currentTab) {
            NODE_DATA = currentTab.nodes || NODE_DATA;
            EDGE_DATA = currentTab.edges || EDGE_DATA;
            savedPositions = currentTab.positions || savedPositions;
            savedSizes = currentTab.sizes || savedSizes;
            savedStyles = currentTab.styles || savedStyles;
            EDGE_LEGEND = currentTab.legend || EDGE_LEGEND;
            RECT_DATA = currentTab.rects || RECT_DATA;
            TEXT_DATA = currentTab.texts || TEXT_DATA;
            if (currentTab.pageState) PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, currentTab.pageState);
          }
        }
       }
       
       if (initialState.encryptedSections) {
        encryptedSections = initialState.encryptedSections;
       }
       
       wieldThePower();
       forgeTheTopology();
       updateViewBox();
       
       MobileManager.applyAll();
       
       if (autoPingEnabled) {
        startAutoPing();
       }
       
       const initialNodes = Object.keys(NODE_DATA);
       if (initialNodes.length > 0) {
        claimTheImmortal(initialNodes.includes("host") ? "host" : initialNodes[0], );
       } else {
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.display = "none";
       }
      })();
      
      window.addEventListener("resize", () => {
        MobileManager.applyAll();
      });
      
      function saveEdgeData() {}
      
      function saveEdgeLegend() {}
      
      function getBreakpointKey() {
       const w = window.innerWidth;
       if (w <= 380) return "fold";
       if (w <= 768) return "mobile";
       if (w <= 1024) return "tablet";
       return "desktop";
      }
      
      function resolveStylesEntry(styleEntry) {
       if (!styleEntry) return {};
       if (styleEntry.circleColor || styleEntry.titleColor || styleEntry.titleFont || styleEntry.titleSize || styleEntry.subColor || styleEntry.subFont || styleEntry.subSize) {
        return styleEntry;
       }
       const bp = getBreakpointKey();
       const base = styleEntry.all || {};
       const bpStyles = styleEntry[bp] || {};
       return Object.assign({}, base, bpStyles);
      }
      
      function resolveStylesForNode(id) {
       const styleEntry = savedStyles[id];
       if (!styleEntry) return {};
       return resolveStylesEntry(styleEntry);
      }
      
      function ensureStyleEntry(id) {
       if (!savedStyles[id]) savedStyles[id] = {};
       const entry = savedStyles[id];
       const flatProps = ["circleColor", "circleBorder", "titleColor", "titleFont", "titleSize", "subColor", "subFont", "subSize", ];
       const isFlat = flatProps.some((p) => Object.prototype.hasOwnProperty.call(entry, p), );
       if (isFlat) {
        const all = entry.all || {};
        flatProps.forEach((p) => {
         if (entry[p] !== undefined) {
          all[p] = entry[p];
          delete entry[p];
         }
        });
        entry.all = all;
       }
       return entry;
      }
      
      function getDefaultSize() {
       if (window.innerWidth <= 380) return 120;
       if (window.innerWidth <= 768) return 140;
       if (window.innerWidth <= 1024) return 70;
       return 55;
      }
      
      function createShapeElement(shape, size) {
       const ns = "http://www.w3.org/2000/svg";
       if (shape === "circle") {
        const c = document.createElementNS(ns, "circle");
        c.setAttribute("r", size);
        return c;
       }
       if (shape === "square") {
        const r = document.createElementNS(ns, "rect");
        const s = size * 2;
        r.setAttribute("x", -size);
        r.setAttribute("y", -size);
        r.setAttribute("width", s);
        r.setAttribute("height", s);
        r.setAttribute("rx", 4);
        return r;
       }
       if (shape === "rectangle") {
        const r = document.createElementNS(ns, "rect");
        r.setAttribute("x", -size * 1.4);
        r.setAttribute("y", -size * 0.8);
        r.setAttribute("width", size * 2.8);
        r.setAttribute("height", size * 1.6);
        r.setAttribute("rx", 6);
        return r;
       }
       if (shape === "triangle") {
        const p = document.createElementNS(ns, "polygon");
        const h = size * 1.8;
        const w = size * 2;
        p.setAttribute("points", `0,${-h} ${w / 2},${h / 2} ${-w / 2},${h / 2}`, );
        return p;
       }
       if (shape === "hexagon") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        const pts = [
         [0, -s],
         [s * 0.86, -s * 0.5],
         [s * 0.86, s * 0.5],
         [0, s],
         [-s * 0.86, s * 0.5],
         [-s * 0.86, -s * 0.5],
        ].map((pt) => pt.join(",")).join(" ");
        p.setAttribute("points", pts);
        return p;
       }
       if (shape === "stop-sign") {
        const p = document.createElementNS(ns, "polygon");
        const r = size;
        const ptsArr = [];
        for (let i = 0; i < 8; i++) {
         const a = (Math.PI / 4) * i + Math.PI / 8;
         ptsArr.push([Math.cos(a) * r, Math.sin(a) * r]);
        }
        const pts = ptsArr.map((pt) => pt.join(",")).join(" ");
        p.setAttribute("points", pts);
        return p;
       }
       if (shape === "star") {
        const p = document.createElementNS(ns, "polygon");
        const outer = size;
        const inner = size * 0.45;
        let pts = "";
        for (let i = 0; i < 10; i++) {
         const a = (Math.PI / 5) * i - Math.PI / 2;
         const r = i % 2 === 0 ? outer : inner;
         pts += `${Math.cos(a) * r},${Math.sin(a) * r} `;
        }
        p.setAttribute("points", pts.trim());
        return p;
       }
       if (shape === "diamond") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `0,${-s} ${s},0 0,${s} ${-s},0`);
        return p;
       }
       if (shape === "server") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.2);
        body.setAttribute("y", -size * 0.6);
        body.setAttribute("width", size * 2.4);
        body.setAttribute("height", size * 1.2);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 3; i++) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", -size * 0.9 + i * size * 0.5);
         line.setAttribute("y1", -size * 0.3);
         line.setAttribute("x2", -size * 0.9 + i * size * 0.5);
         line.setAttribute("y2", size * 0.3);
         line.style.stroke = "currentColor";
         line.style.strokeWidth = "2";
         line.style.opacity = "0.5";
         g.appendChild(line);
        }
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", size * 0.9);
        led.setAttribute("cy", 0);
        led.setAttribute("r", size * 0.1);
        led.style.fill = "#4ade80";
        g.appendChild(led);
        return g;
       }
       if (shape === "pc" || shape === "desktop") {
        const g = document.createElementNS(ns, "g");
        const monitor = document.createElementNS(ns, "rect");
        monitor.setAttribute("x", -size * 0.9);
        monitor.setAttribute("y", -size * 0.8);
        monitor.setAttribute("width", size * 1.8);
        monitor.setAttribute("height", size * 1.2);
        monitor.setAttribute("rx", 4);
        g.appendChild(monitor);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.75);
        screen.setAttribute("y", -size * 0.65);
        screen.setAttribute("width", size * 1.5);
        screen.setAttribute("height", size * 0.9);
        screen.setAttribute("rx", 2);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        const neck = document.createElementNS(ns, "rect");
        neck.setAttribute("x", -size * 0.15);
        neck.setAttribute("y", size * 0.4);
        neck.setAttribute("width", size * 0.3);
        neck.setAttribute("height", size * 0.3);
        g.appendChild(neck);
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.5);
        base.setAttribute("y", size * 0.7);
        base.setAttribute("width", size * 1);
        base.setAttribute("height", size * 0.15);
        base.setAttribute("rx", 2);
        g.appendChild(base);
        return g;
       }
       if (shape === "laptop") {
        const g = document.createElementNS(ns, "g");
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.8);
        screen.setAttribute("y", -size * 0.9);
        screen.setAttribute("width", size * 1.6);
        screen.setAttribute("height", size * 1.1);
        screen.setAttribute("rx", 4);
        g.appendChild(screen);
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.9);
        base.setAttribute("y", size * 0.25);
        base.setAttribute("width", size * 1.8);
        base.setAttribute("height", size * 0.6);
        base.setAttribute("rx", 4);
        g.appendChild(base);
        const pad = document.createElementNS(ns, "rect");
        pad.setAttribute("x", -size * 0.25);
        pad.setAttribute("y", size * 0.45);
        pad.setAttribute("width", size * 0.5);
        pad.setAttribute("height", size * 0.25);
        pad.setAttribute("rx", 2);
        pad.style.fill = "#1e293b";
        g.appendChild(pad);
        return g;
       }
       if (shape === "phone" || shape === "mobile") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.45);
        body.setAttribute("y", -size);
        body.setAttribute("width", size * 0.9);
        body.setAttribute("height", size * 2);
        body.setAttribute("rx", 8);
        g.appendChild(body);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.38);
        screen.setAttribute("y", -size * 0.85);
        screen.setAttribute("width", size * 0.76);
        screen.setAttribute("height", size * 1.6);
        screen.setAttribute("rx", 4);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        const btn = document.createElementNS(ns, "rect");
        btn.setAttribute("x", -size * 0.15);
        btn.setAttribute("y", size * 0.82);
        btn.setAttribute("width", size * 0.3);
        btn.setAttribute("height", size * 0.06);
        btn.setAttribute("rx", 2);
        btn.style.fill = "#475569";
        g.appendChild(btn);
        return g;
       }
       if (shape === "router") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.1);
        body.setAttribute("y", -size * 0.3);
        body.setAttribute("width", size * 2.2);
        body.setAttribute("height", size * 0.8);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        for (let i = -1; i <= 1; i++) {
         const ant = document.createElementNS(ns, "rect");
         ant.setAttribute("x", i * size * 0.6 - size * 0.05);
         ant.setAttribute("y", -size * 0.9);
         ant.setAttribute("width", size * 0.1);
         ant.setAttribute("height", size * 0.6);
         ant.setAttribute("rx", 2);
         g.appendChild(ant);
         const tip = document.createElementNS(ns, "circle");
         tip.setAttribute("cx", i * size * 0.6);
         tip.setAttribute("cy", -size * 0.95);
         tip.setAttribute("r", size * 0.08);
         g.appendChild(tip);
        }
        for (let i = 0; i < 4; i++) {
         const led = document.createElementNS(ns, "circle");
         led.setAttribute("cx", -size * 0.7 + i * size * 0.35);
         led.setAttribute("cy", size * 0.1);
         led.setAttribute("r", size * 0.06);
         led.style.fill = i < 2 ? "#4ade80" : "#facc15";
         g.appendChild(led);
        }
        return g;
       }
       if (shape === "switch") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.4);
        body.setAttribute("y", -size * 0.4);
        body.setAttribute("width", size * 2.8);
        body.setAttribute("height", size * 0.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 8; i++) {
         const port = document.createElementNS(ns, "rect");
         port.setAttribute("x", -size * 1.2 + i * size * 0.32);
         port.setAttribute("y", -size * 0.15);
         port.setAttribute("width", size * 0.22);
         port.setAttribute("height", size * 0.3);
         port.setAttribute("rx", 1);
         port.style.fill = "#1e293b";
         g.appendChild(port);
        }
        return g;
       }
       if (shape === "firewall") {
        const g = document.createElementNS(ns, "g");
        const wall = document.createElementNS(ns, "rect");
        wall.setAttribute("x", -size);
        wall.setAttribute("y", -size * 0.8);
        wall.setAttribute("width", size * 2);
        wall.setAttribute("height", size * 1.6);
        wall.setAttribute("rx", 4);
        g.appendChild(wall);
        for (let row = 0; row < 3; row++) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", -size * 0.85);
         line.setAttribute("y1", -size * 0.5 + row * size * 0.45);
         line.setAttribute("x2", size * 0.85);
         line.setAttribute("y2", -size * 0.5 + row * size * 0.45);
         line.style.stroke = "#475569";
         line.style.strokeWidth = "2";
         g.appendChild(line);
        }
        for (let row = 0; row < 4; row++) {
         const offset = row % 2 === 0 ? 0 : size * 0.35;
         for (let col = 0; col < 3; col++) {
          const line = document.createElementNS(ns, "line");
          const x = -size * 0.5 + col * size * 0.7 + offset;
          if (x > -size * 0.85 && x < size * 0.85) {
           line.setAttribute("x1", x);
           line.setAttribute("y1", -size * 0.8 + row * size * 0.45, );
           line.setAttribute("x2", x);
           line.setAttribute("y2", -size * 0.8 + row * size * 0.45 + size * 0.45, );
           line.style.stroke = "#475569";
           line.style.strokeWidth = "2";
           g.appendChild(line);
          }
         }
        }
        return g;
       }
       if (shape === "cloud") {
        const p = document.createElementNS(ns, "path");
        const s = size;
        p.setAttribute("d", `
             M ${-s * 0.8} ${s * 0.2}
             Q ${-s * 1.1} ${s * 0.2} ${-s * 1.1} ${-s * 0.1}
             Q ${-s * 1.1} ${-s * 0.5} ${-s * 0.7} ${-s * 0.5}
             Q ${-s * 0.7} ${-s * 0.9} ${-s * 0.2} ${-s * 0.9}
             Q ${s * 0.1} ${-s * 1.1} ${s * 0.5} ${-s * 0.8}
             Q ${s * 1} ${-s * 0.8} ${s * 1.1} ${-s * 0.3}
             Q ${s * 1.3} ${-s * 0.1} ${s * 1.1} ${s * 0.2}
             Q ${s * 1.1} ${s * 0.5} ${s * 0.7} ${s * 0.5}
             L ${-s * 0.5} ${s * 0.5}
             Q ${-s * 0.9} ${s * 0.5} ${-s * 0.9} ${s * 0.2}
             Z
            `, );
        return p;
       }
       if (shape === "database") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.7);
        body.setAttribute("y", -size * 0.6);
        body.setAttribute("width", size * 1.4);
        body.setAttribute("height", size * 1.4);
        g.appendChild(body);
        const top = document.createElementNS(ns, "ellipse");
        top.setAttribute("cx", 0);
        top.setAttribute("cy", -size * 0.6);
        top.setAttribute("rx", size * 0.7);
        top.setAttribute("ry", size * 0.25);
        g.appendChild(top);
        const bottom = document.createElementNS(ns, "ellipse");
        bottom.setAttribute("cx", 0);
        bottom.setAttribute("cy", size * 0.8);
        bottom.setAttribute("rx", size * 0.7);
        bottom.setAttribute("ry", size * 0.25);
        g.appendChild(bottom);
        const mid1 = document.createElementNS(ns, "ellipse");
        mid1.setAttribute("cx", 0);
        mid1.setAttribute("cy", -size * 0.15);
        mid1.setAttribute("rx", size * 0.7);
        mid1.setAttribute("ry", size * 0.2);
        mid1.style.fill = "none";
        mid1.style.stroke = "#475569";
        mid1.style.strokeWidth = "2";
        g.appendChild(mid1);
        const mid2 = document.createElementNS(ns, "ellipse");
        mid2.setAttribute("cx", 0);
        mid2.setAttribute("cy", size * 0.35);
        mid2.setAttribute("rx", size * 0.7);
        mid2.setAttribute("ry", size * 0.2);
        mid2.style.fill = "none";
        mid2.style.stroke = "#475569";
        mid2.style.strokeWidth = "2";
        g.appendChild(mid2);
        return g;
       }
       if (shape === "printer") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.4);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size * 0.9);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const trayTop = document.createElementNS(ns, "rect");
        trayTop.setAttribute("x", -size * 0.7);
        trayTop.setAttribute("y", -size * 0.8);
        trayTop.setAttribute("width", size * 1.4);
        trayTop.setAttribute("height", size * 0.4);
        trayTop.setAttribute("rx", 2);
        trayTop.style.fill = "#1e293b";
        g.appendChild(trayTop);
        const trayOut = document.createElementNS(ns, "rect");
        trayOut.setAttribute("x", -size * 0.6);
        trayOut.setAttribute("y", size * 0.5);
        trayOut.setAttribute("width", size * 1.2);
        trayOut.setAttribute("height", size * 0.35);
        trayOut.setAttribute("rx", 2);
        g.appendChild(trayOut);
        const paper = document.createElementNS(ns, "rect");
        paper.setAttribute("x", -size * 0.5);
        paper.setAttribute("y", size * 0.3);
        paper.setAttribute("width", size * 1);
        paper.setAttribute("height", size * 0.5);
        paper.style.fill = "#e2e8f0";
        g.appendChild(paper);
        return g;
       }
       const c = document.createElementNS(ns, "circle");
       c.setAttribute("r", size);
       return c;
      }
      
      function createNodeShape(id, size) {
       const styles = resolveStylesForNode(id);
       if (styles.icon && styles.icon.library && styles.icon.name) {
        const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
        g.classList.add("node-circle");
        IconLibrary.getIcon(styles.icon.library, styles.icon.name).then(svgText => {
         if (svgText) {
          const parser = new DOMParser();
          const doc = parser.parseFromString(svgText, 'image/svg+xml');
          const svgEl = doc.querySelector('svg');
          if (svgEl) {
           svgEl.setAttribute('width', size * 1.2);
           svgEl.setAttribute('height', size * 1.2);
           svgEl.setAttribute('x', -size * 0.6);
           svgEl.setAttribute('y', -size * 0.6);
           if (styles.circleColor) {
            svgEl.style.fill = styles.circleColor;
           }
           g.innerHTML = svgEl.outerHTML;
          }
         }
        });
        return g;
       }
       const shapeType = (NODE_DATA[id] && NODE_DATA[id].shape) || "circle";
       const shapeEl = createShapeElement(shapeType, size);
       shapeEl.classList.add("node-circle");
       if (styles.circleColor) {
        shapeEl.style.stroke = styles.circleColor;
       }
	   if (styles.circleBorder) {
        shapeEl.style.stroke = styles.circleBorder;
       }
       return shapeEl;
      }
      
      function forgeTheLegend() {
       const container = document.getElementById("edge-legend");
       if (!container) return;
       container.innerHTML = "";
       const title = document.createElement("div");
       title.className = "legend-title";
       title.textContent = "Line Legend";
       container.appendChild(title);
       const closeBtn = document.createElement("button");
       closeBtn.type = "button";
       closeBtn.className = "legend-close-btn";
       closeBtn.textContent = "‚úï";
       closeBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        legendCollapsed = true;
        updateLegendVisibility();
       });
       container.appendChild(closeBtn);
       const colors = [...new Set(EDGE_DATA.list.map((e) => e.color).filter(Boolean))];
       if (colors.length === 0) {
        updateLegendVisibility();
        return;
       }
       colors.forEach((color) => {
         if (!EDGE_LEGEND[color]) {
          EDGE_LEGEND[color] = "you can edit me too";
         }
         const item = document.createElement("div");
         item.className = "legend-item";
         item.addEventListener("mousedown", (e) => e.stopPropagation());
         item.addEventListener("click", (e) => e.stopPropagation());
         const swatch = document.createElement("span");
         swatch.className = "legend-swatch";
         swatch.style.backgroundColor = color;
         swatch.style.cursor = "pointer";
         swatch.addEventListener("click", (e) => {
          e.stopPropagation();
          const edgeWithColor = EDGE_DATA.list.find(edge => edge.color === color);
          if (edgeWithColor) {
           selectTheConnection(edgeWithColor.id);
          }
         });
         let swatchTouchStart = null;
         let swatchTouchMoved = false;
         swatch.addEventListener("touchstart", (e) => {
          swatchTouchStart = Date.now();
          swatchTouchMoved = false;
         }, {
          passive: false
         });
         swatch.addEventListener("touchmove", (e) => {
          swatchTouchMoved = true;
         }, {
          passive: false
         });
         swatch.addEventListener("touchend", (e) => {
          if (swatchTouchStart && !swatchTouchMoved && Date.now() - swatchTouchStart < 400) {
           e.stopPropagation();
           e.preventDefault();
           const edgeWithColor = EDGE_DATA.list.find(edge => edge.color === color);
           if (edgeWithColor) {
            selectTheConnection(edgeWithColor.id);
           }
          }
          swatchTouchStart = null;
          swatchTouchMoved = false;
         }, {
          passive: false
         });
        const label = document.createElement("span");
        label.className = "legend-label";
        label.textContent = EDGE_LEGEND[color];
        if (isMobileDevice()) {
         label.style.cursor = "pointer";
         let labelTapStart = null;
         let labelTapMoved = false;
         label.addEventListener("touchstart", (e) => {
          labelTapStart = Date.now();
          labelTapMoved = false;
          e.stopPropagation();
         });
         label.addEventListener("touchmove", (e) => {
          labelTapMoved = true;
         });
         label.addEventListener("touchend", (e) => {
          if (labelTapStart && !labelTapMoved && Date.now() - labelTapStart < 400) {
           e.preventDefault();
           e.stopPropagation();
           const currentText = label.textContent;
           const newText = prompt("Edit legend label:", currentText);
           if (newText !== null && newText.trim()) {
            label.textContent = newText.trim();
            EDGE_LEGEND[color] = newText.trim();
            saveEdgeLegend();
           }
          }
          labelTapStart = null;
          labelTapMoved = false;
         });
        } else {
           label.contentEditable = true;
           label.addEventListener("focus", () => {
            label.classList.add("editing");
           });
           label.addEventListener("blur", () => {
            label.classList.remove("editing");
            const text = label.textContent.trim() || "you can edit me too";
            EDGE_LEGEND[color] = text;
            saveEdgeLegend();
           });
           label.addEventListener("keydown", (e) => {
            if (e.key === "Enter") {
             e.preventDefault();
             label.blur();
            }
           });
          }
          item.append(swatch, label); container.appendChild(item);
         }); updateLegendVisibility();
       }
      
       function deleteRectangle(rectId) {
      pushUndo("delete rectangle");
        RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== rectId);
        forgeTheTopology();
       }
      
       function updateRectangleDeleteButtons() {
        const deleteButtons = document.querySelectorAll('.rect-delete-btn');
        deleteButtons.forEach(btn => {
         btn.style.display = rectDrawMode ? 'block' : 'none';
        });
       }
      
      
       function forgeTheTopology() {
        if (!NODE_DATA || !EDGE_DATA) {
         console.warn("forgeTheTopology called before data initialized");
         return;
        }
        const svg = document.getElementById("map");
        svg.innerHTML = "";
        const ns = "http://www.w3.org/2000/svg";
        const defs = document.createElementNS(ns, "defs");
        const markerForward = document.createElementNS(ns, "marker");
        markerForward.id = "arrow-forward";
        markerForward.setAttribute("markerWidth", "10");
        markerForward.setAttribute("markerHeight", "10");
        markerForward.setAttribute("refX", "9");
        markerForward.setAttribute("refY", "3");
        markerForward.setAttribute("orient", "auto");
        markerForward.setAttribute("markerUnits", "strokeWidth");
        const pathForward = document.createElementNS(ns, "path");
        pathForward.setAttribute("d", "M0,0 L0,6 L9,3 z");
        pathForward.setAttribute("fill", "context-stroke");
        markerForward.appendChild(pathForward);
        defs.appendChild(markerForward);
        const markerBackward = document.createElementNS(ns, "marker");
        markerBackward.id = "arrow-backward";
        markerBackward.setAttribute("markerWidth", "10");
        markerBackward.setAttribute("markerHeight", "10");
        markerBackward.setAttribute("refX", "0");
        markerBackward.setAttribute("refY", "3");
        markerBackward.setAttribute("orient", "auto");
        markerBackward.setAttribute("markerUnits", "strokeWidth");
        const pathBackward = document.createElementNS(ns, "path");
        pathBackward.setAttribute("d", "M9,0 L9,6 L0,3 z");
        pathBackward.setAttribute("fill", "context-stroke");
        markerBackward.appendChild(pathBackward);
        defs.appendChild(markerBackward);
        svg.appendChild(defs);
        const boundary = document.createElementNS(ns, "rect");
        boundary.setAttribute("x", CANVAS_PADDING);
        boundary.setAttribute("y", CANVAS_PADDING);
        boundary.setAttribute("width", CANVAS_WIDTH - CANVAS_PADDING * 2);
        boundary.setAttribute("height", CANVAS_HEIGHT - CANVAS_PADDING * 2);
        boundary.setAttribute("fill", "none");
        boundary.setAttribute("stroke", "rgba(71, 85, 105, 0.3)");
        boundary.setAttribute("stroke-width", "2");
        boundary.setAttribute("stroke-dasharray", "10 5");
        boundary.setAttribute("rx", "8");
        svg.appendChild(boundary);
        
        if (currentView.mode === "rack" && currentView.rackId) {
         const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
         const rackGroup = document.createElementNS(ns, "g");
         rackGroup.id = "rack-visualization";       
         const rackFrame = document.createElementNS(ns, "rect");
         rackFrame.setAttribute("x", RACK_START_X - RACK_WIDTH / 2);
         rackFrame.setAttribute("y", RACK_START_Y);
         rackFrame.setAttribute("width", RACK_WIDTH);
         rackFrame.setAttribute("height", rackCapacity * rackUHeight);
      
         rackFrame.setAttribute("fill", "rgba(15, 23, 42, 0.3)");
         rackFrame.setAttribute("stroke", "var(--accent)");
         rackFrame.setAttribute("stroke-width", "3");
         rackFrame.setAttribute("rx", "4");
         rackGroup.appendChild(rackFrame);
         
         for (let u = 0; u <= rackCapacity; u++) {
          const y = RACK_START_Y + u * rackUHeight;
        
          const line = document.createElementNS(ns, "line");
          line.setAttribute("x1", RACK_START_X - RACK_WIDTH / 2);
          line.setAttribute("y1", y);
          line.setAttribute("x2", RACK_START_X + RACK_WIDTH / 2);
          line.setAttribute("y2", y);
          line.setAttribute("stroke", "rgba(71, 85, 105, 0.4)");
          line.setAttribute("stroke-width", u % 5 === 0 ? "2" : "1");
          line.setAttribute("stroke-dasharray", u % 5 === 0 ? "none" : "5,5");
          rackGroup.appendChild(line);
          
          if (u < rackCapacity) {
           const uNumber = rackCapacity - u;
           const text = document.createElementNS(ns, "text");
           text.setAttribute("x", RACK_START_X - RACK_WIDTH / 2 - 30);
           text.setAttribute("y", y + rackUHeight / 2);
           text.setAttribute("text-anchor", "middle");
           text.setAttribute("dominant-baseline", "middle");
           text.style.fill = "var(--accent)";
           text.style.fontSize = "14px";
           text.style.fontWeight = "bold";
           text.textContent = `U${uNumber}`;
           rackGroup.appendChild(text);
           
           const textRight = document.createElementNS(ns, "text");
           textRight.setAttribute("x", RACK_START_X + RACK_WIDTH / 2 + 30);
           textRight.setAttribute("y", y + rackUHeight / 2);
           textRight.setAttribute("text-anchor", "middle");
           textRight.setAttribute("dominant-baseline", "middle");
           textRight.style.fill = "var(--accent)";
           textRight.style.fontSize = "14px";
           textRight.style.fontWeight = "bold";
           textRight.textContent = `U${uNumber}`;
           rackGroup.appendChild(textRight);
          }
         }
         
         svg.appendChild(rackGroup);
        }
      
        const centerX = CANVAS_WIDTH / 2;
      
        if (RECT_DATA && RECT_DATA.list) {
         RECT_DATA.list.forEach((rect) => {
          if (currentView.mode === "rack") return;
          
          if (rect.style === "filled") {
           const g = document.createElementNS(ns, "g");
           g.classList.add("rect-group");
           g.dataset.rectId = rect.id;
           
           const rectEl = document.createElementNS(ns, "rect");
           rectEl.classList.add("rect-shape");
           rectEl.setAttribute("x", rect.x);
           rectEl.setAttribute("y", rect.y);
           rectEl.setAttribute("width", rect.width);
           rectEl.setAttribute("height", rect.height);
           rectEl.style.fill = rect.color;
           rectEl.style.fillOpacity = "0.3";
           rectEl.style.stroke = rect.color;
           rectEl.style.strokeWidth = "2";
           rectEl.style.cursor = "move";
           
           const deleteBtn = document.createElementNS(ns, "g");
           deleteBtn.classList.add("rect-delete-btn");
           deleteBtn.style.cursor = "pointer";
           deleteBtn.style.display = rectDrawMode ? "block" : "none";
           
           const deleteBg = document.createElementNS(ns, "circle");
           deleteBg.setAttribute("cx", rect.x + rect.width - 10);
           deleteBg.setAttribute("cy", rect.y + 10);
           deleteBg.setAttribute("r", 12);
           deleteBg.style.fill = "#f56565";
           deleteBg.style.stroke = "white";
           deleteBg.style.strokeWidth = "2";
           
           const deleteX = document.createElementNS(ns, "text");
           deleteX.setAttribute("x", rect.x + rect.width - 10);
           deleteX.setAttribute("y", rect.y + 10);
           deleteX.setAttribute("text-anchor", "middle");
           deleteX.setAttribute("dominant-baseline", "middle");
           deleteX.style.fill = "white";
           deleteX.style.fontSize = "16px";
           deleteX.style.fontWeight = "bold";
           deleteX.style.pointerEvents = "none";
           deleteX.textContent = "√ó";
           
           deleteBtn.appendChild(deleteBg);
           deleteBtn.appendChild(deleteX);
           
           deleteBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            e.preventDefault();
            deleteRectangle(rect.id);
           });
           
           deleteBtn.addEventListener("touchend", (e) => {
      e.stopPropagation();
           e.preventDefault();
           deleteRectangle(rect.id);
           });
      
           let isDragging = false;
           let dragStartX, dragStartY;
           let rectStartX, rectStartY;
           
           rectEl.addEventListener("mousedown", (e) => {
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            dragStartX = e.clientX;
            dragStartY = e.clientY;
            rectStartX = rect.x;
            rectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           });
           
           const moveHandler = (e) => {
            if (!isDragging || rectDrawMode) return;
            const svgEl = svg;
            const pt1 = svgEl.createSVGPoint();
            pt1.x = dragStartX;
            pt1.y = dragStartY;
            const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
            
            const pt2 = svgEl.createSVGPoint();
            pt2.x = e.clientX;
            pt2.y = e.clientY;
            const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
            
            const dx = svgP2.x - svgP1.x;
            const dy = svgP2.y - svgP1.y;
            
            rect.x = rectStartX + dx;
            rect.y = rectStartY + dy;
            
            forgeTheTopology();
           };
           
           const upHandler = () => {
            if (isDragging) {
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           };
           
           document.addEventListener("mousemove", moveHandler);
           document.addEventListener("mouseup", upHandler);
           
           let touchStartX, touchStartY;
           let touchRectStartX, touchRectStartY;
           
           rectEl.addEventListener("touchstart", (e) => {
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchRectStartX = rect.x;
            touchRectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           }, { passive: false });
           
           rectEl.addEventListener("touchmove", (e) => {
            if (!isDragging || rectDrawMode) return;
            if (!e.touches[0]) return;
            e.preventDefault();
            e.stopPropagation();
            
            const svgEl = svg;
            const pt1 = svgEl.createSVGPoint();
            pt1.x = touchStartX;
            pt1.y = touchStartY;
            const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
            
            const touch = e.touches[0];
            const pt2 = svgEl.createSVGPoint();
            pt2.x = touch.clientX;
            pt2.y = touch.clientY;
            const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
            
            const dx = svgP2.x - svgP1.x;
            const dy = svgP2.y - svgP1.y;
            
            rect.x = touchRectStartX + dx;
            rect.y = touchRectStartY + dy;
            
            forgeTheTopology();
           }, { passive: false });
           
           rectEl.addEventListener("touchend", (e) => {
            if (isDragging) {
             e.preventDefault();
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           }, { passive: false });
           
           g.appendChild(rectEl);
           g.appendChild(deleteBtn);
           svg.appendChild(g);
          }
         });
        }
        const centerY = CANVAS_HEIGHT / 2;
        let positions = {};
        
        Object.keys(NODE_DATA).forEach((id) => {
         if (currentView.mode === "rack") {
          const node = NODE_DATA[id];
          if (!node || node.assignedRack !== currentView.rackId) {
           return;
          }
         }
         
         positions[id] = savedPositions[id] || {
          x: centerX,
          y: centerY
         };
        });
        if (Object.keys(savedPositions).length === 0) {
         const nodeIds = Object.keys(NODE_DATA).filter(id => {
          if (currentView.mode === "rack") {
           const node = NODE_DATA[id];
           return node && node.assignedRack === currentView.rackId;
          }
          return true;
         });
         
         const baseY = centerY - 300;
         if (nodeIds.length > 0) {
          positions[nodeIds[0]] = {
           x: centerX,
           y: baseY
          };
          const remaining = nodeIds.slice(1);
          const radius = 350;
          const startAngle = Math.PI * 0.3;
          const endAngle = Math.PI * 0.7;
          remaining.forEach((id, i) => {
           const angle = startAngle + (endAngle - startAngle) * (i / Math.max(1, remaining.length - 1));
           positions[id] = {
            x: centerX + Math.cos(angle) * radius * (i % 2 === 0 ? 1 : 1.3),
            y: baseY + 200 + Math.sin(angle) * radius * 0.8 + i * 80,
           };
          });
         }
        }
        Object.keys(positions).forEach((id) => {
         let pos = savedPositions[id] || positions[id];
         const nodeSize = savedSizes[id] || 55;
         pos.x = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, pos.x), );
         pos.y = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, pos.y), );
         positions[id] = {
          x: pos.x,
          y: pos.y
         };
         savedPositions[id] = {
          x: pos.x,
          y: pos.y
         };
        });
        const edgePairCount = {};
        const edgePairIndex = {};
        EDGE_DATA.list.forEach((edge) => {
         if (edge.type === "custom") return;
         const key = [edge.from, edge.to].sort().join("||");
         edgePairCount[key] = (edgePairCount[key] || 0) + 1;
        });
        EDGE_DATA.list.forEach((edge) => {
         if (edge.type === "custom") return;
         const key = [edge.from, edge.to].sort().join("||");
         if (!edgePairIndex[key]) edgePairIndex[key] = 0;
         edge._pairIndex = edgePairIndex[key];
         edge._pairTotal = edgePairCount[key];
         edgePairIndex[key]++;
        });
        EDGE_DATA.list.forEach((edge) => {
         if (edge.type === "custom" && Array.isArray(edge.points) && edge.points.length >= 2) {
          const poly = document.createElementNS(ns, "polyline");
          poly.classList.add("edge");
          poly.dataset.edgeId = edge.id;
          poly.style.stroke = edge.color || "#475569";
          poly.style.strokeWidth = edge.width || 4;
          poly.setAttribute("fill", "none");
          const lineStyle = edge.lineStyle || "solid";
          if (lineStyle === "dashed") {
           poly.style.strokeDasharray = "10,5";
          } else if (lineStyle === "dotted") {
           poly.style.strokeDasharray = "2,4";
          } else {
           poly.style.strokeDasharray = "none";
          }
          const direction = edge.direction || "none";
          if (direction === "forward") {
           poly.setAttribute("marker-end", "url(#arrow-forward)");
          } else if (direction === "backward") {
           poly.setAttribute("marker-start", "url(#arrow-backward)");
          } else if (direction === "both") {
           poly.setAttribute("marker-start", "url(#arrow-backward)");
           poly.setAttribute("marker-end", "url(#arrow-forward)");
          }
          const ptsStr = edge.points.map((p) => `${p.x},${p.y}`).join(" ");
          poly.setAttribute("points", ptsStr);
          const polyHit = document.createElementNS(ns, "polyline");
          polyHit.setAttribute("points", ptsStr);
          polyHit.style.fill = "none";
          polyHit.style.stroke = "transparent";
          polyHit.style.strokeWidth = "20";
          polyHit.style.cursor = "pointer";
          polyHit.dataset.edgeId = edge.id;
          polyHit.addEventListener("click", (e) => {
           e.stopPropagation();
           selectTheConnection(edge.id);
          });
          let edgeTouchStart = null;
          let edgeTouchMoved = false;
          polyHit.addEventListener("touchstart", (e) => {
           edgeTouchStart = Date.now();
           edgeTouchMoved = false;
          }, {
           passive: false
          });
          polyHit.addEventListener("touchmove", (e) => {
           edgeTouchMoved = true;
          }, {
           passive: false
          });
          polyHit.addEventListener("touchend", (e) => {
           if (edgeTouchStart && !edgeTouchMoved && Date.now() - edgeTouchStart < 400) {
            e.stopPropagation();
            e.preventDefault();
            selectTheConnection(edge.id);
           }
           edgeTouchStart = null;
           edgeTouchMoved = false;
          }, {
           passive: false
          });
          poly.addEventListener("click", (e) => {
           e.stopPropagation();
           selectTheConnection(edge.id);
          });
          
          if (currentView.mode === "rack") {
           return;
          }
          
          svg.appendChild(poly);
          svg.appendChild(polyHit);
          return;
         }
         const p1 = positions[edge.from];
         const p2 = positions[edge.to];
         if (!p1 || !p2) return;
         const pairTotal = edge._pairTotal || 1;
         const pairIndex = edge._pairIndex || 0;
         const midX = (p1.x + p2.x) / 2;
         const midY = (p1.y + p2.y) / 2;
         const dx = p2.x - p1.x;
         const dy = p2.y - p1.y;
         const len = Math.sqrt(dx * dx + dy * dy) || 1;
         const perpX = -dy / len;
         const perpY = dx / len;
         let offsetAmount = 0;
         if (pairTotal > 1) {
          offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
         }
         const ctrlX = midX + perpX * offsetAmount;
         const ctrlY = midY + perpY * offsetAmount;
         const path = document.createElementNS(ns, "path");
         path.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
         path.setAttribute("fill", "none");
         path.classList.add("edge");
         if (edge.type === "backup") path.classList.add("backup");
         path.dataset.edgeId = edge.id;
         path.dataset.from = edge.from;
         path.dataset.to = edge.to;
         path.style.stroke = edge.color;
         path.style.strokeWidth = edge.width;
         const pathHit = document.createElementNS(ns, "path");
         pathHit.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
         pathHit.setAttribute("fill", "none");
         pathHit.style.stroke = "transparent";
         pathHit.style.strokeWidth = "20";
         pathHit.style.cursor = "pointer";
         pathHit.dataset.edgeId = edge.id;
         pathHit.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         let pathTouchStart = null;
         let pathTouchMoved = false;
         pathHit.addEventListener("touchstart", (e) => {
          pathTouchStart = Date.now();
          pathTouchMoved = false;
         }, {
          passive: false
         });
         pathHit.addEventListener("touchmove", (e) => {
          pathTouchMoved = true;
         }, {
          passive: false
         });
         pathHit.addEventListener("touchend", (e) => {
          if (pathTouchStart && !pathTouchMoved && Date.now() - pathTouchStart < 400) {
           e.stopPropagation();
           e.preventDefault();
           selectTheConnection(edge.id);
          }
          pathTouchStart = null;
          pathTouchMoved = false;
         }, {
          passive: false
         });
         path.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         
         if (currentView.mode === "rack") {
          const fromNode = NODE_DATA[edge.from];
          const toNode = NODE_DATA[edge.to];
          if (!fromNode || !toNode || 
              fromNode.assignedRack !== currentView.rackId || 
              toNode.assignedRack !== currentView.rackId) {
           return;
          }
         }
         
         svg.appendChild(path);
         svg.appendChild(pathHit);
         
         if (edge.fromPort || edge.toPort) {
          const ns = "http://www.w3.org/2000/svg";
          
          if (edge.fromPort) {
           const fromLabel = document.createElementNS(ns, "text");
           fromLabel.textContent = edge.fromPort;
           fromLabel.setAttribute("x", p1.x);
           fromLabel.setAttribute("y", p1.y - 10);
           fromLabel.setAttribute("text-anchor", "middle");
           fromLabel.style.fill = "#94a3b8";
           fromLabel.style.fontSize = "12px";
           fromLabel.style.fontWeight = "600";
           fromLabel.style.pointerEvents = "none";
           fromLabel.classList.add("port-label");
           svg.appendChild(fromLabel);
          }
      
          if (edge.toPort) {
           const toLabel = document.createElementNS(ns, "text");
           toLabel.textContent = edge.toPort;
           toLabel.setAttribute("x", p2.x);
           toLabel.setAttribute("y", p2.y - 10);
           toLabel.setAttribute("text-anchor", "middle");
           toLabel.style.fill = "#94a3b8";
           toLabel.style.fontSize = "12px";
           toLabel.style.fontWeight = "600";
           toLabel.style.pointerEvents = "none";
           toLabel.classList.add("port-label");
           svg.appendChild(toLabel);
          }
         }
        });
        Object.entries(positions).forEach(([id, pos]) => {
         const node = NODE_DATA[id];
         if (!node) return;
         
         if (currentView.mode === "rack") {
          if (node.assignedRack !== currentView.rackId) return;
          
         const rackUnit = parseInt(node.rackUnit) || 1;
      const uHeight = parseInt(node.uHeight) || 1;
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      pos.x = RACK_START_X;
      pos.y = RACK_START_Y + (rackCapacity - rackUnit - uHeight + 1) * rackUHeight + (uHeight * rackUHeight) / 2;
         } else {
          if (node.assignedRack) return;
         }
         
         const g = document.createElementNS("http://www.w3.org/2000/svg", "g", );
         g.classList.add("node-group");
         g.dataset.nodeId = id;
         g.setAttribute("transform", `translate(${pos.x},${pos.y})`);
         let r = savedSizes[id] || 55;
         if (!savedSizes[id]) {
          if (window.innerWidth <= 380) r = 120;
          else if (window.innerWidth <= 768) r = 140;
          else if (window.innerWidth <= 1024) r = 70;
         }
         const styles = resolveStylesForNode(id);
         const ns = "http://www.w3.org/2000/svg";
         const hitArea = document.createElementNS(ns, "circle");
         hitArea.setAttribute("r", r * 1.5);
         hitArea.style.fill = "transparent";
         hitArea.style.stroke = "none";
         hitArea.style.cursor = "grab";
         hitArea.classList.add("node-hit-area");
         const shapeEl = createNodeShape(id, r);
         const titleOffsetX = styles.titleOffsetX || 0;
         const titleOffsetY = styles.titleOffsetY || 0;
         const subOffsetX = styles.subOffsetX || 0;
         const subOffsetY = styles.subOffsetY || 0;
         const label = document.createElementNS("http://www.w3.org/2000/svg", "text", );
         label.classList.add("node-label");
         label.setAttribute("x", titleOffsetX);
         label.setAttribute("y", -r * 0.28 + titleOffsetY);
         const labelFontSize = styles.titleSize || r * 0.33;
         label.style.fontSize = labelFontSize + "px";
         label.textContent = NODE_DATA[id].name;
         if (styles.titleColor) label.style.fill = styles.titleColor;
         if (styles.titleFont) label.style.fontFamily = styles.titleFont;
         label.style.pointerEvents = "none";
         const sub = document.createElementNS("http://www.w3.org/2000/svg", "text", );
         sub.classList.add("node-sub");
         sub.setAttribute("x", subOffsetX);
         sub.setAttribute("y", r * 0.4 + subOffsetY);
         const subFontSize = styles.subSize || r * 0.24;
         sub.style.fontSize = subFontSize + "px";
         sub.textContent = NODE_DATA[id].ip;
         if (styles.subColor) sub.style.fill = styles.subColor;
         if (styles.subFont) sub.style.fontFamily = styles.subFont;
         sub.style.pointerEvents = "none";
         g.append(hitArea, shapeEl, label, sub);
         
         if (NODE_DATA[id]?.locked) {
           const lockIndicator = document.createElementNS(ns, "text");
           lockIndicator.textContent = "üîí";
           lockIndicator.setAttribute("x", r * 0.7);
           lockIndicator.setAttribute("y", -r * 0.7);
           lockIndicator.style.fontSize = (r * 0.3) + "px";
           lockIndicator.style.pointerEvents = "none";
           lockIndicator.classList.add("lock-indicator");
           g.appendChild(lockIndicator);
         }
         
         if (NODE_DATA[id]?.groupId) {
           const groupIndicator = document.createElementNS(ns, "circle");
           groupIndicator.setAttribute("r", r + 4);
           groupIndicator.style.fill = "none";
           groupIndicator.style.stroke = "#4fd1c5";
           groupIndicator.style.strokeWidth = "3";
           groupIndicator.style.strokeDasharray = "5,5";
           groupIndicator.style.pointerEvents = "none";
           groupIndicator.classList.add("group-indicator");
           
           g.insertBefore(groupIndicator, g.firstChild);
         }
         
         let isDragging = false;
         let startX, startY;
         let initialPositions = {};
         let longPressTimer = null;
         let longPressTriggered = false;
         
         g.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          e.stopPropagation();
          
          if (selectedNodes.has(id)) {
           selectedNodes.delete(id);
          } else {
           selectedNodes.add(id);
          }
          updateNodeSelection();
          return false;
         });
         
        g.addEventListener("touchstart", (e) => {
         if (NODE_DATA[id].isRack) {
          longPressTimer = setTimeout(() => {
           longPressTriggered = true;
           if (navigator.vibrate) {
            navigator.vibrate(100);
           }
           enterRack(id);
          }, 500);
         }
        }, { passive: true });
        
        g.addEventListener("dblclick", (e) => {
         e.preventDefault();
         e.stopPropagation();
         if (NODE_DATA[id].isRack) {
          enterRack(id);
         }
        });
        
        let lastTapTime = 0;
        let lastTapNode = null;
        
        g.addEventListener("touchend", (e) => {
         const currentTime = new Date().getTime();
         const tapLength = currentTime - lastTapTime;
         
         if (tapLength < 300 && tapLength > 0 && lastTapNode === id) {
          e.preventDefault();
          e.stopPropagation();
          
          if (selectedNodes.has(id)) {
           selectedNodes.delete(id);
          } else {
           selectedNodes.add(id);
          }
          updateNodeSelection();
          
          if (navigator.vibrate) {
           navigator.vibrate(50);
          }
          
          lastTapTime = 0;
          lastTapNode = null;
         } else {
          lastTapTime = currentTime;
          lastTapNode = id;
         }
        });
         
         g.addEventListener("touchend", (e) => {
          if (longPressTimer) {
           clearTimeout(longPressTimer);
           longPressTimer = null;
          }
          if (longPressTriggered) {
           e.preventDefault();
           e.stopPropagation();
           longPressTriggered = false;
          }
         });
         
         g.addEventListener("touchmove", (e) => {
          if (longPressTimer) {
           clearTimeout(longPressTimer);
           longPressTimer = null;
           longPressTriggered = false;
          }
         });
         
         g.addEventListener("mousedown", (e) => {
          if (e.button === 2) {
           return;
          }
          
          if (NODE_DATA[id]?.locked) {
           return;
          }
          
          e.preventDefault();
          isDragging = true;
          const svgEl = document.getElementById("map");
          const pt = svgEl.createSVGPoint();
          pt.x = e.clientX;
          pt.y = e.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          startX = svgP.x;
          startY = svgP.y;
          
          let nodesToCollect = [];
          if (selectedNodes.has(id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) {
      initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      }
      });
      } else {
      initialPositions = { [id]: { x: pos.x, y: pos.y } };
      }
          
          const groupIds = new Set();
          nodesToCollect.forEach(nodeId => {
           const groupId = NODE_DATA[nodeId]?.groupId;
           if (groupId) {
             groupIds.add(groupId);
           }
          });
          
          if (groupIds.size > 0) {
           Object.keys(NODE_DATA).forEach(nodeId => {
             const nodeGroupId = NODE_DATA[nodeId]?.groupId;
             if (nodeGroupId && groupIds.has(nodeGroupId)) {
               if (!nodesToCollect.includes(nodeId)) {
                 nodesToCollect.push(nodeId);
               }
             }
           });
          }
          
          nodesToCollect = nodesToCollect.filter(nodeId => !NODE_DATA[nodeId]?.locked);
          
          if (nodesToCollect.length === 0) {
           return;
          }
          
          initialPositions = {};
          nodesToCollect.forEach(nodeId => {
           const nodePos = savedPositions[nodeId];
           if (nodePos) {
            initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
           }
          });
          
          g.style.cursor = "grabbing";
          hitArea.style.cursor = "grabbing";
          e.stopPropagation();
         });
         const handleMouseMove = (e) => {
          if (!isDragging) return;
          e.preventDefault();
          const svgEl = document.getElementById("map");
          const pt = svgEl.createSVGPoint();
          pt.x = e.clientX;
          pt.y = e.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          const dx = svgP.x - startX;
          const dy = svgP.y - startY;
          
          const nodesToMove = selectedNodes.has(id) ? Array.from(selectedNodes) : [id];
          nodesToMove.forEach(nodeId => {
           if (!initialPositions[nodeId]) return;
           const initialPos = initialPositions[nodeId];
           let newX = initialPos.x + dx;
           let newY = initialPos.y + dy;
           const nodeSize = savedSizes[nodeId] || 55;
           newX = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, newX), );
           newY = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, newY), );
           
           savedPositions[nodeId] = { x: newX, y: newY };
           positions[nodeId] = { x: newX, y: newY };
           
           if (nodeId === id) {
            pos.x = newX;
            pos.y = newY;
           }
           
           const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
           if (nodeGroup) {
            nodeGroup.setAttribute("transform", `translate(${newX},${newY})`);
           }
          });
          
          updateMinimap();
          document.querySelectorAll(".edge").forEach((edgeEl) => {
           const fromId = edgeEl.dataset.from;
           const toId = edgeEl.dataset.to;
           if (nodesToMove.includes(fromId) || nodesToMove.includes(toId)) {
            const p1 = savedPositions[fromId] || positions[fromId] || {
             x: 600,
             y: 350
            };
            const p2 = savedPositions[toId] || positions[toId] || {
             x: 600,
             y: 350
            };
            if (edgeEl.tagName === "line") {
             edgeEl.setAttribute("x1", p1.x);
             edgeEl.setAttribute("y1", p1.y);
             edgeEl.setAttribute("x2", p2.x);
             edgeEl.setAttribute("y2", p2.y);
            } else if (edgeEl.tagName === "path") {
             const edgeId = edgeEl.dataset.edgeId;
             const edge = EDGE_DATA.list.find(
              (e) => e.id === edgeId, );
             if (edge) {
              const pairTotal = edge._pairTotal || 1;
              const pairIndex = edge._pairIndex || 0;
              const midX = (p1.x + p2.x) / 2;
              const midY = (p1.y + p2.y) / 2;
              const dx = p2.x - p1.x;
              const dy = p2.y - p1.y;
              const len = Math.sqrt(dx * dx + dy * dy) || 1;
              const perpX = -dy / len;
              const perpY = dx / len;
              let offsetAmount = 0;
              if (pairTotal > 1) {
               offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
              }
              const ctrlX = midX + perpX * offsetAmount;
              const ctrlY = midY + perpY * offsetAmount;
              edgeEl.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
             }
            }
           }
          });
         };
      const handleMouseUp = () => {
      if (isDragging) {
      pushUndo("move nodes");
      isDragging = false;
      g.style.cursor = "grab";
      hitArea.style.cursor = "grab";
      if (currentView.mode === "rack" && NODE_DATA[id]?.assignedRack === currentView.rackId) {
      const draggedY = savedPositions[id]?.y || pos.y;
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      let newUnit = rackCapacity - Math.round((draggedY - RACK_START_Y) / rackUHeight);
      newUnit = Math.max(1, Math.min(newUnit, rackCapacity));
      NODE_DATA[id].rackUnit = newUnit;
      forgeTheTopology();
      claimTheImmortal(id);
      }
      }
      };
         document.addEventListener("mousemove", handleMouseMove);
         document.addEventListener("mouseup", handleMouseUp);
         let touchStartTime = 0;
         let touchStartX = 0;
         let touchStartY = 0;
         let touchMoved = false;
       g.addEventListener("touchstart",
         (e) => {
          if (NODE_DATA[id]?.locked) {
           return;
          }
          
          e.preventDefault();
          touchStartTime = Date.now();
          touchMoved = false;
          const svgEl = document.getElementById("map");
          const pt = svgEl.createSVGPoint();
          const touch = e.touches[0];
          pt.x = touch.clientX;
          pt.y = touch.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          touchStartX = svgP.x;
          touchStartY = svgP.y;
          startX = svgP.x;
          startY = svgP.y;
          
          let nodesToCollect = [];
          if (selectedNodes.has(id)) {
           nodesToCollect = Array.from(selectedNodes);
          } else {
           nodesToCollect = [id];
          }
          
          const groupIds = new Set();
          nodesToCollect.forEach(nodeId => {
           const groupId = NODE_DATA[nodeId]?.groupId;
           if (groupId) {
             groupIds.add(groupId);
           }
          });
          
          if (groupIds.size > 0) {
           Object.keys(NODE_DATA).forEach(nodeId => {
             const nodeGroupId = NODE_DATA[nodeId]?.groupId;
             if (nodeGroupId && groupIds.has(nodeGroupId)) {
               if (!nodesToCollect.includes(nodeId)) {
                 nodesToCollect.push(nodeId);
               }
             }
           });
          }
          
          nodesToCollect = nodesToCollect.filter(nodeId => !NODE_DATA[nodeId]?.locked);
          
          if (nodesToCollect.length === 0) {
           return;
          }
          
          initialPositions = {};
          nodesToCollect.forEach(nodeId => {
           const nodePos = savedPositions[nodeId];
           if (nodePos) {
            initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
           }
          });
          
          e.stopPropagation();
         }, {
          passive: false
         }, );
         g.addEventListener("touchmove", (e) => {
         e.preventDefault();
         const svgEl = document.getElementById("map");
         const pt = svgEl.createSVGPoint();
         const touch = e.touches[0];
         pt.x = touch.clientX;
         pt.y = touch.clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
         const dx = Math.abs(svgP.x - touchStartX);
         const dy = Math.abs(svgP.y - touchStartY);
         if (dx > (isMobileDevice() ? 4 : 10) || dy > (isMobileDevice() ? 4 : 10)) {
      touchMoved = true;
      isDragging = true;
      }
         if (!isDragging) return;
         
         const deltaX = svgP.x - startX;
         const deltaY = svgP.y - startY;
         
         const nodesToMove = selectedNodes.has(id) ? Array.from(selectedNodes) : [id];
         nodesToMove.forEach(nodeId => {
          if (!initialPositions[nodeId]) return;
          const initialPos = initialPositions[nodeId];
          let newX = initialPos.x + deltaX;
          let newY = initialPos.y + deltaY;
          const nodeSize = savedSizes[nodeId] || 55;
          newX = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, newX), );
          newY = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, newY), );
          
          savedPositions[nodeId] = { x: newX, y: newY };
          positions[nodeId] = { x: newX, y: newY };
          
          if (nodeId === id) {
           pos.x = newX;
           pos.y = newY;
          }
          
          const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
          if (nodeGroup) {
           nodeGroup.setAttribute("transform", `translate(${newX},${newY})`);
          }
         });
         
         updateMinimap();
         document.querySelectorAll(".edge").forEach((edgeEl) => {
          const fromId = edgeEl.dataset.from;
          const toId = edgeEl.dataset.to;
          if (nodesToMove.includes(fromId) || nodesToMove.includes(toId)) {
            const p1 = savedPositions[fromId] || positions[fromId] || {
             x: 600,
             y: 350
            };
            const p2 = savedPositions[toId] || positions[toId] || {
             x: 600,
             y: 350
            };
            if (edgeEl.tagName === "line") {
             edgeEl.setAttribute("x1", p1.x);
             edgeEl.setAttribute("y1", p1.y);
             edgeEl.setAttribute("x2", p2.x);
             edgeEl.setAttribute("y2", p2.y);
            } else if (edgeEl.tagName === "path") {
             const edgeId = edgeEl.dataset.edgeId;
             const edge = EDGE_DATA.list.find(
              (e) => e.id === edgeId, );
             if (edge) {
              const pairTotal = edge._pairTotal || 1;
              const pairIndex = edge._pairIndex || 0;
              const midX = (p1.x + p2.x) / 2;
              const midY = (p1.y + p2.y) / 2;
              const dx = p2.x - p1.x;
              const dy = p2.y - p1.y;
              const len = Math.sqrt(dx * dx + dy * dy) || 1;
              const perpX = -dy / len;
              const perpY = dx / len;
              let offsetAmount = 0;
              if (pairTotal > 1) {
               offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
              }
              const ctrlX = midX + perpX * offsetAmount;
              const ctrlY = midY + perpY * offsetAmount;
              edgeEl.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
             }
            }
           }
          });
         }, {
          passive: false
         });
      g.addEventListener("touchend", (e) => {
      const touchDuration = Date.now() - touchStartTime;
      if (!touchMoved && touchDuration < 400) {
      claimTheImmortal(id);
      }
      if (isDragging) {
      const draggedY = pos.y;
      isDragging = false;
      savedPositions[id] = {
      x: pos.x,
      y: pos.y
      };
      if (currentView.mode === "rack" && NODE_DATA[id]?.assignedRack === currentView.rackId) {
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      let newUnit = rackCapacity - Math.round((draggedY - RACK_START_Y) / rackUHeight);
      newUnit = Math.max(1, Math.min(newUnit, rackCapacity));
      NODE_DATA[id].rackUnit = newUnit;
      forgeTheTopology();
      claimTheImmortal(id);
      }
      }
      touchMoved = false;
      });
         g.style.cursor = "grab";
         g.addEventListener("click", (e) => {
          if (!isDragging) {
           claimTheImmortal(id);
          }
         });
         svg.appendChild(g);
        });
        
        if (RECT_DATA && RECT_DATA.list) {
         RECT_DATA.list.forEach((rect) => {
          if (rect.style === "outlined") {
           const g = document.createElementNS(ns, "g");
           g.classList.add("rect-group");
           g.dataset.rectId = rect.id;
           
           const rectEl = document.createElementNS(ns, "rect");
           rectEl.classList.add("rect-shape");
           rectEl.setAttribute("x", rect.x);
           rectEl.setAttribute("y", rect.y);
           rectEl.setAttribute("width", rect.width);
           rectEl.setAttribute("height", rect.height);
           rectEl.style.fill = "none";
           rectEl.style.stroke = rect.color;
           rectEl.style.strokeWidth = "3";
           rectEl.style.cursor = "move";
           
           const deleteBtn = document.createElementNS(ns, "g");
           deleteBtn.classList.add("rect-delete-btn");
           deleteBtn.style.cursor = "pointer";
           deleteBtn.style.display = rectDrawMode ? "block" : "none";
           
           const deleteBg = document.createElementNS(ns, "circle");
           deleteBg.setAttribute("cx", rect.x + rect.width - 10);
           deleteBg.setAttribute("cy", rect.y + 10);
           deleteBg.setAttribute("r", 12);
           deleteBg.style.fill = "#f56565";
           deleteBg.style.stroke = "white";
           deleteBg.style.strokeWidth = "2";
           
           const deleteX = document.createElementNS(ns, "text");
           deleteX.setAttribute("x", rect.x + rect.width - 10);
           deleteX.setAttribute("y", rect.y + 10);
           deleteX.setAttribute("text-anchor", "middle");
           deleteX.setAttribute("dominant-baseline", "middle");
           deleteX.style.fill = "white";
           deleteX.style.fontSize = "16px";
           deleteX.style.fontWeight = "bold";
           deleteX.style.pointerEvents = "none";
           deleteX.textContent = "√ó";
           
           deleteBtn.appendChild(deleteBg);
           deleteBtn.appendChild(deleteX);
           
           deleteBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            e.preventDefault();
            deleteRectangle(rect.id);
           });
           
           let isDragging = false;
           let dragStartX, dragStartY;
           let rectStartX, rectStartY;
           
           rectEl.addEventListener("mousedown", (e) => {
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            dragStartX = e.clientX;
            dragStartY = e.clientY;
            rectStartX = rect.x;
            rectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           });
           
           const moveHandler = (e) => {
            if (!isDragging || rectDrawMode) return;
            const svgEl = svg;
            const pt1 = svgEl.createSVGPoint();
            pt1.x = dragStartX;
            pt1.y = dragStartY;
            const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
            
            const pt2 = svgEl.createSVGPoint();
            pt2.x = e.clientX;
            pt2.y = e.clientY;
            const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
            
            const dx = svgP2.x - svgP1.x;
            const dy = svgP2.y - svgP1.y;
            
            rect.x = rectStartX + dx;
            rect.y = rectStartY + dy;
            
            forgeTheTopology();
           };
           
           const upHandler = () => {
            if (isDragging) {
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           };
           
           document.addEventListener("mousemove", moveHandler);
           document.addEventListener("mouseup", upHandler);
           
           let touchStartX, touchStartY;
           let touchRectStartX, touchRectStartY;
           
           rectEl.addEventListener("touchstart", (e) => {
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchRectStartX = rect.x;
            touchRectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           }, { passive: false });
           
           rectEl.addEventListener("touchmove", (e) => {
            if (!isDragging || rectDrawMode) return;
            if (!e.touches[0]) return;
            e.preventDefault();
            e.stopPropagation();
            
            const svgEl = svg;
            const pt1 = svgEl.createSVGPoint();
            pt1.x = touchStartX;
            pt1.y = touchStartY;
            const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
            
            const touch = e.touches[0];
            const pt2 = svgEl.createSVGPoint();
            pt2.x = touch.clientX;
            pt2.y = touch.clientY;
            const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
            
            const dx = svgP2.x - svgP1.x;
            const dy = svgP2.y - svgP1.y;
            
            rect.x = touchRectStartX + dx;
            rect.y = touchRectStartY + dy;
            
            forgeTheTopology();
           }, { passive: false });
           
           rectEl.addEventListener("touchend", (e) => {
            if (isDragging) {
             e.preventDefault();
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           }, { passive: false });
           
           g.appendChild(rectEl);
           g.appendChild(deleteBtn);
           svg.appendChild(g);
          }
         });
        }
        
        if (TEXT_DATA && TEXT_DATA.list) {
         TEXT_DATA.list.forEach((textItem) => {
          if (currentView.mode === "rack") return;
          
          const g = document.createElementNS(ns, "g");
          g.classList.add("text-group");
          g.dataset.textId = textItem.id;
          
          if (textItem.bgEnabled) {
           const bgRect = document.createElementNS(ns, "rect");
           bgRect.classList.add("text-bg");
      
           bgRect.setAttribute("x", textItem.x - 5);
           bgRect.setAttribute("y", textItem.y - textItem.fontSize - 2);
           bgRect.setAttribute("width", 100);
           bgRect.setAttribute("height", textItem.fontSize + 10);
           bgRect.style.fill = textItem.bgColor;
           bgRect.style.opacity = "0.7";
           bgRect.style.rx = "4";
           g.appendChild(bgRect);
          }
          
          const textEl = document.createElementNS(ns, "text");
          textEl.classList.add("text-element");
          textEl.setAttribute("x", textItem.x);
          textEl.setAttribute("y", textItem.y);
          textEl.style.fill = textItem.color;
          textEl.style.fontSize = textItem.fontSize + "px";
          textEl.style.fontWeight = textItem.fontWeight;
          textEl.style.fontStyle = textItem.fontStyle;
          textEl.style.textAnchor = textItem.textAlign;
          textEl.style.textDecoration = textItem.textDecoration;
          textEl.style.opacity = textItem.opacity;
          textEl.style.cursor = "move";
          textEl.style.userSelect = "none";
          textEl.setAttribute("dominant-baseline", "middle");
          
          const lines = textItem.content.split('\n');
          if (lines.length === 1) {
           textEl.textContent = textItem.content;
          } else {
           lines.forEach((line, i) => {
            const tspan = document.createElementNS(ns, "tspan");
            tspan.textContent = line;
            tspan.setAttribute("x", textItem.x);
            tspan.setAttribute("dy", i === 0 ? 0 : textItem.fontSize * 1.2);
            textEl.appendChild(tspan);
           });
          }
          
          g.appendChild(textEl);
          
          if (textItem.bgEnabled) {
           setTimeout(() => {
            try {
             const bbox = textEl.getBBox();
             const bgRect = g.querySelector('.text-bg');
             if (bgRect && bbox) {
              bgRect.setAttribute("x", bbox.x - 5);
              bgRect.setAttribute("y", bbox.y - 2);
              bgRect.setAttribute("width", bbox.width + 10);
              bgRect.setAttribute("height", bbox.height + 4);
             }
            } catch (e) {
            }
           }, 0);
          }
          
          const deleteBtn = document.createElementNS(ns, "g");
          deleteBtn.classList.add("text-delete-btn");
          deleteBtn.style.cursor = "pointer";
          deleteBtn.style.display = textDrawMode ? "block" : "none";
          
          const deleteBg = document.createElementNS(ns, "circle");
          deleteBg.setAttribute("cx", textItem.x + 20);
          deleteBg.setAttribute("cy", textItem.y - textItem.fontSize);
          deleteBg.setAttribute("r", 12);
          deleteBg.style.fill = "#f56565";
          deleteBg.style.stroke = "white";
          deleteBg.style.strokeWidth = "2";
          
          const deleteX = document.createElementNS(ns, "text");
          deleteX.setAttribute("x", textItem.x + 20);
          deleteX.setAttribute("y", textItem.y - textItem.fontSize);
          deleteX.setAttribute("text-anchor", "middle");
          deleteX.setAttribute("dominant-baseline", "middle");
          deleteX.style.fill = "white";
          deleteX.style.fontSize = "16px";
          deleteX.style.fontWeight = "bold";
          deleteX.style.pointerEvents = "none";
          deleteX.textContent = "√ó";
          
          deleteBtn.appendChild(deleteBg);
          deleteBtn.appendChild(deleteX);
          
          deleteBtn.addEventListener("click", (e) => {
           e.stopPropagation();
           e.preventDefault();
           deleteText(textItem.id);
          });
          
          let isDragging = false;
          let dragStartX, dragStartY;
          let textStartX, textStartY;
          
          textEl.addEventListener("mousedown", (e) => {
           if (textDrawMode) return;
           e.preventDefault();
           e.stopPropagation();
           isDragging = true;
           dragStartX = e.clientX;
           dragStartY = e.clientY;
           textStartX = textItem.x;
           textStartY = textItem.y;
           textEl.style.cursor = "grabbing";
           
           showTextPanel(textItem.id);
          });
          
          const moveHandler = (e) => {
           if (!isDragging || textDrawMode) return;
           const svgEl = svg;
           const pt1 = svgEl.createSVGPoint();
           pt1.x = dragStartX;
           pt1.y = dragStartY;
           const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
           
           const pt2 = svgEl.createSVGPoint();
           pt2.x = e.clientX;
           pt2.y = e.clientY;
           const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
           
           const dx = svgP2.x - svgP1.x;
           const dy = svgP2.y - svgP1.y;
           
           textItem.x = textStartX + dx;
           textItem.y = textStartY + dy;
           
           forgeTheTopology();
          };
          
          const upHandler = () => {
           if (isDragging) {
            isDragging = false;
            textEl.style.cursor = "move";
           }
          };
          
          document.addEventListener("mousemove", moveHandler);
          document.addEventListener("mouseup", upHandler);
          
          let touchStartX = 0, touchStartY = 0;
          let textTouchStartX = 0, textTouchStartY = 0;
          
          textEl.addEventListener("touchstart", (e) => {
           if (textDrawMode) return;
           if (e.touches.length !== 1) return;
           
           e.preventDefault();
           e.stopPropagation();
           const touch = e.touches[0];
           isDragging = true;
           touchStartX = touch.clientX;
           touchStartY = touch.clientY;
           textTouchStartX = textItem.x;
           textTouchStartY = textItem.y;
           
           showTextPanel(textItem.id);
          }, { passive: false });
          
          textEl.addEventListener("touchmove", (e) => {
           if (!isDragging || textDrawMode) return;
           if (e.touches.length !== 1) return;
           
           e.preventDefault();
           const touch = e.touches[0];
           const svgEl = svg;
           
           const pt1 = svgEl.createSVGPoint();
           pt1.x = touchStartX;
           pt1.y = touchStartY;
           const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
           
           const pt2 = svgEl.createSVGPoint();
           pt2.x = touch.clientX;
           pt2.y = touch.clientY;
           const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
           
           const dx = svgP2.x - svgP1.x;
           const dy = svgP2.y - svgP1.y;
           
           textItem.x = textTouchStartX + dx;
           textItem.y = textTouchStartY + dy;
           
           forgeTheTopology();
          }, { passive: false });
          
          textEl.addEventListener("touchend", () => {
           if (isDragging) {
            isDragging = false;
           }
          }, { passive: false });
          
          g.appendChild(deleteBtn);
          svg.appendChild(g);
         });
        }
        
        
        Object.keys(NODE_DATA).forEach(nodeId => {
         updatePingIndicator(nodeId);
        });
        
        forgeTheLegend();
        updateMinimap();
       }
      
       function showEditModal(title, currentValue, onSave) {
        const modal = document.getElementById("edit-modal");
        const input = document.getElementById("modal-input");
        const titleEl = document.getElementById("modal-title");
        const saveBtn = document.getElementById("modal-save");
        const cancelBtn = document.getElementById("modal-cancel");
        titleEl.textContent = title;
        input.value = currentValue;
        modal.classList.add("active");
        input.focus();
        input.select();
        const handleSave = () => {
         if (input.value.trim()) {
          onSave(input.value.trim());
         }
         modal.classList.remove("active");
         saveBtn.removeEventListener("click", handleSave);
         cancelBtn.removeEventListener("click", handleCancel);
         input.removeEventListener("keypress", handleEnter);
        };
        const handleCancel = () => {
         modal.classList.remove("active");
         saveBtn.removeEventListener("click", handleSave);
         cancelBtn.removeEventListener("click", handleCancel);
         input.removeEventListener("keypress", handleEnter);
        };
        const handleEnter = (e) => {
         if (e.key === "Enter") handleSave();
        };
        saveBtn.addEventListener("click", handleSave);
        cancelBtn.addEventListener("click", handleCancel);
        input.addEventListener("keypress", handleEnter);
        modal.addEventListener("click", function bgHandler(e) {
         if (e.target === modal) {
          handleCancel();
          modal.removeEventListener("click", bgHandler);
         }
        });
       }
      
       function challengeTheImmortal(message, onConfirm) {
        const modal = document.getElementById("confirm-modal");
        const messageEl = document.getElementById("confirm-message");
        const deleteBtn = document.getElementById("confirm-delete");
        const cancelBtn = document.getElementById("confirm-cancel");
        messageEl.textContent = message;
        modal.classList.add("active");
        const handleConfirm = () => {
         onConfirm();
         modal.classList.remove("active");
         deleteBtn.removeEventListener("click", handleConfirm);
         cancelBtn.removeEventListener("click", handleCancel);
        };
        const handleCancel = () => {
         modal.classList.remove("active");
         deleteBtn.removeEventListener("click", handleConfirm);
         cancelBtn.removeEventListener("click", handleCancel);
        };
        deleteBtn.addEventListener("click", handleConfirm);
        cancelBtn.addEventListener("click", handleCancel);
        modal.addEventListener("click", function bgHandler(e) {
         if (e.target === modal) {
          handleCancel();
          modal.removeEventListener("click", bgHandler);
         }
        });
       }
       const pageTitleEl = document.getElementById("page-title");
       if (pageTitleEl) {
        pageTitleEl.addEventListener("click", () => {
         showEditModal("Edit Title", PAGE_STATE.title || DEFAULT_PAGE_STATE.title,
          (newTitle) => {
           PAGE_STATE.title = newTitle;
           wieldThePower();
          }, );
        });
       }
      
       function editNodeName(id) {
        if (!NODE_DATA[id]) return;
        showEditModal("Edit Name", NODE_DATA[id].name, (newName) => {
         if (!NODE_DATA[id]) return;
         NODE_DATA[id].name = newName;
         const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`, );
         if (nodeGroup) {
          const label = nodeGroup.querySelector(".node-label");
          if (label) label.textContent = newName;
         }
         if (currentNodeId === id) {
          document.getElementById("node-name").textContent = newName;
         }
        });
       }
      
       function editNodeIp(id) {
        if (!NODE_DATA[id]) return;
        showEditModal("Edit IP/Subtitle", NODE_DATA[id].ip, (newIp) => {
         if (!NODE_DATA[id]) return;
         NODE_DATA[id].ip = newIp;
         const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`, );
         if (nodeGroup) {
          const sub = nodeGroup.querySelector(".node-sub");
          if (sub) sub.textContent = newIp;
         }
         if (currentNodeId === id) {
          document.getElementById("node-ip").textContent = newIp;
         }
        });
       }
      
       function claimTheImmortal(id) {
        if (!NODE_DATA[id]) return;
        currentNodeId = id;
        currentEdgeId = null;
        const data = NODE_DATA[id];
        document.querySelectorAll(".node-group").forEach((n) => {
         n.classList.toggle("active", n.dataset.nodeId === id);
        });
        document.querySelectorAll(".edge").forEach((e) => {
         const active = e.dataset.from === id || e.dataset.to === id;
         e.classList.toggle("active", active);
        });
        document.getElementById("node-panel").style.display = "block";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        const toolbar = document.getElementById("topology-toolbar");
        if (!topologyToolbarCollapsed) {
         toolbar.style.display = "flex";
        }
        updateTopologyToolbarVisibility();
        document.getElementById("node-name").textContent = data.name;
        document.getElementById("node-ip").textContent = data.ip;
        document.getElementById("node-mac").textContent = data.mac || "--";
        document.getElementById("node-rack").textContent = data.rackUnit || "--";
        document.getElementById("node-uheight").textContent = (data.uHeight || "1") + "U";
        document.getElementById("node-role").textContent = data.role;
      
        populateRackDropdown();
        const assignedRackSelect = document.getElementById("node-assigned-rack");
        if (assignedRackSelect) {
         assignedRackSelect.value = data.assignedRack || "";
        }
        
        const rackCapacitySelect = document.getElementById("node-rack-capacity");
        if (rackCapacitySelect) {
         rackCapacitySelect.value = data.rackCapacity || "42";
        }
        
        const isRack = data.isRack === true;
        const isAssignedToRack = !!data.assignedRack;
        const assignedRackRow = document.getElementById("assigned-rack-row");
        const rackCapacityRow = document.getElementById("rack-capacity-row");
        const uheightRow = document.getElementById("uheight-row");
        if (assignedRackRow) assignedRackRow.style.display = isRack ? "none" : "flex";
        if (rackCapacityRow) rackCapacityRow.style.display = isRack ? "flex" : "none";
        if (uheightRow) uheightRow.style.display = isAssignedToRack ? "flex" : "none";
        
        document.getElementById("node-name").onclick = () => editNodeName(id);
        document.getElementById("node-ip").onclick = () => editNodeIp(id);
        document.getElementById("node-mac").onclick = () => editNodeMac(id);
        document.getElementById("node-rack").onclick = () => editNodeRack(id);
        document.getElementById("node-uheight").onclick = () => editNodeUHeight(id);
        const currentSize = savedSizes[id] || getDefaultSize();
        document.getElementById("size-slider").value = currentSize;
        document.getElementById("size-value").textContent = currentSize;
        const styleEntry = savedStyles[id] || {};
        const resolvedStyles = resolveStylesEntry(styleEntry);
        const scopeKey = currentStyleScope || "all";
        const flatProps = ["circleColor", "circleBorder", "titleColor", "titleFont", "titleSize", "subColor", "subFont", "subSize", ];
        const isFlat = flatProps.some((p) => Object.prototype.hasOwnProperty.call(styleEntry, p), );
        const scopedStyles = isFlat ? styleEntry : styleEntry[scopeKey] || {};
        const circleColorInput = document.getElementById("circle-color");
        const titleColorInput = document.getElementById("title-color");
        const titleFontSelect = document.getElementById("title-font");
        const titleSizeInput = document.getElementById("title-size");
        const subColorInput = document.getElementById("sub-color");
        const subFontSelect = document.getElementById("sub-font");
        const subSizeInput = document.getElementById("sub-size");
        const shapeSelect = document.getElementById("shape-select");
        const scopeSelect = document.getElementById("style-scope");
        circleColorInput.value = scopedStyles.circleColor || resolvedStyles.circleColor || "#1e293b";
        const circleBorderInput = document.getElementById("circle-border");
        circleBorderInput.value = scopedStyles.circleBorder || resolvedStyles.circleBorder || "#475569";
        titleColorInput.value = scopedStyles.titleColor || resolvedStyles.titleColor || "#e2e8f0";
        titleFontSelect.value = scopedStyles.titleFont || resolvedStyles.titleFont || "system-ui, sans-serif";
        titleSizeInput.value = scopedStyles.titleSize || resolvedStyles.titleSize || 18;
        subColorInput.value = scopedStyles.subColor || resolvedStyles.subColor || "#94a3b8";
        subFontSelect.value = scopedStyles.subFont || resolvedStyles.subFont || "system-ui, sans-serif";
        subSizeInput.value = scopedStyles.subSize || resolvedStyles.subSize || 13;
        shapeSelect.value = data.shape || "circle";
        scopeSelect.value = currentStyleScope || "all";
        document.getElementById("title-offset-y").value = scopedStyles.titleOffsetY || resolvedStyles.titleOffsetY || 0;
        document.getElementById("title-offset-x").value = scopedStyles.titleOffsetX || resolvedStyles.titleOffsetX || 0;
        document.getElementById("sub-offset-y").value = scopedStyles.subOffsetY || resolvedStyles.subOffsetY || 0;
        document.getElementById("sub-offset-x").value = scopedStyles.subOffsetX || resolvedStyles.subOffsetX || 0;
      
      const pingOffsetXInput = document.getElementById("ping-offset-x");
      const pingOffsetYInput = document.getElementById("ping-offset-y");
      
      if (pingOffsetXInput && pingOffsetYInput) {
      pingOffsetXInput.value =
       (scopedStyles.pingOffsetX !== undefined
         ? scopedStyles.pingOffsetX
         : (resolvedStyles.pingOffsetX !== undefined
             ? resolvedStyles.pingOffsetX
             : 0));
      
      pingOffsetYInput.value =
       (scopedStyles.pingOffsetY !== undefined
         ? scopedStyles.pingOffsetY
         : (resolvedStyles.pingOffsetY !== undefined
             ? resolvedStyles.pingOffsetY
             : 0));
      }
        const tagEl = document.getElementById("node-tags");
        tagEl.innerHTML = "";
        data.tags.forEach((tag, i) => {
         const b = document.createElement("span");
         b.className = "badge";
         const isIconTag = typeof tag === 'object' && tag.type === 'icon';
         if (!isIconTag && typeof tag === 'string' && tag.toLowerCase().includes("wg")) b.classList.add("wg");
         b.style.cursor = "pointer";
         b.style.position = "relative";
         const tagContent = document.createElement("span");
         if (isIconTag) {
          b.classList.add("icon-badge");
          IconLibrary.getIcon(tag.library, tag.name).then(svgText => {
           if (svgText) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(svgText, 'image/svg+xml');
            const svgEl = doc.querySelector('svg');
            if (svgEl) {
             svgEl.setAttribute('width', '16');
             svgEl.setAttribute('height', '16');
             tagContent.innerHTML = '';
             tagContent.appendChild(svgEl);
             const nameSpan = document.createElement('span');
             nameSpan.textContent = tag.name;
             nameSpan.style.marginLeft = '4px';
             tagContent.appendChild(nameSpan);
            }
           }
          });
         } else {
          tagContent.textContent = tag;
          tagContent.addEventListener("click", (e) => {
           e.stopPropagation();
           showEditModal("Edit Tag", tag, (newTag) => {
            if (newTag) {
             data.tags[i] = newTag;
             claimTheImmortal(id);
            }
           });
          });
         }
         const deleteTag = document.createElement("span");
         deleteTag.textContent = " ‚úï";
         deleteTag.style.opacity = "0.6";
         deleteTag.style.marginLeft = "4px";
         deleteTag.style.fontSize = "10px";
         deleteTag.addEventListener("click", (e) => {
          e.stopPropagation();
          data.tags.splice(i, 1);
          claimTheImmortal(id);
         });
         b.append(tagContent, deleteTag);
         tagEl.append(b);
        });
        const addTagBtn = document.createElement("span");
        addTagBtn.className = "badge";
        addTagBtn.style.cursor = "pointer";
        addTagBtn.style.opacity = "0.6";
        addTagBtn.style.borderStyle = "dashed";
        addTagBtn.textContent = "+ Add";
        addTagBtn.addEventListener("click", () => {
         showEditModal("Add Tag(s) : comma separated", "",
          (newTagStr) => {
           if (newTagStr) {
            const newTags = newTagStr.split(",").map((t) => t.trim()).filter((t) => t);
            newTags.forEach((t) => data.tags.push(t));
            claimTheImmortal(id);
           }
          }, );
        });
        tagEl.append(addTagBtn);
        const notesEl = document.getElementById("node-notes");
        notesEl.innerHTML = "";
        data.notes.forEach((note, i) => {
         const li = document.createElement("li");
         const noteText = document.createElement("span");
         noteText.textContent = note;
         noteText.style.flex = "1";
         const deleteBtn = document.createElement("span");
         deleteBtn.className = "delete-note";
         deleteBtn.textContent = "‚úï";
         deleteBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          challengeTheImmortal("Are you sure you want to delete this note?",
           () => {
            data.notes.splice(i, 1);
            claimTheImmortal(id);
           }, );
         });
         li.append(noteText, deleteBtn);
         noteText.addEventListener("dblclick", () => {
          noteText.classList.add("editing");
          noteText.contentEditable = true;
          noteText.focus();
         });
         noteText.addEventListener("blur", () => {
          noteText.classList.remove("editing");
          noteText.contentEditable = false;
          data.notes[i] = noteText.textContent;
         });
         notesEl.append(li);
        });
        const addLineSelect = document.getElementById("add-line-select");
      addLineSelect.innerHTML = "";
      const currentRack = data.assignedRack || "";
      Object.entries(NODE_DATA).forEach(([nodeId, node]) => {
      if (nodeId !== id) {
      const nodeRack = node.assignedRack || "";
      if (currentRack === nodeRack) {
      const opt = document.createElement("option");
      opt.value = nodeId;
      opt.textContent = node.name;
      addLineSelect.appendChild(opt);
      }
      }
      });
        
        const pingEnabled = data.ping && data.ping.enabled;
        document.getElementById('node-pingable').checked = pingEnabled;
        document.getElementById('node-ping-options').style.display = pingEnabled ? 'block' : 'none';
        
        if (data.ping) {
         document.getElementById('node-ping-protocol').value = data.ping.protocol || 'http';
         document.getElementById('node-custom-url').value = data.ping.customUrl || '';
         document.getElementById('node-ping-timeout').value = data.ping.timeout || 3000;
         document.getElementById('node-custom-url-container').style.display = 
          data.ping.protocol === 'custom' ? 'block' : 'none';
         
         updatePingStatusDisplay(id);
        }
       }
      
       function updatePingStatusDisplay(nodeId) {
        const data = NODE_DATA[nodeId];
        if (!data || !data.ping) return;
        
        const statusEl = document.getElementById('node-ping-status');
        const lastCheckEl = document.getElementById('node-ping-last-check');
        
        const statusColors = {
         online: 'var(--accent)',
         offline: 'var(--danger)',
         checking: '#f59e0b',
         unknown: 'var(--text-soft)'
        };
        
        const statusTexts = {
         online: '‚óè Online',
         offline: '‚óè Offline',
         checking: '‚óè Checking...',
         unknown: '‚óè Unknown'
        };
        
        statusEl.textContent = statusTexts[data.ping.status] || statusTexts.unknown;
        statusEl.style.color = statusColors[data.ping.status] || statusColors.unknown;
        
        if (data.ping.lastCheck) {
         const checkTime = new Date(data.ping.lastCheck);
         lastCheckEl.textContent = `Last checked: ${checkTime.toLocaleTimeString()}`;
        } else {
         lastCheckEl.textContent = 'Never checked';
        }
       }
      
       function selectTheConnection(id) {
        currentEdgeId = id;
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "block";
        document.getElementById("text-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.display = "none";
        document.querySelectorAll(".node-group").forEach((n) => n.classList.remove("active"));
        document.querySelectorAll(".edge").forEach((e) => {
         e.classList.toggle("active", e.dataset.edgeId === id);
        });
        const edge = EDGE_DATA.list.find((e) => e.id === id);
        if (!edge) return;
        const directionSymbols = {
         none: "‚áÑ",
         forward: "‚Üí",
         backward: "‚Üê",
         both: "‚Üî",
        };
        const dirSymbol = directionSymbols[edge.direction] || "‚áÑ";
        let titleText = "Custom line";
        if (edge.from || edge.to) {
         const fromName = edge.from ? NODE_DATA[edge.from]?.name || edge.from : "";
         const toName = edge.to ? NODE_DATA[edge.to]?.name || edge.to : "";
         titleText = `${fromName || "?"} ${dirSymbol} ${toName || "?"}`;
        }
        document.getElementById("edge-title").textContent = titleText;
        const widthInput = document.getElementById("edge-width");
        const colorInput = document.getElementById("edge-color");
        const directionSelect = document.getElementById("edge-direction");
        const lineStyleSelect = document.getElementById("edge-line-style");
        widthInput.value = edge.width;
        colorInput.value = edge.color;
        directionSelect.value = edge.direction || "none";
        lineStyleSelect.value = edge.lineStyle || "solid";
        
        const fromPortInput = document.getElementById("edge-from-port");
        const toPortInput = document.getElementById("edge-to-port");
        const portFieldsFrom = document.getElementById("edge-port-fields");
        const portFieldsTo = document.getElementById("edge-port-fields-to");
        
        if (edge.type === "custom") {
         if (portFieldsFrom) portFieldsFrom.style.display = "none";
         if (portFieldsTo) portFieldsTo.style.display = "none";
        } else {
         if (portFieldsFrom) portFieldsFrom.style.display = "flex";
         if (portFieldsTo) portFieldsTo.style.display = "flex";
         if (fromPortInput) {
          fromPortInput.value = edge.fromPort || "";
          fromPortInput.onchange = () => updateEdgePortLabels(id);
         }
         if (toPortInput) {
          toPortInput.value = edge.toPort || "";
          toPortInput.onchange = () => updateEdgePortLabels(id);
         }
        }
        
        const list = document.getElementById("edge-notes");
        list.innerHTML = "";
        edge.notes.forEach((note, i) => {
         const li = document.createElement("li");
         const txt = document.createElement("span");
         txt.textContent = note;
         txt.style.flex = "1";
         const del = document.createElement("span");
         del.className = "delete-note";
         del.textContent = "‚úï";
         del.addEventListener("click", (e) => {
          e.stopPropagation();
          challengeTheImmortal("Delete this line note?", () => {
           edge.notes.splice(i, 1);
           saveEdgeData();
           selectTheConnection(id);
          });
         });
         txt.addEventListener("dblclick", () => {
          txt.classList.add("editing");
          txt.contentEditable = true;
          txt.focus();
         });
         txt.addEventListener("blur", () => {
          txt.classList.remove("editing");
          txt.contentEditable = false;
          edge.notes[i] = txt.textContent;
          saveEdgeData();
         });
         li.append(txt, del);
         list.appendChild(li);
        });
       }
       window.addEventListener("resize", () => {
        forgeTheTopology();
        if (currentEdgeId) {
         selectTheConnection(currentEdgeId);
        } else if (currentNodeId && NODE_DATA[currentNodeId]) {
         claimTheImmortal(currentNodeId);
        } else {
         const availableNodes = Object.keys(NODE_DATA);
         if (availableNodes.length > 0) {
          claimTheImmortal(availableNodes[0]);
         }
        }
       });
       (function initZoomPan() {
        const viewport = document.getElementById("canvas-viewport");
        const svg = document.getElementById("map");
        const hint = document.getElementById("canvas-hint");
        setTimeout(() => {
         hint.classList.add("visible");
         setTimeout(() => hint.classList.remove("visible"), 4000);
        }, 1000);
        viewport.addEventListener("wheel",
         (e) => {
          e.preventDefault();
          const rect = viewport.getBoundingClientRect();
          const mouseX = (e.clientX - rect.left) / rect.width;
          const mouseY = (e.clientY - rect.top) / rect.height;
          const delta = e.deltaY > 0 ? 0.9 : 1.1;
          zoomTo(canvasState.zoom * delta, mouseX, mouseY);
         }, {
          passive: false
         }, );
        let initialPinchDistance = 0;
        let initialPinchZoom = 1;
        let pinchCenter = {
         x: 0.5,
         y: 0.5
        };
        viewport.addEventListener("touchstart",
         (e) => {
          if (e.touches.length === 2) {
           e.preventDefault();
           const touch1 = e.touches[0];
           const touch2 = e.touches[1];
           initialPinchDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY, );
           initialPinchZoom = canvasState.zoom;
           const rect = viewport.getBoundingClientRect();
           const centerX = (touch1.clientX + touch2.clientX) / 2;
           const centerY = (touch1.clientY + touch2.clientY) / 2;
           pinchCenter.x = (centerX - rect.left) / rect.width;
           pinchCenter.y = (centerY - rect.top) / rect.height;
          }
         }, {
          passive: false
         }, );
        viewport.addEventListener("touchmove",
         (e) => {
          if (e.touches.length === 2) {
           e.preventDefault();
           const touch1 = e.touches[0];
           const touch2 = e.touches[1];
           const currentDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY, );
           if (initialPinchDistance > 0) {
            const scale = currentDistance / initialPinchDistance;
            const newZoom = initialPinchZoom * scale;
            zoomTo(newZoom, pinchCenter.x, pinchCenter.y);
           }
          }
         }, {
          passive: false
         }, );
        let panStartViewX = 0;
        let panStartViewY = 0;
        
        let lastEmptyTapTime = 0;
        let emptyTapTimeout = null;
        let emptyTapMoved = false;
        
        viewport.addEventListener("touchend", (e) => {
          if (currentView.mode !== "rack") return;
          
          if (e.changedTouches.length !== 1) return;
          
          const isEmptySpace = e.target === svg || e.target === viewport || e.target.tagName === "svg";
          if (!isEmptySpace) return;
          
          if (emptyTapMoved) {
            emptyTapMoved = false;
            return;
          }
          
          const currentTime = new Date().getTime();
          const tapGap = currentTime - lastEmptyTapTime;
          
          if (tapGap < 300 && tapGap > 0) {
            e.preventDefault();
            
            exitRack();
            
            if (navigator.vibrate) {
              navigator.vibrate(50);
            }
            
            lastEmptyTapTime = 0;
            if (emptyTapTimeout) {
              clearTimeout(emptyTapTimeout);
              emptyTapTimeout = null;
            }
          } else {
            lastEmptyTapTime = currentTime;
            
            if (emptyTapTimeout) clearTimeout(emptyTapTimeout);
            emptyTapTimeout = setTimeout(() => {
              lastEmptyTapTime = 0;
            }, 300);
          }
        }, { passive: false });
        
        viewport.addEventListener("mousedown", (e) => {
         if (e.target.closest(".draw-toolbar") || e.target.closest(".topology-toolbar") || e.target.closest(".legend-container")) {
          return;
         }
         if (freeDrawMode || rectDrawMode) {
          return;
         }
         const isEmptySpace = e.target === svg || e.target === viewport || e.target.tagName === "svg";
         if (isEmptySpace || e.button === 2 || e.button === 1) {
          e.preventDefault();
          canvasState.isPanning = true;
          canvasState.panStartX = e.clientX;
          canvasState.panStartY = e.clientY;
          panStartViewX = canvasState.panX;
          panStartViewY = canvasState.panY;
          viewport.classList.add("panning");
         }
        });
        viewport.addEventListener("touchstart",
         (e) => {
          if (e.target.closest(".draw-toolbar") || e.target.closest(".topology-toolbar") || e.target.closest(".legend-container")) {
           return;
          }
          if (freeDrawMode || rectDrawMode) {
           return;
          }
          const isEmptySpace = e.target === svg || e.target === viewport || e.target.tagName === "svg";
          if (isEmptySpace && e.touches.length === 1) {
           e.preventDefault();
           emptyTapMoved = false;
           canvasState.isPanning = true;
           canvasState.panStartX = e.touches[0].clientX;
           canvasState.panStartY = e.touches[0].clientY;
           panStartViewX = canvasState.panX;
           panStartViewY = canvasState.panY;
           viewport.classList.add("panning");
          }
         }, {
          passive: false
         }, );
        document.addEventListener("mousemove", (e) => {
         if (!canvasState.isPanning) return;
         const dx = e.clientX - canvasState.panStartX;
         const dy = e.clientY - canvasState.panStartY;
         const rect = viewport.getBoundingClientRect();
         const viewWidth = CANVAS_WIDTH / canvasState.zoom;
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         const canvasDx = (dx / rect.width) * viewWidth;
         const canvasDy = (dy / rect.height) * viewHeight;
         canvasState.panX = panStartViewX - canvasDx;
         canvasState.panY = panStartViewY - canvasDy;
         constrainPan();
         updateViewBox();
        });
        document.addEventListener("touchmove", (e) => {
         if (!canvasState.isPanning || !e.touches[0]) return;
         emptyTapMoved = true; 
         const dx = e.touches[0].clientX - canvasState.panStartX;
         const dy = e.touches[0].clientY - canvasState.panStartY;
         const rect = viewport.getBoundingClientRect();
         const viewWidth = CANVAS_WIDTH / canvasState.zoom;
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         const canvasDx = (dx / rect.width) * viewWidth;
         const canvasDy = (dy / rect.height) * viewHeight;
         canvasState.panX = panStartViewX - canvasDx;
         canvasState.panY = panStartViewY - canvasDy;
         constrainPan();
         updateViewBox();
        });
        document.addEventListener("mouseup", () => {
         if (canvasState.isPanning) {
          canvasState.isPanning = false;
          viewport.classList.remove("panning");
         }
        });
        document.addEventListener("touchend", () => {
         if (canvasState.isPanning) {
          canvasState.isPanning = false;
          viewport.classList.remove("panning");
         }
        });
        document.addEventListener("keydown", (e) => {
         const isEditing = document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "TEXTAREA" || document.activeElement.isContentEditable;
         if (e.code === "Space" && !e.repeat && !isEditing) {
          e.preventDefault();
          canvasState.spacePressed = true;
          viewport.style.cursor = "grab";
         }
        });
        document.addEventListener("keyup", (e) => {
         if (e.code === "Space") {
          canvasState.spacePressed = false;
          viewport.style.cursor = "";
         }
        });
        document.getElementById("zoom-in-btn").addEventListener("click", () => {
         zoomTo(canvasState.zoom * 1.25, 0.5, 0.5);
        });
        document.getElementById("zoom-out-btn").addEventListener("click", () => {
         zoomTo(canvasState.zoom * 0.8, 0.5, 0.5);
        });
        document.getElementById("zoom-fit-btn").addEventListener("click", fitToContent);
        document.getElementById("zoom-reset-btn").addEventListener("click", resetView);
        const minimapContainer = document.getElementById("minimap-container");
        const minimapSvg = document.getElementById("minimap");
        let minimapDragging = false;
        minimapContainer.addEventListener("mousedown", (e) => {
         e.preventDefault();
         minimapDragging = true;
         updatePanFromMinimap(e);
        });
        minimapContainer.addEventListener("touchstart",
         (e) => {
          e.preventDefault();
          minimapDragging = true;
          updatePanFromMinimapTouch(e);
         }, {
          passive: false
         }, );
        document.addEventListener("mousemove", (e) => {
         if (minimapDragging) {
          updatePanFromMinimap(e);
         }
        });
        document.addEventListener("touchmove", (e) => {
         if (minimapDragging && e.touches[0]) {
          updatePanFromMinimapTouch(e);
         }
        });
        document.addEventListener("mouseup", () => {
         minimapDragging = false;
        });
        document.addEventListener("touchend", () => {
         minimapDragging = false;
        });
      
        function updatePanFromMinimap(e) {
         const rect = minimapContainer.getBoundingClientRect();
         const x = (e.clientX - rect.left) / rect.width;
         const y = (e.clientY - rect.top) / rect.height;
         const viewWidth = CANVAS_WIDTH / canvasState.zoom;
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         canvasState.panX = x * CANVAS_WIDTH - viewWidth / 2;
         canvasState.panY = y * CANVAS_HEIGHT - viewHeight / 2;
         constrainPan();
         updateViewBox();
        }
      
        function updatePanFromMinimapTouch(e) {
         const rect = minimapContainer.getBoundingClientRect();
         const touch = e.touches[0];
         const x = (touch.clientX - rect.left) / rect.width;
         const y = (touch.clientY - rect.top) / rect.height;
         const viewWidth = CANVAS_WIDTH / canvasState.zoom;
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         canvasState.panX = x * CANVAS_WIDTH - viewWidth / 2;
         canvasState.panY = y * CANVAS_HEIGHT - viewHeight / 2;
         constrainPan();
         updateViewBox();
        }
        document.addEventListener("keydown", (e) => {
         if (document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "TEXTAREA") return;
         if (
          (e.key === "+" || e.key === "=") && (e.ctrlKey || e.metaKey)) {
          e.preventDefault();
          zoomTo(canvasState.zoom * 1.25, 0.5, 0.5);
         } else if (e.key === "-" && (e.ctrlKey || e.metaKey)) {
          e.preventDefault();
          zoomTo(canvasState.zoom * 0.8, 0.5, 0.5);
         } else if (e.key === "0" && (e.ctrlKey || e.metaKey)) {
          e.preventDefault();
          resetView();
         }
        });
        setTimeout(() => {
         fitToContent();
        }, 100);
       })();
       const sizeSlider = document.getElementById("size-slider");
       const sizeValue = document.getElementById("size-value");
       const resetSizeBtn = document.getElementById("reset-size");
       sizeSlider.addEventListener("input", () => {
        const newSize = parseInt(sizeSlider.value, 10);
        sizeValue.textContent = newSize;
        savedSizes[currentNodeId] = newSize;
        const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
        if (nodeGroup) {
         const oldShape = nodeGroup.querySelector(".node-circle");
         if (oldShape) oldShape.remove();
         const newShape = createNodeShape(currentNodeId, newSize);
         nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
         const styles = resolveStylesForNode(currentNodeId);
         if (styles.circleColor) newShape.style.fill = styles.circleColor;
		 if (styles.circleBorder) newShape.style.stroke = styles.circleBorder;
         const label = nodeGroup.querySelector(".node-label");
         const sub = nodeGroup.querySelector(".node-sub");
         if (label) {
          label.setAttribute("y", -newSize * 0.28);
          const labelSize = styles.titleSize || newSize * 0.33;
          label.style.fontSize = labelSize + "px";
         }
         if (sub) {
          sub.setAttribute("y", newSize * 0.4);
          const subSize = styles.subSize || newSize * 0.24;
          sub.style.fontSize = subSize + "px";
         }
       updatePingIndicator(currentNodeId);
        }
       });
       resetSizeBtn.addEventListener("click", () => {
        delete savedSizes[currentNodeId];
        const defaultSize = getDefaultSize();
        sizeSlider.value = defaultSize;
        sizeValue.textContent = defaultSize;
        const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
        if (nodeGroup) {
         const oldShape = nodeGroup.querySelector(".node-circle");
         if (oldShape) oldShape.remove();
         const shapeType = (NODE_DATA[currentNodeId] && NODE_DATA[currentNodeId].shape) || "circle";
         const newShape = createNodeShape(currentNodeId, defaultSize);
         nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
         const styles = resolveStylesForNode(currentNodeId);
         if (styles.circleColor) newShape.style.fill = styles.circleColor;
		 if (styles.circleBorder) newShape.style.stroke = styles.circleBorder;
         const label = nodeGroup.querySelector(".node-label");
         const sub = nodeGroup.querySelector(".node-sub");
         if (label) {
          label.setAttribute("y", -defaultSize * 0.28);
          const labelSize = styles.titleSize || defaultSize * 0.33;
          label.style.fontSize = labelSize + "px";
         }
         if (sub) {
          sub.setAttribute("y", defaultSize * 0.4);
          const subSize = styles.subSize || defaultSize * 0.24;
          sub.style.fontSize = subSize + "px";
         }
          updatePingIndicator(currentNodeId);
      
        }
       });
       const applyStyle = (property, value) => {
        const styleEntry = ensureStyleEntry(currentNodeId);
        const scopeKey = currentStyleScope || "all";
        if (!styleEntry[scopeKey]) styleEntry[scopeKey] = {};
        styleEntry[scopeKey][property] = value;
        const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
        if (!nodeGroup) return;
        const shapeEl = nodeGroup.querySelector(".node-circle");
        const label = nodeGroup.querySelector(".node-label");
        const sub = nodeGroup.querySelector(".node-sub");
        if (property === "circleColor" && shapeEl) shapeEl.style.fill = value;
		else if (property === "circleBorder" && shapeEl) shapeEl.style.stroke = value;
        else if (property === "titleColor" && label) label.style.fill = value;
        else if (property === "titleFont" && label) label.style.fontFamily = value;
        else if (property === "titleSize" && label) label.style.fontSize = value + "px";
        else if (property === "subColor" && sub) sub.style.fill = value;
        else if (property === "subFont" && sub) sub.style.fontFamily = value;
        else if (property === "subSize" && sub) sub.style.fontSize = value + "px";
       };
       document.getElementById("circle-color").addEventListener("input", (e) => applyStyle("circleColor", e.target.value), );
	   document.getElementById("circle-border").addEventListener("input", (e) => applyStyle("circleBorder", e.target.value), );
       document.getElementById("title-color").addEventListener("input", (e) => applyStyle("titleColor", e.target.value), );
       document.getElementById("title-font").addEventListener("change", (e) => applyStyle("titleFont", e.target.value), );
       document.getElementById("title-size").addEventListener("input", (e) => applyStyle("titleSize", parseInt(e.target.value, 10)), );
       document.getElementById("sub-color").addEventListener("input", (e) => applyStyle("subColor", e.target.value), );
       document.getElementById("sub-font").addEventListener("change", (e) => applyStyle("subFont", e.target.value), );
       document.getElementById("sub-size").addEventListener("input", (e) => applyStyle("subSize", parseInt(e.target.value, 10)), );
       document.getElementById("title-offset-y").addEventListener("input", (e) => {
        applyStyle("titleOffsetY", parseInt(e.target.value, 10) || 0);
        forgeTheTopology();
        if (currentNodeId) claimTheImmortal(currentNodeId);
       });
       document.getElementById("title-offset-x").addEventListener("input", (e) => {
        applyStyle("titleOffsetX", parseInt(e.target.value, 10) || 0);
        forgeTheTopology();
        if (currentNodeId) claimTheImmortal(currentNodeId);
       });
       document.getElementById("sub-offset-y").addEventListener("input", (e) => {
        applyStyle("subOffsetY", parseInt(e.target.value, 10) || 0);
        forgeTheTopology();
        if (currentNodeId) claimTheImmortal(currentNodeId);
       });
       document.getElementById("sub-offset-x").addEventListener("input", (e) => {
        applyStyle("subOffsetX", parseInt(e.target.value, 10) || 0);
        forgeTheTopology();
        if (currentNodeId) claimTheImmortal(currentNodeId);
       });
      document.getElementById("ping-offset-x").addEventListener("input", (e) => {
      applyStyle("pingOffsetX", parseInt(e.target.value, 10) || 0);
      updatePingIndicator(currentNodeId);
      if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      
      document.getElementById("ping-offset-y").addEventListener("input", (e) => {
      applyStyle("pingOffsetY", parseInt(e.target.value, 10) || 0);
      updatePingIndicator(currentNodeId);
      if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      
       document.getElementById("reset-styles").addEventListener("click", () => {
        delete savedStyles[currentNodeId];
        forgeTheTopology();
        claimTheImmortal(currentNodeId);
       });
       document.getElementById("style-scope").addEventListener("change", (e) => {
        currentStyleScope = e.target.value || "all";
        claimTheImmortal(currentNodeId);
       });
       document.getElementById("shape-select").addEventListener("change", (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId]) return;
        const shape = e.target.value || "circle";
        NODE_DATA[currentNodeId].shape = shape;
        const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
        if (!nodeGroup) return;
        const oldShape = nodeGroup.querySelector(".node-circle");
        if (oldShape) oldShape.remove();
        const size = savedSizes[currentNodeId] || getDefaultSize();
        const newShape = createNodeShape(currentNodeId, size);
        nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
       });
       const addNoteBtn = document.getElementById("add-note-btn");
       const noteInput = document.getElementById("new-note-input");
       addNoteBtn.addEventListener("click", () => {
        const newNote = noteInput.value.trim();
        if (newNote && currentNodeId && NODE_DATA[currentNodeId]) {
         NODE_DATA[currentNodeId].notes.push(newNote);
         claimTheImmortal(currentNodeId);
         noteInput.value = "";
        }
       });
       noteInput.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
         addNoteBtn.click();
        }
       });
       
       document.getElementById('node-pingable').addEventListener('change', (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId]) return;
        if (!NODE_DATA[currentNodeId].ping) {
         NODE_DATA[currentNodeId].ping = {
          enabled: false,
          protocol: 'http',
          customUrl: '',
          timeout: 3000,
          status: 'unknown',
          lastCheck: null
         };
        }
        NODE_DATA[currentNodeId].ping.enabled = e.target.checked;
        document.getElementById('node-ping-options').style.display = e.target.checked ? 'block' : 'none';
        forgeTheTopology();
       });
       
       document.getElementById('node-ping-protocol').addEventListener('change', (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId].ping) return;
        NODE_DATA[currentNodeId].ping.protocol = e.target.value;
        document.getElementById('node-custom-url-container').style.display = 
         e.target.value === 'custom' ? 'block' : 'none';
       });
       
       document.getElementById('node-custom-url').addEventListener('change', (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId].ping) return;
        NODE_DATA[currentNodeId].ping.customUrl = e.target.value.trim();
       });
       
       document.getElementById('node-ping-timeout').addEventListener('change', (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId].ping) return;
        NODE_DATA[currentNodeId].ping.timeout = parseInt(e.target.value) || 3000;
       });
       
       document.getElementById('check-ping-now').addEventListener('click', () => {
        if (!currentNodeId) return;
        checkNodeStatus(currentNodeId);
       });
       
       document.getElementById("edge-width").addEventListener("input", () => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        const v = parseInt(document.getElementById("edge-width").value, 10);
        if (Number.isNaN(v) || v <= 0) return;
        edge.width = v;
        saveEdgeData();
        const el = document.querySelector(`.edge[data-edge-id="${currentEdgeId}"]`, );
        if (el) el.style.strokeWidth = v;
       });
       document.getElementById("edge-color").addEventListener("input", () => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        const color = document.getElementById("edge-color").value;
        edge.color = color;
        saveEdgeData();
        const el = document.querySelector(`.edge[data-edge-id="${currentEdgeId}"]`, );
        if (el) el.style.stroke = color;
        forgeTheLegend();
       });
       document.getElementById("edge-direction").addEventListener("change", () => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        edge.direction = document.getElementById("edge-direction").value;
        saveEdgeData();
        forgeTheTopology();
        selectTheConnection(currentEdgeId);
       });
       document.getElementById("edge-line-style").addEventListener("change", () => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        edge.lineStyle = document.getElementById("edge-line-style").value;
        saveEdgeData();
        forgeTheTopology();
        selectTheConnection(currentEdgeId);
       });
       const addEdgeNoteBtn = document.getElementById("add-edge-note");
       const newEdgeNoteInput = document.getElementById("new-edge-note");
       addEdgeNoteBtn.addEventListener("click", () => {
        const txt = newEdgeNoteInput.value.trim();
        if (!txt || !currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        edge.notes.push(txt);
        saveEdgeData();
        newEdgeNoteInput.value = "";
        selectTheConnection(currentEdgeId);
       });
       newEdgeNoteInput.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
         addEdgeNoteBtn.click();
        }
       });
       document.getElementById("delete-edge").addEventListener("click", () => {
        if (!currentEdgeId) return;
        challengeTheImmortal("Are you sure you want to delete this line?",
         () => {
          EDGE_DATA.list = EDGE_DATA.list.filter(
           (e) => e.id !== currentEdgeId, );
          saveEdgeData();
          currentEdgeId = null;
          forgeTheTopology();
          const availableNodes = Object.keys(NODE_DATA);
          if (availableNodes.length > 0) {
           claimTheImmortal(availableNodes[0]);
          } else {
           document.getElementById("node-panel").style.display = "none";
           document.getElementById("edge-panel").style.display = "none";
           document.getElementById("topology-toolbar", ).style.display = "none";
          }
         }, );
       });
       document.getElementById("add-line-btn").addEventListener("click", () => {
        if (!currentNodeId) return;
        const select = document.getElementById("add-line-select");
        const directionSelect = document.getElementById("add-line-direction");
        const colorInput = document.getElementById("add-line-color");
        const targetId = select.value;
        if (!targetId || targetId === currentNodeId) return;
        const direction = directionSelect.value || "none";
        const lineColor = colorInput.value || "#475569";
        const newId = `${currentNodeId}-${targetId}-${Date.now()}`;
        const newEdge = {
         id: newId,
         from: currentNodeId,
         to: targetId,
         width: 4,
         color: lineColor,
         direction: direction,
         type: "main",
         notes: [],
         fromPort: "",
         toPort: "",
        };
        EDGE_DATA.list.push(newEdge);
        saveEdgeData();
        forgeTheTopology();
        claimTheImmortal(currentNodeId);
       });
       let freeDrawMode = false;
       let rectDrawMode = false;
       let currentTextId = null;
       let rectStartPoint = null;
       let rectPreviewEl = null;
       let rectStyle = "filled";
       let freeDrawPoints = [];
       let freeDrawPolylineEl = null;
       let freeDrawPointEls = [];
       const drawToggleBtn = document.getElementById("draw-toggle");
       const drawUndoBtn = document.getElementById("draw-undo");
       const drawColorInput = document.getElementById("draw-color");
       const drawStyleSelect = document.getElementById("draw-style");
       const drawArrowSelect = document.getElementById("draw-arrow");
       const svgMap = document.getElementById("map");
      
       function updateFreeDrawGraphics() {
        const ns = "http://www.w3.org/2000/svg";
        const svg = svgMap;
        if (!freeDrawPolylineEl && freeDrawPoints.length > 0) {
         freeDrawPolylineEl = document.createElementNS(ns, "polyline");
         freeDrawPolylineEl.classList.add("edge", "free-preview");
         freeDrawPolylineEl.setAttribute("fill", "none");
         svg.appendChild(freeDrawPolylineEl);
        }
        if (freeDrawPolylineEl) {
         if (freeDrawPoints.length === 0) {
          freeDrawPolylineEl.remove();
          freeDrawPolylineEl = null;
         } else {
          const ptsStr = freeDrawPoints.map((p) => `${p.x},${p.y}`).join(" ");
          freeDrawPolylineEl.setAttribute("points", ptsStr);
          freeDrawPolylineEl.style.stroke = drawColorInput.value || "#475569";
          freeDrawPolylineEl.style.strokeWidth = 3;
          const lineStyle = drawStyleSelect.value || "solid";
          if (lineStyle === "dashed") {
           freeDrawPolylineEl.style.strokeDasharray = "10,5";
          } else if (lineStyle === "dotted") {
           freeDrawPolylineEl.style.strokeDasharray = "2,4";
          } else {
           freeDrawPolylineEl.style.strokeDasharray = "none";
          }
         }
        }
        freeDrawPointEls.forEach((el) => el.remove());
        freeDrawPointEls = [];
        freeDrawPoints.forEach((p, idx) => {
         const c = document.createElementNS(ns, "circle");
         c.classList.add("free-point");
         c.setAttribute("cx", p.x);
         c.setAttribute("cy", p.y);
         c.setAttribute("r", 5);
         c.dataset.index = String(idx);
         c.addEventListener("mousedown", (e) => {
          if (!freeDrawMode) return;
          e.preventDefault();
          e.stopPropagation();
          let dragging = true;
          const svgEl = svgMap;
          const moveHandler = (ev) => {
           if (!dragging) return;
           const pt = svgEl.createSVGPoint();
           pt.x = ev.clientX;
           pt.y = ev.clientY;
           const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
           const i = parseInt(c.dataset.index, 10);
           if (Number.isNaN(i) || !freeDrawPoints[i]) return;
           freeDrawPoints[i].x = svgP.x;
           freeDrawPoints[i].y = svgP.y;
           updateFreeDrawGraphics();
          };
          const upHandler = () => {
           dragging = false;
           document.removeEventListener("mousemove", moveHandler);
           document.removeEventListener("mouseup", upHandler);
          };
          document.addEventListener("mousemove", moveHandler);
          document.addEventListener("mouseup", upHandler);
         });
         c.addEventListener("touchstart",
          (e) => {
           if (!freeDrawMode) return;
           e.preventDefault();
           e.stopPropagation();
           let dragging = true;
           const svgEl = svgMap;
           const touchMoveHandler = (ev) => {
            if (!dragging || !ev.touches[0]) return;
            const pt = svgEl.createSVGPoint();
            pt.x = ev.touches[0].clientX;
            pt.y = ev.touches[0].clientY;
            const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
            const i = parseInt(c.dataset.index, 10);
            if (Number.isNaN(i) || !freeDrawPoints[i]) return;
            freeDrawPoints[i].x = svgP.x;
            freeDrawPoints[i].y = svgP.y;
            updateFreeDrawGraphics();
           };
           const touchUpHandler = () => {
            dragging = false;
            document.removeEventListener("touchmove", touchMoveHandler, );
            document.removeEventListener("touchend", touchUpHandler, );
           };
           document.addEventListener("touchmove", touchMoveHandler);
           document.addEventListener("touchend", touchUpHandler);
          }, {
           passive: false
          }, );
         svg.appendChild(c);
         freeDrawPointEls.push(c);
        });
        drawUndoBtn.style.display = freeDrawPoints.length ? "inline-block" : "none";
       }
      
       function addFreeDrawPoint(x, y) {
        freeDrawPoints.push({
         x,
         y
        });
        updateFreeDrawGraphics();
       }
      
       function startFreeDraw() {
        freeDrawMode = true;
        freeDrawPoints = [];
        if (freeDrawPolylineEl) {
         freeDrawPolylineEl.remove();
         freeDrawPolylineEl = null;
        }
        freeDrawPointEls.forEach((el) => el.remove());
        freeDrawPointEls = [];
        svgMap.style.cursor = "crosshair";
        drawToggleBtn.textContent = "Done";
        drawUndoBtn.style.display = "none";
       }
      
       function finishFreeDraw() {
        freeDrawMode = false;
        svgMap.style.cursor = "";
        drawToggleBtn.textContent = "‚úèÔ∏è";
        if (freeDrawPoints.length >= 2) {
         const color = drawColorInput.value || "#475569";
         const lineStyle = drawStyleSelect.value || "solid";
         const arrowDir = drawArrowSelect.value || "none";
         const newId = "custom-" + Date.now();
         const pointsCopy = freeDrawPoints.map((p) => ({
          x: p.x,
          y: p.y,
         }));
         EDGE_DATA.list.push({
          id: newId,
          type: "custom",
          color,
          width: 4,
          lineStyle: lineStyle,
          direction: arrowDir,
          points: pointsCopy,
          notes: [],
         });
         saveEdgeData();
         freeDrawPoints = [];
         if (freeDrawPolylineEl) {
          freeDrawPolylineEl.remove();
          freeDrawPolylineEl = null;
         }
         freeDrawPointEls.forEach((el) => el.remove());
         freeDrawPointEls = [];
         forgeTheTopology();
         selectTheConnection(newId);
        } else {
         freeDrawPoints = [];
         if (freeDrawPolylineEl) {
          freeDrawPolylineEl.remove();
          freeDrawPolylineEl = null;
         }
         freeDrawPointEls.forEach((el) => el.remove());
         freeDrawPointEls = [];
         forgeTheLegend();
        }
        drawUndoBtn.style.display = "none";
       }
       drawToggleBtn.addEventListener("click", () => {
        if (currentView.mode === "rack") {
         alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
         return;
        }
        
        if (freeDrawMode) {
         finishFreeDraw();
        } else {
         startFreeDraw();
        }
       });
       drawUndoBtn.addEventListener("click", () => {
        if (!freeDrawMode || !freeDrawPoints.length) return;
        freeDrawPoints.pop();
        updateFreeDrawGraphics();
       });
       const drawToolbar = document.getElementById("draw-toolbar");
       drawToolbar.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       drawToolbar.addEventListener("click", (e) => {
        if (e.target !== drawToggleBtn && e.target !== drawUndoBtn) {
         e.stopPropagation();
        }
       });
       drawStyleSelect.addEventListener("change", () => {
        if (freeDrawMode) {
         updateFreeDrawGraphics();
        }
       });
       drawArrowSelect.addEventListener("change", () => {
        if (freeDrawMode) {
         updateFreeDrawGraphics();
        }
       });
       drawColorInput.addEventListener("input", () => {
        if (freeDrawMode) {
         updateFreeDrawGraphics();
        }
       });
       drawStyleSelect.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       drawStyleSelect.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       drawArrowSelect.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       drawArrowSelect.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       drawColorInput.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       drawColorInput.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       svgMap.addEventListener("click", (e) => {
        if (!freeDrawMode) return;
        if (e.button !== 0) return;
        const target = e.target;
        if (target && target.classList && target.classList.contains("free-point")) return;
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        addFreeDrawPoint(svgP.x, svgP.y);
       });
       svgMap.addEventListener("touchend",
        (e) => {
         if (!freeDrawMode) return;
         const target = e.target;
         if (target && target.classList && target.classList.contains("free-point")) return;
         if (e.changedTouches && e.changedTouches[0]) {
          e.preventDefault();
          const svgEl = svgMap;
          const pt = svgEl.createSVGPoint();
          pt.x = e.changedTouches[0].clientX;
          pt.y = e.changedTouches[0].clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          addFreeDrawPoint(svgP.x, svgP.y);
         }
        }, {
         passive: false
        }, );
       const settingsBtn = document.getElementById("settings-btn");
      
       const rectToggleBtn = document.getElementById("rect-toggle");
       const rectStyleSelect = document.getElementById("rect-style");
      
       function updateRectPreview() {
        if (!rectPreviewEl || !rectStartPoint) return;
        
        const ns = "http://www.w3.org/2000/svg";
        const svg = svgMap;
        
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
       }
      
       function startRectDraw() {
        rectDrawMode = true;
        rectStartPoint = null;
        rectPreviewEl = null;
        svgMap.style.cursor = "crosshair";
        rectToggleBtn.textContent = "Done";
        rectStyle = rectStyleSelect.value || "filled";
        
        if (freeDrawMode) {
         finishFreeDraw();
        }
        updateRectangleDeleteButtons();
       }
      
       function finishRectDraw() {
        rectDrawMode = false;
        svgMap.style.cursor = "";
        rectToggleBtn.textContent = "‚ñ≠";
        
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
       }
        updateRectangleDeleteButtons();
      
       rectToggleBtn.addEventListener("click", () => {
        if (currentView.mode === "rack") {
         alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
         return;
        }
        
        if (rectDrawMode) {
         finishRectDraw();
        } else {
         startRectDraw();
        }
       });
      
       rectStyleSelect.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       rectStyleSelect.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       rectStyleSelect.addEventListener("change", () => {
        if (rectDrawMode) {
         rectStyle = rectStyleSelect.value || "filled";
        }
       });
      
       svgMap.addEventListener("mousedown", (e) => {
        if (!rectDrawMode) return;
        if (e.button !== 0) return;
        e.preventDefault();
        e.stopPropagation();
        
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        rectStartPoint = { x: svgP.x, y: svgP.y };
        
        const ns = "http://www.w3.org/2000/svg";
        rectPreviewEl = document.createElementNS(ns, "rect");
        rectPreviewEl.classList.add("rect-preview");
        rectPreviewEl.setAttribute("x", svgP.x);
        rectPreviewEl.setAttribute("y", svgP.y);
        rectPreviewEl.setAttribute("width", 0);
        rectPreviewEl.setAttribute("height", 0);
        
        const color = drawColorInput.value || "#f97316";
        rectPreviewEl.style.stroke = color;
        rectPreviewEl.style.strokeWidth = 2;
        rectPreviewEl.style.strokeDasharray = "5,5";
        
        if (rectStyle === "filled") {
         rectPreviewEl.style.fill = color;
         rectPreviewEl.style.fillOpacity = "0.3";
        } else {
         rectPreviewEl.style.fill = "none";
        }
        
        svgEl.appendChild(rectPreviewEl);
       });
      
       svgMap.addEventListener("mousemove", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        
        rectPreviewEl.setAttribute("x", x);
        rectPreviewEl.setAttribute("y", y);
        rectPreviewEl.setAttribute("width", width);
        rectPreviewEl.setAttribute("height", height);
       });
      
       svgMap.addEventListener("mouseup", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        
        if (width > 10 && height > 10) {
      pushUndo("draw rectangle"); 
         const color = drawColorInput.value || "#f97316";
         const newId = "rect-" + Date.now();
         
         RECT_DATA.list.push({
          id: newId,
          x: x,
          y: y,
          width: width,
          height: height,
          color: color,
          style: rectStyle,
          notes: []
         });
         
         forgeTheTopology();
        }
        
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
       });
      
       let rectTouchStart = null;
       
       svgMap.addEventListener("touchstart", (e) => {
        if (!rectDrawMode) return;
        if (e.touches.length !== 1) return;
        
        e.preventDefault();
        const touch = e.touches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        rectStartPoint = { x: svgP.x, y: svgP.y };
        rectTouchStart = { x: svgP.x, y: svgP.y };
        
        const ns = "http://www.w3.org/2000/svg";
        rectPreviewEl = document.createElementNS(ns, "rect");
        rectPreviewEl.classList.add("rect-preview");
        rectPreviewEl.setAttribute("x", svgP.x);
        rectPreviewEl.setAttribute("y", svgP.y);
        rectPreviewEl.setAttribute("width", 0);
        rectPreviewEl.setAttribute("height", 0);
        
        const color = drawColorInput.value || "#f97316";
        rectPreviewEl.style.stroke = color;
        rectPreviewEl.style.strokeWidth = 2;
        rectPreviewEl.style.strokeDasharray = "5,5";
        
        if (rectStyle === "filled") {
         rectPreviewEl.style.fill = color;
         rectPreviewEl.style.fillOpacity = "0.3";
        } else {
         rectPreviewEl.style.fill = "none";
        }
        
        svgEl.appendChild(rectPreviewEl);
       }, { passive: false });
      
       svgMap.addEventListener("touchmove", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        if (e.touches.length !== 1) return;
        
        e.preventDefault();
        const touch = e.touches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        
        rectPreviewEl.setAttribute("x", x);
        rectPreviewEl.setAttribute("y", y);
        rectPreviewEl.setAttribute("width", width);
        rectPreviewEl.setAttribute("height", height);
       }, { passive: false });
      
       svgMap.addEventListener("touchend", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        if (!rectTouchStart) return;
        
        e.preventDefault();
        const touch = e.changedTouches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        
        if (width > 10 && height > 10) {
      pushUndo("draw rectangle");
         const color = drawColorInput.value || "#f97316";
         const newId = "rect-" + Date.now();
         
         RECT_DATA.list.push({
          id: newId,
          x: x,
          y: y,
          width: width,
          height: height,
          color: color,
          style: rectStyle,
          notes: []
         });
         
         forgeTheTopology();
        }
        
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
        rectTouchStart = null;
       }, { passive: false });
      
       const textToggleBtn = document.getElementById("text-toggle");
       
       function startTextMode() {
        textDrawMode = true;
        svgMap.style.cursor = "crosshair";
        textToggleBtn.textContent = "Done";
        textToggleBtn.style.background = "var(--accent)";
        textToggleBtn.style.color = "var(--bg)";
        
        if (freeDrawMode) {
         finishFreeDraw();
        }
        if (rectDrawMode) {
         finishRectDraw();
        }
        
        updateTextDeleteButtons();
       }
       
       function finishTextMode() {
        textDrawMode = false;
        svgMap.style.cursor = "";
        textToggleBtn.textContent = "T";
        textToggleBtn.style.background = "";
        textToggleBtn.style.color = "";
        updateTextDeleteButtons();
       }
       
       textToggleBtn.addEventListener("click", () => {
        if (currentView.mode === "rack") {
         alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
         return;
        }
        
        if (textDrawMode) {
         finishTextMode();
        } else {
         startTextMode();
        }
       });
       
       function handleTextPlacement(e) {
        if (!textDrawMode) return;
        
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        const newId = "text-" + Date.now();
      pushUndo("add text");
        TEXT_DATA.list.push({
         id: newId,
         x: svgP.x,
         y: svgP.y,
         content: "New Text",
         fontSize: 18,
         color: "#e2e8f0",
         fontWeight: "normal",
         fontStyle: "normal",
         textAlign: "start",
         textDecoration: "none",
         bgColor: "#000000",
         bgEnabled: false,
         opacity: 1
        });
        
        forgeTheTopology();
        
        showTextPanel(newId);
       }
       
       svgMap.addEventListener("click", (e) => {
        if (!textDrawMode) return;
        if (e.target.closest('.text-delete-btn')) return;
        if (e.target.closest('.text-group')) return;
        
        e.preventDefault();
        e.stopPropagation();
        handleTextPlacement(e);
       });
       
       svgMap.addEventListener("touchend", (e) => {
        if (!textDrawMode) return;
        if (e.target.closest('.text-delete-btn')) return;
        if (e.target.closest('.text-group')) return;
        if (e.touches.length > 0) return;
        
        e.preventDefault();
        const touch = e.changedTouches[0];
        const fakeEvent = {
         clientX: touch.clientX,
         clientY: touch.clientY,
         preventDefault: () => {},
         stopPropagation: () => {}
        };
        handleTextPlacement(fakeEvent);
       }, { passive: false });
       
       function showTextPanel(textId) {
        currentTextId = textId;
        const textItem = TEXT_DATA.list.find(t => t.id === textId);
        if (!textItem) return;
        
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        
        const textPanel = document.getElementById("text-panel");
        textPanel.style.display = "block";
        
        document.getElementById("text-content").value = textItem.content;
        document.getElementById("text-font-size").value = textItem.fontSize;
        document.getElementById("text-color").value = textItem.color;
        document.getElementById("text-font-weight").value = textItem.fontWeight;
        document.getElementById("text-font-style").value = textItem.fontStyle;
        document.getElementById("text-align").value = textItem.textAlign;
        document.getElementById("text-decoration").value = textItem.textDecoration;
        document.getElementById("text-bg-color").value = textItem.bgColor;
        document.getElementById("text-bg-enabled").checked = textItem.bgEnabled;
        document.getElementById("text-opacity").value = textItem.opacity;
        document.getElementById("text-opacity-val").textContent = Math.round(textItem.opacity * 100) + "%";
       }
       
       function updateTextDeleteButtons() {
        const deleteButtons = document.querySelectorAll('.text-delete-btn');
        deleteButtons.forEach(btn => {
         btn.style.display = textDrawMode ? 'block' : 'none';
        });
       }
       
       function deleteText(textId) {
      pushUndo("delete text");
        TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== textId);
        forgeTheTopology();
        
        if (currentTextId === textId) {
         document.getElementById("text-panel").style.display = "none";
         currentTextId = null;
        }
       }
       
       document.getElementById("text-content").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
      pushUndo("edit text");
         textItem.content = e.target.value;
         forgeTheTopology();
        }
       });
       
       document.getElementById("text-font-size").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         textItem.fontSize = parseInt(e.target.value);
         forgeTheTopology();
        }
       });
       
       document.getElementById("text-color").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         textItem.color = e.target.value;
         forgeTheTopology();
        }
       });
       
       document.getElementById("text-font-weight").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         textItem.fontWeight = e.target.value;
         forgeTheTopology();
        }
       });
       
       document.getElementById("text-font-style").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         textItem.fontStyle = e.target.value;
         forgeTheTopology();
        }
       });
       
       document.getElementById("text-align").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         textItem.textAlign = e.target.value;
         forgeTheTopology();
        }
       });
       
       document.getElementById("text-decoration").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         textItem.textDecoration = e.target.value;
         forgeTheTopology();
        }
       });
       
       document.getElementById("text-bg-color").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         textItem.bgColor = e.target.value;
         forgeTheTopology();
        }
       });
       
       document.getElementById("text-bg-enabled").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         textItem.bgEnabled = e.target.checked;
         forgeTheTopology();
        }
       });
       
       document.getElementById("text-opacity").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         textItem.opacity = parseFloat(e.target.value);
         document.getElementById("text-opacity-val").textContent = Math.round(textItem.opacity * 100) + "%";
         forgeTheTopology();
        }
       });
       
       document.getElementById("delete-text").addEventListener("click", () => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         challengeTheImmortal(`Delete text "${textItem.content.substring(0, 30)}..."?`, () => {
          deleteText(currentTextId);
         });
        }
       });
      
       const settingsModal = document.getElementById("settings-modal");
       const settingsClose = document.getElementById("settings-close");
       settingsBtn.addEventListener("click", () => {	 
      document.getElementById("page-bg-color").value = rgbaToHex(PAGE_STATE.background) || "#050608";
        document.getElementById("topbar-bg-color").value = rgbaToHex(PAGE_STATE.topbarBg) || "#0b0e13";
        document.getElementById("topbar-border-color").value = rgbaToHex(PAGE_STATE.topbarBorder) || "#1f2533";	 
      document.getElementById("panel-color").value = rgbaToHex(PAGE_STATE.panel) || "#0b0e13";
      document.getElementById("panel-alt-color").value = rgbaToHex(PAGE_STATE.panelAlt) || "#10141b";
      document.getElementById("accent-color").value = rgbaToHex(PAGE_STATE.accent) || "#4fd1c5";
      document.getElementById("danger-color").value = rgbaToHex(PAGE_STATE.danger) || "#f56565";
      document.getElementById("text-main-color").value = rgbaToHex(PAGE_STATE.textMain) || "#e2e8f0";
      document.getElementById("text-soft-color").value = rgbaToHex(PAGE_STATE.textSoft) || "#94a3b8";
      
        
        document.getElementById("auto-ping-enabled").checked = autoPingEnabled;
        document.getElementById("auto-ping-interval").value = autoPingInterval;
        document.getElementById("auto-ping-settings").style.display = autoPingEnabled ? 'block' : 'none';
        
        settingsModal.classList.add("active");
       });
       settingsClose.addEventListener("click", () => {
        settingsModal.classList.remove("active");
       });
       settingsModal.addEventListener("click", (e) => {
        if (e.target === settingsModal) {
         settingsModal.classList.remove("active");
        }
       });
       document.getElementById("page-bg-color").addEventListener("input", (e) => {
        PAGE_STATE.background = e.target.value;
        wieldThePower();
       });
       document.getElementById("topbar-bg-color").addEventListener("input", (e) => {
        PAGE_STATE.topbarBg = e.target.value;
        wieldThePower();
       });
       document.getElementById("topbar-border-color").addEventListener("input", (e) => {
        PAGE_STATE.topbarBorder = e.target.value;
        wieldThePower();
       });
       document.getElementById("panel-color").addEventListener("input", (e) => {
        PAGE_STATE.panel = e.target.value;
        wieldThePower();
       });
       document.getElementById("panel-alt-color").addEventListener("input", (e) => {
        PAGE_STATE.panelAlt = e.target.value;
        wieldThePower();
       });
       document.getElementById("accent-color").addEventListener("input", (e) => {
        PAGE_STATE.accent = e.target.value;
        wieldThePower();
       });
       document.getElementById("danger-color").addEventListener("input", (e) => {
        PAGE_STATE.danger = e.target.value;
        wieldThePower();
       });
       document.getElementById("text-main-color").addEventListener("input", (e) => {
        PAGE_STATE.textMain = e.target.value;
        wieldThePower();
       });
       document.getElementById("text-soft-color").addEventListener("input", (e) => {
        PAGE_STATE.textSoft = e.target.value;
        wieldThePower();
       });
       
       (function initializeResizers() {
         const headerResizer = document.getElementById('header-resizer');
         const sidebarResizer = document.getElementById('sidebar-resizer');
         const mobileFooterResizer = document.getElementById('mobile-footer-resizer');
         
         let isResizing = false;
         let currentResizer = null;
         let startY = 0;
         let startX = 0;
         let startHeight = 0;
         let startWidth = 0;
         
         function getClientPos(e) {
           if (e.touches && e.touches.length > 0) {
             return { x: e.touches[0].clientX, y: e.touches[0].clientY };
           }
           return { x: e.clientX, y: e.clientY };
         }
         
         function startResize(resizer, type, e) {
           isResizing = true;
           currentResizer = type;
           const pos = getClientPos(e);
           
           if (type === 'header') {
             startY = pos.y;
             startHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--topbar-height'));
           } else if (type === 'sidebar') {
             startX = pos.x;
             startWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width'));
           } else if (type === 'mobile-footer') {
             startY = pos.y;
             const currentVh = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--mobile-footer-height'));
             startHeight = (currentVh / 100) * window.innerHeight;
           }
           
           resizer.classList.add('resizing');
           document.body.classList.add('resizing');
           document.body.style.cursor = (type === 'sidebar') ? 'col-resize' : 'row-resize';
           e.preventDefault();
         }
         
         if (headerResizer) {
           headerResizer.addEventListener('mousedown', (e) => startResize(headerResizer, 'header', e));
           headerResizer.addEventListener('touchstart', (e) => startResize(headerResizer, 'header', e), { passive: false });
         }
         
         if (sidebarResizer) {
           sidebarResizer.addEventListener('mousedown', (e) => startResize(sidebarResizer, 'sidebar', e));
           sidebarResizer.addEventListener('touchstart', (e) => startResize(sidebarResizer, 'sidebar', e), { passive: false });
         }
         
         if (mobileFooterResizer) {
           mobileFooterResizer.addEventListener('mousedown', (e) => startResize(mobileFooterResizer, 'mobile-footer', e));
           mobileFooterResizer.addEventListener('touchstart', (e) => startResize(mobileFooterResizer, 'mobile-footer', e), { passive: false });
         }
         
         function handleMove(e) {
           if (!isResizing) return;
           
           const pos = getClientPos(e);
           
           if (currentResizer === 'header') {
             const deltaY = pos.y - startY;
             const newHeight = Math.max(40, Math.min(150, startHeight + deltaY));
             document.documentElement.style.setProperty('--topbar-height', newHeight + 'px');
           } else if (currentResizer === 'sidebar') {
             const deltaX = startX - pos.x;
             const newWidth = Math.max(200, Math.min(800, startWidth + deltaX));
             document.documentElement.style.setProperty('--sidebar-width', newWidth + 'px');
           } else if (currentResizer === 'mobile-footer') {
             const deltaY = startY - pos.y;
             const newHeight = startHeight + deltaY;
             const newVh = Math.max(15, Math.min(80, (newHeight / window.innerHeight) * 100));
             document.documentElement.style.setProperty('--mobile-footer-height', newVh + 'vh');
           }
           
           e.preventDefault();
         }
         
         document.addEventListener('mousemove', handleMove);
         document.addEventListener('touchmove', handleMove, { passive: false });
         
         function handleEnd() {
           if (isResizing) {
             isResizing = false;
             
             if (currentResizer === 'header') {
               PAGE_STATE.topbarHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--topbar-height'));
               headerResizer.classList.remove('resizing');
             } else if (currentResizer === 'sidebar') {
               PAGE_STATE.sidebarWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width'));
               sidebarResizer.classList.remove('resizing');
             } else if (currentResizer === 'mobile-footer') {
               PAGE_STATE.mobileFooterHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--mobile-footer-height'));
               mobileFooterResizer.classList.remove('resizing');
             }
             
             document.body.classList.remove('resizing');
             document.body.style.cursor = '';
             currentResizer = null;
           }
         }
         
         document.addEventListener('mouseup', handleEnd);
         document.addEventListener('touchend', handleEnd);
         document.addEventListener('touchcancel', handleEnd);
       })();
       
       document.getElementById("auto-ping-enabled").addEventListener("change", (e) => {
        autoPingEnabled = e.target.checked;
        PAGE_STATE.autoPingEnabled = autoPingEnabled;
        document.getElementById("auto-ping-settings").style.display = autoPingEnabled ? 'block' : 'none';
        
        if (autoPingEnabled) {
         startAutoPing();
        } else {
         stopAutoPing();
        }
       });
       
       document.getElementById("auto-ping-interval").addEventListener("change", (e) => {
        const newInterval = parseInt(e.target.value, 10);
        if (newInterval >= 5 && newInterval <= 3600) {
         autoPingInterval = newInterval;
         PAGE_STATE.autoPingInterval = autoPingInterval;
         
         if (autoPingEnabled) {
          startAutoPing();
         }
        }
       });
       
       document.getElementById("export-data-btn").addEventListener("click", () => {
        const data = captureTheQuickening();
        const jsonStr = JSON.stringify(data, null, 2);
        const blob = new Blob([jsonStr], {
         type: "application/json"
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        const safeTitle = (PAGE_STATE.title || "network-topology").toLowerCase().replace(/[^a-z0-9\-]+/g, "-");
        const timestamp = new Date().toISOString().split("T")[0];
        a.download = `${safeTitle}-data-${timestamp}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
       });
       document.getElementById("import-data-btn").addEventListener("click", () => {
        document.getElementById("import-data-file").click();
       });
       document.getElementById("import-data-file").addEventListener("change", async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        try {
         const text = await file.text();
         const data = JSON.parse(text);
         if (!data.nodeData || !data.edgeData) {
          alert("Invalid data file. Missing required fields.");
          return;
         }
         const confirmMsg = `This will replace all current data with the imported data.\n\nImporting:\n- ${Object.keys(data.nodeData).length} nodes\n- ${data.edgeData.list?.length || 0} connections\n\nContinue?`;
         if (!confirm(confirmMsg)) {
          e.target.value = "";
          return;
         }
         NODE_DATA = data.nodeData || {};
         EDGE_DATA = data.edgeData || {
          list: []
         };
         EDGE_LEGEND = data.edgeLegend || {};
         RECT_DATA = data.rectData || { list: [] };
         TEXT_DATA = data.textData || { list: [] };
         savedPositions = data.nodePositions || {};
         savedSizes = data.nodeSizes || {};
         savedStyles = data.nodeStyles || {};
         if (data.page) {
          PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, data.page, );
          wieldThePower();
         }
      
      if (data.autoPingEnabled !== undefined) {
      autoPingEnabled = data.autoPingEnabled;
      PAGE_STATE.autoPingEnabled = autoPingEnabled;
      document.getElementById("auto-ping-enabled").checked = autoPingEnabled;
      }
      
      if (data.autoPingInterval !== undefined) {
      autoPingInterval = data.autoPingInterval;
      PAGE_STATE.autoPingInterval = autoPingInterval;
      document.getElementById("auto-ping-interval").value = autoPingInterval;
      }
         if (data.canvas) {
          canvasState.zoom = data.canvas.zoom || 1;
          canvasState.panX = data.canvas.panX || 0;
          canvasState.panY = data.canvas.panY || 0;
         }
         if (data.page?.title) {
          document.title = data.page.title;
          document.querySelector(".editable-page-title", ).textContent = data.page.title;
         }
         forgeTheTopology();
         forgeTheLegend();
         updateViewBox();
      
      if (autoPingEnabled) {
      startAutoPing();
      } else {
      stopAutoPing();
      }
      
         const nodeIds = Object.keys(NODE_DATA);
         if (nodeIds.length > 0) {
          claimTheImmortal(nodeIds[0]);
         } else {
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("topology-toolbar").style.display = "none";
         }
         alert("Data imported successfully!");
         e.target.value = "";
        } catch (err) {
         console.error("Import error:", err);
         alert(`Failed to import data: ${err.message}`);
         e.target.value = "";
        }
       });
       const saveHelpBtn = document.getElementById("save-help-btn");
       const saveInfoModal = document.getElementById("save-info-modal");
       const saveInfoClose = document.getElementById("save-info-close");
       saveHelpBtn.addEventListener("click", () => {
        saveInfoModal.classList.add("active");
       });
       saveInfoClose.addEventListener("click", () => {
        saveInfoModal.classList.remove("active");
       });
       saveInfoModal.addEventListener("click", (e) => {
        if (e.target === saveInfoModal) {
         saveInfoModal.classList.remove("active");
        }
       });
       async function deriveKey(password, salt) {
      const encoder = new TextEncoder();
      
      const keyMaterial = await crypto.subtle.importKey(
      "raw",
      encoder.encode(password),
      "PBKDF2",
      false,
      ["deriveKey"]
      );
      
      return crypto.subtle.deriveKey(
      {
      name: "PBKDF2",
      salt: salt,
      iterations: 200000,  
      hash: "SHA-256"
      },
      keyMaterial,
      {
      name: "AES-GCM",
      length: 256
      },
      false,
      ["encrypt", "decrypt"]
      );
      }
      
       async function encryptData(data, password) {
      const encoder = new TextEncoder();
      const salt = crypto.getRandomValues(new Uint8Array(16));
      const iv   = crypto.getRandomValues(new Uint8Array(12));
      
      const key = await deriveKey(password, salt);
      const encrypted = await crypto.subtle.encrypt(
      { name: "AES-GCM", iv },
      key,
      encoder.encode(data)
      );
      
      const encryptedU8 = new Uint8Array(encrypted);
      
      const result = new Uint8Array(salt.length + iv.length + encryptedU8.length);
      result.set(salt, 0);
      result.set(iv, salt.length);
      result.set(encryptedU8, salt.length + iv.length);
      
      return "ENCRYPTED:" + u8ToBase64(result);
      }
      
       async function decryptData(encryptedData, password) {
      const base64Data = encryptedData.replace("ENCRYPTED:", "");
      const fullData   = base64ToU8(base64Data);
      
      const salt      = fullData.slice(0, 16);
      const iv        = fullData.slice(16, 28);
      const encrypted = fullData.slice(28);
      
      const key = await deriveKey(password, salt);
      
      const decrypted = await crypto.subtle.decrypt(
      { name: "AES-GCM", iv },
      key,
      encrypted
      );
      
      const decoder = new TextDecoder();
      return decoder.decode(decrypted);
      }
      
      
       function isEncrypted(data) {
        return typeof data === "string" && data.startsWith("ENCRYPTED:");
       }
      
       function captureTheQuickening() {
      const currentTab = documentTabs[currentTabIndex];
      currentTab.nodes = JSON.parse(JSON.stringify(NODE_DATA));
      currentTab.edges = JSON.parse(JSON.stringify(EDGE_DATA));
      currentTab.positions = JSON.parse(JSON.stringify(savedPositions));
      currentTab.sizes = JSON.parse(JSON.stringify(savedSizes));
      currentTab.styles = JSON.parse(JSON.stringify(savedStyles));
      currentTab.legend = JSON.parse(JSON.stringify(EDGE_LEGEND));
      currentTab.rects = JSON.parse(JSON.stringify(RECT_DATA));
      currentTab.texts = JSON.parse(JSON.stringify(TEXT_DATA));
      currentTab.pageState = JSON.parse(JSON.stringify(PAGE_STATE));
       
      return {
      nodeData: NODE_DATA,
       edgeData: EDGE_DATA,
       rectData: RECT_DATA,
       textData: TEXT_DATA,
       edgeLegend: EDGE_LEGEND,
       nodePositions: savedPositions,
       nodeSizes: savedSizes,
       nodeStyles: savedStyles,
       iconCache: IconLibrary.iconCache,
      
       page: PAGE_STATE,
      
       autoPingEnabled: autoPingEnabled,
       autoPingInterval: autoPingInterval,
      
       canvas: {
         zoom: canvasState.zoom,
         panX: canvasState.panX,
         panY: canvasState.panY,
       },
       
       savedTopologyView: savedTopologyView,
       
       documentTabs: documentTabs,
       currentTabIndex: currentTabIndex,
       encryptedSections: encryptedSections,
      };
      }
      
       function assembleTheImmortalForm() {
        const clone = document.documentElement.cloneNode(true);
        const nodeScript = clone.querySelector("#nodes-json");
        if (nodeScript) {
         nodeScript.textContent = JSON.stringify(NODE_DATA, null, 2);
        }
        let stateScript = clone.querySelector("#topology-state");
        if (!stateScript) {
         stateScript = document.createElement("script");
         stateScript.id = "topology-state";
         stateScript.type = "application/json";
         const body = clone.querySelector("body") || clone;
         body.appendChild(stateScript);
        }
        stateScript.textContent = JSON.stringify(captureTheQuickening(), null, 2, );
        return " <!DOCTYPE html> \n " + clone.outerHTML;
       }
       async function becomeImmortal() {
        const encryptEnabled = document.getElementById("encrypt-toggle").checked;
        let stateData = JSON.stringify(captureTheQuickening(), null, 2);
        if (encryptEnabled) {
         const password = prompt("Enter a password to encrypt your data:\n(Remember this password! You will need it to open this file and its non recoverable!)", );
         if (!password) {
          alert("Encryption cancelled. File not saved.");
          return;
         }
         const confirmPassword = prompt("Confirm your password:");
         if (password !== confirmPassword) {
          alert("Passwords do not match. File not saved.");
          return;
         }
         try {
          stateData = await encryptData(stateData, password);
         } catch (e) {
          alert("Encryption failed: " + e.message);
          return;
         }
        }
        const clone = document.documentElement.cloneNode(true);
        const nodeScript = clone.querySelector("#nodes-json");
        if (nodeScript) {
         if (encryptEnabled) {
          nodeScript.textContent = JSON.stringify({}, null, 2);
         } else {
          nodeScript.textContent = JSON.stringify(NODE_DATA, null, 2);
         }
        }
        let stateScript = clone.querySelector("#topology-state");
        if (!stateScript) {
         stateScript = document.createElement("script");
         stateScript.id = "topology-state";
         stateScript.type = "application/json";
         const body = clone.querySelector("body") || clone;
         body.appendChild(stateScript);
        }
        stateScript.textContent = stateData;
        const html = "<!DOCTYPE html> \n " + clone.outerHTML;
        const blob = new Blob([html], {
         type: "text/html"
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        const safeTitle = (PAGE_STATE.title || document.title || "network-topology").toLowerCase().replace(/[^a-z0-9\-]+/g, "-");
        a.download = safeTitle + ".html";
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        saveRollbackVersion("Manual save");
       }
       
      function captureState() {
      return {
        nodes: JSON.parse(JSON.stringify(NODE_DATA)),
        edges: JSON.parse(JSON.stringify(EDGE_DATA)),
        positions: JSON.parse(JSON.stringify(savedPositions)),
        sizes: JSON.parse(JSON.stringify(savedSizes)),
        styles: JSON.parse(JSON.stringify(savedStyles)),
        legend: JSON.parse(JSON.stringify(EDGE_LEGEND)),
        rects: JSON.parse(JSON.stringify(RECT_DATA)),
        texts: JSON.parse(JSON.stringify(TEXT_DATA))
        };
      }
      
      function pushUndo(action = "") {
       const state = captureState();
       undoStack.push(state);
       if (undoStack.length > MAX_UNDO_STACK) {
        undoStack.shift();
       }
       redoStack = [];
       updateUndoButtons();
      }
      
      function undo() {
       if (undoStack.length === 0) return;
       const currentState = captureState();
       redoStack.push(currentState);
       const previousState = undoStack.pop();
       restoreState(previousState);
       updateUndoButtons();
      }
      
      function redo() {
       if (redoStack.length === 0) return;
       const currentState = captureState();
       undoStack.push(currentState);
       const nextState = redoStack.pop();
       restoreState(nextState);
       updateUndoButtons();
      }
      
      function restoreState(state) {
      NODE_DATA = state.nodes;
       EDGE_DATA = state.edges;
       savedPositions = state.positions;
       savedSizes = state.sizes;
       savedStyles = state.styles;
       EDGE_LEGEND = state.legend;
       RECT_DATA = state.rects || { list: [] };
       TEXT_DATA = state.texts || { list: [] };
       forgeTheTopology();
       if (currentNodeId && NODE_DATA[currentNodeId]) {
       claimTheImmortal(currentNodeId);
       } else if (currentEdgeId) {
       selectTheConnection(currentEdgeId);
       }
      }
      
      function updateUndoButtons() {
       const undoBtn = document.getElementById("undo-btn");
       const redoBtn = document.getElementById("redo-btn");
       if (undoBtn) {
        undoBtn.disabled = undoStack.length === 0;
        undoBtn.style.opacity = undoStack.length === 0 ? "0.5" : "1";
       }
       if (redoBtn) {
        redoBtn.disabled = redoStack.length === 0;
        redoBtn.style.opacity = redoStack.length === 0 ? "0.5" : "1";
       }
      }
      
      function selectNode(nodeId, addToSelection = false) {
       if (!addToSelection) {
        selectedNodes.clear();
       }
       selectedNodes.add(nodeId);
       updateNodeSelection();
      }
      
      function clearSelection() {
       selectedNodes.clear();
       updateNodeSelection();
       clearSearchHighlight();
      }
      
      function updateNodeSelection() {
       document.querySelectorAll(".node-group").forEach(node => {
        const nodeId = node.dataset.nodeId;
        if (selectedNodes.has(nodeId)) {
         node.classList.add("selected");
        } else {
         node.classList.remove("selected");
        }
       });
       
       const bulkToolbar = document.getElementById("bulk-toolbar");
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       const bulkCount = document.getElementById("bulk-count");
       const bulkCountMobile = document.getElementById("bulk-count-mobile");
       const bulkCountModal = document.getElementById("bulk-count-modal");
       
       if (selectedNodes.size > 0) {
        if (bulkToolbar) bulkToolbar.style.display = "flex";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
        if (bulkCount) bulkCount.textContent = selectedNodes.size;
        if (bulkCountMobile) bulkCountMobile.textContent = selectedNodes.size;
        if (bulkCountModal) bulkCountModal.textContent = selectedNodes.size;
       } else {
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        const modal = document.getElementById("bulk-actions-modal");
        if (modal) modal.style.display = "none";
       }
      }
      
      function deleteSelected() {
       if (selectedNodes.size === 0) return;
       const count = selectedNodes.size;
       challengeTheImmortal(`Delete ${count} selected node${count > 1 ? 's' : ''}?`, () => {
        pushUndo("delete selected");
        selectedNodes.forEach(nodeId => {
         delete NODE_DATA[nodeId];
         delete savedPositions[nodeId];
         delete savedSizes[nodeId];
         delete savedStyles[nodeId];
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== nodeId && e.to !== nodeId);
        });
        selectedNodes.clear();
        saveEdgeData();
        forgeTheTopology();
        if (currentNodeId && !NODE_DATA[currentNodeId]) {
         currentNodeId = null;
         document.getElementById("node-panel").style.display = "none";
        }
        updateNodeSelection();
       });
      }
      
      function startSelection(event) {
       const svgEl = document.getElementById("map");
       const pt = svgEl.createSVGPoint();
       pt.x = event.clientX;
       pt.y = event.clientY;
       const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
       
       isSelecting = true;
       selectionStart = { x: svgP.x, y: svgP.y };
       
       if (!selectionRect) {
        selectionRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        selectionRect.setAttribute("fill", "rgba(79, 209, 197, 0.1)");
        selectionRect.setAttribute("stroke", "#4fd1c5");
        selectionRect.setAttribute("stroke-width", "2");
        selectionRect.setAttribute("stroke-dasharray", "5,5");
        selectionRect.style.pointerEvents = "none";
        svgEl.appendChild(selectionRect);
       }
       
       if (!event.shiftKey) {
        selectedNodes.clear();
       }
      }
      
      function updateSelection(event) {
       if (!isSelecting || !selectionStart) return;
       
       const svgEl = document.getElementById("map");
       const pt = svgEl.createSVGPoint();
       pt.x = event.clientX;
       pt.y = event.clientY;
       const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
       
       const x = Math.min(selectionStart.x, svgP.x);
       const y = Math.min(selectionStart.y, svgP.y);
       const width = Math.abs(svgP.x - selectionStart.x);
       const height = Math.abs(svgP.y - selectionStart.y);
       
       selectionRect.setAttribute("x", x);
       selectionRect.setAttribute("y", y);
       selectionRect.setAttribute("width", width);
       selectionRect.setAttribute("height", height);
       selectionRect.style.display = "block";
       
       document.querySelectorAll(".node-group").forEach(node => {
        const nodeId = node.dataset.nodeId;
        const pos = savedPositions[nodeId];
        if (pos && pos.x >= x && pos.x <= x + width && pos.y >= y && pos.y <= y + height) {
         selectedNodes.add(nodeId);
        } else if (!event.shiftKey) {
         selectedNodes.delete(nodeId);
        }
       });
       
       updateNodeSelection();
      }
      
      function endSelection() {
       isSelecting = false;
       selectionStart = null;
       if (selectionRect) {
        selectionRect.style.display = "none";
       }
      }
      
      function cloneNode(sourceId) {
       const source = NODE_DATA[sourceId];
       if (!source) return;
       
       pushUndo("clone node");
       
       let baseName = source.name;
       let copyNum = 0;
       let newName = baseName + " copy";
       while (Object.values(NODE_DATA).some(n => n.name === newName)) {
        copyNum++;
        newName = baseName + " copy " + copyNum;
       }
       
       const newId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
       
       NODE_DATA[newId] = {
        shape: source.shape,
        name: newName,
        ip: source.ip,
        role: source.role,
        tags: [...source.tags],
        notes: [...source.notes],
        mac: source.mac || "",
        rackUnit: source.rackUnit || "",
        uHeight: source.uHeight || "1",
        ping: source.ping ? JSON.parse(JSON.stringify(source.ping)) : {
         enabled: false,
         protocol: 'http',
         customUrl: '',
         timeout: 3000,
         status: 'unknown',
         lastCheck: null
        }
       };
       
       if (savedSizes[sourceId]) {
        savedSizes[newId] = savedSizes[sourceId];
       }
       
       if (savedStyles[sourceId]) {
        savedStyles[newId] = JSON.parse(JSON.stringify(savedStyles[sourceId]));
       }
       
       const sourcePos = savedPositions[sourceId];
       savedPositions[newId] = {
        x: sourcePos.x + 100,
        y: sourcePos.y + 100
       };
       
       forgeTheTopology();
       claimTheImmortal(newId);
      }
      
      function alignSelectedNodes(direction) {
       if (selectedNodes.size < 2) return;
       
       pushUndo("align nodes");
       
       const nodeIds = Array.from(selectedNodes);
       const positions = nodeIds.map(id => ({ id, pos: savedPositions[id] }));
       
       switch(direction) {
        case "left":
         const minX = Math.min(...positions.map(p => p.pos.x));
         positions.forEach(p => savedPositions[p.id].x = minX);
         break;
        case "right":
         const maxX = Math.max(...positions.map(p => p.pos.x));
         positions.forEach(p => savedPositions[p.id].x = maxX);
         break;
        case "top":
         const minY = Math.min(...positions.map(p => p.pos.y));
         positions.forEach(p => savedPositions[p.id].y = minY);
         break;
        case "bottom":
         const maxY = Math.max(...positions.map(p => p.pos.y));
         positions.forEach(p => savedPositions[p.id].y = maxY);
         break;
        case "center-h":
         const avgX = positions.reduce((sum, p) => sum + p.pos.x, 0) / positions.length;
         positions.forEach(p => savedPositions[p.id].x = avgX);
         break;
        case "center-v":
         const avgY = positions.reduce((sum, p) => sum + p.pos.y, 0) / positions.length;
         positions.forEach(p => savedPositions[p.id].y = avgY);
         break;
       }
       
       forgeTheTopology();
      }
      
      function distributeSelectedNodes(direction) {
       if (selectedNodes.size < 3) return;
       
       pushUndo("distribute nodes");
       
       const nodeIds = Array.from(selectedNodes);
       const positions = nodeIds.map(id => ({ id, pos: savedPositions[id] }));
       
       if (direction === "horizontal") {
        positions.sort((a, b) => a.pos.x - b.pos.x);
        const minX = positions[0].pos.x;
        const maxX = positions[positions.length - 1].pos.x;
        const gap = (maxX - minX) / (positions.length - 1);
        positions.forEach((p, i) => {
         savedPositions[p.id].x = minX + (gap * i);
        });
       } else if (direction === "vertical") {
        positions.sort((a, b) => a.pos.y - b.pos.y);
        const minY = positions[0].pos.y;
        const maxY = positions[positions.length - 1].pos.y;
        const gap = (maxY - minY) / (positions.length - 1);
        positions.forEach((p, i) => {
         savedPositions[p.id].y = minY + (gap * i);
        });
       }
       
       forgeTheTopology();
      }
      
      function snapToGrid(nodeId, gridSize = 50) {
       if (!savedPositions[nodeId]) return;
       
       pushUndo("snap to grid");
       
       const pos = savedPositions[nodeId];
       pos.x = Math.round(pos.x / gridSize) * gridSize;
       pos.y = Math.round(pos.y / gridSize) * gridSize;
       
       forgeTheTopology();
      }
      
      function nudgeSelectedNodes(direction, distance) {
        const nodesToNudge = selectedNodes.size > 0 
          ? Array.from(selectedNodes) 
          : (currentNodeId ? [currentNodeId] : []);
        
        if (nodesToNudge.length === 0) return;
        
        const unlockedNodes = nodesToNudge.filter(id => !NODE_DATA[id]?.locked);
        
        if (unlockedNodes.length === 0) {
          return;
        }
        
        pushUndo("nudge nodes");
        
        unlockedNodes.forEach(id => {
          if (!savedPositions[id]) {
            savedPositions[id] = { x: 0, y: 0 };
          }
          
          switch(direction) {
            case "ArrowUp":
              savedPositions[id].y -= distance;
              break;
            case "ArrowDown":
              savedPositions[id].y += distance;
              break;
            case "ArrowLeft":
              savedPositions[id].x -= distance;
              break;
            case "ArrowRight":
              savedPositions[id].x += distance;
              break;
          }
        });
        
        forgeTheTopology();
      }
      
      function cycleNodes(reverse = false) {
        const nodeIds = Object.keys(NODE_DATA).filter(id => {
          if (currentView.mode === "rack" && currentView.rackId) {
            return NODE_DATA[id].assignedRack === currentView.rackId;
          }
          return !NODE_DATA[id].assignedRack;
        });
        
        if (nodeIds.length === 0) return;
        
        let currentIndex = nodeIds.indexOf(currentNodeId);
        
        if (reverse) {
          currentIndex = currentIndex <= 0 ? nodeIds.length - 1 : currentIndex - 1;
        } else {
          currentIndex = currentIndex >= nodeIds.length - 1 ? 0 : currentIndex + 1;
        }
        
        const nextNodeId = nodeIds[currentIndex];
        claimTheImmortal(nextNodeId);
        
        selectedNodes.clear();
        updateNodeSelection();
      }
      
      function focusOnSelected() {
        const nodesToFocus = selectedNodes.size > 0 
          ? Array.from(selectedNodes) 
          : (currentNodeId ? [currentNodeId] : []);
        
        if (nodesToFocus.length === 0) return;
        
        let minX = Infinity, minY = Infinity;
        let maxX = -Infinity, maxY = -Infinity;
        
        nodesToFocus.forEach(id => {
          const pos = savedPositions[id];
          if (pos) {
            const size = savedSizes[id] || 50;
            minX = Math.min(minX, pos.x - size/2);
            minY = Math.min(minY, pos.y - size/2);
            maxX = Math.max(maxX, pos.x + size/2);
            maxY = Math.max(maxY, pos.y + size/2);
          }
        });
        
        if (!isFinite(minX)) return;
        
        const padding = 100;
        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;
        const width = maxX - minX + padding * 2;
        const height = maxY - minY + padding * 2;
        
        const zoomX = CANVAS_WIDTH / width;
        const zoomY = CANVAS_HEIGHT / height;
        const targetZoom = Math.min(zoomX, zoomY, 2);
        
        canvasState.zoom = targetZoom;
        canvasState.panX = centerX - (CANVAS_WIDTH / targetZoom) / 2;
        canvasState.panY = centerY - (CANVAS_HEIGHT / targetZoom) / 2;
        
        forgeTheTopology();
      }
      
      function toggleLockSelected() {
        const nodesToToggle = selectedNodes.size > 0 
          ? Array.from(selectedNodes) 
          : (currentNodeId ? [currentNodeId] : []);
        
        if (nodesToToggle.length === 0) return;
        
        pushUndo("toggle lock");
        
        const hasUnlocked = nodesToToggle.some(id => !NODE_DATA[id]?.locked);
        
        nodesToToggle.forEach(id => {
          if (NODE_DATA[id]) {
            NODE_DATA[id].locked = hasUnlocked;
          }
        });
        
        forgeTheTopology();
      
        const lockState = hasUnlocked ? "locked" : "unlocked";
      }
      
      function toggleGroupSelected() {
        const nodesToGroup = Array.from(selectedNodes);
        if (nodesToGroup.length < 2) {
          return;
        }
        
        pushUndo("toggle group");
        
        const groupIds = nodesToGroup.map(id => NODE_DATA[id]?.groupId).filter(g => g !== null && g !== undefined);
        const uniqueGroups = [...new Set(groupIds)];
        
        if (uniqueGroups.length === 1 && groupIds.length === nodesToGroup.length) {
          nodesToGroup.forEach(id => {
            if (NODE_DATA[id]) {
              NODE_DATA[id].groupId = null;
            }
          });
        } else {
          const newGroupId = "group-" + Date.now();
          nodesToGroup.forEach(id => {
            if (NODE_DATA[id]) {
              NODE_DATA[id].groupId = newGroupId;
            }
          });
        }
        
        forgeTheTopology();
      }
      
      function handleKeyDown(event) {
       if (event.target.tagName === "INPUT" || event.target.tagName === "TEXTAREA" || event.target.isContentEditable) {
        return;
       }
      
       if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(event.key)) {
        event.preventDefault();
        const distance = event.shiftKey ? 10 : 1;
        nudgeSelectedNodes(event.key, distance);
       }
       
       if (event.key === "Tab") {
        event.preventDefault();
        cycleNodes(event.shiftKey);
       }
       
       if (event.key === "f" || event.key === "F") {
        event.preventDefault();
        focusOnSelected();
       }
       
       if (event.key === "l" || event.key === "L") {
        event.preventDefault();
        toggleLockSelected();
       }
       
       if (event.key === "g" || event.key === "G") {
        event.preventDefault();
        toggleGroupSelected();
       }
       
       if (event.ctrlKey && event.key === "z" && !event.shiftKey) {
        event.preventDefault();
        undo();
       }
       
       if ((event.ctrlKey && event.key === "y") || (event.ctrlKey && event.shiftKey && event.key === "z")) {
        event.preventDefault();
        redo();
       }
       
       if (event.ctrlKey && event.key === "c" && currentNodeId) {
        event.preventDefault();
        const node = NODE_DATA[currentNodeId];
        if (node) {
         clipboard = {
          type: "node",
          data: JSON.parse(JSON.stringify(node)),
          size: savedSizes[currentNodeId],
          style: savedStyles[currentNodeId] ? JSON.parse(JSON.stringify(savedStyles[currentNodeId])) : null
         };
        }
       }
       
       if (event.ctrlKey && event.key === "v" && clipboard && clipboard.type === "node") {
        event.preventDefault();
        pushUndo("paste node");
        
        let baseName = clipboard.data.name;
        let copyNum = 0;
        let newName = baseName + " copy";
        while (Object.values(NODE_DATA).some(n => n.name === newName)) {
         copyNum++;
         newName = baseName + " copy " + copyNum;
        }
        
        const newId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
        NODE_DATA[newId] = JSON.parse(JSON.stringify(clipboard.data));
        NODE_DATA[newId].name = newName;
        
        if (clipboard.size) savedSizes[newId] = clipboard.size;
        if (clipboard.style) savedStyles[newId] = JSON.parse(JSON.stringify(clipboard.style));
        
        const svgEl = document.getElementById("map");
        const rect = svgEl.getBoundingClientRect();
        const pt = svgEl.createSVGPoint();
        pt.x = rect.left + rect.width / 2;
        pt.y = rect.top + rect.height / 2;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        savedPositions[newId] = { x: svgP.x, y: svgP.y };
        
        forgeTheTopology();
        claimTheImmortal(newId);
       }
       
       if (event.ctrlKey && event.key === "d" && currentNodeId) {
        event.preventDefault();
        cloneNode(currentNodeId);
       }
       
       if (event.key === "Delete") {
        event.preventDefault();
        if (selectedNodes.size > 0) {
         deleteSelected();
        } else if (currentNodeId && NODE_DATA[currentNodeId]) {
         challengeTheImmortal(`Delete node "${NODE_DATA[currentNodeId].name}"?`, () => {
          pushUndo("delete node");
          delete NODE_DATA[currentNodeId];
          delete savedPositions[currentNodeId];
          delete savedSizes[currentNodeId];
          delete savedStyles[currentNodeId];
          EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== currentNodeId && e.to !== currentNodeId);
          saveEdgeData();
          forgeTheTopology();
          currentNodeId = null;
          document.getElementById("node-panel").style.display = "none";
         });
        } else if (currentEdgeId) {
         const edge = EDGE_DATA.list.find(e => e.id === currentEdgeId);
         if (edge) {
          challengeTheImmortal("Delete this line?", () => {
           pushUndo("delete edge");
           EDGE_DATA.list = EDGE_DATA.list.filter(e => e.id !== currentEdgeId);
           saveEdgeData();
           forgeTheTopology();
           currentEdgeId = null;
           document.getElementById("edge-panel").style.display = "none";
          });
         }
        }
       }
       
       if (event.ctrlKey && event.key === "a") {
        event.preventDefault();
        selectedNodes.clear();
        Object.keys(NODE_DATA).forEach(id => selectedNodes.add(id));
        updateNodeSelection();
       }
       
       if (event.key === "Escape") {
        clearSelection();
       }
      }
      
      function searchNodes(query) {
       clearSearchHighlight();
       
       if (!query || query.trim() === "") return;
       
       const lowerQuery = query.toLowerCase();
       const matchingIds = [];
       
       Object.entries(NODE_DATA).forEach(([id, node]) => {
        const searchableText = [
         node.name,
         node.ip,
         node.role,
         ...(node.tags || []),
         node.mac || "",
         node.rackUnit || ""
        ].join(" ").toLowerCase();
        
        if (searchableText.includes(lowerQuery)) {
         matchingIds.push(id);
        }
       });
       
       highlightSearchResults(matchingIds);
      }
      
      function highlightSearchResults(nodeIds) {
       clearSearchHighlight();
       nodeIds.forEach(id => {
        const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`);
        if (nodeGroup) {
         nodeGroup.classList.add("search-highlight");
        }
       });
      }
      
      function clearSearchHighlight() {
       document.querySelectorAll(".node-group").forEach(node => {
        node.classList.remove("search-highlight");
       });
      }
      
      function editNodeMac(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       
       document.getElementById("modal-title").textContent = "Edit MAC Address";
       document.getElementById("modal-input").value = node.mac || "";
       document.getElementById("edit-modal").style.display = "flex";
       document.getElementById("modal-input").focus();
       
       const saveHandler = () => {
        pushUndo("edit mac");
        const value = document.getElementById("modal-input").value.trim();
        node.mac = value;
        document.getElementById("edit-modal").style.display = "none";
        claimTheImmortal(id);
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       
       const cancelHandler = () => {
        document.getElementById("edit-modal").style.display = "none";
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       
       document.getElementById("edit-modal").addEventListener("click", function bgHandler(e) {
        if (e.target === document.getElementById("edit-modal")) {
         cancelHandler();
         document.getElementById("edit-modal").removeEventListener("click", bgHandler);
        }
       });
      }
      
      function editNodeRack(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       
       document.getElementById("modal-title").textContent = "Edit Rack Unit";
       document.getElementById("modal-input").value = node.rackUnit || "";
       document.getElementById("edit-modal").style.display = "flex";
       document.getElementById("modal-input").focus();
       
       const saveHandler = () => {
        pushUndo("edit rack");
        const value = document.getElementById("modal-input").value.trim();
        node.rackUnit = value;
        document.getElementById("edit-modal").style.display = "none";
        claimTheImmortal(id);
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       
       const cancelHandler = () => {
        document.getElementById("edit-modal").style.display = "none";
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       
       document.getElementById("edit-modal").addEventListener("click", function bgHandler(e) {
        if (e.target === document.getElementById("edit-modal")) {
         cancelHandler();
         document.getElementById("edit-modal").removeEventListener("click", bgHandler);
        }
       });
      }
      
      function editNodeUHeight(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       
       document.getElementById("modal-title").textContent = "Edit U Height";
       document.getElementById("modal-input").value = node.uHeight || "1";
       document.getElementById("edit-modal").style.display = "flex";
       document.getElementById("modal-input").focus();
       
       const saveHandler = () => {
        pushUndo("edit U height");
        const value = document.getElementById("modal-input").value.trim();
        node.uHeight = value;
        document.getElementById("edit-modal").style.display = "none";
        claimTheImmortal(id);
        forgeTheTopology();
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       
       const cancelHandler = () => {
        document.getElementById("edit-modal").style.display = "none";
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       
       document.getElementById("edit-modal").addEventListener("click", function bgHandler(e) {
        if (e.target === document.getElementById("edit-modal")) {
         cancelHandler();
         document.getElementById("edit-modal").removeEventListener("click", bgHandler);
        }
       });
      }
      
      function updateEdgePortLabels(edgeId) {
       const edge = EDGE_DATA.list.find(e => e.id === edgeId);
       if (!edge) return;
       
       const fromPortInput = document.getElementById("edge-from-port");
       const toPortInput = document.getElementById("edge-to-port");
       
       edge.fromPort = fromPortInput ? fromPortInput.value.trim() : "";
       edge.toPort = toPortInput ? toPortInput.value.trim() : "";
       
       saveEdgeData();
       forgeTheTopology();
      }
      
      document.addEventListener("keydown", handleKeyDown);
      
      const undoBtn = document.getElementById("undo-btn");
      const redoBtn = document.getElementById("redo-btn");
      if (undoBtn) undoBtn.addEventListener("click", undo);
      if (redoBtn) redoBtn.addEventListener("click", redo);
      
      const backToTopologyBtn = document.getElementById("back-to-topology-btn");
      if (backToTopologyBtn) {
       backToTopologyBtn.addEventListener("click", exitRack);
      }
      
      const bulkToolbarClose = document.getElementById("bulk-toolbar-close");
      if (bulkToolbarClose) {
       bulkToolbarClose.addEventListener("click", clearSelection);
      }
      
      const bulkAlignLeft = document.getElementById("bulk-align-left");
      if (bulkAlignLeft) {
       bulkAlignLeft.addEventListener("click", () => alignSelectedNodes("left"));
      }
      
      const bulkAlignRight = document.getElementById("bulk-align-right");
      if (bulkAlignRight) {
       bulkAlignRight.addEventListener("click", () => alignSelectedNodes("right"));
      }
      
      const bulkAlignTop = document.getElementById("bulk-align-top");
      if (bulkAlignTop) {
       bulkAlignTop.addEventListener("click", () => alignSelectedNodes("top"));
      }
      
      const bulkAlignBottom = document.getElementById("bulk-align-bottom");
      if (bulkAlignBottom) {
       bulkAlignBottom.addEventListener("click", () => alignSelectedNodes("bottom"));
      }
      
      const bulkDistributeH = document.getElementById("bulk-distribute-h");
      if (bulkDistributeH) {
       bulkDistributeH.addEventListener("click", () => distributeSelectedNodes("horizontal"));
      }
      
      const bulkDistributeV = document.getElementById("bulk-distribute-v");
      if (bulkDistributeV) {
       bulkDistributeV.addEventListener("click", () => distributeSelectedNodes("vertical"));
      }
      
      const bulkClone = document.getElementById("bulk-clone");
      if (bulkClone) {
       bulkClone.addEventListener("click", () => {
        if (selectedNodes.size === 0) return;
        pushUndo("clone selected");
        const nodesToClone = Array.from(selectedNodes);
        selectedNodes.clear();
        nodesToClone.forEach(id => {
         cloneNode(id);
         selectedNodes.add(currentNodeId);
        });
        updateNodeSelection();
       });
      }
      
      const bulkDelete = document.getElementById("bulk-delete");
      if (bulkDelete) {
       bulkDelete.addEventListener("click", deleteSelected);
      }
      
      const bulkMobileBtn = document.getElementById("bulk-mobile-btn");
      const bulkActionsModal = document.getElementById("bulk-actions-modal");
      const bulkModalClose = document.getElementById("bulk-modal-close");
      
      if (bulkMobileBtn) {
       bulkMobileBtn.addEventListener("click", () => {
        if (bulkActionsModal) bulkActionsModal.style.display = "block";
       });
      }
      
      if (bulkModalClose) {
       bulkModalClose.addEventListener("click", () => {
        if (bulkActionsModal) bulkActionsModal.style.display = "none";
       });
      }
      
      const closeModalAfterAction = () => {
       if (bulkActionsModal) bulkActionsModal.style.display = "none";
      };
      
      const bulkAlignLeftMobile = document.getElementById("bulk-align-left-mobile");
      if (bulkAlignLeftMobile) {
       bulkAlignLeftMobile.addEventListener("click", () => {
        alignSelectedNodes("left");
        closeModalAfterAction();
       });
      }
      
      const bulkAlignRightMobile = document.getElementById("bulk-align-right-mobile");
      if (bulkAlignRightMobile) {
       bulkAlignRightMobile.addEventListener("click", () => {
        alignSelectedNodes("right");
        closeModalAfterAction();
       });
      }
      
      const bulkAlignTopMobile = document.getElementById("bulk-align-top-mobile");
      if (bulkAlignTopMobile) {
       bulkAlignTopMobile.addEventListener("click", () => {
        alignSelectedNodes("top");
        closeModalAfterAction();
       });
      }
      
      const bulkAlignBottomMobile = document.getElementById("bulk-align-bottom-mobile");
      if (bulkAlignBottomMobile) {
       bulkAlignBottomMobile.addEventListener("click", () => {
        alignSelectedNodes("bottom");
        closeModalAfterAction();
       });
      }
      
      const bulkDistributeHMobile = document.getElementById("bulk-distribute-h-mobile");
      if (bulkDistributeHMobile) {
       bulkDistributeHMobile.addEventListener("click", () => {
        distributeSelectedNodes("horizontal");
        closeModalAfterAction();
       });
      }
      
      const bulkDistributeVMobile = document.getElementById("bulk-distribute-v-mobile");
      if (bulkDistributeVMobile) {
       bulkDistributeVMobile.addEventListener("click", () => {
        distributeSelectedNodes("vertical");
        closeModalAfterAction();
       });
      }
      
      const bulkCloneMobile = document.getElementById("bulk-clone-mobile");
      if (bulkCloneMobile) {
       bulkCloneMobile.addEventListener("click", () => {
        if (selectedNodes.size === 0) return;
        pushUndo("clone selected");
        const nodesToClone = Array.from(selectedNodes);
        selectedNodes.clear();
        nodesToClone.forEach(id => {
         cloneNode(id);
         selectedNodes.add(currentNodeId);
        });
        updateNodeSelection();
        closeModalAfterAction();
       });
      }
      
      const bulkDeleteMobile = document.getElementById("bulk-delete-mobile");
      if (bulkDeleteMobile) {
       bulkDeleteMobile.addEventListener("click", () => {
        deleteSelected();
        closeModalAfterAction();
       });
      }
      
      const bulkLockMobile = document.getElementById("bulk-lock-mobile");
      if (bulkLockMobile) {
       bulkLockMobile.addEventListener("click", () => {
        toggleLockSelected();
        closeModalAfterAction();
       });
      }
      
      const bulkGroupMobile = document.getElementById("bulk-group-mobile");
      if (bulkGroupMobile) {
       bulkGroupMobile.addEventListener("click", () => {
        toggleGroupSelected();
        closeModalAfterAction();
       });
      }
      
      const bulkClearMobile = document.getElementById("bulk-clear-mobile");
      if (bulkClearMobile) {
       bulkClearMobile.addEventListener("click", () => {
        clearSelection();
        closeModalAfterAction();
       });
      }
      
      const searchInput = document.getElementById("search-input");
      if (searchInput) {
       searchInput.addEventListener("input", (e) => {
        searchNodes(e.target.value);
       });
      }
      
       document.getElementById("save-file-btn").addEventListener("click", becomeImmortal);
       document.getElementById("check-all-ping-btn").addEventListener("click", checkAllNodesStatus);
       const addNodeBtn = document.getElementById("add-node-btn");
       const addNodeModal = document.getElementById("add-node-modal");
       const addNodeCancel = document.getElementById("add-node-cancel");
       const addNodeSave = document.getElementById("add-node-save");
       addNodeBtn.addEventListener("click", () => {
        document.getElementById("new-node-name").value = "";
        document.getElementById("new-node-ip").value = "";
        document.getElementById("new-node-tags").value = "";
        document.getElementById("new-node-shape").value = "circle";
        document.getElementById("new-node-pingable").checked = false;
        document.getElementById("new-node-ping-protocol").value = "http";
        document.getElementById("new-node-custom-url").value = "";
        document.getElementById("new-node-ping-timeout").value = "3000";
        document.getElementById("new-node-ping-options").style.display = "none";
        document.getElementById("new-node-custom-url-container").style.display = "none";
        newNodeIconTags = [];
        document.getElementById("new-node-icon-tags").style.display = "none";
        document.getElementById("new-node-icon-tags-list").innerHTML = "";
        addNodeModal.classList.add("active");
        document.getElementById("new-node-name").focus();
       });
       
       const canvasViewport = document.getElementById("canvas-viewport");
       if (canvasViewport) {
        canvasViewport.addEventListener("dblclick", (e) => {
         if (currentView.mode === "rack" && e.target.id === "map") {
          exitRack();
         }
        });
       }
       
       const layersBtn = document.getElementById("layers-btn");
       const layerModal = document.getElementById("layer-modal");
       const layerModalClose = document.getElementById("layer-modal-close");
       if (layersBtn && layerModal) {
        layersBtn.addEventListener("click", () => {
         layerModal.classList.add("active");
        });
       }
       if (layerModalClose && layerModal) {
        layerModalClose.addEventListener("click", () => {
         layerModal.classList.remove("active");
        });
       }
       if (layerModal) {
        layerModal.addEventListener("click", (e) => {
         if (e.target === layerModal) {
          layerModal.classList.remove("active");
         }
        });
       }
      
       const tabsBtn = document.getElementById("tabs-btn");
       const tabsModal = document.getElementById("tabs-modal");
       const tabsModalClose = document.getElementById("tabs-modal-close");
       if (tabsBtn && tabsModal) {
         tabsBtn.addEventListener("click", () => {
           displayTabs();
           tabsModal.classList.add("active");
         });
       }
       if (tabsModalClose && tabsModal) {
         tabsModalClose.addEventListener("click", () => {
           tabsModal.classList.remove("active");
         });
       }
       if (tabsModal) {
         tabsModal.addEventListener("click", (e) => {
           if (e.target === tabsModal) {
             tabsModal.classList.remove("active");
           }
         });
       }
       
       const rollbackBtn = document.getElementById("rollback-btn");
       const rollbackModal = document.getElementById("rollback-modal");
       const rollbackModalClose = document.getElementById("rollback-modal-close");
       if (rollbackBtn && rollbackModal) {
         rollbackBtn.addEventListener("click", () => {
           loadRollbackVersions();
           rollbackModal.classList.add("active");
         });
       }
       if (rollbackModalClose && rollbackModal) {
         rollbackModalClose.addEventListener("click", () => {
           rollbackModal.classList.remove("active");
         });
       }
       if (rollbackModal) {
         rollbackModal.addEventListener("click", (e) => {
           if (e.target === rollbackModal) {
             rollbackModal.classList.remove("active");
           }
         });
       }
       
       const auditLogBtn = document.getElementById("audit-log-btn");
       const auditLogModal = document.getElementById("audit-log-modal");
       const auditLogModalClose = document.getElementById("audit-log-modal-close");
       if (auditLogBtn && auditLogModal) {
         auditLogBtn.addEventListener("click", () => {
           loadAuditLog();
           displayAuditLog();
           auditLogModal.classList.add("active");
         });
       }
       if (auditLogModalClose && auditLogModal) {
         auditLogModalClose.addEventListener("click", () => {
           auditLogModal.classList.remove("active");
         });
       }
       if (auditLogModal) {
         auditLogModal.addEventListener("click", (e) => {
           if (e.target === auditLogModal) {
             auditLogModal.classList.remove("active");
           }
         });
       }
      
       const auditFilter = document.getElementById("audit-filter");
       if (auditFilter) {
         auditFilter.addEventListener("change", (e) => {
           displayAuditLog(e.target.value);
         });
       }
       
       const secretsBtn = document.getElementById("secrets-btn");
       const secretsModal = document.getElementById("secrets-modal");
       const secretsModalClose = document.getElementById("secrets-modal-close");
       if (secretsBtn && secretsModal) {
         secretsBtn.addEventListener("click", () => {
           displaySecrets();
           secretsModal.classList.add("active");
         });
       }
       if (secretsModalClose && secretsModal) {
         secretsModalClose.addEventListener("click", () => {
           secretsModal.classList.remove("active");
         });
       }
       if (secretsModal) {
         secretsModal.addEventListener("click", (e) => {
           if (e.target === secretsModal) {
             secretsModal.classList.remove("active");
           }
         });
       }
       
       const secretEditorModal = document.getElementById("secret-editor-modal");
       if (secretEditorModal) {
         secretEditorModal.addEventListener("click", (e) => {
           if (e.target === secretEditorModal) {
             closeSecretEditor();
           }
         });
       }
       
       ["physical", "logical", "security", "application"].forEach(layer => {
        const checkbox = document.getElementById(`layer-${layer}`);
        if (checkbox) {
         checkbox.addEventListener("change", applyLayerFilter);
        }
       });
       
       const layerSelect = document.getElementById("node-layer");
       if (layerSelect) {
        layerSelect.addEventListener("change", (e) => {
         if (currentNodeId) {
          pushUndo("change layer");
          NODE_DATA[currentNodeId].layer = e.target.value;
          forgeTheTopology();
         }
        });
       }
       
       const assignedRackSelect = document.getElementById("node-assigned-rack");
       if (assignedRackSelect) {
        assignedRackSelect.addEventListener("change", (e) => {
      if (currentNodeId) {
      pushUndo("change assigned rack");
      EDGE_DATA.list = EDGE_DATA.list.filter(edge => edge.from !== currentNodeId && edge.to !== currentNodeId);
      NODE_DATA[currentNodeId].assignedRack = e.target.value;
      forgeTheTopology();
      claimTheImmortal(currentNodeId);
      }
      });
       }
       
       const rackCapacitySelect = document.getElementById("node-rack-capacity");
       if (rackCapacitySelect) {
        rackCapacitySelect.addEventListener("change", (e) => {
         if (currentNodeId) {
          pushUndo("change rack capacity");
          NODE_DATA[currentNodeId].rackCapacity = e.target.value;
          forgeTheTopology();
         }
        });
       }
       
       const addRackBtn = document.getElementById("add-rack-btn");
       const addRackModal = document.getElementById("add-rack-modal");
       const addRackCancel = document.getElementById("add-rack-cancel");
       const addRackSave = document.getElementById("add-rack-save");
       
       if (addRackBtn && addRackModal) {
        addRackBtn.addEventListener("click", () => {
         document.getElementById("new-rack-name").value = "";
         document.getElementById("new-rack-ip").value = "";
         document.getElementById("new-rack-tags").value = "";
         document.getElementById("new-rack-shape").value = "server";
         document.getElementById("new-rack-capacity").value = "42";
         selectedRackIconData = null;
         document.getElementById('selected-rack-icon').style.display = 'none';
         addRackModal.classList.add("active");
         document.getElementById("new-rack-name").focus();
        });
       }
       
       if (addRackCancel && addRackModal) {
        addRackCancel.addEventListener("click", () => {
         addRackModal.classList.remove("active");
        });
       }
       
       if (addRackModal) {
        addRackModal.addEventListener("click", (e) => {
         if (e.target === addRackModal) {
          addRackModal.classList.remove("active");
         }
        });
       }
       
       if (addRackSave && addRackModal) {
        addRackSave.addEventListener("click", () => {
         const name = document.getElementById("new-rack-name").value.trim();
         const ip = document.getElementById("new-rack-ip").value.trim();
         const tagsStr = document.getElementById("new-rack-tags").value.trim();
         const shape = document.getElementById("new-rack-shape").value;
         const capacity = document.getElementById("new-rack-capacity").value;
         
         if (!name) {
          alert("Please enter a rack name.");
          return;
         }
         
         const tags = tagsStr ? tagsStr.split(",").map((t) => t.trim()).filter((t) => t) : [];
         let baseId = name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");
         if (!baseId) baseId = "rack";
         let nodeId = baseId;
         let counter = 1;
         while (NODE_DATA[nodeId]) {
          nodeId = baseId + "-" + counter;
          counter++;
         }
         
         pushUndo("add rack");
         
         NODE_DATA[nodeId] = {
          shape: shape,
          name: name,
          ip: ip || "",
          role: "Rack",
          tags: tags,
          notes: [],
          mac: "",
          rackUnit: "",
          uHeight: "1",
          layer: "physical",
          assignedRack: "",
          rackCapacity: capacity,
          isRack: true,
          locked: false,
          groupId: null
         };
         
         const viewWidth = CANVAS_WIDTH / canvasState.zoom;
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         const centerX = canvasState.panX + (viewWidth / 2);
         const centerY = canvasState.panY + (viewHeight / 2);
         savedPositions[nodeId] = {
          x: centerX,
          y: centerY
         };
         
         if (selectedRackIconData) {
          if (!savedStyles[nodeId]) {
           savedStyles[nodeId] = {};
          }
          if (!savedStyles[nodeId]['all']) {
           savedStyles[nodeId]['all'] = {};
          }
          savedStyles[nodeId]['all'].icon = {
           library: selectedRackIconData.library,
           name: selectedRackIconData.name
          };
          selectedRackIconData = null;
          document.getElementById('selected-rack-icon').style.display = 'none';
         }
         
         addRackModal.classList.remove("active");
         forgeTheTopology();
         claimTheImmortal(nodeId);
        });
        
        ["new-rack-name", "new-rack-ip", "new-rack-tags"].forEach((inputId) => {
         const input = document.getElementById(inputId);
         if (input) {
          input.addEventListener("keypress", (e) => {
           if (e.key === "Enter") {
            addRackSave.click();
           }
          });
         }
        });
       }
       
       addNodeCancel.addEventListener("click", () => {
        addNodeModal.classList.remove("active");
       });
       addNodeModal.addEventListener("click", (e) => {
        if (e.target === addNodeModal) {
         addNodeModal.classList.remove("active");
        }
       });
       addNodeSave.addEventListener("click", () => {
        const name = document.getElementById("new-node-name").value.trim();
        const ip = document.getElementById("new-node-ip").value.trim();
        const tagsStr = document.getElementById("new-node-tags").value.trim();
        const shape = document.getElementById("new-node-shape").value;
        const pingable = document.getElementById("new-node-pingable").checked;
        const pingProtocol = document.getElementById("new-node-ping-protocol").value;
        const pingCustomUrl = document.getElementById("new-node-custom-url").value.trim();
        const pingTimeout = parseInt(document.getElementById("new-node-ping-timeout").value) || 3000;
        
        if (!name) {
         alert("Please enter a node name.");
         return;
        }
        const tags = tagsStr ? tagsStr.split(",").map((t) => t.trim()).filter((t) => t) : [];
        if (newNodeIconTags.length > 0) {
         tags.push(...newNodeIconTags);
        }
        let baseId = name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");
        if (!baseId) baseId = "node";
        let nodeId = baseId;
        let counter = 1;
        while (NODE_DATA[nodeId]) {
         nodeId = baseId + "-" + counter;
         counter++;
        }
        NODE_DATA[nodeId] = {
         shape: shape || "circle",
         name: name,
         ip: ip || "0.0.0.0",
         role: "",
         tags: tags,
         notes: [],
         mac: "",
         rackUnit: "",
         uHeight: "1",
         ping: {
          enabled: pingable,
          protocol: pingProtocol,
          customUrl: pingCustomUrl,
          timeout: pingTimeout,
          status: 'unknown',
          lastCheck: null
         },
         locked: false, 
         groupId: null 
        };
        
        if (currentView.mode === "rack" && currentView.rackId) {
         NODE_DATA[nodeId].assignedRack = currentView.rackId;
         NODE_DATA[nodeId].layer = "physical";
        }
        
        if (selectedNodeIconData) {
         if (!savedStyles[nodeId]) savedStyles[nodeId] = {};
         if (!savedStyles[nodeId]['all']) savedStyles[nodeId]['all'] = {};
         savedStyles[nodeId]['all'].icon = {
          library: selectedNodeIconData.library,
          name: selectedNodeIconData.name
         };
         selectedNodeIconData = null;
         document.getElementById('selected-node-icon').style.display = 'none';
        }
        newNodeIconTags = [];
      const viewWidth = CANVAS_WIDTH / canvasState.zoom;
      const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
      const centerX = canvasState.panX + (viewWidth / 2);
      const centerY = canvasState.panY + (viewHeight / 2);
      savedPositions[nodeId] = {
      x: centerX,
      y: centerY
      };
        addNodeModal.classList.remove("active");
        forgeTheTopology();
        claimTheImmortal(nodeId);
       });
       ["new-node-name", "new-node-ip", "new-node-tags"].forEach(
        (inputId) => {
         document.getElementById(inputId).addEventListener("keypress", (e) => {
          if (e.key === "Enter") {
           addNodeSave.click();
          }
         });
        }, );
       
       document.getElementById('new-node-pingable').addEventListener('change', (e) => {
        const pingOptions = document.getElementById('new-node-ping-options');
        pingOptions.style.display = e.target.checked ? 'block' : 'none';
       });
       
       document.getElementById('new-node-ping-protocol').addEventListener('change', (e) => {
        const customUrlContainer = document.getElementById('new-node-custom-url-container');
        customUrlContainer.style.display = e.target.value === 'custom' ? 'block' : 'none';
       });
       
       document.getElementById('pick-rack-icon-btn').addEventListener('click', () => {
        openIconPicker((iconData) => {
         selectedRackIconData = iconData;
         const preview = document.getElementById('selected-rack-icon-preview');
         const container = document.getElementById('selected-rack-icon');
         const parser = new DOMParser();
         const doc = parser.parseFromString(iconData.svg, 'image/svg+xml');
         const svgEl = doc.querySelector('svg');
         preview.innerHTML = '';
         if (svgEl) {
          preview.appendChild(svgEl.cloneNode(true));
         }
         const nameSpan = document.createElement('span');
         nameSpan.textContent = iconData.name;
         preview.appendChild(nameSpan);
         container.style.display = 'block';
        });
       });
       
       document.getElementById('pick-node-icon-btn').addEventListener('click', () => {
        openIconPicker((iconData) => {
         selectedNodeIconData = iconData;
         const preview = document.getElementById('selected-node-icon-preview');
         const container = document.getElementById('selected-node-icon');
         const parser = new DOMParser();
         const doc = parser.parseFromString(iconData.svg, 'image/svg+xml');
         const svgEl = doc.querySelector('svg');
         preview.innerHTML = '';
         if (svgEl) {
          preview.appendChild(svgEl.cloneNode(true));
         }
         const nameSpan = document.createElement('span');
         nameSpan.textContent = iconData.name;
         preview.appendChild(nameSpan);
         container.style.display = 'block';
        });
       });
       document.getElementById('pick-tag-icon-btn').addEventListener('click', () => {
        if (!currentNodeId) return;
        openIconPicker((iconData) => {
         if (!currentNodeId || !NODE_DATA[currentNodeId]) return;
         if (!NODE_DATA[currentNodeId].tags) {
          NODE_DATA[currentNodeId].tags = [];
         }
         NODE_DATA[currentNodeId].tags.push({
          type: 'icon',
          library: iconData.library,
          name: iconData.name
         });
         forgeTheTopology();
         claimTheImmortal(currentNodeId);
        });
       });
       document.getElementById('pick-new-node-tag-icon-btn').addEventListener('click', () => {
        openIconPicker((iconData) => {
         newNodeIconTags.push({
          type: 'icon',
          library: iconData.library,
          name: iconData.name
         });
         const container = document.getElementById('new-node-icon-tags');
         const list = document.getElementById('new-node-icon-tags-list');
         const badge = document.createElement('div');
         badge.className = 'icon-badge';
         badge.style.cssText = 'display: inline-flex; align-items: center; gap: 6px; padding: 6px 10px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; font-size: 13px;';
         const iconPreview = document.createElement('div');
         iconPreview.style.cssText = 'width: 16px; height: 16px; display: flex; align-items: center; justify-content: center;';
         IconLibrary.getIcon(iconData.library, iconData.name).then(svg => {
          if (svg) {
           const parser = new DOMParser();
           const doc = parser.parseFromString(svg, 'image/svg+xml');
           const svgEl = doc.querySelector('svg');
           if (svgEl) {
            svgEl.setAttribute('width', '16');
            svgEl.setAttribute('height', '16');
            svgEl.style.fill = 'var(--text-main)';
            iconPreview.appendChild(svgEl);
           }
          }
         });
         const name = document.createElement('span');
         name.textContent = iconData.name;
         name.style.color = 'var(--text-soft)';
         const removeBtn = document.createElement('button');
         removeBtn.textContent = '√ó';
         removeBtn.style.cssText = 'background: none; border: none; color: var(--danger); cursor: pointer; font-size: 18px; line-height: 1; padding: 0 4px;';
         removeBtn.addEventListener('click', () => {
          const index = newNodeIconTags.findIndex(t => t.type === 'icon' && t.library === iconData.library && t.name === iconData.name);
          if (index > -1) {
           newNodeIconTags.splice(index, 1);
          }
          badge.remove();
          if (list.children.length === 0) {
           container.style.display = 'none';
          }
         });
         badge.appendChild(iconPreview);
         badge.appendChild(name);
         badge.appendChild(removeBtn);
         list.appendChild(badge);
         container.style.display = 'block';
        });
       });
       document.getElementById('pick-shape-icon-btn').addEventListener('click', () => {
        if (!currentNodeId) return;
        openIconPicker((iconData) => {
         if (!savedStyles[currentNodeId]) {
          savedStyles[currentNodeId] = {};
         }
         if (!savedStyles[currentNodeId][currentStyleScope]) {
          savedStyles[currentNodeId][currentStyleScope] = {};
         }
         savedStyles[currentNodeId][currentStyleScope].icon = {
          library: iconData.library,
          name: iconData.name
         };
         forgeTheTopology();
        });
       });
       document.getElementById('add-tag-btn').addEventListener('click', () => {
        if (!currentNodeId) return;
        if (!NODE_DATA[currentNodeId]) return;
        const input = document.getElementById('new-tag-input');
        const tagText = input.value.trim();
        if (!tagText) return;
        if (!NODE_DATA[currentNodeId].tags) {
         NODE_DATA[currentNodeId].tags = [];
        }
        NODE_DATA[currentNodeId].tags.push(tagText);
        input.value = '';
        forgeTheTopology();
        claimTheImmortal(currentNodeId);
       });
      
      function saveRollbackVersion(description = "Auto-save") {
        const version = {
          timestamp: Date.now(),
          description,
          data: captureTheQuickening()
        };
        
        try {
          const stored = localStorage.getItem(ROLLBACK_STORAGE_KEY);
          rollbackVersions = stored ? JSON.parse(stored) : [];
        } catch (e) {
          rollbackVersions = [];
        }
        
        rollbackVersions.unshift(version);
        
        if (rollbackVersions.length > MAX_ROLLBACK_VERSIONS) {
          rollbackVersions = rollbackVersions.slice(0, MAX_ROLLBACK_VERSIONS);
        }
        
        try {
          localStorage.setItem(ROLLBACK_STORAGE_KEY, JSON.stringify(rollbackVersions));
        } catch (e) {
          console.warn("Failed to save rollback version:", e);
        }
      }
      
      function loadRollbackVersions() {
        try {
          const stored = localStorage.getItem(ROLLBACK_STORAGE_KEY);
          rollbackVersions = stored ? JSON.parse(stored) : [];
          displayRollbackVersions();
        } catch (e) {
          console.warn("Failed to load rollback versions:", e);
          rollbackVersions = [];
        }
      }
      
      function displayRollbackVersions() {
        const listEl = document.getElementById("rollback-list");
        if (!listEl) return;
        
        if (rollbackVersions.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No version history yet. Versions are saved automatically when you save the file.</div>';
          return;
        }
        
        listEl.innerHTML = rollbackVersions.map((version, index) => {
          const date = new Date(version.timestamp);
          const timeStr = date.toLocaleString();
          const nodeCount = Object.keys(version.data.nodeData || {}).length;
          const edgeCount = (version.data.edgeData?.list || []).length;
          
          return `
            <div class="version-item" onclick="restoreRollbackVersion(${index})">
              <div class="version-info">
                <div class="timestamp">${timeStr}</div>
                <div class="details">${version.description} ‚Ä¢ ${nodeCount} nodes ‚Ä¢ ${edgeCount} connections</div>
              </div>
              <div class="version-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteRollbackVersion(${index})" title="Delete this version">üóëÔ∏è</button>
              </div>
            </div>
          `;
        }).join('');
      }
      
      function restoreRollbackVersion(index) {
        if (!confirm(`Restore version from ${new Date(rollbackVersions[index].timestamp).toLocaleString()}?\n\nYour current work will be lost unless you save first.`)) {
          return;
        }
        
        const version = rollbackVersions[index];
        const data = version.data;
        
        NODE_DATA = data.nodeData || {};
        EDGE_DATA = data.edgeData || { list: [] };
        RECT_DATA = data.rectData || { list: [] };
        TEXT_DATA = data.textData || { list: [] };
        EDGE_LEGEND = data.edgeLegend || {};
        savedPositions = data.nodePositions || {};
        savedSizes = data.nodeSizes || {};
        savedStyles = data.nodeStyles || {};
        PAGE_STATE = data.page || PAGE_STATE;
        
        if (data.canvas) {
          canvasState.zoom = data.canvas.zoom;
          canvasState.panX = data.canvas.panX;
          canvasState.panY = data.canvas.panY;
        }
        
        wieldThePower();
        forgeTheTopology();
        
        document.getElementById("rollback-modal").classList.remove("active");
        
        logAuditEvent("rollback", `Restored version from ${new Date(version.timestamp).toLocaleString()}`);
      }
      
      function deleteRollbackVersion(index) {
        if (!confirm("Delete this version from history?")) return;
        
        rollbackVersions.splice(index, 1);
        try {
          localStorage.setItem(ROLLBACK_STORAGE_KEY, JSON.stringify(rollbackVersions));
        } catch (e) {
          console.warn("Failed to delete version:", e);
        }
        displayRollbackVersions();
      }
      
      function clearRollbackHistory() {
        if (!confirm("Clear all version history?\n\nThis cannot be undone.")) return;
        
        rollbackVersions = [];
        localStorage.removeItem(ROLLBACK_STORAGE_KEY);
        displayRollbackVersions();
      }
      
      function createManualSnapshot() {
        const description = prompt("Enter a description for this snapshot:", "Manual snapshot");
        if (!description) return;
        
        saveRollbackVersion(description);
        displayRollbackVersions();
      }
      
      function switchTab(index) {
        if (index === currentTabIndex) return;
        
        const currentTab = documentTabs[currentTabIndex];
        currentTab.nodes = JSON.parse(JSON.stringify(NODE_DATA));
        currentTab.edges = JSON.parse(JSON.stringify(EDGE_DATA));
        currentTab.positions = JSON.parse(JSON.stringify(savedPositions));
        currentTab.sizes = JSON.parse(JSON.stringify(savedSizes));
        currentTab.styles = JSON.parse(JSON.stringify(savedStyles));
        currentTab.legend = JSON.parse(JSON.stringify(EDGE_LEGEND));
        currentTab.rects = JSON.parse(JSON.stringify(RECT_DATA));
        currentTab.texts = JSON.parse(JSON.stringify(TEXT_DATA));
        currentTab.pageState = JSON.parse(JSON.stringify(PAGE_STATE));

        currentTabIndex = index;
        const newTab = documentTabs[index];
        NODE_DATA = JSON.parse(JSON.stringify(newTab.nodes));
        EDGE_DATA = JSON.parse(JSON.stringify(newTab.edges));
        savedPositions = JSON.parse(JSON.stringify(newTab.positions));
        savedSizes = JSON.parse(JSON.stringify(newTab.sizes));
        savedStyles = JSON.parse(JSON.stringify(newTab.styles));
        EDGE_LEGEND = JSON.parse(JSON.stringify(newTab.legend));
        RECT_DATA = JSON.parse(JSON.stringify(newTab.rects));
        TEXT_DATA = JSON.parse(JSON.stringify(newTab.texts));
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, newTab.pageState || {});
        wieldThePower();
        document.title = newTab.name;
        document.getElementById("page-title").textContent = newTab.name;
        forgeTheTopology();
        displayTabs();
        
        logAuditEvent("tab", `Switched to tab: ${newTab.name}`);
      }
      
      function createNewTab() {
        const nameInput = document.getElementById("new-tab-name");
        const name = nameInput.value.trim();
        
        if (!name) {
          alert("Please enter a tab name");
          return;
        }
        
        const newTab = {
          id: `tab-${Date.now()}`,
          name,
          nodes: {},
          edges: { list: [] },
          positions: {},
          sizes: {},
          styles: {},
          legend: {},
          rects: { list: [] },
          texts: { list: [] },
		  pageState: null
        };
        
        documentTabs.push(newTab);
        nameInput.value = "";
        displayTabs();
        
        logAuditEvent("tab", `Created new tab: ${name}`);
      }
      
      function renameTab(index) {
        const tab = documentTabs[index];
        const newName = prompt("Enter new name:", tab.name);
        if (!newName || newName === tab.name) return;
        
        tab.name = newName;
        displayTabs();
        
        logAuditEvent("tab", `Renamed tab to: ${newName}`);
      }
      
      function deleteTab(index) {
        if (documentTabs.length === 1) {
          alert("Cannot delete the last tab");
          return;
        }
        
        if (!confirm(`Delete tab "${documentTabs[index].name}"?`)) return;
        
        documentTabs.splice(index, 1);
        
        if (currentTabIndex >= documentTabs.length) {
          currentTabIndex = documentTabs.length - 1;
        }
        
        if (currentTabIndex === index) {
          switchTab(currentTabIndex);
        }
        
        displayTabs();
      }
      
      function displayTabs() {
        const listEl = document.getElementById("tabs-list");
        if (!listEl) return;
        
        listEl.innerHTML = documentTabs.map((tab, index) => {
          const nodeCount = Object.keys(tab.nodes).length;
          const edgeCount = tab.edges.list.length;
          const isActive = index === currentTabIndex;
          
          return `
            <div class="tab-item ${isActive ? 'active' : ''}" onclick="switchTab(${index})">
              <div class="tab-name">${tab.name}</div>
              <div class="tab-stats">${nodeCount} nodes ‚Ä¢ ${edgeCount} connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(${index})" title="Rename tab">‚úèÔ∏è</button>
                ${documentTabs.length > 1 ? '<button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(${index})" title="Delete tab">üóëÔ∏è</button>' : ''}
              </div>
            </div>
          `;
        }).join('');
      }
      
      function logAuditEvent(type, description, details = {}) {
        const event = {
          timestamp: Date.now(),
          type,
          description,
          details,
          tab: documentTabs[currentTabIndex]?.name || "Main"
        };
        
        auditLog.unshift(event);
        
        if (auditLog.length > MAX_AUDIT_ENTRIES) {
          auditLog = auditLog.slice(0, MAX_AUDIT_ENTRIES);
        }
        
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to save audit log:", e);
        }
      }
      
      function loadAuditLog() {
        try {
          const stored = localStorage.getItem(AUDIT_STORAGE_KEY);
          auditLog = stored ? JSON.parse(stored) : [];
        } catch (e) {
          console.warn("Failed to load audit log:", e);
          auditLog = [];
        }
      }
      
      function displayAuditLog(filter = "all") {
        const listEl = document.getElementById("audit-log-list");
        if (!listEl) return;
        
        const filtered = filter === "all" ? auditLog : auditLog.filter(e => e.type === filter);
        
        if (filtered.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No audit entries yet</div>';
          return;
        }
        
        listEl.innerHTML = filtered.map(event => {
          const date = new Date(event.timestamp);
          const timeStr = date.toLocaleString();
          
          return `<div class="audit-entry ${event.type}">
              <div class="time">[${timeStr}] ${event.tab}</div>
              <div class="action">[${event.type.toUpperCase()}] ${event.description}</div>
            </div>
          `;
        }).join('');
      }
      
      function clearAuditLog() {
        if (!confirm("Clear all audit log entries?\n\nThis cannot be undone.")) return;
        
        auditLog = [];
        localStorage.removeItem(AUDIT_STORAGE_KEY);
        displayAuditLog();
      }
      
      function exportAuditLog() {
        if (auditLog.length === 0) {
          alert("No audit entries to export");
          return;
        }
        
        const csv = [
          ["Timestamp", "Tab", "Type", "Description"],
          ...auditLog.map(e => [
            new Date(e.timestamp).toISOString(),
            e.tab,
            e.type,
            e.description
          ])
        ].map(row => row.map(cell => `"${cell}"`).join(",")).join("\n");
        
        const blob = new Blob([csv], { type: "text/csv" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `audit-log-${Date.now()}.csv`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }
      
      let currentSecretName = null;
      
      function createNewSecret() {
        const nameInput = document.getElementById("new-secret-name");
        const name = nameInput.value.trim();
        
        if (!name) {
          alert("Please enter a note name");
          return;
        }
        
        if (encryptedSections[name]) {
          alert("A note note with this name already exists");
          return;
        }
        
        currentSecretName = name;
        encryptedSections[name] = { encrypted: false, data: "" };
        nameInput.value = "";
        
        document.getElementById("secret-editor-title").textContent = `New note: ${name}`;
        document.getElementById("secret-editor-content").value = "";
        document.getElementById("secrets-modal").classList.remove("active");
        document.getElementById("secret-editor-modal").classList.add("active");
        
        displaySecrets();
      }
      
      function editSecret(name) {
        currentSecretName = name;
        const section = encryptedSections[name];
        
        if (section.encrypted) {
          const password = prompt(`Enter password to decrypt "${name}":`);
          if (!password) return;
          
          try {
            decryptData(section.data, password).then(decrypted => {
              document.getElementById("secret-editor-title").textContent = `Edit Secret: ${name}`;
              document.getElementById("secret-editor-content").value = decrypted;
              document.getElementById("secrets-modal").classList.remove("active");
              document.getElementById("secret-editor-modal").classList.add("active");
            }).catch(e => {
              alert("Failed to decrypt. Wrong password?");
            });
          } catch (e) {
            alert("Failed to decrypt. Wrong password?");
          }
        } else {
          document.getElementById("secret-editor-title").textContent = `Edit note: ${name}`;
          document.getElementById("secret-editor-content").value = section.data;
          document.getElementById("secrets-modal").classList.remove("active");
          document.getElementById("secret-editor-modal").classList.add("active");
        }
      }
      
      async function saveSecret() {
        if (!currentSecretName) return;
        
        const content = document.getElementById("secret-editor-content").value;
        const autoEncrypt = document.getElementById("secret-auto-encrypt").checked;
        
        if (autoEncrypt) {
          const password = prompt(`Enter password to encrypt "${currentSecretName}":`);
          if (!password) return;
          
          const confirmPassword = prompt("Confirm password:");
          if (password !== confirmPassword) {
            alert("Passwords do not match");
            return;
          }
          
          try {
            const encrypted = await encryptData(content, password);
            encryptedSections[currentSecretName] = { encrypted: true, data: encrypted };
          } catch (e) {
            alert("Encryption failed: " + e.message);
            return;
          }
        } else {
          encryptedSections[currentSecretName] = { encrypted: false, data: content };
        }
        
        closeSecretEditor();
        displaySecrets();
        
        logAuditEvent("secret", `Saved note section: ${currentSecretName}`);
      }
      
      function closeSecretEditor() {
        document.getElementById("secret-editor-modal").classList.remove("active");
        document.getElementById("secrets-modal").classList.add("active");
        currentSecretName = null;
      }
      
      function deleteSecret(name) {
        if (!confirm(`Delete note "${name}"?`)) return;
        
        delete encryptedSections[name];
        displaySecrets();
        
        logAuditEvent("secret", `Deleted note: ${name}`);
      }
      
      function displaySecrets() {
        const listEl = document.getElementById("secrets-list");
        if (!listEl) return;
        
        const secrets = Object.keys(encryptedSections);
        
        if (secrets.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No notes yet</div>';
          return;
        }
        
        listEl.innerHTML = secrets.map(name => {
          const section = encryptedSections[name];
          const status = section.encrypted ? "üîí Encrypted" : "üîì Plaintext";
          
          return `
            <div class="secret-item">
              <div class="secret-name">${name}</div>
              <div class="secret-status">${status}</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="editSecret('${name}')" title="Edit note">‚úèÔ∏è</button>
                <button class="btn-cancel" onclick="deleteSecret('${name}')" title="Delete note">üóëÔ∏è</button>
              </div>
            </div>
          `;
        }).join('');
      }
      
       const clearAllBtn = document.getElementById("clear-all-btn");
       const clearAllModal = document.getElementById("clear-all-modal");
       const clearAllCancel = document.getElementById("clear-all-cancel");
       const clearAllConfirm = document.getElementById("clear-all-confirm");
       clearAllBtn.addEventListener("click", () => {
        clearAllModal.classList.add("active");
       });
       clearAllCancel.addEventListener("click", () => {
        clearAllModal.classList.remove("active");
       });
       clearAllModal.addEventListener("click", (e) => {
        if (e.target === clearAllModal) {
         clearAllModal.classList.remove("active");
        }
       });
       clearAllConfirm.addEventListener("click", () => {
        NODE_DATA = {};
        EDGE_DATA = {
         list: []
        };
        EDGE_LEGEND = {};
        RECT_DATA = { list: [] };
        TEXT_DATA = { list: [] };
        savedPositions = {};
        savedSizes = {};
        savedStyles = {};
        clearAllModal.classList.remove("active");
      
      autoPingEnabled = false;
      autoPingInterval = 30;
      PAGE_STATE.autoPingEnabled = false;
      PAGE_STATE.autoPingInterval = autoPingInterval;
      
      stopAutoPing();
      
      document.getElementById("auto-ping-enabled").checked = false;
      document.getElementById("auto-ping-settings").style.display = "none";
      document.getElementById("auto-ping-interval").value = autoPingInterval;
        forgeTheTopology();
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.display = "none";
        currentNodeId = null;
        currentEdgeId = null;
        currentTextId = null;
       });
       (function addDeleteNodeButton() {
        const nodePanel = document.getElementById("node-panel");
        if (!nodePanel) return;
        if (document.getElementById("delete-node-btn")) return;
        const deleteBtn = document.createElement("button");
        deleteBtn.id = "delete-node-btn";
        deleteBtn.textContent = "Delete Node";
        deleteBtn.style.cssText = "margin-top:15px; padding:10px 16px; background:var(--danger); color:#fff; border:none; border-radius:6px; cursor:pointer; font-size:clamp(14px,1.6vw,18px); font-weight:600; width:100%;";
        deleteBtn.addEventListener("click", () => {
         if (!currentNodeId) return;
         challengeTheImmortal(`Delete node "${NODE_DATA[currentNodeId]?.name || currentNodeId}" and all its connections?`,
          () => {
           EDGE_DATA.list = EDGE_DATA.list.filter(
            (e) => e.from !== currentNodeId && e.to !== currentNodeId, );
           delete NODE_DATA[currentNodeId];
           delete savedPositions[currentNodeId];
           delete savedSizes[currentNodeId];
           delete savedStyles[currentNodeId];
           currentNodeId = null;
           currentEdgeId = null;
           forgeTheTopology();
           const remainingNodes = Object.keys(NODE_DATA);
           if (remainingNodes.length > 0) {
            claimTheImmortal(remainingNodes[0]);
           } else {
            document.getElementById("node-panel").style.display = "none";
            document.getElementById("edge-panel").style.display = "none";
            document.getElementById("topology-toolbar", ).style.display = "none";
           }
          }, );
        });
        nodePanel.appendChild(deleteBtn);
       })();
      
       function screenshotCanvas() {
        const svg = document.getElementById("map");
        const svgClone = svg.cloneNode(true);
        const viewBox = svg.getAttribute("viewBox").split(" ").map(Number);
        const [x, y, width, height] = viewBox;
        svgClone.setAttribute("width", width);
        svgClone.setAttribute("height", height);
        svgClone.setAttribute("viewBox", `${x} ${y} ${width} ${height}`);
        const wrapper = document.createElement("div");
        wrapper.style.position = "absolute";
        wrapper.style.left = "-9999px";
        wrapper.appendChild(svgClone);
        document.body.appendChild(wrapper);
      
        function inlineStyles(original, clone) {
         const elements = original.querySelectorAll("*");
         const clonedElements = clone.querySelectorAll("*");
         const rootStyles = getComputedStyle(document.documentElement);
         const bgColor = rootStyles.getPropertyValue("--bg").trim() || "#050608";
         const bgRect = document.createElementNS("http://www.w3.org/2000/svg", "rect", );
         bgRect.setAttribute("x", x);
         bgRect.setAttribute("y", y);
         bgRect.setAttribute("width", width);
         bgRect.setAttribute("height", height);
         bgRect.setAttribute("fill", bgColor);
         clone.insertBefore(bgRect, clone.firstChild);
         elements.forEach((el, index) => {
          const clonedEl = clonedElements[index];
          if (!clonedEl) return;
          const computedStyle = getComputedStyle(el);
          const svgProps = ["fill", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin", "opacity", "font-family", "font-size", "font-weight", "font-style", "text-anchor", "dominant-baseline", "marker-start", "marker-end", ];
          svgProps.forEach((prop) => {
           const value = computedStyle.getPropertyValue(prop);
           if (value && value !== "none" && value !== "normal") {
            clonedEl.style[prop] = value;
           }
          });
          clonedEl.removeAttribute("class");
         });
        }
        inlineStyles(svg, svgClone);
        const svgData = new XMLSerializer().serializeToString(svgClone);
        document.body.removeChild(wrapper);
        const svgBlob = new Blob([svgData], {
         type: "image/svg+xml;charset=utf-8",
        });
        const url = URL.createObjectURL(svgBlob);
        const img = new Image();
        img.onload = function() {
         const canvas = document.createElement("canvas");
         canvas.width = width;
         canvas.height = height;
         const ctx = canvas.getContext("2d");
         ctx.drawImage(img, 0, 0);
         canvas.toBlob(function(blob) {
          const link = document.createElement("a");
          const timestamp = new Date().toISOString().slice(0, 10);
          link.download = `topology-${timestamp}.png`;
          link.href = URL.createObjectURL(blob);
          link.click();
          URL.revokeObjectURL(url);
          URL.revokeObjectURL(link.href);
         }, "image/png");
        };
        img.onerror = function() {
         console.error("Failed to load SVG image");
         alert("Screenshot failed. Please try again.");
         URL.revokeObjectURL(url);
        };
        img.src = url;
       }
      
       function exportCanvasSVG() {
        const svg = document.getElementById("map");
        const svgClone = svg.cloneNode(true);
        const viewBox = svg.getAttribute("viewBox").split(" ").map(Number);
        const [x, y, width, height] = viewBox;
        svgClone.setAttribute("width", width);
        svgClone.setAttribute("height", height);
        const rootStyles = getComputedStyle(document.documentElement);
        const bgColor = rootStyles.getPropertyValue("--bg").trim() || "#050608";
        const bgRect = document.createElementNS("http://www.w3.org/2000/svg", "rect", );
        bgRect.setAttribute("x", x);
        bgRect.setAttribute("y", y);
        bgRect.setAttribute("width", width);
        bgRect.setAttribute("height", height);
        bgRect.setAttribute("fill", bgColor);
        svgClone.insertBefore(bgRect, svgClone.firstChild);
        const wrapper = document.createElement("div");
        wrapper.style.position = "absolute";
        wrapper.style.left = "-9999px";
        wrapper.appendChild(svgClone);
        document.body.appendChild(wrapper);
        const elements = svg.querySelectorAll("*");
        const clonedElements = svgClone.querySelectorAll("*");
        elements.forEach((el, index) => {
         const clonedEl = clonedElements[index];
         if (!clonedEl) return;
         const computedStyle = getComputedStyle(el);
         const svgProps = ["fill", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin", "opacity", "font-family", "font-size", "font-weight", "font-style", "text-anchor", "dominant-baseline", "marker-start", "marker-end", ];
         svgProps.forEach((prop) => {
          const value = computedStyle.getPropertyValue(prop);
          if (value && value !== "none" && value !== "normal") {
           clonedEl.setAttribute(prop, value);
          }
         });
         clonedEl.removeAttribute("class");
        });
        const svgData = new XMLSerializer().serializeToString(svgClone);
        document.body.removeChild(wrapper);
        const blob = new Blob([svgData], {
         type: "image/svg+xml;charset=utf-8",
        });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        const timestamp = new Date().toISOString().slice(0, 10);
        link.download = `topology-${timestamp}.svg`;
        link.href = url;
        link.click();
        URL.revokeObjectURL(url);
       }
      let resizeTimeout;
       window.addEventListener('resize', () => {
       clearTimeout(resizeTimeout);
       resizeTimeout = setTimeout(() => {
       updateDrawToolbarVisibility();
       updateTopologyToolbarVisibility();
       }, 100);
      });	   
    </script>
  
</body></html>