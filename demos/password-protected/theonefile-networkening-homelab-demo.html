<!DOCTYPE html> 
 <html lang="en" style="--panel: #541c1c; --panel-alt: #701010; --accent: #feb4b4; --danger: #ff5c5c; --text-main: #ffffff; --text-soft: #ffffff; --topbar-bg: #000000; --topbar-border: #000000; --topbar-height: 100px; --sidebar-width: 435px; --mobile-footer-height: 20vh; --draw-toolbar-height: 45px; --sidebar-bg: #10141b; --btn-bg: #0b0e13; --btn-text: #e2e8f0; --tag-fill: #1e293b; --tag-text: #e2e8f0; --tag-border: #475569; --input-bg: #0b0e13; --input-text: #e2e8f0; --input-border: #1f2937; --input-font: Inter, system-ui, sans-serif; --input-font-size: 14px; --toolbar-bg: #0f172a; --toolbar-border: #1f2937; --toolbar-text: #94a3b8; --toolbar-btn-bg: #0b0e13; --toolbar-btn-text: #e2e8f0; --minimap-dots: #94a3b8; --canvas-hint-bg: #0f172a; --canvas-hint-color: #94a3b8; --node-fill: #1e293b; --node-stroke: #475569; --node-title: #e2e8f0; --node-sub: #94a3b8; --node-title-size: 18px; --node-sub-size: 13px; --node-font: Inter, system-ui, sans-serif; --default-edge: #475569; --selection-handle: #f59e0b; --selection-handle-size: 8px; --group-indicator: #4fd1c5;"><head>
    <meta charset="UTF-8">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Homelab</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- 
      * ==================================================================================
      * The One File: The Networkening
      * !!!!!!!!!!!!!!!!!!!NOTE: THIS IS THE ONLINE VERSION!!!!!!!!!!!!!!!!!!!!!!
      * Online version uses 3 cdn calls from cdn.jsdelivr.net to display additional icons
      * Since 3.0 Online version uses http as a form of ping to display uptime
      * "There can be only one". A all in one file topology maker.
      * 
      * This is your last backup when all others fail. A completely self-contained
      * network topology visualization tool that works as a single HTML file.
      * Open it anywhere, anytime and the idea lives forever.
      * ==================================================================================
      -->
    <style>
      :root {
      color-scheme: dark;
      --bg: #050608;
      --panel: #0b0e13;
      --panel-alt: #10141b;
      --accent: #4fd1c5;
      --danger: #f56565;
      --text-main: #e2e8f0;
      --text-soft: #94a3b8;
      --edge-main: #475569;
      --node-min: 35px;
      --node-max: 70px;
      --topbar-bg: rgba(9, 12, 20, 0.9);
      --topbar-border: #1f2533;
      }
      * {
      box-sizing: border-box;
      user-select: none;
      }
      input,
      textarea,
      [contenteditable="true"] {
      user-select: text;
      -webkit-user-select: text;
      }
      body {
      margin: 0;
      font-family: system-ui, sans-serif;
      background: radial-gradient(circle at top, #1e2532 0, #050608 70%);
      color: var(--text-main);
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
      }
      header {
      padding: 0 20px;
      height: var(--topbar-height, 52px);
      min-height: var(--topbar-height, 52px);
      background: var(--topbar-bg);
      backdrop-filter: blur(6px);
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid var(--topbar-border);
      gap: 16px;
      }
      .title-block {
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-width: 0;
      }
      header h1 {
      font-size: clamp(22px, 3vw, 32px);
      margin: 0;
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
      }
      .editable-page-title {
      cursor: pointer;
      transition: opacity 0.2s;
      }
      .editable-page-title:hover {
      opacity: 0.7;
      }
      .save-row {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      }
      .save-btn {
      padding: 6px 12px;
      background: var(--accent);
      color: var(--bg);
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      white-space: nowrap;
      }
      .save-btn:hover {
      opacity: 0.9;
      }
      .help-icon {
      width: 22px;
      height: 22px;
      border-radius: 50%;
      border: 1px solid var(--edge-main);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      cursor: pointer;
      color: var(--text-soft);
      background: rgba(15, 23, 42, 0.9);
      flex-shrink: 0;
      }
      .help-icon:hover {
      color: var(--accent);
      border-color: var(--accent);
      }
#settings-btn {
      background: var(--btn-bg, var(--panel));
      color: var(--btn-text, var(--text-main));
      border: 1px solid var(--edge-main);
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 16px;
      flex-shrink: 0;
      }
      #settings-btn:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .header-resizer {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 6px;
      background: transparent;
      cursor: row-resize;
      z-index: 1000;
      transition: background 0.2s;
      }
      .header-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .header-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      .sidebar-resizer {
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 6px;
      background: transparent;
      cursor: col-resize;
      z-index: 1000;
      transition: background 0.2s;
      }
      .sidebar-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .sidebar-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      .mobile-footer-resizer {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 6px;
      background: transparent;
      cursor: row-resize;
      z-index: 1000;
      transition: background 0.2s;
      display: none;
      }
      .mobile-footer-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .mobile-footer-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      @media (max-width: 900px) {
      .mobile-footer-resizer {
      display: block;
      height: 12px;
      }
      .sidebar-resizer {
      display: none;
      }
      .header-resizer {
      height: 12px;
      }
      }
      @media (pointer: coarse) {
      .header-resizer {
      height: 16px;
      }
      .mobile-footer-resizer {
      height: 16px;
      }
      .sidebar-resizer {
      width: 16px;
      }
      }
      .resizer-icon {
      position: absolute;
      opacity: 0.5;
      transition: opacity 0.2s, transform 0.2s;
      pointer-events: none;
      fill: var(--accent);
      }
      .header-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .sidebar-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .mobile-footer-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .header-resizer:hover .resizer-icon,
      .sidebar-resizer:hover .resizer-icon,
      .mobile-footer-resizer:hover .resizer-icon {
      opacity: 1;
      }
      .header-resizer.resizing .resizer-icon,
      .sidebar-resizer.resizing .resizer-icon,
      .mobile-footer-resizer.resizing .resizer-icon {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1.2);
      }
      body.resizing {
      user-select: none;
      }
      body.resizing * {
      cursor: inherit !important;
      pointer-events: none;
      }
      header {
      position: relative;
      }
      .details-panel {
      position: relative;
      }
      main {
      display: grid;
      grid-template-columns: 1fr var(--sidebar-width, 350px);
      flex: 1;
      }
      main.sidebar-collapsed {
      grid-template-columns: 1fr 0;
      }
      @media (max-width: 900px) {
      main {
      grid-template-columns: 1fr;
      grid-template-rows: calc(100vh - var(--topbar-height, 52px) - var(--mobile-footer-height, 40vh)) var(--mobile-footer-height, 40vh);
      }
      main.sidebar-collapsed {
      grid-template-rows: 1fr 0;
      }
      .details-panel {
      max-height: var(--mobile-footer-height, 40vh);
      height: 100%;
      }
      }
      .topology-panel {
      background: var(--panel);
      border-right: 1px solid #111827;
      position: relative;
      overflow: hidden;
      }
.topology-toolbar {
      position: absolute;
      top: 10px;
      right: 10px;
      display: none;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      z-index: 99;
      font-size: 13px;
      color: var(--toolbar-text, #94a3b8);
      }
.topology-toolbar label {
      color: var(--toolbar-text, var(--text-soft));
      }
.topology-toolbar select {
      padding: 4px 6px;
      background: var(--toolbar-btn-bg, var(--panel));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 13px;
      cursor: pointer;
      }
.topology-toolbar button {
      padding: 4px 10px;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      }
      .topology-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .bulk-toolbar-desktop,
      .bulk-toolbar-mobile {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 9999;
      }
      .bulk-toolbar-desktop {
      position: absolute;
      top: 10px;
      right: 10px;
      bottom: auto;
      left: auto;
      transform: none;
      }
      @media (min-width: 768px) {
      .bulk-toolbar-mobile {
      display: none !important;
      }
      }	  
      .bulk-action-btn {
      padding: 16px;
      background: var(--panel-main);
      border: 1px solid var(--edge-main);
      border-radius: 8px;
      color: var(--text-main);
      font-size: 24px;
      cursor: pointer;
      text-align: center;
      line-height: 1.2;
      }
      .bulk-action-btn:active {
      transform: scale(0.95);
      background: var(--accent);
      }
.draw-toolbar {
      position: absolute;
      top: 10px;
      left: 10px;
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 8px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      z-index: 99;
      font-size: 13px;
      pointer-events: auto;
      color: var(--toolbar-text, #94a3b8);
      }
.draw-toolbar button {
      padding: 4px 8px;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      }
      .draw-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .draw-toolbar input[type="color"] {
      width: 30px;
      height: 22px;
      border-radius: 4px;
      border: 1px solid var(--edge-main);
      padding: 0;
      background: transparent;
      cursor: pointer;
      }
.draw-toolbar select {
      padding: 4px 6px;
      background: var(--toolbar-btn-bg, var(--panel));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 13px;
      cursor: pointer;
      }
.legend-container {
      position: absolute;
      left: 10px;
      bottom: 10px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      padding: 8px 10px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      font-size: 12px;
      z-index: 20;
      max-width: 260px;
      pointer-events: auto;
      color: var(--toolbar-text, #94a3b8);
      }
      .legend-container {
      padding-right: 22px;
      }
      @media (max-width: 900px) {
      .legend-container {
      max-height: calc(100vh - var(--topbar-height, 100px) - 120px);
      overflow-y: auto;
      }
      }
      @media (max-width: 900px) {
      .bulk-toolbar-desktop,
      .topology-toolbar {
      display: none !important;
      }
      }
      .legend-close-btn {
      position: absolute;
      top: 5px;
      right: 5px;
      width: 18px;
      height: 18px;
      border-radius: 999px;
      border: 1px solid var(--edge-main);
      background: var(--panel-alt);
      color: var(--text-soft);
      font-size: 11px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      }
      .legend-close-btn:hover {
      background: var(--danger);
      color: #fff;
      }
.legend-mini-btn {
      position: absolute;
      left: 10px;
      padding: 4px 8px;
      border-radius: 4px;
      border: 1px solid var(--toolbar-border, #1f2937);
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 11px;
      cursor: pointer;
      z-index: 20;
      display: none;
      transition: all 0.2s;
      }
      .legend-mini-btn:hover,
      .legend-mini-btn:active {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
      }
.legend-title {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: var(--toolbar-text, var(--text-soft));
      margin-bottom: 2px;
      }
      .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      }
      .legend-swatch {
      width: 14px;
      height: 14px;
      border-radius: 3px;
      border: 1px solid #020617;
      flex-shrink: 0;
      }
      .legend-label {
      outline: none;
      cursor: text;
      flex: 1;
      min-width: 60px;
      user-select: text;
      -webkit-user-select: text;
      }
      .legend-label.editing {
      border-bottom: 1px dashed var(--accent);
      }
      .canvas-viewport {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      overflow: hidden;
      }
      .canvas-viewport.panning {
      cursor: grabbing !important;
      }
      .canvas-viewport.panning * {
      cursor: grabbing !important;
      }
      .canvas-viewport svg {
      width: 100%;
      height: 100%;
      display: block;
      background: linear-gradient(rgba(71, 85, 105, 0.1) 1px,
      transparent 1px),
      linear-gradient(90deg,
      rgba(71, 85, 105, 0.1) 1px,
      transparent 1px),
      linear-gradient(rgba(71, 85, 105, 0.05) 1px, transparent 1px),
      linear-gradient(90deg,
      rgba(71, 85, 105, 0.05) 1px,
      transparent 1px);
      background-size:
      100px 100px,
      100px 100px,
      20px 20px,
      20px 20px;
      background-position:
      -1px -1px,
      -1px -1px,
      -1px -1px,
      -1px -1px;
      }
.zoom-toolbar {
      display: flex;
      gap: 4px;
      padding: 6px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      }
.zoom-toolbar button {
      width: 32px;
      height: 32px;
      padding: 0;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 18px;
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
      }
      .zoom-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
.zoom-toolbar .zoom-level {
      font-size: 11px;
      color: var(--toolbar-text, var(--text-soft));
      text-align: center;
      padding: 2px 0;
      min-width: 32px;
      }
.zoom-toolbar .divider {
      height: 1px;
      background: var(--toolbar-border, var(--edge-main));
      margin: 2px 0;
      }
      .minimap-zoom-wrapper {
      position: absolute;
      bottom: 10px;
      right: 10px;
      z-index: 99;
      }
.minimap-container {
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      overflow: hidden;
      margin-bottom: 4px;
      }
      .minimap-container svg {
      width: 100%;
      height: 100%;
      }
      .minimap-viewport {
      fill: rgba(79, 209, 197, 0.2);
      stroke: var(--accent);
      stroke-width: 2;
      cursor: move;
      }
.minimap-node {
      fill: var(--minimap-dots, var(--text-soft));
      }
      .minimap-edge {
      stroke: var(--edge-main);
      stroke-width: 1;
      }
.minimap-close-btn {
      position: absolute;
      top: 2px;
      right: 2px;
      width: 18px;
      height: 18px;
      background: var(--toolbar-btn-bg, rgba(15, 23, 42, 0.9));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 3px;
      color: var(--toolbar-text, var(--text-soft));
      font-size: 11px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
      padding: 0;
      line-height: 1;
      }
      .minimap-close-btn:hover {
      background: var(--danger);
      color: white;
      border-color: var(--danger);
      }
.toolbar-close-btn {
      width: 24px;
      height: 24px;
      background: var(--toolbar-btn-bg, rgba(15, 23, 42, 0.9));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-text, var(--text-soft));
      font-size: 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      line-height: 1;
      flex-shrink: 0;
      }
      .toolbar-close-btn:hover {
      background: var(--danger);
      color: white;
      border-color: var(--danger);
      }
.canvas-hint {
      position: absolute;
      top: 50px;
      left: 50%;
      transform: translateX(-50%);
      padding: 8px 16px;
      background: var(--canvas-hint-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      font-size: 12px;
      color: var(--canvas-hint-color, var(--text-soft));
      z-index: 18;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
      }
      .canvas-hint.visible {
      opacity: 1;
      }
      .edge {
      stroke: var(--edge-main);
      stroke-width: 4;
      opacity: 0.75;
      transition: 0.25s ease-in-out;
      cursor: pointer;
      }
      .edge.backup {
      stroke: var(--danger);
      stroke-width: 5;
      }
      .edge.active {
      opacity: 1;
      stroke-width: 7;
      }
      .free-preview {
      fill: none;
      stroke-dasharray: 4 4;
      pointer-events: none;
      }
      .free-point {
      fill: #e5e7eb;
      stroke: #0f172a;
      stroke-width: 1.5;
      cursor: grab;
      }
      .node-circle {
      fill: var(--node-fill, #1e293b);
      stroke: var(--node-stroke, #475569);
      stroke-width: 2;
      transition: 0.25s ease;
      transform-origin: center center;
      }
      .node-hit-area {
      cursor: grab;
      pointer-events: all;
      }
      .node-group:hover .node-circle {
      filter: drop-shadow(0 0 10px rgba(79, 209, 197, 0.45));
      }
      .node-group.active .node-circle {
      stroke: var(--accent);
      animation: pulse 1.2s infinite ease-in-out;
      }
      @keyframes pulse {
      0% {
      filter: drop-shadow(0 0 4px #4fd1c5);
      }
      50% {
      filter: drop-shadow(0 0 14px #4fd1c5);
      }
      100% {
      filter: drop-shadow(0 0 4px #4fd1c5);
      }
      }
      .node-label {
      fill: var(--text-main);
      font-size: 18px;
      text-anchor: middle;
      font-weight: 600;
      }
      .node-sub {
      fill: var(--text-soft);
      font-size: 13px;
      text-anchor: middle;
      }
      .ping-indicator {
      fill: #6b7280;
      stroke: #4b5563;
      stroke-width: 1;
      }
      .ping-indicator.online {
      fill: #10b981;
      stroke: #059669;
      }
      .ping-indicator.offline {
      fill: #ef4444;
      stroke: #dc2626;
      }
      .ping-indicator.checking {
      fill: #f59e0b;
      stroke: #d97706;
      }
      @media (max-width: 1024px) {
      .node-label {
      font-size: 28px;
      }
      .node-sub {
      font-size: 20px;
      }
      }
      @media (max-width: 768px) {
      .node-label {
      font-size: 70px;
      }
      .node-sub {
      font-size: 50px;
      }
      }
      @media (max-width: 380px) {
      .node-label {
      font-size: 60px;
      }
      .node-sub {
      font-size: 42px;
      }
      }
      .details-panel {
      background: var(--sidebar-bg, var(--panel-alt));
      padding: 22px;
      padding-bottom: 80px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 15px;
      position: relative;
      transition:
      width 0.3s ease,
      min-width 0.3s ease,
      padding 0.3s ease,
      opacity 0.3s ease;
      }
      .details-panel {
      min-width: 260px !important;
      }
      .details-panel {
      overflow-y: auto !important;
      overflow-x: hidden;
      }
      .details-panel.collapsed {
      width: 0 !important;
      min-width: 0 !important;
      padding: 0 !important;
      overflow: hidden;
      opacity: 0;
      }
      body {
      overflow-x: hidden;
      overflow-y: hidden;
      }
      main {
      overflow-x: hidden;
      overflow-y: visible;
      }
      .details-panel {
      overflow-y: auto !important;
      overflow-x: hidden;
      }
      .details-panel.collapsed {
      min-width: 0 !important;
      }
      .sidebar-toggle {
      position: absolute;
      left: -16px;
      top: 50%;
      transform: translateY(-50%);
      width: 16px;
      height: 60px;
      background: var(--sidebar-bg, var(--panel-alt));
      border: 1px solid var(--edge-main);
      border-right: none;
      border-radius: 8px 0 0 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text-soft);
      font-size: 10px;
      z-index: 25;
      transition:
      background 0.2s,
      color 0.2s;
      }
      .sidebar-toggle:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .sidebar-toggle.collapsed {
      left: 0;
      border-right: 1px solid var(--edge-main);
      border-radius: 0 8px 8px 0;
      position: fixed;
      right: 0;
      left: auto;
      }
      .details-name {
      font-size: clamp(22px, 2.5vw, 30px);
      font-weight: 700;
      }
      .details-ip {
      font-size: clamp(16px, 2vw, 22px);
      color: var(--text-soft);
      }
      .details-role {
      font-size: clamp(16px, 2vw, 22px);
      color: var(--accent);
      }
      .size-controls {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-top: 10px;
      }
      .size-controls label {
      font-size: clamp(14px, 1.6vw, 18px);
      color: var(--text-soft);
      }
      .size-controls input[type="range"] {
      flex: 1;
      accent-color: var(--accent);
      }
      .size-controls button {
      padding: 6px 12px;
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      font-size: clamp(12px, 1.4vw, 16px);
      }
      .size-controls button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .style-section {
      margin-top: 15px;
      padding-top: 15px;
      border-top: 1px solid var(--edge-main);
      }
      .style-section summary {
      cursor: pointer;
      font-size: clamp(14px, 1.6vw, 20px);
      text-transform: uppercase;
      color: var(--text-soft);
      list-style: none;
      display: flex;
      justify-content: space-between;
      align-items: center;
      user-select: none;
      }
      .style-section summary::-webkit-details-marker {
      display: none;
      }
      .password-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #ffffff;
      z-index: 9999;
      }
      .style-section summary::after {
      content: "‚ñº";
      transition: transform 0.2s;
      }
      .style-section[open] summary::after {
      transform: rotate(180deg);
      }
      .style-content {
      margin-top: 10px;
      }
      .style-row {
      display: flex;
      gap: 10px;
      align-items: center;
      margin: 8px 0;
      }
      .style-row label {
      font-size: clamp(13px, 1.5vw, 17px);
      color: var(--text-soft);
      min-width: 80px;
      }
      .style-row input[type="color"] {
      width: 50px;
      height: 30px;
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      background: transparent;
      }
      .style-row input[type="number"] {
      width: 70px;
      padding: 4px 8px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(12px, 1.4vw, 16px);
      }
      .style-row select {
      flex: 1;
      padding: 4px 8px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(12px, 1.4vw, 16px);
      cursor: pointer;
      }
      .editable-text {
      cursor: pointer;
      transition: opacity 0.2s;
      }
      .editable-text:hover {
      opacity: 0.7;
      }
      .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 999999;
      justify-content: center;
      align-items: center;
      overflow: auto;
      }
      .modal.active {
      display: inline-grid;
      }
      .modal-content {
      background: var(--panel-alt);
      padding: 25px;
      border-radius: 8px;
      border: 1px solid var(--edge-main);
      min-width: 300px;
      max-width: 90%;
      }
      .modal-content h3 {
      margin: 0 0 15px 0;
      color: var(--text-main);
      font-size: clamp(18px, 2vw, 24px);
      }
      .modal-content p {
      color: var(--text-soft);
      font-size: clamp(14px, 1.6vw, 18px);
      margin: 0 0 20px 0;
      }
      .modal-content input:not([type="color"]),
      .modal-content select {
      width: 100%;
      padding: 10px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(14px, 1.6vw, 18px);
      margin-bottom: 15px;
      user-select: text;
      -webkit-user-select: text;
      }
      .modal-content input[type="color"] {
      width: 60px;
      height: 36px;
      padding: 2px;
      border: 2px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      background: none;
      -webkit-appearance: none;
      appearance: none;
      }
      .modal-content input[type="color"]::-webkit-color-swatch-wrapper {
      padding: 0;
      }
      .modal-content input[type="color"]::-webkit-color-swatch {
      border: none;
      border-radius: 4px;
      }
      .modal-buttons {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
      margin-top: 10px;
      }
      .modal-buttons button {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: clamp(14px, 1.6vw, 18px);
      font-weight: 600;
      }
      .modal-buttons .btn-cancel {
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      }
      .modal-buttons .btn-save {
      background: var(--accent);
      color: var(--bg);
      }
      .modal-buttons .btn-delete {
      background: var(--danger);
      color: white;
      }
      .confirm-modal p {
      color: var(--text-soft);
      font-size: clamp(14px, 1.6vw, 18px);
      margin: 0 0 20px 0;
      }
      .context-menu-item {
      transition: background 0.15s;
      }
      .context-menu-item:hover {
      background: var(--panel);
      }
      .details-info-row {
      display: flex;
      align-items: center;
      margin: 6px 0;
      }
	 .node-group.selected .node-circle {
      stroke: var(--selection-handle, #f59e0b);
      stroke-width: 3;
      }
	  .node-group.layer-faded {
      pointer-events: none;
      }
      .edge.layer-faded {
      pointer-events: none;
      }
      .node-group.search-highlight .node-circle,
      .node-group.search-highlight rect,
      .node-group.search-highlight polygon {
      stroke: #10b981;
      stroke-width: 3;
      filter: drop-shadow(0 0 8px #10b981);
      }
      .badge-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      }
     .badge {
      background: var(--tag-fill, #1e293b);
      color: var(--tag-text, #e2e8f0);
      border: 1px solid var(--tag-border, var(--edge-main));
      padding: 5px 12px;
      border-radius: 22px;
      font-size: clamp(12px, 1.4vw, 18px);
      }
.badge.wg {
      color: var(--accent);
      border-color: var(--accent);
      }
input[type="text"],
      input[type="number"],
      input[type="password"],
      textarea,
      select {
      background: var(--input-bg, #0b0e13) !important;
      color: var(--input-text, #e2e8f0) !important;
      border-color: var(--input-border, #1f2937) !important;
      font-family: var(--input-font, Inter, system-ui, sans-serif) !important;
      font-size: var(--input-font-size, 14px) !important;
      }
      .section-label {
      margin-top: 8px;
      font-size: clamp(14px, 1.6vw, 20px);
      text-transform: uppercase;
      color: var(--text-soft);
      }
      .list li {
      margin: 6px 0;
      font-size: clamp(14px, 1.6vw, 20px);
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      }
      .list li:hover {
      color: var(--accent);
      }
      .delete-note {
      color: var(--danger);
      font-size: 18px;
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.2s;
      flex-shrink: 0;
      }
      .list li:hover .delete-note {
      opacity: 1;
      }
      .editing {
      outline: 2px solid var(--accent);
      background: #0d141f;
      padding: 4px;
      border-radius: 6px;
      user-select: text;
      -webkit-user-select: text;
      }
      .mobile-menu-btn {
      display: none;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      color: var(--text-main);
      font-size: 22px;
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      }
      #topbar-menu {
      gap: 8px;
      }
      @media (min-width: 721px) {
      #topbar-menu {
      display: flex !important;
      }
      }
      @media (max-width: 720px) {
      #topbar-menu {
      display: none;
      }
      #topbar-menu.open {
      display: flex;
      }
      }
      @media (max-width: 720px) {
      .mobile-menu-btn {
      display: block;
      }
      #topbar-menu {
      position: absolute;
      top: var(--topbar-height);
      right: 0;
      background: var(--panel-alt);
      border-left: 1px solid var(--topbar-border);
      border-bottom: 1px solid var(--topbar-border);
      padding: 12px;
      display: none;
      flex-direction: column;
      width: 180px;
      z-index: 999;
      }
      #topbar-menu.open {
      display: flex;
      }
      header {
      position: relative;
      z-index: 9999;
      }
      }
      @media (max-width: 720px) {
      .draw-toolbar {
      position: absolute;
      top: auto;
      bottom: auto;
      left: 10px !important;
      right: auto !important;
      width: auto;
      gap: 6px;
      padding: 8px;
      }	  
      .topology-toolbar {
      position: absolute;
      top: auto;
      bottom: auto;
      width: auto;
      gap: 6px;
      padding: 8px;
      }
      .draw-toolbar {
      top: 10px !important;
      }
      .topology-toolbar {
      top: calc(10px + var(--draw-toolbar-height, 50px)) !important;
      }
      .canvas-hint {
      top: calc(10px + 120px);
      }
      }
      .icon-picker-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      z-index: 999999999;
      justify-content: center;
      align-items: center;
      }
      .icon-picker-modal.active {
      display: flex;
      }
      .icon-picker-content {
      background: var(--panel);
      border-radius: 12px;
      width: 90%;
      max-width: 800px;
      max-height: 80vh;
      display: flex;
      flex-direction: column;
      border: 1px solid var(--edge-main);
      }
      .icon-picker-header {
      padding: 20px;
      border-bottom: 1px solid var(--edge-main);
      }
      .icon-picker-header h3 {
      margin: 0 0 15px 0;
      color: var(--text-main);
      }
      .icon-picker-tabs {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
      flex-wrap: wrap;
      }
      .icon-picker-tab {
      padding: 8px 16px;
      background: var(--panel-alt);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      color: var(--text-soft);
      font-size: 14px;
      transition: all 0.2s;
      }
      .icon-picker-tab:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .icon-picker-tab.active {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
      }
      .icon-picker-search {
      width: 100%;
      padding: 10px 15px;
      background: var(--panel-alt);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      color: var(--text-main);
      font-size: 14px;
      }
      .icon-picker-search::placeholder {
      color: var(--text-soft);
      }
      .icon-picker-body {
      padding: 20px;
      overflow-y: auto;
      flex: 1;
      }
      .icon-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
      gap: 10px;
      }
      .icon-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 15px 10px;
      background: var(--panel-alt);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .icon-item:hover {
      background: var(--accent);
      border-color: var(--accent);
      transform: scale(1.05);
      }
      .icon-item svg {
      width: 32px;
      height: 32px;
      fill: var(--text-main);
      }
      .icon-item:hover svg {
      fill: var(--bg);
      }
      .icon-item-name {
      margin-top: 8px;
      font-size: 10px;
      color: var(--text-soft);
      text-align: center;
      word-break: break-word;
      }
      .icon-item:hover .icon-item-name {
      color: var(--bg);
      }
      .icon-picker-loading {
      text-align: center;
      padding: 40px;
      color: var(--text-soft);
      }
      .icon-picker-footer {
      padding: 15px 20px;
      border-top: 1px solid var(--edge-main);
      display: flex;
      justify-content: flex-end;
      }
      .icon-btn-cancel {
      padding: 8px 20px;
      background: var(--panel-alt);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      }
      .icon-btn-cancel:hover {
      background: var(--edge-main);
      }
      .icon-badge {
      display: inline-flex;
      align-items: center;
      gap: 5px;
      padding: 4px 8px;
      background: var(--panel-alt);
      border-radius: 4px;
      font-size: 12px;
      margin: 2px;
      }
      .icon-badge svg {
      width: 16px;
      height: 16px;
      fill: currentColor;
      }
      .pick-icon-btn {
      padding: 6px 12px;
      background: var(--accent);
      color: var(--bg);
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      margin-top: 8px;
      width: 100%;
      }
      .pick-icon-btn:hover {
      opacity: 0.9;
      }
      @media (max-width: 768px) {
      .icon-picker-content {
      width: 95%;
      max-height: 90vh;	
      }
      .modal-content {
      background: var(--panel-alt);
      }
      #search-input {
      width: 100%;
      }
      }
      .version-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .version-item:hover {
      background: var(--panel-alt);
      border-color: var(--accent);
      }
      .version-item.current {
      border-color: var(--accent);
      background: rgba(79, 209, 197, 0.1);
      }
      .version-info {
      flex: 1;
      }
      .version-info .timestamp {
      font-size: 13px;
      color: var(--text-main);
      font-weight: 600;
      }
      .version-info .details {
      font-size: 11px;
      color: var(--text-soft);
      margin-top: 4px;
      }
      .version-actions {
      display: flex;
      gap: 6px;
      }
      .audit-entry {
      padding: 8px 12px;
      background: var(--panel);
      border-left: 3px solid var(--edge-main);
      border-radius: 4px;
      font-size: 12px;
      }
      .audit-entry.node { border-left-color: #4fd1c5; }
      .audit-entry.connection { border-left-color: #9f7aea; }
      .audit-entry.style { border-left-color: #ed8936; }
      .audit-entry.rack { border-left-color: #48bb78; }
      .audit-entry.layer { border-left-color: #4299e1; }
      .audit-entry .time {
      color: var(--text-soft);
      font-size: 10px;
      }
      .audit-entry .action {
      color: var(--text-main);
      font-weight: 500;
      }
      .tab-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .tab-item:hover {
      background: var(--panel-alt);
      }
      .tab-item.active {
      border-color: var(--accent);
      background: rgba(79, 209, 197, 0.1);
      }
      .tab-item .tab-name {
      font-weight: 600;
      color: var(--text-main);
      flex: 1;
      }
      .tab-item .tab-stats {
      font-size: 11px;
      color: var(--text-soft);
      margin-right: 10px;
      }
      .tab-actions {
      display: flex;
      gap: 6px;
      }
      .secret-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      border-left: 3px solid var(--danger);
      }
      .secret-item .secret-name {
      font-weight: 600;
      color: var(--text-main);
      flex: 1;
      }
      .secret-item .secret-status {
      font-size: 11px;
      color: var(--text-soft);
      margin-right: 10px;
      }   
    </style>
  </head>
  <body style="background: radial-gradient(circle at center top, rgb(30, 37, 50) 0px, rgb(5, 6, 8) 70%);" class="">
    <div class="icon-picker-modal" id="icon-picker-modal">
      <div class="icon-picker-content">
        <div class="icon-picker-header">
          <h3>Select Icon</h3>
          <div class="icon-picker-tabs">
            <button class="icon-picker-tab" data-library="mdi">MDI</button>
            <button class="icon-picker-tab" data-library="simple">Simple Icons</button>
            <button class="icon-picker-tab active" data-library="selfhst">selfh.st/icons</button>
          </div>
          <input type="text" class="icon-picker-search" id="icon-search" placeholder="Search icons..." style="display: none;">
        </div>
        <div class="icon-picker-body" id="icon-picker-body">
        </div>
        <div class="icon-picker-footer">
          <button class="icon-btn-cancel" id="icon-picker-cancel">Cancel</button>
        </div>
      </div>
    </div>
    <div class="modal" id="tabs-modal">
      <div class="modal-content" style="max-width: 600px;">
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Manage multiple topologies</p>
        <div id="tabs-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 400px; overflow-y: auto; margin-bottom: 15px;">
            <div class="tab-item active" onclick="switchTab(0)">
              <div class="tab-name">Homelab</div>
              <div class="tab-stats">20 nodes ‚Ä¢ 22 connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(0)" title="Rename tab">‚úèÔ∏è</button>
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(${index})" title="Delete tab">üóëÔ∏è</button>
              </div>
            </div>
          
            <div class="tab-item " onclick="switchTab(1)">
              <div class="tab-name">Corporate</div>
              <div class="tab-stats">21 nodes ‚Ä¢ 22 connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(1)" title="Rename tab">‚úèÔ∏è</button>
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(${index})" title="Delete tab">üóëÔ∏è</button>
              </div>
            </div>
          </div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="new-tab-name" placeholder="New tab name..." style="flex: 1; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <button class="btn-save" onclick="createNewTab()">+ Add Tab</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="tabs-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="rollback-modal">
      <div class="modal-content" style="max-width: 700px;">
        <h3>Version History</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Limit: Snapshots</p>
        <div id="rollback-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 450px; overflow-y: auto; margin-bottom: 15px;">
          <div style="text-align: center; padding: 40px; color: var(--text-soft);">No version history yet. Versions are saved automatically when you save the file.</div>
        </div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <button class="btn-cancel" onclick="clearRollbackHistory()">Clear History</button>
          <button class="btn-save" onclick="createManualSnapshot()">Create Snapshot</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="rollback-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="audit-log-modal">
      <div class="modal-content" style="max-width: 800px;">
        <h3>Audit Log</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Track all changes made to your topology</p>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <select id="audit-filter" style="padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
            <option value="all">All Events</option>
            <option value="node">Node Operations</option>
            <option value="connection">Connections</option>
            <option value="style">Style Changes</option>
            <option value="rack">Rack Operations</option>
            <option value="layer">Layer Changes</option>
          </select>
          <button class="btn-save" onclick="exportAuditLog()">Export</button>
        </div>
        <div id="audit-log-list" style="display: flex; flex-direction: column; gap: 4px; max-height: 450px; overflow-y: auto; margin-bottom: 15px; font-family: monospace; font-size: 12px;">
          <div style="text-align: center; padding: 40px; color: var(--text-soft);">No audit entries yet</div>
        </div>
        <div style="display: flex; gap: 8px;">
          <button class="btn-cancel" onclick="clearAuditLog()">Clear Log</button>
          <button class="btn-cancel" id="audit-log-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="secrets-modal">
      <div class="modal-content" style="max-width: 600px;">
        <h3>Notes</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Notes can also be stored with AES 256 encryption</p>
        <div id="secrets-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 350px; overflow-y: auto; margin-bottom: 15px;">
        </div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="new-secret-name" placeholder="Section name (e.g., 'Root Passwords')..." style="flex: 1; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <button class="btn-save" onclick="createNewSecret()">+ Add Note</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="secrets-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="secret-editor-modal">
      <div class="modal-content" style="max-width: 600px;">
        <h3 id="secret-editor-title">Edit Note</h3>
        <textarea id="secret-editor-content" placeholder="Enter sensitive information here..." style="width: 100%; height: 200px; padding: 12px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main); font-family: monospace; resize: vertical; margin-bottom: 15px;"></textarea>
        <div style="margin-bottom: 15px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
          <input type="checkbox" id="secret-auto-encrypt" checked="" style="cursor: pointer;">
          <span>Encrypt Note</span>
          </label>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" onclick="closeSecretEditor()">Cancel</button>
          <button class="btn-save" onclick="saveSecret()">Save</button>
        </div>
      </div>
    </div>
    <div class="modal" id="edit-modal">
      <div class="modal-content">
        <h3 id="modal-title">Edit Name</h3>
        <input type="text" id="modal-input">
        <div class="modal-buttons">
          <button class="btn-cancel" id="modal-cancel">Cancel</button>
          <button class="btn-save" id="modal-save">Save</button>
        </div>
      </div>
    </div>
    <div class="modal confirm-modal" id="confirm-modal">
      <div class="modal-content">
        <h3>Confirm</h3>
        <p id="confirm-message"> Are you sure you want to delete this line? </p>
        <div class="modal-buttons">
          <button class="btn-cancel" id="confirm-cancel">Cancel</button>
          <button class="btn-delete" id="confirm-delete">Delete</button>
        </div>
      </div>
    </div>
    <div class="modal" id="save-info-modal">
      <div class="modal-content" style="max-width: 700px; max-height: 80vh; overflow-y: auto;">
        <h3 style="margin-bottom: 16px;">Help</h3>
        <div style="display: flex; gap: 8px; margin-bottom: 16px; flex-wrap: wrap;">
          <button class="help-tab active" data-tab="general" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--accent); color: var(--bg); border-radius: 6px; cursor: pointer; font-weight: 600;">General</button>
          <button class="help-tab" data-tab="desktop" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--panel); color: var(--text-main); border-radius: 6px; cursor: pointer; font-weight: 600;">Desktop</button>
          <button class="help-tab" data-tab="mobile" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--panel); color: var(--text-main); border-radius: 6px; cursor: pointer; font-weight: 600;">Mobile</button>
        </div>
        <div id="help-tab-general" class="help-tab-content" style="display: block;">
          <ul style="margin-left: 20px; margin-bottom: 12px; line-height: 1.8;">
            <li><strong>Add Nodes:</strong> Click "+ Node" or "+ Rack" in the top menu</li>
            <li><strong>Connect Nodes:</strong> Select a node, then use "Add Connection" in the panel</li>
            <li><strong>Move Nodes:</strong> Drag nodes to reposition them</li>
            <li><strong>Enter Rack View:</strong> Double click on desktop or Long press on mobile</li>
            <li><strong>Multi Select:</strong> Right click (desktop) or double tap (mobile)</li>
            <li><strong>Pan Canvas:</strong> Drag empty space or hold Space + drag</li>
            <li><strong>Zoom:</strong> Scroll wheel or pinch gesture</li>
            <li><strong>Free Draw:</strong> Use draw toolbar for drawing lines, boxes/zones , and text</li>
          </ul>
          <h4 style="color: var(--accent); margin-bottom: 8px;">Saving &amp; Encryption</h4>
          <p style="margin-bottom: 8px;">Browsers cannot overwrite local files. Click <strong>Save File</strong> to download an updated HTML with all changes. Replace your old file to keep edits.</p>
          <p style="margin-bottom: 8px;"><strong>Encryption of data:</strong> Check "Encrypt" before saving to password protect your data. Beware! No recovery possible without password!!</p>
          <p><strong>Decryption of data:</strong> Export via JSON in top settings menu after successful password validation to decrypt your data. You can then reimport back into the same file and save!</p>
        </div>
        <div id="help-tab-desktop" class="help-tab-content" style="display: none;">
          <h4 style="color: var(--accent); margin-bottom: 12px;">Navigation</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Arrow Keys</code></td>
              <td style="padding: 8px;">Move selected 1px</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Shift + Arrows</code></td>
              <td style="padding: 8px;">Move selected 10px</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Tab / Shift+Tab</code></td>
              <td style="padding: 8px;">Cycle through nodes</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">F</code></td>
              <td style="padding: 8px;">Focus on selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Space + Drag</code></td>
              <td style="padding: 8px;">Pan canvas</td>
            </tr>
          </tbody></table>
          <h4 style="color: var(--accent); margin-bottom: 12px;">Management</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">L</code></td>
              <td style="padding: 8px;">Lock/unlock selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">G</code></td>
              <td style="padding: 8px;">Group/ungroup selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+C / Ctrl+V</code></td>
              <td style="padding: 8px;">Copy / Paste</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+D</code></td>
              <td style="padding: 8px;">Duplicate</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+A</code></td>
              <td style="padding: 8px;">Select all</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Delete</code></td>
              <td style="padding: 8px;">Delete selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Escape</code></td>
              <td style="padding: 8px;">Clear selection</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+Z / Ctrl+Y</code></td>
              <td style="padding: 8px;">Undo / Redo</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Right Click</code></td>
              <td style="padding: 8px;">Multi select toggle</td>
            </tr>
          </tbody></table>
        </div>
        <div id="help-tab-mobile" class="help-tab-content" style="display: none;">
          <h4 style="color: var(--accent); margin-bottom: 12px;">Basic Gestures</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Tap node</strong></td>
              <td style="padding: 8px;">Select &amp; open properties</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Tap empty</strong></td>
              <td style="padding: 8px;">Deselect all</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Drag node</strong></td>
              <td style="padding: 8px;">Move node</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Drag empty</strong></td>
              <td style="padding: 8px;">Pan canvas</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Pinch</strong></td>
              <td style="padding: 8px;">Zoom in/out</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Double-tap node</strong></td>
              <td style="padding: 8px;">Add/remove from selection</td>
            </tr>
          </tbody></table>
          <h4 style="color: var(--accent); margin-bottom: 12px;">Rack View</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Long-press rack</strong></td>
              <td style="padding: 8px;">Enter rack view</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Double-tap empty</strong></td>
              <td style="padding: 8px;">Exit rack view</td>
            </tr>
          </tbody></table>
        </div>
        <div class="modal-buttons" style="margin-top: 16px;">
          <button class="btn-cancel" id="save-info-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="settings-modal">
	
	
	<div class="modal-content">
        <h2>Settings</h2>
        
        <details class="style-section">
          <summary>General Theme</summary>
          <div class="style-content">
		    <div class="style-row">
              <label>Main Background</label>
              <input type="color" id="panel-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Modal Window (popup) Background</label>
              <input type="color" id="panel-alt-color" value="#10141b">
            </div>
            <div class="style-row">
              <label>Accent Buttons</label>
              <input type="color" id="accent-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Danger Buttons</label>
              <input type="color" id="danger-color" value="#f56565">
            </div>
            <div class="style-row">
              <label>Primary Text</label>
              <input type="color" id="text-main-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Secondary Text</label>
              <input type="color" id="text-soft-color" value="#94a3b8">
            </div>
          </div>
        </details>
		
        <details class="style-section">
          <summary>Top Bar</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="topbar-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="topbar-border-color" value="#1f2533">
            </div>
          </div>
		  <div class="style-content">
            <div class="style-row">
              <label>Button Fill</label>
              <input type="color" id="btn-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Button Text</label>
              <input type="color" id="btn-text-color" value="#e2e8f0">
            </div>
          </div>
        </details>
		
        <details class="style-section">
          <summary>Main Canvas</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="canvas-border-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Grid Lines</label>
              <input type="color" id="canvas-grid-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Grid Size</label>
              <input type="number" id="canvas-grid-size" value="50" min="20" max="200" style="width:60px;">
            </div>
		    <div class="style-row">
              <label>Background Top</label>
              <input type="color" id="canvas-gradient-top" value="#1e2532">
            </div>
            <div class="style-row">
              <label>Background Bottom</label>
              <input type="color" id="canvas-gradient-bottom" value="#050608">
            </div>
            <div class="style-row">
              <label>Solid Background</label>
              <input type="color" id="page-bg-color" value="#050608">
            </div>
            <p style="margin-top:4px;font-size:12px;color:var(--text-soft);">Set solid background to override gradient.</p>
          </div>
        </details>
        <details class="style-section">
          <summary>Rack Canvas</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Frame Fill</label>
              <input type="color" id="rack-frame-fill" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Frame Border</label>
              <input type="color" id="rack-frame-stroke" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Grid Lines</label>
              <input type="color" id="rack-line-color" value="#475569">
            </div>
            <div class="style-row">
              <label>U Labels</label>
              <input type="color" id="rack-text-color" value="#4fd1c5">
            </div>
          </div>
       </details>
	   <details class="style-section">
          <summary>Canvas Toolbars</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="toolbar-bg-color" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="toolbar-border-color" value="#1f2937">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="toolbar-text-color" value="#94a3b8">
            </div>
            <div class="style-row">
              <label>Button Fill</label>
              <input type="color" id="toolbar-btn-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Button Text</label>
              <input type="color" id="toolbar-btn-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Minimap Dots</label>
              <input type="color" id="minimap-dots-color" value="#94a3b8">
            </div>
          </div>
        </details>
		
        <details class="style-section">
          <summary>Nodes</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Fill</label>
              <input type="color" id="node-fill-color" value="#1e293b">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="node-stroke-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Title Color</label>
              <input type="color" id="node-title-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Title Size</label>
              <input type="number" id="node-title-size" value="18" min="8" max="48" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Subtitle Color</label>
              <input type="color" id="node-sub-color" value="#94a3b8">
            </div>
            <div class="style-row">
              <label>Subtitle Size</label>
              <input type="number" id="node-sub-size" value="13" min="8" max="48" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Font</label>
              <select id="node-font-family" style="flex:1;padding:4px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;">
                <option value="Inter, system-ui, sans-serif">Inter</option>
                <option value="Arial, sans-serif">Arial</option>
                <option value="Helvetica, sans-serif">Helvetica</option>
                <option value="Georgia, serif">Georgia</option>
                <option value="monospace">Monospace</option>
              </select>
            </div>
          </div>
        </details>
        
        <details class="style-section">
          <summary>Connections</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Default Color</label>
              <input type="color" id="default-edge-color" value="#475569">
            </div>
          </div>
        </details>
        
        <details class="style-section">
          <summary>Groups &amp; Editing</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Resize handle Color</label>
              <input type="color" id="selection-handle-color" value="#f59e0b">
            </div>
            <div class="style-row">
              <label>Resize Handle Size</label>
              <input type="number" id="selection-handle-size" value="8" min="4" max="16" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Grouped Icon Outline</label>
              <input type="color" id="group-indicator-color" value="#4fd1c5">
            </div>
          </div>
        </details>
   
		<details class="style-section">
          <summary>Inputs &amp; Dropdowns</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="input-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="input-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="input-border-color" value="#1f2937">
            </div>
            <div class="style-row">
              <label>Font</label>
              <select id="input-font-family" style="flex:1;padding:4px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;">
                <option value="Inter, system-ui, sans-serif">Inter</option>
                <option value="Arial, sans-serif">Arial</option>
                <option value="Helvetica, sans-serif">Helvetica</option>
                <option value="Georgia, serif">Georgia</option>
                <option value="monospace">Monospace</option>
              </select>
            </div>
            <div class="style-row">
              <label>Font Size</label>
              <input type="number" id="input-font-size" value="14" min="10" max="24" style="width:60px;">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Welcome Message</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Enabled</label>
              <input type="checkbox" id="canvas-hint-enabled" checked="" style="width:auto;">
            </div>
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="canvas-hint-bg-color" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Text Color</label>
              <input type="color" id="canvas-hint-text-color" value="#94a3b8">
            </div>
            <div class="style-row" style="flex-direction:column;align-items:stretch;">
              <label>Custom Text (HTML)</label>
              <textarea id="canvas-hint-text" rows="4" style="width:100%;margin-top:4px;padding:6px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;font-size:12px;resize:vertical;" placeholder="Leave empty for default"></textarea>
            </div>
          </div>
        </details>
        
        <details class="style-section">
          <summary>Sidebar / Mobile Footer</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="sidebar-bg-color" value="#10141b">
            </div>
          </div>
        </details>
        
        <details class="style-section">
          <summary>Tags</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Fill</label>
              <input type="color" id="tag-fill-color" value="#1e293b">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="tag-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="tag-border-color" value="#475569">
            </div>
          </div>
        </details>     
        <details class="style-section" open="">
          <summary>Import / Export / Upgrade JSON</summary>
          <div class="style-content">
            <button id="export-data-btn" style="width:100%;margin-bottom:10px;padding:10px;background:var(--accent);color:var(--bg);border:none;border-radius:6px;cursor:pointer;font-size:14px;font-weight:600;">Export JSON</button>
            <button id="import-data-btn" style="width:100%;padding:10px;background:var(--panel);color:var(--text-main);border:1px solid var(--edge-main);border-radius:6px;cursor:pointer;font-size:14px;font-weight:600;">Import JSON</button>
            <input type="file" id="import-data-file" accept=".json" style="display:none">
          </div>
        </details>
         <details class="style-section">
          <summary>Auto Status Checking</summary>
          <div class="style-content">
            <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 16px; cursor: pointer;">
            <input type="checkbox" id="auto-ping-enabled" style="cursor: pointer;">
            <span style="font-size: 14px; font-weight: 600;">Enable automatic status checking</span>
            </label>
            <div id="auto-ping-settings" style="display: none; padding-left: 20px; border-left: 2px solid var(--edge-main);">
              <div class="style-row" style="margin-bottom: 12px;">
                <label>Check Interval (seconds):</label>
                <input type="number" id="auto-ping-interval" min="5" max="3600" value="30" style="width: 80px; padding: 6px; background: var(--panel); border: 1px solid var(--edge-main); border-radius: 4px; color: var(--text-main);">
              </div>
              <div style="padding: 10px; background: var(--panel); border-radius: 6px; border: 1px solid var(--edge-main); font-size: 12px; color: var(--text-soft);">
                <div style="margin-bottom: 4px;"><span id="auto-ping-next-check">Next check in: --</span></div>
                <div><span id="auto-ping-last-run">Last run: 1:15:07 PM</span></div>
              </div>
            </div>
            <p style="margin-top: 12px; font-size: 12px; color: var(--text-soft); font-style: italic;">
              Automatically checks all ping enabled nodes at the specified interval. I recommend 30 to 60 seconds for local networks.
            </p>
			</div>
        </details>
        <details class="style-section">
          <summary>Danger Zone</summary>
          <div class="style-content">
            <p style="margin-bottom:12px;font-size:13px;color:var(--text-soft);">Permanently delete everything on the canvas.</p>
            <button id="clear-all-btn" title="Clear all nodes" style="padding:6px 12px;background:var(--danger);color:#fff;border:none;border-radius:6px;cursor:pointer;font-size:14px;font-weight:600;">Clear All</button>
            <input type="file" id="import-data-file" accept=".json" style="display:none">
          </div>
        </details>
        
        <div class="modal-buttons">
          <button class="btn-cancel" id="settings-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="add-node-modal">
      <div class="modal-content">
        <h3>Add New Node</h3>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Basic Information</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Name</label>
          <input type="text" id="new-node-name" placeholder="e.g. web server, jellyfin">
          <label style="display: block;margin-bottom: 4px;margin-top: 12px;color: var(--text-soft);font-size: 13px;">IP / Subtitle</label>
          <input type="text" id="new-node-ip" placeholder="e.g. 192.168.1.100">
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Tags</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Text Tags (comma separated)</label>
          <input type="text" id="new-node-tags" placeholder="e.g. Docker, nginx, WG: vpn">
          <button class="pick-icon-btn" id="pick-new-node-tag-icon-btn" style="margin-top: 10px;">Add Icon Tag</button>
          <div id="new-node-icon-tags" style="margin-top: 10px; display: none;">
            <label style="display: block; margin-bottom: 8px; color: var(--text-soft); font-size: 13px;">Icon Tags:</label>
            <div id="new-node-icon-tags-list" style="display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 10px;"></div>
          </div>
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Node Appearance</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Basic Shapes</label>
          <select id="new-node-shape">
            <optgroup label="Basic Shapes">
              <option value="circle">Circle</option>
              <option value="square">Square</option>
              <option value="rectangle">Rectangle</option>
              <option value="triangle">Triangle</option>
              <option value="hexagon">Hexagon</option>
              <option value="diamond">Diamond</option>
              <option value="star">Star</option>
              <option value="stop-sign">Stop Sign</option>
            </optgroup>
            <optgroup label="Network Equipment">
              <option value="server">Server</option>
              <option value="pc">PC / Desktop</option>
              <option value="laptop">Laptop</option>
              <option value="phone">Phone / Mobile</option>
              <option value="router">Router</option>
              <option value="switch">Switch</option>
              <option value="firewall">Firewall</option>
              <option value="cloud">Cloud</option>
              <option value="database">Database</option>
              <option value="printer">Printer</option>
            </optgroup>
          </select>
          <button class="pick-icon-btn" id="pick-node-icon-btn" style="margin-top: 10px;"> Or search web icons</button>
          <div id="selected-node-icon" style="margin-top: 10px; display: none;">
            <label style="display: block; margin-bottom: 8px; color: var(--text-soft); font-size: 13px;">Selected Icon:</label>
            <div class="icon-badge" id="selected-node-icon-preview">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24">
                <image href="https://cdn.jsdelivr.net/gh/selfhst/icons@master/png/docker.png" width="24" height="24"></image>
              </svg>
              <span>docker</span>
            </div>
          </div>
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Ping / Status Monitoring</div>
          <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px; cursor: pointer;">
          <input type="checkbox" id="new-node-pingable" style="cursor: pointer;">
          <span style="color: var(--text-soft); font-size: 13px;">Enable ping/status check for this node</span>
          </label>
          <div id="new-node-ping-options" style="display: block; padding-left: 24px; border-left: 2px solid var(--edge-main);">
            <label style="display: block; margin-bottom: 4px; color: var(--text-soft); font-size: 13px;">Protocol</label>
            <select id="new-node-ping-protocol" style="margin-bottom: 12px;">
              <option value="http">HTTP (port 80) uses IP field</option>
              <option value="https">HTTPS (port 443) uses IP field</option>
              <option value="custom">Custom URL</option>
            </select>
            <div id="new-node-custom-url-container" style="display: block;">
              <label style="display: block; margin-bottom: 4px; color: var(--text-soft); font-size: 13px;">Custom URL</label>
              <input type="text" id="new-node-custom-url" placeholder="e.g. http://192.168.1.1:8080">
            </div>
            <label style="display: block; margin-bottom: 4px; margin-top: 8px; color: var(--text-soft); font-size: 13px;">
            Timeout (ms)
            </label>
            <input type="number" id="new-node-ping-timeout" value="3000" min="1000" max="10000" step="500">
          </div>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="add-node-cancel">Cancel</button>
          <button class="btn-save" id="add-node-save">Add Node</button>
        </div>
      </div>
    </div>
    <div class="modal" id="add-rack-modal">
      <div class="modal-content">
        <h3>Add New Rack</h3>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Basic Information</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Rack Name</label>
          <input type="text" id="new-rack-name" placeholder="e.g. Rack-A, DC1-R01, Production-01">
          <label style="display: block;margin-bottom: 4px;margin-top: 12px;color: var(--text-soft);font-size: 13px;">IP / Network Range (optional)</label>
          <input type="text" id="new-rack-ip" placeholder="e.g. 192.168.1.0/24">
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Tags</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Text Tags (comma separated)</label>
          <input type="text" id="new-rack-tags" placeholder="e.g. Production, Data Center 1, Row A">
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Rack Appearance</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Icon / Shape</label>
          <select id="new-rack-shape">
            <optgroup label="Basic Shapes">
              <option value="circle">Circle</option>
              <option value="square">Square</option>
              <option value="rectangle">Rectangle</option>
              <option value="triangle">Triangle</option>
              <option value="hexagon">Hexagon</option>
              <option value="diamond">Diamond</option>
              <option value="star">Star</option>
              <option value="stop-sign">Stop Sign</option>
            </optgroup>
            <optgroup label="Network Equipment">
              <option value="server" selected="">Server</option>
              <option value="pc">PC / Desktop</option>
              <option value="laptop">Laptop</option>
              <option value="phone">Phone / Mobile</option>
              <option value="router">Router</option>
              <option value="switch">Switch</option>
              <option value="firewall">Firewall</option>
              <option value="cloud">Cloud</option>
              <option value="database">Database</option>
              <option value="printer">Printer</option>
            </optgroup>
          </select>
          <button class="pick-icon-btn" id="pick-rack-icon-btn" style="margin-top: 10px;">Or Search Web Icons</button>
          <div id="selected-rack-icon" style="margin-top: 10px; display: none;">
            <label style="display: block; margin-bottom: 8px; color: var(--text-soft); font-size: 13px;">Selected Icon:</label>
            <div class="icon-badge" id="selected-rack-icon-preview">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24">
                <image href="" width="24" height="24"></image>
              </svg>
              <span></span>
            </div>
          </div>
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Rack Configuration</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Rack Capacity</label>
          <select id="new-rack-capacity">
            <option value="42" selected="">42U (Standard Full Rack)</option>
            <option value="48">48U (Large Rack)</option>
            <option value="24">24U (Half Rack)</option>
            <option value="12">12U (Small/Wall Mount)</option>
            <option value="6">6U (Mini Rack)</option>
          </select>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="add-rack-cancel">Cancel</button>
          <button class="btn-save" id="add-rack-save">Add Rack</button>
        </div>
      </div>
    </div>
    <div class="modal confirm-modal" id="clear-all-modal">
      <div class="modal-content">
        <h3>Clear All Nodes</h3>
        <p> This will remove ALL nodes and connections. This cannot be undone until you reload without saving. Are you sure? </p>
        <div class="modal-buttons">
          <button class="btn-cancel" id="clear-all-cancel">Cancel</button>
          <button class="btn-delete" id="clear-all-confirm">Clear Everything</button>
        </div>
      </div>
    </div>
    <div class="modal" id="layer-modal">
      <div class="modal-content" style="max-width: 400px;">
        <h3>Layer Visibility</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Toggle which layers are visible on the canvas</p>
        <div style="display: flex; flex-direction: column; gap: 10px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-physical" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Physical Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-logical" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Logical Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-security" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Security Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-application" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Application Layer</span>
          </label>
        </div>
        <div style="margin-top: 15px; display: flex; gap: 8px;">
          <button class="btn-cancel" style="flex: 1;" onclick="document.querySelectorAll('#layer-modal input[type=checkbox]').forEach(cb =&gt; cb.checked = false); applyLayerFilter();">Hide All</button>
          <button class="btn-save" style="flex: 1;" onclick="document.querySelectorAll('#layer-modal input[type=checkbox]').forEach(cb =&gt; cb.checked = true); applyLayerFilter();">Show All</button>
        </div>
        <div class="modal-buttons" style="margin-top: 10px;">
          <button class="btn-cancel" id="layer-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div id="context-menu" style="display: none !important;">
    </div>
    <header>
      <div class="title-block">
        <h1 id="page-title" class="editable-page-title">Homelab</h1>
        <div class="save-row">
          <button id="save-file-btn" class="save-btn" type="button">Save File</button>
          <label style="display: flex;align-items: center;gap: 4px;font-size: 12px;color: var(--text-soft);cursor: pointer;user-select: none;">
          <input type="checkbox" id="encrypt-toggle" style="cursor: pointer">
          <span title="Encrypt data with password">Encrypt</span>
          </label>
          <span id="save-help-btn" class="help-icon" title="Why save?">?</span>
        </div>
      </div>
      <div id="topbar-menu">
        <button id="back-to-topology-btn" title="Exit rack view and return to topology" style="padding: 6px 12px; background: var(--accent); color: var(--bg); border: none; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600; display: none;">‚Üê Back to Topology</button>
        <button id="add-node-btn" class="save-btn" title="Add new node" style="background: var(--accent)">+ Node</button>
        <button id="add-rack-btn" class="save-btn" title="Add new rack" style="background: var(--accent); margin-left: 8px;">+ Rack</button>
        <button id="undo-btn" title="Undo (Ctrl+Z)" style="padding: 6px 12px; background: var(--btn-bg); color: var(--btn-text); border: 1px solid var(--edge-main); border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600; opacity: 1;">‚Ü∂</button>
        <button id="redo-btn" title="Redo (Ctrl+Y)" style="padding: 6px 12px; background: var(--btn-bg); color: var(--btn-text); border: 1px solid var(--edge-main); border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600; opacity: 0.5;" disabled="">‚Ü∑</button>
<input type="text" id="search-nodes" placeholder="Search nodes..." title="Search by name, IP, MAC, role, or tag" style="padding: 6px 12px;background: var(--input-bg);color: var(--input-text);border: 1px solid var(--input-border);border-radius: 6px;font-family: var(--input-font);font-size: var(--input-font-size);width: 180px;">
        <button id="check-all-ping-btn" title="Check status of all enabled nodes" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600">Check Pings</button>
        <button id="layers-btn" title="Toggle layer visibility" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Layers</button>
        <button id="tabs-btn" title="Manage document tabs" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Tabs</button>
        <button id="rollback-btn" title="View version history" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Snapshots</button>
        <button id="audit-log-btn" title="View audit log" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Audit</button>
        <button id="secrets-btn" title="Manage encrypted notes" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Notes</button>
        <button onclick="screenshotCanvas()" title="Export canvas as PNG image" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">PNG</button>
        <button onclick="exportCanvasSVG()" title="Export canvas as SVG vector" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">SVG</button>
        <button id="settings-btn" title="Page settings">‚öôÔ∏è</button>
      </div>
      <button id="mobile-menu-toggle" class="mobile-menu-btn">‚ò∞</button>
      <div class="header-resizer" id="header-resizer">
        <svg class="resizer-icon" width="40" height="6" viewBox="0 0 40 6" xmlns="http://www.w3.org/2000/svg">
          <circle cx="14" cy="3" r="2"></circle>
          <circle cx="20" cy="3" r="2"></circle>
          <circle cx="26" cy="3" r="2"></circle>
        </svg>
      </div>
    </header>
    <main>
      <section class="topology-panel">
        <div class="draw-toolbar" id="draw-toolbar" style="display: flex !important;">
          <button type="button" class="toolbar-close-btn" id="draw-toolbar-close-btn" title="Hide draw toolbar">‚úï</button>
          <button id="draw-toggle" title="Draw custom line">‚úèÔ∏è</button>
          <button id="rect-toggle" title="Draw zone">‚ñ≠</button>
          <button id="text-toggle" title="Add text">T</button>
          <select id="rect-style" title="zone style">
            <option value="filled">Filled</option>
            <option value="outlined">Outlined</option>
          </select>
          <input type="color" id="draw-color" value="#f97316" title="Line color">
          <select id="draw-style" title="Line style">
            <option value="solid">Solid</option>
            <option value="dashed">Dashed</option>
            <option value="dotted">Dotted</option>
          </select>
          <select id="draw-arrow" title="Arrow direction">
            <option value="none">No arrows</option>
            <option value="forward">‚Üí Right</option>
            <option value="backward">‚Üê Left</option>
            <option value="both">‚Üî Both</option>
          </select>
          <button id="draw-undo" style="display: none" title="Undo last point">Undo</button>
        </div>
        <div class="topology-toolbar" id="topology-toolbar" style="display: flex !important;">
          <button type="button" class="toolbar-close-btn" id="topology-toolbar-close-btn" title="Hide add line toolbar">‚úï</button>
          <label for="add-line-select">Add line to:</label>
          <select id="add-line-select"><option value="opnsense">OPNsense</option><option value="main-switch">Main Switch</option><option value="proxmox">Proxmox</option><option value="truenas">TrueNAS</option><option value="docker-host">Docker Host</option><option value="pi-hole">Pi-hole</option><option value="plex">Plex</option><option value="jellyfin">Jellyfin</option><option value="nextcloud">Nextcloud</option><option value="bitwarden">Vaultwarden</option><option value="homeassistant">Home Assistant</option><option value="portainer">Portainer</option><option value="traefik">Traefik</option><option value="grafana">Grafana</option><option value="prometheus">Prometheus</option><option value="unifi-controller">UniFi Controller</option><option value="wireguard">WireGuard</option><option value="im-a-rack">IM A RACK</option></select>
<input type="color" id="add-line-color" value="#475569" title="Line color" style="width: 30px;height: 24px;border: 1px solid var(--toolbar-border);border-radius: 4px;cursor: pointer;background: transparent;padding: 0;">          <select id="add-line-direction" title="Line direction">
            <option value="none">No arrows</option>
            <option value="forward">‚Üí Forward</option>
            <option value="backward">‚Üê Backward</option>
            <option value="both">‚Üî Both</option>
          </select>
          <button id="add-line-btn">Add</button>
        </div>
        <div class="topology-toolbar bulk-toolbar-desktop" id="bulk-toolbar" style="display: none">
          <button type="button" class="toolbar-close-btn" id="bulk-toolbar-close" title="Clear selection">‚úï</button>
          <label style="font-weight: 600; color: var(--accent)">Selected: <span id="bulk-count">0</span></label>
          <button id="bulk-align-left" title="Align left">‚¨Ö Left</button>
          <button id="bulk-align-right" title="Align right">‚û° Right</button>
          <button id="bulk-align-top" title="Align top">‚¨Ü Top</button>
          <button id="bulk-align-bottom" title="Align bottom">‚¨á Bottom</button>
          <button id="bulk-distribute-h" title="Distribute horizontally">‚Üî Distribute H</button>
          <button id="bulk-distribute-v" title="Distribute vertically">‚Üï Distribute V</button>
          <button id="bulk-clone" title="Clone selected">üìã Clone</button>
          <button id="bulk-delete" title="Delete selected" style="background: var(--danger); color: white;">Delete</button>
        </div>
        <div class="bulk-toolbar-mobile" id="bulk-toolbar-mobile" style="display: none">
          <button type="button" id="bulk-mobile-btn" style="background: var(--accent);color: white;padding: 12px 20px;border-radius: 25px;font-weight: 600;font-size: 16px;box-shadow: 0 4px 12px rgba(0,0,0,0.3);border: none;cursor: pointer;display: flex;align-items: center;gap: 8px;">
          <span id="bulk-count-mobile">0</span>Selected</button>
        </div>
        <div id="bulk-actions-modal" style="display: none;position: fixed;bottom: 0;left: 0;right: 0;background: var(--panel-alt);border-top-left-radius:20px;border-top-right-radius:20px;padding:20px;padding-bottom:(safe-area-inset-bottom, 20px);box-shadow: 0 -4px 20px rgba(0,0,0,0.5);z-index: 10000;max-height: calc(100vh - 80px);overflow-y: auto;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            <h3 style="margin: 0; color: var(--accent); font-size: 20px;">
              <span id="bulk-count-modal">0</span> Nodes Selected
            </h3>
            <button id="bulk-modal-close" style="background: none;border: none;font-size: 24px;cursor: pointer;color: var(--text-main);padding: 0;width: 32px;height: 32px;">‚úï</button>
          </div>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
            <button id="bulk-align-left-mobile" class="bulk-action-btn">‚¨Ö<br><span style="font-size: 12px;">Align Left</span></button>
            <button id="bulk-align-right-mobile" class="bulk-action-btn">‚û°<br><span style="font-size: 12px;">Align Right</span></button>
            <button id="bulk-align-top-mobile" class="bulk-action-btn">‚¨Ü<br><span style="font-size: 12px;">Align Top</span></button>
            <button id="bulk-align-bottom-mobile" class="bulk-action-btn">‚¨á<br><span style="font-size: 12px;">Align Bottom</span></button>
            <button id="bulk-distribute-h-mobile" class="bulk-action-btn">‚Üî<br><span style="font-size: 12px;">Distribute H</span></button>
            <button id="bulk-distribute-v-mobile" class="bulk-action-btn">‚Üï<br><span style="font-size: 12px;">Distribute V</span></button>
            <button id="bulk-lock-mobile" class="bulk-action-btn">üîí<br><span style="font-size: 12px;">Lock Toggle</span></button>
            <button id="bulk-group-mobile" class="bulk-action-btn">‚≠ï<br><span style="font-size: 12px;">Group Toggle</span></button>
            <button id="bulk-clone-mobile" class="bulk-action-btn">üìã<br><span style="font-size: 12px;">Clone All</span></button>
            <button id="bulk-delete-mobile" class="bulk-action-btn" style="background: var(--danger); color: white;">üóë<br><span style="font-size: 12px;">Delete All</span></button>
          </div>
          <button id="bulk-clear-mobile" style="width: 100%;margin-top: 16px;padding: 14px;background: var(--panel-main);border: 1px solid var(--edge-main);border-radius: 8px;color: var(--text-main);font-size: 16px;cursor: pointer;">Clear Selection</button>
        </div>
        <div class="canvas-hint" id="canvas-hint"></div>
        <div class="legend-container" id="edge-legend" style="display: flex;"><div class="legend-title">Line Legend</div><button type="button" class="legend-close-btn">‚úï</button><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(239, 68, 68); cursor: pointer;"></span><span class="legend-label" contenteditable="true">WAN</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(16, 185, 129); cursor: pointer;"></span><span class="legend-label" contenteditable="true">LAN Trunk</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(139, 92, 246); cursor: pointer;"></span><span class="legend-label" contenteditable="true">Server VLAN</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(59, 130, 246); cursor: pointer;"></span><span class="legend-label" contenteditable="true">Management</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(245, 158, 11); cursor: pointer;"></span><span class="legend-label" contenteditable="true">VM Network</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(6, 182, 212); cursor: pointer;"></span><span class="legend-label" contenteditable="true">Containers</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(236, 72, 153); cursor: pointer;"></span><span class="legend-label" contenteditable="true">Storage</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(249, 115, 22); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div></div>
        <div class="canvas-viewport" id="canvas-viewport">
          <svg id="map" viewBox="384.66666666666674 27 3230.6666666666665 2423" style=""><defs><marker id="arrow-forward" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto" markerUnits="strokeWidth"><path d="M0,0 L0,6 L9,3 z" fill="context-stroke"></path></marker><marker id="arrow-backward" markerWidth="10" markerHeight="10" refX="0" refY="3" orient="auto" markerUnits="strokeWidth"><path d="M9,0 L9,6 L0,3 z" fill="context-stroke"></path></marker></defs><rect x="100" y="100" width="3800" height="2800" fill="none" stroke="#4755694D" stroke-width="20" stroke-dasharray="10 5" rx="8"></rect><g id="canvas-grid"><line x1="100" y1="100" x2="100" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="150" y1="100" x2="150" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="200" y1="100" x2="200" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="250" y1="100" x2="250" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="300" y1="100" x2="300" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="350" y1="100" x2="350" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="400" y1="100" x2="400" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="450" y1="100" x2="450" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="500" y1="100" x2="500" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="550" y1="100" x2="550" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="600" y1="100" x2="600" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="650" y1="100" x2="650" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="700" y1="100" x2="700" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="750" y1="100" x2="750" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="800" y1="100" x2="800" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="850" y1="100" x2="850" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="900" y1="100" x2="900" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="950" y1="100" x2="950" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1000" y1="100" x2="1000" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1050" y1="100" x2="1050" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1100" y1="100" x2="1100" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="1150" y1="100" x2="1150" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1200" y1="100" x2="1200" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1250" y1="100" x2="1250" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1300" y1="100" x2="1300" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1350" y1="100" x2="1350" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="1400" y1="100" x2="1400" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1450" y1="100" x2="1450" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1500" y1="100" x2="1500" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1550" y1="100" x2="1550" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1600" y1="100" x2="1600" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="1650" y1="100" x2="1650" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1700" y1="100" x2="1700" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1750" y1="100" x2="1750" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1800" y1="100" x2="1800" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1850" y1="100" x2="1850" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="1900" y1="100" x2="1900" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1950" y1="100" x2="1950" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2000" y1="100" x2="2000" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2050" y1="100" x2="2050" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2100" y1="100" x2="2100" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="2150" y1="100" x2="2150" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2200" y1="100" x2="2200" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2250" y1="100" x2="2250" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2300" y1="100" x2="2300" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2350" y1="100" x2="2350" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="2400" y1="100" x2="2400" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2450" y1="100" x2="2450" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2500" y1="100" x2="2500" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2550" y1="100" x2="2550" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2600" y1="100" x2="2600" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="2650" y1="100" x2="2650" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2700" y1="100" x2="2700" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2750" y1="100" x2="2750" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2800" y1="100" x2="2800" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2850" y1="100" x2="2850" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="2900" y1="100" x2="2900" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2950" y1="100" x2="2950" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3000" y1="100" x2="3000" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3050" y1="100" x2="3050" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3100" y1="100" x2="3100" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="3150" y1="100" x2="3150" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3200" y1="100" x2="3200" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3250" y1="100" x2="3250" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3300" y1="100" x2="3300" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3350" y1="100" x2="3350" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="3400" y1="100" x2="3400" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3450" y1="100" x2="3450" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3500" y1="100" x2="3500" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3550" y1="100" x2="3550" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3600" y1="100" x2="3600" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="3650" y1="100" x2="3650" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3700" y1="100" x2="3700" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3750" y1="100" x2="3750" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3800" y1="100" x2="3800" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3850" y1="100" x2="3850" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="3900" y1="100" x2="3900" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="100" x2="3900" y2="100" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="150" x2="3900" y2="150" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="200" x2="3900" y2="200" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="250" x2="3900" y2="250" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="300" x2="3900" y2="300" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="350" x2="3900" y2="350" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="400" x2="3900" y2="400" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="450" x2="3900" y2="450" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="500" x2="3900" y2="500" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="550" x2="3900" y2="550" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="600" x2="3900" y2="600" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="650" x2="3900" y2="650" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="700" x2="3900" y2="700" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="750" x2="3900" y2="750" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="800" x2="3900" y2="800" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="850" x2="3900" y2="850" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="900" x2="3900" y2="900" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="950" x2="3900" y2="950" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1000" x2="3900" y2="1000" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1050" x2="3900" y2="1050" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1100" x2="3900" y2="1100" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="1150" x2="3900" y2="1150" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1200" x2="3900" y2="1200" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1250" x2="3900" y2="1250" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1300" x2="3900" y2="1300" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1350" x2="3900" y2="1350" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="1400" x2="3900" y2="1400" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1450" x2="3900" y2="1450" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1500" x2="3900" y2="1500" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1550" x2="3900" y2="1550" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1600" x2="3900" y2="1600" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="1650" x2="3900" y2="1650" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1700" x2="3900" y2="1700" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1750" x2="3900" y2="1750" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1800" x2="3900" y2="1800" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1850" x2="3900" y2="1850" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="1900" x2="3900" y2="1900" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1950" x2="3900" y2="1950" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2000" x2="3900" y2="2000" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2050" x2="3900" y2="2050" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2100" x2="3900" y2="2100" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="2150" x2="3900" y2="2150" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2200" x2="3900" y2="2200" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2250" x2="3900" y2="2250" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2300" x2="3900" y2="2300" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2350" x2="3900" y2="2350" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="2400" x2="3900" y2="2400" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2450" x2="3900" y2="2450" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2500" x2="3900" y2="2500" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2550" x2="3900" y2="2550" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2600" x2="3900" y2="2600" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="2650" x2="3900" y2="2650" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2700" x2="3900" y2="2700" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2750" x2="3900" y2="2750" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2800" x2="3900" y2="2800" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2850" x2="3900" y2="2850" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="2900" x2="3900" y2="2900" stroke="#47556933" stroke-width="1"></line></g><path d="M 2000 227 Q 1843.414794921875 427.9279479980469 1686.82958984375 628.8558959960938" fill="none" class="edge active" data-edge-id="edge-1" data-from="isp-modem" data-to="opnsense" style="stroke: rgb(239, 68, 68); stroke-width: 6;"></path><path d="M 2000 227 Q 1843.414794921875 427.9279479980469 1686.82958984375 628.8558959960938" fill="none" data-edge-id="edge-1" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 1686.82958984375 628.8558959960938 Q 1843.414794921875 789.4279479980469 2000 950" fill="none" class="edge" data-edge-id="edge-2" data-from="opnsense" data-to="main-switch" style="stroke: rgb(16, 185, 129); stroke-width: 6;"></path><path d="M 1686.82958984375 628.8558959960938 Q 1843.414794921875 789.4279479980469 2000 950" fill="none" data-edge-id="edge-2" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2000 950 Q 1600 1150 1200 1350" fill="none" class="edge" data-edge-id="edge-3" data-from="main-switch" data-to="proxmox" style="stroke: rgb(139, 92, 246); stroke-width: 5;"></path><path d="M 2000 950 Q 1600 1150 1200 1350" fill="none" data-edge-id="edge-3" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2000 950 Q 2400 1150 2800 1350" fill="none" class="edge" data-edge-id="edge-4" data-from="main-switch" data-to="truenas" style="stroke: rgb(139, 92, 246); stroke-width: 5;"></path><path d="M 2000 950 Q 2400 1150 2800 1350" fill="none" data-edge-id="edge-4" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2000 950 Q 2000 1150 2000 1350" fill="none" class="edge" data-edge-id="edge-5" data-from="main-switch" data-to="docker-host" style="stroke: rgb(139, 92, 246); stroke-width: 5;"></path><path d="M 2000 950 Q 2000 1150 2000 1350" fill="none" data-edge-id="edge-5" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2000 950 Q 2000 1300 2000 1650" fill="none" class="edge" data-edge-id="edge-6" data-from="main-switch" data-to="pi-hole" style="stroke: rgb(59, 130, 246); stroke-width: 4;"></path><path d="M 2000 950 Q 2000 1300 2000 1650" fill="none" data-edge-id="edge-6" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 1200 1350 Q 900 1600 600 1850" fill="none" class="edge" data-edge-id="edge-7" data-from="proxmox" data-to="plex" style="stroke: rgb(245, 158, 11); stroke-width: 4;"></path><path d="M 1200 1350 Q 900 1600 600 1850" fill="none" data-edge-id="edge-7" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 1200 1350 Q 1100 1600 1000 1850" fill="none" class="edge" data-edge-id="edge-8" data-from="proxmox" data-to="homeassistant" style="stroke: rgb(245, 158, 11); stroke-width: 4;"></path><path d="M 1200 1350 Q 1100 1600 1000 1850" fill="none" data-edge-id="edge-8" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 1200 1350 Q 1300 1600 1400 1850" fill="none" class="edge" data-edge-id="edge-9" data-from="proxmox" data-to="wireguard" style="stroke: rgb(245, 158, 11); stroke-width: 4;"></path><path d="M 1200 1350 Q 1300 1600 1400 1850" fill="none" data-edge-id="edge-9" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2000 1350 Q 1700 1800 1400 2250" fill="none" class="edge" data-edge-id="edge-10" data-from="docker-host" data-to="jellyfin" style="stroke: rgb(6, 182, 212); stroke-width: 4;"></path><path d="M 2000 1350 Q 1700 1800 1400 2250" fill="none" data-edge-id="edge-10" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2000 1350 Q 1900 1800 1800 2250" fill="none" class="edge" data-edge-id="edge-11" data-from="docker-host" data-to="nextcloud" style="stroke: rgb(6, 182, 212); stroke-width: 4;"></path><path d="M 2000 1350 Q 1900 1800 1800 2250" fill="none" data-edge-id="edge-11" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2000 1350 Q 2100 1800 2200 2250" fill="none" class="edge" data-edge-id="edge-12" data-from="docker-host" data-to="bitwarden" style="stroke: rgb(6, 182, 212); stroke-width: 4;"></path><path d="M 2000 1350 Q 2100 1800 2200 2250" fill="none" data-edge-id="edge-12" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2000 1350 Q 2300 1800 2600 2250" fill="none" class="edge" data-edge-id="edge-13" data-from="docker-host" data-to="portainer" style="stroke: rgb(6, 182, 212); stroke-width: 4;"></path><path d="M 2000 1350 Q 2300 1800 2600 2250" fill="none" data-edge-id="edge-13" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2000 1350 Q 2500 1800 3000 2250" fill="none" class="edge" data-edge-id="edge-14" data-from="docker-host" data-to="traefik" style="stroke: rgb(6, 182, 212); stroke-width: 4;"></path><path d="M 2000 1350 Q 2500 1800 3000 2250" fill="none" data-edge-id="edge-14" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2000 1350 Q 2700 1800 3400 2250" fill="none" class="edge" data-edge-id="edge-15" data-from="docker-host" data-to="grafana" style="stroke: rgb(6, 182, 212); stroke-width: 4;"></path><path d="M 2000 1350 Q 2700 1800 3400 2250" fill="none" data-edge-id="edge-15" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2000 1350 Q 2700 1600 3400 1850" fill="none" class="edge" data-edge-id="edge-16" data-from="docker-host" data-to="prometheus" style="stroke: rgb(6, 182, 212); stroke-width: 4;"></path><path d="M 2000 1350 Q 2700 1600 3400 1850" fill="none" data-edge-id="edge-16" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2000 1350 Q 2500 1600 3000 1850" fill="none" class="edge" data-edge-id="edge-17" data-from="docker-host" data-to="unifi-controller" style="stroke: rgb(6, 182, 212); stroke-width: 4;"></path><path d="M 2000 1350 Q 2500 1600 3000 1850" fill="none" data-edge-id="edge-17" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2800 1350 Q 1700 1600 600 1850" fill="none" class="edge" data-edge-id="edge-18" data-from="truenas" data-to="plex" style="stroke: rgb(236, 72, 153); stroke-width: 3;"></path><path d="M 2800 1350 Q 1700 1600 600 1850" fill="none" data-edge-id="edge-18" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2800 1350 Q 2100 1800 1400 2250" fill="none" class="edge" data-edge-id="edge-19" data-from="truenas" data-to="jellyfin" style="stroke: rgb(236, 72, 153); stroke-width: 3;"></path><path d="M 2800 1350 Q 2100 1800 1400 2250" fill="none" data-edge-id="edge-19" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2800 1350 Q 2300 1800 1800 2250" fill="none" class="edge" data-edge-id="edge-20" data-from="truenas" data-to="nextcloud" style="stroke: rgb(236, 72, 153); stroke-width: 3;"></path><path d="M 2800 1350 Q 2300 1800 1800 2250" fill="none" data-edge-id="edge-20" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><polyline class="edge" data-edge-id="custom-1764789591702" fill="none" marker-end="url(#arrow-forward)" points="2180.72900390625,753.431884765625 2178.278076171875,883.335693359375 2273.86767578125,888.2376708984375" style="stroke: rgb(249, 115, 22); stroke-width: 4; stroke-dasharray: none;"></polyline><polyline points="2180.72900390625,753.431884765625 2178.278076171875,883.335693359375 2273.86767578125,888.2376708984375" data-edge-id="custom-1764789591702" style="fill: none; stroke: transparent; stroke-width: 20; cursor: pointer;"></polyline><polyline class="edge" data-edge-id="custom-1764791338569" fill="none" marker-end="url(#arrow-forward)" points="1178.4932861328125,139.6976776123047 1282.2938232421875,59.62301254272461 1730.1187744140625,127.83476257324219" style="stroke: rgb(249, 115, 22); stroke-width: 4; stroke-dasharray: 10, 5;"></polyline><polyline points="1178.4932861328125,139.6976776123047 1282.2938232421875,59.62301254272461 1730.1187744140625,127.83476257324219" data-edge-id="custom-1764791338569" style="fill: none; stroke: transparent; stroke-width: 20; cursor: pointer;"></polyline><g class="node-group active" data-node-id="isp-modem" transform="translate(2000,227)" style="cursor: grab;"><circle r="190.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" role="img" viewBox="0 0 24 24" width="152.4" height="152.4" x="-76.2" y="-76.2" style="fill: rgb(255, 0, 0);"><title>OPNsense</title><path d="M5.25 0v5.25h13.5v13.5H24V7.5L16.5 0Zm13.5 18.75H5.25V5.25H0V16.5L7.5 24h11.25Z"></path></svg></g><text class="node-label" x="0" y="-35.56" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">OPNSENSE</text><text class="node-sub" x="0" y="50.800000000000004" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">192.168.100.1</text><circle class="ping-indicator online" r="7.62" cx="-53.59041979980469" cy="-88.894"></circle></g><g class="node-group" data-node-id="opnsense" transform="translate(1686.82958984375,628.8558959960938)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-55" y="-44" width="110" height="88" rx="4"></rect><line x1="-46.75" y1="-27.5" x2="46.75" y2="-27.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="-2.75" x2="46.75" y2="-2.75" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-46.75" y1="22" x2="46.75" y2="22" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="-44" x2="-27.5" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="-44" x2="11" y2="-19.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="-19.25" x2="-8.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="-19.25" x2="30.25" y2="5.5" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-27.5" y1="5.5" x2="-27.5" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="11" y1="5.5" x2="11" y2="30.25" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="-8.25" y1="30.25" x2="-8.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line><line x1="30.25" y1="30.25" x2="30.25" y2="55" style="stroke: rgb(71, 85, 105); stroke-width: 2;"></line></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">OPNsense</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">192.168.1.1</text></g><g class="node-group" data-node-id="main-switch" transform="translate(2000,950)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-77" y="-22" width="154" height="44" rx="4"></rect><rect x="-66" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-48.4" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-30.799999999999997" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="-13.199999999999996" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="4.400000000000006" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="22" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="39.60000000000001" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect><rect x="57.2" y="-8.25" width="12.1" height="16.5" rx="1" style="fill: rgb(30, 41, 59);"></rect></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Main Switch</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">192.168.1.2</text></g><g class="node-group" data-node-id="proxmox" transform="translate(1200,1350)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-66" y="-33" width="132" height="66" rx="4"></rect><line x1="-49.5" y1="-16.5" x2="-49.5" y2="16.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="-22" y1="-16.5" x2="-22" y2="16.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="5.5" y1="-16.5" x2="5.5" y2="16.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><circle cx="49.5" cy="0" r="5.5" style="fill: rgb(74, 222, 128);"></circle></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Proxmox</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">192.168.1.10</text></g><g class="node-group" data-node-id="truenas" transform="translate(2800,1350)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-38.5" y="-33" width="77" height="77"></rect><ellipse cx="0" cy="-33" rx="38.5" ry="13.75"></ellipse><ellipse cx="0" cy="44" rx="38.5" ry="13.75"></ellipse><ellipse cx="0" cy="-8.25" rx="38.5" ry="11" style="fill: none; stroke: rgb(71, 85, 105); stroke-width: 2;"></ellipse><ellipse cx="0" cy="19.25" rx="38.5" ry="11" style="fill: none; stroke: rgb(71, 85, 105); stroke-width: 2;"></ellipse></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">TrueNAS</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">192.168.1.11</text></g><g class="node-group" data-node-id="docker-host" transform="translate(2000,1350)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-66" y="-33" width="132" height="66" rx="4"></rect><line x1="-49.5" y1="-16.5" x2="-49.5" y2="16.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="-22" y1="-16.5" x2="-22" y2="16.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="5.5" y1="-16.5" x2="5.5" y2="16.5" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><circle cx="49.5" cy="0" r="5.5" style="fill: rgb(74, 222, 128);"></circle></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Docker Host</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">192.168.1.12</text></g><g class="node-group" data-node-id="pi-hole" transform="translate(2000,1650)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="66" height="66" x="-33" y="-33"><image href="https://cdn.jsdelivr.net/gh/selfhst/icons@master/png/pi-hole.png" width="24" height="24"></image></svg></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Pi-hole</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">192.168.1.53</text></g><g class="node-group" data-node-id="plex" transform="translate(600,1850)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="66" height="66" x="-33" y="-33"><image href="https://cdn.jsdelivr.net/gh/selfhst/icons@master/png/plex.png" width="24" height="24"></image></svg></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Plex</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">192.168.1.20</text></g><g class="node-group" data-node-id="jellyfin" transform="translate(1400,2250)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="66" height="66" x="-33" y="-33"><image href="https://cdn.jsdelivr.net/gh/selfhst/icons@master/png/jellyfin.png" width="24" height="24"></image></svg></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Jellyfin</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">192.168.1.21</text></g><g class="node-group" data-node-id="nextcloud" transform="translate(1800,2250)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" role="img" viewBox="0 0 24 24" width="66" height="66" x="-33" y="-33"><title>Nextcloud</title><path d="M12.018 6.537c-2.5 0-4.6 1.712-5.241 4.015-.56-1.232-1.793-2.105-3.225-2.105A3.569 3.569 0 0 0 0 12a3.569 3.569 0 0 0 3.552 3.553c1.432 0 2.664-.874 3.224-2.106.641 2.304 2.742 4.016 5.242 4.016 2.487 0 4.576-1.693 5.231-3.977.569 1.21 1.783 2.067 3.198 2.067A3.568 3.568 0 0 0 24 12a3.569 3.569 0 0 0-3.553-3.553c-1.416 0-2.63.858-3.199 2.067-.654-2.284-2.743-3.978-5.23-3.977zm0 2.085c1.878 0 3.378 1.5 3.378 3.378 0 1.878-1.5 3.378-3.378 3.378A3.362 3.362 0 0 1 8.641 12c0-1.878 1.5-3.378 3.377-3.378zm-8.466 1.91c.822 0 1.467.645 1.467 1.468s-.644 1.467-1.467 1.468A1.452 1.452 0 0 1 2.085 12c0-.823.644-1.467 1.467-1.467zm16.895 0c.823 0 1.468.645 1.468 1.468s-.645 1.468-1.468 1.468A1.452 1.452 0 0 1 18.98 12c0-.823.644-1.467 1.467-1.467z"></path></svg></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Nextcloud</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">192.168.1.30</text></g><g class="node-group" data-node-id="bitwarden" transform="translate(2200,2250)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" role="img" viewBox="0 0 24 24" width="66" height="66" x="-33" y="-33"><title>Bitwarden</title><path d="M21.722.296A.964.964 0 0 0 21.018 0H2.982a.959.959 0 0 0-.703.296.96.96 0 0 0-.297.702v12c0 .895.174 1.783.523 2.665.349.88.783 1.66 1.3 2.345.517.68 1.132 1.346 1.848 1.993a21.807 21.807 0 0 0 1.98 1.609c.605.427 1.235.83 1.893 1.212.657.381 1.125.638 1.4.772.276.134.5.241.664.311a.916.916 0 0 0 .814 0c.168-.073.389-.177.667-.311.275-.134.743-.394 1.401-.772a25.305 25.305 0 0 0 1.894-1.212A21.891 21.891 0 0 0 18.348 20c.716-.647 1.33-1.31 1.847-1.993s.949-1.463 1.3-2.345c.35-.879.524-1.767.524-2.665V1.001a.95.95 0 0 0-.297-.705zm-2.325 12.815c0 4.344-7.397 8.087-7.397 8.087V2.57h7.397v10.54z"></path></svg></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Vaultwarden</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">192.168.1.31</text></g><g class="node-group" data-node-id="homeassistant" transform="translate(1000,1850)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" role="img" viewBox="0 0 24 24" width="66" height="66" x="-33" y="-33"><title>Home Assistant</title><path d="M22.939 10.627 13.061.749a1.505 1.505 0 0 0-2.121 0l-9.879 9.878C.478 11.21 0 12.363 0 13.187v9c0 .826.675 1.5 1.5 1.5h9.227l-4.063-4.062a2.034 2.034 0 0 1-.664.113c-1.13 0-2.05-.92-2.05-2.05s.92-2.05 2.05-2.05 2.05.92 2.05 2.05c0 .233-.041.456-.113.665l3.163 3.163V9.928a2.05 2.05 0 0 1-1.15-1.84c0-1.13.92-2.05 2.05-2.05s2.05.92 2.05 2.05a2.05 2.05 0 0 1-1.15 1.84v8.127l3.146-3.146A2.051 2.051 0 0 1 18 12.239c1.13 0 2.05.92 2.05 2.05s-.92 2.05-2.05 2.05c-.25 0-.488-.047-.709-.13L12.9 20.602v3.088h9.6c.825 0 1.5-.675 1.5-1.5v-9c0-.825-.477-1.977-1.061-2.561z"></path></svg></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Home Assistant</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">192.168.1.40</text></g><g class="node-group" data-node-id="portainer" transform="translate(2600,2250)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" role="img" viewBox="0 0 24 24" width="66" height="66" x="-33" y="-33"><title>Portainer</title><path d="M12.504 0v1.023l-.01-.015-6.106 3.526H3.417v.751h5.359v3.638h1.942V5.284h1.786v10.416c.027 0 .54-.01.751.091V5.285h.531v10.608c.293.147.55.312.751.54V5.286h6.046v-.75h-1.267l-6.061-3.5V0zm0 1.87v2.664H7.889zm.751.031l4.56 2.633h-4.56zM9.142 5.285h1.21v1.686h-1.21zm-4.736 2.73v1.951h1.942v-1.95zm2.19 0v1.951h1.941v-1.95zm-2.19 2.171v1.951h1.942v-1.95zm2.19 0v1.951h1.941v-1.95zm2.18 0v1.951h1.942v-1.95zM4.36 12.43a3.73 3.73 0 00-.494 1.851c0 1.227.604 2.308 1.52 2.986.239-.064.477-.1.724-.11.1 0 .165.01.266.019.284-1.191 1.383-1.988 2.665-1.988.724 0 1.438.201 1.924.668.229-.476.302-1.007.302-1.575 0-.65-.165-1.292-.494-1.85zm4.828 3.16c-1.21 0-2.226.844-2.492 1.97a.922.922 0 00-.275-.009 2.559 2.559 0 00-2.564 2.556 2.565 2.565 0 003.096 2.5A2.579 2.579 0 009.233 24c.862 0 1.622-.43 2.09-1.081a2.557 2.557 0 004.186-1.97c0-.567-.193-1.099-.504-1.52a2.557 2.557 0 00-3.866-2.94 2.574 2.574 0 00-1.951-.898z"></path></svg></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Portainer</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">192.168.1.50</text></g><g class="node-group" data-node-id="traefik" transform="translate(3000,2250)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" role="img" viewBox="0 0 24 24" width="66" height="66" x="-33" y="-33"><title>Traefik Proxy</title><path d="M12 1.19c1.088 0 2.056.768 2.056 1.714 0 .947-.921 1.715-2.056 1.715-.13 0-.3-.022-.509-.064a.685.685 0 0 0-.475.076l-7.37 4.195a.344.344 0 0 0 .001.597l7.99 4.49c.208.116.461.116.669 0l8.034-4.468a.343.343 0 0 0 .003-.598l-2.507-1.424a.683.683 0 0 0-.67-.003l-2.647 1.468a.234.234 0 0 0-.119.18l-.001.025c0 .946-.921 1.714-2.056 1.714s-2.056-.768-2.056-1.714c0-.947.921-1.715 2.056-1.715.042 0 .09.002.145.007l.087.008.096.013a.685.685 0 0 0 .425-.08l3.913-2.173c.3-.166.662-.171.965-.017l.04.023 5.465 3.104c.686.39.693 1.368.03 1.773l-.037.021-3.656 2.033a.343.343 0 0 0 .007.604l3.62 1.906c.72.378.736 1.402.03 1.804l-10.995 6.272a1.03 1.03 0 0 1-1.019 0L.526 16.43a1.03 1.03 0 0 1 .034-1.806l3.66-1.911a.343.343 0 0 0 .01-.603L.524 10.029a1.03 1.03 0 0 1-.041-1.77l.036-.021L9.618 3.06a.688.688 0 0 0 .308-.369l.011-.036c.32-.952 1.046-1.466 2.063-1.466Zm5.076 12.63-4.492 2.586-.041.022c-.306.158-.671.152-.973-.018l-4.478-2.527a.682.682 0 0 0-.65-.01L3.86 15.224a.343.343 0 0 0-.012.602l7.887 4.515c.21.12.467.121.677 0l7.956-4.547a.343.343 0 0 0-.01-.602l-2.623-1.384a.683.683 0 0 0-.659.012z"></path></svg></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Traefik</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">192.168.1.51</text></g><g class="node-group" data-node-id="grafana" transform="translate(3400,2250)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" role="img" viewBox="0 0 24 24" width="66" height="66" x="-33" y="-33"><title>Grafana</title><path d="M23.02 10.59a8.578 8.578 0 0 0-.862-3.034 8.911 8.911 0 0 0-1.789-2.445c.337-1.342-.413-2.505-.413-2.505-1.292-.08-2.113.4-2.416.62-.052-.02-.102-.044-.154-.064-.22-.089-.446-.172-.677-.247-.231-.073-.47-.14-.711-.197a9.867 9.867 0 0 0-.875-.161C14.557.753 12.94 0 12.94 0c-1.804 1.145-2.147 2.744-2.147 2.744l-.018.093c-.098.029-.2.057-.298.088-.138.042-.275.094-.413.143-.138.055-.275.107-.41.166a8.869 8.869 0 0 0-1.557.87l-.063-.029c-2.497-.955-4.716.195-4.716.195-.203 2.658.996 4.33 1.235 4.636a11.608 11.608 0 0 0-.607 2.635C1.636 12.677.953 15.014.953 15.014c1.926 2.214 4.171 2.351 4.171 2.351.003-.002.006-.002.006-.005.285.509.615.994.986 1.446.156.19.32.371.488.548-.704 2.009.099 3.68.099 3.68 2.144.08 3.553-.937 3.849-1.173a9.784 9.784 0 0 0 3.164.501h.08l.055-.003.107-.002.103-.005.003.002c1.01 1.44 2.788 1.646 2.788 1.646 1.264-1.332 1.337-2.653 1.337-2.94v-.058c0-.02-.003-.039-.003-.06.265-.187.52-.387.758-.6a7.875 7.875 0 0 0 1.415-1.7c1.43.083 2.437-.885 2.437-.885-.236-1.49-1.085-2.216-1.264-2.354l-.018-.013-.016-.013a.217.217 0 0 1-.031-.02c.008-.092.016-.18.02-.27.011-.162.016-.323.016-.48v-.253l-.005-.098-.008-.135a1.891 1.891 0 0 0-.01-.13c-.003-.042-.008-.083-.013-.125l-.016-.124-.018-.122a6.215 6.215 0 0 0-2.032-3.73 6.015 6.015 0 0 0-3.222-1.46 6.292 6.292 0 0 0-.85-.048l-.107.002h-.063l-.044.003-.104.008a4.777 4.777 0 0 0-3.335 1.695c-.332.4-.592.84-.768 1.297a4.594 4.594 0 0 0-.312 1.817l.003.091c.005.055.007.11.013.164a3.615 3.615 0 0 0 .698 1.82 3.53 3.53 0 0 0 1.827 1.282c.33.098.66.14.971.137.039 0 .078 0 .114-.002l.063-.003c.02 0 .041-.003.062-.003.034-.002.065-.007.099-.01.007 0 .018-.003.028-.003l.031-.005.06-.008a1.18 1.18 0 0 0 .112-.02c.036-.008.072-.013.109-.024a2.634 2.634 0 0 0 .914-.415c.028-.02.056-.041.085-.065a.248.248 0 0 0 .039-.35.244.244 0 0 0-.309-.06l-.078.042c-.09.044-.184.083-.283.116a2.476 2.476 0 0 1-.475.096c-.028.003-.054.006-.083.006l-.083.002c-.026 0-.054 0-.08-.002l-.102-.006h-.012l-.024.006c-.016-.003-.031-.003-.044-.006-.031-.002-.06-.007-.091-.01a2.59 2.59 0 0 1-.724-.213 2.557 2.557 0 0 1-.667-.438 2.52 2.52 0 0 1-.805-1.475 2.306 2.306 0 0 1-.029-.444l.006-.122v-.023l.002-.031c.003-.021.003-.04.005-.06a3.163 3.163 0 0 1 1.352-2.29 3.12 3.12 0 0 1 .937-.43 2.946 2.946 0 0 1 .776-.101h.06l.07.002.045.003h.026l.07.005a4.041 4.041 0 0 1 1.635.49 3.94 3.94 0 0 1 1.602 1.662 3.77 3.77 0 0 1 .397 1.414l.005.076.003.075c.002.026.002.05.002.075 0 .024.003.052 0 .07v.065l-.002.073-.008.174a6.195 6.195 0 0 1-.08.639 5.1 5.1 0 0 1-.267.927 5.31 5.31 0 0 1-.624 1.13 5.052 5.052 0 0 1-3.237 2.014 4.82 4.82 0 0 1-.649.066l-.039.003h-.287a6.607 6.607 0 0 1-1.716-.265 6.776 6.776 0 0 1-3.4-2.274 6.75 6.75 0 0 1-.746-1.15 6.616 6.616 0 0 1-.714-2.596l-.005-.083-.002-.02v-.056l-.003-.073v-.096l-.003-.104v-.07l.003-.163c.008-.22.026-.45.054-.678a8.707 8.707 0 0 1 .28-1.355c.128-.444.286-.872.473-1.277a7.04 7.04 0 0 1 1.456-2.1 5.925 5.925 0 0 1 .953-.763c.169-.111.343-.213.524-.306.089-.05.182-.091.273-.135.047-.02.093-.042.138-.062a7.177 7.177 0 0 1 .714-.267l.145-.045c.049-.015.098-.026.148-.041.098-.029.197-.052.296-.076.049-.013.1-.02.15-.033l.15-.032.151-.028.076-.013.075-.01.153-.024c.057-.01.114-.013.171-.023l.169-.021c.036-.003.073-.008.106-.01l.073-.008.036-.003.042-.002c.057-.003.114-.008.171-.01l.086-.006h.023l.037-.003.145-.007a7.999 7.999 0 0 1 1.708.125 7.917 7.917 0 0 1 2.048.68 8.253 8.253 0 0 1 1.672 1.09l.09.077.089.078c.06.052.114.107.171.159.057.052.112.106.166.16.052.055.107.107.159.164a8.671 8.671 0 0 1 1.41 1.978c.012.026.028.052.04.078l.04.078.075.156c.023.051.05.1.07.153l.065.15a8.848 8.848 0 0 1 .45 1.34.19.19 0 0 0 .201.142.186.186 0 0 0 .172-.184c.01-.246.002-.532-.024-.856z"></path></svg></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Grafana</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">192.168.1.60</text></g><g class="node-group" data-node-id="prometheus" transform="translate(3400,1850)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" role="img" viewBox="0 0 24 24" width="66" height="66" x="-33" y="-33"><title>Prometheus</title><path d="M12 0C5.373 0 0 5.372 0 12c0 6.627 5.373 12 12 12s12-5.373 12-12c0-6.628-5.373-12-12-12zm0 22.46c-1.885 0-3.414-1.26-3.414-2.814h6.828c0 1.553-1.528 2.813-3.414 2.813zm5.64-3.745H6.36v-2.046h11.28v2.046zm-.04-3.098H6.391c-.037-.043-.075-.086-.111-.13-1.155-1.401-1.427-2.133-1.69-2.879-.005-.025 1.4.287 2.395.511 0 0 .513.119 1.262.255-.72-.843-1.147-1.915-1.147-3.01 0-2.406 1.845-4.508 1.18-6.207.648.053 1.34 1.367 1.387 3.422.689-.951.977-2.69.977-3.755 0-1.103.727-2.385 1.454-2.429-.648 1.069.168 1.984.894 4.256.272.854.237 2.29.447 3.201.07-1.892.395-4.652 1.595-5.605-.529 1.2.079 2.702.494 3.424.671 1.164 1.078 2.047 1.078 3.716a4.642 4.642 0 01-1.11 2.996c.792-.149 1.34-.283 1.34-.283l2.573-.502s-.374 1.538-1.81 3.019z"></path></svg></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Prometheus</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">192.168.1.61</text></g><g class="node-group" data-node-id="unifi-controller" transform="translate(3000,1850)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" role="img" viewBox="0 0 24 24" width="66" height="66" x="-33" y="-33"><title>Ubiquiti</title><path d="M23.1627 0h-1.4882v1.4882h1.4882zm-5.2072 10.4226V7.4409l.0007.001h2.9755v2.9762h2.9756v.9433c0 1.0906-.0927 2.3827-.306 3.3973-.1194.5672-.3004 1.1308-.5127 1.672-.2175.5537-.468 1.0841-.7408 1.5595a11.6795 11.6795 0 0 1-1.2456 1.7762l-.0253.0294-.0417.0488c-.1148.1347-.2283.2679-.3531.398a11.7612 11.7612 0 0 1-.4494.4492c-1.9046 1.8343-4.3861 2.98-6.9808 3.243-.3122.032-.939.0652-1.2519.0652-.3139-.001-.9397-.0331-1.252-.0651-2.5946-.263-5.0761-1.4097-6.9806-3.243a11.75 11.75 0 0 1-.4495-.4494c-.131-.1356-.249-.2748-.3683-.4154l-.0006-.0004-.0512-.0603a11.6576 11.6576 0 0 1-1.2456-1.7762c-.2727-.4763-.5233-1.0058-.7408-1.5595-.2123-.5414-.3933-1.1048-.5128-1.6718C.1854 13.743.0927 12.452.0927 11.3616V.1864h5.9518v10.2362s0 .7847.0099 1.0415l.0022.0599v.0004c.0127.332.0247.6575.0594.9812.098.919.3014 1.7913.7203 2.5288.1213.213.2443.42.3915.616.8953 1.1939 2.2577 2.0901 3.9573 2.3398.2022.0294.6108.0552.8149.0552.204 0 .6125-.0258.8149-.0552 1.6996-.2497 3.062-1.146 3.9573-2.3398.148-.196.2701-.403.3914-.616.419-.7375.6224-1.6095.7204-2.5288.0346-.3243.047-.6503.0594-.9831l.0022-.0584c.0099-.2568.0099-1.0415.0099-1.0415zm.7427-8.19h2.2326v2.2319h2.9764v2.9764h-2.9764V4.4654h-2.2326V2.2328Z"></path></svg></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">UniFi Controller</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">192.168.1.70</text></g><g class="node-group" data-node-id="wireguard" transform="translate(1400,1850)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" role="img" viewBox="0 0 24 24" width="66" height="66" x="-33" y="-33"><title>WireGuard</title><path d="M23.98 11.645S24.533 0 11.735 0C.418 0 .064 11.17.064 11.17S-1.6 24 11.997 24C25.04 24 23.98 11.645 23.98 11.645zM8.155 7.576c2.4-1.47 5.469-.571 6.618 1.638.218.419.246 1.063.108 1.503-.477 1.516-1.601 2.366-3.145 2.728.455-.39.817-.832.933-1.442a2.112 2.112 0 0 0-.364-1.677 2.14 2.14 0 0 0-2.465-.75c-.95.36-1.47 1.228-1.377 2.294.087.99.839 1.632 2.245 1.876-.21.111-.372.193-.53.281a5.113 5.113 0 0 0-1.644 1.43c-.143.192-.24.208-.458.075-2.827-1.729-3.009-6.067.078-7.956zM6.04 18.258c-.455.116-.895.286-1.359.438.227-1.532 2.021-2.943 3.539-2.782a3.91 3.91 0 0 0-.74 2.072c-.504.093-.98.155-1.44.272zM15.703 3.3c.448.017.898.01 1.347.02a2.324 2.324 0 0 1 .334.047 3.249 3.249 0 0 1-.34.434c-.16.15-.341.296-.573.069-.055-.055-.187-.042-.283-.044-.447-.005-.894-.02-1.34-.003a8.323 8.323 0 0 0-1.154.118c-.072.013-.178.25-.146.338.078.207.191.435.359.567.619.49 1.277.928 1.9 1.413.604.472 1.167.99 1.51 1.7.446.928.46 1.9.267 2.877-.322 1.63-1.147 2.98-2.483 3.962-.538.395-1.205.62-1.821.903-.543.25-1.1.465-1.644.712-.98.446-1.53 1.51-1.369 2.615.149 1.015 1.04 1.862 2.059 2.037 1.223.21 2.486-.586 2.785-1.83.336-1.397-.423-2.646-1.845-3.024l-.256-.066c.38-.17.708-.291 1.012-.458q.793-.437 1.558-.925c.15-.096.231-.096.36.014.977.846 1.56 1.898 1.724 3.187.27 2.135-.74 4.096-2.646 5.101-2.948 1.555-6.557-.215-7.208-3.484-.558-2.8 1.418-5.34 3.797-5.83 1.023-.211 1.958-.637 2.685-1.425.47-.508.697-.944.775-1.141a3.165 3.165 0 0 0 .217-1.158 2.71 2.71 0 0 0-.237-.992c-.248-.566-1.2-1.466-1.435-1.656l-2.24-1.754c-.079-.065-.168-.06-.36-.047-.23.016-.815.048-1.067-.018.204-.155.76-.38 1-.56-.726-.49-1.554-.314-2.315-.46.176-.328 1.046-.831 1.541-.888a7.323 7.323 0 0 0-.135-.822c-.03-.111-.154-.22-.263-.283-.262-.154-.541-.281-.843-.434a1.755 1.755 0 0 1 .906-.28 3.385 3.385 0 0 1 .908.088c.54.123.97.042 1.399-.324-.338-.136-.676-.26-1.003-.407a9.843 9.843 0 0 1-.942-.493c.85.118 1.671.437 2.54.32l.022-.118-2.018-.47c1.203-.11 2.323-.128 3.384.388.299.146.61.266.897.432.14.08.233.24.348.365.09.098.164.23.276.29.424.225.89.234 1.366.223l.01-.16c.479.15 1.017.702 1.017 1.105-.776 0-1.55-.003-2.325.004-.083 0-.165.061-.247.094.078.046.155.128.235.131z M14.703 2.153a.118.118 0 0 0-.016.19.179.179 0 0 0 .246.065c.075-.038.148-.078.238-.125-.072-.062-.13-.114-.19-.163-.106-.087-.193-.032-.278.033z"></path></svg></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">WireGuard</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">192.168.1.80</text></g><g class="node-group" data-node-id="im-a-rack" transform="translate(2590.18017578125,882.6126098632812)" style="cursor: grab;"><circle r="271.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-217.2" y="-108.6" width="434.4" height="217.2" rx="4"></rect><line x1="-162.9" y1="-54.3" x2="-162.9" y2="54.3" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="-72.4" y1="-54.3" x2="-72.4" y2="54.3" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><line x1="18.099999999999994" y1="-54.3" x2="18.099999999999994" y2="54.3" style="stroke: currentcolor; stroke-width: 2; opacity: 0.5;"></line><circle cx="162.9" cy="0" r="18.1" style="fill: rgb(74, 222, 128);"></circle></g><text class="node-label" x="0" y="-50.68000000000001" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">IM A RACK</text><text class="node-sub" x="0" y="72.4" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;"></text><text x="126.69999999999999" y="-126.69999999999999" class="lock-indicator" style="font-size: 54.3px; pointer-events: none;">üîí</text></g><g class="text-group" data-text-id="text-1764789550897"><text class="text-element" x="2158.669921875" y="621.0770263671875" dominant-baseline="middle" style="fill: rgb(226, 232, 240); font-size: 37px; font-weight: normal; font-style: normal; text-anchor: start; text-decoration: none; opacity: 1; cursor: move; user-select: none;"><tspan x="2158.669921875" dy="0">DOUBLE CLICK ON DESKTOP</tspan><tspan x="2158.669921875" dy="44.4">OR LONG PRESS ON MOBILE</tspan><tspan x="2158.669921875" dy="44.4">TO OPEN RACK VIEW</tspan></text><g class="text-delete-btn" style="cursor: pointer; display: none;"><circle cx="2178.669921875" cy="584.0770263671875" r="12" style="fill: rgb(245, 101, 101); stroke: white; stroke-width: 2;"></circle><text x="2178.669921875" y="584.0770263671875" text-anchor="middle" dominant-baseline="middle" style="fill: white; font-size: 16px; font-weight: bold; pointer-events: none;">√ó</text></g></g><g class="text-group" data-text-id="text-1764791291347"><text class="text-element" x="1065.795654296875" y="187.14932250976562" dominant-baseline="middle" style="fill: rgb(226, 232, 240); font-size: 41px; font-weight: bold; font-style: normal; text-anchor: start; text-decoration: none; opacity: 1; cursor: move; user-select: none;"><tspan x="1065.795654296875" dy="0">Router is live!</tspan><tspan x="1065.795654296875" dy="49.199999999999996">Uses http requests to live ping</tspan></text><g class="text-delete-btn" style="cursor: pointer; display: none;"><circle cx="1085.795654296875" cy="146.14932250976562" r="12" style="fill: rgb(245, 101, 101); stroke: white; stroke-width: 2;"></circle><text x="1085.795654296875" y="146.14932250976562" text-anchor="middle" dominant-baseline="middle" style="fill: white; font-size: 16px; font-weight: bold; pointer-events: none;">√ó</text></g></g></svg>
        </div>
        <div class="minimap-zoom-wrapper" id="minimap-zoom-wrapper" style="display: block;">
          <button type="button" class="minimap-close-btn" id="minimap-close-btn" title="Hide map &amp; zoom">‚úï</button>
          <div class="minimap-container" id="minimap-container">
            <svg id="minimap" viewBox="0 0 4000 3000">
              <line x1="2000" y1="227" x2="1686.82958984375" y2="628.8558959960938" class="minimap-edge"></line><line x1="1686.82958984375" y1="628.8558959960938" x2="2000" y2="950" class="minimap-edge"></line><line x1="2000" y1="950" x2="1200" y2="1350" class="minimap-edge"></line><line x1="2000" y1="950" x2="2800" y2="1350" class="minimap-edge"></line><line x1="2000" y1="950" x2="2000" y2="1350" class="minimap-edge"></line><line x1="2000" y1="950" x2="2000" y2="1650" class="minimap-edge"></line><line x1="1200" y1="1350" x2="600" y2="1850" class="minimap-edge"></line><line x1="1200" y1="1350" x2="1000" y2="1850" class="minimap-edge"></line><line x1="1200" y1="1350" x2="1400" y2="1850" class="minimap-edge"></line><line x1="2000" y1="1350" x2="1400" y2="2250" class="minimap-edge"></line><line x1="2000" y1="1350" x2="1800" y2="2250" class="minimap-edge"></line><line x1="2000" y1="1350" x2="2200" y2="2250" class="minimap-edge"></line><line x1="2000" y1="1350" x2="2600" y2="2250" class="minimap-edge"></line><line x1="2000" y1="1350" x2="3000" y2="2250" class="minimap-edge"></line><line x1="2000" y1="1350" x2="3400" y2="2250" class="minimap-edge"></line><line x1="2000" y1="1350" x2="3400" y2="1850" class="minimap-edge"></line><line x1="2000" y1="1350" x2="3000" y2="1850" class="minimap-edge"></line><line x1="2800" y1="1350" x2="600" y2="1850" class="minimap-edge"></line><line x1="2800" y1="1350" x2="1400" y2="2250" class="minimap-edge"></line><line x1="2800" y1="1350" x2="1800" y2="2250" class="minimap-edge"></line><circle cx="2000" cy="227" r="40" class="minimap-node"></circle><circle cx="1686.82958984375" cy="628.8558959960938" r="40" class="minimap-node"></circle><circle cx="2000" cy="950" r="40" class="minimap-node"></circle><circle cx="1200" cy="1350" r="40" class="minimap-node"></circle><circle cx="2800" cy="1350" r="40" class="minimap-node"></circle><circle cx="2000" cy="1350" r="40" class="minimap-node"></circle><circle cx="2000" cy="1650" r="40" class="minimap-node"></circle><circle cx="600" cy="1850" r="40" class="minimap-node"></circle><circle cx="1400" cy="2250" r="40" class="minimap-node"></circle><circle cx="1800" cy="2250" r="40" class="minimap-node"></circle><circle cx="2200" cy="2250" r="40" class="minimap-node"></circle><circle cx="1000" cy="1850" r="40" class="minimap-node"></circle><circle cx="2600" cy="2250" r="40" class="minimap-node"></circle><circle cx="3000" cy="2250" r="40" class="minimap-node"></circle><circle cx="3400" cy="2250" r="40" class="minimap-node"></circle><circle cx="3400" cy="1850" r="40" class="minimap-node"></circle><circle cx="3000" cy="1850" r="40" class="minimap-node"></circle><circle cx="1400" cy="1850" r="40" class="minimap-node"></circle><circle cx="2590.18017578125" cy="882.6126098632812" r="40" class="minimap-node"></circle><rect class="minimap-viewport" id="minimap-viewport" x="384.66666666666674" y="27" width="3230.6666666666665" height="2423"></rect>
            </svg>
          </div>
          <div class="zoom-toolbar" id="zoom-toolbar">
            <button id="zoom-in-btn" title="Zoom in">+</button>
            <div class="zoom-level" id="zoom-level">124%</div>
            <button id="zoom-out-btn" title="Zoom out">-</button>
            <div class="divider"></div>
            <button id="zoom-fit-btn" title="Fit to view">[ ]</button>
            <button id="zoom-reset-btn" title="Reset view">R</button>
          </div>
        </div>
        <button type="button" id="edge-legend-mini" class="legend-mini-btn" style="bottom: 10px; display: none;">Line Legend</button>
        <button type="button" id="minimap-mini" class="legend-mini-btn" style="right: 10px; left: auto; bottom: 10px; display: none;">Map</button>
        <button type="button" id="draw-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: 10px; right: auto; display: none;">Draw</button>
        <button type="button" id="topology-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: auto; right: 40px; display: none;">Add Line</button>
      <button type="button" id="edge-legend-mini" class="legend-mini-btn" style="bottom: 10px; display: none;">Legend</button><button type="button" id="minimap-mini" class="legend-mini-btn" style="right: 10px; left: auto; bottom: 10px; display: none;">Map</button><button type="button" id="draw-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: 10px; right: auto; display: none;">Draw</button><button type="button" id="topology-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: auto; right: 40px; display: none;">Add Line</button><button type="button" id="edge-legend-mini" class="legend-mini-btn" style="bottom: 10px; display: none;">Legend</button><button type="button" id="topology-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: auto; right: 40px; display: none;">Add Line</button><button type="button" id="minimap-mini" class="legend-mini-btn" style="right: 10px; left: auto; bottom: 10px; display: none;">Map</button><button type="button" id="draw-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: 10px; right: auto; display: none;">Draw</button></section>
      <aside class="details-panel" id="details-panel">
        <div class="sidebar-resizer" id="sidebar-resizer">
          <svg class="resizer-icon" width="6" height="40" viewBox="0 0 6 40" xmlns="http://www.w3.org/2000/svg">
            <circle cx="3" cy="14" r="2"></circle>
            <circle cx="3" cy="20" r="2"></circle>
            <circle cx="3" cy="26" r="2"></circle>
          </svg>
        </div>
        <div class="mobile-footer-resizer" id="mobile-footer-resizer">
          <svg class="resizer-icon" width="40" height="6" viewBox="0 0 40 6" xmlns="http://www.w3.org/2000/svg">
            <circle cx="14" cy="3" r="2"></circle>
            <circle cx="20" cy="3" r="2"></circle>
            <circle cx="26" cy="3" r="2"></circle>
          </svg>
        </div>
        <div id="node-panel" style="display: block;">
          <div class="details-name editable-text" id="node-name">OPNSENSE</div>
          <div class="details-ip editable-text" id="node-ip">192.168.100.1</div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">MAC:</span>
            <span class="editable-text" id="node-mac" style="flex: 1; cursor: pointer; color: var(--text-main);">--</span>
          </div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">Rack Unit:</span>
            <span class="editable-text" id="node-rack" style="flex: 1; cursor: pointer; color: var(--text-main);">--</span>
          </div>
          <div class="details-info-row" id="uheight-row" style="display: none;">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">U Height:</span>
            <span class="editable-text" id="node-uheight" style="flex: 1; cursor: pointer; color: var(--text-main);">1U</span>
          </div>
          <div class="details-info-row" id="assigned-rack-row" style="display: flex;">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">Assigned Rack:</span>
            <select id="node-assigned-rack" style="flex: 1; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;"><option value="">None</option><option value="im-a-rack">IM A RACK</option></select>
          </div>
          <div class="details-info-row" id="rack-capacity-row" style="display: none;">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">Rack Capacity:</span>
            <select id="node-rack-capacity" style="flex: 1; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;">
              <option value="42">42U</option>
              <option value="48">48U</option>
              <option value="24">24U</option>
              <option value="12">12U</option>
              <option value="6">6U</option>
            </select>
          </div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">Layer:</span>
            <select id="node-layer" style="flex: 1; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;">
              <option value="physical">Physical</option>
              <option value="logical">Logical</option>
              <option value="security">Security</option>
              <option value="application">Application</option>
            </select>
          </div>
          <div class="details-role" id="node-role">WAN</div>
          <div class="badge-row" id="node-tags"><span class="badge" style="cursor: pointer; position: relative;"><span>1Gbps Fiber</span><span style="opacity: 0.6; margin-left: 4px; font-size: 10px;"> ‚úï</span></span><span class="badge" style="cursor: pointer; position: relative;"><span>Bridge Mode</span><span style="opacity: 0.6; margin-left: 4px; font-size: 10px;"> ‚úï</span></span><span class="badge" style="cursor: pointer; opacity: 0.6; border-style: dashed;">+ Add</span></div>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-tag-input" placeholder="Add tag..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-tag-btn" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button class="pick-icon-btn" id="pick-tag-icon-btn">Add Icon Tag</button>
          <div class="section-label">Size</div>
          <div class="size-controls">
            <label>Size:</label>
            <input type="range" id="size-slider" min="20" max="200" value="55">
            <span id="size-value">127</span>
            <button id="reset-size">Reset</button>
          </div>
          <details class="style-section" open="">
            <summary>Styling</summary>
            <div class="style-content">
              <div class="style-row">
                <label>Screen:</label>
                <select id="style-scope">
                  <option value="all">All</option>
                  <option value="desktop">Desktop</option>
                  <option value="tablet">Tablet</option>
                  <option value="mobile">Mobile</option>
                  <option value="fold">Fold</option>
                </select>
              </div>
              <div class="style-row">
                <label>Shape:</label>
                <select id="shape-select">
                  <optgroup label="Basic Shapes">
                    <option value="circle">Circle</option>
                    <option value="square">Square</option>
                    <option value="rectangle">Rectangle</option>
                    <option value="triangle">Triangle</option>
                    <option value="hexagon">Hexagon</option>
                    <option value="diamond">Diamond</option>
                    <option value="star">Star</option>
                    <option value="stop-sign">Stop Sign</option>
                  </optgroup>
                  <optgroup label="Network Equipment">
                    <option value="server">Server</option>
                    <option value="pc">PC / Desktop</option>
                    <option value="laptop">Laptop</option>
                    <option value="phone">Phone / Mobile</option>
                    <option value="router">Router</option>
                    <option value="switch">Switch</option>
                    <option value="firewall">Firewall</option>
                    <option value="cloud">Cloud</option>
                    <option value="database">Database</option>
                    <option value="printer">Printer</option>
                  </optgroup>
                </select>
              </div>
              <button class="pick-icon-btn" id="pick-shape-icon-btn">Or Search Web Icons</button>
              <div class="style-row">
                <label>Fill Color:</label>
                <input type="color" id="circle-color" value="#1e293b">
              </div>
              <div class="style-row">
                <label>Border Color:</label>
                <input type="color" id="circle-border" value="#475569">
              </div>
              <div class="style-row">
                <label>Title Color:</label>
                <input type="color" id="title-color" value="#e2e8f0">
              </div>
              <div class="style-row">
                <label>Title Font:</label>
                <select id="title-font">
                  <option value="system-ui, sans-serif">System UI</option>
                  <option value="monospace">Monospace</option>
                  <option value="serif">Serif</option>
                  <option value="cursive">Cursive</option>
                  <option value="'Courier New', monospace">Courier</option>
                  <option value="Arial, sans-serif">Arial</option>
                  <option value="'Times New Roman', serif">Times</option>
                </select>
              </div>
              <div class="style-row">
                <label>Title Size:</label>
                <input type="number" id="title-size" min="8" max="100" value="18">
              </div>
              <div class="style-row">
                <label>Sub Color:</label>
                <input type="color" id="sub-color" value="#94a3b8">
              </div>
              <div class="style-row">
                <label>Sub Font:</label>
                <select id="sub-font">
                  <option value="system-ui, sans-serif">System UI</option>
                  <option value="monospace">Monospace</option>
                  <option value="serif">Serif</option>
                  <option value="cursive">Cursive</option>
                  <option value="'Courier New', monospace">Courier</option>
                  <option value="Arial, sans-serif">Arial</option>
                  <option value="'Times New Roman', serif">Times</option>
                </select>
              </div>
              <div class="style-row">
                <label>Sub Size:</label>
                <input type="number" id="sub-size" min="6" max="80" value="13">
              </div>
              <div style="
                margin-top: 12px;
                padding-top: 10px;
                border-top: 1px solid var(--edge-main);
                ">
                <div style="font-size: 12px;color: var(--text-soft);margin-bottom: 8px;text-transform: uppercase;">Text Position</div>
                <div class="style-row">
                  <label>Name Y:</label>
                  <input type="number" id="title-offset-y" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>Name X:</label>
                  <input type="number" id="title-offset-x" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>IP Y:</label>
                  <input type="number" id="sub-offset-y" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>IP X:</label>
                  <input type="number" id="sub-offset-x" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div style="margin-top: 16px; font-size: 12px; color: var(--text-soft); text-transform: uppercase;">
                  Ping Indicator Position
                </div>
                <div class="style-row">
                  <label>Ping X:</label>
                  <input type="number" id="ping-offset-x" min="-200" max="200" value="0" style="width: 60px;">
                </div>
                <div class="style-row">
                  <label>Ping Y:</label>
                  <input type="number" id="ping-offset-y" min="-200" max="200" value="0" style="width: 60px;">
                </div>
              </div>
              <button id="reset-styles" style="width: 100%;margin-top: 10px;padding: 8px;background: var(--panel);color: var(--text-main);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: clamp(13px, 1.5vw, 17px);">Reset Styles</button>
            </div>
          </details>
          <details class="style-section">
            <summary>Ping / Status Monitoring</summary>
            <div class="style-content">
              <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px; cursor: pointer;">
              <input type="checkbox" id="node-pingable" style="cursor: pointer;">
              <span style="font-size: 14px;">Enable status check for this node</span>
              </label>
              <div id="node-ping-options" style="display: block;">
                <div class="style-row">
                  <label>Protocol:</label>
                  <select id="node-ping-protocol">
                    <option value="http">HTTP (port 80)</option>
                    <option value="https">HTTPS (port 443)</option>
                    <option value="custom">Custom URL</option>
                  </select>
                </div>
                <div id="node-custom-url-container" style="display: block; margin-top: 8px;">
                  <label style="display: block; margin-bottom: 4px; font-size: 13px;">Custom URL:</label>
                  <input type="text" id="node-custom-url" placeholder="e.g. http://192.168.1.1:8080" style="width: 100%;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: 14px;">
                </div>
                <div class="style-row" style="margin-top: 8px;">
                  <label>Timeout (ms):</label>
                  <input type="number" id="node-ping-timeout" value="3000" min="1000" max="10000" step="500" style="width: 100px;">
                </div>
                <div style="margin-top: 12px; padding: 10px; background: var(--panel); border-radius: 6px; border: 1px solid var(--edge-main);">
                  <div style="font-size: 12px; color: var(--text-soft); margin-bottom: 8px;">Current Status:</div>
                  <div id="node-ping-status" style="font-size: 14px; font-weight: 600; color: var(--accent);">‚óè Online</div>
                  <div id="node-ping-last-check" style="font-size: 11px; color: var(--text-soft); margin-top: 4px;">Last checked: 2:25:19 PM</div>
                </div>
                <button id="check-ping-now" style="width: 100%;margin-top: 10px;padding: 8px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Check Status Now</button>
              </div>
            </div>
          </details>
          <div class="section-label">Notes</div>
          <ul class="list" id="node-notes"><li><span style="flex: 1 1 0%;">ISP: AT&amp;T Fiber</span><span class="delete-note">‚úï</span></li><li><span style="flex: 1 1 0%;">set to google for ping sake</span><span class="delete-note">‚úï</span></li></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-note-input" placeholder="Type new note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-note-btn" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-node-btn" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: rgb(255, 255, 255);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;width: 100%;">Delete Node</button>
        </div>
        <div id="edge-panel" style="display: none">
          <div class="details-name" id="edge-title">Custom line</div>
          <div class="style-row" style="margin-top: 10px">
            <label>Width:</label>
            <input type="number" id="edge-width" min="1" max="20" value="4">
          </div>
          <div class="style-row">
            <label>Color:</label>
            <input type="color" id="edge-color" value="#475569">
          </div>
          <div class="style-row">
            <label>Line Style:</label>
            <select id="edge-line-style">
              <option value="solid">Solid</option>
              <option value="dashed">Dashed</option>
              <option value="dotted">Dotted</option>
            </select>
          </div>
          <div class="style-row">
            <label>Direction:</label>
            <select id="edge-direction">
              <option value="none">No arrows</option>
              <option value="forward">‚Üí Forward</option>
              <option value="backward">‚Üê Backward</option>
              <option value="both">‚Üî Bidirectional</option>
            </select>
          </div>
          <div class="style-row" id="edge-port-fields">
            <label>From Port:</label>
            <input type="text" id="edge-from-port" placeholder="e.g. eth0, gi0/1" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);font-size: 14px;">
          </div>
          <div class="style-row" id="edge-port-fields-to">
            <label>To Port:</label>
            <input type="text" id="edge-to-port" placeholder="e.g. eth1, gi0/2" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);font-size: 14px;">
          </div>
          <div class="section-label">Line Notes</div>
          <ul class="list" id="edge-notes"></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-edge-note" placeholder="Add note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-edge-note" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-edge" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Delete Line</button>
        </div>
        <div id="rect-panel" style="display: none">
          <div class="details-name" id="rect-title">Zone</div>
          <div class="style-row" id="rect-fill-row" style="margin-top: 10px">
            <label>Fill Color:</label>
            <input type="color" id="rect-color" value="#f97316">
          </div>
          <div class="style-row">
            <label>Border Color:</label>
            <input type="color" id="rect-border-color" value="#f97316">
          </div>
          <div class="style-row">
            <label>Border Width:</label>
            <input type="number" id="rect-border-width" min="0" max="20" value="2">
          </div>
          <div class="style-row">
            <label>Style:</label>
            <select id="rect-style-select">
              <option value="filled">Filled</option>
              <option value="outlined">Outlined</option>
            </select>
          </div>
          <div class="section-label">Zone Notes</div>
          <ul class="list" id="rect-notes"></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-rect-note" placeholder="Add note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-rect-note" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-rect" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Delete Zone</button>
        </div>
        <div id="text-panel" style="display: none;">
          <div class="details-name" id="text-title">Text Element</div>
          <div class="style-row" style="margin-top: 10px">
            <label>Content:</label>
            <textarea id="text-content" placeholder="Enter text..." style="width: 100%;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: 14px;min-height: 80px;resize: vertical;font-family: inherit;"></textarea>
          </div>
          <div class="style-row">
            <label>Font Size:</label>
            <input type="number" id="text-font-size" min="8" max="200" value="18" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);">
          </div>
          <div class="style-row">
            <label>Color:</label>
            <input type="color" id="text-color" value="#e2e8f0">
          </div>
          <div class="style-row">
            <label>Font Weight:</label>
            <select id="text-font-weight" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="normal">Normal</option>
              <option value="bold">Bold</option>
              <option value="600">Semi-Bold</option>
              <option value="300">Light</option>
            </select>
          </div>
          <div class="style-row">
            <label>Font Style:</label>
            <select id="text-font-style" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="normal">Normal</option>
              <option value="italic">Italic</option>
            </select>
          </div>
          <div class="style-row">
            <label>Text Align:</label>
            <select id="text-align" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="start">Left</option>
              <option value="middle">Center</option>
              <option value="end">Right</option>
            </select>
          </div>
          <div class="style-row">
            <label>Text Decoration:</label>
            <select id="text-decoration" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="none">None</option>
              <option value="underline">Underline</option>
              <option value="line-through">Strike Through</option>
            </select>
          </div>
          <div class="style-row">
            <label>Background:</label>
            <input type="color" id="text-bg-color" value="#000000">
            <label style="margin-left: 10px; display: flex; align-items: center; gap: 6px;">
            <input type="checkbox" id="text-bg-enabled" style="cursor: pointer;">
            <span style="font-size: 13px;">Enable</span>
            </label>
          </div>
          <div class="style-row">
            <label>Opacity:</label>
            <input type="range" id="text-opacity" min="0" max="1" step="0.1" value="1" style="flex: 1">
            <span id="text-opacity-val" style="min-width: 35px; text-align: right">100%</span>
          </div>
          <button id="delete-text" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;width: 100%;">Delete Text</button>
        </div>
     <details class="style-section">
          <summary>Page Layout</summary>
          <div class="style-content">
            <div style="padding: 12px; background: var(--panel-alt); border-radius: 6px; color: var(--text-soft); font-size: 13px; line-height: 1.6;">
              <strong style="color: var(--accent); display: block; margin-bottom: 8px;">Drag to Resize:</strong>
              ‚Ä¢ <strong>Header:</strong> Drag the bottom edge of the header bar<br>
              ‚Ä¢ <strong>Sidebar:</strong> Drag the left edge of the sidebar panel<br>
              ‚Ä¢ <strong>Mobile:</strong> Drag the top edge of the footer panel<br>
              <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--edge-main); font-size: 12px;">
                Hover over panel edges to see resize handles
              </div>
            </div>
          </div>
        </details>
      </aside>
    </main>
    <script id="nodes-json" type="application/json">{}</script>
    <script id="topology-state" type="application/json">ENCRYPTED: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</script>
    <script>
      const IconLibrary = {
       libraries: {
        mdi: {
         name: 'Material Design Icons',
         cdnBase: 'https://cdn.jsdelivr.net/npm/@mdi/svg@latest/svg/',
         metaUrl: 'https://cdn.jsdelivr.net/npm/@mdi/svg@latest/meta.json',
         icons: []
        },
        simple: {
         name: 'Simple Icons',
         cdnBase: 'https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/',
         indexUrl: 'https://cdn.jsdelivr.net/npm/@iconify-json/simple-icons@latest/icons.json',
         icons: []
        },
        selfhst: {
         name: 'selfh.st/icons',
         cdnBase: 'https://cdn.jsdelivr.net/gh/selfhst/icons@master/png/',
         indexUrl: 'https://raw.githubusercontent.com/selfhst/icons/refs/heads/main/index.json',
         icons: []
        }
       },
       currentLibrary: 'selfhst',
       iconCache: {},
       indexCache: {},
       indexLoading: {},
       async loadLibraryIndex(library) {
        if (this.indexCache[library]) {
         return this.indexCache[library];
        }
        if (this.indexLoading[library]) {
         return this.indexLoading[library];
        }
        const lib = this.libraries[library];
        this.indexLoading[library] = (async () => {
         try {
          if (library === 'selfhst') {
           const response = await fetch(lib.indexUrl);
           const data = await response.json();
           const icons = data.map(item => ({
            name: item.Reference,
            displayName: item.Name,
            tags: item.Tags ? item.Tags.split(',').map(t => t.trim()).filter(t => t) : [],
            category: item.Category
           }));
           this.indexCache[library] = icons;
           lib.icons = icons;
           return icons;
          } else if (library === 'simple') {
           const response = await fetch('https://cdn.jsdelivr.net/npm/@iconify-json/simple-icons@latest/icons.json');
           const data = await response.json();
           const icons = Object.keys(data.icons).map(slug => ({
            name: slug,
            displayName: data.icons[slug].title || slug,
            tags: data.aliases && data.aliases[slug] ? [data.aliases[slug].parent] : [],
            hex: data.icons[slug].hex
           }));
           this.indexCache[library] = icons;
           lib.icons = icons;
           return icons;
          } else if (library === 'mdi') {
           const response = await fetch(lib.metaUrl);
           const data = await response.json();
           const icons = data.map(item => ({
            name: item.name,
            displayName: item.name,
            tags: item.tags || [],
            author: item.author
           }));
           this.indexCache[library] = icons;
           lib.icons = icons;
           return icons;
          }
         } catch (error) {
          console.error(`Failed to load index for ${library}:`, error);
          this.indexCache[library] = [];
          lib.icons = [];
          return [];
         } finally {
          delete this.indexLoading[library];
         }
        })();
        return this.indexLoading[library];
       },
       async getIcon(library, name) {
        const cacheKey = `${library}-${name}`;
        if (this.iconCache[cacheKey]) {
         return this.iconCache[cacheKey];
        }
        const cached = localStorage.getItem(`icon-${cacheKey}`);
        if (cached) {
         this.iconCache[cacheKey] = cached;
         return cached;
        }
        const lib = this.libraries[library];
        if (library === 'selfhst') {
         const pngUrl = `${lib.cdnBase}${name}.png`;
         const svgWrapper = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><image href="${pngUrl}" width="24" height="24"/></svg>`;
         this.iconCache[cacheKey] = svgWrapper;
         localStorage.setItem(`icon-${cacheKey}`, svgWrapper);
         return svgWrapper;
        }
        const url = `${lib.cdnBase}${name}.svg`;
        try {
         const response = await fetch(url);
         if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
         }
         const svg = await response.text();
         this.iconCache[cacheKey] = svg;
         localStorage.setItem(`icon-${cacheKey}`, svg);
         return svg;
        } catch (error) {
         console.error(`Failed to fetch icon ${cacheKey}:`, error);
         return null;
        }
       },
       searchIcons(library, query) {
        const lib = this.libraries[library];
        if (!lib.icons.length) return [];
        const q = query.toLowerCase();
        return lib.icons.filter(icon => {
         const nameMatch = icon.name.toLowerCase().includes(q);
         const displayMatch = icon.displayName && icon.displayName.toLowerCase().includes(q);
         const tagMatch = icon.tags && icon.tags.some(t => t.toLowerCase().includes(q));
         const categoryMatch = icon.category && icon.category.toLowerCase().includes(q);
         return nameMatch || displayMatch || tagMatch || categoryMatch;
        }).slice(0, 50);
       }
      };
      let iconPickerCallback = null;
      let selectedNodeIconData = null;
      let selectedRackIconData = null;
      let newNodeIconTags = [];
      let freeDrawMode = false;
      async function checkNodeStatus(nodeId) {
       const data = NODE_DATA[nodeId];
       if (!data || !data.ping || !data.ping.enabled) return;
       
       data.ping.status = 'checking';
       data.ping.lastCheck = new Date().toISOString();
       updatePingIndicator(nodeId);
       if (currentNodeId === nodeId) {
        updatePingStatusDisplay(nodeId);
       }
       
       let url;
       if (data.ping.protocol === 'custom') {
        url = data.ping.customUrl;
       } else {
        const ip = data.ip || '0.0.0.0';
        const protocol = data.ping.protocol || 'http';
        url = `${protocol}://${ip}`;
       }
       
       if (!url) {
        data.ping.status = 'unknown';
        updatePingIndicator(nodeId);
        if (currentNodeId === nodeId) {
         updatePingStatusDisplay(nodeId);
        }
        return;
       }
       
       try {
        const controller = new AbortController();
        const timeout = data.ping.timeout || 3000;
        const timeoutId = setTimeout(() => controller.abort(), timeout);
        
        const response = await fetch(url, {
         method: 'HEAD',
         mode: 'no-cors', 
         signal: controller.signal
        });
        
        clearTimeout(timeoutId);
        
        data.ping.status = 'online';
       } catch (error) {
        data.ping.status = 'offline';
       }
       
       data.ping.lastCheck = new Date().toISOString();
       updatePingIndicator(nodeId);
       if (currentNodeId === nodeId) {
        updatePingStatusDisplay(nodeId);
       }
      }
      function rgbaToHex(val) {
      if (!val) return "#000000";
      if (val.startsWith("#")) return val;
      
      const m = val.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
      if (!m) return "#000000";
      
      const r = Number(m[1]).toString(16).padStart(2, "0");
      const g = Number(m[2]).toString(16).padStart(2, "0");
      const b = Number(m[3]).toString(16).padStart(2, "0");
      
      return `#${r}${g}${b}`;
      }
      function updatePingIndicator(nodeId) {
      const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
      if (!nodeGroup) return;
      
      const data = NODE_DATA[nodeId];
      if (!data || !data.ping || !data.ping.enabled) {
       const existingIndicator = nodeGroup.querySelector('.ping-indicator');
       if (existingIndicator) existingIndicator.remove();
       return;
      }
      
      let indicator = nodeGroup.querySelector('.ping-indicator');
      const label = nodeGroup.querySelector('.node-label');
      
      if (!indicator && label) {
       indicator = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
       indicator.classList.add('ping-indicator');
       nodeGroup.appendChild(indicator);
      }
      
      if (indicator && label) {
       const size = savedSizes[nodeId] || getDefaultSize();
       const radius = Math.max(4, size * 0.06);
      
       indicator.setAttribute('r', radius);
      
       const labelBBox = label.getBBox();
       const labelX = parseFloat(label.getAttribute('x') || 0);
       const labelY = parseFloat(label.getAttribute('y') || 0);
      
       const styles = resolveStylesForNode(nodeId);
      const offX = styles.pingOffsetX || 0;
      const offY = styles.pingOffsetY || 0;
      
      indicator.setAttribute('cx', (labelX - labelBBox.width / 2 - radius * 1.1) + offX);
      indicator.setAttribute('cy', (labelY - radius * 0.7) + offY);
      }
      
      if (indicator) {
       indicator.classList.remove('online', 'offline', 'checking');
       if (data.ping.status) indicator.classList.add(data.ping.status);
      }
      }
      
      
      function checkAllNodesStatus() {
       Object.keys(NODE_DATA).forEach(nodeId => {
        const data = NODE_DATA[nodeId];
        if (data && data.ping && data.ping.enabled) {
         checkNodeStatus(nodeId);
        }
       });
      }
      
      function startAutoPing() {
       stopAutoPing();
       
       checkAllNodesStatus();
       updateAutoPingLastRun();
       
       autoPingSecondsRemaining = autoPingInterval;
       
      
       autoPingTimer = setInterval(() => {
        checkAllNodesStatus();
        updateAutoPingLastRun();
        autoPingSecondsRemaining = autoPingInterval;
       }, autoPingInterval * 1000);
       
       autoPingCountdown = setInterval(() => {
        autoPingSecondsRemaining--;
        updateAutoPingCountdown();
        if (autoPingSecondsRemaining <= 0) {
         autoPingSecondsRemaining = autoPingInterval;
        }
       }, 1000);
       
       updateAutoPingCountdown();
      }
      
      function stopAutoPing() {
       if (autoPingTimer) {
        clearInterval(autoPingTimer);
        autoPingTimer = null;
       }
       if (autoPingCountdown) {
        clearInterval(autoPingCountdown);
        autoPingCountdown = null;
       }
       autoPingSecondsRemaining = 0;
       updateAutoPingCountdown();
      }
      
      function updateAutoPingCountdown() {
       const nextCheckEl = document.getElementById('auto-ping-next-check');
       if (nextCheckEl) {
        if (autoPingSecondsRemaining > 0 && autoPingEnabled) {
         const mins = Math.floor(autoPingSecondsRemaining / 60);
         const secs = autoPingSecondsRemaining % 60;
         if (mins > 0) {
          nextCheckEl.textContent = `Next check in: ${mins}m ${secs}s`;
         } else {
          nextCheckEl.textContent = `Next check in: ${secs}s`;
         }
        } else {
         nextCheckEl.textContent = 'Next check in: --';
        }
       }
      }
      
      function updateAutoPingLastRun() {
       const lastRunEl = document.getElementById('auto-ping-last-run');
       if (lastRunEl) {
        const now = new Date();
        lastRunEl.textContent = `Last run: ${now.toLocaleTimeString()}`;
       }
      }
      
      function openIconPicker(callback) {
       iconPickerCallback = callback;
       const modal = document.getElementById('icon-picker-modal');
       modal.classList.add('active');
       const searchInput = document.getElementById('icon-search');
       searchInput.style.display = 'none';
       loadIconsForCurrentLibrary();
      }
      
      function closeIconPicker() {
       const modal = document.getElementById('icon-picker-modal');
       modal.classList.remove('active');
       iconPickerCallback = null;
      }
      async function loadIconsForCurrentLibrary() {
       const body = document.getElementById('icon-picker-body');
       const libNames = {
        mdi: 'MDI (Material Design Icons)',
        simple: 'Simple Icons',
        selfhst: 'selfh.st/icons'
       };
       body.innerHTML = `<div style="padding: 20px;"><p style="color: var(--text-soft); margin-bottom: 15px; text-align: center;">Search ${libNames[IconLibrary.currentLibrary]}:</p><input type="text" id="icon-search-field" placeholder="Search icons..." style="width: 100%; padding: 12px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main); font-size: 16px; margin-bottom: 20px;"><div id="icon-grid-container" style="max-height: 400px; overflow-y: auto;"><div style="text-align: center; color: var(--text-soft); padding: 40px;">Loading icons...</div></div></div>`;
       const searchField = document.getElementById('icon-search-field');
       const gridContainer = document.getElementById('icon-grid-container');
       await IconLibrary.loadLibraryIndex(IconLibrary.currentLibrary);
       const renderIcons = (icons) => {
        if (!icons || icons.length === 0) {
         gridContainer.innerHTML = '<div style="text-align: center; color: var(--text-soft); padding: 40px;">No icons found</div>';
         return;
        }
        const grid = document.createElement('div');
        grid.style.cssText = 'display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 15px; padding: 10px;';
        icons.forEach(icon => {
         const item = document.createElement('div');
         item.style.cssText = 'display: flex; flex-direction: column; align-items: center; gap: 8px; padding: 15px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; cursor: pointer; transition: all 0.2s;';
         item.onmouseover = () => {
          item.style.background = 'var(--panel)';
          item.style.borderColor = 'var(--accent)';
         };
         item.onmouseout = () => {
          item.style.background = 'var(--panel-alt)';
          item.style.borderColor = 'var(--edge-main)';
         };
         const iconPreview = document.createElement('div');
         iconPreview.style.cssText = 'width: 48px; height: 48px; display: flex; align-items: center; justify-content: center;';
         iconPreview.innerHTML = '<div style="color: var(--text-soft); font-size: 12px;">...</div>';
         IconLibrary.getIcon(IconLibrary.currentLibrary, icon.name).then(svg => {
          if (svg) {
           const parser = new DOMParser();
           const doc = parser.parseFromString(svg, 'image/svg+xml');
           const svgEl = doc.querySelector('svg');
           if (svgEl) {
            svgEl.setAttribute('width', '48');
            svgEl.setAttribute('height', '48');
            svgEl.style.fill = 'var(--text-main)';
            iconPreview.innerHTML = '';
            iconPreview.appendChild(svgEl);
           }
          }
         });
         const name = document.createElement('div');
         name.textContent = icon.displayName || icon.name;
         name.style.cssText = 'font-size: 11px; color: var(--text-soft); text-align: center; word-break: break-word; max-width: 100%;';
         item.appendChild(iconPreview);
         item.appendChild(name);
         item.addEventListener('click', async () => {
          const svg = await IconLibrary.getIcon(IconLibrary.currentLibrary, icon.name);
          if (iconPickerCallback && svg) {
           iconPickerCallback({
            library: IconLibrary.currentLibrary,
            name: icon.name,
            svg: svg
           });
          }
          closeIconPicker();
         });
         grid.appendChild(item);
        });
        gridContainer.innerHTML = '';
        gridContainer.appendChild(grid);
       };
       gridContainer.innerHTML = '<div style="text-align: center; color: var(--text-soft); padding: 40px;">Type to search icons</div>';
       let searchTimeout;
       searchField.addEventListener('input', (e) => {
        clearTimeout(searchTimeout);
        const query = e.target.value.trim();
        searchTimeout = setTimeout(() => {
         if (!query) {
          gridContainer.innerHTML = '<div style="text-align: center; color: var(--text-soft); padding: 40px;">Type to search icons</div>';
          return;
         }
         const results = IconLibrary.searchIcons(IconLibrary.currentLibrary, query);
         renderIcons(results);
        }, 300);
       });
       searchField.focus();
      }
      async function displayIcons(icons) {
       const body = document.getElementById('icon-picker-body');
       const grid = document.createElement('div');
       grid.className = 'icon-grid';
       for (const icon of icons) {
        const item = document.createElement('div');
        item.className = 'icon-item';
        const svg = await IconLibrary.getIcon(icon.library, icon.name);
        if (svg) {
         const parser = new DOMParser();
         const doc = parser.parseFromString(svg, 'image/svg+xml');
         const svgEl = doc.querySelector('svg');
         if (svgEl) {
          item.innerHTML = svgEl.outerHTML;
         }
        } else {
         item.innerHTML = '<svg width = "32" height = "32"><rect width = "32" height = "32" fill = "currentColor"/> </svg>';
        }
        const name = document.createElement('div');
        name.className = 'icon-item-name';
        name.textContent = icon.name;
        item.appendChild(name);
        item.addEventListener('click', () => {
         if (iconPickerCallback) {
          iconPickerCallback({
           library: icon.library,
           name: icon.name,
           svg: svg
          });
         }
         closeIconPicker();
        });
        grid.appendChild(item);
       }
       body.innerHTML = '';
       body.appendChild(grid);
      }
      window.addEventListener('DOMContentLoaded', () => {
       document.querySelectorAll('.icon-picker-tab').forEach(tab => {
        tab.addEventListener('click', () => {
         document.querySelectorAll('.icon-picker-tab').forEach(t => t.classList.remove('active'));
         tab.classList.add('active');
         IconLibrary.currentLibrary = tab.dataset.library;
         loadIconsForCurrentLibrary();
        });
       });
       document.getElementById('icon-picker-cancel').addEventListener('click', closeIconPicker);
       document.getElementById('icon-picker-modal').addEventListener('click', (e) => {
        if (e.target.id === 'icon-picker-modal') {
         closeIconPicker();
        }
       });
      });
      let textDrawMode = false;
      const BASE_NODE_DATA = JSON.parse(document.getElementById("nodes-json").textContent, );
      let currentNodeId = "host";
      let currentEdgeId = null;
      let currentStyleScope = "all";
      let NODE_DATA = {};
      let EDGE_DATA = {
       list: []
      };
      let currentRectId = null;
      let rectDrawMode = false;
      let RECT_DATA = {
       list: []
      };
      let TEXT_DATA = {
       list: []
      };
      let EDGE_LEGEND = {};
      let savedPositions = {};
      let savedSizes = {};
      let savedStyles = {};
      let legendCollapsed = false;
      let minimapCollapsed = false;
      let drawToolbarCollapsed = false;
      let currentView = {
       mode: "topology",
       rackId: null
      };
      let savedTopologyView = null;
      let activeLayers = new Set(["physical", "logical", "security", "application"]);
      let topologyToolbarCollapsed = false;
      let legendMiniBtn = null;
      let minimapMiniBtn = null;
      let drawToolbarMiniBtn = null;
      let topologyToolbarMiniBtn = null;
      
      let autoPingEnabled = false;
      let autoPingInterval = 30;
      let autoPingTimer = null;
      let autoPingCountdown = null;
      let autoPingSecondsRemaining = 0;
      
      const ROLLBACK_STORAGE_KEY = "theonefile_rollback_history";
      let rollbackVersions = [];
      const MAX_ROLLBACK_VERSIONS = 50;
      let currentRollbackIndex = -1;
      
      const AUDIT_STORAGE_KEY = "theonefile_audit_log";
      let auditLog = [];
      const MAX_AUDIT_ENTRIES = 1000;
      
      let documentTabs = [{
        id: "main",
        name: "Main Topology",
        nodes: {},
        edges: { list: [] },
        positions: {},
        sizes: {},
        styles: {},
        legend: {},
        rects: { list: [] },
        texts: { list: [] },
      pageState: null
      }];
      let currentTabIndex = 0;
      
      let encryptedSections = {};
      
      let undoStack = [];
      let redoStack = [];
      const MAX_UNDO_STACK = 50;
      let selectedNodes = new Set();
      let selectedEdges = new Set();
      let selectedRects = new Set();
      let selectedTexts = new Set();
      let isSelecting = false;
      let selectionStart = null;
      let selectionRect = null;
      let isDraggingSelection = false;
      let dragSelectionStart = null;
      let clipboard = null;
      
      const MobileManager = {
        isMobile: false,
        detect() {
      
          if (navigator.userAgentData?.mobile === true) {
            this.isMobile = true;
            return true;
          }
          const coarse = matchMedia("(pointer: coarse)").matches;
          const width = window.innerWidth <= 900;
          const portrait = matchMedia("(orientation: portrait)").matches;
          this.isMobile = coarse && (width || portrait);
          return this.isMobile;
        },
        applyInitialCollapse() {
          if (!this.isMobile) return;
          legendCollapsed = true;
          minimapCollapsed = true;
          drawToolbarCollapsed = true;
          topologyToolbarCollapsed = true;
          if (typeof updateLegendVisibility === "function") updateLegendVisibility();
          if (typeof updateMinimapVisibility === "function") updateMinimapVisibility();
          if (typeof updateDrawToolbarVisibility === "function") updateDrawToolbarVisibility();
          if (typeof updateTopologyToolbarVisibility === "function") updateTopologyToolbarVisibility();
        },
        updateBulkToolbar() {
          const desktop = document.getElementById("bulk-toolbar");
          const mobile = document.getElementById("bulk-toolbar-mobile");
          if (!desktop || !mobile) return;
          
          const isVisible = desktop.style.display !== "none" || mobile.style.display !== "none";
          
          if (this.isMobile) {
            desktop.style.display = "none";
            if (isVisible) {
              mobile.style.display = "flex";
            }
          } else {
            mobile.style.display = "none";
            if (isVisible) {
              desktop.style.display = "flex";
            }
          }
        },
        updateLayout() {
          const main = document.querySelector("main");
          if (!main) return;
        },
        updateCanvasHint() {
      const hint = document.getElementById("canvas-hint");
      if (!hint) return;
      
      if (PAGE_STATE.canvasHintText !== undefined && PAGE_STATE.canvasHintText !== "") {
        hint.innerHTML = PAGE_STATE.canvasHintText;
        return;
      }
      
      const items = this.isMobile
      ? [
        "Pinch to zoom",
        "Drag to pan",
        "Add node from top menu",
        "Double tap to clone and align",
        "Double tap to select multiple",
        "You have the power",	
        "Your time is NOW!",
      ]
      : [
        "Scroll to zoom",
        "Drag to pan",
        "Right click to clone and align",
        "Right click to select multiple",
        "You have the power",
        "Your time is NOW!",
      ];
      
      const list = document.createElement("ul");
      for (const item of items) {
      const li = document.createElement("li");
      li.textContent = item;
      list.appendChild(li);
      }
      
      hint.replaceChildren(list);
      },
        autoSelectStyleScope() {
          const scope = document.getElementById("style-scope");
          if (!scope) return;
          if (this.isMobile) scope.value = "mobile";
        },
        updateToolbarStack() {
          if (!this.isMobile) return;
          const draw = document.getElementById("draw-toolbar");
          const topo = document.getElementById("topology-toolbar");
          if (!draw || !topo) return;
          const h = draw.getBoundingClientRect().height;
          document.documentElement.style.setProperty("--draw-toolbar-height", h + "px");
        },
        updateLayoutControls() {
          const sidebarRow = document.getElementById("sidebar-width-row");
          const footerRow = document.getElementById("mobile-footer-row");
          if (sidebarRow && footerRow) {
            if (this.isMobile) {
              sidebarRow.style.display = "none";
              footerRow.style.display = "flex";
            } else {
              sidebarRow.style.display = "flex";
              footerRow.style.display = "none";
            }
          }
        },
        applyAll() {
          this.detect();
          this.applyInitialCollapse();
          this.updateBulkToolbar();
          this.updateLayout();
          this.updateCanvasHint();
          this.autoSelectStyleScope();
          this.updateToolbarStack();
          this.updateLayoutControls();
        }
      };
      function isMobileDevice() {
        return MobileManager.isMobile;
      }
      
      function ensureLegendMiniButton() {
       if (legendMiniBtn) return legendMiniBtn;
      
       const panel = document.querySelector(".topology-panel");
       if (!panel) return null;
       const btn = document.createElement("button");
       btn.type = "button";
       btn.id = "edge-legend-mini";
       btn.className = "legend-mini-btn";
       btn.textContent = "Legend";
       btn.style.bottom = "10px";
       const handleClick = (e) => {
        e.stopPropagation();
        e.preventDefault();
        legendCollapsed = false;
        updateLegendVisibility();
       };
       btn.addEventListener("click", handleClick);
       btn.addEventListener("touchend", handleClick);
       panel.appendChild(btn);
       legendMiniBtn = btn;
       return btn;
      }
      
      function ensureMinimapMiniButton() {
       if (minimapMiniBtn) return minimapMiniBtn;
       const panel = document.querySelector(".topology-panel");
       if (!panel) return null;
       const btn = document.createElement("button");
       btn.type = "button";
       btn.id = "minimap-mini";
       btn.className = "legend-mini-btn";
       btn.textContent = "Map";
       btn.style.right = "10px";
       btn.style.left = "auto";
       btn.style.bottom = "10px";
       const handleClick = (e) => {
        e.stopPropagation();
        e.preventDefault();
        minimapCollapsed = false;
        updateMinimapVisibility();
       };
       btn.addEventListener("click", handleClick);
       btn.addEventListener("touchend", handleClick);
       panel.appendChild(btn);
       minimapMiniBtn = btn;
       return btn;
      }
      
      function ensureDrawToolbarMiniButton() {
       if (drawToolbarMiniBtn) return drawToolbarMiniBtn;
       const panel = document.querySelector(".topology-panel");
       if (!panel) return null;
       const btn = document.createElement("button");
       btn.type = "button";
       btn.id = "draw-toolbar-mini";
       btn.className = "legend-mini-btn";
       btn.textContent = "Draw";
       btn.style.top = "10px";
       btn.style.left = "10px";
       btn.style.right = "auto";
       const handleClick = (e) => {
        e.stopPropagation();
        e.preventDefault();
        drawToolbarCollapsed = false;
        updateDrawToolbarVisibility();
       };
       btn.addEventListener("click", handleClick);
       btn.addEventListener("touchend", handleClick);
       panel.appendChild(btn);
       drawToolbarMiniBtn = btn;
       return btn;
      }
      
      function ensureTopologyToolbarMiniButton() {
       if (topologyToolbarMiniBtn) return topologyToolbarMiniBtn;
       const panel = document.querySelector(".topology-panel");
       if (!panel) return null;
       const btn = document.createElement("button");
       btn.type = "button";
       btn.id = "topology-toolbar-mini";
       btn.className = "legend-mini-btn";
       btn.textContent = "Add Line";
       btn.style.top = "10px";
       btn.style.left = "auto";
       btn.style.right = "40px";
       const handleClick = (e) => {
        e.stopPropagation();
        e.preventDefault();
        topologyToolbarCollapsed = false;
        updateTopologyToolbarVisibility();
       };
       btn.addEventListener("click", handleClick);
       btn.addEventListener("touchend", handleClick);
       panel.appendChild(btn);
       topologyToolbarMiniBtn = btn;
       return btn;
      }
      
      function updateToolbarStack() {
       if (!isMobileDevice()) return;
       const draw = document.getElementById("draw-toolbar");
       const topo = document.getElementById("topology-toolbar");
       if (!draw || !topo) return;
       const h = draw.getBoundingClientRect().height;
       document.documentElement.style.setProperty("--draw-toolbar-height", h + "px");
      }
      window.addEventListener("resize", updateToolbarStack);
      window.addEventListener("DOMContentLoaded", updateToolbarStack);
      updateToolbarStack();
      
      function updateLegendVisibility() {
       const legend = document.getElementById("edge-legend");
       const mini = ensureLegendMiniButton();
       if (!legend || !mini) return;
       const hasItems = legend.querySelectorAll(".legend-item").length > 0;
       if (!hasItems) {
        legend.style.display = "none";
        mini.style.display = "none";
        return;
       }
       if (legendCollapsed) {
        legend.style.display = "none";
        mini.style.display = "inline-flex";
       } else {
        legend.style.display = "flex";
        mini.style.display = "none";
       }
      }
      
      function updateMinimapVisibility() {
       const wrapper = document.getElementById("minimap-zoom-wrapper");
       const mini = ensureMinimapMiniButton();
       if (!wrapper || !mini) return;
       if (minimapCollapsed) {
        wrapper.style.display = "none";
        mini.style.display = "inline-flex";
       } else {
        wrapper.style.display = "block";
        mini.style.display = "none";
       }
      }
      
      function updateDrawToolbarVisibility() {
       const toolbar = document.getElementById("draw-toolbar");
       const mini = ensureDrawToolbarMiniButton();
       if (!toolbar || !mini) return;
       if (drawToolbarCollapsed) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "inline-flex";
       } else {
      if (isMobileDevice()) {    	   
        toolbar.style.setProperty('display', 'grid', 'important');
        mini.style.display = "none";
        } else {   
        toolbar.style.setProperty('display', 'flex', 'important');
        mini.style.display = "none";	  
      }
       }
      }
      
      function u8ToBase64(u8) {
      let binary = "";
      for (let i = 0; i < u8.length; i++) binary += String.fromCharCode(u8[i]);
      return btoa(binary);
      }
      
      function base64ToU8(base64) {
      const binary = atob(base64);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
      return bytes;
      }  
      
      function updateTopologyToolbarVisibility() {
       const toolbar = document.getElementById("topology-toolbar");
       const mini = ensureTopologyToolbarMiniButton();
       if (!toolbar || !mini) return;
       const hasSelectedNode = currentNodeId !== null;
       if (!hasSelectedNode) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "none";
       } else if (topologyToolbarCollapsed) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "inline-flex";
       } else {   
      if (isMobileDevice()) {    	   
        toolbar.style.setProperty('display', 'grid', 'important');
        mini.style.display = "none";
        } else {   
        toolbar.style.setProperty('display', 'flex', 'important');
        mini.style.display = "none";	  
      }
       }
      }
      const DEFAULT_CANVAS_HINT = document.getElementById("canvas-hint")?.innerHTML || "";
      const DEFAULT_PAGE_STATE = {
       title: "The One File: The Networkening",
       background: "",
       topbarBg: "rgba(9, 12, 20, 0.9)",
       topbarBorder: "#1f2533",
       panel: "#0b0e13",
       panelAlt: "#10141b",
       accent: "#4fd1c5",
       sidebarBg: "#10141b",
       btnBg: "#0b0e13",
       btnText: "#e2e8f0",
       tagFill: "#1e293b",
       tagText: "#e2e8f0",
       tagBorder: "#475569",
       inputBg: "#0b0e13",
       inputText: "#e2e8f0",
       inputBorder: "#1f2937",
       inputFont: "Inter, system-ui, sans-serif",
       inputFontSize: 14,
       toolbarBg: "#0f172a",
       toolbarBorder: "#1f2937",
       toolbarText: "#94a3b8",
       toolbarBtnBg: "#0b0e13",
       toolbarBtnText: "#e2e8f0",
       minimapDots: "#94a3b8",
       canvasHintEnabled: true,
       canvasHintText: "",
       canvasHintBg: "#0f172a",
       canvasHintColor: "#94a3b8",
       danger: "#f56565",
       textMain: "#e2e8f0",
       textSoft: "#94a3b8",
       topbarHeight: 52,
       sidebarWidth: 350,
       mobileFooterHeight: 40,
       sidebarCollapsed: false,
       nodeFill: "#1e293b",
       nodeStroke: "#475569",
       nodeTitle: "#e2e8f0",
       nodeSub: "#94a3b8",
       nodeTitleSize: 18,
       nodeSubSize: 13,
       nodeFont: "Inter, system-ui, sans-serif",
       defaultEdge: "#475569",
       selectionHandle: "#f59e0b",
       selectionHandleSize: 8,
       groupIndicator: "#4fd1c5",
       canvasGradientTop: "#1e2532",
       canvasGradientBottom: "#050608",
       canvasBorder: "#475569",
       canvasGrid: "#475569",
       canvasGridSize: 50,
       rackFrameFill: "#0f172a",
       rackFrameStroke: "#4fd1c5",
       rackLineColor: "#475569",
       rackTextColor: "#4fd1c5",
      };
      let PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE);
      const CANVAS_WIDTH = 4000;
      let CANVAS_HEIGHT = 3000;
      const BASE_CANVAS_HEIGHT = 3000;
      const CANVAS_PADDING = 100;
      
      const RACK_U_HEIGHT = 70;
      const RACK_WIDTH = 600;
      const RACK_START_X = CANVAS_WIDTH / 2;
      const RACK_START_Y = CANVAS_PADDING + 100;
      function getRackUHeight(rackId) {
      const capacity = getRackCapacity(rackId);
      const availableHeight = CANVAS_HEIGHT - RACK_START_Y - 200;
      return Math.floor(availableHeight / capacity);
      }
      let canvasState = {
       zoom: 1,
       panX: 0,
       panY: 0,
       minZoom: 0.25,
       maxZoom: 4,
       isPanning: false,
       panStartX: 0,
       panStartY: 0,
       spacePressed: false,
      };
      
      function getViewBox() {
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       return {
        x: canvasState.panX,
        y: canvasState.panY,
        width: viewWidth,
        height: viewHeight,
       };
      }
      
      function updateViewBox() {
       const svg = document.getElementById("map");
       const vb = getViewBox();
       svg.setAttribute("viewBox", `${vb.x} ${vb.y} ${vb.width} ${vb.height}`, );
       const zoomLevel = document.getElementById("zoom-level");
       if (zoomLevel) {
        zoomLevel.textContent = Math.round(canvasState.zoom * 100) + "%";
       }
       updateMinimap();
      }
      
      function updateMinimap() {
       const minimapViewport = document.getElementById("minimap-viewport");
       const minimapSvg = document.getElementById("minimap");
       if (!minimapViewport || !minimapSvg) return;
       const vb = getViewBox();
       minimapViewport.setAttribute("x", vb.x);
       minimapViewport.setAttribute("y", vb.y);
       minimapViewport.setAttribute("width", vb.width);
       minimapViewport.setAttribute("height", vb.height);
       const minimapNodes = minimapSvg.querySelectorAll(".minimap-node");
       minimapNodes.forEach((n) => n.remove());
       const minimapEdges = minimapSvg.querySelectorAll(".minimap-edge");
       minimapEdges.forEach((e) => e.remove());
       
       EDGE_DATA.list.forEach((edge) => {
        if (edge.type === "custom") return;
        
        const fromNode = NODE_DATA[edge.from];
        const toNode = NODE_DATA[edge.to];
        if (!fromNode || !toNode) return;
        
        if (currentView.mode === "rack") {
         if (fromNode.assignedRack !== currentView.rackId || 
             toNode.assignedRack !== currentView.rackId) {
          return;
         }
        } else {
         if (fromNode.assignedRack || toNode.assignedRack) {
          return;
         }
        }
        
        const p1 = savedPositions[edge.from];
        const p2 = savedPositions[edge.to];
        if (!p1 || !p2) return;
        const line = document.createElementNS("http://www.w3.org/2000/svg", "line", );
        line.setAttribute("x1", p1.x);
        line.setAttribute("y1", p1.y);
        line.setAttribute("x2", p2.x);
        line.setAttribute("y2", p2.y);
        line.classList.add("minimap-edge");
        minimapSvg.insertBefore(line, minimapViewport);
       });
      
       Object.entries(savedPositions).forEach(([id, pos]) => {
        const node = NODE_DATA[id];
        if (!node) return;
        
        if (currentView.mode === "rack") {
         if (node.assignedRack !== currentView.rackId) {
          return;
         }
        } else {
         if (node.assignedRack) {
          return;
         }
        }
        
        const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle", );
        circle.setAttribute("cx", pos.x);
        circle.setAttribute("cy", pos.y);
        circle.setAttribute("r", 40);
        circle.classList.add("minimap-node");
        minimapSvg.insertBefore(circle, minimapViewport);
       });
      }
      
      function zoomTo(newZoom, centerX, centerY) {
       const oldZoom = canvasState.zoom;
       newZoom = Math.max(canvasState.minZoom, Math.min(canvasState.maxZoom, newZoom), );
       if (centerX !== undefined && centerY !== undefined) {
        const oldWidth = CANVAS_WIDTH / oldZoom;
        const oldHeight = CANVAS_HEIGHT / oldZoom;
        const newWidth = CANVAS_WIDTH / newZoom;
        const newHeight = CANVAS_HEIGHT / newZoom;
        const pointX = canvasState.panX + centerX * oldWidth;
        const pointY = canvasState.panY + centerY * oldHeight;
        canvasState.panX = pointX - centerX * newWidth;
        canvasState.panY = pointY - centerY * newHeight;
       }
       canvasState.zoom = newZoom;
       constrainPan();
       updateViewBox();
      }
      
      function constrainPan() {
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       const minVisiblePortion = 0.1;
       const maxPanX = CANVAS_WIDTH - viewWidth * minVisiblePortion;
       const maxPanY = CANVAS_HEIGHT - viewHeight * minVisiblePortion;
       const minPanX = -viewWidth * (1 - minVisiblePortion);
       const minPanY = -viewHeight * (1 - minVisiblePortion);
       canvasState.panX = Math.max(minPanX, Math.min(maxPanX, canvasState.panX), );
       canvasState.panY = Math.max(minPanY, Math.min(maxPanY, canvasState.panY), );
      }
      
      function fitToContent() {
       const positions = Object.values(savedPositions);
       if (positions.length === 0) {
        resetView();
        return;
       }
       let minX = Infinity,
        minY = Infinity,
        maxX = -Infinity,
        maxY = -Infinity;
       positions.forEach((pos) => {
        minX = Math.min(minX, pos.x - 100);
        minY = Math.min(minY, pos.y - 100);
        maxX = Math.max(maxX, pos.x + 100);
        maxY = Math.max(maxY, pos.y + 100);
       });
       const contentWidth = maxX - minX + 200;
       const contentHeight = maxY - minY + 200;
       const viewport = document.getElementById("canvas-viewport");
       const vpRect = viewport.getBoundingClientRect();
       const aspectRatio = vpRect.width / vpRect.height;
       const contentAspect = contentWidth / contentHeight;
       let newZoom;
       if (contentAspect > aspectRatio) {
        newZoom = (vpRect.width / contentWidth) * (CANVAS_WIDTH / vpRect.width);
       } else {
        newZoom = (vpRect.height / contentHeight) * (CANVAS_HEIGHT / vpRect.height);
       }
       newZoom = Math.max(canvasState.minZoom, Math.min(2, newZoom));
       const viewWidth = CANVAS_WIDTH / newZoom;
       const viewHeight = CANVAS_HEIGHT / newZoom;
       canvasState.zoom = newZoom;
       canvasState.panX = minX - 100 - (viewWidth - contentWidth) / 2;
       canvasState.panY = minY - 100 - (viewHeight - contentHeight) / 2;
       constrainPan();
       updateViewBox();
      }
      
      function resetView() {
       canvasState.zoom = 1;
       canvasState.panX = 0;
       canvasState.panY = 0;
       updateViewBox();
      }
      window.addEventListener("DOMContentLoaded", () => {
       const toggle = document.getElementById("mobile-menu-toggle");
       const menu = document.getElementById("topbar-menu");
       if (!toggle || !menu) return;
       toggle.addEventListener("click", () => {
        menu.classList.toggle("open");
       });
       menu.addEventListener("click", (e) => {
        const target = e.target.closest("a, button");
        if (!target) return;
        if (isMobileDevice()) {
       menu.classList.remove("open");
      }
       });
       const minimapCloseBtn = document.getElementById("minimap-close-btn");
       if (minimapCloseBtn) {
        const handleMinimapClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         minimapCollapsed = true;
         updateMinimapVisibility();
        };
        minimapCloseBtn.addEventListener("click", handleMinimapClose);
        minimapCloseBtn.addEventListener("touchend", handleMinimapClose);
       }
       const drawToolbarCloseBtn = document.getElementById("draw-toolbar-close-btn");
       if (drawToolbarCloseBtn) {
        const handleDrawClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         drawToolbarCollapsed = true;
         updateDrawToolbarVisibility();
        };
        drawToolbarCloseBtn.addEventListener("click", handleDrawClose);
        drawToolbarCloseBtn.addEventListener("touchend", handleDrawClose);
       }
       const topologyToolbarCloseBtn = document.getElementById("topology-toolbar-close-btn");
       if (topologyToolbarCloseBtn) {
        const handleTopologyClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         topologyToolbarCollapsed = true;
         updateTopologyToolbarVisibility();
        };
        topologyToolbarCloseBtn.addEventListener("click", handleTopologyClose);
        topologyToolbarCloseBtn.addEventListener("touchstart", (e) => e.preventDefault(), {
         passive: false
        });
        topologyToolbarCloseBtn.addEventListener("touchend", handleTopologyClose);
       }
      
       updateMinimapVisibility();
       updateDrawToolbarVisibility();
       updateTopologyToolbarVisibility();
      });
      
      function applyLayerFilter() {  
       activeLayers.clear(); 
       if (document.getElementById("layer-physical").checked) activeLayers.add("physical");    
       if (document.getElementById("layer-logical").checked) activeLayers.add("logical");    
       if (document.getElementById("layer-security").checked) activeLayers.add("security");     
       if (document.getElementById("layer-application").checked) activeLayers.add("application");
       forgeTheTopology();    
      }
      
      function isNodeVisible(nodeId) {  
       const node = NODE_DATA[nodeId];    
       if (!node) return false;     
       const nodeLayer = node.layer || "physical";     
       return activeLayers.has(nodeLayer);     
      }
      
      function enterRack(rackId) {
      if (!NODE_DATA[rackId] || !NODE_DATA[rackId].isRack) return;
      const rackCapacity = getRackCapacity(rackId);
      const neededHeight = RACK_START_Y + (rackCapacity * RACK_U_HEIGHT) + 200;
      if (neededHeight > BASE_CANVAS_HEIGHT) {
      CANVAS_HEIGHT = neededHeight;
      }
       
       currentView.mode = "rack";
       currentView.rackId = rackId;
       
       const backBtn = document.getElementById("back-to-topology-btn");
       if (backBtn) backBtn.style.display = "inline-block";
       
       const hint = document.getElementById("canvas-hint");
       if (hint) {
        hint.textContent = `Viewing: ${NODE_DATA[rackId].name} | Double click empty space to exit`;
        hint.classList.add("visible");
       }
       
      
      const rackUHeight = getRackUHeight(rackId);
      const rackHeight = rackCapacity * rackUHeight;
      const rackCenterX = RACK_START_X;
      const rackCenterY = RACK_START_Y + (rackHeight / 2);
       
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       
       canvasState.panX = rackCenterX - (viewWidth / 2);
       canvasState.panY = rackCenterY - (viewHeight / 2);
       
       constrainPan();
       updateViewBox();
       
       forgeTheTopology();
      }
      
      function exitRack() {
      CANVAS_HEIGHT = BASE_CANVAS_HEIGHT;
      currentView.mode = "topology";
      currentView.rackId = null;
       
       const backBtn = document.getElementById("back-to-topology-btn");
       if (backBtn) backBtn.style.display = "none";
       
       const hint = document.getElementById("canvas-hint");
       if (hint) {
        hint.classList.remove("visible");
       }
       
       if (savedTopologyView) {
        canvasState.zoom = savedTopologyView.zoom;
        canvasState.panX = savedTopologyView.panX;
        canvasState.panY = savedTopologyView.panY;
        updateViewBox();
       }
       
       forgeTheTopology();
      }
      
      function getRackCapacity(rackId) {
       const node = NODE_DATA[rackId];
       return node && node.rackCapacity ? parseInt(node.rackCapacity) : 42;
      }
      
      function populateRackDropdown() {
       const dropdown = document.getElementById("node-assigned-rack");
       if (!dropdown) return;
       
       dropdown.innerHTML = '<option value="">None</option>';
       
       Object.keys(NODE_DATA).forEach(id => {
        if (NODE_DATA[id].isRack) {
         const option = document.createElement("option");
         option.value = id;
         option.textContent = NODE_DATA[id].name;
         dropdown.appendChild(option);
        }
       });
      }
      
      function wieldThePower() {
       const root = document.documentElement;
       root.style.setProperty("--panel", PAGE_STATE.panel);
       root.style.setProperty("--panel-alt", PAGE_STATE.panelAlt);
       root.style.setProperty("--sidebar-bg", PAGE_STATE.sidebarBg || PAGE_STATE.panelAlt);
       root.style.setProperty("--btn-bg", PAGE_STATE.btnBg || PAGE_STATE.panel);
       root.style.setProperty("--btn-text", PAGE_STATE.btnText || "#e2e8f0");
       root.style.setProperty("--tag-fill", PAGE_STATE.tagFill || "#1e293b");
       root.style.setProperty("--tag-text", PAGE_STATE.tagText || "#e2e8f0");
       root.style.setProperty("--tag-border", PAGE_STATE.tagBorder || "#475569");
       root.style.setProperty("--input-bg", PAGE_STATE.inputBg || "#0b0e13");
       root.style.setProperty("--input-text", PAGE_STATE.inputText || "#e2e8f0");
       root.style.setProperty("--input-border", PAGE_STATE.inputBorder || "#1f2937");
       root.style.setProperty("--input-font", PAGE_STATE.inputFont || "Inter, system-ui, sans-serif");
       root.style.setProperty("--input-font-size", (PAGE_STATE.inputFontSize || 14) + "px");
       root.style.setProperty("--toolbar-bg", PAGE_STATE.toolbarBg || "#0f172a");
       root.style.setProperty("--toolbar-border", PAGE_STATE.toolbarBorder || "#1f2937");
       root.style.setProperty("--toolbar-text", PAGE_STATE.toolbarText || "#94a3b8");
       root.style.setProperty("--toolbar-btn-bg", PAGE_STATE.toolbarBtnBg || "#0b0e13");
       root.style.setProperty("--toolbar-btn-text", PAGE_STATE.toolbarBtnText || "#e2e8f0");
       root.style.setProperty("--minimap-dots", PAGE_STATE.minimapDots || "#94a3b8");
       root.style.setProperty("--canvas-hint-bg", PAGE_STATE.canvasHintBg || "#0f172a");
       root.style.setProperty("--canvas-hint-color", PAGE_STATE.canvasHintColor || "#94a3b8");
       
       const canvasHint = document.getElementById("canvas-hint");
       if (canvasHint) {
        canvasHint.style.display = PAGE_STATE.canvasHintEnabled === false ? "none" : "";
        if (PAGE_STATE.canvasHintText !== undefined && PAGE_STATE.canvasHintText !== "") {
         canvasHint.innerHTML = PAGE_STATE.canvasHintText;
        } else {
         canvasHint.innerHTML = DEFAULT_CANVAS_HINT;
        }
       }
       root.style.setProperty("--accent", PAGE_STATE.accent);
       root.style.setProperty("--danger", PAGE_STATE.danger);
       root.style.setProperty("--text-main", PAGE_STATE.textMain);
       root.style.setProperty("--text-soft", PAGE_STATE.textSoft);
       root.style.setProperty("--topbar-bg", PAGE_STATE.topbarBg);
       root.style.setProperty("--topbar-border", PAGE_STATE.topbarBorder);
       root.style.setProperty("--node-fill", PAGE_STATE.nodeFill || "#1e293b");
       root.style.setProperty("--node-stroke", PAGE_STATE.nodeStroke || "#475569");
       root.style.setProperty("--node-title", PAGE_STATE.nodeTitle || "#e2e8f0");
       root.style.setProperty("--node-sub", PAGE_STATE.nodeSub || "#94a3b8");
       root.style.setProperty("--node-title-size", (PAGE_STATE.nodeTitleSize || 18) + "px");
       root.style.setProperty("--node-sub-size", (PAGE_STATE.nodeSubSize || 13) + "px");
       root.style.setProperty("--node-font", PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif");
       root.style.setProperty("--default-edge", PAGE_STATE.defaultEdge || "#475569");
       root.style.setProperty("--selection-handle", PAGE_STATE.selectionHandle || "#f59e0b");
       root.style.setProperty("--selection-handle-size", (PAGE_STATE.selectionHandleSize || 8) + "px");
       root.style.setProperty("--group-indicator", PAGE_STATE.groupIndicator || "#4fd1c5");
       const topbarHeight = PAGE_STATE.topbarHeight || 52;
       const sidebarWidth = PAGE_STATE.sidebarWidth || 350;
       const mobileFooterHeight = PAGE_STATE.mobileFooterHeight || 40;
       root.style.setProperty("--topbar-height", topbarHeight + "px");
       root.style.setProperty("--sidebar-width", sidebarWidth + "px");
       root.style.setProperty("--mobile-footer-height", mobileFooterHeight + "vh", );
       const mainEl = document.querySelector("main");
       const detailsPanel = document.getElementById("details-panel");
       const sidebarToggle = document.getElementById("sidebar-toggle");
       if (PAGE_STATE.sidebarCollapsed) {
        if (mainEl) mainEl.classList.add("sidebar-collapsed");
        if (detailsPanel) detailsPanel.classList.add("collapsed");
        if (sidebarToggle) {
         sidebarToggle.classList.add("collapsed");
         sidebarToggle.textContent = "‚ñ∂";
        }
       } else {
        if (mainEl) mainEl.classList.remove("sidebar-collapsed");
        if (detailsPanel) detailsPanel.classList.remove("collapsed");
        if (sidebarToggle) {
         sidebarToggle.classList.remove("collapsed");
         sidebarToggle.textContent = "‚óÄ";
        }
       }
       if (PAGE_STATE.background) {
        document.body.style.background = PAGE_STATE.background;
       } else {
        document.body.style.background = `radial-gradient(circle at top, ${PAGE_STATE.canvasGradientTop || "#1e2532"} 0, ${PAGE_STATE.canvasGradientBottom || "#050608"} 70%)`;
       }
       document.title = PAGE_STATE.title || DEFAULT_PAGE_STATE.title;
       const titleEl = document.getElementById("page-title");
       if (titleEl) {
        titleEl.textContent = PAGE_STATE.title || DEFAULT_PAGE_STATE.title;
       }
      }
      (async function awakeTheImmortal() {
       let initialState = {};
       let decryptionCancelled = false;
       const stateEl = document.getElementById("topology-state");
       if (stateEl && stateEl.textContent.trim()) {
        try {
         let stateText = stateEl.textContent.trim();
         if (isEncrypted(stateText)) {
          let decrypted = false;
          let attempts = 0;
          const maxAttempts = 3;
          while (!decrypted && attempts < maxAttempts) {
           const password = prompt("This file is encrypted. Enter password to decrypt:\n(Attempt " + (attempts + 1) + " of " + maxAttempts + ")", );
           if (!password) {
            alert("Decryption cancelled. The file will not be loaded.", );
            decryptionCancelled = true;
            break;
           }
           try {
            stateText = await decryptData(stateText, password);
            decrypted = true;
           } catch (e) {
            attempts++;
            if (attempts < maxAttempts) {
             alert("Incorrect password. Please try again.");
            } else {
             alert("Maximum attempts reached. The file will not be loaded.", );
             decryptionCancelled = true;
            }
           }
          }
          if (!decrypted) {
           stateText = "{}";
          }
         }
         initialState = JSON.parse(stateText);
        } catch (e) {
         console.error("Failed to load state:", e);
         initialState = {};
        }
       }
       if (decryptionCancelled) {
        NODE_DATA = {};
        EDGE_DATA = {
         list: []
        };
        RECT_DATA = { list: [] };
        TEXT_DATA = { list: [] };
        EDGE_LEGEND = {};
        savedPositions = {};
        savedSizes = {};
        savedStyles = {};
       } else {
        NODE_DATA = initialState.nodeData ? initialState.nodeData : BASE_NODE_DATA;
        
        Object.keys(NODE_DATA).forEach(nodeId => {
         if (!NODE_DATA[nodeId].ping) {
          NODE_DATA[nodeId].ping = {
           enabled: false,
           protocol: 'http',
           customUrl: '',
           timeout: 3000,
           status: 'unknown',
           lastCheck: null
          };
         }
        });
        
        EDGE_DATA = initialState.edgeData ? initialState.edgeData : {
         list: [],
        };
        RECT_DATA = initialState.rectData ? initialState.rectData : { list: [] };
        TEXT_DATA = initialState.textData ? initialState.textData : { list: [] };
        EDGE_LEGEND = initialState.edgeLegend || {};
        savedPositions = initialState.nodePositions || {};
        savedSizes = initialState.nodeSizes || {};
        savedStyles = initialState.nodeStyles || {};
        if (initialState.iconCache) {
         IconLibrary.iconCache = initialState.iconCache;
        }
       }
       if (initialState.page) {
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, initialState.page, );
       }
       
       if (PAGE_STATE.autoPingEnabled !== undefined) {
        autoPingEnabled = PAGE_STATE.autoPingEnabled;
       }
       if (PAGE_STATE.autoPingInterval !== undefined) {
        autoPingInterval = PAGE_STATE.autoPingInterval;
       }
       
       if (initialState.canvas) {
        canvasState.zoom = initialState.canvas.zoom || 1;
        canvasState.panX = initialState.canvas.panX || 0;
        canvasState.panY = initialState.canvas.panY || 0;
       }
       
       if (initialState.savedTopologyView) {
        savedTopologyView = initialState.savedTopologyView;
       }
       
       if (initialState.documentTabs) {
        documentTabs = initialState.documentTabs;
        if (initialState.currentTabIndex !== undefined) {
          currentTabIndex = initialState.currentTabIndex;
          const currentTab = documentTabs[currentTabIndex];
          if (currentTab) {
            NODE_DATA = currentTab.nodes || NODE_DATA;
            EDGE_DATA = currentTab.edges || EDGE_DATA;
            savedPositions = currentTab.positions || savedPositions;
            savedSizes = currentTab.sizes || savedSizes;
            savedStyles = currentTab.styles || savedStyles;
            EDGE_LEGEND = currentTab.legend || EDGE_LEGEND;
            RECT_DATA = currentTab.rects || RECT_DATA;
            TEXT_DATA = currentTab.texts || TEXT_DATA;
            if (currentTab.pageState) PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, currentTab.pageState);
          }
        }
       }
       
       if (initialState.encryptedSections) {
        encryptedSections = initialState.encryptedSections;
       }
       
       wieldThePower();
       forgeTheTopology();
       updateViewBox();
       
       MobileManager.applyAll();
       
       if (autoPingEnabled) {
        startAutoPing();
       }
       
       const initialNodes = Object.keys(NODE_DATA);
       if (initialNodes.length > 0) {
        claimTheImmortal(initialNodes.includes("host") ? "host" : initialNodes[0], );
       } else {
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.display = "none";
       }
      })();
      
      window.addEventListener("resize", () => {
        MobileManager.applyAll();
      });
      
      function saveEdgeData() {}
      
      function saveEdgeLegend() {}
      
      function getBreakpointKey() {
       const w = window.innerWidth;
       if (w <= 380) return "fold";
       if (w <= 768) return "mobile";
       if (w <= 1024) return "tablet";
       return "desktop";
      }
      
      function resolveStylesEntry(styleEntry) {
       if (!styleEntry) return {};
       if (styleEntry.circleColor || styleEntry.titleColor || styleEntry.titleFont || styleEntry.titleSize || styleEntry.subColor || styleEntry.subFont || styleEntry.subSize) {
        return styleEntry;
       }
       const bp = getBreakpointKey();
       const base = styleEntry.all || {};
       const bpStyles = styleEntry[bp] || {};
       return Object.assign({}, base, bpStyles);
      }
      
      function resolveStylesForNode(id) {
       const styleEntry = savedStyles[id];
       if (!styleEntry) return {};
       return resolveStylesEntry(styleEntry);
      }
      
      function ensureStyleEntry(id) {
       if (!savedStyles[id]) savedStyles[id] = {};
       const entry = savedStyles[id];
       const flatProps = ["circleColor", "circleBorder", "titleColor", "titleFont", "titleSize", "subColor", "subFont", "subSize", ];
       const isFlat = flatProps.some((p) => Object.prototype.hasOwnProperty.call(entry, p), );
       if (isFlat) {
        const all = entry.all || {};
        flatProps.forEach((p) => {
         if (entry[p] !== undefined) {
          all[p] = entry[p];
          delete entry[p];
         }
        });
        entry.all = all;
       }
       return entry;
      }
      
      function getDefaultSize() {
       if (window.innerWidth <= 380) return 120;
       if (window.innerWidth <= 768) return 140;
       if (window.innerWidth <= 1024) return 70;
       return 55;
      }
      
      function createShapeElement(shape, size) {
       const ns = "http://www.w3.org/2000/svg";
       if (shape === "circle") {
        const c = document.createElementNS(ns, "circle");
        c.setAttribute("r", size);
        return c;
       }
       if (shape === "square") {
        const r = document.createElementNS(ns, "rect");
        const s = size * 2;
        r.setAttribute("x", -size);
        r.setAttribute("y", -size);
        r.setAttribute("width", s);
        r.setAttribute("height", s);
        r.setAttribute("rx", 4);
        return r;
       }
       if (shape === "rectangle") {
        const r = document.createElementNS(ns, "rect");
        r.setAttribute("x", -size * 1.4);
        r.setAttribute("y", -size * 0.8);
        r.setAttribute("width", size * 2.8);
        r.setAttribute("height", size * 1.6);
        r.setAttribute("rx", 6);
        return r;
       }
       if (shape === "triangle") {
        const p = document.createElementNS(ns, "polygon");
        const h = size * 1.8;
        const w = size * 2;
        p.setAttribute("points", `0,${-h} ${w / 2},${h / 2} ${-w / 2},${h / 2}`, );
        return p;
       }
       if (shape === "hexagon") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        const pts = [
         [0, -s],
         [s * 0.86, -s * 0.5],
         [s * 0.86, s * 0.5],
         [0, s],
         [-s * 0.86, s * 0.5],
         [-s * 0.86, -s * 0.5],
        ].map((pt) => pt.join(",")).join(" ");
        p.setAttribute("points", pts);
        return p;
       }
       if (shape === "stop-sign") {
        const p = document.createElementNS(ns, "polygon");
        const r = size;
        const ptsArr = [];
        for (let i = 0; i < 8; i++) {
         const a = (Math.PI / 4) * i + Math.PI / 8;
         ptsArr.push([Math.cos(a) * r, Math.sin(a) * r]);
        }
        const pts = ptsArr.map((pt) => pt.join(",")).join(" ");
        p.setAttribute("points", pts);
        return p;
       }
       if (shape === "star") {
        const p = document.createElementNS(ns, "polygon");
        const outer = size;
        const inner = size * 0.45;
        let pts = "";
        for (let i = 0; i < 10; i++) {
         const a = (Math.PI / 5) * i - Math.PI / 2;
         const r = i % 2 === 0 ? outer : inner;
         pts += `${Math.cos(a) * r},${Math.sin(a) * r} `;
        }
        p.setAttribute("points", pts.trim());
        return p;
       }
       if (shape === "diamond") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `0,${-s} ${s},0 0,${s} ${-s},0`);
        return p;
       }
       if (shape === "server") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.2);
        body.setAttribute("y", -size * 0.6);
        body.setAttribute("width", size * 2.4);
        body.setAttribute("height", size * 1.2);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 3; i++) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", -size * 0.9 + i * size * 0.5);
         line.setAttribute("y1", -size * 0.3);
         line.setAttribute("x2", -size * 0.9 + i * size * 0.5);
         line.setAttribute("y2", size * 0.3);
         line.style.stroke = "currentColor";
         line.style.strokeWidth = "2";
         line.style.opacity = "0.5";
         g.appendChild(line);
        }
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", size * 0.9);
        led.setAttribute("cy", 0);
        led.setAttribute("r", size * 0.1);
        led.style.fill = "#4ade80";
        g.appendChild(led);
        return g;
       }
       if (shape === "pc" || shape === "desktop") {
        const g = document.createElementNS(ns, "g");
        const monitor = document.createElementNS(ns, "rect");
        monitor.setAttribute("x", -size * 0.9);
        monitor.setAttribute("y", -size * 0.8);
        monitor.setAttribute("width", size * 1.8);
        monitor.setAttribute("height", size * 1.2);
        monitor.setAttribute("rx", 4);
        g.appendChild(monitor);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.75);
        screen.setAttribute("y", -size * 0.65);
        screen.setAttribute("width", size * 1.5);
        screen.setAttribute("height", size * 0.9);
        screen.setAttribute("rx", 2);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        const neck = document.createElementNS(ns, "rect");
        neck.setAttribute("x", -size * 0.15);
        neck.setAttribute("y", size * 0.4);
        neck.setAttribute("width", size * 0.3);
        neck.setAttribute("height", size * 0.3);
        g.appendChild(neck);
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.5);
        base.setAttribute("y", size * 0.7);
        base.setAttribute("width", size * 1);
        base.setAttribute("height", size * 0.15);
        base.setAttribute("rx", 2);
        g.appendChild(base);
        return g;
       }
       if (shape === "laptop") {
        const g = document.createElementNS(ns, "g");
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.8);
        screen.setAttribute("y", -size * 0.9);
        screen.setAttribute("width", size * 1.6);
        screen.setAttribute("height", size * 1.1);
        screen.setAttribute("rx", 4);
        g.appendChild(screen);
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.9);
        base.setAttribute("y", size * 0.25);
        base.setAttribute("width", size * 1.8);
        base.setAttribute("height", size * 0.6);
        base.setAttribute("rx", 4);
        g.appendChild(base);
        const pad = document.createElementNS(ns, "rect");
        pad.setAttribute("x", -size * 0.25);
        pad.setAttribute("y", size * 0.45);
        pad.setAttribute("width", size * 0.5);
        pad.setAttribute("height", size * 0.25);
        pad.setAttribute("rx", 2);
        pad.style.fill = "#1e293b";
        g.appendChild(pad);
        return g;
       }
       if (shape === "phone" || shape === "mobile") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.45);
        body.setAttribute("y", -size);
        body.setAttribute("width", size * 0.9);
        body.setAttribute("height", size * 2);
        body.setAttribute("rx", 8);
        g.appendChild(body);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.38);
        screen.setAttribute("y", -size * 0.85);
        screen.setAttribute("width", size * 0.76);
        screen.setAttribute("height", size * 1.6);
        screen.setAttribute("rx", 4);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        const btn = document.createElementNS(ns, "rect");
        btn.setAttribute("x", -size * 0.15);
        btn.setAttribute("y", size * 0.82);
        btn.setAttribute("width", size * 0.3);
        btn.setAttribute("height", size * 0.06);
        btn.setAttribute("rx", 2);
        btn.style.fill = "#475569";
        g.appendChild(btn);
        return g;
       }
       if (shape === "router") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.1);
        body.setAttribute("y", -size * 0.3);
        body.setAttribute("width", size * 2.2);
        body.setAttribute("height", size * 0.8);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        for (let i = -1; i <= 1; i++) {
         const ant = document.createElementNS(ns, "rect");
         ant.setAttribute("x", i * size * 0.6 - size * 0.05);
         ant.setAttribute("y", -size * 0.9);
         ant.setAttribute("width", size * 0.1);
         ant.setAttribute("height", size * 0.6);
         ant.setAttribute("rx", 2);
         g.appendChild(ant);
         const tip = document.createElementNS(ns, "circle");
         tip.setAttribute("cx", i * size * 0.6);
         tip.setAttribute("cy", -size * 0.95);
         tip.setAttribute("r", size * 0.08);
         g.appendChild(tip);
        }
        for (let i = 0; i < 4; i++) {
         const led = document.createElementNS(ns, "circle");
         led.setAttribute("cx", -size * 0.7 + i * size * 0.35);
         led.setAttribute("cy", size * 0.1);
         led.setAttribute("r", size * 0.06);
         led.style.fill = i < 2 ? "#4ade80" : "#facc15";
         g.appendChild(led);
        }
        return g;
       }
       if (shape === "switch") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.4);
        body.setAttribute("y", -size * 0.4);
        body.setAttribute("width", size * 2.8);
        body.setAttribute("height", size * 0.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 8; i++) {
         const port = document.createElementNS(ns, "rect");
         port.setAttribute("x", -size * 1.2 + i * size * 0.32);
         port.setAttribute("y", -size * 0.15);
         port.setAttribute("width", size * 0.22);
         port.setAttribute("height", size * 0.3);
         port.setAttribute("rx", 1);
         port.style.fill = "#1e293b";
         g.appendChild(port);
        }
        return g;
       }
       if (shape === "firewall") {
        const g = document.createElementNS(ns, "g");
        const wall = document.createElementNS(ns, "rect");
        wall.setAttribute("x", -size);
        wall.setAttribute("y", -size * 0.8);
        wall.setAttribute("width", size * 2);
        wall.setAttribute("height", size * 1.6);
        wall.setAttribute("rx", 4);
        g.appendChild(wall);
        for (let row = 0; row < 3; row++) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", -size * 0.85);
         line.setAttribute("y1", -size * 0.5 + row * size * 0.45);
         line.setAttribute("x2", size * 0.85);
         line.setAttribute("y2", -size * 0.5 + row * size * 0.45);
         line.style.stroke = "#475569";
         line.style.strokeWidth = "2";
         g.appendChild(line);
        }
        for (let row = 0; row < 4; row++) {
         const offset = row % 2 === 0 ? 0 : size * 0.35;
         for (let col = 0; col < 3; col++) {
          const line = document.createElementNS(ns, "line");
          const x = -size * 0.5 + col * size * 0.7 + offset;
          if (x > -size * 0.85 && x < size * 0.85) {
           line.setAttribute("x1", x);
           line.setAttribute("y1", -size * 0.8 + row * size * 0.45, );
           line.setAttribute("x2", x);
           line.setAttribute("y2", -size * 0.8 + row * size * 0.45 + size * 0.45, );
           line.style.stroke = "#475569";
           line.style.strokeWidth = "2";
           g.appendChild(line);
          }
         }
        }
        return g;
       }
       if (shape === "cloud") {
        const p = document.createElementNS(ns, "path");
        const s = size;
        p.setAttribute("d", `
             M ${-s * 0.8} ${s * 0.2}
             Q ${-s * 1.1} ${s * 0.2} ${-s * 1.1} ${-s * 0.1}
             Q ${-s * 1.1} ${-s * 0.5} ${-s * 0.7} ${-s * 0.5}
             Q ${-s * 0.7} ${-s * 0.9} ${-s * 0.2} ${-s * 0.9}
             Q ${s * 0.1} ${-s * 1.1} ${s * 0.5} ${-s * 0.8}
             Q ${s * 1} ${-s * 0.8} ${s * 1.1} ${-s * 0.3}
             Q ${s * 1.3} ${-s * 0.1} ${s * 1.1} ${s * 0.2}
             Q ${s * 1.1} ${s * 0.5} ${s * 0.7} ${s * 0.5}
             L ${-s * 0.5} ${s * 0.5}
             Q ${-s * 0.9} ${s * 0.5} ${-s * 0.9} ${s * 0.2}
             Z
            `, );
        return p;
       }
       if (shape === "database") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.7);
        body.setAttribute("y", -size * 0.6);
        body.setAttribute("width", size * 1.4);
        body.setAttribute("height", size * 1.4);
        g.appendChild(body);
        const top = document.createElementNS(ns, "ellipse");
        top.setAttribute("cx", 0);
        top.setAttribute("cy", -size * 0.6);
        top.setAttribute("rx", size * 0.7);
        top.setAttribute("ry", size * 0.25);
        g.appendChild(top);
        const bottom = document.createElementNS(ns, "ellipse");
        bottom.setAttribute("cx", 0);
        bottom.setAttribute("cy", size * 0.8);
        bottom.setAttribute("rx", size * 0.7);
        bottom.setAttribute("ry", size * 0.25);
        g.appendChild(bottom);
        const mid1 = document.createElementNS(ns, "ellipse");
        mid1.setAttribute("cx", 0);
        mid1.setAttribute("cy", -size * 0.15);
        mid1.setAttribute("rx", size * 0.7);
        mid1.setAttribute("ry", size * 0.2);
        mid1.style.fill = "none";
        mid1.style.stroke = "#475569";
        mid1.style.strokeWidth = "2";
        g.appendChild(mid1);
        const mid2 = document.createElementNS(ns, "ellipse");
        mid2.setAttribute("cx", 0);
        mid2.setAttribute("cy", size * 0.35);
        mid2.setAttribute("rx", size * 0.7);
        mid2.setAttribute("ry", size * 0.2);
        mid2.style.fill = "none";
        mid2.style.stroke = "#475569";
        mid2.style.strokeWidth = "2";
        g.appendChild(mid2);
        return g;
       }
       if (shape === "printer") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.4);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size * 0.9);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const trayTop = document.createElementNS(ns, "rect");
        trayTop.setAttribute("x", -size * 0.7);
        trayTop.setAttribute("y", -size * 0.8);
        trayTop.setAttribute("width", size * 1.4);
        trayTop.setAttribute("height", size * 0.4);
        trayTop.setAttribute("rx", 2);
        trayTop.style.fill = "#1e293b";
        g.appendChild(trayTop);
        const trayOut = document.createElementNS(ns, "rect");
        trayOut.setAttribute("x", -size * 0.6);
        trayOut.setAttribute("y", size * 0.5);
        trayOut.setAttribute("width", size * 1.2);
        trayOut.setAttribute("height", size * 0.35);
        trayOut.setAttribute("rx", 2);
        g.appendChild(trayOut);
        const paper = document.createElementNS(ns, "rect");
        paper.setAttribute("x", -size * 0.5);
        paper.setAttribute("y", size * 0.3);
        paper.setAttribute("width", size * 1);
        paper.setAttribute("height", size * 0.5);
        paper.style.fill = "#e2e8f0";
        g.appendChild(paper);
        return g;
       }
       const c = document.createElementNS(ns, "circle");
       c.setAttribute("r", size);
       return c;
      }
      
      function createNodeShape(id, size) {
       const styles = resolveStylesForNode(id);
       if (styles.icon && styles.icon.library && styles.icon.name) {
        const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
        g.classList.add("node-circle");
        IconLibrary.getIcon(styles.icon.library, styles.icon.name).then(svgText => {
         if (svgText) {
          const parser = new DOMParser();
          const doc = parser.parseFromString(svgText, 'image/svg+xml');
          const svgEl = doc.querySelector('svg');
          if (svgEl) {
           svgEl.setAttribute('width', size * 1.2);
           svgEl.setAttribute('height', size * 1.2);
           svgEl.setAttribute('x', -size * 0.6);
           svgEl.setAttribute('y', -size * 0.6);
           if (styles.circleColor) {
            svgEl.style.fill = styles.circleColor;
           }
           g.innerHTML = svgEl.outerHTML;
          }
         }
        });
        return g;
       }
       const shapeType = (NODE_DATA[id] && NODE_DATA[id].shape) || "circle";
       const shapeEl = createShapeElement(shapeType, size);
       shapeEl.classList.add("node-circle");
shapeEl.style.fill = styles.circleColor || PAGE_STATE.nodeFill || "#1e293b";
       shapeEl.style.stroke = styles.circleBorder || PAGE_STATE.nodeStroke || "#475569";
       return shapeEl;
      }
      
      function forgeTheLegend() {
       const container = document.getElementById("edge-legend");
       if (!container) return;
       container.innerHTML = "";
       const title = document.createElement("div");
       title.className = "legend-title";
       title.textContent = "Line Legend";
       container.appendChild(title);
       const closeBtn = document.createElement("button");
       closeBtn.type = "button";
       closeBtn.className = "legend-close-btn";
       closeBtn.textContent = "‚úï";
       closeBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        legendCollapsed = true;
        updateLegendVisibility();
       });
       container.appendChild(closeBtn);
       const colors = [...new Set(EDGE_DATA.list.map((e) => e.color).filter(Boolean))];
       if (colors.length === 0) {
        updateLegendVisibility();
        return;
       }
       colors.forEach((color) => {
         if (!EDGE_LEGEND[color]) {
          EDGE_LEGEND[color] = "you can edit me too";
         }
         const item = document.createElement("div");
         item.className = "legend-item";
         item.addEventListener("mousedown", (e) => e.stopPropagation());
         item.addEventListener("click", (e) => e.stopPropagation());
         const swatch = document.createElement("span");
         swatch.className = "legend-swatch";
         swatch.style.backgroundColor = color;
         swatch.style.cursor = "pointer";
         swatch.addEventListener("click", (e) => {
          e.stopPropagation();
          const edgeWithColor = EDGE_DATA.list.find(edge => edge.color === color);
          if (edgeWithColor) {
           selectTheConnection(edgeWithColor.id);
          }
         });
         let swatchTouchStart = null;
         let swatchTouchMoved = false;
         swatch.addEventListener("touchstart", (e) => {
         swatchTouchStart = Date.now();
         swatchTouchMoved = false;
         if (e.touches[0]) {
          swatchTouchStartX = e.touches[0].clientX;
          swatchTouchStartY = e.touches[0].clientY;
         }
        }, {
          passive: false
         });
         let swatchTouchStartX = 0, swatchTouchStartY = 0;
        swatch.addEventListener("touchmove", (e) => {
         if (e.touches[0]) {
          const dx = Math.abs(e.touches[0].clientX - swatchTouchStartX);
          const dy = Math.abs(e.touches[0].clientY - swatchTouchStartY);
          if (dx > 10 || dy > 10) swatchTouchMoved = true;
         }
        }, {
          passive: false
         });
         swatch.addEventListener("touchend", (e) => {
          if (swatchTouchStart && !swatchTouchMoved && Date.now() - swatchTouchStart < 400) {
           e.stopPropagation();
           e.preventDefault();
           const edgeWithColor = EDGE_DATA.list.find(edge => edge.color === color);
           if (edgeWithColor) {
            selectTheConnection(edgeWithColor.id);
           }
          }
          swatchTouchStart = null;
          swatchTouchMoved = false;
         }, {
          passive: false
         });
        const label = document.createElement("span");
        label.className = "legend-label";
        label.textContent = EDGE_LEGEND[color];
        if (isMobileDevice()) {
         label.style.cursor = "pointer";
         let labelTapStart = null;
         let labelTapMoved = false;
         label.addEventListener("touchstart", (e) => {
          labelTapStart = Date.now();
          labelTapMoved = false;
          if (e.touches[0]) {
           labelTapStartX = e.touches[0].clientX;
           labelTapStartY = e.touches[0].clientY;
          }
          e.stopPropagation();
         });
         let labelTapStartX = 0, labelTapStartY = 0;
         label.addEventListener("touchmove", (e) => {
          if (e.touches[0]) {
           const dx = Math.abs(e.touches[0].clientX - labelTapStartX);
           const dy = Math.abs(e.touches[0].clientY - labelTapStartY);
           if (dx > 10 || dy > 10) labelTapMoved = true;
          }
         });
         label.addEventListener("touchend", (e) => {
          if (labelTapStart && !labelTapMoved && Date.now() - labelTapStart < 400) {
           e.preventDefault();
           e.stopPropagation();
           const currentText = label.textContent;
           const newText = prompt("Edit legend label:", currentText);
           if (newText !== null && newText.trim()) {
            label.textContent = newText.trim();
            EDGE_LEGEND[color] = newText.trim();
            saveEdgeLegend();
           }
          }
          labelTapStart = null;
          labelTapMoved = false;
         });
        } else {
           label.contentEditable = true;
           label.addEventListener("focus", () => {
            label.classList.add("editing");
           });
           label.addEventListener("blur", () => {
            label.classList.remove("editing");
            const text = label.textContent.trim() || "you can edit me too";
            EDGE_LEGEND[color] = text;
            saveEdgeLegend();
           });
           label.addEventListener("keydown", (e) => {
            if (e.key === "Enter") {
             e.preventDefault();
             label.blur();
            }
           });
          }
          item.append(swatch, label); container.appendChild(item);
         }); updateLegendVisibility();
       }
      
       function deleteRectangle(rectId) {
      pushUndo("delete zone");
        RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== rectId);
        forgeTheTopology();
       }
      
       function updateRectangleDeleteButtons() {
        const deleteButtons = document.querySelectorAll('.rect-delete-btn');
        deleteButtons.forEach(btn => {
         btn.style.display = rectDrawMode ? 'block' : 'none';
        });
       }
      
      
       function forgeTheTopology() {
        if (!NODE_DATA || !EDGE_DATA) {
         console.warn("forgeTheTopology called before data initialized");
         return;
        }
        const svg = document.getElementById("map");
        svg.innerHTML = "";
        const ns = "http://www.w3.org/2000/svg";
        const defs = document.createElementNS(ns, "defs");
        const markerForward = document.createElementNS(ns, "marker");
        markerForward.id = "arrow-forward";
        markerForward.setAttribute("markerWidth", "10");
        markerForward.setAttribute("markerHeight", "10");
        markerForward.setAttribute("refX", "9");
        markerForward.setAttribute("refY", "3");
        markerForward.setAttribute("orient", "auto");
        markerForward.setAttribute("markerUnits", "strokeWidth");
        const pathForward = document.createElementNS(ns, "path");
        pathForward.setAttribute("d", "M0,0 L0,6 L9,3 z");
        pathForward.setAttribute("fill", "context-stroke");
        markerForward.appendChild(pathForward);
        defs.appendChild(markerForward);
        const markerBackward = document.createElementNS(ns, "marker");
        markerBackward.id = "arrow-backward";
        markerBackward.setAttribute("markerWidth", "10");
        markerBackward.setAttribute("markerHeight", "10");
        markerBackward.setAttribute("refX", "0");
        markerBackward.setAttribute("refY", "3");
        markerBackward.setAttribute("orient", "auto");
        markerBackward.setAttribute("markerUnits", "strokeWidth");
        const pathBackward = document.createElementNS(ns, "path");
        pathBackward.setAttribute("d", "M9,0 L9,6 L0,3 z");
        pathBackward.setAttribute("fill", "context-stroke");
        markerBackward.appendChild(pathBackward);
        defs.appendChild(markerBackward);
        svg.appendChild(defs);
        const boundary = document.createElementNS(ns, "rect");
        boundary.setAttribute("x", CANVAS_PADDING);
        boundary.setAttribute("y", CANVAS_PADDING);
        boundary.setAttribute("width", CANVAS_WIDTH - CANVAS_PADDING * 2);
        boundary.setAttribute("height", CANVAS_HEIGHT - CANVAS_PADDING * 2);
        boundary.setAttribute("fill", "none");
        boundary.setAttribute("stroke", (PAGE_STATE.canvasBorder || "#475569") + "4D");
        boundary.setAttribute("stroke-width", "20");
        boundary.setAttribute("stroke-dasharray", "10 5");
        boundary.setAttribute("rx", "8");
        svg.appendChild(boundary);
       
       if (currentView.mode !== "rack") {
        const gridGroup = document.createElementNS(ns, "g");
        gridGroup.id = "canvas-grid";
        const gridSize = PAGE_STATE.canvasGridSize || 50;
        const gridColor = (PAGE_STATE.canvasGrid || "#475569") + "33";
        const majorGridColor = (PAGE_STATE.canvasGrid || "#475569") + "66";
        
        for (let x = CANVAS_PADDING; x <= CANVAS_WIDTH - CANVAS_PADDING; x += gridSize) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", x);
         line.setAttribute("y1", CANVAS_PADDING);
         line.setAttribute("x2", x);
         line.setAttribute("y2", CANVAS_HEIGHT - CANVAS_PADDING);
         line.setAttribute("stroke", (x - CANVAS_PADDING) % (gridSize * 5) === 0 ? majorGridColor : gridColor);
         line.setAttribute("stroke-width", (x - CANVAS_PADDING) % (gridSize * 5) === 0 ? "2" : "1");
         gridGroup.appendChild(line);
        }
        
        for (let y = CANVAS_PADDING; y <= CANVAS_HEIGHT - CANVAS_PADDING; y += gridSize) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", CANVAS_PADDING);
         line.setAttribute("y1", y);
         line.setAttribute("x2", CANVAS_WIDTH - CANVAS_PADDING);
         line.setAttribute("y2", y);
         line.setAttribute("stroke", (y - CANVAS_PADDING) % (gridSize * 5) === 0 ? majorGridColor : gridColor);
         line.setAttribute("stroke-width", (y - CANVAS_PADDING) % (gridSize * 5) === 0 ? "2" : "1");
         gridGroup.appendChild(line);
        }
        
        svg.appendChild(gridGroup);
       }
       
       if (currentView.mode === "rack" && currentView.rackId) {
         const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
         const rackGroup = document.createElementNS(ns, "g");
         rackGroup.id = "rack-visualization";       
         const rackFrame = document.createElementNS(ns, "rect");
         rackFrame.setAttribute("x", RACK_START_X - RACK_WIDTH / 2);
         rackFrame.setAttribute("y", RACK_START_Y);
         rackFrame.setAttribute("width", RACK_WIDTH);
         rackFrame.setAttribute("height", rackCapacity * rackUHeight);
      
         rackFrame.setAttribute("fill", (PAGE_STATE.rackFrameFill || "#0f172a") + "4D");
         rackFrame.setAttribute("stroke", PAGE_STATE.rackFrameStroke || "#4fd1c5");
         rackFrame.setAttribute("stroke-width", "3");
         rackFrame.setAttribute("rx", "4");
         rackGroup.appendChild(rackFrame);
         
         for (let u = 0; u <= rackCapacity; u++) {
          const y = RACK_START_Y + u * rackUHeight;
        
          const line = document.createElementNS(ns, "line");
          line.setAttribute("x1", RACK_START_X - RACK_WIDTH / 2);
          line.setAttribute("y1", y);
          line.setAttribute("x2", RACK_START_X + RACK_WIDTH / 2);
          line.setAttribute("y2", y);
          line.setAttribute("stroke", (PAGE_STATE.rackLineColor || "#475569") + "66");
          line.setAttribute("stroke-width", u % 5 === 0 ? "2" : "1");
          line.setAttribute("stroke-dasharray", u % 5 === 0 ? "none" : "5,5");
          rackGroup.appendChild(line);
          
          if (u < rackCapacity) {
           const uNumber = rackCapacity - u;
           const text = document.createElementNS(ns, "text");
           text.setAttribute("x", RACK_START_X - RACK_WIDTH / 2 - 30);
           text.setAttribute("y", y + rackUHeight / 2);
           text.setAttribute("text-anchor", "middle");
           text.setAttribute("dominant-baseline", "middle");
           text.style.fill = PAGE_STATE.rackTextColor || "#4fd1c5";
           text.style.fontSize = "14px";
           text.style.fontWeight = "bold";
           text.textContent = `U${uNumber}`;
           rackGroup.appendChild(text);
           
           const textRight = document.createElementNS(ns, "text");
           textRight.setAttribute("x", RACK_START_X + RACK_WIDTH / 2 + 30);
           textRight.setAttribute("y", y + rackUHeight / 2);
           textRight.setAttribute("text-anchor", "middle");
           textRight.setAttribute("dominant-baseline", "middle");
           textRight.style.fill = PAGE_STATE.rackTextColor || "#4fd1c5";
           textRight.style.fontSize = "14px";
           textRight.style.fontWeight = "bold";
           textRight.textContent = `U${uNumber}`;
           rackGroup.appendChild(textRight);
          }
         }
         
         svg.appendChild(rackGroup);
        }
      
        const centerX = CANVAS_WIDTH / 2;
      
        if (RECT_DATA && RECT_DATA.list) {
         RECT_DATA.list.forEach((rect) => {
          if (currentView.mode === "rack") return;
          
          if (rect.style === "filled") {
           const g = document.createElementNS(ns, "g");
           g.classList.add("rect-group");
           g.dataset.rectId = rect.id;
           
           const rectEl = document.createElementNS(ns, "rect");
           rectEl.classList.add("rect-shape");
           rectEl.setAttribute("x", rect.x);
           rectEl.setAttribute("y", rect.y);
           rectEl.setAttribute("width", rect.width);
           rectEl.setAttribute("height", rect.height);
           rectEl.style.fill = rect.color;
           rectEl.style.fillOpacity = "0.3";
           rectEl.style.stroke = rect.borderColor || rect.color;
           rectEl.style.strokeWidth = (rect.borderWidth !== undefined ? rect.borderWidth : 2) + "px";
           if (rect.lineStyle === "dashed") { rectEl.style.strokeDasharray = "10,5"; }
           else if (rect.lineStyle === "dotted") { rectEl.style.strokeDasharray = "2,4"; }
           else { rectEl.style.strokeDasharray = "none"; }
           rectEl.style.cursor = "move";
           
           rectEl.addEventListener("click", (e) => {
             if (rectDrawMode) return;
             e.stopPropagation();
             currentRectId = rect.id;
             selectTheRect(rect.id);
           });
           
           rectEl.addEventListener("contextmenu", (e) => {
             e.preventDefault();
             e.stopPropagation();
             if (selectedRects.has(rect.id)) {
               selectedRects.delete(rect.id);
             } else {
               selectedRects.add(rect.id);
             }
             updateAllSelections();
           });
           
           let rectLastTap = 0;
           rectEl.addEventListener("touchend", (e) => {
             const now = Date.now();
             if (now - rectLastTap < 300) {
               e.preventDefault();
               if (selectedRects.has(rect.id)) {
                 selectedRects.delete(rect.id);
               } else {
                 selectedRects.add(rect.id);
               }
               updateAllSelections();
               if (navigator.vibrate) navigator.vibrate(50);
               rectLastTap = 0;
             } else {
               rectLastTap = now;
             }
           }, { passive: false });
           
           const deleteBtn = document.createElementNS(ns, "g");
           deleteBtn.classList.add("rect-delete-btn");
           deleteBtn.style.cursor = "pointer";
           deleteBtn.style.display = rectDrawMode ? "block" : "none";
           
           const deleteBg = document.createElementNS(ns, "circle");
           deleteBg.setAttribute("cx", rect.x + rect.width - 10);
           deleteBg.setAttribute("cy", rect.y + 10);
           deleteBg.setAttribute("r", 12);
           deleteBg.style.fill = "#f56565";
           deleteBg.style.stroke = "white";
           deleteBg.style.strokeWidth = "2";
           
           const deleteX = document.createElementNS(ns, "text");
           deleteX.setAttribute("x", rect.x + rect.width - 10);
           deleteX.setAttribute("y", rect.y + 10);
           deleteX.setAttribute("text-anchor", "middle");
           deleteX.setAttribute("dominant-baseline", "middle");
           deleteX.style.fill = "white";
           deleteX.style.fontSize = "16px";
           deleteX.style.fontWeight = "bold";
           deleteX.style.pointerEvents = "none";
           deleteX.textContent = "√ó";
           
           deleteBtn.appendChild(deleteBg);
           deleteBtn.appendChild(deleteX);
           
           deleteBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            e.preventDefault();
            deleteRectangle(rect.id);
           });
           
           deleteBtn.addEventListener("touchend", (e) => {
      e.stopPropagation();
           e.preventDefault();
           deleteRectangle(rect.id);
           });
      
           let isDragging = false;
           let dragStartX, dragStartY;
           let rectStartX, rectStartY;
           
           rectEl.addEventListener("mousedown", (e) => {
      if (rectDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      rectStartX = rect.x;
      rectStartY = rect.y;
      rectEl.style.cursor = "grabbing";
      
      if (selectedRects.has(rect.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
           
      const moveHandler = (e) => {
      if (!isDragging || rectDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      rect.x = rectStartX + dx;
      rect.y = rectStartY + dy;
      if (selectedRects.has(rect.id)) {
      selectedNodes.forEach(nodeId => { if (initialPositions[nodeId]) { savedPositions[nodeId] = { x: initialPositions[nodeId].x + dx, y: initialPositions[nodeId].y + dy }; } });
      selectedRects.forEach(rectId => { if (rectId === rect.id) return; const r = RECT_DATA.list.find(x => x.id === rectId); if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; } });
      selectedTexts.forEach(textId => { const t = TEXT_DATA.list.find(x => x.id === textId); if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; } });
      selectedEdges.forEach(edgeId => { const ed = EDGE_DATA.list.find(x => x.id === edgeId); if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); } });
      }
      forgeTheTopology();
      };
           
           const upHandler = () => {
            if (isDragging) {
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           };
           
           document.addEventListener("mousemove", moveHandler);
           document.addEventListener("mouseup", upHandler);
           
           let touchStartX, touchStartY;
           let touchRectStartX, touchRectStartY;
           
           rectEl.addEventListener("touchstart", (e) => {
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchRectStartX = rect.x;
            touchRectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           }, { passive: false });
           
           rectEl.addEventListener("touchmove", (e) => {
            if (!isDragging || rectDrawMode) return;
            if (!e.touches[0]) return;
            e.preventDefault();
            e.stopPropagation();
            
            const svgEl = svg;
            const pt1 = svgEl.createSVGPoint();
            pt1.x = touchStartX;
            pt1.y = touchStartY;
            const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
            
            const touch = e.touches[0];
            const pt2 = svgEl.createSVGPoint();
            pt2.x = touch.clientX;
            pt2.y = touch.clientY;
            const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
            
            const dx = svgP2.x - svgP1.x;
            const dy = svgP2.y - svgP1.y;
            
            rect.x = touchRectStartX + dx;
            rect.y = touchRectStartY + dy;
            
            forgeTheTopology();
           }, { passive: false });
           
           rectEl.addEventListener("touchend", (e) => {
            if (isDragging) {
             e.preventDefault();
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           }, { passive: false });
            if (currentRectId === rect.id) {
      const corners = [
      { cx: rect.x, cy: rect.y, cursor: 'nwse-resize', dx: -1, dy: -1 },
      { cx: rect.x + rect.width, cy: rect.y, cursor: 'nesw-resize', dx: 1, dy: -1 },
      { cx: rect.x, cy: rect.y + rect.height, cursor: 'nesw-resize', dx: -1, dy: 1 },
      { cx: rect.x + rect.width, cy: rect.y + rect.height, cursor: 'nwse-resize', dx: 1, dy: 1 }
      ];
      corners.forEach((corner, idx) => {
      const handle = document.createElementNS(ns, "circle");
      handle.setAttribute("cx", corner.cx);
      handle.setAttribute("cy", corner.cy);
      handle.setAttribute("r", 8);
      handle.style.fill = "#f59e0b";
      handle.style.stroke = "#fff";
      handle.style.strokeWidth = "2";
      handle.style.cursor = corner.cursor;
      handle.addEventListener("mousedown", (e) => {
      e.preventDefault();
      e.stopPropagation();
      let dragging = true;
      const startX = e.clientX, startY = e.clientY;
      const origX = rect.x, origY = rect.y, origW = rect.width, origH = rect.height;
      const moveHandler = (ev) => {
        if (!dragging) return;
        const pt1 = svg.createSVGPoint(); pt1.x = startX; pt1.y = startY;
        const pt2 = svg.createSVGPoint(); pt2.x = ev.clientX; pt2.y = ev.clientY;
        const svgP1 = pt1.matrixTransform(svg.getScreenCTM().inverse());
        const svgP2 = pt2.matrixTransform(svg.getScreenCTM().inverse());
        const dx = svgP2.x - svgP1.x, dy = svgP2.y - svgP1.y;
        if (corner.dx < 0) { rect.x = origX + dx; rect.width = origW - dx; }
        else { rect.width = origW + dx; }
        if (corner.dy < 0) { rect.y = origY + dy; rect.height = origH - dy; }
        else { rect.height = origH + dy; }
        if (rect.width < 20) rect.width = 20;
        if (rect.height < 20) rect.height = 20;
        forgeTheTopology();
      };
      const upHandler = () => { dragging = false; document.removeEventListener("mousemove", moveHandler); document.removeEventListener("mouseup", upHandler); };
      document.addEventListener("mousemove", moveHandler);
      document.addEventListener("mouseup", upHandler);
      });
      g.appendChild(handle);
      });
      }
            if (rect.groupId) {
             const groupIndicator = document.createElementNS(ns, "rect");
             groupIndicator.setAttribute("x", rect.x - 4);
             groupIndicator.setAttribute("y", rect.y - 4);
             groupIndicator.setAttribute("width", rect.width + 8);
             groupIndicator.setAttribute("height", rect.height + 8);
             groupIndicator.style.fill = "none";
        groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
             groupIndicator.style.strokeWidth = "3";
             groupIndicator.style.strokeDasharray = "5,5";
             groupIndicator.style.pointerEvents = "none";
             g.insertBefore(groupIndicator, g.firstChild);
           }
           g.appendChild(rectEl);
           g.appendChild(deleteBtn);
           svg.appendChild(g);
          }
         });
        }
        const centerY = CANVAS_HEIGHT / 2;
        let positions = {};
        
        Object.keys(NODE_DATA).forEach((id) => {
         if (currentView.mode === "rack") {
          const node = NODE_DATA[id];
          if (!node || node.assignedRack !== currentView.rackId) {
           return;
          }
         }
         
         positions[id] = savedPositions[id] || {
          x: centerX,
          y: centerY
         };
        });
        if (Object.keys(savedPositions).length === 0) {
         const nodeIds = Object.keys(NODE_DATA).filter(id => {
          if (currentView.mode === "rack") {
           const node = NODE_DATA[id];
           return node && node.assignedRack === currentView.rackId;
          }
          return true;
         });
         
         const baseY = centerY - 300;
         if (nodeIds.length > 0) {
          positions[nodeIds[0]] = {
           x: centerX,
           y: baseY
          };
          const remaining = nodeIds.slice(1);
          const radius = 350;
          const startAngle = Math.PI * 0.3;
          const endAngle = Math.PI * 0.7;
          remaining.forEach((id, i) => {
           const angle = startAngle + (endAngle - startAngle) * (i / Math.max(1, remaining.length - 1));
           positions[id] = {
            x: centerX + Math.cos(angle) * radius * (i % 2 === 0 ? 1 : 1.3),
            y: baseY + 200 + Math.sin(angle) * radius * 0.8 + i * 80,
           };
          });
         }
        }
        Object.keys(positions).forEach((id) => {
         let pos = savedPositions[id] || positions[id];
         const nodeSize = savedSizes[id] || 55;
         pos.x = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, pos.x), );
         pos.y = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, pos.y), );
         positions[id] = {
          x: pos.x,
          y: pos.y
         };
         savedPositions[id] = {
          x: pos.x,
          y: pos.y
         };
        });
        const edgePairCount = {};
        const edgePairIndex = {};
        EDGE_DATA.list.forEach((edge) => {
         if (edge.type === "custom") return;
         const key = [edge.from, edge.to].sort().join("||");
         edgePairCount[key] = (edgePairCount[key] || 0) + 1;
        });
        EDGE_DATA.list.forEach((edge) => {
         if (edge.type === "custom") return;
         const key = [edge.from, edge.to].sort().join("||");
         if (!edgePairIndex[key]) edgePairIndex[key] = 0;
         edge._pairIndex = edgePairIndex[key];
         edge._pairTotal = edgePairCount[key];
         edgePairIndex[key]++;
        });
        EDGE_DATA.list.forEach((edge) => {
         if (edge.type === "custom" && Array.isArray(edge.points) && edge.points.length >= 2) {
          const customEdgeFaded = currentView.mode !== "rack" && edge.from && edge.to && (!isNodeVisible(edge.from) || !isNodeVisible(edge.to));
          const poly = document.createElementNS(ns, "polyline");
          poly.classList.add("edge");
          if (customEdgeFaded) {
           poly.style.opacity = "0.25";
           poly.classList.add("layer-faded");
          }
          poly.dataset.edgeId = edge.id;
poly.style.stroke = edge.color || PAGE_STATE.defaultEdge || "#475569";
          poly.style.strokeWidth = edge.width || 4;
          poly.setAttribute("fill", "none");
          const lineStyle = edge.lineStyle || "solid";
          if (lineStyle === "dashed") {
           poly.style.strokeDasharray = "10,5";
          } else if (lineStyle === "dotted") {
           poly.style.strokeDasharray = "2,4";
          } else {
           poly.style.strokeDasharray = "none";
          }
          const direction = edge.direction || "none";
          if (direction === "forward") {
           poly.setAttribute("marker-end", "url(#arrow-forward)");
          } else if (direction === "backward") {
           poly.setAttribute("marker-start", "url(#arrow-backward)");
          } else if (direction === "both") {
           poly.setAttribute("marker-start", "url(#arrow-backward)");
           poly.setAttribute("marker-end", "url(#arrow-forward)");
          }
          const ptsStr = edge.points.map((p) => `${p.x},${p.y}`).join(" ");
          poly.setAttribute("points", ptsStr);
          const polyHit = document.createElementNS(ns, "polyline");
          polyHit.setAttribute("points", ptsStr);
          polyHit.style.fill = "none";
          polyHit.style.stroke = "transparent";
          polyHit.style.strokeWidth = "20";
          polyHit.style.cursor = "pointer";
          polyHit.dataset.edgeId = edge.id;
          polyHit.addEventListener("click", (e) => {
           e.stopPropagation();
           selectTheConnection(edge.id);
          });
          let edgeTouchStart = null;
          let edgeTouchMoved = false;
          polyHit.addEventListener("touchstart", (e) => {
          edgeTouchStart = Date.now();
          edgeTouchMoved = false;
          if (e.touches[0]) {
           edgeTouchStartX = e.touches[0].clientX;
           edgeTouchStartY = e.touches[0].clientY;
          }
         }, {
           passive: false
          });
          let edgeTouchStartX = 0, edgeTouchStartY = 0;
         polyHit.addEventListener("touchmove", (e) => {
          if (e.touches[0]) {
           const dx = Math.abs(e.touches[0].clientX - edgeTouchStartX);
           const dy = Math.abs(e.touches[0].clientY - edgeTouchStartY);
           if (dx > 10 || dy > 10) edgeTouchMoved = true;
          }
         }, {
           passive: false
          });
          polyHit.addEventListener("touchend", (e) => {
           if (edgeTouchStart && !edgeTouchMoved && Date.now() - edgeTouchStart < 400) {
            e.stopPropagation();
            e.preventDefault();
            selectTheConnection(edge.id);
           }
           edgeTouchStart = null;
           edgeTouchMoved = false;
          }, {
           passive: false
          });
          poly.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         
         polyHit.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (selectedEdges.has(edge.id)) {
           selectedEdges.delete(edge.id);
          } else {
           selectedEdges.add(edge.id);
          }
          updateAllSelections();
         });
         
         let customEdgeLastTap = 0;
         polyHit.addEventListener("touchend", (e) => {
          const now = Date.now();
          if (now - customEdgeLastTap < 300) {
           e.preventDefault();
           if (selectedEdges.has(edge.id)) {
            selectedEdges.delete(edge.id);
           } else {
            selectedEdges.add(edge.id);
           }
           updateAllSelections();
           if (navigator.vibrate) navigator.vibrate(50);
           customEdgeLastTap = 0;
          } else {
           customEdgeLastTap = now;
          }
         }, { passive: false });
         
         poly.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (selectedEdges.has(edge.id)) {
           selectedEdges.delete(edge.id);
          } else {
           selectedEdges.add(edge.id);
          }
          updateAllSelections();
         });
         
         let edgeLastTap = 0;
         poly.addEventListener("touchend", (e) => {
          const now = Date.now();
          if (now - edgeLastTap < 300) {
           e.preventDefault();
           if (selectedEdges.has(edge.id)) {
            selectedEdges.delete(edge.id);
           } else {
            selectedEdges.add(edge.id);
           }
           updateAllSelections();
           if (navigator.vibrate) navigator.vibrate(50);
           edgeLastTap = 0;
          } else {
           edgeLastTap = now;
          }
         });
          
          if (currentView.mode === "rack") {
           return;
          }
          if (edge.groupId) {
      const bounds = edge.points.reduce((acc, p) => ({ minX: Math.min(acc.minX, p.x), minY: Math.min(acc.minY, p.y), maxX: Math.max(acc.maxX, p.x), maxY: Math.max(acc.maxY, p.y) }), { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity });
      const groupIndicator = document.createElementNS(ns, "rect");
      groupIndicator.setAttribute("x", bounds.minX - 8);
      groupIndicator.setAttribute("y", bounds.minY - 8);
      groupIndicator.setAttribute("width", bounds.maxX - bounds.minX + 16);
      groupIndicator.setAttribute("height", bounds.maxY - bounds.minY + 16);
      groupIndicator.setAttribute("rx", "4");
      groupIndicator.style.fill = "none";
  groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
      groupIndicator.style.strokeWidth = "3";
      groupIndicator.style.strokeDasharray = "5,5";
      groupIndicator.style.pointerEvents = "none";
      svg.appendChild(groupIndicator);
      }
         let lineDragging = false;
      let lineDragStartX, lineDragStartY;
      let linePointsStart = [];
      
      polyHit.addEventListener("mousedown", (e) => {
      if (freeDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      lineDragging = true;
      lineDragStartX = e.clientX;
      lineDragStartY = e.clientY;
      linePointsStart = edge.points.map(p => ({x: p.x, y: p.y}));
      
      if (selectedEdges.has(edge.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
      
      const lineMoveHandler = (e) => {
      if (!lineDragging || freeDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = lineDragStartX;
      pt1.y = lineDragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      
      edge.points.forEach((p, i) => { p.x = linePointsStart[i].x + dx; p.y = linePointsStart[i].y + dy; });
      
      if (selectedEdges.has(edge.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       savedPositions[nodeId] = { x: initialPositions[nodeId].x + dx, y: initialPositions[nodeId].y + dy };
      }
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      if (edgeId === edge.id) return;
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      forgeTheTopology();
      };
      
      const lineUpHandler = () => { lineDragging = false; };
      document.addEventListener("mousemove", lineMoveHandler);
      document.addEventListener("mouseup", lineUpHandler);
      
      svg.appendChild(poly);
      svg.appendChild(polyHit);
         
         if (currentEdgeId === edge.id) {
          edge.points.forEach((p, idx) => {
           const c = document.createElementNS(ns, "circle");
           c.classList.add("edge-edit-point");
           c.setAttribute("cx", p.x);
           c.setAttribute("cy", p.y);
c.setAttribute("r", PAGE_STATE.selectionHandleSize || 8);
           c.style.fill = PAGE_STATE.selectionHandle || "#f59e0b";
           c.style.stroke = "#fff";
           c.style.strokeWidth = "2";
           c.style.cursor = "move";
           c.dataset.edgeId = edge.id;
           c.dataset.pointIndex = String(idx);
           
           c.addEventListener("mousedown", (e) => {
            e.preventDefault();
            e.stopPropagation();
            let dragging = true;
            const svgEl = svg;
            const moveHandler = (ev) => {
             if (!dragging) return;
             const pt = svgEl.createSVGPoint();
             pt.x = ev.clientX;
             pt.y = ev.clientY;
             const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
             edge.points[idx].x = svgP.x;
             edge.points[idx].y = svgP.y;
             forgeTheTopology();
            };
            const upHandler = () => {
             dragging = false;
             document.removeEventListener("mousemove", moveHandler);
             document.removeEventListener("mouseup", upHandler);
            };
            document.addEventListener("mousemove", moveHandler);
            document.addEventListener("mouseup", upHandler);
           });
           
           c.addEventListener("touchstart", (e) => {
            e.preventDefault();
            e.stopPropagation();
            let dragging = true;
            const svgEl = svg;
            const touchMoveHandler = (ev) => {
             if (!dragging || !ev.touches[0]) return;
             const pt = svgEl.createSVGPoint();
             pt.x = ev.touches[0].clientX;
             pt.y = ev.touches[0].clientY;
             const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
             edge.points[idx].x = svgP.x;
             edge.points[idx].y = svgP.y;
             forgeTheTopology();
            };
            const touchUpHandler = () => {
             dragging = false;
             document.removeEventListener("touchmove", touchMoveHandler);
             document.removeEventListener("touchend", touchUpHandler);
            };
            document.addEventListener("touchmove", touchMoveHandler);
            document.addEventListener("touchend", touchUpHandler);
           }, { passive: false });
           
           svg.appendChild(c);
          });
         }
         
         return;
         }
         const p1 = positions[edge.from];
         const p2 = positions[edge.to];
         if (!p1 || !p2) return;
         const edgeFaded = currentView.mode !== "rack" && (!isNodeVisible(edge.from) || !isNodeVisible(edge.to));
         const pairTotal = edge._pairTotal || 1;
         const pairIndex = edge._pairIndex || 0;
         const midX = (p1.x + p2.x) / 2;
         const midY = (p1.y + p2.y) / 2;
         const dx = p2.x - p1.x;
         const dy = p2.y - p1.y;
         const len = Math.sqrt(dx * dx + dy * dy) || 1;
         const perpX = -dy / len;
         const perpY = dx / len;
         let offsetAmount = 0;
         if (pairTotal > 1) {
          offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
         }
         const ctrlX = midX + perpX * offsetAmount;
         const ctrlY = midY + perpY * offsetAmount;
         const path = document.createElementNS(ns, "path");
         path.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
         path.setAttribute("fill", "none");
         path.classList.add("edge");
         if (edgeFaded) {
          path.style.opacity = "0.25";
          path.classList.add("layer-faded");
         }
         if (edge.type === "backup") path.classList.add("backup");
         path.dataset.edgeId = edge.id;
         path.dataset.from = edge.from;
         path.dataset.to = edge.to;
         path.style.stroke = edge.color;
         path.style.strokeWidth = edge.width;
         const pathHit = document.createElementNS(ns, "path");
         pathHit.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
         pathHit.setAttribute("fill", "none");
         pathHit.style.stroke = "transparent";
         pathHit.style.strokeWidth = "20";
         pathHit.style.cursor = "pointer";
         pathHit.dataset.edgeId = edge.id;
         pathHit.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         let pathTouchStart = null;
         let pathTouchMoved = false;
         pathHit.addEventListener("touchstart", (e) => {
         pathTouchStart = Date.now();
         pathTouchMoved = false;
         if (e.touches[0]) {
          pathTouchStartX = e.touches[0].clientX;
          pathTouchStartY = e.touches[0].clientY;
         }
        }, {
          passive: false
         });
         let pathTouchStartX = 0, pathTouchStartY = 0;
        pathHit.addEventListener("touchmove", (e) => {
         if (e.touches[0]) {
          const dx = Math.abs(e.touches[0].clientX - pathTouchStartX);
          const dy = Math.abs(e.touches[0].clientY - pathTouchStartY);
          if (dx > 10 || dy > 10) pathTouchMoved = true;
         }
        }, {
          passive: false
         });
         pathHit.addEventListener("touchend", (e) => {
          if (pathTouchStart && !pathTouchMoved && Date.now() - pathTouchStart < 400) {
           e.stopPropagation();
           e.preventDefault();
           selectTheConnection(edge.id);
          }
          pathTouchStart = null;
          pathTouchMoved = false;
         }, {
          passive: false
         });
         path.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         
         if (currentView.mode === "rack") {
          const fromNode = NODE_DATA[edge.from];
          const toNode = NODE_DATA[edge.to];
          if (!fromNode || !toNode || 
              fromNode.assignedRack !== currentView.rackId || 
              toNode.assignedRack !== currentView.rackId) {
           return;
          }
         }
         
         svg.appendChild(path);
         svg.appendChild(pathHit);
         
         if (edge.fromPort || edge.toPort) {
          const ns = "http://www.w3.org/2000/svg";
          
          if (edge.fromPort) {
           const fromLabel = document.createElementNS(ns, "text");
           fromLabel.textContent = edge.fromPort;
           fromLabel.setAttribute("x", p1.x);
           fromLabel.setAttribute("y", p1.y - 10);
           fromLabel.setAttribute("text-anchor", "middle");
           fromLabel.style.fill = "#94a3b8";
           fromLabel.style.fontSize = "12px";
           fromLabel.style.fontWeight = "600";
           fromLabel.style.pointerEvents = "none";
           fromLabel.classList.add("port-label");
           svg.appendChild(fromLabel);
          }
      
          if (edge.toPort) {
           const toLabel = document.createElementNS(ns, "text");
           toLabel.textContent = edge.toPort;
           toLabel.setAttribute("x", p2.x);
           toLabel.setAttribute("y", p2.y - 10);
           toLabel.setAttribute("text-anchor", "middle");
           toLabel.style.fill = "#94a3b8";
           toLabel.style.fontSize = "12px";
           toLabel.style.fontWeight = "600";
           toLabel.style.pointerEvents = "none";
           toLabel.classList.add("port-label");
           svg.appendChild(toLabel);
          }
         }
        });
        Object.entries(positions).forEach(([id, pos]) => {
         const node = NODE_DATA[id];
         if (!node) return;
         
         if (currentView.mode === "rack") {
          if (node.assignedRack !== currentView.rackId) return;
          
         const rackUnit = parseInt(node.rackUnit) || 1;
      const uHeight = parseInt(node.uHeight) || 1;
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      pos.x = RACK_START_X;
      pos.y = RACK_START_Y + (rackCapacity - rackUnit - uHeight + 1) * rackUHeight + (uHeight * rackUHeight) / 2;
         } else {
          if (node.assignedRack) return;
         }
         
         const g = document.createElementNS("http://www.w3.org/2000/svg", "g", );
         g.classList.add("node-group");
         g.dataset.nodeId = id;
         g.setAttribute("transform", `translate(${pos.x},${pos.y})`);
         if (currentView.mode !== "rack" && !isNodeVisible(id)) {
          g.style.opacity = "0.25";
          g.classList.add("layer-faded");
         }
         let r = savedSizes[id] || 55;
         if (!savedSizes[id]) {
          if (window.innerWidth <= 380) r = 120;
          else if (window.innerWidth <= 768) r = 140;
          else if (window.innerWidth <= 1024) r = 70;
         }
         const styles = resolveStylesForNode(id);
         const ns = "http://www.w3.org/2000/svg";
         const hitArea = document.createElementNS(ns, "circle");
         hitArea.setAttribute("r", r * 1.5);
         hitArea.style.fill = "transparent";
         hitArea.style.stroke = "none";
         hitArea.style.cursor = "grab";
         hitArea.classList.add("node-hit-area");
         const shapeEl = createNodeShape(id, r);
         const titleOffsetX = styles.titleOffsetX || 0;
         const titleOffsetY = styles.titleOffsetY || 0;
         const subOffsetX = styles.subOffsetX || 0;
         const subOffsetY = styles.subOffsetY || 0;
         const label = document.createElementNS("http://www.w3.org/2000/svg", "text", );
         label.classList.add("node-label");
         label.setAttribute("x", titleOffsetX);
         label.setAttribute("y", -r * 0.28 + titleOffsetY);
         const labelFontSize = styles.titleSize || PAGE_STATE.nodeTitleSize || r * 0.33;
        label.style.fontSize = labelFontSize + "px";
         label.textContent = NODE_DATA[id].name;
label.style.fill = styles.titleColor || PAGE_STATE.nodeTitle || "#e2e8f0";
        label.style.fontFamily = styles.titleFont || PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
         label.style.pointerEvents = "none";
         const sub = document.createElementNS("http://www.w3.org/2000/svg", "text", );
         sub.classList.add("node-sub");
         sub.setAttribute("x", subOffsetX);
         sub.setAttribute("y", r * 0.4 + subOffsetY);
         const subFontSize = styles.subSize || PAGE_STATE.nodeSubSize || r * 0.24;
        sub.style.fontSize = subFontSize + "px";
         sub.textContent = NODE_DATA[id].ip;
sub.style.fill = styles.subColor || PAGE_STATE.nodeSub || "#94a3b8";
        sub.style.fontFamily = styles.subFont || PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
         sub.style.pointerEvents = "none";
         g.append(hitArea, shapeEl, label, sub);
         
         if (NODE_DATA[id]?.locked) {
           const lockIndicator = document.createElementNS(ns, "text");
           lockIndicator.textContent = "üîí";
           lockIndicator.setAttribute("x", r * 0.7);
           lockIndicator.setAttribute("y", -r * 0.7);
           lockIndicator.style.fontSize = (r * 0.3) + "px";
           lockIndicator.style.pointerEvents = "none";
           lockIndicator.classList.add("lock-indicator");
           g.appendChild(lockIndicator);
         }
         
         if (NODE_DATA[id]?.groupId) {
           const groupIndicator = document.createElementNS(ns, "circle");
           groupIndicator.setAttribute("r", r + 4);
           groupIndicator.style.fill = "none";
         groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
           groupIndicator.style.strokeWidth = "3";
           groupIndicator.style.strokeDasharray = "5,5";
           groupIndicator.style.pointerEvents = "none";
           groupIndicator.classList.add("group-indicator");
           
           g.insertBefore(groupIndicator, g.firstChild);
         }
         
         let isDragging = false;
         let startX, startY;
         let initialPositions = {};
         let longPressTimer = null;
         let longPressTriggered = false;
         
         g.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          e.stopPropagation();
          
          if (selectedNodes.has(id)) {
           selectedNodes.delete(id);
          } else {
           selectedNodes.add(id);
          }
          updateNodeSelection();
          return false;
         });
         
        g.addEventListener("touchstart", (e) => {
         if (NODE_DATA[id].isRack) {
          const touch = e.touches[0];
          longPressStartX = touch.clientX;
          longPressStartY = touch.clientY;
          longPressTimer = setTimeout(() => {
           longPressTriggered = true;
           if (navigator.vibrate) {
            navigator.vibrate(100);
           }
           enterRack(id);
          }, 500);
         }
        }, { passive: true });
        
        g.addEventListener("dblclick", (e) => {
         e.preventDefault();
         e.stopPropagation();
         if (NODE_DATA[id].isRack) {
          enterRack(id);
         }
        });
        
        let lastTapTime = 0;
        let lastTapNode = null;
        
        g.addEventListener("touchend", (e) => {
         const currentTime = new Date().getTime();
         const tapLength = currentTime - lastTapTime;
         
         if (tapLength < 300 && tapLength > 0 && lastTapNode === id) {
          e.preventDefault();
          e.stopPropagation();
          
          if (selectedNodes.has(id)) {
           selectedNodes.delete(id);
          } else {
           selectedNodes.add(id);
          }
          updateNodeSelection();
          
          if (navigator.vibrate) {
           navigator.vibrate(50);
          }
          
          lastTapTime = 0;
          lastTapNode = null;
         } else {
          lastTapTime = currentTime;
          lastTapNode = id;
         }
        });
         
         g.addEventListener("touchend", (e) => {
          if (longPressTimer) {
           clearTimeout(longPressTimer);
           longPressTimer = null;
          }
          if (longPressTriggered) {
           e.preventDefault();
           e.stopPropagation();
           longPressTriggered = false;
          }
         });
         
         let longPressStartX = 0;
        let longPressStartY = 0;
        g.addEventListener("touchmove", (e) => {
         if (longPressTimer) {
          const touch = e.touches[0];
          const dx = Math.abs(touch.clientX - longPressStartX);
          const dy = Math.abs(touch.clientY - longPressStartY);
          if (dx > 15 || dy > 15) {
           clearTimeout(longPressTimer);
           longPressTimer = null;
           longPressTriggered = false;
          }
         }
        });
         
         g.addEventListener("mousedown", (e) => {
          if (e.button === 2) {
           return;
          }
          
          if (NODE_DATA[id]?.locked) {
           return;
          }
          
          e.preventDefault();
          isDragging = true;
          const svgEl = document.getElementById("map");
          const pt = svgEl.createSVGPoint();
          pt.x = e.clientX;
          pt.y = e.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          startX = svgP.x;
          startY = svgP.y;
          
          let nodesToCollect = [];
      
      
      if (selectedNodes.has(id)) {
      initialPositions = {};
      const allSelectedRects = Array.from(selectedRects);
      const allSelectedTexts = Array.from(selectedTexts);
      const allSelectedEdges = Array.from(selectedEdges).map(eid => EDGE_DATA.list.find(e => e.id === eid)).filter(Boolean);
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) {
      initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      }
      });
      Array.from(selectedRects).forEach(rectId => {
        const rect = RECT_DATA.list.find(r => r.id === rectId);
        if (rect) { rect._dragStartX = rect.x; rect._dragStartY = rect.y; }
      });
      Array.from(selectedTexts).forEach(textId => {
        const text = TEXT_DATA.list.find(t => t.id === textId);
        if (text) { text._dragStartX = text.x; text._dragStartY = text.y; }
      });
      Array.from(selectedEdges).forEach(edgeId => {
        const edge = EDGE_DATA.list.find(e => e.id === edgeId);
        if (edge && edge.points) { edge._dragStartPoints = edge.points.map(p => ({x: p.x, y: p.y})); }
      });
      
      
      } else {
      initialPositions = { [id]: { x: pos.x, y: pos.y } };
      }
          
          const groupIds = new Set();
          nodesToCollect.forEach(nodeId => {
           const groupId = NODE_DATA[nodeId]?.groupId;
           if (groupId) {
             groupIds.add(groupId);
           }
          });
          
          if (groupIds.size > 0) {
           Object.keys(NODE_DATA).forEach(nodeId => {
             const nodeGroupId = NODE_DATA[nodeId]?.groupId;
             if (nodeGroupId && groupIds.has(nodeGroupId)) {
               if (!nodesToCollect.includes(nodeId)) {
                 nodesToCollect.push(nodeId);
               }
             }
           });
          }
          
          nodesToCollect = nodesToCollect.filter(nodeId => !NODE_DATA[nodeId]?.locked);
          
          if (nodesToCollect.length === 0) {
           return;
          }
          
          initialPositions = {};
          nodesToCollect.forEach(nodeId => {
           const nodePos = savedPositions[nodeId];
           if (nodePos) {
            initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
           }
          });
          
          g.style.cursor = "grabbing";
          hitArea.style.cursor = "grabbing";
          e.stopPropagation();
         });
         const handleMouseMove = (e) => {
          if (!isDragging) return;
          e.preventDefault();
          const svgEl = document.getElementById("map");
          const pt = svgEl.createSVGPoint();
          pt.x = e.clientX;
          pt.y = e.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          const dx = svgP.x - startX;
          const dy = svgP.y - startY;
          
          const nodesToMove = selectedNodes.has(id) ? Array.from(selectedNodes) : [id];
          nodesToMove.forEach(nodeId => {
           if (!initialPositions[nodeId]) return;
           const initialPos = initialPositions[nodeId];
           let newX = initialPos.x + dx;
           let newY = initialPos.y + dy;
           const nodeSize = savedSizes[nodeId] || 55;
           newX = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, newX), );
           newY = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, newY), );
           
           savedPositions[nodeId] = { x: newX, y: newY };
           positions[nodeId] = { x: newX, y: newY };
           
           if (nodeId === id) {
            pos.x = newX;
            pos.y = newY;
           }
           
           const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
          if (nodeGroup) {
           nodeGroup.setAttribute("transform", `translate(${newX},${newY})`);
          }
         });
         
         Array.from(selectedRects).forEach(rectId => {
           const rect = RECT_DATA.list.find(r => r.id === rectId);
           if (rect && rect._dragStartX !== undefined) {
             rect.x = rect._dragStartX + dx;
             rect.y = rect._dragStartY + dy;
           }
         });
         Array.from(selectedTexts).forEach(textId => {
           const text = TEXT_DATA.list.find(t => t.id === textId);
           if (text && text._dragStartX !== undefined) {
             text.x = text._dragStartX + dx;
             text.y = text._dragStartY + dy;
           }
         });
         Array.from(selectedEdges).forEach(edgeId => {
           const edge = EDGE_DATA.list.find(e => e.id === edgeId);
           if (edge && edge._dragStartPoints) {
             edge.points.forEach((p, i) => {
               p.x = edge._dragStartPoints[i].x + dx;
               p.y = edge._dragStartPoints[i].y + dy;
             });
           }
         });
         forgeTheTopology();
         
         updateMinimap();
          document.querySelectorAll(".edge").forEach((edgeEl) => {
           const fromId = edgeEl.dataset.from;
           const toId = edgeEl.dataset.to;
           if (nodesToMove.includes(fromId) || nodesToMove.includes(toId)) {
            const p1 = savedPositions[fromId] || positions[fromId] || {
             x: 600,
             y: 350
            };
            const p2 = savedPositions[toId] || positions[toId] || {
             x: 600,
             y: 350
            };
            if (edgeEl.tagName === "line") {
             edgeEl.setAttribute("x1", p1.x);
             edgeEl.setAttribute("y1", p1.y);
             edgeEl.setAttribute("x2", p2.x);
             edgeEl.setAttribute("y2", p2.y);
            } else if (edgeEl.tagName === "path") {
             const edgeId = edgeEl.dataset.edgeId;
             const edge = EDGE_DATA.list.find(
              (e) => e.id === edgeId, );
             if (edge) {
              const pairTotal = edge._pairTotal || 1;
              const pairIndex = edge._pairIndex || 0;
              const midX = (p1.x + p2.x) / 2;
              const midY = (p1.y + p2.y) / 2;
              const dx = p2.x - p1.x;
              const dy = p2.y - p1.y;
              const len = Math.sqrt(dx * dx + dy * dy) || 1;
              const perpX = -dy / len;
              const perpY = dx / len;
              let offsetAmount = 0;
              if (pairTotal > 1) {
               offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
              }
              const ctrlX = midX + perpX * offsetAmount;
              const ctrlY = midY + perpY * offsetAmount;
              edgeEl.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
             }
            }
           }
          });
         };
      const handleMouseUp = () => {
      if (isDragging) {
      pushUndo("move nodes");
      isDragging = false;
      g.style.cursor = "grab";
      hitArea.style.cursor = "grab";
      if (currentView.mode === "rack" && NODE_DATA[id]?.assignedRack === currentView.rackId) {
      const draggedY = savedPositions[id]?.y || pos.y;
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      let newUnit = rackCapacity - Math.round((draggedY - RACK_START_Y) / rackUHeight);
      newUnit = Math.max(1, Math.min(newUnit, rackCapacity));
      NODE_DATA[id].rackUnit = newUnit;
      forgeTheTopology();
      claimTheImmortal(id);
      }
      }
      };
         document.addEventListener("mousemove", handleMouseMove);
         document.addEventListener("mouseup", handleMouseUp);
         let touchStartTime = 0;
         let touchStartX = 0;
         let touchStartY = 0;
         let touchMoved = false;
       g.addEventListener("touchstart",
         (e) => {
          if (NODE_DATA[id]?.locked) {
           return;
          }
          
          e.preventDefault();
          touchStartTime = Date.now();
          touchMoved = false;
          const svgEl = document.getElementById("map");
          const pt = svgEl.createSVGPoint();
          const touch = e.touches[0];
          pt.x = touch.clientX;
          pt.y = touch.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          touchStartX = svgP.x;
          touchStartY = svgP.y;
          startX = svgP.x;
          startY = svgP.y;
          
          let nodesToCollect = [];
          if (selectedNodes.has(id)) {
           nodesToCollect = Array.from(selectedNodes);
          } else {
           nodesToCollect = [id];
          }
          
          const groupIds = new Set();
          nodesToCollect.forEach(nodeId => {
           const groupId = NODE_DATA[nodeId]?.groupId;
           if (groupId) {
             groupIds.add(groupId);
           }
          });
          
          if (groupIds.size > 0) {
           Object.keys(NODE_DATA).forEach(nodeId => {
             const nodeGroupId = NODE_DATA[nodeId]?.groupId;
             if (nodeGroupId && groupIds.has(nodeGroupId)) {
               if (!nodesToCollect.includes(nodeId)) {
                 nodesToCollect.push(nodeId);
               }
             }
           });
          }
          
          nodesToCollect = nodesToCollect.filter(nodeId => !NODE_DATA[nodeId]?.locked);
          
          if (nodesToCollect.length === 0) {
           return;
          }
          
          initialPositions = {};
          nodesToCollect.forEach(nodeId => {
           const nodePos = savedPositions[nodeId];
           if (nodePos) {
            initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
           }
          });
          
          e.stopPropagation();
         }, {
          passive: false
         }, );
         g.addEventListener("touchmove", (e) => {
         e.preventDefault();
         const svgEl = document.getElementById("map");
         const pt = svgEl.createSVGPoint();
         const touch = e.touches[0];
         pt.x = touch.clientX;
         pt.y = touch.clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
         const dx = Math.abs(svgP.x - touchStartX);
         const dy = Math.abs(svgP.y - touchStartY);
         if (dx > (isMobileDevice() ? 4 : 10) || dy > (isMobileDevice() ? 4 : 10)) {
      touchMoved = true;
      isDragging = true;
      }
         if (!isDragging) return;
         
         const deltaX = svgP.x - startX;
         const deltaY = svgP.y - startY;
         
         const nodesToMove = selectedNodes.has(id) ? Array.from(selectedNodes) : [id];
         nodesToMove.forEach(nodeId => {
          if (!initialPositions[nodeId]) return;
          const initialPos = initialPositions[nodeId];
          let newX = initialPos.x + deltaX;
          let newY = initialPos.y + deltaY;
          const nodeSize = savedSizes[nodeId] || 55;
          newX = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, newX), );
          newY = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, newY), );
          
          savedPositions[nodeId] = { x: newX, y: newY };
          positions[nodeId] = { x: newX, y: newY };
          
          if (nodeId === id) {
           pos.x = newX;
           pos.y = newY;
          }
          
          const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
          if (nodeGroup) {
           nodeGroup.setAttribute("transform", `translate(${newX},${newY})`);
          }
         });
         
         updateMinimap();
         document.querySelectorAll(".edge").forEach((edgeEl) => {
          const fromId = edgeEl.dataset.from;
          const toId = edgeEl.dataset.to;
          if (nodesToMove.includes(fromId) || nodesToMove.includes(toId)) {
            const p1 = savedPositions[fromId] || positions[fromId] || {
             x: 600,
             y: 350
            };
            const p2 = savedPositions[toId] || positions[toId] || {
             x: 600,
             y: 350
            };
            if (edgeEl.tagName === "line") {
             edgeEl.setAttribute("x1", p1.x);
             edgeEl.setAttribute("y1", p1.y);
             edgeEl.setAttribute("x2", p2.x);
             edgeEl.setAttribute("y2", p2.y);
            } else if (edgeEl.tagName === "path") {
             const edgeId = edgeEl.dataset.edgeId;
             const edge = EDGE_DATA.list.find(
              (e) => e.id === edgeId, );
             if (edge) {
              const pairTotal = edge._pairTotal || 1;
              const pairIndex = edge._pairIndex || 0;
              const midX = (p1.x + p2.x) / 2;
              const midY = (p1.y + p2.y) / 2;
              const dx = p2.x - p1.x;
              const dy = p2.y - p1.y;
              const len = Math.sqrt(dx * dx + dy * dy) || 1;
              const perpX = -dy / len;
              const perpY = dx / len;
              let offsetAmount = 0;
              if (pairTotal > 1) {
               offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
              }
              const ctrlX = midX + perpX * offsetAmount;
              const ctrlY = midY + perpY * offsetAmount;
              edgeEl.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
             }
            }
           }
          });
         }, {
          passive: false
         });
      g.addEventListener("touchend", (e) => {
      const touchDuration = Date.now() - touchStartTime;
      if (!touchMoved && touchDuration < 400) {
      claimTheImmortal(id);
      }
      if (isDragging) {
      const draggedY = pos.y;
      isDragging = false;
      savedPositions[id] = {
      x: pos.x,
      y: pos.y
      };
      if (currentView.mode === "rack" && NODE_DATA[id]?.assignedRack === currentView.rackId) {
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      let newUnit = rackCapacity - Math.round((draggedY - RACK_START_Y) / rackUHeight);
      newUnit = Math.max(1, Math.min(newUnit, rackCapacity));
      NODE_DATA[id].rackUnit = newUnit;
      forgeTheTopology();
      claimTheImmortal(id);
      }
      }
      touchMoved = false;
      });
         g.style.cursor = "grab";
         g.addEventListener("click", (e) => {
          if (!isDragging) {
           claimTheImmortal(id);
          }
         });
         svg.appendChild(g);
        });
        
        if (RECT_DATA && RECT_DATA.list) {
         RECT_DATA.list.forEach((rect) => {
          if (currentView.mode === "rack") return;
          if (rect.style === "outlined") {
           const g = document.createElementNS(ns, "g");
           g.classList.add("rect-group");
           g.dataset.rectId = rect.id;
           
           const rectEl = document.createElementNS(ns, "rect");
           rectEl.classList.add("rect-shape");
           rectEl.setAttribute("x", rect.x);
           rectEl.setAttribute("y", rect.y);
           rectEl.setAttribute("width", rect.width);
           rectEl.setAttribute("height", rect.height);
           rectEl.style.fill = "none";
           rectEl.style.stroke = rect.borderColor || rect.color;
           rectEl.style.strokeWidth = (rect.borderWidth !== undefined ? rect.borderWidth : 3) + "px";
      if (rect.lineStyle === "dashed") { rectEl.style.strokeDasharray = "10,5"; }
           else if (rect.lineStyle === "dotted") { rectEl.style.strokeDasharray = "2,4"; }
           else { rectEl.style.strokeDasharray = "none"; }
           rectEl.style.cursor = "move";
           
           rectEl.addEventListener("click", (e) => {
             if (rectDrawMode) return;
             e.stopPropagation();
             currentRectId = rect.id;
             selectTheRect(rect.id);
           });
           
           rectEl.addEventListener("contextmenu", (e) => {
             e.preventDefault();
             e.stopPropagation();
             if (selectedRects.has(rect.id)) {
               selectedRects.delete(rect.id);
             } else {
               selectedRects.add(rect.id);
             }
             updateAllSelections();
           });
           
           let rectLastTap = 0;
           rectEl.addEventListener("touchend", (e) => {
             const now = Date.now();
             if (now - rectLastTap < 300) {
               e.preventDefault();
               if (selectedRects.has(rect.id)) {
                 selectedRects.delete(rect.id);
               } else {
                 selectedRects.add(rect.id);
               }
               updateAllSelections();
               if (navigator.vibrate) navigator.vibrate(50);
               rectLastTap = 0;
             } else {
               rectLastTap = now;
             }
           }, { passive: false });
           
           const deleteBtn = document.createElementNS(ns, "g");
           deleteBtn.classList.add("rect-delete-btn");
           deleteBtn.style.cursor = "pointer";
           deleteBtn.style.display = rectDrawMode ? "block" : "none";
           
           const deleteBg = document.createElementNS(ns, "circle");
           deleteBg.setAttribute("cx", rect.x + rect.width - 10);
           deleteBg.setAttribute("cy", rect.y + 10);
           deleteBg.setAttribute("r", 12);
           deleteBg.style.fill = "#f56565";
           deleteBg.style.stroke = "white";
           deleteBg.style.strokeWidth = "2";
           
           const deleteX = document.createElementNS(ns, "text");
           deleteX.setAttribute("x", rect.x + rect.width - 10);
           deleteX.setAttribute("y", rect.y + 10);
           deleteX.setAttribute("text-anchor", "middle");
           deleteX.setAttribute("dominant-baseline", "middle");
           deleteX.style.fill = "white";
           deleteX.style.fontSize = "16px";
           deleteX.style.fontWeight = "bold";
           deleteX.style.pointerEvents = "none";
           deleteX.textContent = "√ó";
           
           deleteBtn.appendChild(deleteBg);
           deleteBtn.appendChild(deleteX);
           
           deleteBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            e.preventDefault();
            deleteRectangle(rect.id);
           });
           
           let isDragging = false;
           let dragStartX, dragStartY;
           let rectStartX, rectStartY;
           
           rectEl.addEventListener("mousedown", (e) => {
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            dragStartX = e.clientX;
            dragStartY = e.clientY;
            rectStartX = rect.x;
            rectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           });
           
      const moveHandler = (e) => {
      if (!isDragging || rectDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      rect.x = rectStartX + dx;
      rect.y = rectStartY + dy;
      if (selectedRects.has(rect.id)) {
      selectedNodes.forEach(nodeId => { if (initialPositions[nodeId]) { savedPositions[nodeId] = { x: initialPositions[nodeId].x + dx, y: initialPositions[nodeId].y + dy }; } });
      selectedRects.forEach(rectId => { if (rectId === rect.id) return; const r = RECT_DATA.list.find(x => x.id === rectId); if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; } });
      selectedTexts.forEach(textId => { const t = TEXT_DATA.list.find(x => x.id === textId); if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; } });
      selectedEdges.forEach(edgeId => { const ed = EDGE_DATA.list.find(x => x.id === edgeId); if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); } });
      }
      forgeTheTopology();
      };
           
           const upHandler = () => {
            if (isDragging) {
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           };
           
           document.addEventListener("mousemove", moveHandler);
           document.addEventListener("mouseup", upHandler);
           
           let touchStartX, touchStartY;
           let touchRectStartX, touchRectStartY;
           
           rectEl.addEventListener("touchstart", (e) => {
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchRectStartX = rect.x;
            touchRectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           }, { passive: false });
           
           rectEl.addEventListener("touchmove", (e) => {
            if (!isDragging || rectDrawMode) return;
            if (!e.touches[0]) return;
            e.preventDefault();
            e.stopPropagation();
            
            const svgEl = svg;
            const pt1 = svgEl.createSVGPoint();
            pt1.x = touchStartX;
            pt1.y = touchStartY;
            const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
            
            const touch = e.touches[0];
            const pt2 = svgEl.createSVGPoint();
            pt2.x = touch.clientX;
            pt2.y = touch.clientY;
            const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
            
            const dx = svgP2.x - svgP1.x;
            const dy = svgP2.y - svgP1.y;
            
            rect.x = touchRectStartX + dx;
            rect.y = touchRectStartY + dy;
            
            forgeTheTopology();
           }, { passive: false });
           
           rectEl.addEventListener("touchend", (e) => {
            if (isDragging) {
             e.preventDefault();
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           }, { passive: false });
           
           if (currentRectId === rect.id) {
             const corners = [
               { cx: rect.x, cy: rect.y, cursor: 'nwse-resize', dx: -1, dy: -1 },
               { cx: rect.x + rect.width, cy: rect.y, cursor: 'nesw-resize', dx: 1, dy: -1 },
               { cx: rect.x, cy: rect.y + rect.height, cursor: 'nesw-resize', dx: -1, dy: 1 },
               { cx: rect.x + rect.width, cy: rect.y + rect.height, cursor: 'nwse-resize', dx: 1, dy: 1 }
             ];
             corners.forEach((corner) => {
               const handle = document.createElementNS(ns, "circle");
               handle.setAttribute("cx", corner.cx);
               handle.setAttribute("cy", corner.cy);
handle.setAttribute("r", PAGE_STATE.selectionHandleSize || 8);
      handle.style.fill = PAGE_STATE.selectionHandle || "#f59e0b";
               handle.style.stroke = "#fff";
               handle.style.strokeWidth = "2";
               handle.style.cursor = corner.cursor;
               handle.addEventListener("mousedown", (e) => {
                 e.preventDefault();
                 e.stopPropagation();
                 let dragging = true;
                 const startX = e.clientX, startY = e.clientY;
                 const origX = rect.x, origY = rect.y, origW = rect.width, origH = rect.height;
                 const moveHandler = (ev) => {
                   if (!dragging) return;
                   const pt1 = svg.createSVGPoint(); pt1.x = startX; pt1.y = startY;
                   const pt2 = svg.createSVGPoint(); pt2.x = ev.clientX; pt2.y = ev.clientY;
                   const svgP1 = pt1.matrixTransform(svg.getScreenCTM().inverse());
                   const svgP2 = pt2.matrixTransform(svg.getScreenCTM().inverse());
                   const dx = svgP2.x - svgP1.x, dy = svgP2.y - svgP1.y;
                   if (corner.dx < 0) { rect.x = origX + dx; rect.width = origW - dx; }
                   else { rect.width = origW + dx; }
                   if (corner.dy < 0) { rect.y = origY + dy; rect.height = origH - dy; }
                   else { rect.height = origH + dy; }
                   if (rect.width < 20) rect.width = 20;
                   if (rect.height < 20) rect.height = 20;
                   forgeTheTopology();
                 };
                 const upHandler = () => { dragging = false; document.removeEventListener("mousemove", moveHandler); document.removeEventListener("mouseup", upHandler); };
                 document.addEventListener("mousemove", moveHandler);
                 document.addEventListener("mouseup", upHandler);
               });
               g.appendChild(handle);
             });
           }
           if (rect.groupId) {
             const groupIndicator = document.createElementNS(ns, "rect");
             groupIndicator.setAttribute("x", rect.x - 4);
             groupIndicator.setAttribute("y", rect.y - 4);
             groupIndicator.setAttribute("width", rect.width + 8);
             groupIndicator.setAttribute("height", rect.height + 8);
             groupIndicator.style.fill = "none";
         groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
             groupIndicator.style.strokeWidth = "3";
             groupIndicator.style.strokeDasharray = "5,5";
             groupIndicator.style.pointerEvents = "none";
             g.insertBefore(groupIndicator, g.firstChild);
           }
           g.appendChild(rectEl);
           g.appendChild(deleteBtn);
           svg.appendChild(g);
          }
         });
        }
        
        if (TEXT_DATA && TEXT_DATA.list) {
         TEXT_DATA.list.forEach((textItem) => {
          if (currentView.mode === "rack") return;
          
          const g = document.createElementNS(ns, "g");
          g.classList.add("text-group");
          g.dataset.textId = textItem.id;
          
          if (textItem.bgEnabled) {
           const bgRect = document.createElementNS(ns, "rect");
           bgRect.classList.add("text-bg");
      
           bgRect.setAttribute("x", textItem.x - 5);
           bgRect.setAttribute("y", textItem.y - textItem.fontSize - 2);
           bgRect.setAttribute("width", 100);
           bgRect.setAttribute("height", textItem.fontSize + 10);
           bgRect.style.fill = textItem.bgColor;
           bgRect.style.opacity = "0.7";
           bgRect.style.rx = "4";
           g.appendChild(bgRect);
          }
          
          const textEl = document.createElementNS(ns, "text");
          textEl.classList.add("text-element");
          textEl.setAttribute("x", textItem.x);
          textEl.setAttribute("y", textItem.y);
          textEl.style.fill = textItem.color;
          textEl.style.fontSize = textItem.fontSize + "px";
          textEl.style.fontWeight = textItem.fontWeight;
          textEl.style.fontStyle = textItem.fontStyle;
          textEl.style.textAnchor = textItem.textAlign;
          textEl.style.textDecoration = textItem.textDecoration;
          textEl.style.opacity = textItem.opacity;
          textEl.style.cursor = "move";
          textEl.style.userSelect = "none";
          textEl.setAttribute("dominant-baseline", "middle");
          
          const lines = textItem.content.split('\n');
          if (lines.length === 1) {
           textEl.textContent = textItem.content;
          } else {
           lines.forEach((line, i) => {
            const tspan = document.createElementNS(ns, "tspan");
            tspan.textContent = line;
            tspan.setAttribute("x", textItem.x);
            tspan.setAttribute("dy", i === 0 ? 0 : textItem.fontSize * 1.2);
            textEl.appendChild(tspan);
           });
          }
          
          g.appendChild(textEl);
          
          if (textItem.bgEnabled) {
           setTimeout(() => {
            try {
             const bbox = textEl.getBBox();
             const bgRect = g.querySelector('.text-bg');
             if (bgRect && bbox) {
              bgRect.setAttribute("x", bbox.x - 5);
              bgRect.setAttribute("y", bbox.y - 2);
              bgRect.setAttribute("width", bbox.width + 10);
              bgRect.setAttribute("height", bbox.height + 4);
             }
            } catch (e) {
            }
           }, 0);
          }
          
          const deleteBtn = document.createElementNS(ns, "g");
          deleteBtn.classList.add("text-delete-btn");
          deleteBtn.style.cursor = "pointer";
          deleteBtn.style.display = textDrawMode ? "block" : "none";
          
          const deleteBg = document.createElementNS(ns, "circle");
          deleteBg.setAttribute("cx", textItem.x + 20);
          deleteBg.setAttribute("cy", textItem.y - textItem.fontSize);
          deleteBg.setAttribute("r", 12);
          deleteBg.style.fill = "#f56565";
          deleteBg.style.stroke = "white";
          deleteBg.style.strokeWidth = "2";
          
          const deleteX = document.createElementNS(ns, "text");
          deleteX.setAttribute("x", textItem.x + 20);
          deleteX.setAttribute("y", textItem.y - textItem.fontSize);
          deleteX.setAttribute("text-anchor", "middle");
          deleteX.setAttribute("dominant-baseline", "middle");
          deleteX.style.fill = "white";
          deleteX.style.fontSize = "16px";
          deleteX.style.fontWeight = "bold";
          deleteX.style.pointerEvents = "none";
          deleteX.textContent = "√ó";
          
          deleteBtn.appendChild(deleteBg);
          deleteBtn.appendChild(deleteX);
          
          deleteBtn.addEventListener("click", (e) => {
           e.stopPropagation();
           e.preventDefault();
           deleteText(textItem.id);
          });
          
          let isDragging = false;
          let dragStartX, dragStartY;
          let textStartX, textStartY;
          
          textEl.addEventListener("mousedown", (e) => {
      if (textDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      textStartX = textItem.x;
      textStartY = textItem.y;
      textEl.style.cursor = "grabbing";
      
      showTextPanel(textItem.id);
      
      if (selectedTexts.has(textItem.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
          
          const moveHandler = (e) => {
      if (!isDragging || textDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      
      textItem.x = textStartX + dx;
      textItem.y = textStartY + dy;
      
      if (selectedTexts.has(textItem.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       const newX = initialPositions[nodeId].x + dx;
       const newY = initialPositions[nodeId].y + dy;
       savedPositions[nodeId] = { x: newX, y: newY };
      }
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      if (textId === textItem.id) return;
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      
      forgeTheTopology();
      };
          
          const upHandler = () => {
           if (isDragging) {
            isDragging = false;
            textEl.style.cursor = "move";
           }
          };
          
          document.addEventListener("mousemove", moveHandler);
          document.addEventListener("mouseup", upHandler);
          
          let touchStartX = 0, touchStartY = 0;
          let textTouchStartX = 0, textTouchStartY = 0;
          
          textEl.addEventListener("touchstart", (e) => {
           if (textDrawMode) return;
           if (e.touches.length !== 1) return;
           
           e.preventDefault();
           e.stopPropagation();
           const touch = e.touches[0];
           isDragging = true;
           touchStartX = touch.clientX;
           touchStartY = touch.clientY;
           textTouchStartX = textItem.x;
           textTouchStartY = textItem.y;
           
           showTextPanel(textItem.id);
          }, { passive: false });
          
          textEl.addEventListener("touchmove", (e) => {
           if (!isDragging || textDrawMode) return;
           if (e.touches.length !== 1) return;
           
           e.preventDefault();
           const touch = e.touches[0];
           const svgEl = svg;
           
           const pt1 = svgEl.createSVGPoint();
           pt1.x = touchStartX;
           pt1.y = touchStartY;
           const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
           
           const pt2 = svgEl.createSVGPoint();
           pt2.x = touch.clientX;
           pt2.y = touch.clientY;
           const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
           
           const dx = svgP2.x - svgP1.x;
           const dy = svgP2.y - svgP1.y;
           
           textItem.x = textTouchStartX + dx;
           textItem.y = textTouchStartY + dy;
           
           forgeTheTopology();
          }, { passive: false });
          
          textEl.addEventListener("touchend", () => {
           if (isDragging) {
            isDragging = false;
           }
          }, { passive: false });
          
          textEl.addEventListener("contextmenu", (e) => {
           e.preventDefault();
           e.stopPropagation();
           if (selectedTexts.has(textItem.id)) {
            selectedTexts.delete(textItem.id);
           } else {
            selectedTexts.add(textItem.id);
           }
           updateAllSelections();
          });
          
          let textLastTap = 0;
          g.addEventListener("touchend", (e) => {
           const now = Date.now();
           if (now - textLastTap < 300) {
            e.preventDefault();
            if (selectedTexts.has(textItem.id)) {
             selectedTexts.delete(textItem.id);
            } else {
             selectedTexts.add(textItem.id);
            }
            updateAllSelections();
            if (navigator.vibrate) navigator.vibrate(50);
            textLastTap = 0;
           } else {
            textLastTap = now;
           }
          }, { passive: false });
          
          if (textItem.groupId) {
            const groupIndicator = document.createElementNS(ns, "rect");
            groupIndicator.setAttribute("x", textItem.x - 54);
            groupIndicator.setAttribute("y", textItem.y - 24);
            groupIndicator.setAttribute("width", 108);
            groupIndicator.setAttribute("height", 48);
            groupIndicator.setAttribute("rx", "8");
            groupIndicator.style.fill = "none";
       groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
            groupIndicator.style.strokeWidth = "3";
            groupIndicator.style.strokeDasharray = "5,5";
            groupIndicator.style.pointerEvents = "none";
            g.insertBefore(groupIndicator, g.firstChild);
          }
          g.appendChild(deleteBtn);
          svg.appendChild(g);
         });
        }
        
        
        Object.keys(NODE_DATA).forEach(nodeId => {
         updatePingIndicator(nodeId);
        });
        
        forgeTheLegend();
        updateMinimap();
       }
      
       function showEditModal(title, currentValue, onSave) {
        const modal = document.getElementById("edit-modal");
        const input = document.getElementById("modal-input");
        const titleEl = document.getElementById("modal-title");
        const saveBtn = document.getElementById("modal-save");
        const cancelBtn = document.getElementById("modal-cancel");
        titleEl.textContent = title;
        input.value = currentValue;
        modal.classList.add("active");
        input.focus();
        input.select();
        const handleSave = () => {
         if (input.value.trim()) {
          onSave(input.value.trim());
         }
         modal.classList.remove("active");
         saveBtn.removeEventListener("click", handleSave);
         cancelBtn.removeEventListener("click", handleCancel);
         input.removeEventListener("keypress", handleEnter);
        };
        const handleCancel = () => {
         modal.classList.remove("active");
         saveBtn.removeEventListener("click", handleSave);
         cancelBtn.removeEventListener("click", handleCancel);
         input.removeEventListener("keypress", handleEnter);
        };
        const handleEnter = (e) => {
         if (e.key === "Enter") handleSave();
        };
        saveBtn.addEventListener("click", handleSave);
        cancelBtn.addEventListener("click", handleCancel);
        input.addEventListener("keypress", handleEnter);
        modal.addEventListener("click", function bgHandler(e) {
         if (e.target === modal) {
          handleCancel();
          modal.removeEventListener("click", bgHandler);
         }
        });
       }
      
       function challengeTheImmortal(message, onConfirm) {
        const modal = document.getElementById("confirm-modal");
        const messageEl = document.getElementById("confirm-message");
        const deleteBtn = document.getElementById("confirm-delete");
        const cancelBtn = document.getElementById("confirm-cancel");
        messageEl.textContent = message;
        modal.classList.add("active");
        const handleConfirm = () => {
         onConfirm();
         modal.classList.remove("active");
         deleteBtn.removeEventListener("click", handleConfirm);
         cancelBtn.removeEventListener("click", handleCancel);
        };
        const handleCancel = () => {
         modal.classList.remove("active");
         deleteBtn.removeEventListener("click", handleConfirm);
         cancelBtn.removeEventListener("click", handleCancel);
        };
        deleteBtn.addEventListener("click", handleConfirm);
        cancelBtn.addEventListener("click", handleCancel);
        modal.addEventListener("click", function bgHandler(e) {
         if (e.target === modal) {
          handleCancel();
          modal.removeEventListener("click", bgHandler);
         }
        });
       }
       const pageTitleEl = document.getElementById("page-title");
       if (pageTitleEl) {
        pageTitleEl.addEventListener("click", () => {
         showEditModal("Edit Title", PAGE_STATE.title || DEFAULT_PAGE_STATE.title,
          (newTitle) => {
           PAGE_STATE.title = newTitle;
           wieldThePower();
          }, );
        });
       }
      
       function editNodeName(id) {
        if (!NODE_DATA[id]) return;
        showEditModal("Edit Name", NODE_DATA[id].name, (newName) => {
         if (!NODE_DATA[id]) return;
         NODE_DATA[id].name = newName;
         const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`, );
         if (nodeGroup) {
          const label = nodeGroup.querySelector(".node-label");
          if (label) label.textContent = newName;
         }
         if (currentNodeId === id) {
          document.getElementById("node-name").textContent = newName;
         }
        });
       }
      
       function editNodeIp(id) {
        if (!NODE_DATA[id]) return;
        showEditModal("Edit IP/Subtitle", NODE_DATA[id].ip, (newIp) => {
         if (!NODE_DATA[id]) return;
         NODE_DATA[id].ip = newIp;
         const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`, );
         if (nodeGroup) {
          const sub = nodeGroup.querySelector(".node-sub");
          if (sub) sub.textContent = newIp;
         }
         if (currentNodeId === id) {
          document.getElementById("node-ip").textContent = newIp;
         }
        });
       }
      
       function claimTheImmortal(id) {
        if (!NODE_DATA[id]) return;
        currentNodeId = id;
        currentEdgeId = null;
        const data = NODE_DATA[id];
        document.querySelectorAll(".node-group").forEach((n) => {
         n.classList.toggle("active", n.dataset.nodeId === id);
        });
        document.querySelectorAll(".edge").forEach((e) => {
         const active = e.dataset.from === id || e.dataset.to === id;
         e.classList.toggle("active", active);
        });
        document.getElementById("node-panel").style.display = "block";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        const toolbar = document.getElementById("topology-toolbar");
        if (!topologyToolbarCollapsed) {
         toolbar.style.display = "flex";
        }
        updateTopologyToolbarVisibility();
        document.getElementById("node-name").textContent = data.name;
        document.getElementById("node-ip").textContent = data.ip;
        document.getElementById("node-mac").textContent = data.mac || "--";
        document.getElementById("node-rack").textContent = data.rackUnit || "--";
        document.getElementById("node-uheight").textContent = (data.uHeight || "1") + "U";
        document.getElementById("node-role").textContent = data.role;
      
        populateRackDropdown();
        const assignedRackSelect = document.getElementById("node-assigned-rack");
        if (assignedRackSelect) {
         assignedRackSelect.value = data.assignedRack || "";
        }
        
        const rackCapacitySelect = document.getElementById("node-rack-capacity");
        if (rackCapacitySelect) {
         rackCapacitySelect.value = data.rackCapacity || "42";
        }
        
        const isRack = data.isRack === true;
        const isAssignedToRack = !!data.assignedRack;
        const assignedRackRow = document.getElementById("assigned-rack-row");
        const rackCapacityRow = document.getElementById("rack-capacity-row");
        const uheightRow = document.getElementById("uheight-row");
        if (assignedRackRow) assignedRackRow.style.display = isRack ? "none" : "flex";
        if (rackCapacityRow) rackCapacityRow.style.display = isRack ? "flex" : "none";
        if (uheightRow) uheightRow.style.display = isAssignedToRack ? "flex" : "none";
        
        document.getElementById("node-name").onclick = () => editNodeName(id);
        document.getElementById("node-ip").onclick = () => editNodeIp(id);
        document.getElementById("node-mac").onclick = () => editNodeMac(id);
        document.getElementById("node-rack").onclick = () => editNodeRack(id);
        document.getElementById("node-uheight").onclick = () => editNodeUHeight(id);
        const currentSize = savedSizes[id] || getDefaultSize();
        document.getElementById("size-slider").value = currentSize;
        document.getElementById("size-value").textContent = currentSize;
        const styleEntry = savedStyles[id] || {};
        const resolvedStyles = resolveStylesEntry(styleEntry);
        const scopeKey = currentStyleScope || "all";
        const flatProps = ["circleColor", "circleBorder", "titleColor", "titleFont", "titleSize", "subColor", "subFont", "subSize", ];
        const isFlat = flatProps.some((p) => Object.prototype.hasOwnProperty.call(styleEntry, p), );
        const scopedStyles = isFlat ? styleEntry : styleEntry[scopeKey] || {};
        const circleColorInput = document.getElementById("circle-color");
        const titleColorInput = document.getElementById("title-color");
        const titleFontSelect = document.getElementById("title-font");
        const titleSizeInput = document.getElementById("title-size");
        const subColorInput = document.getElementById("sub-color");
        const subFontSelect = document.getElementById("sub-font");
        const subSizeInput = document.getElementById("sub-size");
        const shapeSelect = document.getElementById("shape-select");
        const scopeSelect = document.getElementById("style-scope");
circleColorInput.value = scopedStyles.circleColor || resolvedStyles.circleColor || PAGE_STATE.nodeFill || "#1e293b";
       const circleBorderInput = document.getElementById("circle-border");
       circleBorderInput.value = scopedStyles.circleBorder || resolvedStyles.circleBorder || PAGE_STATE.nodeStroke || "#475569";
        titleColorInput.value = scopedStyles.titleColor || resolvedStyles.titleColor || PAGE_STATE.textMain || "#e2e8f0";
        titleFontSelect.value = scopedStyles.titleFont || resolvedStyles.titleFont || "system-ui, sans-serif";
        titleSizeInput.value = scopedStyles.titleSize || resolvedStyles.titleSize || 18;
        subColorInput.value = scopedStyles.subColor || resolvedStyles.subColor || PAGE_STATE.textSoft || "#94a3b8";
        subFontSelect.value = scopedStyles.subFont || resolvedStyles.subFont || "system-ui, sans-serif";
        subSizeInput.value = scopedStyles.subSize || resolvedStyles.subSize || 13;
        shapeSelect.value = data.shape || "circle";
        const layerSelect = document.getElementById("node-layer");
        if (layerSelect) {
         layerSelect.value = data.layer || "physical";
        }
        scopeSelect.value = currentStyleScope || "all";
        document.getElementById("title-offset-y").value = scopedStyles.titleOffsetY || resolvedStyles.titleOffsetY || 0;
        document.getElementById("title-offset-x").value = scopedStyles.titleOffsetX || resolvedStyles.titleOffsetX || 0;
        document.getElementById("sub-offset-y").value = scopedStyles.subOffsetY || resolvedStyles.subOffsetY || 0;
        document.getElementById("sub-offset-x").value = scopedStyles.subOffsetX || resolvedStyles.subOffsetX || 0;
      
      const pingOffsetXInput = document.getElementById("ping-offset-x");
      const pingOffsetYInput = document.getElementById("ping-offset-y");
      
      if (pingOffsetXInput && pingOffsetYInput) {
      pingOffsetXInput.value =
       (scopedStyles.pingOffsetX !== undefined
         ? scopedStyles.pingOffsetX
         : (resolvedStyles.pingOffsetX !== undefined
             ? resolvedStyles.pingOffsetX
             : 0));
      
      pingOffsetYInput.value =
       (scopedStyles.pingOffsetY !== undefined
         ? scopedStyles.pingOffsetY
         : (resolvedStyles.pingOffsetY !== undefined
             ? resolvedStyles.pingOffsetY
             : 0));
      }
        const tagEl = document.getElementById("node-tags");
        tagEl.innerHTML = "";
        data.tags.forEach((tag, i) => {
         const b = document.createElement("span");
         b.className = "badge";
         const isIconTag = typeof tag === 'object' && tag.type === 'icon';
         if (!isIconTag && typeof tag === 'string' && tag.toLowerCase().includes("wg")) b.classList.add("wg");
         b.style.cursor = "pointer";
         b.style.position = "relative";
         const tagContent = document.createElement("span");
         if (isIconTag) {
          b.classList.add("icon-badge");
          IconLibrary.getIcon(tag.library, tag.name).then(svgText => {
           if (svgText) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(svgText, 'image/svg+xml');
            const svgEl = doc.querySelector('svg');
            if (svgEl) {
             svgEl.setAttribute('width', '16');
             svgEl.setAttribute('height', '16');
             tagContent.innerHTML = '';
             tagContent.appendChild(svgEl);
             const nameSpan = document.createElement('span');
             nameSpan.textContent = tag.name;
             nameSpan.style.marginLeft = '4px';
             tagContent.appendChild(nameSpan);
            }
           }
          });
         } else {
          tagContent.textContent = tag;
          tagContent.addEventListener("click", (e) => {
           e.stopPropagation();
           showEditModal("Edit Tag", tag, (newTag) => {
            if (newTag) {
             data.tags[i] = newTag;
             claimTheImmortal(id);
            }
           });
          });
         }
         const deleteTag = document.createElement("span");
         deleteTag.textContent = " ‚úï";
         deleteTag.style.opacity = "0.6";
         deleteTag.style.marginLeft = "4px";
         deleteTag.style.fontSize = "10px";
         deleteTag.addEventListener("click", (e) => {
          e.stopPropagation();
          data.tags.splice(i, 1);
          claimTheImmortal(id);
         });
         b.append(tagContent, deleteTag);
         tagEl.append(b);
        });
        const addTagBtn = document.createElement("span");
        addTagBtn.className = "badge";
        addTagBtn.style.cursor = "pointer";
        addTagBtn.style.opacity = "0.6";
        addTagBtn.style.borderStyle = "dashed";
        addTagBtn.textContent = "+ Add";
        addTagBtn.addEventListener("click", () => {
         showEditModal("Add Tag(s) : comma separated", "",
          (newTagStr) => {
           if (newTagStr) {
            const newTags = newTagStr.split(",").map((t) => t.trim()).filter((t) => t);
            newTags.forEach((t) => data.tags.push(t));
            claimTheImmortal(id);
           }
          }, );
        });
        tagEl.append(addTagBtn);
        const notesEl = document.getElementById("node-notes");
        notesEl.innerHTML = "";
        data.notes.forEach((note, i) => {
         const li = document.createElement("li");
         const noteText = document.createElement("span");
         noteText.textContent = note;
         noteText.style.flex = "1";
         const deleteBtn = document.createElement("span");
         deleteBtn.className = "delete-note";
         deleteBtn.textContent = "‚úï";
         deleteBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          challengeTheImmortal("Are you sure you want to delete this note?",
           () => {
            data.notes.splice(i, 1);
            claimTheImmortal(id);
           }, );
         });
         li.append(noteText, deleteBtn);
         noteText.addEventListener("dblclick", () => {
          noteText.classList.add("editing");
          noteText.contentEditable = true;
          noteText.focus();
         });
         noteText.addEventListener("blur", () => {
          noteText.classList.remove("editing");
          noteText.contentEditable = false;
          data.notes[i] = noteText.textContent;
         });
         notesEl.append(li);
        });
        const addLineSelect = document.getElementById("add-line-select");
      addLineSelect.innerHTML = "";
      const currentRack = data.assignedRack || "";
      Object.entries(NODE_DATA).forEach(([nodeId, node]) => {
      if (nodeId !== id) {
      const nodeRack = node.assignedRack || "";
      if (currentRack === nodeRack) {
      const opt = document.createElement("option");
      opt.value = nodeId;
      opt.textContent = node.name;
      addLineSelect.appendChild(opt);
      }
      }
      });
        
        const pingEnabled = data.ping && data.ping.enabled;
        document.getElementById('node-pingable').checked = pingEnabled;
        document.getElementById('node-ping-options').style.display = pingEnabled ? 'block' : 'none';
        
        if (data.ping) {
         document.getElementById('node-ping-protocol').value = data.ping.protocol || 'http';
         document.getElementById('node-custom-url').value = data.ping.customUrl || '';
         document.getElementById('node-ping-timeout').value = data.ping.timeout || 3000;
         document.getElementById('node-custom-url-container').style.display = 
          data.ping.protocol === 'custom' ? 'block' : 'none';
         
         updatePingStatusDisplay(id);
        }
       }
      
       function updatePingStatusDisplay(nodeId) {
        const data = NODE_DATA[nodeId];
        if (!data || !data.ping) return;
        
        const statusEl = document.getElementById('node-ping-status');
        const lastCheckEl = document.getElementById('node-ping-last-check');
        
        const statusColors = {
         online: 'var(--accent)',
         offline: 'var(--danger)',
         checking: '#f59e0b',
         unknown: 'var(--text-soft)'
        };
        
        const statusTexts = {
         online: '‚óè Online',
         offline: '‚óè Offline',
         checking: '‚óè Checking...',
         unknown: '‚óè Unknown'
        };
        
        statusEl.textContent = statusTexts[data.ping.status] || statusTexts.unknown;
        statusEl.style.color = statusColors[data.ping.status] || statusColors.unknown;
        
        if (data.ping.lastCheck) {
         const checkTime = new Date(data.ping.lastCheck);
         lastCheckEl.textContent = `Last checked: ${checkTime.toLocaleTimeString()}`;
        } else {
         lastCheckEl.textContent = 'Never checked';
        }
       }
      
       function selectTheConnection(id) {
        currentEdgeId = id;
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "block";
        document.getElementById("text-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.display = "none";
        document.querySelectorAll(".node-group").forEach((n) => n.classList.remove("active"));
        document.querySelectorAll(".edge").forEach((e) => {
         e.classList.toggle("active", e.dataset.edgeId === id);
        });
        const edge = EDGE_DATA.list.find((e) => e.id === id);
        if (!edge) return;
        const directionSymbols = {
         none: "‚áÑ",
         forward: "‚Üí",
         backward: "‚Üê",
         both: "‚Üî",
        };
        const dirSymbol = directionSymbols[edge.direction] || "‚áÑ";
        let titleText = "Custom line";
        if (edge.from || edge.to) {
         const fromName = edge.from ? NODE_DATA[edge.from]?.name || edge.from : "";
         const toName = edge.to ? NODE_DATA[edge.to]?.name || edge.to : "";
         titleText = `${fromName || "?"} ${dirSymbol} ${toName || "?"}`;
        }
        document.getElementById("edge-title").textContent = titleText;
        const widthInput = document.getElementById("edge-width");
        const colorInput = document.getElementById("edge-color");
        const directionSelect = document.getElementById("edge-direction");
        const lineStyleSelect = document.getElementById("edge-line-style");
        widthInput.value = edge.width;
        colorInput.value = edge.color;
        directionSelect.value = edge.direction || "none";
        lineStyleSelect.value = edge.lineStyle || "solid";
        
        const fromPortInput = document.getElementById("edge-from-port");
        const toPortInput = document.getElementById("edge-to-port");
        const portFieldsFrom = document.getElementById("edge-port-fields");
        const portFieldsTo = document.getElementById("edge-port-fields-to");
        
        if (edge.type === "custom") {
         if (portFieldsFrom) portFieldsFrom.style.display = "none";
         if (portFieldsTo) portFieldsTo.style.display = "none";
        } else {
         if (portFieldsFrom) portFieldsFrom.style.display = "flex";
         if (portFieldsTo) portFieldsTo.style.display = "flex";
         if (fromPortInput) {
          fromPortInput.value = edge.fromPort || "";
          fromPortInput.onchange = () => updateEdgePortLabels(id);
         }
         if (toPortInput) {
          toPortInput.value = edge.toPort || "";
          toPortInput.onchange = () => updateEdgePortLabels(id);
         }
        }
        
        const list = document.getElementById("edge-notes");
        list.innerHTML = "";
        edge.notes.forEach((note, i) => {
         const li = document.createElement("li");
         const txt = document.createElement("span");
         txt.textContent = note;
         txt.style.flex = "1";
         const del = document.createElement("span");
         del.className = "delete-note";
         del.textContent = "‚úï";
         del.addEventListener("click", (e) => {
          e.stopPropagation();
          challengeTheImmortal("Delete this line note?", () => {
           edge.notes.splice(i, 1);
           saveEdgeData();
           selectTheConnection(id);
          });
         });
         txt.addEventListener("dblclick", () => {
          txt.classList.add("editing");
          txt.contentEditable = true;
          txt.focus();
         });
         txt.addEventListener("blur", () => {
          txt.classList.remove("editing");
          txt.contentEditable = false;
          edge.notes[i] = txt.textContent;
          saveEdgeData();
         });
         li.append(txt, del);
         list.appendChild(li);
       });
       
       if (edge.type === "custom" && Array.isArray(edge.points)) {
        forgeTheTopology();
       }
      }
       window.addEventListener("resize", () => {
        forgeTheTopology();
        if (currentEdgeId) {
         selectTheConnection(currentEdgeId);
        } else if (currentNodeId && NODE_DATA[currentNodeId]) {
         claimTheImmortal(currentNodeId);
        } else {
         const availableNodes = Object.keys(NODE_DATA);
         if (availableNodes.length > 0) {
          claimTheImmortal(availableNodes[0]);
         }
        }
       });
       (function initZoomPan() {
        const viewport = document.getElementById("canvas-viewport");
        const svg = document.getElementById("map");
        const hint = document.getElementById("canvas-hint");
        setTimeout(() => {
         hint.classList.add("visible");
         setTimeout(() => hint.classList.remove("visible"), 4000);
        }, 1000);
        viewport.addEventListener("wheel",
         (e) => {
          e.preventDefault();
          const rect = viewport.getBoundingClientRect();
          const mouseX = (e.clientX - rect.left) / rect.width;
          const mouseY = (e.clientY - rect.top) / rect.height;
          const delta = e.deltaY > 0 ? 0.9 : 1.1;
          zoomTo(canvasState.zoom * delta, mouseX, mouseY);
         }, {
          passive: false
         }, );
        let initialPinchDistance = 0;
        let initialPinchZoom = 1;
        let pinchCenter = {
         x: 0.5,
         y: 0.5
        };
        viewport.addEventListener("touchstart",
         (e) => {
          if (e.touches.length === 2) {
           e.preventDefault();
           const touch1 = e.touches[0];
           const touch2 = e.touches[1];
           initialPinchDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY, );
           initialPinchZoom = canvasState.zoom;
           const rect = viewport.getBoundingClientRect();
           const centerX = (touch1.clientX + touch2.clientX) / 2;
           const centerY = (touch1.clientY + touch2.clientY) / 2;
           pinchCenter.x = (centerX - rect.left) / rect.width;
           pinchCenter.y = (centerY - rect.top) / rect.height;
          }
         }, {
          passive: false
         }, );
        viewport.addEventListener("touchmove",
         (e) => {
          if (e.touches.length === 2) {
           e.preventDefault();
           const touch1 = e.touches[0];
           const touch2 = e.touches[1];
           const currentDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY, );
           if (initialPinchDistance > 0) {
            const scale = currentDistance / initialPinchDistance;
            const newZoom = initialPinchZoom * scale;
            zoomTo(newZoom, pinchCenter.x, pinchCenter.y);
           }
          }
         }, {
          passive: false
         }, );
        let panStartViewX = 0;
        let panStartViewY = 0;
        
        let lastEmptyTapTime = 0;
        let emptyTapTimeout = null;
        let emptyTapMoved = false;
        let emptyTapStartX = 0;
        let emptyTapStartY = 0;
        
        viewport.addEventListener("touchend", (e) => {
          if (currentView.mode !== "rack") return;
          
          if (e.changedTouches.length !== 1) return;
          
      const isNodeOrEdge = e.target.closest(".node-group") || e.target.closest(".edge-group");
         if (isNodeOrEdge) return;
          
          if (emptyTapMoved) {
            emptyTapMoved = false;
            return;
          }
          
          const currentTime = new Date().getTime();
          const tapGap = currentTime - lastEmptyTapTime;
          
          if (tapGap < 300 && tapGap > 0) {
            e.preventDefault();
            
            exitRack();
            
            if (navigator.vibrate) {
              navigator.vibrate(50);
            }
            
            lastEmptyTapTime = 0;
            if (emptyTapTimeout) {
              clearTimeout(emptyTapTimeout);
              emptyTapTimeout = null;
            }
          } else {
            lastEmptyTapTime = currentTime;
            
            if (emptyTapTimeout) clearTimeout(emptyTapTimeout);
            emptyTapTimeout = setTimeout(() => {
              lastEmptyTapTime = 0;
            }, 300);
          }
        }, { passive: false });
        
        viewport.addEventListener("mousedown", (e) => {
         if (e.target.closest(".draw-toolbar") || e.target.closest(".topology-toolbar") || e.target.closest(".legend-container")) {
          return;
         }
         if (freeDrawMode || rectDrawMode) {
          return;
         }
      const isEmptySpace = e.target === svg || e.target === viewport || e.target.tagName === "svg";
      const isEdgeElement = e.target.closest('.edge') || e.target.classList.contains('edge-edit-point');
      const isTextElement = e.target.closest('.text-group') || e.target.closest('.text-element');
      const isRectElement = e.target.closest('.rect-group');
      if (!isEdgeElement && !isTextElement && !isRectElement && currentEdgeId) {
      currentEdgeId = null;
      forgeTheTopology();
      }
      if (!isRectElement && currentRectId) {
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      }
         if (isEmptySpace || e.button === 2 || e.button === 1) {
          e.preventDefault();
          canvasState.isPanning = true;
          canvasState.panStartX = e.clientX;
          canvasState.panStartY = e.clientY;
          panStartViewX = canvasState.panX;
          panStartViewY = canvasState.panY;
          viewport.classList.add("panning");
         }
        });
        viewport.addEventListener("touchstart",
         (e) => {
          if (e.target.closest(".draw-toolbar") || e.target.closest(".topology-toolbar") || e.target.closest(".legend-container")) {
           return;
          }
          if (freeDrawMode || rectDrawMode) {
           return;
          }
      const isEmptySpace = e.target === svg || e.target === viewport || e.target.tagName === "svg";
      const isEdgeElement = e.target.closest('.edge') || e.target.classList.contains('edge-edit-point');
      const isTextElement = e.target.closest('.text-group') || e.target.closest('.text-element');
      const isRectElement = e.target.closest('.rect-group');
      if (!isEdgeElement && !isTextElement && !isRectElement && currentEdgeId) {
      currentEdgeId = null;
      forgeTheTopology();
      }
      if (!isRectElement && currentRectId) {
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      }
          if (isEmptySpace && e.touches.length === 1) {
           e.preventDefault();
           emptyTapMoved = false;
           emptyTapStartX = e.touches[0].clientX;
           emptyTapStartY = e.touches[0].clientY;
           canvasState.isPanning = true;
           canvasState.panStartX = e.touches[0].clientX;
           canvasState.panStartY = e.touches[0].clientY;
           panStartViewX = canvasState.panX;
           panStartViewY = canvasState.panY;
           viewport.classList.add("panning");
          }
         }, {
          passive: false
         }, );
        document.addEventListener("mousemove", (e) => {
         if (!canvasState.isPanning) return;
         const dx = e.clientX - canvasState.panStartX;
         const dy = e.clientY - canvasState.panStartY;
         const rect = viewport.getBoundingClientRect();
         const viewWidth = CANVAS_WIDTH / canvasState.zoom;
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         const canvasDx = (dx / rect.width) * viewWidth;
         const canvasDy = (dy / rect.height) * viewHeight;
         canvasState.panX = panStartViewX - canvasDx;
         canvasState.panY = panStartViewY - canvasDy;
         constrainPan();
         updateViewBox();
        });
       document.addEventListener("touchmove", (e) => {
        if (!canvasState.isPanning || !e.touches[0]) return;
        const moveDx = Math.abs(e.touches[0].clientX - emptyTapStartX);
        const moveDy = Math.abs(e.touches[0].clientY - emptyTapStartY);
        if (moveDx > 15 || moveDy > 15) {
         emptyTapMoved = true;
        }
        const dx = e.touches[0].clientX - canvasState.panStartX;
         const dy = e.touches[0].clientY - canvasState.panStartY;
         const rect = viewport.getBoundingClientRect();
         const viewWidth = CANVAS_WIDTH / canvasState.zoom;
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         const canvasDx = (dx / rect.width) * viewWidth;
         const canvasDy = (dy / rect.height) * viewHeight;
         canvasState.panX = panStartViewX - canvasDx;
         canvasState.panY = panStartViewY - canvasDy;
         constrainPan();
         updateViewBox();
        });
        document.addEventListener("mouseup", () => {
         if (canvasState.isPanning) {
          canvasState.isPanning = false;
          viewport.classList.remove("panning");
         }
        });
        document.addEventListener("touchend", () => {
         if (canvasState.isPanning) {
          canvasState.isPanning = false;
          viewport.classList.remove("panning");
         }
        });
        document.addEventListener("keydown", (e) => {
         const isEditing = document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "TEXTAREA" || document.activeElement.isContentEditable;
         if (e.code === "Space" && !e.repeat && !isEditing) {
          e.preventDefault();
          canvasState.spacePressed = true;
          viewport.style.cursor = "grab";
         }
        });
        document.addEventListener("keyup", (e) => {
         if (e.code === "Space") {
          canvasState.spacePressed = false;
          viewport.style.cursor = "";
         }
        });
        document.getElementById("zoom-in-btn").addEventListener("click", () => {
         zoomTo(canvasState.zoom * 1.25, 0.5, 0.5);
        });
        document.getElementById("zoom-out-btn").addEventListener("click", () => {
         zoomTo(canvasState.zoom * 0.8, 0.5, 0.5);
        });
        document.getElementById("zoom-fit-btn").addEventListener("click", fitToContent);
        document.getElementById("zoom-reset-btn").addEventListener("click", resetView);
        const minimapContainer = document.getElementById("minimap-container");
        const minimapSvg = document.getElementById("minimap");
        let minimapDragging = false;
        minimapContainer.addEventListener("mousedown", (e) => {
         e.preventDefault();
         minimapDragging = true;
         updatePanFromMinimap(e);
        });
        minimapContainer.addEventListener("touchstart",
         (e) => {
          e.preventDefault();
          minimapDragging = true;
          updatePanFromMinimapTouch(e);
         }, {
          passive: false
         }, );
        document.addEventListener("mousemove", (e) => {
         if (minimapDragging) {
          updatePanFromMinimap(e);
         }
        });
        document.addEventListener("touchmove", (e) => {
         if (minimapDragging && e.touches[0]) {
          updatePanFromMinimapTouch(e);
         }
        });
        document.addEventListener("mouseup", () => {
         minimapDragging = false;
        });
        document.addEventListener("touchend", () => {
         minimapDragging = false;
        });
      
        function updatePanFromMinimap(e) {
         const rect = minimapContainer.getBoundingClientRect();
         const x = (e.clientX - rect.left) / rect.width;
         const y = (e.clientY - rect.top) / rect.height;
         const viewWidth = CANVAS_WIDTH / canvasState.zoom;
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         canvasState.panX = x * CANVAS_WIDTH - viewWidth / 2;
         canvasState.panY = y * CANVAS_HEIGHT - viewHeight / 2;
         constrainPan();
         updateViewBox();
        }
      
        function updatePanFromMinimapTouch(e) {
         const rect = minimapContainer.getBoundingClientRect();
         const touch = e.touches[0];
         const x = (touch.clientX - rect.left) / rect.width;
         const y = (touch.clientY - rect.top) / rect.height;
         const viewWidth = CANVAS_WIDTH / canvasState.zoom;
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         canvasState.panX = x * CANVAS_WIDTH - viewWidth / 2;
         canvasState.panY = y * CANVAS_HEIGHT - viewHeight / 2;
         constrainPan();
         updateViewBox();
        }
        document.addEventListener("keydown", (e) => {
         if (document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "TEXTAREA") return;
         if (
          (e.key === "+" || e.key === "=") && (e.ctrlKey || e.metaKey)) {
          e.preventDefault();
          zoomTo(canvasState.zoom * 1.25, 0.5, 0.5);
         } else if (e.key === "-" && (e.ctrlKey || e.metaKey)) {
          e.preventDefault();
          zoomTo(canvasState.zoom * 0.8, 0.5, 0.5);
         } else if (e.key === "0" && (e.ctrlKey || e.metaKey)) {
          e.preventDefault();
          resetView();
         }
        });
        setTimeout(() => {
         fitToContent();
        }, 100);
       })();
       const sizeSlider = document.getElementById("size-slider");
       const sizeValue = document.getElementById("size-value");
       const resetSizeBtn = document.getElementById("reset-size");
       sizeSlider.addEventListener("input", () => {
        const newSize = parseInt(sizeSlider.value, 10);
        sizeValue.textContent = newSize;
        savedSizes[currentNodeId] = newSize;
        const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
        if (nodeGroup) {
         const oldShape = nodeGroup.querySelector(".node-circle");
         if (oldShape) oldShape.remove();
         const newShape = createNodeShape(currentNodeId, newSize);
         nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
         const styles = resolveStylesForNode(currentNodeId);
         if (styles.circleColor) newShape.style.fill = styles.circleColor;
      if (styles.circleBorder) newShape.style.stroke = styles.circleBorder;
         const label = nodeGroup.querySelector(".node-label");
         const sub = nodeGroup.querySelector(".node-sub");
         if (label) {
          label.setAttribute("y", -newSize * 0.28);
          const labelSize = styles.titleSize || newSize * 0.33;
          label.style.fontSize = labelSize + "px";
         }
         if (sub) {
          sub.setAttribute("y", newSize * 0.4);
          const subSize = styles.subSize || newSize * 0.24;
          sub.style.fontSize = subSize + "px";
         }
       updatePingIndicator(currentNodeId);
        }
       });
       resetSizeBtn.addEventListener("click", () => {
        delete savedSizes[currentNodeId];
        const defaultSize = getDefaultSize();
        sizeSlider.value = defaultSize;
        sizeValue.textContent = defaultSize;
        const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
        if (nodeGroup) {
         const oldShape = nodeGroup.querySelector(".node-circle");
         if (oldShape) oldShape.remove();
         const shapeType = (NODE_DATA[currentNodeId] && NODE_DATA[currentNodeId].shape) || "circle";
         const newShape = createNodeShape(currentNodeId, defaultSize);
         nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
         const styles = resolveStylesForNode(currentNodeId);
         if (styles.circleColor) newShape.style.fill = styles.circleColor;
      if (styles.circleBorder) newShape.style.stroke = styles.circleBorder;
         const label = nodeGroup.querySelector(".node-label");
         const sub = nodeGroup.querySelector(".node-sub");
         if (label) {
          label.setAttribute("y", -defaultSize * 0.28);
          const labelSize = styles.titleSize || defaultSize * 0.33;
          label.style.fontSize = labelSize + "px";
         }
         if (sub) {
          sub.setAttribute("y", defaultSize * 0.4);
          const subSize = styles.subSize || defaultSize * 0.24;
          sub.style.fontSize = subSize + "px";
         }
          updatePingIndicator(currentNodeId);
      
        }
       });
       const applyStyle = (property, value) => {
        const styleEntry = ensureStyleEntry(currentNodeId);
        const scopeKey = currentStyleScope || "all";
        if (!styleEntry[scopeKey]) styleEntry[scopeKey] = {};
        styleEntry[scopeKey][property] = value;
        const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
        if (!nodeGroup) return;
        const shapeEl = nodeGroup.querySelector(".node-circle");
        const label = nodeGroup.querySelector(".node-label");
        const sub = nodeGroup.querySelector(".node-sub");
        if (property === "circleColor" && shapeEl) shapeEl.style.fill = value;
      else if (property === "circleBorder" && shapeEl) shapeEl.style.stroke = value;
        else if (property === "titleColor" && label) label.style.fill = value;
        else if (property === "titleFont" && label) label.style.fontFamily = value;
        else if (property === "titleSize" && label) label.style.fontSize = value + "px";
        else if (property === "subColor" && sub) sub.style.fill = value;
        else if (property === "subFont" && sub) sub.style.fontFamily = value;
        else if (property === "subSize" && sub) sub.style.fontSize = value + "px";
       };
       document.getElementById("circle-color").addEventListener("input", (e) => applyStyle("circleColor", e.target.value), );
      document.getElementById("circle-border").addEventListener("input", (e) => applyStyle("circleBorder", e.target.value), );
       document.getElementById("title-color").addEventListener("input", (e) => applyStyle("titleColor", e.target.value), );
       document.getElementById("title-font").addEventListener("change", (e) => applyStyle("titleFont", e.target.value), );
       document.getElementById("title-size").addEventListener("input", (e) => applyStyle("titleSize", parseInt(e.target.value, 10)), );
       document.getElementById("sub-color").addEventListener("input", (e) => applyStyle("subColor", e.target.value), );
       document.getElementById("sub-font").addEventListener("change", (e) => applyStyle("subFont", e.target.value), );
       document.getElementById("sub-size").addEventListener("input", (e) => applyStyle("subSize", parseInt(e.target.value, 10)), );
       document.getElementById("title-offset-y").addEventListener("input", (e) => {
        applyStyle("titleOffsetY", parseInt(e.target.value, 10) || 0);
        forgeTheTopology();
        if (currentNodeId) claimTheImmortal(currentNodeId);
       });
       document.getElementById("title-offset-x").addEventListener("input", (e) => {
        applyStyle("titleOffsetX", parseInt(e.target.value, 10) || 0);
        forgeTheTopology();
        if (currentNodeId) claimTheImmortal(currentNodeId);
       });
       document.getElementById("sub-offset-y").addEventListener("input", (e) => {
        applyStyle("subOffsetY", parseInt(e.target.value, 10) || 0);
        forgeTheTopology();
        if (currentNodeId) claimTheImmortal(currentNodeId);
       });
       document.getElementById("sub-offset-x").addEventListener("input", (e) => {
        applyStyle("subOffsetX", parseInt(e.target.value, 10) || 0);
        forgeTheTopology();
        if (currentNodeId) claimTheImmortal(currentNodeId);
       });
      document.getElementById("ping-offset-x").addEventListener("input", (e) => {
      applyStyle("pingOffsetX", parseInt(e.target.value, 10) || 0);
      updatePingIndicator(currentNodeId);
      if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      
      document.getElementById("ping-offset-y").addEventListener("input", (e) => {
      applyStyle("pingOffsetY", parseInt(e.target.value, 10) || 0);
      updatePingIndicator(currentNodeId);
      if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      
       document.getElementById("reset-styles").addEventListener("click", () => {
        delete savedStyles[currentNodeId];
        forgeTheTopology();
        claimTheImmortal(currentNodeId);
       });
       document.getElementById("style-scope").addEventListener("change", (e) => {
        currentStyleScope = e.target.value || "all";
        claimTheImmortal(currentNodeId);
       });
       document.getElementById("shape-select").addEventListener("change", (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId]) return;
        const shape = e.target.value || "circle";
        NODE_DATA[currentNodeId].shape = shape;
        const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
        if (!nodeGroup) return;
        const oldShape = nodeGroup.querySelector(".node-circle");
        if (oldShape) oldShape.remove();
        const size = savedSizes[currentNodeId] || getDefaultSize();
        const newShape = createNodeShape(currentNodeId, size);
        nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
       });
       const addNoteBtn = document.getElementById("add-note-btn");
       const noteInput = document.getElementById("new-note-input");
       addNoteBtn.addEventListener("click", () => {
        const newNote = noteInput.value.trim();
        if (newNote && currentNodeId && NODE_DATA[currentNodeId]) {
         NODE_DATA[currentNodeId].notes.push(newNote);
         claimTheImmortal(currentNodeId);
         noteInput.value = "";
        }
       });
       noteInput.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
         addNoteBtn.click();
        }
       });
       
       document.getElementById('node-pingable').addEventListener('change', (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId]) return;
        if (!NODE_DATA[currentNodeId].ping) {
         NODE_DATA[currentNodeId].ping = {
          enabled: false,
          protocol: 'http',
          customUrl: '',
          timeout: 3000,
          status: 'unknown',
          lastCheck: null
         };
        }
        NODE_DATA[currentNodeId].ping.enabled = e.target.checked;
        document.getElementById('node-ping-options').style.display = e.target.checked ? 'block' : 'none';
        forgeTheTopology();
       });
       
       document.getElementById('node-ping-protocol').addEventListener('change', (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId].ping) return;
        NODE_DATA[currentNodeId].ping.protocol = e.target.value;
        document.getElementById('node-custom-url-container').style.display = 
         e.target.value === 'custom' ? 'block' : 'none';
       });
       
       document.getElementById('node-custom-url').addEventListener('change', (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId].ping) return;
        NODE_DATA[currentNodeId].ping.customUrl = e.target.value.trim();
       });
       
       document.getElementById('node-ping-timeout').addEventListener('change', (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId].ping) return;
        NODE_DATA[currentNodeId].ping.timeout = parseInt(e.target.value) || 3000;
       });
       
       document.getElementById('check-ping-now').addEventListener('click', () => {
        if (!currentNodeId) return;
        checkNodeStatus(currentNodeId);
       });
       
       document.getElementById("edge-width").addEventListener("input", () => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        const v = parseInt(document.getElementById("edge-width").value, 10);
        if (Number.isNaN(v) || v <= 0) return;
        edge.width = v;
        saveEdgeData();
        const el = document.querySelector(`.edge[data-edge-id="${currentEdgeId}"]`, );
        if (el) el.style.strokeWidth = v;
       });
       document.getElementById("edge-color").addEventListener("input", () => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        const color = document.getElementById("edge-color").value;
        edge.color = color;
        saveEdgeData();
        const el = document.querySelector(`.edge[data-edge-id="${currentEdgeId}"]`, );
        if (el) el.style.stroke = color;
        forgeTheLegend();
       });
       document.getElementById("edge-direction").addEventListener("change", () => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        edge.direction = document.getElementById("edge-direction").value;
        saveEdgeData();
        forgeTheTopology();
        selectTheConnection(currentEdgeId);
       });
       document.getElementById("edge-line-style").addEventListener("change", () => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        edge.lineStyle = document.getElementById("edge-line-style").value;
        saveEdgeData();
        forgeTheTopology();
        selectTheConnection(currentEdgeId);
       });
       const addEdgeNoteBtn = document.getElementById("add-edge-note");
       const newEdgeNoteInput = document.getElementById("new-edge-note");
       addEdgeNoteBtn.addEventListener("click", () => {
        const txt = newEdgeNoteInput.value.trim();
        if (!txt || !currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        edge.notes.push(txt);
        saveEdgeData();
        newEdgeNoteInput.value = "";
        selectTheConnection(currentEdgeId);
       });
       newEdgeNoteInput.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
         addEdgeNoteBtn.click();
        }
       });
      function selectTheRect(id) {
      currentRectId = id;
      document.getElementById("node-panel").style.display = "none";
      document.getElementById("edge-panel").style.display = "none";
      document.getElementById("text-panel").style.display = "none";
      document.getElementById("rect-panel").style.display = "block";
      document.getElementById("topology-toolbar").style.display = "none";
      
      const rect = RECT_DATA.list.find(r => r.id === id);
      if (!rect) return;
      
      document.getElementById("rect-title").textContent = "";
      document.getElementById("rect-color").value = rect.color || "#f97316";
      document.getElementById("rect-border-color").value = rect.borderColor || rect.color || "#f97316";
      document.getElementById("rect-border-width").value = rect.borderWidth !== undefined ? rect.borderWidth : 2;
      document.getElementById("rect-style-select").value = rect.style || "filled";
      document.getElementById("rect-fill-row").style.display = (rect.style === "outlined") ? "none" : "flex";
      
      const list = document.getElementById("rect-notes");
      list.innerHTML = "";
      (rect.notes || []).forEach((note, i) => {
      const li = document.createElement("li");
      const txt = document.createElement("span");
      txt.textContent = note;
      txt.style.flex = "1";
      const del = document.createElement("span");
      del.className = "delete-note";
      del.textContent = "‚úï";
      del.addEventListener("click", (e) => {
      e.stopPropagation();
      challengeTheImmortal("Delete this note?", () => {
        rect.notes.splice(i, 1);
        selectTheRect(id);
      });
      });
      li.appendChild(txt);
      li.appendChild(del);
      list.appendChild(li);
      });
      
      forgeTheTopology();
      }
      
      document.getElementById("rect-color").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      rect.color = document.getElementById("rect-color").value;
      forgeTheTopology();
      });
      
      document.getElementById("rect-border-color").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      rect.borderColor = document.getElementById("rect-border-color").value;
      forgeTheTopology();
      });
      
      document.getElementById("rect-border-width").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      rect.borderWidth = parseInt(document.getElementById("rect-border-width").value) || 2;
      forgeTheTopology();
      });
      
      document.getElementById("rect-style-select").addEventListener("change", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      rect.style = document.getElementById("rect-style-select").value;
      forgeTheTopology();
      selectTheRect(currentRectId);
      });
      
      document.getElementById("add-rect-note").addEventListener("click", () => {
      const input = document.getElementById("new-rect-note");
      const txt = input.value.trim();
      if (!txt || !currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      if (!rect.notes) rect.notes = [];
      rect.notes.push(txt);
      input.value = "";
      selectTheRect(currentRectId);
      });
      
      document.getElementById("new-rect-note").addEventListener("keypress", (e) => {
      if (e.key === "Enter") {
      document.getElementById("add-rect-note").click();
      }
      });
      
      document.getElementById("delete-rect").addEventListener("click", () => {
      if (!currentRectId) return;
      challengeTheImmortal("Delete this box?", () => {
      RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== currentRectId);
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      });
      });
       document.getElementById("delete-edge").addEventListener("click", () => {
        if (!currentEdgeId) return;
        challengeTheImmortal("Are you sure you want to delete this line?",
         () => {
          EDGE_DATA.list = EDGE_DATA.list.filter(
           (e) => e.id !== currentEdgeId, );
          saveEdgeData();
          currentEdgeId = null;
          forgeTheTopology();
          const availableNodes = Object.keys(NODE_DATA);
          if (availableNodes.length > 0) {
           claimTheImmortal(availableNodes[0]);
          } else {
           document.getElementById("node-panel").style.display = "none";
           document.getElementById("edge-panel").style.display = "none";
           document.getElementById("topology-toolbar", ).style.display = "none";
          }
         }, );
       });
       document.getElementById("add-line-btn").addEventListener("click", () => {
        if (!currentNodeId) return;
        const select = document.getElementById("add-line-select");
        const directionSelect = document.getElementById("add-line-direction");
        const colorInput = document.getElementById("add-line-color");
        const targetId = select.value;
        if (!targetId || targetId === currentNodeId) return;
        const direction = directionSelect.value || "none";
        const lineColor = colorInput.value || "#475569";
        const newId = `${currentNodeId}-${targetId}-${Date.now()}`;
        const newEdge = {
         id: newId,
         from: currentNodeId,
         to: targetId,
         width: 4,
         color: lineColor,
         direction: direction,
         type: "main",
         notes: [],
         fromPort: "",
         toPort: "",
        };
        EDGE_DATA.list.push(newEdge);
        saveEdgeData();
        forgeTheTopology();
        claimTheImmortal(currentNodeId);
       });
       let currentTextId = null;
       let rectStartPoint = null;
       let rectPreviewEl = null;
       let rectStyle = "filled";
       let freeDrawPoints = [];
       let freeDrawPolylineEl = null;
       let freeDrawPointEls = [];
       const drawToggleBtn = document.getElementById("draw-toggle");
       const drawUndoBtn = document.getElementById("draw-undo");
       const drawColorInput = document.getElementById("draw-color");
       const drawStyleSelect = document.getElementById("draw-style");
       const drawArrowSelect = document.getElementById("draw-arrow");
       const svgMap = document.getElementById("map");
      
       function updateFreeDrawGraphics() {
        const ns = "http://www.w3.org/2000/svg";
        const svg = svgMap;
        if (!freeDrawPolylineEl && freeDrawPoints.length > 0) {
         freeDrawPolylineEl = document.createElementNS(ns, "polyline");
         freeDrawPolylineEl.classList.add("edge", "free-preview");
         freeDrawPolylineEl.setAttribute("fill", "none");
         svg.appendChild(freeDrawPolylineEl);
        }
        if (freeDrawPolylineEl) {
         if (freeDrawPoints.length === 0) {
          freeDrawPolylineEl.remove();
          freeDrawPolylineEl = null;
         } else {
          const ptsStr = freeDrawPoints.map((p) => `${p.x},${p.y}`).join(" ");
          freeDrawPolylineEl.setAttribute("points", ptsStr);
          freeDrawPolylineEl.style.stroke = drawColorInput.value || "#475569";
          freeDrawPolylineEl.style.strokeWidth = 3;
          const lineStyle = drawStyleSelect.value || "solid";
          if (lineStyle === "dashed") {
           freeDrawPolylineEl.style.strokeDasharray = "10,5";
          } else if (lineStyle === "dotted") {
           freeDrawPolylineEl.style.strokeDasharray = "2,4";
          } else {
           freeDrawPolylineEl.style.strokeDasharray = "none";
          }
         }
        }
        freeDrawPointEls.forEach((el) => el.remove());
        freeDrawPointEls = [];
        freeDrawPoints.forEach((p, idx) => {
         const c = document.createElementNS(ns, "circle");
         c.classList.add("free-point");
         c.setAttribute("cx", p.x);
         c.setAttribute("cy", p.y);
         c.setAttribute("r", 5);
         c.dataset.index = String(idx);
         c.addEventListener("mousedown", (e) => {
          if (!freeDrawMode) return;
          e.preventDefault();
          e.stopPropagation();
          let dragging = true;
          const svgEl = svgMap;
          const moveHandler = (ev) => {
           if (!dragging) return;
           const pt = svgEl.createSVGPoint();
           pt.x = ev.clientX;
           pt.y = ev.clientY;
           const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
           const i = parseInt(c.dataset.index, 10);
           if (Number.isNaN(i) || !freeDrawPoints[i]) return;
           freeDrawPoints[i].x = svgP.x;
           freeDrawPoints[i].y = svgP.y;
           updateFreeDrawGraphics();
          };
          const upHandler = () => {
           dragging = false;
           document.removeEventListener("mousemove", moveHandler);
           document.removeEventListener("mouseup", upHandler);
          };
          document.addEventListener("mousemove", moveHandler);
          document.addEventListener("mouseup", upHandler);
         });
         c.addEventListener("touchstart",
          (e) => {
           if (!freeDrawMode) return;
           e.preventDefault();
           e.stopPropagation();
           let dragging = true;
           const svgEl = svgMap;
           const touchMoveHandler = (ev) => {
            if (!dragging || !ev.touches[0]) return;
            const pt = svgEl.createSVGPoint();
            pt.x = ev.touches[0].clientX;
            pt.y = ev.touches[0].clientY;
            const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
            const i = parseInt(c.dataset.index, 10);
            if (Number.isNaN(i) || !freeDrawPoints[i]) return;
            freeDrawPoints[i].x = svgP.x;
            freeDrawPoints[i].y = svgP.y;
            updateFreeDrawGraphics();
           };
           const touchUpHandler = () => {
            dragging = false;
            document.removeEventListener("touchmove", touchMoveHandler, );
            document.removeEventListener("touchend", touchUpHandler, );
           };
           document.addEventListener("touchmove", touchMoveHandler);
           document.addEventListener("touchend", touchUpHandler);
          }, {
           passive: false
          }, );
         svg.appendChild(c);
         freeDrawPointEls.push(c);
        });
        drawUndoBtn.style.display = freeDrawPoints.length ? "inline-block" : "none";
       }
      
       function addFreeDrawPoint(x, y) {
        freeDrawPoints.push({
         x,
         y
        });
        updateFreeDrawGraphics();
       }
      
       function startFreeDraw() {
        freeDrawMode = true;
        freeDrawPoints = [];
        if (freeDrawPolylineEl) {
         freeDrawPolylineEl.remove();
         freeDrawPolylineEl = null;
        }
        freeDrawPointEls.forEach((el) => el.remove());
        freeDrawPointEls = [];
        svgMap.style.cursor = "crosshair";
        drawToggleBtn.textContent = "Done";
        drawUndoBtn.style.display = "none";
       }
      
       function finishFreeDraw() {
        freeDrawMode = false;
        svgMap.style.cursor = "";
        drawToggleBtn.textContent = "‚úèÔ∏è";
        if (freeDrawPoints.length >= 2) {
         const color = drawColorInput.value || "#475569";
         const lineStyle = drawStyleSelect.value || "solid";
         const arrowDir = drawArrowSelect.value || "none";
         const newId = "custom-" + Date.now();
         const pointsCopy = freeDrawPoints.map((p) => ({
          x: p.x,
          y: p.y,
         }));
         EDGE_DATA.list.push({
          id: newId,
          type: "custom",
          color,
          width: 4,
          lineStyle: lineStyle,
          direction: arrowDir,
          points: pointsCopy,
          notes: [],
         });
         saveEdgeData();
         freeDrawPoints = [];
         if (freeDrawPolylineEl) {
          freeDrawPolylineEl.remove();
          freeDrawPolylineEl = null;
         }
         freeDrawPointEls.forEach((el) => el.remove());
         freeDrawPointEls = [];
         forgeTheTopology();
         selectTheConnection(newId);
        } else {
         freeDrawPoints = [];
         if (freeDrawPolylineEl) {
          freeDrawPolylineEl.remove();
          freeDrawPolylineEl = null;
         }
         freeDrawPointEls.forEach((el) => el.remove());
         freeDrawPointEls = [];
         forgeTheLegend();
        }
        drawUndoBtn.style.display = "none";
       }
       drawToggleBtn.addEventListener("click", () => {
        if (currentView.mode === "rack") {
         alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
         return;
        }
        
        if (freeDrawMode) {
         finishFreeDraw();
        } else {
         startFreeDraw();
        }
       });
       drawUndoBtn.addEventListener("click", () => {
        if (!freeDrawMode || !freeDrawPoints.length) return;
        freeDrawPoints.pop();
        updateFreeDrawGraphics();
       });
       const drawToolbar = document.getElementById("draw-toolbar");
       drawToolbar.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       drawToolbar.addEventListener("click", (e) => {
        if (e.target !== drawToggleBtn && e.target !== drawUndoBtn) {
         e.stopPropagation();
        }
       });
       drawStyleSelect.addEventListener("change", () => {
        if (freeDrawMode) {
         updateFreeDrawGraphics();
        }
       });
       drawArrowSelect.addEventListener("change", () => {
        if (freeDrawMode) {
         updateFreeDrawGraphics();
        }
       });
       drawColorInput.addEventListener("input", () => {
        if (freeDrawMode) {
         updateFreeDrawGraphics();
        }
       });
       drawStyleSelect.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       drawStyleSelect.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       drawArrowSelect.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       drawArrowSelect.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       drawColorInput.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       drawColorInput.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       svgMap.addEventListener("click", (e) => {
        if (!freeDrawMode) return;
        if (e.button !== 0) return;
        const target = e.target;
        if (target && target.classList && target.classList.contains("free-point")) return;
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        addFreeDrawPoint(svgP.x, svgP.y);
       });
       svgMap.addEventListener("touchend",
        (e) => {
         if (!freeDrawMode) return;
         const target = e.target;
         if (target && target.classList && target.classList.contains("free-point")) return;
         if (e.changedTouches && e.changedTouches[0]) {
          e.preventDefault();
          const svgEl = svgMap;
          const pt = svgEl.createSVGPoint();
          pt.x = e.changedTouches[0].clientX;
          pt.y = e.changedTouches[0].clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          addFreeDrawPoint(svgP.x, svgP.y);
         }
        }, {
         passive: false
        }, );
       const settingsBtn = document.getElementById("settings-btn");
      
       const rectToggleBtn = document.getElementById("rect-toggle");
       const rectStyleSelect = document.getElementById("rect-style");
      
       function updateRectPreview() {
        if (!rectPreviewEl || !rectStartPoint) return;
        
        const ns = "http://www.w3.org/2000/svg";
        const svg = svgMap;
        
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
       }
      
       function startRectDraw() {
        rectDrawMode = true;
        rectStartPoint = null;
        rectPreviewEl = null;
        svgMap.style.cursor = "crosshair";
        rectToggleBtn.textContent = "Done";
        rectStyle = rectStyleSelect.value || "filled";
        
        if (freeDrawMode) {
         finishFreeDraw();
        }
        updateRectangleDeleteButtons();
       }
      
       function finishRectDraw() {
        rectDrawMode = false;
        svgMap.style.cursor = "";
        rectToggleBtn.textContent = "‚ñ≠";
        
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
       }
        updateRectangleDeleteButtons();
      
       rectToggleBtn.addEventListener("click", () => {
        if (currentView.mode === "rack") {
         alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
         return;
        }
        
        if (rectDrawMode) {
         finishRectDraw();
        } else {
         startRectDraw();
        }
       });
      
       rectStyleSelect.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       rectStyleSelect.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       rectStyleSelect.addEventListener("change", () => {
        if (rectDrawMode) {
         rectStyle = rectStyleSelect.value || "filled";
        }
       });
      
       svgMap.addEventListener("mousedown", (e) => {
        if (!rectDrawMode) return;
        if (e.button !== 0) return;
        e.preventDefault();
        e.stopPropagation();
        
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        rectStartPoint = { x: svgP.x, y: svgP.y };
        
        const ns = "http://www.w3.org/2000/svg";
        rectPreviewEl = document.createElementNS(ns, "rect");
        rectPreviewEl.classList.add("rect-preview");
        rectPreviewEl.setAttribute("x", svgP.x);
        rectPreviewEl.setAttribute("y", svgP.y);
        rectPreviewEl.setAttribute("width", 0);
        rectPreviewEl.setAttribute("height", 0);
        
        const color = drawColorInput.value || "#f97316";
        rectPreviewEl.style.stroke = color;
        rectPreviewEl.style.strokeWidth = 2;
        rectPreviewEl.style.strokeDasharray = "5,5";
        
        if (rectStyle === "filled") {
         rectPreviewEl.style.fill = color;
         rectPreviewEl.style.fillOpacity = "0.3";
        } else {
         rectPreviewEl.style.fill = "none";
        }
        
        svgEl.appendChild(rectPreviewEl);
       });
      
       svgMap.addEventListener("mousemove", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        
        rectPreviewEl.setAttribute("x", x);
        rectPreviewEl.setAttribute("y", y);
        rectPreviewEl.setAttribute("width", width);
        rectPreviewEl.setAttribute("height", height);
       });
      
       svgMap.addEventListener("mouseup", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        
        if (width > 10 && height > 10) {
      pushUndo("draw zone"); 
         const color = drawColorInput.value || "#f97316";
         const newId = "rect-" + Date.now();
         
         const lineStyle = document.getElementById("draw-style").value || "solid";
         RECT_DATA.list.push({
          id: newId,
          x: x,
          y: y,
          width: width,
          height: height,
          color: color,
          style: rectStyle,
          lineStyle: lineStyle,
          notes: []
         });
         
         forgeTheTopology();
        }
        
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
       });
      
       let rectTouchStart = null;
       
       svgMap.addEventListener("touchstart", (e) => {
        if (!rectDrawMode) return;
        if (e.touches.length !== 1) return;
        
        e.preventDefault();
        const touch = e.touches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        rectStartPoint = { x: svgP.x, y: svgP.y };
        rectTouchStart = { x: svgP.x, y: svgP.y };
        
        const ns = "http://www.w3.org/2000/svg";
        rectPreviewEl = document.createElementNS(ns, "rect");
        rectPreviewEl.classList.add("rect-preview");
        rectPreviewEl.setAttribute("x", svgP.x);
        rectPreviewEl.setAttribute("y", svgP.y);
        rectPreviewEl.setAttribute("width", 0);
        rectPreviewEl.setAttribute("height", 0);
        
        const color = drawColorInput.value || "#f97316";
        rectPreviewEl.style.stroke = color;
        rectPreviewEl.style.strokeWidth = 2;
        rectPreviewEl.style.strokeDasharray = "5,5";
        
        if (rectStyle === "filled") {
         rectPreviewEl.style.fill = color;
         rectPreviewEl.style.fillOpacity = "0.3";
        } else {
         rectPreviewEl.style.fill = "none";
        }
        
        svgEl.appendChild(rectPreviewEl);
       }, { passive: false });
      
       svgMap.addEventListener("touchmove", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        if (e.touches.length !== 1) return;
        
        e.preventDefault();
        const touch = e.touches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        
        rectPreviewEl.setAttribute("x", x);
        rectPreviewEl.setAttribute("y", y);
        rectPreviewEl.setAttribute("width", width);
        rectPreviewEl.setAttribute("height", height);
       }, { passive: false });
      
       svgMap.addEventListener("touchend", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        if (!rectTouchStart) return;
        
        e.preventDefault();
        const touch = e.changedTouches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        
        if (width > 10 && height > 10) {
      pushUndo("draw zone");
         const color = drawColorInput.value || "#f97316";
         const newId = "rect-" + Date.now();
         
         const lineStyle = document.getElementById("draw-style").value || "solid";
         RECT_DATA.list.push({
          id: newId,
          x: x,
          y: y,
          width: width,
          height: height,
          color: color,
          style: rectStyle,
          lineStyle: lineStyle,
          notes: []
         });
         
         forgeTheTopology();
        }
        
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
        rectTouchStart = null;
       }, { passive: false });
      
       const textToggleBtn = document.getElementById("text-toggle");
       
       function startTextMode() {
        textDrawMode = true;
        svgMap.style.cursor = "crosshair";
        textToggleBtn.textContent = "Done";
        textToggleBtn.style.background = "var(--accent)";
        textToggleBtn.style.color = "var(--bg)";
        
        if (freeDrawMode) {
         finishFreeDraw();
        }
        if (rectDrawMode) {
         finishRectDraw();
        }
        
        updateTextDeleteButtons();
       }
       
       function finishTextMode() {
        textDrawMode = false;
        svgMap.style.cursor = "";
        textToggleBtn.textContent = "T";
        textToggleBtn.style.background = "";
        textToggleBtn.style.color = "";
        updateTextDeleteButtons();
       }
       
       textToggleBtn.addEventListener("click", () => {
        if (currentView.mode === "rack") {
         alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
         return;
        }
        
        if (textDrawMode) {
         finishTextMode();
        } else {
         startTextMode();
        }
       });
       
       function handleTextPlacement(e) {
        if (!textDrawMode) return;
        
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        const newId = "text-" + Date.now();
      pushUndo("add text");
        TEXT_DATA.list.push({
         id: newId,
         x: svgP.x,
         y: svgP.y,
         content: "New Text",
         fontSize: 18,
         color: "#e2e8f0",
         fontWeight: "normal",
         fontStyle: "normal",
         textAlign: "start",
         textDecoration: "none",
         bgColor: "#000000",
         bgEnabled: false,
         opacity: 1
        });
        
        forgeTheTopology();
        
        showTextPanel(newId);
       }
       
       svgMap.addEventListener("click", (e) => {
        if (!textDrawMode) return;
        if (e.target.closest('.text-delete-btn')) return;
        if (e.target.closest('.text-group')) return;
        
        e.preventDefault();
        e.stopPropagation();
        handleTextPlacement(e);
       });
       
       svgMap.addEventListener("touchend", (e) => {
        if (!textDrawMode) return;
        if (e.target.closest('.text-delete-btn')) return;
        if (e.target.closest('.text-group')) return;
        if (e.touches.length > 0) return;
        
        e.preventDefault();
        const touch = e.changedTouches[0];
        const fakeEvent = {
         clientX: touch.clientX,
         clientY: touch.clientY,
         preventDefault: () => {},
         stopPropagation: () => {}
        };
        handleTextPlacement(fakeEvent);
       }, { passive: false });
       
       function showTextPanel(textId) {
        currentTextId = textId;
        const textItem = TEXT_DATA.list.find(t => t.id === textId);
        if (!textItem) return;
        
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        
        const textPanel = document.getElementById("text-panel");
        textPanel.style.display = "block";
        
        document.getElementById("text-content").value = textItem.content;
        document.getElementById("text-font-size").value = textItem.fontSize;
        document.getElementById("text-color").value = textItem.color;
        document.getElementById("text-font-weight").value = textItem.fontWeight;
        document.getElementById("text-font-style").value = textItem.fontStyle;
        document.getElementById("text-align").value = textItem.textAlign;
        document.getElementById("text-decoration").value = textItem.textDecoration;
        document.getElementById("text-bg-color").value = textItem.bgColor;
        document.getElementById("text-bg-enabled").checked = textItem.bgEnabled;
        document.getElementById("text-opacity").value = textItem.opacity;
        document.getElementById("text-opacity-val").textContent = Math.round(textItem.opacity * 100) + "%";
       }
       
       function updateTextDeleteButtons() {
        const deleteButtons = document.querySelectorAll('.text-delete-btn');
        deleteButtons.forEach(btn => {
         btn.style.display = textDrawMode ? 'block' : 'none';
        });
       }
       
       function deleteText(textId) {
      pushUndo("delete text");
        TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== textId);
        forgeTheTopology();
        
        if (currentTextId === textId) {
         document.getElementById("text-panel").style.display = "none";
         currentTextId = null;
        }
       }
       
       document.getElementById("text-content").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
      pushUndo("edit text");
         textItem.content = e.target.value;
         forgeTheTopology();
        }
       });
       
       document.getElementById("text-font-size").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         textItem.fontSize = parseInt(e.target.value);
         forgeTheTopology();
        }
       });
       
       document.getElementById("text-color").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         textItem.color = e.target.value;
         forgeTheTopology();
        }
       });
       
       document.getElementById("text-font-weight").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         textItem.fontWeight = e.target.value;
         forgeTheTopology();
        }
       });
       
       document.getElementById("text-font-style").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         textItem.fontStyle = e.target.value;
         forgeTheTopology();
        }
       });
       
       document.getElementById("text-align").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         textItem.textAlign = e.target.value;
         forgeTheTopology();
        }
       });
       
       document.getElementById("text-decoration").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         textItem.textDecoration = e.target.value;
         forgeTheTopology();
        }
       });
       
       document.getElementById("text-bg-color").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         textItem.bgColor = e.target.value;
         forgeTheTopology();
        }
       });
       
       document.getElementById("text-bg-enabled").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         textItem.bgEnabled = e.target.checked;
         forgeTheTopology();
        }
       });
       
       document.getElementById("text-opacity").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         textItem.opacity = parseFloat(e.target.value);
         document.getElementById("text-opacity-val").textContent = Math.round(textItem.opacity * 100) + "%";
         forgeTheTopology();
        }
       });
       
       document.getElementById("delete-text").addEventListener("click", () => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         challengeTheImmortal(`Delete text "${textItem.content.substring(0, 30)}..."?`, () => {
          deleteText(currentTextId);
         });
        }
       });
      
       const settingsModal = document.getElementById("settings-modal");
       const settingsClose = document.getElementById("settings-close");
       settingsBtn.addEventListener("click", () => {	 
      document.getElementById("page-bg-color").value = rgbaToHex(PAGE_STATE.background) || "#050608";
        document.getElementById("topbar-bg-color").value = rgbaToHex(PAGE_STATE.topbarBg) || "#0b0e13";
        document.getElementById("topbar-border-color").value = rgbaToHex(PAGE_STATE.topbarBorder) || "#1f2533";	 
      document.getElementById("panel-color").value = rgbaToHex(PAGE_STATE.panel) || "#0b0e13";
      document.getElementById("panel-alt-color").value = PAGE_STATE.panelAlt || "#10141b";
       document.getElementById("sidebar-bg-color").value = PAGE_STATE.sidebarBg || "#10141b";
       document.getElementById("btn-bg-color").value = PAGE_STATE.btnBg || "#0b0e13";
       document.getElementById("btn-text-color").value = PAGE_STATE.btnText || "#e2e8f0";
       document.getElementById("tag-fill-color").value = PAGE_STATE.tagFill || "#1e293b";
       document.getElementById("tag-text-color").value = PAGE_STATE.tagText || "#e2e8f0";
       document.getElementById("tag-border-color").value = PAGE_STATE.tagBorder || "#475569";
       document.getElementById("input-bg-color").value = PAGE_STATE.inputBg || "#0b0e13";
       document.getElementById("input-text-color").value = PAGE_STATE.inputText || "#e2e8f0";
document.getElementById("input-border-color").value = PAGE_STATE.inputBorder || "#1f2937";
       document.getElementById("input-font-family").value = PAGE_STATE.inputFont || "Inter, system-ui, sans-serif";
       document.getElementById("input-font-size").value = PAGE_STATE.inputFontSize || 14;
       document.getElementById("toolbar-bg-color").value = PAGE_STATE.toolbarBg || "#0f172a";
       document.getElementById("toolbar-border-color").value = PAGE_STATE.toolbarBorder || "#1f2937";
       document.getElementById("toolbar-text-color").value = PAGE_STATE.toolbarText || "#94a3b8";
       document.getElementById("toolbar-btn-bg-color").value = PAGE_STATE.toolbarBtnBg || "#0b0e13";
       document.getElementById("toolbar-btn-text-color").value = PAGE_STATE.toolbarBtnText || "#e2e8f0";
       document.getElementById("minimap-dots-color").value = PAGE_STATE.minimapDots || "#94a3b8";
       document.getElementById("canvas-hint-enabled").checked = PAGE_STATE.canvasHintEnabled !== false;
       document.getElementById("canvas-hint-bg-color").value = PAGE_STATE.canvasHintBg || "#0f172a";
       document.getElementById("canvas-hint-text-color").value = PAGE_STATE.canvasHintColor || "#94a3b8";
       document.getElementById("canvas-hint-text").value = PAGE_STATE.canvasHintText || "";
      document.getElementById("accent-color").value = rgbaToHex(PAGE_STATE.accent) || "#4fd1c5";
      document.getElementById("danger-color").value = rgbaToHex(PAGE_STATE.danger) || "#f56565";
      document.getElementById("text-main-color").value = rgbaToHex(PAGE_STATE.textMain) || "#e2e8f0";
      document.getElementById("text-soft-color").value = PAGE_STATE.textSoft || "#94a3b8";
       document.getElementById("node-fill-color").value = PAGE_STATE.nodeFill || "#1e293b";
       document.getElementById("node-stroke-color").value = PAGE_STATE.nodeStroke || "#475569";
       document.getElementById("node-title-color").value = PAGE_STATE.nodeTitle || "#e2e8f0";
       document.getElementById("node-sub-color").value = PAGE_STATE.nodeSub || "#94a3b8";
       document.getElementById("node-title-size").value = PAGE_STATE.nodeTitleSize || 18;
       document.getElementById("node-sub-size").value = PAGE_STATE.nodeSubSize || 13;
       document.getElementById("node-font-family").value = PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
       document.getElementById("default-edge-color").value = PAGE_STATE.defaultEdge || "#475569";
       document.getElementById("selection-handle-color").value = PAGE_STATE.selectionHandle || "#f59e0b";
       document.getElementById("selection-handle-size").value = PAGE_STATE.selectionHandleSize || 8;
       document.getElementById("group-indicator-color").value = PAGE_STATE.groupIndicator || "#4fd1c5";
       document.getElementById("canvas-gradient-top").value = PAGE_STATE.canvasGradientTop || "#1e2532";
       document.getElementById("canvas-gradient-bottom").value = PAGE_STATE.canvasGradientBottom || "#050608";
       document.getElementById("canvas-border-color").value = PAGE_STATE.canvasBorder || "#475569";
       document.getElementById("canvas-grid-color").value = PAGE_STATE.canvasGrid || "#475569";
       document.getElementById("canvas-grid-size").value = PAGE_STATE.canvasGridSize || 50;
       document.getElementById("rack-frame-fill").value = PAGE_STATE.rackFrameFill || "#0f172a";
       document.getElementById("rack-frame-stroke").value = PAGE_STATE.rackFrameStroke || "#4fd1c5";
       document.getElementById("rack-line-color").value = PAGE_STATE.rackLineColor || "#475569";
       document.getElementById("rack-text-color").value = PAGE_STATE.rackTextColor || "#4fd1c5";
      
        
        document.getElementById("auto-ping-enabled").checked = autoPingEnabled;
        document.getElementById("auto-ping-interval").value = autoPingInterval;
        document.getElementById("auto-ping-settings").style.display = autoPingEnabled ? 'block' : 'none';
        
        settingsModal.classList.add("active");
       });
       settingsClose.addEventListener("click", () => {
        settingsModal.classList.remove("active");
       });
       settingsModal.addEventListener("click", (e) => {
        if (e.target === settingsModal) {
         settingsModal.classList.remove("active");
        }
       });
       document.getElementById("page-bg-color").addEventListener("input", (e) => {
        PAGE_STATE.background = e.target.value;
        wieldThePower();
       });
       document.getElementById("topbar-bg-color").addEventListener("input", (e) => {
        PAGE_STATE.topbarBg = e.target.value;
        wieldThePower();
       });
       document.getElementById("topbar-border-color").addEventListener("input", (e) => {
        PAGE_STATE.topbarBorder = e.target.value;
        wieldThePower();
       });
       document.getElementById("panel-color").addEventListener("input", (e) => {
        PAGE_STATE.panel = e.target.value;
        wieldThePower();
       });
       document.getElementById("panel-alt-color").addEventListener("input", (e) => {
       PAGE_STATE.panelAlt = e.target.value;
       wieldThePower();
      });
      document.getElementById("sidebar-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.sidebarBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("btn-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.btnBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("btn-text-color").addEventListener("input", (e) => {
       PAGE_STATE.btnText = e.target.value;
       wieldThePower();
      });
      document.getElementById("tag-fill-color").addEventListener("input", (e) => {
       PAGE_STATE.tagFill = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("tag-text-color").addEventListener("input", (e) => {
       PAGE_STATE.tagText = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
document.getElementById("tag-border-color").addEventListener("input", (e) => {
       PAGE_STATE.tagBorder = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("input-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.inputBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-text-color").addEventListener("input", (e) => {
       PAGE_STATE.inputText = e.target.value;
       wieldThePower();
      });
document.getElementById("input-border-color").addEventListener("input", (e) => {
       PAGE_STATE.inputBorder = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-font-family").addEventListener("change", (e) => {
       PAGE_STATE.inputFont = e.target.value;
       wieldThePower();
      });
document.getElementById("input-font-size").addEventListener("input", (e) => {
       PAGE_STATE.inputFontSize = parseInt(e.target.value) || 14;
       wieldThePower();
      });
      document.getElementById("toolbar-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-border-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBorder = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-text-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarText = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-btn-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBtnBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-btn-text-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBtnText = e.target.value;
       wieldThePower();
      });
      document.getElementById("minimap-dots-color").addEventListener("input", (e) => {
       PAGE_STATE.minimapDots = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("canvas-hint-enabled").addEventListener("change", (e) => {
       PAGE_STATE.canvasHintEnabled = e.target.checked;
       wieldThePower();
      });
      document.getElementById("canvas-hint-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-hint-text-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintColor = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-hint-text").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintText = e.target.value;
       wieldThePower();
      });
       document.getElementById("accent-color").addEventListener("input", (e) => {
        PAGE_STATE.accent = e.target.value;
        wieldThePower();
       });
       document.getElementById("danger-color").addEventListener("input", (e) => {
        PAGE_STATE.danger = e.target.value;
        wieldThePower();
       });
       document.getElementById("text-main-color").addEventListener("input", (e) => {
        PAGE_STATE.textMain = e.target.value;
        wieldThePower();
       });
       document.getElementById("text-soft-color").addEventListener("input", (e) => {
       PAGE_STATE.textSoft = e.target.value;
       wieldThePower();
      });
      document.getElementById("node-fill-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeFill = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-stroke-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeStroke = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-title-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeTitle = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-sub-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeSub = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-title-size").addEventListener("input", (e) => {
       PAGE_STATE.nodeTitleSize = parseInt(e.target.value) || 18;
       forgeTheTopology();
      });
      document.getElementById("node-sub-size").addEventListener("input", (e) => {
       PAGE_STATE.nodeSubSize = parseInt(e.target.value) || 13;
       forgeTheTopology();
      });
      document.getElementById("node-font-family").addEventListener("change", (e) => {
       PAGE_STATE.nodeFont = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("default-edge-color").addEventListener("input", (e) => {
       PAGE_STATE.defaultEdge = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("selection-handle-color").addEventListener("input", (e) => {
       PAGE_STATE.selectionHandle = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("selection-handle-size").addEventListener("input", (e) => {
       PAGE_STATE.selectionHandleSize = parseInt(e.target.value) || 8;
       forgeTheTopology();
      });
      document.getElementById("group-indicator-color").addEventListener("input", (e) => {
       PAGE_STATE.groupIndicator = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-gradient-top").addEventListener("input", (e) => {
       PAGE_STATE.canvasGradientTop = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-gradient-bottom").addEventListener("input", (e) => {
       PAGE_STATE.canvasGradientBottom = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-border-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasBorder = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-grid-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasGrid = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-grid-size").addEventListener("input", (e) => {
       PAGE_STATE.canvasGridSize = parseInt(e.target.value) || 50;
       forgeTheTopology();
      });
      document.getElementById("rack-frame-fill").addEventListener("input", (e) => {
       PAGE_STATE.rackFrameFill = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-frame-stroke").addEventListener("input", (e) => {
       PAGE_STATE.rackFrameStroke = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-line-color").addEventListener("input", (e) => {
       PAGE_STATE.rackLineColor = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-text-color").addEventListener("input", (e) => {
       PAGE_STATE.rackTextColor = e.target.value;
       forgeTheTopology();
      });
      
      (function initializeResizers() {
         const headerResizer = document.getElementById('header-resizer');
         const sidebarResizer = document.getElementById('sidebar-resizer');
         const mobileFooterResizer = document.getElementById('mobile-footer-resizer');
         
         let isResizing = false;
         let currentResizer = null;
         let startY = 0;
         let startX = 0;
         let startHeight = 0;
         let startWidth = 0;
         
         function getClientPos(e) {
           if (e.touches && e.touches.length > 0) {
             return { x: e.touches[0].clientX, y: e.touches[0].clientY };
           }
           return { x: e.clientX, y: e.clientY };
         }
         
         function startResize(resizer, type, e) {
           isResizing = true;
           currentResizer = type;
           const pos = getClientPos(e);
           
           if (type === 'header') {
             startY = pos.y;
             startHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--topbar-height'));
           } else if (type === 'sidebar') {
             startX = pos.x;
             startWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width'));
           } else if (type === 'mobile-footer') {
             startY = pos.y;
             const currentVh = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--mobile-footer-height'));
             startHeight = (currentVh / 100) * window.innerHeight;
           }
           
           resizer.classList.add('resizing');
           document.body.classList.add('resizing');
           document.body.style.cursor = (type === 'sidebar') ? 'col-resize' : 'row-resize';
           e.preventDefault();
         }
         
         if (headerResizer) {
           headerResizer.addEventListener('mousedown', (e) => startResize(headerResizer, 'header', e));
           headerResizer.addEventListener('touchstart', (e) => startResize(headerResizer, 'header', e), { passive: false });
         }
         
         if (sidebarResizer) {
           sidebarResizer.addEventListener('mousedown', (e) => startResize(sidebarResizer, 'sidebar', e));
           sidebarResizer.addEventListener('touchstart', (e) => startResize(sidebarResizer, 'sidebar', e), { passive: false });
         }
         
         if (mobileFooterResizer) {
           mobileFooterResizer.addEventListener('mousedown', (e) => startResize(mobileFooterResizer, 'mobile-footer', e));
           mobileFooterResizer.addEventListener('touchstart', (e) => startResize(mobileFooterResizer, 'mobile-footer', e), { passive: false });
         }
         
         function handleMove(e) {
           if (!isResizing) return;
           
           const pos = getClientPos(e);
           
           if (currentResizer === 'header') {
             const deltaY = pos.y - startY;
             const newHeight = Math.max(40, Math.min(150, startHeight + deltaY));
             document.documentElement.style.setProperty('--topbar-height', newHeight + 'px');
           } else if (currentResizer === 'sidebar') {
             const deltaX = startX - pos.x;
             const newWidth = Math.max(200, Math.min(800, startWidth + deltaX));
             document.documentElement.style.setProperty('--sidebar-width', newWidth + 'px');
           } else if (currentResizer === 'mobile-footer') {
             const deltaY = startY - pos.y;
             const newHeight = startHeight + deltaY;
             const newVh = Math.max(15, Math.min(80, (newHeight / window.innerHeight) * 100));
             document.documentElement.style.setProperty('--mobile-footer-height', newVh + 'vh');
           }
           
           e.preventDefault();
         }
         
         document.addEventListener('mousemove', handleMove);
         document.addEventListener('touchmove', handleMove, { passive: false });
         
         function handleEnd() {
           if (isResizing) {
             isResizing = false;
             
             if (currentResizer === 'header') {
               PAGE_STATE.topbarHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--topbar-height'));
               headerResizer.classList.remove('resizing');
             } else if (currentResizer === 'sidebar') {
               PAGE_STATE.sidebarWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width'));
               sidebarResizer.classList.remove('resizing');
             } else if (currentResizer === 'mobile-footer') {
               PAGE_STATE.mobileFooterHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--mobile-footer-height'));
               mobileFooterResizer.classList.remove('resizing');
             }
             
             document.body.classList.remove('resizing');
             document.body.style.cursor = '';
             currentResizer = null;
           }
         }
         
         document.addEventListener('mouseup', handleEnd);
         document.addEventListener('touchend', handleEnd);
         document.addEventListener('touchcancel', handleEnd);
       })();
       
       document.getElementById("auto-ping-enabled").addEventListener("change", (e) => {
        autoPingEnabled = e.target.checked;
        PAGE_STATE.autoPingEnabled = autoPingEnabled;
        document.getElementById("auto-ping-settings").style.display = autoPingEnabled ? 'block' : 'none';
        
        if (autoPingEnabled) {
         startAutoPing();
        } else {
         stopAutoPing();
        }
       });
       
       document.getElementById("auto-ping-interval").addEventListener("change", (e) => {
        const newInterval = parseInt(e.target.value, 10);
        if (newInterval >= 5 && newInterval <= 3600) {
         autoPingInterval = newInterval;
         PAGE_STATE.autoPingInterval = autoPingInterval;
         
         if (autoPingEnabled) {
          startAutoPing();
         }
        }
       });
       
       document.getElementById("export-data-btn").addEventListener("click", () => {
        const data = captureTheQuickening();
        const jsonStr = JSON.stringify(data, null, 2);
        const blob = new Blob([jsonStr], {
         type: "application/json"
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        const safeTitle = (PAGE_STATE.title || "network-topology").toLowerCase().replace(/[^a-z0-9\-]+/g, "-");
        const timestamp = new Date().toISOString().split("T")[0];
        a.download = `${safeTitle}-data-${timestamp}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
       });
       document.getElementById("import-data-btn").addEventListener("click", () => {
        document.getElementById("import-data-file").click();
       });
       document.getElementById("import-data-file").addEventListener("change", async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        try {
         const text = await file.text();
         const data = JSON.parse(text);
         if (!data.nodeData || !data.edgeData) {
          alert("Invalid data file. Missing required fields.");
          return;
         }
         const confirmMsg = `This will replace all current data with the imported data.\n\nImporting:\n- ${Object.keys(data.nodeData).length} nodes\n- ${data.edgeData.list?.length || 0} connections\n- ${data.documentTabs?.length || 1} tab(s)\n\nContinue?`;         if (!confirm(confirmMsg)) {
          e.target.value = "";
          return;
         }
         NODE_DATA = data.nodeData || {};
         EDGE_DATA = data.edgeData || {
          list: []
         };
         EDGE_LEGEND = data.edgeLegend || {};
         RECT_DATA = data.rectData || { list: [] };
         TEXT_DATA = data.textData || { list: [] };
         savedPositions = data.nodePositions || {};
         savedSizes = data.nodeSizes || {};
         savedStyles = data.nodeStyles || {};
         if (data.page) {
          PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, data.page, );
          wieldThePower();
         }
      
      if (data.autoPingEnabled !== undefined) {
      autoPingEnabled = data.autoPingEnabled;
      PAGE_STATE.autoPingEnabled = autoPingEnabled;
      document.getElementById("auto-ping-enabled").checked = autoPingEnabled;
      }
      
      if (data.autoPingInterval !== undefined) {
      autoPingInterval = data.autoPingInterval;
      PAGE_STATE.autoPingInterval = autoPingInterval;
      document.getElementById("auto-ping-interval").value = autoPingInterval;
      }
         if (data.canvas) {
          canvasState.zoom = data.canvas.zoom || 1;
          canvasState.panX = data.canvas.panX || 0;
          canvasState.panY = data.canvas.panY || 0;
         }
         if (data.page?.title) {
         document.title = data.page.title;
         document.querySelector(".editable-page-title", ).textContent = data.page.title;
        }
        if (data.documentTabs) {
         documentTabs = data.documentTabs;
         currentTabIndex = data.currentTabIndex || 0;
        }
        if (data.savedTopologyView) {
         savedTopologyView = data.savedTopologyView;
        }
        if (data.encryptedSections) {
         encryptedSections = data.encryptedSections;
        }
        forgeTheTopology();
         forgeTheLegend();
         updateViewBox();
      
      if (autoPingEnabled) {
      startAutoPing();
      } else {
      stopAutoPing();
      }
      
         const nodeIds = Object.keys(NODE_DATA);
         if (nodeIds.length > 0) {
          claimTheImmortal(nodeIds[0]);
         } else {
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("topology-toolbar").style.display = "none";
         }
         alert("Data imported successfully!");
         e.target.value = "";
        } catch (err) {
         console.error("Import error:", err);
         alert(`Failed to import data: ${err.message}`);
         e.target.value = "";
        }
       });
       const saveHelpBtn = document.getElementById("save-help-btn");
       const saveInfoModal = document.getElementById("save-info-modal");
       const saveInfoClose = document.getElementById("save-info-close");
       saveHelpBtn.addEventListener("click", () => {
        saveInfoModal.classList.add("active");
       });
       saveInfoClose.addEventListener("click", () => {
        saveInfoModal.classList.remove("active");
       });
       saveInfoModal.addEventListener("click", (e) => {
       if (e.target === saveInfoModal) {
        saveInfoModal.classList.remove("active");
       }
      });
      document.querySelectorAll(".help-tab").forEach(tab => {
        tab.addEventListener("click", () => {
          document.querySelectorAll(".help-tab").forEach(t => { t.style.background = "var(--panel)"; t.style.color = "var(--text-main)"; });
          tab.style.background = "var(--accent)"; tab.style.color = "var(--bg)";
          document.querySelectorAll(".help-tab-content").forEach(c => c.style.display = "none");
          document.getElementById("help-tab-" + tab.dataset.tab).style.display = "block";
        });
      });
      async function deriveKey(password, salt) {
      const encoder = new TextEncoder();
      
      const keyMaterial = await crypto.subtle.importKey(
      "raw",
      encoder.encode(password),
      "PBKDF2",
      false,
      ["deriveKey"]
      );
      
      return crypto.subtle.deriveKey(
      {
      name: "PBKDF2",
      salt: salt,
      iterations: 200000,  
      hash: "SHA-256"
      },
      keyMaterial,
      {
      name: "AES-GCM",
      length: 256
      },
      false,
      ["encrypt", "decrypt"]
      );
      }
      
       async function encryptData(data, password) {
      const encoder = new TextEncoder();
      const salt = crypto.getRandomValues(new Uint8Array(16));
      const iv   = crypto.getRandomValues(new Uint8Array(12));
      
      const key = await deriveKey(password, salt);
      const encrypted = await crypto.subtle.encrypt(
      { name: "AES-GCM", iv },
      key,
      encoder.encode(data)
      );
      
      const encryptedU8 = new Uint8Array(encrypted);
      
      const result = new Uint8Array(salt.length + iv.length + encryptedU8.length);
      result.set(salt, 0);
      result.set(iv, salt.length);
      result.set(encryptedU8, salt.length + iv.length);
      
      return "ENCRYPTED:" + u8ToBase64(result);
      }
      
       async function decryptData(encryptedData, password) {
      const base64Data = encryptedData.replace("ENCRYPTED:", "");
      const fullData   = base64ToU8(base64Data);
      
      const salt      = fullData.slice(0, 16);
      const iv        = fullData.slice(16, 28);
      const encrypted = fullData.slice(28);
      
      const key = await deriveKey(password, salt);
      
      const decrypted = await crypto.subtle.decrypt(
      { name: "AES-GCM", iv },
      key,
      encrypted
      );
      
      const decoder = new TextDecoder();
      return decoder.decode(decrypted);
      }
      
      
       function isEncrypted(data) {
        return typeof data === "string" && data.startsWith("ENCRYPTED:");
       }
      
       function captureTheQuickening() {
      const currentTab = documentTabs[currentTabIndex];
      currentTab.nodes = JSON.parse(JSON.stringify(NODE_DATA));
      currentTab.edges = JSON.parse(JSON.stringify(EDGE_DATA));
      currentTab.positions = JSON.parse(JSON.stringify(savedPositions));
      currentTab.sizes = JSON.parse(JSON.stringify(savedSizes));
      currentTab.styles = JSON.parse(JSON.stringify(savedStyles));
      currentTab.legend = JSON.parse(JSON.stringify(EDGE_LEGEND));
      currentTab.rects = JSON.parse(JSON.stringify(RECT_DATA));
      currentTab.texts = JSON.parse(JSON.stringify(TEXT_DATA));
      currentTab.pageState = JSON.parse(JSON.stringify(PAGE_STATE));
       
      return {
      nodeData: NODE_DATA,
       edgeData: EDGE_DATA,
       rectData: RECT_DATA,
       textData: TEXT_DATA,
       edgeLegend: EDGE_LEGEND,
       nodePositions: savedPositions,
       nodeSizes: savedSizes,
       nodeStyles: savedStyles,
       iconCache: IconLibrary.iconCache,
      
       page: PAGE_STATE,
      
       autoPingEnabled: autoPingEnabled,
       autoPingInterval: autoPingInterval,
      
       canvas: {
         zoom: canvasState.zoom,
         panX: canvasState.panX,
         panY: canvasState.panY,
       },
       
       savedTopologyView: savedTopologyView,
       
       documentTabs: documentTabs,
       currentTabIndex: currentTabIndex,
       encryptedSections: encryptedSections,
      };
      }
      
       function assembleTheImmortalForm() {
	   const canvasHintEl = document.getElementById("canvas-hint");
       const savedHintHTML = canvasHintEl ? canvasHintEl.innerHTML : "";
       if (canvasHintEl) canvasHintEl.innerHTML = DEFAULT_CANVAS_HINT;
        const clone = document.documentElement.cloneNode(true);
        const nodeScript = clone.querySelector("#nodes-json");
        if (nodeScript) {
         nodeScript.textContent = JSON.stringify(NODE_DATA, null, 2);
        }
        let stateScript = clone.querySelector("#topology-state");
        if (!stateScript) {
         stateScript = document.createElement("script");
         stateScript.id = "topology-state";
         stateScript.type = "application/json";
         const body = clone.querySelector("body") || clone;
         body.appendChild(stateScript);
        }
        stateScript.textContent = JSON.stringify(captureTheQuickening(), null, 2, );
        return " <!DOCTYPE html> \n " + clone.outerHTML;
       }
       async function becomeImmortal() {
        const encryptEnabled = document.getElementById("encrypt-toggle").checked;
        let stateData = JSON.stringify(captureTheQuickening(), null, 2);
        if (encryptEnabled) {
         const password = prompt("Enter a password to encrypt your data:\n(Remember this password! You will need it to open this file and its non recoverable!)", );
         if (!password) {
          alert("Encryption cancelled. File not saved.");
          return;
         }
         const confirmPassword = prompt("Confirm your password:");
         if (password !== confirmPassword) {
          alert("Passwords do not match. File not saved.");
          return;
         }
         try {
          stateData = await encryptData(stateData, password);
         } catch (e) {
          alert("Encryption failed: " + e.message);
          return;
         }
        }
       const canvasHintEl = document.getElementById("canvas-hint");
       const savedHintHTML = canvasHintEl ? canvasHintEl.innerHTML : "";
       if (canvasHintEl) canvasHintEl.innerHTML = DEFAULT_CANVAS_HINT;
       
       const clone = document.documentElement.cloneNode(true);
        const nodeScript = clone.querySelector("#nodes-json");
        if (nodeScript) {
         if (encryptEnabled) {
          nodeScript.textContent = JSON.stringify({}, null, 2);
         } else {
          nodeScript.textContent = JSON.stringify(NODE_DATA, null, 2);
         }
        }
        let stateScript = clone.querySelector("#topology-state");
        if (!stateScript) {
         stateScript = document.createElement("script");
         stateScript.id = "topology-state";
         stateScript.type = "application/json";
         const body = clone.querySelector("body") || clone;
         body.appendChild(stateScript);
        }
        stateScript.textContent = stateData;
        const html = "<!DOCTYPE html> \n " + clone.outerHTML;
        const blob = new Blob([html], {
         type: "text/html"
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        const safeTitle = (PAGE_STATE.title || document.title || "network-topology").toLowerCase().replace(/[^a-z0-9\-]+/g, "-");
        a.download = safeTitle + ".html";
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url); 
		if (canvasHintEl) canvasHintEl.innerHTML = savedHintHTML;
        saveRollbackVersion("Manual save");
		logAuditEvent("save", `File saved: ${safeTitle}.html`);
       }
       
      function captureState() {
      return {
        nodes: JSON.parse(JSON.stringify(NODE_DATA)),
        edges: JSON.parse(JSON.stringify(EDGE_DATA)),
        positions: JSON.parse(JSON.stringify(savedPositions)),
        sizes: JSON.parse(JSON.stringify(savedSizes)),
        styles: JSON.parse(JSON.stringify(savedStyles)),
        legend: JSON.parse(JSON.stringify(EDGE_LEGEND)),
        rects: JSON.parse(JSON.stringify(RECT_DATA)),
        texts: JSON.parse(JSON.stringify(TEXT_DATA))
        };
      }
      
      function pushUndo(action = "") {
       const state = captureState();
       undoStack.push(state);
       if (undoStack.length > MAX_UNDO_STACK) {
        undoStack.shift();
       }
       redoStack = [];
       updateUndoButtons();
      }
      
      function undo() {
       if (undoStack.length === 0) return;
       const currentState = captureState();
       redoStack.push(currentState);
       const previousState = undoStack.pop();
       restoreState(previousState);
       updateUndoButtons();
      }
      
      function redo() {
       if (redoStack.length === 0) return;
       const currentState = captureState();
       undoStack.push(currentState);
       const nextState = redoStack.pop();
       restoreState(nextState);
       updateUndoButtons();
      }
      
      function restoreState(state) {
      NODE_DATA = state.nodes;
       EDGE_DATA = state.edges;
       savedPositions = state.positions;
       savedSizes = state.sizes;
       savedStyles = state.styles;
       EDGE_LEGEND = state.legend;
       RECT_DATA = state.rects || { list: [] };
       TEXT_DATA = state.texts || { list: [] };
       forgeTheTopology();
       if (currentNodeId && NODE_DATA[currentNodeId]) {
       claimTheImmortal(currentNodeId);
       } else if (currentEdgeId) {
       selectTheConnection(currentEdgeId);
       }
      }
      
      function updateUndoButtons() {
       const undoBtn = document.getElementById("undo-btn");
       const redoBtn = document.getElementById("redo-btn");
       if (undoBtn) {
        undoBtn.disabled = undoStack.length === 0;
        undoBtn.style.opacity = undoStack.length === 0 ? "0.5" : "1";
       }
       if (redoBtn) {
        redoBtn.disabled = redoStack.length === 0;
        redoBtn.style.opacity = redoStack.length === 0 ? "0.5" : "1";
       }
      }
      
      function selectNode(nodeId, addToSelection = false) {
       if (!addToSelection) {
        selectedNodes.clear();
       }
       selectedNodes.add(nodeId);
       updateNodeSelection();
      }
      
      function clearSelection() {
       selectedNodes.clear();
       selectedEdges.clear();
       selectedRects.clear();
       selectedTexts.clear();
       updateAllSelections();
      }
      
      function updateAllSelections() {
      updateNodeSelection();
      clearSearchHighlight();
      document.querySelectorAll(".edge").forEach(el => {
      const edgeId = el.dataset.edgeId;
      if (selectedEdges.has(edgeId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      
      document.querySelectorAll(".rect-group").forEach(el => {
      const rectId = el.dataset.rectId;
      if (selectedRects.has(rectId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      
      document.querySelectorAll(".text-group").forEach(el => {
      const textId = el.dataset.textId;
      if (selectedTexts.has(textId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      
      const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
      const bulkToolbar = document.getElementById("bulk-toolbar");
      const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
      const bulkCount = document.getElementById("bulk-count");
      const bulkCountMobile = document.getElementById("bulk-count-mobile");
      
      if (total > 0) {
      if (bulkToolbar) bulkToolbar.style.display = "flex";
      if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
      if (bulkCount) bulkCount.textContent = total;
      if (bulkCountMobile) bulkCountMobile.textContent = total;
      } else {
      if (bulkToolbar) bulkToolbar.style.display = "none";
      if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
      }
      }
      
      
      function updateNodeSelection() {
       document.querySelectorAll(".node-group").forEach(node => {
        const nodeId = node.dataset.nodeId;
        if (selectedNodes.has(nodeId)) {
         node.classList.add("selected");
        } else {
         node.classList.remove("selected");
        }
       });
       
       const bulkToolbar = document.getElementById("bulk-toolbar");
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       const bulkCount = document.getElementById("bulk-count");
       const bulkCountMobile = document.getElementById("bulk-count-mobile");
       const bulkCountModal = document.getElementById("bulk-count-modal");
       
       if (selectedNodes.size > 0) {
        if (bulkToolbar) bulkToolbar.style.display = "flex";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
        if (bulkCount) bulkCount.textContent = selectedNodes.size;
        if (bulkCountMobile) bulkCountMobile.textContent = selectedNodes.size;
        if (bulkCountModal) bulkCountModal.textContent = selectedNodes.size;
       } else {
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        const modal = document.getElementById("bulk-actions-modal");
        if (modal) modal.style.display = "none";
       }
      }
      
      function deleteSelected() {
       const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
       if (total === 0) return;
       const message = `Delete ${total} selected item(s)?`;
       challengeTheImmortal(message, () => {
        pushUndo("delete selected");
        selectedNodes.forEach(nodeId => {
         delete NODE_DATA[nodeId];
         delete savedPositions[nodeId];
         delete savedSizes[nodeId];
         delete savedStyles[nodeId];
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== nodeId && e.to !== nodeId);
        });
        selectedEdges.forEach(edgeId => {
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.id !== edgeId);
        });
        selectedRects.forEach(rectId => {
         RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== rectId);
        });
        selectedTexts.forEach(textId => {
         TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== textId);
        });
        clearSelection();
        saveEdgeData();
        forgeTheTopology();
       });
      }
      
      function startSelection(event) {
       const svgEl = document.getElementById("map");
       const pt = svgEl.createSVGPoint();
       pt.x = event.clientX;
       pt.y = event.clientY;
       const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
       
       isSelecting = true;
       selectionStart = { x: svgP.x, y: svgP.y };
       
       if (!selectionRect) {
        selectionRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        selectionRect.setAttribute("fill", "rgba(79, 209, 197, 0.1)");
        selectionRect.setAttribute("stroke", "#4fd1c5");
        selectionRect.setAttribute("stroke-width", "2");
        selectionRect.setAttribute("stroke-dasharray", "5,5");
        selectionRect.style.pointerEvents = "none";
        svgEl.appendChild(selectionRect);
       }
       
       if (!event.shiftKey) {
        selectedNodes.clear();
       }
      }
      
      function updateSelection(event) {
       if (!isSelecting || !selectionStart) return;
       
       const svgEl = document.getElementById("map");
       const pt = svgEl.createSVGPoint();
       pt.x = event.clientX;
       pt.y = event.clientY;
       const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
       
       const x = Math.min(selectionStart.x, svgP.x);
       const y = Math.min(selectionStart.y, svgP.y);
       const width = Math.abs(svgP.x - selectionStart.x);
       const height = Math.abs(svgP.y - selectionStart.y);
       
       selectionRect.setAttribute("x", x);
       selectionRect.setAttribute("y", y);
       selectionRect.setAttribute("width", width);
       selectionRect.setAttribute("height", height);
       selectionRect.style.display = "block";
       
       document.querySelectorAll(".node-group").forEach(node => {
        const nodeId = node.dataset.nodeId;
        const pos = savedPositions[nodeId];
        if (pos && pos.x >= x && pos.x <= x + width && pos.y >= y && pos.y <= y + height) {
         selectedNodes.add(nodeId);
        } else if (!event.shiftKey) {
         selectedNodes.delete(nodeId);
        }
       });
       
       updateNodeSelection();
      }
      
      function endSelection() {
       isSelecting = false;
       selectionStart = null;
       if (selectionRect) {
        selectionRect.style.display = "none";
       }
      }
      
      function cloneNode(sourceId) {
       const source = NODE_DATA[sourceId];
       if (!source) return;
       
       pushUndo("clone node");
       
       let baseName = source.name;
       let copyNum = 0;
       let newName = baseName + " copy";
       while (Object.values(NODE_DATA).some(n => n.name === newName)) {
        copyNum++;
        newName = baseName + " copy " + copyNum;
       }
       
       const newId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
       
       NODE_DATA[newId] = {
        shape: source.shape,
        name: newName,
        ip: source.ip,
        role: source.role,
        tags: [...source.tags],
        notes: [...source.notes],
        mac: source.mac || "",
        rackUnit: source.rackUnit || "",
        uHeight: source.uHeight || "1",
        ping: source.ping ? JSON.parse(JSON.stringify(source.ping)) : {
         enabled: false,
         protocol: 'http',
         customUrl: '',
         timeout: 3000,
         status: 'unknown',
         lastCheck: null
        }
       };
       
       if (savedSizes[sourceId]) {
        savedSizes[newId] = savedSizes[sourceId];
       }
       
       if (savedStyles[sourceId]) {
        savedStyles[newId] = JSON.parse(JSON.stringify(savedStyles[sourceId]));
       }
       
      if (currentView.mode === "rack" && currentView.rackId) {
        NODE_DATA[newId].assignedRack = currentView.rackId;
       }
       
       const sourcePos = savedPositions[sourceId];
       savedPositions[newId] = {
        x: sourcePos.x + 100,
        y: sourcePos.y + 100
       };
       
       forgeTheTopology();
       claimTheImmortal(newId);
      }
      
      function alignSelectedNodes(direction) {
       if (selectedNodes.size < 2) return;
       
       pushUndo("align nodes");
       
       const nodeIds = Array.from(selectedNodes);
       const positions = nodeIds.map(id => ({ id, pos: savedPositions[id] }));
       
       switch(direction) {
        case "left":
         const minX = Math.min(...positions.map(p => p.pos.x));
         positions.forEach(p => savedPositions[p.id].x = minX);
         break;
        case "right":
         const maxX = Math.max(...positions.map(p => p.pos.x));
         positions.forEach(p => savedPositions[p.id].x = maxX);
         break;
        case "top":
         const minY = Math.min(...positions.map(p => p.pos.y));
         positions.forEach(p => savedPositions[p.id].y = minY);
         break;
        case "bottom":
         const maxY = Math.max(...positions.map(p => p.pos.y));
         positions.forEach(p => savedPositions[p.id].y = maxY);
         break;
        case "center-h":
         const avgX = positions.reduce((sum, p) => sum + p.pos.x, 0) / positions.length;
         positions.forEach(p => savedPositions[p.id].x = avgX);
         break;
        case "center-v":
         const avgY = positions.reduce((sum, p) => sum + p.pos.y, 0) / positions.length;
         positions.forEach(p => savedPositions[p.id].y = avgY);
         break;
       }
       
       forgeTheTopology();
      }
      
      function distributeSelectedNodes(direction) {
       if (selectedNodes.size < 3) return;
       
       pushUndo("distribute nodes");
       
       const nodeIds = Array.from(selectedNodes);
       const positions = nodeIds.map(id => ({ id, pos: savedPositions[id] }));
       
       if (direction === "horizontal") {
        positions.sort((a, b) => a.pos.x - b.pos.x);
        const minX = positions[0].pos.x;
        const maxX = positions[positions.length - 1].pos.x;
        const gap = (maxX - minX) / (positions.length - 1);
        positions.forEach((p, i) => {
         savedPositions[p.id].x = minX + (gap * i);
        });
       } else if (direction === "vertical") {
        positions.sort((a, b) => a.pos.y - b.pos.y);
        const minY = positions[0].pos.y;
        const maxY = positions[positions.length - 1].pos.y;
        const gap = (maxY - minY) / (positions.length - 1);
        positions.forEach((p, i) => {
         savedPositions[p.id].y = minY + (gap * i);
        });
       }
       
       forgeTheTopology();
      }
      
      function snapToGrid(nodeId, gridSize = 50) {
       if (!savedPositions[nodeId]) return;
       
       pushUndo("snap to grid");
       
       const pos = savedPositions[nodeId];
       pos.x = Math.round(pos.x / gridSize) * gridSize;
       pos.y = Math.round(pos.y / gridSize) * gridSize;
       
       forgeTheTopology();
      }
      
      function nudgeSelectedNodes(direction, distance) {
        const nodesToNudge = selectedNodes.size > 0 
          ? Array.from(selectedNodes) 
          : (currentNodeId ? [currentNodeId] : []);
        
        if (nodesToNudge.length === 0) return;
        
        const unlockedNodes = nodesToNudge.filter(id => !NODE_DATA[id]?.locked);
        
        if (unlockedNodes.length === 0) {
          return;
        }
        
        pushUndo("nudge nodes");
        
        unlockedNodes.forEach(id => {
          if (!savedPositions[id]) {
            savedPositions[id] = { x: 0, y: 0 };
          }
          
          switch(direction) {
            case "ArrowUp":
              savedPositions[id].y -= distance;
              break;
            case "ArrowDown":
              savedPositions[id].y += distance;
              break;
            case "ArrowLeft":
              savedPositions[id].x -= distance;
              break;
            case "ArrowRight":
              savedPositions[id].x += distance;
              break;
          }
        });
        
        forgeTheTopology();
      }
      
      function cycleNodes(reverse = false) {
        const nodeIds = Object.keys(NODE_DATA).filter(id => {
          if (currentView.mode === "rack") {
           const node = NODE_DATA[id];
           return node && node.assignedRack === currentView.rackId;
          }
          return isNodeVisible(id);
         });
        
        if (nodeIds.length === 0) return;
        
        let currentIndex = nodeIds.indexOf(currentNodeId);
        
        if (reverse) {
          currentIndex = currentIndex <= 0 ? nodeIds.length - 1 : currentIndex - 1;
        } else {
          currentIndex = currentIndex >= nodeIds.length - 1 ? 0 : currentIndex + 1;
        }
        
        const nextNodeId = nodeIds[currentIndex];
        claimTheImmortal(nextNodeId);
        
        selectedNodes.clear();
        updateNodeSelection();
      }
      
      function focusOnSelected() {
        const nodesToFocus = selectedNodes.size > 0 
          ? Array.from(selectedNodes) 
          : (currentNodeId ? [currentNodeId] : []);
        
        if (nodesToFocus.length === 0) return;
        
        let minX = Infinity, minY = Infinity;
        let maxX = -Infinity, maxY = -Infinity;
        
        nodesToFocus.forEach(id => {
          const pos = savedPositions[id];
          if (pos) {
            const size = savedSizes[id] || 50;
            minX = Math.min(minX, pos.x - size/2);
            minY = Math.min(minY, pos.y - size/2);
            maxX = Math.max(maxX, pos.x + size/2);
            maxY = Math.max(maxY, pos.y + size/2);
          }
        });
        
        if (!isFinite(minX)) return;
        
        const padding = 100;
        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;
        const width = maxX - minX + padding * 2;
        const height = maxY - minY + padding * 2;
        
        const zoomX = CANVAS_WIDTH / width;
        const zoomY = CANVAS_HEIGHT / height;
        const targetZoom = Math.min(zoomX, zoomY, 2);
        
        canvasState.zoom = targetZoom;
        canvasState.panX = centerX - (CANVAS_WIDTH / targetZoom) / 2;
        canvasState.panY = centerY - (CANVAS_HEIGHT / targetZoom) / 2;
        
        forgeTheTopology();
      }
      
      function toggleLockSelected() {
        const nodesToToggle = selectedNodes.size > 0 
          ? Array.from(selectedNodes) 
          : (currentNodeId ? [currentNodeId] : []);
        
        if (nodesToToggle.length === 0) return;
        
        pushUndo("toggle lock");
        
        const hasUnlocked = nodesToToggle.some(id => !NODE_DATA[id]?.locked);
        
        nodesToToggle.forEach(id => {
          if (NODE_DATA[id]) {
            NODE_DATA[id].locked = hasUnlocked;
          }
        });
        
        forgeTheTopology();
      
        const lockState = hasUnlocked ? "locked" : "unlocked";
      }
      
      function toggleGroupSelected() {
      const nodesToGroup = Array.from(selectedNodes);
      const rectsToGroup = Array.from(selectedRects);
      const textsToGroup = Array.from(selectedTexts);
      const edgesToGroup = Array.from(selectedEdges);
      const totalItems = nodesToGroup.length + rectsToGroup.length + textsToGroup.length + edgesToGroup.length;
      if (totalItems < 2) return;
      
      pushUndo("toggle group");
      
      const allGroupIds = [];
      nodesToGroup.forEach(id => { if (NODE_DATA[id]?.groupId) allGroupIds.push(NODE_DATA[id].groupId); });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r?.groupId) allGroupIds.push(r.groupId); });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t?.groupId) allGroupIds.push(t.groupId); });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e?.groupId) allGroupIds.push(e.groupId); });
      const uniqueGroups = [...new Set(allGroupIds)];
      
      if (uniqueGroups.length === 1 && allGroupIds.length === totalItems) {
      nodesToGroup.forEach(id => { if (NODE_DATA[id]) NODE_DATA[id].groupId = null; });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r) r.groupId = null; });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t) t.groupId = null; });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e) e.groupId = null; });
      } else {
      const newGroupId = "group-" + Date.now();
      nodesToGroup.forEach(id => { if (NODE_DATA[id]) NODE_DATA[id].groupId = newGroupId; });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r) r.groupId = newGroupId; });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t) t.groupId = newGroupId; });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e) e.groupId = newGroupId; });
      }
      
      forgeTheTopology();
      }
      
      function handleKeyDown(event) {
       if (event.target.tagName === "INPUT" || event.target.tagName === "TEXTAREA" || event.target.isContentEditable) {
        return;
       }
      
       if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(event.key)) {
        event.preventDefault();
        const distance = event.shiftKey ? 10 : 1;
        nudgeSelectedNodes(event.key, distance);
       }
       
       if (event.key === "Tab") {
        event.preventDefault();
        cycleNodes(event.shiftKey);
       }
       
       if (event.key === "f" || event.key === "F") {
        event.preventDefault();
        focusOnSelected();
       }
       
       if (event.key === "l" || event.key === "L") {
        event.preventDefault();
        toggleLockSelected();
       }
       
       if (event.key === "g" || event.key === "G") {
        event.preventDefault();
        toggleGroupSelected();
       }
       
       if (event.ctrlKey && event.key === "z" && !event.shiftKey) {
        event.preventDefault();
        undo();
       }
       
       if ((event.ctrlKey && event.key === "y") || (event.ctrlKey && event.shiftKey && event.key === "z")) {
        event.preventDefault();
        redo();
       }
       
       if (event.ctrlKey && event.key === "c" && currentNodeId) {
        event.preventDefault();
        const node = NODE_DATA[currentNodeId];
        if (node) {
         clipboard = {
          type: "node",
          data: JSON.parse(JSON.stringify(node)),
          size: savedSizes[currentNodeId],
          style: savedStyles[currentNodeId] ? JSON.parse(JSON.stringify(savedStyles[currentNodeId])) : null
         };
        }
       }
       
       if (event.ctrlKey && event.key === "v" && clipboard && clipboard.type === "node") {
        event.preventDefault();
        pushUndo("paste node");
        
        let baseName = clipboard.data.name;
        let copyNum = 0;
        let newName = baseName + " copy";
        while (Object.values(NODE_DATA).some(n => n.name === newName)) {
         copyNum++;
         newName = baseName + " copy " + copyNum;
        }
        
        const newId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
        NODE_DATA[newId] = JSON.parse(JSON.stringify(clipboard.data));
        NODE_DATA[newId].name = newName;
        
        if (clipboard.size) savedSizes[newId] = clipboard.size;
        if (clipboard.style) savedStyles[newId] = JSON.parse(JSON.stringify(clipboard.style));
        
        const svgEl = document.getElementById("map");
        const rect = svgEl.getBoundingClientRect();
        const pt = svgEl.createSVGPoint();
        pt.x = rect.left + rect.width / 2;
        pt.y = rect.top + rect.height / 2;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        savedPositions[newId] = { x: svgP.x, y: svgP.y };
        
        forgeTheTopology();
        claimTheImmortal(newId);
       }
       
       if (event.ctrlKey && event.key === "d" && currentNodeId) {
        event.preventDefault();
        cloneNode(currentNodeId);
       }
       
       if (event.key === "Delete") {
        event.preventDefault();
        if (selectedNodes.size > 0) {
         deleteSelected();
        } else if (currentNodeId && NODE_DATA[currentNodeId]) {
         challengeTheImmortal(`Delete node "${NODE_DATA[currentNodeId].name}"?`, () => {
          pushUndo("delete node");
          delete NODE_DATA[currentNodeId];
          delete savedPositions[currentNodeId];
          delete savedSizes[currentNodeId];
          delete savedStyles[currentNodeId];
          EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== currentNodeId && e.to !== currentNodeId);
          saveEdgeData();
          forgeTheTopology();
          currentNodeId = null;
          document.getElementById("node-panel").style.display = "none";
         });
        } else if (currentEdgeId) {
         const edge = EDGE_DATA.list.find(e => e.id === currentEdgeId);
         if (edge) {
          challengeTheImmortal("Delete this line?", () => {
           pushUndo("delete edge");
           EDGE_DATA.list = EDGE_DATA.list.filter(e => e.id !== currentEdgeId);
           saveEdgeData();
           forgeTheTopology();
           currentEdgeId = null;
           document.getElementById("edge-panel").style.display = "none";
          });
         }
        }
       }
       
       if (event.ctrlKey && event.key === "a") {
        event.preventDefault();
        selectedNodes.clear();
        Object.keys(NODE_DATA).forEach(id => selectedNodes.add(id));
        updateNodeSelection();
       }
       
       if (event.key === "Escape") {
        clearSelection();
       }
      }
      
      function searchNodes(query) {
       clearSearchHighlight();
       
       if (!query || query.trim() === "") return;
       
       const lowerQuery = query.toLowerCase();
       const matchingIds = [];
       
       Object.entries(NODE_DATA).forEach(([id, node]) => {
        const searchableText = [
         node.name,
         node.ip,
         node.role,
         ...(node.tags || []),
         node.mac || "",
         node.rackUnit || ""
        ].join(" ").toLowerCase();
        
        if (searchableText.includes(lowerQuery)) {
         matchingIds.push(id);
        }
       });
       
       highlightSearchResults(matchingIds);
      }
      
      function highlightSearchResults(nodeIds) {
       clearSearchHighlight();
       nodeIds.forEach(id => {
        const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`);
        if (nodeGroup) {
         nodeGroup.classList.add("search-highlight");
        }
       });
      }
      
      function clearSearchHighlight() {
       document.querySelectorAll(".node-group").forEach(node => {
        node.classList.remove("search-highlight");
       });
      }
      
      function editNodeMac(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       
       document.getElementById("modal-title").textContent = "Edit MAC Address";
       document.getElementById("modal-input").value = node.mac || "";
       document.getElementById("edit-modal").style.display = "flex";
       document.getElementById("modal-input").focus();
       
       const saveHandler = () => {
        pushUndo("edit mac");
        const value = document.getElementById("modal-input").value.trim();
        node.mac = value;
        document.getElementById("edit-modal").style.display = "none";
        claimTheImmortal(id);
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       
       const cancelHandler = () => {
        document.getElementById("edit-modal").style.display = "none";
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       
       document.getElementById("edit-modal").addEventListener("click", function bgHandler(e) {
        if (e.target === document.getElementById("edit-modal")) {
         cancelHandler();
         document.getElementById("edit-modal").removeEventListener("click", bgHandler);
        }
       });
      }
      
      function editNodeRack(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       
       document.getElementById("modal-title").textContent = "Edit Rack Unit";
       document.getElementById("modal-input").value = node.rackUnit || "";
       document.getElementById("edit-modal").style.display = "flex";
       document.getElementById("modal-input").focus();
       
       const saveHandler = () => {
        pushUndo("edit rack");
        const value = document.getElementById("modal-input").value.trim();
        node.rackUnit = value;
        document.getElementById("edit-modal").style.display = "none";
        claimTheImmortal(id);
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       
       const cancelHandler = () => {
        document.getElementById("edit-modal").style.display = "none";
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       
       document.getElementById("edit-modal").addEventListener("click", function bgHandler(e) {
        if (e.target === document.getElementById("edit-modal")) {
         cancelHandler();
         document.getElementById("edit-modal").removeEventListener("click", bgHandler);
        }
       });
      }
      
      function editNodeUHeight(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       
       document.getElementById("modal-title").textContent = "Edit U Height";
       document.getElementById("modal-input").value = node.uHeight || "1";
       document.getElementById("edit-modal").style.display = "flex";
       document.getElementById("modal-input").focus();
       
       const saveHandler = () => {
        pushUndo("edit U height");
        const value = document.getElementById("modal-input").value.trim();
        node.uHeight = value;
        document.getElementById("edit-modal").style.display = "none";
        claimTheImmortal(id);
        forgeTheTopology();
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       
       const cancelHandler = () => {
        document.getElementById("edit-modal").style.display = "none";
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       
       document.getElementById("edit-modal").addEventListener("click", function bgHandler(e) {
        if (e.target === document.getElementById("edit-modal")) {
         cancelHandler();
         document.getElementById("edit-modal").removeEventListener("click", bgHandler);
        }
       });
      }
      
      function updateEdgePortLabels(edgeId) {
       const edge = EDGE_DATA.list.find(e => e.id === edgeId);
       if (!edge) return;
       
       const fromPortInput = document.getElementById("edge-from-port");
       const toPortInput = document.getElementById("edge-to-port");
       
       edge.fromPort = fromPortInput ? fromPortInput.value.trim() : "";
       edge.toPort = toPortInput ? toPortInput.value.trim() : "";
       
       saveEdgeData();
       forgeTheTopology();
      }
      
      document.addEventListener("keydown", handleKeyDown);
      
      const undoBtn = document.getElementById("undo-btn");
      const redoBtn = document.getElementById("redo-btn");
      if (undoBtn) undoBtn.addEventListener("click", undo);
      if (redoBtn) redoBtn.addEventListener("click", redo);
      
      const backToTopologyBtn = document.getElementById("back-to-topology-btn");
      if (backToTopologyBtn) {
       backToTopologyBtn.addEventListener("click", exitRack);
      }
      
      const bulkToolbarClose = document.getElementById("bulk-toolbar-close");
      if (bulkToolbarClose) {
       bulkToolbarClose.addEventListener("click", clearSelection);
      }
      
      const bulkAlignLeft = document.getElementById("bulk-align-left");
      if (bulkAlignLeft) {
       bulkAlignLeft.addEventListener("click", () => alignSelectedNodes("left"));
      }
      
      const bulkAlignRight = document.getElementById("bulk-align-right");
      if (bulkAlignRight) {
       bulkAlignRight.addEventListener("click", () => alignSelectedNodes("right"));
      }
      
      const bulkAlignTop = document.getElementById("bulk-align-top");
      if (bulkAlignTop) {
       bulkAlignTop.addEventListener("click", () => alignSelectedNodes("top"));
      }
      
      const bulkAlignBottom = document.getElementById("bulk-align-bottom");
      if (bulkAlignBottom) {
       bulkAlignBottom.addEventListener("click", () => alignSelectedNodes("bottom"));
      }
      
      const bulkDistributeH = document.getElementById("bulk-distribute-h");
      if (bulkDistributeH) {
       bulkDistributeH.addEventListener("click", () => distributeSelectedNodes("horizontal"));
      }
      
      const bulkDistributeV = document.getElementById("bulk-distribute-v");
      if (bulkDistributeV) {
       bulkDistributeV.addEventListener("click", () => distributeSelectedNodes("vertical"));
      }
      
      const bulkClone = document.getElementById("bulk-clone");
      if (bulkClone) {
       bulkClone.addEventListener("click", () => {
        if (selectedNodes.size === 0) return;
        pushUndo("clone selected");
        const nodesToClone = Array.from(selectedNodes);
        selectedNodes.clear();
        nodesToClone.forEach(id => {
         cloneNode(id);
         selectedNodes.add(currentNodeId);
        });
        updateNodeSelection();
       });
      }
      
      const bulkDelete = document.getElementById("bulk-delete");
      if (bulkDelete) {
       bulkDelete.addEventListener("click", deleteSelected);
      }
      
      const bulkMobileBtn = document.getElementById("bulk-mobile-btn");
      const bulkActionsModal = document.getElementById("bulk-actions-modal");
      const bulkModalClose = document.getElementById("bulk-modal-close");
      
      if (bulkMobileBtn) {
       bulkMobileBtn.addEventListener("click", () => {
        if (bulkActionsModal) bulkActionsModal.style.display = "block";
       });
      }
      
      if (bulkModalClose) {
       bulkModalClose.addEventListener("click", () => {
        if (bulkActionsModal) bulkActionsModal.style.display = "none";
       });
      }
      
      const closeModalAfterAction = () => {
       if (bulkActionsModal) bulkActionsModal.style.display = "none";
      };
      
      const bulkAlignLeftMobile = document.getElementById("bulk-align-left-mobile");
      if (bulkAlignLeftMobile) {
       bulkAlignLeftMobile.addEventListener("click", () => {
        alignSelectedNodes("left");
        closeModalAfterAction();
       });
      }
      
      const bulkAlignRightMobile = document.getElementById("bulk-align-right-mobile");
      if (bulkAlignRightMobile) {
       bulkAlignRightMobile.addEventListener("click", () => {
        alignSelectedNodes("right");
        closeModalAfterAction();
       });
      }
      
      const bulkAlignTopMobile = document.getElementById("bulk-align-top-mobile");
      if (bulkAlignTopMobile) {
       bulkAlignTopMobile.addEventListener("click", () => {
        alignSelectedNodes("top");
        closeModalAfterAction();
       });
      }
      
      const bulkAlignBottomMobile = document.getElementById("bulk-align-bottom-mobile");
      if (bulkAlignBottomMobile) {
       bulkAlignBottomMobile.addEventListener("click", () => {
        alignSelectedNodes("bottom");
        closeModalAfterAction();
       });
      }
      
      const bulkDistributeHMobile = document.getElementById("bulk-distribute-h-mobile");
      if (bulkDistributeHMobile) {
       bulkDistributeHMobile.addEventListener("click", () => {
        distributeSelectedNodes("horizontal");
        closeModalAfterAction();
       });
      }
      
      const bulkDistributeVMobile = document.getElementById("bulk-distribute-v-mobile");
      if (bulkDistributeVMobile) {
       bulkDistributeVMobile.addEventListener("click", () => {
        distributeSelectedNodes("vertical");
        closeModalAfterAction();
       });
      }
      
      const bulkCloneMobile = document.getElementById("bulk-clone-mobile");
      if (bulkCloneMobile) {
       bulkCloneMobile.addEventListener("click", () => {
        if (selectedNodes.size === 0) return;
        pushUndo("clone selected");
        const nodesToClone = Array.from(selectedNodes);
        selectedNodes.clear();
        nodesToClone.forEach(id => {
         cloneNode(id);
         selectedNodes.add(currentNodeId);
        });
        updateNodeSelection();
        closeModalAfterAction();
       });
      }
      
      const bulkDeleteMobile = document.getElementById("bulk-delete-mobile");
      if (bulkDeleteMobile) {
       bulkDeleteMobile.addEventListener("click", () => {
        deleteSelected();
        closeModalAfterAction();
       });
      }
      
      const bulkLockMobile = document.getElementById("bulk-lock-mobile");
      if (bulkLockMobile) {
       bulkLockMobile.addEventListener("click", () => {
        toggleLockSelected();
        closeModalAfterAction();
       });
      }
      
      const bulkGroupMobile = document.getElementById("bulk-group-mobile");
      if (bulkGroupMobile) {
       bulkGroupMobile.addEventListener("click", () => {
        toggleGroupSelected();
        closeModalAfterAction();
       });
      }
      
      const bulkClearMobile = document.getElementById("bulk-clear-mobile");
      if (bulkClearMobile) {
       bulkClearMobile.addEventListener("click", () => {
        clearSelection();
        closeModalAfterAction();
       });
      }
      
      const searchInput = document.getElementById("search-input");
      if (searchInput) {
       searchInput.addEventListener("input", (e) => {
        searchNodes(e.target.value);
       });
      }
      
       document.getElementById("save-file-btn").addEventListener("click", becomeImmortal);
       document.getElementById("check-all-ping-btn").addEventListener("click", checkAllNodesStatus);
       const addNodeBtn = document.getElementById("add-node-btn");
       const addNodeModal = document.getElementById("add-node-modal");
       const addNodeCancel = document.getElementById("add-node-cancel");
       const addNodeSave = document.getElementById("add-node-save");
       addNodeBtn.addEventListener("click", () => {
        document.getElementById("new-node-name").value = "";
        document.getElementById("new-node-ip").value = "";
        document.getElementById("new-node-tags").value = "";
        document.getElementById("new-node-shape").value = "circle";
        document.getElementById("new-node-pingable").checked = false;
        document.getElementById("new-node-ping-protocol").value = "http";
        document.getElementById("new-node-custom-url").value = "";
        document.getElementById("new-node-ping-timeout").value = "3000";
        document.getElementById("new-node-ping-options").style.display = "none";
        document.getElementById("new-node-custom-url-container").style.display = "none";
        newNodeIconTags = [];
        document.getElementById("new-node-icon-tags").style.display = "none";
        document.getElementById("new-node-icon-tags-list").innerHTML = "";
        addNodeModal.classList.add("active");
        document.getElementById("new-node-name").focus();
       });
       
       const canvasViewport = document.getElementById("canvas-viewport");
       if (canvasViewport) {
        canvasViewport.addEventListener("dblclick", (e) => {
         if (currentView.mode === "rack" && e.target.id === "map") {
          exitRack();
         }
        });
       }
       
       const layersBtn = document.getElementById("layers-btn");
       const layerModal = document.getElementById("layer-modal");
       const layerModalClose = document.getElementById("layer-modal-close");
       if (layersBtn && layerModal) {
        layersBtn.addEventListener("click", () => {
         layerModal.classList.add("active");
        });
       }
       if (layerModalClose && layerModal) {
        layerModalClose.addEventListener("click", () => {
         layerModal.classList.remove("active");
        });
       }
       if (layerModal) {
        layerModal.addEventListener("click", (e) => {
         if (e.target === layerModal) {
          layerModal.classList.remove("active");
         }
        });
       }
      
       const tabsBtn = document.getElementById("tabs-btn");
       const tabsModal = document.getElementById("tabs-modal");
       const tabsModalClose = document.getElementById("tabs-modal-close");
       if (tabsBtn && tabsModal) {
         tabsBtn.addEventListener("click", () => {
           displayTabs();
           tabsModal.classList.add("active");
         });
       }
       if (tabsModalClose && tabsModal) {
         tabsModalClose.addEventListener("click", () => {
           tabsModal.classList.remove("active");
         });
       }
       if (tabsModal) {
         tabsModal.addEventListener("click", (e) => {
           if (e.target === tabsModal) {
             tabsModal.classList.remove("active");
           }
         });
       }
       
       const rollbackBtn = document.getElementById("rollback-btn");
       const rollbackModal = document.getElementById("rollback-modal");
       const rollbackModalClose = document.getElementById("rollback-modal-close");
       if (rollbackBtn && rollbackModal) {
         rollbackBtn.addEventListener("click", () => {
           loadRollbackVersions();
           rollbackModal.classList.add("active");
         });
       }
       if (rollbackModalClose && rollbackModal) {
         rollbackModalClose.addEventListener("click", () => {
           rollbackModal.classList.remove("active");
         });
       }
       if (rollbackModal) {
         rollbackModal.addEventListener("click", (e) => {
           if (e.target === rollbackModal) {
             rollbackModal.classList.remove("active");
           }
         });
       }
       
       const auditLogBtn = document.getElementById("audit-log-btn");
       const auditLogModal = document.getElementById("audit-log-modal");
       const auditLogModalClose = document.getElementById("audit-log-modal-close");
       if (auditLogBtn && auditLogModal) {
         auditLogBtn.addEventListener("click", () => {
           loadAuditLog();
           displayAuditLog();
           auditLogModal.classList.add("active");
         });
       }
       if (auditLogModalClose && auditLogModal) {
         auditLogModalClose.addEventListener("click", () => {
           auditLogModal.classList.remove("active");
         });
       }
       if (auditLogModal) {
         auditLogModal.addEventListener("click", (e) => {
           if (e.target === auditLogModal) {
             auditLogModal.classList.remove("active");
           }
         });
       }
      
       const auditFilter = document.getElementById("audit-filter");
       if (auditFilter) {
         auditFilter.addEventListener("change", (e) => {
           displayAuditLog(e.target.value);
         });
       }
       
       const secretsBtn = document.getElementById("secrets-btn");
       const secretsModal = document.getElementById("secrets-modal");
       const secretsModalClose = document.getElementById("secrets-modal-close");
       if (secretsBtn && secretsModal) {
         secretsBtn.addEventListener("click", () => {
           displaySecrets();
           secretsModal.classList.add("active");
         });
       }
       if (secretsModalClose && secretsModal) {
         secretsModalClose.addEventListener("click", () => {
           secretsModal.classList.remove("active");
         });
       }
       if (secretsModal) {
         secretsModal.addEventListener("click", (e) => {
           if (e.target === secretsModal) {
             secretsModal.classList.remove("active");
           }
         });
       }
       
       const secretEditorModal = document.getElementById("secret-editor-modal");
       if (secretEditorModal) {
         secretEditorModal.addEventListener("click", (e) => {
           if (e.target === secretEditorModal) {
             closeSecretEditor();
           }
         });
       }
       
       ["physical", "logical", "security", "application"].forEach(layer => {
        const checkbox = document.getElementById(`layer-${layer}`);
        if (checkbox) {
         checkbox.addEventListener("change", applyLayerFilter);
        }
       });
       
       const layerSelect = document.getElementById("node-layer");
       if (layerSelect) {
        layerSelect.addEventListener("change", (e) => {
         if (currentNodeId) {
          pushUndo("change layer");
          NODE_DATA[currentNodeId].layer = e.target.value;
          forgeTheTopology();
         }
        });
       }
       
       const assignedRackSelect = document.getElementById("node-assigned-rack");
       if (assignedRackSelect) {
        assignedRackSelect.addEventListener("change", (e) => {
      if (currentNodeId) {
      pushUndo("change assigned rack");
      EDGE_DATA.list = EDGE_DATA.list.filter(edge => edge.from !== currentNodeId && edge.to !== currentNodeId);
      NODE_DATA[currentNodeId].assignedRack = e.target.value;
      forgeTheTopology();
      claimTheImmortal(currentNodeId);
      }
      });
       }
       
       const rackCapacitySelect = document.getElementById("node-rack-capacity");
       if (rackCapacitySelect) {
        rackCapacitySelect.addEventListener("change", (e) => {
         if (currentNodeId) {
          pushUndo("change rack capacity");
          NODE_DATA[currentNodeId].rackCapacity = e.target.value;
          forgeTheTopology();
         }
        });
       }
       
       const addRackBtn = document.getElementById("add-rack-btn");
       const addRackModal = document.getElementById("add-rack-modal");
       const addRackCancel = document.getElementById("add-rack-cancel");
       const addRackSave = document.getElementById("add-rack-save");
       
       if (addRackBtn && addRackModal) {
        addRackBtn.addEventListener("click", () => {
         document.getElementById("new-rack-name").value = "";
         document.getElementById("new-rack-ip").value = "";
         document.getElementById("new-rack-tags").value = "";
         document.getElementById("new-rack-shape").value = "server";
         document.getElementById("new-rack-capacity").value = "42";
         selectedRackIconData = null;
         document.getElementById('selected-rack-icon').style.display = 'none';
         addRackModal.classList.add("active");
         document.getElementById("new-rack-name").focus();
        });
       }
       
       if (addRackCancel && addRackModal) {
        addRackCancel.addEventListener("click", () => {
         addRackModal.classList.remove("active");
        });
       }
       
       if (addRackModal) {
        addRackModal.addEventListener("click", (e) => {
         if (e.target === addRackModal) {
          addRackModal.classList.remove("active");
         }
        });
       }
       
       if (addRackSave && addRackModal) {
        addRackSave.addEventListener("click", () => {
         const name = document.getElementById("new-rack-name").value.trim();
         const ip = document.getElementById("new-rack-ip").value.trim();
         const tagsStr = document.getElementById("new-rack-tags").value.trim();
         const shape = document.getElementById("new-rack-shape").value;
         const capacity = document.getElementById("new-rack-capacity").value;
         
         if (!name) {
          alert("Please enter a rack name.");
          return;
         }
         
         const tags = tagsStr ? tagsStr.split(",").map((t) => t.trim()).filter((t) => t) : [];
         let baseId = name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");
         if (!baseId) baseId = "rack";
         let nodeId = baseId;
         let counter = 1;
         while (NODE_DATA[nodeId]) {
          nodeId = baseId + "-" + counter;
          counter++;
         }
         
         pushUndo("add rack");
         
         NODE_DATA[nodeId] = {
          shape: shape,
          name: name,
          ip: ip || "",
          role: "Rack",
          tags: tags,
          notes: [],
          mac: "",
          rackUnit: "",
          uHeight: "1",
          layer: "physical",
          assignedRack: "",
          rackCapacity: capacity,
          isRack: true,
          locked: false,
          groupId: null
         };
         
         const viewWidth = CANVAS_WIDTH / canvasState.zoom;
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         const centerX = canvasState.panX + (viewWidth / 2);
         const centerY = canvasState.panY + (viewHeight / 2);
         savedPositions[nodeId] = {
          x: centerX,
          y: centerY
         };
         
         if (selectedRackIconData) {
          if (!savedStyles[nodeId]) {
           savedStyles[nodeId] = {};
          }
          if (!savedStyles[nodeId]['all']) {
           savedStyles[nodeId]['all'] = {};
          }
          savedStyles[nodeId]['all'].icon = {
           library: selectedRackIconData.library,
           name: selectedRackIconData.name
          };
          selectedRackIconData = null;
          document.getElementById('selected-rack-icon').style.display = 'none';
         }
         
         addRackModal.classList.remove("active");
         forgeTheTopology();
         claimTheImmortal(nodeId);
        });
        
        ["new-rack-name", "new-rack-ip", "new-rack-tags"].forEach((inputId) => {
         const input = document.getElementById(inputId);
         if (input) {
          input.addEventListener("keypress", (e) => {
           if (e.key === "Enter") {
            addRackSave.click();
           }
          });
         }
        });
       }
       
       addNodeCancel.addEventListener("click", () => {
        addNodeModal.classList.remove("active");
       });
       addNodeModal.addEventListener("click", (e) => {
        if (e.target === addNodeModal) {
         addNodeModal.classList.remove("active");
        }
       });
       addNodeSave.addEventListener("click", () => {
        const name = document.getElementById("new-node-name").value.trim();
        const ip = document.getElementById("new-node-ip").value.trim();
        const tagsStr = document.getElementById("new-node-tags").value.trim();
        const shape = document.getElementById("new-node-shape").value;
        const pingable = document.getElementById("new-node-pingable").checked;
        const pingProtocol = document.getElementById("new-node-ping-protocol").value;
        const pingCustomUrl = document.getElementById("new-node-custom-url").value.trim();
        const pingTimeout = parseInt(document.getElementById("new-node-ping-timeout").value) || 3000;
        
        if (!name) {
         alert("Please enter a node name.");
         return;
        }
        const tags = tagsStr ? tagsStr.split(",").map((t) => t.trim()).filter((t) => t) : [];
        if (newNodeIconTags.length > 0) {
         tags.push(...newNodeIconTags);
        }
        let baseId = name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");
        if (!baseId) baseId = "node";
        let nodeId = baseId;
        let counter = 1;
        while (NODE_DATA[nodeId]) {
         nodeId = baseId + "-" + counter;
         counter++;
        }
        NODE_DATA[nodeId] = {
         shape: shape || "circle",
         name: name,
         ip: ip || "0.0.0.0",
         role: "",
         tags: tags,
         notes: [],
         mac: "",
         rackUnit: "",
         uHeight: "1",
         ping: {
          enabled: pingable,
          protocol: pingProtocol,
          customUrl: pingCustomUrl,
          timeout: pingTimeout,
          status: 'unknown',
          lastCheck: null
         },
         locked: false, 
         groupId: null 
        };
        
        if (currentView.mode === "rack" && currentView.rackId) {
         NODE_DATA[nodeId].assignedRack = currentView.rackId;
         NODE_DATA[nodeId].layer = "physical";
        }
        
        if (selectedNodeIconData) {
         if (!savedStyles[nodeId]) savedStyles[nodeId] = {};
         if (!savedStyles[nodeId]['all']) savedStyles[nodeId]['all'] = {};
         savedStyles[nodeId]['all'].icon = {
          library: selectedNodeIconData.library,
          name: selectedNodeIconData.name
         };
         selectedNodeIconData = null;
         document.getElementById('selected-node-icon').style.display = 'none';
        }
        newNodeIconTags = [];
      const viewWidth = CANVAS_WIDTH / canvasState.zoom;
      const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
      const centerX = canvasState.panX + (viewWidth / 2);
      const centerY = canvasState.panY + (viewHeight / 2);
      savedPositions[nodeId] = {
      x: centerX,
      y: centerY
      };
        addNodeModal.classList.remove("active");
        forgeTheTopology();
        claimTheImmortal(nodeId);
       });
       ["new-node-name", "new-node-ip", "new-node-tags"].forEach(
        (inputId) => {
         document.getElementById(inputId).addEventListener("keypress", (e) => {
          if (e.key === "Enter") {
           addNodeSave.click();
          }
         });
        }, );
       
       document.getElementById('new-node-pingable').addEventListener('change', (e) => {
        const pingOptions = document.getElementById('new-node-ping-options');
        pingOptions.style.display = e.target.checked ? 'block' : 'none';
       });
       
       document.getElementById('new-node-ping-protocol').addEventListener('change', (e) => {
        const customUrlContainer = document.getElementById('new-node-custom-url-container');
        customUrlContainer.style.display = e.target.value === 'custom' ? 'block' : 'none';
       });
       
       document.getElementById('pick-rack-icon-btn').addEventListener('click', () => {
        openIconPicker((iconData) => {
         selectedRackIconData = iconData;
         const preview = document.getElementById('selected-rack-icon-preview');
         const container = document.getElementById('selected-rack-icon');
         const parser = new DOMParser();
         const doc = parser.parseFromString(iconData.svg, 'image/svg+xml');
         const svgEl = doc.querySelector('svg');
         preview.innerHTML = '';
         if (svgEl) {
          preview.appendChild(svgEl.cloneNode(true));
         }
         const nameSpan = document.createElement('span');
         nameSpan.textContent = iconData.name;
         preview.appendChild(nameSpan);
         container.style.display = 'block';
        });
       });
       
       document.getElementById('pick-node-icon-btn').addEventListener('click', () => {
        openIconPicker((iconData) => {
         selectedNodeIconData = iconData;
         const preview = document.getElementById('selected-node-icon-preview');
         const container = document.getElementById('selected-node-icon');
         const parser = new DOMParser();
         const doc = parser.parseFromString(iconData.svg, 'image/svg+xml');
         const svgEl = doc.querySelector('svg');
         preview.innerHTML = '';
         if (svgEl) {
          preview.appendChild(svgEl.cloneNode(true));
         }
         const nameSpan = document.createElement('span');
         nameSpan.textContent = iconData.name;
         preview.appendChild(nameSpan);
         container.style.display = 'block';
        });
       });
       document.getElementById('pick-tag-icon-btn').addEventListener('click', () => {
        if (!currentNodeId) return;
        openIconPicker((iconData) => {
         if (!currentNodeId || !NODE_DATA[currentNodeId]) return;
         if (!NODE_DATA[currentNodeId].tags) {
          NODE_DATA[currentNodeId].tags = [];
         }
         NODE_DATA[currentNodeId].tags.push({
          type: 'icon',
          library: iconData.library,
          name: iconData.name
         });
         forgeTheTopology();
         claimTheImmortal(currentNodeId);
        });
       });
       document.getElementById('pick-new-node-tag-icon-btn').addEventListener('click', () => {
        openIconPicker((iconData) => {
         newNodeIconTags.push({
          type: 'icon',
          library: iconData.library,
          name: iconData.name
         });
         const container = document.getElementById('new-node-icon-tags');
         const list = document.getElementById('new-node-icon-tags-list');
         const badge = document.createElement('div');
         badge.className = 'icon-badge';
         badge.style.cssText = 'display: inline-flex; align-items: center; gap: 6px; padding: 6px 10px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; font-size: 13px;';
         const iconPreview = document.createElement('div');
         iconPreview.style.cssText = 'width: 16px; height: 16px; display: flex; align-items: center; justify-content: center;';
         IconLibrary.getIcon(iconData.library, iconData.name).then(svg => {
          if (svg) {
           const parser = new DOMParser();
           const doc = parser.parseFromString(svg, 'image/svg+xml');
           const svgEl = doc.querySelector('svg');
           if (svgEl) {
            svgEl.setAttribute('width', '16');
            svgEl.setAttribute('height', '16');
            svgEl.style.fill = 'var(--text-main)';
            iconPreview.appendChild(svgEl);
           }
          }
         });
         const name = document.createElement('span');
         name.textContent = iconData.name;
         name.style.color = 'var(--text-soft)';
         const removeBtn = document.createElement('button');
         removeBtn.textContent = '√ó';
         removeBtn.style.cssText = 'background: none; border: none; color: var(--danger); cursor: pointer; font-size: 18px; line-height: 1; padding: 0 4px;';
         removeBtn.addEventListener('click', () => {
          const index = newNodeIconTags.findIndex(t => t.type === 'icon' && t.library === iconData.library && t.name === iconData.name);
          if (index > -1) {
           newNodeIconTags.splice(index, 1);
          }
          badge.remove();
          if (list.children.length === 0) {
           container.style.display = 'none';
          }
         });
         badge.appendChild(iconPreview);
         badge.appendChild(name);
         badge.appendChild(removeBtn);
         list.appendChild(badge);
         container.style.display = 'block';
        });
       });
       document.getElementById('pick-shape-icon-btn').addEventListener('click', () => {
        if (!currentNodeId) return;
        openIconPicker((iconData) => {
         if (!savedStyles[currentNodeId]) {
          savedStyles[currentNodeId] = {};
         }
         if (!savedStyles[currentNodeId][currentStyleScope]) {
          savedStyles[currentNodeId][currentStyleScope] = {};
         }
         savedStyles[currentNodeId][currentStyleScope].icon = {
          library: iconData.library,
          name: iconData.name
         };
         forgeTheTopology();
        });
       });
       document.getElementById('add-tag-btn').addEventListener('click', () => {
        if (!currentNodeId) return;
        if (!NODE_DATA[currentNodeId]) return;
        const input = document.getElementById('new-tag-input');
        const tagText = input.value.trim();
        if (!tagText) return;
        if (!NODE_DATA[currentNodeId].tags) {
         NODE_DATA[currentNodeId].tags = [];
        }
        NODE_DATA[currentNodeId].tags.push(tagText);
        input.value = '';
        forgeTheTopology();
        claimTheImmortal(currentNodeId);
       });
      
      function saveRollbackVersion(description = "Auto-save") {
        const version = {
          timestamp: Date.now(),
          description,
          data: captureTheQuickening()
        };
        
        try {
          const stored = localStorage.getItem(ROLLBACK_STORAGE_KEY);
          rollbackVersions = stored ? JSON.parse(stored) : [];
        } catch (e) {
          rollbackVersions = [];
        }
        
        rollbackVersions.unshift(version);
        
        if (rollbackVersions.length > MAX_ROLLBACK_VERSIONS) {
          rollbackVersions = rollbackVersions.slice(0, MAX_ROLLBACK_VERSIONS);
        }
        
        try {
          localStorage.setItem(ROLLBACK_STORAGE_KEY, JSON.stringify(rollbackVersions));
        } catch (e) {
          console.warn("Failed to save rollback version:", e);
        }
      }
      
      function loadRollbackVersions() {
        try {
          const stored = localStorage.getItem(ROLLBACK_STORAGE_KEY);
          rollbackVersions = stored ? JSON.parse(stored) : [];
          displayRollbackVersions();
        } catch (e) {
          console.warn("Failed to load rollback versions:", e);
          rollbackVersions = [];
        }
      }
      
      function displayRollbackVersions() {
        const listEl = document.getElementById("rollback-list");
        if (!listEl) return;
        
        if (rollbackVersions.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No version history yet. Versions are saved automatically when you save the file.</div>';
          return;
        }
        
        listEl.innerHTML = rollbackVersions.map((version, index) => {
          const date = new Date(version.timestamp);
          const timeStr = date.toLocaleString();
          const nodeCount = Object.keys(version.data.nodeData || {}).length;
          const edgeCount = (version.data.edgeData?.list || []).length;
          
          return `
            <div class="version-item" onclick="restoreRollbackVersion(${index})">
              <div class="version-info">
                <div class="timestamp">${timeStr}</div>
                <div class="details">${version.description} ‚Ä¢ ${nodeCount} nodes ‚Ä¢ ${edgeCount} connections</div>
              </div>
              <div class="version-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteRollbackVersion(${index})" title="Delete this version">üóëÔ∏è</button>
              </div>
            </div>
          `;
        }).join('');
      }
      
      function restoreRollbackVersion(index) {
        if (!confirm(`Restore version from ${new Date(rollbackVersions[index].timestamp).toLocaleString()}?\n\nYour current work will be lost unless you save first.`)) {
          return;
        }
        
        const version = rollbackVersions[index];
        const data = version.data;
        
        NODE_DATA = data.nodeData || {};
        EDGE_DATA = data.edgeData || { list: [] };
        RECT_DATA = data.rectData || { list: [] };
        TEXT_DATA = data.textData || { list: [] };
        EDGE_LEGEND = data.edgeLegend || {};
        savedPositions = data.nodePositions || {};
        savedSizes = data.nodeSizes || {};
        savedStyles = data.nodeStyles || {};
        PAGE_STATE = data.page || PAGE_STATE;
        
        if (data.canvas) {
          canvasState.zoom = data.canvas.zoom;
          canvasState.panX = data.canvas.panX;
          canvasState.panY = data.canvas.panY;
        }
        
        wieldThePower();
        forgeTheTopology();
        
        document.getElementById("rollback-modal").classList.remove("active");
        
        logAuditEvent("rollback", `Restored version from ${new Date(version.timestamp).toLocaleString()}`);
      }
      
      function deleteRollbackVersion(index) {
        if (!confirm("Delete this version from history?")) return;
        
        rollbackVersions.splice(index, 1);
        try {
          localStorage.setItem(ROLLBACK_STORAGE_KEY, JSON.stringify(rollbackVersions));
        } catch (e) {
          console.warn("Failed to delete version:", e);
        }
        displayRollbackVersions();
      }
      
      function clearRollbackHistory() {
        if (!confirm("Clear all version history?\n\nThis cannot be undone.")) return;
        
        rollbackVersions = [];
        localStorage.removeItem(ROLLBACK_STORAGE_KEY);
        displayRollbackVersions();
      }
      
      function createManualSnapshot() {
        const description = prompt("Enter a description for this snapshot:", "Manual snapshot");
        if (!description) return;
        
        saveRollbackVersion(description);
        displayRollbackVersions();
      }
      
      function switchTab(index) {
        if (index === currentTabIndex) return;
        
        const currentTab = documentTabs[currentTabIndex];
        currentTab.nodes = JSON.parse(JSON.stringify(NODE_DATA));
        currentTab.edges = JSON.parse(JSON.stringify(EDGE_DATA));
        currentTab.positions = JSON.parse(JSON.stringify(savedPositions));
        currentTab.sizes = JSON.parse(JSON.stringify(savedSizes));
        currentTab.styles = JSON.parse(JSON.stringify(savedStyles));
        currentTab.legend = JSON.parse(JSON.stringify(EDGE_LEGEND));
        currentTab.rects = JSON.parse(JSON.stringify(RECT_DATA));
        currentTab.texts = JSON.parse(JSON.stringify(TEXT_DATA));
        currentTab.pageState = JSON.parse(JSON.stringify(PAGE_STATE));
      
        currentTabIndex = index;
        const newTab = documentTabs[index];
        NODE_DATA = JSON.parse(JSON.stringify(newTab.nodes));
        EDGE_DATA = JSON.parse(JSON.stringify(newTab.edges));
        savedPositions = JSON.parse(JSON.stringify(newTab.positions));
        savedSizes = JSON.parse(JSON.stringify(newTab.sizes));
        savedStyles = JSON.parse(JSON.stringify(newTab.styles));
        EDGE_LEGEND = JSON.parse(JSON.stringify(newTab.legend));
        RECT_DATA = JSON.parse(JSON.stringify(newTab.rects));
        TEXT_DATA = JSON.parse(JSON.stringify(newTab.texts));
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, newTab.pageState || {});
        wieldThePower();
        document.title = newTab.name;
        document.getElementById("page-title").textContent = newTab.name;
        forgeTheTopology();
        displayTabs();
        
        logAuditEvent("tab", `Switched to tab: ${newTab.name}`);
      }
      
      function createNewTab() {
        const nameInput = document.getElementById("new-tab-name");
        const name = nameInput.value.trim();
        
        if (!name) {
          alert("Please enter a tab name");
          return;
        }
        
        const newTab = {
          id: `tab-${Date.now()}`,
          name,
          nodes: {},
          edges: { list: [] },
          positions: {},
          sizes: {},
          styles: {},
          legend: {},
          rects: { list: [] },
          texts: { list: [] },
      pageState: null
        };
        
        documentTabs.push(newTab);
        nameInput.value = "";
        displayTabs();
        
        logAuditEvent("tab", `Created new tab: ${name}`);
      }
      
      function renameTab(index) {
        const tab = documentTabs[index];
        const newName = prompt("Enter new name:", tab.name);
        if (!newName || newName === tab.name) return;
        
        tab.name = newName;
        displayTabs();
        
        logAuditEvent("tab", `Renamed tab to: ${newName}`);
      }
      
      function deleteTab(index) {
        if (documentTabs.length === 1) {
          alert("Cannot delete the last tab");
          return;
        }
        
        if (!confirm(`Delete tab "${documentTabs[index].name}"?`)) return;
        
        documentTabs.splice(index, 1);
        
        if (currentTabIndex >= documentTabs.length) {
          currentTabIndex = documentTabs.length - 1;
        }
        
        if (currentTabIndex === index) {
          switchTab(currentTabIndex);
        }
        
        displayTabs();
      }
      
      function displayTabs() {
        const listEl = document.getElementById("tabs-list");
        if (!listEl) return;
        
        listEl.innerHTML = documentTabs.map((tab, index) => {
          const nodeCount = Object.keys(tab.nodes).length;
          const edgeCount = tab.edges.list.length;
          const isActive = index === currentTabIndex;
          
          return `
            <div class="tab-item ${isActive ? 'active' : ''}" onclick="switchTab(${index})">
              <div class="tab-name">${tab.name}</div>
              <div class="tab-stats">${nodeCount} nodes ‚Ä¢ ${edgeCount} connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(${index})" title="Rename tab">‚úèÔ∏è</button>
                ${documentTabs.length > 1 ? '<button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(${index})" title="Delete tab">üóëÔ∏è</button>' : ''}
              </div>
            </div>
          `;
        }).join('');
      }
      
      function logAuditEvent(type, description, details = {}) {
        const event = {
          timestamp: Date.now(),
          type,
          description,
          details,
          tab: documentTabs[currentTabIndex]?.name || "Main"
        };
        
        auditLog.unshift(event);
        
        if (auditLog.length > MAX_AUDIT_ENTRIES) {
          auditLog = auditLog.slice(0, MAX_AUDIT_ENTRIES);
        }
        
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to save audit log:", e);
        }
      }
      
      function loadAuditLog() {
        try {
          const stored = localStorage.getItem(AUDIT_STORAGE_KEY);
          auditLog = stored ? JSON.parse(stored) : [];
        } catch (e) {
          console.warn("Failed to load audit log:", e);
          auditLog = [];
        }
      }
      
      function displayAuditLog(filter = "all") {
        const listEl = document.getElementById("audit-log-list");
        if (!listEl) return;
        
        const filtered = filter === "all" ? auditLog : auditLog.filter(e => e.type === filter);
        
        if (filtered.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No audit entries yet</div>';
          return;
        }
        
        listEl.innerHTML = filtered.map(event => {
          const date = new Date(event.timestamp);
          const timeStr = date.toLocaleString();
          
          return `<div class="audit-entry ${event.type}">
              <div class="time">[${timeStr}] ${event.tab}</div>
              <div class="action">[${event.type.toUpperCase()}] ${event.description}</div>
            </div>
          `;
        }).join('');
      }
      
      function clearAuditLog() {
        if (!confirm("Clear all audit log entries?\n\nThis cannot be undone.")) return;
        
        auditLog = [];
        localStorage.removeItem(AUDIT_STORAGE_KEY);
        displayAuditLog();
      }
      
      function exportAuditLog() {
        if (auditLog.length === 0) {
          alert("No audit entries to export");
          return;
        }
        
        const csv = [
          ["Timestamp", "Tab", "Type", "Description"],
          ...auditLog.map(e => [
            new Date(e.timestamp).toISOString(),
            e.tab,
            e.type,
            e.description
          ])
        ].map(row => row.map(cell => `"${cell}"`).join(",")).join("\n");
        
        const blob = new Blob([csv], { type: "text/csv" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `audit-log-${Date.now()}.csv`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }
      
      let currentSecretName = null;
      
      function createNewSecret() {
        const nameInput = document.getElementById("new-secret-name");
        const name = nameInput.value.trim();
        
        if (!name) {
          alert("Please enter a note name");
          return;
        }
        
        if (encryptedSections[name]) {
          alert("A note note with this name already exists");
          return;
        }
        
        currentSecretName = name;
        encryptedSections[name] = { encrypted: false, data: "" };
        nameInput.value = "";
        
        document.getElementById("secret-editor-title").textContent = `New note: ${name}`;
        document.getElementById("secret-editor-content").value = "";
        document.getElementById("secrets-modal").classList.remove("active");
        document.getElementById("secret-editor-modal").classList.add("active");
        
        displaySecrets();
      }
      
      function editSecret(name) {
        currentSecretName = name;
        const section = encryptedSections[name];
        
        if (section.encrypted) {
          const password = prompt(`Enter password to decrypt "${name}":`);
          if (!password) return;
          
          try {
            decryptData(section.data, password).then(decrypted => {
              document.getElementById("secret-editor-title").textContent = `Edit Secret: ${name}`;
              document.getElementById("secret-editor-content").value = decrypted;
              document.getElementById("secrets-modal").classList.remove("active");
              document.getElementById("secret-editor-modal").classList.add("active");
            }).catch(e => {
              alert("Failed to decrypt. Wrong password?");
            });
          } catch (e) {
            alert("Failed to decrypt. Wrong password?");
          }
        } else {
          document.getElementById("secret-editor-title").textContent = `Edit note: ${name}`;
          document.getElementById("secret-editor-content").value = section.data;
          document.getElementById("secrets-modal").classList.remove("active");
          document.getElementById("secret-editor-modal").classList.add("active");
        }
      }
      
      async function saveSecret() {
        if (!currentSecretName) return;
        
        const content = document.getElementById("secret-editor-content").value;
        const autoEncrypt = document.getElementById("secret-auto-encrypt").checked;
        
        if (autoEncrypt) {
          const password = prompt(`Enter password to encrypt "${currentSecretName}":`);
          if (!password) return;
          
          const confirmPassword = prompt("Confirm password:");
          if (password !== confirmPassword) {
            alert("Passwords do not match");
            return;
          }
          
          try {
            const encrypted = await encryptData(content, password);
            encryptedSections[currentSecretName] = { encrypted: true, data: encrypted };
          } catch (e) {
            alert("Encryption failed: " + e.message);
            return;
          }
        } else {
          encryptedSections[currentSecretName] = { encrypted: false, data: content };
        }
        
        closeSecretEditor();
        displaySecrets();
        
        logAuditEvent("secret", `Saved note section: ${currentSecretName}`);
      }
      
      function closeSecretEditor() {
        document.getElementById("secret-editor-modal").classList.remove("active");
        document.getElementById("secrets-modal").classList.add("active");
        currentSecretName = null;
      }
      
      function deleteSecret(name) {
        if (!confirm(`Delete note "${name}"?`)) return;
        
        delete encryptedSections[name];
        displaySecrets();
        
        logAuditEvent("secret", `Deleted note: ${name}`);
      }
      
      function displaySecrets() {
        const listEl = document.getElementById("secrets-list");
        if (!listEl) return;
        
        const secrets = Object.keys(encryptedSections);
        
        if (secrets.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No notes yet</div>';
          return;
        }
        
        listEl.innerHTML = secrets.map(name => {
          const section = encryptedSections[name];
          const status = section.encrypted ? "üîí Encrypted" : "üîì Plaintext";
          
          return `
            <div class="secret-item">
              <div class="secret-name">${name}</div>
              <div class="secret-status">${status}</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="editSecret('${name}')" title="Edit note">‚úèÔ∏è</button>
                <button class="btn-cancel" onclick="deleteSecret('${name}')" title="Delete note">üóëÔ∏è</button>
              </div>
            </div>
          `;
        }).join('');
      }
      
       const clearAllBtn = document.getElementById("clear-all-btn");
       const clearAllModal = document.getElementById("clear-all-modal");
       const clearAllCancel = document.getElementById("clear-all-cancel");
       const clearAllConfirm = document.getElementById("clear-all-confirm");
       clearAllBtn.addEventListener("click", () => {
        clearAllModal.classList.add("active");
       });
       clearAllCancel.addEventListener("click", () => {
        clearAllModal.classList.remove("active");
       });
       clearAllModal.addEventListener("click", (e) => {
        if (e.target === clearAllModal) {
         clearAllModal.classList.remove("active");
        }
       });
       clearAllConfirm.addEventListener("click", () => {
        NODE_DATA = {};
        EDGE_DATA = {
         list: []
        };
        EDGE_LEGEND = {};
        RECT_DATA = { list: [] };
        TEXT_DATA = { list: [] };
        savedPositions = {};
        savedSizes = {};
        savedStyles = {};
        clearAllModal.classList.remove("active");
      
      autoPingEnabled = false;
      autoPingInterval = 30;
      PAGE_STATE.autoPingEnabled = false;
      PAGE_STATE.autoPingInterval = autoPingInterval;
      
      stopAutoPing();
      
      document.getElementById("auto-ping-enabled").checked = false;
      document.getElementById("auto-ping-settings").style.display = "none";
      document.getElementById("auto-ping-interval").value = autoPingInterval;
        forgeTheTopology();
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.display = "none";
        currentNodeId = null;
        currentEdgeId = null;
        currentTextId = null;
       });
       (function addDeleteNodeButton() {
        const nodePanel = document.getElementById("node-panel");
        if (!nodePanel) return;
        if (document.getElementById("delete-node-btn")) return;
        const deleteBtn = document.createElement("button");
        deleteBtn.id = "delete-node-btn";
        deleteBtn.textContent = "Delete Node";
        deleteBtn.style.cssText = "margin-top:15px; padding:10px 16px; background:var(--danger); color:#fff; border:none; border-radius:6px; cursor:pointer; font-size:clamp(14px,1.6vw,18px); font-weight:600; width:100%;";
        deleteBtn.addEventListener("click", () => {
         if (!currentNodeId) return;
         challengeTheImmortal(`Delete node "${NODE_DATA[currentNodeId]?.name || currentNodeId}" and all its connections?`,
          () => {
           EDGE_DATA.list = EDGE_DATA.list.filter(
            (e) => e.from !== currentNodeId && e.to !== currentNodeId, );
           delete NODE_DATA[currentNodeId];
           delete savedPositions[currentNodeId];
           delete savedSizes[currentNodeId];
           delete savedStyles[currentNodeId];
           currentNodeId = null;
           currentEdgeId = null;
           forgeTheTopology();
           const remainingNodes = Object.keys(NODE_DATA);
           if (remainingNodes.length > 0) {
            claimTheImmortal(remainingNodes[0]);
           } else {
            document.getElementById("node-panel").style.display = "none";
            document.getElementById("edge-panel").style.display = "none";
            document.getElementById("topology-toolbar", ).style.display = "none";
           }
          }, );
        });
        nodePanel.appendChild(deleteBtn);
       })();
      
       function screenshotCanvas() {
        const svg = document.getElementById("map");
        const svgClone = svg.cloneNode(true);
        const viewBox = svg.getAttribute("viewBox").split(" ").map(Number);
        const [x, y, width, height] = viewBox;
        svgClone.setAttribute("width", width);
        svgClone.setAttribute("height", height);
        svgClone.setAttribute("viewBox", `${x} ${y} ${width} ${height}`);
        const wrapper = document.createElement("div");
        wrapper.style.position = "absolute";
        wrapper.style.left = "-9999px";
        wrapper.appendChild(svgClone);
        document.body.appendChild(wrapper);
      
        function inlineStyles(original, clone) {
         const elements = original.querySelectorAll("*");
         const clonedElements = clone.querySelectorAll("*");
         const rootStyles = getComputedStyle(document.documentElement);
         const bgColor = rootStyles.getPropertyValue("--bg").trim() || "#050608";
         const bgRect = document.createElementNS("http://www.w3.org/2000/svg", "rect", );
         bgRect.setAttribute("x", x);
         bgRect.setAttribute("y", y);
         bgRect.setAttribute("width", width);
         bgRect.setAttribute("height", height);
         bgRect.setAttribute("fill", bgColor);
         clone.insertBefore(bgRect, clone.firstChild);
         elements.forEach((el, index) => {
          const clonedEl = clonedElements[index];
          if (!clonedEl) return;
          const computedStyle = getComputedStyle(el);
          const svgProps = ["fill", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin", "opacity", "font-family", "font-size", "font-weight", "font-style", "text-anchor", "dominant-baseline", "marker-start", "marker-end", ];
          svgProps.forEach((prop) => {
           const value = computedStyle.getPropertyValue(prop);
           if (value && value !== "none" && value !== "normal") {
            clonedEl.style[prop] = value;
           }
          });
          clonedEl.removeAttribute("class");
         });
        }
        inlineStyles(svg, svgClone);
        const svgData = new XMLSerializer().serializeToString(svgClone);
        document.body.removeChild(wrapper);
        const svgBlob = new Blob([svgData], {
         type: "image/svg+xml;charset=utf-8",
        });
        const url = URL.createObjectURL(svgBlob);
        const img = new Image();
        img.onload = function() {
         const canvas = document.createElement("canvas");
         canvas.width = width;
         canvas.height = height;
         const ctx = canvas.getContext("2d");
         ctx.drawImage(img, 0, 0);
         canvas.toBlob(function(blob) {
          const link = document.createElement("a");
          const timestamp = new Date().toISOString().slice(0, 10);
          link.download = `topology-${timestamp}.png`;
          link.href = URL.createObjectURL(blob);
          link.click();
          URL.revokeObjectURL(url);
          URL.revokeObjectURL(link.href);
         }, "image/png");
        };
        img.onerror = function() {
         console.error("Failed to load SVG image");
         alert("Screenshot failed. Please try again.");
         URL.revokeObjectURL(url);
        };
        img.src = url;
       }
      
       function exportCanvasSVG() {
        const svg = document.getElementById("map");
        const svgClone = svg.cloneNode(true);
        const viewBox = svg.getAttribute("viewBox").split(" ").map(Number);
        const [x, y, width, height] = viewBox;
        svgClone.setAttribute("width", width);
        svgClone.setAttribute("height", height);
        const rootStyles = getComputedStyle(document.documentElement);
        const bgColor = rootStyles.getPropertyValue("--bg").trim() || "#050608";
        const bgRect = document.createElementNS("http://www.w3.org/2000/svg", "rect", );
        bgRect.setAttribute("x", x);
        bgRect.setAttribute("y", y);
        bgRect.setAttribute("width", width);
        bgRect.setAttribute("height", height);
        bgRect.setAttribute("fill", bgColor);
        svgClone.insertBefore(bgRect, svgClone.firstChild);
        const wrapper = document.createElement("div");
        wrapper.style.position = "absolute";
        wrapper.style.left = "-9999px";
        wrapper.appendChild(svgClone);
        document.body.appendChild(wrapper);
        const elements = svg.querySelectorAll("*");
        const clonedElements = svgClone.querySelectorAll("*");
        elements.forEach((el, index) => {
         const clonedEl = clonedElements[index];
         if (!clonedEl) return;
         const computedStyle = getComputedStyle(el);
         const svgProps = ["fill", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin", "opacity", "font-family", "font-size", "font-weight", "font-style", "text-anchor", "dominant-baseline", "marker-start", "marker-end", ];
         svgProps.forEach((prop) => {
          const value = computedStyle.getPropertyValue(prop);
          if (value && value !== "none" && value !== "normal") {
           clonedEl.setAttribute(prop, value);
          }
         });
         clonedEl.removeAttribute("class");
        });
        const svgData = new XMLSerializer().serializeToString(svgClone);
        document.body.removeChild(wrapper);
        const blob = new Blob([svgData], {
         type: "image/svg+xml;charset=utf-8",
        });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        const timestamp = new Date().toISOString().slice(0, 10);
        link.download = `topology-${timestamp}.svg`;
        link.href = url;
        link.click();
        URL.revokeObjectURL(url);
       }
      let resizeTimeout;
       window.addEventListener('resize', () => {
       clearTimeout(resizeTimeout);
       resizeTimeout = setTimeout(() => {
       updateDrawToolbarVisibility();
       updateTopologyToolbarVisibility();
       }, 100);
      });	   
    </script>
  
</body></html>