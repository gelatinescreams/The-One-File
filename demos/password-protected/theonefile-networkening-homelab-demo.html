<!DOCTYPE html> 
 <html lang="en" style="--panel: #2f0e0e; --panel-alt: #10141b; --accent: #a75252; --danger: #f56565; --text-main: #e2e8f0; --text-soft: #94a3b8; --topbar-bg: rgba(9, 12, 20, 0.9); --topbar-border: #1f2533; --topbar-height: 112px; --sidebar-width: 350px; --mobile-footer-height: 40vh; --draw-toolbar-height: 45px; --sidebar-bg: #10141b; --btn-bg: #0b0e13; --btn-text: #e2e8f0; --tag-fill: #1e293b; --tag-text: #e2e8f0; --tag-border: #475569; --input-bg: #0b0e13; --input-text: #e2e8f0; --input-border: #1f2937; --input-font: Inter, system-ui, sans-serif; --input-font-size: 14px; --toolbar-bg: #441215; --toolbar-border: #1f2937; --toolbar-text: #94a3b8; --toolbar-btn-bg: #0b0e13; --toolbar-btn-text: #e2e8f0; --minimap-dots: #94a3b8; --canvas-hint-bg: #0f172a; --canvas-hint-color: #94a3b8; --node-fill: #1e293b; --node-stroke: #475569; --node-title: #e2e8f0; --node-sub: #94a3b8; --node-title-size: 18px; --node-sub-size: 13px; --node-font: Inter, system-ui, sans-serif; --default-edge: #475569; --selection-handle: #f59e0b; --selection-handle-size: 8px; --group-indicator: #4fd1c5;"><head>
    <meta charset="UTF-8">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>The One File</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!--
      * ==================================================================================
      * The One File: The Networkening
      * !!!!!!!!!!!!!!!!!!!NOTE: THIS IS THE ONLINE VERSION!!!!!!!!!!!!!!!!!!!!!!
      * Online version uses 3 cdn calls from cdn.jsdelivr.net to display additional icons
      * Since 3.0 Online version uses http as a form of ping to display uptime
      * "There can be only one". A all in one file topology maker.
      *
      * This is your last backup when all others fail. A completely self-contained
      * network topology visualization tool that works as a single HTML file.
      * Open it anywhere, anytime and the idea lives forever.
      * ==================================================================================
      -->
    <style>
      :root {
      color-scheme: dark;
      --bg: #050608;
      --panel: #0b0e13;
      --panel-alt: #10141b;
      --accent: #4fd1c5;
      --danger: #f56565;
      --text-main: #e2e8f0;
      --text-soft: #94a3b8;
      --edge-main: #475569;
      --node-min: 35px;
      --node-max: 70px;
      --topbar-bg: rgba(9, 12, 20, 0.9);
      --topbar-border: #1f2533;
      }
	  html, body, svg, .map-container {
      touch-action: none;
      }
      * {
      box-sizing: border-box;
      user-select: none;
      }
      input,
      textarea,
      [contenteditable="true"] {
      user-select: text;
      -webkit-user-select: text;
      }
      body {
      margin: 0;
      font-family: system-ui, sans-serif;
      background: radial-gradient(circle at top, #1e2532 0, #050608 70%);
      color: var(--text-main);
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
      }
      header {
      padding: 0 20px;
      height: var(--topbar-height, 52px);
      min-height: var(--topbar-height, 52px);
      background: var(--topbar-bg);
      backdrop-filter: blur(6px);
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid var(--topbar-border);
      gap: 16px;
      }
      .title-block {
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-width: 0;
      }
      header h1 {
      font-size: clamp(22px, 3vw, 32px);
      margin: 0;
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
      }
      .editable-page-title {
      cursor: pointer;
      transition: opacity 0.2s;
      }
      .editable-page-title:hover {
      opacity: 0.7;
      }
      .save-row {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      }
      .save-btn {
      padding: 6px 12px;
      background: var(--accent);
      color: var(--bg);
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      white-space: nowrap;
      }
      .save-btn:hover {
      opacity: 0.9;
      }
      .help-icon {
      width: 22px;
      height: 22px;
      border-radius: 50%;
      border: 1px solid var(--edge-main);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      cursor: pointer;
      color: var(--text-soft);
      background: rgba(15, 23, 42, 0.9);
      flex-shrink: 0;
      }
      .help-icon:hover {
      color: var(--accent);
      border-color: var(--accent);
      }
      #settings-btn {
      background: var(--btn-bg, var(--panel));
      color: var(--btn-text, var(--text-main));
      border: 1px solid var(--edge-main);
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 16px;
      flex-shrink: 0;
      }
      #settings-btn:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .header-resizer {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 6px;
      background: transparent;
      cursor: row-resize;
      z-index: 1000;
      transition: background 0.2s;
      }
      .header-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .header-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      .sidebar-resizer {
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 6px;
      background: transparent;
      cursor: col-resize;
      z-index: 1000;
      transition: background 0.2s;
      }
      .sidebar-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .sidebar-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      .mobile-footer-resizer {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 6px;
      background: transparent;
      cursor: row-resize;
      z-index: 1000;
      transition: background 0.2s;
      display: none;
      }
      .mobile-footer-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .mobile-footer-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      @media (max-width: 900px) {
      .mobile-footer-resizer {
      display: block;
      height: 12px;
      }
      .sidebar-resizer {
      display: none;
      }
      .header-resizer {
      height: 12px;
      }
      }
      @media (pointer: coarse) {
      .header-resizer {
      height: 16px;
      }
      .mobile-footer-resizer {
      height: 16px;
      }
      .sidebar-resizer {
      width: 16px;
      }
      }
      .resizer-icon {
      position: absolute;
      opacity: 0.5;
      transition: opacity 0.2s, transform 0.2s;
      pointer-events: none;
      fill: var(--accent);
      }
      .header-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .sidebar-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .mobile-footer-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .header-resizer:hover .resizer-icon,
      .sidebar-resizer:hover .resizer-icon,
      .mobile-footer-resizer:hover .resizer-icon {
      opacity: 1;
      }
      .header-resizer.resizing .resizer-icon,
      .sidebar-resizer.resizing .resizer-icon,
      .mobile-footer-resizer.resizing .resizer-icon {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1.2);
      }
      body.resizing {
      user-select: none;
      }
      body.resizing * {
      cursor: inherit !important;
      pointer-events: none;
      }
      header {
      position: relative;
      }
      .details-panel {
      position: relative;
      }
      main {
      display: grid;
      grid-template-columns: 1fr var(--sidebar-width, 350px);
      flex: 1;
      }
      main.sidebar-collapsed {
      grid-template-columns: 1fr 0;
      }
      @media (max-width: 900px) {
      main {
      grid-template-columns: 1fr;
      grid-template-rows: calc(100vh - var(--topbar-height, 52px) - var(--mobile-footer-height, 40vh)) var(--mobile-footer-height, 40vh);
      }
      main.sidebar-collapsed {
      grid-template-rows: 1fr 0;
      }
      .details-panel {
      max-height: var(--mobile-footer-height, 40vh);
      height: 100%;
      }
      }
      .topology-panel {
      background: var(--panel);
      border-right: 1px solid #111827;
      position: relative;
      overflow: hidden;
      }
      .topology-toolbar {
      position: absolute;
      top: 10px;
      right: 10px;
      display: none;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      z-index: 99;
      font-size: 13px;
      color: var(--toolbar-text, #94a3b8);
      }
      .topology-toolbar label {
      color: var(--toolbar-text, var(--text-soft));
      }
      .topology-toolbar select {
      padding: 4px 6px;
      background: var(--toolbar-btn-bg, var(--panel));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 13px;
      cursor: pointer;
      }
      .topology-toolbar button {
      padding: 4px 10px;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      }
      .topology-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .bulk-toolbar-desktop,
      .bulk-toolbar-mobile {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 9999;
      }
      .bulk-toolbar-desktop {
      position: absolute;
      top: 10px;
      right: 10px;
      bottom: auto;
      left: auto;
      transform: none;
      }
      @media (min-width: 768px) {
      .bulk-toolbar-mobile {
      display: none !important;
      }
      }
      .bulk-action-btn {
      padding: 16px;
      background: var(--panel-main);
      border: 1px solid var(--edge-main);
      border-radius: 8px;
      color: var(--text-main);
      font-size: 24px;
      cursor: pointer;
      text-align: center;
      line-height: 1.2;
      }
      .bulk-action-btn:active {
      transform: scale(0.95);
      background: var(--accent);
      }
      .draw-toolbar {
      position: absolute;
      top: 10px;
      left: 10px;
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 8px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      z-index: 99;
      font-size: 13px;
      pointer-events: auto;
      color: var(--toolbar-text, #94a3b8);
      }
      .draw-toolbar button {
      padding: 4px 8px;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      }
      .draw-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .draw-toolbar input[type="color"] {
      width: 30px;
      height: 22px;
      border-radius: 4px;
      border: 1px solid var(--edge-main);
      padding: 0;
      background: transparent;
      cursor: pointer;
      }
      .draw-toolbar select {
      padding: 4px 6px;
      background: var(--toolbar-btn-bg, var(--panel));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 13px;
      cursor: pointer;
      }
      .legend-container {
      position: absolute;
      left: 10px;
      bottom: 10px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      padding: 8px 10px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      font-size: 12px;
      z-index: 20;
      max-width: 260px;
      pointer-events: auto;
      color: var(--toolbar-text, #94a3b8);
      }
      .legend-container {
      padding-right: 22px;
      }
      @media (max-width: 900px) {
      .legend-container {
      max-height: calc(100vh - var(--topbar-height, 100px) - 120px);
      overflow-y: auto;
      }
      }
      @media (max-width: 900px) {
      .bulk-toolbar-desktop,
      .topology-toolbar {
      display: none !important;
      }
      }
      .legend-close-btn {
      position: absolute;
      top: 5px;
      right: 5px;
      width: 18px;
      height: 18px;
      border-radius: 999px;
      border: 1px solid var(--edge-main);
      background: var(--panel-alt);
      color: var(--text-soft);
      font-size: 11px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      }
      .legend-close-btn:hover {
      background: var(--danger);
      color: #fff;
      }
      .legend-mini-btn {
      position: absolute;
      left: 10px;
      padding: 4px 8px;
      border-radius: 4px;
      border: 1px solid var(--toolbar-border, #1f2937);
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 11px;
      cursor: pointer;
      z-index: 20;
      display: none;
      transition: all 0.2s;
      }
      .legend-mini-btn:hover,
      .legend-mini-btn:active {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
      }
      .legend-title {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: var(--toolbar-text, var(--text-soft));
      margin-bottom: 2px;
      }
      .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      }
      .legend-swatch {
      width: 14px;
      height: 14px;
      border-radius: 3px;
      border: 1px solid #020617;
      flex-shrink: 0;
      }
      .legend-label {
      outline: none;
      cursor: text;
      flex: 1;
      min-width: 60px;
      user-select: text;
      -webkit-user-select: text;
      }
      .legend-label.editing {
      border-bottom: 1px dashed var(--accent);
      }
      .canvas-viewport {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      overflow: hidden;
      }
      .canvas-viewport.panning {
      cursor: grabbing !important;
      }
      .canvas-viewport.panning * {
      cursor: grabbing !important;
      }
      .canvas-viewport svg {
      width: 100%;
      height: 100%;
      display: block;
      background: linear-gradient(rgba(71, 85, 105, 0.1) 1px,
      transparent 1px),
      linear-gradient(90deg,
      rgba(71, 85, 105, 0.1) 1px,
      transparent 1px),
      linear-gradient(rgba(71, 85, 105, 0.05) 1px, transparent 1px),
      linear-gradient(90deg,
      rgba(71, 85, 105, 0.05) 1px,
      transparent 1px);
      background-size:
      100px 100px,
      100px 100px,
      20px 20px,
      20px 20px;
      background-position:
      -1px -1px,
      -1px -1px,
      -1px -1px,
      -1px -1px;
      }
      .zoom-toolbar {
      display: flex;
      gap: 4px;
      padding: 6px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      }
      .zoom-toolbar button {
      width: 32px;
      height: 32px;
      padding: 0;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 18px;
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
      }
      .zoom-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .zoom-toolbar .zoom-level {
      font-size: 11px;
      color: var(--toolbar-text, var(--text-soft));
      text-align: center;
      padding: 2px 0;
      min-width: 32px;
      }
      .zoom-toolbar .divider {
      height: 1px;
      background: var(--toolbar-border, var(--edge-main));
      margin: 2px 0;
      }
      .minimap-zoom-wrapper {
      position: absolute;
      bottom: 10px;
      right: 10px;
      z-index: 99;
      }
      .minimap-container {
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      overflow: hidden;
      margin-bottom: 4px;
      }
      .minimap-container svg {
      width: 100%;
      height: 100%;
      }
      .minimap-viewport {
      fill: rgba(79, 209, 197, 0.2);
      stroke: var(--accent);
      stroke-width: 2;
      cursor: move;
      }
      .minimap-node {
      fill: var(--minimap-dots, var(--text-soft));
      }
      .minimap-edge {
      stroke: var(--edge-main);
      stroke-width: 1;
      }
	  .minimap-close-btn {
      position: absolute;
      top: 2px;
      right: 2px;
      width: 18px;
      height: 18px;
      background: var(--toolbar-btn-bg, rgba(15, 23, 42, 0.9));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 3px;
      color: var(--toolbar-text, var(--text-soft));
      font-size: 11px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
      padding: 0;
      line-height: 1;
      }
      .minimap-close-btn:hover {
      background: var(--danger);
      color: white;
      border-color: var(--danger);
      }
	  .toolbar-close-btn {
      width: 24px;
      height: 24px;
      background: var(--toolbar-btn-bg, rgba(15, 23, 42, 0.9));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-text, var(--text-soft));
      font-size: 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      line-height: 1;
      flex-shrink: 0;
      }
      .toolbar-close-btn:hover {
      background: var(--danger);
      color: white;
      border-color: var(--danger);
      }
	  .canvas-hint {
      position: absolute;
      top: 50px;
      left: 50%;
      transform: translateX(-50%);
      padding: 8px 16px;
      background: var(--canvas-hint-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      font-size: 12px;
      color: var(--canvas-hint-color, var(--text-soft));
      z-index: 18;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
      }
      .canvas-hint.visible {
      opacity: 1;
      }
      .edge {
      stroke: var(--edge-main);
      stroke-width: 4;
      opacity: 0.75;
      transition: 0.25s ease-in-out;
      cursor: pointer;
      }
      .edge.backup {
      stroke: var(--danger);
      stroke-width: 5;
      }
      .edge.active {
      opacity: 1;
      stroke-width: 7;
      filter: drop-shadow(0 0 8px var(--accent, #4fd1c5));
      }
      .rect-group.active .rect-shape {
      filter: drop-shadow(0 0 10px var(--accent, #4fd1c5));
      animation: pulse 1.2s infinite ease-in-out;
      }
      .text-element.active {
      filter: drop-shadow(0 0 10px var(--accent, #4fd1c5));
      animation: pulse 1.2s infinite ease-in-out;
      }
      .free-preview {
      fill: none;
      stroke-dasharray: 4 4;
      pointer-events: none;
      }
      .free-point {
      fill: #e5e7eb;
      stroke: #0f172a;
      stroke-width: 1.5;
      cursor: grab;
      }
      .node-circle {
      fill: var(--node-fill, #1e293b);
      stroke: var(--node-stroke, #475569);
      stroke-width: 2;
      transition: 0.25s ease;
      transform-origin: center center;
      }
      .node-hit-area {
      cursor: grab;
      pointer-events: all;
      }
      .node-group:hover .node-circle {
      filter: drop-shadow(0 0 10px rgba(79, 209, 197, 0.45));
      }
      .node-group.active .node-circle {
      stroke: var(--accent);
      animation: pulse 1.2s infinite ease-in-out;
      }
      @keyframes pulse {
      0% {
      filter: drop-shadow(0 0 4px #4fd1c5);
      }
      50% {
      filter: drop-shadow(0 0 14px #4fd1c5);
      }
      100% {
      filter: drop-shadow(0 0 4px #4fd1c5);
      }
      }
      .node-label {
      fill: var(--text-main);
      font-size: 18px;
      text-anchor: middle;
      font-weight: 600;
      }
      .node-sub {
      fill: var(--text-soft);
      font-size: 13px;
      text-anchor: middle;
      }
      .ping-indicator {
      fill: #6b7280;
      stroke: #4b5563;
      stroke-width: 1;
      }
      .ping-indicator.online {
      fill: #10b981;
      stroke: #059669;
      }
      .ping-indicator.offline {
      fill: #ef4444;
      stroke: #dc2626;
      }
      .ping-indicator.checking {
      fill: #f59e0b;
      stroke: #d97706;
      }
      @media (max-width: 1024px) {
      .node-label {
      font-size: 28px;
      }
      .node-sub {
      font-size: 20px;
      }
      }
      @media (max-width: 768px) {
      .node-label {
      font-size: 70px;
      }
      .node-sub {
      font-size: 50px;
      }
      }
      @media (max-width: 380px) {
      .node-label {
      font-size: 60px;
      }
      .node-sub {
      font-size: 42px;
      }
      }
      .details-panel {
      background: var(--sidebar-bg, var(--panel-alt));
      padding: 22px;
      padding-bottom: 80px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 15px;
      position: relative;
      transition:
      width 0.3s ease,
      min-width 0.3s ease,
      padding 0.3s ease,
      opacity 0.3s ease;
      }
      .details-panel {
      min-width: 260px !important;
      }
      .details-panel {
      overflow-y: auto !important;
      overflow-x: hidden;
      }
      .details-panel.collapsed {
      width: 0 !important;
      min-width: 0 !important;
      padding: 0 !important;
      overflow: hidden;
      opacity: 0;
      }
      body {
      overflow-x: hidden;
      overflow-y: hidden;
      }
      main {
      overflow-x: hidden;
      overflow-y: visible;
      }
      .details-panel {
      overflow-y: auto !important;
      overflow-x: hidden;
      }
      .details-panel.collapsed {
      min-width: 0 !important;
      }
      .sidebar-toggle {
      position: absolute;
      left: -16px;
      top: 50%;
      transform: translateY(-50%);
      width: 16px;
      height: 60px;
      background: var(--sidebar-bg, var(--panel-alt));
      border: 1px solid var(--edge-main);
      border-right: none;
      border-radius: 8px 0 0 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text-soft);
      font-size: 10px;
      z-index: 25;
      transition:
      background 0.2s,
      color 0.2s;
      }
      .sidebar-toggle:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .sidebar-toggle.collapsed {
      left: 0;
      border-right: 1px solid var(--edge-main);
      border-radius: 0 8px 8px 0;
      position: fixed;
      right: 0;
      left: auto;
      }
      .details-name {
      font-size: clamp(22px, 2.5vw, 30px);
      font-weight: 700;
      }
      .details-ip {
      font-size: clamp(16px, 2vw, 22px);
      color: var(--text-soft);
      }
      .details-role {
      font-size: clamp(16px, 2vw, 22px);
      color: var(--accent);
      }
      .size-controls {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-top: 10px;
      }
      .size-controls label {
      font-size: clamp(14px, 1.6vw, 18px);
      color: var(--text-soft);
      }
      .size-controls input[type="range"] {
      flex: 1;
      accent-color: var(--accent);
      }
      .size-controls button {
      padding: 6px 12px;
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      font-size: clamp(12px, 1.4vw, 16px);
      }
      .size-controls button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .style-section {
      margin-top: 15px;
      padding-top: 15px;
      border-top: 1px solid var(--edge-main);
      }
      .style-section summary {
      cursor: pointer;
      font-size: clamp(14px, 1.6vw, 20px);
      text-transform: uppercase;
      color: var(--text-soft);
      list-style: none;
      display: flex;
      justify-content: space-between;
      align-items: center;
      user-select: none;
      }
      .style-section summary::-webkit-details-marker {
      display: none;
      }
      .password-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #ffffff;
      z-index: 9999;
      }
      .style-section summary::after {
      content: "‚ñº";
      transition: transform 0.2s;
      }
      .style-section[open] summary::after {
      transform: rotate(180deg);
      }
      .style-content {
      margin-top: 10px;
      }
      .style-row {
      display: flex;
      gap: 10px;
      align-items: center;
      margin: 8px 0;
      }
      .style-row label {
      font-size: clamp(13px, 1.5vw, 17px);
      color: var(--text-soft);
      min-width: 80px;
      }
      .style-row input[type="color"] {
      width: 50px;
      height: 30px;
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      background: transparent;
      }
      .style-row input[type="number"] {
      width: 70px;
      padding: 4px 8px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(12px, 1.4vw, 16px);
      }
      .style-row select {
      flex: 1;
      padding: 4px 8px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(12px, 1.4vw, 16px);
      cursor: pointer;
      }
      .editable-text {
      cursor: pointer;
      transition: opacity 0.2s;
      }
      .editable-text:hover {
      opacity: 0.7;
      }
      .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 999999;
      justify-content: center;
      align-items: center;
      overflow: auto;
      }
      .modal.active {
      display: inline-grid;
      }
      .modal-content {
      background: var(--panel-alt);
      padding: 25px;
      border-radius: 8px;
      border: 1px solid var(--edge-main);
      min-width: 300px;
      max-width: 90%;
      }
      .modal-content h3 {
      margin: 0 0 15px 0;
      color: var(--text-main);
      font-size: clamp(18px, 2vw, 24px);
      }
      .modal-content p {
      color: var(--text-soft);
      font-size: clamp(14px, 1.6vw, 18px);
      margin: 0 0 20px 0;
      }
      .modal-content input:not([type="color"]),
      .modal-content select {
      width: 100%;
      padding: 10px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(14px, 1.6vw, 18px);
      margin-bottom: 15px;
      user-select: text;
      -webkit-user-select: text;
      }
      .modal-content input[type="color"] {
      width: 60px;
      height: 36px;
      padding: 2px;
      border: 2px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      background: none;
      -webkit-appearance: none;
      appearance: none;
      }
      .modal-content input[type="color"]::-webkit-color-swatch-wrapper {
      padding: 0;
      }
      .modal-content input[type="color"]::-webkit-color-swatch {
      border: none;
      border-radius: 4px;
      }
      .modal-buttons {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
      margin-top: 10px;
      }
      .modal-buttons button {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: clamp(14px, 1.6vw, 18px);
      font-weight: 600;
      }
      .modal-buttons .btn-cancel {
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      }
      .modal-buttons .btn-save {
      background: var(--accent);
      color: var(--bg);
      }
      .modal-buttons .btn-delete {
      background: var(--danger);
      color: white;
      }
      .confirm-modal p {
      color: var(--text-soft);
      font-size: clamp(14px, 1.6vw, 18px);
      margin: 0 0 20px 0;
      }
      .context-menu-item {
      transition: background 0.15s;
      }
      .context-menu-item:hover {
      background: var(--panel);
      }
      .details-info-row {
      display: flex;
      align-items: center;
      margin: 6px 0;
      }
	 .node-group.selected .node-circle {
      stroke: var(--selection-handle, #f59e0b);
      stroke-width: 3;
      }
	  .node-group.layer-faded {
      pointer-events: none;
      }
      .edge.layer-faded {
      pointer-events: none;
      }
      .node-group.search-highlight .node-circle,
      .node-group.search-highlight rect,
      .node-group.search-highlight polygon {
      stroke: #10b981;
      stroke-width: 3;
      filter: drop-shadow(0 0 8px #10b981);
      }
	  .node-group.search-faded {
  opacity: 0.15;
  pointer-events: none;
}
.node-group.search-faded .node-label,
.node-group.search-faded .node-sub {
  opacity: 0.3;
}
.edge-group.search-faded,
.edge.search-faded {
  opacity: 0.1;
}
      .badge-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      }
     .badge {
      background: var(--tag-fill, #1e293b);
      color: var(--tag-text, #e2e8f0);
      border: 1px solid var(--tag-border, var(--edge-main));
      padding: 5px 12px;
      border-radius: 22px;
      font-size: clamp(12px, 1.4vw, 18px);
      }
	  .badge.wg {
      color: var(--accent);
      border-color: var(--accent);
      }
	  input[type="text"],
      input[type="number"],
      input[type="password"],
      textarea,
      select {
      background: var(--input-bg, #0b0e13) !important;
      color: var(--input-text, #e2e8f0) !important;
      border-color: var(--input-border, #1f2937) !important;
      font-family: var(--input-font, Inter, system-ui, sans-serif) !important;
      font-size: var(--input-font-size, 14px) !important;
      }
      .section-label {
      margin-top: 8px;
      font-size: clamp(14px, 1.6vw, 20px);
      text-transform: uppercase;
      color: var(--text-soft);
      }
      .list li {
      margin: 6px 0;
      font-size: clamp(14px, 1.6vw, 20px);
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      }
      .list li:hover {
      color: var(--accent);
      }
      .delete-note {
      color: var(--danger);
      font-size: 18px;
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.2s;
      flex-shrink: 0;
      }
      .list li:hover .delete-note {
      opacity: 1;
      }
      .editing {
      outline: 2px solid var(--accent);
      background: #0d141f;
      padding: 4px;
      border-radius: 6px;
      user-select: text;
      -webkit-user-select: text;
      }
      .mobile-menu-btn {
      display: none;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      color: var(--text-main);
      font-size: 22px;
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      }
      #topbar-menu {
      gap: 8px;
      }
      @media (min-width: 721px) {
      #topbar-menu {
      display: flex !important;
      }
      }
      @media (max-width: 720px) {
      #topbar-menu {
      display: none;
      }
      #topbar-menu.open {
      display: flex;
      }
      }
      @media (max-width: 720px) {
      .mobile-menu-btn {
      display: block;
      }
      #topbar-menu {
      position: absolute;
      top: var(--topbar-height);
      right: 0;
      background: var(--panel-alt);
      border-left: 1px solid var(--topbar-border);
      border-bottom: 1px solid var(--topbar-border);
      padding: 12px;
      display: none;
      flex-direction: column;
      width: 180px;
      z-index: 999;
      }
      #topbar-menu.open {
      display: flex;
      }
      header {
      position: relative;
      z-index: 9999;
      }
      }
      @media (max-width: 720px) {
      .draw-toolbar {
      position: absolute;
      top: auto;
      bottom: auto;
      left: 10px !important;
      right: auto !important;
      width: auto;
      gap: 6px;
      padding: 8px;
      }
      .topology-toolbar {
      position: absolute;
      top: auto;
      bottom: auto;
      width: auto;
      gap: 6px;
      padding: 8px;
      }
      .draw-toolbar {
      top: 10px !important;
      }
      .topology-toolbar {
      top: calc(10px + var(--draw-toolbar-height, 50px)) !important;
      }
      .canvas-hint {
      top: calc(10px + 120px);
      }
      }
      .icon-picker-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      z-index: 999999999;
      justify-content: center;
      align-items: center;
      }
      .icon-picker-modal.active {
      display: flex;
      }
      .icon-picker-content {
      background: var(--panel);
      border-radius: 12px;
      width: 90%;
      max-width: 800px;
      max-height: 80vh;
      display: flex;
      flex-direction: column;
      border: 1px solid var(--edge-main);
      }
      .icon-picker-header {
      padding: 20px;
      border-bottom: 1px solid var(--edge-main);
      }
      .icon-picker-header h3 {
      margin: 0 0 15px 0;
      color: var(--text-main);
      }
      .icon-picker-tabs {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
      flex-wrap: wrap;
      }
      .icon-picker-tab {
      padding: 8px 16px;
      background: var(--panel-alt);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      color: var(--text-soft);
      font-size: 14px;
      transition: all 0.2s;
      }
      .icon-picker-tab:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .icon-picker-tab.active {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
      }
      .icon-picker-search {
      width: 100%;
      padding: 10px 15px;
      background: var(--panel-alt);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      color: var(--text-main);
      font-size: 14px;
      }
      .icon-picker-search::placeholder {
      color: var(--text-soft);
      }
      .icon-picker-body {
      padding: 20px;
      overflow-y: auto;
      flex: 1;
      }
      .icon-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
      gap: 10px;
      }
      .icon-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 15px 10px;
      background: var(--panel-alt);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .icon-item:hover {
      background: var(--accent);
      border-color: var(--accent);
      transform: scale(1.05);
      }
      .icon-item svg {
      width: 32px;
      height: 32px;
      fill: var(--text-main);
      }
      .icon-item:hover svg {
      fill: var(--bg);
      }
      .icon-item-name {
      margin-top: 8px;
      font-size: 10px;
      color: var(--text-soft);
      text-align: center;
      word-break: break-word;
      }
      .icon-item:hover .icon-item-name {
      color: var(--bg);
      }
      .icon-picker-loading {
      text-align: center;
      padding: 40px;
      color: var(--text-soft);
      }
      .icon-picker-footer {
      padding: 15px 20px;
      border-top: 1px solid var(--edge-main);
      display: flex;
      justify-content: flex-end;
      }
      .icon-btn-cancel {
      padding: 8px 20px;
      background: var(--panel-alt);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      }
      .icon-btn-cancel:hover {
      background: var(--edge-main);
      }
      .icon-badge {
      display: inline-flex;
      align-items: center;
      gap: 5px;
      padding: 4px 8px;
      background: var(--panel-alt);
      border-radius: 4px;
      font-size: 12px;
      margin: 2px;
      }
      .icon-badge svg {
      width: 16px;
      height: 16px;
      fill: currentColor;
      }
      .pick-icon-btn {
      padding: 6px 12px;
      background: var(--accent);
      color: var(--bg);
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      margin-top: 8px;
      width: 100%;
      }
      .pick-icon-btn:hover {
      opacity: 0.9;
      }
      @media (max-width: 768px) {
      .icon-picker-content {
      width: 95%;
      max-height: 90vh;
      }
      .modal-content {
      background: var(--panel-alt);
      }
      #search-input {
      width: 100%;
      }
      }
      .version-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .version-item:hover {
      background: var(--panel-alt);
      border-color: var(--accent);
      }
      .version-item.current {
      border-color: var(--accent);
      background: rgba(79, 209, 197, 0.1);
      }
      .version-info {
      flex: 1;
      }
      .version-info .timestamp {
      font-size: 13px;
      color: var(--text-main);
      font-weight: 600;
      }
      .version-info .details {
      font-size: 11px;
      color: var(--text-soft);
      margin-top: 4px;
      }
      .version-actions {
      display: flex;
      gap: 6px;
      }
      .audit-entry {
      padding: 8px 12px;
      background: var(--panel);
      border-left: 3px solid var(--edge-main);
      border-radius: 4px;
      font-size: 12px;
      }
      .audit-entry.node { border-left-color: #4fd1c5; }
      .audit-entry.connection { border-left-color: #9f7aea; }
      .audit-entry.style { border-left-color: #ed8936; }
      .audit-entry.rack { border-left-color: #48bb78; }
      .audit-entry.layer { border-left-color: #4299e1; }
      .audit-entry .time {
      color: var(--text-soft);
      font-size: 10px;
      }
      .audit-entry .action {
      color: var(--text-main);
      font-weight: 500;
      }
      .tab-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .tab-item:hover {
      background: var(--panel-alt);
      }
      .tab-item.active {
      border-color: var(--accent);
      background: rgba(79, 209, 197, 0.1);
      }
      .tab-item .tab-name {
      font-weight: 600;
      color: var(--text-main);
      flex: 1;
      }
      .tab-item .tab-stats {
      font-size: 11px;
      color: var(--text-soft);
      margin-right: 10px;
      }
      .tab-actions {
      display: flex;
      gap: 6px;
      }
      .secret-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      border-left: 3px solid var(--danger);
      }
      .secret-item .secret-name {
      font-weight: 600;
      color: var(--text-main);
      flex: 1;
      }
      .secret-item .secret-status {
      font-size: 11px;
      color: var(--text-soft);
      margin-right: 10px;
      }
	  body.view-only-mode:not(.view-only-inspect) #node-panel,
      body.view-only-mode:not(.view-only-inspect) #edge-panel,
      body.view-only-mode:not(.view-only-inspect) #text-panel,
      body.view-only-mode:not(.view-only-inspect) #rect-panel {
        display: none !important;
      }
      body.view-only-mode .node-group,
      body.view-only-mode .edge,
      body.view-only-mode .rect-group,
      body.view-only-mode .text-element {
        cursor: default !important;
      }
      body.view-only-mode .resize-handle,
      body.view-only-mode .edge-control-point {
        display: none !important;
      }
      body.view-only-mode #bulk-toolbar,
      body.view-only-mode #bulk-toolbar-mobile,
      body.view-only-mode #bulk-actions-modal {
        display: none !important;
      }
      body.view-only-mode::after {
        content: "VIEW ONLY ‚Ä¢ click 5√ó to inspect";
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(245, 101, 101, 0.9);
        color: white;
        padding: 6px 16px;
        border-radius: 20px;
        font-size: 12px;
        font-weight: 600;
        letter-spacing: 1px;
        z-index: 9999;
        pointer-events: none;
      }
    </style>
  </head>
  <body style="background: radial-gradient(circle at center top, rgb(30, 37, 50) 0px, rgb(5, 6, 8) 70%);" class="">
    <div class="icon-picker-modal" id="icon-picker-modal">
      <div class="icon-picker-content">
        <div class="icon-picker-header">
          <h3>Select Icon</h3>
          <div class="icon-picker-tabs">
            <button class="icon-picker-tab" data-library="mdi">MDI</button>
            <button class="icon-picker-tab" data-library="simple">Simple Icons</button>
            <button class="icon-picker-tab active" data-library="selfhst">selfh.st/icons</button>
          </div>
          <input type="text" class="icon-picker-search" id="icon-search" placeholder="Search icons..." style="display: none;">
        </div>
        <div class="icon-picker-body" id="icon-picker-body">
        </div>
        <div class="icon-picker-footer">
          <button class="icon-btn-cancel" id="icon-picker-cancel">Cancel</button>
        </div>
      </div>
    </div>
    <div class="modal" id="tabs-modal">
      <div class="modal-content" style="max-width: 600px;">
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Manage multiple topologies</p>
        <div id="tabs-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 400px; overflow-y: auto; margin-bottom: 15px;">
            <div class="tab-item " onclick="switchTab(0)">
              <div class="tab-name">Corporate Site B</div>
              <div class="tab-stats">105 nodes ‚Ä¢ 65 connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(0)" title="Rename tab">‚úèÔ∏è</button>
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(0)" title="Delete tab">üóëÔ∏è</button>
              </div>
            </div>
          
            <div class="tab-item active" onclick="switchTab(1)">
              <div class="tab-name">Homelab 2</div>
              <div class="tab-stats">11 nodes ‚Ä¢ 10 connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(1)" title="Rename tab">‚úèÔ∏è</button>
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(1)" title="Delete tab">üóëÔ∏è</button>
              </div>
            </div>
          </div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="new-tab-name" placeholder="New tab name..." style="flex: 1; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <button class="btn-save" onclick="createNewTab()">+ Add Tab</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="tabs-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="rollback-modal">
      <div class="modal-content" style="max-width: 700px;">
        <h3>Version History</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Limit: Snapshots</p>
        <div id="rollback-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 450px; overflow-y: auto; margin-bottom: 15px;"><div style="text-align: center; padding: 40px; color: var(--text-soft);">No version history yet. Versions are saved automatically when you save the file.</div></div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <button class="btn-cancel" onclick="clearRollbackHistory()">Clear History</button>
          <button class="btn-save" onclick="createManualSnapshot()">Create Snapshot</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="rollback-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="audit-log-modal">
      <div class="modal-content" style="max-width: 800px;">
        <h3>Audit Log</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Track all changes made to your topology</p>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <select id="audit-filter" style="padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
            <option value="all">All Events</option>
            <option value="node">Node Operations</option>
            <option value="connection">Connections</option>
            <option value="style">Style Changes</option>
            <option value="rack">Rack Operations</option>
            <option value="layer">Layer Changes</option>
          </select>
          <button class="btn-save" onclick="exportAuditLog()">Export</button>
        </div>
        <div id="audit-log-list" style="display: flex; flex-direction: column; gap: 4px; max-height: 450px; overflow-y: auto; margin-bottom: 15px; font-family: monospace; font-size: 12px;"><div style="text-align: center; padding: 40px; color: var(--text-soft);">No audit entries yet</div></div>
        <div style="display: flex; gap: 8px;">
          <button class="btn-cancel" onclick="clearAuditLog()">Clear Log</button>
          <button class="btn-cancel" id="audit-log-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="port-map-modal">
      <div class="modal-content" style="max-width: 900px;">
        <h3>Port Map</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">All connections with port assignments</p>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="port-map-search" placeholder="Search devices or ports..." style="flex: 1; min-width: 200px; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <select id="port-map-filter" style="padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
            <option value="all">All Connections</option>
            <option value="with-ports">With Ports Only</option>
            <option value="without-ports">Missing Ports</option>
          </select>
        </div>
        <div id="port-map-table" style="max-height: 450px; overflow-y: auto; margin-bottom: 15px;"><div style="text-align: center; padding: 40px; color: var(--text-soft);">No connections found</div></div>
        <div style="display: flex; gap: 8px;">
          <button class="btn-save" onclick="exportPortMap()">Export CSV</button>
          <button class="btn-cancel" id="port-map-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="secrets-modal">
      <div class="modal-content" style="max-width: 600px;">
        <h3>Notes</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Notes can also be stored with AES 256 encryption</p>
        <div id="secrets-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 350px; overflow-y: auto; margin-bottom: 15px;">
        </div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="new-secret-name" placeholder="Section name (e.g., 'Root Passwords')..." style="flex: 1; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <button class="btn-save" onclick="createNewSecret()">+ Add Note</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="secrets-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="secret-editor-modal">
      <div class="modal-content" style="max-width: 600px;">
        <h3 id="secret-editor-title">Edit Note</h3>
        <textarea id="secret-editor-content" placeholder="Enter sensitive information here..." style="width: 100%; height: 200px; padding: 12px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main); font-family: monospace; resize: vertical; margin-bottom: 15px;"></textarea>
        <div style="margin-bottom: 15px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
          <input type="checkbox" id="secret-auto-encrypt" checked="" style="cursor: pointer;">
          <span>Encrypt Note</span>
          </label>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" onclick="closeSecretEditor()">Cancel</button>
          <button class="btn-save" onclick="saveSecret()">Save</button>
        </div>
      </div>
    </div>
    <div class="modal" id="edit-modal">
      <div class="modal-content">
        <h3 id="modal-title">Edit Name</h3>
        <input type="text" id="modal-input">
        <div class="modal-buttons">
          <button class="btn-cancel" id="modal-cancel">Cancel</button>
          <button class="btn-save" id="modal-save">Save</button>
        </div>
      </div>
    </div>
    <div class="modal confirm-modal" id="confirm-modal">
      <div class="modal-content">
        <h3>Confirm</h3>
        <p id="confirm-message"> Are you sure you want to delete this line? </p>
        <div class="modal-buttons">
          <button class="btn-cancel" id="confirm-cancel">Cancel</button>
          <button class="btn-delete" id="confirm-delete">Delete</button>
        </div>
      </div>
    </div>
    <div class="modal" id="save-info-modal">
      <div class="modal-content" style="max-width: 700px; max-height: 80vh; overflow-y: auto;">
        <h3 style="margin-bottom: 16px;">Help</h3>
        <div style="display: flex; gap: 8px; margin-bottom: 16px; flex-wrap: wrap;">
          <button class="help-tab active" data-tab="general" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--accent); color: var(--bg); border-radius: 6px; cursor: pointer; font-weight: 600;">General</button>
          <button class="help-tab" data-tab="desktop" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--panel); color: var(--text-main); border-radius: 6px; cursor: pointer; font-weight: 600;">Desktop</button>
          <button class="help-tab" data-tab="mobile" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--panel); color: var(--text-main); border-radius: 6px; cursor: pointer; font-weight: 600;">Mobile</button>
        </div>
        <div id="help-tab-general" class="help-tab-content" style="display: block;">
          <ul style="margin-left: 20px; margin-bottom: 12px; line-height: 1.8;">
            <li><strong>Add Nodes:</strong> Click "+ Node" or "+ Rack" in the top menu</li>
            <li><strong>Connect Nodes:</strong> Select a node, then use "Add Connection" in the panel</li>
            <li><strong>Move Nodes:</strong> Drag nodes to reposition them</li>
            <li><strong>Enter Rack View:</strong> Double click on desktop or Long press on mobile</li>
            <li><strong>Multi Select:</strong> Right click (desktop) or double tap (mobile)</li>
            <li><strong>Pan Canvas:</strong> Drag empty space or hold Space + drag</li>
            <li><strong>Zoom:</strong> Scroll wheel or pinch gesture</li>
            <li><strong>Free Draw:</strong> Use draw toolbar for drawing lines, boxes/zones , and text</li>
          </ul>
          <h4 style="color: var(--accent); margin-bottom: 8px;">Saving &amp; Encryption</h4>
          <p style="margin-bottom: 8px;">Browsers cannot overwrite local files. Click <strong>Save File</strong> to download an updated HTML with all changes. Replace your old file to keep edits.</p>
          <p style="margin-bottom: 8px;"><strong>Encryption of data:</strong> Check "Encrypt" before saving to password protect your data. Beware! No recovery possible without password!!</p>
          <p><strong>Decryption of data:</strong> Export via JSON in top settings menu after successful password validation to decrypt your data. You can then reimport back into the same file and save!</p>
        </div>
        <div id="help-tab-desktop" class="help-tab-content" style="display: none;">
          <h4 style="color: var(--accent); margin-bottom: 12px;">Navigation</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Arrow Keys</code></td>
              <td style="padding: 8px;">Move selected 1px</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Shift + Arrows</code></td>
              <td style="padding: 8px;">Move selected 10px</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Tab / Shift+Tab</code></td>
              <td style="padding: 8px;">Cycle through nodes</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">F</code></td>
              <td style="padding: 8px;">Focus on selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Space + Drag</code></td>
              <td style="padding: 8px;">Pan canvas</td>
            </tr>
          </tbody></table>
          <h4 style="color: var(--accent); margin-bottom: 12px;">Management</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">L</code></td>
              <td style="padding: 8px;">Lock/unlock selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">G</code></td>
              <td style="padding: 8px;">Group/ungroup selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+C / Ctrl+V</code></td>
              <td style="padding: 8px;">Copy / Paste</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+D</code></td>
              <td style="padding: 8px;">Duplicate</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+A</code></td>
              <td style="padding: 8px;">Select all</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Delete</code></td>
              <td style="padding: 8px;">Delete selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Escape</code></td>
              <td style="padding: 8px;">Clear selection</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+Z / Ctrl+Y</code></td>
              <td style="padding: 8px;">Undo / Redo</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Right Click</code></td>
              <td style="padding: 8px;">Multi select toggle</td>
            </tr>
          </tbody></table>
        </div>
        <div id="help-tab-mobile" class="help-tab-content" style="display: none;">
          <h4 style="color: var(--accent); margin-bottom: 12px;">Basic Gestures</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Tap node</strong></td>
              <td style="padding: 8px;">Select &amp; open properties</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Tap empty</strong></td>
              <td style="padding: 8px;">Deselect all</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Drag node</strong></td>
              <td style="padding: 8px;">Move node</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Drag empty</strong></td>
              <td style="padding: 8px;">Pan canvas</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Pinch</strong></td>
              <td style="padding: 8px;">Zoom in/out</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Double-tap node</strong></td>
              <td style="padding: 8px;">Add/remove from selection</td>
            </tr>
          </tbody></table>
          <h4 style="color: var(--accent); margin-bottom: 12px;">Rack View</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Long-press rack</strong></td>
              <td style="padding: 8px;">Enter rack view</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Double-tap empty</strong></td>
              <td style="padding: 8px;">Exit rack view</td>
            </tr>
          </tbody></table>
        </div>
        <div class="modal-buttons" style="margin-top: 16px;">
          <button class="btn-cancel" id="save-info-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="settings-modal">
	<div class="modal-content">
        <h2>Settings</h2>
        <details class="style-section">
          <summary>View Only Mode</summary>
          <div class="style-content">
            <div class="style-row">
              <label>View Only (disable all editing)</label>
              <input type="checkbox" id="view-only-mode" style="width:auto;">
            </div>
            <p style="margin-top:4px;font-size:12px;color:var(--text-soft);">When enabled, all editing of the canvas is disabled. Pan and zoom still work.</p>
          </div>
        </details>
        <details class="style-section">
          <summary>General Theme</summary>
          <div class="style-content">
		    <div class="style-row">
              <label>Main Background</label>
              <input type="color" id="panel-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Modal Window (popup) Background</label>
              <input type="color" id="panel-alt-color" value="#10141b">
            </div>
            <div class="style-row">
              <label>Accent Buttons</label>
              <input type="color" id="accent-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Danger Buttons</label>
              <input type="color" id="danger-color" value="#f56565">
            </div>
            <div class="style-row">
              <label>Primary Text</label>
              <input type="color" id="text-main-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Secondary Text</label>
              <input type="color" id="text-soft-color" value="#94a3b8">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Top Bar</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="topbar-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="topbar-border-color" value="#1f2533">
            </div>
          </div>
		  <div class="style-content">
            <div class="style-row">
              <label>Button Fill</label>
              <input type="color" id="btn-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Button Text</label>
              <input type="color" id="btn-text-color" value="#e2e8f0">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Main Canvas</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="canvas-border-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Grid Lines</label>
              <input type="color" id="canvas-grid-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Grid Size</label>
              <input type="number" id="canvas-grid-size" value="50" min="20" max="200" style="width:60px;">
            </div>
		    <div class="style-row">
              <label>Background Top</label>
              <input type="color" id="canvas-gradient-top" value="#1e2532">
            </div>
            <div class="style-row">
              <label>Background Bottom</label>
              <input type="color" id="canvas-gradient-bottom" value="#050608">
            </div>
            <div class="style-row">
              <label>Solid Background</label>
              <input type="color" id="page-bg-color" value="#050608">
            </div>
            <p style="margin-top:4px;font-size:12px;color:var(--text-soft);">Set solid background to override gradient.</p>
          </div>
        </details>
        <details class="style-section">
          <summary>Rack Canvas</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Frame Fill</label>
              <input type="color" id="rack-frame-fill" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Frame Border</label>
              <input type="color" id="rack-frame-stroke" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Grid Lines</label>
              <input type="color" id="rack-line-color" value="#475569">
            </div>
            <div class="style-row">
              <label>U Labels</label>
              <input type="color" id="rack-text-color" value="#4fd1c5">
            </div>
          </div>
       </details>
	   <details class="style-section">
          <summary>Canvas Toolbars</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="toolbar-bg-color" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="toolbar-border-color" value="#1f2937">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="toolbar-text-color" value="#94a3b8">
            </div>
            <div class="style-row">
              <label>Button Fill</label>
              <input type="color" id="toolbar-btn-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Button Text</label>
              <input type="color" id="toolbar-btn-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Minimap Dots</label>
              <input type="color" id="minimap-dots-color" value="#94a3b8">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Nodes</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Fill</label>
              <input type="color" id="node-fill-color" value="#1e293b">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="node-stroke-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Title Color</label>
              <input type="color" id="node-title-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Title Size</label>
              <input type="number" id="node-title-size" value="18" min="8" max="48" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Subtitle Color</label>
              <input type="color" id="node-sub-color" value="#94a3b8">
            </div>
            <div class="style-row">
              <label>Subtitle Size</label>
              <input type="number" id="node-sub-size" value="13" min="8" max="48" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Font</label>
              <select id="node-font-family" style="flex:1;padding:4px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;">
                <option value="Inter, system-ui, sans-serif">Inter</option>
                <option value="Arial, sans-serif">Arial</option>
                <option value="Helvetica, sans-serif">Helvetica</option>
                <option value="Georgia, serif">Georgia</option>
                <option value="monospace">Monospace</option>
              </select>
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Connections</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Default Color</label>
              <input type="color" id="default-edge-color" value="#475569">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Groups &amp; Editing</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Resize handle Color</label>
              <input type="color" id="selection-handle-color" value="#f59e0b">
            </div>
            <div class="style-row">
              <label>Resize Handle Size</label>
              <input type="number" id="selection-handle-size" value="8" min="4" max="16" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Grouped Icon Outline</label>
              <input type="color" id="group-indicator-color" value="#4fd1c5">
            </div>
          </div>
		  <div class="style-content">
            <div class="style-row">
              <label>Multiselect Fill Color (Desktop)</label>
              <input type="color" id="selection-fill-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Multiselect Fill Opacity (Desktop)</label>
              <input type="range" id="selection-fill-opacity" min="0" max="1" step="0.05" value="0.1">
              <span id="selection-fill-opacity-val" style="min-width:35px;text-align:right;">10%</span>
            </div>
            <div class="style-row">
              <label>Multiselect Border Color (Desktop)</label>
              <input type="color" id="selection-stroke-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Multiselect Border Width (Desktop)</label>
              <input type="number" id="selection-stroke-width" min="1" max="10" value="2">
            </div>
            <div class="style-row">
              <label>Multiselect Border Style (Desktop)</label>
              <select id="selection-stroke-style">
                <option value="5,5">Dashed</option>
                <option value="2,4">Dotted</option>
                <option value="none">Solid</option>
              </select>
            </div>
          </div>
        </details>
		<details class="style-section">
          <summary>Inputs &amp; Dropdowns</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="input-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="input-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="input-border-color" value="#1f2937">
            </div>
            <div class="style-row">
              <label>Font</label>
              <select id="input-font-family" style="flex:1;padding:4px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;">
                <option value="Inter, system-ui, sans-serif">Inter</option>
                <option value="Arial, sans-serif">Arial</option>
                <option value="Helvetica, sans-serif">Helvetica</option>
                <option value="Georgia, serif">Georgia</option>
                <option value="monospace">Monospace</option>
              </select>
            </div>
            <div class="style-row">
              <label>Font Size</label>
              <input type="number" id="input-font-size" value="14" min="10" max="24" style="width:60px;">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Welcome Message</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Enabled</label>
              <input type="checkbox" id="canvas-hint-enabled" checked="" style="width:auto;">
            </div>
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="canvas-hint-bg-color" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Text Color</label>
              <input type="color" id="canvas-hint-text-color" value="#94a3b8">
            </div>
            <div class="style-row" style="flex-direction:column;align-items:stretch;">
              <label>Custom Text (HTML)</label>
              <textarea id="canvas-hint-text" rows="4" style="width:100%;margin-top:4px;padding:6px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;font-size:12px;resize:vertical;" placeholder="Leave empty for default"></textarea>
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Sidebar / Mobile Footer</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="sidebar-bg-color" value="#10141b">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Tags</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Fill</label>
              <input type="color" id="tag-fill-color" value="#1e293b">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="tag-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="tag-border-color" value="#475569">
            </div>
          </div>
        </details>
        <details class="style-section" open="">
          <summary>Import / Export / Upgrade JSON</summary>
          <div class="style-content">
            <button id="export-data-btn" style="width:100%;margin-bottom:10px;padding:10px;background:var(--accent);color:var(--bg);border:none;border-radius:6px;cursor:pointer;font-size:14px;font-weight:600;">Export JSON</button>
            <button id="import-data-btn" style="width:100%;padding:10px;background:var(--panel);color:var(--text-main);border:1px solid var(--edge-main);border-radius:6px;cursor:pointer;font-size:14px;font-weight:600;">Import JSON</button>
            <input type="file" id="import-data-file" accept=".json" style="display:none">
          </div>
        </details>
         <details class="style-section">
          <summary>Auto Status Checking</summary>
          <div class="style-content">
            <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 16px; cursor: pointer;">
            <input type="checkbox" id="auto-ping-enabled" style="cursor: pointer;">
            <span style="font-size: 14px; font-weight: 600;">Enable automatic status checking</span>
            </label>
            <div id="auto-ping-settings" style="display: none; padding-left: 20px; border-left: 2px solid var(--edge-main);">
              <div class="style-row" style="margin-bottom: 12px;">
                <label>Check Interval (seconds):</label>
                <input type="number" id="auto-ping-interval" min="5" max="3600" value="30" style="width: 80px; padding: 6px; background: var(--panel); border: 1px solid var(--edge-main); border-radius: 4px; color: var(--text-main);">
              </div>
              <div style="padding: 10px; background: var(--panel); border-radius: 6px; border: 1px solid var(--edge-main); font-size: 12px; color: var(--text-soft);">
                <div style="margin-bottom: 4px;"><span id="auto-ping-next-check">Next check in: --</span></div>
                <div><span id="auto-ping-last-run">Last run: 1:15:07 PM</span></div>
              </div>
            </div>
            <p style="margin-top: 12px; font-size: 12px; color: var(--text-soft); font-style: italic;">
              Automatically checks all ping enabled nodes at the specified interval. I recommend 30 to 60 seconds for local networks.
            </p>
			</div>
        </details>
        <details class="style-section" open="">
          <summary>Danger Zone</summary>
          <div class="style-content">
            <p style="margin-bottom:12px;font-size:13px;color:var(--text-soft);">Permanently delete everything on the canvas.</p>
            <button id="clear-all-btn" title="Clear all nodes" style="padding:6px 12px;background:var(--danger);color:#fff;border:none;border-radius:6px;cursor:pointer;font-size:14px;font-weight:600;">Clear All</button>
            <input type="file" id="import-data-file" accept=".json" style="display:none">
          </div>
        </details>
        <div class="modal-buttons">
          <button class="btn-cancel" id="settings-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="add-node-modal">
      <div class="modal-content">
        <h3>Add New Node</h3>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Basic Information</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Name</label>
          <input type="text" id="new-node-name" placeholder="e.g. web server, jellyfin">
          <label style="display: block;margin-bottom: 4px;margin-top: 12px;color: var(--text-soft);font-size: 13px;">IP / Subtitle</label>
          <input type="text" id="new-node-ip" placeholder="e.g. 192.168.1.100">
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Tags</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Text Tags (comma separated)</label>
          <input type="text" id="new-node-tags" placeholder="e.g. Docker, nginx, WG: vpn">
          <button class="pick-icon-btn" id="pick-new-node-tag-icon-btn" style="margin-top: 10px;">Add Icon Tag</button>
          <div id="new-node-icon-tags" style="margin-top: 10px; display: none;">
            <label style="display: block; margin-bottom: 8px; color: var(--text-soft); font-size: 13px;">Icon Tags:</label>
            <div id="new-node-icon-tags-list" style="display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 10px;"></div>
          </div>
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Node Appearance</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Basic Shapes</label>
          <select id="new-node-shape">
            <optgroup label="Basic Shapes">
            <option value="circle">Circle</option>
            <option value="square">Square</option>
            <option value="rectangle">Rectangle</option>
            <option value="triangle">Triangle</option>
            <option value="hexagon">Hexagon</option>
            <option value="diamond">Diamond</option>
            <option value="star">Star</option>
            <option value="stop-sign">Stop Sign</option>
            <option value="octagon">Octagon</option>
            <option value="pentagon">Pentagon</option>
            <option value="cross">Cross</option>
            <option value="rounded-square">Rounded Square</option>
            <option value="pill">Pill</option>
            <option value="parallelogram">Parallelogram</option>
            <option value="trapezoid">Trapezoid</option>
          </optgroup>
          <optgroup label="Computers &amp; Devices">
            <option value="server">Server</option>
            <option value="pc">PC / Desktop</option>
            <option value="laptop">Laptop</option>
            <option value="phone">Phone / Mobile</option>
            <option value="printer">Printer</option>
            <option value="pi">Raspberry Pi</option>
            <option value="sensor">Sensor / IoT</option>
          </optgroup>
          <optgroup label="Network Equipment">
            <option value="router">Router</option>
            <option value="switch">Switch</option>
            <option value="firewall">Firewall</option>
            <option value="access-point">Access Point</option>
            <option value="load-balancer">Load Balancer</option>
            <option value="gateway">Gateway</option>
            <option value="vpn">VPN / Tunnel</option>
            <option value="nas">NAS / Storage</option>
          </optgroup>
          <optgroup label="Cloud &amp; Services">
            <option value="cloud">Cloud</option>
            <option value="database">Database</option>
			<option value="docker">Docker</option>
            <option value="container">Container</option>
            <option value="vm">Virtual Machine</option>
            <option value="kubernetes">Kubernetes</option>
            <option value="api">API / Endpoint</option>
            <option value="queue">Queue / Message</option>
            <option value="lambda">Lambda / Function</option>
            <option value="bucket">Bucket / S3</option>
          </optgroup>
          <optgroup label="Security &amp; Monitoring">
            <option value="shield">Shield</option>
            <option value="camera">Camera / CCTV</option>
            <option value="monitor">Monitor / Dashboard</option>
          </optgroup>
          </select>
          <button class="pick-icon-btn" id="pick-node-icon-btn" style="margin-top: 10px;"> Or search web icons</button>
          <div id="selected-node-icon" style="margin-top: 10px; display: none;">
            <label style="display: block; margin-bottom: 8px; color: var(--text-soft); font-size: 13px;">Selected Icon:</label>
            <div class="icon-badge" id="selected-node-icon-preview">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24">
                <image href="https://cdn.jsdelivr.net/gh/selfhst/icons@master/png/docker.png" width="24" height="24"></image>
              </svg>
              <span>docker</span>
            </div>
          </div>
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Ping / Status Monitoring</div>
          <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px; cursor: pointer;">
          <input type="checkbox" id="new-node-pingable" style="cursor: pointer;">
          <span style="color: var(--text-soft); font-size: 13px;">Enable ping/status check for this node</span>
          </label>
          <div id="new-node-ping-options" style="display: block; padding-left: 24px; border-left: 2px solid var(--edge-main);">
            <label style="display: block; margin-bottom: 4px; color: var(--text-soft); font-size: 13px;">Protocol</label>
            <select id="new-node-ping-protocol" style="margin-bottom: 12px;">
              <option value="http">HTTP (port 80) uses IP field</option>
              <option value="https">HTTPS (port 443) uses IP field</option>
              <option value="custom">Custom URL</option>
            </select>
            <div id="new-node-custom-url-container" style="display: block;">
              <label style="display: block; margin-bottom: 4px; color: var(--text-soft); font-size: 13px;">Custom URL</label>
              <input type="text" id="new-node-custom-url" placeholder="e.g. http://192.168.1.1:8080">
            </div>
            <label style="display: block; margin-bottom: 4px; margin-top: 8px; color: var(--text-soft); font-size: 13px;">
            Timeout (ms)
            </label>
            <input type="number" id="new-node-ping-timeout" value="3000" min="1000" max="10000" step="500">
          </div>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="add-node-cancel">Cancel</button>
          <button class="btn-save" id="add-node-save">Add Node</button>
        </div>
      </div>
    </div>
    <div class="modal" id="add-rack-modal">
      <div class="modal-content">
        <h3>Add New Rack</h3>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Basic Information</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Rack Name</label>
          <input type="text" id="new-rack-name" placeholder="e.g. Rack-A, DC1-R01, Production-01">
          <label style="display: block;margin-bottom: 4px;margin-top: 12px;color: var(--text-soft);font-size: 13px;">IP / Network Range (optional)</label>
          <input type="text" id="new-rack-ip" placeholder="e.g. 192.168.1.0/24">
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Tags</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Text Tags (comma separated)</label>
          <input type="text" id="new-rack-tags" placeholder="e.g. Production, Data Center 1, Row A">
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Rack Appearance</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Icon / Shape</label>
          <select id="new-rack-shape">
            <optgroup label="Basic Shapes">
            <option value="circle">Circle</option>
            <option value="square">Square</option>
            <option value="rectangle">Rectangle</option>
            <option value="triangle">Triangle</option>
            <option value="hexagon">Hexagon</option>
            <option value="diamond">Diamond</option>
            <option value="star">Star</option>
            <option value="stop-sign">Stop Sign</option>
            <option value="octagon">Octagon</option>
            <option value="pentagon">Pentagon</option>
            <option value="cross">Cross</option>
            <option value="rounded-square">Rounded Square</option>
            <option value="pill">Pill</option>
            <option value="parallelogram">Parallelogram</option>
            <option value="trapezoid">Trapezoid</option>
          </optgroup>
          <optgroup label="Computers &amp; Devices">
            <option value="server">Server</option>
            <option value="pc">PC / Desktop</option>
            <option value="laptop">Laptop</option>
            <option value="phone">Phone / Mobile</option>
            <option value="printer">Printer</option>
            <option value="pi">Raspberry Pi</option>
            <option value="sensor">Sensor / IoT</option>
          </optgroup>
          <optgroup label="Network Equipment">
            <option value="router">Router</option>
            <option value="switch">Switch</option>
            <option value="firewall">Firewall</option>
            <option value="access-point">Access Point</option>
            <option value="load-balancer">Load Balancer</option>
            <option value="gateway">Gateway</option>
            <option value="vpn">VPN / Tunnel</option>
            <option value="nas">NAS / Storage</option>
          </optgroup>
          <optgroup label="Cloud &amp; Services">
            <option value="cloud">Cloud</option>
            <option value="database">Database</option>
			<option value="docker">Docker</option>
            <option value="container">Container</option>
            <option value="vm">Virtual Machine</option>
            <option value="kubernetes">Kubernetes</option>
            <option value="api">API / Endpoint</option>
            <option value="queue">Queue / Message</option>
            <option value="lambda">Lambda / Function</option>
            <option value="bucket">Bucket / S3</option>
          </optgroup>
          <optgroup label="Security &amp; Monitoring">
            <option value="shield">Shield</option>
            <option value="camera">Camera / CCTV</option>
            <option value="monitor">Monitor / Dashboard</option>
          </optgroup>
          </select>
          <button class="pick-icon-btn" id="pick-rack-icon-btn" style="margin-top: 10px;">Or Search Web Icons</button>
          <div id="selected-rack-icon" style="margin-top: 10px; display: none;">
            <label style="display: block; margin-bottom: 8px; color: var(--text-soft); font-size: 13px;">Selected Icon:</label>
            <div class="icon-badge" id="selected-rack-icon-preview">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24">
                <image href="" width="24" height="24"></image>
              </svg>
              <span></span>
            </div>
          </div>
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Rack Configuration</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Rack Capacity</label>
          <select id="new-rack-capacity">
            <option value="42" selected="">42U (Standard Full Rack)</option>
            <option value="48">48U (Large Rack)</option>
            <option value="24">24U (Half Rack)</option>
            <option value="12">12U (Small/Wall Mount)</option>
            <option value="6">6U (Mini Rack)</option>
          </select>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="add-rack-cancel">Cancel</button>
          <button class="btn-save" id="add-rack-save">Add Rack</button>
        </div>
      </div>
    </div>
    <div class="modal confirm-modal" id="clear-all-modal">
      <div class="modal-content">
        <h3>Clear All Nodes</h3>
        <p> This will remove ALL nodes and connections. This cannot be undone until you reload without saving. Are you sure? </p>
        <div class="modal-buttons">
          <button class="btn-cancel" id="clear-all-cancel">Cancel</button>
          <button class="btn-delete" id="clear-all-confirm">Clear Everything</button>
        </div>
      </div>
    </div>
    <div class="modal" id="layer-modal">
      <div class="modal-content" style="max-width: 400px;">
        <h3>Layer Visibility</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Toggle which layers are visible on the canvas</p>
        <div style="display: flex; flex-direction: column; gap: 10px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-physical" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Physical Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-logical" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Logical Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-security" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Security Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-application" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Application Layer</span>
          </label>
        </div>
        <div style="margin-top: 15px; display: flex; gap: 8px;">
          <button class="btn-cancel" style="flex: 1;" onclick="document.querySelectorAll('#layer-modal input[type=checkbox]').forEach(cb =&gt; cb.checked = false); applyLayerFilter();">Hide All</button>
          <button class="btn-save" style="flex: 1;" onclick="document.querySelectorAll('#layer-modal input[type=checkbox]').forEach(cb =&gt; cb.checked = true); applyLayerFilter();">Show All</button>
        </div>
        <div class="modal-buttons" style="margin-top: 10px;">
          <button class="btn-cancel" id="layer-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div id="context-menu" style="display: none !important;">
    </div>
    <header>
      <div class="title-block">
        <h1 id="page-title" class="editable-page-title">The One File</h1>
        <div class="save-row">
          <button id="save-file-btn" class="save-btn" type="button">Save File</button>
          <label style="display: flex;align-items: center;gap: 4px;font-size: 12px;color: var(--text-soft);cursor: pointer;user-select: none;">
          <input type="checkbox" id="encrypt-toggle" style="cursor: pointer">
          <span title="Encrypt data with password">Encrypt</span>
          </label>
          <span id="save-help-btn" class="help-icon" title="Why save?">?</span>
        </div>
      </div>
      <div id="topbar-menu">
        <button id="back-to-topology-btn" title="Exit rack view and return to topology" style="padding: 6px 12px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;display: none;">‚Üê Back to Topology</button>
        <button id="add-node-btn" class="save-btn" title="Add new node" style="background: var(--accent)">+ Node</button>
        <button id="add-rack-btn" class="save-btn" title="Add new rack" style="background: var(--accent); margin-left: 8px;">+ Rack</button>
        <button id="undo-btn" title="Undo (Ctrl+Z)" style="padding: 6px 12px; background: var(--btn-bg); color: var(--btn-text); border: 1px solid var(--edge-main); border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600; opacity: 1;">‚Ü∂</button>
        <button id="redo-btn" title="Redo (Ctrl+Y)" style="padding: 6px 12px; background: var(--btn-bg); color: var(--btn-text); border: 1px solid var(--edge-main); border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600; opacity: 0.5;" disabled="">‚Ü∑</button>
<input type="text" id="search-nodes" placeholder="Search nodes..." title="Search by name, IP, MAC, role, or tag" style="padding: 6px 12px;background: var(--input-bg);color: var(--input-text);border: 1px solid var(--input-border);border-radius: 6px;font-family: var(--input-font);font-size: var(--input-font-size);width: 180px;">
        <button id="check-all-ping-btn" title="Check status of all enabled nodes" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600">Check Pings</button>
        <button id="layers-btn" title="Toggle layer visibility" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Layers</button>
        <button id="tabs-btn" title="Manage document tabs" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Tabs</button>
        <button id="rollback-btn" title="View version history" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Snapshots</button>
        <button id="audit-log-btn" title="View audit log" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Audit</button>
        <button id="port-map-btn" title="View all port connections" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Ports</button>
        <button id="secrets-btn" title="Manage encrypted notes" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Notes</button>
        <button onclick="screenshotCanvas()" title="Export canvas as PNG image" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">PNG</button>
        <button onclick="exportCanvasSVG()" title="Export canvas as SVG vector" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">SVG</button>
        <button id="settings-btn" title="Page settings">‚öôÔ∏è</button>
      </div>
      <button id="mobile-menu-toggle" class="mobile-menu-btn">‚ò∞</button>
      <div class="header-resizer" id="header-resizer">
        <svg class="resizer-icon" width="40" height="6" viewBox="0 0 40 6" xmlns="http://www.w3.org/2000/svg">
          <circle cx="14" cy="3" r="2"></circle>
          <circle cx="20" cy="3" r="2"></circle>
          <circle cx="26" cy="3" r="2"></circle>
        </svg>
      </div>
    </header>
    <main>
      <section class="topology-panel">
        <div class="draw-toolbar" id="draw-toolbar" style="display: flex !important;">
          <button type="button" class="toolbar-close-btn" id="draw-toolbar-close-btn" title="Hide draw toolbar">‚úï</button>
          <button id="draw-toggle" title="Draw custom line">‚úèÔ∏è</button>
          <button id="rect-toggle" title="Draw zone">‚ñ≠</button>
          <button id="text-toggle" title="Add text">T</button>
          <select id="rect-style" title="zone style">
            <option value="filled">Filled</option>
            <option value="outlined">Outlined</option>
          </select>
          <input type="color" id="draw-color" value="#f97316" title="Line color">
          <select id="draw-style" title="Line style">
            <option value="solid">Solid</option>
            <option value="dashed">Dashed</option>
            <option value="dotted">Dotted</option>
          </select>
          <select id="draw-arrow" title="Arrow direction">
            <option value="none">No arrows</option>
            <option value="forward">‚Üí Right</option>
            <option value="backward">‚Üê Left</option>
            <option value="both">‚Üî Both</option>
          </select>
          <button id="draw-undo" style="display: none" title="Undo last point">Undo</button>
        </div>
        <div class="topology-toolbar" id="topology-toolbar" style="display: flex !important;">
          <button type="button" class="toolbar-close-btn" id="topology-toolbar-close-btn" title="Hide add line toolbar">‚úï</button>
          <label for="add-line-select">Add line to:</label>
          <select id="add-line-select"><option value="core-router-2">Core Router 2</option><option value="fw-external-1">External FW 1</option><option value="fw-external-2">External FW 2</option><option value="fw-internal">Internal FW</option><option value="core-switch-1">Core Switch 1</option><option value="core-switch-2">Core Switch 2</option><option value="dc-rack-a1">DC Rack A1</option><option value="dc-rack-a2">DC Rack A2</option><option value="dc-rack-b1">DC Rack B1</option><option value="dc-rack-b2">DC Rack B2</option><option value="dmz-rack">DMZ Rack</option><option value="mgmt-rack">Management Rack</option><option value="wlc-primary">WLC Primary</option><option value="wlc-secondary">WLC Secondary</option><option value="mobile-zone-hq">HQ Mobile Zone</option><option value="mobile-zone-guest">Guest WiFi Zone</option><option value="mobile-zone-iot">IoT Device Zone</option><option value="branch-router-ny">NYC Branch Router</option><option value="branch-router-la">LA Branch Router</option><option value="branch-router-chi">Chicago Branch Router</option><option value="branch-router-lon">London Branch Router</option><option value="branch-router-tokyo">Tokyo Branch Router</option><option value="cloud-aws">AWS Cloud</option><option value="cloud-azure">Azure Cloud</option><option value="cloud-gcp">GCP Cloud</option><option value="isp-primary">ISP Primary</option><option value="isp-secondary">ISP Secondary</option><option value="proxy-server-1">Proxy Server 1</option><option value="proxy-server-2">Proxy Server 2</option><option value="vpn-concentrator">VPN Concentrator</option><option value="nac-server">NAC Server</option><option value="voip-cluster">VoIP Cluster</option><option value="video-conf">Video Conference</option><option value="security-cameras">Security Cameras</option><option value="dev-server-1">Dev Server 1</option><option value="dev-server-2">Dev Server 2</option><option value="test-environment">Test Environment</option><option value="erp-system">ERP System</option><option value="crm-system">CRM System</option><option value="endpoint-1000">Corporate Endpoints</option><option value="dist-switch-floor1">Floor 1 Switch</option><option value="dist-switch-floor2">Floor 2 Switch</option><option value="dist-switch-floor3">Floor 3 Switch</option><option value="dist-switch-floor4">Floor 4 Switch</option><option value="ap-floor1-zone1">AP Floor 1 Zone 1</option><option value="ap-floor2-zone1">AP Floor 2 Zone 1</option><option value="ap-floor3-zone1">AP Floor 3 Zone 1</option><option value="ap-floor4-zone1">AP Floor 4 Zone 1</option><option value="ups-dc-1">UPS DC-1</option><option value="ups-dc-2">UPS DC-2</option><option value="cooling-1">CRAC Unit 1</option><option value="cooling-2">CRAC Unit 2</option></select>
<input type="color" id="add-line-color" value="#475569" title="Line color" style="width: 30px;height: 24px;border: 1px solid var(--toolbar-border);border-radius: 4px;cursor: pointer;background: transparent;padding: 0;">          <select id="add-line-direction" title="Line direction">
            <option value="none">No arrows</option>
            <option value="forward">‚Üí Forward</option>
            <option value="backward">‚Üê Backward</option>
            <option value="both">‚Üî Both</option>
          </select>
          <button id="add-line-btn">Add</button>
        </div>
        <div class="topology-toolbar bulk-toolbar-desktop" id="bulk-toolbar" style="display: none">
          <button type="button" class="toolbar-close-btn" id="bulk-toolbar-close" title="Clear selection">‚úï</button>
          <label style="font-weight: 600; color: var(--accent)">Selected: <span id="bulk-count">0</span></label>
          <button id="bulk-align-left" title="Align left">‚¨Ö Left</button>
          <button id="bulk-align-right" title="Align right">‚û° Right</button>
          <button id="bulk-align-top" title="Align top">‚¨Ü Top</button>
          <button id="bulk-align-bottom" title="Align bottom">‚¨á Bottom</button>
          <button id="bulk-distribute-h" title="Distribute horizontally">‚Üî Distribute H</button>
          <button id="bulk-distribute-v" title="Distribute vertically">‚Üï Distribute V</button>
          <button id="bulk-clone" title="Clone selected">üìã Clone</button>
          <button id="bulk-delete" title="Delete selected" style="background: var(--danger); color: white;">Delete</button>
        </div>
        <div class="bulk-toolbar-mobile" id="bulk-toolbar-mobile" style="display: none">
          <button type="button" id="bulk-mobile-btn" style="background: var(--accent);color: white;padding: 12px 20px;border-radius: 25px;font-weight: 600;font-size: 16px;box-shadow: 0 4px 12px rgba(0,0,0,0.3);border: none;cursor: pointer;display: flex;align-items: center;gap: 8px;">
          <span id="bulk-count-mobile">0</span>Selected</button>
        </div>
        <div id="bulk-actions-modal" style="display: none;position: fixed;bottom: 0;left: 0;right: 0;background: var(--panel-alt);border-top-left-radius:20px;border-top-right-radius:20px;padding:20px;padding-bottom:(safe-area-inset-bottom, 20px);box-shadow: 0 -4px 20px rgba(0,0,0,0.5);z-index: 10000;max-height: calc(100vh - 80px);overflow-y: auto;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            <h3 style="margin: 0; color: var(--accent); font-size: 20px;">
              <span id="bulk-count-modal">0</span> Nodes Selected
            </h3>
            <button id="bulk-modal-close" style="background: none;border: none;font-size: 24px;cursor: pointer;color: var(--text-main);padding: 0;width: 32px;height: 32px;">‚úï</button>
          </div>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
            <button id="bulk-align-left-mobile" class="bulk-action-btn">‚¨Ö<br><span style="font-size: 12px;">Align Left</span></button>
            <button id="bulk-align-right-mobile" class="bulk-action-btn">‚û°<br><span style="font-size: 12px;">Align Right</span></button>
            <button id="bulk-align-top-mobile" class="bulk-action-btn">‚¨Ü<br><span style="font-size: 12px;">Align Top</span></button>
            <button id="bulk-align-bottom-mobile" class="bulk-action-btn">‚¨á<br><span style="font-size: 12px;">Align Bottom</span></button>
            <button id="bulk-distribute-h-mobile" class="bulk-action-btn">‚Üî<br><span style="font-size: 12px;">Distribute H</span></button>
            <button id="bulk-distribute-v-mobile" class="bulk-action-btn">‚Üï<br><span style="font-size: 12px;">Distribute V</span></button>
            <button id="bulk-lock-mobile" class="bulk-action-btn">üîí<br><span style="font-size: 12px;">Lock Toggle</span></button>
            <button id="bulk-group-mobile" class="bulk-action-btn">‚≠ï<br><span style="font-size: 12px;">Group Toggle</span></button>
            <button id="bulk-clone-mobile" class="bulk-action-btn">üìã<br><span style="font-size: 12px;">Clone All</span></button>
            <button id="bulk-delete-mobile" class="bulk-action-btn" style="background: var(--danger); color: white;">üóë<br><span style="font-size: 12px;">Delete All</span></button>
          </div>
          <button id="bulk-clear-mobile" style="width: 100%;margin-top: 16px;padding: 14px;background: var(--panel-main);border: 1px solid var(--edge-main);border-radius: 8px;color: var(--text-main);font-size: 16px;cursor: pointer;">Clear Selection</button>
        </div>
        <div class="canvas-hint" id="canvas-hint"></div>
        <div class="legend-container" id="edge-legend" style="display: flex;"><div class="legend-title">Line Legend</div><button type="button" class="legend-close-btn">‚úï</button><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(85, 226, 8); cursor: pointer;"></span><span class="legend-label" contenteditable="true">ISP LINE</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(76, 0, 255); cursor: pointer;"></span><span class="legend-label" contenteditable="true">MY Guest NETWORK</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(128, 255, 0); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(251, 0, 255); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(255, 0, 208); cursor: pointer;"></span><span class="legend-label" contenteditable="true">iPhone (always guest iPhone)</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(249, 115, 22); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div></div>
        <div class="canvas-viewport" id="canvas-viewport">
          <svg id="map" viewBox="1254.5197896196048 -147.55422459755366 2648.185035176588 1986.138776382441" style=""><defs><marker id="arrow-forward" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto" markerUnits="strokeWidth"><path d="M0,0 L0,6 L9,3 z" fill="context-stroke"></path></marker><marker id="arrow-backward" markerWidth="10" markerHeight="10" refX="0" refY="3" orient="auto" markerUnits="strokeWidth"><path d="M9,0 L9,6 L0,3 z" fill="context-stroke"></path></marker></defs><rect x="100" y="100" width="3800" height="2800" fill="none" stroke="#4755694D" stroke-width="20" stroke-dasharray="10 5" rx="8"></rect><g id="canvas-grid"><line x1="100" y1="100" x2="100" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="150" y1="100" x2="150" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="200" y1="100" x2="200" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="250" y1="100" x2="250" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="300" y1="100" x2="300" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="350" y1="100" x2="350" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="400" y1="100" x2="400" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="450" y1="100" x2="450" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="500" y1="100" x2="500" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="550" y1="100" x2="550" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="600" y1="100" x2="600" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="650" y1="100" x2="650" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="700" y1="100" x2="700" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="750" y1="100" x2="750" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="800" y1="100" x2="800" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="850" y1="100" x2="850" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="900" y1="100" x2="900" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="950" y1="100" x2="950" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1000" y1="100" x2="1000" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1050" y1="100" x2="1050" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1100" y1="100" x2="1100" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="1150" y1="100" x2="1150" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1200" y1="100" x2="1200" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1250" y1="100" x2="1250" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1300" y1="100" x2="1300" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1350" y1="100" x2="1350" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="1400" y1="100" x2="1400" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1450" y1="100" x2="1450" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1500" y1="100" x2="1500" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1550" y1="100" x2="1550" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1600" y1="100" x2="1600" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="1650" y1="100" x2="1650" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1700" y1="100" x2="1700" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1750" y1="100" x2="1750" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1800" y1="100" x2="1800" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1850" y1="100" x2="1850" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="1900" y1="100" x2="1900" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1950" y1="100" x2="1950" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2000" y1="100" x2="2000" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2050" y1="100" x2="2050" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2100" y1="100" x2="2100" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="2150" y1="100" x2="2150" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2200" y1="100" x2="2200" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2250" y1="100" x2="2250" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2300" y1="100" x2="2300" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2350" y1="100" x2="2350" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="2400" y1="100" x2="2400" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2450" y1="100" x2="2450" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2500" y1="100" x2="2500" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2550" y1="100" x2="2550" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2600" y1="100" x2="2600" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="2650" y1="100" x2="2650" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2700" y1="100" x2="2700" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2750" y1="100" x2="2750" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2800" y1="100" x2="2800" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2850" y1="100" x2="2850" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="2900" y1="100" x2="2900" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2950" y1="100" x2="2950" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3000" y1="100" x2="3000" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3050" y1="100" x2="3050" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3100" y1="100" x2="3100" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="3150" y1="100" x2="3150" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3200" y1="100" x2="3200" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3250" y1="100" x2="3250" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3300" y1="100" x2="3300" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3350" y1="100" x2="3350" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="3400" y1="100" x2="3400" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3450" y1="100" x2="3450" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3500" y1="100" x2="3500" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3550" y1="100" x2="3550" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3600" y1="100" x2="3600" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="3650" y1="100" x2="3650" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3700" y1="100" x2="3700" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3750" y1="100" x2="3750" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3800" y1="100" x2="3800" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3850" y1="100" x2="3850" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="3900" y1="100" x2="3900" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="100" x2="3900" y2="100" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="150" x2="3900" y2="150" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="200" x2="3900" y2="200" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="250" x2="3900" y2="250" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="300" x2="3900" y2="300" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="350" x2="3900" y2="350" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="400" x2="3900" y2="400" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="450" x2="3900" y2="450" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="500" x2="3900" y2="500" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="550" x2="3900" y2="550" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="600" x2="3900" y2="600" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="650" x2="3900" y2="650" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="700" x2="3900" y2="700" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="750" x2="3900" y2="750" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="800" x2="3900" y2="800" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="850" x2="3900" y2="850" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="900" x2="3900" y2="900" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="950" x2="3900" y2="950" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1000" x2="3900" y2="1000" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1050" x2="3900" y2="1050" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1100" x2="3900" y2="1100" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="1150" x2="3900" y2="1150" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1200" x2="3900" y2="1200" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1250" x2="3900" y2="1250" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1300" x2="3900" y2="1300" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1350" x2="3900" y2="1350" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="1400" x2="3900" y2="1400" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1450" x2="3900" y2="1450" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1500" x2="3900" y2="1500" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1550" x2="3900" y2="1550" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1600" x2="3900" y2="1600" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="1650" x2="3900" y2="1650" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1700" x2="3900" y2="1700" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1750" x2="3900" y2="1750" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1800" x2="3900" y2="1800" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1850" x2="3900" y2="1850" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="1900" x2="3900" y2="1900" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1950" x2="3900" y2="1950" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2000" x2="3900" y2="2000" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2050" x2="3900" y2="2050" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2100" x2="3900" y2="2100" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="2150" x2="3900" y2="2150" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2200" x2="3900" y2="2200" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2250" x2="3900" y2="2250" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2300" x2="3900" y2="2300" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2350" x2="3900" y2="2350" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="2400" x2="3900" y2="2400" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2450" x2="3900" y2="2450" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2500" x2="3900" y2="2500" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2550" x2="3900" y2="2550" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2600" x2="3900" y2="2600" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="2650" x2="3900" y2="2650" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2700" x2="3900" y2="2700" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2750" x2="3900" y2="2750" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2800" x2="3900" y2="2800" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2850" x2="3900" y2="2850" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="2900" x2="3900" y2="2900" stroke="#47556933" stroke-width="1"></line></g><g class="rect-group" data-rect-id="rect-1765238219615"><rect class="rect-shape" x="2680.053955078125" y="251.44879150390625" width="814.10400390625" height="389.26678466796875" style="fill: rgb(236, 9, 153); fill-opacity: 0.3; stroke: rgb(236, 9, 153); stroke-width: 2px; stroke-dasharray: none; cursor: move;"></rect><g class="rect-delete-btn" style="cursor: pointer; display: none;"><circle cx="3484.157958984375" cy="261.44879150390625" r="12" style="fill: rgb(245, 101, 101); stroke: white; stroke-width: 2;"></circle><text x="3484.157958984375" y="261.44879150390625" text-anchor="middle" dominant-baseline="middle" style="fill: white; font-size: 16px; font-weight: bold; pointer-events: none;">√ó</text></g></g><path d="M 2103.968290880771 268 Q 2085.4680212352528 370.70595670887826 2066.9677515897347 473.4119134177565" fill="none" class="edge" data-edge-id="internet-internet-copy-1765238145151" data-from="internet" data-to="internet-copy" style="stroke: rgb(85, 226, 8); stroke-width: 4;"></path><path d="M 2103.968290880771 268 Q 2085.4680212352528 370.70595670887826 2066.9677515897347 473.4119134177565" fill="none" data-edge-id="internet-internet-copy-1765238145151" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 1920.4039088162972 569.9938683738112 1773.8400660428597 666.5758233298659" fill="none" class="edge" data-edge-id="internet-copy-opnsense-copy-1765238187451" data-from="internet-copy" data-to="opnsense-copy" style="stroke: rgb(76, 0, 255); stroke-width: 4;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 1920.4039088162972 569.9938683738112 1773.8400660428597 666.5758233298659" fill="none" data-edge-id="internet-copy-opnsense-copy-1765238187451" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 1999.08282329894 627.8447547749242 1931.1978950081452 782.2775961320921" fill="none" class="edge" data-edge-id="internet-copy-docker-copy-1765238242477" data-from="internet-copy" data-to="docker-copy" style="stroke: rgb(76, 0, 255); stroke-width: 4;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 1999.08282329894 627.8447547749242 1931.1978950081452 782.2775961320921" fill="none" data-edge-id="internet-copy-docker-copy-1765238242477" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2112.546995662221 620.5620704487524 2158.1262397347077 767.7122274797483" fill="none" class="edge" data-edge-id="internet-copy-docker-copy-1-1765238244637" data-from="internet-copy" data-to="docker-copy-1" style="stroke: rgb(76, 0, 255); stroke-width: 4;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2112.546995662221 620.5620704487524 2158.1262397347077 767.7122274797483" fill="none" data-edge-id="internet-copy-docker-copy-1-1765238244637" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2204.617064021596 552.590055067893 2342.2663764534577 631.7681967180296" fill="none" class="edge" data-edge-id="internet-copy-docker-copy-2-1765238246233" data-from="internet-copy" data-to="docker-copy-2" style="stroke: rgb(76, 0, 255); stroke-width: 4;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2204.617064021596 552.590055067893 2342.2663764534577 631.7681967180296" fill="none" data-edge-id="internet-copy-docker-copy-2-1765238246233" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2103.968290880771 268 Q 2430.923885484287 287.80585580459456 2757.879480087803 307.6117116091891" fill="none" class="edge" data-edge-id="internet-opnsense-copy-1-1765238266117" data-from="internet" data-to="opnsense-copy-1" style="stroke: rgb(128, 255, 0); stroke-width: 4;"></path><path d="M 2103.968290880771 268 Q 2430.923885484287 287.80585580459456 2757.879480087803 307.6117116091891" fill="none" data-edge-id="internet-opnsense-copy-1-1765238266117" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2757.879480087803 307.6117116091891 Q 2979.171899521397 314.04065142852505 3200.4643189549906 320.469591247861" fill="none" class="edge" data-edge-id="opnsense-copy-1-dns-1765238347996" data-from="opnsense-copy-1" data-to="dns" style="stroke: rgb(251, 0, 255); stroke-width: 4;"></path><path d="M 2757.879480087803 307.6117116091891 Q 2979.171899521397 314.04065142852505 3200.4643189549906 320.469591247861" fill="none" data-edge-id="opnsense-copy-1-dns-1765238347996" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 3200.4643189549906 320.469591247861 Q 3086.0821778417094 400.59916888457974 2971.700036728428 480.7287465212985" fill="none" class="edge" data-edge-id="dns-desktop-1765238386101" data-from="dns" data-to="desktop" style="stroke: rgb(255, 0, 208); stroke-width: 4;"></path><path d="M 3200.4643189549906 320.469591247861 Q 3086.0821778417094 400.59916888457974 2971.700036728428 480.7287465212985" fill="none" data-edge-id="dns-desktop-1765238386101" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 3312.857751572178 502.58220111114224 Q 3256.6610352635844 411.5258961795016 3200.4643189549906 320.469591247861" fill="none" class="edge" data-edge-id="phone-dns-1765238391156" data-from="phone" data-to="dns" style="stroke: rgb(255, 0, 208); stroke-width: 4;"></path><path d="M 3312.857751572178 502.58220111114224 Q 3256.6610352635844 411.5258961795016 3200.4643189549906 320.469591247861" fill="none" data-edge-id="phone-dns-1765238391156" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><polyline class="edge" data-edge-id="custom-1765239449323" fill="none" marker-end="url(#arrow-forward)" points="2936.464111328125,786.07958984375 3184.112060546875,887.6153564453125 2763.110107421875,981.7216796875" style="stroke: rgb(249, 115, 22); stroke-width: 4; stroke-dasharray: none;"></polyline><polyline points="2936.464111328125,786.07958984375 3184.112060546875,887.6153564453125 2763.110107421875,981.7216796875" data-edge-id="custom-1765239449323" style="fill: none; stroke: transparent; stroke-width: 20; cursor: pointer;"></polyline><g class="node-group" data-node-id="internet" transform="translate(2103.968290880771,268)" style="cursor: grab;"><circle r="252" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" viewBox="0 0 512 512" width="201.6" height="201.6" x="-100.8" y="-100.8" style="fill: rgb(255, 255, 255); stroke: rgb(255, 255, 255);"><path d="M144.3 214.1c0 6.3.7 11.4 1.9 15.2 1.4 3.7 3.1 7.8 5.4 12.3.9 1.4 1.2 2.7 1.2 3.9 0 1.7-1 3.4-3.2 5.1l-10.7 7.2c-1.5 1-3.1 1.5-4.4 1.5-1.7 0-3.4-.9-5.1-2.4-2.4-2.6-4.4-5.3-6.1-8-1.7-2.9-3.4-6.1-5.3-10-13.3 15.7-30 23.5-50.1 23.5-14.3 0-25.7-4.1-34.1-12.3-8.3-8.2-12.6-19.1-12.6-32.7 0-14.5 5.1-26.2 15.5-35.1S60.8 169 78.4 169c5.8 0 11.7.5 18.1 1.4s12.8 2.2 19.6 3.7v-12.4c0-12.9-2.7-22-8-27.2-5.4-5.3-14.6-7.8-27.8-7.8-6 0-12.1.7-18.4 2.2s-12.4 3.4-18.4 5.8c-2.7 1.2-4.8 1.9-6 2.2s-2 .5-2.7.5c-2.4 0-3.6-1.7-3.6-5.3v-8.3c0-2.7.3-4.8 1.2-6s2.4-2.4 4.8-3.6c6-3.1 13.1-5.6 21.5-7.7 8.3-2.2 17.2-3.2 26.6-3.2 20.3 0 35.1 4.6 44.6 13.8 9.4 9.2 14.1 23.2 14.1 41.9v55.2zM75.2 240c5.6 0 11.4-1 17.5-3.1 6.1-2 11.6-5.8 16.2-10.9 2.7-3.2 4.8-6.8 5.8-10.9s1.7-9 1.7-14.8v-7.2c-4.9-1.2-10.2-2.2-15.7-2.9-5.4-.7-10.7-1-16-1-11.4 0-19.8 2.2-25.4 6.8S51 207.1 51 215.6c0 8 2 14 6.3 18.1 4.1 4.2 10 6.3 17.9 6.3m136.7 18.4c-3.1 0-5.1-.5-6.5-1.7-1.4-1-2.6-3.4-3.6-6.6l-40-131.6c-1-3.4-1.5-5.6-1.5-6.8 0-2.7 1.4-4.3 4.1-4.3h16.7c3.2 0 5.4.5 6.6 1.7 1.4 1 2.4 3.4 3.4 6.6l28.6 112.7 26.6-112.7c.9-3.4 1.9-5.6 3.2-6.6 1.4-1 3.7-1.7 6.8-1.7H270c3.2 0 5.4.5 6.8 1.7 1.4 1 2.6 3.4 3.2 6.6l26.9 114.1 29.5-114.1c1-3.4 2.2-5.6 3.4-6.6 1.4-1 3.6-1.7 6.6-1.7h15.8c2.7 0 4.3 1.4 4.3 4.3 0 .9-.2 1.7-.3 2.7-.2 1-.5 2.4-1.2 4.3l-41 131.6q-1.5 5.1-3.6 6.6c-1.4 1-3.6 1.7-6.5 1.7h-14.6c-3.2 0-5.4-.5-6.8-1.7s-2.6-3.4-3.2-6.8l-26.4-109.8L236.7 250c-.9 3.4-1.9 5.6-3.2 6.8-1.4 1.2-3.7 1.7-6.8 1.7zm218.8 4.6c-8.9 0-17.7-1-26.2-3.1-8.5-2-15.2-4.3-19.6-6.8-2.7-1.5-4.6-3.2-5.3-4.8s-1-3.2-1-4.8v-8.7c0-3.6 1.4-5.3 3.9-5.3 1 0 2 .2 3.1.5 1 .3 2.6 1 4.3 1.7 5.8 2.6 12.1 4.6 18.7 6 6.8 1.4 13.5 2 20.3 2 10.7 0 19.1-1.9 24.9-5.6s8.9-9.2 8.9-16.2c0-4.8-1.5-8.7-4.6-11.9s-8.9-6.1-17.2-8.9l-24.7-7.7c-12.4-3.9-21.6-9.7-27.2-17.4-5.6-7.5-8.5-15.8-8.5-24.7 0-7.2 1.5-13.5 4.6-18.9s7.2-10.2 12.3-14c5.1-3.9 10.9-6.8 17.7-8.9 6.8-2 14-2.9 21.5-2.9 3.7 0 7.7.2 11.4.7 3.9.5 7.5 1.2 11.1 1.9 3.4.9 6.6 1.7 9.7 2.7s5.4 2 7.2 3.1c2.4 1.4 4.1 2.7 5.1 4.3 1 1.4 1.5 3.2 1.5 5.6v8c0 3.6-1.4 5.4-3.9 5.4-1.4 0-3.6-.7-6.5-2q-14.55-6.6-32.7-6.6c-9.7 0-17.4 1.5-22.6 4.8s-8 8.2-8 15.2c0 4.8 1.7 8.9 5.1 12.1s9.7 6.5 18.7 9.4l24.2 7.7c12.3 3.9 21.1 9.4 26.4 16.3s7.8 15 7.8 23.8c0 7.3-1.5 14-4.4 19.8-3.1 5.8-7.2 10.9-12.4 15-5.3 4.3-11.6 7.3-18.9 9.5-8 2.5-16 3.7-24.7 3.7" style="fill: rgb(255, 255, 255); stroke: rgb(255, 255, 255);"></path><path d="M462.9 345.7c-56 41.4-137.4 63.3-207.4 63.3-98.1 0-186.5-36.3-253.2-96.6-5.3-4.8-.5-11.2 5.8-7.5 72.2 41.9 161.3 67.3 253.4 67.3 62.2 0 130.4-12.9 193.3-39.5 9.3-4.2 17.3 6.2 8.1 13m23.3-26.5c-7.2-9.2-47.3-4.4-65.6-2.2-5.4.7-6.3-4.1-1.4-7.7 32-22.5 84.6-16 90.8-8.5 6.1 7.7-1.7 60.3-31.7 85.5-4.6 3.9-9 1.9-7-3.2 6.9-16.9 22.1-54.9 14.9-63.9" style="fill-rule: evenodd; clip-rule: evenodd; fill: rgb(255, 255, 255); stroke: rgb(255, 255, 255);"></path></svg></g><text class="node-label" x="0" y="-47.040000000000006" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Internet</text><text class="node-sub" x="0" y="67.2" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="internet-copy" transform="translate(2066.9677515897347,473.4119134177565)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" viewBox="0 0 512 512" width="66" height="66" x="-33" y="-33"><path d="M512 160.2V400H400V112H112V0h240.4zM112 112H0v240.4L160.2 512H400V400H112z" style="fill:#de3c07"></path></svg></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">OPNSENSE</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="opnsense-copy" transform="translate(1773.8400660428597,666.5758233298659)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" viewBox="0 0 512 512" width="66" height="66" x="-33" y="-33"><path d="M462.2 512H49.8C22.3 512 0 489.7 0 462.2V49.8C0 22.3 22.3 0 49.8 0h412.4C489.7 0 512 22.3 512 49.8v412.4c0 27.5-22.3 49.8-49.8 49.8" style="fill:#2e2f33"></path><path d="M108.2 63.9h140.9c97.2 0 154.6 30.4 154.6 129.5v3.4c0 99.4-57.2 129.5-154.5 129.5h-30.7V447H108.2zm134.5 177.8c30.1 0 46-11.2 46-44.6v-3.9c0-33.2-15.8-44.6-46-44.6h-24.2v93.1zM313 358h90.3v90.1H313z" style="fill:#f7f6f3"></path></svg></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Docker</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="docker-copy" transform="translate(1931.1978950081452,782.2775961320921)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" viewBox="0 0 512 512" width="66" height="66" x="-33" y="-33"><path d="M438.6 0H73.4C33.1 0 .3 32.8.3 73.1v365.7c0 40.3 32.8 73.1 73.1 73.1h365.3c40.3 0 73.1-32.8 73.1-73.1V73.1C511.7 32.8 478.9 0 438.6 0" style="fill-rule:evenodd;clip-rule:evenodd;fill:#8b3bd0"></path><path d="M356.8 53.6v261.3c0 39.3-13.9 72.8-41.8 100.7s-61.4 41.8-100.7 41.8l-23.8-95h23.8c13 0 24.1-4.6 33.2-13.8 9.5-9.5 14.3-20.7 14.3-33.7V148.6H157.3v-95z" style="fill:#fff"></path></svg></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Docker2</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="docker-copy-1" transform="translate(2158.1262397347077,767.7122274797483)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" viewBox="0 0 512 512" width="66" height="66" x="-33" y="-33"><path d="M0 0h512v512H0z" style="fill:#111827"></path><path d="M170.7 85.3 369.8 256 170.7 426.7z" style="fill:#f59e0b"></path></svg></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Docker3</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="docker-copy-2" transform="translate(2342.2663764534577,631.7681967180296)" style="cursor: grab;"><circle r="123" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" viewBox="0 0 512 512" width="98.39999999999999" height="98.39999999999999" x="-49.199999999999996" y="-49.199999999999996"><path d="M501.4 212.3c-11.5-8-38-11-58.6-7-2.4-20-13.5-37.5-32.7-53l-11-8-7.7 11.5c-9.6 15-14.4 36-13 56 .5 7 2.9 19.5 10.1 30.5-6.7 4-20.7 9-38.9 9H2.3l-1 4c-3.4 20-3.4 82.5 36 130.5 29.8 36.5 74 55 132.1 55 125.9 0 219.1-60.5 262.8-170 17.3.5 54.3 0 73-37.5.5-1 1.4-3 4.8-10.5l1.9-4zM280 71.3h-52.8v50H280zm0 60h-52.8v50H280zm-62.5 0h-52.8v50h52.8zm-62.4 0h-52.8v50h52.8zm-62.5 60H39.8v50h52.8zm62.5 0h-52.8v50h52.8zm62.4 0h-52.8v50h52.8zm62.5 0h-52.8v50H280zm62.4 0h-52.8v50h52.8z" style="fill:#2396ed"></path></svg></g><text class="node-label" x="0" y="-22.96" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Docker 4</text><text class="node-sub" x="0" y="32.800000000000004" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="opnsense-copy-1" transform="translate(2757.879480087803,307.6117116091891)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" viewBox="0 0 512 512" width="66" height="66" x="-33" y="-33"><path d="M503.1 465.4v2.1c-6 25.5-28.4 44.5-55 44.5H7.3v-46.6h38.3v7.3h403c1.1 0 2 0 2.9-.1 1.8-.1 3.6-.6 5.2-1.3 2.9-1.3 5.3-3.3 7-5.9zM63.9 0c-26.5 0-49 19-55 44.5V47H48c2.7-4.3 7.3-7.2 12.6-7.6 1-.1 2-.1 3.2-.1h402.6V47h38.3V0z" style="fill:#898b8d"></path><path d="M466.1 157.7V197H319.5v-39.3zM45.9 315.4v39.3h146.6v-39.3zm0-157.7V197h146.6v-39.3zm273.6 157.7v39.3h146.6v-39.3z" style="fill:#58595b"></path><path d="M83.8 78.6H428v39.3H83.8zm0 315.9H428v39.3H83.8z" style="fill:#403f41"></path><linearGradient id="opnsense-v1_svg__a" x1="-1460.617" x2="-1375.11" y1="1248.095" y2="1248.095" gradientTransform="matrix(.1853 .356 .6722 -.353 -90.66 993.802)" gradientUnits="userSpaceOnUse"><stop offset="0" style="stop-color:#737373"></stop><stop offset="1" style="stop-color:#333"></stop></linearGradient><path d="m466.5 78.6 38.2-20.5.1-39.5-38.3 20.7" style="fill:url(#opnsense-v1_svg__a)"></path><linearGradient id="opnsense-v1_svg__b" x1="4.634" x2="50.301" y1="462.6" y2="462.6" gradientTransform="matrix(1 0 0 -1 0 514)" gradientUnits="userSpaceOnUse"><stop offset="0" style="stop-color:#737373"></stop><stop offset="1" style="stop-color:#333"></stop></linearGradient><path d="M45.6 64.5v-8.9c0-5.3 2.6-10 6.5-13l-34-18.5c-6.7 9.5-10.8 21.3-10.9 34l38.3 20.6v-14c.1-.1.1-.2.1-.2" style="fill:url(#opnsense-v1_svg__b)"></path><linearGradient id="opnsense-v1_svg__c" x1="-1587.887" x2="-1498.137" y1="-2208.165" y2="-2208.165" gradientTransform="matrix(-.1853 -.356 -.6722 .353 -1743.836 694.098)" gradientUnits="userSpaceOnUse"><stop offset="0" style="stop-color:#737373"></stop><stop offset="1" style="stop-color:#333"></stop></linearGradient><path d="M45.6 472.7v-38.9L7.3 454.5v39.7l39.9-21.5z" style="fill:url(#opnsense-v1_svg__c)"></path><linearGradient id="opnsense-v1_svg__d" x1="460.439" x2="504.436" y1="53" y2="53" gradientTransform="matrix(1 0 0 -1 0 514)" gradientUnits="userSpaceOnUse"><stop offset="0" style="stop-color:#737373"></stop><stop offset="1" style="stop-color:#333"></stop></linearGradient><path d="M466.5 456.4c0 5.5-2.7 10.3-6.9 13.2l34.2 18.4c6.8-9.5 10.8-21.2 10.9-33.8L466.5 434v12.8" style="fill:url(#opnsense-v1_svg__d)"></path><linearGradient id="opnsense-v1_svg__e" x1="2521.902" x2="2684.464" y1="-2476.233" y2="-2476.233" gradientTransform="matrix(-1.508 -1.0166 -3.1265 -1.519 -3697.438 -937.952)" gradientUnits="userSpaceOnUse"><stop offset=".107" style="stop-color:#58595b"></stop><stop offset="1" style="stop-color:#000"></stop></linearGradient><path d="M192.5 197v-.4l-72.4-38.9H45.9v.2l72.5 39.1z" style="fill:url(#opnsense-v1_svg__e)"></path><linearGradient id="opnsense-v1_svg__f" x1="-1594.953" x2="-1432.391" y1="278.458" y2="278.458" gradientTransform="matrix(1.508 -1.0166 3.1265 -1.519 1804.196 -937.952)" gradientUnits="userSpaceOnUse"><stop offset=".107" style="stop-color:#58595b"></stop><stop offset="1" style="stop-color:#000"></stop></linearGradient><path d="M466.1 157.7h-74l-72.6 39.1v.2h74.2l72.4-38.9z" style="fill:url(#opnsense-v1_svg__f)"></path><linearGradient id="opnsense-v1_svg__g" x1="-4327.142" x2="-4164.581" y1="1572.387" y2="1572.387" gradientTransform="matrix(1.508 1.0166 3.1265 1.519 1863.938 2252.352)" gradientUnits="userSpaceOnUse"><stop offset=".107" style="stop-color:#58595b"></stop><stop offset="1" style="stop-color:#000"></stop></linearGradient><path d="M466.1 354.7v-.4l-72.4-38.9h-74.2v.2l72.6 39.1z" style="fill:url(#opnsense-v1_svg__g)"></path><linearGradient id="opnsense-v1_svg__h" x1="-413.668" x2="-246.99" y1="-1046.618" y2="-1046.618" gradientTransform="matrix(-1.508 1.0166 -3.1265 1.519 -3638.692 2252.352)" gradientUnits="userSpaceOnUse"><stop offset=".107" style="stop-color:#58595b"></stop><stop offset="1" style="stop-color:#000"></stop></linearGradient><path d="M192.5 315.4h-74.1l-72.5 39.1v.2h74.2l72.4-38.9z" style="fill:url(#opnsense-v1_svg__h)"></path><linearGradient id="opnsense-v1_svg__i" x1="74.725" x2="261.062" y1="132.65" y2="132.65" gradientTransform="matrix(.9914 0 0 -1 -66.782 260.2)" gradientUnits="userSpaceOnUse"><stop offset=".237" style="stop-color:#a6a8ab"></stop><stop offset="1" style="stop-color:#404040"></stop></linearGradient><path d="M192.8 157.7V197L7.3 97.4V58.1z" style="fill:url(#opnsense-v1_svg__i)"></path><linearGradient id="opnsense-v1_svg__j" x1="-2461.056" x2="-2274.718" y1="132.65" y2="132.65" gradientTransform="matrix(-.9914 0 0 -1 -1935.19 260.2)" gradientUnits="userSpaceOnUse"><stop offset=".237" style="stop-color:#a6a8ab"></stop><stop offset="1" style="stop-color:#404040"></stop></linearGradient><path d="M319.2 157.7V197l185.5-99.6V58.1z" style="fill:url(#opnsense-v1_svg__j)"></path><linearGradient id="opnsense-v1_svg__k" x1="-2291.845" x2="-2105.508" y1="-739.55" y2="-739.55" gradientTransform="matrix(-.9914 0 0 1 -1767.435 1124.6)" gradientUnits="userSpaceOnUse"><stop offset=".237" style="stop-color:#a6a8ab"></stop><stop offset="1" style="stop-color:#404040"></stop></linearGradient><path d="M319.2 355.2v-39.8L504.7 415v39.7z" style="fill:url(#opnsense-v1_svg__k)"></path><linearGradient id="opnsense-v1_svg__l" x1="-94.103" x2="91.934" y1="-739.55" y2="-739.55" gradientTransform="matrix(.9914 0 0 1 100.993 1124.6)" gradientUnits="userSpaceOnUse"><stop offset=".237" style="stop-color:#a6a8ab"></stop><stop offset="1" style="stop-color:#404040"></stop></linearGradient><path d="M192.8 355.2v-39.8L7.3 415v39.7z" style="fill:url(#opnsense-v1_svg__l)"></path><path d="m319.2 276.1 108.9 58.5v-39.7l-35.3-18.8h111.9v-39.8H392.8l35.3-18.8v-39.3l-108.9 58.1zM83.8 334.6l109-58.5v-39.8l-109-58.1v39.3l35.7 18.8H7.3v39.8h111.9l-35.3 18.8v39.7z" style="fill:#e24525"></path></svg></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">OPNSENSE GUEST</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="phone" transform="translate(3312.857751572178,502.58220111114224)" style="cursor: grab;"><circle r="181.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-54.45" y="-121" width="108.9" height="242" rx="8"></rect><rect x="-45.980000000000004" y="-102.85" width="91.96000000000001" height="193.60000000000002" rx="4" style="fill: rgb(30, 41, 59);"></rect><rect x="-18.15" y="99.22" width="36.3" height="7.26" rx="2" style="fill: rgb(71, 85, 105);"></rect></g><text class="node-label" x="0" y="-33.88" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Phone</text><text class="node-sub" x="0" y="48.400000000000006" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="desktop" transform="translate(2971.700036728428,480.7287465212985)" style="cursor: grab;"><circle r="220.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-132.3" y="-117.60000000000001" width="264.6" height="176.4" rx="4"></rect><rect x="-110.25" y="-95.55" width="220.5" height="132.3" rx="2" style="fill: rgb(30, 41, 59);"></rect><rect x="-22.05" y="58.800000000000004" width="44.1" height="44.1"></rect><rect x="-73.5" y="102.89999999999999" width="147" height="22.05" rx="2"></rect></g><text class="node-label" x="0" y="-41.160000000000004" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Desktop</text><text class="node-sub" x="0" y="58.800000000000004" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="dns" transform="translate(3200.4643189549906,320.469591247861)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><path d="
             M -44 11
             Q -60.50000000000001 11 -60.50000000000001 -5.5
             Q -60.50000000000001 -27.5 -38.5 -27.5
             Q -38.5 -49.5 -11 -49.5
             Q 5.5 -60.50000000000001 27.5 -44
             Q 55 -44 60.50000000000001 -16.5
             Q 71.5 -5.5 60.50000000000001 11
             Q 60.50000000000001 27.5 38.5 27.5
             L -27.5 27.5
             Q -49.5 27.5 -49.5 11
             Z
            " class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"></path><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">DNS</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="racked" transform="translate(2645.5845448279656,970.7820678889219)" style="cursor: grab;"><circle r="205.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" id="mdi-server-security" viewBox="0 0 24 24" width="164.4" height="164.4" x="-82.2" y="-82.2" style="fill: rgb(1, 8, 19); stroke: rgb(255, 255, 255);"><path d="M3,1H19A1,1 0 0,1 20,2V6A1,1 0 0,1 19,7H3A1,1 0 0,1 2,6V2A1,1 0 0,1 3,1M3,9H19A1,1 0 0,1 20,10V10.67L17.5,9.56L11,12.44V15H3A1,1 0 0,1 2,14V10A1,1 0 0,1 3,9M3,17H11C11.06,19.25 12,21.4 13.46,23H3A1,1 0 0,1 2,22V18A1,1 0 0,1 3,17M8,5H9V3H8V5M8,13H9V11H8V13M8,21H9V19H8V21M4,3V5H6V3H4M4,11V13H6V11H4M4,19V21H6V19H4M17.5,12L22,14V17C22,19.78 20.08,22.37 17.5,23C14.92,22.37 13,19.78 13,17V14L17.5,12M17.5,13.94L15,15.06V17.72C15,19.26 16.07,20.7 17.5,21.06V13.94Z" style="fill: rgb(1, 8, 19); stroke: rgb(255, 255, 255);"></path></svg></g><text class="node-label" x="0" y="-38.36000000000001" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Racked</text><text class="node-sub" x="0" y="54.800000000000004" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;"></text></g><g class="text-group" data-text-id="text-1765238422602"><text class="text-element" x="2466.35986328125" y="741.6801147460938" dominant-baseline="middle" style="fill: rgb(226, 232, 240); font-size: 40px; font-weight: normal; font-style: normal; text-anchor: start; text-decoration: none; opacity: 1; cursor: move; user-select: none;"><tspan x="2466.35986328125" dy="0">Double click on desktop</tspan><tspan x="2466.35986328125" dy="48">or long press on mobile</tspan><tspan x="2466.35986328125" dy="48">to enter rack canvas view</tspan></text><g class="text-delete-btn" style="cursor: pointer; display: none;"><circle cx="2486.35986328125" cy="701.6801147460938" r="12" style="fill: rgb(245, 101, 101); stroke: white; stroke-width: 2;"></circle><text x="2486.35986328125" y="701.6801147460938" text-anchor="middle" dominant-baseline="middle" style="fill: white; font-size: 16px; font-weight: bold; pointer-events: none;">√ó</text></g></g></svg>
        </div>
        <div class="minimap-zoom-wrapper" id="minimap-zoom-wrapper" style="display: block;">
          <button type="button" class="minimap-close-btn" id="minimap-close-btn" title="Hide map &amp; zoom">‚úï</button>
          <div class="minimap-container" id="minimap-container">
            <svg id="minimap" viewBox="0 0 4000 3000">
              <line x1="2103.968290880771" y1="268" x2="2066.9677515897347" y2="473.4119134177565" class="minimap-edge"></line><line x1="2066.9677515897347" y1="473.4119134177565" x2="1773.8400660428597" y2="666.5758233298659" class="minimap-edge"></line><line x1="2066.9677515897347" y1="473.4119134177565" x2="1931.1978950081452" y2="782.2775961320921" class="minimap-edge"></line><line x1="2066.9677515897347" y1="473.4119134177565" x2="2158.1262397347077" y2="767.7122274797483" class="minimap-edge"></line><line x1="2066.9677515897347" y1="473.4119134177565" x2="2342.2663764534577" y2="631.7681967180296" class="minimap-edge"></line><line x1="2103.968290880771" y1="268" x2="2757.879480087803" y2="307.6117116091891" class="minimap-edge"></line><line x1="2757.879480087803" y1="307.6117116091891" x2="3200.4643189549906" y2="320.469591247861" class="minimap-edge"></line><line x1="3200.4643189549906" y1="320.469591247861" x2="2971.700036728428" y2="480.7287465212985" class="minimap-edge"></line><line x1="3312.857751572178" y1="502.58220111114224" x2="3200.4643189549906" y2="320.469591247861" class="minimap-edge"></line><circle cx="2103.968290880771" cy="268" r="40" class="minimap-node"></circle><circle cx="2066.9677515897347" cy="473.4119134177565" r="40" class="minimap-node"></circle><circle cx="1773.8400660428597" cy="666.5758233298659" r="40" class="minimap-node"></circle><circle cx="1931.1978950081452" cy="782.2775961320921" r="40" class="minimap-node"></circle><circle cx="2158.1262397347077" cy="767.7122274797483" r="40" class="minimap-node"></circle><circle cx="2342.2663764534577" cy="631.7681967180296" r="40" class="minimap-node"></circle><circle cx="2757.879480087803" cy="307.6117116091891" r="40" class="minimap-node"></circle><circle cx="3312.857751572178" cy="502.58220111114224" r="40" class="minimap-node"></circle><circle cx="2971.700036728428" cy="480.7287465212985" r="40" class="minimap-node"></circle><circle cx="3200.4643189549906" cy="320.469591247861" r="40" class="minimap-node"></circle><circle cx="2645.5845448279656" cy="970.7820678889219" r="40" class="minimap-node"></circle><rect class="minimap-viewport" id="minimap-viewport" x="1254.5197896196048" y="-147.55422459755366" width="2648.185035176588" height="1986.138776382441"></rect>
            </svg>
          </div>
          <div class="zoom-toolbar" id="zoom-toolbar">
            <button id="zoom-in-btn" title="Zoom in">+</button>
            <div class="zoom-level" id="zoom-level">151%</div>
            <button id="zoom-out-btn" title="Zoom out">-</button>
            <div class="divider"></div>
            <button id="zoom-fit-btn" title="Fit to view">[ ]</button>
            <button id="zoom-reset-btn" title="Reset view">R</button>
          </div>
        </div>
        <button type="button" id="edge-legend-mini" class="legend-mini-btn" style="bottom: 10px; display: none;">Line Legend</button>
        <button type="button" id="minimap-mini" class="legend-mini-btn" style="right: 10px; left: auto; bottom: 10px; display: none;">Map</button>
        <button type="button" id="draw-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: 10px; right: auto; display: none;">Draw</button>
        <button type="button" id="topology-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: auto; right: 40px; display: none;">Add Line</button>
     </section>
      <aside class="details-panel" id="details-panel">
        <div class="sidebar-resizer" id="sidebar-resizer">
          <svg class="resizer-icon" width="6" height="40" viewBox="0 0 6 40" xmlns="http://www.w3.org/2000/svg">
            <circle cx="3" cy="14" r="2"></circle>
            <circle cx="3" cy="20" r="2"></circle>
            <circle cx="3" cy="26" r="2"></circle>
          </svg>
        </div>
        <div class="mobile-footer-resizer" id="mobile-footer-resizer">
          <svg class="resizer-icon" width="40" height="6" viewBox="0 0 40 6" xmlns="http://www.w3.org/2000/svg">
            <circle cx="14" cy="3" r="2"></circle>
            <circle cx="20" cy="3" r="2"></circle>
            <circle cx="26" cy="3" r="2"></circle>
          </svg>
        </div>
        <div id="node-panel" style="display: none;">
          <div class="details-name editable-text" id="node-name">Core Router 1</div>
          <div class="details-ip editable-text" id="node-ip">10.0.0.1</div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">MAC:</span>
            <span class="editable-text" id="node-mac" style="flex: 1; cursor: pointer; color: var(--text-main);">00:1A:2B:3C:4D:01</span>
          </div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">Rack Unit:</span>
            <span class="editable-text" id="node-rack" style="flex: 1; cursor: pointer; color: var(--text-main);">--</span>
          </div>
          <div class="details-info-row" id="uheight-row" style="display: none;">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">U Height:</span>
            <span class="editable-text" id="node-uheight" style="flex: 1; cursor: pointer; color: var(--text-main);">2U</span>
          </div>
          <div class="details-info-row" id="assigned-rack-row" style="display: flex;">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">Assigned Rack:</span>
            <select id="node-assigned-rack" style="flex: 1; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;"><option value="">None</option><option value="dc-rack-a1">DC Rack A1</option><option value="dc-rack-a2">DC Rack A2</option><option value="dc-rack-b1">DC Rack B1</option><option value="dc-rack-b2">DC Rack B2</option><option value="dmz-rack">DMZ Rack</option><option value="mgmt-rack">Management Rack</option></select>
          </div>
          <div class="details-info-row" id="rack-capacity-row" style="display: none;">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">Rack Capacity:</span>
            <select id="node-rack-capacity" style="flex: 1; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;">
              <option value="42">42U</option>
              <option value="48">48U</option>
              <option value="24">24U</option>
              <option value="12">12U</option>
              <option value="6">6U</option>
            </select>
          </div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">Layer:</span>
            <select id="node-layer" style="flex: 1; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;">
              <option value="physical">Physical</option>
              <option value="logical">Logical</option>
              <option value="security">Security</option>
              <option value="application">Application</option>
            </select>
          </div>
          <div class="details-role" id="node-role">Core Routing</div>
		  <details id="rack-contents-section" style="display: none; margin-top: 12px; margin-bottom: 12px; padding: 10px; background: var(--panel-alt); border-radius: 6px;" open="">
            <summary style="color: var(--accent); font-weight: 600; font-size: 14px; cursor: pointer;">Nodes in Rack (<span id="rack-contents-count">0</span>)</summary>
            <div id="rack-contents-list" style="max-height: 200px; overflow-y: auto; margin-top: 8px;"></div>
          </details>
          <details id="node-connections-section" style="margin-top: 12px; margin-bottom: 12px; padding: 10px; background: var(--panel-alt); border-radius: 6px; display: block;">
            <summary style="color: var(--accent); font-weight: 600; font-size: 14px; cursor: pointer;">Connections (<span id="node-connections-count">9</span>)</summary>
            <div id="node-connections-list" style="max-height: 200px; overflow-y: auto; margin-top: 8px;"><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to view connection" style="color: var(--accent); font-family: monospace; cursor: pointer;">Gi1/0/1</span><span style="color: var(--text-soft); margin: 0px 8px;">‚Üî</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">ISP Primary</span><span title="Click to view connection" style="color: var(--accent); font-family: monospace; margin-left: 6px; cursor: pointer;">(Gi0/0)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to view connection" style="color: var(--accent); font-family: monospace; cursor: pointer;">Gi1/0/24</span><span style="color: var(--text-soft); margin: 0px 8px;">‚Üî</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">Core Router 2</span><span title="Click to view connection" style="color: var(--accent); font-family: monospace; margin-left: 6px; cursor: pointer;">(Gi1/0/24)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to set port" style="color: var(--text-soft); cursor: pointer;">-</span><span style="color: var(--text-soft); margin: 0px 8px;">‚Üî</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">External FW 1</span><span title="Click to set port" style="color: var(--text-soft); margin-left: 6px; cursor: pointer;">(-)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to set port" style="color: var(--text-soft); cursor: pointer;">-</span><span style="color: var(--text-soft); margin: 0px 8px;">‚Üî</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">NYC Branch Router</span><span title="Click to set port" style="color: var(--text-soft); margin-left: 6px; cursor: pointer;">(-)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to set port" style="color: var(--text-soft); cursor: pointer;">-</span><span style="color: var(--text-soft); margin: 0px 8px;">‚Üî</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">LA Branch Router</span><span title="Click to set port" style="color: var(--text-soft); margin-left: 6px; cursor: pointer;">(-)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to set port" style="color: var(--text-soft); cursor: pointer;">-</span><span style="color: var(--text-soft); margin: 0px 8px;">‚Üî</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">Chicago Branch Router</span><span title="Click to set port" style="color: var(--text-soft); margin-left: 6px; cursor: pointer;">(-)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to set port" style="color: var(--text-soft); cursor: pointer;">-</span><span style="color: var(--text-soft); margin: 0px 8px;">‚Üî</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">London Branch Router</span><span title="Click to set port" style="color: var(--text-soft); margin-left: 6px; cursor: pointer;">(-)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to set port" style="color: var(--text-soft); cursor: pointer;">-</span><span style="color: var(--text-soft); margin: 0px 8px;">‚Üî</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">Tokyo Branch Router</span><span title="Click to set port" style="color: var(--text-soft); margin-left: 6px; cursor: pointer;">(-)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to set port" style="color: var(--text-soft); cursor: pointer;">-</span><span style="color: var(--text-soft); margin: 0px 8px;">‚Üî</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">AWS Cloud</span><span title="Click to set port" style="color: var(--text-soft); margin-left: 6px; cursor: pointer;">(-)</span></div></div>
          </details>
          <div class="badge-row" id="node-tags"><span class="badge" style="cursor: pointer; position: relative;"><span>core</span><span style="opacity: 0.6; margin-left: 4px; font-size: 10px;"> ‚úï</span></span><span class="badge" style="cursor: pointer; position: relative;"><span>tier-1</span><span style="opacity: 0.6; margin-left: 4px; font-size: 10px;"> ‚úï</span></span><span class="badge" style="cursor: pointer; position: relative;"><span>redundant</span><span style="opacity: 0.6; margin-left: 4px; font-size: 10px;"> ‚úï</span></span><span class="badge" style="cursor: pointer; opacity: 0.6; border-style: dashed;">+ Add Tag</span></div>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-tag-input" placeholder="Add tag..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-tag-btn" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button class="pick-icon-btn" id="pick-tag-icon-btn">Add Icon Tag</button>
          <div class="section-label">Size</div>
          <div class="size-controls">
            <label>Size:</label>
            <input type="range" id="size-slider" min="20" max="200" value="55">
            <span id="size-value">55</span>
            <button id="reset-size">Reset</button>
          </div>
          <details class="style-section">
            <summary>Styling</summary>
            <div class="style-content">
              <div class="style-row">
                <label>Screen:</label>
                <select id="style-scope">
                  <option value="all">All</option>
                  <option value="desktop">Desktop</option>
                  <option value="tablet">Tablet</option>
                  <option value="mobile">Mobile</option>
                  <option value="fold">Fold</option>
                </select>
              </div>
              <div class="style-row">
                <label>Shape:</label>
                <select id="shape-select"><option value="custom-icon">Custom Icon</option>
                  <optgroup label="Basic Shapes">
            <option value="circle">Circle</option>
            <option value="square">Square</option>
            <option value="rectangle">Rectangle</option>
            <option value="triangle">Triangle</option>
            <option value="hexagon">Hexagon</option>
            <option value="diamond">Diamond</option>
            <option value="star">Star</option>
            <option value="stop-sign">Stop Sign</option>
            <option value="octagon">Octagon</option>
            <option value="pentagon">Pentagon</option>
            <option value="cross">Cross</option>
            <option value="rounded-square">Rounded Square</option>
            <option value="pill">Pill</option>
            <option value="parallelogram">Parallelogram</option>
            <option value="trapezoid">Trapezoid</option>
          </optgroup>
          <optgroup label="Computers &amp; Devices">
            <option value="server">Server</option>
            <option value="pc">PC / Desktop</option>
            <option value="laptop">Laptop</option>
            <option value="phone">Phone / Mobile</option>
            <option value="printer">Printer</option>
            <option value="pi">Raspberry Pi</option>
            <option value="sensor">Sensor / IoT</option>
          </optgroup>
          <optgroup label="Network Equipment">
            <option value="router">Router</option>
            <option value="switch">Switch</option>
            <option value="firewall">Firewall</option>
            <option value="access-point">Access Point</option>
            <option value="load-balancer">Load Balancer</option>
            <option value="gateway">Gateway</option>
            <option value="vpn">VPN / Tunnel</option>
            <option value="nas">NAS / Storage</option>
          </optgroup>
          <optgroup label="Cloud &amp; Services">
            <option value="cloud">Cloud</option>
            <option value="database">Database</option>
			<option value="docker">Docker</option>
            <option value="container">Container</option>
            <option value="vm">Virtual Machine</option>
            <option value="kubernetes">Kubernetes</option>
            <option value="api">API / Endpoint</option>
            <option value="queue">Queue / Message</option>
            <option value="lambda">Lambda / Function</option>
            <option value="bucket">Bucket / S3</option>
          </optgroup>
          <optgroup label="Security &amp; Monitoring">
            <option value="shield">Shield</option>
            <option value="camera">Camera / CCTV</option>
            <option value="monitor">Monitor / Dashboard</option>
          </optgroup>
                </select>
              </div>
              <button class="pick-icon-btn" id="pick-shape-icon-btn">Or Search Web Icons</button>
              <div class="style-row">
                <label>Fill Color:</label>
                <input type="color" id="circle-color" value="#1e293b">
              </div>
              <div class="style-row">
                <label>Border Color:</label>
                <input type="color" id="circle-border" value="#475569">
              </div>
              <div class="style-row">
                <label>Title Color:</label>
                <input type="color" id="title-color" value="#e2e8f0">
              </div>
              <div class="style-row">
                <label>Title Font:</label>
                <select id="title-font">
                  <option value="system-ui, sans-serif">System UI</option>
                  <option value="monospace">Monospace</option>
                  <option value="serif">Serif</option>
                  <option value="cursive">Cursive</option>
                  <option value="'Courier New', monospace">Courier</option>
                  <option value="Arial, sans-serif">Arial</option>
                  <option value="'Times New Roman', serif">Times</option>
                </select>
              </div>
              <div class="style-row">
                <label>Title Size:</label>
                <input type="number" id="title-size" min="8" max="100" value="18">
              </div>
              <div class="style-row">
                <label>Sub Color:</label>
                <input type="color" id="sub-color" value="#94a3b8">
              </div>
              <div class="style-row">
                <label>Sub Font:</label>
                <select id="sub-font">
                  <option value="system-ui, sans-serif">System UI</option>
                  <option value="monospace">Monospace</option>
                  <option value="serif">Serif</option>
                  <option value="cursive">Cursive</option>
                  <option value="'Courier New', monospace">Courier</option>
                  <option value="Arial, sans-serif">Arial</option>
                  <option value="'Times New Roman', serif">Times</option>
                </select>
              </div>
              <div class="style-row">
                <label>Sub Size:</label>
                <input type="number" id="sub-size" min="6" max="80" value="13">
              </div>
              <div style="
                margin-top: 12px;
                padding-top: 10px;
                border-top: 1px solid var(--edge-main);
                ">
                <div style="font-size: 12px;color: var(--text-soft);margin-bottom: 8px;text-transform: uppercase;">Text Position</div>
                <div class="style-row">
                  <label>Name Y:</label>
                  <input type="number" id="title-offset-y" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>Name X:</label>
                  <input type="number" id="title-offset-x" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>IP Y:</label>
                  <input type="number" id="sub-offset-y" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>IP X:</label>
                  <input type="number" id="sub-offset-x" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div style="margin-top: 16px; font-size: 12px; color: var(--text-soft); text-transform: uppercase;">
                  Ping Indicator Position
                </div>
                <div class="style-row">
                  <label>Ping X:</label>
                  <input type="number" id="ping-offset-x" min="-200" max="200" value="0" style="width: 60px;">
                </div>
                <div class="style-row">
                  <label>Ping Y:</label>
                  <input type="number" id="ping-offset-y" min="-200" max="200" value="0" style="width: 60px;">
                </div>
              </div>
              <button id="reset-styles" style="width: 100%;margin-top: 10px;padding: 8px;background: var(--panel);color: var(--text-main);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: clamp(13px, 1.5vw, 17px);">Reset Styles</button>
            </div>
          </details>
          <details class="style-section">
            <summary>Ping / Status Monitoring</summary>
            <div class="style-content">
              <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px; cursor: pointer;">
              <input type="checkbox" id="node-pingable" style="cursor: pointer;">
              <span style="font-size: 14px;">Enable status check for this node</span>
              </label>
              <div id="node-ping-options" style="display: none;">
                <div class="style-row">
                  <label>Protocol:</label>
                  <select id="node-ping-protocol">
                    <option value="http">HTTP (port 80)</option>
                    <option value="https">HTTPS (port 443)</option>
                    <option value="custom">Custom URL</option>
                  </select>
                </div>
                <div id="node-custom-url-container" style="display: block; margin-top: 8px;">
                  <label style="display: block; margin-bottom: 4px; font-size: 13px;">Custom URL:</label>
                  <input type="text" id="node-custom-url" placeholder="e.g. http://192.168.1.1:8080" style="width: 100%;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: 14px;">
                </div>
                <div class="style-row" style="margin-top: 8px;">
                  <label>Timeout (ms):</label>
                  <input type="number" id="node-ping-timeout" value="3000" min="1000" max="10000" step="500" style="width: 100px;">
                </div>
                <div style="margin-top: 12px; padding: 10px; background: var(--panel); border-radius: 6px; border: 1px solid var(--edge-main);">
                  <div style="font-size: 12px; color: var(--text-soft); margin-bottom: 8px;">Current Status:</div>
                  <div id="node-ping-status" style="font-size: 14px; font-weight: 600; color: var(--accent);">‚óè Online</div>
                  <div id="node-ping-last-check" style="font-size: 11px; color: var(--text-soft); margin-top: 4px;">Last checked: 2:25:19 PM</div>
                </div>
                <button id="check-ping-now" style="width: 100%;margin-top: 10px;padding: 8px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Check Status Now</button>
              </div>
            </div>
          </details>
          <div class="section-label">Notes</div>
          <ul class="list" id="node-notes"><li><span style="flex: 1 1 0%;">Primary core router</span><span class="delete-note">‚úï</span></li><li><span style="flex: 1 1 0%;">BGP peering enabled</span><span class="delete-note">‚úï</span></li></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-note-input" placeholder="Type new note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-note-btn" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-node-btn" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: rgb(255, 255, 255);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;width: 100%;">Delete Node</button>
        </div>
        <div id="edge-panel" style="display: none">
          <div class="details-name" id="edge-title">Custom line</div>
          <div class="style-row" style="margin-top: 10px">
            <label>Width:</label>
            <input type="number" id="edge-width" min="1" max="20" value="4">
          </div>
          <div class="style-row">
            <label>Color:</label>
            <input type="color" id="edge-color" value="#475569">
          </div>
          <div class="style-row">
            <label>Line Style:</label>
            <select id="edge-line-style">
              <option value="solid">Solid</option>
              <option value="dashed">Dashed</option>
              <option value="dotted">Dotted</option>
            </select>
          </div>
          <div class="style-row">
            <label>Direction:</label>
            <select id="edge-direction">
              <option value="none">No arrows</option>
              <option value="forward">‚Üí Forward</option>
              <option value="backward">‚Üê Backward</option>
              <option value="both">‚Üî Bidirectional</option>
            </select>
          </div>
          <div class="style-row" id="edge-port-fields">
            <label>From Port:</label>
            <input type="text" id="edge-from-port" placeholder="e.g. eth0, gi0/1" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);font-size: 14px;">
          </div>
          <div class="style-row" id="edge-port-fields-to">
            <label>To Port:</label>
            <input type="text" id="edge-to-port" placeholder="e.g. eth1, gi0/2" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);font-size: 14px;">
          </div>
          <div class="section-label">Line Notes</div>
          <ul class="list" id="edge-notes"></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-edge-note" placeholder="Add note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-edge-note" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-edge" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Delete Line</button>
        </div>
        <div id="rect-panel" style="display: none">
          <div class="details-name" id="rect-title">Zone</div>
          <div class="style-row" id="rect-fill-row" style="margin-top: 10px">
            <label>Fill Color:</label>
            <input type="color" id="rect-color" value="#f97316">
          </div>
          <div class="style-row">
            <label>Border Color:</label>
            <input type="color" id="rect-border-color" value="#f97316">
          </div>
          <div class="style-row">
            <label>Border Width:</label>
            <input type="number" id="rect-border-width" min="0" max="20" value="2">
          </div>
          <div class="style-row">
            <label>Style:</label>
            <select id="rect-style-select">
              <option value="filled">Filled</option>
              <option value="outlined">Outlined</option>
            </select>
          </div>
		  <div class="style-row">
            <label>Line Style:</label>
            <select id="rect-line-style">
              <option value="solid">Solid</option>
              <option value="dashed">Dashed</option>
              <option value="dotted">Dotted</option>
            </select>
          </div>
          <div class="section-label">Zone Notes</div>
          <ul class="list" id="rect-notes"></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-rect-note" placeholder="Add note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-rect-note" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-rect" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Delete Zone</button>
        </div>
        <div id="text-panel" style="display: none">
          <div class="details-name" id="text-title">Text Element</div>
          <div class="style-row" style="margin-top: 10px">
            <label>Content:</label>
            <textarea id="text-content" placeholder="Enter text..." style="width: 100%;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: 14px;min-height: 80px;resize: vertical;font-family: inherit;"></textarea>
          </div>
          <div class="style-row">
            <label>Font Size:</label>
            <input type="number" id="text-font-size" min="8" max="200" value="18" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);">
          </div>
          <div class="style-row">
            <label>Color:</label>
            <input type="color" id="text-color" value="#e2e8f0">
          </div>
          <div class="style-row">
            <label>Font Weight:</label>
            <select id="text-font-weight" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="normal">Normal</option>
              <option value="bold">Bold</option>
              <option value="600">Semi-Bold</option>
              <option value="300">Light</option>
            </select>
          </div>
          <div class="style-row">
            <label>Font Style:</label>
            <select id="text-font-style" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="normal">Normal</option>
              <option value="italic">Italic</option>
            </select>
          </div>
          <div class="style-row">
            <label>Text Align:</label>
            <select id="text-align" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="start">Left</option>
              <option value="middle">Center</option>
              <option value="end">Right</option>
            </select>
          </div>
          <div class="style-row">
            <label>Text Decoration:</label>
            <select id="text-decoration" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="none">None</option>
              <option value="underline">Underline</option>
              <option value="line-through">Strike Through</option>
            </select>
          </div>
          <div class="style-row">
            <label>Background:</label>
            <input type="color" id="text-bg-color" value="#000000">
            <label style="margin-left: 10px; display: flex; align-items: center; gap: 6px;">
            <input type="checkbox" id="text-bg-enabled" style="cursor: pointer;">
            <span style="font-size: 13px;">Enable</span>
            </label>
          </div>
          <div class="style-row">
            <label>Opacity:</label>
            <input type="range" id="text-opacity" min="0" max="1" step="0.1" value="1" style="flex: 1">
            <span id="text-opacity-val" style="min-width: 35px; text-align: right">100%</span>
          </div>
          <button id="delete-text" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;width: 100%;">Delete Text</button>
        </div>
     <details class="style-section" open="">
          <summary>Page Layout</summary>
          <div class="style-content">
            <div style="padding: 12px; background: var(--panel-alt); border-radius: 6px; color: var(--text-soft); font-size: 13px; line-height: 1.6;">
              <strong style="color: var(--accent); display: block; margin-bottom: 8px;">Drag to Resize:</strong>
              ‚Ä¢ <strong>Header:</strong> Drag the bottom edge of the header bar<br>
              ‚Ä¢ <strong>Sidebar:</strong> Drag the left edge of the sidebar panel<br>
              ‚Ä¢ <strong>Mobile:</strong> Drag the top edge of the footer panel<br>
              <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--edge-main); font-size: 12px;">
                Hover over panel edges to see resize handles
              </div>
            </div>
          </div>
        </details>
      </aside>
    </main>
    <script id="nodes-json" type="application/json">{}</script>
    <script id="topology-state" type="application/json">ENCRYPTED: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</script>
    <script>
	Object.keys(localStorage).forEach(key => {
       if (key.startsWith('icon-selfhst-')) {
        const val = localStorage.getItem(key);
        if (val && val.includes('<image href=')) {
         localStorage.removeItem(key);
        }
       }
      });
      const IconLibrary = {
       libraries: {
        mdi: {
         name: 'Material Design Icons',
         cdnBase: 'https://cdn.jsdelivr.net/npm/@mdi/svg@latest/svg/',
         metaUrl: 'https://cdn.jsdelivr.net/npm/@mdi/svg@latest/meta.json',
         icons: []
        },
        simple: {
         name: 'Simple Icons',
         cdnBase: 'https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/',
         indexUrl: 'https://cdn.jsdelivr.net/npm/@iconify-json/simple-icons@latest/icons.json',
         icons: []
        },
        selfhst: {
         name: 'selfh.st/icons',
         cdnBase: 'https://cdn.jsdelivr.net/gh/selfhst/icons@master/svg/',
         indexUrl: 'https://raw.githubusercontent.com/selfhst/icons/refs/heads/main/index.json',
         icons: []
        }
       },
       currentLibrary: 'selfhst',
       iconCache: {},
       indexCache: {},
       indexLoading: {},
       async loadLibraryIndex(library) {
        if (this.indexCache[library]) {
         return this.indexCache[library];
        }
        if (this.indexLoading[library]) {
         return this.indexLoading[library];
        }
        const lib = this.libraries[library];
        this.indexLoading[library] = (async () => {
         try {
          if (library === 'selfhst') {
           const response = await fetch(lib.indexUrl);
           const data = await response.json();
           const icons = data.filter(item => item.SVG === "Yes").map(item => ({
            name: item.Reference,
            displayName: item.Name,
            tags: item.Tags ? item.Tags.split(',').map(t => t.trim()).filter(t => t) : [],
            category: item.Category
           }));
           this.indexCache[library] = icons;
           lib.icons = icons;
           return icons;
          } else if (library === 'simple') {
           const response = await fetch('https://cdn.jsdelivr.net/npm/@iconify-json/simple-icons@latest/icons.json');
           const data = await response.json();
           const icons = Object.keys(data.icons).map(slug => ({
            name: slug,
            displayName: data.icons[slug].title || slug,
            tags: data.aliases && data.aliases[slug] ? [data.aliases[slug].parent] : [],
            hex: data.icons[slug].hex
           }));
           this.indexCache[library] = icons;
           lib.icons = icons;
           return icons;
          } else if (library === 'mdi') {
           const response = await fetch(lib.metaUrl);
           const data = await response.json();
           const icons = data.map(item => ({
            name: item.name,
            displayName: item.name,
            tags: item.tags || [],
            author: item.author
           }));
           this.indexCache[library] = icons;
           lib.icons = icons;
           return icons;
          }
         } catch (error) {
          console.error(`Failed to load index for ${library}:`, error);
          this.indexCache[library] = [];
          lib.icons = [];
          return [];
         } finally {
          delete this.indexLoading[library];
         }
        })();
        return this.indexLoading[library];
       },
       async getIcon(library, name) {
        const cacheKey = `${library}-${name}`;
        if (this.iconCache[cacheKey]) {
         return this.iconCache[cacheKey];
        }
        const cached = localStorage.getItem(`icon-${cacheKey}`);
        if (cached) {
         this.iconCache[cacheKey] = cached;
         return cached;
        }
        const lib = this.libraries[library];
        const url = `${lib.cdnBase}${name}.svg`;
        try {
         const response = await fetch(url);
         if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
         }
         const svg = await response.text();
         this.iconCache[cacheKey] = svg;
         localStorage.setItem(`icon-${cacheKey}`, svg);
         return svg;
        } catch (error) {
         console.error(`Failed to fetch icon ${cacheKey}:`, error);
         return null;
        }
       },
       searchIcons(library, query) {
        const lib = this.libraries[library];
        if (!lib.icons.length) return [];
        const q = query.toLowerCase();
        return lib.icons.filter(icon => {
         const nameMatch = icon.name.toLowerCase().includes(q);
         const displayMatch = icon.displayName && icon.displayName.toLowerCase().includes(q);
         const tagMatch = icon.tags && icon.tags.some(t => t.toLowerCase().includes(q));
         const categoryMatch = icon.category && icon.category.toLowerCase().includes(q);
         return nameMatch || displayMatch || tagMatch || categoryMatch;
        }).slice(0, 50);
       }
      };
      let iconPickerCallback = null;
      let selectedNodeIconData = null;
      let selectedRackIconData = null;
      let newNodeIconTags = [];
      let freeDrawMode = false;
      async function checkNodeStatus(nodeId) {
       const data = NODE_DATA[nodeId];
       if (!data || !data.ping || !data.ping.enabled) return;
       data.ping.status = 'checking';
       data.ping.lastCheck = new Date().toISOString();
       updatePingIndicator(nodeId);
       if (currentNodeId === nodeId) {
        updatePingStatusDisplay(nodeId);
       }
       let url;
       if (data.ping.protocol === 'custom') {
        url = data.ping.customUrl;
       } else {
        const ip = data.ip || '0.0.0.0';
        const protocol = data.ping.protocol || 'http';
        url = `${protocol}://${ip}`;
       }
       if (!url) {
        data.ping.status = 'unknown';
        updatePingIndicator(nodeId);
        if (currentNodeId === nodeId) {
         updatePingStatusDisplay(nodeId);
        }
        return;
       }
       try {
        const controller = new AbortController();
        const timeout = data.ping.timeout || 3000;
        const timeoutId = setTimeout(() => controller.abort(), timeout);
        const response = await fetch(url, {
         method: 'HEAD',
         mode: 'no-cors',
         signal: controller.signal
        });
        clearTimeout(timeoutId);
        data.ping.status = 'online';
       } catch (error) {
        data.ping.status = 'offline';
       }
       data.ping.lastCheck = new Date().toISOString();
       updatePingIndicator(nodeId);
       if (currentNodeId === nodeId) {
        updatePingStatusDisplay(nodeId);
       }
      }
      function rgbaToHex(val) {
      if (!val) return "#000000";
      if (val.startsWith("#")) return val;
      const m = val.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
      if (!m) return "#000000";
      const r = Number(m[1]).toString(16).padStart(2, "0");
      const g = Number(m[2]).toString(16).padStart(2, "0");
      const b = Number(m[3]).toString(16).padStart(2, "0");
      return `#${r}${g}${b}`;
      }
      function updatePingIndicator(nodeId) {
      const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
      if (!nodeGroup) return;
      const data = NODE_DATA[nodeId];
      if (!data || !data.ping || !data.ping.enabled) {
       const existingIndicator = nodeGroup.querySelector('.ping-indicator');
       if (existingIndicator) existingIndicator.remove();
       return;
      }
      let indicator = nodeGroup.querySelector('.ping-indicator');
      const label = nodeGroup.querySelector('.node-label');
      if (!indicator && label) {
       indicator = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
       indicator.classList.add('ping-indicator');
       nodeGroup.appendChild(indicator);
      }
      if (indicator && label) {
       const size = savedSizes[nodeId] || getDefaultSize();
       const radius = Math.max(4, size * 0.06);
       indicator.setAttribute('r', radius);
       const labelBBox = label.getBBox();
       const labelX = parseFloat(label.getAttribute('x') || 0);
       const labelY = parseFloat(label.getAttribute('y') || 0);
       const styles = resolveStylesForNode(nodeId);
      const offX = styles.pingOffsetX || 0;
      const offY = styles.pingOffsetY || 0;
      indicator.setAttribute('cx', (labelX - labelBBox.width / 2 - radius * 1.1) + offX);
      indicator.setAttribute('cy', (labelY - radius * 0.7) + offY);
      }
      if (indicator) {
       indicator.classList.remove('online', 'offline', 'checking');
       if (data.ping.status) indicator.classList.add(data.ping.status);
      }
      }
      function checkAllNodesStatus() {
       Object.keys(NODE_DATA).forEach(nodeId => {
        const data = NODE_DATA[nodeId];
        if (data && data.ping && data.ping.enabled) {
         checkNodeStatus(nodeId);
        }
       });
      }
      function startAutoPing() {
       stopAutoPing();
       checkAllNodesStatus();
       updateAutoPingLastRun();
       autoPingSecondsRemaining = autoPingInterval;
       autoPingTimer = setInterval(() => {
        checkAllNodesStatus();
        updateAutoPingLastRun();
        autoPingSecondsRemaining = autoPingInterval;
       }, autoPingInterval * 1000);
       autoPingCountdown = setInterval(() => {
        autoPingSecondsRemaining--;
        updateAutoPingCountdown();
        if (autoPingSecondsRemaining <= 0) {
         autoPingSecondsRemaining = autoPingInterval;
        }
       }, 1000);
       updateAutoPingCountdown();
      }
      function stopAutoPing() {
       if (autoPingTimer) {
        clearInterval(autoPingTimer);
        autoPingTimer = null;
       }
       if (autoPingCountdown) {
        clearInterval(autoPingCountdown);
        autoPingCountdown = null;
       }
       autoPingSecondsRemaining = 0;
       updateAutoPingCountdown();
      }
      function updateAutoPingCountdown() {
       const nextCheckEl = document.getElementById('auto-ping-next-check');
       if (nextCheckEl) {
        if (autoPingSecondsRemaining > 0 && autoPingEnabled) {
         const mins = Math.floor(autoPingSecondsRemaining / 60);
         const secs = autoPingSecondsRemaining % 60;
         if (mins > 0) {
          nextCheckEl.textContent = `Next check in: ${mins}m ${secs}s`;
         } else {
          nextCheckEl.textContent = `Next check in: ${secs}s`;
         }
        } else {
         nextCheckEl.textContent = 'Next check in: --';
        }
       }
      }
      function updateAutoPingLastRun() {
       const lastRunEl = document.getElementById('auto-ping-last-run');
       if (lastRunEl) {
        const now = new Date();
        lastRunEl.textContent = `Last run: ${now.toLocaleTimeString()}`;
       }
      }
      function openIconPicker(callback) {
       iconPickerCallback = callback;
       const modal = document.getElementById('icon-picker-modal');
       modal.classList.add('active');
       const searchInput = document.getElementById('icon-search');
       searchInput.style.display = 'none';
       loadIconsForCurrentLibrary();
      }
      function closeIconPicker() {
       const modal = document.getElementById('icon-picker-modal');
       modal.classList.remove('active');
       iconPickerCallback = null;
      }
      async function loadIconsForCurrentLibrary() {
       const body = document.getElementById('icon-picker-body');
       const libNames = {
        mdi: 'MDI (Material Design Icons)',
        simple: 'Simple Icons',
        selfhst: 'selfh.st/icons'
       };
       body.innerHTML = `<div style="padding: 20px;"><p style="color: var(--text-soft); margin-bottom: 15px; text-align: center;">Search ${libNames[IconLibrary.currentLibrary]}:</p><input type="text" id="icon-search-field" placeholder="Search icons..." style="width: 100%; padding: 12px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main); font-size: 16px; margin-bottom: 20px;"><div id="icon-grid-container" style="max-height: 400px; overflow-y: auto;"><div style="text-align: center; color: var(--text-soft); padding: 40px;">Loading icons...</div></div></div>`;
       const searchField = document.getElementById('icon-search-field');
       const gridContainer = document.getElementById('icon-grid-container');
       await IconLibrary.loadLibraryIndex(IconLibrary.currentLibrary);
       const renderIcons = (icons) => {
        if (!icons || icons.length === 0) {
         gridContainer.innerHTML = '<div style="text-align: center; color: var(--text-soft); padding: 40px;">No icons found</div>';
         return;
        }
        const grid = document.createElement('div');
        grid.style.cssText = 'display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 15px; padding: 10px;';
        icons.forEach(icon => {
         const item = document.createElement('div');
         item.style.cssText = 'display: flex; flex-direction: column; align-items: center; gap: 8px; padding: 15px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; cursor: pointer; transition: all 0.2s;';
         item.onmouseover = () => {
          item.style.background = 'var(--panel)';
          item.style.borderColor = 'var(--accent)';
         };
         item.onmouseout = () => {
          item.style.background = 'var(--panel-alt)';
          item.style.borderColor = 'var(--edge-main)';
         };
         const iconPreview = document.createElement('div');
         iconPreview.style.cssText = 'width: 48px; height: 48px; display: flex; align-items: center; justify-content: center;';
         iconPreview.innerHTML = '<div style="color: var(--text-soft); font-size: 12px;">...</div>';
         IconLibrary.getIcon(IconLibrary.currentLibrary, icon.name).then(svg => {
          if (svg) {
           const parser = new DOMParser();
           const doc = parser.parseFromString(svg, 'image/svg+xml');
           const svgEl = doc.querySelector('svg');
           if (svgEl) {
            svgEl.setAttribute('width', '48');
            svgEl.setAttribute('height', '48');
            svgEl.style.fill = 'var(--text-main)';
            iconPreview.innerHTML = '';
            iconPreview.appendChild(svgEl);
           }
          }
         });
         const name = document.createElement('div');
         name.textContent = icon.displayName || icon.name;
         name.style.cssText = 'font-size: 11px; color: var(--text-soft); text-align: center; word-break: break-word; max-width: 100%;';
         item.appendChild(iconPreview);
         item.appendChild(name);
         item.addEventListener('click', async () => {
          const svg = await IconLibrary.getIcon(IconLibrary.currentLibrary, icon.name);
          if (iconPickerCallback && svg) {
           iconPickerCallback({
            library: IconLibrary.currentLibrary,
            name: icon.name,
            svg: svg
           });
          }
          closeIconPicker();
         });
         grid.appendChild(item);
        });
        gridContainer.innerHTML = '';
        gridContainer.appendChild(grid);
       };
       gridContainer.innerHTML = '<div style="text-align: center; color: var(--text-soft); padding: 40px;">Type to search icons</div>';
       let searchTimeout;
       searchField.addEventListener('input', (e) => {
        clearTimeout(searchTimeout);
        const query = e.target.value.trim();
        searchTimeout = setTimeout(() => {
         if (!query) {
          gridContainer.innerHTML = '<div style="text-align: center; color: var(--text-soft); padding: 40px;">Type to search icons</div>';
          return;
         }
         const results = IconLibrary.searchIcons(IconLibrary.currentLibrary, query);
         renderIcons(results);
        }, 300);
       });
       searchField.focus();
      }
      async function displayIcons(icons) {
       const body = document.getElementById('icon-picker-body');
       const grid = document.createElement('div');
       grid.className = 'icon-grid';
       for (const icon of icons) {
        const item = document.createElement('div');
        item.className = 'icon-item';
        const svg = await IconLibrary.getIcon(icon.library, icon.name);
        if (svg) {
         const parser = new DOMParser();
         const doc = parser.parseFromString(svg, 'image/svg+xml');
         const svgEl = doc.querySelector('svg');
         if (svgEl) {
          item.innerHTML = svgEl.outerHTML;
         }
        } else {
         item.innerHTML = '<svg width = "32" height = "32"><rect width = "32" height = "32" fill = "currentColor"/> </svg>';
        }
        const name = document.createElement('div');
        name.className = 'icon-item-name';
        name.textContent = icon.name;
        item.appendChild(name);
        item.addEventListener('click', () => {
         if (iconPickerCallback) {
          iconPickerCallback({
           library: icon.library,
           name: icon.name,
           svg: svg
          });
         }
         closeIconPicker();
        });
        grid.appendChild(item);
       }
       body.innerHTML = '';
       body.appendChild(grid);
      }
      window.addEventListener('DOMContentLoaded', () => {
       document.querySelectorAll('.icon-picker-tab').forEach(tab => {
        tab.addEventListener('click', () => {
         document.querySelectorAll('.icon-picker-tab').forEach(t => t.classList.remove('active'));
         tab.classList.add('active');
         IconLibrary.currentLibrary = tab.dataset.library;
         loadIconsForCurrentLibrary();
        });
       });
       document.getElementById('icon-picker-cancel').addEventListener('click', closeIconPicker);
       document.getElementById('icon-picker-modal').addEventListener('click', (e) => {
        if (e.target.id === 'icon-picker-modal') {
         closeIconPicker();
        }
       });
      });
      let textDrawMode = false;
      const BASE_NODE_DATA = JSON.parse(document.getElementById("nodes-json").textContent, );
      let currentNodeId = "host";
      let currentEdgeId = null;
      let currentStyleScope = "all";
      let NODE_DATA = {};
      let EDGE_DATA = {
       list: []
      };
      let currentRectId = null;
      let currentTextId = null;
      let rectDrawMode = false;
      let RECT_DATA = {
       list: []
      };
      let TEXT_DATA = {
       list: []
      };
      let EDGE_LEGEND = {};
      let savedPositions = {};
      let savedSizes = {};
      let savedStyles = {};
      let legendCollapsed = false;
      let minimapCollapsed = false;
      let drawToolbarCollapsed = false;
      let currentView = {
       mode: "topology",
       rackId: null
      };
      let savedTopologyView = null;
      let activeLayers = new Set(["physical", "logical", "security", "application"]);
      let topologyToolbarCollapsed = false;
      let legendMiniBtn = null;
      let minimapMiniBtn = null;
      let drawToolbarMiniBtn = null;
      let topologyToolbarMiniBtn = null;
      let autoPingEnabled = false;
      let autoPingInterval = 30;
      let autoPingTimer = null;
      let autoPingCountdown = null;
      let autoPingSecondsRemaining = 0;
      const ROLLBACK_STORAGE_KEY = "theonefile_rollback_history";
      let rollbackVersions = [];
      const MAX_ROLLBACK_VERSIONS = 50;
      let currentRollbackIndex = -1;
      const AUDIT_STORAGE_KEY = "theonefile_audit_log";
      let auditLog = [];
      const MAX_AUDIT_ENTRIES = 1000;
      let documentTabs = [{
        id: "main",
        name: "Main Topology",
        nodes: {},
        edges: { list: [] },
        positions: {},
        sizes: {},
        styles: {},
        legend: {},
        rects: { list: [] },
        texts: { list: [] },
      pageState: null
      }];
      let currentTabIndex = 0;
      let encryptedSections = {};
      let undoStack = [];
      let redoStack = [];
      const MAX_UNDO_STACK = 50;
      let selectedNodes = new Set();
      let selectedEdges = new Set();
      let selectedRects = new Set();
      let selectedTexts = new Set();
      let isSelecting = false;
      let selectionStart = null;
      let preDragSelectedNodes = new Set();
      let preDragSelectedEdges = new Set();
      let preDragSelectedRects = new Set();
      let preDragSelectedTexts = new Set();
      let selectionRect = null;
      let isDraggingSelection = false;
      let dragSelectionStart = null;
      let selectionBoxStyle = {
       fillColor: "#4fd1c5",
       fillOpacity: 0.1,
       strokeColor: "#4fd1c5",
       strokeWidth: 2,
       strokeDasharray: "5,5"
      };
      let clipboard = null;
	  function escapeHtml(str) {
       if (!str) return '';
       return String(str).replace(/[&<>"']/g, c => ({
        '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;'
       }[c]));
      }
      const MobileManager = {
        isMobile: false,
        detect() {
          if (navigator.userAgentData?.mobile === true) {
            this.isMobile = true;
            return true;
          }
          const coarse = matchMedia("(pointer: coarse)").matches;
          const width = window.innerWidth <= 900;
          const portrait = matchMedia("(orientation: portrait)").matches;
          this.isMobile = coarse;
          return this.isMobile;
        },
        applyInitialCollapse() {
          if (!this.isMobile) return;
          legendCollapsed = true;
          minimapCollapsed = true;
          drawToolbarCollapsed = true;
          topologyToolbarCollapsed = true;
          if (typeof updateLegendVisibility === "function") updateLegendVisibility();
          if (typeof updateMinimapVisibility === "function") updateMinimapVisibility();
          if (typeof updateDrawToolbarVisibility === "function") updateDrawToolbarVisibility();
          if (typeof updateTopologyToolbarVisibility === "function") updateTopologyToolbarVisibility();
        },
        updateBulkToolbar() {
          const desktop = document.getElementById("bulk-toolbar");
          const mobile = document.getElementById("bulk-toolbar-mobile");
          if (!desktop || !mobile) return;
          if (typeof isViewOnly === 'function' && isViewOnly()) {
           desktop.style.display = "none";
           mobile.style.display = "none";
           return;
          }
          if (typeof selectedNodes === 'undefined' || selectedNodes.size === 0) {
           desktop.style.display = "none";
           mobile.style.display = "none";
           return;
          }
          const isVisible = desktop.style.display !== "none" || mobile.style.display !== "none";
          if (this.isMobile) {
            desktop.style.display = "none";
            if (isVisible) {
              mobile.style.display = "flex";
            }
          } else {
            mobile.style.display = "none";
            if (isVisible) {
              desktop.style.display = "flex";
            }
          }
        },
        updateCanvasHint() {
      const hint = document.getElementById("canvas-hint");
      if (!hint) return;
      if (PAGE_STATE.canvasHintText !== undefined && PAGE_STATE.canvasHintText !== "") {
        hint.textContent = PAGE_STATE.canvasHintText;
        return;
      }
      const items = this.isMobile
      ? [
        "Pinch to zoom",
        "Drag to pan",
        "Add node from top menu",
        "Double tap to clone and align",
        "Double tap to select multiple",
        "You have the power",
        "Your time is NOW!",
      ]
      : [
        "Scroll to zoom",
        "Drag to pan",
        "Right click to clone and align",
        "Right click to select multiple",
        "You have the power",
        "Your time is NOW!",
      ];
      const list = document.createElement("ul");
      for (const item of items) {
      const li = document.createElement("li");
      li.textContent = item;
      list.appendChild(li);
      }
      hint.replaceChildren(list);
      },
        autoSelectStyleScope() {
          const scope = document.getElementById("style-scope");
          if (!scope) return;
          if (this.isMobile) scope.value = "mobile";
        },
        updateToolbarStack() {
          if (!this.isMobile) return;
          const draw = document.getElementById("draw-toolbar");
          const topo = document.getElementById("topology-toolbar");
          if (!draw || !topo) return;
          const h = draw.getBoundingClientRect().height;
          document.documentElement.style.setProperty("--draw-toolbar-height", h + "px");
        },
        updateLayoutControls() {
          const sidebarRow = document.getElementById("sidebar-width-row");
          const footerRow = document.getElementById("mobile-footer-row");
          if (sidebarRow && footerRow) {
            if (this.isMobile) {
              sidebarRow.style.display = "none";
              footerRow.style.display = "flex";
            } else {
              sidebarRow.style.display = "flex";
              footerRow.style.display = "none";
            }
          }
        },
        applyAll() {
          this.detect();
          this.applyInitialCollapse();
          this.updateBulkToolbar();
          this.updateCanvasHint();
          this.autoSelectStyleScope();
          this.updateToolbarStack();
          this.updateLayoutControls();
        }
      };
      function isMobileDevice() {
        return MobileManager.isMobile;
      }
      function ensureLegendMiniButton() {
		if (legendMiniBtn) return legendMiniBtn;
		const handleClick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			legendCollapsed = false;
			updateLegendVisibility();
		};
		const preventTouch = (e) => { e.preventDefault(); };
		const existing = document.getElementById("edge-legend-mini");
		if (existing) {
			existing.addEventListener("click", handleClick);
			existing.addEventListener("touchstart", preventTouch, { passive: false });
			existing.addEventListener("touchend", handleClick);
			legendMiniBtn = existing;
			return existing;
		}
		const panel = document.querySelector(".topology-panel");
		if (!panel) return null;
		   const btn = document.createElement("button");
		   btn.type = "button";
		   btn.id = "edge-legend-mini";
		   btn.className = "legend-mini-btn";
		   btn.textContent = "Legend";
		   btn.style.bottom = "10px";
		   btn.addEventListener("click", handleClick);
		   btn.addEventListener("touchstart", preventTouch, { passive: false });
		   btn.addEventListener("touchend", handleClick);
		   panel.appendChild(btn);
		   legendMiniBtn = btn;
		   return btn;
		}
			 function ensureMinimapMiniButton() {
		   if (minimapMiniBtn) return minimapMiniBtn;
		   const handleClick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			minimapCollapsed = false;
			updateMinimapVisibility();
		   };
		   const preventTouch = (e) => { e.preventDefault(); };
		   const existing = document.getElementById("minimap-mini");
		   if (existing) {
			existing.addEventListener("click", handleClick);
			existing.addEventListener("touchstart", preventTouch, { passive: false });
			existing.addEventListener("touchend", handleClick);
			minimapMiniBtn = existing;
			return existing;
		   }
		   const panel = document.querySelector(".topology-panel");
		   if (!panel) return null;
		   const btn = document.createElement("button");
		   btn.type = "button";
		   btn.id = "minimap-mini";
		   btn.className = "legend-mini-btn";
		   btn.textContent = "Map";
		   btn.style.right = "10px";
		   btn.style.left = "auto";
		   btn.style.bottom = "10px";
		   btn.addEventListener("click", handleClick);
		   btn.addEventListener("touchstart", preventTouch, { passive: false });
		   btn.addEventListener("touchend", handleClick);
		   panel.appendChild(btn);
		   minimapMiniBtn = btn;
		   return btn;
		}
			  function ensureDrawToolbarMiniButton() {
		   if (drawToolbarMiniBtn) return drawToolbarMiniBtn;
		   const handleClick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			drawToolbarCollapsed = false;
			updateDrawToolbarVisibility();
		   };
		   const preventTouch = (e) => { e.preventDefault(); };
		   const existing = document.getElementById("draw-toolbar-mini");
		   if (existing) {
			existing.addEventListener("click", handleClick);
			existing.addEventListener("touchstart", preventTouch, { passive: false });
			existing.addEventListener("touchend", handleClick);
			drawToolbarMiniBtn = existing;
			return existing;
		   }
		   const panel = document.querySelector(".topology-panel");
		   if (!panel) return null;
		   const btn = document.createElement("button");
		   btn.type = "button";
		   btn.id = "draw-toolbar-mini";
		   btn.className = "legend-mini-btn";
		   btn.textContent = "Draw";
		   btn.style.top = "10px";
		   btn.style.left = "10px";
		   btn.style.right = "auto";
		   btn.addEventListener("click", handleClick);
		   btn.addEventListener("touchstart", preventTouch, { passive: false });
		   btn.addEventListener("touchend", handleClick);
		   panel.appendChild(btn);
		   drawToolbarMiniBtn = btn;
		   return btn;
		}
		  function ensureTopologyToolbarMiniButton() {
	   if (topologyToolbarMiniBtn) return topologyToolbarMiniBtn;
	   const handleClick = (e) => {
		e.stopPropagation();
		e.preventDefault();
		topologyToolbarCollapsed = false;
		updateTopologyToolbarVisibility();
	   };
	   const preventTouch = (e) => { e.preventDefault(); };
	   const existing = document.getElementById("topology-toolbar-mini");
	   if (existing) {
		existing.addEventListener("click", handleClick);
		existing.addEventListener("touchstart", preventTouch, { passive: false });
		existing.addEventListener("touchend", handleClick);
		topologyToolbarMiniBtn = existing;
		return existing;
	   }
	   const panel = document.querySelector(".topology-panel");
	   if (!panel) return null;
	   const btn = document.createElement("button");
	   btn.type = "button";
	   btn.id = "topology-toolbar-mini";
	   btn.className = "legend-mini-btn";
	   btn.textContent = "Add Line";
	   btn.style.top = "10px";
	   btn.style.left = "auto";
	   btn.style.right = "40px";
	   btn.addEventListener("click", handleClick);
	   btn.addEventListener("touchstart", preventTouch, { passive: false });
	   btn.addEventListener("touchend", handleClick);
	   panel.appendChild(btn);
	   topologyToolbarMiniBtn = btn;
	   return btn;
	}
      function updateToolbarStack() {
       if (!isMobileDevice()) return;
       const draw = document.getElementById("draw-toolbar");
       const topo = document.getElementById("topology-toolbar");
       if (!draw || !topo) return;
       const h = draw.getBoundingClientRect().height;
       document.documentElement.style.setProperty("--draw-toolbar-height", h + "px");
      }
      window.addEventListener("resize", updateToolbarStack);
      window.addEventListener("DOMContentLoaded", updateToolbarStack);
      updateToolbarStack();
      function updateLegendVisibility() {
       const legend = document.getElementById("edge-legend");
       const mini = ensureLegendMiniButton();
       if (!legend || !mini) return;
       const hasItems = legend.querySelectorAll(".legend-item").length > 0;
       if (!hasItems) {
        legend.style.display = "none";
        mini.style.display = "none";
        return;
       }
       if (legendCollapsed) {
        legend.style.display = "none";
        mini.style.display = "inline-flex";
       } else {
        legend.style.display = "flex";
        mini.style.display = "none";
       }
      }
      function updateMinimapVisibility() {
       const wrapper = document.getElementById("minimap-zoom-wrapper");
       const mini = ensureMinimapMiniButton();
       if (!wrapper || !mini) return;
       if (minimapCollapsed) {
        wrapper.style.display = "none";
        mini.style.display = "inline-flex";
       } else {
        wrapper.style.display = "block";
        mini.style.display = "none";
       }
      }
      function updateDrawToolbarVisibility() {
       const toolbar = document.getElementById("draw-toolbar");
       const mini = ensureDrawToolbarMiniButton();
       if (!toolbar || !mini) return;
       if (typeof isViewOnly === 'function' && isViewOnly()) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "none";
        return;
       }
       if (drawToolbarCollapsed) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "inline-flex";
       } else {
      if (isMobileDevice()) {
        toolbar.style.setProperty('display', 'grid', 'important');
        mini.style.display = "none";
        } else {
        toolbar.style.setProperty('display', 'flex', 'important');
        mini.style.display = "none";
      }
       }
      }
      function u8ToBase64(u8) {
      let binary = "";
      for (let i = 0; i < u8.length; i++) binary += String.fromCharCode(u8[i]);
      return btoa(binary);
      }
      function base64ToU8(base64) {
      const binary = atob(base64);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
      return bytes;
      }
      function updateTopologyToolbarVisibility() {
       const toolbar = document.getElementById("topology-toolbar");
       const mini = ensureTopologyToolbarMiniButton();
       if (!toolbar || !mini) return;
       if (typeof isViewOnly === 'function' && isViewOnly()) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "none";
        return;
       }
       const hasSelectedNode = currentNodeId !== null;
       if (!hasSelectedNode) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "none";
       } else if (topologyToolbarCollapsed) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "inline-flex";
       } else {
      if (isMobileDevice()) {
        toolbar.style.setProperty('display', 'grid', 'important');
        mini.style.display = "none";
        } else {
        toolbar.style.setProperty('display', 'flex', 'important');
        mini.style.display = "none";
      }
       }
      }
      const DEFAULT_CANVAS_HINT = document.getElementById("canvas-hint")?.innerHTML || "";
      const DEFAULT_PAGE_STATE = {
       title: "The One File: The Networkening",
       background: "",
       topbarBg: "rgba(9, 12, 20, 0.9)",
       topbarBorder: "#1f2533",
       panel: "#0b0e13",
       panelAlt: "#10141b",
       accent: "#4fd1c5",
       sidebarBg: "#10141b",
       btnBg: "#0b0e13",
       btnText: "#e2e8f0",
       tagFill: "#1e293b",
       tagText: "#e2e8f0",
       tagBorder: "#475569",
       inputBg: "#0b0e13",
       inputText: "#e2e8f0",
       inputBorder: "#1f2937",
       inputFont: "Inter, system-ui, sans-serif",
       inputFontSize: 14,
       toolbarBg: "#0f172a",
       toolbarBorder: "#1f2937",
       toolbarText: "#94a3b8",
       toolbarBtnBg: "#0b0e13",
       toolbarBtnText: "#e2e8f0",
       minimapDots: "#94a3b8",
       canvasHintEnabled: true,
       canvasHintText: "",
       canvasHintBg: "#0f172a",
       canvasHintColor: "#94a3b8",
       danger: "#f56565",
       textMain: "#e2e8f0",
       textSoft: "#94a3b8",
       topbarHeight: 52,
       sidebarWidth: 350,
       mobileFooterHeight: 40,
       sidebarCollapsed: false,
       nodeFill: "#1e293b",
       nodeStroke: "#475569",
       nodeTitle: "#e2e8f0",
       nodeSub: "#94a3b8",
       nodeTitleSize: 18,
       nodeSubSize: 13,
       nodeFont: "Inter, system-ui, sans-serif",
       defaultEdge: "#475569",
       selectionHandle: "#f59e0b",
       selectionHandleSize: 8,
       groupIndicator: "#4fd1c5",
       canvasGradientTop: "#1e2532",
       canvasGradientBottom: "#050608",
       canvasBorder: "#475569",
       canvasGrid: "#475569",
       canvasGridSize: 50,
       rackFrameFill: "#0f172a",
       rackFrameStroke: "#4fd1c5",
       rackLineColor: "#475569",
       rackTextColor: "#4fd1c5",
	   viewOnly: false,
      };
      let PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE);
	  function isViewOnly() {
       return PAGE_STATE.viewOnly === true;
      }
      let viewOnlyClickCount = 0;
      let viewOnlyClickTimer = null;
      let viewOnlyClickTarget = null;
      function handleViewOnlyClick(id, type) {
       if (!isViewOnly()) return false;
       if (viewOnlyClickTarget !== id) {
        viewOnlyClickCount = 0;
        viewOnlyClickTarget = id;
       }
       viewOnlyClickCount++;
       clearTimeout(viewOnlyClickTimer);
       viewOnlyClickTimer = setTimeout(() => {
        viewOnlyClickCount = 0;
        viewOnlyClickTarget = null;
       }, 2000);
       if (viewOnlyClickCount >= 5) {
        viewOnlyClickCount = 0;
        viewOnlyClickTarget = null;
        document.body.classList.add("view-only-inspect");
        if (type === 'node') {
         currentNodeId = id;
         const data = NODE_DATA[id];
         if (data) {
          document.querySelectorAll(".node-group").forEach((n) => {
           n.classList.toggle("active", n.dataset.nodeId === id);
          });
          document.getElementById("node-panel").style.display = "block";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("node-name").textContent = data.name;
          document.getElementById("node-ip").textContent = data.ip;
          document.getElementById("node-role").textContent = data.role;
          document.getElementById("node-mac").textContent = data.mac || "--";
          document.getElementById("node-rack").textContent = data.rackUnit || "--";
          document.getElementById("node-uheight").textContent = (data.uHeight || "1") + "U";
          const tagList = document.getElementById("node-tags");
          if (tagList) {
           tagList.innerHTML = "";
           if (data.tags && data.tags.length > 0) {
            data.tags.forEach((tag) => {
             const li = document.createElement("li");
             li.textContent = tag;
             tagList.appendChild(li);
            });
           }
          }
          const noteList = document.getElementById("node-notes");
          if (noteList) {
           noteList.innerHTML = "";
           if (data.notes && data.notes.length > 0) {
            data.notes.forEach((note) => {
             const li = document.createElement("li");
             li.textContent = note;
             noteList.appendChild(li);
            });
           }
          }
         }
        } else if (type === 'edge') {
         currentEdgeId = id;
         const edge = EDGE_DATA.list.find(e => e.id === id);
         if (edge) {
          document.querySelectorAll(".edge").forEach((e) => {
           e.classList.toggle("active", e.dataset.edgeId === id);
          });
          document.getElementById("edge-panel").style.display = "block";
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-from").textContent = NODE_DATA[edge.from]?.name || edge.from;
          document.getElementById("edge-to").textContent = NODE_DATA[edge.to]?.name || edge.to;
          document.getElementById("edge-label").value = edge.label || "";
         }
        }
        return true;
       }
       return false;
      }
      const CANVAS_WIDTH = 4000;
      let CANVAS_HEIGHT = 3000;
      const BASE_CANVAS_HEIGHT = 3000;
      const CANVAS_PADDING = 100;
      const RACK_U_HEIGHT = 70;
      const RACK_WIDTH = 600;
      const RACK_START_X = CANVAS_WIDTH / 2;
      const RACK_START_Y = CANVAS_PADDING + 100;
      function getRackUHeight(rackId) {
      const capacity = getRackCapacity(rackId);
      const availableHeight = CANVAS_HEIGHT - RACK_START_Y - 200;
      return Math.floor(availableHeight / capacity);
      }
      let canvasState = {
       zoom: 1,
       panX: 0,
       panY: 0,
       minZoom: 0.25,
       maxZoom: 4,
       isPanning: false,
       panStartX: 0,
       panStartY: 0,
       spacePressed: false,
      };
      function getViewBox() {
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       return {
        x: canvasState.panX,
        y: canvasState.panY,
        width: viewWidth,
        height: viewHeight,
       };
      }
      function updateViewBox() {
       const svg = document.getElementById("map");
       const vb = getViewBox();
       svg.setAttribute("viewBox", `${vb.x} ${vb.y} ${vb.width} ${vb.height}`, );
       const zoomLevel = document.getElementById("zoom-level");
       if (zoomLevel) {
        zoomLevel.textContent = Math.round(canvasState.zoom * 100) + "%";
       }
       updateMinimap();
      }
      function updateMinimap() {
       const minimapViewport = document.getElementById("minimap-viewport");
       const minimapSvg = document.getElementById("minimap");
       if (!minimapViewport || !minimapSvg) return;
       const vb = getViewBox();
       minimapViewport.setAttribute("x", vb.x);
       minimapViewport.setAttribute("y", vb.y);
       minimapViewport.setAttribute("width", vb.width);
       minimapViewport.setAttribute("height", vb.height);
       const minimapNodes = minimapSvg.querySelectorAll(".minimap-node");
       minimapNodes.forEach((n) => n.remove());
       const minimapEdges = minimapSvg.querySelectorAll(".minimap-edge");
       minimapEdges.forEach((e) => e.remove());
       EDGE_DATA.list.forEach((edge) => {
        if (edge.type === "custom") return;
        const fromNode = NODE_DATA[edge.from];
        const toNode = NODE_DATA[edge.to];
        if (!fromNode || !toNode) return;
        if (currentView.mode === "rack") {
         if (fromNode.assignedRack !== currentView.rackId ||
             toNode.assignedRack !== currentView.rackId) {
          return;
         }
        } else {
         if (fromNode.assignedRack || toNode.assignedRack) {
          return;
         }
        }
        const p1 = savedPositions[edge.from];
        const p2 = savedPositions[edge.to];
        if (!p1 || !p2) return;
        const line = document.createElementNS("http://www.w3.org/2000/svg", "line", );
        line.setAttribute("x1", p1.x);
        line.setAttribute("y1", p1.y);
        line.setAttribute("x2", p2.x);
        line.setAttribute("y2", p2.y);
        line.classList.add("minimap-edge");
        minimapSvg.insertBefore(line, minimapViewport);
       });
       Object.entries(savedPositions).forEach(([id, pos]) => {
        const node = NODE_DATA[id];
        if (!node) return;
        if (currentView.mode === "rack") {
         if (node.assignedRack !== currentView.rackId) {
          return;
         }
        } else {
         if (node.assignedRack) {
          return;
         }
        }
        const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle", );
        circle.setAttribute("cx", pos.x);
        circle.setAttribute("cy", pos.y);
        circle.setAttribute("r", 40);
        circle.classList.add("minimap-node");
        minimapSvg.insertBefore(circle, minimapViewport);
       });
      }
      function zoomTo(newZoom, centerX, centerY) {
       const oldZoom = canvasState.zoom;
       newZoom = Math.max(canvasState.minZoom, Math.min(canvasState.maxZoom, newZoom), );
       if (centerX !== undefined && centerY !== undefined) {
        const oldWidth = CANVAS_WIDTH / oldZoom;
        const oldHeight = CANVAS_HEIGHT / oldZoom;
        const newWidth = CANVAS_WIDTH / newZoom;
        const newHeight = CANVAS_HEIGHT / newZoom;
        const pointX = canvasState.panX + centerX * oldWidth;
        const pointY = canvasState.panY + centerY * oldHeight;
        canvasState.panX = pointX - centerX * newWidth;
        canvasState.panY = pointY - centerY * newHeight;
       }
       canvasState.zoom = newZoom;
       constrainPan();
       updateViewBox();
      }
      function constrainPan() {
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       const minVisiblePortion = 0.1;
       const maxPanX = CANVAS_WIDTH - viewWidth * minVisiblePortion;
       const maxPanY = CANVAS_HEIGHT - viewHeight * minVisiblePortion;
       const minPanX = -viewWidth * (1 - minVisiblePortion);
       const minPanY = -viewHeight * (1 - minVisiblePortion);
       canvasState.panX = Math.max(minPanX, Math.min(maxPanX, canvasState.panX), );
       canvasState.panY = Math.max(minPanY, Math.min(maxPanY, canvasState.panY), );
      }
      function fitToContent() {
       const positions = Object.values(savedPositions);
       if (positions.length === 0) {
        resetView();
        return;
       }
       let minX = Infinity,
        minY = Infinity,
        maxX = -Infinity,
        maxY = -Infinity;
       positions.forEach((pos) => {
        minX = Math.min(minX, pos.x - 100);
        minY = Math.min(minY, pos.y - 100);
        maxX = Math.max(maxX, pos.x + 100);
        maxY = Math.max(maxY, pos.y + 100);
       });
       const contentWidth = maxX - minX + 200;
       const contentHeight = maxY - minY + 200;
       const viewport = document.getElementById("canvas-viewport");
       const vpRect = viewport.getBoundingClientRect();
       const aspectRatio = vpRect.width / vpRect.height;
       const contentAspect = contentWidth / contentHeight;
       let newZoom;
       if (contentAspect > aspectRatio) {
        newZoom = (vpRect.width / contentWidth) * (CANVAS_WIDTH / vpRect.width);
       } else {
        newZoom = (vpRect.height / contentHeight) * (CANVAS_HEIGHT / vpRect.height);
       }
       newZoom = Math.max(canvasState.minZoom, Math.min(2, newZoom));
       const viewWidth = CANVAS_WIDTH / newZoom;
       const viewHeight = CANVAS_HEIGHT / newZoom;
       canvasState.zoom = newZoom;
       canvasState.panX = minX - 100 - (viewWidth - contentWidth) / 2;
       canvasState.panY = minY - 100 - (viewHeight - contentHeight) / 2;
       constrainPan();
       updateViewBox();
      }
      function resetView() {
       canvasState.zoom = 1;
       canvasState.panX = 0;
       canvasState.panY = 0;
       updateViewBox();
      }
      window.addEventListener("DOMContentLoaded", () => {
       const toggle = document.getElementById("mobile-menu-toggle");
       const menu = document.getElementById("topbar-menu");
       if (!toggle || !menu) return;
       toggle.addEventListener("click", () => {
        menu.classList.toggle("open");
       });
       menu.addEventListener("click", (e) => {
        const target = e.target.closest("a, button");
        if (!target) return;
        if (isMobileDevice()) {
       menu.classList.remove("open");
      }
       });
       const minimapCloseBtn = document.getElementById("minimap-close-btn");
       if (minimapCloseBtn) {
        const handleMinimapClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         minimapCollapsed = true;
         updateMinimapVisibility();
        };
        minimapCloseBtn.addEventListener("click", handleMinimapClose);
        minimapCloseBtn.addEventListener("touchend", handleMinimapClose);
       }
       const drawToolbarCloseBtn = document.getElementById("draw-toolbar-close-btn");
       if (drawToolbarCloseBtn) {
        const handleDrawClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         drawToolbarCollapsed = true;
         updateDrawToolbarVisibility();
        };
        drawToolbarCloseBtn.addEventListener("click", handleDrawClose);
        drawToolbarCloseBtn.addEventListener("touchend", handleDrawClose);
       }
       const topologyToolbarCloseBtn = document.getElementById("topology-toolbar-close-btn");
       if (topologyToolbarCloseBtn) {
        const handleTopologyClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         topologyToolbarCollapsed = true;
         updateTopologyToolbarVisibility();
        };
        topologyToolbarCloseBtn.addEventListener("click", handleTopologyClose);
        topologyToolbarCloseBtn.addEventListener("touchstart", (e) => e.preventDefault(), {
         passive: false
        });
        topologyToolbarCloseBtn.addEventListener("touchend", handleTopologyClose);
       }
       updateMinimapVisibility();
       updateDrawToolbarVisibility();
       updateTopologyToolbarVisibility();
      });
      function applyLayerFilter() {
       activeLayers.clear();
       if (document.getElementById("layer-physical").checked) activeLayers.add("physical");
       if (document.getElementById("layer-logical").checked) activeLayers.add("logical");
       if (document.getElementById("layer-security").checked) activeLayers.add("security");
       if (document.getElementById("layer-application").checked) activeLayers.add("application");
       forgeTheTopology();
      }
      function isNodeVisible(nodeId) {
       const node = NODE_DATA[nodeId];
       if (!node) return false;
       const nodeLayer = node.layer || "physical";
       return activeLayers.has(nodeLayer);
      }
      function enterRack(rackId) {
      if (!NODE_DATA[rackId] || !NODE_DATA[rackId].isRack) return;
      const rackCapacity = getRackCapacity(rackId);
      const neededHeight = RACK_START_Y + (rackCapacity * RACK_U_HEIGHT) + 200;
      if (neededHeight > BASE_CANVAS_HEIGHT) {
      CANVAS_HEIGHT = neededHeight;
      }
       currentView.mode = "rack";
       currentView.rackId = rackId;
       const backBtn = document.getElementById("back-to-topology-btn");
       if (backBtn) backBtn.style.display = "inline-block";
       const hint = document.getElementById("canvas-hint");
       if (hint) {
        hint.textContent = `Viewing: ${NODE_DATA[rackId]?.name || 'Rack'} | Double click empty space to exit`;
        hint.classList.add("visible");
       }
      const rackUHeight = getRackUHeight(rackId);
      const rackHeight = rackCapacity * rackUHeight;
      const rackCenterX = RACK_START_X;
      const rackCenterY = RACK_START_Y + (rackHeight / 2);
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       canvasState.panX = rackCenterX - (viewWidth / 2);
       canvasState.panY = rackCenterY - (viewHeight / 2);
       constrainPan();
       updateViewBox();
       forgeTheTopology();
      }
      function exitRack() {
      CANVAS_HEIGHT = BASE_CANVAS_HEIGHT;
      currentView.mode = "topology";
      currentView.rackId = null;
       const backBtn = document.getElementById("back-to-topology-btn");
       if (backBtn) backBtn.style.display = "none";
       const hint = document.getElementById("canvas-hint");
       if (hint) {
        hint.classList.remove("visible");
       }
       if (savedTopologyView) {
        canvasState.zoom = savedTopologyView.zoom;
        canvasState.panX = savedTopologyView.panX;
        canvasState.panY = savedTopologyView.panY;
        updateViewBox();
       }
       forgeTheTopology();
      }
      function getRackCapacity(rackId) {
       const node = NODE_DATA[rackId];
       return node && node.rackCapacity ? parseInt(node.rackCapacity) : 42;
      }
      function populateRackDropdown() {
       const dropdown = document.getElementById("node-assigned-rack");
       if (!dropdown) return;
       dropdown.innerHTML = '<option value="">None</option>';
       Object.keys(NODE_DATA).forEach(id => {
        if (NODE_DATA[id].isRack) {
         const option = document.createElement("option");
         option.value = id;
         option.textContent = NODE_DATA[id].name;
         dropdown.appendChild(option);
        }
       });
      }
      function wieldThePower() {
       const root = document.documentElement;
       root.style.setProperty("--panel", PAGE_STATE.panel);
       root.style.setProperty("--panel-alt", PAGE_STATE.panelAlt);
       root.style.setProperty("--sidebar-bg", PAGE_STATE.sidebarBg || PAGE_STATE.panelAlt);
       root.style.setProperty("--btn-bg", PAGE_STATE.btnBg || PAGE_STATE.panel);
       root.style.setProperty("--btn-text", PAGE_STATE.btnText || "#e2e8f0");
       root.style.setProperty("--tag-fill", PAGE_STATE.tagFill || "#1e293b");
       root.style.setProperty("--tag-text", PAGE_STATE.tagText || "#e2e8f0");
       root.style.setProperty("--tag-border", PAGE_STATE.tagBorder || "#475569");
       root.style.setProperty("--input-bg", PAGE_STATE.inputBg || "#0b0e13");
       root.style.setProperty("--input-text", PAGE_STATE.inputText || "#e2e8f0");
       root.style.setProperty("--input-border", PAGE_STATE.inputBorder || "#1f2937");
       root.style.setProperty("--input-font", PAGE_STATE.inputFont || "Inter, system-ui, sans-serif");
       root.style.setProperty("--input-font-size", (PAGE_STATE.inputFontSize || 14) + "px");
       root.style.setProperty("--toolbar-bg", PAGE_STATE.toolbarBg || "#0f172a");
       root.style.setProperty("--toolbar-border", PAGE_STATE.toolbarBorder || "#1f2937");
       root.style.setProperty("--toolbar-text", PAGE_STATE.toolbarText || "#94a3b8");
       root.style.setProperty("--toolbar-btn-bg", PAGE_STATE.toolbarBtnBg || "#0b0e13");
       root.style.setProperty("--toolbar-btn-text", PAGE_STATE.toolbarBtnText || "#e2e8f0");
       root.style.setProperty("--minimap-dots", PAGE_STATE.minimapDots || "#94a3b8");
       root.style.setProperty("--canvas-hint-bg", PAGE_STATE.canvasHintBg || "#0f172a");
       root.style.setProperty("--canvas-hint-color", PAGE_STATE.canvasHintColor || "#94a3b8");
       const canvasHint = document.getElementById("canvas-hint");
       if (canvasHint) {
        canvasHint.style.display = PAGE_STATE.canvasHintEnabled === false ? "none" : "";
        if (PAGE_STATE.canvasHintText !== undefined && PAGE_STATE.canvasHintText !== "") {
         canvasHint.innerHTML = PAGE_STATE.canvasHintText;
        } else {
         canvasHint.innerHTML = DEFAULT_CANVAS_HINT;
        }
       }
       root.style.setProperty("--accent", PAGE_STATE.accent);
       root.style.setProperty("--danger", PAGE_STATE.danger);
       root.style.setProperty("--text-main", PAGE_STATE.textMain);
       root.style.setProperty("--text-soft", PAGE_STATE.textSoft);
       root.style.setProperty("--topbar-bg", PAGE_STATE.topbarBg);
       root.style.setProperty("--topbar-border", PAGE_STATE.topbarBorder);
       root.style.setProperty("--node-fill", PAGE_STATE.nodeFill || "#1e293b");
       root.style.setProperty("--node-stroke", PAGE_STATE.nodeStroke || "#475569");
       root.style.setProperty("--node-title", PAGE_STATE.nodeTitle || "#e2e8f0");
       root.style.setProperty("--node-sub", PAGE_STATE.nodeSub || "#94a3b8");
       root.style.setProperty("--node-title-size", (PAGE_STATE.nodeTitleSize || 18) + "px");
       root.style.setProperty("--node-sub-size", (PAGE_STATE.nodeSubSize || 13) + "px");
       root.style.setProperty("--node-font", PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif");
       root.style.setProperty("--default-edge", PAGE_STATE.defaultEdge || "#475569");
       root.style.setProperty("--selection-handle", PAGE_STATE.selectionHandle || "#f59e0b");
       root.style.setProperty("--selection-handle-size", (PAGE_STATE.selectionHandleSize || 8) + "px");
       root.style.setProperty("--group-indicator", PAGE_STATE.groupIndicator || "#4fd1c5");
       const topbarHeight = PAGE_STATE.topbarHeight || 52;
       const sidebarWidth = PAGE_STATE.sidebarWidth || 350;
       const mobileFooterHeight = PAGE_STATE.mobileFooterHeight || 40;
       root.style.setProperty("--topbar-height", topbarHeight + "px");
       root.style.setProperty("--sidebar-width", sidebarWidth + "px");
       root.style.setProperty("--mobile-footer-height", mobileFooterHeight + "vh", );
       const mainEl = document.querySelector("main");
       const detailsPanel = document.getElementById("details-panel");
       const sidebarToggle = document.getElementById("sidebar-toggle");
       if (PAGE_STATE.sidebarCollapsed) {
        if (mainEl) mainEl.classList.add("sidebar-collapsed");
        if (detailsPanel) detailsPanel.classList.add("collapsed");
        if (sidebarToggle) {
         sidebarToggle.classList.add("collapsed");
         sidebarToggle.textContent = "‚ñ∂";
        }
       } else {
        if (mainEl) mainEl.classList.remove("sidebar-collapsed");
        if (detailsPanel) detailsPanel.classList.remove("collapsed");
        if (sidebarToggle) {
         sidebarToggle.classList.remove("collapsed");
         sidebarToggle.textContent = "‚óÄ";
        }
       }
       if (PAGE_STATE.background) {
        document.body.style.background = PAGE_STATE.background;
       } else {
        document.body.style.background = `radial-gradient(circle at top, ${PAGE_STATE.canvasGradientTop || "#1e2532"} 0, ${PAGE_STATE.canvasGradientBottom || "#050608"} 70%)`;
       }
       document.title = PAGE_STATE.title || DEFAULT_PAGE_STATE.title;
       const titleEl = document.getElementById("page-title");
       if (titleEl) {
        titleEl.textContent = PAGE_STATE.title || DEFAULT_PAGE_STATE.title;
       }
       const viewOnlyMode = PAGE_STATE.viewOnly === true;
       const addNodeBtn = document.getElementById("add-node-btn");
       const addRackBtn = document.getElementById("add-rack-btn");
       const bulkToolbar = document.getElementById("bulk-toolbar");
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       if (viewOnlyMode) {
        if (addNodeBtn) addNodeBtn.style.display = "none";
        if (addRackBtn) addRackBtn.style.display = "none";
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        ["draw-toolbar-mini", "topology-toolbar-mini"].forEach(id => {
         const el = document.getElementById(id);
         if (el) el.style.display = "none";
        });
        document.body.classList.remove("view-only-inspect");
       } else {
        if (addNodeBtn) addNodeBtn.style.display = "";
        if (addRackBtn) addRackBtn.style.display = "";
       }
       document.body.classList.toggle("view-only-mode", viewOnlyMode);
       if (!viewOnlyMode) {
        if (typeof updateDrawToolbarVisibility === 'function') updateDrawToolbarVisibility();
        if (typeof updateTopologyToolbarVisibility === 'function') updateTopologyToolbarVisibility();
       }
      }
      (async function awakeTheImmortal() {
       let initialState = {};
       let decryptionCancelled = false;
       const stateEl = document.getElementById("topology-state");
       if (stateEl && stateEl.textContent.trim()) {
        try {
         let stateText = stateEl.textContent.trim();
         if (isEncrypted(stateText)) {
          let decrypted = false;
          let attempts = 0;
          const maxAttempts = 3;
          while (!decrypted && attempts < maxAttempts) {
           const password = prompt("This file is encrypted. Enter password to decrypt:\n(Attempt " + (attempts + 1) + " of " + maxAttempts + ")", );
           if (!password) {
            alert("Decryption cancelled. The file will not be loaded.", );
            decryptionCancelled = true;
            break;
           }
           try {
            stateText = await decryptData(stateText, password);
            decrypted = true;
           } catch (e) {
            attempts++;
            if (attempts < maxAttempts) {
             alert("Incorrect password. Please try again.");
            } else {
             alert("Maximum attempts reached. The file will not be loaded.", );
             decryptionCancelled = true;
            }
           }
          }
          if (!decrypted) {
           stateText = "{}";
          }
         }
         initialState = JSON.parse(stateText);
        } catch (e) {
         console.error("Failed to load state:", e);
         initialState = {};
        }
       }
       if (decryptionCancelled) {
        NODE_DATA = {};
        EDGE_DATA = {
         list: []
        };
        RECT_DATA = { list: [] };
        TEXT_DATA = { list: [] };
        EDGE_LEGEND = {};
        savedPositions = {};
        savedSizes = {};
        savedStyles = {};
       } else {
        NODE_DATA = initialState.nodeData ? initialState.nodeData : BASE_NODE_DATA;
        Object.keys(NODE_DATA).forEach(nodeId => {
         if (!NODE_DATA[nodeId].ping) {
          NODE_DATA[nodeId].ping = {
           enabled: false,
           protocol: 'http',
           customUrl: '',
           timeout: 3000,
           status: 'unknown',
           lastCheck: null
          };
         }
        });
        EDGE_DATA = initialState.edgeData ? initialState.edgeData : {
         list: [],
        };
        RECT_DATA = initialState.rectData ? initialState.rectData : { list: [] };
        TEXT_DATA = initialState.textData ? initialState.textData : { list: [] };
        EDGE_LEGEND = initialState.edgeLegend || {};
        savedPositions = initialState.nodePositions || {};
        savedSizes = initialState.nodeSizes || {};
        savedStyles = initialState.nodeStyles || {};
        if (initialState.iconCache) {
         IconLibrary.iconCache = initialState.iconCache;
        }
       }
       if (initialState.page) {
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, initialState.page, );
       }
       if (PAGE_STATE.autoPingEnabled !== undefined) {
        autoPingEnabled = PAGE_STATE.autoPingEnabled;
       }
       if (PAGE_STATE.autoPingInterval !== undefined) {
        autoPingInterval = PAGE_STATE.autoPingInterval;
       }
       if (initialState.canvas) {
        canvasState.zoom = initialState.canvas.zoom || 1;
        canvasState.panX = initialState.canvas.panX || 0;
        canvasState.panY = initialState.canvas.panY || 0;
       }
       if (initialState.savedTopologyView) {
        savedTopologyView = initialState.savedTopologyView;
       }
       if (initialState.documentTabs) {
        documentTabs = initialState.documentTabs;
        if (initialState.currentTabIndex !== undefined) {
          currentTabIndex = initialState.currentTabIndex;
          const currentTab = documentTabs[currentTabIndex];
          if (currentTab) {
            NODE_DATA = currentTab.nodes || NODE_DATA;
            EDGE_DATA = currentTab.edges || EDGE_DATA;
            savedPositions = currentTab.positions || savedPositions;
            savedSizes = currentTab.sizes || savedSizes;
            savedStyles = currentTab.styles || savedStyles;
            EDGE_LEGEND = currentTab.legend || EDGE_LEGEND;
            RECT_DATA = currentTab.rects || RECT_DATA;
            TEXT_DATA = currentTab.texts || TEXT_DATA;
            if (currentTab.pageState) PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, currentTab.pageState);
          }
        }
       }
       if (initialState.encryptedSections) {
        encryptedSections = initialState.encryptedSections;
       }
       wieldThePower();
       forgeTheTopology();
       updateViewBox();
       MobileManager.applyAll();
       if (autoPingEnabled) {
        startAutoPing();
       }
       const initialNodes = Object.keys(NODE_DATA);
       if (initialNodes.length > 0) {
        claimTheImmortal(initialNodes.includes("host") ? "host" : initialNodes[0], );
       } else {
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.display = "none";
       }
      })();
      let resizeDebounceTimer = null;
      window.addEventListener("resize", () => {
        clearTimeout(resizeDebounceTimer);
        resizeDebounceTimer = setTimeout(() => {
          MobileManager.applyAll();
          if (typeof updateDrawToolbarVisibility === 'function') updateDrawToolbarVisibility();
          if (typeof updateTopologyToolbarVisibility === 'function') updateTopologyToolbarVisibility();
        }, 100);
      });
      function getBreakpointKey() {
       const w = window.innerWidth;
       if (w <= 380) return "fold";
       if (w <= 768) return "mobile";
       if (w <= 1024) return "tablet";
       return "desktop";
      }
      function resolveStylesEntry(styleEntry) {
       if (!styleEntry) return {};
       if (styleEntry.circleColor || styleEntry.titleColor || styleEntry.titleFont || styleEntry.titleSize || styleEntry.subColor || styleEntry.subFont || styleEntry.subSize) {
        return styleEntry;
       }
       const bp = getBreakpointKey();
       const base = styleEntry.all || {};
       const bpStyles = styleEntry[bp] || {};
       return Object.assign({}, base, bpStyles);
      }
      function resolveStylesForNode(id) {
       const styleEntry = savedStyles[id];
       if (!styleEntry) return {};
       return resolveStylesEntry(styleEntry);
      }
      function ensureStyleEntry(id) {
       if (!savedStyles[id]) savedStyles[id] = {};
       const entry = savedStyles[id];
       const flatProps = ["circleColor", "circleBorder", "titleColor", "titleFont", "titleSize", "subColor", "subFont", "subSize", ];
       const isFlat = flatProps.some((p) => Object.prototype.hasOwnProperty.call(entry, p), );
       if (isFlat) {
        const all = entry.all || {};
        flatProps.forEach((p) => {
         if (entry[p] !== undefined) {
          all[p] = entry[p];
          delete entry[p];
         }
        });
        entry.all = all;
       }
       return entry;
      }
      function getDefaultSize() {
       if (window.innerWidth <= 380) return 120;
       if (window.innerWidth <= 768) return 140;
       if (window.innerWidth <= 1024) return 70;
       return 55;
      }
      function createShapeElement(shape, size) {
       const ns = "http://www.w3.org/2000/svg";
       if (shape === "circle") {
        const c = document.createElementNS(ns, "circle");
        c.setAttribute("r", size);
        return c;
       }
       if (shape === "square") {
        const r = document.createElementNS(ns, "rect");
        const s = size * 2;
        r.setAttribute("x", -size);
        r.setAttribute("y", -size);
        r.setAttribute("width", s);
        r.setAttribute("height", s);
        r.setAttribute("rx", 4);
        return r;
       }
       if (shape === "rectangle") {
        const r = document.createElementNS(ns, "rect");
        r.setAttribute("x", -size * 1.4);
        r.setAttribute("y", -size * 0.8);
        r.setAttribute("width", size * 2.8);
        r.setAttribute("height", size * 1.6);
        r.setAttribute("rx", 6);
        return r;
       }
       if (shape === "triangle") {
        const p = document.createElementNS(ns, "polygon");
        const h = size * 1.8;
        const w = size * 2;
        p.setAttribute("points", `0,${-h} ${w / 2},${h / 2} ${-w / 2},${h / 2}`, );
        return p;
       }
       if (shape === "hexagon") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        const pts = [
         [0, -s],
         [s * 0.86, -s * 0.5],
         [s * 0.86, s * 0.5],
         [0, s],
         [-s * 0.86, s * 0.5],
         [-s * 0.86, -s * 0.5],
        ].map((pt) => pt.join(",")).join(" ");
        p.setAttribute("points", pts);
        return p;
       }
       if (shape === "stop-sign") {
        const p = document.createElementNS(ns, "polygon");
        const r = size;
        const ptsArr = [];
        for (let i = 0; i < 8; i++) {
         const a = (Math.PI / 4) * i + Math.PI / 8;
         ptsArr.push([Math.cos(a) * r, Math.sin(a) * r]);
        }
        const pts = ptsArr.map((pt) => pt.join(",")).join(" ");
        p.setAttribute("points", pts);
        return p;
       }
       if (shape === "star") {
        const p = document.createElementNS(ns, "polygon");
        const outer = size;
        const inner = size * 0.45;
        let pts = "";
        for (let i = 0; i < 10; i++) {
         const a = (Math.PI / 5) * i - Math.PI / 2;
         const r = i % 2 === 0 ? outer : inner;
         pts += `${Math.cos(a) * r},${Math.sin(a) * r} `;
        }
        p.setAttribute("points", pts.trim());
        return p;
       }
       if (shape === "diamond") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `0,${-s} ${s},0 0,${s} ${-s},0`);
        return p;
       }
       if (shape === "server") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.2);
        body.setAttribute("y", -size * 0.6);
        body.setAttribute("width", size * 2.4);
        body.setAttribute("height", size * 1.2);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 3; i++) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", -size * 0.9 + i * size * 0.5);
         line.setAttribute("y1", -size * 0.3);
         line.setAttribute("x2", -size * 0.9 + i * size * 0.5);
         line.setAttribute("y2", size * 0.3);
         line.style.stroke = "currentColor";
         line.style.strokeWidth = "2";
         line.style.opacity = "0.5";
         g.appendChild(line);
        }
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", size * 0.9);
        led.setAttribute("cy", 0);
        led.setAttribute("r", size * 0.1);
        led.style.fill = "#4ade80";
        g.appendChild(led);
        return g;
       }
       if (shape === "pc" || shape === "desktop") {
        const g = document.createElementNS(ns, "g");
        const monitor = document.createElementNS(ns, "rect");
        monitor.setAttribute("x", -size * 0.9);
        monitor.setAttribute("y", -size * 0.8);
        monitor.setAttribute("width", size * 1.8);
        monitor.setAttribute("height", size * 1.2);
        monitor.setAttribute("rx", 4);
        g.appendChild(monitor);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.75);
        screen.setAttribute("y", -size * 0.65);
        screen.setAttribute("width", size * 1.5);
        screen.setAttribute("height", size * 0.9);
        screen.setAttribute("rx", 2);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        const neck = document.createElementNS(ns, "rect");
        neck.setAttribute("x", -size * 0.15);
        neck.setAttribute("y", size * 0.4);
        neck.setAttribute("width", size * 0.3);
        neck.setAttribute("height", size * 0.3);
        g.appendChild(neck);
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.5);
        base.setAttribute("y", size * 0.7);
        base.setAttribute("width", size * 1);
        base.setAttribute("height", size * 0.15);
        base.setAttribute("rx", 2);
        g.appendChild(base);
        return g;
       }
       if (shape === "laptop") {
        const g = document.createElementNS(ns, "g");
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.8);
        screen.setAttribute("y", -size * 0.9);
        screen.setAttribute("width", size * 1.6);
        screen.setAttribute("height", size * 1.1);
        screen.setAttribute("rx", 4);
        g.appendChild(screen);
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.9);
        base.setAttribute("y", size * 0.25);
        base.setAttribute("width", size * 1.8);
        base.setAttribute("height", size * 0.6);
        base.setAttribute("rx", 4);
        g.appendChild(base);
        const pad = document.createElementNS(ns, "rect");
        pad.setAttribute("x", -size * 0.25);
        pad.setAttribute("y", size * 0.45);
        pad.setAttribute("width", size * 0.5);
        pad.setAttribute("height", size * 0.25);
        pad.setAttribute("rx", 2);
        pad.style.fill = "#1e293b";
        g.appendChild(pad);
        return g;
       }
       if (shape === "phone" || shape === "mobile") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.45);
        body.setAttribute("y", -size);
        body.setAttribute("width", size * 0.9);
        body.setAttribute("height", size * 2);
        body.setAttribute("rx", 8);
        g.appendChild(body);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.38);
        screen.setAttribute("y", -size * 0.85);
        screen.setAttribute("width", size * 0.76);
        screen.setAttribute("height", size * 1.6);
        screen.setAttribute("rx", 4);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        const btn = document.createElementNS(ns, "rect");
        btn.setAttribute("x", -size * 0.15);
        btn.setAttribute("y", size * 0.82);
        btn.setAttribute("width", size * 0.3);
        btn.setAttribute("height", size * 0.06);
        btn.setAttribute("rx", 2);
        btn.style.fill = "#475569";
        g.appendChild(btn);
        return g;
       }
       if (shape === "router") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.1);
        body.setAttribute("y", -size * 0.3);
        body.setAttribute("width", size * 2.2);
        body.setAttribute("height", size * 0.8);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        for (let i = -1; i <= 1; i++) {
         const ant = document.createElementNS(ns, "rect");
         ant.setAttribute("x", i * size * 0.6 - size * 0.05);
         ant.setAttribute("y", -size * 0.9);
         ant.setAttribute("width", size * 0.1);
         ant.setAttribute("height", size * 0.6);
         ant.setAttribute("rx", 2);
         g.appendChild(ant);
         const tip = document.createElementNS(ns, "circle");
         tip.setAttribute("cx", i * size * 0.6);
         tip.setAttribute("cy", -size * 0.95);
         tip.setAttribute("r", size * 0.08);
         g.appendChild(tip);
        }
        for (let i = 0; i < 4; i++) {
         const led = document.createElementNS(ns, "circle");
         led.setAttribute("cx", -size * 0.7 + i * size * 0.35);
         led.setAttribute("cy", size * 0.1);
         led.setAttribute("r", size * 0.06);
         led.style.fill = i < 2 ? "#4ade80" : "#facc15";
         g.appendChild(led);
        }
        return g;
       }
       if (shape === "switch") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.4);
        body.setAttribute("y", -size * 0.4);
        body.setAttribute("width", size * 2.8);
        body.setAttribute("height", size * 0.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 8; i++) {
         const port = document.createElementNS(ns, "rect");
         port.setAttribute("x", -size * 1.2 + i * size * 0.32);
         port.setAttribute("y", -size * 0.15);
         port.setAttribute("width", size * 0.22);
         port.setAttribute("height", size * 0.3);
         port.setAttribute("rx", 1);
         port.style.fill = "#1e293b";
         g.appendChild(port);
        }
        return g;
       }
       if (shape === "firewall") {
        const g = document.createElementNS(ns, "g");
        const wall = document.createElementNS(ns, "rect");
        wall.setAttribute("x", -size);
        wall.setAttribute("y", -size * 0.8);
        wall.setAttribute("width", size * 2);
        wall.setAttribute("height", size * 1.6);
        wall.setAttribute("rx", 4);
        g.appendChild(wall);
        for (let row = 0; row < 3; row++) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", -size * 0.85);
         line.setAttribute("y1", -size * 0.5 + row * size * 0.45);
         line.setAttribute("x2", size * 0.85);
         line.setAttribute("y2", -size * 0.5 + row * size * 0.45);
         line.style.stroke = "#475569";
         line.style.strokeWidth = "2";
         g.appendChild(line);
        }
        for (let row = 0; row < 4; row++) {
         const offset = row % 2 === 0 ? 0 : size * 0.35;
         for (let col = 0; col < 3; col++) {
          const line = document.createElementNS(ns, "line");
          const x = -size * 0.5 + col * size * 0.7 + offset;
          if (x > -size * 0.85 && x < size * 0.85) {
           line.setAttribute("x1", x);
           line.setAttribute("y1", -size * 0.8 + row * size * 0.45, );
           line.setAttribute("x2", x);
           line.setAttribute("y2", -size * 0.8 + row * size * 0.45 + size * 0.45, );
           line.style.stroke = "#475569";
           line.style.strokeWidth = "2";
           g.appendChild(line);
          }
         }
        }
        return g;
       }
       if (shape === "cloud") {
        const p = document.createElementNS(ns, "path");
        const s = size;
        p.setAttribute("d", `
             M ${-s * 0.8} ${s * 0.2}
             Q ${-s * 1.1} ${s * 0.2} ${-s * 1.1} ${-s * 0.1}
             Q ${-s * 1.1} ${-s * 0.5} ${-s * 0.7} ${-s * 0.5}
             Q ${-s * 0.7} ${-s * 0.9} ${-s * 0.2} ${-s * 0.9}
             Q ${s * 0.1} ${-s * 1.1} ${s * 0.5} ${-s * 0.8}
             Q ${s * 1} ${-s * 0.8} ${s * 1.1} ${-s * 0.3}
             Q ${s * 1.3} ${-s * 0.1} ${s * 1.1} ${s * 0.2}
             Q ${s * 1.1} ${s * 0.5} ${s * 0.7} ${s * 0.5}
             L ${-s * 0.5} ${s * 0.5}
             Q ${-s * 0.9} ${s * 0.5} ${-s * 0.9} ${s * 0.2}
             Z
            `, );
        return p;
       }
       if (shape === "database") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.7);
        body.setAttribute("y", -size * 0.6);
        body.setAttribute("width", size * 1.4);
        body.setAttribute("height", size * 1.4);
        g.appendChild(body);
        const top = document.createElementNS(ns, "ellipse");
        top.setAttribute("cx", 0);
        top.setAttribute("cy", -size * 0.6);
        top.setAttribute("rx", size * 0.7);
        top.setAttribute("ry", size * 0.25);
        g.appendChild(top);
        const bottom = document.createElementNS(ns, "ellipse");
        bottom.setAttribute("cx", 0);
        bottom.setAttribute("cy", size * 0.8);
        bottom.setAttribute("rx", size * 0.7);
        bottom.setAttribute("ry", size * 0.25);
        g.appendChild(bottom);
        const mid1 = document.createElementNS(ns, "ellipse");
        mid1.setAttribute("cx", 0);
        mid1.setAttribute("cy", -size * 0.15);
        mid1.setAttribute("rx", size * 0.7);
        mid1.setAttribute("ry", size * 0.2);
        mid1.style.fill = "none";
        mid1.style.stroke = "#475569";
        mid1.style.strokeWidth = "2";
        g.appendChild(mid1);
        const mid2 = document.createElementNS(ns, "ellipse");
        mid2.setAttribute("cx", 0);
        mid2.setAttribute("cy", size * 0.35);
        mid2.setAttribute("rx", size * 0.7);
        mid2.setAttribute("ry", size * 0.2);
        mid2.style.fill = "none";
        mid2.style.stroke = "#475569";
        mid2.style.strokeWidth = "2";
        g.appendChild(mid2);
        return g;
       }
       if (shape === "printer") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.4);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size * 0.9);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const trayTop = document.createElementNS(ns, "rect");
        trayTop.setAttribute("x", -size * 0.7);
        trayTop.setAttribute("y", -size * 0.8);
        trayTop.setAttribute("width", size * 1.4);
        trayTop.setAttribute("height", size * 0.4);
        trayTop.setAttribute("rx", 2);
        trayTop.style.fill = "#1e293b";
        g.appendChild(trayTop);
        const trayOut = document.createElementNS(ns, "rect");
        trayOut.setAttribute("x", -size * 0.6);
        trayOut.setAttribute("y", size * 0.5);
        trayOut.setAttribute("width", size * 1.2);
        trayOut.setAttribute("height", size * 0.35);
        trayOut.setAttribute("rx", 2);
        g.appendChild(trayOut);
        const paper = document.createElementNS(ns, "rect");
        paper.setAttribute("x", -size * 0.5);
        paper.setAttribute("y", size * 0.3);
        paper.setAttribute("width", size * 1);
        paper.setAttribute("height", size * 0.5);
        paper.style.fill = "#e2e8f0";
        g.appendChild(paper);
        return g;
       }
       if (shape === "access-point" || shape === "wifi") {
        const g = document.createElementNS(ns, "g");
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.3);
        base.setAttribute("y", size * 0.2);
        base.setAttribute("width", size * 0.6);
        base.setAttribute("height", size * 0.3);
        base.setAttribute("rx", 3);
        g.appendChild(base);
        for (let i = 1; i <= 3; i++) {
         const arc = document.createElementNS(ns, "path");
         const r = size * 0.3 * i;
         arc.setAttribute("d", `M ${-r * 0.7} ${size * 0.1 - r * 0.5} A ${r} ${r} 0 0 1 ${r * 0.7} ${size * 0.1 - r * 0.5}`);
         arc.style.fill = "none";
         arc.style.stroke = "currentColor";
         arc.style.strokeWidth = "2";
         arc.style.opacity = 1 - (i * 0.2);
         g.appendChild(arc);
        }
        return g;
       }
       if (shape === "load-balancer") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.5);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        const bar = document.createElementNS(ns, "line");
        bar.setAttribute("x1", -size * 0.6);
        bar.setAttribute("y1", 0);
        bar.setAttribute("x2", size * 0.6);
        bar.setAttribute("y2", 0);
        bar.style.stroke = "#4ade80";
        bar.style.strokeWidth = "3";
        g.appendChild(bar);
        [-1, 1].forEach(dir => {
         const arrow = document.createElementNS(ns, "path");
         arrow.setAttribute("d", `M ${dir * size * 0.3} ${-size * 0.2} L ${dir * size * 0.6} 0 L ${dir * size * 0.3} ${size * 0.2}`);
         arrow.style.fill = "none";
         arrow.style.stroke = "#4ade80";
         arrow.style.strokeWidth = "2";
         g.appendChild(arrow);
        });
        return g;
       }
       if (shape === "nas" || shape === "storage") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.8);
        body.setAttribute("y", -size * 0.9);
        body.setAttribute("width", size * 1.6);
        body.setAttribute("height", size * 1.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 4; i++) {
         const bay = document.createElementNS(ns, "rect");
         bay.setAttribute("x", -size * 0.6);
         bay.setAttribute("y", -size * 0.7 + i * size * 0.4);
         bay.setAttribute("width", size * 1.2);
         bay.setAttribute("height", size * 0.3);
         bay.setAttribute("rx", 2);
         bay.style.fill = "#1e293b";
         g.appendChild(bay);
        }
        return g;
       }
       if (shape === "gateway" || shape === "modem") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.5);
        body.setAttribute("y", -size * 0.9);
        body.setAttribute("width", size);
        body.setAttribute("height", size * 1.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 4; i++) {
         const led = document.createElementNS(ns, "circle");
         led.setAttribute("cx", 0);
         led.setAttribute("cy", -size * 0.6 + i * size * 0.35);
         led.setAttribute("r", size * 0.08);
         led.style.fill = ["#4ade80", "#4ade80", "#facc15", "#60a5fa"][i];
         g.appendChild(led);
        }
        return g;
       }
       if (shape === "vpn" || shape === "tunnel") {
        const g = document.createElementNS(ns, "g");
        const outer = document.createElementNS(ns, "ellipse");
        outer.setAttribute("cx", 0);
        outer.setAttribute("cy", 0);
        outer.setAttribute("rx", size);
        outer.setAttribute("ry", size * 0.6);
        g.appendChild(outer);
        const inner = document.createElementNS(ns, "ellipse");
        inner.setAttribute("cx", 0);
        inner.setAttribute("cy", 0);
        inner.setAttribute("rx", size * 0.5);
        inner.setAttribute("ry", size * 0.3);
        inner.style.fill = "#1e293b";
        g.appendChild(inner);
        const lock = document.createElementNS(ns, "rect");
        lock.setAttribute("x", -size * 0.15);
        lock.setAttribute("y", -size * 0.1);
        lock.setAttribute("width", size * 0.3);
        lock.setAttribute("height", size * 0.25);
        lock.setAttribute("rx", 2);
        lock.style.fill = "#4ade80";
        g.appendChild(lock);
        return g;
       }
       if (shape === "container") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.5);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 3; i++) {
         const block = document.createElementNS(ns, "rect");
         block.setAttribute("x", -size * 0.8 + i * size * 0.55);
         block.setAttribute("y", -size * 0.3);
         block.setAttribute("width", size * 0.45);
         block.setAttribute("height", size * 0.6);
         block.setAttribute("rx", 2);
         block.style.fill = "#1e293b";
         g.appendChild(block);
        }
        return g;
       }
       if (shape === "vm" || shape === "virtual") {
        const g = document.createElementNS(ns, "g");
        const shadow = document.createElementNS(ns, "rect");
        shadow.setAttribute("x", -size * 0.85 + 4);
        shadow.setAttribute("y", -size * 0.65 + 4);
        shadow.setAttribute("width", size * 1.7);
        shadow.setAttribute("height", size * 1.3);
        shadow.setAttribute("rx", 4);
        shadow.style.opacity = "0.3";
        g.appendChild(shadow);
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.85);
        body.setAttribute("y", -size * 0.65);
        body.setAttribute("width", size * 1.7);
        body.setAttribute("height", size * 1.3);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.65);
        screen.setAttribute("y", -size * 0.45);
        screen.setAttribute("width", size * 1.3);
        screen.setAttribute("height", size * 0.7);
        screen.setAttribute("rx", 2);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        return g;
       }
       if (shape === "kubernetes" || shape === "k8s") {
        const g = document.createElementNS(ns, "g");
        const outer = document.createElementNS(ns, "circle");
        outer.setAttribute("cx", 0);
        outer.setAttribute("cy", 0);
        outer.setAttribute("r", size);
        g.appendChild(outer);
        const inner = document.createElementNS(ns, "circle");
        inner.setAttribute("cx", 0);
        inner.setAttribute("cy", 0);
        inner.setAttribute("r", size * 0.4);
        inner.style.fill = "#1e293b";
        g.appendChild(inner);
        for (let i = 0; i < 7; i++) {
         const angle = (Math.PI * 2 / 7) * i - Math.PI / 2;
         const spoke = document.createElementNS(ns, "line");
         spoke.setAttribute("x1", Math.cos(angle) * size * 0.4);
         spoke.setAttribute("y1", Math.sin(angle) * size * 0.4);
         spoke.setAttribute("x2", Math.cos(angle) * size * 0.85);
         spoke.setAttribute("y2", Math.sin(angle) * size * 0.85);
         spoke.style.stroke = "#326ce5";
         spoke.style.strokeWidth = "3";
         g.appendChild(spoke);
        }
        return g;
       }
       if (shape === "shield" || shape === "security") {
        const p = document.createElementNS(ns, "path");
        const s = size;
        p.setAttribute("d", `M 0 ${-s} L ${s * 0.85} ${-s * 0.5} L ${s * 0.85} ${s * 0.2} Q ${s * 0.7} ${s * 0.9} 0 ${s} Q ${-s * 0.7} ${s * 0.9} ${-s * 0.85} ${s * 0.2} L ${-s * 0.85} ${-s * 0.5} Z`);
        return p;
       }
       if (shape === "camera" || shape === "cctv") {
        const g = document.createElementNS(ns, "g");
        const mount = document.createElementNS(ns, "rect");
        mount.setAttribute("x", -size * 1.1);
        mount.setAttribute("y", -size * 0.5);
        mount.setAttribute("width", size * 0.25);
        mount.setAttribute("height", size * 0.6);
        mount.setAttribute("rx", 2);
        g.appendChild(mount);
        const arm = document.createElementNS(ns, "rect");
        arm.setAttribute("x", -size * 0.9);
        arm.setAttribute("y", -size * 0.15);
        arm.setAttribute("width", size * 0.5);
        arm.setAttribute("height", size * 0.15);
        g.appendChild(arm);
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.45);
        body.setAttribute("y", -size * 0.35);
        body.setAttribute("width", size * 1.1);
        body.setAttribute("height", size * 0.7);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const lensHousing = document.createElementNS(ns, "circle");
        lensHousing.setAttribute("cx", size * 0.85);
        lensHousing.setAttribute("cy", 0);
        lensHousing.setAttribute("r", size * 0.4);
        g.appendChild(lensHousing);
        const lensOuter = document.createElementNS(ns, "circle");
        lensOuter.setAttribute("cx", size * 0.85);
        lensOuter.setAttribute("cy", 0);
        lensOuter.setAttribute("r", size * 0.28);
        lensOuter.style.fill = "#1e293b";
        g.appendChild(lensOuter);
        const lensInner = document.createElementNS(ns, "circle");
        lensInner.setAttribute("cx", size * 0.85);
        lensInner.setAttribute("cy", 0);
        lensInner.setAttribute("r", size * 0.15);
        lensInner.style.fill = "#3b82f6";
        g.appendChild(lensInner);
        const reflection = document.createElementNS(ns, "circle");
        reflection.setAttribute("cx", size * 0.8);
        reflection.setAttribute("cy", -size * 0.05);
        reflection.setAttribute("r", size * 0.05);
        reflection.style.fill = "#93c5fd";
        g.appendChild(reflection);
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", -size * 0.2);
        led.setAttribute("cy", -size * 0.15);
        led.setAttribute("r", size * 0.06);
        led.style.fill = "#ef4444";
        g.appendChild(led);
        return g;
       }
       if (shape === "monitor" || shape === "dashboard") {
        const g = document.createElementNS(ns, "g");
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size);
        screen.setAttribute("y", -size * 0.7);
        screen.setAttribute("width", size * 2);
        screen.setAttribute("height", size * 1.2);
        screen.setAttribute("rx", 4);
        g.appendChild(screen);
        const graph = document.createElementNS(ns, "polyline");
        graph.setAttribute("points", `${-size * 0.8},${size * 0.2} ${-size * 0.3},${-size * 0.2} ${size * 0.2},${size * 0.1} ${size * 0.7},${-size * 0.3}`);
        graph.style.fill = "none";
        graph.style.stroke = "#4ade80";
        graph.style.strokeWidth = "3";
        g.appendChild(graph);
        return g;
       }
       if (shape === "docker" || shape === "whale") {
        const g = document.createElementNS(ns, "g");
        const s = size;
        const body = document.createElementNS(ns, "path");
        body.setAttribute("d", `
         M ${-s * 0.9} ${s * 0.2}
         Q ${-s * 1.1} ${s * 0.5} ${-s * 0.7} ${s * 0.7}
         Q ${-s * 0.3} ${s * 0.85} ${s * 0.3} ${s * 0.75}
         Q ${s * 0.8} ${s * 0.6} ${s * 1.0} ${s * 0.3}
         Q ${s * 1.1} ${s * 0.1} ${s * 1.0} ${-s * 0.1}
         L ${s * 0.85} ${-s * 0.1}
         Q ${s * 0.7} ${-s * 0.15} ${s * 0.4} ${-s * 0.2}
         L ${-s * 0.5} ${-s * 0.2}
         Q ${-s * 0.8} ${-s * 0.1} ${-s * 0.9} ${s * 0.2}
         Z
        `);
        body.style.fill = "#0db7ed";
        g.appendChild(body);
        const tail = document.createElementNS(ns, "path");
        tail.setAttribute("d", `
         M ${-s * 0.85} ${s * 0.1}
         Q ${-s * 1.2} ${-s * 0.2} ${-s * 1.0} ${-s * 0.55}
         Q ${-s * 0.95} ${-s * 0.35} ${-s * 0.8} ${-s * 0.15}
         Z
        `);
        tail.style.fill = "#0db7ed";
        g.appendChild(tail);
        const belly = document.createElementNS(ns, "path");
        belly.setAttribute("d", `
         M ${-s * 0.5} ${s * 0.65}
         Q ${s * 0.1} ${s * 0.75} ${s * 0.6} ${s * 0.55}
         Q ${s * 0.8} ${s * 0.45} ${s * 0.9} ${s * 0.25}
         Q ${s * 0.7} ${s * 0.5} ${s * 0.3} ${s * 0.6}
         Q ${-s * 0.1} ${s * 0.7} ${-s * 0.5} ${s * 0.65}
         Z
        `);
        belly.style.fill = "#ffffff";
        belly.style.opacity = "0.3";
        g.appendChild(belly);
        for (let row = 0; row < 2; row++) {
         for (let col = 0; col < 3; col++) {
          const container = document.createElementNS(ns, "rect");
          container.setAttribute("x", -s * 0.45 + col * s * 0.35);
          container.setAttribute("y", -s * 0.7 + row * s * 0.28);
          container.setAttribute("width", s * 0.3);
          container.setAttribute("height", s * 0.23);
          container.setAttribute("rx", 2);
          container.style.fill = "#0db7ed";
          container.style.stroke = "#0a9ed8";
          container.style.strokeWidth = "1.5";
          g.appendChild(container);
         }
        }
        const topContainer = document.createElementNS(ns, "rect");
        topContainer.setAttribute("x", -s * 0.1);
        topContainer.setAttribute("y", -s * 0.95);
        topContainer.setAttribute("width", s * 0.3);
        topContainer.setAttribute("height", s * 0.23);
        topContainer.setAttribute("rx", 2);
        topContainer.style.fill = "#0db7ed";
        topContainer.style.stroke = "#0a9ed8";
        topContainer.style.strokeWidth = "1.5";
        g.appendChild(topContainer);
        const eye = document.createElementNS(ns, "circle");
        eye.setAttribute("cx", s * 0.65);
        eye.setAttribute("cy", s * 0.25);
        eye.setAttribute("r", s * 0.08);
        eye.style.fill = "#0a5f7a";
        g.appendChild(eye);
        return g;
       }
       if (shape === "rounded-square") {
        const r = document.createElementNS(ns, "rect");
        const s = size * 1.6;
        r.setAttribute("x", -s / 2);
        r.setAttribute("y", -s / 2);
        r.setAttribute("width", s);
        r.setAttribute("height", s);
        r.setAttribute("rx", size * 0.4);
        return r;
       }
       if (shape === "pill" || shape === "capsule") {
        const r = document.createElementNS(ns, "rect");
        r.setAttribute("x", -size * 1.2);
        r.setAttribute("y", -size * 0.5);
        r.setAttribute("width", size * 2.4);
        r.setAttribute("height", size);
        r.setAttribute("rx", size * 0.5);
        return r;
       }
       if (shape === "octagon") {
        const p = document.createElementNS(ns, "polygon");
        const r = size;
        const pts = [];
        for (let i = 0; i < 8; i++) {
         const a = (Math.PI / 4) * i - Math.PI / 8;
         pts.push([Math.cos(a) * r, Math.sin(a) * r]);
        }
        p.setAttribute("points", pts.map(pt => pt.join(",")).join(" "));
        return p;
       }
       if (shape === "pentagon") {
        const p = document.createElementNS(ns, "polygon");
        const pts = [];
        for (let i = 0; i < 5; i++) {
         const a = (Math.PI * 2 / 5) * i - Math.PI / 2;
         pts.push([Math.cos(a) * size, Math.sin(a) * size]);
        }
        p.setAttribute("points", pts.map(pt => pt.join(",")).join(" "));
        return p;
       }
       if (shape === "cross" || shape === "plus") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        const t = size * 0.35;
        p.setAttribute("points", `${-t},${-s} ${t},${-s} ${t},${-t} ${s},${-t} ${s},${t} ${t},${t} ${t},${s} ${-t},${s} ${-t},${t} ${-s},${t} ${-s},${-t} ${-t},${-t}`);
        return p;
       }
       if (shape === "parallelogram") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `${-s * 0.6},${-s * 0.6} ${s * 1.2},${-s * 0.6} ${s * 0.6},${s * 0.6} ${-s * 1.2},${s * 0.6}`);
        return p;
       }
       if (shape === "trapezoid") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `${-s * 0.6},${-s * 0.6} ${s * 0.6},${-s * 0.6} ${s},${s * 0.6} ${-s},${s * 0.6}`);
        return p;
       }
       if (shape === "sensor" || shape === "iot") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "circle");
        body.setAttribute("cx", 0);
        body.setAttribute("cy", 0);
        body.setAttribute("r", size * 0.7);
        g.appendChild(body);
        const ant = document.createElementNS(ns, "line");
        ant.setAttribute("x1", 0);
        ant.setAttribute("y1", -size * 0.7);
        ant.setAttribute("x2", 0);
        ant.setAttribute("y2", -size);
        ant.style.stroke = "currentColor";
        ant.style.strokeWidth = "2";
        g.appendChild(ant);
        const tip = document.createElementNS(ns, "circle");
        tip.setAttribute("cx", 0);
        tip.setAttribute("cy", -size);
        tip.setAttribute("r", size * 0.1);
        tip.style.fill = "#4ade80";
        g.appendChild(tip);
        return g;
       }
       if (shape === "pi" || shape === "sbc" || shape === "raspberry") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.65);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size * 1.3);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 10; i++) {
         const pin = document.createElementNS(ns, "rect");
         pin.setAttribute("x", -size * 0.85 + i * size * 0.19);
         pin.setAttribute("y", -size * 0.8);
         pin.setAttribute("width", size * 0.08);
         pin.setAttribute("height", size * 0.15);
         pin.style.fill = "#facc15";
         g.appendChild(pin);
        }
        const port = document.createElementNS(ns, "rect");
        port.setAttribute("x", size * 0.6);
        port.setAttribute("y", -size * 0.2);
        port.setAttribute("width", size * 0.35);
        port.setAttribute("height", size * 0.4);
        port.style.fill = "#1e293b";
        g.appendChild(port);
        return g;
       }
       if (shape === "api" || shape === "endpoint") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.9);
        body.setAttribute("y", -size * 0.7);
        body.setAttribute("width", size * 1.8);
        body.setAttribute("height", size * 1.4);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        const left = document.createElementNS(ns, "text");
        left.setAttribute("x", -size * 0.5);
        left.setAttribute("y", size * 0.15);
        left.setAttribute("font-size", size * 0.9);
        left.setAttribute("fill", "#4ade80");
        left.setAttribute("font-family", "monospace");
        left.textContent = "{";
        g.appendChild(left);
        const right = document.createElementNS(ns, "text");
        right.setAttribute("x", size * 0.15);
        right.setAttribute("y", size * 0.15);
        right.setAttribute("font-size", size * 0.9);
        right.setAttribute("fill", "#4ade80");
        right.setAttribute("font-family", "monospace");
        right.textContent = "}";
        g.appendChild(right);
        return g;
       }
       if (shape === "queue" || shape === "message") {
        const g = document.createElementNS(ns, "g");
        for (let i = 2; i >= 0; i--) {
         const card = document.createElementNS(ns, "rect");
         card.setAttribute("x", -size * 0.7 + i * 4);
         card.setAttribute("y", -size * 0.5 + i * 4);
         card.setAttribute("width", size * 1.4);
         card.setAttribute("height", size * 0.8);
         card.setAttribute("rx", 3);
         card.style.opacity = 1 - i * 0.25;
         g.appendChild(card);
        }
        return g;
       }
       if (shape === "lambda" || shape === "function") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.8);
        body.setAttribute("y", -size * 0.8);
        body.setAttribute("width", size * 1.6);
        body.setAttribute("height", size * 1.6);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const lambda = document.createElementNS(ns, "text");
        lambda.setAttribute("x", 0);
        lambda.setAttribute("y", size * 0.2);
        lambda.setAttribute("font-size", size * 1.2);
        lambda.setAttribute("fill", "#f59e0b");
        lambda.setAttribute("text-anchor", "middle");
        lambda.setAttribute("font-family", "serif");
        lambda.textContent = "Œª";
        g.appendChild(lambda);
        return g;
       }
       if (shape === "bucket" || shape === "s3") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "path");
        body.setAttribute("d", `M ${-size * 0.8} ${-size * 0.7} L ${-size * 0.6} ${size * 0.8} Q ${-size * 0.5} ${size} 0 ${size} Q ${size * 0.5} ${size} ${size * 0.6} ${size * 0.8} L ${size * 0.8} ${-size * 0.7} Z`);
        g.appendChild(body);
        const rim = document.createElementNS(ns, "ellipse");
        rim.setAttribute("cx", 0);
        rim.setAttribute("cy", -size * 0.7);
        rim.setAttribute("rx", size * 0.8);
        rim.setAttribute("ry", size * 0.25);
        g.appendChild(rim);
        return g;
       }
       const c = document.createElementNS(ns, "circle");
       c.setAttribute("r", size);
       return c;
      }
      function createNodeShape(id, size) {
       const styles = resolveStylesForNode(id);
       if (styles.icon && styles.icon.library && styles.icon.name) {
        const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
        g.classList.add("node-circle");
        IconLibrary.getIcon(styles.icon.library, styles.icon.name).then(svgText => {
         if (svgText) {
          const parser = new DOMParser();
          const doc = parser.parseFromString(svgText, 'image/svg+xml');
          const svgEl = doc.querySelector('svg');
          if (svgEl) {
           svgEl.setAttribute('width', size * 1.2);
           svgEl.setAttribute('height', size * 1.2);
           svgEl.setAttribute('x', -size * 0.6);
           svgEl.setAttribute('y', -size * 0.6);
           if (styles.circleColor) {
            svgEl.style.fill = styles.circleColor;
            svgEl.querySelectorAll('path, circle, rect, polygon, ellipse').forEach(el => {
             el.style.fill = styles.circleColor;
            });
           }
           if (styles.circleBorder) {
            svgEl.style.stroke = styles.circleBorder;
            svgEl.querySelectorAll('path, circle, rect, polygon, ellipse').forEach(el => {
             el.style.stroke = styles.circleBorder;
            });
           }
           g.innerHTML = svgEl.outerHTML;
          }
         }
        });
        return g;
       }
       const shapeType = (NODE_DATA[id] && NODE_DATA[id].shape) || "circle";
       const shapeEl = createShapeElement(shapeType, size);
       shapeEl.classList.add("node-circle");
       shapeEl.style.fill = styles.circleColor || PAGE_STATE.nodeFill || "#1e293b";
       shapeEl.style.stroke = styles.circleBorder || PAGE_STATE.nodeStroke || "#475569";
       return shapeEl;
      }
      function forgeTheLegend() {
       const container = document.getElementById("edge-legend");
       if (!container) return;
       container.innerHTML = "";
       const title = document.createElement("div");
       title.className = "legend-title";
       title.textContent = "Line Legend";
       container.appendChild(title);
       const closeBtn = document.createElement("button");
       closeBtn.type = "button";
       closeBtn.className = "legend-close-btn";
       closeBtn.textContent = "‚úï";
       closeBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        legendCollapsed = true;
        updateLegendVisibility();
       });
       container.appendChild(closeBtn);
       const colors = [...new Set(EDGE_DATA.list.map((e) => e.color).filter(Boolean))];
       if (colors.length === 0) {
        updateLegendVisibility();
        return;
       }
       colors.forEach((color) => {
         if (!EDGE_LEGEND[color]) {
          EDGE_LEGEND[color] = "you can edit me too";
         }
         const item = document.createElement("div");
         item.className = "legend-item";
         item.addEventListener("mousedown", (e) => e.stopPropagation());
         item.addEventListener("click", (e) => e.stopPropagation());
         const swatch = document.createElement("span");
         swatch.className = "legend-swatch";
         swatch.style.backgroundColor = color;
         swatch.style.cursor = "pointer";
         swatch.addEventListener("click", (e) => {
          e.stopPropagation();
          const edgeWithColor = EDGE_DATA.list.find(edge => edge.color === color);
          if (edgeWithColor) {
           selectTheConnection(edgeWithColor.id);
          }
         });
         let swatchTouchStart = null;
         let swatchTouchMoved = false;
         swatch.addEventListener("touchstart", (e) => {
         swatchTouchStart = Date.now();
         swatchTouchMoved = false;
         if (e.touches[0]) {
          swatchTouchStartX = e.touches[0].clientX;
          swatchTouchStartY = e.touches[0].clientY;
         }
        }, {
          passive: false
         });
         let swatchTouchStartX = 0, swatchTouchStartY = 0;
        swatch.addEventListener("touchmove", (e) => {
         if (e.touches[0]) {
          const dx = Math.abs(e.touches[0].clientX - swatchTouchStartX);
          const dy = Math.abs(e.touches[0].clientY - swatchTouchStartY);
          if (dx > 10 || dy > 10) swatchTouchMoved = true;
         }
        }, {
          passive: false
         });
         swatch.addEventListener("touchend", (e) => {
          if (swatchTouchStart && !swatchTouchMoved && Date.now() - swatchTouchStart < 400) {
           e.stopPropagation();
           e.preventDefault();
           const edgeWithColor = EDGE_DATA.list.find(edge => edge.color === color);
           if (edgeWithColor) {
            selectTheConnection(edgeWithColor.id);
           }
          }
          swatchTouchStart = null;
          swatchTouchMoved = false;
         }, {
          passive: false
         });
        const label = document.createElement("span");
        label.className = "legend-label";
        label.textContent = EDGE_LEGEND[color];
        if (isMobileDevice()) {
         label.style.cursor = "pointer";
         let labelTapStart = null;
         let labelTapMoved = false;
         label.addEventListener("touchstart", (e) => {
          labelTapStart = Date.now();
          labelTapMoved = false;
          if (e.touches[0]) {
           labelTapStartX = e.touches[0].clientX;
           labelTapStartY = e.touches[0].clientY;
          }
          e.stopPropagation();
         });
         let labelTapStartX = 0, labelTapStartY = 0;
         label.addEventListener("touchmove", (e) => {
          if (e.touches[0]) {
           const dx = Math.abs(e.touches[0].clientX - labelTapStartX);
           const dy = Math.abs(e.touches[0].clientY - labelTapStartY);
           if (dx > 10 || dy > 10) labelTapMoved = true;
          }
         });
         label.addEventListener("touchend", (e) => {
          if (labelTapStart && !labelTapMoved && Date.now() - labelTapStart < 400) {
           e.preventDefault();
           e.stopPropagation();
           const currentText = label.textContent;
           const newText = prompt("Edit legend label:", currentText);
           if (newText !== null && newText.trim()) {
            label.textContent = newText.trim();
            EDGE_LEGEND[color] = newText.trim();
           }
          }
          labelTapStart = null;
          labelTapMoved = false;
         });
        } else {
           label.contentEditable = true;
           label.addEventListener("focus", () => {
            label.classList.add("editing");
           });
           label.addEventListener("blur", () => {
            label.classList.remove("editing");
            const text = label.textContent.trim() || "you can edit me too";
            EDGE_LEGEND[color] = text;
           });
           label.addEventListener("keydown", (e) => {
            if (e.key === "Enter") {
             e.preventDefault();
             label.blur();
            }
           });
          }
          item.append(swatch, label); container.appendChild(item);
         }); updateLegendVisibility();
       }
       function deleteRectangle(rectId) {
      pushUndo("delete zone");
        RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== rectId);
        forgeTheTopology();
       }
       function updateRectangleDeleteButtons() {
        const deleteButtons = document.querySelectorAll('.rect-delete-btn');
        deleteButtons.forEach(btn => {
         btn.style.display = rectDrawMode ? 'block' : 'none';
        });
       }
       function forgeTheTopology() {
        if (!NODE_DATA || !EDGE_DATA) {
         console.warn("forgeTheTopology called before data initialized");
         return;
        }
        const svg = document.getElementById("map");
        svg.innerHTML = "";
        const ns = "http://www.w3.org/2000/svg";
        const defs = document.createElementNS(ns, "defs");
        const markerForward = document.createElementNS(ns, "marker");
        markerForward.id = "arrow-forward";
        markerForward.setAttribute("markerWidth", "10");
        markerForward.setAttribute("markerHeight", "10");
        markerForward.setAttribute("refX", "9");
        markerForward.setAttribute("refY", "3");
        markerForward.setAttribute("orient", "auto");
        markerForward.setAttribute("markerUnits", "strokeWidth");
        const pathForward = document.createElementNS(ns, "path");
        pathForward.setAttribute("d", "M0,0 L0,6 L9,3 z");
        pathForward.setAttribute("fill", "context-stroke");
        markerForward.appendChild(pathForward);
        defs.appendChild(markerForward);
        const markerBackward = document.createElementNS(ns, "marker");
        markerBackward.id = "arrow-backward";
        markerBackward.setAttribute("markerWidth", "10");
        markerBackward.setAttribute("markerHeight", "10");
        markerBackward.setAttribute("refX", "0");
        markerBackward.setAttribute("refY", "3");
        markerBackward.setAttribute("orient", "auto");
        markerBackward.setAttribute("markerUnits", "strokeWidth");
        const pathBackward = document.createElementNS(ns, "path");
        pathBackward.setAttribute("d", "M9,0 L9,6 L0,3 z");
        pathBackward.setAttribute("fill", "context-stroke");
        markerBackward.appendChild(pathBackward);
        defs.appendChild(markerBackward);
        svg.appendChild(defs);
        const boundary = document.createElementNS(ns, "rect");
        boundary.setAttribute("x", CANVAS_PADDING);
        boundary.setAttribute("y", CANVAS_PADDING);
        boundary.setAttribute("width", CANVAS_WIDTH - CANVAS_PADDING * 2);
        boundary.setAttribute("height", CANVAS_HEIGHT - CANVAS_PADDING * 2);
        boundary.setAttribute("fill", "none");
        boundary.setAttribute("stroke", (PAGE_STATE.canvasBorder || "#475569") + "4D");
        boundary.setAttribute("stroke-width", "20");
        boundary.setAttribute("stroke-dasharray", "10 5");
        boundary.setAttribute("rx", "8");
        svg.appendChild(boundary);
       if (currentView.mode !== "rack") {
        const gridGroup = document.createElementNS(ns, "g");
        gridGroup.id = "canvas-grid";
        const gridSize = PAGE_STATE.canvasGridSize || 50;
        const gridColor = (PAGE_STATE.canvasGrid || "#475569") + "33";
        const majorGridColor = (PAGE_STATE.canvasGrid || "#475569") + "66";
        for (let x = CANVAS_PADDING; x <= CANVAS_WIDTH - CANVAS_PADDING; x += gridSize) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", x);
         line.setAttribute("y1", CANVAS_PADDING);
         line.setAttribute("x2", x);
         line.setAttribute("y2", CANVAS_HEIGHT - CANVAS_PADDING);
         line.setAttribute("stroke", (x - CANVAS_PADDING) % (gridSize * 5) === 0 ? majorGridColor : gridColor);
         line.setAttribute("stroke-width", (x - CANVAS_PADDING) % (gridSize * 5) === 0 ? "2" : "1");
         gridGroup.appendChild(line);
        }
        for (let y = CANVAS_PADDING; y <= CANVAS_HEIGHT - CANVAS_PADDING; y += gridSize) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", CANVAS_PADDING);
         line.setAttribute("y1", y);
         line.setAttribute("x2", CANVAS_WIDTH - CANVAS_PADDING);
         line.setAttribute("y2", y);
         line.setAttribute("stroke", (y - CANVAS_PADDING) % (gridSize * 5) === 0 ? majorGridColor : gridColor);
         line.setAttribute("stroke-width", (y - CANVAS_PADDING) % (gridSize * 5) === 0 ? "2" : "1");
         gridGroup.appendChild(line);
        }
        svg.appendChild(gridGroup);
       }
       if (currentView.mode === "rack" && currentView.rackId) {
         const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
         const rackGroup = document.createElementNS(ns, "g");
         rackGroup.id = "rack-visualization";
         const rackFrame = document.createElementNS(ns, "rect");
         rackFrame.setAttribute("x", RACK_START_X - RACK_WIDTH / 2);
         rackFrame.setAttribute("y", RACK_START_Y);
         rackFrame.setAttribute("width", RACK_WIDTH);
         rackFrame.setAttribute("height", rackCapacity * rackUHeight);
         rackFrame.setAttribute("fill", (PAGE_STATE.rackFrameFill || "#0f172a") + "4D");
         rackFrame.setAttribute("stroke", PAGE_STATE.rackFrameStroke || "#4fd1c5");
         rackFrame.setAttribute("stroke-width", "3");
         rackFrame.setAttribute("rx", "4");
         rackGroup.appendChild(rackFrame);
         for (let u = 0; u <= rackCapacity; u++) {
          const y = RACK_START_Y + u * rackUHeight;
          const line = document.createElementNS(ns, "line");
          line.setAttribute("x1", RACK_START_X - RACK_WIDTH / 2);
          line.setAttribute("y1", y);
          line.setAttribute("x2", RACK_START_X + RACK_WIDTH / 2);
          line.setAttribute("y2", y);
          line.setAttribute("stroke", (PAGE_STATE.rackLineColor || "#475569") + "66");
          line.setAttribute("stroke-width", u % 5 === 0 ? "2" : "1");
          line.setAttribute("stroke-dasharray", u % 5 === 0 ? "none" : "5,5");
          rackGroup.appendChild(line);
          if (u < rackCapacity) {
           const uNumber = rackCapacity - u;
           const text = document.createElementNS(ns, "text");
           text.setAttribute("x", RACK_START_X - RACK_WIDTH / 2 - 30);
           text.setAttribute("y", y + rackUHeight / 2);
           text.setAttribute("text-anchor", "middle");
           text.setAttribute("dominant-baseline", "middle");
           text.style.fill = PAGE_STATE.rackTextColor || "#4fd1c5";
           text.style.fontSize = "14px";
           text.style.fontWeight = "bold";
           text.textContent = `U${uNumber}`;
           rackGroup.appendChild(text);
           const textRight = document.createElementNS(ns, "text");
           textRight.setAttribute("x", RACK_START_X + RACK_WIDTH / 2 + 30);
           textRight.setAttribute("y", y + rackUHeight / 2);
           textRight.setAttribute("text-anchor", "middle");
           textRight.setAttribute("dominant-baseline", "middle");
           textRight.style.fill = PAGE_STATE.rackTextColor || "#4fd1c5";
           textRight.style.fontSize = "14px";
           textRight.style.fontWeight = "bold";
           textRight.textContent = `U${uNumber}`;
           rackGroup.appendChild(textRight);
          }
         }
         svg.appendChild(rackGroup);
        }
        const centerX = CANVAS_WIDTH / 2;
        if (RECT_DATA && RECT_DATA.list) {
         RECT_DATA.list.forEach((rect) => {
          if (currentView.mode === "rack") return;
          if (rect.style === "filled") {
           const g = document.createElementNS(ns, "g");
           g.classList.add("rect-group");
           g.dataset.rectId = rect.id;
           const rectEl = document.createElementNS(ns, "rect");
           rectEl.classList.add("rect-shape");
           rectEl.setAttribute("x", rect.x);
           rectEl.setAttribute("y", rect.y);
           rectEl.setAttribute("width", rect.width);
           rectEl.setAttribute("height", rect.height);
           rectEl.style.fill = rect.color;
           rectEl.style.fillOpacity = "0.3";
           rectEl.style.stroke = rect.borderColor || rect.color;
           rectEl.style.strokeWidth = (rect.borderWidth !== undefined ? rect.borderWidth : 2) + "px";
           if (rect.lineStyle === "dashed") { rectEl.style.strokeDasharray = "10,5"; }
           else if (rect.lineStyle === "dotted") { rectEl.style.strokeDasharray = "2,4"; }
           else { rectEl.style.strokeDasharray = "none"; }
           rectEl.style.cursor = "move";
           rectEl.addEventListener("click", (e) => {
		   if (isViewOnly()) return;
             if (rectDrawMode) return;
             e.stopPropagation();
             currentRectId = rect.id;
             selectTheRect(rect.id);
           });
           rectEl.addEventListener("contextmenu", (e) => {
		    if (isViewOnly()) return;
             e.preventDefault();
             e.stopPropagation();
             if (selectedRects.has(rect.id)) {
               selectedRects.delete(rect.id);
             } else {
               selectedRects.add(rect.id);
             }
             updateAllSelections();
           });
           let rectLastTap = 0;
           rectEl.addEventListener("touchend", (e) => {
             const now = Date.now();
             if (now - rectLastTap < 300) {
               e.preventDefault();
               if (selectedRects.has(rect.id)) {
                 selectedRects.delete(rect.id);
               } else {
                 selectedRects.add(rect.id);
               }
               updateAllSelections();
               if (navigator.vibrate) navigator.vibrate(50);
               rectLastTap = 0;
             } else {
               rectLastTap = now;
             }
           }, { passive: false });
           const deleteBtn = document.createElementNS(ns, "g");
           deleteBtn.classList.add("rect-delete-btn");
           deleteBtn.style.cursor = "pointer";
           deleteBtn.style.display = rectDrawMode ? "block" : "none";
           const deleteBg = document.createElementNS(ns, "circle");
           deleteBg.setAttribute("cx", rect.x + rect.width - 10);
           deleteBg.setAttribute("cy", rect.y + 10);
           deleteBg.setAttribute("r", 12);
           deleteBg.style.fill = "#f56565";
           deleteBg.style.stroke = "white";
           deleteBg.style.strokeWidth = "2";
           const deleteX = document.createElementNS(ns, "text");
           deleteX.setAttribute("x", rect.x + rect.width - 10);
           deleteX.setAttribute("y", rect.y + 10);
           deleteX.setAttribute("text-anchor", "middle");
           deleteX.setAttribute("dominant-baseline", "middle");
           deleteX.style.fill = "white";
           deleteX.style.fontSize = "16px";
           deleteX.style.fontWeight = "bold";
           deleteX.style.pointerEvents = "none";
           deleteX.textContent = "√ó";
           deleteBtn.appendChild(deleteBg);
           deleteBtn.appendChild(deleteX);
           deleteBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            e.preventDefault();
            deleteRectangle(rect.id);
           });
           deleteBtn.addEventListener("touchend", (e) => {
      e.stopPropagation();
           e.preventDefault();
           deleteRectangle(rect.id);
           });
           let isDragging = false;
           let dragStartX, dragStartY;
           let rectStartX, rectStartY;
           rectEl.addEventListener("mousedown", (e) => {
		   if (isViewOnly()) return;
      if (rectDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      rectStartX = rect.x;
      rectStartY = rect.y;
      rectEl.style.cursor = "grabbing";
      if (selectedRects.has(rect.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
      const moveHandler = (e) => {
      if (!isDragging || rectDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      rect.x = rectStartX + dx;
      rect.y = rectStartY + dy;
      if (selectedRects.has(rect.id)) {
      selectedNodes.forEach(nodeId => { if (initialPositions[nodeId]) { savedPositions[nodeId] = { x: initialPositions[nodeId].x + dx, y: initialPositions[nodeId].y + dy }; } });
      selectedRects.forEach(rectId => { if (rectId === rect.id) return; const r = RECT_DATA.list.find(x => x.id === rectId); if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; } });
      selectedTexts.forEach(textId => { const t = TEXT_DATA.list.find(x => x.id === textId); if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; } });
      selectedEdges.forEach(edgeId => { const ed = EDGE_DATA.list.find(x => x.id === edgeId); if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); } });
      }
      forgeTheTopology();
      };
           const upHandler = () => {
            if (isDragging) {
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           };
           document.addEventListener("mousemove", moveHandler);
           document.addEventListener("mouseup", upHandler);
           let touchStartX, touchStartY;
           let touchRectStartX, touchRectStartY;
           rectEl.addEventListener("touchstart", (e) => {
		   if (isViewOnly()) return;
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchRectStartX = rect.x;
            touchRectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           }, { passive: false });
           rectEl.addEventListener("touchmove", (e) => {
		   if (isViewOnly()) return;
            if (!isDragging || rectDrawMode) return;
            if (!e.touches[0]) return;
            e.preventDefault();
            e.stopPropagation();
            const svgEl = svg;
            const pt1 = svgEl.createSVGPoint();
            pt1.x = touchStartX;
            pt1.y = touchStartY;
            const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
            const touch = e.touches[0];
            const pt2 = svgEl.createSVGPoint();
            pt2.x = touch.clientX;
            pt2.y = touch.clientY;
            const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
            const dx = svgP2.x - svgP1.x;
            const dy = svgP2.y - svgP1.y;
            rect.x = touchRectStartX + dx;
            rect.y = touchRectStartY + dy;
            forgeTheTopology();
           }, { passive: false });
           rectEl.addEventListener("touchend", (e) => {
            if (isDragging) {
             e.preventDefault();
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           }, { passive: false });
            if (currentRectId === rect.id) {
      const corners = [
      { cx: rect.x, cy: rect.y, cursor: 'nwse-resize', dx: -1, dy: -1 },
      { cx: rect.x + rect.width, cy: rect.y, cursor: 'nesw-resize', dx: 1, dy: -1 },
      { cx: rect.x, cy: rect.y + rect.height, cursor: 'nesw-resize', dx: -1, dy: 1 },
      { cx: rect.x + rect.width, cy: rect.y + rect.height, cursor: 'nwse-resize', dx: 1, dy: 1 }
      ];
      corners.forEach((corner, idx) => {
      const handle = document.createElementNS(ns, "circle");
      handle.setAttribute("cx", corner.cx);
      handle.setAttribute("cy", corner.cy);
      handle.setAttribute("r", 8);
      handle.style.fill = "#f59e0b";
      handle.style.stroke = "#fff";
      handle.style.strokeWidth = "2";
      handle.style.cursor = corner.cursor;
      handle.addEventListener("mousedown", (e) => {
	  if (isViewOnly()) return;
      e.preventDefault();
      e.stopPropagation();
	  pushUndo("resize zone");
      let dragging = true;
      const startX = e.clientX, startY = e.clientY;
      const origX = rect.x, origY = rect.y, origW = rect.width, origH = rect.height;
      const moveHandler = (ev) => {
        if (!dragging) return;
        const pt1 = svg.createSVGPoint(); pt1.x = startX; pt1.y = startY;
        const pt2 = svg.createSVGPoint(); pt2.x = ev.clientX; pt2.y = ev.clientY;
        const svgP1 = pt1.matrixTransform(svg.getScreenCTM().inverse());
        const svgP2 = pt2.matrixTransform(svg.getScreenCTM().inverse());
        const dx = svgP2.x - svgP1.x, dy = svgP2.y - svgP1.y;
        if (corner.dx < 0) { rect.x = origX + dx; rect.width = origW - dx; }
        else { rect.width = origW + dx; }
        if (corner.dy < 0) { rect.y = origY + dy; rect.height = origH - dy; }
        else { rect.height = origH + dy; }
        if (rect.width < 20) rect.width = 20;
        if (rect.height < 20) rect.height = 20;
        forgeTheTopology();
      };
      const upHandler = () => { dragging = false; document.removeEventListener("mousemove", moveHandler); document.removeEventListener("mouseup", upHandler); };
      document.addEventListener("mousemove", moveHandler);
      document.addEventListener("mouseup", upHandler);
      });
      g.appendChild(handle);
      });
      }
            if (rect.groupId) {
             const groupIndicator = document.createElementNS(ns, "rect");
             groupIndicator.setAttribute("x", rect.x - 4);
             groupIndicator.setAttribute("y", rect.y - 4);
             groupIndicator.setAttribute("width", rect.width + 8);
             groupIndicator.setAttribute("height", rect.height + 8);
             groupIndicator.style.fill = "none";
        groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
             groupIndicator.style.strokeWidth = "3";
             groupIndicator.style.strokeDasharray = "5,5";
             groupIndicator.style.pointerEvents = "none";
             g.insertBefore(groupIndicator, g.firstChild);
           }
           g.appendChild(rectEl);
           g.appendChild(deleteBtn);
           svg.appendChild(g);
          }
         });
        }
        const centerY = CANVAS_HEIGHT / 2;
        let positions = {};
        Object.keys(NODE_DATA).forEach((id) => {
         if (currentView.mode === "rack") {
          const node = NODE_DATA[id];
          if (!node || node.assignedRack !== currentView.rackId) {
           return;
          }
         }
         positions[id] = savedPositions[id] || {
          x: centerX,
          y: centerY
         };
        });
        if (Object.keys(savedPositions).length === 0) {
         const nodeIds = Object.keys(NODE_DATA).filter(id => {
          if (currentView.mode === "rack") {
           const node = NODE_DATA[id];
           return node && node.assignedRack === currentView.rackId;
          }
          return true;
         });
         const baseY = centerY - 300;
         if (nodeIds.length > 0) {
          positions[nodeIds[0]] = {
           x: centerX,
           y: baseY
          };
          const remaining = nodeIds.slice(1);
          const radius = 350;
          const startAngle = Math.PI * 0.3;
          const endAngle = Math.PI * 0.7;
          remaining.forEach((id, i) => {
           const angle = startAngle + (endAngle - startAngle) * (i / Math.max(1, remaining.length - 1));
           positions[id] = {
            x: centerX + Math.cos(angle) * radius * (i % 2 === 0 ? 1 : 1.3),
            y: baseY + 200 + Math.sin(angle) * radius * 0.8 + i * 80,
           };
          });
         }
        }
        Object.keys(positions).forEach((id) => {
         let pos = savedPositions[id] || positions[id];
         const nodeSize = savedSizes[id] || 55;
         pos.x = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, pos.x), );
         pos.y = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, pos.y), );
         positions[id] = {
          x: pos.x,
          y: pos.y
         };
         savedPositions[id] = {
          x: pos.x,
          y: pos.y
         };
        });
        const edgePairCount = {};
        const edgePairIndex = {};
        EDGE_DATA.list.forEach((edge) => {
         if (edge.type === "custom") return;
         const key = [edge.from, edge.to].sort().join("||");
         edgePairCount[key] = (edgePairCount[key] || 0) + 1;
        });
        EDGE_DATA.list.forEach((edge) => {
         if (edge.type === "custom") return;
         const key = [edge.from, edge.to].sort().join("||");
         if (!edgePairIndex[key]) edgePairIndex[key] = 0;
         edge._pairIndex = edgePairIndex[key];
         edge._pairTotal = edgePairCount[key];
         edgePairIndex[key]++;
        });
        EDGE_DATA.list.forEach((edge) => {
         if (edge.type === "custom" && Array.isArray(edge.points) && edge.points.length >= 2) {
          const customEdgeFaded = currentView.mode !== "rack" && edge.from && edge.to && (!isNodeVisible(edge.from) || !isNodeVisible(edge.to));
          const poly = document.createElementNS(ns, "polyline");
          poly.classList.add("edge");
          if (customEdgeFaded) {
           poly.style.opacity = "0.25";
           poly.classList.add("layer-faded");
          }
          poly.dataset.edgeId = edge.id;
poly.style.stroke = edge.color || PAGE_STATE.defaultEdge || "#475569";
          poly.style.strokeWidth = edge.width || 4;
          poly.setAttribute("fill", "none");
          const lineStyle = edge.lineStyle || "solid";
          if (lineStyle === "dashed") {
           poly.style.strokeDasharray = "10,5";
          } else if (lineStyle === "dotted") {
           poly.style.strokeDasharray = "2,4";
          } else {
           poly.style.strokeDasharray = "none";
          }
          const direction = edge.direction || "none";
          if (direction === "forward") {
           poly.setAttribute("marker-end", "url(#arrow-forward)");
          } else if (direction === "backward") {
           poly.setAttribute("marker-start", "url(#arrow-backward)");
          } else if (direction === "both") {
           poly.setAttribute("marker-start", "url(#arrow-backward)");
           poly.setAttribute("marker-end", "url(#arrow-forward)");
          }
          const ptsStr = edge.points.map((p) => `${p.x},${p.y}`).join(" ");
          poly.setAttribute("points", ptsStr);
          const polyHit = document.createElementNS(ns, "polyline");
          polyHit.setAttribute("points", ptsStr);
          polyHit.style.fill = "none";
          polyHit.style.stroke = "transparent";
          polyHit.style.strokeWidth = "20";
          polyHit.style.cursor = "pointer";
          polyHit.dataset.edgeId = edge.id;
          polyHit.addEventListener("click", (e) => {
           e.stopPropagation();
           selectTheConnection(edge.id);
          });
          let edgeTouchStart = null;
          let edgeTouchMoved = false;
          polyHit.addEventListener("touchstart", (e) => {
          edgeTouchStart = Date.now();
          edgeTouchMoved = false;
          if (e.touches[0]) {
           edgeTouchStartX = e.touches[0].clientX;
           edgeTouchStartY = e.touches[0].clientY;
          }
         }, {
           passive: false
          });
          let edgeTouchStartX = 0, edgeTouchStartY = 0;
         polyHit.addEventListener("touchmove", (e) => {
          if (e.touches[0]) {
           const dx = Math.abs(e.touches[0].clientX - edgeTouchStartX);
           const dy = Math.abs(e.touches[0].clientY - edgeTouchStartY);
           if (dx > 10 || dy > 10) edgeTouchMoved = true;
          }
         }, {
           passive: false
          });
          polyHit.addEventListener("touchend", (e) => {
           if (edgeTouchStart && !edgeTouchMoved && Date.now() - edgeTouchStart < 400) {
            e.stopPropagation();
            e.preventDefault();
            selectTheConnection(edge.id);
           }
           edgeTouchStart = null;
           edgeTouchMoved = false;
          }, {
           passive: false
          });
          poly.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         polyHit.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (selectedEdges.has(edge.id)) {
           selectedEdges.delete(edge.id);
          } else {
           selectedEdges.add(edge.id);
          }
          updateAllSelections();
         });
         let customEdgeLastTap = 0;
         polyHit.addEventListener("touchend", (e) => {
          const now = Date.now();
          if (now - customEdgeLastTap < 300) {
           e.preventDefault();
           if (selectedEdges.has(edge.id)) {
            selectedEdges.delete(edge.id);
           } else {
            selectedEdges.add(edge.id);
           }
           updateAllSelections();
           if (navigator.vibrate) navigator.vibrate(50);
           customEdgeLastTap = 0;
          } else {
           customEdgeLastTap = now;
          }
         }, { passive: false });
         poly.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (selectedEdges.has(edge.id)) {
           selectedEdges.delete(edge.id);
          } else {
           selectedEdges.add(edge.id);
          }
          updateAllSelections();
         });
         let edgeLastTap = 0;
         poly.addEventListener("touchend", (e) => {
          const now = Date.now();
          if (now - edgeLastTap < 300) {
           e.preventDefault();
           if (selectedEdges.has(edge.id)) {
            selectedEdges.delete(edge.id);
           } else {
            selectedEdges.add(edge.id);
           }
           updateAllSelections();
           if (navigator.vibrate) navigator.vibrate(50);
           edgeLastTap = 0;
          } else {
           edgeLastTap = now;
          }
         });
          if (currentView.mode === "rack") {
           return;
          }
          if (edge.groupId) {
      const bounds = edge.points.reduce((acc, p) => ({ minX: Math.min(acc.minX, p.x), minY: Math.min(acc.minY, p.y), maxX: Math.max(acc.maxX, p.x), maxY: Math.max(acc.maxY, p.y) }), { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity });
      const groupIndicator = document.createElementNS(ns, "rect");
      groupIndicator.setAttribute("x", bounds.minX - 8);
      groupIndicator.setAttribute("y", bounds.minY - 8);
      groupIndicator.setAttribute("width", bounds.maxX - bounds.minX + 16);
      groupIndicator.setAttribute("height", bounds.maxY - bounds.minY + 16);
      groupIndicator.setAttribute("rx", "4");
      groupIndicator.style.fill = "none";
  groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
      groupIndicator.style.strokeWidth = "3";
      groupIndicator.style.strokeDasharray = "5,5";
      groupIndicator.style.pointerEvents = "none";
      svg.appendChild(groupIndicator);
      }
         let lineDragging = false;
      let lineDragStartX, lineDragStartY;
      let linePointsStart = [];
      polyHit.addEventListener("mousedown", (e) => {
	  if (isViewOnly()) return;
      if (freeDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      lineDragging = true;
      lineDragStartX = e.clientX;
      lineDragStartY = e.clientY;
      linePointsStart = edge.points.map(p => ({x: p.x, y: p.y}));
      if (selectedEdges.has(edge.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
      const lineMoveHandler = (e) => {
      if (!lineDragging || freeDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = lineDragStartX;
      pt1.y = lineDragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      edge.points.forEach((p, i) => { p.x = linePointsStart[i].x + dx; p.y = linePointsStart[i].y + dy; });
      if (selectedEdges.has(edge.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       savedPositions[nodeId] = { x: initialPositions[nodeId].x + dx, y: initialPositions[nodeId].y + dy };
      }
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      if (edgeId === edge.id) return;
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      forgeTheTopology();
      };
      const lineUpHandler = () => { lineDragging = false; };
      document.addEventListener("mousemove", lineMoveHandler);
      document.addEventListener("mouseup", lineUpHandler);
      svg.appendChild(poly);
      svg.appendChild(polyHit);
         if (currentEdgeId === edge.id) {
          edge.points.forEach((p, idx) => {
           const c = document.createElementNS(ns, "circle");
           c.classList.add("edge-edit-point");
           c.setAttribute("cx", p.x);
           c.setAttribute("cy", p.y);
		   c.setAttribute("r", PAGE_STATE.selectionHandleSize || 8);
           c.style.fill = PAGE_STATE.selectionHandle || "#f59e0b";
           c.style.stroke = "#fff";
           c.style.strokeWidth = "2";
           c.style.cursor = "move";
           c.dataset.edgeId = edge.id;
           c.dataset.pointIndex = String(idx);
           c.addEventListener("mousedown", (e) => {
		   if (isViewOnly()) return;
            e.preventDefault();
            e.stopPropagation();
            pushUndo("edit edge point");
            let dragging = true;
            const svgEl = svg;
            const moveHandler = (ev) => {
             if (!dragging) return;
             const pt = svgEl.createSVGPoint();
             pt.x = ev.clientX;
             pt.y = ev.clientY;
             const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
             edge.points[idx].x = svgP.x;
             edge.points[idx].y = svgP.y;
             forgeTheTopology();
            };
            const upHandler = () => {
             dragging = false;
             document.removeEventListener("mousemove", moveHandler);
             document.removeEventListener("mouseup", upHandler);
            };
            document.addEventListener("mousemove", moveHandler);
            document.addEventListener("mouseup", upHandler);
           });
           c.addEventListener("touchstart", (e) => {
		   if (isViewOnly()) return;
            e.preventDefault();
            e.stopPropagation();
            pushUndo("edit edge point");
            let dragging = true;
            const svgEl = svg;
            const touchMoveHandler = (ev) => {
             if (!dragging || !ev.touches[0]) return;
             const pt = svgEl.createSVGPoint();
             pt.x = ev.touches[0].clientX;
             pt.y = ev.touches[0].clientY;
             const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
             edge.points[idx].x = svgP.x;
             edge.points[idx].y = svgP.y;
             forgeTheTopology();
            };
            const touchUpHandler = () => {
             dragging = false;
             document.removeEventListener("touchmove", touchMoveHandler);
             document.removeEventListener("touchend", touchUpHandler);
            };
            document.addEventListener("touchmove", touchMoveHandler);
            document.addEventListener("touchend", touchUpHandler);
           }, { passive: false });
           svg.appendChild(c);
          });
         }
         return;
         }
         const p1 = positions[edge.from];
         const p2 = positions[edge.to];
         if (!p1 || !p2) return;
         const edgeFaded = currentView.mode !== "rack" && (!isNodeVisible(edge.from) || !isNodeVisible(edge.to));
         const pairTotal = edge._pairTotal || 1;
         const pairIndex = edge._pairIndex || 0;
         const midX = (p1.x + p2.x) / 2;
         const midY = (p1.y + p2.y) / 2;
         const dx = p2.x - p1.x;
         const dy = p2.y - p1.y;
         const len = Math.sqrt(dx * dx + dy * dy) || 1;
         const perpX = -dy / len;
         const perpY = dx / len;
         let offsetAmount = 0;
         if (pairTotal > 1) {
          offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
         }
         const ctrlX = midX + perpX * offsetAmount;
         const ctrlY = midY + perpY * offsetAmount;
         const path = document.createElementNS(ns, "path");
         path.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
         path.setAttribute("fill", "none");
         path.classList.add("edge");
         if (edgeFaded) {
          path.style.opacity = "0.25";
          path.classList.add("layer-faded");
         }
         if (edge.type === "backup") path.classList.add("backup");
         path.dataset.edgeId = edge.id;
         path.dataset.from = edge.from;
         path.dataset.to = edge.to;
         path.style.stroke = edge.color;
         path.style.strokeWidth = edge.width;
         const pathHit = document.createElementNS(ns, "path");
         pathHit.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
         pathHit.setAttribute("fill", "none");
         pathHit.style.stroke = "transparent";
         pathHit.style.strokeWidth = "20";
         pathHit.style.cursor = "pointer";
         pathHit.dataset.edgeId = edge.id;
         pathHit.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         let pathTouchStart = null;
         let pathTouchMoved = false;
         pathHit.addEventListener("touchstart", (e) => {
         pathTouchStart = Date.now();
         pathTouchMoved = false;
         if (e.touches[0]) {
          pathTouchStartX = e.touches[0].clientX;
          pathTouchStartY = e.touches[0].clientY;
         }
        }, {
          passive: false
         });
         let pathTouchStartX = 0, pathTouchStartY = 0;
        pathHit.addEventListener("touchmove", (e) => {
         if (e.touches[0]) {
          const dx = Math.abs(e.touches[0].clientX - pathTouchStartX);
          const dy = Math.abs(e.touches[0].clientY - pathTouchStartY);
          if (dx > 10 || dy > 10) pathTouchMoved = true;
         }
        }, {
          passive: false
         });
         pathHit.addEventListener("touchend", (e) => {
          if (pathTouchStart && !pathTouchMoved && Date.now() - pathTouchStart < 400) {
           e.stopPropagation();
           e.preventDefault();
           selectTheConnection(edge.id);
          }
          pathTouchStart = null;
          pathTouchMoved = false;
         }, {
          passive: false
         });
         path.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         if (currentView.mode === "rack") {
          const fromNode = NODE_DATA[edge.from];
          const toNode = NODE_DATA[edge.to];
          if (!fromNode || !toNode ||
              fromNode.assignedRack !== currentView.rackId ||
              toNode.assignedRack !== currentView.rackId) {
           return;
          }
         }
         svg.appendChild(path);
         svg.appendChild(pathHit);
         if (edge.fromPort || edge.toPort) {
          const ns = "http://www.w3.org/2000/svg";
          if (edge.fromPort) {
           const fromLabel = document.createElementNS(ns, "text");
           fromLabel.textContent = edge.fromPort;
           fromLabel.setAttribute("x", p1.x);
           fromLabel.setAttribute("y", p1.y - 10);
           fromLabel.setAttribute("text-anchor", "middle");
           fromLabel.style.fill = "#94a3b8";
           fromLabel.style.fontSize = "12px";
           fromLabel.style.fontWeight = "600";
           fromLabel.style.pointerEvents = "none";
           fromLabel.classList.add("port-label");
           svg.appendChild(fromLabel);
          }
          if (edge.toPort) {
           const toLabel = document.createElementNS(ns, "text");
           toLabel.textContent = edge.toPort;
           toLabel.setAttribute("x", p2.x);
           toLabel.setAttribute("y", p2.y - 10);
           toLabel.setAttribute("text-anchor", "middle");
           toLabel.style.fill = "#94a3b8";
           toLabel.style.fontSize = "12px";
           toLabel.style.fontWeight = "600";
           toLabel.style.pointerEvents = "none";
           toLabel.classList.add("port-label");
           svg.appendChild(toLabel);
          }
         }
        });
        Object.entries(positions).forEach(([id, pos]) => {
         const node = NODE_DATA[id];
         if (!node) return;
         if (currentView.mode === "rack") {
          if (node.assignedRack !== currentView.rackId) return;
         const rackUnit = parseInt(node.rackUnit) || 1;
      const uHeight = parseInt(node.uHeight) || 1;
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      pos.x = RACK_START_X;
      pos.y = RACK_START_Y + (rackCapacity - rackUnit - uHeight + 1) * rackUHeight + (uHeight * rackUHeight) / 2;
         } else {
          if (node.assignedRack) return;
         }
         const g = document.createElementNS("http://www.w3.org/2000/svg", "g", );
         g.classList.add("node-group");
         g.dataset.nodeId = id;
         g.setAttribute("transform", `translate(${pos.x},${pos.y})`);
         if (currentView.mode !== "rack" && !isNodeVisible(id)) {
          g.style.opacity = "0.25";
          g.classList.add("layer-faded");
         }
         let r = savedSizes[id] || 55;
		if (!savedSizes[id]) {
		 if (window.innerWidth <= 480) r = 45;
		 else if (window.innerWidth <= 768) r = 50;
		}
         const styles = resolveStylesForNode(id);
         const ns = "http://www.w3.org/2000/svg";
         const hitArea = document.createElementNS(ns, "circle");
         hitArea.setAttribute("r", r * 1.5);
         hitArea.style.fill = "transparent";
         hitArea.style.stroke = "none";
         hitArea.style.cursor = "grab";
         hitArea.classList.add("node-hit-area");
         const shapeEl = createNodeShape(id, r);
         const titleOffsetX = styles.titleOffsetX || 0;
         const titleOffsetY = styles.titleOffsetY || 0;
         const subOffsetX = styles.subOffsetX || 0;
         const subOffsetY = styles.subOffsetY || 0;
         const label = document.createElementNS("http://www.w3.org/2000/svg", "text", );
         label.classList.add("node-label");
         label.setAttribute("x", titleOffsetX);
         label.setAttribute("y", -r * 0.28 + titleOffsetY);
         const labelFontSize = styles.titleSize || PAGE_STATE.nodeTitleSize || r * 0.33;
        label.style.fontSize = labelFontSize + "px";
         label.textContent = NODE_DATA[id].name;
		label.style.fill = styles.titleColor || PAGE_STATE.nodeTitle || "#e2e8f0";
        label.style.fontFamily = styles.titleFont || PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
         label.style.pointerEvents = "none";
         const sub = document.createElementNS("http://www.w3.org/2000/svg", "text", );
         sub.classList.add("node-sub");
         sub.setAttribute("x", subOffsetX);
         sub.setAttribute("y", r * 0.4 + subOffsetY);
         const subFontSize = styles.subSize || PAGE_STATE.nodeSubSize || r * 0.24;
        sub.style.fontSize = subFontSize + "px";
         sub.textContent = NODE_DATA[id].ip;
		sub.style.fill = styles.subColor || PAGE_STATE.nodeSub || "#94a3b8";
        sub.style.fontFamily = styles.subFont || PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
         sub.style.pointerEvents = "none";
         g.append(hitArea, shapeEl, label, sub);
         if (NODE_DATA[id]?.locked) {
           const lockIndicator = document.createElementNS(ns, "text");
           lockIndicator.textContent = "üîí";
           lockIndicator.setAttribute("x", r * 0.7);
           lockIndicator.setAttribute("y", -r * 0.7);
           lockIndicator.style.fontSize = (r * 0.3) + "px";
           lockIndicator.style.pointerEvents = "none";
           lockIndicator.classList.add("lock-indicator");
           g.appendChild(lockIndicator);
         }
         if (NODE_DATA[id]?.groupId) {
           const groupIndicator = document.createElementNS(ns, "circle");
           groupIndicator.setAttribute("r", r + 4);
           groupIndicator.style.fill = "none";
         groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
           groupIndicator.style.strokeWidth = "3";
           groupIndicator.style.strokeDasharray = "5,5";
           groupIndicator.style.pointerEvents = "none";
           groupIndicator.classList.add("group-indicator");
           g.insertBefore(groupIndicator, g.firstChild);
         }
         let isDragging = false;
         let startX, startY;
         let initialPositions = {};
         let longPressTimer = null;
         let longPressTriggered = false;
         g.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (isViewOnly()) return;
          if (selectedNodes.has(id)) {
           selectedNodes.delete(id);
          } else {
           selectedNodes.add(id);
          }
          updateNodeSelection();
          return false;
         });
        g.addEventListener("touchstart", (e) => {
         if (NODE_DATA[id].isRack) {
          const touch = e.touches[0];
          longPressStartX = touch.clientX;
          longPressStartY = touch.clientY;
          longPressTimer = setTimeout(() => {
           longPressTriggered = true;
           if (navigator.vibrate) {
            navigator.vibrate(100);
           }
           enterRack(id);
          }, 500);
         }
        }, { passive: true });
        g.addEventListener("dblclick", (e) => {
         e.preventDefault();
         e.stopPropagation();
         if (NODE_DATA[id].isRack) {
          enterRack(id);
         }
        });
        let lastTapTime = 0;
        let lastTapNode = null;
        g.addEventListener("touchend", (e) => {
         const currentTime = new Date().getTime();
         const tapLength = currentTime - lastTapTime;
         if (tapLength < 300 && tapLength > 0 && lastTapNode === id) {
          e.preventDefault();
          e.stopPropagation();
          if (isViewOnly()) return;
          if (selectedNodes.has(id)) {
           selectedNodes.delete(id);
          } else {
           selectedNodes.add(id);
          }
          updateNodeSelection();
          if (navigator.vibrate) {
           navigator.vibrate(50);
          }
          lastTapTime = 0;
          lastTapNode = null;
         } else {
          lastTapTime = currentTime;
          lastTapNode = id;
         }
        });
         g.addEventListener("touchend", (e) => {
          if (longPressTimer) {
           clearTimeout(longPressTimer);
           longPressTimer = null;
          }
          if (longPressTriggered) {
           e.preventDefault();
           e.stopPropagation();
           longPressTriggered = false;
          }
         });
         let longPressStartX = 0;
        let longPressStartY = 0;
        g.addEventListener("touchmove", (e) => {
         if (longPressTimer) {
          const touch = e.touches[0];
          const dx = Math.abs(touch.clientX - longPressStartX);
          const dy = Math.abs(touch.clientY - longPressStartY);
          if (dx > 15 || dy > 15) {
           clearTimeout(longPressTimer);
           longPressTimer = null;
           longPressTriggered = false;
          }
         }
        }, { passive: true });
         g.addEventListener("mousedown", (e) => {
          if (isViewOnly()) return;
          if (e.button === 2) {
           return;
          }
          if (NODE_DATA[id]?.locked) {
           return;
          }
          e.preventDefault();
          isDragging = true;
		  pushUndo("move nodes");
          const svgEl = document.getElementById("map");
          const pt = svgEl.createSVGPoint();
          pt.x = e.clientX;
          pt.y = e.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          startX = svgP.x;
          startY = svgP.y;
          let nodesToCollect = [];
      if (selectedNodes.has(id)) {
      initialPositions = {};
      const allSelectedRects = Array.from(selectedRects);
      const allSelectedTexts = Array.from(selectedTexts);
      const allSelectedEdges = Array.from(selectedEdges).map(eid => EDGE_DATA.list.find(e => e.id === eid)).filter(Boolean);
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) {
      initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      }
      });
      Array.from(selectedRects).forEach(rectId => {
        const rect = RECT_DATA.list.find(r => r.id === rectId);
        if (rect) { rect._dragStartX = rect.x; rect._dragStartY = rect.y; }
      });
      Array.from(selectedTexts).forEach(textId => {
        const text = TEXT_DATA.list.find(t => t.id === textId);
        if (text) { text._dragStartX = text.x; text._dragStartY = text.y; }
      });
      Array.from(selectedEdges).forEach(edgeId => {
        const edge = EDGE_DATA.list.find(e => e.id === edgeId);
        if (edge && edge.points) { edge._dragStartPoints = edge.points.map(p => ({x: p.x, y: p.y})); }
      });
      } else {
      initialPositions = { [id]: { x: pos.x, y: pos.y } };
      }
          const groupIds = new Set();
          nodesToCollect.forEach(nodeId => {
           const groupId = NODE_DATA[nodeId]?.groupId;
           if (groupId) {
             groupIds.add(groupId);
           }
          });
          if (groupIds.size > 0) {
           Object.keys(NODE_DATA).forEach(nodeId => {
             const nodeGroupId = NODE_DATA[nodeId]?.groupId;
             if (nodeGroupId && groupIds.has(nodeGroupId)) {
               if (!nodesToCollect.includes(nodeId)) {
                 nodesToCollect.push(nodeId);
               }
             }
           });
          }
          nodesToCollect = nodesToCollect.filter(nodeId => !NODE_DATA[nodeId]?.locked);
          if (nodesToCollect.length === 0) {
           return;
          }
          initialPositions = {};
          nodesToCollect.forEach(nodeId => {
           const nodePos = savedPositions[nodeId];
           if (nodePos) {
            initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
           }
          });
          g.style.cursor = "grabbing";
          hitArea.style.cursor = "grabbing";
          e.stopPropagation();
         });
         const handleMouseMove = (e) => {
          if (!isDragging) return;
          e.preventDefault();
          const svgEl = document.getElementById("map");
          const pt = svgEl.createSVGPoint();
          pt.x = e.clientX;
          pt.y = e.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          const dx = svgP.x - startX;
          const dy = svgP.y - startY;
          const nodesToMove = selectedNodes.has(id) ? Array.from(selectedNodes) : [id];
          nodesToMove.forEach(nodeId => {
           if (!initialPositions[nodeId]) return;
           const initialPos = initialPositions[nodeId];
           let newX = initialPos.x + dx;
           let newY = initialPos.y + dy;
           const nodeSize = savedSizes[nodeId] || 55;
           newX = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, newX), );
           newY = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, newY), );
           savedPositions[nodeId] = { x: newX, y: newY };
           positions[nodeId] = { x: newX, y: newY };
           if (nodeId === id) {
            pos.x = newX;
            pos.y = newY;
           }
           const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
          if (nodeGroup) {
           nodeGroup.setAttribute("transform", `translate(${newX},${newY})`);
          }
         });
         Array.from(selectedRects).forEach(rectId => {
           const rect = RECT_DATA.list.find(r => r.id === rectId);
           if (rect && rect._dragStartX !== undefined) {
             rect.x = rect._dragStartX + dx;
             rect.y = rect._dragStartY + dy;
           }
         });
         Array.from(selectedTexts).forEach(textId => {
           const text = TEXT_DATA.list.find(t => t.id === textId);
           if (text && text._dragStartX !== undefined) {
             text.x = text._dragStartX + dx;
             text.y = text._dragStartY + dy;
           }
         });
         Array.from(selectedEdges).forEach(edgeId => {
           const edge = EDGE_DATA.list.find(e => e.id === edgeId);
           if (edge && edge._dragStartPoints) {
             edge.points.forEach((p, i) => {
               p.x = edge._dragStartPoints[i].x + dx;
               p.y = edge._dragStartPoints[i].y + dy;
             });
           }
         });
         forgeTheTopology();
         updateMinimap();
          document.querySelectorAll(".edge").forEach((edgeEl) => {
           const fromId = edgeEl.dataset.from;
           const toId = edgeEl.dataset.to;
           if (nodesToMove.includes(fromId) || nodesToMove.includes(toId)) {
            const p1 = savedPositions[fromId] || positions[fromId] || {
             x: 600,
             y: 350
            };
            const p2 = savedPositions[toId] || positions[toId] || {
             x: 600,
             y: 350
            };
            if (edgeEl.tagName === "line") {
             edgeEl.setAttribute("x1", p1.x);
             edgeEl.setAttribute("y1", p1.y);
             edgeEl.setAttribute("x2", p2.x);
             edgeEl.setAttribute("y2", p2.y);
            } else if (edgeEl.tagName === "path") {
             const edgeId = edgeEl.dataset.edgeId;
             const edge = EDGE_DATA.list.find(
              (e) => e.id === edgeId, );
             if (edge) {
              const pairTotal = edge._pairTotal || 1;
              const pairIndex = edge._pairIndex || 0;
              const midX = (p1.x + p2.x) / 2;
              const midY = (p1.y + p2.y) / 2;
              const dx = p2.x - p1.x;
              const dy = p2.y - p1.y;
              const len = Math.sqrt(dx * dx + dy * dy) || 1;
              const perpX = -dy / len;
              const perpY = dx / len;
              let offsetAmount = 0;
              if (pairTotal > 1) {
               offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
              }
              const ctrlX = midX + perpX * offsetAmount;
              const ctrlY = midY + perpY * offsetAmount;
              edgeEl.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
             }
            }
           }
          });
         };
      const handleMouseUp = () => {
      if (isDragging) {
      isDragging = false;
      g.style.cursor = "grab";
      hitArea.style.cursor = "grab";
      if (currentView.mode === "rack" && NODE_DATA[id]?.assignedRack === currentView.rackId) {
      const draggedY = savedPositions[id]?.y || pos.y;
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      let newUnit = rackCapacity - Math.round((draggedY - RACK_START_Y) / rackUHeight);
      newUnit = Math.max(1, Math.min(newUnit, rackCapacity));
      NODE_DATA[id].rackUnit = newUnit;
      forgeTheTopology();
      claimTheImmortal(id);
      }
      }
      };
         document.addEventListener("mousemove", handleMouseMove);
         document.addEventListener("mouseup", handleMouseUp);
         let touchStartTime = 0;
         let touchStartX = 0;
         let touchStartY = 0;
         let touchMoved = false;
       g.addEventListener("touchstart",
         (e) => {
          if (NODE_DATA[id]?.locked) {
           return;
          }
          e.preventDefault();
          touchStartTime = Date.now();
          touchMoved = false;
          const svgEl = document.getElementById("map");
          const pt = svgEl.createSVGPoint();
          const touch = e.touches[0];
          pt.x = touch.clientX;
          pt.y = touch.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          touchStartX = svgP.x;
          touchStartY = svgP.y;
          startX = svgP.x;
          startY = svgP.y;
          let nodesToCollect = [];
          if (selectedNodes.has(id)) {
           nodesToCollect = Array.from(selectedNodes);
          } else {
           nodesToCollect = [id];
          }
          const groupIds = new Set();
          nodesToCollect.forEach(nodeId => {
           const groupId = NODE_DATA[nodeId]?.groupId;
           if (groupId) {
             groupIds.add(groupId);
           }
          });
          if (groupIds.size > 0) {
           Object.keys(NODE_DATA).forEach(nodeId => {
             const nodeGroupId = NODE_DATA[nodeId]?.groupId;
             if (nodeGroupId && groupIds.has(nodeGroupId)) {
               if (!nodesToCollect.includes(nodeId)) {
                 nodesToCollect.push(nodeId);
               }
             }
           });
          }
          nodesToCollect = nodesToCollect.filter(nodeId => !NODE_DATA[nodeId]?.locked);
          if (nodesToCollect.length === 0) {
           return;
          }
          initialPositions = {};
          nodesToCollect.forEach(nodeId => {
           const nodePos = savedPositions[nodeId];
           if (nodePos) {
            initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
           }
          });
          e.stopPropagation();
         }, {
          passive: false
         }, );
         g.addEventListener("touchmove", (e) => {
		  if (isViewOnly()) return;
         e.preventDefault();
         const svgEl = document.getElementById("map");
         const pt = svgEl.createSVGPoint();
         const touch = e.touches[0];
         pt.x = touch.clientX;
         pt.y = touch.clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
         const dx = Math.abs(svgP.x - touchStartX);
         const dy = Math.abs(svgP.y - touchStartY);
         if (dx > (isMobileDevice() ? 4 : 10) || dy > (isMobileDevice() ? 4 : 10)) {
      touchMoved = true;
      isDragging = true;
      }
         if (!isDragging) return;
         const deltaX = svgP.x - startX;
         const deltaY = svgP.y - startY;
         const nodesToMove = selectedNodes.has(id) ? Array.from(selectedNodes) : [id];
         nodesToMove.forEach(nodeId => {
          if (!initialPositions[nodeId]) return;
          const initialPos = initialPositions[nodeId];
          let newX = initialPos.x + deltaX;
          let newY = initialPos.y + deltaY;
          const nodeSize = savedSizes[nodeId] || 55;
          newX = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, newX), );
          newY = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, newY), );
          savedPositions[nodeId] = { x: newX, y: newY };
          positions[nodeId] = { x: newX, y: newY };
          if (nodeId === id) {
           pos.x = newX;
           pos.y = newY;
          }
          const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
          if (nodeGroup) {
           nodeGroup.setAttribute("transform", `translate(${newX},${newY})`);
          }
         });
         updateMinimap();
         document.querySelectorAll(".edge").forEach((edgeEl) => {
          const fromId = edgeEl.dataset.from;
          const toId = edgeEl.dataset.to;
          if (nodesToMove.includes(fromId) || nodesToMove.includes(toId)) {
            const p1 = savedPositions[fromId] || positions[fromId] || {
             x: 600,
             y: 350
            };
            const p2 = savedPositions[toId] || positions[toId] || {
             x: 600,
             y: 350
            };
            if (edgeEl.tagName === "line") {
             edgeEl.setAttribute("x1", p1.x);
             edgeEl.setAttribute("y1", p1.y);
             edgeEl.setAttribute("x2", p2.x);
             edgeEl.setAttribute("y2", p2.y);
            } else if (edgeEl.tagName === "path") {
             const edgeId = edgeEl.dataset.edgeId;
             const edge = EDGE_DATA.list.find(
              (e) => e.id === edgeId, );
             if (edge) {
              const pairTotal = edge._pairTotal || 1;
              const pairIndex = edge._pairIndex || 0;
              const midX = (p1.x + p2.x) / 2;
              const midY = (p1.y + p2.y) / 2;
              const dx = p2.x - p1.x;
              const dy = p2.y - p1.y;
              const len = Math.sqrt(dx * dx + dy * dy) || 1;
              const perpX = -dy / len;
              const perpY = dx / len;
              let offsetAmount = 0;
              if (pairTotal > 1) {
               offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
              }
              const ctrlX = midX + perpX * offsetAmount;
              const ctrlY = midY + perpY * offsetAmount;
              edgeEl.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
             }
            }
           }
          });
         }, {
          passive: false
         });
      g.addEventListener("touchend", (e) => {
      const touchDuration = Date.now() - touchStartTime;
      if (!touchMoved && touchDuration < 400) {
       if (isViewOnly()) {
        handleViewOnlyClick(id, 'node');
        return;
       }
       claimTheImmortal(id);
      }
      if (isDragging) {
      const draggedY = pos.y;
      isDragging = false;
      savedPositions[id] = {
      x: pos.x,
      y: pos.y
      };
      if (currentView.mode === "rack" && NODE_DATA[id]?.assignedRack === currentView.rackId) {
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      let newUnit = rackCapacity - Math.round((draggedY - RACK_START_Y) / rackUHeight);
      newUnit = Math.max(1, Math.min(newUnit, rackCapacity));
      NODE_DATA[id].rackUnit = newUnit;
      forgeTheTopology();
      claimTheImmortal(id);
      }
      }
      touchMoved = false;
      });
         g.style.cursor = "grab";
         g.addEventListener("click", (e) => {
          if (!isDragging) {
           if (isViewOnly()) {
            handleViewOnlyClick(id, 'node');
            return;
           }
           claimTheImmortal(id);
          }
         });
         svg.appendChild(g);
        });
        if (RECT_DATA && RECT_DATA.list) {
         RECT_DATA.list.forEach((rect) => {
          if (currentView.mode === "rack") return;
          if (rect.style === "outlined") {
           const g = document.createElementNS(ns, "g");
           g.classList.add("rect-group");
           g.dataset.rectId = rect.id;
           const rectEl = document.createElementNS(ns, "rect");
           rectEl.classList.add("rect-shape");
           rectEl.setAttribute("x", rect.x);
           rectEl.setAttribute("y", rect.y);
           rectEl.setAttribute("width", rect.width);
           rectEl.setAttribute("height", rect.height);
           rectEl.style.fill = "none";
           rectEl.style.stroke = rect.borderColor || rect.color;
           rectEl.style.strokeWidth = (rect.borderWidth !== undefined ? rect.borderWidth : 3) + "px";
      if (rect.lineStyle === "dashed") { rectEl.style.strokeDasharray = "10,5"; }
           else if (rect.lineStyle === "dotted") { rectEl.style.strokeDasharray = "2,4"; }
           else { rectEl.style.strokeDasharray = "none"; }
           rectEl.style.cursor = "move";
           rectEl.addEventListener("click", (e) => {
             if (rectDrawMode) return;
             e.stopPropagation();
             currentRectId = rect.id;
             selectTheRect(rect.id);
           });
           rectEl.addEventListener("contextmenu", (e) => {
             e.preventDefault();
             e.stopPropagation();
             if (selectedRects.has(rect.id)) {
               selectedRects.delete(rect.id);
             } else {
               selectedRects.add(rect.id);
             }
             updateAllSelections();
           });
           let rectLastTap = 0;
           rectEl.addEventListener("touchend", (e) => {
             const now = Date.now();
             if (now - rectLastTap < 300) {
               e.preventDefault();
               if (selectedRects.has(rect.id)) {
                 selectedRects.delete(rect.id);
               } else {
                 selectedRects.add(rect.id);
               }
               updateAllSelections();
               if (navigator.vibrate) navigator.vibrate(50);
               rectLastTap = 0;
             } else {
               rectLastTap = now;
             }
           }, { passive: false });
           const deleteBtn = document.createElementNS(ns, "g");
           deleteBtn.classList.add("rect-delete-btn");
           deleteBtn.style.cursor = "pointer";
           deleteBtn.style.display = rectDrawMode ? "block" : "none";
           const deleteBg = document.createElementNS(ns, "circle");
           deleteBg.setAttribute("cx", rect.x + rect.width - 10);
           deleteBg.setAttribute("cy", rect.y + 10);
           deleteBg.setAttribute("r", 12);
           deleteBg.style.fill = "#f56565";
           deleteBg.style.stroke = "white";
           deleteBg.style.strokeWidth = "2";
           const deleteX = document.createElementNS(ns, "text");
           deleteX.setAttribute("x", rect.x + rect.width - 10);
           deleteX.setAttribute("y", rect.y + 10);
           deleteX.setAttribute("text-anchor", "middle");
           deleteX.setAttribute("dominant-baseline", "middle");
           deleteX.style.fill = "white";
           deleteX.style.fontSize = "16px";
           deleteX.style.fontWeight = "bold";
           deleteX.style.pointerEvents = "none";
           deleteX.textContent = "√ó";
           deleteBtn.appendChild(deleteBg);
           deleteBtn.appendChild(deleteX);
           deleteBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            e.preventDefault();
            deleteRectangle(rect.id);
           });
           let isDragging = false;
           let dragStartX, dragStartY;
           let rectStartX, rectStartY;
           rectEl.addEventListener("mousedown", (e) => {
		   if (isViewOnly()) return;
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            dragStartX = e.clientX;
            dragStartY = e.clientY;
            rectStartX = rect.x;
            rectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           });
      const moveHandler = (e) => {
      if (!isDragging || rectDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      rect.x = rectStartX + dx;
      rect.y = rectStartY + dy;
      if (selectedRects.has(rect.id)) {
      selectedNodes.forEach(nodeId => { if (initialPositions[nodeId]) { savedPositions[nodeId] = { x: initialPositions[nodeId].x + dx, y: initialPositions[nodeId].y + dy }; } });
      selectedRects.forEach(rectId => { if (rectId === rect.id) return; const r = RECT_DATA.list.find(x => x.id === rectId); if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; } });
      selectedTexts.forEach(textId => { const t = TEXT_DATA.list.find(x => x.id === textId); if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; } });
      selectedEdges.forEach(edgeId => { const ed = EDGE_DATA.list.find(x => x.id === edgeId); if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); } });
      }
      forgeTheTopology();
      };
           const upHandler = () => {
            if (isDragging) {
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           };
           document.addEventListener("mousemove", moveHandler);
           document.addEventListener("mouseup", upHandler);
           let touchStartX, touchStartY;
           let touchRectStartX, touchRectStartY;
           rectEl.addEventListener("touchstart", (e) => {
		    if (isViewOnly()) return;
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchRectStartX = rect.x;
            touchRectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           }, { passive: false });
           rectEl.addEventListener("touchmove", (e) => {
		   if (isViewOnly()) return;
            if (!isDragging || rectDrawMode) return;
            if (!e.touches[0]) return;
            e.preventDefault();
            e.stopPropagation();
            const svgEl = svg;
            const pt1 = svgEl.createSVGPoint();
            pt1.x = touchStartX;
            pt1.y = touchStartY;
            const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
            const touch = e.touches[0];
            const pt2 = svgEl.createSVGPoint();
            pt2.x = touch.clientX;
            pt2.y = touch.clientY;
            const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
            const dx = svgP2.x - svgP1.x;
            const dy = svgP2.y - svgP1.y;
            rect.x = touchRectStartX + dx;
            rect.y = touchRectStartY + dy;
            forgeTheTopology();
           }, { passive: false });
           rectEl.addEventListener("touchend", (e) => {
            if (isDragging) {
             e.preventDefault();
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           }, { passive: false });
           if (currentRectId === rect.id) {
             const corners = [
               { cx: rect.x, cy: rect.y, cursor: 'nwse-resize', dx: -1, dy: -1 },
               { cx: rect.x + rect.width, cy: rect.y, cursor: 'nesw-resize', dx: 1, dy: -1 },
               { cx: rect.x, cy: rect.y + rect.height, cursor: 'nesw-resize', dx: -1, dy: 1 },
               { cx: rect.x + rect.width, cy: rect.y + rect.height, cursor: 'nwse-resize', dx: 1, dy: 1 }
             ];
             corners.forEach((corner) => {
               const handle = document.createElementNS(ns, "circle");
               handle.setAttribute("cx", corner.cx);
               handle.setAttribute("cy", corner.cy);
handle.setAttribute("r", PAGE_STATE.selectionHandleSize || 8);
      handle.style.fill = PAGE_STATE.selectionHandle || "#f59e0b";
               handle.style.stroke = "#fff";
               handle.style.strokeWidth = "2";
               handle.style.cursor = corner.cursor;
               handle.addEventListener("mousedown", (e) => {
			   if (isViewOnly()) return;
                 e.preventDefault();
                 e.stopPropagation();
				 pushUndo("resize zone");
                 let dragging = true;
                 const startX = e.clientX, startY = e.clientY;
                 const origX = rect.x, origY = rect.y, origW = rect.width, origH = rect.height;
                 const moveHandler = (ev) => {
                   if (!dragging) return;
                   const pt1 = svg.createSVGPoint(); pt1.x = startX; pt1.y = startY;
                   const pt2 = svg.createSVGPoint(); pt2.x = ev.clientX; pt2.y = ev.clientY;
                   const svgP1 = pt1.matrixTransform(svg.getScreenCTM().inverse());
                   const svgP2 = pt2.matrixTransform(svg.getScreenCTM().inverse());
                   const dx = svgP2.x - svgP1.x, dy = svgP2.y - svgP1.y;
                   if (corner.dx < 0) { rect.x = origX + dx; rect.width = origW - dx; }
                   else { rect.width = origW + dx; }
                   if (corner.dy < 0) { rect.y = origY + dy; rect.height = origH - dy; }
                   else { rect.height = origH + dy; }
                   if (rect.width < 20) rect.width = 20;
                   if (rect.height < 20) rect.height = 20;
                   forgeTheTopology();
                 };
                 const upHandler = () => { dragging = false; document.removeEventListener("mousemove", moveHandler); document.removeEventListener("mouseup", upHandler); };
                 document.addEventListener("mousemove", moveHandler);
                 document.addEventListener("mouseup", upHandler);
               });
               g.appendChild(handle);
             });
           }
           if (rect.groupId) {
             const groupIndicator = document.createElementNS(ns, "rect");
             groupIndicator.setAttribute("x", rect.x - 4);
             groupIndicator.setAttribute("y", rect.y - 4);
             groupIndicator.setAttribute("width", rect.width + 8);
             groupIndicator.setAttribute("height", rect.height + 8);
             groupIndicator.style.fill = "none";
         groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
             groupIndicator.style.strokeWidth = "3";
             groupIndicator.style.strokeDasharray = "5,5";
             groupIndicator.style.pointerEvents = "none";
             g.insertBefore(groupIndicator, g.firstChild);
           }
           g.appendChild(rectEl);
           g.appendChild(deleteBtn);
           svg.appendChild(g);
          }
         });
        }
        if (TEXT_DATA && TEXT_DATA.list) {
         TEXT_DATA.list.forEach((textItem) => {
          if (currentView.mode === "rack") return;
          const g = document.createElementNS(ns, "g");
          g.classList.add("text-group");
          g.dataset.textId = textItem.id;
          if (textItem.bgEnabled) {
           const bgRect = document.createElementNS(ns, "rect");
           bgRect.classList.add("text-bg");
           bgRect.setAttribute("x", textItem.x - 5);
           bgRect.setAttribute("y", textItem.y - textItem.fontSize - 2);
           bgRect.setAttribute("width", 100);
           bgRect.setAttribute("height", textItem.fontSize + 10);
           bgRect.style.fill = textItem.bgColor;
           bgRect.style.opacity = "0.7";
           bgRect.style.rx = "4";
           g.appendChild(bgRect);
          }
          const textEl = document.createElementNS(ns, "text");
          textEl.classList.add("text-element");
          textEl.setAttribute("x", textItem.x);
          textEl.setAttribute("y", textItem.y);
          textEl.style.fill = textItem.color;
          textEl.style.fontSize = textItem.fontSize + "px";
          textEl.style.fontWeight = textItem.fontWeight;
          textEl.style.fontStyle = textItem.fontStyle;
          textEl.style.textAnchor = textItem.textAlign;
          textEl.style.textDecoration = textItem.textDecoration;
          textEl.style.opacity = textItem.opacity;
          textEl.style.cursor = "move";
          textEl.style.userSelect = "none";
          textEl.setAttribute("dominant-baseline", "middle");
          const lines = textItem.content.split('\n');
          if (lines.length === 1) {
           textEl.textContent = textItem.content;
          } else {
           lines.forEach((line, i) => {
            const tspan = document.createElementNS(ns, "tspan");
            tspan.textContent = line;
            tspan.setAttribute("x", textItem.x);
            tspan.setAttribute("dy", i === 0 ? 0 : textItem.fontSize * 1.2);
            textEl.appendChild(tspan);
           });
          }
          g.appendChild(textEl);
          if (textItem.bgEnabled) {
           setTimeout(() => {
            try {
             const bbox = textEl.getBBox();
             const bgRect = g.querySelector('.text-bg');
             if (bgRect && bbox) {
              bgRect.setAttribute("x", bbox.x - 5);
              bgRect.setAttribute("y", bbox.y - 2);
              bgRect.setAttribute("width", bbox.width + 10);
              bgRect.setAttribute("height", bbox.height + 4);
             }
            } catch (e) {
            }
           }, 0);
          }
          const deleteBtn = document.createElementNS(ns, "g");
          deleteBtn.classList.add("text-delete-btn");
          deleteBtn.style.cursor = "pointer";
          deleteBtn.style.display = textDrawMode ? "block" : "none";
          const deleteBg = document.createElementNS(ns, "circle");
          deleteBg.setAttribute("cx", textItem.x + 20);
          deleteBg.setAttribute("cy", textItem.y - textItem.fontSize);
          deleteBg.setAttribute("r", 12);
          deleteBg.style.fill = "#f56565";
          deleteBg.style.stroke = "white";
          deleteBg.style.strokeWidth = "2";
          const deleteX = document.createElementNS(ns, "text");
          deleteX.setAttribute("x", textItem.x + 20);
          deleteX.setAttribute("y", textItem.y - textItem.fontSize);
          deleteX.setAttribute("text-anchor", "middle");
          deleteX.setAttribute("dominant-baseline", "middle");
          deleteX.style.fill = "white";
          deleteX.style.fontSize = "16px";
          deleteX.style.fontWeight = "bold";
          deleteX.style.pointerEvents = "none";
          deleteX.textContent = "√ó";
          deleteBtn.appendChild(deleteBg);
          deleteBtn.appendChild(deleteX);
          deleteBtn.addEventListener("click", (e) => {
           e.stopPropagation();
           e.preventDefault();
           deleteText(textItem.id);
          });
          let isDragging = false;
          let dragStartX, dragStartY;
          let textStartX, textStartY;
          textEl.addEventListener("mousedown", (e) => {
		  if (isViewOnly()) return;
      if (textDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      textStartX = textItem.x;
      textStartY = textItem.y;
      textEl.style.cursor = "grabbing";
      showTextPanel(textItem.id);
      if (selectedTexts.has(textItem.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
          const moveHandler = (e) => {
      if (!isDragging || textDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      textItem.x = textStartX + dx;
      textItem.y = textStartY + dy;
      if (selectedTexts.has(textItem.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       const newX = initialPositions[nodeId].x + dx;
       const newY = initialPositions[nodeId].y + dy;
       savedPositions[nodeId] = { x: newX, y: newY };
      }
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      if (textId === textItem.id) return;
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      forgeTheTopology();
      };
          const upHandler = () => {
           if (isDragging) {
            isDragging = false;
            textEl.style.cursor = "move";
           }
          };
          document.addEventListener("mousemove", moveHandler);
          document.addEventListener("mouseup", upHandler);
          let touchStartX = 0, touchStartY = 0;
          let textTouchStartX = 0, textTouchStartY = 0;
          textEl.addEventListener("touchstart", (e) => {
		   if (isViewOnly()) return;
           if (textDrawMode) return;
           if (e.touches.length !== 1) return;
           e.preventDefault();
           e.stopPropagation();
           const touch = e.touches[0];
           isDragging = true;
           touchStartX = touch.clientX;
           touchStartY = touch.clientY;
           textTouchStartX = textItem.x;
           textTouchStartY = textItem.y;
           showTextPanel(textItem.id);
          }, { passive: false });
          textEl.addEventListener("touchmove", (e) => {
           if (!isDragging || textDrawMode) return;
           if (e.touches.length !== 1) return;
           e.preventDefault();
           const touch = e.touches[0];
           const svgEl = svg;
           const pt1 = svgEl.createSVGPoint();
           pt1.x = touchStartX;
           pt1.y = touchStartY;
           const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
           const pt2 = svgEl.createSVGPoint();
           pt2.x = touch.clientX;
           pt2.y = touch.clientY;
           const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
           const dx = svgP2.x - svgP1.x;
           const dy = svgP2.y - svgP1.y;
           textItem.x = textTouchStartX + dx;
           textItem.y = textTouchStartY + dy;
           forgeTheTopology();
          }, { passive: false });
          textEl.addEventListener("touchend", () => {
           if (isDragging) {
            isDragging = false;
           }
          }, { passive: false });
          textEl.addEventListener("contextmenu", (e) => {
           e.preventDefault();
           e.stopPropagation();
           if (selectedTexts.has(textItem.id)) {
            selectedTexts.delete(textItem.id);
           } else {
            selectedTexts.add(textItem.id);
           }
           updateAllSelections();
          });
          let textLastTap = 0;
          g.addEventListener("touchend", (e) => {
           const now = Date.now();
           if (now - textLastTap < 300) {
            e.preventDefault();
            if (selectedTexts.has(textItem.id)) {
             selectedTexts.delete(textItem.id);
            } else {
             selectedTexts.add(textItem.id);
            }
            updateAllSelections();
            if (navigator.vibrate) navigator.vibrate(50);
            textLastTap = 0;
           } else {
            textLastTap = now;
           }
          }, { passive: false });
          if (textItem.groupId) {
            const groupIndicator = document.createElementNS(ns, "rect");
            groupIndicator.setAttribute("x", textItem.x - 54);
            groupIndicator.setAttribute("y", textItem.y - 24);
            groupIndicator.setAttribute("width", 108);
            groupIndicator.setAttribute("height", 48);
            groupIndicator.setAttribute("rx", "8");
            groupIndicator.style.fill = "none";
       groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
            groupIndicator.style.strokeWidth = "3";
            groupIndicator.style.strokeDasharray = "5,5";
            groupIndicator.style.pointerEvents = "none";
            g.insertBefore(groupIndicator, g.firstChild);
          }
          g.appendChild(deleteBtn);
          svg.appendChild(g);
         });
        }
        Object.keys(NODE_DATA).forEach(nodeId => {
         updatePingIndicator(nodeId);
        });
        forgeTheLegend();
        updateMinimap();
       }
       function showEditModal(title, currentValue, onSave) {
        const modal = document.getElementById("edit-modal");
        const input = document.getElementById("modal-input");
        const titleEl = document.getElementById("modal-title");
        const saveBtn = document.getElementById("modal-save");
        const cancelBtn = document.getElementById("modal-cancel");
        titleEl.textContent = title;
        input.value = currentValue;
        modal.classList.add("active");
        input.focus();
        input.select();
        const cleanup = () => {
         modal.classList.remove("active");
         saveBtn.removeEventListener("click", handleSave);
         cancelBtn.removeEventListener("click", handleCancel);
         input.removeEventListener("keypress", handleEnter);
         modal.removeEventListener("click", bgHandler);
        };
        const handleSave = () => {
         if (input.value.trim()) {
          onSave(input.value.trim());
         }
         cleanup();
        };
        const handleCancel = () => {
         cleanup();
        };
        const handleEnter = (e) => {
         if (e.key === "Enter") handleSave();
        };
        const bgHandler = (e) => {
         if (e.target === modal) handleCancel();
        };
        saveBtn.addEventListener("click", handleSave);
        cancelBtn.addEventListener("click", handleCancel);
        input.addEventListener("keypress", handleEnter);
        modal.addEventListener("click", bgHandler);
       }
       function challengeTheImmortal(message, onConfirm) {
        const modal = document.getElementById("confirm-modal");
        const messageEl = document.getElementById("confirm-message");
        const deleteBtn = document.getElementById("confirm-delete");
        const cancelBtn = document.getElementById("confirm-cancel");
        messageEl.textContent = message;
        modal.classList.add("active");
	    const cleanup = () => {
         modal.classList.remove("active");
         deleteBtn.removeEventListener("click", handleConfirm);
         cancelBtn.removeEventListener("click", handleCancel);
         modal.removeEventListener("click", bgHandler);
        };
        const handleConfirm = () => {
         onConfirm();
         cleanup();
        };
        const handleCancel = () => {
         cleanup();
        };
        const bgHandler = (e) => {
         if (e.target === modal) handleCancel();
        };
        deleteBtn.addEventListener("click", handleConfirm);
        cancelBtn.addEventListener("click", handleCancel);
        modal.addEventListener("click", bgHandler);
       }
       const pageTitleEl = document.getElementById("page-title");
       if (pageTitleEl) {
        pageTitleEl.addEventListener("click", () => {
         showEditModal("Edit Title", PAGE_STATE.title || DEFAULT_PAGE_STATE.title,
          (newTitle) => {
           PAGE_STATE.title = newTitle;
           wieldThePower();
          }, );
        });
       }
       function editNodeName(id) {
        if (!NODE_DATA[id]) return;
        showEditModal("Edit Name", NODE_DATA[id].name, (newName) => {
         if (!NODE_DATA[id]) return;
         pushUndo("edit node name");
         NODE_DATA[id].name = newName;
         const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`, );
         if (nodeGroup) {
          const label = nodeGroup.querySelector(".node-label");
          if (label) label.textContent = newName;
         }
         if (currentNodeId === id) {
          document.getElementById("node-name").textContent = newName;
         }
        });
       }
       function editNodeIp(id) {
        if (!NODE_DATA[id]) return;
        showEditModal("Edit IP/Subtitle", NODE_DATA[id].ip, (newIp) => {
         if (!NODE_DATA[id]) return;
         pushUndo("edit node ip");
         NODE_DATA[id].ip = newIp;
         const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`, );
         if (nodeGroup) {
          const sub = nodeGroup.querySelector(".node-sub");
          if (sub) sub.textContent = newIp;
         }
         if (currentNodeId === id) {
          document.getElementById("node-ip").textContent = newIp;
         }
        });
       }
       function claimTheImmortal(id) {
	   if (isViewOnly()) return;
        if (!NODE_DATA[id]) return;
        currentNodeId = id;
        currentEdgeId = null;
        currentRectId = null;
        currentTextId = null;
        const data = NODE_DATA[id];
        document.querySelectorAll(".node-group").forEach((n) => {
         n.classList.toggle("active", n.dataset.nodeId === id);
        });
        document.querySelectorAll(".edge").forEach((e) => {
        const active = e.dataset.from === id || e.dataset.to === id;
        e.classList.toggle("active", active);
       });
       document.querySelectorAll(".rect-group").forEach((r) => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach((t) => t.classList.remove("active"));
       document.getElementById("node-panel").style.display = "block";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        const toolbar = document.getElementById("topology-toolbar");
        if (!topologyToolbarCollapsed) {
         toolbar.style.display = "flex";
        }
        updateTopologyToolbarVisibility();
        document.getElementById("node-name").textContent = data.name;
        document.getElementById("node-ip").textContent = data.ip;
        document.getElementById("node-mac").textContent = data.mac || "--";
        document.getElementById("node-rack").textContent = data.rackUnit || "--";
        document.getElementById("node-uheight").textContent = (data.uHeight || "1") + "U";
        document.getElementById("node-role").textContent = data.role;
        populateRackDropdown();
        const assignedRackSelect = document.getElementById("node-assigned-rack");
        if (assignedRackSelect) {
         assignedRackSelect.value = data.assignedRack || "";
        }
        const rackCapacitySelect = document.getElementById("node-rack-capacity");
        if (rackCapacitySelect) {
         rackCapacitySelect.value = data.rackCapacity || "42";
        }
        const isRack = data.isRack === true;
        const isAssignedToRack = !!data.assignedRack;
        const assignedRackRow = document.getElementById("assigned-rack-row");
        const rackCapacityRow = document.getElementById("rack-capacity-row");
        const uheightRow = document.getElementById("uheight-row");
        if (assignedRackRow) assignedRackRow.style.display = isRack ? "none" : "flex";
        if (rackCapacityRow) rackCapacityRow.style.display = isRack ? "flex" : "none";
        if (uheightRow) uheightRow.style.display = isAssignedToRack ? "flex" : "none";
		const delBtn = document.getElementById("delete-node-btn");
        if (delBtn) delBtn.textContent = isRack ? "Delete Rack" : "Delete Node";
		const rackContentsSection = document.getElementById("rack-contents-section");
        const rackContentsList = document.getElementById("rack-contents-list");
        const rackContentsCount = document.getElementById("rack-contents-count");
        if (rackContentsSection && rackContentsList) {
        if (isRack) {
         const nodesInRack = Object.entries(NODE_DATA).filter(([nid, n]) => n.assignedRack === id);
         rackContentsCount.textContent = nodesInRack.length;
         if (nodesInRack.length > 0) {
          rackContentsList.innerHTML = '';
          nodesInRack.forEach(([nid, n]) => {
           const div = document.createElement('div');
           div.style.cssText = 'padding: 8px 4px; border-bottom: 1px solid var(--edge-main); cursor: pointer;';
           div.onclick = () => claimTheImmortal(nid);
           const nameSpan = document.createElement('span');
           nameSpan.style.color = 'var(--text-main)';
           nameSpan.textContent = n.name;
           div.appendChild(nameSpan);
           (n.tags || []).forEach(t => {
            const tagSpan = document.createElement('span');
            tagSpan.style.cssText = 'background: var(--accent); color: var(--bg); padding: 2px 6px; border-radius: 4px; font-size: 11px; margin-left: 4px;';
            tagSpan.textContent = t;
            div.appendChild(tagSpan);
           });
           rackContentsList.appendChild(div);
          });
         } else {
          rackContentsList.innerHTML = '<div style="color: var(--text-soft); font-style: italic; padding: 8px 4px;">No nodes assigned</div>';
         }
         rackContentsSection.style.display = "block";
         } else {
         rackContentsSection.style.display = "none";
         }
        }
       const connectionsSection = document.getElementById("node-connections-section");
       const connectionsList = document.getElementById("node-connections-list");
       const connectionsCount = document.getElementById("node-connections-count");
       if (connectionsSection && connectionsList) {
        const connectedEdges = (EDGE_DATA.list || []).filter(e => e.from === id || e.to === id);
        connectionsCount.textContent = connectedEdges.length;
        if (connectedEdges.length > 0) {
         connectionsList.innerHTML = '';
         connectedEdges.forEach(e => {
          const isFrom = e.from === id;
          const localPort = isFrom ? e.fromPort : e.toPort;
          const remoteNodeId = isFrom ? e.to : e.from;
          const remotePort = isFrom ? e.toPort : e.fromPort;
          const remoteName = NODE_DATA[remoteNodeId]?.name || remoteNodeId;
          const div = document.createElement('div');
          div.style.cssText = 'padding: 6px 0; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;';
          const localSpan = document.createElement('span');
          localSpan.style.cssText = localPort ? 'color: var(--accent); font-family: monospace; cursor: pointer;' : 'color: var(--text-soft); cursor: pointer;';
          localSpan.textContent = localPort || '-';
          localSpan.title = localPort ? 'Click to view connection' : 'Click to set port';
          localSpan.onclick = () => { if (localPort) { selectTheConnection(e.id); } else { const label = `Port on ${NODE_DATA[id]?.name || id}:`; const newVal = prompt(label, ''); if (newVal !== null && newVal !== '') { const isDupe = (EDGE_DATA.list || []).some(x => x.id !== e.id && ((x.from === id && x.fromPort === newVal) || (x.to === id && x.toPort === newVal))); if (isDupe && !confirm(`Warning: Port "${newVal}" is already used on ${NODE_DATA[id]?.name || id}. Use anyway?`)) return; if (isFrom) e.fromPort = newVal; else e.toPort = newVal; claimTheImmortal(id); } } };
          const arrow = document.createElement('span');
          arrow.style.cssText = 'color: var(--text-soft); margin: 0 8px;';
          arrow.textContent = '‚Üî';
          const remoteSpan = document.createElement('span');
          remoteSpan.style.cssText = 'color: var(--text-main); cursor: pointer;';
          remoteSpan.textContent = remoteName;
          remoteSpan.title = 'Click to view connection';
          remoteSpan.onclick = () => { claimTheImmortal(remoteNodeId); focusOnSelected(); };
          const remotePortSpan = document.createElement('span');
          remotePortSpan.style.cssText = remotePort ? 'color: var(--accent); font-family: monospace; margin-left: 6px; cursor: pointer;' : 'color: var(--text-soft); margin-left: 6px; cursor: pointer;';
          remotePortSpan.textContent = '(' + (remotePort || '-') + ')';
          remotePortSpan.title = remotePort ? 'Click to view connection' : 'Click to set port';
          remotePortSpan.onclick = () => { if (remotePort) { selectTheConnection(e.id); } else { const label = `Port on ${remoteName}:`; const newVal = prompt(label, ''); if (newVal !== null && newVal !== '') { const isDupe = (EDGE_DATA.list || []).some(x => x.id !== e.id && ((x.from === remoteNodeId && x.fromPort === newVal) || (x.to === remoteNodeId && x.toPort === newVal))); if (isDupe && !confirm(`Warning: Port "${newVal}" is already used on ${remoteName}. Use anyway?`)) return; if (isFrom) e.toPort = newVal; else e.fromPort = newVal; claimTheImmortal(id); } } };
          div.appendChild(localSpan);
          div.appendChild(arrow);
          div.appendChild(remoteSpan);
          div.appendChild(remotePortSpan);
          connectionsList.appendChild(div);
         });
         connectionsSection.style.display = "block";
        } else {
         connectionsList.innerHTML = '<div style="color: var(--text-soft); font-style: italic;">No connections</div>';
         connectionsSection.style.display = "block";
        }
       }
       document.getElementById("node-name").onclick = () => editNodeName(id);
        document.getElementById("node-ip").onclick = () => editNodeIp(id);
        document.getElementById("node-mac").onclick = () => editNodeMac(id);
        document.getElementById("node-rack").onclick = () => editNodeRack(id);
        document.getElementById("node-uheight").onclick = () => editNodeUHeight(id);
        const currentSize = savedSizes[id] || getDefaultSize();
        document.getElementById("size-slider").value = currentSize;
        document.getElementById("size-value").textContent = currentSize;
        const styleEntry = savedStyles[id] || {};
        const resolvedStyles = resolveStylesEntry(styleEntry);
        const scopeKey = currentStyleScope || "all";
        const flatProps = ["circleColor", "circleBorder", "titleColor", "titleFont", "titleSize", "subColor", "subFont", "subSize", ];
        const isFlat = flatProps.some((p) => Object.prototype.hasOwnProperty.call(styleEntry, p), );
        const scopedStyles = isFlat ? styleEntry : styleEntry[scopeKey] || {};
        const circleColorInput = document.getElementById("circle-color");
        const titleColorInput = document.getElementById("title-color");
        const titleFontSelect = document.getElementById("title-font");
        const titleSizeInput = document.getElementById("title-size");
        const subColorInput = document.getElementById("sub-color");
        const subFontSelect = document.getElementById("sub-font");
        const subSizeInput = document.getElementById("sub-size");
        const shapeSelect = document.getElementById("shape-select");
        const scopeSelect = document.getElementById("style-scope");
        circleColorInput.value = scopedStyles.circleColor || resolvedStyles.circleColor || PAGE_STATE.nodeFill || "#1e293b";
       const circleBorderInput = document.getElementById("circle-border");
       circleBorderInput.value = scopedStyles.circleBorder || resolvedStyles.circleBorder || PAGE_STATE.nodeStroke || "#475569";
        titleColorInput.value = scopedStyles.titleColor || resolvedStyles.titleColor || PAGE_STATE.textMain || "#e2e8f0";
        titleFontSelect.value = scopedStyles.titleFont || resolvedStyles.titleFont || "system-ui, sans-serif";
        titleSizeInput.value = scopedStyles.titleSize || resolvedStyles.titleSize || 18;
        subColorInput.value = scopedStyles.subColor || resolvedStyles.subColor || PAGE_STATE.textSoft || "#94a3b8";
        subFontSelect.value = scopedStyles.subFont || resolvedStyles.subFont || "system-ui, sans-serif";
        subSizeInput.value = scopedStyles.subSize || resolvedStyles.subSize || 13;
        const hasWebIcon = resolvedStyles.icon && resolvedStyles.icon.library;
        const customOpt = shapeSelect.querySelector('option[value="custom-icon"]');
        if (hasWebIcon) {
         if (!customOpt) {
          const opt = document.createElement('option');
          opt.value = 'custom-icon';
          opt.textContent = 'Custom Icon';
          shapeSelect.insertBefore(opt, shapeSelect.firstChild);
         }
         shapeSelect.value = 'custom-icon';
        } else {
         if (customOpt) customOpt.remove();
         shapeSelect.value = data.shape || "circle";
        }
        const layerSelect = document.getElementById("node-layer");
        if (layerSelect) {
         layerSelect.value = data.layer || "physical";
        }
        scopeSelect.value = currentStyleScope || "all";
        document.getElementById("title-offset-y").value = scopedStyles.titleOffsetY || resolvedStyles.titleOffsetY || 0;
        document.getElementById("title-offset-x").value = scopedStyles.titleOffsetX || resolvedStyles.titleOffsetX || 0;
        document.getElementById("sub-offset-y").value = scopedStyles.subOffsetY || resolvedStyles.subOffsetY || 0;
        document.getElementById("sub-offset-x").value = scopedStyles.subOffsetX || resolvedStyles.subOffsetX || 0;
      const pingOffsetXInput = document.getElementById("ping-offset-x");
      const pingOffsetYInput = document.getElementById("ping-offset-y");
      if (pingOffsetXInput && pingOffsetYInput) {
      pingOffsetXInput.value =
       (scopedStyles.pingOffsetX !== undefined
         ? scopedStyles.pingOffsetX
         : (resolvedStyles.pingOffsetX !== undefined
             ? resolvedStyles.pingOffsetX
             : 0));
      pingOffsetYInput.value =
       (scopedStyles.pingOffsetY !== undefined
         ? scopedStyles.pingOffsetY
         : (resolvedStyles.pingOffsetY !== undefined
             ? resolvedStyles.pingOffsetY
             : 0));
      }
        const tagEl = document.getElementById("node-tags");
        tagEl.innerHTML = "";
        data.tags.forEach((tag, i) => {
         const b = document.createElement("span");
         b.className = "badge";
         const isIconTag = typeof tag === 'object' && tag.type === 'icon';
         if (!isIconTag && typeof tag === 'string' && tag.toLowerCase().includes("wg")) b.classList.add("wg");
         b.style.cursor = "pointer";
         b.style.position = "relative";
         const tagContent = document.createElement("span");
         if (isIconTag) {
          b.classList.add("icon-badge");
          IconLibrary.getIcon(tag.library, tag.name).then(svgText => {
           if (svgText) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(svgText, 'image/svg+xml');
            const svgEl = doc.querySelector('svg');
            if (svgEl) {
             svgEl.setAttribute('width', '16');
             svgEl.setAttribute('height', '16');
             tagContent.innerHTML = '';
             tagContent.appendChild(svgEl);
             const nameSpan = document.createElement('span');
             nameSpan.textContent = tag.name;
             nameSpan.style.marginLeft = '4px';
             tagContent.appendChild(nameSpan);
            }
           }
          });
         } else {
          tagContent.textContent = tag;
          tagContent.addEventListener("click", (e) => {
           e.stopPropagation();
           showEditModal("Edit Tag", tag, (newTag) => {
            if (newTag) {
             pushUndo("edit tag");
             data.tags[i] = newTag;
             claimTheImmortal(id);
            }
           });
          });
         }
         const deleteTag = document.createElement("span");
         deleteTag.textContent = " ‚úï";
         deleteTag.style.opacity = "0.6";
         deleteTag.style.marginLeft = "4px";
         deleteTag.style.fontSize = "10px";
         deleteTag.addEventListener("click", (e) => {
          e.stopPropagation();
          pushUndo("delete tag");
          data.tags.splice(i, 1);
          claimTheImmortal(id);
         });
         b.append(tagContent, deleteTag);
         tagEl.append(b);
        });
        const addTagBtn = document.createElement("span");
        addTagBtn.className = "badge";
        addTagBtn.style.cursor = "pointer";
        addTagBtn.style.opacity = "0.6";
        addTagBtn.style.borderStyle = "dashed";
        addTagBtn.textContent = "+ Add Tag";
        addTagBtn.addEventListener("click", () => {
         showEditModal("Add Tag(s) : comma separated", "",
          (newTagStr) => {
           if (newTagStr) {
            pushUndo("add tags");
            const newTags = newTagStr.split(",").map((t) => t.trim()).filter((t) => t);
            newTags.forEach((t) => data.tags.push(t));
            claimTheImmortal(id);
           }
          }, );
        });
        tagEl.append(addTagBtn);
        const notesEl = document.getElementById("node-notes");
        notesEl.innerHTML = "";
        data.notes.forEach((note, i) => {
         const li = document.createElement("li");
         const noteText = document.createElement("span");
         noteText.textContent = note;
         noteText.style.flex = "1";
         const deleteBtn = document.createElement("span");
         deleteBtn.className = "delete-note";
         deleteBtn.textContent = "‚úï";
         deleteBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          challengeTheImmortal("Are you sure you want to delete this note?",
           () => {
            pushUndo("delete note");
            data.notes.splice(i, 1);
            claimTheImmortal(id);
           }, );
         });
         li.append(noteText, deleteBtn);
         noteText.addEventListener("dblclick", () => {
          noteText.classList.add("editing");
          noteText.contentEditable = true;
          noteText.focus();
         });
         noteText.addEventListener("blur", () => {
          noteText.classList.remove("editing");
          noteText.contentEditable = false;
          pushUndo("edit note");
          data.notes[i] = noteText.textContent;
         });
         notesEl.append(li);
        });
        const addLineSelect = document.getElementById("add-line-select");
      addLineSelect.innerHTML = "";
      const currentRack = data.assignedRack || "";
      Object.entries(NODE_DATA).forEach(([nodeId, node]) => {
      if (nodeId !== id) {
      const nodeRack = node.assignedRack || "";
      if (currentRack === nodeRack) {
      const opt = document.createElement("option");
      opt.value = nodeId;
      opt.textContent = node.name;
      addLineSelect.appendChild(opt);
      }
      }
      });
        const pingEnabled = data.ping && data.ping.enabled;
        document.getElementById('node-pingable').checked = pingEnabled;
        document.getElementById('node-ping-options').style.display = pingEnabled ? 'block' : 'none';
        if (data.ping) {
         document.getElementById('node-ping-protocol').value = data.ping.protocol || 'http';
         document.getElementById('node-custom-url').value = data.ping.customUrl || '';
         document.getElementById('node-ping-timeout').value = data.ping.timeout || 3000;
         document.getElementById('node-custom-url-container').style.display =
          data.ping.protocol === 'custom' ? 'block' : 'none';
         updatePingStatusDisplay(id);
        }
       }
       function updatePingStatusDisplay(nodeId) {
        const data = NODE_DATA[nodeId];
        if (!data || !data.ping) return;
        const statusEl = document.getElementById('node-ping-status');
        const lastCheckEl = document.getElementById('node-ping-last-check');
        const statusColors = {
         online: 'var(--accent)',
         offline: 'var(--danger)',
         checking: '#f59e0b',
         unknown: 'var(--text-soft)'
        };
        const statusTexts = {
         online: '‚óè Online',
         offline: '‚óè Offline',
         checking: '‚óè Checking...',
         unknown: '‚óè Unknown'
        };
        statusEl.textContent = statusTexts[data.ping.status] || statusTexts.unknown;
        statusEl.style.color = statusColors[data.ping.status] || statusColors.unknown;
        if (data.ping.lastCheck) {
         const checkTime = new Date(data.ping.lastCheck);
         lastCheckEl.textContent = `Last checked: ${checkTime.toLocaleTimeString()}`;
        } else {
         lastCheckEl.textContent = 'Never checked';
        }
       }
       function selectTheConnection(id) {
	   if (isViewOnly()) return;
        currentEdgeId = id;
        currentNodeId = null;
        currentRectId = null;
        currentTextId = null;
		if (isMobileDevice()) {
        const currentHeight = PAGE_STATE.mobileFooterHeight || 40;
        if (currentHeight <= 20) {
         PAGE_STATE.mobileFooterHeight = 80;
         const root = document.documentElement;
         root.style.setProperty("--mobile-footer-height", "80vh");
         const mobileFooterHeightInput = document.getElementById("mobile-footer-height");
         const mobileFooterHeightVal = document.getElementById("mobile-footer-height-val");
         if (mobileFooterHeightInput) mobileFooterHeightInput.value = 80;
         if (mobileFooterHeightVal) mobileFooterHeightVal.textContent = "80%";
        }
       }
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "block";
        document.getElementById("text-panel").style.display = "none";
       document.getElementById("rect-panel").style.display = "none";
       document.getElementById("topology-toolbar").style.display = "none";
       document.querySelectorAll(".node-group").forEach((n) => n.classList.remove("active"));
       document.querySelectorAll(".rect-group").forEach((r) => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach((t) => t.classList.remove("active"));
       document.querySelectorAll(".edge").forEach((e) => {
        e.classList.toggle("active", e.dataset.edgeId === id);
       });
        const edge = EDGE_DATA.list.find((e) => e.id === id);
        if (!edge) return;
        const directionSymbols = {
         none: "‚áÑ",
         forward: "‚Üí",
         backward: "‚Üê",
         both: "‚Üî",
        };
        const dirSymbol = directionSymbols[edge.direction] || "‚áÑ";
        let titleText = "Custom line";
        if (edge.from || edge.to) {
         const fromName = edge.from ? NODE_DATA[edge.from]?.name || edge.from : "";
         const toName = edge.to ? NODE_DATA[edge.to]?.name || edge.to : "";
         titleText = `${fromName || "?"} ${dirSymbol} ${toName || "?"}`;
        }
        document.getElementById("edge-title").textContent = titleText;
        const widthInput = document.getElementById("edge-width");
        const colorInput = document.getElementById("edge-color");
        const directionSelect = document.getElementById("edge-direction");
        const lineStyleSelect = document.getElementById("edge-line-style");
        widthInput.value = edge.width;
        colorInput.value = edge.color;
        directionSelect.value = edge.direction || "none";
        lineStyleSelect.value = edge.lineStyle || "solid";
        const fromPortInput = document.getElementById("edge-from-port");
        const toPortInput = document.getElementById("edge-to-port");
        const portFieldsFrom = document.getElementById("edge-port-fields");
        const portFieldsTo = document.getElementById("edge-port-fields-to");
        if (edge.type === "custom") {
         if (portFieldsFrom) portFieldsFrom.style.display = "none";
         if (portFieldsTo) portFieldsTo.style.display = "none";
        } else {
         if (portFieldsFrom) portFieldsFrom.style.display = "flex";
         if (portFieldsTo) portFieldsTo.style.display = "flex";
         if (fromPortInput) {
          fromPortInput.value = edge.fromPort || "";
          fromPortInput.onchange = () => updateEdgePortLabels(id);
         }
         if (toPortInput) {
          toPortInput.value = edge.toPort || "";
          toPortInput.onchange = () => updateEdgePortLabels(id);
         }
        }
        const list = document.getElementById("edge-notes");
        list.innerHTML = "";
        edge.notes.forEach((note, i) => {
         const li = document.createElement("li");
         const txt = document.createElement("span");
         txt.textContent = note;
         txt.style.flex = "1";
         const del = document.createElement("span");
         del.className = "delete-note";
         del.textContent = "‚úï";
         del.addEventListener("click", (e) => {
          e.stopPropagation();
         challengeTheImmortal("Delete this line note?", () => {
           pushUndo("delete edge note");
           edge.notes.splice(i, 1);
           selectTheConnection(id);
          });
         });
         txt.addEventListener("dblclick", () => {
          txt.classList.add("editing");
          txt.contentEditable = true;
          txt.focus();
         });
        txt.addEventListener("blur", () => {
          txt.classList.remove("editing");
          txt.contentEditable = false;
          pushUndo("edit edge note");
          edge.notes[i] = txt.textContent;
         });
         li.append(txt, del);
         list.appendChild(li);
       });
       if (edge.type === "custom" && Array.isArray(edge.points)) {
        forgeTheTopology();
       }
      }
       window.addEventListener("resize", () => {
        forgeTheTopology();
        if (currentEdgeId) {
         selectTheConnection(currentEdgeId);
        } else if (currentNodeId && NODE_DATA[currentNodeId]) {
         claimTheImmortal(currentNodeId);
        } else {
         const availableNodes = Object.keys(NODE_DATA);
         if (availableNodes.length > 0) {
          claimTheImmortal(availableNodes[0]);
         }
        }
       });
       (function initZoomPan() {
        const viewport = document.getElementById("canvas-viewport");
        const svg = document.getElementById("map");
        const hint = document.getElementById("canvas-hint");
        setTimeout(() => {
         hint.classList.add("visible");
         setTimeout(() => hint.classList.remove("visible"), 4000);
        }, 1000);
        viewport.addEventListener("wheel",
         (e) => {
          e.preventDefault();
          const rect = viewport.getBoundingClientRect();
          const mouseX = (e.clientX - rect.left) / rect.width;
          const mouseY = (e.clientY - rect.top) / rect.height;
          const delta = e.deltaY > 0 ? 0.9 : 1.1;
          zoomTo(canvasState.zoom * delta, mouseX, mouseY);
         }, {
          passive: false
         }, );
        let initialPinchDistance = 0;
        let initialPinchZoom = 1;
        let pinchCenter = {
         x: 0.5,
         y: 0.5
        };
        viewport.addEventListener("touchstart",
         (e) => {
          if (e.touches.length === 2) {
           e.preventDefault();
           const touch1 = e.touches[0];
           const touch2 = e.touches[1];
           initialPinchDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY, );
           initialPinchZoom = canvasState.zoom;
           const rect = viewport.getBoundingClientRect();
           const centerX = (touch1.clientX + touch2.clientX) / 2;
           const centerY = (touch1.clientY + touch2.clientY) / 2;
           pinchCenter.x = (centerX - rect.left) / rect.width;
           pinchCenter.y = (centerY - rect.top) / rect.height;
          }
         }, {
          passive: false
         }, );
        viewport.addEventListener("touchmove",
         (e) => {
          if (e.touches.length === 2) {
           e.preventDefault();
           const touch1 = e.touches[0];
           const touch2 = e.touches[1];
           const currentDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY, );
           if (initialPinchDistance > 0) {
            const scale = currentDistance / initialPinchDistance;
            const newZoom = initialPinchZoom * scale;
            zoomTo(newZoom, pinchCenter.x, pinchCenter.y);
           }
          }
         }, {
          passive: false
         }, );
        let panStartViewX = 0;
        let panStartViewY = 0;
        let lastEmptyTapTime = 0;
        let emptyTapTimeout = null;
        let emptyTapMoved = false;
        let emptyTapStartX = 0;
        let emptyTapStartY = 0;
        viewport.addEventListener("touchend", (e) => {
          if (currentView.mode !== "rack") return;
          if (e.changedTouches.length !== 1) return;
      const isNodeOrEdge = e.target.closest(".node-group") || e.target.closest(".edge-group");
         if (isNodeOrEdge) return;
          if (emptyTapMoved) {
            emptyTapMoved = false;
            return;
          }
          const currentTime = new Date().getTime();
          const tapGap = currentTime - lastEmptyTapTime;
          if (tapGap < 300 && tapGap > 0) {
            e.preventDefault();
            exitRack();
            if (navigator.vibrate) {
              navigator.vibrate(50);
            }
            lastEmptyTapTime = 0;
            if (emptyTapTimeout) {
              clearTimeout(emptyTapTimeout);
              emptyTapTimeout = null;
            }
          } else {
            lastEmptyTapTime = currentTime;
            if (emptyTapTimeout) clearTimeout(emptyTapTimeout);
            emptyTapTimeout = setTimeout(() => {
              lastEmptyTapTime = 0;
            }, 300);
          }
        }, { passive: false });
        viewport.addEventListener("mousedown", (e) => {
         if (e.target.closest(".draw-toolbar") || e.target.closest(".topology-toolbar") || e.target.closest(".legend-container")) {
          return;
         }
         if (freeDrawMode || rectDrawMode) {
          return;
         }
      const isEmptySpace = e.target === svg || e.target === viewport || e.target.tagName === "svg";
      const isEdgeElement = e.target.closest('.edge') || e.target.classList.contains('edge-edit-point');
      const isTextElement = e.target.closest('.text-group') || e.target.closest('.text-element');
      const isRectElement = e.target.closest('.rect-group');
      if (!isEdgeElement && !isTextElement && !isRectElement && currentEdgeId) {
      currentEdgeId = null;
      forgeTheTopology();
      }
      if (!isRectElement && currentRectId) {
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      }
         if (isViewOnly()) {
         document.body.classList.remove("view-only-inspect");
         document.getElementById("node-panel").style.display = "none";
         document.getElementById("edge-panel").style.display = "none";
        }
         if (isEmptySpace && e.shiftKey && e.button === 0) {
         if (isViewOnly()) return;
         e.preventDefault();
         startSelection(e);
         return;
        }
        if (isEmptySpace || e.button === 2 || e.button === 1) {
          e.preventDefault();
          canvasState.isPanning = true;
          canvasState.panStartX = e.clientX;
          canvasState.panStartY = e.clientY;
          panStartViewX = canvasState.panX;
          panStartViewY = canvasState.panY;
          viewport.classList.add("panning");
         }
        });
        viewport.addEventListener("touchstart",
         (e) => {
          if (e.target.closest(".draw-toolbar") || e.target.closest(".topology-toolbar") || e.target.closest(".legend-container")) {
           return;
          }
          if (freeDrawMode || rectDrawMode) {
           return;
          }
      const isEmptySpace = e.target === svg || e.target === viewport || e.target.tagName === "svg";
      const isEdgeElement = e.target.closest('.edge') || e.target.classList.contains('edge-edit-point');
      const isTextElement = e.target.closest('.text-group') || e.target.closest('.text-element');
      const isRectElement = e.target.closest('.rect-group');
      if (!isEdgeElement && !isTextElement && !isRectElement && currentEdgeId) {
      currentEdgeId = null;
      forgeTheTopology();
      }
      if (!isRectElement && currentRectId) {
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      }
          if (isEmptySpace && e.touches.length === 1) {
           e.preventDefault();
           emptyTapMoved = false;
           emptyTapStartX = e.touches[0].clientX;
           emptyTapStartY = e.touches[0].clientY;
           canvasState.isPanning = true;
           canvasState.panStartX = e.touches[0].clientX;
           canvasState.panStartY = e.touches[0].clientY;
           panStartViewX = canvasState.panX;
           panStartViewY = canvasState.panY;
           viewport.classList.add("panning");
          }
         }, {
          passive: false
         }, );
        document.addEventListener("mousemove", (e) => {
         if (isSelecting) {
          updateSelection(e);
          return;
         }
         if (!canvasState.isPanning) return;
         const dx = e.clientX - canvasState.panStartX;
         const dy = e.clientY - canvasState.panStartY;
         const rect = viewport.getBoundingClientRect();
         const viewWidth = CANVAS_WIDTH / canvasState.zoom;
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         const canvasDx = (dx / rect.width) * viewWidth;
         const canvasDy = (dy / rect.height) * viewHeight;
         canvasState.panX = panStartViewX - canvasDx;
         canvasState.panY = panStartViewY - canvasDy;
         constrainPan();
         updateViewBox();
        });
       document.addEventListener("touchmove", (e) => {
        if (!canvasState.isPanning || !e.touches[0]) return;
        const moveDx = Math.abs(e.touches[0].clientX - emptyTapStartX);
        const moveDy = Math.abs(e.touches[0].clientY - emptyTapStartY);
        if (moveDx > 15 || moveDy > 15) {
         emptyTapMoved = true;
        }
        const dx = e.touches[0].clientX - canvasState.panStartX;
         const dy = e.touches[0].clientY - canvasState.panStartY;
         const rect = viewport.getBoundingClientRect();
         const viewWidth = CANVAS_WIDTH / canvasState.zoom;
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         const canvasDx = (dx / rect.width) * viewWidth;
         const canvasDy = (dy / rect.height) * viewHeight;
         canvasState.panX = panStartViewX - canvasDx;
         canvasState.panY = panStartViewY - canvasDy;
         constrainPan();
         updateViewBox();
        });
        document.addEventListener("mouseup", () => {
         if (isSelecting) {
          endSelection();
         }
         if (canvasState.isPanning) {
          canvasState.isPanning = false;
          viewport.classList.remove("panning");
         }
        });
        document.addEventListener("touchend", () => {
         if (canvasState.isPanning) {
          canvasState.isPanning = false;
          viewport.classList.remove("panning");
         }
        });
        document.addEventListener("keydown", (e) => {
         const isEditing = document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "TEXTAREA" || document.activeElement.isContentEditable;
         if (e.code === "Space" && !e.repeat && !isEditing) {
          e.preventDefault();
          canvasState.spacePressed = true;
          viewport.style.cursor = "grab";
         }
        });
        document.addEventListener("keyup", (e) => {
         if (e.code === "Space") {
          canvasState.spacePressed = false;
          viewport.style.cursor = "";
         }
        });
        document.getElementById("zoom-in-btn").addEventListener("click", () => {
         zoomTo(canvasState.zoom * 1.25, 0.5, 0.5);
        });
        document.getElementById("zoom-out-btn").addEventListener("click", () => {
         zoomTo(canvasState.zoom * 0.8, 0.5, 0.5);
        });
        document.getElementById("zoom-fit-btn").addEventListener("click", fitToContent);
        document.getElementById("zoom-reset-btn").addEventListener("click", resetView);
        const minimapContainer = document.getElementById("minimap-container");
        const minimapSvg = document.getElementById("minimap");
        let minimapDragging = false;
        minimapContainer.addEventListener("mousedown", (e) => {
         e.preventDefault();
         minimapDragging = true;
         updatePanFromMinimap(e);
        });
        minimapContainer.addEventListener("touchstart",
         (e) => {
          e.preventDefault();
          minimapDragging = true;
          updatePanFromMinimapTouch(e);
         }, {
          passive: false
         }, );
        document.addEventListener("mousemove", (e) => {
         if (minimapDragging) {
          updatePanFromMinimap(e);
         }
        });
        document.addEventListener("touchmove", (e) => {
         if (minimapDragging && e.touches[0]) {
          updatePanFromMinimapTouch(e);
         }
        });
        document.addEventListener("mouseup", () => {
         minimapDragging = false;
        });
        document.addEventListener("touchend", () => {
         minimapDragging = false;
        });
        function updatePanFromMinimap(e) {
         const rect = minimapContainer.getBoundingClientRect();
         const x = (e.clientX - rect.left) / rect.width;
         const y = (e.clientY - rect.top) / rect.height;
         const viewWidth = CANVAS_WIDTH / canvasState.zoom;
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         canvasState.panX = x * CANVAS_WIDTH - viewWidth / 2;
         canvasState.panY = y * CANVAS_HEIGHT - viewHeight / 2;
         constrainPan();
         updateViewBox();
        }
        function updatePanFromMinimapTouch(e) {
         const rect = minimapContainer.getBoundingClientRect();
         const touch = e.touches[0];
         const x = (touch.clientX - rect.left) / rect.width;
         const y = (touch.clientY - rect.top) / rect.height;
         const viewWidth = CANVAS_WIDTH / canvasState.zoom;
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         canvasState.panX = x * CANVAS_WIDTH - viewWidth / 2;
         canvasState.panY = y * CANVAS_HEIGHT - viewHeight / 2;
         constrainPan();
         updateViewBox();
        }
        document.addEventListener("keydown", (e) => {
         if (document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "TEXTAREA") return;
         if (
          (e.key === "+" || e.key === "=") && (e.ctrlKey || e.metaKey)) {
          e.preventDefault();
          zoomTo(canvasState.zoom * 1.25, 0.5, 0.5);
         } else if (e.key === "-" && (e.ctrlKey || e.metaKey)) {
          e.preventDefault();
          zoomTo(canvasState.zoom * 0.8, 0.5, 0.5);
         } else if (e.key === "0" && (e.ctrlKey || e.metaKey)) {
          e.preventDefault();
          resetView();
         }
        });
        setTimeout(() => {
         fitToContent();
        }, 100);
       })();
       const sizeSlider = document.getElementById("size-slider");
       const sizeValue = document.getElementById("size-value");
       const resetSizeBtn = document.getElementById("reset-size");
       sizeSlider.addEventListener("input", () => {
        const newSize = parseInt(sizeSlider.value, 10);
        sizeValue.textContent = newSize;
        pushUndo("resize node");
        savedSizes[currentNodeId] = newSize;
        const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
        if (nodeGroup) {
         const oldShape = nodeGroup.querySelector(".node-circle");
         if (oldShape) oldShape.remove();
         const newShape = createNodeShape(currentNodeId, newSize);
         nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
         const styles = resolveStylesForNode(currentNodeId);
         if (styles.circleColor) newShape.style.fill = styles.circleColor;
      if (styles.circleBorder) newShape.style.stroke = styles.circleBorder;
         const label = nodeGroup.querySelector(".node-label");
         const sub = nodeGroup.querySelector(".node-sub");
         if (label) {
          label.setAttribute("y", -newSize * 0.28);
          const labelSize = styles.titleSize || newSize * 0.33;
          label.style.fontSize = labelSize + "px";
         }
         if (sub) {
          sub.setAttribute("y", newSize * 0.4);
          const subSize = styles.subSize || newSize * 0.24;
          sub.style.fontSize = subSize + "px";
         }
       updatePingIndicator(currentNodeId);
        }
       });
       resetSizeBtn.addEventListener("click", () => {
        pushUndo("reset size");
        delete savedSizes[currentNodeId];
        const defaultSize = getDefaultSize();
        sizeSlider.value = defaultSize;
        sizeValue.textContent = defaultSize;
        const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
        if (nodeGroup) {
         const oldShape = nodeGroup.querySelector(".node-circle");
         if (oldShape) oldShape.remove();
         const shapeType = (NODE_DATA[currentNodeId] && NODE_DATA[currentNodeId].shape) || "circle";
         const newShape = createNodeShape(currentNodeId, defaultSize);
         nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
         const styles = resolveStylesForNode(currentNodeId);
         if (styles.circleColor) newShape.style.fill = styles.circleColor;
      if (styles.circleBorder) newShape.style.stroke = styles.circleBorder;
         const label = nodeGroup.querySelector(".node-label");
         const sub = nodeGroup.querySelector(".node-sub");
         if (label) {
          label.setAttribute("y", -defaultSize * 0.28);
          const labelSize = styles.titleSize || defaultSize * 0.33;
          label.style.fontSize = labelSize + "px";
         }
         if (sub) {
          sub.setAttribute("y", defaultSize * 0.4);
          const subSize = styles.subSize || defaultSize * 0.24;
          sub.style.fontSize = subSize + "px";
         }
          updatePingIndicator(currentNodeId);
        }
       });
       const applyStyle = (property, value) => {
        pushUndo("style change");
        const styleEntry = ensureStyleEntry(currentNodeId);
        const scopeKey = currentStyleScope || "all";
        if (!styleEntry[scopeKey]) styleEntry[scopeKey] = {};
        styleEntry[scopeKey][property] = value;
        const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
        if (!nodeGroup) return;
        const shapeEl = nodeGroup.querySelector(".node-circle");
        const label = nodeGroup.querySelector(".node-label");
        const sub = nodeGroup.querySelector(".node-sub");
        const isWebIcon = shapeEl && shapeEl.querySelector('svg');
        if (property === "circleColor" && shapeEl) {
         if (isWebIcon) {
          shapeEl.querySelectorAll('svg, path, circle, rect, polygon, ellipse').forEach(el => el.style.fill = value);
         } else {
          shapeEl.style.fill = value;
         }
        } else if (property === "circleBorder" && shapeEl) {
         if (isWebIcon) {
          shapeEl.querySelectorAll('svg, path, circle, rect, polygon, ellipse').forEach(el => el.style.stroke = value);
         } else {
          shapeEl.style.stroke = value;
         }
        } else if (property === "titleColor" && label) label.style.fill = value;
        else if (property === "titleFont" && label) label.style.fontFamily = value;
        else if (property === "titleSize" && label) label.style.fontSize = value + "px";
        else if (property === "subColor" && sub) sub.style.fill = value;
        else if (property === "subFont" && sub) sub.style.fontFamily = value;
        else if (property === "subSize" && sub) sub.style.fontSize = value + "px";
       };
       document.getElementById("circle-color").addEventListener("input", (e) => applyStyle("circleColor", e.target.value), );
      document.getElementById("circle-border").addEventListener("input", (e) => applyStyle("circleBorder", e.target.value), );
       document.getElementById("title-color").addEventListener("input", (e) => applyStyle("titleColor", e.target.value), );
       document.getElementById("title-font").addEventListener("change", (e) => applyStyle("titleFont", e.target.value), );
       document.getElementById("title-size").addEventListener("input", (e) => applyStyle("titleSize", parseInt(e.target.value, 10)), );
       document.getElementById("sub-color").addEventListener("input", (e) => applyStyle("subColor", e.target.value), );
       document.getElementById("sub-font").addEventListener("change", (e) => applyStyle("subFont", e.target.value), );
       document.getElementById("sub-size").addEventListener("input", (e) => applyStyle("subSize", parseInt(e.target.value, 10)), );
       document.getElementById("title-offset-y").addEventListener("input", (e) => {
        applyStyle("titleOffsetY", parseInt(e.target.value, 10) || 0);
        forgeTheTopology();
        if (currentNodeId) claimTheImmortal(currentNodeId);
       });
       document.getElementById("title-offset-x").addEventListener("input", (e) => {
        applyStyle("titleOffsetX", parseInt(e.target.value, 10) || 0);
        forgeTheTopology();
        if (currentNodeId) claimTheImmortal(currentNodeId);
       });
       document.getElementById("sub-offset-y").addEventListener("input", (e) => {
        applyStyle("subOffsetY", parseInt(e.target.value, 10) || 0);
        forgeTheTopology();
        if (currentNodeId) claimTheImmortal(currentNodeId);
       });
       document.getElementById("sub-offset-x").addEventListener("input", (e) => {
        applyStyle("subOffsetX", parseInt(e.target.value, 10) || 0);
        forgeTheTopology();
        if (currentNodeId) claimTheImmortal(currentNodeId);
       });
      document.getElementById("ping-offset-x").addEventListener("input", (e) => {
      applyStyle("pingOffsetX", parseInt(e.target.value, 10) || 0);
      updatePingIndicator(currentNodeId);
      if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      document.getElementById("ping-offset-y").addEventListener("input", (e) => {
      applyStyle("pingOffsetY", parseInt(e.target.value, 10) || 0);
      updatePingIndicator(currentNodeId);
      if (currentNodeId) claimTheImmortal(currentNodeId);
      });
       document.getElementById("reset-styles").addEventListener("click", () => {
        delete savedStyles[currentNodeId];
        forgeTheTopology();
        claimTheImmortal(currentNodeId);
       });
       document.getElementById("style-scope").addEventListener("change", (e) => {
        currentStyleScope = e.target.value || "all";
        claimTheImmortal(currentNodeId);
       });
       document.getElementById("shape-select").addEventListener("change", (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId]) return;
        const shape = e.target.value || "circle";
        if (shape === 'custom-icon') return;
        pushUndo("change shape");
        NODE_DATA[currentNodeId].shape = shape;
        if (savedStyles[currentNodeId]) {
         Object.keys(savedStyles[currentNodeId]).forEach(scope => {
          if (savedStyles[currentNodeId][scope] && savedStyles[currentNodeId][scope].icon) {
           delete savedStyles[currentNodeId][scope].icon;
          }
         });
        }
        const customOpt = e.target.querySelector('option[value="custom-icon"]');
        if (customOpt) customOpt.remove();
        forgeTheTopology();
       });
       const addNoteBtn = document.getElementById("add-note-btn");
       const noteInput = document.getElementById("new-note-input");
       addNoteBtn.addEventListener("click", () => {
        const newNote = noteInput.value.trim();
        if (newNote && currentNodeId && NODE_DATA[currentNodeId]) {
         pushUndo("add note");
         NODE_DATA[currentNodeId].notes.push(newNote);
         claimTheImmortal(currentNodeId);
         noteInput.value = "";
        }
       });
       noteInput.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
         addNoteBtn.click();
        }
       });
       document.getElementById('node-pingable').addEventListener('change', (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId]) return;
        if (!NODE_DATA[currentNodeId].ping) {
         NODE_DATA[currentNodeId].ping = {
          enabled: false,
          protocol: 'http',
          customUrl: '',
          timeout: 3000,
          status: 'unknown',
          lastCheck: null
         };
        }
        NODE_DATA[currentNodeId].ping.enabled = e.target.checked;
        document.getElementById('node-ping-options').style.display = e.target.checked ? 'block' : 'none';
        forgeTheTopology();
       });
       document.getElementById('node-ping-protocol').addEventListener('change', (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId].ping) return;
        NODE_DATA[currentNodeId].ping.protocol = e.target.value;
        document.getElementById('node-custom-url-container').style.display =
         e.target.value === 'custom' ? 'block' : 'none';
       });
       document.getElementById('node-custom-url').addEventListener('change', (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId].ping) return;
        NODE_DATA[currentNodeId].ping.customUrl = e.target.value.trim();
       });
       document.getElementById('node-ping-timeout').addEventListener('change', (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId].ping) return;
        NODE_DATA[currentNodeId].ping.timeout = parseInt(e.target.value) || 3000;
       });
       document.getElementById('check-ping-now').addEventListener('click', () => {
        if (!currentNodeId) return;
        checkNodeStatus(currentNodeId);
       });
       document.getElementById("edge-width").addEventListener("input", () => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        const v = parseInt(document.getElementById("edge-width").value, 10);
        if (Number.isNaN(v) || v <= 0) return;
        pushUndo("edit edge");
        edge.width = v;
        const el = document.querySelector(`.edge[data-edge-id="${currentEdgeId}"]`, );
        if (el) el.style.strokeWidth = v;
       });
       document.getElementById("edge-color").addEventListener("input", () => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        const color = document.getElementById("edge-color").value;
        pushUndo("edit edge");
        edge.color = color;
        const el = document.querySelector(`.edge[data-edge-id="${currentEdgeId}"]`, );
        if (el) el.style.stroke = color;
        forgeTheLegend();
       });
       document.getElementById("edge-direction").addEventListener("change", () => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        pushUndo("edit edge");
        edge.direction = document.getElementById("edge-direction").value;
        forgeTheTopology();
        selectTheConnection(currentEdgeId);
       });
       document.getElementById("edge-line-style").addEventListener("change", () => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        pushUndo("edit edge");
        edge.lineStyle = document.getElementById("edge-line-style").value;
        forgeTheTopology();
        selectTheConnection(currentEdgeId);
       });
       const addEdgeNoteBtn = document.getElementById("add-edge-note");
       const newEdgeNoteInput = document.getElementById("new-edge-note");
       addEdgeNoteBtn.addEventListener("click", () => {
        const txt = newEdgeNoteInput.value.trim();
        if (!txt || !currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
		pushUndo("add edge note");
        edge.notes.push(txt);
        newEdgeNoteInput.value = "";
        selectTheConnection(currentEdgeId);
       });
       newEdgeNoteInput.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
         addEdgeNoteBtn.click();
        }
       });
      function selectTheRect(id) {
	  if (isViewOnly()) return;
      currentRectId = id;
      currentNodeId = null;
      currentEdgeId = null;
      currentTextId = null;
      document.getElementById("node-panel").style.display = "none";
      document.getElementById("edge-panel").style.display = "none";
      document.getElementById("text-panel").style.display = "none";
      document.getElementById("rect-panel").style.display = "block";
      document.getElementById("topology-toolbar").style.display = "none";
      document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active"));
      document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
      document.querySelectorAll(".text-element").forEach(t => t.classList.remove("active"));
      document.querySelectorAll(".rect-group").forEach(r => r.classList.toggle("active", r.dataset.rectId === id));
      const rect = RECT_DATA.list.find(r => r.id === id);
      if (!rect) return;
      document.getElementById("rect-title").textContent = "";
      document.getElementById("rect-color").value = rect.color || "#f97316";
      document.getElementById("rect-border-color").value = rect.borderColor || rect.color || "#f97316";
      document.getElementById("rect-border-width").value = rect.borderWidth !== undefined ? rect.borderWidth : 2;
      document.getElementById("rect-style-select").value = rect.style || "filled";
      document.getElementById("rect-line-style").value = rect.lineStyle || "solid";
      document.getElementById("rect-fill-row").style.display = (rect.style === "outlined") ? "none" : "flex";
      const list = document.getElementById("rect-notes");
      list.innerHTML = "";
      (rect.notes || []).forEach((note, i) => {
      const li = document.createElement("li");
      const txt = document.createElement("span");
      txt.textContent = note;
      txt.style.flex = "1";
      const del = document.createElement("span");
      del.className = "delete-note";
      del.textContent = "‚úï";
      del.addEventListener("click", (e) => {
      e.stopPropagation();
      challengeTheImmortal("Delete this note?", () => {
        pushUndo("delete zone note");
        rect.notes.splice(i, 1);
        selectTheRect(id);
      });
      });
      li.appendChild(txt);
      li.appendChild(del);
      list.appendChild(li);
      });
      forgeTheTopology();
      }
      document.getElementById("rect-color").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.color = document.getElementById("rect-color").value;
      forgeTheTopology();
      });
      document.getElementById("rect-border-color").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.borderColor = document.getElementById("rect-border-color").value;
      forgeTheTopology();
      });
      document.getElementById("rect-border-width").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.borderWidth = parseInt(document.getElementById("rect-border-width").value) || 2;
      forgeTheTopology();
      });
      document.getElementById("rect-style-select").addEventListener("change", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.style = document.getElementById("rect-style-select").value;
      forgeTheTopology();
      selectTheRect(currentRectId);
      });
	  document.getElementById("rect-line-style").addEventListener("change", () => {
      if (!currentRectId) return;
      pushUndo("change zone line style");
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      rect.lineStyle = document.getElementById("rect-line-style").value;
      forgeTheTopology();
      });
      document.getElementById("add-rect-note").addEventListener("click", () => {
      const input = document.getElementById("new-rect-note");
      const txt = input.value.trim();
      if (!txt || !currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      if (!rect.notes) rect.notes = [];
	  pushUndo("add zone note");
      rect.notes.push(txt);
      input.value = "";
      selectTheRect(currentRectId);
      });
      document.getElementById("new-rect-note").addEventListener("keypress", (e) => {
      if (e.key === "Enter") {
      document.getElementById("add-rect-note").click();
      }
      });
      document.getElementById("delete-rect").addEventListener("click", () => {
      if (!currentRectId) return;
      challengeTheImmortal("Delete this box?", () => {
      pushUndo("delete zone");
      RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== currentRectId);
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      });
      });
       document.getElementById("delete-edge").addEventListener("click", () => {
        if (!currentEdgeId) return;
        challengeTheImmortal("Are you sure you want to delete this line?",
         () => {
          pushUndo("delete edge");
          EDGE_DATA.list = EDGE_DATA.list.filter(
           (e) => e.id !== currentEdgeId, );
          currentEdgeId = null;
          forgeTheTopology();
          const availableNodes = Object.keys(NODE_DATA);
          if (availableNodes.length > 0) {
           claimTheImmortal(availableNodes[0]);
          } else {
           document.getElementById("node-panel").style.display = "none";
           document.getElementById("edge-panel").style.display = "none";
           document.getElementById("topology-toolbar", ).style.display = "none";
          }
         }, );
       });
       document.getElementById("add-line-btn").addEventListener("click", () => {
        if (!currentNodeId) return;
        const select = document.getElementById("add-line-select");
        const directionSelect = document.getElementById("add-line-direction");
        const colorInput = document.getElementById("add-line-color");
        const targetId = select.value;
        if (!targetId || targetId === currentNodeId) return;
        const direction = directionSelect.value || "none";
        const lineColor = colorInput.value || "#475569";
        const newId = `${currentNodeId}-${targetId}-${Date.now()}`;
        const newEdge = {
         id: newId,
         from: currentNodeId,
         to: targetId,
         width: 4,
         color: lineColor,
         direction: direction,
         type: "main",
         notes: [],
         fromPort: "",
         toPort: "",
        };
		pushUndo("add edge");
        EDGE_DATA.list.push(newEdge);
        forgeTheTopology();
        claimTheImmortal(currentNodeId);
       });
       let rectStartPoint = null;
       let rectPreviewEl = null;
       let rectStyle = "filled";
       let freeDrawPoints = [];
       let freeDrawPolylineEl = null;
       let freeDrawPointEls = [];
       const drawToggleBtn = document.getElementById("draw-toggle");
       const drawUndoBtn = document.getElementById("draw-undo");
       const drawColorInput = document.getElementById("draw-color");
       const drawStyleSelect = document.getElementById("draw-style");
       const drawArrowSelect = document.getElementById("draw-arrow");
       const svgMap = document.getElementById("map");
       function updateFreeDrawGraphics() {
        const ns = "http://www.w3.org/2000/svg";
        const svg = svgMap;
        if (!freeDrawPolylineEl && freeDrawPoints.length > 0) {
         freeDrawPolylineEl = document.createElementNS(ns, "polyline");
         freeDrawPolylineEl.classList.add("edge", "free-preview");
         freeDrawPolylineEl.setAttribute("fill", "none");
         svg.appendChild(freeDrawPolylineEl);
        }
        if (freeDrawPolylineEl) {
         if (freeDrawPoints.length === 0) {
          freeDrawPolylineEl.remove();
          freeDrawPolylineEl = null;
         } else {
          const ptsStr = freeDrawPoints.map((p) => `${p.x},${p.y}`).join(" ");
          freeDrawPolylineEl.setAttribute("points", ptsStr);
          freeDrawPolylineEl.style.stroke = drawColorInput.value || "#475569";
          freeDrawPolylineEl.style.strokeWidth = 3;
          const lineStyle = drawStyleSelect.value || "solid";
          if (lineStyle === "dashed") {
           freeDrawPolylineEl.style.strokeDasharray = "10,5";
          } else if (lineStyle === "dotted") {
           freeDrawPolylineEl.style.strokeDasharray = "2,4";
          } else {
           freeDrawPolylineEl.style.strokeDasharray = "none";
          }
         }
        }
        freeDrawPointEls.forEach((el) => el.remove());
        freeDrawPointEls = [];
        freeDrawPoints.forEach((p, idx) => {
         const c = document.createElementNS(ns, "circle");
         c.classList.add("free-point");
         c.setAttribute("cx", p.x);
         c.setAttribute("cy", p.y);
         c.setAttribute("r", 5);
         c.dataset.index = String(idx);
         c.addEventListener("mousedown", (e) => {
          if (!freeDrawMode) return;
          e.preventDefault();
          e.stopPropagation();
          let dragging = true;
          const svgEl = svgMap;
          const moveHandler = (ev) => {
           if (!dragging) return;
           const pt = svgEl.createSVGPoint();
           pt.x = ev.clientX;
           pt.y = ev.clientY;
           const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
           const i = parseInt(c.dataset.index, 10);
           if (Number.isNaN(i) || !freeDrawPoints[i]) return;
           freeDrawPoints[i].x = svgP.x;
           freeDrawPoints[i].y = svgP.y;
           updateFreeDrawGraphics();
          };
          const upHandler = () => {
           dragging = false;
           document.removeEventListener("mousemove", moveHandler);
           document.removeEventListener("mouseup", upHandler);
          };
          document.addEventListener("mousemove", moveHandler);
          document.addEventListener("mouseup", upHandler);
         });
         c.addEventListener("touchstart",
          (e) => {
           if (!freeDrawMode) return;
           e.preventDefault();
           e.stopPropagation();
           let dragging = true;
           const svgEl = svgMap;
           const touchMoveHandler = (ev) => {
            if (!dragging || !ev.touches[0]) return;
            const pt = svgEl.createSVGPoint();
            pt.x = ev.touches[0].clientX;
            pt.y = ev.touches[0].clientY;
            const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
            const i = parseInt(c.dataset.index, 10);
            if (Number.isNaN(i) || !freeDrawPoints[i]) return;
            freeDrawPoints[i].x = svgP.x;
            freeDrawPoints[i].y = svgP.y;
            updateFreeDrawGraphics();
           };
           const touchUpHandler = () => {
            dragging = false;
            document.removeEventListener("touchmove", touchMoveHandler, );
            document.removeEventListener("touchend", touchUpHandler, );
           };
           document.addEventListener("touchmove", touchMoveHandler);
           document.addEventListener("touchend", touchUpHandler);
          }, {
           passive: false
          }, );
         svg.appendChild(c);
         freeDrawPointEls.push(c);
        });
        drawUndoBtn.style.display = freeDrawPoints.length ? "inline-block" : "none";
       }
       function addFreeDrawPoint(x, y) {
        freeDrawPoints.push({
         x,
         y
        });
        updateFreeDrawGraphics();
       }
       function startFreeDraw() {
        freeDrawMode = true;
        freeDrawPoints = [];
        if (freeDrawPolylineEl) {
         freeDrawPolylineEl.remove();
         freeDrawPolylineEl = null;
        }
        freeDrawPointEls.forEach((el) => el.remove());
        freeDrawPointEls = [];
        svgMap.style.cursor = "crosshair";
        drawToggleBtn.textContent = "Done";
        drawUndoBtn.style.display = "none";
       }
       function finishFreeDraw() {
        freeDrawMode = false;
        svgMap.style.cursor = "";
        drawToggleBtn.textContent = "‚úèÔ∏è";
        if (freeDrawPoints.length >= 2) {
         const color = drawColorInput.value || "#475569";
         const lineStyle = drawStyleSelect.value || "solid";
         const arrowDir = drawArrowSelect.value || "none";
         const newId = "custom-" + Date.now();
         const pointsCopy = freeDrawPoints.map((p) => ({
          x: p.x,
          y: p.y,
         }));
         EDGE_DATA.list.push({
          id: newId,
          type: "custom",
          color,
          width: 4,
          lineStyle: lineStyle,
          direction: arrowDir,
          points: pointsCopy,
          notes: [],
         });
         freeDrawPoints = [];
         if (freeDrawPolylineEl) {
          freeDrawPolylineEl.remove();
          freeDrawPolylineEl = null;
         }
         freeDrawPointEls.forEach((el) => el.remove());
         freeDrawPointEls = [];
         forgeTheTopology();
         selectTheConnection(newId);
        } else {
         freeDrawPoints = [];
         if (freeDrawPolylineEl) {
          freeDrawPolylineEl.remove();
          freeDrawPolylineEl = null;
         }
         freeDrawPointEls.forEach((el) => el.remove());
         freeDrawPointEls = [];
         forgeTheLegend();
        }
        drawUndoBtn.style.display = "none";
       }
       drawToggleBtn.addEventListener("click", () => {
        if (currentView.mode === "rack") {
         alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
         return;
        }
        if (freeDrawMode) {
         finishFreeDraw();
        } else {
         startFreeDraw();
        }
       });
       drawUndoBtn.addEventListener("click", () => {
        if (!freeDrawMode || !freeDrawPoints.length) return;
        freeDrawPoints.pop();
        updateFreeDrawGraphics();
       });
       const drawToolbar = document.getElementById("draw-toolbar");
       drawToolbar.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       drawToolbar.addEventListener("click", (e) => {
        if (e.target !== drawToggleBtn && e.target !== drawUndoBtn) {
         e.stopPropagation();
        }
       });
       drawStyleSelect.addEventListener("change", () => {
        if (freeDrawMode) {
         updateFreeDrawGraphics();
        }
       });
       drawArrowSelect.addEventListener("change", () => {
        if (freeDrawMode) {
         updateFreeDrawGraphics();
        }
       });
       drawColorInput.addEventListener("input", () => {
        if (freeDrawMode) {
         updateFreeDrawGraphics();
        }
       });
       drawStyleSelect.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       drawStyleSelect.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       drawArrowSelect.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       drawArrowSelect.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       drawColorInput.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       drawColorInput.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       svgMap.addEventListener("click", (e) => {
        if (!freeDrawMode) return;
        if (e.button !== 0) return;
        const target = e.target;
        if (target && target.classList && target.classList.contains("free-point")) return;
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        addFreeDrawPoint(svgP.x, svgP.y);
       });
       svgMap.addEventListener("touchend",
        (e) => {
         if (!freeDrawMode) return;
         const target = e.target;
         if (target && target.classList && target.classList.contains("free-point")) return;
         if (e.changedTouches && e.changedTouches[0]) {
          e.preventDefault();
          const svgEl = svgMap;
          const pt = svgEl.createSVGPoint();
          pt.x = e.changedTouches[0].clientX;
          pt.y = e.changedTouches[0].clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          addFreeDrawPoint(svgP.x, svgP.y);
         }
        }, {
         passive: false
        }, );
       const settingsBtn = document.getElementById("settings-btn");
       const rectToggleBtn = document.getElementById("rect-toggle");
       const rectStyleSelect = document.getElementById("rect-style");
       function updateRectPreview() {
        if (!rectPreviewEl || !rectStartPoint) return;
        const ns = "http://www.w3.org/2000/svg";
        const svg = svgMap;
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
       }
       function startRectDraw() {
        rectDrawMode = true;
        rectStartPoint = null;
        rectPreviewEl = null;
        svgMap.style.cursor = "crosshair";
        rectToggleBtn.textContent = "Done";
        rectStyle = rectStyleSelect.value || "filled";
        if (freeDrawMode) {
         finishFreeDraw();
        }
        updateRectangleDeleteButtons();
       }
       function finishRectDraw() {
        rectDrawMode = false;
        svgMap.style.cursor = "";
        rectToggleBtn.textContent = "‚ñ≠";
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
		updateRectangleDeleteButtons();
       }
       rectToggleBtn.addEventListener("click", () => {
        if (currentView.mode === "rack") {
         alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
         return;
        }
        if (rectDrawMode) {
         finishRectDraw();
        } else {
         startRectDraw();
        }
       });
       rectStyleSelect.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       rectStyleSelect.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       rectStyleSelect.addEventListener("change", () => {
        if (rectDrawMode) {
         rectStyle = rectStyleSelect.value || "filled";
        }
       });
       svgMap.addEventListener("mousedown", (e) => {
        if (!rectDrawMode) return;
        if (e.button !== 0) return;
        e.preventDefault();
        e.stopPropagation();
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        rectStartPoint = { x: svgP.x, y: svgP.y };
        const ns = "http://www.w3.org/2000/svg";
        rectPreviewEl = document.createElementNS(ns, "rect");
        rectPreviewEl.classList.add("rect-preview");
        rectPreviewEl.setAttribute("x", svgP.x);
        rectPreviewEl.setAttribute("y", svgP.y);
        rectPreviewEl.setAttribute("width", 0);
        rectPreviewEl.setAttribute("height", 0);
        const color = drawColorInput.value || "#f97316";
        rectPreviewEl.style.stroke = color;
        rectPreviewEl.style.strokeWidth = 2;
        rectPreviewEl.style.strokeDasharray = "5,5";
        if (rectStyle === "filled") {
         rectPreviewEl.style.fill = color;
         rectPreviewEl.style.fillOpacity = "0.3";
        } else {
         rectPreviewEl.style.fill = "none";
        }
        svgEl.appendChild(rectPreviewEl);
       });
       svgMap.addEventListener("mousemove", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        rectPreviewEl.setAttribute("x", x);
        rectPreviewEl.setAttribute("y", y);
        rectPreviewEl.setAttribute("width", width);
        rectPreviewEl.setAttribute("height", height);
       });
       svgMap.addEventListener("mouseup", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        if (width > 10 && height > 10) {
      pushUndo("draw zone");
         const color = drawColorInput.value || "#f97316";
         const newId = "rect-" + Date.now();
         const lineStyle = document.getElementById("draw-style").value || "solid";
         RECT_DATA.list.push({
          id: newId,
          x: x,
          y: y,
          width: width,
          height: height,
          color: color,
          style: rectStyle,
          lineStyle: lineStyle,
          notes: []
         });
         forgeTheTopology();
        }
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
       });
       let rectTouchStart = null;
       svgMap.addEventListener("touchstart", (e) => {
        if (!rectDrawMode) return;
        if (e.touches.length !== 1) return;
        e.preventDefault();
        const touch = e.touches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        rectStartPoint = { x: svgP.x, y: svgP.y };
        rectTouchStart = { x: svgP.x, y: svgP.y };
        const ns = "http://www.w3.org/2000/svg";
        rectPreviewEl = document.createElementNS(ns, "rect");
        rectPreviewEl.classList.add("rect-preview");
        rectPreviewEl.setAttribute("x", svgP.x);
        rectPreviewEl.setAttribute("y", svgP.y);
        rectPreviewEl.setAttribute("width", 0);
        rectPreviewEl.setAttribute("height", 0);
        const color = drawColorInput.value || "#f97316";
        rectPreviewEl.style.stroke = color;
        rectPreviewEl.style.strokeWidth = 2;
        rectPreviewEl.style.strokeDasharray = "5,5";
        if (rectStyle === "filled") {
         rectPreviewEl.style.fill = color;
         rectPreviewEl.style.fillOpacity = "0.3";
        } else {
         rectPreviewEl.style.fill = "none";
        }
        svgEl.appendChild(rectPreviewEl);
       }, { passive: false });
       svgMap.addEventListener("touchmove", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        if (e.touches.length !== 1) return;
        e.preventDefault();
        const touch = e.touches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        rectPreviewEl.setAttribute("x", x);
        rectPreviewEl.setAttribute("y", y);
        rectPreviewEl.setAttribute("width", width);
        rectPreviewEl.setAttribute("height", height);
       }, { passive: false });
       svgMap.addEventListener("touchend", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        if (!rectTouchStart) return;
        e.preventDefault();
        const touch = e.changedTouches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        if (width > 10 && height > 10) {
      pushUndo("draw zone");
         const color = drawColorInput.value || "#f97316";
         const newId = "rect-" + Date.now();
         const lineStyle = document.getElementById("draw-style").value || "solid";
         RECT_DATA.list.push({
          id: newId,
          x: x,
          y: y,
          width: width,
          height: height,
          color: color,
          style: rectStyle,
          lineStyle: lineStyle,
          notes: []
         });
         forgeTheTopology();
        }
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
        rectTouchStart = null;
       }, { passive: false });
       const textToggleBtn = document.getElementById("text-toggle");
       function startTextMode() {
        textDrawMode = true;
        svgMap.style.cursor = "crosshair";
        textToggleBtn.textContent = "Done";
        textToggleBtn.style.background = "var(--accent)";
        textToggleBtn.style.color = "var(--bg)";
        if (freeDrawMode) {
         finishFreeDraw();
        }
        if (rectDrawMode) {
         finishRectDraw();
        }
        updateTextDeleteButtons();
       }
       function finishTextMode() {
        textDrawMode = false;
        svgMap.style.cursor = "";
        textToggleBtn.textContent = "T";
        textToggleBtn.style.background = "";
        textToggleBtn.style.color = "";
        updateTextDeleteButtons();
       }
       textToggleBtn.addEventListener("click", () => {
        if (currentView.mode === "rack") {
         alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
         return;
        }
        if (textDrawMode) {
         finishTextMode();
        } else {
         startTextMode();
        }
       });
       function handleTextPlacement(e) {
        if (!textDrawMode) return;
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const newId = "text-" + Date.now();
      pushUndo("add text");
        TEXT_DATA.list.push({
         id: newId,
         x: svgP.x,
         y: svgP.y,
         content: "New Text",
         fontSize: 18,
         color: "#e2e8f0",
         fontWeight: "normal",
         fontStyle: "normal",
         textAlign: "start",
         textDecoration: "none",
         bgColor: "#000000",
         bgEnabled: false,
         opacity: 1
        });
        forgeTheTopology();
        showTextPanel(newId);
       }
       svgMap.addEventListener("click", (e) => {
        if (!textDrawMode) return;
        if (e.target.closest('.text-delete-btn')) return;
        if (e.target.closest('.text-group')) return;
        e.preventDefault();
        e.stopPropagation();
        handleTextPlacement(e);
       });
       svgMap.addEventListener("touchend", (e) => {
        if (!textDrawMode) return;
        if (e.target.closest('.text-delete-btn')) return;
        if (e.target.closest('.text-group')) return;
        if (e.touches.length > 0) return;
        e.preventDefault();
        const touch = e.changedTouches[0];
        const fakeEvent = {
         clientX: touch.clientX,
         clientY: touch.clientY,
         preventDefault: () => {},
         stopPropagation: () => {}
        };
        handleTextPlacement(fakeEvent);
       }, { passive: false });
       function showTextPanel(textId) {
	   if (isViewOnly()) return;
       currentTextId = textId;
       currentNodeId = null;
       currentEdgeId = null;
       currentRectId = null;
       const textItem = TEXT_DATA.list.find(t => t.id === textId);
       if (!textItem) return;
       document.getElementById("node-panel").style.display = "none";
       document.getElementById("edge-panel").style.display = "none";
       document.getElementById("rect-panel").style.display = "none";
       const textPanel = document.getElementById("text-panel");
       textPanel.style.display = "block";
       document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active"));
       document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
       document.querySelectorAll(".rect-group").forEach(r => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach(t => t.classList.toggle("active", t.dataset.textId === textId));
        document.getElementById("text-content").value = textItem.content;
        document.getElementById("text-font-size").value = textItem.fontSize;
        document.getElementById("text-color").value = textItem.color;
        document.getElementById("text-font-weight").value = textItem.fontWeight;
        document.getElementById("text-font-style").value = textItem.fontStyle;
        document.getElementById("text-align").value = textItem.textAlign;
        document.getElementById("text-decoration").value = textItem.textDecoration;
        document.getElementById("text-bg-color").value = textItem.bgColor;
        document.getElementById("text-bg-enabled").checked = textItem.bgEnabled;
        document.getElementById("text-opacity").value = textItem.opacity;
        document.getElementById("text-opacity-val").textContent = Math.round(textItem.opacity * 100) + "%";
       }
       function updateTextDeleteButtons() {
        const deleteButtons = document.querySelectorAll('.text-delete-btn');
        deleteButtons.forEach(btn => {
         btn.style.display = textDrawMode ? 'block' : 'none';
        });
       }
       function deleteText(textId) {
      pushUndo("delete text");
        TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== textId);
        forgeTheTopology();
        if (currentTextId === textId) {
         document.getElementById("text-panel").style.display = "none";
         currentTextId = null;
        }
       }
       document.getElementById("text-content").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
      pushUndo("edit text");
         textItem.content = e.target.value;
         forgeTheTopology();
        }
       });
       document.getElementById("text-font-size").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.fontSize = parseInt(e.target.value);
         forgeTheTopology();
        }
       });
       document.getElementById("text-color").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.color = e.target.value;
         forgeTheTopology();
        }
       });
       document.getElementById("text-font-weight").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.fontWeight = e.target.value;
         forgeTheTopology();
        }
       });
       document.getElementById("text-font-style").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.fontStyle = e.target.value;
         forgeTheTopology();
        }
       });
       document.getElementById("text-align").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.textAlign = e.target.value;
         forgeTheTopology();
        }
       });
        document.getElementById("text-decoration").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.textDecoration = e.target.value;
         forgeTheTopology();
        }
       });
       document.getElementById("text-bg-color").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.bgColor = e.target.value;
         forgeTheTopology();
        }
       });
       document.getElementById("text-bg-enabled").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.bgEnabled = e.target.checked;
         forgeTheTopology();
        }
       });
       document.getElementById("text-opacity").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.opacity = parseFloat(e.target.value);
         document.getElementById("text-opacity-val").textContent = Math.round(textItem.opacity * 100) + "%";
         forgeTheTopology();
        }
       });
       document.getElementById("delete-text").addEventListener("click", () => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         challengeTheImmortal(`Delete text "${(textItem.content || '').substring(0, 30)}..."?`, () => {
          deleteText(currentTextId);
         });
        }
       });
       const settingsModal = document.getElementById("settings-modal");
       const settingsClose = document.getElementById("settings-close");
       settingsBtn.addEventListener("click", () => {
       document.getElementById("page-bg-color").value = rgbaToHex(PAGE_STATE.background) || "#050608";
       document.getElementById("topbar-bg-color").value = rgbaToHex(PAGE_STATE.topbarBg) || "#0b0e13";
       document.getElementById("topbar-border-color").value = rgbaToHex(PAGE_STATE.topbarBorder) || "#1f2533";
       document.getElementById("panel-color").value = rgbaToHex(PAGE_STATE.panel) || "#0b0e13";
       document.getElementById("panel-alt-color").value = PAGE_STATE.panelAlt || "#10141b";
       document.getElementById("sidebar-bg-color").value = PAGE_STATE.sidebarBg || "#10141b";
       document.getElementById("btn-bg-color").value = PAGE_STATE.btnBg || "#0b0e13";
       document.getElementById("btn-text-color").value = PAGE_STATE.btnText || "#e2e8f0";
       document.getElementById("tag-fill-color").value = PAGE_STATE.tagFill || "#1e293b";
       document.getElementById("tag-text-color").value = PAGE_STATE.tagText || "#e2e8f0";
       document.getElementById("tag-border-color").value = PAGE_STATE.tagBorder || "#475569";
       document.getElementById("input-bg-color").value = PAGE_STATE.inputBg || "#0b0e13";
       document.getElementById("input-text-color").value = PAGE_STATE.inputText || "#e2e8f0";
	   document.getElementById("input-border-color").value = PAGE_STATE.inputBorder || "#1f2937";
       document.getElementById("input-font-family").value = PAGE_STATE.inputFont || "Inter, system-ui, sans-serif";
       document.getElementById("input-font-size").value = PAGE_STATE.inputFontSize || 14;
       document.getElementById("toolbar-bg-color").value = PAGE_STATE.toolbarBg || "#0f172a";
       document.getElementById("toolbar-border-color").value = PAGE_STATE.toolbarBorder || "#1f2937";
       document.getElementById("toolbar-text-color").value = PAGE_STATE.toolbarText || "#94a3b8";
       document.getElementById("toolbar-btn-bg-color").value = PAGE_STATE.toolbarBtnBg || "#0b0e13";
       document.getElementById("toolbar-btn-text-color").value = PAGE_STATE.toolbarBtnText || "#e2e8f0";
       document.getElementById("minimap-dots-color").value = PAGE_STATE.minimapDots || "#94a3b8";
       document.getElementById("canvas-hint-enabled").checked = PAGE_STATE.canvasHintEnabled !== false;
       document.getElementById("canvas-hint-bg-color").value = PAGE_STATE.canvasHintBg || "#0f172a";
       document.getElementById("canvas-hint-text-color").value = PAGE_STATE.canvasHintColor || "#94a3b8";
       document.getElementById("canvas-hint-text").value = PAGE_STATE.canvasHintText || "";
       document.getElementById("accent-color").value = rgbaToHex(PAGE_STATE.accent) || "#4fd1c5";
       document.getElementById("danger-color").value = rgbaToHex(PAGE_STATE.danger) || "#f56565";
       document.getElementById("text-main-color").value = rgbaToHex(PAGE_STATE.textMain) || "#e2e8f0";
       document.getElementById("text-soft-color").value = PAGE_STATE.textSoft || "#94a3b8";
       document.getElementById("node-fill-color").value = PAGE_STATE.nodeFill || "#1e293b";
       document.getElementById("node-stroke-color").value = PAGE_STATE.nodeStroke || "#475569";
       document.getElementById("node-title-color").value = PAGE_STATE.nodeTitle || "#e2e8f0";
       document.getElementById("node-sub-color").value = PAGE_STATE.nodeSub || "#94a3b8";
       document.getElementById("node-title-size").value = PAGE_STATE.nodeTitleSize || 18;
       document.getElementById("node-sub-size").value = PAGE_STATE.nodeSubSize || 13;
       document.getElementById("node-font-family").value = PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
       document.getElementById("default-edge-color").value = PAGE_STATE.defaultEdge || "#475569";
       document.getElementById("selection-handle-color").value = PAGE_STATE.selectionHandle || "#f59e0b";
       document.getElementById("selection-handle-size").value = PAGE_STATE.selectionHandleSize || 8;
       document.getElementById("group-indicator-color").value = PAGE_STATE.groupIndicator || "#4fd1c5";
       document.getElementById("canvas-gradient-top").value = PAGE_STATE.canvasGradientTop || "#1e2532";
       document.getElementById("canvas-gradient-bottom").value = PAGE_STATE.canvasGradientBottom || "#050608";
       document.getElementById("canvas-border-color").value = PAGE_STATE.canvasBorder || "#475569";
       document.getElementById("canvas-grid-color").value = PAGE_STATE.canvasGrid || "#475569";
       document.getElementById("canvas-grid-size").value = PAGE_STATE.canvasGridSize || 50;
       document.getElementById("rack-frame-fill").value = PAGE_STATE.rackFrameFill || "#0f172a";
       document.getElementById("rack-frame-stroke").value = PAGE_STATE.rackFrameStroke || "#4fd1c5";
       document.getElementById("rack-line-color").value = PAGE_STATE.rackLineColor || "#475569";
       document.getElementById("rack-text-color").value = PAGE_STATE.rackTextColor || "#4fd1c5";
        document.getElementById("auto-ping-enabled").checked = autoPingEnabled;
        document.getElementById("auto-ping-interval").value = autoPingInterval;
        document.getElementById("auto-ping-settings").style.display = autoPingEnabled ? 'block' : 'none';
        document.getElementById("view-only-mode").checked = PAGE_STATE.viewOnly === true;
        settingsModal.classList.add("active");
       });
       settingsClose.addEventListener("click", () => {
        settingsModal.classList.remove("active");
       });
	   document.getElementById("view-only-mode").addEventListener("change", (e) => {
       PAGE_STATE.viewOnly = e.target.checked;
       if (e.target.checked) {
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        document.getElementById("rect-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.setProperty('display', 'none', 'important');
        document.getElementById("draw-toolbar").style.setProperty('display', 'none', 'important');
        currentNodeId = null;
        currentEdgeId = null;
        currentRectId = null;
        currentTextId = null;
        selectedNodes.clear();
        selectedRects.clear();
        selectedTexts.clear();
        selectedEdges.clear();
        const bulkToolbar = document.getElementById("bulk-toolbar");
        const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active", "selected"));
        document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
        document.querySelectorAll(".rect-group").forEach(r => r.classList.remove("active"));
        document.querySelectorAll(".text-element").forEach(t => t.classList.remove("active"));
       }
       wieldThePower();
       if (!e.target.checked) {
        updateDrawToolbarVisibility();
        updateTopologyToolbarVisibility();
       }
       forgeTheTopology();
      });
       settingsModal.addEventListener("click", (e) => {
        if (e.target === settingsModal) {
         settingsModal.classList.remove("active");
        }
       });
       document.getElementById("page-bg-color").addEventListener("input", (e) => {
        PAGE_STATE.background = e.target.value;
        wieldThePower();
       });
       document.getElementById("topbar-bg-color").addEventListener("input", (e) => {
        PAGE_STATE.topbarBg = e.target.value;
        wieldThePower();
       });
       document.getElementById("topbar-border-color").addEventListener("input", (e) => {
        PAGE_STATE.topbarBorder = e.target.value;
        wieldThePower();
       });
       document.getElementById("panel-color").addEventListener("input", (e) => {
        PAGE_STATE.panel = e.target.value;
        wieldThePower();
       });
       document.getElementById("panel-alt-color").addEventListener("input", (e) => {
       PAGE_STATE.panelAlt = e.target.value;
       wieldThePower();
      });
      document.getElementById("sidebar-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.sidebarBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("btn-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.btnBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("btn-text-color").addEventListener("input", (e) => {
       PAGE_STATE.btnText = e.target.value;
       wieldThePower();
      });
      document.getElementById("tag-fill-color").addEventListener("input", (e) => {
       PAGE_STATE.tagFill = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("tag-text-color").addEventListener("input", (e) => {
       PAGE_STATE.tagText = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("tag-border-color").addEventListener("input", (e) => {
       PAGE_STATE.tagBorder = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("selection-fill-color").addEventListener("input", function() {
       selectionBoxStyle.fillColor = this.value;
      });
      document.getElementById("selection-fill-opacity").addEventListener("input", function() {
       selectionBoxStyle.fillOpacity = parseFloat(this.value);
       document.getElementById("selection-fill-opacity-val").textContent = Math.round(this.value * 100) + "%";
      });
      document.getElementById("selection-stroke-color").addEventListener("input", function() {
       selectionBoxStyle.strokeColor = this.value;
      });
      document.getElementById("selection-stroke-width").addEventListener("input", function() {
       selectionBoxStyle.strokeWidth = parseInt(this.value) || 2;
      });
      document.getElementById("selection-stroke-style").addEventListener("change", function() {
       selectionBoxStyle.strokeDasharray = this.value;
      });
      document.getElementById("input-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.inputBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-text-color").addEventListener("input", (e) => {
       PAGE_STATE.inputText = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-border-color").addEventListener("input", (e) => {
       PAGE_STATE.inputBorder = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-font-family").addEventListener("change", (e) => {
       PAGE_STATE.inputFont = e.target.value;
       wieldThePower();
      });
	  document.getElementById("input-font-size").addEventListener("input", (e) => {
       PAGE_STATE.inputFontSize = parseInt(e.target.value) || 14;
       wieldThePower();
      });
      document.getElementById("toolbar-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-border-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBorder = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-text-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarText = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-btn-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBtnBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-btn-text-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBtnText = e.target.value;
       wieldThePower();
      });
      document.getElementById("minimap-dots-color").addEventListener("input", (e) => {
       PAGE_STATE.minimapDots = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("canvas-hint-enabled").addEventListener("change", (e) => {
       PAGE_STATE.canvasHintEnabled = e.target.checked;
       wieldThePower();
      });
      document.getElementById("canvas-hint-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-hint-text-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintColor = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-hint-text").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintText = e.target.value;
       wieldThePower();
      });
       document.getElementById("accent-color").addEventListener("input", (e) => {
        PAGE_STATE.accent = e.target.value;
        wieldThePower();
       });
       document.getElementById("danger-color").addEventListener("input", (e) => {
        PAGE_STATE.danger = e.target.value;
        wieldThePower();
       });
       document.getElementById("text-main-color").addEventListener("input", (e) => {
        PAGE_STATE.textMain = e.target.value;
        wieldThePower();
       });
       document.getElementById("text-soft-color").addEventListener("input", (e) => {
       PAGE_STATE.textSoft = e.target.value;
       wieldThePower();
      });
      document.getElementById("node-fill-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeFill = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-stroke-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeStroke = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-title-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeTitle = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-sub-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeSub = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-title-size").addEventListener("input", (e) => {
       PAGE_STATE.nodeTitleSize = parseInt(e.target.value) || 18;
       forgeTheTopology();
      });
      document.getElementById("node-sub-size").addEventListener("input", (e) => {
       PAGE_STATE.nodeSubSize = parseInt(e.target.value) || 13;
       forgeTheTopology();
      });
      document.getElementById("node-font-family").addEventListener("change", (e) => {
       PAGE_STATE.nodeFont = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("default-edge-color").addEventListener("input", (e) => {
       PAGE_STATE.defaultEdge = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("selection-handle-color").addEventListener("input", (e) => {
       PAGE_STATE.selectionHandle = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("selection-handle-size").addEventListener("input", (e) => {
       PAGE_STATE.selectionHandleSize = parseInt(e.target.value) || 8;
       forgeTheTopology();
      });
      document.getElementById("group-indicator-color").addEventListener("input", (e) => {
       PAGE_STATE.groupIndicator = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-gradient-top").addEventListener("input", (e) => {
       PAGE_STATE.canvasGradientTop = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-gradient-bottom").addEventListener("input", (e) => {
       PAGE_STATE.canvasGradientBottom = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-border-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasBorder = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-grid-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasGrid = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-grid-size").addEventListener("input", (e) => {
       PAGE_STATE.canvasGridSize = parseInt(e.target.value) || 50;
       forgeTheTopology();
      });
      document.getElementById("rack-frame-fill").addEventListener("input", (e) => {
       PAGE_STATE.rackFrameFill = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-frame-stroke").addEventListener("input", (e) => {
       PAGE_STATE.rackFrameStroke = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-line-color").addEventListener("input", (e) => {
       PAGE_STATE.rackLineColor = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-text-color").addEventListener("input", (e) => {
       PAGE_STATE.rackTextColor = e.target.value;
       forgeTheTopology();
      });
      (function initializeResizers() {
         const headerResizer = document.getElementById('header-resizer');
         const sidebarResizer = document.getElementById('sidebar-resizer');
         const mobileFooterResizer = document.getElementById('mobile-footer-resizer');
         let isResizing = false;
         let currentResizer = null;
         let startY = 0;
         let startX = 0;
         let startHeight = 0;
         let startWidth = 0;
         function getClientPos(e) {
           if (e.touches && e.touches.length > 0) {
             return { x: e.touches[0].clientX, y: e.touches[0].clientY };
           }
           return { x: e.clientX, y: e.clientY };
         }
         function startResize(resizer, type, e) {
           isResizing = true;
           currentResizer = type;
           const pos = getClientPos(e);
           if (type === 'header') {
             startY = pos.y;
             startHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--topbar-height'));
           } else if (type === 'sidebar') {
             startX = pos.x;
             startWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width'));
           } else if (type === 'mobile-footer') {
             startY = pos.y;
             const currentVh = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--mobile-footer-height'));
             startHeight = (currentVh / 100) * window.innerHeight;
           }
           resizer.classList.add('resizing');
           document.body.classList.add('resizing');
           document.body.style.cursor = (type === 'sidebar') ? 'col-resize' : 'row-resize';
           e.preventDefault();
         }
         if (headerResizer) {
           headerResizer.addEventListener('mousedown', (e) => startResize(headerResizer, 'header', e));
           headerResizer.addEventListener('touchstart', (e) => startResize(headerResizer, 'header', e), { passive: false });
         }
         if (sidebarResizer) {
           sidebarResizer.addEventListener('mousedown', (e) => startResize(sidebarResizer, 'sidebar', e));
           sidebarResizer.addEventListener('touchstart', (e) => startResize(sidebarResizer, 'sidebar', e), { passive: false });
         }
         if (mobileFooterResizer) {
           mobileFooterResizer.addEventListener('mousedown', (e) => startResize(mobileFooterResizer, 'mobile-footer', e));
           mobileFooterResizer.addEventListener('touchstart', (e) => startResize(mobileFooterResizer, 'mobile-footer', e), { passive: false });
         }
         function handleMove(e) {
           if (!isResizing) return;
           const pos = getClientPos(e);
           if (currentResizer === 'header') {
             const deltaY = pos.y - startY;
             const newHeight = Math.max(40, Math.min(150, startHeight + deltaY));
             document.documentElement.style.setProperty('--topbar-height', newHeight + 'px');
           } else if (currentResizer === 'sidebar') {
             const deltaX = startX - pos.x;
             const newWidth = Math.max(200, Math.min(800, startWidth + deltaX));
             document.documentElement.style.setProperty('--sidebar-width', newWidth + 'px');
           } else if (currentResizer === 'mobile-footer') {
             const deltaY = startY - pos.y;
             const newHeight = startHeight + deltaY;
             const newVh = Math.max(15, Math.min(80, (newHeight / window.innerHeight) * 100));
             document.documentElement.style.setProperty('--mobile-footer-height', newVh + 'vh');
           }
           e.preventDefault();
         }
         document.addEventListener('mousemove', handleMove);
         document.addEventListener('touchmove', handleMove, { passive: false });
         function handleEnd() {
           if (isResizing) {
             isResizing = false;
             if (currentResizer === 'header') {
               PAGE_STATE.topbarHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--topbar-height'));
               headerResizer.classList.remove('resizing');
             } else if (currentResizer === 'sidebar') {
               PAGE_STATE.sidebarWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width'));
               sidebarResizer.classList.remove('resizing');
             } else if (currentResizer === 'mobile-footer') {
               PAGE_STATE.mobileFooterHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--mobile-footer-height'));
               mobileFooterResizer.classList.remove('resizing');
             }
             document.body.classList.remove('resizing');
             document.body.style.cursor = '';
             currentResizer = null;
           }
         }
         document.addEventListener('mouseup', handleEnd);
         document.addEventListener('touchend', handleEnd);
         document.addEventListener('touchcancel', handleEnd);
       })();
       document.getElementById("auto-ping-enabled").addEventListener("change", (e) => {
        autoPingEnabled = e.target.checked;
        PAGE_STATE.autoPingEnabled = autoPingEnabled;
        document.getElementById("auto-ping-settings").style.display = autoPingEnabled ? 'block' : 'none';
        if (autoPingEnabled) {
         startAutoPing();
        } else {
         stopAutoPing();
        }
       });
       document.getElementById("auto-ping-interval").addEventListener("change", (e) => {
        const newInterval = parseInt(e.target.value, 10);
        if (newInterval >= 5 && newInterval <= 3600) {
         autoPingInterval = newInterval;
         PAGE_STATE.autoPingInterval = autoPingInterval;
         if (autoPingEnabled) {
          startAutoPing();
         }
        }
       });
       document.getElementById("export-data-btn").addEventListener("click", () => {
        const data = captureTheQuickening();
        const jsonStr = JSON.stringify(data, null, 2);
        const blob = new Blob([jsonStr], {
         type: "application/json"
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        const safeTitle = (PAGE_STATE.title || "network-topology").toLowerCase().replace(/[^a-z0-9\-]+/g, "-");
        const timestamp = new Date().toISOString().split("T")[0];
        a.download = `${safeTitle}-data-${timestamp}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
		logAuditEvent("export", `Exported JSON: ${a.download}`);
       });
       document.getElementById("import-data-btn").addEventListener("click", () => {
        document.getElementById("import-data-file").click();
       });
       document.getElementById("import-data-file").addEventListener("change", async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        try {
         const text = await file.text();
         const data = JSON.parse(text);
         if (!data.nodeData || !data.edgeData) {
          alert("Invalid data file. Missing required fields.");
          return;
         }
         const confirmMsg = `This will replace all current data with the imported data.\n\nImporting:\n- ${Object.keys(data.nodeData).length} nodes\n- ${data.edgeData.list?.length || 0} connections\n- ${data.documentTabs?.length || 1} tab(s)\n\nContinue?`;         if (!confirm(confirmMsg)) {
          e.target.value = "";
          return;
         }
         NODE_DATA = data.nodeData || {};
         EDGE_DATA = data.edgeData || {
          list: []
         };
         EDGE_LEGEND = data.edgeLegend || {};
         RECT_DATA = data.rectData || { list: [] };
         TEXT_DATA = data.textData || { list: [] };
         savedPositions = data.nodePositions || {};
         savedSizes = data.nodeSizes || {};
         savedStyles = data.nodeStyles || {};
         if (data.page) {
          PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, data.page, );
          wieldThePower();
         }
      if (data.autoPingEnabled !== undefined) {
      autoPingEnabled = data.autoPingEnabled;
      PAGE_STATE.autoPingEnabled = autoPingEnabled;
      document.getElementById("auto-ping-enabled").checked = autoPingEnabled;
      }
      if (data.autoPingInterval !== undefined) {
      autoPingInterval = data.autoPingInterval;
      PAGE_STATE.autoPingInterval = autoPingInterval;
      document.getElementById("auto-ping-interval").value = autoPingInterval;
      }
         if (data.canvas) {
          canvasState.zoom = data.canvas.zoom || 1;
          canvasState.panX = data.canvas.panX || 0;
          canvasState.panY = data.canvas.panY || 0;
         }
         if (data.page?.title) {
         document.title = data.page.title;
         document.querySelector(".editable-page-title", ).textContent = data.page.title;
        }
        if (data.documentTabs) {
         documentTabs = data.documentTabs;
         currentTabIndex = data.currentTabIndex || 0;
        }
        if (data.savedTopologyView) {
         savedTopologyView = data.savedTopologyView;
        }
        if (data.encryptedSections) {
         encryptedSections = data.encryptedSections;
        }
        if (data.auditLog && Array.isArray(data.auditLog)) {
         auditLog = data.auditLog;
         try {
           localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
         } catch (e) {
           console.warn("Failed to sync audit log to localStorage:", e);
         }
        }
        forgeTheTopology();
        forgeTheLegend();
        logAuditEvent("import", `Imported JSON: ${file.name} (${Object.keys(data.nodeData).length} nodes, ${data.edgeData.list?.length || 0} connections)`);
        updateViewBox();
      if (autoPingEnabled) {
      startAutoPing();
      } else {
      stopAutoPing();
      }
         const nodeIds = Object.keys(NODE_DATA);
         if (nodeIds.length > 0) {
          claimTheImmortal(nodeIds[0]);
         } else {
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("topology-toolbar").style.display = "none";
         }
         alert("Data imported successfully!");
         e.target.value = "";
        } catch (err) {
         console.error("Import error:", err);
         alert(`Failed to import data: ${err.message}`);
         e.target.value = "";
        }
       });
       const saveHelpBtn = document.getElementById("save-help-btn");
       const saveInfoModal = document.getElementById("save-info-modal");
       const saveInfoClose = document.getElementById("save-info-close");
       saveHelpBtn.addEventListener("click", () => {
        saveInfoModal.classList.add("active");
       });
       saveInfoClose.addEventListener("click", () => {
        saveInfoModal.classList.remove("active");
       });
       saveInfoModal.addEventListener("click", (e) => {
       if (e.target === saveInfoModal) {
        saveInfoModal.classList.remove("active");
       }
      });
      document.querySelectorAll(".help-tab").forEach(tab => {
        tab.addEventListener("click", () => {
          document.querySelectorAll(".help-tab").forEach(t => { t.style.background = "var(--panel)"; t.style.color = "var(--text-main)"; });
          tab.style.background = "var(--accent)"; tab.style.color = "var(--bg)";
          document.querySelectorAll(".help-tab-content").forEach(c => c.style.display = "none");
          document.getElementById("help-tab-" + tab.dataset.tab).style.display = "block";
        });
      });
      async function deriveKey(password, salt) {
      const encoder = new TextEncoder();
      const keyMaterial = await crypto.subtle.importKey(
      "raw",
      encoder.encode(password),
      "PBKDF2",
      false,
      ["deriveKey"]
      );
      return crypto.subtle.deriveKey(
      {
      name: "PBKDF2",
      salt: salt,
      iterations: 200000,
      hash: "SHA-256"
      },
      keyMaterial,
      {
      name: "AES-GCM",
      length: 256
      },
      false,
      ["encrypt", "decrypt"]
      );
      }
       async function encryptData(data, password) {
      const encoder = new TextEncoder();
      const salt = crypto.getRandomValues(new Uint8Array(16));
      const iv   = crypto.getRandomValues(new Uint8Array(12));
      const key = await deriveKey(password, salt);
      const encrypted = await crypto.subtle.encrypt(
      { name: "AES-GCM", iv },
      key,
      encoder.encode(data)
      );
      const encryptedU8 = new Uint8Array(encrypted);
      const result = new Uint8Array(salt.length + iv.length + encryptedU8.length);
      result.set(salt, 0);
      result.set(iv, salt.length);
      result.set(encryptedU8, salt.length + iv.length);
      return "ENCRYPTED:" + u8ToBase64(result);
      }
       async function decryptData(encryptedData, password) {
      const base64Data = encryptedData.replace("ENCRYPTED:", "");
      const fullData   = base64ToU8(base64Data);
      const salt      = fullData.slice(0, 16);
      const iv        = fullData.slice(16, 28);
      const encrypted = fullData.slice(28);
      const key = await deriveKey(password, salt);
      const decrypted = await crypto.subtle.decrypt(
      { name: "AES-GCM", iv },
      key,
      encrypted
      );
      const decoder = new TextDecoder();
      return decoder.decode(decrypted);
      }
       function isEncrypted(data) {
        return typeof data === "string" && data.startsWith("ENCRYPTED:");
       }
       function captureTheQuickening() {
      const currentTab = documentTabs[currentTabIndex];
      currentTab.nodes = JSON.parse(JSON.stringify(NODE_DATA));
      currentTab.edges = JSON.parse(JSON.stringify(EDGE_DATA));
      currentTab.positions = JSON.parse(JSON.stringify(savedPositions));
      currentTab.sizes = JSON.parse(JSON.stringify(savedSizes));
      currentTab.styles = JSON.parse(JSON.stringify(savedStyles));
      currentTab.legend = JSON.parse(JSON.stringify(EDGE_LEGEND));
      currentTab.rects = JSON.parse(JSON.stringify(RECT_DATA));
      currentTab.texts = JSON.parse(JSON.stringify(TEXT_DATA));
      currentTab.pageState = JSON.parse(JSON.stringify(PAGE_STATE));
      return {
      nodeData: NODE_DATA,
       edgeData: EDGE_DATA,
       rectData: RECT_DATA,
       textData: TEXT_DATA,
       edgeLegend: EDGE_LEGEND,
       nodePositions: savedPositions,
       nodeSizes: savedSizes,
       nodeStyles: savedStyles,
       iconCache: IconLibrary.iconCache,
       page: PAGE_STATE,
       autoPingEnabled: autoPingEnabled,
       autoPingInterval: autoPingInterval,
       canvas: {
         zoom: canvasState.zoom,
         panX: canvasState.panX,
         panY: canvasState.panY,
       },
       savedTopologyView: savedTopologyView,
       documentTabs: documentTabs,
       currentTabIndex: currentTabIndex,
       encryptedSections: encryptedSections,
	   auditLog: auditLog,
       };
      }
       function assembleTheImmortalForm() {
	   const canvasHintEl = document.getElementById("canvas-hint");
       const savedHintHTML = canvasHintEl ? canvasHintEl.innerHTML : "";
       if (canvasHintEl) canvasHintEl.innerHTML = DEFAULT_CANVAS_HINT;
        const clone = document.documentElement.cloneNode(true);
       ["edge-legend-mini", "minimap-mini", "draw-toolbar-mini", "topology-toolbar-mini"].forEach(id => {
        const all = clone.querySelectorAll("#" + id);
        for (let i = 1; i < all.length; i++) {
         all[i].remove();
        }
       });
       const nodeScript = clone.querySelector("#nodes-json");
        if (nodeScript) {
         nodeScript.textContent = JSON.stringify(NODE_DATA, null, 2);
        }
        let stateScript = clone.querySelector("#topology-state");
        if (!stateScript) {
         stateScript = document.createElement("script");
         stateScript.id = "topology-state";
         stateScript.type = "application/json";
         const body = clone.querySelector("body") || clone;
         body.appendChild(stateScript);
        }
        stateScript.textContent = JSON.stringify(captureTheQuickening(), null, 2, );
        return " <!DOCTYPE html> \n " + clone.outerHTML;
       }
       async function becomeImmortal() {
        const encryptEnabled = document.getElementById("encrypt-toggle").checked;
        let stateData = JSON.stringify(captureTheQuickening(), null, 2);
        if (encryptEnabled) {
         const password = prompt("Enter a password to encrypt your data:\n(Remember this password! You will need it to open this file and its non recoverable!)", );
         if (!password) {
          alert("Encryption cancelled. File not saved.");
          return;
         }
         const confirmPassword = prompt("Confirm your password:");
         if (password !== confirmPassword) {
          alert("Passwords do not match. File not saved.");
          return;
         }
         try {
          stateData = await encryptData(stateData, password);
         } catch (e) {
          alert("Encryption failed: " + e.message);
          return;
         }
        }
       const canvasHintEl = document.getElementById("canvas-hint");
       const savedHintHTML = canvasHintEl ? canvasHintEl.innerHTML : "";
       if (canvasHintEl) canvasHintEl.innerHTML = DEFAULT_CANVAS_HINT;
       const clone = document.documentElement.cloneNode(true);
       ["edge-legend-mini", "minimap-mini", "draw-toolbar-mini", "topology-toolbar-mini"].forEach(id => {
        const all = clone.querySelectorAll("#" + id);
        for (let i = 1; i < all.length; i++) {
         all[i].remove();
        }
       });
       const nodeScript = clone.querySelector("#nodes-json");
        if (nodeScript) {
         if (encryptEnabled) {
          nodeScript.textContent = JSON.stringify({}, null, 2);
         } else {
          nodeScript.textContent = JSON.stringify(NODE_DATA, null, 2);
         }
        }
        let stateScript = clone.querySelector("#topology-state");
        if (!stateScript) {
         stateScript = document.createElement("script");
         stateScript.id = "topology-state";
         stateScript.type = "application/json";
         const body = clone.querySelector("body") || clone;
         body.appendChild(stateScript);
        }
        stateScript.textContent = stateData;
        const html = "<!DOCTYPE html> \n " + clone.outerHTML;
        const blob = new Blob([html], {
         type: "text/html"
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        const safeTitle = (PAGE_STATE.title || document.title || "network-topology").toLowerCase().replace(/[^a-z0-9\-]+/g, "-");
        a.download = safeTitle + ".html";
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
		if (canvasHintEl) canvasHintEl.innerHTML = savedHintHTML;
        saveRollbackVersion("Manual save");
		logAuditEvent("save", `File saved: ${safeTitle}.html`);
       }
      function captureState() {
      return {
        nodes: JSON.parse(JSON.stringify(NODE_DATA)),
        edges: JSON.parse(JSON.stringify(EDGE_DATA)),
        positions: JSON.parse(JSON.stringify(savedPositions)),
        sizes: JSON.parse(JSON.stringify(savedSizes)),
        styles: JSON.parse(JSON.stringify(savedStyles)),
        legend: JSON.parse(JSON.stringify(EDGE_LEGEND)),
        rects: JSON.parse(JSON.stringify(RECT_DATA)),
        texts: JSON.parse(JSON.stringify(TEXT_DATA))
        };
      }
      function pushUndo(action = "") {
       const state = captureState();
       undoStack.push(state);
       if (undoStack.length > MAX_UNDO_STACK) {
        undoStack.shift();
       }
       redoStack = [];
       updateUndoButtons();
       if (action) {
        const actionTypeMap = {
          "create node": "node",
          "delete node": "node",
          "add node": "node",
          "edit": "node",
          "clone node": "node",
          "paste node": "node",
          "move nodes": "node",
          "nudge": "node",
          "nudge nodes": "node",
          "align nodes": "node",
          "distribute nodes": "node",
          "snap to grid": "node",
          "toggle group": "node",
          "toggle lock": "node",
          "create rack": "rack",
          "add rack": "rack",
          "edit rack": "rack",
          "edit mac": "rack",
          "edit U height": "rack",
          "change rack capacity": "rack",
          "change assigned rack": "rack",
          "add connection": "connection",
          "delete connection": "connection",
          "delete edge": "connection",
          "clone edge": "connection",
          "paste edge": "connection",
          "style change": "style",
          "change layer": "layer",
          "add text": "text",
          "edit text": "text",
          "delete text": "text",
          "clone text": "text",
          "paste text": "text",
          "draw zone": "zone",
          "delete zone": "zone",
          "delete rect": "zone",
          "clone rect": "zone",
          "paste rect": "zone",
          "change zone line style": "zone",
          "delete selected": "bulk",
          "clone selected": "bulk",
        };
        const type = actionTypeMap[action] || "edit";
        logAuditEvent(type, action);
       }
      }
      function undo() {
       if (undoStack.length === 0) return;
       const currentState = captureState();
       redoStack.push(currentState);
       const previousState = undoStack.pop();
       restoreState(previousState);
       updateUndoButtons();
       logAuditEvent("undo", "Undo action performed");
      }
      function redo() {
       if (redoStack.length === 0) return;
       logAuditEvent("redo", "Redo action performed");
       const currentState = captureState();
       undoStack.push(currentState);
       const nextState = redoStack.pop();
       restoreState(nextState);
       updateUndoButtons();
      }
      function restoreState(state) {
      NODE_DATA = state.nodes;
       EDGE_DATA = state.edges;
       savedPositions = state.positions;
       savedSizes = state.sizes;
       savedStyles = state.styles;
       EDGE_LEGEND = state.legend;
       RECT_DATA = state.rects || { list: [] };
       TEXT_DATA = state.texts || { list: [] };
       forgeTheTopology();
       if (currentNodeId && NODE_DATA[currentNodeId]) {
       claimTheImmortal(currentNodeId);
       } else if (currentEdgeId) {
       selectTheConnection(currentEdgeId);
       }
      }
      function updateUndoButtons() {
       const undoBtn = document.getElementById("undo-btn");
       const redoBtn = document.getElementById("redo-btn");
       if (undoBtn) {
        undoBtn.disabled = undoStack.length === 0;
        undoBtn.style.opacity = undoStack.length === 0 ? "0.5" : "1";
       }
       if (redoBtn) {
        redoBtn.disabled = redoStack.length === 0;
        redoBtn.style.opacity = redoStack.length === 0 ? "0.5" : "1";
       }
      }
      function clearSelection() {
       selectedNodes.clear();
       selectedEdges.clear();
       selectedRects.clear();
       selectedTexts.clear();
       updateAllSelections();
      }
      function updateAllSelections() {
      updateNodeSelection();
      clearSearchHighlight();
      document.querySelectorAll(".edge").forEach(el => {
      const edgeId = el.dataset.edgeId;
      if (selectedEdges.has(edgeId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      document.querySelectorAll(".rect-group").forEach(el => {
      const rectId = el.dataset.rectId;
      if (selectedRects.has(rectId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      document.querySelectorAll(".text-group").forEach(el => {
      const textId = el.dataset.textId;
      if (selectedTexts.has(textId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
      const bulkToolbar = document.getElementById("bulk-toolbar");
      const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
      const bulkCount = document.getElementById("bulk-count");
      const bulkCountMobile = document.getElementById("bulk-count-mobile");
      if (total > 0) {
      if (bulkToolbar) bulkToolbar.style.display = "flex";
      if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
      if (bulkCount) bulkCount.textContent = total;
      if (bulkCountMobile) bulkCountMobile.textContent = total;
      } else {
      if (bulkToolbar) bulkToolbar.style.display = "none";
      if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
      }
      }
      function updateNodeSelection() {
       if (isViewOnly()) {
        selectedNodes.clear();
        selectedRects.clear();
        selectedTexts.clear();
        const bulkToolbar = document.getElementById("bulk-toolbar");
        const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        return;
       }
       document.querySelectorAll(".node-group").forEach(node => {
        const nodeId = node.dataset.nodeId;
        if (selectedNodes.has(nodeId)) {
         node.classList.add("selected");
        } else {
         node.classList.remove("selected");
        }
       });
       const bulkToolbar = document.getElementById("bulk-toolbar");
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       const bulkCount = document.getElementById("bulk-count");
       const bulkCountMobile = document.getElementById("bulk-count-mobile");
       const bulkCountModal = document.getElementById("bulk-count-modal");
       if (selectedNodes.size > 0) {
        if (bulkToolbar) bulkToolbar.style.display = "flex";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
        if (bulkCount) bulkCount.textContent = selectedNodes.size;
        if (bulkCountMobile) bulkCountMobile.textContent = selectedNodes.size;
        if (bulkCountModal) bulkCountModal.textContent = selectedNodes.size;
       } else {
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        const modal = document.getElementById("bulk-actions-modal");
        if (modal) modal.style.display = "none";
       }
      }
      function deleteSelected() {
       const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
       if (total === 0) return;
       let nodesInsideRacks = [];
       selectedNodes.forEach(nodeId => {
        if (NODE_DATA[nodeId]?.isRack) {
         Object.entries(NODE_DATA).forEach(([id, n]) => {
          if (n.assignedRack === nodeId) nodesInsideRacks.push(n.name || id);
         });
        }
       });
       let message = `Delete ${total} selected item(s)?`;
       if (nodesInsideRacks.length > 0) {
        message += `\n\nThis will also delete ${nodesInsideRacks.length} node(s) inside rack(s):\n‚Ä¢ ${nodesInsideRacks.join('\n‚Ä¢ ')}`;
       }
       challengeTheImmortal(message, () => {
        pushUndo("delete selected");
        selectedNodes.forEach(nodeId => {
         if (NODE_DATA[nodeId]?.isRack) {
          Object.keys(NODE_DATA).forEach(id => {
           if (NODE_DATA[id]?.assignedRack === nodeId) {
            EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== id && e.to !== id);
            delete NODE_DATA[id];
            delete savedPositions[id];
            delete savedSizes[id];
            delete savedStyles[id];
           }
          });
         }
         delete NODE_DATA[nodeId];
         delete savedPositions[nodeId];
         delete savedSizes[nodeId];
         delete savedStyles[nodeId];
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== nodeId && e.to !== nodeId);
        });
        selectedEdges.forEach(edgeId => {
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.id !== edgeId);
        });
        selectedRects.forEach(rectId => {
         RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== rectId);
        });
        selectedTexts.forEach(textId => {
         TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== textId);
        });
        clearSelection();
        forgeTheTopology();
       });
      }
      function startSelection(event) {
       const svgEl = document.getElementById("map");
       const pt = svgEl.createSVGPoint();
       pt.x = event.clientX;
       pt.y = event.clientY;
       const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
       isSelecting = true;
       selectionStart = { x: svgP.x, y: svgP.y };
       if (!selectionRect || !selectionRect.parentNode) {
        selectionRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        selectionRect.setAttribute("fill", selectionBoxStyle.fillColor);
        selectionRect.setAttribute("fill-opacity", selectionBoxStyle.fillOpacity);
        selectionRect.setAttribute("stroke", selectionBoxStyle.strokeColor);
        selectionRect.setAttribute("stroke-width", selectionBoxStyle.strokeWidth);
        selectionRect.setAttribute("stroke-dasharray", selectionBoxStyle.strokeDasharray);
        selectionRect.style.pointerEvents = "none";
        svgEl.appendChild(selectionRect);
       }
       clearSelection();
       preDragSelectedNodes = new Set(selectedNodes);
       preDragSelectedEdges = new Set(selectedEdges);
       preDragSelectedRects = new Set(selectedRects);
       preDragSelectedTexts = new Set(selectedTexts);
      }
      function updateSelection(event) {
       if (!isSelecting || !selectionStart) return;
       const svgEl = document.getElementById("map");
       const pt = svgEl.createSVGPoint();
       pt.x = event.clientX;
       pt.y = event.clientY;
       const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
       const x = Math.min(selectionStart.x, svgP.x);
       const y = Math.min(selectionStart.y, svgP.y);
       const width = Math.abs(svgP.x - selectionStart.x);
       const height = Math.abs(svgP.y - selectionStart.y);
       selectionRect.setAttribute("x", x);
       selectionRect.setAttribute("y", y);
       selectionRect.setAttribute("width", width);
       selectionRect.setAttribute("height", height);
       selectionRect.style.display = "block";
       const box = { x, y, width, height };
       Object.entries(savedPositions).forEach(([nodeId, pos]) => {
        const size = savedSizes[nodeId] || 50;
        const halfSize = size / 2;
        const nodeBox = { x: pos.x - halfSize, y: pos.y - halfSize, width: size, height: size };
        if (boxesIntersect(box, nodeBox)) {
         selectedNodes.add(nodeId);
        } else if (!preDragSelectedNodes.has(nodeId)) {
         selectedNodes.delete(nodeId);
        }
       });
       EDGE_DATA.list.forEach(edge => {
        if (!edge.points || edge.points.length === 0) return;
        for (let i = 0; i < edge.points.length - 1; i++) {
         const p1 = edge.points[i];
         const p2 = edge.points[i + 1];
         if (lineIntersectsBox(p1.x, p1.y, p2.x, p2.y, box)) {
          selectedEdges.add(edge.id);
          return;
         }
        }
        if (!preDragSelectedEdges.has(edge.id)) {
         selectedEdges.delete(edge.id);
        }
       });
       RECT_DATA.list.forEach(rect => {
        const rectBox = { x: rect.x, y: rect.y, width: rect.width, height: rect.height };
        if (boxesIntersect(box, rectBox)) {
         selectedRects.add(rect.id);
        } else if (!preDragSelectedRects.has(rect.id)) {
         selectedRects.delete(rect.id);
        }
       });
       TEXT_DATA.list.forEach(text => {
        const fontSize = text.fontSize || 18;
        const textBox = { x: text.x - 50, y: text.y - fontSize, width: 100, height: fontSize * 1.5 };
        if (boxesIntersect(box, textBox)) {
         selectedTexts.add(text.id);
        } else if (!preDragSelectedTexts.has(text.id)) {
         selectedTexts.delete(text.id);
        }
       });
       updateAllSelectionVisuals();
      }
      function endSelection() {
       isSelecting = false;
       selectionStart = null;
       if (selectionRect) {
        selectionRect.style.display = "none";
       }
      }
      function boxesIntersect(a, b) {
       return !(a.x + a.width < b.x || b.x + b.width < a.x || a.y + a.height < b.y || b.y + b.height < a.y);
      }
      function lineIntersectsBox(x1, y1, x2, y2, box) {
       if (pointInBox(x1, y1, box) || pointInBox(x2, y2, box)) return true;
       const lines = [
        [box.x, box.y, box.x + box.width, box.y],
        [box.x + box.width, box.y, box.x + box.width, box.y + box.height],
        [box.x + box.width, box.y + box.height, box.x, box.y + box.height],
        [box.x, box.y + box.height, box.x, box.y]
       ];
       for (const [bx1, by1, bx2, by2] of lines) {
        if (linesIntersect(x1, y1, x2, y2, bx1, by1, bx2, by2)) return true;
       }
       return false;
      }
      function pointInBox(x, y, box) {
       return x >= box.x && x <= box.x + box.width && y >= box.y && y <= box.y + box.height;
      }
      function linesIntersect(x1, y1, x2, y2, x3, y3, x4, y4) {
       const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
       if (Math.abs(denom) < 0.0001) return false;
       const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom;
       const ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denom;
       return ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1;
      }
      function updateAllSelectionVisuals() {
       document.querySelectorAll(".node-group").forEach(node => {
        const nodeId = node.dataset.nodeId;
        if (selectedNodes.has(nodeId)) {
         node.classList.add("selected");
        } else {
         node.classList.remove("selected");
        }
       });
       document.querySelectorAll(".edge").forEach(edge => {
        const edgeId = edge.dataset.edgeId;
        if (selectedEdges.has(edgeId)) {
         edge.style.filter = "drop-shadow(0 0 6px #4fd1c5)";
        } else {
         edge.style.filter = "";
        }
       });
       document.querySelectorAll(".rect-group rect").forEach(el => {
        const rectId = el.closest(".rect-group")?.dataset?.rectId;
        if (selectedRects.has(rectId)) {
         el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
        } else {
         el.style.filter = "";
        }
       });
       document.querySelectorAll(".text-group, .text-element").forEach(el => {
        const textId = el.dataset?.textId;
        if (selectedTexts.has(textId)) {
         el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
        } else {
         el.style.filter = "";
        }
       });
       const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
       const bulkToolbar = document.getElementById("bulk-toolbar");
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       const bulkCount = document.getElementById("bulk-count");
       const bulkCountMobile = document.getElementById("bulk-count-mobile");
       if (total > 0) {
        if (bulkToolbar) bulkToolbar.style.display = "flex";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
        if (bulkCount) bulkCount.textContent = total;
        if (bulkCountMobile) bulkCountMobile.textContent = total;
       } else {
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
       }
      }
      function cloneNode(sourceId, skipUndo) {
       const source = NODE_DATA[sourceId];
       if (!source) return;
       if (!skipUndo) pushUndo("clone node");
       let baseName = source.name;
       let copyNum = 0;
       let newName = baseName + " copy";
       while (Object.values(NODE_DATA).some(n => n.name === newName)) {
        copyNum++;
        newName = baseName + " copy " + copyNum;
       }
       const newId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
       NODE_DATA[newId] = {
        shape: source.shape,
        name: newName,
        ip: source.ip,
        role: source.role,
        tags: [...source.tags],
        notes: [...source.notes],
        mac: source.mac || "",
        rackUnit: source.rackUnit || "",
        uHeight: source.uHeight || "1",
        ping: source.ping ? JSON.parse(JSON.stringify(source.ping)) : {
         enabled: false,
         protocol: 'http',
         customUrl: '',
         timeout: 3000,
         status: 'unknown',
         lastCheck: null
        },
        layer: source.layer || "physical",
        assignedRack: source.assignedRack || "",
        rackCapacity: source.rackCapacity || "42",
        isRack: source.isRack || false
       };
       if (source.isRack) {
        const childNodes = Object.entries(NODE_DATA).filter(([id, n]) =>
         id !== newId && n.assignedRack === sourceId
        );
        childNodes.forEach(([childId, childNode]) => {
         let childBaseName = childNode.name;
         let c = 0;
         let childNewName = childBaseName + " copy";
         while (Object.values(NODE_DATA).some(n => n.name === childNewName)) {
          c++;
          childNewName = childBaseName + " copy " + c;
         }
         const childNewId = childNewName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
         NODE_DATA[childNewId] = {
          ...JSON.parse(JSON.stringify(childNode)),
          name: childNewName,
          assignedRack: newId
         };
         if (savedPositions[childId]) {
          savedPositions[childNewId] = { ...savedPositions[childId] };
         }
         if (savedSizes[childId]) {
          savedSizes[childNewId] = savedSizes[childId];
         }
         if (savedStyles[childId]) {
          savedStyles[childNewId] = JSON.parse(JSON.stringify(savedStyles[childId]));
         }
        });
       }
       if (savedSizes[sourceId]) {
        savedSizes[newId] = savedSizes[sourceId];
       }
       if (savedStyles[sourceId]) {
        savedStyles[newId] = JSON.parse(JSON.stringify(savedStyles[sourceId]));
       }
      if (currentView.mode === "rack" && currentView.rackId) {
        NODE_DATA[newId].assignedRack = currentView.rackId;
       }
       const sourcePos = savedPositions[sourceId];
       savedPositions[newId] = {
        x: sourcePos.x + 100,
        y: sourcePos.y + 100
       };
       forgeTheTopology();
       claimTheImmortal(newId);
      }
      function alignSelectedNodes(direction) {
       if (selectedNodes.size < 2) return;
       pushUndo("align nodes");
       const nodeIds = Array.from(selectedNodes);
       const positions = nodeIds.map(id => ({ id, pos: savedPositions[id] }));
       switch(direction) {
        case "left":
         const minX = Math.min(...positions.map(p => p.pos.x));
         positions.forEach(p => savedPositions[p.id].x = minX);
         break;
        case "right":
         const maxX = Math.max(...positions.map(p => p.pos.x));
         positions.forEach(p => savedPositions[p.id].x = maxX);
         break;
        case "top":
         const minY = Math.min(...positions.map(p => p.pos.y));
         positions.forEach(p => savedPositions[p.id].y = minY);
         break;
        case "bottom":
         const maxY = Math.max(...positions.map(p => p.pos.y));
         positions.forEach(p => savedPositions[p.id].y = maxY);
         break;
        case "center-h":
         const avgX = positions.reduce((sum, p) => sum + p.pos.x, 0) / positions.length;
         positions.forEach(p => savedPositions[p.id].x = avgX);
         break;
        case "center-v":
         const avgY = positions.reduce((sum, p) => sum + p.pos.y, 0) / positions.length;
         positions.forEach(p => savedPositions[p.id].y = avgY);
         break;
       }
       forgeTheTopology();
      }
      function distributeSelectedNodes(direction) {
       if (selectedNodes.size < 3) return;
       pushUndo("distribute nodes");
       const nodeIds = Array.from(selectedNodes);
       const positions = nodeIds.map(id => ({ id, pos: savedPositions[id] }));
       if (direction === "horizontal") {
        positions.sort((a, b) => a.pos.x - b.pos.x);
        const minX = positions[0].pos.x;
        const maxX = positions[positions.length - 1].pos.x;
        const gap = (maxX - minX) / (positions.length - 1);
        positions.forEach((p, i) => {
         savedPositions[p.id].x = minX + (gap * i);
        });
       } else if (direction === "vertical") {
        positions.sort((a, b) => a.pos.y - b.pos.y);
        const minY = positions[0].pos.y;
        const maxY = positions[positions.length - 1].pos.y;
        const gap = (maxY - minY) / (positions.length - 1);
        positions.forEach((p, i) => {
         savedPositions[p.id].y = minY + (gap * i);
        });
       }
       forgeTheTopology();
      }
      function snapToGrid(nodeId, gridSize = 50) {
       if (!savedPositions[nodeId]) return;
       pushUndo("snap to grid");
       const pos = savedPositions[nodeId];
       pos.x = Math.round(pos.x / gridSize) * gridSize;
       pos.y = Math.round(pos.y / gridSize) * gridSize;
       forgeTheTopology();
      }
      function nudgeSelectedNodes(direction, distance) {
        const nodesToNudge = selectedNodes.size > 0
          ? Array.from(selectedNodes)
          : (currentNodeId ? [currentNodeId] : []);
        if (nodesToNudge.length === 0) return;
        const unlockedNodes = nodesToNudge.filter(id => !NODE_DATA[id]?.locked);
        if (unlockedNodes.length === 0) {
          return;
        }
        pushUndo("nudge nodes");
        unlockedNodes.forEach(id => {
          if (!savedPositions[id]) {
            savedPositions[id] = { x: 0, y: 0 };
          }
          switch(direction) {
            case "ArrowUp":
              savedPositions[id].y -= distance;
              break;
            case "ArrowDown":
              savedPositions[id].y += distance;
              break;
            case "ArrowLeft":
              savedPositions[id].x -= distance;
              break;
            case "ArrowRight":
              savedPositions[id].x += distance;
              break;
          }
        });
        forgeTheTopology();
      }
      function cycleNodes(reverse = false) {
        const nodeIds = Object.keys(NODE_DATA).filter(id => {
          if (currentView.mode === "rack") {
           const node = NODE_DATA[id];
           return node && node.assignedRack === currentView.rackId;
          }
          return isNodeVisible(id);
         });
        if (nodeIds.length === 0) return;
        let currentIndex = nodeIds.indexOf(currentNodeId);
        if (reverse) {
          currentIndex = currentIndex <= 0 ? nodeIds.length - 1 : currentIndex - 1;
        } else {
          currentIndex = currentIndex >= nodeIds.length - 1 ? 0 : currentIndex + 1;
        }
        const nextNodeId = nodeIds[currentIndex];
        claimTheImmortal(nextNodeId);
        selectedNodes.clear();
        updateNodeSelection();
      }
      function focusOnSelected() {
        let minX = Infinity, minY = Infinity;
        let maxX = -Infinity, maxY = -Infinity;
        let hasItems = false;
        const nodesToFocus = selectedNodes.size > 0
          ? Array.from(selectedNodes)
          : (currentNodeId ? [currentNodeId] : []);
        nodesToFocus.forEach(id => {
          const pos = savedPositions[id];
          if (pos) {
            hasItems = true;
            const size = savedSizes[id] || 50;
            minX = Math.min(minX, pos.x - size/2);
            minY = Math.min(minY, pos.y - size/2);
            maxX = Math.max(maxX, pos.x + size/2);
            maxY = Math.max(maxY, pos.y + size/2);
          }
        });
        const rectsToFocus = selectedRects.size > 0 ? Array.from(selectedRects) : (currentRectId ? [currentRectId] : []);
        rectsToFocus.forEach(id => {
          const r = RECT_DATA.list.find(x => x.id === id);
          if (r) {
            hasItems = true;
            minX = Math.min(minX, r.x);
            minY = Math.min(minY, r.y);
            maxX = Math.max(maxX, r.x + r.width);
            maxY = Math.max(maxY, r.y + r.height);
          }
        });
        const textsToFocus = selectedTexts.size > 0 ? Array.from(selectedTexts) : (currentTextId ? [currentTextId] : []);
        textsToFocus.forEach(id => {
          const t = TEXT_DATA.list.find(x => x.id === id);
          if (t) {
            hasItems = true;
            minX = Math.min(minX, t.x - 50);
            minY = Math.min(minY, t.y - 20);
            maxX = Math.max(maxX, t.x + 50);
            maxY = Math.max(maxY, t.y + 20);
          }
        });
        const edgesToFocus = selectedEdges.size > 0 ? Array.from(selectedEdges) : (currentEdgeId ? [currentEdgeId] : []);
        edgesToFocus.forEach(id => {
          const e = EDGE_DATA.list.find(x => x.id === id);
          if (e) {
            const fromPos = savedPositions[e.from];
            const toPos = savedPositions[e.to];
            if (fromPos && toPos) {
              hasItems = true;
              minX = Math.min(minX, fromPos.x, toPos.x);
              minY = Math.min(minY, fromPos.y, toPos.y);
              maxX = Math.max(maxX, fromPos.x, toPos.x);
              maxY = Math.max(maxY, fromPos.y, toPos.y);
            }
          }
        });
        if (!hasItems || !isFinite(minX)) return;
        const padding = 100;
        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;
        const width = maxX - minX + padding * 2;
        const height = maxY - minY + padding * 2;
        const zoomX = CANVAS_WIDTH / width;
        const zoomY = CANVAS_HEIGHT / height;
        const targetZoom = Math.min(zoomX, zoomY, 2);
        canvasState.zoom = targetZoom;
        canvasState.panX = centerX - (CANVAS_WIDTH / targetZoom) / 2;
        canvasState.panY = centerY - (CANVAS_HEIGHT / targetZoom) / 2;
		// forgeTheTopology(); getting ready to implement new core canvas performance system
        updateViewBox();
      }
      function toggleLockSelected() {
        const nodesToToggle = selectedNodes.size > 0
          ? Array.from(selectedNodes)
          : (currentNodeId ? [currentNodeId] : []);
        const rectsToToggle = selectedRects.size > 0
          ? Array.from(selectedRects)
          : (currentRectId ? [currentRectId] : []);
        const textsToToggle = selectedTexts.size > 0
          ? Array.from(selectedTexts)
          : (currentTextId ? [currentTextId] : []);
        if (nodesToToggle.length === 0 && rectsToToggle.length === 0 && textsToToggle.length === 0) return;
        pushUndo("toggle lock");
        let hasUnlocked = nodesToToggle.some(id => !NODE_DATA[id]?.locked);
        hasUnlocked = hasUnlocked || rectsToToggle.some(id => { const r = RECT_DATA.list.find(x => x.id === id); return r && !r.locked; });
        hasUnlocked = hasUnlocked || textsToToggle.some(id => { const t = TEXT_DATA.list.find(x => x.id === id); return t && !t.locked; });
        nodesToToggle.forEach(id => {
          if (NODE_DATA[id]) NODE_DATA[id].locked = hasUnlocked;
        });
        rectsToToggle.forEach(id => {
          const r = RECT_DATA.list.find(x => x.id === id);
          if (r) r.locked = hasUnlocked;
        });
        textsToToggle.forEach(id => {
          const t = TEXT_DATA.list.find(x => x.id === id);
          if (t) t.locked = hasUnlocked;
        });
        forgeTheTopology();
      }
      function toggleGroupSelected() {
      const nodesToGroup = Array.from(selectedNodes);
      const rectsToGroup = Array.from(selectedRects);
      const textsToGroup = Array.from(selectedTexts);
      const edgesToGroup = Array.from(selectedEdges);
      const totalItems = nodesToGroup.length + rectsToGroup.length + textsToGroup.length + edgesToGroup.length;
      if (totalItems < 2) return;
      pushUndo("toggle group");
      const allGroupIds = [];
      nodesToGroup.forEach(id => { if (NODE_DATA[id]?.groupId) allGroupIds.push(NODE_DATA[id].groupId); });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r?.groupId) allGroupIds.push(r.groupId); });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t?.groupId) allGroupIds.push(t.groupId); });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e?.groupId) allGroupIds.push(e.groupId); });
      const uniqueGroups = [...new Set(allGroupIds)];
      if (uniqueGroups.length === 1 && allGroupIds.length === totalItems) {
      nodesToGroup.forEach(id => { if (NODE_DATA[id]) NODE_DATA[id].groupId = null; });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r) r.groupId = null; });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t) t.groupId = null; });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e) e.groupId = null; });
      } else {
      const newGroupId = "group-" + Date.now();
      nodesToGroup.forEach(id => { if (NODE_DATA[id]) NODE_DATA[id].groupId = newGroupId; });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r) r.groupId = newGroupId; });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t) t.groupId = newGroupId; });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e) e.groupId = newGroupId; });
      }
      forgeTheTopology();
      }
      function handleKeyDown(event) {
       if (event.target.tagName === "INPUT" || event.target.tagName === "TEXTAREA" || event.target.isContentEditable) {
        return;
       }
       if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(event.key)) {
        event.preventDefault();
        const distance = event.shiftKey ? 10 : 1;
        nudgeSelectedNodes(event.key, distance);
       }
       if (event.key === "Tab") {
        event.preventDefault();
        cycleNodes(event.shiftKey);
       }
       if (event.key === "f" || event.key === "F") {
        event.preventDefault();
        focusOnSelected();
       }
       if (event.key === "l" || event.key === "L") {
        event.preventDefault();
        toggleLockSelected();
       }
       if (event.key === "g" || event.key === "G") {
        event.preventDefault();
        toggleGroupSelected();
       }
       if (event.ctrlKey && event.key === "z" && !event.shiftKey) {
        event.preventDefault();
        undo();
       }
       if ((event.ctrlKey && event.key === "y") || (event.ctrlKey && event.shiftKey && event.key === "z")) {
        event.preventDefault();
        redo();
       }
       if (event.ctrlKey && event.key === "c") {
        event.preventDefault();
        clipboard = null;
        if (currentNodeId && NODE_DATA[currentNodeId]) {
         clipboard = {
          type: "node",
          data: JSON.parse(JSON.stringify(NODE_DATA[currentNodeId])),
          size: savedSizes[currentNodeId],
          style: savedStyles[currentNodeId] ? JSON.parse(JSON.stringify(savedStyles[currentNodeId])) : null
         };
        } else if (currentEdgeId) {
         const edge = EDGE_DATA.list.find(e => e.id === currentEdgeId);
         if (edge) clipboard = { type: "edge", data: JSON.parse(JSON.stringify(edge)) };
        } else if (currentRectId) {
         const rect = RECT_DATA.list.find(r => r.id === currentRectId);
         if (rect) clipboard = { type: "rect", data: JSON.parse(JSON.stringify(rect)) };
        } else if (currentTextId) {
         const text = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (text) clipboard = { type: "text", data: JSON.parse(JSON.stringify(text)) };
        }
       }
       if (event.ctrlKey && event.key === "v") {
        event.preventDefault();
        if (!clipboard) return;
        const svgEl = document.getElementById("map");
        const rect = svgEl.getBoundingClientRect();
        const pt = svgEl.createSVGPoint();
        pt.x = rect.left + rect.width / 2;
        pt.y = rect.top + rect.height / 2;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const centerX = svgP.x;
        const centerY = svgP.y;
        if (clipboard.type === "node") {
         let newName = clipboard.data.name + " copy";
         let counter = 1;
         while (Object.values(NODE_DATA).some(n => n.name === newName)) {
          newName = clipboard.data.name + " copy " + counter;
          counter++;
         }
         let newId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
         counter = 1;
         while (NODE_DATA[newId]) {
          newId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-") + "-" + counter;
          counter++;
         }
         pushUndo("paste node");
         NODE_DATA[newId] = { ...JSON.parse(JSON.stringify(clipboard.data)), name: newName };
         savedPositions[newId] = { x: centerX, y: centerY };
         if (clipboard.size) savedSizes[newId] = clipboard.size;
         if (clipboard.style) savedStyles[newId] = JSON.parse(JSON.stringify(clipboard.style));
         forgeTheTopology();
         claimTheImmortal(newId);
        } else if (clipboard.type === "edge") {
         pushUndo("paste edge");
         const newEdge = { ...clipboard.data, id: "edge-" + Date.now() };
         EDGE_DATA.list.push(newEdge);
         forgeTheTopology();
         selectTheConnection(newEdge.id);
        } else if (clipboard.type === "rect") {
         pushUndo("paste rect");
         const newRect = { ...clipboard.data, id: "rect-" + Date.now(), x: centerX - (clipboard.data.width || 100) / 2, y: centerY - (clipboard.data.height || 100) / 2 };
         RECT_DATA.list.push(newRect);
         forgeTheTopology();
         selectTheRect(newRect.id);
        } else if (clipboard.type === "text") {
         pushUndo("paste text");
         const newText = { ...clipboard.data, id: "text-" + Date.now(), x: centerX, y: centerY };
         TEXT_DATA.list.push(newText);
         forgeTheTopology();
         showTextPanel(newText.id);
        }
       }
       if (event.ctrlKey && event.key === "d") {
        event.preventDefault();
        if (currentNodeId && NODE_DATA[currentNodeId]) {
         cloneNode(currentNodeId);
        } else if (currentEdgeId) {
         const edge = EDGE_DATA.list.find(e => e.id === currentEdgeId);
         if (edge) {
          pushUndo("clone edge");
          const newEdge = { ...JSON.parse(JSON.stringify(edge)), id: "edge-" + Date.now() };
          EDGE_DATA.list.push(newEdge);
          forgeTheTopology();
          selectTheConnection(newEdge.id);
         }
        } else if (currentRectId) {
         const rect = RECT_DATA.list.find(r => r.id === currentRectId);
         if (rect) {
          pushUndo("clone rect");
          const newRect = { ...JSON.parse(JSON.stringify(rect)), id: "rect-" + Date.now(), x: rect.x + 50, y: rect.y + 50 };
          RECT_DATA.list.push(newRect);
          forgeTheTopology();
          selectTheRect(newRect.id);
         }
        } else if (currentTextId) {
         const text = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (text) {
          pushUndo("clone text");
          const newText = { ...JSON.parse(JSON.stringify(text)), id: "text-" + Date.now(), x: text.x + 50, y: text.y + 50 };
          TEXT_DATA.list.push(newText);
          forgeTheTopology();
          showTextPanel(newText.id);
         }
        }
       }
       if (event.key === "Delete") {
        event.preventDefault();
        const totalSelected = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
        if (totalSelected > 0) {
         deleteSelected();
        } else if (currentNodeId && NODE_DATA[currentNodeId]) {
         challengeTheImmortal(`Delete node "${NODE_DATA[currentNodeId].name}"?`, () => {
          pushUndo("delete node");
          delete NODE_DATA[currentNodeId];
          delete savedPositions[currentNodeId];
          delete savedSizes[currentNodeId];
          delete savedStyles[currentNodeId];
          EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== currentNodeId && e.to !== currentNodeId);
          currentNodeId = null;
          forgeTheTopology();
          document.getElementById("node-panel").style.display = "none";
         });
        } else if (currentEdgeId) {
         challengeTheImmortal("Delete this line?", () => {
          pushUndo("delete edge");
          EDGE_DATA.list = EDGE_DATA.list.filter(e => e.id !== currentEdgeId);
          currentEdgeId = null;
          forgeTheTopology();
          document.getElementById("edge-panel").style.display = "none";
         });
        } else if (currentRectId) {
         challengeTheImmortal("Delete this zone?", () => {
          pushUndo("delete rect");
          RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== currentRectId);
          currentRectId = null;
          forgeTheTopology();
          document.getElementById("rect-panel").style.display = "none";
         });
        } else if (currentTextId) {
         const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (textItem) {
          challengeTheImmortal(`Delete text "${(textItem.content || '').substring(0, 30)}..."?`, () => {
           pushUndo("delete text");
           TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== currentTextId);
           currentTextId = null;
           forgeTheTopology();
           document.getElementById("text-panel").style.display = "none";
          });
         }
        }
       }
       if (event.ctrlKey && event.key === "a") {
        event.preventDefault();
        Object.keys(NODE_DATA).forEach(id => selectedNodes.add(id));
        EDGE_DATA.list.forEach(e => selectedEdges.add(e.id));
        RECT_DATA.list.forEach(r => selectedRects.add(r.id));
        TEXT_DATA.list.forEach(t => selectedTexts.add(t.id));
        updateAllSelections();
       }
       if (event.key === "Escape") {
        clearSelection();
       }
      }
      function searchNodes(query) {
   if (!query) {
    clearSearchHighlight();
    return [];
   }
   query = query.toLowerCase();
   const results = [];
   Object.entries(NODE_DATA).forEach(([id, data]) => {
    try {
     const nameMatch = data.name && data.name.toLowerCase().includes(query);
     const ipMatch = data.ip && data.ip.toLowerCase().includes(query);
     const roleMatch = data.role && data.role.toLowerCase().includes(query);
     const tagsMatch = data.tags && Array.isArray(data.tags) && data.tags.some(tag => tag && tag.toLowerCase().includes(query));
     const macMatch = data.mac && data.mac.toLowerCase().includes(query);
     const rackUnitMatch = data.rackUnit && String(data.rackUnit).toLowerCase().includes(query);
     if (nameMatch || ipMatch || roleMatch || tagsMatch || macMatch || rackUnitMatch) {
      results.push(id);
     }
    } catch (e) {
     console.warn("Search error for node:", id, e);
    }
   });
   highlightSearchResults(results);
   return results;
}
		function highlightSearchResults(nodeIds, hasQuery = true) {
		   document.querySelectorAll(".node-group").forEach(node => {
			const nodeId = node.dataset.nodeId;
			if (nodeIds.includes(nodeId)) {
			 node.classList.add("search-highlight");
			 node.classList.remove("search-faded");
			} else {
			 node.classList.remove("search-highlight");
			 if (hasQuery) {
			  node.classList.add("search-faded");
			 } else {
			  node.classList.remove("search-faded");
			 }
			}
		   });
		   document.querySelectorAll(".edge-group, .edge").forEach(edge => {
			if (hasQuery) {
			 edge.classList.add("search-faded");
			} else {
			 edge.classList.remove("search-faded");
			}
		   });
		}
		function clearSearchHighlight() {
		   document.querySelectorAll(".search-highlight").forEach(node => {
			node.classList.remove("search-highlight");
		   });
		   document.querySelectorAll(".search-faded").forEach(el => {
			el.classList.remove("search-faded");
		   });
		}
      function editNodeMac(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       document.getElementById("modal-title").textContent = "Edit MAC Address";
       document.getElementById("modal-input").value = node.mac || "";
       document.getElementById("edit-modal").style.display = "";
	   document.getElementById("edit-modal").classList.add("active");
       document.getElementById("modal-input").focus();
       const modal = document.getElementById("edit-modal");
       const cleanup = () => {
        modal.classList.remove("active");
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
        modal.removeEventListener("click", bgHandler);
       };
       const saveHandler = () => {
        pushUndo("edit mac");
        const value = document.getElementById("modal-input").value.trim();
        node.mac = value;
        cleanup();
        claimTheImmortal(id);
       };
       const cancelHandler = () => {
        cleanup();
       };
       const bgHandler = (e) => {
        if (e.target === modal) cancelHandler();
       };
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       modal.addEventListener("click", bgHandler);
      }
      function editNodeRack(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       document.getElementById("modal-title").textContent = "Edit Rack Unit";
       document.getElementById("modal-input").value = node.rackUnit || "";
       document.getElementById("edit-modal").style.display = "";
       document.getElementById("edit-modal").classList.add("active");
       document.getElementById("modal-input").focus();
	   const modal = document.getElementById("edit-modal");
       const cleanup = () => {
        modal.classList.remove("active");
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
        modal.removeEventListener("click", bgHandler);
       };
       const saveHandler = () => {
        pushUndo("edit rack");
        const value = document.getElementById("modal-input").value.trim();
        node.rackUnit = value;
        cleanup();
        claimTheImmortal(id);
       };
       const cancelHandler = () => {
        cleanup();
       };
       const bgHandler = (e) => {
        if (e.target === modal) cancelHandler();
       };
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       modal.addEventListener("click", bgHandler);
      }
      function editNodeUHeight(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       document.getElementById("modal-title").textContent = "Edit U Height";
       document.getElementById("modal-input").value = node.uHeight || "1";
       document.getElementById("edit-modal").style.display = "";
       document.getElementById("edit-modal").classList.add("active");
       document.getElementById("modal-input").focus();
	   const modal = document.getElementById("edit-modal");
       const cleanup = () => {
        modal.classList.remove("active");
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
        modal.removeEventListener("click", bgHandler);
       };
       const saveHandler = () => {
        pushUndo("edit U height");
        const value = document.getElementById("modal-input").value.trim();
        node.uHeight = value;
        cleanup();
        claimTheImmortal(id);
        forgeTheTopology();
       };
       const cancelHandler = () => {
        cleanup();
       };
       const bgHandler = (e) => {
        if (e.target === modal) cancelHandler();
       };
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       modal.addEventListener("click", bgHandler);
      }
      function updateEdgePortLabels(edgeId) {
       const edge = EDGE_DATA.list.find(e => e.id === edgeId);
       if (!edge) return;
       const fromPortInput = document.getElementById("edge-from-port");
       const toPortInput = document.getElementById("edge-to-port");
       edge.fromPort = fromPortInput ? fromPortInput.value.trim() : "";
       edge.toPort = toPortInput ? toPortInput.value.trim() : "";
       forgeTheTopology();
      }
      document.addEventListener("keydown", handleKeyDown);
      const undoBtn = document.getElementById("undo-btn");
      const redoBtn = document.getElementById("redo-btn");
      if (undoBtn) undoBtn.addEventListener("click", undo);
      if (redoBtn) redoBtn.addEventListener("click", redo);
      const backToTopologyBtn = document.getElementById("back-to-topology-btn");
      if (backToTopologyBtn) {
       backToTopologyBtn.addEventListener("click", exitRack);
      }
      const bulkToolbarClose = document.getElementById("bulk-toolbar-close");
      if (bulkToolbarClose) {
       bulkToolbarClose.addEventListener("click", clearSelection);
      }
      const bulkAlignLeft = document.getElementById("bulk-align-left");
      if (bulkAlignLeft) {
       bulkAlignLeft.addEventListener("click", () => alignSelectedNodes("left"));
      }
      const bulkAlignRight = document.getElementById("bulk-align-right");
      if (bulkAlignRight) {
       bulkAlignRight.addEventListener("click", () => alignSelectedNodes("right"));
      }
      const bulkAlignTop = document.getElementById("bulk-align-top");
      if (bulkAlignTop) {
       bulkAlignTop.addEventListener("click", () => alignSelectedNodes("top"));
      }
      const bulkAlignBottom = document.getElementById("bulk-align-bottom");
      if (bulkAlignBottom) {
       bulkAlignBottom.addEventListener("click", () => alignSelectedNodes("bottom"));
      }
      const bulkDistributeH = document.getElementById("bulk-distribute-h");
      if (bulkDistributeH) {
       bulkDistributeH.addEventListener("click", () => distributeSelectedNodes("horizontal"));
      }
      const bulkDistributeV = document.getElementById("bulk-distribute-v");
      if (bulkDistributeV) {
       bulkDistributeV.addEventListener("click", () => distributeSelectedNodes("vertical"));
      }
      const bulkClone = document.getElementById("bulk-clone");
      if (bulkClone) {
       bulkClone.addEventListener("click", () => {
        if (selectedNodes.size === 0) return;
        pushUndo("clone selected");
        const nodesToClone = Array.from(selectedNodes);
        selectedNodes.clear();
       nodesToClone.forEach(id => {
         cloneNode(id, true);
         selectedNodes.add(currentNodeId);
        });
        updateNodeSelection();
       });
      }
      const bulkDelete = document.getElementById("bulk-delete");
      if (bulkDelete) {
       bulkDelete.addEventListener("click", deleteSelected);
      }
      const bulkMobileBtn = document.getElementById("bulk-mobile-btn");
      const bulkActionsModal = document.getElementById("bulk-actions-modal");
      const bulkModalClose = document.getElementById("bulk-modal-close");
      if (bulkMobileBtn) {
       bulkMobileBtn.addEventListener("click", () => {
        if (bulkActionsModal) bulkActionsModal.style.display = "block";
       });
      }
      if (bulkModalClose) {
       bulkModalClose.addEventListener("click", () => {
        if (bulkActionsModal) bulkActionsModal.style.display = "none";
       });
      }
      const closeModalAfterAction = () => {
       if (bulkActionsModal) bulkActionsModal.style.display = "none";
      };
      const bulkAlignLeftMobile = document.getElementById("bulk-align-left-mobile");
      if (bulkAlignLeftMobile) {
       bulkAlignLeftMobile.addEventListener("click", () => {
        alignSelectedNodes("left");
        closeModalAfterAction();
       });
      }
      const bulkAlignRightMobile = document.getElementById("bulk-align-right-mobile");
      if (bulkAlignRightMobile) {
       bulkAlignRightMobile.addEventListener("click", () => {
        alignSelectedNodes("right");
        closeModalAfterAction();
       });
      }
      const bulkAlignTopMobile = document.getElementById("bulk-align-top-mobile");
      if (bulkAlignTopMobile) {
       bulkAlignTopMobile.addEventListener("click", () => {
        alignSelectedNodes("top");
        closeModalAfterAction();
       });
      }
      const bulkAlignBottomMobile = document.getElementById("bulk-align-bottom-mobile");
      if (bulkAlignBottomMobile) {
       bulkAlignBottomMobile.addEventListener("click", () => {
        alignSelectedNodes("bottom");
        closeModalAfterAction();
       });
      }
      const bulkDistributeHMobile = document.getElementById("bulk-distribute-h-mobile");
      if (bulkDistributeHMobile) {
       bulkDistributeHMobile.addEventListener("click", () => {
        distributeSelectedNodes("horizontal");
        closeModalAfterAction();
       });
      }
      const bulkDistributeVMobile = document.getElementById("bulk-distribute-v-mobile");
      if (bulkDistributeVMobile) {
       bulkDistributeVMobile.addEventListener("click", () => {
        distributeSelectedNodes("vertical");
        closeModalAfterAction();
       });
      }
      const bulkCloneMobile = document.getElementById("bulk-clone-mobile");
      if (bulkCloneMobile) {
       bulkCloneMobile.addEventListener("click", () => {
        if (selectedNodes.size === 0) return;
        pushUndo("clone selected");
        const nodesToClone = Array.from(selectedNodes);
        selectedNodes.clear();
        nodesToClone.forEach(id => {
         cloneNode(id, true);
         selectedNodes.add(currentNodeId);
        });
        updateNodeSelection();
        closeModalAfterAction();
       });
      }
      const bulkDeleteMobile = document.getElementById("bulk-delete-mobile");
      if (bulkDeleteMobile) {
       bulkDeleteMobile.addEventListener("click", () => {
        deleteSelected();
        closeModalAfterAction();
       });
      }
      const bulkLockMobile = document.getElementById("bulk-lock-mobile");
      if (bulkLockMobile) {
       bulkLockMobile.addEventListener("click", () => {
        toggleLockSelected();
        closeModalAfterAction();
       });
      }
      const bulkGroupMobile = document.getElementById("bulk-group-mobile");
      if (bulkGroupMobile) {
       bulkGroupMobile.addEventListener("click", () => {
        toggleGroupSelected();
        closeModalAfterAction();
       });
      }
      const bulkClearMobile = document.getElementById("bulk-clear-mobile");
      if (bulkClearMobile) {
       bulkClearMobile.addEventListener("click", () => {
        clearSelection();
        closeModalAfterAction();
       });
      }
      const searchInput = document.getElementById("search-nodes");
if (searchInput) {
 searchInput.addEventListener("input", (e) => {
  searchNodes(e.target.value);
 });
}
       document.getElementById("save-file-btn").addEventListener("click", becomeImmortal);
       document.getElementById("check-all-ping-btn").addEventListener("click", checkAllNodesStatus);
       const addNodeBtn = document.getElementById("add-node-btn");
       const addNodeModal = document.getElementById("add-node-modal");
       const addNodeCancel = document.getElementById("add-node-cancel");
       const addNodeSave = document.getElementById("add-node-save");
       addNodeBtn.addEventListener("click", () => {
	    if (isViewOnly()) return;
        document.getElementById("new-node-name").value = "";
        document.getElementById("new-node-ip").value = "";
        document.getElementById("new-node-tags").value = "";
        document.getElementById("new-node-shape").value = "circle";
        document.getElementById("new-node-pingable").checked = false;
        document.getElementById("new-node-ping-protocol").value = "http";
        document.getElementById("new-node-custom-url").value = "";
        document.getElementById("new-node-ping-timeout").value = "3000";
        document.getElementById("new-node-ping-options").style.display = "none";
        document.getElementById("new-node-custom-url-container").style.display = "none";
        newNodeIconTags = [];
        document.getElementById("new-node-icon-tags").style.display = "none";
        document.getElementById("new-node-icon-tags-list").innerHTML = "";
        addNodeModal.classList.add("active");
        document.getElementById("new-node-name").focus();
       });
       const canvasViewport = document.getElementById("canvas-viewport");
       if (canvasViewport) {
        canvasViewport.addEventListener("dblclick", (e) => {
         if (currentView.mode === "rack" && e.target.id === "map") {
          exitRack();
         }
        });
       }
       const layersBtn = document.getElementById("layers-btn");
       const layerModal = document.getElementById("layer-modal");
       const layerModalClose = document.getElementById("layer-modal-close");
       if (layersBtn && layerModal) {
        layersBtn.addEventListener("click", () => {
         layerModal.classList.add("active");
        });
       }
       if (layerModalClose && layerModal) {
        layerModalClose.addEventListener("click", () => {
         layerModal.classList.remove("active");
        });
       }
       if (layerModal) {
        layerModal.addEventListener("click", (e) => {
         if (e.target === layerModal) {
          layerModal.classList.remove("active");
         }
        });
       }
       const tabsBtn = document.getElementById("tabs-btn");
       const tabsModal = document.getElementById("tabs-modal");
       const tabsModalClose = document.getElementById("tabs-modal-close");
       if (tabsBtn && tabsModal) {
         tabsBtn.addEventListener("click", () => {
           displayTabs();
           tabsModal.classList.add("active");
         });
       }
       if (tabsModalClose && tabsModal) {
         tabsModalClose.addEventListener("click", () => {
           tabsModal.classList.remove("active");
         });
       }
       if (tabsModal) {
         tabsModal.addEventListener("click", (e) => {
           if (e.target === tabsModal) {
             tabsModal.classList.remove("active");
           }
         });
       }
       const rollbackBtn = document.getElementById("rollback-btn");
       const rollbackModal = document.getElementById("rollback-modal");
       const rollbackModalClose = document.getElementById("rollback-modal-close");
       if (rollbackBtn && rollbackModal) {
         rollbackBtn.addEventListener("click", () => {
           loadRollbackVersions();
           rollbackModal.classList.add("active");
         });
       }
       if (rollbackModalClose && rollbackModal) {
         rollbackModalClose.addEventListener("click", () => {
           rollbackModal.classList.remove("active");
         });
       }
       if (rollbackModal) {
         rollbackModal.addEventListener("click", (e) => {
           if (e.target === rollbackModal) {
             rollbackModal.classList.remove("active");
           }
         });
       }
       const auditLogBtn = document.getElementById("audit-log-btn");
       const auditLogModal = document.getElementById("audit-log-modal");
       const auditLogModalClose = document.getElementById("audit-log-modal-close");
       if (auditLogBtn && auditLogModal) {
         auditLogBtn.addEventListener("click", () => {
           loadAuditLog();
           displayAuditLog();
           auditLogModal.classList.add("active");
         });
       }
       if (auditLogModalClose && auditLogModal) {
         auditLogModalClose.addEventListener("click", () => {
           auditLogModal.classList.remove("active");
         });
       }
	   const portMapBtn = document.getElementById("port-map-btn");
      const portMapModal = document.getElementById("port-map-modal");
      const portMapClose = document.getElementById("port-map-modal-close");
      const portMapSearch = document.getElementById("port-map-search");
      const portMapFilter = document.getElementById("port-map-filter");
      function renderPortMap() {
        const container = document.getElementById("port-map-table");
        const search = (document.getElementById("port-map-search")?.value || "").toLowerCase();
        const filter = document.getElementById("port-map-filter")?.value || "all";
        let edges = EDGE_DATA.list || [];
        if (filter === "with-ports") edges = edges.filter(e => e.fromPort || e.toPort);
        if (filter === "without-ports") edges = edges.filter(e => !e.fromPort && !e.toPort);
        if (search) {
          edges = edges.filter(e => {
            const fromName = (NODE_DATA[e.from]?.name || e.from || "").toLowerCase();
            const toName = (NODE_DATA[e.to]?.name || e.to || "").toLowerCase();
            return fromName.includes(search) || toName.includes(search) || (e.fromPort || "").toLowerCase().includes(search) || (e.toPort || "").toLowerCase().includes(search) || (e.notes || []).join(" ").toLowerCase().includes(search);
          });
        }
        if (edges.length === 0) {
          container.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No connections found</div>';
          return;
        }
        let html = '<table style="width: 100%; border-collapse: collapse; font-size: 13px;">';
        html += '<thead><tr style="background: var(--panel-alt); position: sticky; top: 0;"><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">From Device</th><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">From Port</th><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">To Device</th><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">To Port</th><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">Notes</th></tr></thead><tbody>';
        edges.forEach(e => {
          const fromName = NODE_DATA[e.from]?.name || e.from;
          const toName = NODE_DATA[e.to]?.name || e.to;
          const notes = (e.notes || []).join(", ");
          const edgeColor = e.color || EDGE_LEGEND[e.type]?.color || 'var(--edge-main)';
          const fromPortDisplay = e.fromPort ? escapeHtml(e.fromPort) : "-";
          const toPortDisplay = e.toPort ? escapeHtml(e.toPort) : "-";
          const goToEdge = `document.getElementById('port-map-modal').classList.remove('active'); selectTheConnection('${escapeHtml(e.id)}'); focusOnSelected()`;
          html += `<tr style="border-bottom: 1px solid var(--edge-main);"><td style="padding: 10px;"><span style="display: inline-block; width: 8px; height: 8px; border-radius: 50%; background: ${edgeColor}; margin-right: 8px;"></span><span style="cursor: pointer; text-decoration: underline;" onclick="document.getElementById('port-map-modal').classList.remove('active'); claimTheImmortal('${escapeHtml(e.from)}'); focusOnSelected()">${escapeHtml(fromName)}</span></td><td style="padding: 10px; font-family: monospace;"><span style="color: ${e.fromPort ? 'var(--accent)' : 'var(--text-soft)'}; cursor: pointer;" onclick="editPortFromMap('${escapeHtml(e.id)}', 'from')">${fromPortDisplay}</span> <span style="cursor: pointer; opacity: 0.6; font-size: 11px;" onclick="${goToEdge}" title="Go to connection">‚Üó</span></td><td style="padding: 10px; cursor: pointer; text-decoration: underline;" onclick="document.getElementById('port-map-modal').classList.remove('active'); claimTheImmortal('${escapeHtml(e.to)}'); focusOnSelected()">${escapeHtml(toName)}</td><td style="padding: 10px; font-family: monospace;"><span style="color: ${e.toPort ? 'var(--accent)' : 'var(--text-soft)'}; cursor: pointer;" onclick="editPortFromMap('${escapeHtml(e.id)}', 'to')">${toPortDisplay}</span> <span style="cursor: pointer; opacity: 0.6; font-size: 11px;" onclick="${goToEdge}" title="Go to connection">‚Üó</span></td><td style="padding: 10px; color: var(--text-soft); font-size: 12px;">${escapeHtml(notes) || "-"}</td></tr>`;
        });
        html += '</tbody></table>';
        container.innerHTML = html;
      }
      window.editPortFromMap = function(edgeId, which) {
        const edge = EDGE_DATA.list.find(e => e.id === edgeId);
        if (!edge) return;
        const fromName = NODE_DATA[edge.from]?.name || edge.from;
        const toName = NODE_DATA[edge.to]?.name || edge.to;
        const nodeId = which === 'from' ? edge.from : edge.to;
        const nodeName = which === 'from' ? fromName : toName;
        const label = `Port on ${nodeName}:`;
        const currentVal = which === 'from' ? (edge.fromPort || '') : (edge.toPort || '');
        const newVal = prompt(label, currentVal);
        if (newVal !== null && newVal !== '') {
          const isDuplicate = (EDGE_DATA.list || []).some(e => {
            if (e.id === edgeId) return false;
            if (e.from === nodeId && e.fromPort === newVal) return true;
            if (e.to === nodeId && e.toPort === newVal) return true;
            return false;
          });
          if (isDuplicate && !confirm(`Warning: Port "${newVal}" is already used on ${nodeName}. Use anyway?`)) {
            return;
          }
          if (which === 'from') edge.fromPort = newVal;
          else edge.toPort = newVal;
          renderPortMap();
          if (currentNodeId && (edge.from === currentNodeId || edge.to === currentNodeId)) {
            claimTheImmortal(currentNodeId);
          }
        } else if (newVal === '') {
          if (which === 'from') edge.fromPort = '';
          else edge.toPort = '';
          renderPortMap();
          if (currentNodeId && (edge.from === currentNodeId || edge.to === currentNodeId)) {
            claimTheImmortal(currentNodeId);
          }
        }
      };
      window.exportPortMap = function() {
        let csv = "From Device,From Port,To Device,To Port,Notes\n";
        (EDGE_DATA.list || []).forEach(e => {
          const fromName = (NODE_DATA[e.from]?.name || e.from || "").replace(/,/g, ";");
          const toName = (NODE_DATA[e.to]?.name || e.to || "").replace(/,/g, ";");
          const notes = (e.notes || []).join("; ").replace(/,/g, ";");
          csv += `"${fromName}","${e.fromPort || ""}","${toName}","${e.toPort || ""}","${notes}"\n`;
        });
        const blob = new Blob([csv], { type: "text/csv" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "port-map.csv";
        a.click();
        URL.revokeObjectURL(url);
      };
      if (portMapBtn && portMapModal) {
        portMapBtn.addEventListener("click", () => { renderPortMap(); portMapModal.classList.add("active"); });
      }
      if (portMapClose && portMapModal) {
        portMapClose.addEventListener("click", () => { portMapModal.classList.remove("active"); });
      }
      if (portMapSearch) { portMapSearch.addEventListener("input", renderPortMap); }
      if (portMapFilter) { portMapFilter.addEventListener("change", renderPortMap); }
      if (portMapModal) {
        portMapModal.addEventListener("click", (e) => { if (e.target === portMapModal) portMapModal.classList.remove("active"); });
      }
       if (auditLogModal) {
         auditLogModal.addEventListener("click", (e) => {
           if (e.target === auditLogModal) {
             auditLogModal.classList.remove("active");
           }
         });
       }
       const auditFilter = document.getElementById("audit-filter");
       if (auditFilter) {
         auditFilter.addEventListener("change", (e) => {
           displayAuditLog(e.target.value);
         });
       }
       const secretsBtn = document.getElementById("secrets-btn");
       const secretsModal = document.getElementById("secrets-modal");
       const secretsModalClose = document.getElementById("secrets-modal-close");
       if (secretsBtn && secretsModal) {
         secretsBtn.addEventListener("click", () => {
           displaySecrets();
           secretsModal.classList.add("active");
         });
       }
       if (secretsModalClose && secretsModal) {
         secretsModalClose.addEventListener("click", () => {
           secretsModal.classList.remove("active");
         });
       }
       if (secretsModal) {
         secretsModal.addEventListener("click", (e) => {
           if (e.target === secretsModal) {
             secretsModal.classList.remove("active");
           }
         });
       }
       const secretEditorModal = document.getElementById("secret-editor-modal");
       if (secretEditorModal) {
         secretEditorModal.addEventListener("click", (e) => {
           if (e.target === secretEditorModal) {
             closeSecretEditor();
           }
         });
       }
       ["physical", "logical", "security", "application"].forEach(layer => {
        const checkbox = document.getElementById(`layer-${layer}`);
        if (checkbox) {
         checkbox.addEventListener("change", applyLayerFilter);
        }
       });
       const layerSelect = document.getElementById("node-layer");
       if (layerSelect) {
        layerSelect.addEventListener("change", (e) => {
         if (currentNodeId) {
          pushUndo("change layer");
          NODE_DATA[currentNodeId].layer = e.target.value;
          forgeTheTopology();
         }
        });
       }
       const assignedRackSelect = document.getElementById("node-assigned-rack");
       if (assignedRackSelect) {
        assignedRackSelect.addEventListener("change", (e) => {
      if (currentNodeId) {
      pushUndo("change assigned rack");
      EDGE_DATA.list = EDGE_DATA.list.filter(edge => edge.from !== currentNodeId && edge.to !== currentNodeId);
      NODE_DATA[currentNodeId].assignedRack = e.target.value;
      forgeTheTopology();
      claimTheImmortal(currentNodeId);
      }
      });
       }
       const rackCapacitySelect = document.getElementById("node-rack-capacity");
       if (rackCapacitySelect) {
        rackCapacitySelect.addEventListener("change", (e) => {
         if (currentNodeId) {
          pushUndo("change rack capacity");
          NODE_DATA[currentNodeId].rackCapacity = e.target.value;
          forgeTheTopology();
         }
        });
       }
       const addRackBtn = document.getElementById("add-rack-btn");
       const addRackModal = document.getElementById("add-rack-modal");
       const addRackCancel = document.getElementById("add-rack-cancel");
       const addRackSave = document.getElementById("add-rack-save");
       if (addRackBtn && addRackModal) {
        addRackBtn.addEventListener("click", () => {
		if (isViewOnly()) return;
         document.getElementById("new-rack-name").value = "";
         document.getElementById("new-rack-ip").value = "";
         document.getElementById("new-rack-tags").value = "";
         document.getElementById("new-rack-shape").value = "server";
         document.getElementById("new-rack-capacity").value = "42";
         selectedRackIconData = null;
         document.getElementById('selected-rack-icon').style.display = 'none';
         addRackModal.classList.add("active");
         document.getElementById("new-rack-name").focus();
        });
       }
       if (addRackCancel && addRackModal) {
        addRackCancel.addEventListener("click", () => {
         addRackModal.classList.remove("active");
        });
       }
       if (addRackModal) {
        addRackModal.addEventListener("click", (e) => {
         if (e.target === addRackModal) {
          addRackModal.classList.remove("active");
         }
        });
       }
       if (addRackSave && addRackModal) {
        addRackSave.addEventListener("click", () => {
         const name = document.getElementById("new-rack-name").value.trim();
         const ip = document.getElementById("new-rack-ip").value.trim();
         const tagsStr = document.getElementById("new-rack-tags").value.trim();
         const shape = document.getElementById("new-rack-shape").value;
         const capacity = document.getElementById("new-rack-capacity").value;
         if (!name) {
          alert("Please enter a rack name.");
          return;
         }
         const tags = tagsStr ? tagsStr.split(",").map((t) => t.trim()).filter((t) => t) : [];
         let baseId = name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");
         if (!baseId) baseId = "rack";
         let nodeId = baseId;
         let counter = 1;
         while (NODE_DATA[nodeId]) {
          nodeId = baseId + "-" + counter;
          counter++;
         }
         pushUndo("add rack");
         NODE_DATA[nodeId] = {
          shape: shape,
          name: name,
          ip: ip || "",
          role: "Rack",
          tags: tags,
          notes: [],
          mac: "",
          rackUnit: "",
          uHeight: "1",
          layer: "physical",
          assignedRack: "",
          rackCapacity: capacity,
          isRack: true,
          locked: false,
          groupId: null
         };
         const viewWidth = CANVAS_WIDTH / canvasState.zoom;
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         const centerX = canvasState.panX + (viewWidth / 2);
         const centerY = canvasState.panY + (viewHeight / 2);
         savedPositions[nodeId] = {
          x: centerX,
          y: centerY
         };
         if (selectedRackIconData) {
          if (!savedStyles[nodeId]) {
           savedStyles[nodeId] = {};
          }
          if (!savedStyles[nodeId]['all']) {
           savedStyles[nodeId]['all'] = {};
          }
          savedStyles[nodeId]['all'].icon = {
           library: selectedRackIconData.library,
           name: selectedRackIconData.name
          };
          selectedRackIconData = null;
          document.getElementById('selected-rack-icon').style.display = 'none';
         }
         addRackModal.classList.remove("active");
         forgeTheTopology();
         claimTheImmortal(nodeId);
        });
        ["new-rack-name", "new-rack-ip", "new-rack-tags"].forEach((inputId) => {
         const input = document.getElementById(inputId);
         if (input) {
          input.addEventListener("keypress", (e) => {
           if (e.key === "Enter") {
            addRackSave.click();
           }
          });
         }
        });
       }
       addNodeCancel.addEventListener("click", () => {
        addNodeModal.classList.remove("active");
       });
       addNodeModal.addEventListener("click", (e) => {
        if (e.target === addNodeModal) {
         addNodeModal.classList.remove("active");
        }
       });
       addNodeSave.addEventListener("click", () => {
        const name = document.getElementById("new-node-name").value.trim();
        const ip = document.getElementById("new-node-ip").value.trim();
        const tagsStr = document.getElementById("new-node-tags").value.trim();
        const shape = document.getElementById("new-node-shape").value;
        const pingable = document.getElementById("new-node-pingable").checked;
        const pingProtocol = document.getElementById("new-node-ping-protocol").value;
        const pingCustomUrl = document.getElementById("new-node-custom-url").value.trim();
        const pingTimeout = parseInt(document.getElementById("new-node-ping-timeout").value) || 3000;
        if (!name) {
         alert("Please enter a node name.");
         return;
        }
        const tags = tagsStr ? tagsStr.split(",").map((t) => t.trim()).filter((t) => t) : [];
        if (newNodeIconTags.length > 0) {
         tags.push(...newNodeIconTags);
        }
        let baseId = name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");
        if (!baseId) baseId = "node";
        let nodeId = baseId;
        let counter = 1;
        while (NODE_DATA[nodeId]) {
         nodeId = baseId + "-" + counter;
         counter++;
        }
		pushUndo("add node");
        NODE_DATA[nodeId] = {
         shape: shape || "circle",
         name: name,
         ip: ip || "0.0.0.0",
         role: "",
         tags: tags,
         notes: [],
         mac: "",
         rackUnit: "",
         uHeight: "1",
         ping: {
          enabled: pingable,
          protocol: pingProtocol,
          customUrl: pingCustomUrl,
          timeout: pingTimeout,
          status: 'unknown',
          lastCheck: null
         },
         locked: false,
         groupId: null
        };
        if (currentView.mode === "rack" && currentView.rackId) {
         NODE_DATA[nodeId].assignedRack = currentView.rackId;
         NODE_DATA[nodeId].layer = "physical";
         const rackCapacity = getRackCapacity(currentView.rackId);
         const rackUHeight = getRackUHeight(currentView.rackId);
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         const centerY = canvasState.panY + (viewHeight / 2);
         let unit = rackCapacity - Math.round((centerY - RACK_START_Y) / rackUHeight);
         unit = Math.max(1, Math.min(rackCapacity, unit));
         NODE_DATA[nodeId].rackUnit = String(unit);
        }
        if (selectedNodeIconData) {
         if (!savedStyles[nodeId]) savedStyles[nodeId] = {};
         if (!savedStyles[nodeId]['all']) savedStyles[nodeId]['all'] = {};
         savedStyles[nodeId]['all'].icon = {
          library: selectedNodeIconData.library,
          name: selectedNodeIconData.name
         };
         selectedNodeIconData = null;
         document.getElementById('selected-node-icon').style.display = 'none';
        }
        newNodeIconTags = [];
      const viewWidth = CANVAS_WIDTH / canvasState.zoom;
      const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
      const centerX = canvasState.panX + (viewWidth / 2);
      const centerY = canvasState.panY + (viewHeight / 2);
      savedPositions[nodeId] = {
      x: centerX,
      y: centerY
      };
        addNodeModal.classList.remove("active");
        forgeTheTopology();
        claimTheImmortal(nodeId);
       });
       ["new-node-name", "new-node-ip", "new-node-tags"].forEach(
        (inputId) => {
         document.getElementById(inputId).addEventListener("keypress", (e) => {
          if (e.key === "Enter") {
           addNodeSave.click();
          }
         });
        }, );
       document.getElementById('new-node-pingable').addEventListener('change', (e) => {
        const pingOptions = document.getElementById('new-node-ping-options');
        pingOptions.style.display = e.target.checked ? 'block' : 'none';
       });
       document.getElementById('new-node-ping-protocol').addEventListener('change', (e) => {
        const customUrlContainer = document.getElementById('new-node-custom-url-container');
        customUrlContainer.style.display = e.target.value === 'custom' ? 'block' : 'none';
       });
       document.getElementById('pick-rack-icon-btn').addEventListener('click', () => {
        openIconPicker((iconData) => {
         selectedRackIconData = iconData;
         const preview = document.getElementById('selected-rack-icon-preview');
         const container = document.getElementById('selected-rack-icon');
         const parser = new DOMParser();
         const doc = parser.parseFromString(iconData.svg, 'image/svg+xml');
         const svgEl = doc.querySelector('svg');
         preview.innerHTML = '';
         if (svgEl) {
          preview.appendChild(svgEl.cloneNode(true));
         }
         const nameSpan = document.createElement('span');
         nameSpan.textContent = iconData.name;
         preview.appendChild(nameSpan);
         container.style.display = 'block';
        });
       });
       document.getElementById('pick-node-icon-btn').addEventListener('click', () => {
        openIconPicker((iconData) => {
         selectedNodeIconData = iconData;
         const preview = document.getElementById('selected-node-icon-preview');
         const container = document.getElementById('selected-node-icon');
         const parser = new DOMParser();
         const doc = parser.parseFromString(iconData.svg, 'image/svg+xml');
         const svgEl = doc.querySelector('svg');
         preview.innerHTML = '';
         if (svgEl) {
          preview.appendChild(svgEl.cloneNode(true));
         }
         const nameSpan = document.createElement('span');
         nameSpan.textContent = iconData.name;
         preview.appendChild(nameSpan);
         container.style.display = 'block';
        });
       });
       document.getElementById('pick-tag-icon-btn').addEventListener('click', () => {
        if (!currentNodeId) return;
        openIconPicker((iconData) => {
         if (!currentNodeId || !NODE_DATA[currentNodeId]) return;
         if (!NODE_DATA[currentNodeId].tags) {
          NODE_DATA[currentNodeId].tags = [];
         }
         NODE_DATA[currentNodeId].tags.push({
          type: 'icon',
          library: iconData.library,
          name: iconData.name
         });
         forgeTheTopology();
         claimTheImmortal(currentNodeId);
        });
       });
       document.getElementById('pick-new-node-tag-icon-btn').addEventListener('click', () => {
        openIconPicker((iconData) => {
         newNodeIconTags.push({
          type: 'icon',
          library: iconData.library,
          name: iconData.name
         });
         const container = document.getElementById('new-node-icon-tags');
         const list = document.getElementById('new-node-icon-tags-list');
         const badge = document.createElement('div');
         badge.className = 'icon-badge';
         badge.style.cssText = 'display: inline-flex; align-items: center; gap: 6px; padding: 6px 10px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; font-size: 13px;';
         const iconPreview = document.createElement('div');
         iconPreview.style.cssText = 'width: 16px; height: 16px; display: flex; align-items: center; justify-content: center;';
         IconLibrary.getIcon(iconData.library, iconData.name).then(svg => {
          if (svg) {
           const parser = new DOMParser();
           const doc = parser.parseFromString(svg, 'image/svg+xml');
           const svgEl = doc.querySelector('svg');
           if (svgEl) {
            svgEl.setAttribute('width', '16');
            svgEl.setAttribute('height', '16');
            svgEl.style.fill = 'var(--text-main)';
            iconPreview.appendChild(svgEl);
           }
          }
         });
         const name = document.createElement('span');
         name.textContent = iconData.name;
         name.style.color = 'var(--text-soft)';
         const removeBtn = document.createElement('button');
         removeBtn.textContent = '√ó';
         removeBtn.style.cssText = 'background: none; border: none; color: var(--danger); cursor: pointer; font-size: 18px; line-height: 1; padding: 0 4px;';
         removeBtn.addEventListener('click', () => {
          const index = newNodeIconTags.findIndex(t => t.type === 'icon' && t.library === iconData.library && t.name === iconData.name);
          if (index > -1) {
           newNodeIconTags.splice(index, 1);
          }
          badge.remove();
          if (list.children.length === 0) {
           container.style.display = 'none';
          }
         });
         badge.appendChild(iconPreview);
         badge.appendChild(name);
         badge.appendChild(removeBtn);
         list.appendChild(badge);
         container.style.display = 'block';
        });
       });
       document.getElementById('pick-shape-icon-btn').addEventListener('click', () => {
        if (!currentNodeId) return;
        openIconPicker((iconData) => {
         if (!savedStyles[currentNodeId]) {
          savedStyles[currentNodeId] = {};
         }
         if (!savedStyles[currentNodeId][currentStyleScope]) {
          savedStyles[currentNodeId][currentStyleScope] = {};
         }
         savedStyles[currentNodeId][currentStyleScope].icon = {
          library: iconData.library,
          name: iconData.name
         };
		 delete savedStyles[currentNodeId][currentStyleScope].circleColor;
         delete savedStyles[currentNodeId][currentStyleScope].circleBorder;
         const shapeSelect = document.getElementById('shape-select');
         if (!shapeSelect.querySelector('option[value="custom-icon"]')) {
          const opt = document.createElement('option');
          opt.value = 'custom-icon';
          opt.textContent = 'Custom Icon';
          shapeSelect.insertBefore(opt, shapeSelect.firstChild);
         }
         shapeSelect.value = 'custom-icon';
         forgeTheTopology();
        });
       });
       document.getElementById('add-tag-btn').addEventListener('click', () => {
        if (!currentNodeId) return;
        if (!NODE_DATA[currentNodeId]) return;
        const input = document.getElementById('new-tag-input');
        const tagText = input.value.trim();
        if (!tagText) return;
        if (!NODE_DATA[currentNodeId].tags) {
         NODE_DATA[currentNodeId].tags = [];
        }
        NODE_DATA[currentNodeId].tags.push(tagText);
        input.value = '';
        forgeTheTopology();
        claimTheImmortal(currentNodeId);
       });
      function saveRollbackVersion(description = "Auto-save") {
        const version = {
          timestamp: Date.now(),
          description,
          data: captureTheQuickening()
        };
        try {
          const stored = localStorage.getItem(ROLLBACK_STORAGE_KEY);
          rollbackVersions = stored ? JSON.parse(stored) : [];
        } catch (e) {
          rollbackVersions = [];
        }
        rollbackVersions.unshift(version);
        if (rollbackVersions.length > MAX_ROLLBACK_VERSIONS) {
          rollbackVersions = rollbackVersions.slice(0, MAX_ROLLBACK_VERSIONS);
        }
        try {
          localStorage.setItem(ROLLBACK_STORAGE_KEY, JSON.stringify(rollbackVersions));
        } catch (e) {
          console.warn("Failed to save rollback version:", e);
        }
      }
      function loadRollbackVersions() {
        try {
          const stored = localStorage.getItem(ROLLBACK_STORAGE_KEY);
          rollbackVersions = stored ? JSON.parse(stored) : [];
          displayRollbackVersions();
        } catch (e) {
          console.warn("Failed to load rollback versions:", e);
          rollbackVersions = [];
        }
      }
      function displayRollbackVersions() {
        const listEl = document.getElementById("rollback-list");
        if (!listEl) return;
        if (rollbackVersions.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No version history yet. Versions are saved automatically when you save the file.</div>';
          return;
        }
        listEl.innerHTML = rollbackVersions.map((version, index) => {
          const date = new Date(version.timestamp);
          const timeStr = date.toLocaleString();
          const nodeCount = Object.keys(version.data.nodeData || {}).length;
          const edgeCount = (version.data.edgeData?.list || []).length;
          return `
            <div class="version-item" onclick="restoreRollbackVersion(${index})">
              <div class="version-info">
                <div class="timestamp">${escapeHtml(timeStr)}</div>
                <div class="details">${escapeHtml(version.description)} ‚Ä¢ ${nodeCount} nodes ‚Ä¢ ${edgeCount} connections</div>
              </div>
              <div class="version-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteRollbackVersion(${index})" title="Delete this version">üóëÔ∏è</button>
              </div>
            </div>
          `;
        }).join('');
      }
      function restoreRollbackVersion(index) {
        if (!confirm(`Restore version from ${new Date(rollbackVersions[index].timestamp).toLocaleString()}?\n\nYour current work will be lost unless you save first.`)) {
          return;
        }
        const version = rollbackVersions[index];
        const data = version.data;
        NODE_DATA = data.nodeData || {};
        EDGE_DATA = data.edgeData || { list: [] };
        RECT_DATA = data.rectData || { list: [] };
        TEXT_DATA = data.textData || { list: [] };
        EDGE_LEGEND = data.edgeLegend || {};
        savedPositions = data.nodePositions || {};
        savedSizes = data.nodeSizes || {};
        savedStyles = data.nodeStyles || {};
        PAGE_STATE = data.page || PAGE_STATE;
        if (data.canvas) {
          canvasState.zoom = data.canvas.zoom;
          canvasState.panX = data.canvas.panX;
          canvasState.panY = data.canvas.panY;
        }
        wieldThePower();
        forgeTheTopology();
        document.getElementById("rollback-modal").classList.remove("active");
        logAuditEvent("rollback", `Restored version from ${new Date(version.timestamp).toLocaleString()}`);
      }
      function deleteRollbackVersion(index) {
        if (!confirm("Delete this version from history?")) return;
        rollbackVersions.splice(index, 1);
        try {
          localStorage.setItem(ROLLBACK_STORAGE_KEY, JSON.stringify(rollbackVersions));
        } catch (e) {
          console.warn("Failed to delete version:", e);
        }
        displayRollbackVersions();
      }
      function clearRollbackHistory() {
        if (!confirm("Clear all version history?\n\nThis cannot be undone.")) return;
        rollbackVersions = [];
        localStorage.removeItem(ROLLBACK_STORAGE_KEY);
        displayRollbackVersions();
      }
      function createManualSnapshot() {
        const description = prompt("Enter a description for this snapshot:", "Manual snapshot");
        if (!description) return;
        saveRollbackVersion(description);
        displayRollbackVersions();
      }
      function switchTab(index) {
        if (index === currentTabIndex) return;
        const currentTab = documentTabs[currentTabIndex];
        currentTab.nodes = JSON.parse(JSON.stringify(NODE_DATA));
        currentTab.edges = JSON.parse(JSON.stringify(EDGE_DATA));
        currentTab.positions = JSON.parse(JSON.stringify(savedPositions));
        currentTab.sizes = JSON.parse(JSON.stringify(savedSizes));
        currentTab.styles = JSON.parse(JSON.stringify(savedStyles));
        currentTab.legend = JSON.parse(JSON.stringify(EDGE_LEGEND));
        currentTab.rects = JSON.parse(JSON.stringify(RECT_DATA));
        currentTab.texts = JSON.parse(JSON.stringify(TEXT_DATA));
        currentTab.pageState = JSON.parse(JSON.stringify(PAGE_STATE));
        currentTabIndex = index;
        const newTab = documentTabs[index];
        NODE_DATA = JSON.parse(JSON.stringify(newTab.nodes));
        EDGE_DATA = JSON.parse(JSON.stringify(newTab.edges));
        savedPositions = JSON.parse(JSON.stringify(newTab.positions));
        savedSizes = JSON.parse(JSON.stringify(newTab.sizes));
        savedStyles = JSON.parse(JSON.stringify(newTab.styles));
        EDGE_LEGEND = JSON.parse(JSON.stringify(newTab.legend));
        RECT_DATA = JSON.parse(JSON.stringify(newTab.rects));
        TEXT_DATA = JSON.parse(JSON.stringify(newTab.texts));
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, newTab.pageState || {});
        wieldThePower();
        document.title = PAGE_STATE.title || newTab.name;
        document.getElementById("page-title").textContent = PAGE_STATE.title || newTab.name;
        forgeTheTopology();
        currentNodeId = null;
        currentEdgeId = null;
        currentTextId = null;
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        displayTabs();
        logAuditEvent("tab", `Switched to tab: ${newTab.name}`);
      }
      function createNewTab() {
        const nameInput = document.getElementById("new-tab-name");
        const name = nameInput.value.trim();
        if (!name) {
          alert("Please enter a tab name");
          return;
        }
        const newTab = {
          id: `tab-${Date.now()}`,
          name,
          nodes: {},
          edges: { list: [] },
          positions: {},
          sizes: {},
          styles: {},
          legend: {},
          rects: { list: [] },
          texts: { list: [] },
      pageState: null
        };
        documentTabs.push(newTab);
        nameInput.value = "";
        displayTabs();
        logAuditEvent("tab", `Created new tab: ${name}`);
      }
      function renameTab(index) {
        const tab = documentTabs[index];
        const newName = prompt("Enter new name:", tab.name);
        if (!newName || newName === tab.name) return;
        tab.name = newName;
        displayTabs();
        logAuditEvent("tab", `Renamed tab to: ${newName}`);
      }
      function deleteTab(index) {
        if (documentTabs.length === 1) {
          alert("Cannot delete the last tab");
          return;
        }
        if (!confirm(`Delete tab "${documentTabs[index].name}"?`)) return;
        const wasCurrentTab = (index === currentTabIndex);
        documentTabs.splice(index, 1);
        if (currentTabIndex >= documentTabs.length) {
          currentTabIndex = documentTabs.length - 1;
        } else if (index < currentTabIndex) {
          currentTabIndex--;
        }
        if (wasCurrentTab) {
          const newTab = documentTabs[currentTabIndex];
          NODE_DATA = JSON.parse(JSON.stringify(newTab.nodes));
          EDGE_DATA = JSON.parse(JSON.stringify(newTab.edges));
          savedPositions = JSON.parse(JSON.stringify(newTab.positions));
          savedSizes = JSON.parse(JSON.stringify(newTab.sizes));
          savedStyles = JSON.parse(JSON.stringify(newTab.styles));
          EDGE_LEGEND = JSON.parse(JSON.stringify(newTab.legend));
          RECT_DATA = JSON.parse(JSON.stringify(newTab.rects));
          TEXT_DATA = JSON.parse(JSON.stringify(newTab.texts));
          PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, newTab.pageState || {});
          wieldThePower();
          forgeTheTopology();
          currentNodeId = null;
          currentEdgeId = null;
          currentTextId = null;
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("text-panel").style.display = "none";
        }
        displayTabs();
        logAuditEvent("tab", `Deleted tab`);
      }
      function displayTabs() {
        const listEl = document.getElementById("tabs-list");
        if (!listEl) return;
        listEl.innerHTML = documentTabs.map((tab, index) => {
          const nodeCount = Object.keys(tab.nodes).length;
          const edgeCount = tab.edges.list.length;
          const isActive = index === currentTabIndex;
          return `
            <div class="tab-item ${isActive ? 'active' : ''}" onclick="switchTab(${index})">
              <div class="tab-name">${escapeHtml(tab.name)}</div>
              <div class="tab-stats">${nodeCount} nodes ‚Ä¢ ${edgeCount} connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(${index})" title="Rename tab">‚úèÔ∏è</button>
                ${documentTabs.length > 1 ? '<button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(' + index + ')" title="Delete tab">üóëÔ∏è</button>' : ''}
              </div>
            </div>
          `;
        }).join('');
      }
      function logAuditEvent(type, description, details = {}) {
        const event = {
          timestamp: Date.now(),
          type,
          description,
          details,
          tab: documentTabs[currentTabIndex]?.name || "Main"
        };
        auditLog.unshift(event);
        if (auditLog.length > MAX_AUDIT_ENTRIES) {
          auditLog = auditLog.slice(0, MAX_AUDIT_ENTRIES);
        }
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to save audit log:", e);
        }
      }
      function loadAuditLog() {
        let embeddedLog = [];
        let localLog = [];
        try {
          const stateScript = document.getElementById("topology-state");
          if (stateScript) {
            const stateData = JSON.parse(stateScript.textContent);
            if (stateData.auditLog && Array.isArray(stateData.auditLog)) {
              embeddedLog = stateData.auditLog;
            }
          }
        } catch (e) {
          console.warn("Failed to load embedded audit log:", e);
        }
        try {
          const stored = localStorage.getItem(AUDIT_STORAGE_KEY);
          if (stored) {
            localLog = JSON.parse(stored);
          }
        } catch (e) {
          console.warn("Failed to load localStorage audit log:", e);
        }
        const merged = [...embeddedLog, ...localLog];
        const seen = new Set();
        auditLog = merged.filter(entry => {
          const key = entry.timestamp + entry.description;
          if (seen.has(key)) return false;
          seen.add(key);
          return true;
        }).sort((a, b) => b.timestamp - a.timestamp);
        if (auditLog.length > MAX_AUDIT_ENTRIES) {
          auditLog = auditLog.slice(0, MAX_AUDIT_ENTRIES);
        }
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to sync audit log:", e);
        }
      }
      function displayAuditLog(filter = "all") {
        const listEl = document.getElementById("audit-log-list");
        if (!listEl) return;
        const filtered = filter === "all" ? auditLog : auditLog.filter(e => e.type === filter);
        if (filtered.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No audit entries yet</div>';
          return;
        }
        listEl.innerHTML = filtered.map(event => {
          const date = new Date(event.timestamp);
          const timeStr = date.toLocaleString();
          return `
            <div class="audit-entry ${escapeHtml(event.type)}">
              <div class="time">[${escapeHtml(timeStr)}] ${escapeHtml(event.tab)}</div>
              <div class="action">[${escapeHtml(event.type.toUpperCase())}] ${escapeHtml(event.description)}</div>
            </div>
          `;
        }).join('');
      }
      function clearAuditLog() {
        if (!confirm("Clear all audit log entries?\n\nThis cannot be undone.")) return;
        auditLog = [];
        localStorage.removeItem(AUDIT_STORAGE_KEY);
        displayAuditLog();
      }
      function exportAuditLog() {
        if (auditLog.length === 0) {
          alert("No audit entries to export");
          return;
        }
        const csv = [
          ["Timestamp", "Tab", "Type", "Description"],
          ...auditLog.map(e => [
            new Date(e.timestamp).toISOString(),
            e.tab,
            e.type,
            e.description
          ])
        ].map(row => row.map(cell => `"${cell}"`).join(",")).join("\n");
        const blob = new Blob([csv], { type: "text/csv" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `audit-log-${Date.now()}.csv`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }
      let currentSecretName = null;
      function createNewSecret() {
        const nameInput = document.getElementById("new-secret-name");
        const name = nameInput.value.trim();
        if (!name) {
          alert("Please enter a note name");
          return;
        }
        if (encryptedSections[name]) {
          alert("A note note with this name already exists");
          return;
        }
        currentSecretName = name;
        encryptedSections[name] = { encrypted: false, data: "" };
        nameInput.value = "";
        document.getElementById("secret-editor-title").textContent = `New note: ${name}`;
        document.getElementById("secret-editor-content").value = "";
        document.getElementById("secrets-modal").classList.remove("active");
        document.getElementById("secret-editor-modal").classList.add("active");
        displaySecrets();
      }
      function editSecret(name) {
        currentSecretName = name;
        const section = encryptedSections[name];
        if (section.encrypted) {
          const password = prompt(`Enter password to decrypt "${name}":`);
          if (!password) return;
          try {
            decryptData(section.data, password).then(decrypted => {
              document.getElementById("secret-editor-title").textContent = `Edit Secret: ${name}`;
              document.getElementById("secret-editor-content").value = decrypted;
              document.getElementById("secrets-modal").classList.remove("active");
              document.getElementById("secret-editor-modal").classList.add("active");
            }).catch(e => {
              alert("Failed to decrypt. Wrong password?");
            });
          } catch (e) {
            alert("Failed to decrypt. Wrong password?");
          }
        } else {
          document.getElementById("secret-editor-title").textContent = `Edit note: ${name}`;
          document.getElementById("secret-editor-content").value = section.data;
          document.getElementById("secrets-modal").classList.remove("active");
          document.getElementById("secret-editor-modal").classList.add("active");
        }
      }
      async function saveSecret() {
        if (!currentSecretName) return;
        const content = document.getElementById("secret-editor-content").value;
        const autoEncrypt = document.getElementById("secret-auto-encrypt").checked;
        if (autoEncrypt) {
          const password = prompt(`Enter password to encrypt "${currentSecretName}":`);
          if (!password) return;
          const confirmPassword = prompt("Confirm password:");
          if (password !== confirmPassword) {
            alert("Passwords do not match");
            return;
          }
          try {
            const encrypted = await encryptData(content, password);
            encryptedSections[currentSecretName] = { encrypted: true, data: encrypted };
          } catch (e) {
            alert("Encryption failed: " + e.message);
            return;
          }
        } else {
          encryptedSections[currentSecretName] = { encrypted: false, data: content };
        }
        closeSecretEditor();
        displaySecrets();
        logAuditEvent("secret", `Saved note section: ${currentSecretName}`);
      }
      function closeSecretEditor() {
        document.getElementById("secret-editor-modal").classList.remove("active");
        document.getElementById("secrets-modal").classList.add("active");
        currentSecretName = null;
      }
      function deleteSecret(name) {
        if (!confirm(`Delete note "${name}"?`)) return;
        delete encryptedSections[name];
        displaySecrets();
        logAuditEvent("secret", `Deleted note: ${name}`);
      }
      function displaySecrets() {
        const listEl = document.getElementById("secrets-list");
        if (!listEl) return;
        const secrets = Object.keys(encryptedSections);
        if (secrets.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No notes yet</div>';
          return;
        }
        listEl.innerHTML = secrets.map(name => {
          const section = encryptedSections[name];
          const status = section.encrypted ? "üîí Encrypted" : "üîì Plaintext";
          return `
            <div class="secret-item">
              <div class="secret-name">${escapeHtml(name)}</div>
              <div class="secret-status">${status}</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="editSecret('${escapeHtml(name)}')" title="Edit note">‚úèÔ∏è</button>
                <button class="btn-cancel" onclick="deleteSecret('${escapeHtml(name)}')" title="Delete note">üóëÔ∏è</button>
              </div>
            </div>
          `;
        }).join('');
      }
       const clearAllBtn = document.getElementById("clear-all-btn");
       const clearAllModal = document.getElementById("clear-all-modal");
       const clearAllCancel = document.getElementById("clear-all-cancel");
       const clearAllConfirm = document.getElementById("clear-all-confirm");
       clearAllBtn.addEventListener("click", () => {
        clearAllModal.classList.add("active");
       });
       clearAllCancel.addEventListener("click", () => {
        clearAllModal.classList.remove("active");
       });
       clearAllModal.addEventListener("click", (e) => {
        if (e.target === clearAllModal) {
         clearAllModal.classList.remove("active");
        }
       });
       clearAllConfirm.addEventListener("click", () => {
        pushUndo("clear all");
        NODE_DATA = {};
        EDGE_DATA = {
         list: []
        };
        EDGE_LEGEND = {};
        RECT_DATA = { list: [] };
        TEXT_DATA = { list: [] };
        savedPositions = {};
        savedSizes = {};
        savedStyles = {};
		logAuditEvent("clear", "Cleared all data from canvas");
        clearAllModal.classList.remove("active");
      autoPingEnabled = false;
      autoPingInterval = 30;
      PAGE_STATE.autoPingEnabled = false;
      PAGE_STATE.autoPingInterval = autoPingInterval;
      stopAutoPing();
      document.getElementById("auto-ping-enabled").checked = false;
      document.getElementById("auto-ping-settings").style.display = "none";
      document.getElementById("auto-ping-interval").value = autoPingInterval;
        forgeTheTopology();
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.display = "none";
        currentNodeId = null;
        currentEdgeId = null;
        currentTextId = null;
       });
       (function addDeleteNodeButton() {
       const nodePanel = document.getElementById("node-panel");
       if (!nodePanel) return;
       let deleteBtn = document.getElementById("delete-node-btn");
       if (!deleteBtn) {
        deleteBtn = document.createElement("button");
        deleteBtn.id = "delete-node-btn";
        deleteBtn.textContent = "Delete Node";
        deleteBtn.style.cssText = "margin-top:15px; padding:10px 16px; background:var(--danger); color:#fff; border:none; border-radius:6px; cursor:pointer; font-size:clamp(14px,1.6vw,18px); font-weight:600; width:100%;";
        nodePanel.appendChild(deleteBtn);
       }
       deleteBtn.addEventListener("click", () => {
        if (!currentNodeId) return;
        const nodeData = NODE_DATA[currentNodeId];
        let confirmMessage;
        let nodesInsideRack = [];
        if (nodeData?.isRack) {
         nodesInsideRack = Object.entries(NODE_DATA)
          .filter(([id, n]) => n.assignedRack === currentNodeId)
          .map(([id, n]) => n.name || id);
         if (nodesInsideRack.length > 0) {
          confirmMessage = `Delete rack "${nodeData.name}"?\n\nThis will also delete ${nodesInsideRack.length} node(s) inside:\n‚Ä¢ ${nodesInsideRack.join('\n‚Ä¢ ')}`;
         } else {
          confirmMessage = `Delete rack "${nodeData.name}"? (empty rack)`;
         }
        } else {
         confirmMessage = `Delete node "${nodeData?.name || currentNodeId}" and all its connections?`;
        }
        challengeTheImmortal(confirmMessage, () => {
         pushUndo("delete node");
         if (nodeData?.isRack) {
          Object.keys(NODE_DATA).forEach(id => {
           if (NODE_DATA[id]?.assignedRack === currentNodeId) {
            EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== id && e.to !== id);
            delete NODE_DATA[id];
            delete savedPositions[id];
            delete savedSizes[id];
            delete savedStyles[id];
           }
          });
         }
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== currentNodeId && e.to !== currentNodeId);
         delete NODE_DATA[currentNodeId];
         delete savedPositions[currentNodeId];
         delete savedSizes[currentNodeId];
         delete savedStyles[currentNodeId];
         currentNodeId = null;
         currentEdgeId = null;
         forgeTheTopology();
         const remainingNodes = Object.keys(NODE_DATA);
         if (remainingNodes.length > 0) {
          claimTheImmortal(remainingNodes[0]);
         } else {
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("topology-toolbar").style.display = "none";
         }
        });
       });
      })();
       function screenshotCanvas() {
        const svg = document.getElementById("map");
        const svgClone = svg.cloneNode(true);
        const viewBox = svg.getAttribute("viewBox").split(" ").map(Number);
        const [x, y, width, height] = viewBox;
        svgClone.setAttribute("width", width);
        svgClone.setAttribute("height", height);
        svgClone.setAttribute("viewBox", `${x} ${y} ${width} ${height}`);
        const wrapper = document.createElement("div");
        wrapper.style.position = "absolute";
        wrapper.style.left = "-9999px";
        wrapper.appendChild(svgClone);
        document.body.appendChild(wrapper);
        function inlineStyles(original, clone) {
         const elements = original.querySelectorAll("*");
         const clonedElements = clone.querySelectorAll("*");
         const rootStyles = getComputedStyle(document.documentElement);
         const bgColor = rootStyles.getPropertyValue("--bg").trim() || "#050608";
         const bgRect = document.createElementNS("http://www.w3.org/2000/svg", "rect", );
         bgRect.setAttribute("x", x);
         bgRect.setAttribute("y", y);
         bgRect.setAttribute("width", width);
         bgRect.setAttribute("height", height);
         bgRect.setAttribute("fill", bgColor);
         clone.insertBefore(bgRect, clone.firstChild);
         elements.forEach((el, index) => {
          const clonedEl = clonedElements[index];
          if (!clonedEl) return;
          const computedStyle = getComputedStyle(el);
          const svgProps = ["fill", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin", "opacity", "font-family", "font-size", "font-weight", "font-style", "text-anchor", "dominant-baseline", "marker-start", "marker-end", ];
          svgProps.forEach((prop) => {
           const value = computedStyle.getPropertyValue(prop);
           if (value && value !== "none" && value !== "normal") {
            clonedEl.style[prop] = value;
           }
          });
          clonedEl.removeAttribute("class");
         });
        }
        inlineStyles(svg, svgClone);
        const svgData = new XMLSerializer().serializeToString(svgClone);
        document.body.removeChild(wrapper);
        const svgBlob = new Blob([svgData], {
         type: "image/svg+xml;charset=utf-8",
        });
        const url = URL.createObjectURL(svgBlob);
        const img = new Image();
        img.onload = function() {
         const canvas = document.createElement("canvas");
         canvas.width = width;
         canvas.height = height;
         const ctx = canvas.getContext("2d");
         ctx.drawImage(img, 0, 0);
         canvas.toBlob(function(blob) {
          const link = document.createElement("a");
          const timestamp = new Date().toISOString().slice(0, 10);
          link.download = `topology-${timestamp}.png`;
          link.href = URL.createObjectURL(blob);
          link.click();
          URL.revokeObjectURL(url);
          URL.revokeObjectURL(link.href);
         }, "image/png");
        };
        img.onerror = function() {
         console.error("Failed to load SVG image");
         alert("Screenshot failed. Please try again.");
         URL.revokeObjectURL(url);
        };
        img.src = url;
       }
       function exportCanvasSVG() {
        const svg = document.getElementById("map");
        const svgClone = svg.cloneNode(true);
        const viewBox = svg.getAttribute("viewBox").split(" ").map(Number);
        const [x, y, width, height] = viewBox;
        svgClone.setAttribute("width", width);
        svgClone.setAttribute("height", height);
        const rootStyles = getComputedStyle(document.documentElement);
        const bgColor = rootStyles.getPropertyValue("--bg").trim() || "#050608";
        const bgRect = document.createElementNS("http://www.w3.org/2000/svg", "rect", );
        bgRect.setAttribute("x", x);
        bgRect.setAttribute("y", y);
        bgRect.setAttribute("width", width);
        bgRect.setAttribute("height", height);
        bgRect.setAttribute("fill", bgColor);
        svgClone.insertBefore(bgRect, svgClone.firstChild);
        const wrapper = document.createElement("div");
        wrapper.style.position = "absolute";
        wrapper.style.left = "-9999px";
        wrapper.appendChild(svgClone);
        document.body.appendChild(wrapper);
        const elements = svg.querySelectorAll("*");
        const clonedElements = svgClone.querySelectorAll("*");
        elements.forEach((el, index) => {
         const clonedEl = clonedElements[index];
         if (!clonedEl) return;
         const computedStyle = getComputedStyle(el);
         const svgProps = ["fill", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin", "opacity", "font-family", "font-size", "font-weight", "font-style", "text-anchor", "dominant-baseline", "marker-start", "marker-end", ];
         svgProps.forEach((prop) => {
          const value = computedStyle.getPropertyValue(prop);
          if (value && value !== "none" && value !== "normal") {
           clonedEl.setAttribute(prop, value);
          }
         });
         clonedEl.removeAttribute("class");
        });
        const svgData = new XMLSerializer().serializeToString(svgClone);
        document.body.removeChild(wrapper);
        const blob = new Blob([svgData], {
         type: "image/svg+xml;charset=utf-8",
        });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        const timestamp = new Date().toISOString().slice(0, 10);
        link.download = `topology-${timestamp}.svg`;
        link.href = url;
        link.click();
        URL.revokeObjectURL(url);
       }
      let resizeTimeout;
       window.addEventListener('resize', () => {
       clearTimeout(resizeTimeout);
       resizeTimeout = setTimeout(() => {
       updateDrawToolbarVisibility();
       updateTopologyToolbarVisibility();
       }, 100);
      });
    </script>
</body></html>