<!DOCTYPE html> 
 <html lang="en" style="--panel: #2f0e0e; --panel-alt: #10141b; --accent: #a75252; --danger: #f56565; --text-main: #e2e8f0; --text-soft: #94a3b8; --topbar-bg: rgba(9, 12, 20, 0.9); --topbar-border: #1f2533; --topbar-height: 112px; --sidebar-width: 350px; --mobile-footer-height: 40vh; --draw-toolbar-height: 45px; --sidebar-bg: #10141b; --btn-bg: #0b0e13; --btn-text: #e2e8f0; --tag-fill: #1e293b; --tag-text: #e2e8f0; --tag-border: #475569; --input-bg: #0b0e13; --input-text: #e2e8f0; --input-border: #1f2937; --input-font: Inter, system-ui, sans-serif; --input-font-size: 14px; --toolbar-bg: #441215; --toolbar-border: #1f2937; --toolbar-text: #94a3b8; --toolbar-btn-bg: #0b0e13; --toolbar-btn-text: #e2e8f0; --minimap-dots: #94a3b8; --canvas-hint-bg: #0f172a; --canvas-hint-color: #94a3b8; --node-fill: #1e293b; --node-stroke: #475569; --node-title: #e2e8f0; --node-sub: #94a3b8; --node-title-size: 18px; --node-sub-size: 13px; --node-font: Inter, system-ui, sans-serif; --default-edge: #475569; --selection-handle: #f59e0b; --selection-handle-size: 8px; --group-indicator: #4fd1c5;"><head>
    <meta charset="UTF-8">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>The One File</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!--
      * ==================================================================================
      * The One File: The Networkening
      * !!!!!!!!!!!!!!!!!!!NOTE: THIS IS THE ONLINE VERSION!!!!!!!!!!!!!!!!!!!!!!
      * Online version uses 3 cdn calls from cdn.jsdelivr.net to display additional icons
      * Since 3.0 Online version uses http as a form of ping to display uptime
      * "There can be only one". A all in one file topology maker.
      *
      * This is your last backup when all others fail. A completely self-contained
      * network topology visualization tool that works as a single HTML file.
      * Open it anywhere, anytime and the idea lives forever.
      * ==================================================================================
      -->
    <style>
      :root {
      color-scheme: dark;
      --bg: #050608;
      --panel: #0b0e13;
      --panel-alt: #10141b;
      --accent: #4fd1c5;
      --danger: #f56565;
      --text-main: #e2e8f0;
      --text-soft: #94a3b8;
      --edge-main: #475569;
      --node-min: 35px;
      --node-max: 70px;
      --topbar-bg: rgba(9, 12, 20, 0.9);
      --topbar-border: #1f2533;
      }
	  html, body, svg, .map-container {
      touch-action: none;
      }
      * {
      box-sizing: border-box;
      user-select: none;
      }
      input,
      textarea,
      [contenteditable="true"] {
      user-select: text;
      -webkit-user-select: text;
      }
      body {
      margin: 0;
      font-family: system-ui, sans-serif;
      background: radial-gradient(circle at top, #1e2532 0, #050608 70%);
      color: var(--text-main);
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
      }
      header {
      padding: 0 20px;
      height: var(--topbar-height, 52px);
      min-height: var(--topbar-height, 52px);
      background: var(--topbar-bg);
      backdrop-filter: blur(6px);
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid var(--topbar-border);
      gap: 16px;
      }
      .title-block {
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-width: 0;
      }
      header h1 {
      font-size: clamp(22px, 3vw, 32px);
      margin: 0;
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
      }
      .editable-page-title {
      cursor: pointer;
      transition: opacity 0.2s;
      }
      .editable-page-title:hover {
      opacity: 0.7;
      }
      .save-row {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      }
      .save-btn {
      padding: 6px 12px;
      background: var(--accent);
      color: var(--bg);
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      white-space: nowrap;
      }
      .save-btn:hover {
      opacity: 0.9;
      }
      .help-icon {
      width: 22px;
      height: 22px;
      border-radius: 50%;
      border: 1px solid var(--edge-main);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      cursor: pointer;
      color: var(--text-soft);
      background: rgba(15, 23, 42, 0.9);
      flex-shrink: 0;
      }
      .help-icon:hover {
      color: var(--accent);
      border-color: var(--accent);
      }
      #settings-btn {
      background: var(--btn-bg, var(--panel));
      color: var(--btn-text, var(--text-main));
      border: 1px solid var(--edge-main);
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 16px;
      flex-shrink: 0;
      }
      #settings-btn:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .header-resizer {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 6px;
      background: transparent;
      cursor: row-resize;
      z-index: 1000;
      transition: background 0.2s;
      }
      .header-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .header-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      .sidebar-resizer {
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 6px;
      background: transparent;
      cursor: col-resize;
      z-index: 1000;
      transition: background 0.2s;
      }
      .sidebar-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .sidebar-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      .mobile-footer-resizer {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 6px;
      background: transparent;
      cursor: row-resize;
      z-index: 1000;
      transition: background 0.2s;
      display: none;
      }
      .mobile-footer-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .mobile-footer-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      @media (max-width: 900px) {
      .mobile-footer-resizer {
      display: block;
      height: 12px;
      }
      .sidebar-resizer {
      display: none;
      }
      .header-resizer {
      height: 12px;
      }
      }
      @media (pointer: coarse) {
      .header-resizer {
      height: 16px;
      }
      .mobile-footer-resizer {
      height: 16px;
      }
      .sidebar-resizer {
      width: 16px;
      }
      }
      .resizer-icon {
      position: absolute;
      opacity: 0.5;
      transition: opacity 0.2s, transform 0.2s;
      pointer-events: none;
      fill: var(--accent);
      }
      .header-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .sidebar-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .mobile-footer-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .header-resizer:hover .resizer-icon,
      .sidebar-resizer:hover .resizer-icon,
      .mobile-footer-resizer:hover .resizer-icon {
      opacity: 1;
      }
      .header-resizer.resizing .resizer-icon,
      .sidebar-resizer.resizing .resizer-icon,
      .mobile-footer-resizer.resizing .resizer-icon {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1.2);
      }
      body.resizing {
      user-select: none;
      }
      body.resizing * {
      cursor: inherit !important;
      pointer-events: none;
      }
      header {
      position: relative;
      }
      .details-panel {
      position: relative;
      }
      main {
      display: grid;
      grid-template-columns: 1fr var(--sidebar-width, 350px);
      flex: 1;
      }
      main.sidebar-collapsed {
      grid-template-columns: 1fr 0;
      }
      @media (max-width: 900px) {
      main {
      grid-template-columns: 1fr;
      grid-template-rows: calc(100vh - var(--topbar-height, 52px) - var(--mobile-footer-height, 40vh)) var(--mobile-footer-height, 40vh);
      }
      main.sidebar-collapsed {
      grid-template-rows: 1fr 0;
      }
      .details-panel {
      max-height: var(--mobile-footer-height, 40vh);
      height: 100%;
      }
      }
      .topology-panel {
      background: var(--panel);
      border-right: 1px solid #111827;
      position: relative;
      overflow: hidden;
      }
      .topology-toolbar {
      position: absolute;
      top: 10px;
      right: 10px;
      display: none;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      z-index: 99;
      font-size: 13px;
      color: var(--toolbar-text, #94a3b8);
      }
      .topology-toolbar label {
      color: var(--toolbar-text, var(--text-soft));
      }
      .topology-toolbar select {
      padding: 4px 6px;
      background: var(--toolbar-btn-bg, var(--panel));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 13px;
      cursor: pointer;
      }
      .topology-toolbar button {
      padding: 4px 10px;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      }
      .topology-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .bulk-toolbar-desktop,
      .bulk-toolbar-mobile {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 9999;
      }
      .bulk-toolbar-desktop {
      position: absolute;
      top: 10px;
      right: 10px;
      bottom: auto;
      left: auto;
      transform: none;
      }
      @media (min-width: 768px) {
      .bulk-toolbar-mobile {
      display: none !important;
      }
      }
      .bulk-action-btn {
      padding: 16px;
      background: var(--panel-main);
      border: 1px solid var(--edge-main);
      border-radius: 8px;
      color: var(--text-main);
      font-size: 24px;
      cursor: pointer;
      text-align: center;
      line-height: 1.2;
      }
      .bulk-action-btn:active {
      transform: scale(0.95);
      background: var(--accent);
      }
      .draw-toolbar {
      position: absolute;
      top: 10px;
      left: 10px;
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 8px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      z-index: 99;
      font-size: 13px;
      pointer-events: auto;
      color: var(--toolbar-text, #94a3b8);
      }
      .draw-toolbar button {
      padding: 4px 8px;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      }
      .draw-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .draw-toolbar input[type="color"] {
      width: 30px;
      height: 22px;
      border-radius: 4px;
      border: 1px solid var(--edge-main);
      padding: 0;
      background: transparent;
      cursor: pointer;
      }
      .draw-toolbar select {
      padding: 4px 6px;
      background: var(--toolbar-btn-bg, var(--panel));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 13px;
      cursor: pointer;
      }
      .legend-container {
      position: absolute;
      left: 10px;
      bottom: 10px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      padding: 8px 10px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      font-size: 12px;
      z-index: 20;
      max-width: 260px;
      pointer-events: auto;
      color: var(--toolbar-text, #94a3b8);
      }
      .legend-container {
      padding-right: 22px;
      }
      @media (max-width: 900px) {
      .legend-container {
      max-height: calc(100vh - var(--topbar-height, 100px) - 120px);
      overflow-y: auto;
      }
      }
      @media (max-width: 900px) {
      .bulk-toolbar-desktop,
      .topology-toolbar {
      display: none !important;
      }
      }
      .legend-close-btn {
      position: absolute;
      top: 5px;
      right: 5px;
      width: 18px;
      height: 18px;
      border-radius: 999px;
      border: 1px solid var(--edge-main);
      background: var(--panel-alt);
      color: var(--text-soft);
      font-size: 11px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      }
      .legend-close-btn:hover {
      background: var(--danger);
      color: #fff;
      }
      .legend-mini-btn {
      position: absolute;
      left: 10px;
      padding: 4px 8px;
      border-radius: 4px;
      border: 1px solid var(--toolbar-border, #1f2937);
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 11px;
      cursor: pointer;
      z-index: 20;
      display: none;
      transition: all 0.2s;
      }
      .legend-mini-btn:hover,
      .legend-mini-btn:active {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
      }
      .legend-title {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: var(--toolbar-text, var(--text-soft));
      margin-bottom: 2px;
      }
      .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      }
      .legend-swatch {
      width: 14px;
      height: 14px;
      border-radius: 3px;
      border: 1px solid #020617;
      flex-shrink: 0;
      }
      .legend-label {
      outline: none;
      cursor: text;
      flex: 1;
      min-width: 60px;
      user-select: text;
      -webkit-user-select: text;
      }
      .legend-label.editing {
      border-bottom: 1px dashed var(--accent);
      }
      .canvas-viewport {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      overflow: hidden;
      }
      .canvas-viewport.panning {
      cursor: grabbing !important;
      }
      .canvas-viewport.panning * {
      cursor: grabbing !important;
      }
      .canvas-viewport svg {
      width: 100%;
      height: 100%;
      display: block;
      background: linear-gradient(rgba(71, 85, 105, 0.1) 1px,
      transparent 1px),
      linear-gradient(90deg,
      rgba(71, 85, 105, 0.1) 1px,
      transparent 1px),
      linear-gradient(rgba(71, 85, 105, 0.05) 1px, transparent 1px),
      linear-gradient(90deg,
      rgba(71, 85, 105, 0.05) 1px,
      transparent 1px);
      background-size:
      100px 100px,
      100px 100px,
      20px 20px,
      20px 20px;
      background-position:
      -1px -1px,
      -1px -1px,
      -1px -1px,
      -1px -1px;
      }
      .zoom-toolbar {
      display: flex;
      gap: 4px;
      padding: 6px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      }
      .zoom-toolbar button {
      width: 32px;
      height: 32px;
      padding: 0;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 18px;
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
      }
      .zoom-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .zoom-toolbar .zoom-level {
      font-size: 11px;
      color: var(--toolbar-text, var(--text-soft));
      text-align: center;
      padding: 2px 0;
      min-width: 32px;
      }
      .zoom-toolbar .divider {
      height: 1px;
      background: var(--toolbar-border, var(--edge-main));
      margin: 2px 0;
      }
      .minimap-zoom-wrapper {
      position: absolute;
      bottom: 10px;
      right: 10px;
      z-index: 99;
      }
      .minimap-container {
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      overflow: hidden;
      margin-bottom: 4px;
      }
      .minimap-container svg {
      width: 100%;
      height: 100%;
      }
      .minimap-viewport {
      fill: rgba(79, 209, 197, 0.2);
      stroke: var(--accent);
      stroke-width: 2;
      cursor: move;
      }
      .minimap-node {
      fill: var(--minimap-dots, var(--text-soft));
      }
      .minimap-edge {
      stroke: var(--edge-main);
      stroke-width: 1;
      }
	  .minimap-close-btn {
      position: absolute;
      top: 2px;
      right: 2px;
      width: 18px;
      height: 18px;
      background: var(--toolbar-btn-bg, rgba(15, 23, 42, 0.9));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 3px;
      color: var(--toolbar-text, var(--text-soft));
      font-size: 11px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
      padding: 0;
      line-height: 1;
      }
      .minimap-close-btn:hover {
      background: var(--danger);
      color: white;
      border-color: var(--danger);
      }
	  .toolbar-close-btn {
      width: 24px;
      height: 24px;
      background: var(--toolbar-btn-bg, rgba(15, 23, 42, 0.9));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-text, var(--text-soft));
      font-size: 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      line-height: 1;
      flex-shrink: 0;
      }
      .toolbar-close-btn:hover {
      background: var(--danger);
      color: white;
      border-color: var(--danger);
      }
	  .canvas-hint {
      position: absolute;
      top: 50px;
      left: 50%;
      transform: translateX(-50%);
      padding: 8px 16px;
      background: var(--canvas-hint-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      font-size: 12px;
      color: var(--canvas-hint-color, var(--text-soft));
      z-index: 18;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
      }
      .canvas-hint.visible {
      opacity: 1;
      }
      .edge {
      stroke: var(--edge-main);
      stroke-width: 4;
      opacity: 0.75;
      transition: 0.25s ease-in-out;
      cursor: pointer;
      }
      .edge.backup {
      stroke: var(--danger);
      stroke-width: 5;
      }
      .edge.active {
      opacity: 1;
      stroke-width: 7;
      filter: drop-shadow(0 0 8px var(--accent, #4fd1c5));
      }
      .rect-group.active .rect-shape {
      filter: drop-shadow(0 0 10px var(--accent, #4fd1c5));
      animation: pulse 1.2s infinite ease-in-out;
      }
      .text-element.active {
      filter: drop-shadow(0 0 10px var(--accent, #4fd1c5));
      animation: pulse 1.2s infinite ease-in-out;
      }
      .free-preview {
      fill: none;
      stroke-dasharray: 4 4;
      pointer-events: none;
      }
      .free-point {
      fill: #e5e7eb;
      stroke: #0f172a;
      stroke-width: 1.5;
      cursor: grab;
      }
      .node-circle {
      fill: var(--node-fill, #1e293b);
      stroke: var(--node-stroke, #475569);
      stroke-width: 2;
      transition: 0.25s ease;
      transform-origin: center center;
      }
      .node-hit-area {
      cursor: grab;
      pointer-events: all;
      }
      .node-group:hover .node-circle {
      filter: drop-shadow(0 0 10px rgba(79, 209, 197, 0.45));
      }
      .node-group.active .node-circle {
      stroke: var(--accent);
      animation: pulse 1.2s infinite ease-in-out;
      }
      @keyframes pulse {
      0% {
      filter: drop-shadow(0 0 4px #4fd1c5);
      }
      50% {
      filter: drop-shadow(0 0 14px #4fd1c5);
      }
      100% {
      filter: drop-shadow(0 0 4px #4fd1c5);
      }
      }
      .node-label {
      fill: var(--text-main);
      font-size: 18px;
      text-anchor: middle;
      font-weight: 600;
      }
      .node-sub {
      fill: var(--text-soft);
      font-size: 13px;
      text-anchor: middle;
      }
      .ping-indicator {
      fill: #6b7280;
      stroke: #4b5563;
      stroke-width: 1;
      }
      .ping-indicator.online {
      fill: #10b981;
      stroke: #059669;
      }
      .ping-indicator.offline {
      fill: #ef4444;
      stroke: #dc2626;
      }
      .ping-indicator.checking {
      fill: #f59e0b;
      stroke: #d97706;
      }
      @media (max-width: 1024px) {
      .node-label {
      font-size: 28px;
      }
      .node-sub {
      font-size: 20px;
      }
      }
      @media (max-width: 768px) {
      .node-label {
      font-size: 70px;
      }
      .node-sub {
      font-size: 50px;
      }
      }
      @media (max-width: 380px) {
      .node-label {
      font-size: 60px;
      }
      .node-sub {
      font-size: 42px;
      }
      }
      .details-panel {
      background: var(--sidebar-bg, var(--panel-alt));
      padding: 22px;
      padding-bottom: 80px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 15px;
      position: relative;
      transition:
      width 0.3s ease,
      min-width 0.3s ease,
      padding 0.3s ease,
      opacity 0.3s ease;
      }
      .details-panel {
      min-width: 260px !important;
      }
      .details-panel {
      overflow-y: auto !important;
      overflow-x: hidden;
      }
      .details-panel.collapsed {
      width: 0 !important;
      min-width: 0 !important;
      padding: 0 !important;
      overflow: hidden;
      opacity: 0;
      }
      body {
      overflow-x: hidden;
      overflow-y: hidden;
      }
      main {
      overflow-x: hidden;
      overflow-y: visible;
      }
      .details-panel {
      overflow-y: auto !important;
      overflow-x: hidden;
      }
      .details-panel.collapsed {
      min-width: 0 !important;
      }
      .sidebar-toggle {
      position: absolute;
      left: -16px;
      top: 50%;
      transform: translateY(-50%);
      width: 16px;
      height: 60px;
      background: var(--sidebar-bg, var(--panel-alt));
      border: 1px solid var(--edge-main);
      border-right: none;
      border-radius: 8px 0 0 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text-soft);
      font-size: 10px;
      z-index: 25;
      transition:
      background 0.2s,
      color 0.2s;
      }
      .sidebar-toggle:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .sidebar-toggle.collapsed {
      left: 0;
      border-right: 1px solid var(--edge-main);
      border-radius: 0 8px 8px 0;
      position: fixed;
      right: 0;
      left: auto;
      }
      .details-name {
      font-size: clamp(22px, 2.5vw, 30px);
      font-weight: 700;
      }
      .details-ip {
      font-size: clamp(16px, 2vw, 22px);
      color: var(--text-soft);
      }
      .details-role {
      font-size: clamp(16px, 2vw, 22px);
      color: var(--accent);
      }
      .size-controls {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-top: 10px;
      }
      .size-controls label {
      font-size: clamp(14px, 1.6vw, 18px);
      color: var(--text-soft);
      }
      .size-controls input[type="range"] {
      flex: 1;
      accent-color: var(--accent);
      }
      .size-controls button {
      padding: 6px 12px;
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      font-size: clamp(12px, 1.4vw, 16px);
      }
      .size-controls button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .style-section {
      margin-top: 15px;
      padding-top: 15px;
      border-top: 1px solid var(--edge-main);
      }
      .style-section summary {
      cursor: pointer;
      font-size: clamp(14px, 1.6vw, 20px);
      text-transform: uppercase;
      color: var(--text-soft);
      list-style: none;
      display: flex;
      justify-content: space-between;
      align-items: center;
      user-select: none;
      }
      .style-section summary::-webkit-details-marker {
      display: none;
      }
      .password-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #ffffff;
      z-index: 9999;
      }
      .style-section summary::after {
      content: "‚ñº";
      transition: transform 0.2s;
      }
      .style-section[open] summary::after {
      transform: rotate(180deg);
      }
      .style-content {
      margin-top: 10px;
      }
      .style-row {
      display: flex;
      gap: 10px;
      align-items: center;
      margin: 8px 0;
      }
      .style-row label {
      font-size: clamp(13px, 1.5vw, 17px);
      color: var(--text-soft);
      min-width: 80px;
      }
      .style-row input[type="color"] {
      width: 50px;
      height: 30px;
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      background: transparent;
      }
      .style-row input[type="number"] {
      width: 70px;
      padding: 4px 8px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(12px, 1.4vw, 16px);
      }
      .style-row select {
      flex: 1;
      padding: 4px 8px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(12px, 1.4vw, 16px);
      cursor: pointer;
      }
      .editable-text {
      cursor: pointer;
      transition: opacity 0.2s;
      }
      .editable-text:hover {
      opacity: 0.7;
      }
      .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 999999;
      justify-content: center;
      align-items: center;
      overflow: auto;
      }
      .modal.active {
      display: inline-grid;
      }
      .modal-content {
      background: var(--panel-alt);
      padding: 25px;
      border-radius: 8px;
      border: 1px solid var(--edge-main);
      min-width: 300px;
      max-width: 90%;
      }
      .modal-content h3 {
      margin: 0 0 15px 0;
      color: var(--text-main);
      font-size: clamp(18px, 2vw, 24px);
      }
      .modal-content p {
      color: var(--text-soft);
      font-size: clamp(14px, 1.6vw, 18px);
      margin: 0 0 20px 0;
      }
      .modal-content input:not([type="color"]),
      .modal-content select {
      width: 100%;
      padding: 10px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(14px, 1.6vw, 18px);
      margin-bottom: 15px;
      user-select: text;
      -webkit-user-select: text;
      }
      .modal-content input[type="color"] {
      width: 60px;
      height: 36px;
      padding: 2px;
      border: 2px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      background: none;
      -webkit-appearance: none;
      appearance: none;
      }
      .modal-content input[type="color"]::-webkit-color-swatch-wrapper {
      padding: 0;
      }
      .modal-content input[type="color"]::-webkit-color-swatch {
      border: none;
      border-radius: 4px;
      }
      .modal-buttons {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
      margin-top: 10px;
      }
      .modal-buttons button {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: clamp(14px, 1.6vw, 18px);
      font-weight: 600;
      }
      .modal-buttons .btn-cancel {
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      }
      .modal-buttons .btn-save {
      background: var(--accent);
      color: var(--bg);
      }
      .modal-buttons .btn-delete {
      background: var(--danger);
      color: white;
      }
      .confirm-modal p {
      color: var(--text-soft);
      font-size: clamp(14px, 1.6vw, 18px);
      margin: 0 0 20px 0;
      }
      .context-menu-item {
      transition: background 0.15s;
      }
      .context-menu-item:hover {
      background: var(--panel);
      }
      .details-info-row {
      display: flex;
      align-items: center;
      margin: 6px 0;
      }
	 .node-group.selected .node-circle {
      stroke: var(--selection-handle, #f59e0b);
      stroke-width: 3;
      }
	  .node-group.layer-faded {
      pointer-events: none;
      }
      .edge.layer-faded {
      pointer-events: none;
      }
      .node-group.search-highlight .node-circle,
      .node-group.search-highlight rect,
      .node-group.search-highlight polygon {
      stroke: #10b981;
      stroke-width: 3;
      filter: drop-shadow(0 0 8px #10b981);
      }
	  .node-group.search-faded {
  opacity: 0.15;
  pointer-events: none;
}
.node-group.search-faded .node-label,
.node-group.search-faded .node-sub {
  opacity: 0.3;
}
.edge-group.search-faded,
.edge.search-faded {
  opacity: 0.1;
}
      .badge-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      }
     .badge {
      background: var(--tag-fill, #1e293b);
      color: var(--tag-text, #e2e8f0);
      border: 1px solid var(--tag-border, var(--edge-main));
      padding: 5px 12px;
      border-radius: 22px;
      font-size: clamp(12px, 1.4vw, 18px);
      }
	  .badge.wg {
      color: var(--accent);
      border-color: var(--accent);
      }
	  input[type="text"],
      input[type="number"],
      input[type="password"],
      textarea,
      select {
      background: var(--input-bg, #0b0e13) !important;
      color: var(--input-text, #e2e8f0) !important;
      border-color: var(--input-border, #1f2937) !important;
      font-family: var(--input-font, Inter, system-ui, sans-serif) !important;
      font-size: var(--input-font-size, 14px) !important;
      }
      .section-label {
      margin-top: 8px;
      font-size: clamp(14px, 1.6vw, 20px);
      text-transform: uppercase;
      color: var(--text-soft);
      }
      .list li {
      margin: 6px 0;
      font-size: clamp(14px, 1.6vw, 20px);
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      }
      .list li:hover {
      color: var(--accent);
      }
      .delete-note {
      color: var(--danger);
      font-size: 18px;
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.2s;
      flex-shrink: 0;
      }
      .list li:hover .delete-note {
      opacity: 1;
      }
      .editing {
      outline: 2px solid var(--accent);
      background: #0d141f;
      padding: 4px;
      border-radius: 6px;
      user-select: text;
      -webkit-user-select: text;
      }
      .mobile-menu-btn {
      display: none;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      color: var(--text-main);
      font-size: 22px;
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      }
      #topbar-menu {
      gap: 8px;
      }
      @media (min-width: 721px) {
      #topbar-menu {
      display: flex !important;
      }
      }
      @media (max-width: 720px) {
      #topbar-menu {
      display: none;
      }
      #topbar-menu.open {
      display: flex;
      }
      }
      @media (max-width: 720px) {
      .mobile-menu-btn {
      display: block;
      }
      #topbar-menu {
      position: absolute;
      top: var(--topbar-height);
      right: 0;
      background: var(--panel-alt);
      border-left: 1px solid var(--topbar-border);
      border-bottom: 1px solid var(--topbar-border);
      padding: 12px;
      display: none;
      flex-direction: column;
      width: 180px;
      z-index: 999;
      }
      #topbar-menu.open {
      display: flex;
      }
      header {
      position: relative;
      z-index: 9999;
      }
      }
      @media (max-width: 720px) {
      .draw-toolbar {
      position: absolute;
      top: auto;
      bottom: auto;
      left: 10px !important;
      right: auto !important;
      width: auto;
      gap: 6px;
      padding: 8px;
      }
      .topology-toolbar {
      position: absolute;
      top: auto;
      bottom: auto;
      width: auto;
      gap: 6px;
      padding: 8px;
      }
      .draw-toolbar {
      top: 10px !important;
      }
      .topology-toolbar {
      top: calc(10px + var(--draw-toolbar-height, 50px)) !important;
      }
      .canvas-hint {
      top: calc(10px + 120px);
      }
      }
      .icon-picker-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      z-index: 999999999;
      justify-content: center;
      align-items: center;
      }
      .icon-picker-modal.active {
      display: flex;
      }
      .icon-picker-content {
      background: var(--panel);
      border-radius: 12px;
      width: 90%;
      max-width: 800px;
      max-height: 80vh;
      display: flex;
      flex-direction: column;
      border: 1px solid var(--edge-main);
      }
      .icon-picker-header {
      padding: 20px;
      border-bottom: 1px solid var(--edge-main);
      }
      .icon-picker-header h3 {
      margin: 0 0 15px 0;
      color: var(--text-main);
      }
      .icon-picker-tabs {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
      flex-wrap: wrap;
      }
      .icon-picker-tab {
      padding: 8px 16px;
      background: var(--panel-alt);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      color: var(--text-soft);
      font-size: 14px;
      transition: all 0.2s;
      }
      .icon-picker-tab:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .icon-picker-tab.active {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
      }
      .icon-picker-search {
      width: 100%;
      padding: 10px 15px;
      background: var(--panel-alt);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      color: var(--text-main);
      font-size: 14px;
      }
      .icon-picker-search::placeholder {
      color: var(--text-soft);
      }
      .icon-picker-body {
      padding: 20px;
      overflow-y: auto;
      flex: 1;
      }
      .icon-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
      gap: 10px;
      }
      .icon-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 15px 10px;
      background: var(--panel-alt);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .icon-item:hover {
      background: var(--accent);
      border-color: var(--accent);
      transform: scale(1.05);
      }
      .icon-item svg {
      width: 32px;
      height: 32px;
      fill: var(--text-main);
      }
      .icon-item:hover svg {
      fill: var(--bg);
      }
      .icon-item-name {
      margin-top: 8px;
      font-size: 10px;
      color: var(--text-soft);
      text-align: center;
      word-break: break-word;
      }
      .icon-item:hover .icon-item-name {
      color: var(--bg);
      }
      .icon-picker-loading {
      text-align: center;
      padding: 40px;
      color: var(--text-soft);
      }
      .icon-picker-footer {
      padding: 15px 20px;
      border-top: 1px solid var(--edge-main);
      display: flex;
      justify-content: flex-end;
      }
      .icon-btn-cancel {
      padding: 8px 20px;
      background: var(--panel-alt);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      }
      .icon-btn-cancel:hover {
      background: var(--edge-main);
      }
      .icon-badge {
      display: inline-flex;
      align-items: center;
      gap: 5px;
      padding: 4px 8px;
      background: var(--panel-alt);
      border-radius: 4px;
      font-size: 12px;
      margin: 2px;
      }
      .icon-badge svg {
      width: 16px;
      height: 16px;
      fill: currentColor;
      }
      .pick-icon-btn {
      padding: 6px 12px;
      background: var(--accent);
      color: var(--bg);
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      margin-top: 8px;
      width: 100%;
      }
      .pick-icon-btn:hover {
      opacity: 0.9;
      }
      @media (max-width: 768px) {
      .icon-picker-content {
      width: 95%;
      max-height: 90vh;
      }
      .modal-content {
      background: var(--panel-alt);
      }
      #search-input {
      width: 100%;
      }
      }
      .version-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .version-item:hover {
      background: var(--panel-alt);
      border-color: var(--accent);
      }
      .version-item.current {
      border-color: var(--accent);
      background: rgba(79, 209, 197, 0.1);
      }
      .version-info {
      flex: 1;
      }
      .version-info .timestamp {
      font-size: 13px;
      color: var(--text-main);
      font-weight: 600;
      }
      .version-info .details {
      font-size: 11px;
      color: var(--text-soft);
      margin-top: 4px;
      }
      .version-actions {
      display: flex;
      gap: 6px;
      }
      .audit-entry {
      padding: 8px 12px;
      background: var(--panel);
      border-left: 3px solid var(--edge-main);
      border-radius: 4px;
      font-size: 12px;
      }
      .audit-entry.node { border-left-color: #4fd1c5; }
      .audit-entry.connection { border-left-color: #9f7aea; }
      .audit-entry.style { border-left-color: #ed8936; }
      .audit-entry.rack { border-left-color: #48bb78; }
      .audit-entry.layer { border-left-color: #4299e1; }
      .audit-entry .time {
      color: var(--text-soft);
      font-size: 10px;
      }
      .audit-entry .action {
      color: var(--text-main);
      font-weight: 500;
      }
      .tab-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .tab-item:hover {
      background: var(--panel-alt);
      }
      .tab-item.active {
      border-color: var(--accent);
      background: rgba(79, 209, 197, 0.1);
      }
      .tab-item .tab-name {
      font-weight: 600;
      color: var(--text-main);
      flex: 1;
      }
      .tab-item .tab-stats {
      font-size: 11px;
      color: var(--text-soft);
      margin-right: 10px;
      }
      .tab-actions {
      display: flex;
      gap: 6px;
      }
      .secret-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      border-left: 3px solid var(--danger);
      }
      .secret-item .secret-name {
      font-weight: 600;
      color: var(--text-main);
      flex: 1;
      }
      .secret-item .secret-status {
      font-size: 11px;
      color: var(--text-soft);
      margin-right: 10px;
      }
	  body.view-only-mode:not(.view-only-inspect) #node-panel,
      body.view-only-mode:not(.view-only-inspect) #edge-panel,
      body.view-only-mode:not(.view-only-inspect) #text-panel,
      body.view-only-mode:not(.view-only-inspect) #rect-panel {
        display: none !important;
      }
      body.view-only-mode .node-group,
      body.view-only-mode .edge,
      body.view-only-mode .rect-group,
      body.view-only-mode .text-element {
        cursor: default !important;
      }
      body.view-only-mode .resize-handle,
      body.view-only-mode .edge-control-point {
        display: none !important;
      }
      body.view-only-mode #bulk-toolbar,
      body.view-only-mode #bulk-toolbar-mobile,
      body.view-only-mode #bulk-actions-modal {
        display: none !important;
      }
      body.view-only-mode::after {
        content: "VIEW ONLY ‚Ä¢ click 5√ó to inspect";
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(245, 101, 101, 0.9);
        color: white;
        padding: 6px 16px;
        border-radius: 20px;
        font-size: 12px;
        font-weight: 600;
        letter-spacing: 1px;
        z-index: 9999;
        pointer-events: none;
      }
    </style>
  </head>
  <body style="background: radial-gradient(circle at center top, rgb(30, 37, 50) 0px, rgb(5, 6, 8) 70%);" class="">
    <div class="icon-picker-modal" id="icon-picker-modal">
      <div class="icon-picker-content">
        <div class="icon-picker-header">
          <h3>Select Icon</h3>
          <div class="icon-picker-tabs">
            <button class="icon-picker-tab" data-library="mdi">MDI</button>
            <button class="icon-picker-tab" data-library="simple">Simple Icons</button>
            <button class="icon-picker-tab active" data-library="selfhst">selfh.st/icons</button>
          </div>
          <input type="text" class="icon-picker-search" id="icon-search" placeholder="Search icons..." style="display: none;">
        </div>
        <div class="icon-picker-body" id="icon-picker-body">
        </div>
        <div class="icon-picker-footer">
          <button class="icon-btn-cancel" id="icon-picker-cancel">Cancel</button>
        </div>
      </div>
    </div>
    <div class="modal" id="tabs-modal">
      <div class="modal-content" style="max-width: 600px;">
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Manage multiple topologies</p>
        <div id="tabs-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 400px; overflow-y: auto; margin-bottom: 15px;">
            <div class="tab-item " onclick="switchTab(0)">
              <div class="tab-name">Corporate Site B</div>
              <div class="tab-stats">105 nodes ‚Ä¢ 65 connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(0)" title="Rename tab">‚úèÔ∏è</button>
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(${index})" title="Delete tab">üóëÔ∏è</button>
              </div>
            </div>
          
            <div class="tab-item active" onclick="switchTab(1)">
              <div class="tab-name">Homelab 2</div>
              <div class="tab-stats">11 nodes ‚Ä¢ 10 connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(1)" title="Rename tab">‚úèÔ∏è</button>
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(${index})" title="Delete tab">üóëÔ∏è</button>
              </div>
            </div>
          </div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="new-tab-name" placeholder="New tab name..." style="flex: 1; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <button class="btn-save" onclick="createNewTab()">+ Add Tab</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="tabs-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="rollback-modal">
      <div class="modal-content" style="max-width: 700px;">
        <h3>Version History</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Limit: Snapshots</p>
        <div id="rollback-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 450px; overflow-y: auto; margin-bottom: 15px;">
          <div style="text-align: center; padding: 40px; color: var(--text-soft);">No version history yet. Versions are saved automatically when you save the file.</div>
        </div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <button class="btn-cancel" onclick="clearRollbackHistory()">Clear History</button>
          <button class="btn-save" onclick="createManualSnapshot()">Create Snapshot</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="rollback-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="audit-log-modal">
      <div class="modal-content" style="max-width: 800px;">
        <h3>Audit Log</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Track all changes made to your topology</p>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <select id="audit-filter" style="padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
            <option value="all">All Events</option>
            <option value="node">Node Operations</option>
            <option value="connection">Connections</option>
            <option value="style">Style Changes</option>
            <option value="rack">Rack Operations</option>
            <option value="layer">Layer Changes</option>
          </select>
          <button class="btn-save" onclick="exportAuditLog()">Export</button>
        </div>
        <div id="audit-log-list" style="display: flex; flex-direction: column; gap: 4px; max-height: 450px; overflow-y: auto; margin-bottom: 15px; font-family: monospace; font-size: 12px;"><div style="text-align: center; padding: 40px; color: var(--text-soft);">No audit entries yet</div></div>
        <div style="display: flex; gap: 8px;">
          <button class="btn-cancel" onclick="clearAuditLog()">Clear Log</button>
          <button class="btn-cancel" id="audit-log-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="secrets-modal">
      <div class="modal-content" style="max-width: 600px;">
        <h3>Notes</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Notes can also be stored with AES 256 encryption</p>
        <div id="secrets-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 350px; overflow-y: auto; margin-bottom: 15px;">
        </div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="new-secret-name" placeholder="Section name (e.g., 'Root Passwords')..." style="flex: 1; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <button class="btn-save" onclick="createNewSecret()">+ Add Note</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="secrets-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="secret-editor-modal">
      <div class="modal-content" style="max-width: 600px;">
        <h3 id="secret-editor-title">Edit Note</h3>
        <textarea id="secret-editor-content" placeholder="Enter sensitive information here..." style="width: 100%; height: 200px; padding: 12px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main); font-family: monospace; resize: vertical; margin-bottom: 15px;"></textarea>
        <div style="margin-bottom: 15px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
          <input type="checkbox" id="secret-auto-encrypt" checked="" style="cursor: pointer;">
          <span>Encrypt Note</span>
          </label>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" onclick="closeSecretEditor()">Cancel</button>
          <button class="btn-save" onclick="saveSecret()">Save</button>
        </div>
      </div>
    </div>
    <div class="modal" id="edit-modal">
      <div class="modal-content">
        <h3 id="modal-title">Edit Name</h3>
        <input type="text" id="modal-input">
        <div class="modal-buttons">
          <button class="btn-cancel" id="modal-cancel">Cancel</button>
          <button class="btn-save" id="modal-save">Save</button>
        </div>
      </div>
    </div>
    <div class="modal confirm-modal" id="confirm-modal">
      <div class="modal-content">
        <h3>Confirm</h3>
        <p id="confirm-message"> Are you sure you want to delete this line? </p>
        <div class="modal-buttons">
          <button class="btn-cancel" id="confirm-cancel">Cancel</button>
          <button class="btn-delete" id="confirm-delete">Delete</button>
        </div>
      </div>
    </div>
    <div class="modal" id="save-info-modal">
      <div class="modal-content" style="max-width: 700px; max-height: 80vh; overflow-y: auto;">
        <h3 style="margin-bottom: 16px;">Help</h3>
        <div style="display: flex; gap: 8px; margin-bottom: 16px; flex-wrap: wrap;">
          <button class="help-tab active" data-tab="general" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--accent); color: var(--bg); border-radius: 6px; cursor: pointer; font-weight: 600;">General</button>
          <button class="help-tab" data-tab="desktop" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--panel); color: var(--text-main); border-radius: 6px; cursor: pointer; font-weight: 600;">Desktop</button>
          <button class="help-tab" data-tab="mobile" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--panel); color: var(--text-main); border-radius: 6px; cursor: pointer; font-weight: 600;">Mobile</button>
        </div>
        <div id="help-tab-general" class="help-tab-content" style="display: block;">
          <ul style="margin-left: 20px; margin-bottom: 12px; line-height: 1.8;">
            <li><strong>Add Nodes:</strong> Click "+ Node" or "+ Rack" in the top menu</li>
            <li><strong>Connect Nodes:</strong> Select a node, then use "Add Connection" in the panel</li>
            <li><strong>Move Nodes:</strong> Drag nodes to reposition them</li>
            <li><strong>Enter Rack View:</strong> Double click on desktop or Long press on mobile</li>
            <li><strong>Multi Select:</strong> Right click (desktop) or double tap (mobile)</li>
            <li><strong>Pan Canvas:</strong> Drag empty space or hold Space + drag</li>
            <li><strong>Zoom:</strong> Scroll wheel or pinch gesture</li>
            <li><strong>Free Draw:</strong> Use draw toolbar for drawing lines, boxes/zones , and text</li>
          </ul>
          <h4 style="color: var(--accent); margin-bottom: 8px;">Saving &amp; Encryption</h4>
          <p style="margin-bottom: 8px;">Browsers cannot overwrite local files. Click <strong>Save File</strong> to download an updated HTML with all changes. Replace your old file to keep edits.</p>
          <p style="margin-bottom: 8px;"><strong>Encryption of data:</strong> Check "Encrypt" before saving to password protect your data. Beware! No recovery possible without password!!</p>
          <p><strong>Decryption of data:</strong> Export via JSON in top settings menu after successful password validation to decrypt your data. You can then reimport back into the same file and save!</p>
        </div>
        <div id="help-tab-desktop" class="help-tab-content" style="display: none;">
          <h4 style="color: var(--accent); margin-bottom: 12px;">Navigation</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Arrow Keys</code></td>
              <td style="padding: 8px;">Move selected 1px</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Shift + Arrows</code></td>
              <td style="padding: 8px;">Move selected 10px</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Tab / Shift+Tab</code></td>
              <td style="padding: 8px;">Cycle through nodes</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">F</code></td>
              <td style="padding: 8px;">Focus on selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Space + Drag</code></td>
              <td style="padding: 8px;">Pan canvas</td>
            </tr>
          </tbody></table>
          <h4 style="color: var(--accent); margin-bottom: 12px;">Management</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">L</code></td>
              <td style="padding: 8px;">Lock/unlock selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">G</code></td>
              <td style="padding: 8px;">Group/ungroup selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+C / Ctrl+V</code></td>
              <td style="padding: 8px;">Copy / Paste</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+D</code></td>
              <td style="padding: 8px;">Duplicate</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+A</code></td>
              <td style="padding: 8px;">Select all</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Delete</code></td>
              <td style="padding: 8px;">Delete selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Escape</code></td>
              <td style="padding: 8px;">Clear selection</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+Z / Ctrl+Y</code></td>
              <td style="padding: 8px;">Undo / Redo</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Right Click</code></td>
              <td style="padding: 8px;">Multi select toggle</td>
            </tr>
          </tbody></table>
        </div>
        <div id="help-tab-mobile" class="help-tab-content" style="display: none;">
          <h4 style="color: var(--accent); margin-bottom: 12px;">Basic Gestures</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Tap node</strong></td>
              <td style="padding: 8px;">Select &amp; open properties</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Tap empty</strong></td>
              <td style="padding: 8px;">Deselect all</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Drag node</strong></td>
              <td style="padding: 8px;">Move node</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Drag empty</strong></td>
              <td style="padding: 8px;">Pan canvas</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Pinch</strong></td>
              <td style="padding: 8px;">Zoom in/out</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Double-tap node</strong></td>
              <td style="padding: 8px;">Add/remove from selection</td>
            </tr>
          </tbody></table>
          <h4 style="color: var(--accent); margin-bottom: 12px;">Rack View</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Long-press rack</strong></td>
              <td style="padding: 8px;">Enter rack view</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Double-tap empty</strong></td>
              <td style="padding: 8px;">Exit rack view</td>
            </tr>
          </tbody></table>
        </div>
        <div class="modal-buttons" style="margin-top: 16px;">
          <button class="btn-cancel" id="save-info-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="settings-modal">
	<div class="modal-content">
        <h2>Settings</h2>
        <details class="style-section">
          <summary>View Only Mode</summary>
          <div class="style-content">
            <div class="style-row">
              <label>View Only (disable all editing)</label>
              <input type="checkbox" id="view-only-mode" style="width:auto;">
            </div>
            <p style="margin-top:4px;font-size:12px;color:var(--text-soft);">When enabled, all editing of the canvas is disabled. Pan and zoom still work.</p>
          </div>
        </details>
        <details class="style-section">
          <summary>General Theme</summary>
          <div class="style-content">
		    <div class="style-row">
              <label>Main Background</label>
              <input type="color" id="panel-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Modal Window (popup) Background</label>
              <input type="color" id="panel-alt-color" value="#10141b">
            </div>
            <div class="style-row">
              <label>Accent Buttons</label>
              <input type="color" id="accent-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Danger Buttons</label>
              <input type="color" id="danger-color" value="#f56565">
            </div>
            <div class="style-row">
              <label>Primary Text</label>
              <input type="color" id="text-main-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Secondary Text</label>
              <input type="color" id="text-soft-color" value="#94a3b8">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Top Bar</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="topbar-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="topbar-border-color" value="#1f2533">
            </div>
          </div>
		  <div class="style-content">
            <div class="style-row">
              <label>Button Fill</label>
              <input type="color" id="btn-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Button Text</label>
              <input type="color" id="btn-text-color" value="#e2e8f0">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Main Canvas</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="canvas-border-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Grid Lines</label>
              <input type="color" id="canvas-grid-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Grid Size</label>
              <input type="number" id="canvas-grid-size" value="50" min="20" max="200" style="width:60px;">
            </div>
		    <div class="style-row">
              <label>Background Top</label>
              <input type="color" id="canvas-gradient-top" value="#1e2532">
            </div>
            <div class="style-row">
              <label>Background Bottom</label>
              <input type="color" id="canvas-gradient-bottom" value="#050608">
            </div>
            <div class="style-row">
              <label>Solid Background</label>
              <input type="color" id="page-bg-color" value="#050608">
            </div>
            <p style="margin-top:4px;font-size:12px;color:var(--text-soft);">Set solid background to override gradient.</p>
          </div>
        </details>
        <details class="style-section">
          <summary>Rack Canvas</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Frame Fill</label>
              <input type="color" id="rack-frame-fill" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Frame Border</label>
              <input type="color" id="rack-frame-stroke" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Grid Lines</label>
              <input type="color" id="rack-line-color" value="#475569">
            </div>
            <div class="style-row">
              <label>U Labels</label>
              <input type="color" id="rack-text-color" value="#4fd1c5">
            </div>
          </div>
       </details>
	   <details class="style-section">
          <summary>Canvas Toolbars</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="toolbar-bg-color" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="toolbar-border-color" value="#1f2937">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="toolbar-text-color" value="#94a3b8">
            </div>
            <div class="style-row">
              <label>Button Fill</label>
              <input type="color" id="toolbar-btn-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Button Text</label>
              <input type="color" id="toolbar-btn-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Minimap Dots</label>
              <input type="color" id="minimap-dots-color" value="#94a3b8">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Nodes</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Fill</label>
              <input type="color" id="node-fill-color" value="#1e293b">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="node-stroke-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Title Color</label>
              <input type="color" id="node-title-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Title Size</label>
              <input type="number" id="node-title-size" value="18" min="8" max="48" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Subtitle Color</label>
              <input type="color" id="node-sub-color" value="#94a3b8">
            </div>
            <div class="style-row">
              <label>Subtitle Size</label>
              <input type="number" id="node-sub-size" value="13" min="8" max="48" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Font</label>
              <select id="node-font-family" style="flex:1;padding:4px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;">
                <option value="Inter, system-ui, sans-serif">Inter</option>
                <option value="Arial, sans-serif">Arial</option>
                <option value="Helvetica, sans-serif">Helvetica</option>
                <option value="Georgia, serif">Georgia</option>
                <option value="monospace">Monospace</option>
              </select>
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Connections</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Default Color</label>
              <input type="color" id="default-edge-color" value="#475569">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Groups &amp; Editing</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Resize handle Color</label>
              <input type="color" id="selection-handle-color" value="#f59e0b">
            </div>
            <div class="style-row">
              <label>Resize Handle Size</label>
              <input type="number" id="selection-handle-size" value="8" min="4" max="16" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Grouped Icon Outline</label>
              <input type="color" id="group-indicator-color" value="#4fd1c5">
            </div>
          </div>
		  <div class="style-content">
            <div class="style-row">
              <label>Multiselect Fill Color (Desktop)</label>
              <input type="color" id="selection-fill-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Multiselect Fill Opacity (Desktop)</label>
              <input type="range" id="selection-fill-opacity" min="0" max="1" step="0.05" value="0.1">
              <span id="selection-fill-opacity-val" style="min-width:35px;text-align:right;">10%</span>
            </div>
            <div class="style-row">
              <label>Multiselect Border Color (Desktop)</label>
              <input type="color" id="selection-stroke-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Multiselect Border Width (Desktop)</label>
              <input type="number" id="selection-stroke-width" min="1" max="10" value="2">
            </div>
            <div class="style-row">
              <label>Multiselect Border Style (Desktop)</label>
              <select id="selection-stroke-style">
                <option value="5,5">Dashed</option>
                <option value="2,4">Dotted</option>
                <option value="none">Solid</option>
              </select>
            </div>
          </div>
        </details>
		<details class="style-section">
          <summary>Inputs &amp; Dropdowns</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="input-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="input-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="input-border-color" value="#1f2937">
            </div>
            <div class="style-row">
              <label>Font</label>
              <select id="input-font-family" style="flex:1;padding:4px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;">
                <option value="Inter, system-ui, sans-serif">Inter</option>
                <option value="Arial, sans-serif">Arial</option>
                <option value="Helvetica, sans-serif">Helvetica</option>
                <option value="Georgia, serif">Georgia</option>
                <option value="monospace">Monospace</option>
              </select>
            </div>
            <div class="style-row">
              <label>Font Size</label>
              <input type="number" id="input-font-size" value="14" min="10" max="24" style="width:60px;">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Welcome Message</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Enabled</label>
              <input type="checkbox" id="canvas-hint-enabled" checked="" style="width:auto;">
            </div>
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="canvas-hint-bg-color" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Text Color</label>
              <input type="color" id="canvas-hint-text-color" value="#94a3b8">
            </div>
            <div class="style-row" style="flex-direction:column;align-items:stretch;">
              <label>Custom Text (HTML)</label>
              <textarea id="canvas-hint-text" rows="4" style="width:100%;margin-top:4px;padding:6px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;font-size:12px;resize:vertical;" placeholder="Leave empty for default"></textarea>
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Sidebar / Mobile Footer</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="sidebar-bg-color" value="#10141b">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Tags</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Fill</label>
              <input type="color" id="tag-fill-color" value="#1e293b">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="tag-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="tag-border-color" value="#475569">
            </div>
          </div>
        </details>
        <details class="style-section" open="">
          <summary>Import / Export / Upgrade JSON</summary>
          <div class="style-content">
            <button id="export-data-btn" style="width:100%;margin-bottom:10px;padding:10px;background:var(--accent);color:var(--bg);border:none;border-radius:6px;cursor:pointer;font-size:14px;font-weight:600;">Export JSON</button>
            <button id="import-data-btn" style="width:100%;padding:10px;background:var(--panel);color:var(--text-main);border:1px solid var(--edge-main);border-radius:6px;cursor:pointer;font-size:14px;font-weight:600;">Import JSON</button>
            <input type="file" id="import-data-file" accept=".json" style="display:none">
          </div>
        </details>
         <details class="style-section">
          <summary>Auto Status Checking</summary>
          <div class="style-content">
            <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 16px; cursor: pointer;">
            <input type="checkbox" id="auto-ping-enabled" style="cursor: pointer;">
            <span style="font-size: 14px; font-weight: 600;">Enable automatic status checking</span>
            </label>
            <div id="auto-ping-settings" style="display: none; padding-left: 20px; border-left: 2px solid var(--edge-main);">
              <div class="style-row" style="margin-bottom: 12px;">
                <label>Check Interval (seconds):</label>
                <input type="number" id="auto-ping-interval" min="5" max="3600" value="30" style="width: 80px; padding: 6px; background: var(--panel); border: 1px solid var(--edge-main); border-radius: 4px; color: var(--text-main);">
              </div>
              <div style="padding: 10px; background: var(--panel); border-radius: 6px; border: 1px solid var(--edge-main); font-size: 12px; color: var(--text-soft);">
                <div style="margin-bottom: 4px;"><span id="auto-ping-next-check">Next check in: --</span></div>
                <div><span id="auto-ping-last-run">Last run: 1:15:07 PM</span></div>
              </div>
            </div>
            <p style="margin-top: 12px; font-size: 12px; color: var(--text-soft); font-style: italic;">
              Automatically checks all ping enabled nodes at the specified interval. I recommend 30 to 60 seconds for local networks.
            </p>
			</div>
        </details>
        <details class="style-section" open="">
          <summary>Danger Zone</summary>
          <div class="style-content">
            <p style="margin-bottom:12px;font-size:13px;color:var(--text-soft);">Permanently delete everything on the canvas.</p>
            <button id="clear-all-btn" title="Clear all nodes" style="padding:6px 12px;background:var(--danger);color:#fff;border:none;border-radius:6px;cursor:pointer;font-size:14px;font-weight:600;">Clear All</button>
            <input type="file" id="import-data-file" accept=".json" style="display:none">
          </div>
        </details>
        <div class="modal-buttons">
          <button class="btn-cancel" id="settings-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="add-node-modal">
      <div class="modal-content">
        <h3>Add New Node</h3>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Basic Information</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Name</label>
          <input type="text" id="new-node-name" placeholder="e.g. web server, jellyfin">
          <label style="display: block;margin-bottom: 4px;margin-top: 12px;color: var(--text-soft);font-size: 13px;">IP / Subtitle</label>
          <input type="text" id="new-node-ip" placeholder="e.g. 192.168.1.100">
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Tags</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Text Tags (comma separated)</label>
          <input type="text" id="new-node-tags" placeholder="e.g. Docker, nginx, WG: vpn">
          <button class="pick-icon-btn" id="pick-new-node-tag-icon-btn" style="margin-top: 10px;">Add Icon Tag</button>
          <div id="new-node-icon-tags" style="margin-top: 10px; display: none;">
            <label style="display: block; margin-bottom: 8px; color: var(--text-soft); font-size: 13px;">Icon Tags:</label>
            <div id="new-node-icon-tags-list" style="display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 10px;"></div>
          </div>
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Node Appearance</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Basic Shapes</label>
          <select id="new-node-shape">
            <optgroup label="Basic Shapes">
            <option value="circle">Circle</option>
            <option value="square">Square</option>
            <option value="rectangle">Rectangle</option>
            <option value="triangle">Triangle</option>
            <option value="hexagon">Hexagon</option>
            <option value="diamond">Diamond</option>
            <option value="star">Star</option>
            <option value="stop-sign">Stop Sign</option>
            <option value="octagon">Octagon</option>
            <option value="pentagon">Pentagon</option>
            <option value="cross">Cross</option>
            <option value="rounded-square">Rounded Square</option>
            <option value="pill">Pill</option>
            <option value="parallelogram">Parallelogram</option>
            <option value="trapezoid">Trapezoid</option>
          </optgroup>
          <optgroup label="Computers &amp; Devices">
            <option value="server">Server</option>
            <option value="pc">PC / Desktop</option>
            <option value="laptop">Laptop</option>
            <option value="phone">Phone / Mobile</option>
            <option value="printer">Printer</option>
            <option value="pi">Raspberry Pi</option>
            <option value="sensor">Sensor / IoT</option>
          </optgroup>
          <optgroup label="Network Equipment">
            <option value="router">Router</option>
            <option value="switch">Switch</option>
            <option value="firewall">Firewall</option>
            <option value="access-point">Access Point</option>
            <option value="load-balancer">Load Balancer</option>
            <option value="gateway">Gateway</option>
            <option value="vpn">VPN / Tunnel</option>
            <option value="nas">NAS / Storage</option>
          </optgroup>
          <optgroup label="Cloud &amp; Services">
            <option value="cloud">Cloud</option>
            <option value="database">Database</option>
			<option value="docker">Docker</option>
            <option value="container">Container</option>
            <option value="vm">Virtual Machine</option>
            <option value="kubernetes">Kubernetes</option>
            <option value="api">API / Endpoint</option>
            <option value="queue">Queue / Message</option>
            <option value="lambda">Lambda / Function</option>
            <option value="bucket">Bucket / S3</option>
          </optgroup>
          <optgroup label="Security &amp; Monitoring">
            <option value="shield">Shield</option>
            <option value="camera">Camera / CCTV</option>
            <option value="monitor">Monitor / Dashboard</option>
          </optgroup>
          </select>
          <button class="pick-icon-btn" id="pick-node-icon-btn" style="margin-top: 10px;"> Or search web icons</button>
          <div id="selected-node-icon" style="margin-top: 10px; display: none;">
            <label style="display: block; margin-bottom: 8px; color: var(--text-soft); font-size: 13px;">Selected Icon:</label>
            <div class="icon-badge" id="selected-node-icon-preview">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24">
                <image href="https://cdn.jsdelivr.net/gh/selfhst/icons@master/png/docker.png" width="24" height="24"></image>
              </svg>
              <span>docker</span>
            </div>
          </div>
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Ping / Status Monitoring</div>
          <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px; cursor: pointer;">
          <input type="checkbox" id="new-node-pingable" style="cursor: pointer;">
          <span style="color: var(--text-soft); font-size: 13px;">Enable ping/status check for this node</span>
          </label>
          <div id="new-node-ping-options" style="display: block; padding-left: 24px; border-left: 2px solid var(--edge-main);">
            <label style="display: block; margin-bottom: 4px; color: var(--text-soft); font-size: 13px;">Protocol</label>
            <select id="new-node-ping-protocol" style="margin-bottom: 12px;">
              <option value="http">HTTP (port 80) uses IP field</option>
              <option value="https">HTTPS (port 443) uses IP field</option>
              <option value="custom">Custom URL</option>
            </select>
            <div id="new-node-custom-url-container" style="display: block;">
              <label style="display: block; margin-bottom: 4px; color: var(--text-soft); font-size: 13px;">Custom URL</label>
              <input type="text" id="new-node-custom-url" placeholder="e.g. http://192.168.1.1:8080">
            </div>
            <label style="display: block; margin-bottom: 4px; margin-top: 8px; color: var(--text-soft); font-size: 13px;">
            Timeout (ms)
            </label>
            <input type="number" id="new-node-ping-timeout" value="3000" min="1000" max="10000" step="500">
          </div>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="add-node-cancel">Cancel</button>
          <button class="btn-save" id="add-node-save">Add Node</button>
        </div>
      </div>
    </div>
    <div class="modal" id="add-rack-modal">
      <div class="modal-content">
        <h3>Add New Rack</h3>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Basic Information</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Rack Name</label>
          <input type="text" id="new-rack-name" placeholder="e.g. Rack-A, DC1-R01, Production-01">
          <label style="display: block;margin-bottom: 4px;margin-top: 12px;color: var(--text-soft);font-size: 13px;">IP / Network Range (optional)</label>
          <input type="text" id="new-rack-ip" placeholder="e.g. 192.168.1.0/24">
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Tags</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Text Tags (comma separated)</label>
          <input type="text" id="new-rack-tags" placeholder="e.g. Production, Data Center 1, Row A">
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Rack Appearance</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Icon / Shape</label>
          <select id="new-rack-shape">
            <optgroup label="Basic Shapes">
            <option value="circle">Circle</option>
            <option value="square">Square</option>
            <option value="rectangle">Rectangle</option>
            <option value="triangle">Triangle</option>
            <option value="hexagon">Hexagon</option>
            <option value="diamond">Diamond</option>
            <option value="star">Star</option>
            <option value="stop-sign">Stop Sign</option>
            <option value="octagon">Octagon</option>
            <option value="pentagon">Pentagon</option>
            <option value="cross">Cross</option>
            <option value="rounded-square">Rounded Square</option>
            <option value="pill">Pill</option>
            <option value="parallelogram">Parallelogram</option>
            <option value="trapezoid">Trapezoid</option>
          </optgroup>
          <optgroup label="Computers &amp; Devices">
            <option value="server">Server</option>
            <option value="pc">PC / Desktop</option>
            <option value="laptop">Laptop</option>
            <option value="phone">Phone / Mobile</option>
            <option value="printer">Printer</option>
            <option value="pi">Raspberry Pi</option>
            <option value="sensor">Sensor / IoT</option>
          </optgroup>
          <optgroup label="Network Equipment">
            <option value="router">Router</option>
            <option value="switch">Switch</option>
            <option value="firewall">Firewall</option>
            <option value="access-point">Access Point</option>
            <option value="load-balancer">Load Balancer</option>
            <option value="gateway">Gateway</option>
            <option value="vpn">VPN / Tunnel</option>
            <option value="nas">NAS / Storage</option>
          </optgroup>
          <optgroup label="Cloud &amp; Services">
            <option value="cloud">Cloud</option>
            <option value="database">Database</option>
			<option value="docker">Docker</option>
            <option value="container">Container</option>
            <option value="vm">Virtual Machine</option>
            <option value="kubernetes">Kubernetes</option>
            <option value="api">API / Endpoint</option>
            <option value="queue">Queue / Message</option>
            <option value="lambda">Lambda / Function</option>
            <option value="bucket">Bucket / S3</option>
          </optgroup>
          <optgroup label="Security &amp; Monitoring">
            <option value="shield">Shield</option>
            <option value="camera">Camera / CCTV</option>
            <option value="monitor">Monitor / Dashboard</option>
          </optgroup>
          </select>
          <button class="pick-icon-btn" id="pick-rack-icon-btn" style="margin-top: 10px;">Or Search Web Icons</button>
          <div id="selected-rack-icon" style="margin-top: 10px; display: none;">
            <label style="display: block; margin-bottom: 8px; color: var(--text-soft); font-size: 13px;">Selected Icon:</label>
            <div class="icon-badge" id="selected-rack-icon-preview">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24">
                <image href="" width="24" height="24"></image>
              </svg>
              <span></span>
            </div>
          </div>
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Rack Configuration</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Rack Capacity</label>
          <select id="new-rack-capacity">
            <option value="42" selected="">42U (Standard Full Rack)</option>
            <option value="48">48U (Large Rack)</option>
            <option value="24">24U (Half Rack)</option>
            <option value="12">12U (Small/Wall Mount)</option>
            <option value="6">6U (Mini Rack)</option>
          </select>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="add-rack-cancel">Cancel</button>
          <button class="btn-save" id="add-rack-save">Add Rack</button>
        </div>
      </div>
    </div>
    <div class="modal confirm-modal" id="clear-all-modal">
      <div class="modal-content">
        <h3>Clear All Nodes</h3>
        <p> This will remove ALL nodes and connections. This cannot be undone until you reload without saving. Are you sure? </p>
        <div class="modal-buttons">
          <button class="btn-cancel" id="clear-all-cancel">Cancel</button>
          <button class="btn-delete" id="clear-all-confirm">Clear Everything</button>
        </div>
      </div>
    </div>
    <div class="modal" id="layer-modal">
      <div class="modal-content" style="max-width: 400px;">
        <h3>Layer Visibility</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Toggle which layers are visible on the canvas</p>
        <div style="display: flex; flex-direction: column; gap: 10px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-physical" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Physical Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-logical" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Logical Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-security" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Security Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-application" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Application Layer</span>
          </label>
        </div>
        <div style="margin-top: 15px; display: flex; gap: 8px;">
          <button class="btn-cancel" style="flex: 1;" onclick="document.querySelectorAll('#layer-modal input[type=checkbox]').forEach(cb =&gt; cb.checked = false); applyLayerFilter();">Hide All</button>
          <button class="btn-save" style="flex: 1;" onclick="document.querySelectorAll('#layer-modal input[type=checkbox]').forEach(cb =&gt; cb.checked = true); applyLayerFilter();">Show All</button>
        </div>
        <div class="modal-buttons" style="margin-top: 10px;">
          <button class="btn-cancel" id="layer-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div id="context-menu" style="display: none !important;">
    </div>
    <header>
      <div class="title-block">
        <h1 id="page-title" class="editable-page-title">The One File</h1>
        <div class="save-row">
          <button id="save-file-btn" class="save-btn" type="button">Save File</button>
          <label style="display: flex;align-items: center;gap: 4px;font-size: 12px;color: var(--text-soft);cursor: pointer;user-select: none;">
          <input type="checkbox" id="encrypt-toggle" style="cursor: pointer">
          <span title="Encrypt data with password">Encrypt</span>
          </label>
          <span id="save-help-btn" class="help-icon" title="Why save?">?</span>
        </div>
      </div>
      <div id="topbar-menu">
        <button id="back-to-topology-btn" title="Exit rack view and return to topology" style="padding: 6px 12px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;display: none;">‚Üê Back to Topology</button>
        <button id="add-node-btn" class="save-btn" title="Add new node" style="background: var(--accent)">+ Node</button>
        <button id="add-rack-btn" class="save-btn" title="Add new rack" style="background: var(--accent); margin-left: 8px;">+ Rack</button>
        <button id="undo-btn" title="Undo (Ctrl+Z)" style="padding: 6px 12px; background: var(--btn-bg); color: var(--btn-text); border: 1px solid var(--edge-main); border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600; opacity: 1;">‚Ü∂</button>
        <button id="redo-btn" title="Redo (Ctrl+Y)" style="padding: 6px 12px; background: var(--btn-bg); color: var(--btn-text); border: 1px solid var(--edge-main); border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600; opacity: 0.5;" disabled="">‚Ü∑</button>
<input type="text" id="search-nodes" placeholder="Search nodes..." title="Search by name, IP, MAC, role, or tag" style="padding: 6px 12px;background: var(--input-bg);color: var(--input-text);border: 1px solid var(--input-border);border-radius: 6px;font-family: var(--input-font);font-size: var(--input-font-size);width: 180px;">
        <button id="check-all-ping-btn" title="Check status of all enabled nodes" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600">Check Pings</button>
        <button id="layers-btn" title="Toggle layer visibility" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Layers</button>
        <button id="tabs-btn" title="Manage document tabs" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Tabs</button>
        <button id="rollback-btn" title="View version history" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Snapshots</button>
        <button id="audit-log-btn" title="View audit log" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Audit</button>
        <button id="secrets-btn" title="Manage encrypted notes" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Notes</button>
        <button onclick="screenshotCanvas()" title="Export canvas as PNG image" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">PNG</button>
        <button onclick="exportCanvasSVG()" title="Export canvas as SVG vector" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">SVG</button>
        <button id="settings-btn" title="Page settings">‚öôÔ∏è</button>
      </div>
      <button id="mobile-menu-toggle" class="mobile-menu-btn">‚ò∞</button>
      <div class="header-resizer" id="header-resizer">
        <svg class="resizer-icon" width="40" height="6" viewBox="0 0 40 6" xmlns="http://www.w3.org/2000/svg">
          <circle cx="14" cy="3" r="2"></circle>
          <circle cx="20" cy="3" r="2"></circle>
          <circle cx="26" cy="3" r="2"></circle>
        </svg>
      </div>
    </header>
    <main>
      <section class="topology-panel">
        <div class="draw-toolbar" id="draw-toolbar" style="display: flex !important;">
          <button type="button" class="toolbar-close-btn" id="draw-toolbar-close-btn" title="Hide draw toolbar">‚úï</button>
          <button id="draw-toggle" title="Draw custom line">‚úèÔ∏è</button>
          <button id="rect-toggle" title="Draw zone">‚ñ≠</button>
          <button id="text-toggle" title="Add text">T</button>
          <select id="rect-style" title="zone style">
            <option value="filled">Filled</option>
            <option value="outlined">Outlined</option>
          </select>
          <input type="color" id="draw-color" value="#f97316" title="Line color">
          <select id="draw-style" title="Line style">
            <option value="solid">Solid</option>
            <option value="dashed">Dashed</option>
            <option value="dotted">Dotted</option>
          </select>
          <select id="draw-arrow" title="Arrow direction">
            <option value="none">No arrows</option>
            <option value="forward">‚Üí Right</option>
            <option value="backward">‚Üê Left</option>
            <option value="both">‚Üî Both</option>
          </select>
          <button id="draw-undo" style="display: none" title="Undo last point">Undo</button>
        </div>
        <div class="topology-toolbar" id="topology-toolbar" style="display: flex !important;">
          <button type="button" class="toolbar-close-btn" id="topology-toolbar-close-btn" title="Hide add line toolbar">‚úï</button>
          <label for="add-line-select">Add line to:</label>
          <select id="add-line-select"><option value="core-router-2">Core Router 2</option><option value="fw-external-1">External FW 1</option><option value="fw-external-2">External FW 2</option><option value="fw-internal">Internal FW</option><option value="core-switch-1">Core Switch 1</option><option value="core-switch-2">Core Switch 2</option><option value="dc-rack-a1">DC Rack A1</option><option value="dc-rack-a2">DC Rack A2</option><option value="dc-rack-b1">DC Rack B1</option><option value="dc-rack-b2">DC Rack B2</option><option value="dmz-rack">DMZ Rack</option><option value="mgmt-rack">Management Rack</option><option value="wlc-primary">WLC Primary</option><option value="wlc-secondary">WLC Secondary</option><option value="mobile-zone-hq">HQ Mobile Zone</option><option value="mobile-zone-guest">Guest WiFi Zone</option><option value="mobile-zone-iot">IoT Device Zone</option><option value="branch-router-ny">NYC Branch Router</option><option value="branch-router-la">LA Branch Router</option><option value="branch-router-chi">Chicago Branch Router</option><option value="branch-router-lon">London Branch Router</option><option value="branch-router-tokyo">Tokyo Branch Router</option><option value="cloud-aws">AWS Cloud</option><option value="cloud-azure">Azure Cloud</option><option value="cloud-gcp">GCP Cloud</option><option value="isp-primary">ISP Primary</option><option value="isp-secondary">ISP Secondary</option><option value="proxy-server-1">Proxy Server 1</option><option value="proxy-server-2">Proxy Server 2</option><option value="vpn-concentrator">VPN Concentrator</option><option value="nac-server">NAC Server</option><option value="voip-cluster">VoIP Cluster</option><option value="video-conf">Video Conference</option><option value="security-cameras">Security Cameras</option><option value="dev-server-1">Dev Server 1</option><option value="dev-server-2">Dev Server 2</option><option value="test-environment">Test Environment</option><option value="erp-system">ERP System</option><option value="crm-system">CRM System</option><option value="endpoint-1000">Corporate Endpoints</option><option value="dist-switch-floor1">Floor 1 Switch</option><option value="dist-switch-floor2">Floor 2 Switch</option><option value="dist-switch-floor3">Floor 3 Switch</option><option value="dist-switch-floor4">Floor 4 Switch</option><option value="ap-floor1-zone1">AP Floor 1 Zone 1</option><option value="ap-floor2-zone1">AP Floor 2 Zone 1</option><option value="ap-floor3-zone1">AP Floor 3 Zone 1</option><option value="ap-floor4-zone1">AP Floor 4 Zone 1</option><option value="ups-dc-1">UPS DC-1</option><option value="ups-dc-2">UPS DC-2</option><option value="cooling-1">CRAC Unit 1</option><option value="cooling-2">CRAC Unit 2</option></select>
<input type="color" id="add-line-color" value="#475569" title="Line color" style="width: 30px;height: 24px;border: 1px solid var(--toolbar-border);border-radius: 4px;cursor: pointer;background: transparent;padding: 0;">          <select id="add-line-direction" title="Line direction">
            <option value="none">No arrows</option>
            <option value="forward">‚Üí Forward</option>
            <option value="backward">‚Üê Backward</option>
            <option value="both">‚Üî Both</option>
          </select>
          <button id="add-line-btn">Add</button>
        </div>
        <div class="topology-toolbar bulk-toolbar-desktop" id="bulk-toolbar" style="display: none">
          <button type="button" class="toolbar-close-btn" id="bulk-toolbar-close" title="Clear selection">‚úï</button>
          <label style="font-weight: 600; color: var(--accent)">Selected: <span id="bulk-count">0</span></label>
          <button id="bulk-align-left" title="Align left">‚¨Ö Left</button>
          <button id="bulk-align-right" title="Align right">‚û° Right</button>
          <button id="bulk-align-top" title="Align top">‚¨Ü Top</button>
          <button id="bulk-align-bottom" title="Align bottom">‚¨á Bottom</button>
          <button id="bulk-distribute-h" title="Distribute horizontally">‚Üî Distribute H</button>
          <button id="bulk-distribute-v" title="Distribute vertically">‚Üï Distribute V</button>
          <button id="bulk-clone" title="Clone selected">üìã Clone</button>
          <button id="bulk-delete" title="Delete selected" style="background: var(--danger); color: white;">Delete</button>
        </div>
        <div class="bulk-toolbar-mobile" id="bulk-toolbar-mobile" style="display: none">
          <button type="button" id="bulk-mobile-btn" style="background: var(--accent);color: white;padding: 12px 20px;border-radius: 25px;font-weight: 600;font-size: 16px;box-shadow: 0 4px 12px rgba(0,0,0,0.3);border: none;cursor: pointer;display: flex;align-items: center;gap: 8px;">
          <span id="bulk-count-mobile">0</span>Selected</button>
        </div>
        <div id="bulk-actions-modal" style="display: none;position: fixed;bottom: 0;left: 0;right: 0;background: var(--panel-alt);border-top-left-radius:20px;border-top-right-radius:20px;padding:20px;padding-bottom:(safe-area-inset-bottom, 20px);box-shadow: 0 -4px 20px rgba(0,0,0,0.5);z-index: 10000;max-height: calc(100vh - 80px);overflow-y: auto;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            <h3 style="margin: 0; color: var(--accent); font-size: 20px;">
              <span id="bulk-count-modal">0</span> Nodes Selected
            </h3>
            <button id="bulk-modal-close" style="background: none;border: none;font-size: 24px;cursor: pointer;color: var(--text-main);padding: 0;width: 32px;height: 32px;">‚úï</button>
          </div>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
            <button id="bulk-align-left-mobile" class="bulk-action-btn">‚¨Ö<br><span style="font-size: 12px;">Align Left</span></button>
            <button id="bulk-align-right-mobile" class="bulk-action-btn">‚û°<br><span style="font-size: 12px;">Align Right</span></button>
            <button id="bulk-align-top-mobile" class="bulk-action-btn">‚¨Ü<br><span style="font-size: 12px;">Align Top</span></button>
            <button id="bulk-align-bottom-mobile" class="bulk-action-btn">‚¨á<br><span style="font-size: 12px;">Align Bottom</span></button>
            <button id="bulk-distribute-h-mobile" class="bulk-action-btn">‚Üî<br><span style="font-size: 12px;">Distribute H</span></button>
            <button id="bulk-distribute-v-mobile" class="bulk-action-btn">‚Üï<br><span style="font-size: 12px;">Distribute V</span></button>
            <button id="bulk-lock-mobile" class="bulk-action-btn">üîí<br><span style="font-size: 12px;">Lock Toggle</span></button>
            <button id="bulk-group-mobile" class="bulk-action-btn">‚≠ï<br><span style="font-size: 12px;">Group Toggle</span></button>
            <button id="bulk-clone-mobile" class="bulk-action-btn">üìã<br><span style="font-size: 12px;">Clone All</span></button>
            <button id="bulk-delete-mobile" class="bulk-action-btn" style="background: var(--danger); color: white;">üóë<br><span style="font-size: 12px;">Delete All</span></button>
          </div>
          <button id="bulk-clear-mobile" style="width: 100%;margin-top: 16px;padding: 14px;background: var(--panel-main);border: 1px solid var(--edge-main);border-radius: 8px;color: var(--text-main);font-size: 16px;cursor: pointer;">Clear Selection</button>
        </div>
        <div class="canvas-hint" id="canvas-hint"></div>
        <div class="legend-container" id="edge-legend" style="display: flex;"><div class="legend-title">Line Legend</div><button type="button" class="legend-close-btn">‚úï</button><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(85, 226, 8); cursor: pointer;"></span><span class="legend-label" contenteditable="true">ISP LINE</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(76, 0, 255); cursor: pointer;"></span><span class="legend-label" contenteditable="true">MY Guest NETWORK</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(128, 255, 0); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(251, 0, 255); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(255, 0, 208); cursor: pointer;"></span><span class="legend-label" contenteditable="true">iPhone (always guest iPhone)</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(249, 115, 22); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div></div>
        <div class="canvas-viewport" id="canvas-viewport">
          <svg id="map" viewBox="1254.5197896196048 -147.55422459755366 2648.185035176588 1986.138776382441" style=""><defs><marker id="arrow-forward" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto" markerUnits="strokeWidth"><path d="M0,0 L0,6 L9,3 z" fill="context-stroke"></path></marker><marker id="arrow-backward" markerWidth="10" markerHeight="10" refX="0" refY="3" orient="auto" markerUnits="strokeWidth"><path d="M9,0 L9,6 L0,3 z" fill="context-stroke"></path></marker></defs><rect x="100" y="100" width="3800" height="2800" fill="none" stroke="#4755694D" stroke-width="20" stroke-dasharray="10 5" rx="8"></rect><g id="canvas-grid"><line x1="100" y1="100" x2="100" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="150" y1="100" x2="150" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="200" y1="100" x2="200" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="250" y1="100" x2="250" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="300" y1="100" x2="300" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="350" y1="100" x2="350" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="400" y1="100" x2="400" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="450" y1="100" x2="450" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="500" y1="100" x2="500" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="550" y1="100" x2="550" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="600" y1="100" x2="600" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="650" y1="100" x2="650" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="700" y1="100" x2="700" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="750" y1="100" x2="750" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="800" y1="100" x2="800" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="850" y1="100" x2="850" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="900" y1="100" x2="900" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="950" y1="100" x2="950" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1000" y1="100" x2="1000" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1050" y1="100" x2="1050" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1100" y1="100" x2="1100" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="1150" y1="100" x2="1150" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1200" y1="100" x2="1200" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1250" y1="100" x2="1250" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1300" y1="100" x2="1300" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1350" y1="100" x2="1350" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="1400" y1="100" x2="1400" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1450" y1="100" x2="1450" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1500" y1="100" x2="1500" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1550" y1="100" x2="1550" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1600" y1="100" x2="1600" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="1650" y1="100" x2="1650" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1700" y1="100" x2="1700" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1750" y1="100" x2="1750" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1800" y1="100" x2="1800" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1850" y1="100" x2="1850" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="1900" y1="100" x2="1900" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1950" y1="100" x2="1950" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2000" y1="100" x2="2000" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2050" y1="100" x2="2050" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2100" y1="100" x2="2100" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="2150" y1="100" x2="2150" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2200" y1="100" x2="2200" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2250" y1="100" x2="2250" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2300" y1="100" x2="2300" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2350" y1="100" x2="2350" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="2400" y1="100" x2="2400" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2450" y1="100" x2="2450" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2500" y1="100" x2="2500" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2550" y1="100" x2="2550" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2600" y1="100" x2="2600" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="2650" y1="100" x2="2650" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2700" y1="100" x2="2700" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2750" y1="100" x2="2750" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2800" y1="100" x2="2800" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2850" y1="100" x2="2850" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="2900" y1="100" x2="2900" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2950" y1="100" x2="2950" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3000" y1="100" x2="3000" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3050" y1="100" x2="3050" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3100" y1="100" x2="3100" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="3150" y1="100" x2="3150" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3200" y1="100" x2="3200" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3250" y1="100" x2="3250" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3300" y1="100" x2="3300" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3350" y1="100" x2="3350" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="3400" y1="100" x2="3400" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3450" y1="100" x2="3450" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3500" y1="100" x2="3500" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3550" y1="100" x2="3550" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3600" y1="100" x2="3600" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="3650" y1="100" x2="3650" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3700" y1="100" x2="3700" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3750" y1="100" x2="3750" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3800" y1="100" x2="3800" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3850" y1="100" x2="3850" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="3900" y1="100" x2="3900" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="100" x2="3900" y2="100" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="150" x2="3900" y2="150" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="200" x2="3900" y2="200" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="250" x2="3900" y2="250" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="300" x2="3900" y2="300" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="350" x2="3900" y2="350" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="400" x2="3900" y2="400" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="450" x2="3900" y2="450" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="500" x2="3900" y2="500" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="550" x2="3900" y2="550" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="600" x2="3900" y2="600" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="650" x2="3900" y2="650" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="700" x2="3900" y2="700" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="750" x2="3900" y2="750" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="800" x2="3900" y2="800" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="850" x2="3900" y2="850" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="900" x2="3900" y2="900" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="950" x2="3900" y2="950" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1000" x2="3900" y2="1000" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1050" x2="3900" y2="1050" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1100" x2="3900" y2="1100" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="1150" x2="3900" y2="1150" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1200" x2="3900" y2="1200" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1250" x2="3900" y2="1250" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1300" x2="3900" y2="1300" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1350" x2="3900" y2="1350" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="1400" x2="3900" y2="1400" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1450" x2="3900" y2="1450" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1500" x2="3900" y2="1500" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1550" x2="3900" y2="1550" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1600" x2="3900" y2="1600" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="1650" x2="3900" y2="1650" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1700" x2="3900" y2="1700" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1750" x2="3900" y2="1750" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1800" x2="3900" y2="1800" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1850" x2="3900" y2="1850" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="1900" x2="3900" y2="1900" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1950" x2="3900" y2="1950" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2000" x2="3900" y2="2000" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2050" x2="3900" y2="2050" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2100" x2="3900" y2="2100" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="2150" x2="3900" y2="2150" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2200" x2="3900" y2="2200" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2250" x2="3900" y2="2250" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2300" x2="3900" y2="2300" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2350" x2="3900" y2="2350" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="2400" x2="3900" y2="2400" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2450" x2="3900" y2="2450" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2500" x2="3900" y2="2500" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2550" x2="3900" y2="2550" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2600" x2="3900" y2="2600" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="2650" x2="3900" y2="2650" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2700" x2="3900" y2="2700" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2750" x2="3900" y2="2750" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2800" x2="3900" y2="2800" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2850" x2="3900" y2="2850" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="2900" x2="3900" y2="2900" stroke="#47556933" stroke-width="1"></line></g><g class="rect-group" data-rect-id="rect-1765238219615"><rect class="rect-shape" x="2680.053955078125" y="251.44879150390625" width="814.10400390625" height="389.26678466796875" style="fill: rgb(236, 9, 153); fill-opacity: 0.3; stroke: rgb(236, 9, 153); stroke-width: 2px; stroke-dasharray: none; cursor: move;"></rect><g class="rect-delete-btn" style="cursor: pointer; display: none;"><circle cx="3484.157958984375" cy="261.44879150390625" r="12" style="fill: rgb(245, 101, 101); stroke: white; stroke-width: 2;"></circle><text x="3484.157958984375" y="261.44879150390625" text-anchor="middle" dominant-baseline="middle" style="fill: white; font-size: 16px; font-weight: bold; pointer-events: none;">√ó</text></g></g><path d="M 2103.968290880771 268 Q 2085.4680212352528 370.70595670887826 2066.9677515897347 473.4119134177565" fill="none" class="edge" data-edge-id="internet-internet-copy-1765238145151" data-from="internet" data-to="internet-copy" style="stroke: rgb(85, 226, 8); stroke-width: 4;"></path><path d="M 2103.968290880771 268 Q 2085.4680212352528 370.70595670887826 2066.9677515897347 473.4119134177565" fill="none" data-edge-id="internet-internet-copy-1765238145151" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 1920.4039088162972 569.9938683738112 1773.8400660428597 666.5758233298659" fill="none" class="edge" data-edge-id="internet-copy-opnsense-copy-1765238187451" data-from="internet-copy" data-to="opnsense-copy" style="stroke: rgb(76, 0, 255); stroke-width: 4;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 1920.4039088162972 569.9938683738112 1773.8400660428597 666.5758233298659" fill="none" data-edge-id="internet-copy-opnsense-copy-1765238187451" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 1999.08282329894 627.8447547749242 1931.1978950081452 782.2775961320921" fill="none" class="edge" data-edge-id="internet-copy-docker-copy-1765238242477" data-from="internet-copy" data-to="docker-copy" style="stroke: rgb(76, 0, 255); stroke-width: 4;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 1999.08282329894 627.8447547749242 1931.1978950081452 782.2775961320921" fill="none" data-edge-id="internet-copy-docker-copy-1765238242477" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2112.546995662221 620.5620704487524 2158.1262397347077 767.7122274797483" fill="none" class="edge" data-edge-id="internet-copy-docker-copy-1-1765238244637" data-from="internet-copy" data-to="docker-copy-1" style="stroke: rgb(76, 0, 255); stroke-width: 4;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2112.546995662221 620.5620704487524 2158.1262397347077 767.7122274797483" fill="none" data-edge-id="internet-copy-docker-copy-1-1765238244637" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2204.617064021596 552.590055067893 2342.2663764534577 631.7681967180296" fill="none" class="edge" data-edge-id="internet-copy-docker-copy-2-1765238246233" data-from="internet-copy" data-to="docker-copy-2" style="stroke: rgb(76, 0, 255); stroke-width: 4;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2204.617064021596 552.590055067893 2342.2663764534577 631.7681967180296" fill="none" data-edge-id="internet-copy-docker-copy-2-1765238246233" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2103.968290880771 268 Q 2430.923885484287 287.80585580459456 2757.879480087803 307.6117116091891" fill="none" class="edge" data-edge-id="internet-opnsense-copy-1-1765238266117" data-from="internet" data-to="opnsense-copy-1" style="stroke: rgb(128, 255, 0); stroke-width: 4;"></path><path d="M 2103.968290880771 268 Q 2430.923885484287 287.80585580459456 2757.879480087803 307.6117116091891" fill="none" data-edge-id="internet-opnsense-copy-1-1765238266117" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2757.879480087803 307.6117116091891 Q 2979.171899521397 314.04065142852505 3200.4643189549906 320.469591247861" fill="none" class="edge" data-edge-id="opnsense-copy-1-dns-1765238347996" data-from="opnsense-copy-1" data-to="dns" style="stroke: rgb(251, 0, 255); stroke-width: 4;"></path><path d="M 2757.879480087803 307.6117116091891 Q 2979.171899521397 314.04065142852505 3200.4643189549906 320.469591247861" fill="none" data-edge-id="opnsense-copy-1-dns-1765238347996" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 3200.4643189549906 320.469591247861 Q 3086.0821778417094 400.59916888457974 2971.700036728428 480.7287465212985" fill="none" class="edge" data-edge-id="dns-desktop-1765238386101" data-from="dns" data-to="desktop" style="stroke: rgb(255, 0, 208); stroke-width: 4;"></path><path d="M 3200.4643189549906 320.469591247861 Q 3086.0821778417094 400.59916888457974 2971.700036728428 480.7287465212985" fill="none" data-edge-id="dns-desktop-1765238386101" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 3312.857751572178 502.58220111114224 Q 3256.6610352635844 411.5258961795016 3200.4643189549906 320.469591247861" fill="none" class="edge" data-edge-id="phone-dns-1765238391156" data-from="phone" data-to="dns" style="stroke: rgb(255, 0, 208); stroke-width: 4;"></path><path d="M 3312.857751572178 502.58220111114224 Q 3256.6610352635844 411.5258961795016 3200.4643189549906 320.469591247861" fill="none" data-edge-id="phone-dns-1765238391156" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><polyline class="edge" data-edge-id="custom-1765239449323" fill="none" marker-end="url(#arrow-forward)" points="2936.464111328125,786.07958984375 3184.112060546875,887.6153564453125 2763.110107421875,981.7216796875" style="stroke: rgb(249, 115, 22); stroke-width: 4; stroke-dasharray: none;"></polyline><polyline points="2936.464111328125,786.07958984375 3184.112060546875,887.6153564453125 2763.110107421875,981.7216796875" data-edge-id="custom-1765239449323" style="fill: none; stroke: transparent; stroke-width: 20; cursor: pointer;"></polyline><g class="node-group" data-node-id="internet" transform="translate(2103.968290880771,268)" style="cursor: grab;"><circle r="252" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" viewBox="0 0 512 512" width="201.6" height="201.6" x="-100.8" y="-100.8" style="fill: rgb(255, 255, 255); stroke: rgb(255, 255, 255);"><path d="M144.3 214.1c0 6.3.7 11.4 1.9 15.2 1.4 3.7 3.1 7.8 5.4 12.3.9 1.4 1.2 2.7 1.2 3.9 0 1.7-1 3.4-3.2 5.1l-10.7 7.2c-1.5 1-3.1 1.5-4.4 1.5-1.7 0-3.4-.9-5.1-2.4-2.4-2.6-4.4-5.3-6.1-8-1.7-2.9-3.4-6.1-5.3-10-13.3 15.7-30 23.5-50.1 23.5-14.3 0-25.7-4.1-34.1-12.3-8.3-8.2-12.6-19.1-12.6-32.7 0-14.5 5.1-26.2 15.5-35.1S60.8 169 78.4 169c5.8 0 11.7.5 18.1 1.4s12.8 2.2 19.6 3.7v-12.4c0-12.9-2.7-22-8-27.2-5.4-5.3-14.6-7.8-27.8-7.8-6 0-12.1.7-18.4 2.2s-12.4 3.4-18.4 5.8c-2.7 1.2-4.8 1.9-6 2.2s-2 .5-2.7.5c-2.4 0-3.6-1.7-3.6-5.3v-8.3c0-2.7.3-4.8 1.2-6s2.4-2.4 4.8-3.6c6-3.1 13.1-5.6 21.5-7.7 8.3-2.2 17.2-3.2 26.6-3.2 20.3 0 35.1 4.6 44.6 13.8 9.4 9.2 14.1 23.2 14.1 41.9v55.2zM75.2 240c5.6 0 11.4-1 17.5-3.1 6.1-2 11.6-5.8 16.2-10.9 2.7-3.2 4.8-6.8 5.8-10.9s1.7-9 1.7-14.8v-7.2c-4.9-1.2-10.2-2.2-15.7-2.9-5.4-.7-10.7-1-16-1-11.4 0-19.8 2.2-25.4 6.8S51 207.1 51 215.6c0 8 2 14 6.3 18.1 4.1 4.2 10 6.3 17.9 6.3m136.7 18.4c-3.1 0-5.1-.5-6.5-1.7-1.4-1-2.6-3.4-3.6-6.6l-40-131.6c-1-3.4-1.5-5.6-1.5-6.8 0-2.7 1.4-4.3 4.1-4.3h16.7c3.2 0 5.4.5 6.6 1.7 1.4 1 2.4 3.4 3.4 6.6l28.6 112.7 26.6-112.7c.9-3.4 1.9-5.6 3.2-6.6 1.4-1 3.7-1.7 6.8-1.7H270c3.2 0 5.4.5 6.8 1.7 1.4 1 2.6 3.4 3.2 6.6l26.9 114.1 29.5-114.1c1-3.4 2.2-5.6 3.4-6.6 1.4-1 3.6-1.7 6.6-1.7h15.8c2.7 0 4.3 1.4 4.3 4.3 0 .9-.2 1.7-.3 2.7-.2 1-.5 2.4-1.2 4.3l-41 131.6q-1.5 5.1-3.6 6.6c-1.4 1-3.6 1.7-6.5 1.7h-14.6c-3.2 0-5.4-.5-6.8-1.7s-2.6-3.4-3.2-6.8l-26.4-109.8L236.7 250c-.9 3.4-1.9 5.6-3.2 6.8-1.4 1.2-3.7 1.7-6.8 1.7zm218.8 4.6c-8.9 0-17.7-1-26.2-3.1-8.5-2-15.2-4.3-19.6-6.8-2.7-1.5-4.6-3.2-5.3-4.8s-1-3.2-1-4.8v-8.7c0-3.6 1.4-5.3 3.9-5.3 1 0 2 .2 3.1.5 1 .3 2.6 1 4.3 1.7 5.8 2.6 12.1 4.6 18.7 6 6.8 1.4 13.5 2 20.3 2 10.7 0 19.1-1.9 24.9-5.6s8.9-9.2 8.9-16.2c0-4.8-1.5-8.7-4.6-11.9s-8.9-6.1-17.2-8.9l-24.7-7.7c-12.4-3.9-21.6-9.7-27.2-17.4-5.6-7.5-8.5-15.8-8.5-24.7 0-7.2 1.5-13.5 4.6-18.9s7.2-10.2 12.3-14c5.1-3.9 10.9-6.8 17.7-8.9 6.8-2 14-2.9 21.5-2.9 3.7 0 7.7.2 11.4.7 3.9.5 7.5 1.2 11.1 1.9 3.4.9 6.6 1.7 9.7 2.7s5.4 2 7.2 3.1c2.4 1.4 4.1 2.7 5.1 4.3 1 1.4 1.5 3.2 1.5 5.6v8c0 3.6-1.4 5.4-3.9 5.4-1.4 0-3.6-.7-6.5-2q-14.55-6.6-32.7-6.6c-9.7 0-17.4 1.5-22.6 4.8s-8 8.2-8 15.2c0 4.8 1.7 8.9 5.1 12.1s9.7 6.5 18.7 9.4l24.2 7.7c12.3 3.9 21.1 9.4 26.4 16.3s7.8 15 7.8 23.8c0 7.3-1.5 14-4.4 19.8-3.1 5.8-7.2 10.9-12.4 15-5.3 4.3-11.6 7.3-18.9 9.5-8 2.5-16 3.7-24.7 3.7" style="fill: rgb(255, 255, 255); stroke: rgb(255, 255, 255);"></path><path d="M462.9 345.7c-56 41.4-137.4 63.3-207.4 63.3-98.1 0-186.5-36.3-253.2-96.6-5.3-4.8-.5-11.2 5.8-7.5 72.2 41.9 161.3 67.3 253.4 67.3 62.2 0 130.4-12.9 193.3-39.5 9.3-4.2 17.3 6.2 8.1 13m23.3-26.5c-7.2-9.2-47.3-4.4-65.6-2.2-5.4.7-6.3-4.1-1.4-7.7 32-22.5 84.6-16 90.8-8.5 6.1 7.7-1.7 60.3-31.7 85.5-4.6 3.9-9 1.9-7-3.2 6.9-16.9 22.1-54.9 14.9-63.9" style="fill-rule: evenodd; clip-rule: evenodd; fill: rgb(255, 255, 255); stroke: rgb(255, 255, 255);"></path></svg></g><text class="node-label" x="0" y="-47.040000000000006" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Internet</text><text class="node-sub" x="0" y="67.2" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="internet-copy" transform="translate(2066.9677515897347,473.4119134177565)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" viewBox="0 0 512 512" width="66" height="66" x="-33" y="-33"><path d="M512 160.2V400H400V112H112V0h240.4zM112 112H0v240.4L160.2 512H400V400H112z" style="fill:#de3c07"></path></svg></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">OPNSENSE</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="opnsense-copy" transform="translate(1773.8400660428597,666.5758233298659)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" viewBox="0 0 512 512" width="66" height="66" x="-33" y="-33"><path d="M462.2 512H49.8C22.3 512 0 489.7 0 462.2V49.8C0 22.3 22.3 0 49.8 0h412.4C489.7 0 512 22.3 512 49.8v412.4c0 27.5-22.3 49.8-49.8 49.8" style="fill:#2e2f33"></path><path d="M108.2 63.9h140.9c97.2 0 154.6 30.4 154.6 129.5v3.4c0 99.4-57.2 129.5-154.5 129.5h-30.7V447H108.2zm134.5 177.8c30.1 0 46-11.2 46-44.6v-3.9c0-33.2-15.8-44.6-46-44.6h-24.2v93.1zM313 358h90.3v90.1H313z" style="fill:#f7f6f3"></path></svg></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Docker</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="docker-copy" transform="translate(1931.1978950081452,782.2775961320921)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" viewBox="0 0 512 512" width="66" height="66" x="-33" y="-33"><path d="M438.6 0H73.4C33.1 0 .3 32.8.3 73.1v365.7c0 40.3 32.8 73.1 73.1 73.1h365.3c40.3 0 73.1-32.8 73.1-73.1V73.1C511.7 32.8 478.9 0 438.6 0" style="fill-rule:evenodd;clip-rule:evenodd;fill:#8b3bd0"></path><path d="M356.8 53.6v261.3c0 39.3-13.9 72.8-41.8 100.7s-61.4 41.8-100.7 41.8l-23.8-95h23.8c13 0 24.1-4.6 33.2-13.8 9.5-9.5 14.3-20.7 14.3-33.7V148.6H157.3v-95z" style="fill:#fff"></path></svg></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Docker2</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="docker-copy-1" transform="translate(2158.1262397347077,767.7122274797483)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" viewBox="0 0 512 512" width="66" height="66" x="-33" y="-33"><path d="M0 0h512v512H0z" style="fill:#111827"></path><path d="M170.7 85.3 369.8 256 170.7 426.7z" style="fill:#f59e0b"></path></svg></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Docker3</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="docker-copy-2" transform="translate(2342.2663764534577,631.7681967180296)" style="cursor: grab;"><circle r="123" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" viewBox="0 0 512 512" width="98.39999999999999" height="98.39999999999999" x="-49.199999999999996" y="-49.199999999999996"><path d="M501.4 212.3c-11.5-8-38-11-58.6-7-2.4-20-13.5-37.5-32.7-53l-11-8-7.7 11.5c-9.6 15-14.4 36-13 56 .5 7 2.9 19.5 10.1 30.5-6.7 4-20.7 9-38.9 9H2.3l-1 4c-3.4 20-3.4 82.5 36 130.5 29.8 36.5 74 55 132.1 55 125.9 0 219.1-60.5 262.8-170 17.3.5 54.3 0 73-37.5.5-1 1.4-3 4.8-10.5l1.9-4zM280 71.3h-52.8v50H280zm0 60h-52.8v50H280zm-62.5 0h-52.8v50h52.8zm-62.4 0h-52.8v50h52.8zm-62.5 60H39.8v50h52.8zm62.5 0h-52.8v50h52.8zm62.4 0h-52.8v50h52.8zm62.5 0h-52.8v50H280zm62.4 0h-52.8v50h52.8z" style="fill:#2396ed"></path></svg></g><text class="node-label" x="0" y="-22.96" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Docker 4</text><text class="node-sub" x="0" y="32.800000000000004" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="opnsense-copy-1" transform="translate(2757.879480087803,307.6117116091891)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" viewBox="0 0 512 512" width="66" height="66" x="-33" y="-33"><path d="M503.1 465.4v2.1c-6 25.5-28.4 44.5-55 44.5H7.3v-46.6h38.3v7.3h403c1.1 0 2 0 2.9-.1 1.8-.1 3.6-.6 5.2-1.3 2.9-1.3 5.3-3.3 7-5.9zM63.9 0c-26.5 0-49 19-55 44.5V47H48c2.7-4.3 7.3-7.2 12.6-7.6 1-.1 2-.1 3.2-.1h402.6V47h38.3V0z" style="fill:#898b8d"></path><path d="M466.1 157.7V197H319.5v-39.3zM45.9 315.4v39.3h146.6v-39.3zm0-157.7V197h146.6v-39.3zm273.6 157.7v39.3h146.6v-39.3z" style="fill:#58595b"></path><path d="M83.8 78.6H428v39.3H83.8zm0 315.9H428v39.3H83.8z" style="fill:#403f41"></path><linearGradient id="opnsense-v1_svg__a" x1="-1460.617" x2="-1375.11" y1="1248.095" y2="1248.095" gradientTransform="matrix(.1853 .356 .6722 -.353 -90.66 993.802)" gradientUnits="userSpaceOnUse"><stop offset="0" style="stop-color:#737373"></stop><stop offset="1" style="stop-color:#333"></stop></linearGradient><path d="m466.5 78.6 38.2-20.5.1-39.5-38.3 20.7" style="fill:url(#opnsense-v1_svg__a)"></path><linearGradient id="opnsense-v1_svg__b" x1="4.634" x2="50.301" y1="462.6" y2="462.6" gradientTransform="matrix(1 0 0 -1 0 514)" gradientUnits="userSpaceOnUse"><stop offset="0" style="stop-color:#737373"></stop><stop offset="1" style="stop-color:#333"></stop></linearGradient><path d="M45.6 64.5v-8.9c0-5.3 2.6-10 6.5-13l-34-18.5c-6.7 9.5-10.8 21.3-10.9 34l38.3 20.6v-14c.1-.1.1-.2.1-.2" style="fill:url(#opnsense-v1_svg__b)"></path><linearGradient id="opnsense-v1_svg__c" x1="-1587.887" x2="-1498.137" y1="-2208.165" y2="-2208.165" gradientTransform="matrix(-.1853 -.356 -.6722 .353 -1743.836 694.098)" gradientUnits="userSpaceOnUse"><stop offset="0" style="stop-color:#737373"></stop><stop offset="1" style="stop-color:#333"></stop></linearGradient><path d="M45.6 472.7v-38.9L7.3 454.5v39.7l39.9-21.5z" style="fill:url(#opnsense-v1_svg__c)"></path><linearGradient id="opnsense-v1_svg__d" x1="460.439" x2="504.436" y1="53" y2="53" gradientTransform="matrix(1 0 0 -1 0 514)" gradientUnits="userSpaceOnUse"><stop offset="0" style="stop-color:#737373"></stop><stop offset="1" style="stop-color:#333"></stop></linearGradient><path d="M466.5 456.4c0 5.5-2.7 10.3-6.9 13.2l34.2 18.4c6.8-9.5 10.8-21.2 10.9-33.8L466.5 434v12.8" style="fill:url(#opnsense-v1_svg__d)"></path><linearGradient id="opnsense-v1_svg__e" x1="2521.902" x2="2684.464" y1="-2476.233" y2="-2476.233" gradientTransform="matrix(-1.508 -1.0166 -3.1265 -1.519 -3697.438 -937.952)" gradientUnits="userSpaceOnUse"><stop offset=".107" style="stop-color:#58595b"></stop><stop offset="1" style="stop-color:#000"></stop></linearGradient><path d="M192.5 197v-.4l-72.4-38.9H45.9v.2l72.5 39.1z" style="fill:url(#opnsense-v1_svg__e)"></path><linearGradient id="opnsense-v1_svg__f" x1="-1594.953" x2="-1432.391" y1="278.458" y2="278.458" gradientTransform="matrix(1.508 -1.0166 3.1265 -1.519 1804.196 -937.952)" gradientUnits="userSpaceOnUse"><stop offset=".107" style="stop-color:#58595b"></stop><stop offset="1" style="stop-color:#000"></stop></linearGradient><path d="M466.1 157.7h-74l-72.6 39.1v.2h74.2l72.4-38.9z" style="fill:url(#opnsense-v1_svg__f)"></path><linearGradient id="opnsense-v1_svg__g" x1="-4327.142" x2="-4164.581" y1="1572.387" y2="1572.387" gradientTransform="matrix(1.508 1.0166 3.1265 1.519 1863.938 2252.352)" gradientUnits="userSpaceOnUse"><stop offset=".107" style="stop-color:#58595b"></stop><stop offset="1" style="stop-color:#000"></stop></linearGradient><path d="M466.1 354.7v-.4l-72.4-38.9h-74.2v.2l72.6 39.1z" style="fill:url(#opnsense-v1_svg__g)"></path><linearGradient id="opnsense-v1_svg__h" x1="-413.668" x2="-246.99" y1="-1046.618" y2="-1046.618" gradientTransform="matrix(-1.508 1.0166 -3.1265 1.519 -3638.692 2252.352)" gradientUnits="userSpaceOnUse"><stop offset=".107" style="stop-color:#58595b"></stop><stop offset="1" style="stop-color:#000"></stop></linearGradient><path d="M192.5 315.4h-74.1l-72.5 39.1v.2h74.2l72.4-38.9z" style="fill:url(#opnsense-v1_svg__h)"></path><linearGradient id="opnsense-v1_svg__i" x1="74.725" x2="261.062" y1="132.65" y2="132.65" gradientTransform="matrix(.9914 0 0 -1 -66.782 260.2)" gradientUnits="userSpaceOnUse"><stop offset=".237" style="stop-color:#a6a8ab"></stop><stop offset="1" style="stop-color:#404040"></stop></linearGradient><path d="M192.8 157.7V197L7.3 97.4V58.1z" style="fill:url(#opnsense-v1_svg__i)"></path><linearGradient id="opnsense-v1_svg__j" x1="-2461.056" x2="-2274.718" y1="132.65" y2="132.65" gradientTransform="matrix(-.9914 0 0 -1 -1935.19 260.2)" gradientUnits="userSpaceOnUse"><stop offset=".237" style="stop-color:#a6a8ab"></stop><stop offset="1" style="stop-color:#404040"></stop></linearGradient><path d="M319.2 157.7V197l185.5-99.6V58.1z" style="fill:url(#opnsense-v1_svg__j)"></path><linearGradient id="opnsense-v1_svg__k" x1="-2291.845" x2="-2105.508" y1="-739.55" y2="-739.55" gradientTransform="matrix(-.9914 0 0 1 -1767.435 1124.6)" gradientUnits="userSpaceOnUse"><stop offset=".237" style="stop-color:#a6a8ab"></stop><stop offset="1" style="stop-color:#404040"></stop></linearGradient><path d="M319.2 355.2v-39.8L504.7 415v39.7z" style="fill:url(#opnsense-v1_svg__k)"></path><linearGradient id="opnsense-v1_svg__l" x1="-94.103" x2="91.934" y1="-739.55" y2="-739.55" gradientTransform="matrix(.9914 0 0 1 100.993 1124.6)" gradientUnits="userSpaceOnUse"><stop offset=".237" style="stop-color:#a6a8ab"></stop><stop offset="1" style="stop-color:#404040"></stop></linearGradient><path d="M192.8 355.2v-39.8L7.3 415v39.7z" style="fill:url(#opnsense-v1_svg__l)"></path><path d="m319.2 276.1 108.9 58.5v-39.7l-35.3-18.8h111.9v-39.8H392.8l35.3-18.8v-39.3l-108.9 58.1zM83.8 334.6l109-58.5v-39.8l-109-58.1v39.3l35.7 18.8H7.3v39.8h111.9l-35.3 18.8v39.7z" style="fill:#e24525"></path></svg></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">OPNSENSE GUEST</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="phone" transform="translate(3312.857751572178,502.58220111114224)" style="cursor: grab;"><circle r="181.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-54.45" y="-121" width="108.9" height="242" rx="8"></rect><rect x="-45.980000000000004" y="-102.85" width="91.96000000000001" height="193.60000000000002" rx="4" style="fill: rgb(30, 41, 59);"></rect><rect x="-18.15" y="99.22" width="36.3" height="7.26" rx="2" style="fill: rgb(71, 85, 105);"></rect></g><text class="node-label" x="0" y="-33.88" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Phone</text><text class="node-sub" x="0" y="48.400000000000006" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="desktop" transform="translate(2971.700036728428,480.7287465212985)" style="cursor: grab;"><circle r="220.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-132.3" y="-117.60000000000001" width="264.6" height="176.4" rx="4"></rect><rect x="-110.25" y="-95.55" width="220.5" height="132.3" rx="2" style="fill: rgb(30, 41, 59);"></rect><rect x="-22.05" y="58.800000000000004" width="44.1" height="44.1"></rect><rect x="-73.5" y="102.89999999999999" width="147" height="22.05" rx="2"></rect></g><text class="node-label" x="0" y="-41.160000000000004" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Desktop</text><text class="node-sub" x="0" y="58.800000000000004" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="dns" transform="translate(3200.4643189549906,320.469591247861)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><path d="
             M -44 11
             Q -60.50000000000001 11 -60.50000000000001 -5.5
             Q -60.50000000000001 -27.5 -38.5 -27.5
             Q -38.5 -49.5 -11 -49.5
             Q 5.5 -60.50000000000001 27.5 -44
             Q 55 -44 60.50000000000001 -16.5
             Q 71.5 -5.5 60.50000000000001 11
             Q 60.50000000000001 27.5 38.5 27.5
             L -27.5 27.5
             Q -49.5 27.5 -49.5 11
             Z
            " class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"></path><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">DNS</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="racked" transform="translate(2645.5845448279656,970.7820678889219)" style="cursor: grab;"><circle r="205.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" id="mdi-server-security" viewBox="0 0 24 24" width="164.4" height="164.4" x="-82.2" y="-82.2" style="fill: rgb(1, 8, 19); stroke: rgb(255, 255, 255);"><path d="M3,1H19A1,1 0 0,1 20,2V6A1,1 0 0,1 19,7H3A1,1 0 0,1 2,6V2A1,1 0 0,1 3,1M3,9H19A1,1 0 0,1 20,10V10.67L17.5,9.56L11,12.44V15H3A1,1 0 0,1 2,14V10A1,1 0 0,1 3,9M3,17H11C11.06,19.25 12,21.4 13.46,23H3A1,1 0 0,1 2,22V18A1,1 0 0,1 3,17M8,5H9V3H8V5M8,13H9V11H8V13M8,21H9V19H8V21M4,3V5H6V3H4M4,11V13H6V11H4M4,19V21H6V19H4M17.5,12L22,14V17C22,19.78 20.08,22.37 17.5,23C14.92,22.37 13,19.78 13,17V14L17.5,12M17.5,13.94L15,15.06V17.72C15,19.26 16.07,20.7 17.5,21.06V13.94Z" style="fill: rgb(1, 8, 19); stroke: rgb(255, 255, 255);"></path></svg></g><text class="node-label" x="0" y="-38.36000000000001" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Racked</text><text class="node-sub" x="0" y="54.800000000000004" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;"></text></g><g class="text-group" data-text-id="text-1765238422602"><text class="text-element" x="2466.35986328125" y="741.6801147460938" dominant-baseline="middle" style="fill: rgb(226, 232, 240); font-size: 40px; font-weight: normal; font-style: normal; text-anchor: start; text-decoration: none; opacity: 1; cursor: move; user-select: none;"><tspan x="2466.35986328125" dy="0">Double click on desktop</tspan><tspan x="2466.35986328125" dy="48">or long press on mobile</tspan><tspan x="2466.35986328125" dy="48">to enter rack canvas view</tspan></text><g class="text-delete-btn" style="cursor: pointer; display: none;"><circle cx="2486.35986328125" cy="701.6801147460938" r="12" style="fill: rgb(245, 101, 101); stroke: white; stroke-width: 2;"></circle><text x="2486.35986328125" y="701.6801147460938" text-anchor="middle" dominant-baseline="middle" style="fill: white; font-size: 16px; font-weight: bold; pointer-events: none;">√ó</text></g></g></svg>
        </div>
        <div class="minimap-zoom-wrapper" id="minimap-zoom-wrapper" style="display: block;">
          <button type="button" class="minimap-close-btn" id="minimap-close-btn" title="Hide map &amp; zoom">‚úï</button>
          <div class="minimap-container" id="minimap-container">
            <svg id="minimap" viewBox="0 0 4000 3000">
              <line x1="2103.968290880771" y1="268" x2="2066.9677515897347" y2="473.4119134177565" class="minimap-edge"></line><line x1="2066.9677515897347" y1="473.4119134177565" x2="1773.8400660428597" y2="666.5758233298659" class="minimap-edge"></line><line x1="2066.9677515897347" y1="473.4119134177565" x2="1931.1978950081452" y2="782.2775961320921" class="minimap-edge"></line><line x1="2066.9677515897347" y1="473.4119134177565" x2="2158.1262397347077" y2="767.7122274797483" class="minimap-edge"></line><line x1="2066.9677515897347" y1="473.4119134177565" x2="2342.2663764534577" y2="631.7681967180296" class="minimap-edge"></line><line x1="2103.968290880771" y1="268" x2="2757.879480087803" y2="307.6117116091891" class="minimap-edge"></line><line x1="2757.879480087803" y1="307.6117116091891" x2="3200.4643189549906" y2="320.469591247861" class="minimap-edge"></line><line x1="3200.4643189549906" y1="320.469591247861" x2="2971.700036728428" y2="480.7287465212985" class="minimap-edge"></line><line x1="3312.857751572178" y1="502.58220111114224" x2="3200.4643189549906" y2="320.469591247861" class="minimap-edge"></line><circle cx="2103.968290880771" cy="268" r="40" class="minimap-node"></circle><circle cx="2066.9677515897347" cy="473.4119134177565" r="40" class="minimap-node"></circle><circle cx="1773.8400660428597" cy="666.5758233298659" r="40" class="minimap-node"></circle><circle cx="1931.1978950081452" cy="782.2775961320921" r="40" class="minimap-node"></circle><circle cx="2158.1262397347077" cy="767.7122274797483" r="40" class="minimap-node"></circle><circle cx="2342.2663764534577" cy="631.7681967180296" r="40" class="minimap-node"></circle><circle cx="2757.879480087803" cy="307.6117116091891" r="40" class="minimap-node"></circle><circle cx="3312.857751572178" cy="502.58220111114224" r="40" class="minimap-node"></circle><circle cx="2971.700036728428" cy="480.7287465212985" r="40" class="minimap-node"></circle><circle cx="3200.4643189549906" cy="320.469591247861" r="40" class="minimap-node"></circle><circle cx="2645.5845448279656" cy="970.7820678889219" r="40" class="minimap-node"></circle><rect class="minimap-viewport" id="minimap-viewport" x="1254.5197896196048" y="-147.55422459755366" width="2648.185035176588" height="1986.138776382441"></rect>
            </svg>
          </div>
          <div class="zoom-toolbar" id="zoom-toolbar">
            <button id="zoom-in-btn" title="Zoom in">+</button>
            <div class="zoom-level" id="zoom-level">151%</div>
            <button id="zoom-out-btn" title="Zoom out">-</button>
            <div class="divider"></div>
            <button id="zoom-fit-btn" title="Fit to view">[ ]</button>
            <button id="zoom-reset-btn" title="Reset view">R</button>
          </div>
        </div>
        <button type="button" id="edge-legend-mini" class="legend-mini-btn" style="bottom: 10px; display: none;">Line Legend</button>
        <button type="button" id="minimap-mini" class="legend-mini-btn" style="right: 10px; left: auto; bottom: 10px; display: none;">Map</button>
        <button type="button" id="draw-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: 10px; right: auto; display: none;">Draw</button>
        <button type="button" id="topology-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: auto; right: 40px; display: none;">Add Line</button>
     </section>
      <aside class="details-panel" id="details-panel">
        <div class="sidebar-resizer" id="sidebar-resizer">
          <svg class="resizer-icon" width="6" height="40" viewBox="0 0 6 40" xmlns="http://www.w3.org/2000/svg">
            <circle cx="3" cy="14" r="2"></circle>
            <circle cx="3" cy="20" r="2"></circle>
            <circle cx="3" cy="26" r="2"></circle>
          </svg>
        </div>
        <div class="mobile-footer-resizer" id="mobile-footer-resizer">
          <svg class="resizer-icon" width="40" height="6" viewBox="0 0 40 6" xmlns="http://www.w3.org/2000/svg">
            <circle cx="14" cy="3" r="2"></circle>
            <circle cx="20" cy="3" r="2"></circle>
            <circle cx="26" cy="3" r="2"></circle>
          </svg>
        </div>
        <div id="node-panel" style="display: none;">
          <div class="details-name editable-text" id="node-name">Core Router 1</div>
          <div class="details-ip editable-text" id="node-ip">10.0.0.1</div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">MAC:</span>
            <span class="editable-text" id="node-mac" style="flex: 1; cursor: pointer; color: var(--text-main);">00:1A:2B:3C:4D:01</span>
          </div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">Rack Unit:</span>
            <span class="editable-text" id="node-rack" style="flex: 1; cursor: pointer; color: var(--text-main);">--</span>
          </div>
          <div class="details-info-row" id="uheight-row" style="display: none;">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">U Height:</span>
            <span class="editable-text" id="node-uheight" style="flex: 1; cursor: pointer; color: var(--text-main);">2U</span>
          </div>
          <div class="details-info-row" id="assigned-rack-row" style="display: flex;">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">Assigned Rack:</span>
            <select id="node-assigned-rack" style="flex: 1; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;"><option value="">None</option><option value="dc-rack-a1">DC Rack A1</option><option value="dc-rack-a2">DC Rack A2</option><option value="dc-rack-b1">DC Rack B1</option><option value="dc-rack-b2">DC Rack B2</option><option value="dmz-rack">DMZ Rack</option><option value="mgmt-rack">Management Rack</option></select>
          </div>
          <div class="details-info-row" id="rack-capacity-row" style="display: none;">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">Rack Capacity:</span>
            <select id="node-rack-capacity" style="flex: 1; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;">
              <option value="42">42U</option>
              <option value="48">48U</option>
              <option value="24">24U</option>
              <option value="12">12U</option>
              <option value="6">6U</option>
            </select>
          </div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">Layer:</span>
            <select id="node-layer" style="flex: 1; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;">
              <option value="physical">Physical</option>
              <option value="logical">Logical</option>
              <option value="security">Security</option>
              <option value="application">Application</option>
            </select>
          </div>
          <div class="details-role" id="node-role">Core Routing</div>
		  <details id="rack-contents-section" style="display: none; margin-top: 12px; margin-bottom: 12px; padding: 10px; background: var(--panel-alt); border-radius: 6px;" open="">
            <summary style="color: var(--accent); font-weight: 600; font-size: 14px; cursor: pointer;">Nodes in Rack (<span id="rack-contents-count">0</span>)</summary>
            <div id="rack-contents-list" style="max-height: 200px; overflow-y: auto; margin-top: 8px;"></div>
          </details>
          <div class="badge-row" id="node-tags"><span class="badge" style="cursor: pointer; position: relative;"><span>core</span><span style="opacity: 0.6; margin-left: 4px; font-size: 10px;"> ‚úï</span></span><span class="badge" style="cursor: pointer; position: relative;"><span>tier-1</span><span style="opacity: 0.6; margin-left: 4px; font-size: 10px;"> ‚úï</span></span><span class="badge" style="cursor: pointer; position: relative;"><span>redundant</span><span style="opacity: 0.6; margin-left: 4px; font-size: 10px;"> ‚úï</span></span><span class="badge" style="cursor: pointer; opacity: 0.6; border-style: dashed;">+ Add Tag</span></div>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-tag-input" placeholder="Add tag..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-tag-btn" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button class="pick-icon-btn" id="pick-tag-icon-btn">Add Icon Tag</button>
          <div class="section-label">Size</div>
          <div class="size-controls">
            <label>Size:</label>
            <input type="range" id="size-slider" min="20" max="200" value="55">
            <span id="size-value">55</span>
            <button id="reset-size">Reset</button>
          </div>
          <details class="style-section">
            <summary>Styling</summary>
            <div class="style-content">
              <div class="style-row">
                <label>Screen:</label>
                <select id="style-scope">
                  <option value="all">All</option>
                  <option value="desktop">Desktop</option>
                  <option value="tablet">Tablet</option>
                  <option value="mobile">Mobile</option>
                  <option value="fold">Fold</option>
                </select>
              </div>
              <div class="style-row">
                <label>Shape:</label>
                <select id="shape-select"><option value="custom-icon">Custom Icon</option>
                  <optgroup label="Basic Shapes">
            <option value="circle">Circle</option>
            <option value="square">Square</option>
            <option value="rectangle">Rectangle</option>
            <option value="triangle">Triangle</option>
            <option value="hexagon">Hexagon</option>
            <option value="diamond">Diamond</option>
            <option value="star">Star</option>
            <option value="stop-sign">Stop Sign</option>
            <option value="octagon">Octagon</option>
            <option value="pentagon">Pentagon</option>
            <option value="cross">Cross</option>
            <option value="rounded-square">Rounded Square</option>
            <option value="pill">Pill</option>
            <option value="parallelogram">Parallelogram</option>
            <option value="trapezoid">Trapezoid</option>
          </optgroup>
          <optgroup label="Computers &amp; Devices">
            <option value="server">Server</option>
            <option value="pc">PC / Desktop</option>
            <option value="laptop">Laptop</option>
            <option value="phone">Phone / Mobile</option>
            <option value="printer">Printer</option>
            <option value="pi">Raspberry Pi</option>
            <option value="sensor">Sensor / IoT</option>
          </optgroup>
          <optgroup label="Network Equipment">
            <option value="router">Router</option>
            <option value="switch">Switch</option>
            <option value="firewall">Firewall</option>
            <option value="access-point">Access Point</option>
            <option value="load-balancer">Load Balancer</option>
            <option value="gateway">Gateway</option>
            <option value="vpn">VPN / Tunnel</option>
            <option value="nas">NAS / Storage</option>
          </optgroup>
          <optgroup label="Cloud &amp; Services">
            <option value="cloud">Cloud</option>
            <option value="database">Database</option>
			<option value="docker">Docker</option>
            <option value="container">Container</option>
            <option value="vm">Virtual Machine</option>
            <option value="kubernetes">Kubernetes</option>
            <option value="api">API / Endpoint</option>
            <option value="queue">Queue / Message</option>
            <option value="lambda">Lambda / Function</option>
            <option value="bucket">Bucket / S3</option>
          </optgroup>
          <optgroup label="Security &amp; Monitoring">
            <option value="shield">Shield</option>
            <option value="camera">Camera / CCTV</option>
            <option value="monitor">Monitor / Dashboard</option>
          </optgroup>
                </select>
              </div>
              <button class="pick-icon-btn" id="pick-shape-icon-btn">Or Search Web Icons</button>
              <div class="style-row">
                <label>Fill Color:</label>
                <input type="color" id="circle-color" value="#1e293b">
              </div>
              <div class="style-row">
                <label>Border Color:</label>
                <input type="color" id="circle-border" value="#475569">
              </div>
              <div class="style-row">
                <label>Title Color:</label>
                <input type="color" id="title-color" value="#e2e8f0">
              </div>
              <div class="style-row">
                <label>Title Font:</label>
                <select id="title-font">
                  <option value="system-ui, sans-serif">System UI</option>
                  <option value="monospace">Monospace</option>
                  <option value="serif">Serif</option>
                  <option value="cursive">Cursive</option>
                  <option value="'Courier New', monospace">Courier</option>
                  <option value="Arial, sans-serif">Arial</option>
                  <option value="'Times New Roman', serif">Times</option>
                </select>
              </div>
              <div class="style-row">
                <label>Title Size:</label>
                <input type="number" id="title-size" min="8" max="100" value="18">
              </div>
              <div class="style-row">
                <label>Sub Color:</label>
                <input type="color" id="sub-color" value="#94a3b8">
              </div>
              <div class="style-row">
                <label>Sub Font:</label>
                <select id="sub-font">
                  <option value="system-ui, sans-serif">System UI</option>
                  <option value="monospace">Monospace</option>
                  <option value="serif">Serif</option>
                  <option value="cursive">Cursive</option>
                  <option value="'Courier New', monospace">Courier</option>
                  <option value="Arial, sans-serif">Arial</option>
                  <option value="'Times New Roman', serif">Times</option>
                </select>
              </div>
              <div class="style-row">
                <label>Sub Size:</label>
                <input type="number" id="sub-size" min="6" max="80" value="13">
              </div>
              <div style="
                margin-top: 12px;
                padding-top: 10px;
                border-top: 1px solid var(--edge-main);
                ">
                <div style="font-size: 12px;color: var(--text-soft);margin-bottom: 8px;text-transform: uppercase;">Text Position</div>
                <div class="style-row">
                  <label>Name Y:</label>
                  <input type="number" id="title-offset-y" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>Name X:</label>
                  <input type="number" id="title-offset-x" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>IP Y:</label>
                  <input type="number" id="sub-offset-y" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>IP X:</label>
                  <input type="number" id="sub-offset-x" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div style="margin-top: 16px; font-size: 12px; color: var(--text-soft); text-transform: uppercase;">
                  Ping Indicator Position
                </div>
                <div class="style-row">
                  <label>Ping X:</label>
                  <input type="number" id="ping-offset-x" min="-200" max="200" value="0" style="width: 60px;">
                </div>
                <div class="style-row">
                  <label>Ping Y:</label>
                  <input type="number" id="ping-offset-y" min="-200" max="200" value="0" style="width: 60px;">
                </div>
              </div>
              <button id="reset-styles" style="width: 100%;margin-top: 10px;padding: 8px;background: var(--panel);color: var(--text-main);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: clamp(13px, 1.5vw, 17px);">Reset Styles</button>
            </div>
          </details>
          <details class="style-section">
            <summary>Ping / Status Monitoring</summary>
            <div class="style-content">
              <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px; cursor: pointer;">
              <input type="checkbox" id="node-pingable" style="cursor: pointer;">
              <span style="font-size: 14px;">Enable status check for this node</span>
              </label>
              <div id="node-ping-options" style="display: none;">
                <div class="style-row">
                  <label>Protocol:</label>
                  <select id="node-ping-protocol">
                    <option value="http">HTTP (port 80)</option>
                    <option value="https">HTTPS (port 443)</option>
                    <option value="custom">Custom URL</option>
                  </select>
                </div>
                <div id="node-custom-url-container" style="display: block; margin-top: 8px;">
                  <label style="display: block; margin-bottom: 4px; font-size: 13px;">Custom URL:</label>
                  <input type="text" id="node-custom-url" placeholder="e.g. http://192.168.1.1:8080" style="width: 100%;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: 14px;">
                </div>
                <div class="style-row" style="margin-top: 8px;">
                  <label>Timeout (ms):</label>
                  <input type="number" id="node-ping-timeout" value="3000" min="1000" max="10000" step="500" style="width: 100px;">
                </div>
                <div style="margin-top: 12px; padding: 10px; background: var(--panel); border-radius: 6px; border: 1px solid var(--edge-main);">
                  <div style="font-size: 12px; color: var(--text-soft); margin-bottom: 8px;">Current Status:</div>
                  <div id="node-ping-status" style="font-size: 14px; font-weight: 600; color: var(--accent);">‚óè Online</div>
                  <div id="node-ping-last-check" style="font-size: 11px; color: var(--text-soft); margin-top: 4px;">Last checked: 2:25:19 PM</div>
                </div>
                <button id="check-ping-now" style="width: 100%;margin-top: 10px;padding: 8px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Check Status Now</button>
              </div>
            </div>
          </details>
          <div class="section-label">Notes</div>
          <ul class="list" id="node-notes"><li><span style="flex: 1 1 0%;">Primary core router</span><span class="delete-note">‚úï</span></li><li><span style="flex: 1 1 0%;">BGP peering enabled</span><span class="delete-note">‚úï</span></li></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-note-input" placeholder="Type new note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-note-btn" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-node-btn" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: rgb(255, 255, 255);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;width: 100%;">Delete Node</button>
        </div>
        <div id="edge-panel" style="display: none">
          <div class="details-name" id="edge-title">Custom line</div>
          <div class="style-row" style="margin-top: 10px">
            <label>Width:</label>
            <input type="number" id="edge-width" min="1" max="20" value="4">
          </div>
          <div class="style-row">
            <label>Color:</label>
            <input type="color" id="edge-color" value="#475569">
          </div>
          <div class="style-row">
            <label>Line Style:</label>
            <select id="edge-line-style">
              <option value="solid">Solid</option>
              <option value="dashed">Dashed</option>
              <option value="dotted">Dotted</option>
            </select>
          </div>
          <div class="style-row">
            <label>Direction:</label>
            <select id="edge-direction">
              <option value="none">No arrows</option>
              <option value="forward">‚Üí Forward</option>
              <option value="backward">‚Üê Backward</option>
              <option value="both">‚Üî Bidirectional</option>
            </select>
          </div>
          <div class="style-row" id="edge-port-fields">
            <label>From Port:</label>
            <input type="text" id="edge-from-port" placeholder="e.g. eth0, gi0/1" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);font-size: 14px;">
          </div>
          <div class="style-row" id="edge-port-fields-to">
            <label>To Port:</label>
            <input type="text" id="edge-to-port" placeholder="e.g. eth1, gi0/2" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);font-size: 14px;">
          </div>
          <div class="section-label">Line Notes</div>
          <ul class="list" id="edge-notes"></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-edge-note" placeholder="Add note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-edge-note" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-edge" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Delete Line</button>
        </div>
        <div id="rect-panel" style="display: none">
          <div class="details-name" id="rect-title">Zone</div>
          <div class="style-row" id="rect-fill-row" style="margin-top: 10px">
            <label>Fill Color:</label>
            <input type="color" id="rect-color" value="#f97316">
          </div>
          <div class="style-row">
            <label>Border Color:</label>
            <input type="color" id="rect-border-color" value="#f97316">
          </div>
          <div class="style-row">
            <label>Border Width:</label>
            <input type="number" id="rect-border-width" min="0" max="20" value="2">
          </div>
          <div class="style-row">
            <label>Style:</label>
            <select id="rect-style-select">
              <option value="filled">Filled</option>
              <option value="outlined">Outlined</option>
            </select>
          </div>
		  <div class="style-row">
            <label>Line Style:</label>
            <select id="rect-line-style">
              <option value="solid">Solid</option>
              <option value="dashed">Dashed</option>
              <option value="dotted">Dotted</option>
            </select>
          </div>
          <div class="section-label">Zone Notes</div>
          <ul class="list" id="rect-notes"></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-rect-note" placeholder="Add note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-rect-note" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-rect" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Delete Zone</button>
        </div>
        <div id="text-panel" style="display: none">
          <div class="details-name" id="text-title">Text Element</div>
          <div class="style-row" style="margin-top: 10px">
            <label>Content:</label>
            <textarea id="text-content" placeholder="Enter text..." style="width: 100%;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: 14px;min-height: 80px;resize: vertical;font-family: inherit;"></textarea>
          </div>
          <div class="style-row">
            <label>Font Size:</label>
            <input type="number" id="text-font-size" min="8" max="200" value="18" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);">
          </div>
          <div class="style-row">
            <label>Color:</label>
            <input type="color" id="text-color" value="#e2e8f0">
          </div>
          <div class="style-row">
            <label>Font Weight:</label>
            <select id="text-font-weight" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="normal">Normal</option>
              <option value="bold">Bold</option>
              <option value="600">Semi-Bold</option>
              <option value="300">Light</option>
            </select>
          </div>
          <div class="style-row">
            <label>Font Style:</label>
            <select id="text-font-style" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="normal">Normal</option>
              <option value="italic">Italic</option>
            </select>
          </div>
          <div class="style-row">
            <label>Text Align:</label>
            <select id="text-align" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="start">Left</option>
              <option value="middle">Center</option>
              <option value="end">Right</option>
            </select>
          </div>
          <div class="style-row">
            <label>Text Decoration:</label>
            <select id="text-decoration" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="none">None</option>
              <option value="underline">Underline</option>
              <option value="line-through">Strike Through</option>
            </select>
          </div>
          <div class="style-row">
            <label>Background:</label>
            <input type="color" id="text-bg-color" value="#000000">
            <label style="margin-left: 10px; display: flex; align-items: center; gap: 6px;">
            <input type="checkbox" id="text-bg-enabled" style="cursor: pointer;">
            <span style="font-size: 13px;">Enable</span>
            </label>
          </div>
          <div class="style-row">
            <label>Opacity:</label>
            <input type="range" id="text-opacity" min="0" max="1" step="0.1" value="1" style="flex: 1">
            <span id="text-opacity-val" style="min-width: 35px; text-align: right">100%</span>
          </div>
          <button id="delete-text" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;width: 100%;">Delete Text</button>
        </div>
     <details class="style-section">
          <summary>Page Layout</summary>
          <div class="style-content">
            <div style="padding: 12px; background: var(--panel-alt); border-radius: 6px; color: var(--text-soft); font-size: 13px; line-height: 1.6;">
              <strong style="color: var(--accent); display: block; margin-bottom: 8px;">Drag to Resize:</strong>
              ‚Ä¢ <strong>Header:</strong> Drag the bottom edge of the header bar<br>
              ‚Ä¢ <strong>Sidebar:</strong> Drag the left edge of the sidebar panel<br>
              ‚Ä¢ <strong>Mobile:</strong> Drag the top edge of the footer panel<br>
              <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--edge-main); font-size: 12px;">
                Hover over panel edges to see resize handles
              </div>
            </div>
          </div>
        </details>
      </aside>
    </main>
    <script id="nodes-json" type="application/json">{}</script>
    <script id="topology-state" type="application/json">ENCRYPTED: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</script>
    <script>
	Object.keys(localStorage).forEach(key => {
       if (key.startsWith('icon-selfhst-')) {
        const val = localStorage.getItem(key);
        if (val && val.includes('<image href=')) {
         localStorage.removeItem(key);
        }
       }
      });
      const IconLibrary = {
       libraries: {
        mdi: {
         name: 'Material Design Icons',
         cdnBase: 'https://cdn.jsdelivr.net/npm/@mdi/svg@latest/svg/',
         metaUrl: 'https://cdn.jsdelivr.net/npm/@mdi/svg@latest/meta.json',
         icons: []
        },
        simple: {
         name: 'Simple Icons',
         cdnBase: 'https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/',
         indexUrl: 'https://cdn.jsdelivr.net/npm/@iconify-json/simple-icons@latest/icons.json',
         icons: []
        },
        selfhst: {
         name: 'selfh.st/icons',
         cdnBase: 'https://cdn.jsdelivr.net/gh/selfhst/icons@master/svg/',
         indexUrl: 'https://raw.githubusercontent.com/selfhst/icons/refs/heads/main/index.json',
         icons: []
        }
       },
       currentLibrary: 'selfhst',
       iconCache: {},
       indexCache: {},
       indexLoading: {},
       async loadLibraryIndex(library) {
        if (this.indexCache[library]) {
         return this.indexCache[library];
        }
        if (this.indexLoading[library]) {
         return this.indexLoading[library];
        }
        const lib = this.libraries[library];
        this.indexLoading[library] = (async () => {
         try {
          if (library === 'selfhst') {
           const response = await fetch(lib.indexUrl);
           const data = await response.json();
           const icons = data.filter(item => item.SVG === "Yes").map(item => ({
            name: item.Reference,
            displayName: item.Name,
            tags: item.Tags ? item.Tags.split(',').map(t => t.trim()).filter(t => t) : [],
            category: item.Category
           }));
           this.indexCache[library] = icons;
           lib.icons = icons;
           return icons;
          } else if (library === 'simple') {
           const response = await fetch('https://cdn.jsdelivr.net/npm/@iconify-json/simple-icons@latest/icons.json');
           const data = await response.json();
           const icons = Object.keys(data.icons).map(slug => ({
            name: slug,
            displayName: data.icons[slug].title || slug,
            tags: data.aliases && data.aliases[slug] ? [data.aliases[slug].parent] : [],
            hex: data.icons[slug].hex
           }));
           this.indexCache[library] = icons;
           lib.icons = icons;
           return icons;
          } else if (library === 'mdi') {
           const response = await fetch(lib.metaUrl);
           const data = await response.json();
           const icons = data.map(item => ({
            name: item.name,
            displayName: item.name,
            tags: item.tags || [],
            author: item.author
           }));
           this.indexCache[library] = icons;
           lib.icons = icons;
           return icons;
          }
         } catch (error) {
          console.error(`Failed to load index for ${library}:`, error);
          this.indexCache[library] = [];
          lib.icons = [];
          return [];
         } finally {
          delete this.indexLoading[library];
         }
        })();
        return this.indexLoading[library];
       },
       async getIcon(library, name) {
        const cacheKey = `${library}-${name}`;
        if (this.iconCache[cacheKey]) {
         return this.iconCache[cacheKey];
        }
        const cached = localStorage.getItem(`icon-${cacheKey}`);
        if (cached) {
         this.iconCache[cacheKey] = cached;
         return cached;
        }
        const lib = this.libraries[library];
        const url = `${lib.cdnBase}${name}.svg`;
        try {
         const response = await fetch(url);
         if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
         }
         const svg = await response.text();
         this.iconCache[cacheKey] = svg;
         localStorage.setItem(`icon-${cacheKey}`, svg);
         return svg;
        } catch (error) {
         console.error(`Failed to fetch icon ${cacheKey}:`, error);
         return null;
        }
       },
       searchIcons(library, query) {
        const lib = this.libraries[library];
        if (!lib.icons.length) return [];
        const q = query.toLowerCase();
        return lib.icons.filter(icon => {
         const nameMatch = icon.name.toLowerCase().includes(q);
         const displayMatch = icon.displayName && icon.displayName.toLowerCase().includes(q);
         const tagMatch = icon.tags && icon.tags.some(t => t.toLowerCase().includes(q));
         const categoryMatch = icon.category && icon.category.toLowerCase().includes(q);
         return nameMatch || displayMatch || tagMatch || categoryMatch;
        }).slice(0, 50);
       }
      };
      let iconPickerCallback = null;
      let selectedNodeIconData = null;
      let selectedRackIconData = null;
      let newNodeIconTags = [];
      let freeDrawMode = false;
      async function checkNodeStatus(nodeId) {
       const data = NODE_DATA[nodeId];
       if (!data || !data.ping || !data.ping.enabled) return;
       data.ping.status = 'checking';
       data.ping.lastCheck = new Date().toISOString();
       updatePingIndicator(nodeId);
       if (currentNodeId === nodeId) {
        updatePingStatusDisplay(nodeId);
       }
       let url;
       if (data.ping.protocol === 'custom') {
        url = data.ping.customUrl;
       } else {
        const ip = data.ip || '0.0.0.0';
        const protocol = data.ping.protocol || 'http';
        url = `${protocol}://${ip}`;
       }
       if (!url) {
        data.ping.status = 'unknown';
        updatePingIndicator(nodeId);
        if (currentNodeId === nodeId) {
         updatePingStatusDisplay(nodeId);
        }
        return;
       }
       try {
        const controller = new AbortController();
        const timeout = data.ping.timeout || 3000;
        const timeoutId = setTimeout(() => controller.abort(), timeout);
        const response = await fetch(url, {
         method: 'HEAD',
         mode: 'no-cors',
         signal: controller.signal
        });
        clearTimeout(timeoutId);
        data.ping.status = 'online';
       } catch (error) {
        data.ping.status = 'offline';
       }
       data.ping.lastCheck = new Date().toISOString();
       updatePingIndicator(nodeId);
       if (currentNodeId === nodeId) {
        updatePingStatusDisplay(nodeId);
       }
      }
      function rgbaToHex(val) {
      if (!val) return "#000000";
      if (val.startsWith("#")) return val;
      const m = val.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
      if (!m) return "#000000";
      const r = Number(m[1]).toString(16).padStart(2, "0");
      const g = Number(m[2]).toString(16).padStart(2, "0");
      const b = Number(m[3]).toString(16).padStart(2, "0");
      return `#${r}${g}${b}`;
      }
      function updatePingIndicator(nodeId) {
      const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
      if (!nodeGroup) return;
      const data = NODE_DATA[nodeId];
      if (!data || !data.ping || !data.ping.enabled) {
       const existingIndicator = nodeGroup.querySelector('.ping-indicator');
       if (existingIndicator) existingIndicator.remove();
       return;
      }
      let indicator = nodeGroup.querySelector('.ping-indicator');
      const label = nodeGroup.querySelector('.node-label');
      if (!indicator && label) {
       indicator = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
       indicator.classList.add('ping-indicator');
       nodeGroup.appendChild(indicator);
      }
      if (indicator && label) {
       const size = savedSizes[nodeId] || getDefaultSize();
       const radius = Math.max(4, size * 0.06);
       indicator.setAttribute('r', radius);
       const labelBBox = label.getBBox();
       const labelX = parseFloat(label.getAttribute('x') || 0);
       const labelY = parseFloat(label.getAttribute('y') || 0);
       const styles = resolveStylesForNode(nodeId);
      const offX = styles.pingOffsetX || 0;
      const offY = styles.pingOffsetY || 0;
      indicator.setAttribute('cx', (labelX - labelBBox.width / 2 - radius * 1.1) + offX);
      indicator.setAttribute('cy', (labelY - radius * 0.7) + offY);
      }
      if (indicator) {
       indicator.classList.remove('online', 'offline', 'checking');
       if (data.ping.status) indicator.classList.add(data.ping.status);
      }
      }
      function checkAllNodesStatus() {
       Object.keys(NODE_DATA).forEach(nodeId => {
        const data = NODE_DATA[nodeId];
        if (data && data.ping && data.ping.enabled) {
         checkNodeStatus(nodeId);
        }
       });
      }
      function startAutoPing() {
       stopAutoPing();
       checkAllNodesStatus();
       updateAutoPingLastRun();
       autoPingSecondsRemaining = autoPingInterval;
       autoPingTimer = setInterval(() => {
        checkAllNodesStatus();
        updateAutoPingLastRun();
        autoPingSecondsRemaining = autoPingInterval;
       }, autoPingInterval * 1000);
       autoPingCountdown = setInterval(() => {
        autoPingSecondsRemaining--;
        updateAutoPingCountdown();
        if (autoPingSecondsRemaining <= 0) {
         autoPingSecondsRemaining = autoPingInterval;
        }
       }, 1000);
       updateAutoPingCountdown();
      }
      function stopAutoPing() {
       if (autoPingTimer) {
        clearInterval(autoPingTimer);
        autoPingTimer = null;
       }
       if (autoPingCountdown) {
        clearInterval(autoPingCountdown);
        autoPingCountdown = null;
       }
       autoPingSecondsRemaining = 0;
       updateAutoPingCountdown();
      }
      function updateAutoPingCountdown() {
       const nextCheckEl = document.getElementById('auto-ping-next-check');
       if (nextCheckEl) {
        if (autoPingSecondsRemaining > 0 && autoPingEnabled) {
         const mins = Math.floor(autoPingSecondsRemaining / 60);
         const secs = autoPingSecondsRemaining % 60;
         if (mins > 0) {
          nextCheckEl.textContent = `Next check in: ${mins}m ${secs}s`;
         } else {
          nextCheckEl.textContent = `Next check in: ${secs}s`;
         }
        } else {
         nextCheckEl.textContent = 'Next check in: --';
        }
       }
      }
      function updateAutoPingLastRun() {
       const lastRunEl = document.getElementById('auto-ping-last-run');
       if (lastRunEl) {
        const now = new Date();
        lastRunEl.textContent = `Last run: ${now.toLocaleTimeString()}`;
       }
      }
      function openIconPicker(callback) {
       iconPickerCallback = callback;
       const modal = document.getElementById('icon-picker-modal');
       modal.classList.add('active');
       const searchInput = document.getElementById('icon-search');
       searchInput.style.display = 'none';
       loadIconsForCurrentLibrary();
      }
      function closeIconPicker() {
       const modal = document.getElementById('icon-picker-modal');
       modal.classList.remove('active');
       iconPickerCallback = null;
      }
      async function loadIconsForCurrentLibrary() {
       const body = document.getElementById('icon-picker-body');
       const libNames = {
        mdi: 'MDI (Material Design Icons)',
        simple: 'Simple Icons',
        selfhst: 'selfh.st/icons'
       };
       body.innerHTML = `<div style="padding: 20px;"><p style="color: var(--text-soft); margin-bottom: 15px; text-align: center;">Search ${libNames[IconLibrary.currentLibrary]}:</p><input type="text" id="icon-search-field" placeholder="Search icons..." style="width: 100%; padding: 12px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main); font-size: 16px; margin-bottom: 20px;"><div id="icon-grid-container" style="max-height: 400px; overflow-y: auto;"><div style="text-align: center; color: var(--text-soft); padding: 40px;">Loading icons...</div></div></div>`;
       const searchField = document.getElementById('icon-search-field');
       const gridContainer = document.getElementById('icon-grid-container');
       await IconLibrary.loadLibraryIndex(IconLibrary.currentLibrary);
       const renderIcons = (icons) => {
        if (!icons || icons.length === 0) {
         gridContainer.innerHTML = '<div style="text-align: center; color: var(--text-soft); padding: 40px;">No icons found</div>';
         return;
        }
        const grid = document.createElement('div');
        grid.style.cssText = 'display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 15px; padding: 10px;';
        icons.forEach(icon => {
         const item = document.createElement('div');
         item.style.cssText = 'display: flex; flex-direction: column; align-items: center; gap: 8px; padding: 15px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; cursor: pointer; transition: all 0.2s;';
         item.onmouseover = () => {
          item.style.background = 'var(--panel)';
          item.style.borderColor = 'var(--accent)';
         };
         item.onmouseout = () => {
          item.style.background = 'var(--panel-alt)';
          item.style.borderColor = 'var(--edge-main)';
         };
         const iconPreview = document.createElement('div');
         iconPreview.style.cssText = 'width: 48px; height: 48px; display: flex; align-items: center; justify-content: center;';
         iconPreview.innerHTML = '<div style="color: var(--text-soft); font-size: 12px;">...</div>';
         IconLibrary.getIcon(IconLibrary.currentLibrary, icon.name).then(svg => {
          if (svg) {
           const parser = new DOMParser();
           const doc = parser.parseFromString(svg, 'image/svg+xml');
           const svgEl = doc.querySelector('svg');
           if (svgEl) {
            svgEl.setAttribute('width', '48');
            svgEl.setAttribute('height', '48');
            svgEl.style.fill = 'var(--text-main)';
            iconPreview.innerHTML = '';
            iconPreview.appendChild(svgEl);
           }
          }
         });
         const name = document.createElement('div');
         name.textContent = icon.displayName || icon.name;
         name.style.cssText = 'font-size: 11px; color: var(--text-soft); text-align: center; word-break: break-word; max-width: 100%;';
         item.appendChild(iconPreview);
         item.appendChild(name);
         item.addEventListener('click', async () => {
          const svg = await IconLibrary.getIcon(IconLibrary.currentLibrary, icon.name);
          if (iconPickerCallback && svg) {
           iconPickerCallback({
            library: IconLibrary.currentLibrary,
            name: icon.name,
            svg: svg
           });
          }
          closeIconPicker();
         });
         grid.appendChild(item);
        });
        gridContainer.innerHTML = '';
        gridContainer.appendChild(grid);
       };
       gridContainer.innerHTML = '<div style="text-align: center; color: var(--text-soft); padding: 40px;">Type to search icons</div>';
       let searchTimeout;
       searchField.addEventListener('input', (e) => {
        clearTimeout(searchTimeout);
        const query = e.target.value.trim();
        searchTimeout = setTimeout(() => {
         if (!query) {
          gridContainer.innerHTML = '<div style="text-align: center; color: var(--text-soft); padding: 40px;">Type to search icons</div>';
          return;
         }
         const results = IconLibrary.searchIcons(IconLibrary.currentLibrary, query);
         renderIcons(results);
        }, 300);
       });
       searchField.focus();
      }
      async function displayIcons(icons) {
       const body = document.getElementById('icon-picker-body');
       const grid = document.createElement('div');
       grid.className = 'icon-grid';
       for (const icon of icons) {
        const item = document.createElement('div');
        item.className = 'icon-item';
        const svg = await IconLibrary.getIcon(icon.library, icon.name);
        if (svg) {
         const parser = new DOMParser();
         const doc = parser.parseFromString(svg, 'image/svg+xml');
         const svgEl = doc.querySelector('svg');
         if (svgEl) {
          item.innerHTML = svgEl.outerHTML;
         }
        } else {
         item.innerHTML = '<svg width = "32" height = "32"><rect width = "32" height = "32" fill = "currentColor"/> </svg>';
        }
        const name = document.createElement('div');
        name.className = 'icon-item-name';
        name.textContent = icon.name;
        item.appendChild(name);
        item.addEventListener('click', () => {
         if (iconPickerCallback) {
          iconPickerCallback({
           library: icon.library,
           name: icon.name,
           svg: svg
          });
         }
         closeIconPicker();
        });
        grid.appendChild(item);
       }
       body.innerHTML = '';
       body.appendChild(grid);
      }
      window.addEventListener('DOMContentLoaded', () => {
       document.querySelectorAll('.icon-picker-tab').forEach(tab => {
        tab.addEventListener('click', () => {
         document.querySelectorAll('.icon-picker-tab').forEach(t => t.classList.remove('active'));
         tab.classList.add('active');
         IconLibrary.currentLibrary = tab.dataset.library;
         loadIconsForCurrentLibrary();
        });
       });
       document.getElementById('icon-picker-cancel').addEventListener('click', closeIconPicker);
       document.getElementById('icon-picker-modal').addEventListener('click', (e) => {
        if (e.target.id === 'icon-picker-modal') {
         closeIconPicker();
        }
       });
      });
      let textDrawMode = false;
      const BASE_NODE_DATA = JSON.parse(document.getElementById("nodes-json").textContent, );
      let currentNodeId = "host";
      let currentEdgeId = null;
      let currentStyleScope = "all";
      let NODE_DATA = {};
      let EDGE_DATA = {
       list: []
      };
      let currentRectId = null;
      let currentTextId = null;
      let rectDrawMode = false;
      let RECT_DATA = {
       list: []
      };
      let TEXT_DATA = {
       list: []
      };
      let EDGE_LEGEND = {};
      let savedPositions = {};
      let savedSizes = {};
      let savedStyles = {};
      let legendCollapsed = false;
      let minimapCollapsed = false;
      let drawToolbarCollapsed = false;
      let currentView = {
       mode: "topology",
       rackId: null
      };
      let savedTopologyView = null;
      let activeLayers = new Set(["physical", "logical", "security", "application"]);
      let topologyToolbarCollapsed = false;
      let legendMiniBtn = null;
      let minimapMiniBtn = null;
      let drawToolbarMiniBtn = null;
      let topologyToolbarMiniBtn = null;
      let autoPingEnabled = false;
      let autoPingInterval = 30;
      let autoPingTimer = null;
      let autoPingCountdown = null;
      let autoPingSecondsRemaining = 0;
      const ROLLBACK_STORAGE_KEY = "theonefile_rollback_history";
      let rollbackVersions = [];
      const MAX_ROLLBACK_VERSIONS = 50;
      let currentRollbackIndex = -1;
      const AUDIT_STORAGE_KEY = "theonefile_audit_log";
      let auditLog = [];
      const MAX_AUDIT_ENTRIES = 1000;
      let documentTabs = [{
        id: "main",
        name: "Main Topology",
        nodes: {},
        edges: { list: [] },
        positions: {},
        sizes: {},
        styles: {},
        legend: {},
        rects: { list: [] },
        texts: { list: [] },
      pageState: null
      }];
      let currentTabIndex = 0;
      let encryptedSections = {};
      let undoStack = [];
      let redoStack = [];
      const MAX_UNDO_STACK = 50;
      let selectedNodes = new Set();
      let selectedEdges = new Set();
      let selectedRects = new Set();
      let selectedTexts = new Set();
      let isSelecting = false;
      let selectionStart = null;
      let preDragSelectedNodes = new Set();
      let preDragSelectedEdges = new Set();
      let preDragSelectedRects = new Set();
      let preDragSelectedTexts = new Set();
      let selectionRect = null;
      let isDraggingSelection = false;
      let dragSelectionStart = null;
      let selectionBoxStyle = {
       fillColor: "#4fd1c5",
       fillOpacity: 0.1,
       strokeColor: "#4fd1c5",
       strokeWidth: 2,
       strokeDasharray: "5,5"
      };
      let clipboard = null;
      const MobileManager = {
        isMobile: false,
        detect() {
          if (navigator.userAgentData?.mobile === true) {
            this.isMobile = true;
            return true;
          }
          const coarse = matchMedia("(pointer: coarse)").matches;
          const width = window.innerWidth <= 900;
          const portrait = matchMedia("(orientation: portrait)").matches;
          this.isMobile = coarse && (width || portrait);
          return this.isMobile;
        },
        applyInitialCollapse() {
          if (!this.isMobile) return;
          legendCollapsed = true;
          minimapCollapsed = true;
          drawToolbarCollapsed = true;
          topologyToolbarCollapsed = true;
          if (typeof updateLegendVisibility === "function") updateLegendVisibility();
          if (typeof updateMinimapVisibility === "function") updateMinimapVisibility();
          if (typeof updateDrawToolbarVisibility === "function") updateDrawToolbarVisibility();
          if (typeof updateTopologyToolbarVisibility === "function") updateTopologyToolbarVisibility();
        },
        updateBulkToolbar() {
          const desktop = document.getElementById("bulk-toolbar");
          const mobile = document.getElementById("bulk-toolbar-mobile");
          if (!desktop || !mobile) return;
          if (typeof isViewOnly === 'function' && isViewOnly()) {
           desktop.style.display = "none";
           mobile.style.display = "none";
           return;
          }
          if (typeof selectedNodes === 'undefined' || selectedNodes.size === 0) {
           desktop.style.display = "none";
           mobile.style.display = "none";
           return;
          }
          const isVisible = desktop.style.display !== "none" || mobile.style.display !== "none";
          if (this.isMobile) {
            desktop.style.display = "none";
            if (isVisible) {
              mobile.style.display = "flex";
            }
          } else {
            mobile.style.display = "none";
            if (isVisible) {
              desktop.style.display = "flex";
            }
          }
        },
        updateLayout() {
          const main = document.querySelector("main");
          if (!main) return;
        },
        updateCanvasHint() {
      const hint = document.getElementById("canvas-hint");
      if (!hint) return;
      if (PAGE_STATE.canvasHintText !== undefined && PAGE_STATE.canvasHintText !== "") {
        hint.innerHTML = PAGE_STATE.canvasHintText;
        return;
      }
      const items = this.isMobile
      ? [
        "Pinch to zoom",
        "Drag to pan",
        "Add node from top menu",
        "Double tap to clone and align",
        "Double tap to select multiple",
        "You have the power",
        "Your time is NOW!",
      ]
      : [
        "Scroll to zoom",
        "Drag to pan",
        "Right click to clone and align",
        "Right click to select multiple",
        "You have the power",
        "Your time is NOW!",
      ];
      const list = document.createElement("ul");
      for (const item of items) {
      const li = document.createElement("li");
      li.textContent = item;
      list.appendChild(li);
      }
      hint.replaceChildren(list);
      },
        autoSelectStyleScope() {
          const scope = document.getElementById("style-scope");
          if (!scope) return;
          if (this.isMobile) scope.value = "mobile";
        },
        updateToolbarStack() {
          if (!this.isMobile) return;
          const draw = document.getElementById("draw-toolbar");
          const topo = document.getElementById("topology-toolbar");
          if (!draw || !topo) return;
          const h = draw.getBoundingClientRect().height;
          document.documentElement.style.setProperty("--draw-toolbar-height", h + "px");
        },
        updateLayoutControls() {
          const sidebarRow = document.getElementById("sidebar-width-row");
          const footerRow = document.getElementById("mobile-footer-row");
          if (sidebarRow && footerRow) {
            if (this.isMobile) {
              sidebarRow.style.display = "none";
              footerRow.style.display = "flex";
            } else {
              sidebarRow.style.display = "flex";
              footerRow.style.display = "none";
            }
          }
        },
        applyAll() {
          this.detect();
          this.applyInitialCollapse();
          this.updateBulkToolbar();
          this.updateLayout();
          this.updateCanvasHint();
          this.autoSelectStyleScope();
          this.updateToolbarStack();
          this.updateLayoutControls();
        }
      };
      function isMobileDevice() {
        return MobileManager.isMobile;
      }
      function ensureLegendMiniButton() {
		if (legendMiniBtn) return legendMiniBtn;
		const handleClick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			legendCollapsed = false;
			updateLegendVisibility();
		};
		const preventTouch = (e) => { e.preventDefault(); };
		const existing = document.getElementById("edge-legend-mini");
		if (existing) {
			existing.addEventListener("click", handleClick);
			existing.addEventListener("touchstart", preventTouch, { passive: false });
			existing.addEventListener("touchend", handleClick);
			legendMiniBtn = existing;
			return existing;
		}
		const panel = document.querySelector(".topology-panel");
		if (!panel) return null;
		   const btn = document.createElement("button");
		   btn.type = "button";
		   btn.id = "edge-legend-mini";
		   btn.className = "legend-mini-btn";
		   btn.textContent = "Legend";
		   btn.style.bottom = "10px";
		   btn.addEventListener("click", handleClick);
		   btn.addEventListener("touchstart", preventTouch, { passive: false });
		   btn.addEventListener("touchend", handleClick);
		   panel.appendChild(btn);
		   legendMiniBtn = btn;
		   return btn;
		}
			 function ensureMinimapMiniButton() {
		   if (minimapMiniBtn) return minimapMiniBtn;
		   const handleClick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			minimapCollapsed = false;
			updateMinimapVisibility();
		   };
		   const preventTouch = (e) => { e.preventDefault(); };
		   const existing = document.getElementById("minimap-mini");
		   if (existing) {
			existing.addEventListener("click", handleClick);
			existing.addEventListener("touchstart", preventTouch, { passive: false });
			existing.addEventListener("touchend", handleClick);
			minimapMiniBtn = existing;
			return existing;
		   }
		   const panel = document.querySelector(".topology-panel");
		   if (!panel) return null;
		   const btn = document.createElement("button");
		   btn.type = "button";
		   btn.id = "minimap-mini";
		   btn.className = "legend-mini-btn";
		   btn.textContent = "Map";
		   btn.style.right = "10px";
		   btn.style.left = "auto";
		   btn.style.bottom = "10px";
		   btn.addEventListener("click", handleClick);
		   btn.addEventListener("touchstart", preventTouch, { passive: false });
		   btn.addEventListener("touchend", handleClick);
		   panel.appendChild(btn);
		   minimapMiniBtn = btn;
		   return btn;
		}
			  function ensureDrawToolbarMiniButton() {
		   if (drawToolbarMiniBtn) return drawToolbarMiniBtn;
		   const handleClick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			drawToolbarCollapsed = false;
			updateDrawToolbarVisibility();
		   };
		   const preventTouch = (e) => { e.preventDefault(); };
		   const existing = document.getElementById("draw-toolbar-mini");
		   if (existing) {
			existing.addEventListener("click", handleClick);
			existing.addEventListener("touchstart", preventTouch, { passive: false });
			existing.addEventListener("touchend", handleClick);
			drawToolbarMiniBtn = existing;
			return existing;
		   }
		   const panel = document.querySelector(".topology-panel");
		   if (!panel) return null;
		   const btn = document.createElement("button");
		   btn.type = "button";
		   btn.id = "draw-toolbar-mini";
		   btn.className = "legend-mini-btn";
		   btn.textContent = "Draw";
		   btn.style.top = "10px";
		   btn.style.left = "10px";
		   btn.style.right = "auto";
		   btn.addEventListener("click", handleClick);
		   btn.addEventListener("touchstart", preventTouch, { passive: false });
		   btn.addEventListener("touchend", handleClick);
		   panel.appendChild(btn);
		   drawToolbarMiniBtn = btn;
		   return btn;
		}
		  function ensureTopologyToolbarMiniButton() {
	   if (topologyToolbarMiniBtn) return topologyToolbarMiniBtn;
	   const handleClick = (e) => {
		e.stopPropagation();
		e.preventDefault();
		topologyToolbarCollapsed = false;
		updateTopologyToolbarVisibility();
	   };
	   const preventTouch = (e) => { e.preventDefault(); };
	   const existing = document.getElementById("topology-toolbar-mini");
	   if (existing) {
		existing.addEventListener("click", handleClick);
		existing.addEventListener("touchstart", preventTouch, { passive: false });
		existing.addEventListener("touchend", handleClick);
		topologyToolbarMiniBtn = existing;
		return existing;
	   }
	   const panel = document.querySelector(".topology-panel");
	   if (!panel) return null;
	   const btn = document.createElement("button");
	   btn.type = "button";
	   btn.id = "topology-toolbar-mini";
	   btn.className = "legend-mini-btn";
	   btn.textContent = "Add Line";
	   btn.style.top = "10px";
	   btn.style.left = "auto";
	   btn.style.right = "40px";
	   btn.addEventListener("click", handleClick);
	   btn.addEventListener("touchstart", preventTouch, { passive: false });
	   btn.addEventListener("touchend", handleClick);
	   panel.appendChild(btn);
	   topologyToolbarMiniBtn = btn;
	   return btn;
	}
      function updateToolbarStack() {
       if (!isMobileDevice()) return;
       const draw = document.getElementById("draw-toolbar");
       const topo = document.getElementById("topology-toolbar");
       if (!draw || !topo) return;
       const h = draw.getBoundingClientRect().height;
       document.documentElement.style.setProperty("--draw-toolbar-height", h + "px");
      }
      window.addEventListener("resize", updateToolbarStack);
      window.addEventListener("DOMContentLoaded", updateToolbarStack);
      updateToolbarStack();
      function updateLegendVisibility() {
       const legend = document.getElementById("edge-legend");
       const mini = ensureLegendMiniButton();
       if (!legend || !mini) return;
       const hasItems = legend.querySelectorAll(".legend-item").length > 0;
       if (!hasItems) {
        legend.style.display = "none";
        mini.style.display = "none";
        return;
       }
       if (legendCollapsed) {
        legend.style.display = "none";
        mini.style.display = "inline-flex";
       } else {
        legend.style.display = "flex";
        mini.style.display = "none";
       }
      }
      function updateMinimapVisibility() {
       const wrapper = document.getElementById("minimap-zoom-wrapper");
       const mini = ensureMinimapMiniButton();
       if (!wrapper || !mini) return;
       if (minimapCollapsed) {
        wrapper.style.display = "none";
        mini.style.display = "inline-flex";
       } else {
        wrapper.style.display = "block";
        mini.style.display = "none";
       }
      }
      function updateDrawToolbarVisibility() {
       const toolbar = document.getElementById("draw-toolbar");
       const mini = ensureDrawToolbarMiniButton();
       if (!toolbar || !mini) return;
       if (typeof isViewOnly === 'function' && isViewOnly()) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "none";
        return;
       }
       if (drawToolbarCollapsed) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "inline-flex";
       } else {
      if (isMobileDevice()) {
        toolbar.style.setProperty('display', 'grid', 'important');
        mini.style.display = "none";
        } else {
        toolbar.style.setProperty('display', 'flex', 'important');
        mini.style.display = "none";
      }
       }
      }
      function u8ToBase64(u8) {
      let binary = "";
      for (let i = 0; i < u8.length; i++) binary += String.fromCharCode(u8[i]);
      return btoa(binary);
      }
      function base64ToU8(base64) {
      const binary = atob(base64);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
      return bytes;
      }
      function updateTopologyToolbarVisibility() {
       const toolbar = document.getElementById("topology-toolbar");
       const mini = ensureTopologyToolbarMiniButton();
       if (!toolbar || !mini) return;
       if (typeof isViewOnly === 'function' && isViewOnly()) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "none";
        return;
       }
       const hasSelectedNode = currentNodeId !== null;
       if (!hasSelectedNode) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "none";
       } else if (topologyToolbarCollapsed) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "inline-flex";
       } else {
      if (isMobileDevice()) {
        toolbar.style.setProperty('display', 'grid', 'important');
        mini.style.display = "none";
        } else {
        toolbar.style.setProperty('display', 'flex', 'important');
        mini.style.display = "none";
      }
       }
      }
      const DEFAULT_CANVAS_HINT = document.getElementById("canvas-hint")?.innerHTML || "";
      const DEFAULT_PAGE_STATE = {
       title: "The One File: The Networkening",
       background: "",
       topbarBg: "rgba(9, 12, 20, 0.9)",
       topbarBorder: "#1f2533",
       panel: "#0b0e13",
       panelAlt: "#10141b",
       accent: "#4fd1c5",
       sidebarBg: "#10141b",
       btnBg: "#0b0e13",
       btnText: "#e2e8f0",
       tagFill: "#1e293b",
       tagText: "#e2e8f0",
       tagBorder: "#475569",
       inputBg: "#0b0e13",
       inputText: "#e2e8f0",
       inputBorder: "#1f2937",
       inputFont: "Inter, system-ui, sans-serif",
       inputFontSize: 14,
       toolbarBg: "#0f172a",
       toolbarBorder: "#1f2937",
       toolbarText: "#94a3b8",
       toolbarBtnBg: "#0b0e13",
       toolbarBtnText: "#e2e8f0",
       minimapDots: "#94a3b8",
       canvasHintEnabled: true,
       canvasHintText: "",
       canvasHintBg: "#0f172a",
       canvasHintColor: "#94a3b8",
       danger: "#f56565",
       textMain: "#e2e8f0",
       textSoft: "#94a3b8",
       topbarHeight: 52,
       sidebarWidth: 350,
       mobileFooterHeight: 40,
       sidebarCollapsed: false,
       nodeFill: "#1e293b",
       nodeStroke: "#475569",
       nodeTitle: "#e2e8f0",
       nodeSub: "#94a3b8",
       nodeTitleSize: 18,
       nodeSubSize: 13,
       nodeFont: "Inter, system-ui, sans-serif",
       defaultEdge: "#475569",
       selectionHandle: "#f59e0b",
       selectionHandleSize: 8,
       groupIndicator: "#4fd1c5",
       canvasGradientTop: "#1e2532",
       canvasGradientBottom: "#050608",
       canvasBorder: "#475569",
       canvasGrid: "#475569",
       canvasGridSize: 50,
       rackFrameFill: "#0f172a",
       rackFrameStroke: "#4fd1c5",
       rackLineColor: "#475569",
       rackTextColor: "#4fd1c5",
	   viewOnly: false,
      };
      let PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE);
	  function isViewOnly() {
       return PAGE_STATE.viewOnly === true;
      }
      let viewOnlyClickCount = 0;
      let viewOnlyClickTimer = null;
      let viewOnlyClickTarget = null;
      function handleViewOnlyClick(id, type) {
       if (!isViewOnly()) return false;
       if (viewOnlyClickTarget !== id) {
        viewOnlyClickCount = 0;
        viewOnlyClickTarget = id;
       }
       viewOnlyClickCount++;
       clearTimeout(viewOnlyClickTimer);
       viewOnlyClickTimer = setTimeout(() => {
        viewOnlyClickCount = 0;
        viewOnlyClickTarget = null;
       }, 2000);
       if (viewOnlyClickCount >= 5) {
        viewOnlyClickCount = 0;
        viewOnlyClickTarget = null;
        document.body.classList.add("view-only-inspect");
        if (type === 'node') {
         currentNodeId = id;
         const data = NODE_DATA[id];
         if (data) {
          document.querySelectorAll(".node-group").forEach((n) => {
           n.classList.toggle("active", n.dataset.nodeId === id);
          });
          document.getElementById("node-panel").style.display = "block";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("node-name").textContent = data.name;
          document.getElementById("node-ip").textContent = data.ip;
          document.getElementById("node-role").textContent = data.role;
          document.getElementById("node-mac").textContent = data.mac || "--";
          document.getElementById("node-rack").textContent = data.rackUnit || "--";
          document.getElementById("node-uheight").textContent = (data.uHeight || "1") + "U";
          const tagList = document.getElementById("node-tags");
          if (tagList) {
           tagList.innerHTML = "";
           if (data.tags && data.tags.length > 0) {
            data.tags.forEach((tag) => {
             const li = document.createElement("li");
             li.textContent = tag;
             tagList.appendChild(li);
            });
           }
          }
          const noteList = document.getElementById("node-notes");
          if (noteList) {
           noteList.innerHTML = "";
           if (data.notes && data.notes.length > 0) {
            data.notes.forEach((note) => {
             const li = document.createElement("li");
             li.textContent = note;
             noteList.appendChild(li);
            });
           }
          }
         }
        } else if (type === 'edge') {
         currentEdgeId = id;
         const edge = EDGE_DATA.list.find(e => e.id === id);
         if (edge) {
          document.querySelectorAll(".edge").forEach((e) => {
           e.classList.toggle("active", e.dataset.edgeId === id);
          });
          document.getElementById("edge-panel").style.display = "block";
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-from").textContent = NODE_DATA[edge.from]?.name || edge.from;
          document.getElementById("edge-to").textContent = NODE_DATA[edge.to]?.name || edge.to;
          document.getElementById("edge-label").value = edge.label || "";
         }
        }
        return true;
       }
       return false;
      }
      const CANVAS_WIDTH = 4000;
      let CANVAS_HEIGHT = 3000;
      const BASE_CANVAS_HEIGHT = 3000;
      const CANVAS_PADDING = 100;
      const RACK_U_HEIGHT = 70;
      const RACK_WIDTH = 600;
      const RACK_START_X = CANVAS_WIDTH / 2;
      const RACK_START_Y = CANVAS_PADDING + 100;
      function getRackUHeight(rackId) {
      const capacity = getRackCapacity(rackId);
      const availableHeight = CANVAS_HEIGHT - RACK_START_Y - 200;
      return Math.floor(availableHeight / capacity);
      }
      let canvasState = {
       zoom: 1,
       panX: 0,
       panY: 0,
       minZoom: 0.25,
       maxZoom: 4,
       isPanning: false,
       panStartX: 0,
       panStartY: 0,
       spacePressed: false,
      };
      function getViewBox() {
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       return {
        x: canvasState.panX,
        y: canvasState.panY,
        width: viewWidth,
        height: viewHeight,
       };
      }
      function updateViewBox() {
       const svg = document.getElementById("map");
       const vb = getViewBox();
       svg.setAttribute("viewBox", `${vb.x} ${vb.y} ${vb.width} ${vb.height}`, );
       const zoomLevel = document.getElementById("zoom-level");
       if (zoomLevel) {
        zoomLevel.textContent = Math.round(canvasState.zoom * 100) + "%";
       }
       updateMinimap();
      }
      function updateMinimap() {
       const minimapViewport = document.getElementById("minimap-viewport");
       const minimapSvg = document.getElementById("minimap");
       if (!minimapViewport || !minimapSvg) return;
       const vb = getViewBox();
       minimapViewport.setAttribute("x", vb.x);
       minimapViewport.setAttribute("y", vb.y);
       minimapViewport.setAttribute("width", vb.width);
       minimapViewport.setAttribute("height", vb.height);
       const minimapNodes = minimapSvg.querySelectorAll(".minimap-node");
       minimapNodes.forEach((n) => n.remove());
       const minimapEdges = minimapSvg.querySelectorAll(".minimap-edge");
       minimapEdges.forEach((e) => e.remove());
       EDGE_DATA.list.forEach((edge) => {
        if (edge.type === "custom") return;
        const fromNode = NODE_DATA[edge.from];
        const toNode = NODE_DATA[edge.to];
        if (!fromNode || !toNode) return;
        if (currentView.mode === "rack") {
         if (fromNode.assignedRack !== currentView.rackId ||
             toNode.assignedRack !== currentView.rackId) {
          return;
         }
        } else {
         if (fromNode.assignedRack || toNode.assignedRack) {
          return;
         }
        }
        const p1 = savedPositions[edge.from];
        const p2 = savedPositions[edge.to];
        if (!p1 || !p2) return;
        const line = document.createElementNS("http://www.w3.org/2000/svg", "line", );
        line.setAttribute("x1", p1.x);
        line.setAttribute("y1", p1.y);
        line.setAttribute("x2", p2.x);
        line.setAttribute("y2", p2.y);
        line.classList.add("minimap-edge");
        minimapSvg.insertBefore(line, minimapViewport);
       });
       Object.entries(savedPositions).forEach(([id, pos]) => {
        const node = NODE_DATA[id];
        if (!node) return;
        if (currentView.mode === "rack") {
         if (node.assignedRack !== currentView.rackId) {
          return;
         }
        } else {
         if (node.assignedRack) {
          return;
         }
        }
        const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle", );
        circle.setAttribute("cx", pos.x);
        circle.setAttribute("cy", pos.y);
        circle.setAttribute("r", 40);
        circle.classList.add("minimap-node");
        minimapSvg.insertBefore(circle, minimapViewport);
       });
      }
      function zoomTo(newZoom, centerX, centerY) {
       const oldZoom = canvasState.zoom;
       newZoom = Math.max(canvasState.minZoom, Math.min(canvasState.maxZoom, newZoom), );
       if (centerX !== undefined && centerY !== undefined) {
        const oldWidth = CANVAS_WIDTH / oldZoom;
        const oldHeight = CANVAS_HEIGHT / oldZoom;
        const newWidth = CANVAS_WIDTH / newZoom;
        const newHeight = CANVAS_HEIGHT / newZoom;
        const pointX = canvasState.panX + centerX * oldWidth;
        const pointY = canvasState.panY + centerY * oldHeight;
        canvasState.panX = pointX - centerX * newWidth;
        canvasState.panY = pointY - centerY * newHeight;
       }
       canvasState.zoom = newZoom;
       constrainPan();
       updateViewBox();
      }
      function constrainPan() {
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       const minVisiblePortion = 0.1;
       const maxPanX = CANVAS_WIDTH - viewWidth * minVisiblePortion;
       const maxPanY = CANVAS_HEIGHT - viewHeight * minVisiblePortion;
       const minPanX = -viewWidth * (1 - minVisiblePortion);
       const minPanY = -viewHeight * (1 - minVisiblePortion);
       canvasState.panX = Math.max(minPanX, Math.min(maxPanX, canvasState.panX), );
       canvasState.panY = Math.max(minPanY, Math.min(maxPanY, canvasState.panY), );
      }
      function fitToContent() {
       const positions = Object.values(savedPositions);
       if (positions.length === 0) {
        resetView();
        return;
       }
       let minX = Infinity,
        minY = Infinity,
        maxX = -Infinity,
        maxY = -Infinity;
       positions.forEach((pos) => {
        minX = Math.min(minX, pos.x - 100);
        minY = Math.min(minY, pos.y - 100);
        maxX = Math.max(maxX, pos.x + 100);
        maxY = Math.max(maxY, pos.y + 100);
       });
       const contentWidth = maxX - minX + 200;
       const contentHeight = maxY - minY + 200;
       const viewport = document.getElementById("canvas-viewport");
       const vpRect = viewport.getBoundingClientRect();
       const aspectRatio = vpRect.width / vpRect.height;
       const contentAspect = contentWidth / contentHeight;
       let newZoom;
       if (contentAspect > aspectRatio) {
        newZoom = (vpRect.width / contentWidth) * (CANVAS_WIDTH / vpRect.width);
       } else {
        newZoom = (vpRect.height / contentHeight) * (CANVAS_HEIGHT / vpRect.height);
       }
       newZoom = Math.max(canvasState.minZoom, Math.min(2, newZoom));
       const viewWidth = CANVAS_WIDTH / newZoom;
       const viewHeight = CANVAS_HEIGHT / newZoom;
       canvasState.zoom = newZoom;
       canvasState.panX = minX - 100 - (viewWidth - contentWidth) / 2;
       canvasState.panY = minY - 100 - (viewHeight - contentHeight) / 2;
       constrainPan();
       updateViewBox();
      }
      function resetView() {
       canvasState.zoom = 1;
       canvasState.panX = 0;
       canvasState.panY = 0;
       updateViewBox();
      }
      window.addEventListener("DOMContentLoaded", () => {
       const toggle = document.getElementById("mobile-menu-toggle");
       const menu = document.getElementById("topbar-menu");
       if (!toggle || !menu) return;
       toggle.addEventListener("click", () => {
        menu.classList.toggle("open");
       });
       menu.addEventListener("click", (e) => {
        const target = e.target.closest("a, button");
        if (!target) return;
        if (isMobileDevice()) {
       menu.classList.remove("open");
      }
       });
       const minimapCloseBtn = document.getElementById("minimap-close-btn");
       if (minimapCloseBtn) {
        const handleMinimapClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         minimapCollapsed = true;
         updateMinimapVisibility();
        };
        minimapCloseBtn.addEventListener("click", handleMinimapClose);
        minimapCloseBtn.addEventListener("touchend", handleMinimapClose);
       }
       const drawToolbarCloseBtn = document.getElementById("draw-toolbar-close-btn");
       if (drawToolbarCloseBtn) {
        const handleDrawClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         drawToolbarCollapsed = true;
         updateDrawToolbarVisibility();
        };
        drawToolbarCloseBtn.addEventListener("click", handleDrawClose);
        drawToolbarCloseBtn.addEventListener("touchend", handleDrawClose);
       }
       const topologyToolbarCloseBtn = document.getElementById("topology-toolbar-close-btn");
       if (topologyToolbarCloseBtn) {
        const handleTopologyClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         topologyToolbarCollapsed = true;
         updateTopologyToolbarVisibility();
        };
        topologyToolbarCloseBtn.addEventListener("click", handleTopologyClose);
        topologyToolbarCloseBtn.addEventListener("touchstart", (e) => e.preventDefault(), {
         passive: false
        });
        topologyToolbarCloseBtn.addEventListener("touchend", handleTopologyClose);
       }
       updateMinimapVisibility();
       updateDrawToolbarVisibility();
       updateTopologyToolbarVisibility();
      });
      function applyLayerFilter() {
       activeLayers.clear();
       if (document.getElementById("layer-physical").checked) activeLayers.add("physical");
       if (document.getElementById("layer-logical").checked) activeLayers.add("logical");
       if (document.getElementById("layer-security").checked) activeLayers.add("security");
       if (document.getElementById("layer-application").checked) activeLayers.add("application");
       forgeTheTopology();
      }
      function isNodeVisible(nodeId) {
       const node = NODE_DATA[nodeId];
       if (!node) return false;
       const nodeLayer = node.layer || "physical";
       return activeLayers.has(nodeLayer);
      }
      function enterRack(rackId) {
      if (!NODE_DATA[rackId] || !NODE_DATA[rackId].isRack) return;
      const rackCapacity = getRackCapacity(rackId);
      const neededHeight = RACK_START_Y + (rackCapacity * RACK_U_HEIGHT) + 200;
      if (neededHeight > BASE_CANVAS_HEIGHT) {
      CANVAS_HEIGHT = neededHeight;
      }
       currentView.mode = "rack";
       currentView.rackId = rackId;
       const backBtn = document.getElementById("back-to-topology-btn");
       if (backBtn) backBtn.style.display = "inline-block";
       const hint = document.getElementById("canvas-hint");
       if (hint) {
        hint.textContent = `Viewing: ${NODE_DATA[rackId].name} | Double click empty space to exit`;
        hint.classList.add("visible");
       }
      const rackUHeight = getRackUHeight(rackId);
      const rackHeight = rackCapacity * rackUHeight;
      const rackCenterX = RACK_START_X;
      const rackCenterY = RACK_START_Y + (rackHeight / 2);
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       canvasState.panX = rackCenterX - (viewWidth / 2);
       canvasState.panY = rackCenterY - (viewHeight / 2);
       constrainPan();
       updateViewBox();
       forgeTheTopology();
      }
      function exitRack() {
      CANVAS_HEIGHT = BASE_CANVAS_HEIGHT;
      currentView.mode = "topology";
      currentView.rackId = null;
       const backBtn = document.getElementById("back-to-topology-btn");
       if (backBtn) backBtn.style.display = "none";
       const hint = document.getElementById("canvas-hint");
       if (hint) {
        hint.classList.remove("visible");
       }
       if (savedTopologyView) {
        canvasState.zoom = savedTopologyView.zoom;
        canvasState.panX = savedTopologyView.panX;
        canvasState.panY = savedTopologyView.panY;
        updateViewBox();
       }
       forgeTheTopology();
      }
      function getRackCapacity(rackId) {
       const node = NODE_DATA[rackId];
       return node && node.rackCapacity ? parseInt(node.rackCapacity) : 42;
      }
      function populateRackDropdown() {
       const dropdown = document.getElementById("node-assigned-rack");
       if (!dropdown) return;
       dropdown.innerHTML = '<option value="">None</option>';
       Object.keys(NODE_DATA).forEach(id => {
        if (NODE_DATA[id].isRack) {
         const option = document.createElement("option");
         option.value = id;
         option.textContent = NODE_DATA[id].name;
         dropdown.appendChild(option);
        }
       });
      }
      function wieldThePower() {
       const root = document.documentElement;
       root.style.setProperty("--panel", PAGE_STATE.panel);
       root.style.setProperty("--panel-alt", PAGE_STATE.panelAlt);
       root.style.setProperty("--sidebar-bg", PAGE_STATE.sidebarBg || PAGE_STATE.panelAlt);
       root.style.setProperty("--btn-bg", PAGE_STATE.btnBg || PAGE_STATE.panel);
       root.style.setProperty("--btn-text", PAGE_STATE.btnText || "#e2e8f0");
       root.style.setProperty("--tag-fill", PAGE_STATE.tagFill || "#1e293b");
       root.style.setProperty("--tag-text", PAGE_STATE.tagText || "#e2e8f0");
       root.style.setProperty("--tag-border", PAGE_STATE.tagBorder || "#475569");
       root.style.setProperty("--input-bg", PAGE_STATE.inputBg || "#0b0e13");
       root.style.setProperty("--input-text", PAGE_STATE.inputText || "#e2e8f0");
       root.style.setProperty("--input-border", PAGE_STATE.inputBorder || "#1f2937");
       root.style.setProperty("--input-font", PAGE_STATE.inputFont || "Inter, system-ui, sans-serif");
       root.style.setProperty("--input-font-size", (PAGE_STATE.inputFontSize || 14) + "px");
       root.style.setProperty("--toolbar-bg", PAGE_STATE.toolbarBg || "#0f172a");
       root.style.setProperty("--toolbar-border", PAGE_STATE.toolbarBorder || "#1f2937");
       root.style.setProperty("--toolbar-text", PAGE_STATE.toolbarText || "#94a3b8");
       root.style.setProperty("--toolbar-btn-bg", PAGE_STATE.toolbarBtnBg || "#0b0e13");
       root.style.setProperty("--toolbar-btn-text", PAGE_STATE.toolbarBtnText || "#e2e8f0");
       root.style.setProperty("--minimap-dots", PAGE_STATE.minimapDots || "#94a3b8");
       root.style.setProperty("--canvas-hint-bg", PAGE_STATE.canvasHintBg || "#0f172a");
       root.style.setProperty("--canvas-hint-color", PAGE_STATE.canvasHintColor || "#94a3b8");
       const canvasHint = document.getElementById("canvas-hint");
       if (canvasHint) {
        canvasHint.style.display = PAGE_STATE.canvasHintEnabled === false ? "none" : "";
        if (PAGE_STATE.canvasHintText !== undefined && PAGE_STATE.canvasHintText !== "") {
         canvasHint.innerHTML = PAGE_STATE.canvasHintText;
        } else {
         canvasHint.innerHTML = DEFAULT_CANVAS_HINT;
        }
       }
       root.style.setProperty("--accent", PAGE_STATE.accent);
       root.style.setProperty("--danger", PAGE_STATE.danger);
       root.style.setProperty("--text-main", PAGE_STATE.textMain);
       root.style.setProperty("--text-soft", PAGE_STATE.textSoft);
       root.style.setProperty("--topbar-bg", PAGE_STATE.topbarBg);
       root.style.setProperty("--topbar-border", PAGE_STATE.topbarBorder);
       root.style.setProperty("--node-fill", PAGE_STATE.nodeFill || "#1e293b");
       root.style.setProperty("--node-stroke", PAGE_STATE.nodeStroke || "#475569");
       root.style.setProperty("--node-title", PAGE_STATE.nodeTitle || "#e2e8f0");
       root.style.setProperty("--node-sub", PAGE_STATE.nodeSub || "#94a3b8");
       root.style.setProperty("--node-title-size", (PAGE_STATE.nodeTitleSize || 18) + "px");
       root.style.setProperty("--node-sub-size", (PAGE_STATE.nodeSubSize || 13) + "px");
       root.style.setProperty("--node-font", PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif");
       root.style.setProperty("--default-edge", PAGE_STATE.defaultEdge || "#475569");
       root.style.setProperty("--selection-handle", PAGE_STATE.selectionHandle || "#f59e0b");
       root.style.setProperty("--selection-handle-size", (PAGE_STATE.selectionHandleSize || 8) + "px");
       root.style.setProperty("--group-indicator", PAGE_STATE.groupIndicator || "#4fd1c5");
       const topbarHeight = PAGE_STATE.topbarHeight || 52;
       const sidebarWidth = PAGE_STATE.sidebarWidth || 350;
       const mobileFooterHeight = PAGE_STATE.mobileFooterHeight || 40;
       root.style.setProperty("--topbar-height", topbarHeight + "px");
       root.style.setProperty("--sidebar-width", sidebarWidth + "px");
       root.style.setProperty("--mobile-footer-height", mobileFooterHeight + "vh", );
       const mainEl = document.querySelector("main");
       const detailsPanel = document.getElementById("details-panel");
       const sidebarToggle = document.getElementById("sidebar-toggle");
       if (PAGE_STATE.sidebarCollapsed) {
        if (mainEl) mainEl.classList.add("sidebar-collapsed");
        if (detailsPanel) detailsPanel.classList.add("collapsed");
        if (sidebarToggle) {
         sidebarToggle.classList.add("collapsed");
         sidebarToggle.textContent = "‚ñ∂";
        }
       } else {
        if (mainEl) mainEl.classList.remove("sidebar-collapsed");
        if (detailsPanel) detailsPanel.classList.remove("collapsed");
        if (sidebarToggle) {
         sidebarToggle.classList.remove("collapsed");
         sidebarToggle.textContent = "‚óÄ";
        }
       }
       if (PAGE_STATE.background) {
        document.body.style.background = PAGE_STATE.background;
       } else {
        document.body.style.background = `radial-gradient(circle at top, ${PAGE_STATE.canvasGradientTop || "#1e2532"} 0, ${PAGE_STATE.canvasGradientBottom || "#050608"} 70%)`;
       }
       document.title = PAGE_STATE.title || DEFAULT_PAGE_STATE.title;
       const titleEl = document.getElementById("page-title");
       if (titleEl) {
        titleEl.textContent = PAGE_STATE.title || DEFAULT_PAGE_STATE.title;
       }
       const viewOnlyMode = PAGE_STATE.viewOnly === true;
       const addNodeBtn = document.getElementById("add-node-btn");
       const addRackBtn = document.getElementById("add-rack-btn");
       const bulkToolbar = document.getElementById("bulk-toolbar");
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       if (viewOnlyMode) {
        if (addNodeBtn) addNodeBtn.style.display = "none";
        if (addRackBtn) addRackBtn.style.display = "none";
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        ["draw-toolbar-mini", "topology-toolbar-mini"].forEach(id => {
         const el = document.getElementById(id);
         if (el) el.style.display = "none";
        });
        document.body.classList.remove("view-only-inspect");
       } else {
        if (addNodeBtn) addNodeBtn.style.display = "";
        if (addRackBtn) addRackBtn.style.display = "";
       }
       document.body.classList.toggle("view-only-mode", viewOnlyMode);
       if (!viewOnlyMode) {
        if (typeof updateDrawToolbarVisibility === 'function') updateDrawToolbarVisibility();
        if (typeof updateTopologyToolbarVisibility === 'function') updateTopologyToolbarVisibility();
       }
      }
      (async function awakeTheImmortal() {
       let initialState = {};
       let decryptionCancelled = false;
       const stateEl = document.getElementById("topology-state");
       if (stateEl && stateEl.textContent.trim()) {
        try {
         let stateText = stateEl.textContent.trim();
         if (isEncrypted(stateText)) {
          let decrypted = false;
          let attempts = 0;
          const maxAttempts = 3;
          while (!decrypted && attempts < maxAttempts) {
           const password = prompt("This file is encrypted. Enter password to decrypt:\n(Attempt " + (attempts + 1) + " of " + maxAttempts + ")", );
           if (!password) {
            alert("Decryption cancelled. The file will not be loaded.", );
            decryptionCancelled = true;
            break;
           }
           try {
            stateText = await decryptData(stateText, password);
            decrypted = true;
           } catch (e) {
            attempts++;
            if (attempts < maxAttempts) {
             alert("Incorrect password. Please try again.");
            } else {
             alert("Maximum attempts reached. The file will not be loaded.", );
             decryptionCancelled = true;
            }
           }
          }
          if (!decrypted) {
           stateText = "{}";
          }
         }
         initialState = JSON.parse(stateText);
        } catch (e) {
         console.error("Failed to load state:", e);
         initialState = {};
        }
       }
       if (decryptionCancelled) {
        NODE_DATA = {};
        EDGE_DATA = {
         list: []
        };
        RECT_DATA = { list: [] };
        TEXT_DATA = { list: [] };
        EDGE_LEGEND = {};
        savedPositions = {};
        savedSizes = {};
        savedStyles = {};
       } else {
        NODE_DATA = initialState.nodeData ? initialState.nodeData : BASE_NODE_DATA;
        Object.keys(NODE_DATA).forEach(nodeId => {
         if (!NODE_DATA[nodeId].ping) {
          NODE_DATA[nodeId].ping = {
           enabled: false,
           protocol: 'http',
           customUrl: '',
           timeout: 3000,
           status: 'unknown',
           lastCheck: null
          };
         }
        });
        EDGE_DATA = initialState.edgeData ? initialState.edgeData : {
         list: [],
        };
        RECT_DATA = initialState.rectData ? initialState.rectData : { list: [] };
        TEXT_DATA = initialState.textData ? initialState.textData : { list: [] };
        EDGE_LEGEND = initialState.edgeLegend || {};
        savedPositions = initialState.nodePositions || {};
        savedSizes = initialState.nodeSizes || {};
        savedStyles = initialState.nodeStyles || {};
        if (initialState.iconCache) {
         IconLibrary.iconCache = initialState.iconCache;
        }
       }
       if (initialState.page) {
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, initialState.page, );
       }
       if (PAGE_STATE.autoPingEnabled !== undefined) {
        autoPingEnabled = PAGE_STATE.autoPingEnabled;
       }
       if (PAGE_STATE.autoPingInterval !== undefined) {
        autoPingInterval = PAGE_STATE.autoPingInterval;
       }
       if (initialState.canvas) {
        canvasState.zoom = initialState.canvas.zoom || 1;
        canvasState.panX = initialState.canvas.panX || 0;
        canvasState.panY = initialState.canvas.panY || 0;
       }
       if (initialState.savedTopologyView) {
        savedTopologyView = initialState.savedTopologyView;
       }
       if (initialState.documentTabs) {
        documentTabs = initialState.documentTabs;
        if (initialState.currentTabIndex !== undefined) {
          currentTabIndex = initialState.currentTabIndex;
          const currentTab = documentTabs[currentTabIndex];
          if (currentTab) {
            NODE_DATA = currentTab.nodes || NODE_DATA;
            EDGE_DATA = currentTab.edges || EDGE_DATA;
            savedPositions = currentTab.positions || savedPositions;
            savedSizes = currentTab.sizes || savedSizes;
            savedStyles = currentTab.styles || savedStyles;
            EDGE_LEGEND = currentTab.legend || EDGE_LEGEND;
            RECT_DATA = currentTab.rects || RECT_DATA;
            TEXT_DATA = currentTab.texts || TEXT_DATA;
            if (currentTab.pageState) PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, currentTab.pageState);
          }
        }
       }
       if (initialState.encryptedSections) {
        encryptedSections = initialState.encryptedSections;
       }
       wieldThePower();
       forgeTheTopology();
       updateViewBox();
       MobileManager.applyAll();
       if (autoPingEnabled) {
        startAutoPing();
       }
       const initialNodes = Object.keys(NODE_DATA);
       if (initialNodes.length > 0) {
        claimTheImmortal(initialNodes.includes("host") ? "host" : initialNodes[0], );
       } else {
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.display = "none";
       }
      })();
      let resizeDebounceTimer = null;
      window.addEventListener("resize", () => {
        clearTimeout(resizeDebounceTimer);
        resizeDebounceTimer = setTimeout(() => {
          MobileManager.applyAll();
          if (typeof updateDrawToolbarVisibility === 'function') updateDrawToolbarVisibility();
          if (typeof updateTopologyToolbarVisibility === 'function') updateTopologyToolbarVisibility();
        }, 100);
      });
      function getBreakpointKey() {
       const w = window.innerWidth;
       if (w <= 380) return "fold";
       if (w <= 768) return "mobile";
       if (w <= 1024) return "tablet";
       return "desktop";
      }
      function resolveStylesEntry(styleEntry) {
       if (!styleEntry) return {};
       if (styleEntry.circleColor || styleEntry.titleColor || styleEntry.titleFont || styleEntry.titleSize || styleEntry.subColor || styleEntry.subFont || styleEntry.subSize) {
        return styleEntry;
       }
       const bp = getBreakpointKey();
       const base = styleEntry.all || {};
       const bpStyles = styleEntry[bp] || {};
       return Object.assign({}, base, bpStyles);
      }
      function resolveStylesForNode(id) {
       const styleEntry = savedStyles[id];
       if (!styleEntry) return {};
       return resolveStylesEntry(styleEntry);
      }
      function ensureStyleEntry(id) {
       if (!savedStyles[id]) savedStyles[id] = {};
       const entry = savedStyles[id];
       const flatProps = ["circleColor", "circleBorder", "titleColor", "titleFont", "titleSize", "subColor", "subFont", "subSize", ];
       const isFlat = flatProps.some((p) => Object.prototype.hasOwnProperty.call(entry, p), );
       if (isFlat) {
        const all = entry.all || {};
        flatProps.forEach((p) => {
         if (entry[p] !== undefined) {
          all[p] = entry[p];
          delete entry[p];
         }
        });
        entry.all = all;
       }
       return entry;
      }
      function getDefaultSize() {
       if (window.innerWidth <= 380) return 120;
       if (window.innerWidth <= 768) return 140;
       if (window.innerWidth <= 1024) return 70;
       return 55;
      }
      function createShapeElement(shape, size) {
       const ns = "http://www.w3.org/2000/svg";
       if (shape === "circle") {
        const c = document.createElementNS(ns, "circle");
        c.setAttribute("r", size);
        return c;
       }
       if (shape === "square") {
        const r = document.createElementNS(ns, "rect");
        const s = size * 2;
        r.setAttribute("x", -size);
        r.setAttribute("y", -size);
        r.setAttribute("width", s);
        r.setAttribute("height", s);
        r.setAttribute("rx", 4);
        return r;
       }
       if (shape === "rectangle") {
        const r = document.createElementNS(ns, "rect");
        r.setAttribute("x", -size * 1.4);
        r.setAttribute("y", -size * 0.8);
        r.setAttribute("width", size * 2.8);
        r.setAttribute("height", size * 1.6);
        r.setAttribute("rx", 6);
        return r;
       }
       if (shape === "triangle") {
        const p = document.createElementNS(ns, "polygon");
        const h = size * 1.8;
        const w = size * 2;
        p.setAttribute("points", `0,${-h} ${w / 2},${h / 2} ${-w / 2},${h / 2}`, );
        return p;
       }
       if (shape === "hexagon") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        const pts = [
         [0, -s],
         [s * 0.86, -s * 0.5],
         [s * 0.86, s * 0.5],
         [0, s],
         [-s * 0.86, s * 0.5],
         [-s * 0.86, -s * 0.5],
        ].map((pt) => pt.join(",")).join(" ");
        p.setAttribute("points", pts);
        return p;
       }
       if (shape === "stop-sign") {
        const p = document.createElementNS(ns, "polygon");
        const r = size;
        const ptsArr = [];
        for (let i = 0; i < 8; i++) {
         const a = (Math.PI / 4) * i + Math.PI / 8;
         ptsArr.push([Math.cos(a) * r, Math.sin(a) * r]);
        }
        const pts = ptsArr.map((pt) => pt.join(",")).join(" ");
        p.setAttribute("points", pts);
        return p;
       }
       if (shape === "star") {
        const p = document.createElementNS(ns, "polygon");
        const outer = size;
        const inner = size * 0.45;
        let pts = "";
        for (let i = 0; i < 10; i++) {
         const a = (Math.PI / 5) * i - Math.PI / 2;
         const r = i % 2 === 0 ? outer : inner;
         pts += `${Math.cos(a) * r},${Math.sin(a) * r} `;
        }
        p.setAttribute("points", pts.trim());
        return p;
       }
       if (shape === "diamond") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `0,${-s} ${s},0 0,${s} ${-s},0`);
        return p;
       }
       if (shape === "server") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.2);
        body.setAttribute("y", -size * 0.6);
        body.setAttribute("width", size * 2.4);
        body.setAttribute("height", size * 1.2);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 3; i++) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", -size * 0.9 + i * size * 0.5);
         line.setAttribute("y1", -size * 0.3);
         line.setAttribute("x2", -size * 0.9 + i * size * 0.5);
         line.setAttribute("y2", size * 0.3);
         line.style.stroke = "currentColor";
         line.style.strokeWidth = "2";
         line.style.opacity = "0.5";
         g.appendChild(line);
        }
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", size * 0.9);
        led.setAttribute("cy", 0);
        led.setAttribute("r", size * 0.1);
        led.style.fill = "#4ade80";
        g.appendChild(led);
        return g;
       }
       if (shape === "pc" || shape === "desktop") {
        const g = document.createElementNS(ns, "g");
        const monitor = document.createElementNS(ns, "rect");
        monitor.setAttribute("x", -size * 0.9);
        monitor.setAttribute("y", -size * 0.8);
        monitor.setAttribute("width", size * 1.8);
        monitor.setAttribute("height", size * 1.2);
        monitor.setAttribute("rx", 4);
        g.appendChild(monitor);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.75);
        screen.setAttribute("y", -size * 0.65);
        screen.setAttribute("width", size * 1.5);
        screen.setAttribute("height", size * 0.9);
        screen.setAttribute("rx", 2);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        const neck = document.createElementNS(ns, "rect");
        neck.setAttribute("x", -size * 0.15);
        neck.setAttribute("y", size * 0.4);
        neck.setAttribute("width", size * 0.3);
        neck.setAttribute("height", size * 0.3);
        g.appendChild(neck);
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.5);
        base.setAttribute("y", size * 0.7);
        base.setAttribute("width", size * 1);
        base.setAttribute("height", size * 0.15);
        base.setAttribute("rx", 2);
        g.appendChild(base);
        return g;
       }
       if (shape === "laptop") {
        const g = document.createElementNS(ns, "g");
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.8);
        screen.setAttribute("y", -size * 0.9);
        screen.setAttribute("width", size * 1.6);
        screen.setAttribute("height", size * 1.1);
        screen.setAttribute("rx", 4);
        g.appendChild(screen);
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.9);
        base.setAttribute("y", size * 0.25);
        base.setAttribute("width", size * 1.8);
        base.setAttribute("height", size * 0.6);
        base.setAttribute("rx", 4);
        g.appendChild(base);
        const pad = document.createElementNS(ns, "rect");
        pad.setAttribute("x", -size * 0.25);
        pad.setAttribute("y", size * 0.45);
        pad.setAttribute("width", size * 0.5);
        pad.setAttribute("height", size * 0.25);
        pad.setAttribute("rx", 2);
        pad.style.fill = "#1e293b";
        g.appendChild(pad);
        return g;
       }
       if (shape === "phone" || shape === "mobile") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.45);
        body.setAttribute("y", -size);
        body.setAttribute("width", size * 0.9);
        body.setAttribute("height", size * 2);
        body.setAttribute("rx", 8);
        g.appendChild(body);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.38);
        screen.setAttribute("y", -size * 0.85);
        screen.setAttribute("width", size * 0.76);
        screen.setAttribute("height", size * 1.6);
        screen.setAttribute("rx", 4);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        const btn = document.createElementNS(ns, "rect");
        btn.setAttribute("x", -size * 0.15);
        btn.setAttribute("y", size * 0.82);
        btn.setAttribute("width", size * 0.3);
        btn.setAttribute("height", size * 0.06);
        btn.setAttribute("rx", 2);
        btn.style.fill = "#475569";
        g.appendChild(btn);
        return g;
       }
       if (shape === "router") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.1);
        body.setAttribute("y", -size * 0.3);
        body.setAttribute("width", size * 2.2);
        body.setAttribute("height", size * 0.8);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        for (let i = -1; i <= 1; i++) {
         const ant = document.createElementNS(ns, "rect");
         ant.setAttribute("x", i * size * 0.6 - size * 0.05);
         ant.setAttribute("y", -size * 0.9);
         ant.setAttribute("width", size * 0.1);
         ant.setAttribute("height", size * 0.6);
         ant.setAttribute("rx", 2);
         g.appendChild(ant);
         const tip = document.createElementNS(ns, "circle");
         tip.setAttribute("cx", i * size * 0.6);
         tip.setAttribute("cy", -size * 0.95);
         tip.setAttribute("r", size * 0.08);
         g.appendChild(tip);
        }
        for (let i = 0; i < 4; i++) {
         const led = document.createElementNS(ns, "circle");
         led.setAttribute("cx", -size * 0.7 + i * size * 0.35);
         led.setAttribute("cy", size * 0.1);
         led.setAttribute("r", size * 0.06);
         led.style.fill = i < 2 ? "#4ade80" : "#facc15";
         g.appendChild(led);
        }
        return g;
       }
       if (shape === "switch") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.4);
        body.setAttribute("y", -size * 0.4);
        body.setAttribute("width", size * 2.8);
        body.setAttribute("height", size * 0.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 8; i++) {
         const port = document.createElementNS(ns, "rect");
         port.setAttribute("x", -size * 1.2 + i * size * 0.32);
         port.setAttribute("y", -size * 0.15);
         port.setAttribute("width", size * 0.22);
         port.setAttribute("height", size * 0.3);
         port.setAttribute("rx", 1);
         port.style.fill = "#1e293b";
         g.appendChild(port);
        }
        return g;
       }
       if (shape === "firewall") {
        const g = document.createElementNS(ns, "g");
        const wall = document.createElementNS(ns, "rect");
        wall.setAttribute("x", -size);
        wall.setAttribute("y", -size * 0.8);
        wall.setAttribute("width", size * 2);
        wall.setAttribute("height", size * 1.6);
        wall.setAttribute("rx", 4);
        g.appendChild(wall);
        for (let row = 0; row < 3; row++) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", -size * 0.85);
         line.setAttribute("y1", -size * 0.5 + row * size * 0.45);
         line.setAttribute("x2", size * 0.85);
         line.setAttribute("y2", -size * 0.5 + row * size * 0.45);
         line.style.stroke = "#475569";
         line.style.strokeWidth = "2";
         g.appendChild(line);
        }
        for (let row = 0; row < 4; row++) {
         const offset = row % 2 === 0 ? 0 : size * 0.35;
         for (let col = 0; col < 3; col++) {
          const line = document.createElementNS(ns, "line");
          const x = -size * 0.5 + col * size * 0.7 + offset;
          if (x > -size * 0.85 && x < size * 0.85) {
           line.setAttribute("x1", x);
           line.setAttribute("y1", -size * 0.8 + row * size * 0.45, );
           line.setAttribute("x2", x);
           line.setAttribute("y2", -size * 0.8 + row * size * 0.45 + size * 0.45, );
           line.style.stroke = "#475569";
           line.style.strokeWidth = "2";
           g.appendChild(line);
          }
         }
        }
        return g;
       }
       if (shape === "cloud") {
        const p = document.createElementNS(ns, "path");
        const s = size;
        p.setAttribute("d", `
             M ${-s * 0.8} ${s * 0.2}
             Q ${-s * 1.1} ${s * 0.2} ${-s * 1.1} ${-s * 0.1}
             Q ${-s * 1.1} ${-s * 0.5} ${-s * 0.7} ${-s * 0.5}
             Q ${-s * 0.7} ${-s * 0.9} ${-s * 0.2} ${-s * 0.9}
             Q ${s * 0.1} ${-s * 1.1} ${s * 0.5} ${-s * 0.8}
             Q ${s * 1} ${-s * 0.8} ${s * 1.1} ${-s * 0.3}
             Q ${s * 1.3} ${-s * 0.1} ${s * 1.1} ${s * 0.2}
             Q ${s * 1.1} ${s * 0.5} ${s * 0.7} ${s * 0.5}
             L ${-s * 0.5} ${s * 0.5}
             Q ${-s * 0.9} ${s * 0.5} ${-s * 0.9} ${s * 0.2}
             Z
            `, );
        return p;
       }
       if (shape === "database") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.7);
        body.setAttribute("y", -size * 0.6);
        body.setAttribute("width", size * 1.4);
        body.setAttribute("height", size * 1.4);
        g.appendChild(body);
        const top = document.createElementNS(ns, "ellipse");
        top.setAttribute("cx", 0);
        top.setAttribute("cy", -size * 0.6);
        top.setAttribute("rx", size * 0.7);
        top.setAttribute("ry", size * 0.25);
        g.appendChild(top);
        const bottom = document.createElementNS(ns, "ellipse");
        bottom.setAttribute("cx", 0);
        bottom.setAttribute("cy", size * 0.8);
        bottom.setAttribute("rx", size * 0.7);
        bottom.setAttribute("ry", size * 0.25);
        g.appendChild(bottom);
        const mid1 = document.createElementNS(ns, "ellipse");
        mid1.setAttribute("cx", 0);
        mid1.setAttribute("cy", -size * 0.15);
        mid1.setAttribute("rx", size * 0.7);
        mid1.setAttribute("ry", size * 0.2);
        mid1.style.fill = "none";
        mid1.style.stroke = "#475569";
        mid1.style.strokeWidth = "2";
        g.appendChild(mid1);
        const mid2 = document.createElementNS(ns, "ellipse");
        mid2.setAttribute("cx", 0);
        mid2.setAttribute("cy", size * 0.35);
        mid2.setAttribute("rx", size * 0.7);
        mid2.setAttribute("ry", size * 0.2);
        mid2.style.fill = "none";
        mid2.style.stroke = "#475569";
        mid2.style.strokeWidth = "2";
        g.appendChild(mid2);
        return g;
       }
       if (shape === "printer") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.4);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size * 0.9);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const trayTop = document.createElementNS(ns, "rect");
        trayTop.setAttribute("x", -size * 0.7);
        trayTop.setAttribute("y", -size * 0.8);
        trayTop.setAttribute("width", size * 1.4);
        trayTop.setAttribute("height", size * 0.4);
        trayTop.setAttribute("rx", 2);
        trayTop.style.fill = "#1e293b";
        g.appendChild(trayTop);
        const trayOut = document.createElementNS(ns, "rect");
        trayOut.setAttribute("x", -size * 0.6);
        trayOut.setAttribute("y", size * 0.5);
        trayOut.setAttribute("width", size * 1.2);
        trayOut.setAttribute("height", size * 0.35);
        trayOut.setAttribute("rx", 2);
        g.appendChild(trayOut);
        const paper = document.createElementNS(ns, "rect");
        paper.setAttribute("x", -size * 0.5);
        paper.setAttribute("y", size * 0.3);
        paper.setAttribute("width", size * 1);
        paper.setAttribute("height", size * 0.5);
        paper.style.fill = "#e2e8f0";
        g.appendChild(paper);
        return g;
       }
       if (shape === "access-point" || shape === "wifi") {
        const g = document.createElementNS(ns, "g");
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.3);
        base.setAttribute("y", size * 0.2);
        base.setAttribute("width", size * 0.6);
        base.setAttribute("height", size * 0.3);
        base.setAttribute("rx", 3);
        g.appendChild(base);
        for (let i = 1; i <= 3; i++) {
         const arc = document.createElementNS(ns, "path");
         const r = size * 0.3 * i;
         arc.setAttribute("d", `M ${-r * 0.7} ${size * 0.1 - r * 0.5} A ${r} ${r} 0 0 1 ${r * 0.7} ${size * 0.1 - r * 0.5}`);
         arc.style.fill = "none";
         arc.style.stroke = "currentColor";
         arc.style.strokeWidth = "2";
         arc.style.opacity = 1 - (i * 0.2);
         g.appendChild(arc);
        }
        return g;
       }
       if (shape === "load-balancer") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.5);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        const bar = document.createElementNS(ns, "line");
        bar.setAttribute("x1", -size * 0.6);
        bar.setAttribute("y1", 0);
        bar.setAttribute("x2", size * 0.6);
        bar.setAttribute("y2", 0);
        bar.style.stroke = "#4ade80";
        bar.style.strokeWidth = "3";
        g.appendChild(bar);
        [-1, 1].forEach(dir => {
         const arrow = document.createElementNS(ns, "path");
         arrow.setAttribute("d", `M ${dir * size * 0.3} ${-size * 0.2} L ${dir * size * 0.6} 0 L ${dir * size * 0.3} ${size * 0.2}`);
         arrow.style.fill = "none";
         arrow.style.stroke = "#4ade80";
         arrow.style.strokeWidth = "2";
         g.appendChild(arrow);
        });
        return g;
       }
       if (shape === "nas" || shape === "storage") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.8);
        body.setAttribute("y", -size * 0.9);
        body.setAttribute("width", size * 1.6);
        body.setAttribute("height", size * 1.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 4; i++) {
         const bay = document.createElementNS(ns, "rect");
         bay.setAttribute("x", -size * 0.6);
         bay.setAttribute("y", -size * 0.7 + i * size * 0.4);
         bay.setAttribute("width", size * 1.2);
         bay.setAttribute("height", size * 0.3);
         bay.setAttribute("rx", 2);
         bay.style.fill = "#1e293b";
         g.appendChild(bay);
        }
        return g;
       }
       if (shape === "gateway" || shape === "modem") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.5);
        body.setAttribute("y", -size * 0.9);
        body.setAttribute("width", size);
        body.setAttribute("height", size * 1.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 4; i++) {
         const led = document.createElementNS(ns, "circle");
         led.setAttribute("cx", 0);
         led.setAttribute("cy", -size * 0.6 + i * size * 0.35);
         led.setAttribute("r", size * 0.08);
         led.style.fill = ["#4ade80", "#4ade80", "#facc15", "#60a5fa"][i];
         g.appendChild(led);
        }
        return g;
       }
       if (shape === "vpn" || shape === "tunnel") {
        const g = document.createElementNS(ns, "g");
        const outer = document.createElementNS(ns, "ellipse");
        outer.setAttribute("cx", 0);
        outer.setAttribute("cy", 0);
        outer.setAttribute("rx", size);
        outer.setAttribute("ry", size * 0.6);
        g.appendChild(outer);
        const inner = document.createElementNS(ns, "ellipse");
        inner.setAttribute("cx", 0);
        inner.setAttribute("cy", 0);
        inner.setAttribute("rx", size * 0.5);
        inner.setAttribute("ry", size * 0.3);
        inner.style.fill = "#1e293b";
        g.appendChild(inner);
        const lock = document.createElementNS(ns, "rect");
        lock.setAttribute("x", -size * 0.15);
        lock.setAttribute("y", -size * 0.1);
        lock.setAttribute("width", size * 0.3);
        lock.setAttribute("height", size * 0.25);
        lock.setAttribute("rx", 2);
        lock.style.fill = "#4ade80";
        g.appendChild(lock);
        return g;
       }
       if (shape === "container") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.5);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 3; i++) {
         const block = document.createElementNS(ns, "rect");
         block.setAttribute("x", -size * 0.8 + i * size * 0.55);
         block.setAttribute("y", -size * 0.3);
         block.setAttribute("width", size * 0.45);
         block.setAttribute("height", size * 0.6);
         block.setAttribute("rx", 2);
         block.style.fill = "#1e293b";
         g.appendChild(block);
        }
        return g;
       }
       if (shape === "vm" || shape === "virtual") {
        const g = document.createElementNS(ns, "g");
        const shadow = document.createElementNS(ns, "rect");
        shadow.setAttribute("x", -size * 0.85 + 4);
        shadow.setAttribute("y", -size * 0.65 + 4);
        shadow.setAttribute("width", size * 1.7);
        shadow.setAttribute("height", size * 1.3);
        shadow.setAttribute("rx", 4);
        shadow.style.opacity = "0.3";
        g.appendChild(shadow);
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.85);
        body.setAttribute("y", -size * 0.65);
        body.setAttribute("width", size * 1.7);
        body.setAttribute("height", size * 1.3);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.65);
        screen.setAttribute("y", -size * 0.45);
        screen.setAttribute("width", size * 1.3);
        screen.setAttribute("height", size * 0.7);
        screen.setAttribute("rx", 2);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        return g;
       }
       if (shape === "kubernetes" || shape === "k8s") {
        const g = document.createElementNS(ns, "g");
        const outer = document.createElementNS(ns, "circle");
        outer.setAttribute("cx", 0);
        outer.setAttribute("cy", 0);
        outer.setAttribute("r", size);
        g.appendChild(outer);
        const inner = document.createElementNS(ns, "circle");
        inner.setAttribute("cx", 0);
        inner.setAttribute("cy", 0);
        inner.setAttribute("r", size * 0.4);
        inner.style.fill = "#1e293b";
        g.appendChild(inner);
        for (let i = 0; i < 7; i++) {
         const angle = (Math.PI * 2 / 7) * i - Math.PI / 2;
         const spoke = document.createElementNS(ns, "line");
         spoke.setAttribute("x1", Math.cos(angle) * size * 0.4);
         spoke.setAttribute("y1", Math.sin(angle) * size * 0.4);
         spoke.setAttribute("x2", Math.cos(angle) * size * 0.85);
         spoke.setAttribute("y2", Math.sin(angle) * size * 0.85);
         spoke.style.stroke = "#326ce5";
         spoke.style.strokeWidth = "3";
         g.appendChild(spoke);
        }
        return g;
       }
       if (shape === "shield" || shape === "security") {
        const p = document.createElementNS(ns, "path");
        const s = size;
        p.setAttribute("d", `M 0 ${-s} L ${s * 0.85} ${-s * 0.5} L ${s * 0.85} ${s * 0.2} Q ${s * 0.7} ${s * 0.9} 0 ${s} Q ${-s * 0.7} ${s * 0.9} ${-s * 0.85} ${s * 0.2} L ${-s * 0.85} ${-s * 0.5} Z`);
        return p;
       }
       if (shape === "camera" || shape === "cctv") {
        const g = document.createElementNS(ns, "g");
        const mount = document.createElementNS(ns, "rect");
        mount.setAttribute("x", -size * 1.1);
        mount.setAttribute("y", -size * 0.5);
        mount.setAttribute("width", size * 0.25);
        mount.setAttribute("height", size * 0.6);
        mount.setAttribute("rx", 2);
        g.appendChild(mount);
        const arm = document.createElementNS(ns, "rect");
        arm.setAttribute("x", -size * 0.9);
        arm.setAttribute("y", -size * 0.15);
        arm.setAttribute("width", size * 0.5);
        arm.setAttribute("height", size * 0.15);
        g.appendChild(arm);
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.45);
        body.setAttribute("y", -size * 0.35);
        body.setAttribute("width", size * 1.1);
        body.setAttribute("height", size * 0.7);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const lensHousing = document.createElementNS(ns, "circle");
        lensHousing.setAttribute("cx", size * 0.85);
        lensHousing.setAttribute("cy", 0);
        lensHousing.setAttribute("r", size * 0.4);
        g.appendChild(lensHousing);
        const lensOuter = document.createElementNS(ns, "circle");
        lensOuter.setAttribute("cx", size * 0.85);
        lensOuter.setAttribute("cy", 0);
        lensOuter.setAttribute("r", size * 0.28);
        lensOuter.style.fill = "#1e293b";
        g.appendChild(lensOuter);
        const lensInner = document.createElementNS(ns, "circle");
        lensInner.setAttribute("cx", size * 0.85);
        lensInner.setAttribute("cy", 0);
        lensInner.setAttribute("r", size * 0.15);
        lensInner.style.fill = "#3b82f6";
        g.appendChild(lensInner);
        const reflection = document.createElementNS(ns, "circle");
        reflection.setAttribute("cx", size * 0.8);
        reflection.setAttribute("cy", -size * 0.05);
        reflection.setAttribute("r", size * 0.05);
        reflection.style.fill = "#93c5fd";
        g.appendChild(reflection);
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", -size * 0.2);
        led.setAttribute("cy", -size * 0.15);
        led.setAttribute("r", size * 0.06);
        led.style.fill = "#ef4444";
        g.appendChild(led);
        return g;
       }
       if (shape === "monitor" || shape === "dashboard") {
        const g = document.createElementNS(ns, "g");
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size);
        screen.setAttribute("y", -size * 0.7);
        screen.setAttribute("width", size * 2);
        screen.setAttribute("height", size * 1.2);
        screen.setAttribute("rx", 4);
        g.appendChild(screen);
        const graph = document.createElementNS(ns, "polyline");
        graph.setAttribute("points", `${-size * 0.8},${size * 0.2} ${-size * 0.3},${-size * 0.2} ${size * 0.2},${size * 0.1} ${size * 0.7},${-size * 0.3}`);
        graph.style.fill = "none";
        graph.style.stroke = "#4ade80";
        graph.style.strokeWidth = "3";
        g.appendChild(graph);
        return g;
       }
       if (shape === "docker" || shape === "whale") {
        const g = document.createElementNS(ns, "g");
        const s = size;
        const body = document.createElementNS(ns, "path");
        body.setAttribute("d", `
         M ${-s * 0.9} ${s * 0.2}
         Q ${-s * 1.1} ${s * 0.5} ${-s * 0.7} ${s * 0.7}
         Q ${-s * 0.3} ${s * 0.85} ${s * 0.3} ${s * 0.75}
         Q ${s * 0.8} ${s * 0.6} ${s * 1.0} ${s * 0.3}
         Q ${s * 1.1} ${s * 0.1} ${s * 1.0} ${-s * 0.1}
         L ${s * 0.85} ${-s * 0.1}
         Q ${s * 0.7} ${-s * 0.15} ${s * 0.4} ${-s * 0.2}
         L ${-s * 0.5} ${-s * 0.2}
         Q ${-s * 0.8} ${-s * 0.1} ${-s * 0.9} ${s * 0.2}
         Z
        `);
        body.style.fill = "#0db7ed";
        g.appendChild(body);
        const tail = document.createElementNS(ns, "path");
        tail.setAttribute("d", `
         M ${-s * 0.85} ${s * 0.1}
         Q ${-s * 1.2} ${-s * 0.2} ${-s * 1.0} ${-s * 0.55}
         Q ${-s * 0.95} ${-s * 0.35} ${-s * 0.8} ${-s * 0.15}
         Z
        `);
        tail.style.fill = "#0db7ed";
        g.appendChild(tail);
        const belly = document.createElementNS(ns, "path");
        belly.setAttribute("d", `
         M ${-s * 0.5} ${s * 0.65}
         Q ${s * 0.1} ${s * 0.75} ${s * 0.6} ${s * 0.55}
         Q ${s * 0.8} ${s * 0.45} ${s * 0.9} ${s * 0.25}
         Q ${s * 0.7} ${s * 0.5} ${s * 0.3} ${s * 0.6}
         Q ${-s * 0.1} ${s * 0.7} ${-s * 0.5} ${s * 0.65}
         Z
        `);
        belly.style.fill = "#ffffff";
        belly.style.opacity = "0.3";
        g.appendChild(belly);
        for (let row = 0; row < 2; row++) {
         for (let col = 0; col < 3; col++) {
          const container = document.createElementNS(ns, "rect");
          container.setAttribute("x", -s * 0.45 + col * s * 0.35);
          container.setAttribute("y", -s * 0.7 + row * s * 0.28);
          container.setAttribute("width", s * 0.3);
          container.setAttribute("height", s * 0.23);
          container.setAttribute("rx", 2);
          container.style.fill = "#0db7ed";
          container.style.stroke = "#0a9ed8";
          container.style.strokeWidth = "1.5";
          g.appendChild(container);
         }
        }
        const topContainer = document.createElementNS(ns, "rect");
        topContainer.setAttribute("x", -s * 0.1);
        topContainer.setAttribute("y", -s * 0.95);
        topContainer.setAttribute("width", s * 0.3);
        topContainer.setAttribute("height", s * 0.23);
        topContainer.setAttribute("rx", 2);
        topContainer.style.fill = "#0db7ed";
        topContainer.style.stroke = "#0a9ed8";
        topContainer.style.strokeWidth = "1.5";
        g.appendChild(topContainer);
        const eye = document.createElementNS(ns, "circle");
        eye.setAttribute("cx", s * 0.65);
        eye.setAttribute("cy", s * 0.25);
        eye.setAttribute("r", s * 0.08);
        eye.style.fill = "#0a5f7a";
        g.appendChild(eye);
        return g;
       }
       if (shape === "rounded-square") {
        const r = document.createElementNS(ns, "rect");
        const s = size * 1.6;
        r.setAttribute("x", -s / 2);
        r.setAttribute("y", -s / 2);
        r.setAttribute("width", s);
        r.setAttribute("height", s);
        r.setAttribute("rx", size * 0.4);
        return r;
       }
       if (shape === "pill" || shape === "capsule") {
        const r = document.createElementNS(ns, "rect");
        r.setAttribute("x", -size * 1.2);
        r.setAttribute("y", -size * 0.5);
        r.setAttribute("width", size * 2.4);
        r.setAttribute("height", size);
        r.setAttribute("rx", size * 0.5);
        return r;
       }
       if (shape === "octagon") {
        const p = document.createElementNS(ns, "polygon");
        const r = size;
        const pts = [];
        for (let i = 0; i < 8; i++) {
         const a = (Math.PI / 4) * i - Math.PI / 8;
         pts.push([Math.cos(a) * r, Math.sin(a) * r]);
        }
        p.setAttribute("points", pts.map(pt => pt.join(",")).join(" "));
        return p;
       }
       if (shape === "pentagon") {
        const p = document.createElementNS(ns, "polygon");
        const pts = [];
        for (let i = 0; i < 5; i++) {
         const a = (Math.PI * 2 / 5) * i - Math.PI / 2;
         pts.push([Math.cos(a) * size, Math.sin(a) * size]);
        }
        p.setAttribute("points", pts.map(pt => pt.join(",")).join(" "));
        return p;
       }
       if (shape === "cross" || shape === "plus") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        const t = size * 0.35;
        p.setAttribute("points", `${-t},${-s} ${t},${-s} ${t},${-t} ${s},${-t} ${s},${t} ${t},${t} ${t},${s} ${-t},${s} ${-t},${t} ${-s},${t} ${-s},${-t} ${-t},${-t}`);
        return p;
       }
       if (shape === "parallelogram") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `${-s * 0.6},${-s * 0.6} ${s * 1.2},${-s * 0.6} ${s * 0.6},${s * 0.6} ${-s * 1.2},${s * 0.6}`);
        return p;
       }
       if (shape === "trapezoid") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `${-s * 0.6},${-s * 0.6} ${s * 0.6},${-s * 0.6} ${s},${s * 0.6} ${-s},${s * 0.6}`);
        return p;
       }
       if (shape === "sensor" || shape === "iot") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "circle");
        body.setAttribute("cx", 0);
        body.setAttribute("cy", 0);
        body.setAttribute("r", size * 0.7);
        g.appendChild(body);
        const ant = document.createElementNS(ns, "line");
        ant.setAttribute("x1", 0);
        ant.setAttribute("y1", -size * 0.7);
        ant.setAttribute("x2", 0);
        ant.setAttribute("y2", -size);
        ant.style.stroke = "currentColor";
        ant.style.strokeWidth = "2";
        g.appendChild(ant);
        const tip = document.createElementNS(ns, "circle");
        tip.setAttribute("cx", 0);
        tip.setAttribute("cy", -size);
        tip.setAttribute("r", size * 0.1);
        tip.style.fill = "#4ade80";
        g.appendChild(tip);
        return g;
       }
       if (shape === "pi" || shape === "sbc" || shape === "raspberry") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.65);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size * 1.3);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 10; i++) {
         const pin = document.createElementNS(ns, "rect");
         pin.setAttribute("x", -size * 0.85 + i * size * 0.19);
         pin.setAttribute("y", -size * 0.8);
         pin.setAttribute("width", size * 0.08);
         pin.setAttribute("height", size * 0.15);
         pin.style.fill = "#facc15";
         g.appendChild(pin);
        }
        const port = document.createElementNS(ns, "rect");
        port.setAttribute("x", size * 0.6);
        port.setAttribute("y", -size * 0.2);
        port.setAttribute("width", size * 0.35);
        port.setAttribute("height", size * 0.4);
        port.style.fill = "#1e293b";
        g.appendChild(port);
        return g;
       }
       if (shape === "api" || shape === "endpoint") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.9);
        body.setAttribute("y", -size * 0.7);
        body.setAttribute("width", size * 1.8);
        body.setAttribute("height", size * 1.4);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        const left = document.createElementNS(ns, "text");
        left.setAttribute("x", -size * 0.5);
        left.setAttribute("y", size * 0.15);
        left.setAttribute("font-size", size * 0.9);
        left.setAttribute("fill", "#4ade80");
        left.setAttribute("font-family", "monospace");
        left.textContent = "{";
        g.appendChild(left);
        const right = document.createElementNS(ns, "text");
        right.setAttribute("x", size * 0.15);
        right.setAttribute("y", size * 0.15);
        right.setAttribute("font-size", size * 0.9);
        right.setAttribute("fill", "#4ade80");
        right.setAttribute("font-family", "monospace");
        right.textContent = "}";
        g.appendChild(right);
        return g;
       }
       if (shape === "queue" || shape === "message") {
        const g = document.createElementNS(ns, "g");
        for (let i = 2; i >= 0; i--) {
         const card = document.createElementNS(ns, "rect");
         card.setAttribute("x", -size * 0.7 + i * 4);
         card.setAttribute("y", -size * 0.5 + i * 4);
         card.setAttribute("width", size * 1.4);
         card.setAttribute("height", size * 0.8);
         card.setAttribute("rx", 3);
         card.style.opacity = 1 - i * 0.25;
         g.appendChild(card);
        }
        return g;
       }
       if (shape === "lambda" || shape === "function") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.8);
        body.setAttribute("y", -size * 0.8);
        body.setAttribute("width", size * 1.6);
        body.setAttribute("height", size * 1.6);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const lambda = document.createElementNS(ns, "text");
        lambda.setAttribute("x", 0);
        lambda.setAttribute("y", size * 0.2);
        lambda.setAttribute("font-size", size * 1.2);
        lambda.setAttribute("fill", "#f59e0b");
        lambda.setAttribute("text-anchor", "middle");
        lambda.setAttribute("font-family", "serif");
        lambda.textContent = "Œª";
        g.appendChild(lambda);
        return g;
       }
       if (shape === "bucket" || shape === "s3") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "path");
        body.setAttribute("d", `M ${-size * 0.8} ${-size * 0.7} L ${-size * 0.6} ${size * 0.8} Q ${-size * 0.5} ${size} 0 ${size} Q ${size * 0.5} ${size} ${size * 0.6} ${size * 0.8} L ${size * 0.8} ${-size * 0.7} Z`);
        g.appendChild(body);
        const rim = document.createElementNS(ns, "ellipse");
        rim.setAttribute("cx", 0);
        rim.setAttribute("cy", -size * 0.7);
        rim.setAttribute("rx", size * 0.8);
        rim.setAttribute("ry", size * 0.25);
        g.appendChild(rim);
        return g;
       }
       const c = document.createElementNS(ns, "circle");
       c.setAttribute("r", size);
       return c;
      }
      function createNodeShape(id, size) {
       const styles = resolveStylesForNode(id);
       if (styles.icon && styles.icon.library && styles.icon.name) {
        const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
        g.classList.add("node-circle");
        IconLibrary.getIcon(styles.icon.library, styles.icon.name).then(svgText => {
         if (svgText) {
          const parser = new DOMParser();
          const doc = parser.parseFromString(svgText, 'image/svg+xml');
          const svgEl = doc.querySelector('svg');
          if (svgEl) {
           svgEl.setAttribute('width', size * 1.2);
           svgEl.setAttribute('height', size * 1.2);
           svgEl.setAttribute('x', -size * 0.6);
           svgEl.setAttribute('y', -size * 0.6);
           if (styles.circleColor) {
            svgEl.style.fill = styles.circleColor;
            svgEl.querySelectorAll('path, circle, rect, polygon, ellipse').forEach(el => {
             el.style.fill = styles.circleColor;
            });
           }
           if (styles.circleBorder) {
            svgEl.style.stroke = styles.circleBorder;
            svgEl.querySelectorAll('path, circle, rect, polygon, ellipse').forEach(el => {
             el.style.stroke = styles.circleBorder;
            });
           }
           g.innerHTML = svgEl.outerHTML;
          }
         }
        });
        return g;
       }
       const shapeType = (NODE_DATA[id] && NODE_DATA[id].shape) || "circle";
       const shapeEl = createShapeElement(shapeType, size);
       shapeEl.classList.add("node-circle");
       shapeEl.style.fill = styles.circleColor || PAGE_STATE.nodeFill || "#1e293b";
       shapeEl.style.stroke = styles.circleBorder || PAGE_STATE.nodeStroke || "#475569";
       return shapeEl;
      }
      function forgeTheLegend() {
       const container = document.getElementById("edge-legend");
       if (!container) return;
       container.innerHTML = "";
       const title = document.createElement("div");
       title.className = "legend-title";
       title.textContent = "Line Legend";
       container.appendChild(title);
       const closeBtn = document.createElement("button");
       closeBtn.type = "button";
       closeBtn.className = "legend-close-btn";
       closeBtn.textContent = "‚úï";
       closeBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        legendCollapsed = true;
        updateLegendVisibility();
       });
       container.appendChild(closeBtn);
       const colors = [...new Set(EDGE_DATA.list.map((e) => e.color).filter(Boolean))];
       if (colors.length === 0) {
        updateLegendVisibility();
        return;
       }
       colors.forEach((color) => {
         if (!EDGE_LEGEND[color]) {
          EDGE_LEGEND[color] = "you can edit me too";
         }
         const item = document.createElement("div");
         item.className = "legend-item";
         item.addEventListener("mousedown", (e) => e.stopPropagation());
         item.addEventListener("click", (e) => e.stopPropagation());
         const swatch = document.createElement("span");
         swatch.className = "legend-swatch";
         swatch.style.backgroundColor = color;
         swatch.style.cursor = "pointer";
         swatch.addEventListener("click", (e) => {
          e.stopPropagation();
          const edgeWithColor = EDGE_DATA.list.find(edge => edge.color === color);
          if (edgeWithColor) {
           selectTheConnection(edgeWithColor.id);
          }
         });
         let swatchTouchStart = null;
         let swatchTouchMoved = false;
         swatch.addEventListener("touchstart", (e) => {
         swatchTouchStart = Date.now();
         swatchTouchMoved = false;
         if (e.touches[0]) {
          swatchTouchStartX = e.touches[0].clientX;
          swatchTouchStartY = e.touches[0].clientY;
         }
        }, {
          passive: false
         });
         let swatchTouchStartX = 0, swatchTouchStartY = 0;
        swatch.addEventListener("touchmove", (e) => {
         if (e.touches[0]) {
          const dx = Math.abs(e.touches[0].clientX - swatchTouchStartX);
          const dy = Math.abs(e.touches[0].clientY - swatchTouchStartY);
          if (dx > 10 || dy > 10) swatchTouchMoved = true;
         }
        }, {
          passive: false
         });
         swatch.addEventListener("touchend", (e) => {
          if (swatchTouchStart && !swatchTouchMoved && Date.now() - swatchTouchStart < 400) {
           e.stopPropagation();
           e.preventDefault();
           const edgeWithColor = EDGE_DATA.list.find(edge => edge.color === color);
           if (edgeWithColor) {
            selectTheConnection(edgeWithColor.id);
           }
          }
          swatchTouchStart = null;
          swatchTouchMoved = false;
         }, {
          passive: false
         });
        const label = document.createElement("span");
        label.className = "legend-label";
        label.textContent = EDGE_LEGEND[color];
        if (isMobileDevice()) {
         label.style.cursor = "pointer";
         let labelTapStart = null;
         let labelTapMoved = false;
         label.addEventListener("touchstart", (e) => {
          labelTapStart = Date.now();
          labelTapMoved = false;
          if (e.touches[0]) {
           labelTapStartX = e.touches[0].clientX;
           labelTapStartY = e.touches[0].clientY;
          }
          e.stopPropagation();
         });
         let labelTapStartX = 0, labelTapStartY = 0;
         label.addEventListener("touchmove", (e) => {
          if (e.touches[0]) {
           const dx = Math.abs(e.touches[0].clientX - labelTapStartX);
           const dy = Math.abs(e.touches[0].clientY - labelTapStartY);
           if (dx > 10 || dy > 10) labelTapMoved = true;
          }
         });
         label.addEventListener("touchend", (e) => {
          if (labelTapStart && !labelTapMoved && Date.now() - labelTapStart < 400) {
           e.preventDefault();
           e.stopPropagation();
           const currentText = label.textContent;
           const newText = prompt("Edit legend label:", currentText);
           if (newText !== null && newText.trim()) {
            label.textContent = newText.trim();
            EDGE_LEGEND[color] = newText.trim();
           }
          }
          labelTapStart = null;
          labelTapMoved = false;
         });
        } else {
           label.contentEditable = true;
           label.addEventListener("focus", () => {
            label.classList.add("editing");
           });
           label.addEventListener("blur", () => {
            label.classList.remove("editing");
            const text = label.textContent.trim() || "you can edit me too";
            EDGE_LEGEND[color] = text;
           });
           label.addEventListener("keydown", (e) => {
            if (e.key === "Enter") {
             e.preventDefault();
             label.blur();
            }
           });
          }
          item.append(swatch, label); container.appendChild(item);
         }); updateLegendVisibility();
       }
       function deleteRectangle(rectId) {
      pushUndo("delete zone");
        RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== rectId);
        forgeTheTopology();
       }
       function updateRectangleDeleteButtons() {
        const deleteButtons = document.querySelectorAll('.rect-delete-btn');
        deleteButtons.forEach(btn => {
         btn.style.display = rectDrawMode ? 'block' : 'none';
        });
       }
       function forgeTheTopology() {
        if (!NODE_DATA || !EDGE_DATA) {
         console.warn("forgeTheTopology called before data initialized");
         return;
        }
        const svg = document.getElementById("map");
        svg.innerHTML = "";
        const ns = "http://www.w3.org/2000/svg";
        const defs = document.createElementNS(ns, "defs");
        const markerForward = document.createElementNS(ns, "marker");
        markerForward.id = "arrow-forward";
        markerForward.setAttribute("markerWidth", "10");
        markerForward.setAttribute("markerHeight", "10");
        markerForward.setAttribute("refX", "9");
        markerForward.setAttribute("refY", "3");
        markerForward.setAttribute("orient", "auto");
        markerForward.setAttribute("markerUnits", "strokeWidth");
        const pathForward = document.createElementNS(ns, "path");
        pathForward.setAttribute("d", "M0,0 L0,6 L9,3 z");
        pathForward.setAttribute("fill", "context-stroke");
        markerForward.appendChild(pathForward);
        defs.appendChild(markerForward);
        const markerBackward = document.createElementNS(ns, "marker");
        markerBackward.id = "arrow-backward";
        markerBackward.setAttribute("markerWidth", "10");
        markerBackward.setAttribute("markerHeight", "10");
        markerBackward.setAttribute("refX", "0");
        markerBackward.setAttribute("refY", "3");
        markerBackward.setAttribute("orient", "auto");
        markerBackward.setAttribute("markerUnits", "strokeWidth");
        const pathBackward = document.createElementNS(ns, "path");
        pathBackward.setAttribute("d", "M9,0 L9,6 L0,3 z");
        pathBackward.setAttribute("fill", "context-stroke");
        markerBackward.appendChild(pathBackward);
        defs.appendChild(markerBackward);
        svg.appendChild(defs);
        const boundary = document.createElementNS(ns, "rect");
        boundary.setAttribute("x", CANVAS_PADDING);
        boundary.setAttribute("y", CANVAS_PADDING);
        boundary.setAttribute("width", CANVAS_WIDTH - CANVAS_PADDING * 2);
        boundary.setAttribute("height", CANVAS_HEIGHT - CANVAS_PADDING * 2);
        boundary.setAttribute("fill", "none");
        boundary.setAttribute("stroke", (PAGE_STATE.canvasBorder || "#475569") + "4D");
        boundary.setAttribute("stroke-width", "20");
        boundary.setAttribute("stroke-dasharray", "10 5");
        boundary.setAttribute("rx", "8");
        svg.appendChild(boundary);
       if (currentView.mode !== "rack") {
        const gridGroup = document.createElementNS(ns, "g");
        gridGroup.id = "canvas-grid";
        const gridSize = PAGE_STATE.canvasGridSize || 50;
        const gridColor = (PAGE_STATE.canvasGrid || "#475569") + "33";
        const majorGridColor = (PAGE_STATE.canvasGrid || "#475569") + "66";
        for (let x = CANVAS_PADDING; x <= CANVAS_WIDTH - CANVAS_PADDING; x += gridSize) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", x);
         line.setAttribute("y1", CANVAS_PADDING);
         line.setAttribute("x2", x);
         line.setAttribute("y2", CANVAS_HEIGHT - CANVAS_PADDING);
         line.setAttribute("stroke", (x - CANVAS_PADDING) % (gridSize * 5) === 0 ? majorGridColor : gridColor);
         line.setAttribute("stroke-width", (x - CANVAS_PADDING) % (gridSize * 5) === 0 ? "2" : "1");
         gridGroup.appendChild(line);
        }
        for (let y = CANVAS_PADDING; y <= CANVAS_HEIGHT - CANVAS_PADDING; y += gridSize) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", CANVAS_PADDING);
         line.setAttribute("y1", y);
         line.setAttribute("x2", CANVAS_WIDTH - CANVAS_PADDING);
         line.setAttribute("y2", y);
         line.setAttribute("stroke", (y - CANVAS_PADDING) % (gridSize * 5) === 0 ? majorGridColor : gridColor);
         line.setAttribute("stroke-width", (y - CANVAS_PADDING) % (gridSize * 5) === 0 ? "2" : "1");
         gridGroup.appendChild(line);
        }
        svg.appendChild(gridGroup);
       }
       if (currentView.mode === "rack" && currentView.rackId) {
         const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
         const rackGroup = document.createElementNS(ns, "g");
         rackGroup.id = "rack-visualization";
         const rackFrame = document.createElementNS(ns, "rect");
         rackFrame.setAttribute("x", RACK_START_X - RACK_WIDTH / 2);
         rackFrame.setAttribute("y", RACK_START_Y);
         rackFrame.setAttribute("width", RACK_WIDTH);
         rackFrame.setAttribute("height", rackCapacity * rackUHeight);
         rackFrame.setAttribute("fill", (PAGE_STATE.rackFrameFill || "#0f172a") + "4D");
         rackFrame.setAttribute("stroke", PAGE_STATE.rackFrameStroke || "#4fd1c5");
         rackFrame.setAttribute("stroke-width", "3");
         rackFrame.setAttribute("rx", "4");
         rackGroup.appendChild(rackFrame);
         for (let u = 0; u <= rackCapacity; u++) {
          const y = RACK_START_Y + u * rackUHeight;
          const line = document.createElementNS(ns, "line");
          line.setAttribute("x1", RACK_START_X - RACK_WIDTH / 2);
          line.setAttribute("y1", y);
          line.setAttribute("x2", RACK_START_X + RACK_WIDTH / 2);
          line.setAttribute("y2", y);
          line.setAttribute("stroke", (PAGE_STATE.rackLineColor || "#475569") + "66");
          line.setAttribute("stroke-width", u % 5 === 0 ? "2" : "1");
          line.setAttribute("stroke-dasharray", u % 5 === 0 ? "none" : "5,5");
          rackGroup.appendChild(line);
          if (u < rackCapacity) {
           const uNumber = rackCapacity - u;
           const text = document.createElementNS(ns, "text");
           text.setAttribute("x", RACK_START_X - RACK_WIDTH / 2 - 30);
           text.setAttribute("y", y + rackUHeight / 2);
           text.setAttribute("text-anchor", "middle");
           text.setAttribute("dominant-baseline", "middle");
           text.style.fill = PAGE_STATE.rackTextColor || "#4fd1c5";
           text.style.fontSize = "14px";
           text.style.fontWeight = "bold";
           text.textContent = `U${uNumber}`;
           rackGroup.appendChild(text);
           const textRight = document.createElementNS(ns, "text");
           textRight.setAttribute("x", RACK_START_X + RACK_WIDTH / 2 + 30);
           textRight.setAttribute("y", y + rackUHeight / 2);
           textRight.setAttribute("text-anchor", "middle");
           textRight.setAttribute("dominant-baseline", "middle");
           textRight.style.fill = PAGE_STATE.rackTextColor || "#4fd1c5";
           textRight.style.fontSize = "14px";
           textRight.style.fontWeight = "bold";
           textRight.textContent = `U${uNumber}`;
           rackGroup.appendChild(textRight);
          }
         }
         svg.appendChild(rackGroup);
        }
        const centerX = CANVAS_WIDTH / 2;
        if (RECT_DATA && RECT_DATA.list) {
         RECT_DATA.list.forEach((rect) => {
          if (currentView.mode === "rack") return;
          if (rect.style === "filled") {
           const g = document.createElementNS(ns, "g");
           g.classList.add("rect-group");
           g.dataset.rectId = rect.id;
           const rectEl = document.createElementNS(ns, "rect");
           rectEl.classList.add("rect-shape");
           rectEl.setAttribute("x", rect.x);
           rectEl.setAttribute("y", rect.y);
           rectEl.setAttribute("width", rect.width);
           rectEl.setAttribute("height", rect.height);
           rectEl.style.fill = rect.color;
           rectEl.style.fillOpacity = "0.3";
           rectEl.style.stroke = rect.borderColor || rect.color;
           rectEl.style.strokeWidth = (rect.borderWidth !== undefined ? rect.borderWidth : 2) + "px";
           if (rect.lineStyle === "dashed") { rectEl.style.strokeDasharray = "10,5"; }
           else if (rect.lineStyle === "dotted") { rectEl.style.strokeDasharray = "2,4"; }
           else { rectEl.style.strokeDasharray = "none"; }
           rectEl.style.cursor = "move";
           rectEl.addEventListener("click", (e) => {
		   if (isViewOnly()) return;
             if (rectDrawMode) return;
             e.stopPropagation();
             currentRectId = rect.id;
             selectTheRect(rect.id);
           });
           rectEl.addEventListener("contextmenu", (e) => {
		    if (isViewOnly()) return;
             e.preventDefault();
             e.stopPropagation();
             if (selectedRects.has(rect.id)) {
               selectedRects.delete(rect.id);
             } else {
               selectedRects.add(rect.id);
             }
             updateAllSelections();
           });
           let rectLastTap = 0;
           rectEl.addEventListener("touchend", (e) => {
             const now = Date.now();
             if (now - rectLastTap < 300) {
               e.preventDefault();
               if (selectedRects.has(rect.id)) {
                 selectedRects.delete(rect.id);
               } else {
                 selectedRects.add(rect.id);
               }
               updateAllSelections();
               if (navigator.vibrate) navigator.vibrate(50);
               rectLastTap = 0;
             } else {
               rectLastTap = now;
             }
           }, { passive: false });
           const deleteBtn = document.createElementNS(ns, "g");
           deleteBtn.classList.add("rect-delete-btn");
           deleteBtn.style.cursor = "pointer";
           deleteBtn.style.display = rectDrawMode ? "block" : "none";
           const deleteBg = document.createElementNS(ns, "circle");
           deleteBg.setAttribute("cx", rect.x + rect.width - 10);
           deleteBg.setAttribute("cy", rect.y + 10);
           deleteBg.setAttribute("r", 12);
           deleteBg.style.fill = "#f56565";
           deleteBg.style.stroke = "white";
           deleteBg.style.strokeWidth = "2";
           const deleteX = document.createElementNS(ns, "text");
           deleteX.setAttribute("x", rect.x + rect.width - 10);
           deleteX.setAttribute("y", rect.y + 10);
           deleteX.setAttribute("text-anchor", "middle");
           deleteX.setAttribute("dominant-baseline", "middle");
           deleteX.style.fill = "white";
           deleteX.style.fontSize = "16px";
           deleteX.style.fontWeight = "bold";
           deleteX.style.pointerEvents = "none";
           deleteX.textContent = "√ó";
           deleteBtn.appendChild(deleteBg);
           deleteBtn.appendChild(deleteX);
           deleteBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            e.preventDefault();
            deleteRectangle(rect.id);
           });
           deleteBtn.addEventListener("touchend", (e) => {
      e.stopPropagation();
           e.preventDefault();
           deleteRectangle(rect.id);
           });
           let isDragging = false;
           let dragStartX, dragStartY;
           let rectStartX, rectStartY;
           rectEl.addEventListener("mousedown", (e) => {
      if (rectDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      rectStartX = rect.x;
      rectStartY = rect.y;
      rectEl.style.cursor = "grabbing";
      if (selectedRects.has(rect.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
      const moveHandler = (e) => {
      if (!isDragging || rectDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      rect.x = rectStartX + dx;
      rect.y = rectStartY + dy;
      if (selectedRects.has(rect.id)) {
      selectedNodes.forEach(nodeId => { if (initialPositions[nodeId]) { savedPositions[nodeId] = { x: initialPositions[nodeId].x + dx, y: initialPositions[nodeId].y + dy }; } });
      selectedRects.forEach(rectId => { if (rectId === rect.id) return; const r = RECT_DATA.list.find(x => x.id === rectId); if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; } });
      selectedTexts.forEach(textId => { const t = TEXT_DATA.list.find(x => x.id === textId); if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; } });
      selectedEdges.forEach(edgeId => { const ed = EDGE_DATA.list.find(x => x.id === edgeId); if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); } });
      }
      forgeTheTopology();
      };
           const upHandler = () => {
            if (isDragging) {
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           };
           document.addEventListener("mousemove", moveHandler);
           document.addEventListener("mouseup", upHandler);
           let touchStartX, touchStartY;
           let touchRectStartX, touchRectStartY;
           rectEl.addEventListener("touchstart", (e) => {
		   if (isViewOnly()) return;
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchRectStartX = rect.x;
            touchRectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           }, { passive: false });
           rectEl.addEventListener("touchmove", (e) => {
		   if (isViewOnly()) return;
            if (!isDragging || rectDrawMode) return;
            if (!e.touches[0]) return;
            e.preventDefault();
            e.stopPropagation();
            const svgEl = svg;
            const pt1 = svgEl.createSVGPoint();
            pt1.x = touchStartX;
            pt1.y = touchStartY;
            const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
            const touch = e.touches[0];
            const pt2 = svgEl.createSVGPoint();
            pt2.x = touch.clientX;
            pt2.y = touch.clientY;
            const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
            const dx = svgP2.x - svgP1.x;
            const dy = svgP2.y - svgP1.y;
            rect.x = touchRectStartX + dx;
            rect.y = touchRectStartY + dy;
            forgeTheTopology();
           }, { passive: false });
           rectEl.addEventListener("touchend", (e) => {
            if (isDragging) {
             e.preventDefault();
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           }, { passive: false });
            if (currentRectId === rect.id) {
      const corners = [
      { cx: rect.x, cy: rect.y, cursor: 'nwse-resize', dx: -1, dy: -1 },
      { cx: rect.x + rect.width, cy: rect.y, cursor: 'nesw-resize', dx: 1, dy: -1 },
      { cx: rect.x, cy: rect.y + rect.height, cursor: 'nesw-resize', dx: -1, dy: 1 },
      { cx: rect.x + rect.width, cy: rect.y + rect.height, cursor: 'nwse-resize', dx: 1, dy: 1 }
      ];
      corners.forEach((corner, idx) => {
      const handle = document.createElementNS(ns, "circle");
      handle.setAttribute("cx", corner.cx);
      handle.setAttribute("cy", corner.cy);
      handle.setAttribute("r", 8);
      handle.style.fill = "#f59e0b";
      handle.style.stroke = "#fff";
      handle.style.strokeWidth = "2";
      handle.style.cursor = corner.cursor;
      handle.addEventListener("mousedown", (e) => {
      e.preventDefault();
      e.stopPropagation();
	  pushUndo("resize zone");
      let dragging = true;
      const startX = e.clientX, startY = e.clientY;
      const origX = rect.x, origY = rect.y, origW = rect.width, origH = rect.height;
      const moveHandler = (ev) => {
        if (!dragging) return;
        const pt1 = svg.createSVGPoint(); pt1.x = startX; pt1.y = startY;
        const pt2 = svg.createSVGPoint(); pt2.x = ev.clientX; pt2.y = ev.clientY;
        const svgP1 = pt1.matrixTransform(svg.getScreenCTM().inverse());
        const svgP2 = pt2.matrixTransform(svg.getScreenCTM().inverse());
        const dx = svgP2.x - svgP1.x, dy = svgP2.y - svgP1.y;
        if (corner.dx < 0) { rect.x = origX + dx; rect.width = origW - dx; }
        else { rect.width = origW + dx; }
        if (corner.dy < 0) { rect.y = origY + dy; rect.height = origH - dy; }
        else { rect.height = origH + dy; }
        if (rect.width < 20) rect.width = 20;
        if (rect.height < 20) rect.height = 20;
        forgeTheTopology();
      };
      const upHandler = () => { dragging = false; document.removeEventListener("mousemove", moveHandler); document.removeEventListener("mouseup", upHandler); };
      document.addEventListener("mousemove", moveHandler);
      document.addEventListener("mouseup", upHandler);
      });
      g.appendChild(handle);
      });
      }
            if (rect.groupId) {
             const groupIndicator = document.createElementNS(ns, "rect");
             groupIndicator.setAttribute("x", rect.x - 4);
             groupIndicator.setAttribute("y", rect.y - 4);
             groupIndicator.setAttribute("width", rect.width + 8);
             groupIndicator.setAttribute("height", rect.height + 8);
             groupIndicator.style.fill = "none";
        groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
             groupIndicator.style.strokeWidth = "3";
             groupIndicator.style.strokeDasharray = "5,5";
             groupIndicator.style.pointerEvents = "none";
             g.insertBefore(groupIndicator, g.firstChild);
           }
           g.appendChild(rectEl);
           g.appendChild(deleteBtn);
           svg.appendChild(g);
          }
         });
        }
        const centerY = CANVAS_HEIGHT / 2;
        let positions = {};
        Object.keys(NODE_DATA).forEach((id) => {
         if (currentView.mode === "rack") {
          const node = NODE_DATA[id];
          if (!node || node.assignedRack !== currentView.rackId) {
           return;
          }
         }
         positions[id] = savedPositions[id] || {
          x: centerX,
          y: centerY
         };
        });
        if (Object.keys(savedPositions).length === 0) {
         const nodeIds = Object.keys(NODE_DATA).filter(id => {
          if (currentView.mode === "rack") {
           const node = NODE_DATA[id];
           return node && node.assignedRack === currentView.rackId;
          }
          return true;
         });
         const baseY = centerY - 300;
         if (nodeIds.length > 0) {
          positions[nodeIds[0]] = {
           x: centerX,
           y: baseY
          };
          const remaining = nodeIds.slice(1);
          const radius = 350;
          const startAngle = Math.PI * 0.3;
          const endAngle = Math.PI * 0.7;
          remaining.forEach((id, i) => {
           const angle = startAngle + (endAngle - startAngle) * (i / Math.max(1, remaining.length - 1));
           positions[id] = {
            x: centerX + Math.cos(angle) * radius * (i % 2 === 0 ? 1 : 1.3),
            y: baseY + 200 + Math.sin(angle) * radius * 0.8 + i * 80,
           };
          });
         }
        }
        Object.keys(positions).forEach((id) => {
         let pos = savedPositions[id] || positions[id];
         const nodeSize = savedSizes[id] || 55;
         pos.x = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, pos.x), );
         pos.y = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, pos.y), );
         positions[id] = {
          x: pos.x,
          y: pos.y
         };
         savedPositions[id] = {
          x: pos.x,
          y: pos.y
         };
        });
        const edgePairCount = {};
        const edgePairIndex = {};
        EDGE_DATA.list.forEach((edge) => {
         if (edge.type === "custom") return;
         const key = [edge.from, edge.to].sort().join("||");
         edgePairCount[key] = (edgePairCount[key] || 0) + 1;
        });
        EDGE_DATA.list.forEach((edge) => {
         if (edge.type === "custom") return;
         const key = [edge.from, edge.to].sort().join("||");
         if (!edgePairIndex[key]) edgePairIndex[key] = 0;
         edge._pairIndex = edgePairIndex[key];
         edge._pairTotal = edgePairCount[key];
         edgePairIndex[key]++;
        });
        EDGE_DATA.list.forEach((edge) => {
         if (edge.type === "custom" && Array.isArray(edge.points) && edge.points.length >= 2) {
          const customEdgeFaded = currentView.mode !== "rack" && edge.from && edge.to && (!isNodeVisible(edge.from) || !isNodeVisible(edge.to));
          const poly = document.createElementNS(ns, "polyline");
          poly.classList.add("edge");
          if (customEdgeFaded) {
           poly.style.opacity = "0.25";
           poly.classList.add("layer-faded");
          }
          poly.dataset.edgeId = edge.id;
poly.style.stroke = edge.color || PAGE_STATE.defaultEdge || "#475569";
          poly.style.strokeWidth = edge.width || 4;
          poly.setAttribute("fill", "none");
          const lineStyle = edge.lineStyle || "solid";
          if (lineStyle === "dashed") {
           poly.style.strokeDasharray = "10,5";
          } else if (lineStyle === "dotted") {
           poly.style.strokeDasharray = "2,4";
          } else {
           poly.style.strokeDasharray = "none";
          }
          const direction = edge.direction || "none";
          if (direction === "forward") {
           poly.setAttribute("marker-end", "url(#arrow-forward)");
          } else if (direction === "backward") {
           poly.setAttribute("marker-start", "url(#arrow-backward)");
          } else if (direction === "both") {
           poly.setAttribute("marker-start", "url(#arrow-backward)");
           poly.setAttribute("marker-end", "url(#arrow-forward)");
          }
          const ptsStr = edge.points.map((p) => `${p.x},${p.y}`).join(" ");
          poly.setAttribute("points", ptsStr);
          const polyHit = document.createElementNS(ns, "polyline");
          polyHit.setAttribute("points", ptsStr);
          polyHit.style.fill = "none";
          polyHit.style.stroke = "transparent";
          polyHit.style.strokeWidth = "20";
          polyHit.style.cursor = "pointer";
          polyHit.dataset.edgeId = edge.id;
          polyHit.addEventListener("click", (e) => {
           e.stopPropagation();
           selectTheConnection(edge.id);
          });
          let edgeTouchStart = null;
          let edgeTouchMoved = false;
          polyHit.addEventListener("touchstart", (e) => {
          edgeTouchStart = Date.now();
          edgeTouchMoved = false;
          if (e.touches[0]) {
           edgeTouchStartX = e.touches[0].clientX;
           edgeTouchStartY = e.touches[0].clientY;
          }
         }, {
           passive: false
          });
          let edgeTouchStartX = 0, edgeTouchStartY = 0;
         polyHit.addEventListener("touchmove", (e) => {
          if (e.touches[0]) {
           const dx = Math.abs(e.touches[0].clientX - edgeTouchStartX);
           const dy = Math.abs(e.touches[0].clientY - edgeTouchStartY);
           if (dx > 10 || dy > 10) edgeTouchMoved = true;
          }
         }, {
           passive: false
          });
          polyHit.addEventListener("touchend", (e) => {
           if (edgeTouchStart && !edgeTouchMoved && Date.now() - edgeTouchStart < 400) {
            e.stopPropagation();
            e.preventDefault();
            selectTheConnection(edge.id);
           }
           edgeTouchStart = null;
           edgeTouchMoved = false;
          }, {
           passive: false
          });
          poly.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         polyHit.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (selectedEdges.has(edge.id)) {
           selectedEdges.delete(edge.id);
          } else {
           selectedEdges.add(edge.id);
          }
          updateAllSelections();
         });
         let customEdgeLastTap = 0;
         polyHit.addEventListener("touchend", (e) => {
          const now = Date.now();
          if (now - customEdgeLastTap < 300) {
           e.preventDefault();
           if (selectedEdges.has(edge.id)) {
            selectedEdges.delete(edge.id);
           } else {
            selectedEdges.add(edge.id);
           }
           updateAllSelections();
           if (navigator.vibrate) navigator.vibrate(50);
           customEdgeLastTap = 0;
          } else {
           customEdgeLastTap = now;
          }
         }, { passive: false });
         poly.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (selectedEdges.has(edge.id)) {
           selectedEdges.delete(edge.id);
          } else {
           selectedEdges.add(edge.id);
          }
          updateAllSelections();
         });
         let edgeLastTap = 0;
         poly.addEventListener("touchend", (e) => {
          const now = Date.now();
          if (now - edgeLastTap < 300) {
           e.preventDefault();
           if (selectedEdges.has(edge.id)) {
            selectedEdges.delete(edge.id);
           } else {
            selectedEdges.add(edge.id);
           }
           updateAllSelections();
           if (navigator.vibrate) navigator.vibrate(50);
           edgeLastTap = 0;
          } else {
           edgeLastTap = now;
          }
         });
          if (currentView.mode === "rack") {
           return;
          }
          if (edge.groupId) {
      const bounds = edge.points.reduce((acc, p) => ({ minX: Math.min(acc.minX, p.x), minY: Math.min(acc.minY, p.y), maxX: Math.max(acc.maxX, p.x), maxY: Math.max(acc.maxY, p.y) }), { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity });
      const groupIndicator = document.createElementNS(ns, "rect");
      groupIndicator.setAttribute("x", bounds.minX - 8);
      groupIndicator.setAttribute("y", bounds.minY - 8);
      groupIndicator.setAttribute("width", bounds.maxX - bounds.minX + 16);
      groupIndicator.setAttribute("height", bounds.maxY - bounds.minY + 16);
      groupIndicator.setAttribute("rx", "4");
      groupIndicator.style.fill = "none";
  groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
      groupIndicator.style.strokeWidth = "3";
      groupIndicator.style.strokeDasharray = "5,5";
      groupIndicator.style.pointerEvents = "none";
      svg.appendChild(groupIndicator);
      }
         let lineDragging = false;
      let lineDragStartX, lineDragStartY;
      let linePointsStart = [];
      polyHit.addEventListener("mousedown", (e) => {
      if (freeDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      lineDragging = true;
      lineDragStartX = e.clientX;
      lineDragStartY = e.clientY;
      linePointsStart = edge.points.map(p => ({x: p.x, y: p.y}));
      if (selectedEdges.has(edge.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
      const lineMoveHandler = (e) => {
      if (!lineDragging || freeDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = lineDragStartX;
      pt1.y = lineDragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      edge.points.forEach((p, i) => { p.x = linePointsStart[i].x + dx; p.y = linePointsStart[i].y + dy; });
      if (selectedEdges.has(edge.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       savedPositions[nodeId] = { x: initialPositions[nodeId].x + dx, y: initialPositions[nodeId].y + dy };
      }
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      if (edgeId === edge.id) return;
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      forgeTheTopology();
      };
      const lineUpHandler = () => { lineDragging = false; };
      document.addEventListener("mousemove", lineMoveHandler);
      document.addEventListener("mouseup", lineUpHandler);
      svg.appendChild(poly);
      svg.appendChild(polyHit);
         if (currentEdgeId === edge.id) {
          edge.points.forEach((p, idx) => {
           const c = document.createElementNS(ns, "circle");
           c.classList.add("edge-edit-point");
           c.setAttribute("cx", p.x);
           c.setAttribute("cy", p.y);
		   c.setAttribute("r", PAGE_STATE.selectionHandleSize || 8);
           c.style.fill = PAGE_STATE.selectionHandle || "#f59e0b";
           c.style.stroke = "#fff";
           c.style.strokeWidth = "2";
           c.style.cursor = "move";
           c.dataset.edgeId = edge.id;
           c.dataset.pointIndex = String(idx);
           c.addEventListener("mousedown", (e) => {
            e.preventDefault();
            e.stopPropagation();
            pushUndo("edit edge point");
            let dragging = true;
            const svgEl = svg;
            const moveHandler = (ev) => {
             if (!dragging) return;
             const pt = svgEl.createSVGPoint();
             pt.x = ev.clientX;
             pt.y = ev.clientY;
             const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
             edge.points[idx].x = svgP.x;
             edge.points[idx].y = svgP.y;
             forgeTheTopology();
            };
            const upHandler = () => {
             dragging = false;
             document.removeEventListener("mousemove", moveHandler);
             document.removeEventListener("mouseup", upHandler);
            };
            document.addEventListener("mousemove", moveHandler);
            document.addEventListener("mouseup", upHandler);
           });
           c.addEventListener("touchstart", (e) => {
            e.preventDefault();
            e.stopPropagation();
            pushUndo("edit edge point");
            let dragging = true;
            const svgEl = svg;
            const touchMoveHandler = (ev) => {
             if (!dragging || !ev.touches[0]) return;
             const pt = svgEl.createSVGPoint();
             pt.x = ev.touches[0].clientX;
             pt.y = ev.touches[0].clientY;
             const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
             edge.points[idx].x = svgP.x;
             edge.points[idx].y = svgP.y;
             forgeTheTopology();
            };
            const touchUpHandler = () => {
             dragging = false;
             document.removeEventListener("touchmove", touchMoveHandler);
             document.removeEventListener("touchend", touchUpHandler);
            };
            document.addEventListener("touchmove", touchMoveHandler);
            document.addEventListener("touchend", touchUpHandler);
           }, { passive: false });
           svg.appendChild(c);
          });
         }
         return;
         }
         const p1 = positions[edge.from];
         const p2 = positions[edge.to];
         if (!p1 || !p2) return;
         const edgeFaded = currentView.mode !== "rack" && (!isNodeVisible(edge.from) || !isNodeVisible(edge.to));
         const pairTotal = edge._pairTotal || 1;
         const pairIndex = edge._pairIndex || 0;
         const midX = (p1.x + p2.x) / 2;
         const midY = (p1.y + p2.y) / 2;
         const dx = p2.x - p1.x;
         const dy = p2.y - p1.y;
         const len = Math.sqrt(dx * dx + dy * dy) || 1;
         const perpX = -dy / len;
         const perpY = dx / len;
         let offsetAmount = 0;
         if (pairTotal > 1) {
          offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
         }
         const ctrlX = midX + perpX * offsetAmount;
         const ctrlY = midY + perpY * offsetAmount;
         const path = document.createElementNS(ns, "path");
         path.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
         path.setAttribute("fill", "none");
         path.classList.add("edge");
         if (edgeFaded) {
          path.style.opacity = "0.25";
          path.classList.add("layer-faded");
         }
         if (edge.type === "backup") path.classList.add("backup");
         path.dataset.edgeId = edge.id;
         path.dataset.from = edge.from;
         path.dataset.to = edge.to;
         path.style.stroke = edge.color;
         path.style.strokeWidth = edge.width;
         const pathHit = document.createElementNS(ns, "path");
         pathHit.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
         pathHit.setAttribute("fill", "none");
         pathHit.style.stroke = "transparent";
         pathHit.style.strokeWidth = "20";
         pathHit.style.cursor = "pointer";
         pathHit.dataset.edgeId = edge.id;
         pathHit.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         let pathTouchStart = null;
         let pathTouchMoved = false;
         pathHit.addEventListener("touchstart", (e) => {
         pathTouchStart = Date.now();
         pathTouchMoved = false;
         if (e.touches[0]) {
          pathTouchStartX = e.touches[0].clientX;
          pathTouchStartY = e.touches[0].clientY;
         }
        }, {
          passive: false
         });
         let pathTouchStartX = 0, pathTouchStartY = 0;
        pathHit.addEventListener("touchmove", (e) => {
         if (e.touches[0]) {
          const dx = Math.abs(e.touches[0].clientX - pathTouchStartX);
          const dy = Math.abs(e.touches[0].clientY - pathTouchStartY);
          if (dx > 10 || dy > 10) pathTouchMoved = true;
         }
        }, {
          passive: false
         });
         pathHit.addEventListener("touchend", (e) => {
          if (pathTouchStart && !pathTouchMoved && Date.now() - pathTouchStart < 400) {
           e.stopPropagation();
           e.preventDefault();
           selectTheConnection(edge.id);
          }
          pathTouchStart = null;
          pathTouchMoved = false;
         }, {
          passive: false
         });
         path.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         if (currentView.mode === "rack") {
          const fromNode = NODE_DATA[edge.from];
          const toNode = NODE_DATA[edge.to];
          if (!fromNode || !toNode ||
              fromNode.assignedRack !== currentView.rackId ||
              toNode.assignedRack !== currentView.rackId) {
           return;
          }
         }
         svg.appendChild(path);
         svg.appendChild(pathHit);
         if (edge.fromPort || edge.toPort) {
          const ns = "http://www.w3.org/2000/svg";
          if (edge.fromPort) {
           const fromLabel = document.createElementNS(ns, "text");
           fromLabel.textContent = edge.fromPort;
           fromLabel.setAttribute("x", p1.x);
           fromLabel.setAttribute("y", p1.y - 10);
           fromLabel.setAttribute("text-anchor", "middle");
           fromLabel.style.fill = "#94a3b8";
           fromLabel.style.fontSize = "12px";
           fromLabel.style.fontWeight = "600";
           fromLabel.style.pointerEvents = "none";
           fromLabel.classList.add("port-label");
           svg.appendChild(fromLabel);
          }
          if (edge.toPort) {
           const toLabel = document.createElementNS(ns, "text");
           toLabel.textContent = edge.toPort;
           toLabel.setAttribute("x", p2.x);
           toLabel.setAttribute("y", p2.y - 10);
           toLabel.setAttribute("text-anchor", "middle");
           toLabel.style.fill = "#94a3b8";
           toLabel.style.fontSize = "12px";
           toLabel.style.fontWeight = "600";
           toLabel.style.pointerEvents = "none";
           toLabel.classList.add("port-label");
           svg.appendChild(toLabel);
          }
         }
        });
        Object.entries(positions).forEach(([id, pos]) => {
         const node = NODE_DATA[id];
         if (!node) return;
         if (currentView.mode === "rack") {
          if (node.assignedRack !== currentView.rackId) return;
         const rackUnit = parseInt(node.rackUnit) || 1;
      const uHeight = parseInt(node.uHeight) || 1;
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      pos.x = RACK_START_X;
      pos.y = RACK_START_Y + (rackCapacity - rackUnit - uHeight + 1) * rackUHeight + (uHeight * rackUHeight) / 2;
         } else {
          if (node.assignedRack) return;
         }
         const g = document.createElementNS("http://www.w3.org/2000/svg", "g", );
         g.classList.add("node-group");
         g.dataset.nodeId = id;
         g.setAttribute("transform", `translate(${pos.x},${pos.y})`);
         if (currentView.mode !== "rack" && !isNodeVisible(id)) {
          g.style.opacity = "0.25";
          g.classList.add("layer-faded");
         }
         let r = savedSizes[id] || 55;
		if (!savedSizes[id]) {
		 if (window.innerWidth <= 480) r = 45;
		 else if (window.innerWidth <= 768) r = 50;
		}
         const styles = resolveStylesForNode(id);
         const ns = "http://www.w3.org/2000/svg";
         const hitArea = document.createElementNS(ns, "circle");
         hitArea.setAttribute("r", r * 1.5);
         hitArea.style.fill = "transparent";
         hitArea.style.stroke = "none";
         hitArea.style.cursor = "grab";
         hitArea.classList.add("node-hit-area");
         const shapeEl = createNodeShape(id, r);
         const titleOffsetX = styles.titleOffsetX || 0;
         const titleOffsetY = styles.titleOffsetY || 0;
         const subOffsetX = styles.subOffsetX || 0;
         const subOffsetY = styles.subOffsetY || 0;
         const label = document.createElementNS("http://www.w3.org/2000/svg", "text", );
         label.classList.add("node-label");
         label.setAttribute("x", titleOffsetX);
         label.setAttribute("y", -r * 0.28 + titleOffsetY);
         const labelFontSize = styles.titleSize || PAGE_STATE.nodeTitleSize || r * 0.33;
        label.style.fontSize = labelFontSize + "px";
         label.textContent = NODE_DATA[id].name;
		label.style.fill = styles.titleColor || PAGE_STATE.nodeTitle || "#e2e8f0";
        label.style.fontFamily = styles.titleFont || PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
         label.style.pointerEvents = "none";
         const sub = document.createElementNS("http://www.w3.org/2000/svg", "text", );
         sub.classList.add("node-sub");
         sub.setAttribute("x", subOffsetX);
         sub.setAttribute("y", r * 0.4 + subOffsetY);
         const subFontSize = styles.subSize || PAGE_STATE.nodeSubSize || r * 0.24;
        sub.style.fontSize = subFontSize + "px";
         sub.textContent = NODE_DATA[id].ip;
		sub.style.fill = styles.subColor || PAGE_STATE.nodeSub || "#94a3b8";
        sub.style.fontFamily = styles.subFont || PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
         sub.style.pointerEvents = "none";
         g.append(hitArea, shapeEl, label, sub);
         if (NODE_DATA[id]?.locked) {
           const lockIndicator = document.createElementNS(ns, "text");
           lockIndicator.textContent = "üîí";
           lockIndicator.setAttribute("x", r * 0.7);
           lockIndicator.setAttribute("y", -r * 0.7);
           lockIndicator.style.fontSize = (r * 0.3) + "px";
           lockIndicator.style.pointerEvents = "none";
           lockIndicator.classList.add("lock-indicator");
           g.appendChild(lockIndicator);
         }
         if (NODE_DATA[id]?.groupId) {
           const groupIndicator = document.createElementNS(ns, "circle");
           groupIndicator.setAttribute("r", r + 4);
           groupIndicator.style.fill = "none";
         groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
           groupIndicator.style.strokeWidth = "3";
           groupIndicator.style.strokeDasharray = "5,5";
           groupIndicator.style.pointerEvents = "none";
           groupIndicator.classList.add("group-indicator");
           g.insertBefore(groupIndicator, g.firstChild);
         }
         let isDragging = false;
         let startX, startY;
         let initialPositions = {};
         let longPressTimer = null;
         let longPressTriggered = false;
         g.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (isViewOnly()) return;
          if (selectedNodes.has(id)) {
           selectedNodes.delete(id);
          } else {
           selectedNodes.add(id);
          }
          updateNodeSelection();
          return false;
         });
        g.addEventListener("touchstart", (e) => {
         if (NODE_DATA[id].isRack) {
          const touch = e.touches[0];
          longPressStartX = touch.clientX;
          longPressStartY = touch.clientY;
          longPressTimer = setTimeout(() => {
           longPressTriggered = true;
           if (navigator.vibrate) {
            navigator.vibrate(100);
           }
           enterRack(id);
          }, 500);
         }
        }, { passive: true });
        g.addEventListener("dblclick", (e) => {
         e.preventDefault();
         e.stopPropagation();
         if (NODE_DATA[id].isRack) {
          enterRack(id);
         }
        });
        let lastTapTime = 0;
        let lastTapNode = null;
        g.addEventListener("touchend", (e) => {
         const currentTime = new Date().getTime();
         const tapLength = currentTime - lastTapTime;
         if (tapLength < 300 && tapLength > 0 && lastTapNode === id) {
          e.preventDefault();
          e.stopPropagation();
          if (isViewOnly()) return;
          if (selectedNodes.has(id)) {
           selectedNodes.delete(id);
          } else {
           selectedNodes.add(id);
          }
          updateNodeSelection();
          if (navigator.vibrate) {
           navigator.vibrate(50);
          }
          lastTapTime = 0;
          lastTapNode = null;
         } else {
          lastTapTime = currentTime;
          lastTapNode = id;
         }
        });
         g.addEventListener("touchend", (e) => {
          if (longPressTimer) {
           clearTimeout(longPressTimer);
           longPressTimer = null;
          }
          if (longPressTriggered) {
           e.preventDefault();
           e.stopPropagation();
           longPressTriggered = false;
          }
         });
         let longPressStartX = 0;
        let longPressStartY = 0;
        g.addEventListener("touchmove", (e) => {
         if (longPressTimer) {
          const touch = e.touches[0];
          const dx = Math.abs(touch.clientX - longPressStartX);
          const dy = Math.abs(touch.clientY - longPressStartY);
          if (dx > 15 || dy > 15) {
           clearTimeout(longPressTimer);
           longPressTimer = null;
           longPressTriggered = false;
          }
         }
        });
         g.addEventListener("mousedown", (e) => {
          if (isViewOnly()) return;
          if (e.button === 2) {
           return;
          }
          if (NODE_DATA[id]?.locked) {
           return;
          }
          e.preventDefault();
          isDragging = true;
		  pushUndo("move nodes");
          const svgEl = document.getElementById("map");
          const pt = svgEl.createSVGPoint();
          pt.x = e.clientX;
          pt.y = e.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          startX = svgP.x;
          startY = svgP.y;
          let nodesToCollect = [];
      if (selectedNodes.has(id)) {
      initialPositions = {};
      const allSelectedRects = Array.from(selectedRects);
      const allSelectedTexts = Array.from(selectedTexts);
      const allSelectedEdges = Array.from(selectedEdges).map(eid => EDGE_DATA.list.find(e => e.id === eid)).filter(Boolean);
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) {
      initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      }
      });
      Array.from(selectedRects).forEach(rectId => {
        const rect = RECT_DATA.list.find(r => r.id === rectId);
        if (rect) { rect._dragStartX = rect.x; rect._dragStartY = rect.y; }
      });
      Array.from(selectedTexts).forEach(textId => {
        const text = TEXT_DATA.list.find(t => t.id === textId);
        if (text) { text._dragStartX = text.x; text._dragStartY = text.y; }
      });
      Array.from(selectedEdges).forEach(edgeId => {
        const edge = EDGE_DATA.list.find(e => e.id === edgeId);
        if (edge && edge.points) { edge._dragStartPoints = edge.points.map(p => ({x: p.x, y: p.y})); }
      });
      } else {
      initialPositions = { [id]: { x: pos.x, y: pos.y } };
      }
          const groupIds = new Set();
          nodesToCollect.forEach(nodeId => {
           const groupId = NODE_DATA[nodeId]?.groupId;
           if (groupId) {
             groupIds.add(groupId);
           }
          });
          if (groupIds.size > 0) {
           Object.keys(NODE_DATA).forEach(nodeId => {
             const nodeGroupId = NODE_DATA[nodeId]?.groupId;
             if (nodeGroupId && groupIds.has(nodeGroupId)) {
               if (!nodesToCollect.includes(nodeId)) {
                 nodesToCollect.push(nodeId);
               }
             }
           });
          }
          nodesToCollect = nodesToCollect.filter(nodeId => !NODE_DATA[nodeId]?.locked);
          if (nodesToCollect.length === 0) {
           return;
          }
          initialPositions = {};
          nodesToCollect.forEach(nodeId => {
           const nodePos = savedPositions[nodeId];
           if (nodePos) {
            initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
           }
          });
          g.style.cursor = "grabbing";
          hitArea.style.cursor = "grabbing";
          e.stopPropagation();
         });
         const handleMouseMove = (e) => {
          if (!isDragging) return;
          e.preventDefault();
          const svgEl = document.getElementById("map");
          const pt = svgEl.createSVGPoint();
          pt.x = e.clientX;
          pt.y = e.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          const dx = svgP.x - startX;
          const dy = svgP.y - startY;
          const nodesToMove = selectedNodes.has(id) ? Array.from(selectedNodes) : [id];
          nodesToMove.forEach(nodeId => {
           if (!initialPositions[nodeId]) return;
           const initialPos = initialPositions[nodeId];
           let newX = initialPos.x + dx;
           let newY = initialPos.y + dy;
           const nodeSize = savedSizes[nodeId] || 55;
           newX = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, newX), );
           newY = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, newY), );
           savedPositions[nodeId] = { x: newX, y: newY };
           positions[nodeId] = { x: newX, y: newY };
           if (nodeId === id) {
            pos.x = newX;
            pos.y = newY;
           }
           const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
          if (nodeGroup) {
           nodeGroup.setAttribute("transform", `translate(${newX},${newY})`);
          }
         });
         Array.from(selectedRects).forEach(rectId => {
           const rect = RECT_DATA.list.find(r => r.id === rectId);
           if (rect && rect._dragStartX !== undefined) {
             rect.x = rect._dragStartX + dx;
             rect.y = rect._dragStartY + dy;
           }
         });
         Array.from(selectedTexts).forEach(textId => {
           const text = TEXT_DATA.list.find(t => t.id === textId);
           if (text && text._dragStartX !== undefined) {
             text.x = text._dragStartX + dx;
             text.y = text._dragStartY + dy;
           }
         });
         Array.from(selectedEdges).forEach(edgeId => {
           const edge = EDGE_DATA.list.find(e => e.id === edgeId);
           if (edge && edge._dragStartPoints) {
             edge.points.forEach((p, i) => {
               p.x = edge._dragStartPoints[i].x + dx;
               p.y = edge._dragStartPoints[i].y + dy;
             });
           }
         });
         forgeTheTopology();
         updateMinimap();
          document.querySelectorAll(".edge").forEach((edgeEl) => {
           const fromId = edgeEl.dataset.from;
           const toId = edgeEl.dataset.to;
           if (nodesToMove.includes(fromId) || nodesToMove.includes(toId)) {
            const p1 = savedPositions[fromId] || positions[fromId] || {
             x: 600,
             y: 350
            };
            const p2 = savedPositions[toId] || positions[toId] || {
             x: 600,
             y: 350
            };
            if (edgeEl.tagName === "line") {
             edgeEl.setAttribute("x1", p1.x);
             edgeEl.setAttribute("y1", p1.y);
             edgeEl.setAttribute("x2", p2.x);
             edgeEl.setAttribute("y2", p2.y);
            } else if (edgeEl.tagName === "path") {
             const edgeId = edgeEl.dataset.edgeId;
             const edge = EDGE_DATA.list.find(
              (e) => e.id === edgeId, );
             if (edge) {
              const pairTotal = edge._pairTotal || 1;
              const pairIndex = edge._pairIndex || 0;
              const midX = (p1.x + p2.x) / 2;
              const midY = (p1.y + p2.y) / 2;
              const dx = p2.x - p1.x;
              const dy = p2.y - p1.y;
              const len = Math.sqrt(dx * dx + dy * dy) || 1;
              const perpX = -dy / len;
              const perpY = dx / len;
              let offsetAmount = 0;
              if (pairTotal > 1) {
               offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
              }
              const ctrlX = midX + perpX * offsetAmount;
              const ctrlY = midY + perpY * offsetAmount;
              edgeEl.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
             }
            }
           }
          });
         };
      const handleMouseUp = () => {
      if (isDragging) {
      isDragging = false;
      g.style.cursor = "grab";
      hitArea.style.cursor = "grab";
      if (currentView.mode === "rack" && NODE_DATA[id]?.assignedRack === currentView.rackId) {
      const draggedY = savedPositions[id]?.y || pos.y;
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      let newUnit = rackCapacity - Math.round((draggedY - RACK_START_Y) / rackUHeight);
      newUnit = Math.max(1, Math.min(newUnit, rackCapacity));
      NODE_DATA[id].rackUnit = newUnit;
      forgeTheTopology();
      claimTheImmortal(id);
      }
      }
      };
         document.addEventListener("mousemove", handleMouseMove);
         document.addEventListener("mouseup", handleMouseUp);
         let touchStartTime = 0;
         let touchStartX = 0;
         let touchStartY = 0;
         let touchMoved = false;
       g.addEventListener("touchstart",
         (e) => {
          if (NODE_DATA[id]?.locked) {
           return;
          }
          e.preventDefault();
          touchStartTime = Date.now();
          touchMoved = false;
          const svgEl = document.getElementById("map");
          const pt = svgEl.createSVGPoint();
          const touch = e.touches[0];
          pt.x = touch.clientX;
          pt.y = touch.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          touchStartX = svgP.x;
          touchStartY = svgP.y;
          startX = svgP.x;
          startY = svgP.y;
          let nodesToCollect = [];
          if (selectedNodes.has(id)) {
           nodesToCollect = Array.from(selectedNodes);
          } else {
           nodesToCollect = [id];
          }
          const groupIds = new Set();
          nodesToCollect.forEach(nodeId => {
           const groupId = NODE_DATA[nodeId]?.groupId;
           if (groupId) {
             groupIds.add(groupId);
           }
          });
          if (groupIds.size > 0) {
           Object.keys(NODE_DATA).forEach(nodeId => {
             const nodeGroupId = NODE_DATA[nodeId]?.groupId;
             if (nodeGroupId && groupIds.has(nodeGroupId)) {
               if (!nodesToCollect.includes(nodeId)) {
                 nodesToCollect.push(nodeId);
               }
             }
           });
          }
          nodesToCollect = nodesToCollect.filter(nodeId => !NODE_DATA[nodeId]?.locked);
          if (nodesToCollect.length === 0) {
           return;
          }
          initialPositions = {};
          nodesToCollect.forEach(nodeId => {
           const nodePos = savedPositions[nodeId];
           if (nodePos) {
            initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
           }
          });
          e.stopPropagation();
         }, {
          passive: false
         }, );
         g.addEventListener("touchmove", (e) => {
		  if (isViewOnly()) return;
         e.preventDefault();
         const svgEl = document.getElementById("map");
         const pt = svgEl.createSVGPoint();
         const touch = e.touches[0];
         pt.x = touch.clientX;
         pt.y = touch.clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
         const dx = Math.abs(svgP.x - touchStartX);
         const dy = Math.abs(svgP.y - touchStartY);
         if (dx > (isMobileDevice() ? 4 : 10) || dy > (isMobileDevice() ? 4 : 10)) {
      touchMoved = true;
      isDragging = true;
      }
         if (!isDragging) return;
         const deltaX = svgP.x - startX;
         const deltaY = svgP.y - startY;
         const nodesToMove = selectedNodes.has(id) ? Array.from(selectedNodes) : [id];
         nodesToMove.forEach(nodeId => {
          if (!initialPositions[nodeId]) return;
          const initialPos = initialPositions[nodeId];
          let newX = initialPos.x + deltaX;
          let newY = initialPos.y + deltaY;
          const nodeSize = savedSizes[nodeId] || 55;
          newX = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, newX), );
          newY = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, newY), );
          savedPositions[nodeId] = { x: newX, y: newY };
          positions[nodeId] = { x: newX, y: newY };
          if (nodeId === id) {
           pos.x = newX;
           pos.y = newY;
          }
          const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
          if (nodeGroup) {
           nodeGroup.setAttribute("transform", `translate(${newX},${newY})`);
          }
         });
         updateMinimap();
         document.querySelectorAll(".edge").forEach((edgeEl) => {
          const fromId = edgeEl.dataset.from;
          const toId = edgeEl.dataset.to;
          if (nodesToMove.includes(fromId) || nodesToMove.includes(toId)) {
            const p1 = savedPositions[fromId] || positions[fromId] || {
             x: 600,
             y: 350
            };
            const p2 = savedPositions[toId] || positions[toId] || {
             x: 600,
             y: 350
            };
            if (edgeEl.tagName === "line") {
             edgeEl.setAttribute("x1", p1.x);
             edgeEl.setAttribute("y1", p1.y);
             edgeEl.setAttribute("x2", p2.x);
             edgeEl.setAttribute("y2", p2.y);
            } else if (edgeEl.tagName === "path") {
             const edgeId = edgeEl.dataset.edgeId;
             const edge = EDGE_DATA.list.find(
              (e) => e.id === edgeId, );
             if (edge) {
              const pairTotal = edge._pairTotal || 1;
              const pairIndex = edge._pairIndex || 0;
              const midX = (p1.x + p2.x) / 2;
              const midY = (p1.y + p2.y) / 2;
              const dx = p2.x - p1.x;
              const dy = p2.y - p1.y;
              const len = Math.sqrt(dx * dx + dy * dy) || 1;
              const perpX = -dy / len;
              const perpY = dx / len;
              let offsetAmount = 0;
              if (pairTotal > 1) {
               offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
              }
              const ctrlX = midX + perpX * offsetAmount;
              const ctrlY = midY + perpY * offsetAmount;
              edgeEl.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
             }
            }
           }
          });
         }, {
          passive: false
         });
      g.addEventListener("touchend", (e) => {
      const touchDuration = Date.now() - touchStartTime;
      if (!touchMoved && touchDuration < 400) {
       if (isViewOnly()) {
        handleViewOnlyClick(id, 'node');
        return;
       }
       claimTheImmortal(id);
      }
      if (isDragging) {
      const draggedY = pos.y;
      isDragging = false;
      savedPositions[id] = {
      x: pos.x,
      y: pos.y
      };
      if (currentView.mode === "rack" && NODE_DATA[id]?.assignedRack === currentView.rackId) {
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      let newUnit = rackCapacity - Math.round((draggedY - RACK_START_Y) / rackUHeight);
      newUnit = Math.max(1, Math.min(newUnit, rackCapacity));
      NODE_DATA[id].rackUnit = newUnit;
      forgeTheTopology();
      claimTheImmortal(id);
      }
      }
      touchMoved = false;
      });
         g.style.cursor = "grab";
         g.addEventListener("click", (e) => {
          if (!isDragging) {
           if (isViewOnly()) {
            handleViewOnlyClick(id, 'node');
            return;
           }
           claimTheImmortal(id);
          }
         });
         svg.appendChild(g);
        });
        if (RECT_DATA && RECT_DATA.list) {
         RECT_DATA.list.forEach((rect) => {
          if (currentView.mode === "rack") return;
          if (rect.style === "outlined") {
           const g = document.createElementNS(ns, "g");
           g.classList.add("rect-group");
           g.dataset.rectId = rect.id;
           const rectEl = document.createElementNS(ns, "rect");
           rectEl.classList.add("rect-shape");
           rectEl.setAttribute("x", rect.x);
           rectEl.setAttribute("y", rect.y);
           rectEl.setAttribute("width", rect.width);
           rectEl.setAttribute("height", rect.height);
           rectEl.style.fill = "none";
           rectEl.style.stroke = rect.borderColor || rect.color;
           rectEl.style.strokeWidth = (rect.borderWidth !== undefined ? rect.borderWidth : 3) + "px";
      if (rect.lineStyle === "dashed") { rectEl.style.strokeDasharray = "10,5"; }
           else if (rect.lineStyle === "dotted") { rectEl.style.strokeDasharray = "2,4"; }
           else { rectEl.style.strokeDasharray = "none"; }
           rectEl.style.cursor = "move";
           rectEl.addEventListener("click", (e) => {
             if (rectDrawMode) return;
             e.stopPropagation();
             currentRectId = rect.id;
             selectTheRect(rect.id);
           });
           rectEl.addEventListener("contextmenu", (e) => {
             e.preventDefault();
             e.stopPropagation();
             if (selectedRects.has(rect.id)) {
               selectedRects.delete(rect.id);
             } else {
               selectedRects.add(rect.id);
             }
             updateAllSelections();
           });
           let rectLastTap = 0;
           rectEl.addEventListener("touchend", (e) => {
             const now = Date.now();
             if (now - rectLastTap < 300) {
               e.preventDefault();
               if (selectedRects.has(rect.id)) {
                 selectedRects.delete(rect.id);
               } else {
                 selectedRects.add(rect.id);
               }
               updateAllSelections();
               if (navigator.vibrate) navigator.vibrate(50);
               rectLastTap = 0;
             } else {
               rectLastTap = now;
             }
           }, { passive: false });
           const deleteBtn = document.createElementNS(ns, "g");
           deleteBtn.classList.add("rect-delete-btn");
           deleteBtn.style.cursor = "pointer";
           deleteBtn.style.display = rectDrawMode ? "block" : "none";
           const deleteBg = document.createElementNS(ns, "circle");
           deleteBg.setAttribute("cx", rect.x + rect.width - 10);
           deleteBg.setAttribute("cy", rect.y + 10);
           deleteBg.setAttribute("r", 12);
           deleteBg.style.fill = "#f56565";
           deleteBg.style.stroke = "white";
           deleteBg.style.strokeWidth = "2";
           const deleteX = document.createElementNS(ns, "text");
           deleteX.setAttribute("x", rect.x + rect.width - 10);
           deleteX.setAttribute("y", rect.y + 10);
           deleteX.setAttribute("text-anchor", "middle");
           deleteX.setAttribute("dominant-baseline", "middle");
           deleteX.style.fill = "white";
           deleteX.style.fontSize = "16px";
           deleteX.style.fontWeight = "bold";
           deleteX.style.pointerEvents = "none";
           deleteX.textContent = "√ó";
           deleteBtn.appendChild(deleteBg);
           deleteBtn.appendChild(deleteX);
           deleteBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            e.preventDefault();
            deleteRectangle(rect.id);
           });
           let isDragging = false;
           let dragStartX, dragStartY;
           let rectStartX, rectStartY;
           rectEl.addEventListener("mousedown", (e) => {
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            dragStartX = e.clientX;
            dragStartY = e.clientY;
            rectStartX = rect.x;
            rectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           });
      const moveHandler = (e) => {
      if (!isDragging || rectDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      rect.x = rectStartX + dx;
      rect.y = rectStartY + dy;
      if (selectedRects.has(rect.id)) {
      selectedNodes.forEach(nodeId => { if (initialPositions[nodeId]) { savedPositions[nodeId] = { x: initialPositions[nodeId].x + dx, y: initialPositions[nodeId].y + dy }; } });
      selectedRects.forEach(rectId => { if (rectId === rect.id) return; const r = RECT_DATA.list.find(x => x.id === rectId); if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; } });
      selectedTexts.forEach(textId => { const t = TEXT_DATA.list.find(x => x.id === textId); if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; } });
      selectedEdges.forEach(edgeId => { const ed = EDGE_DATA.list.find(x => x.id === edgeId); if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); } });
      }
      forgeTheTopology();
      };
           const upHandler = () => {
            if (isDragging) {
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           };
           document.addEventListener("mousemove", moveHandler);
           document.addEventListener("mouseup", upHandler);
           let touchStartX, touchStartY;
           let touchRectStartX, touchRectStartY;
           rectEl.addEventListener("touchstart", (e) => {
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchRectStartX = rect.x;
            touchRectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           }, { passive: false });
           rectEl.addEventListener("touchmove", (e) => {
		   if (isViewOnly()) return;
            if (!isDragging || rectDrawMode) return;
            if (!e.touches[0]) return;
            e.preventDefault();
            e.stopPropagation();
            const svgEl = svg;
            const pt1 = svgEl.createSVGPoint();
            pt1.x = touchStartX;
            pt1.y = touchStartY;
            const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
            const touch = e.touches[0];
            const pt2 = svgEl.createSVGPoint();
            pt2.x = touch.clientX;
            pt2.y = touch.clientY;
            const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
            const dx = svgP2.x - svgP1.x;
            const dy = svgP2.y - svgP1.y;
            rect.x = touchRectStartX + dx;
            rect.y = touchRectStartY + dy;
            forgeTheTopology();
           }, { passive: false });
           rectEl.addEventListener("touchend", (e) => {
            if (isDragging) {
             e.preventDefault();
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           }, { passive: false });
           if (currentRectId === rect.id) {
             const corners = [
               { cx: rect.x, cy: rect.y, cursor: 'nwse-resize', dx: -1, dy: -1 },
               { cx: rect.x + rect.width, cy: rect.y, cursor: 'nesw-resize', dx: 1, dy: -1 },
               { cx: rect.x, cy: rect.y + rect.height, cursor: 'nesw-resize', dx: -1, dy: 1 },
               { cx: rect.x + rect.width, cy: rect.y + rect.height, cursor: 'nwse-resize', dx: 1, dy: 1 }
             ];
             corners.forEach((corner) => {
               const handle = document.createElementNS(ns, "circle");
               handle.setAttribute("cx", corner.cx);
               handle.setAttribute("cy", corner.cy);
handle.setAttribute("r", PAGE_STATE.selectionHandleSize || 8);
      handle.style.fill = PAGE_STATE.selectionHandle || "#f59e0b";
               handle.style.stroke = "#fff";
               handle.style.strokeWidth = "2";
               handle.style.cursor = corner.cursor;
               handle.addEventListener("mousedown", (e) => {
                 e.preventDefault();
                 e.stopPropagation();
				 pushUndo("resize zone");
                 let dragging = true;
                 const startX = e.clientX, startY = e.clientY;
                 const origX = rect.x, origY = rect.y, origW = rect.width, origH = rect.height;
                 const moveHandler = (ev) => {
                   if (!dragging) return;
                   const pt1 = svg.createSVGPoint(); pt1.x = startX; pt1.y = startY;
                   const pt2 = svg.createSVGPoint(); pt2.x = ev.clientX; pt2.y = ev.clientY;
                   const svgP1 = pt1.matrixTransform(svg.getScreenCTM().inverse());
                   const svgP2 = pt2.matrixTransform(svg.getScreenCTM().inverse());
                   const dx = svgP2.x - svgP1.x, dy = svgP2.y - svgP1.y;
                   if (corner.dx < 0) { rect.x = origX + dx; rect.width = origW - dx; }
                   else { rect.width = origW + dx; }
                   if (corner.dy < 0) { rect.y = origY + dy; rect.height = origH - dy; }
                   else { rect.height = origH + dy; }
                   if (rect.width < 20) rect.width = 20;
                   if (rect.height < 20) rect.height = 20;
                   forgeTheTopology();
                 };
                 const upHandler = () => { dragging = false; document.removeEventListener("mousemove", moveHandler); document.removeEventListener("mouseup", upHandler); };
                 document.addEventListener("mousemove", moveHandler);
                 document.addEventListener("mouseup", upHandler);
               });
               g.appendChild(handle);
             });
           }
           if (rect.groupId) {
             const groupIndicator = document.createElementNS(ns, "rect");
             groupIndicator.setAttribute("x", rect.x - 4);
             groupIndicator.setAttribute("y", rect.y - 4);
             groupIndicator.setAttribute("width", rect.width + 8);
             groupIndicator.setAttribute("height", rect.height + 8);
             groupIndicator.style.fill = "none";
         groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
             groupIndicator.style.strokeWidth = "3";
             groupIndicator.style.strokeDasharray = "5,5";
             groupIndicator.style.pointerEvents = "none";
             g.insertBefore(groupIndicator, g.firstChild);
           }
           g.appendChild(rectEl);
           g.appendChild(deleteBtn);
           svg.appendChild(g);
          }
         });
        }
        if (TEXT_DATA && TEXT_DATA.list) {
         TEXT_DATA.list.forEach((textItem) => {
          if (currentView.mode === "rack") return;
          const g = document.createElementNS(ns, "g");
          g.classList.add("text-group");
          g.dataset.textId = textItem.id;
          if (textItem.bgEnabled) {
           const bgRect = document.createElementNS(ns, "rect");
           bgRect.classList.add("text-bg");
           bgRect.setAttribute("x", textItem.x - 5);
           bgRect.setAttribute("y", textItem.y - textItem.fontSize - 2);
           bgRect.setAttribute("width", 100);
           bgRect.setAttribute("height", textItem.fontSize + 10);
           bgRect.style.fill = textItem.bgColor;
           bgRect.style.opacity = "0.7";
           bgRect.style.rx = "4";
           g.appendChild(bgRect);
          }
          const textEl = document.createElementNS(ns, "text");
          textEl.classList.add("text-element");
          textEl.setAttribute("x", textItem.x);
          textEl.setAttribute("y", textItem.y);
          textEl.style.fill = textItem.color;
          textEl.style.fontSize = textItem.fontSize + "px";
          textEl.style.fontWeight = textItem.fontWeight;
          textEl.style.fontStyle = textItem.fontStyle;
          textEl.style.textAnchor = textItem.textAlign;
          textEl.style.textDecoration = textItem.textDecoration;
          textEl.style.opacity = textItem.opacity;
          textEl.style.cursor = "move";
          textEl.style.userSelect = "none";
          textEl.setAttribute("dominant-baseline", "middle");
          const lines = textItem.content.split('\n');
          if (lines.length === 1) {
           textEl.textContent = textItem.content;
          } else {
           lines.forEach((line, i) => {
            const tspan = document.createElementNS(ns, "tspan");
            tspan.textContent = line;
            tspan.setAttribute("x", textItem.x);
            tspan.setAttribute("dy", i === 0 ? 0 : textItem.fontSize * 1.2);
            textEl.appendChild(tspan);
           });
          }
          g.appendChild(textEl);
          if (textItem.bgEnabled) {
           setTimeout(() => {
            try {
             const bbox = textEl.getBBox();
             const bgRect = g.querySelector('.text-bg');
             if (bgRect && bbox) {
              bgRect.setAttribute("x", bbox.x - 5);
              bgRect.setAttribute("y", bbox.y - 2);
              bgRect.setAttribute("width", bbox.width + 10);
              bgRect.setAttribute("height", bbox.height + 4);
             }
            } catch (e) {
            }
           }, 0);
          }
          const deleteBtn = document.createElementNS(ns, "g");
          deleteBtn.classList.add("text-delete-btn");
          deleteBtn.style.cursor = "pointer";
          deleteBtn.style.display = textDrawMode ? "block" : "none";
          const deleteBg = document.createElementNS(ns, "circle");
          deleteBg.setAttribute("cx", textItem.x + 20);
          deleteBg.setAttribute("cy", textItem.y - textItem.fontSize);
          deleteBg.setAttribute("r", 12);
          deleteBg.style.fill = "#f56565";
          deleteBg.style.stroke = "white";
          deleteBg.style.strokeWidth = "2";
          const deleteX = document.createElementNS(ns, "text");
          deleteX.setAttribute("x", textItem.x + 20);
          deleteX.setAttribute("y", textItem.y - textItem.fontSize);
          deleteX.setAttribute("text-anchor", "middle");
          deleteX.setAttribute("dominant-baseline", "middle");
          deleteX.style.fill = "white";
          deleteX.style.fontSize = "16px";
          deleteX.style.fontWeight = "bold";
          deleteX.style.pointerEvents = "none";
          deleteX.textContent = "√ó";
          deleteBtn.appendChild(deleteBg);
          deleteBtn.appendChild(deleteX);
          deleteBtn.addEventListener("click", (e) => {
           e.stopPropagation();
           e.preventDefault();
           deleteText(textItem.id);
          });
          let isDragging = false;
          let dragStartX, dragStartY;
          let textStartX, textStartY;
          textEl.addEventListener("mousedown", (e) => {
      if (textDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      textStartX = textItem.x;
      textStartY = textItem.y;
      textEl.style.cursor = "grabbing";
      showTextPanel(textItem.id);
      if (selectedTexts.has(textItem.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
          const moveHandler = (e) => {
      if (!isDragging || textDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      textItem.x = textStartX + dx;
      textItem.y = textStartY + dy;
      if (selectedTexts.has(textItem.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       const newX = initialPositions[nodeId].x + dx;
       const newY = initialPositions[nodeId].y + dy;
       savedPositions[nodeId] = { x: newX, y: newY };
      }
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      if (textId === textItem.id) return;
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      forgeTheTopology();
      };
          const upHandler = () => {
           if (isDragging) {
            isDragging = false;
            textEl.style.cursor = "move";
           }
          };
          document.addEventListener("mousemove", moveHandler);
          document.addEventListener("mouseup", upHandler);
          let touchStartX = 0, touchStartY = 0;
          let textTouchStartX = 0, textTouchStartY = 0;
          textEl.addEventListener("touchstart", (e) => {
           if (textDrawMode) return;
           if (e.touches.length !== 1) return;
           e.preventDefault();
           e.stopPropagation();
           const touch = e.touches[0];
           isDragging = true;
           touchStartX = touch.clientX;
           touchStartY = touch.clientY;
           textTouchStartX = textItem.x;
           textTouchStartY = textItem.y;
           showTextPanel(textItem.id);
          }, { passive: false });
          textEl.addEventListener("touchmove", (e) => {
           if (!isDragging || textDrawMode) return;
           if (e.touches.length !== 1) return;
           e.preventDefault();
           const touch = e.touches[0];
           const svgEl = svg;
           const pt1 = svgEl.createSVGPoint();
           pt1.x = touchStartX;
           pt1.y = touchStartY;
           const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
           const pt2 = svgEl.createSVGPoint();
           pt2.x = touch.clientX;
           pt2.y = touch.clientY;
           const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
           const dx = svgP2.x - svgP1.x;
           const dy = svgP2.y - svgP1.y;
           textItem.x = textTouchStartX + dx;
           textItem.y = textTouchStartY + dy;
           forgeTheTopology();
          }, { passive: false });
          textEl.addEventListener("touchend", () => {
           if (isDragging) {
            isDragging = false;
           }
          }, { passive: false });
          textEl.addEventListener("contextmenu", (e) => {
           e.preventDefault();
           e.stopPropagation();
           if (selectedTexts.has(textItem.id)) {
            selectedTexts.delete(textItem.id);
           } else {
            selectedTexts.add(textItem.id);
           }
           updateAllSelections();
          });
          let textLastTap = 0;
          g.addEventListener("touchend", (e) => {
           const now = Date.now();
           if (now - textLastTap < 300) {
            e.preventDefault();
            if (selectedTexts.has(textItem.id)) {
             selectedTexts.delete(textItem.id);
            } else {
             selectedTexts.add(textItem.id);
            }
            updateAllSelections();
            if (navigator.vibrate) navigator.vibrate(50);
            textLastTap = 0;
           } else {
            textLastTap = now;
           }
          }, { passive: false });
          if (textItem.groupId) {
            const groupIndicator = document.createElementNS(ns, "rect");
            groupIndicator.setAttribute("x", textItem.x - 54);
            groupIndicator.setAttribute("y", textItem.y - 24);
            groupIndicator.setAttribute("width", 108);
            groupIndicator.setAttribute("height", 48);
            groupIndicator.setAttribute("rx", "8");
            groupIndicator.style.fill = "none";
       groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
            groupIndicator.style.strokeWidth = "3";
            groupIndicator.style.strokeDasharray = "5,5";
            groupIndicator.style.pointerEvents = "none";
            g.insertBefore(groupIndicator, g.firstChild);
          }
          g.appendChild(deleteBtn);
          svg.appendChild(g);
         });
        }
        Object.keys(NODE_DATA).forEach(nodeId => {
         updatePingIndicator(nodeId);
        });
        forgeTheLegend();
        updateMinimap();
       }
       function showEditModal(title, currentValue, onSave) {
        const modal = document.getElementById("edit-modal");
        const input = document.getElementById("modal-input");
        const titleEl = document.getElementById("modal-title");
        const saveBtn = document.getElementById("modal-save");
        const cancelBtn = document.getElementById("modal-cancel");
        titleEl.textContent = title;
        input.value = currentValue;
        modal.classList.add("active");
        input.focus();
        input.select();
        const handleSave = () => {
         if (input.value.trim()) {
          onSave(input.value.trim());
         }
         modal.classList.remove("active");
         saveBtn.removeEventListener("click", handleSave);
         cancelBtn.removeEventListener("click", handleCancel);
         input.removeEventListener("keypress", handleEnter);
        };
        const handleCancel = () => {
         modal.classList.remove("active");
         saveBtn.removeEventListener("click", handleSave);
         cancelBtn.removeEventListener("click", handleCancel);
         input.removeEventListener("keypress", handleEnter);
        };
        const handleEnter = (e) => {
         if (e.key === "Enter") handleSave();
        };
        saveBtn.addEventListener("click", handleSave);
        cancelBtn.addEventListener("click", handleCancel);
        input.addEventListener("keypress", handleEnter);
        modal.addEventListener("click", function bgHandler(e) {
         if (e.target === modal) {
          handleCancel();
          modal.removeEventListener("click", bgHandler);
         }
        });
       }
       function challengeTheImmortal(message, onConfirm) {
        const modal = document.getElementById("confirm-modal");
        const messageEl = document.getElementById("confirm-message");
        const deleteBtn = document.getElementById("confirm-delete");
        const cancelBtn = document.getElementById("confirm-cancel");
        messageEl.textContent = message;
        modal.classList.add("active");
        const handleConfirm = () => {
         onConfirm();
         modal.classList.remove("active");
         deleteBtn.removeEventListener("click", handleConfirm);
         cancelBtn.removeEventListener("click", handleCancel);
        };
        const handleCancel = () => {
         modal.classList.remove("active");
         deleteBtn.removeEventListener("click", handleConfirm);
         cancelBtn.removeEventListener("click", handleCancel);
        };
        deleteBtn.addEventListener("click", handleConfirm);
        cancelBtn.addEventListener("click", handleCancel);
        modal.addEventListener("click", function bgHandler(e) {
         if (e.target === modal) {
          handleCancel();
          modal.removeEventListener("click", bgHandler);
         }
        });
       }
       const pageTitleEl = document.getElementById("page-title");
       if (pageTitleEl) {
        pageTitleEl.addEventListener("click", () => {
         showEditModal("Edit Title", PAGE_STATE.title || DEFAULT_PAGE_STATE.title,
          (newTitle) => {
           PAGE_STATE.title = newTitle;
           wieldThePower();
          }, );
        });
       }
       function editNodeName(id) {
        if (!NODE_DATA[id]) return;
        showEditModal("Edit Name", NODE_DATA[id].name, (newName) => {
         if (!NODE_DATA[id]) return;
         pushUndo("edit node name");
         NODE_DATA[id].name = newName;
         const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`, );
         if (nodeGroup) {
          const label = nodeGroup.querySelector(".node-label");
          if (label) label.textContent = newName;
         }
         if (currentNodeId === id) {
          document.getElementById("node-name").textContent = newName;
         }
        });
       }
       function editNodeIp(id) {
        if (!NODE_DATA[id]) return;
        showEditModal("Edit IP/Subtitle", NODE_DATA[id].ip, (newIp) => {
         if (!NODE_DATA[id]) return;
         pushUndo("edit node ip");
         NODE_DATA[id].ip = newIp;
         const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`, );
         if (nodeGroup) {
          const sub = nodeGroup.querySelector(".node-sub");
          if (sub) sub.textContent = newIp;
         }
         if (currentNodeId === id) {
          document.getElementById("node-ip").textContent = newIp;
         }
        });
       }
       function claimTheImmortal(id) {
	   if (isViewOnly()) return;
        if (!NODE_DATA[id]) return;
        currentNodeId = id;
        currentEdgeId = null;
        currentRectId = null;
        currentTextId = null;
        const data = NODE_DATA[id];
        document.querySelectorAll(".node-group").forEach((n) => {
         n.classList.toggle("active", n.dataset.nodeId === id);
        });
        document.querySelectorAll(".edge").forEach((e) => {
        const active = e.dataset.from === id || e.dataset.to === id;
        e.classList.toggle("active", active);
       });
       document.querySelectorAll(".rect-group").forEach((r) => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach((t) => t.classList.remove("active"));
       document.getElementById("node-panel").style.display = "block";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        const toolbar = document.getElementById("topology-toolbar");
        if (!topologyToolbarCollapsed) {
         toolbar.style.display = "flex";
        }
        updateTopologyToolbarVisibility();
        document.getElementById("node-name").textContent = data.name;
        document.getElementById("node-ip").textContent = data.ip;
        document.getElementById("node-mac").textContent = data.mac || "--";
        document.getElementById("node-rack").textContent = data.rackUnit || "--";
        document.getElementById("node-uheight").textContent = (data.uHeight || "1") + "U";
        document.getElementById("node-role").textContent = data.role;
        populateRackDropdown();
        const assignedRackSelect = document.getElementById("node-assigned-rack");
        if (assignedRackSelect) {
         assignedRackSelect.value = data.assignedRack || "";
        }
        const rackCapacitySelect = document.getElementById("node-rack-capacity");
        if (rackCapacitySelect) {
         rackCapacitySelect.value = data.rackCapacity || "42";
        }
        const isRack = data.isRack === true;
        const isAssignedToRack = !!data.assignedRack;
        const assignedRackRow = document.getElementById("assigned-rack-row");
        const rackCapacityRow = document.getElementById("rack-capacity-row");
        const uheightRow = document.getElementById("uheight-row");
        if (assignedRackRow) assignedRackRow.style.display = isRack ? "none" : "flex";
        if (rackCapacityRow) rackCapacityRow.style.display = isRack ? "flex" : "none";
        if (uheightRow) uheightRow.style.display = isAssignedToRack ? "flex" : "none";
		const delBtn = document.getElementById("delete-node-btn");
        if (delBtn) delBtn.textContent = isRack ? "Delete Rack" : "Delete Node";
		const rackContentsSection = document.getElementById("rack-contents-section");
        const rackContentsList = document.getElementById("rack-contents-list");
        const rackContentsCount = document.getElementById("rack-contents-count");
        if (rackContentsSection && rackContentsList) {
        if (isRack) {
         const nodesInRack = Object.entries(NODE_DATA).filter(([nid, n]) => n.assignedRack === id);
         rackContentsCount.textContent = nodesInRack.length;
         if (nodesInRack.length > 0) {
          rackContentsList.innerHTML = nodesInRack.map(([nid, n]) => {
           const tags = (n.tags || []).map(t => `<span style="background: var(--accent); color: var(--bg); padding: 2px 6px; border-radius: 4px; font-size: 11px; margin-left: 4px;">${t}</span>`).join('');
           return `<div style="padding: 8px 4px; border-bottom: 1px solid var(--edge-main); cursor: pointer;" onclick="claimTheImmortal('${nid}')">
            <span style="color: var(--text-main);">${n.name}</span>${tags}
           </div>`;
          }).join('');
         } else {
          rackContentsList.innerHTML = '<div style="color: var(--text-soft); font-style: italic; padding: 8px 4px;">No nodes assigned</div>';
         }
         rackContentsSection.style.display = "block";
         } else {
         rackContentsSection.style.display = "none";
         }
        }
        document.getElementById("node-name").onclick = () => editNodeName(id);
        document.getElementById("node-ip").onclick = () => editNodeIp(id);
        document.getElementById("node-mac").onclick = () => editNodeMac(id);
        document.getElementById("node-rack").onclick = () => editNodeRack(id);
        document.getElementById("node-uheight").onclick = () => editNodeUHeight(id);
        const currentSize = savedSizes[id] || getDefaultSize();
        document.getElementById("size-slider").value = currentSize;
        document.getElementById("size-value").textContent = currentSize;
        const styleEntry = savedStyles[id] || {};
        const resolvedStyles = resolveStylesEntry(styleEntry);
        const scopeKey = currentStyleScope || "all";
        const flatProps = ["circleColor", "circleBorder", "titleColor", "titleFont", "titleSize", "subColor", "subFont", "subSize", ];
        const isFlat = flatProps.some((p) => Object.prototype.hasOwnProperty.call(styleEntry, p), );
        const scopedStyles = isFlat ? styleEntry : styleEntry[scopeKey] || {};
        const circleColorInput = document.getElementById("circle-color");
        const titleColorInput = document.getElementById("title-color");
        const titleFontSelect = document.getElementById("title-font");
        const titleSizeInput = document.getElementById("title-size");
        const subColorInput = document.getElementById("sub-color");
        const subFontSelect = document.getElementById("sub-font");
        const subSizeInput = document.getElementById("sub-size");
        const shapeSelect = document.getElementById("shape-select");
        const scopeSelect = document.getElementById("style-scope");
        circleColorInput.value = scopedStyles.circleColor || resolvedStyles.circleColor || PAGE_STATE.nodeFill || "#1e293b";
       const circleBorderInput = document.getElementById("circle-border");
       circleBorderInput.value = scopedStyles.circleBorder || resolvedStyles.circleBorder || PAGE_STATE.nodeStroke || "#475569";
        titleColorInput.value = scopedStyles.titleColor || resolvedStyles.titleColor || PAGE_STATE.textMain || "#e2e8f0";
        titleFontSelect.value = scopedStyles.titleFont || resolvedStyles.titleFont || "system-ui, sans-serif";
        titleSizeInput.value = scopedStyles.titleSize || resolvedStyles.titleSize || 18;
        subColorInput.value = scopedStyles.subColor || resolvedStyles.subColor || PAGE_STATE.textSoft || "#94a3b8";
        subFontSelect.value = scopedStyles.subFont || resolvedStyles.subFont || "system-ui, sans-serif";
        subSizeInput.value = scopedStyles.subSize || resolvedStyles.subSize || 13;
        const hasWebIcon = resolvedStyles.icon && resolvedStyles.icon.library;
        const customOpt = shapeSelect.querySelector('option[value="custom-icon"]');
        if (hasWebIcon) {
         if (!customOpt) {
          const opt = document.createElement('option');
          opt.value = 'custom-icon';
          opt.textContent = 'Custom Icon';
          shapeSelect.insertBefore(opt, shapeSelect.firstChild);
         }
         shapeSelect.value = 'custom-icon';
        } else {
         if (customOpt) customOpt.remove();
         shapeSelect.value = data.shape || "circle";
        }
        const layerSelect = document.getElementById("node-layer");
        if (layerSelect) {
         layerSelect.value = data.layer || "physical";
        }
        scopeSelect.value = currentStyleScope || "all";
        document.getElementById("title-offset-y").value = scopedStyles.titleOffsetY || resolvedStyles.titleOffsetY || 0;
        document.getElementById("title-offset-x").value = scopedStyles.titleOffsetX || resolvedStyles.titleOffsetX || 0;
        document.getElementById("sub-offset-y").value = scopedStyles.subOffsetY || resolvedStyles.subOffsetY || 0;
        document.getElementById("sub-offset-x").value = scopedStyles.subOffsetX || resolvedStyles.subOffsetX || 0;
      const pingOffsetXInput = document.getElementById("ping-offset-x");
      const pingOffsetYInput = document.getElementById("ping-offset-y");
      if (pingOffsetXInput && pingOffsetYInput) {
      pingOffsetXInput.value =
       (scopedStyles.pingOffsetX !== undefined
         ? scopedStyles.pingOffsetX
         : (resolvedStyles.pingOffsetX !== undefined
             ? resolvedStyles.pingOffsetX
             : 0));
      pingOffsetYInput.value =
       (scopedStyles.pingOffsetY !== undefined
         ? scopedStyles.pingOffsetY
         : (resolvedStyles.pingOffsetY !== undefined
             ? resolvedStyles.pingOffsetY
             : 0));
      }
        const tagEl = document.getElementById("node-tags");
        tagEl.innerHTML = "";
        data.tags.forEach((tag, i) => {
         const b = document.createElement("span");
         b.className = "badge";
         const isIconTag = typeof tag === 'object' && tag.type === 'icon';
         if (!isIconTag && typeof tag === 'string' && tag.toLowerCase().includes("wg")) b.classList.add("wg");
         b.style.cursor = "pointer";
         b.style.position = "relative";
         const tagContent = document.createElement("span");
         if (isIconTag) {
          b.classList.add("icon-badge");
          IconLibrary.getIcon(tag.library, tag.name).then(svgText => {
           if (svgText) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(svgText, 'image/svg+xml');
            const svgEl = doc.querySelector('svg');
            if (svgEl) {
             svgEl.setAttribute('width', '16');
             svgEl.setAttribute('height', '16');
             tagContent.innerHTML = '';
             tagContent.appendChild(svgEl);
             const nameSpan = document.createElement('span');
             nameSpan.textContent = tag.name;
             nameSpan.style.marginLeft = '4px';
             tagContent.appendChild(nameSpan);
            }
           }
          });
         } else {
          tagContent.textContent = tag;
          tagContent.addEventListener("click", (e) => {
           e.stopPropagation();
           showEditModal("Edit Tag", tag, (newTag) => {
            if (newTag) {
             pushUndo("edit tag");
             data.tags[i] = newTag;
             claimTheImmortal(id);
            }
           });
          });
         }
         const deleteTag = document.createElement("span");
         deleteTag.textContent = " ‚úï";
         deleteTag.style.opacity = "0.6";
         deleteTag.style.marginLeft = "4px";
         deleteTag.style.fontSize = "10px";
         deleteTag.addEventListener("click", (e) => {
          e.stopPropagation();
          pushUndo("delete tag");
          data.tags.splice(i, 1);
          claimTheImmortal(id);
         });
         b.append(tagContent, deleteTag);
         tagEl.append(b);
        });
        const addTagBtn = document.createElement("span");
        addTagBtn.className = "badge";
        addTagBtn.style.cursor = "pointer";
        addTagBtn.style.opacity = "0.6";
        addTagBtn.style.borderStyle = "dashed";
        addTagBtn.textContent = "+ Add Tag";
        addTagBtn.addEventListener("click", () => {
         showEditModal("Add Tag(s) : comma separated", "",
          (newTagStr) => {
           if (newTagStr) {
            pushUndo("add tags");
            const newTags = newTagStr.split(",").map((t) => t.trim()).filter((t) => t);
            newTags.forEach((t) => data.tags.push(t));
            claimTheImmortal(id);
           }
          }, );
        });
        tagEl.append(addTagBtn);
        const notesEl = document.getElementById("node-notes");
        notesEl.innerHTML = "";
        data.notes.forEach((note, i) => {
         const li = document.createElement("li");
         const noteText = document.createElement("span");
         noteText.textContent = note;
         noteText.style.flex = "1";
         const deleteBtn = document.createElement("span");
         deleteBtn.className = "delete-note";
         deleteBtn.textContent = "‚úï";
         deleteBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          challengeTheImmortal("Are you sure you want to delete this note?",
           () => {
            pushUndo("delete note");
            data.notes.splice(i, 1);
            claimTheImmortal(id);
           }, );
         });
         li.append(noteText, deleteBtn);
         noteText.addEventListener("dblclick", () => {
          noteText.classList.add("editing");
          noteText.contentEditable = true;
          noteText.focus();
         });
         noteText.addEventListener("blur", () => {
          noteText.classList.remove("editing");
          noteText.contentEditable = false;
          pushUndo("edit note");
          data.notes[i] = noteText.textContent;
         });
         notesEl.append(li);
        });
        const addLineSelect = document.getElementById("add-line-select");
      addLineSelect.innerHTML = "";
      const currentRack = data.assignedRack || "";
      Object.entries(NODE_DATA).forEach(([nodeId, node]) => {
      if (nodeId !== id) {
      const nodeRack = node.assignedRack || "";
      if (currentRack === nodeRack) {
      const opt = document.createElement("option");
      opt.value = nodeId;
      opt.textContent = node.name;
      addLineSelect.appendChild(opt);
      }
      }
      });
        const pingEnabled = data.ping && data.ping.enabled;
        document.getElementById('node-pingable').checked = pingEnabled;
        document.getElementById('node-ping-options').style.display = pingEnabled ? 'block' : 'none';
        if (data.ping) {
         document.getElementById('node-ping-protocol').value = data.ping.protocol || 'http';
         document.getElementById('node-custom-url').value = data.ping.customUrl || '';
         document.getElementById('node-ping-timeout').value = data.ping.timeout || 3000;
         document.getElementById('node-custom-url-container').style.display =
          data.ping.protocol === 'custom' ? 'block' : 'none';
         updatePingStatusDisplay(id);
        }
       }
       function updatePingStatusDisplay(nodeId) {
        const data = NODE_DATA[nodeId];
        if (!data || !data.ping) return;
        const statusEl = document.getElementById('node-ping-status');
        const lastCheckEl = document.getElementById('node-ping-last-check');
        const statusColors = {
         online: 'var(--accent)',
         offline: 'var(--danger)',
         checking: '#f59e0b',
         unknown: 'var(--text-soft)'
        };
        const statusTexts = {
         online: '‚óè Online',
         offline: '‚óè Offline',
         checking: '‚óè Checking...',
         unknown: '‚óè Unknown'
        };
        statusEl.textContent = statusTexts[data.ping.status] || statusTexts.unknown;
        statusEl.style.color = statusColors[data.ping.status] || statusColors.unknown;
        if (data.ping.lastCheck) {
         const checkTime = new Date(data.ping.lastCheck);
         lastCheckEl.textContent = `Last checked: ${checkTime.toLocaleTimeString()}`;
        } else {
         lastCheckEl.textContent = 'Never checked';
        }
       }
       function selectTheConnection(id) {
	   if (isViewOnly()) return;
        currentEdgeId = id;
        currentNodeId = null;
        currentRectId = null;
        currentTextId = null;
		if (isMobileDevice()) {
        const currentHeight = PAGE_STATE.mobileFooterHeight || 40;
        if (currentHeight <= 20) {
         PAGE_STATE.mobileFooterHeight = 80;
         const root = document.documentElement;
         root.style.setProperty("--mobile-footer-height", "80vh");
         const mobileFooterHeightInput = document.getElementById("mobile-footer-height");
         const mobileFooterHeightVal = document.getElementById("mobile-footer-height-val");
         if (mobileFooterHeightInput) mobileFooterHeightInput.value = 80;
         if (mobileFooterHeightVal) mobileFooterHeightVal.textContent = "80%";
        }
       }
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "block";
        document.getElementById("text-panel").style.display = "none";
       document.getElementById("rect-panel").style.display = "none";
       document.getElementById("topology-toolbar").style.display = "none";
       document.querySelectorAll(".node-group").forEach((n) => n.classList.remove("active"));
       document.querySelectorAll(".rect-group").forEach((r) => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach((t) => t.classList.remove("active"));
       document.querySelectorAll(".edge").forEach((e) => {
        e.classList.toggle("active", e.dataset.edgeId === id);
       });
        const edge = EDGE_DATA.list.find((e) => e.id === id);
        if (!edge) return;
        const directionSymbols = {
         none: "‚áÑ",
         forward: "‚Üí",
         backward: "‚Üê",
         both: "‚Üî",
        };
        const dirSymbol = directionSymbols[edge.direction] || "‚áÑ";
        let titleText = "Custom line";
        if (edge.from || edge.to) {
         const fromName = edge.from ? NODE_DATA[edge.from]?.name || edge.from : "";
         const toName = edge.to ? NODE_DATA[edge.to]?.name || edge.to : "";
         titleText = `${fromName || "?"} ${dirSymbol} ${toName || "?"}`;
        }
        document.getElementById("edge-title").textContent = titleText;
        const widthInput = document.getElementById("edge-width");
        const colorInput = document.getElementById("edge-color");
        const directionSelect = document.getElementById("edge-direction");
        const lineStyleSelect = document.getElementById("edge-line-style");
        widthInput.value = edge.width;
        colorInput.value = edge.color;
        directionSelect.value = edge.direction || "none";
        lineStyleSelect.value = edge.lineStyle || "solid";
        const fromPortInput = document.getElementById("edge-from-port");
        const toPortInput = document.getElementById("edge-to-port");
        const portFieldsFrom = document.getElementById("edge-port-fields");
        const portFieldsTo = document.getElementById("edge-port-fields-to");
        if (edge.type === "custom") {
         if (portFieldsFrom) portFieldsFrom.style.display = "none";
         if (portFieldsTo) portFieldsTo.style.display = "none";
        } else {
         if (portFieldsFrom) portFieldsFrom.style.display = "flex";
         if (portFieldsTo) portFieldsTo.style.display = "flex";
         if (fromPortInput) {
          fromPortInput.value = edge.fromPort || "";
          fromPortInput.onchange = () => updateEdgePortLabels(id);
         }
         if (toPortInput) {
          toPortInput.value = edge.toPort || "";
          toPortInput.onchange = () => updateEdgePortLabels(id);
         }
        }
        const list = document.getElementById("edge-notes");
        list.innerHTML = "";
        edge.notes.forEach((note, i) => {
         const li = document.createElement("li");
         const txt = document.createElement("span");
         txt.textContent = note;
         txt.style.flex = "1";
         const del = document.createElement("span");
         del.className = "delete-note";
         del.textContent = "‚úï";
         del.addEventListener("click", (e) => {
          e.stopPropagation();
         challengeTheImmortal("Delete this line note?", () => {
           pushUndo("delete edge note");
           edge.notes.splice(i, 1);
           selectTheConnection(id);
          });
         });
         txt.addEventListener("dblclick", () => {
          txt.classList.add("editing");
          txt.contentEditable = true;
          txt.focus();
         });
        txt.addEventListener("blur", () => {
          txt.classList.remove("editing");
          txt.contentEditable = false;
          pushUndo("edit edge note");
          edge.notes[i] = txt.textContent;
         });
         li.append(txt, del);
         list.appendChild(li);
       });
       if (edge.type === "custom" && Array.isArray(edge.points)) {
        forgeTheTopology();
       }
      }
       window.addEventListener("resize", () => {
        forgeTheTopology();
        if (currentEdgeId) {
         selectTheConnection(currentEdgeId);
        } else if (currentNodeId && NODE_DATA[currentNodeId]) {
         claimTheImmortal(currentNodeId);
        } else {
         const availableNodes = Object.keys(NODE_DATA);
         if (availableNodes.length > 0) {
          claimTheImmortal(availableNodes[0]);
         }
        }
       });
       (function initZoomPan() {
        const viewport = document.getElementById("canvas-viewport");
        const svg = document.getElementById("map");
        const hint = document.getElementById("canvas-hint");
        setTimeout(() => {
         hint.classList.add("visible");
         setTimeout(() => hint.classList.remove("visible"), 4000);
        }, 1000);
        viewport.addEventListener("wheel",
         (e) => {
          e.preventDefault();
          const rect = viewport.getBoundingClientRect();
          const mouseX = (e.clientX - rect.left) / rect.width;
          const mouseY = (e.clientY - rect.top) / rect.height;
          const delta = e.deltaY > 0 ? 0.9 : 1.1;
          zoomTo(canvasState.zoom * delta, mouseX, mouseY);
         }, {
          passive: false
         }, );
        let initialPinchDistance = 0;
        let initialPinchZoom = 1;
        let pinchCenter = {
         x: 0.5,
         y: 0.5
        };
        viewport.addEventListener("touchstart",
         (e) => {
          if (e.touches.length === 2) {
           e.preventDefault();
           const touch1 = e.touches[0];
           const touch2 = e.touches[1];
           initialPinchDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY, );
           initialPinchZoom = canvasState.zoom;
           const rect = viewport.getBoundingClientRect();
           const centerX = (touch1.clientX + touch2.clientX) / 2;
           const centerY = (touch1.clientY + touch2.clientY) / 2;
           pinchCenter.x = (centerX - rect.left) / rect.width;
           pinchCenter.y = (centerY - rect.top) / rect.height;
          }
         }, {
          passive: false
         }, );
        viewport.addEventListener("touchmove",
         (e) => {
          if (e.touches.length === 2) {
           e.preventDefault();
           const touch1 = e.touches[0];
           const touch2 = e.touches[1];
           const currentDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY, );
           if (initialPinchDistance > 0) {
            const scale = currentDistance / initialPinchDistance;
            const newZoom = initialPinchZoom * scale;
            zoomTo(newZoom, pinchCenter.x, pinchCenter.y);
           }
          }
         }, {
          passive: false
         }, );
        let panStartViewX = 0;
        let panStartViewY = 0;
        let lastEmptyTapTime = 0;
        let emptyTapTimeout = null;
        let emptyTapMoved = false;
        let emptyTapStartX = 0;
        let emptyTapStartY = 0;
        viewport.addEventListener("touchend", (e) => {
          if (currentView.mode !== "rack") return;
          if (e.changedTouches.length !== 1) return;
      const isNodeOrEdge = e.target.closest(".node-group") || e.target.closest(".edge-group");
         if (isNodeOrEdge) return;
          if (emptyTapMoved) {
            emptyTapMoved = false;
            return;
          }
          const currentTime = new Date().getTime();
          const tapGap = currentTime - lastEmptyTapTime;
          if (tapGap < 300 && tapGap > 0) {
            e.preventDefault();
            exitRack();
            if (navigator.vibrate) {
              navigator.vibrate(50);
            }
            lastEmptyTapTime = 0;
            if (emptyTapTimeout) {
              clearTimeout(emptyTapTimeout);
              emptyTapTimeout = null;
            }
          } else {
            lastEmptyTapTime = currentTime;
            if (emptyTapTimeout) clearTimeout(emptyTapTimeout);
            emptyTapTimeout = setTimeout(() => {
              lastEmptyTapTime = 0;
            }, 300);
          }
        }, { passive: false });
        viewport.addEventListener("mousedown", (e) => {
         if (e.target.closest(".draw-toolbar") || e.target.closest(".topology-toolbar") || e.target.closest(".legend-container")) {
          return;
         }
         if (freeDrawMode || rectDrawMode) {
          return;
         }
      const isEmptySpace = e.target === svg || e.target === viewport || e.target.tagName === "svg";
      const isEdgeElement = e.target.closest('.edge') || e.target.classList.contains('edge-edit-point');
      const isTextElement = e.target.closest('.text-group') || e.target.closest('.text-element');
      const isRectElement = e.target.closest('.rect-group');
      if (!isEdgeElement && !isTextElement && !isRectElement && currentEdgeId) {
      currentEdgeId = null;
      forgeTheTopology();
      }
      if (!isRectElement && currentRectId) {
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      }
         if (isViewOnly()) {
         document.body.classList.remove("view-only-inspect");
         document.getElementById("node-panel").style.display = "none";
         document.getElementById("edge-panel").style.display = "none";
        }
         if (isEmptySpace && e.shiftKey && e.button === 0) {
         if (isViewOnly()) return;
         e.preventDefault();
         startSelection(e);
         return;
        }
        if (isEmptySpace || e.button === 2 || e.button === 1) {
          e.preventDefault();
          canvasState.isPanning = true;
          canvasState.panStartX = e.clientX;
          canvasState.panStartY = e.clientY;
          panStartViewX = canvasState.panX;
          panStartViewY = canvasState.panY;
          viewport.classList.add("panning");
         }
        });
        viewport.addEventListener("touchstart",
         (e) => {
          if (e.target.closest(".draw-toolbar") || e.target.closest(".topology-toolbar") || e.target.closest(".legend-container")) {
           return;
          }
          if (freeDrawMode || rectDrawMode) {
           return;
          }
      const isEmptySpace = e.target === svg || e.target === viewport || e.target.tagName === "svg";
      const isEdgeElement = e.target.closest('.edge') || e.target.classList.contains('edge-edit-point');
      const isTextElement = e.target.closest('.text-group') || e.target.closest('.text-element');
      const isRectElement = e.target.closest('.rect-group');
      if (!isEdgeElement && !isTextElement && !isRectElement && currentEdgeId) {
      currentEdgeId = null;
      forgeTheTopology();
      }
      if (!isRectElement && currentRectId) {
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      }
          if (isEmptySpace && e.touches.length === 1) {
           e.preventDefault();
           emptyTapMoved = false;
           emptyTapStartX = e.touches[0].clientX;
           emptyTapStartY = e.touches[0].clientY;
           canvasState.isPanning = true;
           canvasState.panStartX = e.touches[0].clientX;
           canvasState.panStartY = e.touches[0].clientY;
           panStartViewX = canvasState.panX;
           panStartViewY = canvasState.panY;
           viewport.classList.add("panning");
          }
         }, {
          passive: false
         }, );
        document.addEventListener("mousemove", (e) => {
         if (isSelecting) {
          updateSelection(e);
          return;
         }
         if (!canvasState.isPanning) return;
         const dx = e.clientX - canvasState.panStartX;
         const dy = e.clientY - canvasState.panStartY;
         const rect = viewport.getBoundingClientRect();
         const viewWidth = CANVAS_WIDTH / canvasState.zoom;
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         const canvasDx = (dx / rect.width) * viewWidth;
         const canvasDy = (dy / rect.height) * viewHeight;
         canvasState.panX = panStartViewX - canvasDx;
         canvasState.panY = panStartViewY - canvasDy;
         constrainPan();
         updateViewBox();
        });
       document.addEventListener("touchmove", (e) => {
        if (!canvasState.isPanning || !e.touches[0]) return;
        const moveDx = Math.abs(e.touches[0].clientX - emptyTapStartX);
        const moveDy = Math.abs(e.touches[0].clientY - emptyTapStartY);
        if (moveDx > 15 || moveDy > 15) {
         emptyTapMoved = true;
        }
        const dx = e.touches[0].clientX - canvasState.panStartX;
         const dy = e.touches[0].clientY - canvasState.panStartY;
         const rect = viewport.getBoundingClientRect();
         const viewWidth = CANVAS_WIDTH / canvasState.zoom;
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         const canvasDx = (dx / rect.width) * viewWidth;
         const canvasDy = (dy / rect.height) * viewHeight;
         canvasState.panX = panStartViewX - canvasDx;
         canvasState.panY = panStartViewY - canvasDy;
         constrainPan();
         updateViewBox();
        });
        document.addEventListener("mouseup", () => {
         if (isSelecting) {
          endSelection();
         }
         if (canvasState.isPanning) {
          canvasState.isPanning = false;
          viewport.classList.remove("panning");
         }
        });
        document.addEventListener("touchend", () => {
         if (canvasState.isPanning) {
          canvasState.isPanning = false;
          viewport.classList.remove("panning");
         }
        });
        document.addEventListener("keydown", (e) => {
         const isEditing = document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "TEXTAREA" || document.activeElement.isContentEditable;
         if (e.code === "Space" && !e.repeat && !isEditing) {
          e.preventDefault();
          canvasState.spacePressed = true;
          viewport.style.cursor = "grab";
         }
        });
        document.addEventListener("keyup", (e) => {
         if (e.code === "Space") {
          canvasState.spacePressed = false;
          viewport.style.cursor = "";
         }
        });
        document.getElementById("zoom-in-btn").addEventListener("click", () => {
         zoomTo(canvasState.zoom * 1.25, 0.5, 0.5);
        });
        document.getElementById("zoom-out-btn").addEventListener("click", () => {
         zoomTo(canvasState.zoom * 0.8, 0.5, 0.5);
        });
        document.getElementById("zoom-fit-btn").addEventListener("click", fitToContent);
        document.getElementById("zoom-reset-btn").addEventListener("click", resetView);
        const minimapContainer = document.getElementById("minimap-container");
        const minimapSvg = document.getElementById("minimap");
        let minimapDragging = false;
        minimapContainer.addEventListener("mousedown", (e) => {
         e.preventDefault();
         minimapDragging = true;
         updatePanFromMinimap(e);
        });
        minimapContainer.addEventListener("touchstart",
         (e) => {
          e.preventDefault();
          minimapDragging = true;
          updatePanFromMinimapTouch(e);
         }, {
          passive: false
         }, );
        document.addEventListener("mousemove", (e) => {
         if (minimapDragging) {
          updatePanFromMinimap(e);
         }
        });
        document.addEventListener("touchmove", (e) => {
         if (minimapDragging && e.touches[0]) {
          updatePanFromMinimapTouch(e);
         }
        });
        document.addEventListener("mouseup", () => {
         minimapDragging = false;
        });
        document.addEventListener("touchend", () => {
         minimapDragging = false;
        });
        function updatePanFromMinimap(e) {
         const rect = minimapContainer.getBoundingClientRect();
         const x = (e.clientX - rect.left) / rect.width;
         const y = (e.clientY - rect.top) / rect.height;
         const viewWidth = CANVAS_WIDTH / canvasState.zoom;
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         canvasState.panX = x * CANVAS_WIDTH - viewWidth / 2;
         canvasState.panY = y * CANVAS_HEIGHT - viewHeight / 2;
         constrainPan();
         updateViewBox();
        }
        function updatePanFromMinimapTouch(e) {
         const rect = minimapContainer.getBoundingClientRect();
         const touch = e.touches[0];
         const x = (touch.clientX - rect.left) / rect.width;
         const y = (touch.clientY - rect.top) / rect.height;
         const viewWidth = CANVAS_WIDTH / canvasState.zoom;
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         canvasState.panX = x * CANVAS_WIDTH - viewWidth / 2;
         canvasState.panY = y * CANVAS_HEIGHT - viewHeight / 2;
         constrainPan();
         updateViewBox();
        }
        document.addEventListener("keydown", (e) => {
         if (document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "TEXTAREA") return;
         if (
          (e.key === "+" || e.key === "=") && (e.ctrlKey || e.metaKey)) {
          e.preventDefault();
          zoomTo(canvasState.zoom * 1.25, 0.5, 0.5);
         } else if (e.key === "-" && (e.ctrlKey || e.metaKey)) {
          e.preventDefault();
          zoomTo(canvasState.zoom * 0.8, 0.5, 0.5);
         } else if (e.key === "0" && (e.ctrlKey || e.metaKey)) {
          e.preventDefault();
          resetView();
         }
        });
        setTimeout(() => {
         fitToContent();
        }, 100);
       })();
       const sizeSlider = document.getElementById("size-slider");
       const sizeValue = document.getElementById("size-value");
       const resetSizeBtn = document.getElementById("reset-size");
       sizeSlider.addEventListener("input", () => {
        const newSize = parseInt(sizeSlider.value, 10);
        sizeValue.textContent = newSize;
        pushUndo("resize node");
        savedSizes[currentNodeId] = newSize;
        const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
        if (nodeGroup) {
         const oldShape = nodeGroup.querySelector(".node-circle");
         if (oldShape) oldShape.remove();
         const newShape = createNodeShape(currentNodeId, newSize);
         nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
         const styles = resolveStylesForNode(currentNodeId);
         if (styles.circleColor) newShape.style.fill = styles.circleColor;
      if (styles.circleBorder) newShape.style.stroke = styles.circleBorder;
         const label = nodeGroup.querySelector(".node-label");
         const sub = nodeGroup.querySelector(".node-sub");
         if (label) {
          label.setAttribute("y", -newSize * 0.28);
          const labelSize = styles.titleSize || newSize * 0.33;
          label.style.fontSize = labelSize + "px";
         }
         if (sub) {
          sub.setAttribute("y", newSize * 0.4);
          const subSize = styles.subSize || newSize * 0.24;
          sub.style.fontSize = subSize + "px";
         }
       updatePingIndicator(currentNodeId);
        }
       });
       resetSizeBtn.addEventListener("click", () => {
        pushUndo("reset size");
        delete savedSizes[currentNodeId];
        const defaultSize = getDefaultSize();
        sizeSlider.value = defaultSize;
        sizeValue.textContent = defaultSize;
        const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
        if (nodeGroup) {
         const oldShape = nodeGroup.querySelector(".node-circle");
         if (oldShape) oldShape.remove();
         const shapeType = (NODE_DATA[currentNodeId] && NODE_DATA[currentNodeId].shape) || "circle";
         const newShape = createNodeShape(currentNodeId, defaultSize);
         nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
         const styles = resolveStylesForNode(currentNodeId);
         if (styles.circleColor) newShape.style.fill = styles.circleColor;
      if (styles.circleBorder) newShape.style.stroke = styles.circleBorder;
         const label = nodeGroup.querySelector(".node-label");
         const sub = nodeGroup.querySelector(".node-sub");
         if (label) {
          label.setAttribute("y", -defaultSize * 0.28);
          const labelSize = styles.titleSize || defaultSize * 0.33;
          label.style.fontSize = labelSize + "px";
         }
         if (sub) {
          sub.setAttribute("y", defaultSize * 0.4);
          const subSize = styles.subSize || defaultSize * 0.24;
          sub.style.fontSize = subSize + "px";
         }
          updatePingIndicator(currentNodeId);
        }
       });
       const applyStyle = (property, value) => {
        pushUndo("style change");
        const styleEntry = ensureStyleEntry(currentNodeId);
        const scopeKey = currentStyleScope || "all";
        if (!styleEntry[scopeKey]) styleEntry[scopeKey] = {};
        styleEntry[scopeKey][property] = value;
        const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
        if (!nodeGroup) return;
        const shapeEl = nodeGroup.querySelector(".node-circle");
        const label = nodeGroup.querySelector(".node-label");
        const sub = nodeGroup.querySelector(".node-sub");
        const isWebIcon = shapeEl && shapeEl.querySelector('svg');
        if (property === "circleColor" && shapeEl) {
         if (isWebIcon) {
          shapeEl.querySelectorAll('svg, path, circle, rect, polygon, ellipse').forEach(el => el.style.fill = value);
         } else {
          shapeEl.style.fill = value;
         }
        } else if (property === "circleBorder" && shapeEl) {
         if (isWebIcon) {
          shapeEl.querySelectorAll('svg, path, circle, rect, polygon, ellipse').forEach(el => el.style.stroke = value);
         } else {
          shapeEl.style.stroke = value;
         }
        } else if (property === "titleColor" && label) label.style.fill = value;
        else if (property === "titleFont" && label) label.style.fontFamily = value;
        else if (property === "titleSize" && label) label.style.fontSize = value + "px";
        else if (property === "subColor" && sub) sub.style.fill = value;
        else if (property === "subFont" && sub) sub.style.fontFamily = value;
        else if (property === "subSize" && sub) sub.style.fontSize = value + "px";
       };
       document.getElementById("circle-color").addEventListener("input", (e) => applyStyle("circleColor", e.target.value), );
      document.getElementById("circle-border").addEventListener("input", (e) => applyStyle("circleBorder", e.target.value), );
       document.getElementById("title-color").addEventListener("input", (e) => applyStyle("titleColor", e.target.value), );
       document.getElementById("title-font").addEventListener("change", (e) => applyStyle("titleFont", e.target.value), );
       document.getElementById("title-size").addEventListener("input", (e) => applyStyle("titleSize", parseInt(e.target.value, 10)), );
       document.getElementById("sub-color").addEventListener("input", (e) => applyStyle("subColor", e.target.value), );
       document.getElementById("sub-font").addEventListener("change", (e) => applyStyle("subFont", e.target.value), );
       document.getElementById("sub-size").addEventListener("input", (e) => applyStyle("subSize", parseInt(e.target.value, 10)), );
       document.getElementById("title-offset-y").addEventListener("input", (e) => {
        applyStyle("titleOffsetY", parseInt(e.target.value, 10) || 0);
        forgeTheTopology();
        if (currentNodeId) claimTheImmortal(currentNodeId);
       });
       document.getElementById("title-offset-x").addEventListener("input", (e) => {
        applyStyle("titleOffsetX", parseInt(e.target.value, 10) || 0);
        forgeTheTopology();
        if (currentNodeId) claimTheImmortal(currentNodeId);
       });
       document.getElementById("sub-offset-y").addEventListener("input", (e) => {
        applyStyle("subOffsetY", parseInt(e.target.value, 10) || 0);
        forgeTheTopology();
        if (currentNodeId) claimTheImmortal(currentNodeId);
       });
       document.getElementById("sub-offset-x").addEventListener("input", (e) => {
        applyStyle("subOffsetX", parseInt(e.target.value, 10) || 0);
        forgeTheTopology();
        if (currentNodeId) claimTheImmortal(currentNodeId);
       });
      document.getElementById("ping-offset-x").addEventListener("input", (e) => {
      applyStyle("pingOffsetX", parseInt(e.target.value, 10) || 0);
      updatePingIndicator(currentNodeId);
      if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      document.getElementById("ping-offset-y").addEventListener("input", (e) => {
      applyStyle("pingOffsetY", parseInt(e.target.value, 10) || 0);
      updatePingIndicator(currentNodeId);
      if (currentNodeId) claimTheImmortal(currentNodeId);
      });
       document.getElementById("reset-styles").addEventListener("click", () => {
        delete savedStyles[currentNodeId];
        forgeTheTopology();
        claimTheImmortal(currentNodeId);
       });
       document.getElementById("style-scope").addEventListener("change", (e) => {
        currentStyleScope = e.target.value || "all";
        claimTheImmortal(currentNodeId);
       });
       document.getElementById("shape-select").addEventListener("change", (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId]) return;
        const shape = e.target.value || "circle";
        if (shape === 'custom-icon') return;
        pushUndo("change shape");
        NODE_DATA[currentNodeId].shape = shape;
        if (savedStyles[currentNodeId]) {
         Object.keys(savedStyles[currentNodeId]).forEach(scope => {
          if (savedStyles[currentNodeId][scope] && savedStyles[currentNodeId][scope].icon) {
           delete savedStyles[currentNodeId][scope].icon;
          }
         });
        }
        const customOpt = e.target.querySelector('option[value="custom-icon"]');
        if (customOpt) customOpt.remove();
        forgeTheTopology();
       });
       const addNoteBtn = document.getElementById("add-note-btn");
       const noteInput = document.getElementById("new-note-input");
       addNoteBtn.addEventListener("click", () => {
        const newNote = noteInput.value.trim();
        if (newNote && currentNodeId && NODE_DATA[currentNodeId]) {
         pushUndo("add note");
         NODE_DATA[currentNodeId].notes.push(newNote);
         claimTheImmortal(currentNodeId);
         noteInput.value = "";
        }
       });
       noteInput.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
         addNoteBtn.click();
        }
       });
       document.getElementById('node-pingable').addEventListener('change', (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId]) return;
        if (!NODE_DATA[currentNodeId].ping) {
         NODE_DATA[currentNodeId].ping = {
          enabled: false,
          protocol: 'http',
          customUrl: '',
          timeout: 3000,
          status: 'unknown',
          lastCheck: null
         };
        }
        NODE_DATA[currentNodeId].ping.enabled = e.target.checked;
        document.getElementById('node-ping-options').style.display = e.target.checked ? 'block' : 'none';
        forgeTheTopology();
       });
       document.getElementById('node-ping-protocol').addEventListener('change', (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId].ping) return;
        NODE_DATA[currentNodeId].ping.protocol = e.target.value;
        document.getElementById('node-custom-url-container').style.display =
         e.target.value === 'custom' ? 'block' : 'none';
       });
       document.getElementById('node-custom-url').addEventListener('change', (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId].ping) return;
        NODE_DATA[currentNodeId].ping.customUrl = e.target.value.trim();
       });
       document.getElementById('node-ping-timeout').addEventListener('change', (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId].ping) return;
        NODE_DATA[currentNodeId].ping.timeout = parseInt(e.target.value) || 3000;
       });
       document.getElementById('check-ping-now').addEventListener('click', () => {
        if (!currentNodeId) return;
        checkNodeStatus(currentNodeId);
       });
       document.getElementById("edge-width").addEventListener("input", () => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        const v = parseInt(document.getElementById("edge-width").value, 10);
        if (Number.isNaN(v) || v <= 0) return;
        pushUndo("edit edge");
        edge.width = v;
        const el = document.querySelector(`.edge[data-edge-id="${currentEdgeId}"]`, );
        if (el) el.style.strokeWidth = v;
       });
       document.getElementById("edge-color").addEventListener("input", () => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        const color = document.getElementById("edge-color").value;
        pushUndo("edit edge");
        edge.color = color;
        const el = document.querySelector(`.edge[data-edge-id="${currentEdgeId}"]`, );
        if (el) el.style.stroke = color;
        forgeTheLegend();
       });
       document.getElementById("edge-direction").addEventListener("change", () => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        pushUndo("edit edge");
        edge.direction = document.getElementById("edge-direction").value;
        forgeTheTopology();
        selectTheConnection(currentEdgeId);
       });
       document.getElementById("edge-line-style").addEventListener("change", () => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        pushUndo("edit edge");
        edge.lineStyle = document.getElementById("edge-line-style").value;
        forgeTheTopology();
        selectTheConnection(currentEdgeId);
       });
       const addEdgeNoteBtn = document.getElementById("add-edge-note");
       const newEdgeNoteInput = document.getElementById("new-edge-note");
       addEdgeNoteBtn.addEventListener("click", () => {
        const txt = newEdgeNoteInput.value.trim();
        if (!txt || !currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
		pushUndo("add edge note");
        edge.notes.push(txt);
        newEdgeNoteInput.value = "";
        selectTheConnection(currentEdgeId);
       });
       newEdgeNoteInput.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
         addEdgeNoteBtn.click();
        }
       });
      function selectTheRect(id) {
	  if (isViewOnly()) return;
      currentRectId = id;
      currentNodeId = null;
      currentEdgeId = null;
      currentTextId = null;
      document.getElementById("node-panel").style.display = "none";
      document.getElementById("edge-panel").style.display = "none";
      document.getElementById("text-panel").style.display = "none";
      document.getElementById("rect-panel").style.display = "block";
      document.getElementById("topology-toolbar").style.display = "none";
      document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active"));
      document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
      document.querySelectorAll(".text-element").forEach(t => t.classList.remove("active"));
      document.querySelectorAll(".rect-group").forEach(r => r.classList.toggle("active", r.dataset.rectId === id));
      const rect = RECT_DATA.list.find(r => r.id === id);
      if (!rect) return;
      document.getElementById("rect-title").textContent = "";
      document.getElementById("rect-color").value = rect.color || "#f97316";
      document.getElementById("rect-border-color").value = rect.borderColor || rect.color || "#f97316";
      document.getElementById("rect-border-width").value = rect.borderWidth !== undefined ? rect.borderWidth : 2;
      document.getElementById("rect-style-select").value = rect.style || "filled";
      document.getElementById("rect-line-style").value = rect.lineStyle || "solid";
      document.getElementById("rect-fill-row").style.display = (rect.style === "outlined") ? "none" : "flex";
      const list = document.getElementById("rect-notes");
      list.innerHTML = "";
      (rect.notes || []).forEach((note, i) => {
      const li = document.createElement("li");
      const txt = document.createElement("span");
      txt.textContent = note;
      txt.style.flex = "1";
      const del = document.createElement("span");
      del.className = "delete-note";
      del.textContent = "‚úï";
      del.addEventListener("click", (e) => {
      e.stopPropagation();
      challengeTheImmortal("Delete this note?", () => {
        pushUndo("delete zone note");
        rect.notes.splice(i, 1);
        selectTheRect(id);
      });
      });
      li.appendChild(txt);
      li.appendChild(del);
      list.appendChild(li);
      });
      forgeTheTopology();
      }
      document.getElementById("rect-color").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.color = document.getElementById("rect-color").value;
      forgeTheTopology();
      });
      document.getElementById("rect-border-color").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.borderColor = document.getElementById("rect-border-color").value;
      forgeTheTopology();
      });
      document.getElementById("rect-border-width").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.borderWidth = parseInt(document.getElementById("rect-border-width").value) || 2;
      forgeTheTopology();
      });
      document.getElementById("rect-style-select").addEventListener("change", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.style = document.getElementById("rect-style-select").value;
      forgeTheTopology();
      selectTheRect(currentRectId);
      });
	  document.getElementById("rect-line-style").addEventListener("change", () => {
      if (!currentRectId) return;
      pushUndo("change zone line style");
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      rect.lineStyle = document.getElementById("rect-line-style").value;
      forgeTheTopology();
      });
      document.getElementById("add-rect-note").addEventListener("click", () => {
      const input = document.getElementById("new-rect-note");
      const txt = input.value.trim();
      if (!txt || !currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      if (!rect.notes) rect.notes = [];
	  pushUndo("add zone note");
      rect.notes.push(txt);
      input.value = "";
      selectTheRect(currentRectId);
      });
      document.getElementById("new-rect-note").addEventListener("keypress", (e) => {
      if (e.key === "Enter") {
      document.getElementById("add-rect-note").click();
      }
      });
      document.getElementById("delete-rect").addEventListener("click", () => {
      if (!currentRectId) return;
      challengeTheImmortal("Delete this box?", () => {
      pushUndo("delete zone");
      RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== currentRectId);
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      });
      });
       document.getElementById("delete-edge").addEventListener("click", () => {
        if (!currentEdgeId) return;
        challengeTheImmortal("Are you sure you want to delete this line?",
         () => {
          pushUndo("delete edge");
          EDGE_DATA.list = EDGE_DATA.list.filter(
           (e) => e.id !== currentEdgeId, );
          currentEdgeId = null;
          forgeTheTopology();
          const availableNodes = Object.keys(NODE_DATA);
          if (availableNodes.length > 0) {
           claimTheImmortal(availableNodes[0]);
          } else {
           document.getElementById("node-panel").style.display = "none";
           document.getElementById("edge-panel").style.display = "none";
           document.getElementById("topology-toolbar", ).style.display = "none";
          }
         }, );
       });
       document.getElementById("add-line-btn").addEventListener("click", () => {
        if (!currentNodeId) return;
        const select = document.getElementById("add-line-select");
        const directionSelect = document.getElementById("add-line-direction");
        const colorInput = document.getElementById("add-line-color");
        const targetId = select.value;
        if (!targetId || targetId === currentNodeId) return;
        const direction = directionSelect.value || "none";
        const lineColor = colorInput.value || "#475569";
        const newId = `${currentNodeId}-${targetId}-${Date.now()}`;
        const newEdge = {
         id: newId,
         from: currentNodeId,
         to: targetId,
         width: 4,
         color: lineColor,
         direction: direction,
         type: "main",
         notes: [],
         fromPort: "",
         toPort: "",
        };
		pushUndo("add edge");
        EDGE_DATA.list.push(newEdge);
        forgeTheTopology();
        claimTheImmortal(currentNodeId);
       });
       let rectStartPoint = null;
       let rectPreviewEl = null;
       let rectStyle = "filled";
       let freeDrawPoints = [];
       let freeDrawPolylineEl = null;
       let freeDrawPointEls = [];
       const drawToggleBtn = document.getElementById("draw-toggle");
       const drawUndoBtn = document.getElementById("draw-undo");
       const drawColorInput = document.getElementById("draw-color");
       const drawStyleSelect = document.getElementById("draw-style");
       const drawArrowSelect = document.getElementById("draw-arrow");
       const svgMap = document.getElementById("map");
       function updateFreeDrawGraphics() {
        const ns = "http://www.w3.org/2000/svg";
        const svg = svgMap;
        if (!freeDrawPolylineEl && freeDrawPoints.length > 0) {
         freeDrawPolylineEl = document.createElementNS(ns, "polyline");
         freeDrawPolylineEl.classList.add("edge", "free-preview");
         freeDrawPolylineEl.setAttribute("fill", "none");
         svg.appendChild(freeDrawPolylineEl);
        }
        if (freeDrawPolylineEl) {
         if (freeDrawPoints.length === 0) {
          freeDrawPolylineEl.remove();
          freeDrawPolylineEl = null;
         } else {
          const ptsStr = freeDrawPoints.map((p) => `${p.x},${p.y}`).join(" ");
          freeDrawPolylineEl.setAttribute("points", ptsStr);
          freeDrawPolylineEl.style.stroke = drawColorInput.value || "#475569";
          freeDrawPolylineEl.style.strokeWidth = 3;
          const lineStyle = drawStyleSelect.value || "solid";
          if (lineStyle === "dashed") {
           freeDrawPolylineEl.style.strokeDasharray = "10,5";
          } else if (lineStyle === "dotted") {
           freeDrawPolylineEl.style.strokeDasharray = "2,4";
          } else {
           freeDrawPolylineEl.style.strokeDasharray = "none";
          }
         }
        }
        freeDrawPointEls.forEach((el) => el.remove());
        freeDrawPointEls = [];
        freeDrawPoints.forEach((p, idx) => {
         const c = document.createElementNS(ns, "circle");
         c.classList.add("free-point");
         c.setAttribute("cx", p.x);
         c.setAttribute("cy", p.y);
         c.setAttribute("r", 5);
         c.dataset.index = String(idx);
         c.addEventListener("mousedown", (e) => {
          if (!freeDrawMode) return;
          e.preventDefault();
          e.stopPropagation();
          let dragging = true;
          const svgEl = svgMap;
          const moveHandler = (ev) => {
           if (!dragging) return;
           const pt = svgEl.createSVGPoint();
           pt.x = ev.clientX;
           pt.y = ev.clientY;
           const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
           const i = parseInt(c.dataset.index, 10);
           if (Number.isNaN(i) || !freeDrawPoints[i]) return;
           freeDrawPoints[i].x = svgP.x;
           freeDrawPoints[i].y = svgP.y;
           updateFreeDrawGraphics();
          };
          const upHandler = () => {
           dragging = false;
           document.removeEventListener("mousemove", moveHandler);
           document.removeEventListener("mouseup", upHandler);
          };
          document.addEventListener("mousemove", moveHandler);
          document.addEventListener("mouseup", upHandler);
         });
         c.addEventListener("touchstart",
          (e) => {
           if (!freeDrawMode) return;
           e.preventDefault();
           e.stopPropagation();
           let dragging = true;
           const svgEl = svgMap;
           const touchMoveHandler = (ev) => {
            if (!dragging || !ev.touches[0]) return;
            const pt = svgEl.createSVGPoint();
            pt.x = ev.touches[0].clientX;
            pt.y = ev.touches[0].clientY;
            const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
            const i = parseInt(c.dataset.index, 10);
            if (Number.isNaN(i) || !freeDrawPoints[i]) return;
            freeDrawPoints[i].x = svgP.x;
            freeDrawPoints[i].y = svgP.y;
            updateFreeDrawGraphics();
           };
           const touchUpHandler = () => {
            dragging = false;
            document.removeEventListener("touchmove", touchMoveHandler, );
            document.removeEventListener("touchend", touchUpHandler, );
           };
           document.addEventListener("touchmove", touchMoveHandler);
           document.addEventListener("touchend", touchUpHandler);
          }, {
           passive: false
          }, );
         svg.appendChild(c);
         freeDrawPointEls.push(c);
        });
        drawUndoBtn.style.display = freeDrawPoints.length ? "inline-block" : "none";
       }
       function addFreeDrawPoint(x, y) {
        freeDrawPoints.push({
         x,
         y
        });
        updateFreeDrawGraphics();
       }
       function startFreeDraw() {
        freeDrawMode = true;
        freeDrawPoints = [];
        if (freeDrawPolylineEl) {
         freeDrawPolylineEl.remove();
         freeDrawPolylineEl = null;
        }
        freeDrawPointEls.forEach((el) => el.remove());
        freeDrawPointEls = [];
        svgMap.style.cursor = "crosshair";
        drawToggleBtn.textContent = "Done";
        drawUndoBtn.style.display = "none";
       }
       function finishFreeDraw() {
        freeDrawMode = false;
        svgMap.style.cursor = "";
        drawToggleBtn.textContent = "‚úèÔ∏è";
        if (freeDrawPoints.length >= 2) {
         const color = drawColorInput.value || "#475569";
         const lineStyle = drawStyleSelect.value || "solid";
         const arrowDir = drawArrowSelect.value || "none";
         const newId = "custom-" + Date.now();
         const pointsCopy = freeDrawPoints.map((p) => ({
          x: p.x,
          y: p.y,
         }));
         EDGE_DATA.list.push({
          id: newId,
          type: "custom",
          color,
          width: 4,
          lineStyle: lineStyle,
          direction: arrowDir,
          points: pointsCopy,
          notes: [],
         });
         freeDrawPoints = [];
         if (freeDrawPolylineEl) {
          freeDrawPolylineEl.remove();
          freeDrawPolylineEl = null;
         }
         freeDrawPointEls.forEach((el) => el.remove());
         freeDrawPointEls = [];
         forgeTheTopology();
         selectTheConnection(newId);
        } else {
         freeDrawPoints = [];
         if (freeDrawPolylineEl) {
          freeDrawPolylineEl.remove();
          freeDrawPolylineEl = null;
         }
         freeDrawPointEls.forEach((el) => el.remove());
         freeDrawPointEls = [];
         forgeTheLegend();
        }
        drawUndoBtn.style.display = "none";
       }
       drawToggleBtn.addEventListener("click", () => {
        if (currentView.mode === "rack") {
         alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
         return;
        }
        if (freeDrawMode) {
         finishFreeDraw();
        } else {
         startFreeDraw();
        }
       });
       drawUndoBtn.addEventListener("click", () => {
        if (!freeDrawMode || !freeDrawPoints.length) return;
        freeDrawPoints.pop();
        updateFreeDrawGraphics();
       });
       const drawToolbar = document.getElementById("draw-toolbar");
       drawToolbar.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       drawToolbar.addEventListener("click", (e) => {
        if (e.target !== drawToggleBtn && e.target !== drawUndoBtn) {
         e.stopPropagation();
        }
       });
       drawStyleSelect.addEventListener("change", () => {
        if (freeDrawMode) {
         updateFreeDrawGraphics();
        }
       });
       drawArrowSelect.addEventListener("change", () => {
        if (freeDrawMode) {
         updateFreeDrawGraphics();
        }
       });
       drawColorInput.addEventListener("input", () => {
        if (freeDrawMode) {
         updateFreeDrawGraphics();
        }
       });
       drawStyleSelect.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       drawStyleSelect.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       drawArrowSelect.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       drawArrowSelect.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       drawColorInput.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       drawColorInput.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       svgMap.addEventListener("click", (e) => {
        if (!freeDrawMode) return;
        if (e.button !== 0) return;
        const target = e.target;
        if (target && target.classList && target.classList.contains("free-point")) return;
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        addFreeDrawPoint(svgP.x, svgP.y);
       });
       svgMap.addEventListener("touchend",
        (e) => {
         if (!freeDrawMode) return;
         const target = e.target;
         if (target && target.classList && target.classList.contains("free-point")) return;
         if (e.changedTouches && e.changedTouches[0]) {
          e.preventDefault();
          const svgEl = svgMap;
          const pt = svgEl.createSVGPoint();
          pt.x = e.changedTouches[0].clientX;
          pt.y = e.changedTouches[0].clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          addFreeDrawPoint(svgP.x, svgP.y);
         }
        }, {
         passive: false
        }, );
       const settingsBtn = document.getElementById("settings-btn");
       const rectToggleBtn = document.getElementById("rect-toggle");
       const rectStyleSelect = document.getElementById("rect-style");
       function updateRectPreview() {
        if (!rectPreviewEl || !rectStartPoint) return;
        const ns = "http://www.w3.org/2000/svg";
        const svg = svgMap;
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
       }
       function startRectDraw() {
        rectDrawMode = true;
        rectStartPoint = null;
        rectPreviewEl = null;
        svgMap.style.cursor = "crosshair";
        rectToggleBtn.textContent = "Done";
        rectStyle = rectStyleSelect.value || "filled";
        if (freeDrawMode) {
         finishFreeDraw();
        }
        updateRectangleDeleteButtons();
       }
       function finishRectDraw() {
        rectDrawMode = false;
        svgMap.style.cursor = "";
        rectToggleBtn.textContent = "‚ñ≠";
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
		updateRectangleDeleteButtons();
       }
       rectToggleBtn.addEventListener("click", () => {
        if (currentView.mode === "rack") {
         alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
         return;
        }
        if (rectDrawMode) {
         finishRectDraw();
        } else {
         startRectDraw();
        }
       });
       rectStyleSelect.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       rectStyleSelect.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       rectStyleSelect.addEventListener("change", () => {
        if (rectDrawMode) {
         rectStyle = rectStyleSelect.value || "filled";
        }
       });
       svgMap.addEventListener("mousedown", (e) => {
        if (!rectDrawMode) return;
        if (e.button !== 0) return;
        e.preventDefault();
        e.stopPropagation();
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        rectStartPoint = { x: svgP.x, y: svgP.y };
        const ns = "http://www.w3.org/2000/svg";
        rectPreviewEl = document.createElementNS(ns, "rect");
        rectPreviewEl.classList.add("rect-preview");
        rectPreviewEl.setAttribute("x", svgP.x);
        rectPreviewEl.setAttribute("y", svgP.y);
        rectPreviewEl.setAttribute("width", 0);
        rectPreviewEl.setAttribute("height", 0);
        const color = drawColorInput.value || "#f97316";
        rectPreviewEl.style.stroke = color;
        rectPreviewEl.style.strokeWidth = 2;
        rectPreviewEl.style.strokeDasharray = "5,5";
        if (rectStyle === "filled") {
         rectPreviewEl.style.fill = color;
         rectPreviewEl.style.fillOpacity = "0.3";
        } else {
         rectPreviewEl.style.fill = "none";
        }
        svgEl.appendChild(rectPreviewEl);
       });
       svgMap.addEventListener("mousemove", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        rectPreviewEl.setAttribute("x", x);
        rectPreviewEl.setAttribute("y", y);
        rectPreviewEl.setAttribute("width", width);
        rectPreviewEl.setAttribute("height", height);
       });
       svgMap.addEventListener("mouseup", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        if (width > 10 && height > 10) {
      pushUndo("draw zone");
         const color = drawColorInput.value || "#f97316";
         const newId = "rect-" + Date.now();
         const lineStyle = document.getElementById("draw-style").value || "solid";
         RECT_DATA.list.push({
          id: newId,
          x: x,
          y: y,
          width: width,
          height: height,
          color: color,
          style: rectStyle,
          lineStyle: lineStyle,
          notes: []
         });
         forgeTheTopology();
        }
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
       });
       let rectTouchStart = null;
       svgMap.addEventListener("touchstart", (e) => {
        if (!rectDrawMode) return;
        if (e.touches.length !== 1) return;
        e.preventDefault();
        const touch = e.touches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        rectStartPoint = { x: svgP.x, y: svgP.y };
        rectTouchStart = { x: svgP.x, y: svgP.y };
        const ns = "http://www.w3.org/2000/svg";
        rectPreviewEl = document.createElementNS(ns, "rect");
        rectPreviewEl.classList.add("rect-preview");
        rectPreviewEl.setAttribute("x", svgP.x);
        rectPreviewEl.setAttribute("y", svgP.y);
        rectPreviewEl.setAttribute("width", 0);
        rectPreviewEl.setAttribute("height", 0);
        const color = drawColorInput.value || "#f97316";
        rectPreviewEl.style.stroke = color;
        rectPreviewEl.style.strokeWidth = 2;
        rectPreviewEl.style.strokeDasharray = "5,5";
        if (rectStyle === "filled") {
         rectPreviewEl.style.fill = color;
         rectPreviewEl.style.fillOpacity = "0.3";
        } else {
         rectPreviewEl.style.fill = "none";
        }
        svgEl.appendChild(rectPreviewEl);
       }, { passive: false });
       svgMap.addEventListener("touchmove", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        if (e.touches.length !== 1) return;
        e.preventDefault();
        const touch = e.touches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        rectPreviewEl.setAttribute("x", x);
        rectPreviewEl.setAttribute("y", y);
        rectPreviewEl.setAttribute("width", width);
        rectPreviewEl.setAttribute("height", height);
       }, { passive: false });
       svgMap.addEventListener("touchend", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        if (!rectTouchStart) return;
        e.preventDefault();
        const touch = e.changedTouches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        if (width > 10 && height > 10) {
      pushUndo("draw zone");
         const color = drawColorInput.value || "#f97316";
         const newId = "rect-" + Date.now();
         const lineStyle = document.getElementById("draw-style").value || "solid";
         RECT_DATA.list.push({
          id: newId,
          x: x,
          y: y,
          width: width,
          height: height,
          color: color,
          style: rectStyle,
          lineStyle: lineStyle,
          notes: []
         });
         forgeTheTopology();
        }
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
        rectTouchStart = null;
       }, { passive: false });
       const textToggleBtn = document.getElementById("text-toggle");
       function startTextMode() {
        textDrawMode = true;
        svgMap.style.cursor = "crosshair";
        textToggleBtn.textContent = "Done";
        textToggleBtn.style.background = "var(--accent)";
        textToggleBtn.style.color = "var(--bg)";
        if (freeDrawMode) {
         finishFreeDraw();
        }
        if (rectDrawMode) {
         finishRectDraw();
        }
        updateTextDeleteButtons();
       }
       function finishTextMode() {
        textDrawMode = false;
        svgMap.style.cursor = "";
        textToggleBtn.textContent = "T";
        textToggleBtn.style.background = "";
        textToggleBtn.style.color = "";
        updateTextDeleteButtons();
       }
       textToggleBtn.addEventListener("click", () => {
        if (currentView.mode === "rack") {
         alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
         return;
        }
        if (textDrawMode) {
         finishTextMode();
        } else {
         startTextMode();
        }
       });
       function handleTextPlacement(e) {
        if (!textDrawMode) return;
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const newId = "text-" + Date.now();
      pushUndo("add text");
        TEXT_DATA.list.push({
         id: newId,
         x: svgP.x,
         y: svgP.y,
         content: "New Text",
         fontSize: 18,
         color: "#e2e8f0",
         fontWeight: "normal",
         fontStyle: "normal",
         textAlign: "start",
         textDecoration: "none",
         bgColor: "#000000",
         bgEnabled: false,
         opacity: 1
        });
        forgeTheTopology();
        showTextPanel(newId);
       }
       svgMap.addEventListener("click", (e) => {
        if (!textDrawMode) return;
        if (e.target.closest('.text-delete-btn')) return;
        if (e.target.closest('.text-group')) return;
        e.preventDefault();
        e.stopPropagation();
        handleTextPlacement(e);
       });
       svgMap.addEventListener("touchend", (e) => {
        if (!textDrawMode) return;
        if (e.target.closest('.text-delete-btn')) return;
        if (e.target.closest('.text-group')) return;
        if (e.touches.length > 0) return;
        e.preventDefault();
        const touch = e.changedTouches[0];
        const fakeEvent = {
         clientX: touch.clientX,
         clientY: touch.clientY,
         preventDefault: () => {},
         stopPropagation: () => {}
        };
        handleTextPlacement(fakeEvent);
       }, { passive: false });
       function showTextPanel(textId) {
	   if (isViewOnly()) return;
       currentTextId = textId;
       currentNodeId = null;
       currentEdgeId = null;
       currentRectId = null;
       const textItem = TEXT_DATA.list.find(t => t.id === textId);
       if (!textItem) return;
       document.getElementById("node-panel").style.display = "none";
       document.getElementById("edge-panel").style.display = "none";
       document.getElementById("rect-panel").style.display = "none";
       const textPanel = document.getElementById("text-panel");
       textPanel.style.display = "block";
       document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active"));
       document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
       document.querySelectorAll(".rect-group").forEach(r => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach(t => t.classList.toggle("active", t.dataset.textId === textId));
        document.getElementById("text-content").value = textItem.content;
        document.getElementById("text-font-size").value = textItem.fontSize;
        document.getElementById("text-color").value = textItem.color;
        document.getElementById("text-font-weight").value = textItem.fontWeight;
        document.getElementById("text-font-style").value = textItem.fontStyle;
        document.getElementById("text-align").value = textItem.textAlign;
        document.getElementById("text-decoration").value = textItem.textDecoration;
        document.getElementById("text-bg-color").value = textItem.bgColor;
        document.getElementById("text-bg-enabled").checked = textItem.bgEnabled;
        document.getElementById("text-opacity").value = textItem.opacity;
        document.getElementById("text-opacity-val").textContent = Math.round(textItem.opacity * 100) + "%";
       }
       function updateTextDeleteButtons() {
        const deleteButtons = document.querySelectorAll('.text-delete-btn');
        deleteButtons.forEach(btn => {
         btn.style.display = textDrawMode ? 'block' : 'none';
        });
       }
       function deleteText(textId) {
      pushUndo("delete text");
        TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== textId);
        forgeTheTopology();
        if (currentTextId === textId) {
         document.getElementById("text-panel").style.display = "none";
         currentTextId = null;
        }
       }
       document.getElementById("text-content").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
      pushUndo("edit text");
         textItem.content = e.target.value;
         forgeTheTopology();
        }
       });
       document.getElementById("text-font-size").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.fontSize = parseInt(e.target.value);
         forgeTheTopology();
        }
       });
       document.getElementById("text-color").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.color = e.target.value;
         forgeTheTopology();
        }
       });
       document.getElementById("text-font-weight").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.fontWeight = e.target.value;
         forgeTheTopology();
        }
       });
       document.getElementById("text-font-style").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.fontStyle = e.target.value;
         forgeTheTopology();
        }
       });
       document.getElementById("text-align").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.textAlign = e.target.value;
         forgeTheTopology();
        }
       });
        document.getElementById("text-decoration").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.textDecoration = e.target.value;
         forgeTheTopology();
        }
       });
       document.getElementById("text-bg-color").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.bgColor = e.target.value;
         forgeTheTopology();
        }
       });
       document.getElementById("text-bg-enabled").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.bgEnabled = e.target.checked;
         forgeTheTopology();
        }
       });
       document.getElementById("text-opacity").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.opacity = parseFloat(e.target.value);
         document.getElementById("text-opacity-val").textContent = Math.round(textItem.opacity * 100) + "%";
         forgeTheTopology();
        }
       });
       document.getElementById("delete-text").addEventListener("click", () => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         challengeTheImmortal(`Delete text "${textItem.content.substring(0, 30)}..."?`, () => {
          deleteText(currentTextId);
         });
        }
       });
       const settingsModal = document.getElementById("settings-modal");
       const settingsClose = document.getElementById("settings-close");
       settingsBtn.addEventListener("click", () => {
       document.getElementById("page-bg-color").value = rgbaToHex(PAGE_STATE.background) || "#050608";
       document.getElementById("topbar-bg-color").value = rgbaToHex(PAGE_STATE.topbarBg) || "#0b0e13";
       document.getElementById("topbar-border-color").value = rgbaToHex(PAGE_STATE.topbarBorder) || "#1f2533";
       document.getElementById("panel-color").value = rgbaToHex(PAGE_STATE.panel) || "#0b0e13";
       document.getElementById("panel-alt-color").value = PAGE_STATE.panelAlt || "#10141b";
       document.getElementById("sidebar-bg-color").value = PAGE_STATE.sidebarBg || "#10141b";
       document.getElementById("btn-bg-color").value = PAGE_STATE.btnBg || "#0b0e13";
       document.getElementById("btn-text-color").value = PAGE_STATE.btnText || "#e2e8f0";
       document.getElementById("tag-fill-color").value = PAGE_STATE.tagFill || "#1e293b";
       document.getElementById("tag-text-color").value = PAGE_STATE.tagText || "#e2e8f0";
       document.getElementById("tag-border-color").value = PAGE_STATE.tagBorder || "#475569";
       document.getElementById("input-bg-color").value = PAGE_STATE.inputBg || "#0b0e13";
       document.getElementById("input-text-color").value = PAGE_STATE.inputText || "#e2e8f0";
	   document.getElementById("input-border-color").value = PAGE_STATE.inputBorder || "#1f2937";
       document.getElementById("input-font-family").value = PAGE_STATE.inputFont || "Inter, system-ui, sans-serif";
       document.getElementById("input-font-size").value = PAGE_STATE.inputFontSize || 14;
       document.getElementById("toolbar-bg-color").value = PAGE_STATE.toolbarBg || "#0f172a";
       document.getElementById("toolbar-border-color").value = PAGE_STATE.toolbarBorder || "#1f2937";
       document.getElementById("toolbar-text-color").value = PAGE_STATE.toolbarText || "#94a3b8";
       document.getElementById("toolbar-btn-bg-color").value = PAGE_STATE.toolbarBtnBg || "#0b0e13";
       document.getElementById("toolbar-btn-text-color").value = PAGE_STATE.toolbarBtnText || "#e2e8f0";
       document.getElementById("minimap-dots-color").value = PAGE_STATE.minimapDots || "#94a3b8";
       document.getElementById("canvas-hint-enabled").checked = PAGE_STATE.canvasHintEnabled !== false;
       document.getElementById("canvas-hint-bg-color").value = PAGE_STATE.canvasHintBg || "#0f172a";
       document.getElementById("canvas-hint-text-color").value = PAGE_STATE.canvasHintColor || "#94a3b8";
       document.getElementById("canvas-hint-text").value = PAGE_STATE.canvasHintText || "";
       document.getElementById("accent-color").value = rgbaToHex(PAGE_STATE.accent) || "#4fd1c5";
       document.getElementById("danger-color").value = rgbaToHex(PAGE_STATE.danger) || "#f56565";
       document.getElementById("text-main-color").value = rgbaToHex(PAGE_STATE.textMain) || "#e2e8f0";
       document.getElementById("text-soft-color").value = PAGE_STATE.textSoft || "#94a3b8";
       document.getElementById("node-fill-color").value = PAGE_STATE.nodeFill || "#1e293b";
       document.getElementById("node-stroke-color").value = PAGE_STATE.nodeStroke || "#475569";
       document.getElementById("node-title-color").value = PAGE_STATE.nodeTitle || "#e2e8f0";
       document.getElementById("node-sub-color").value = PAGE_STATE.nodeSub || "#94a3b8";
       document.getElementById("node-title-size").value = PAGE_STATE.nodeTitleSize || 18;
       document.getElementById("node-sub-size").value = PAGE_STATE.nodeSubSize || 13;
       document.getElementById("node-font-family").value = PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
       document.getElementById("default-edge-color").value = PAGE_STATE.defaultEdge || "#475569";
       document.getElementById("selection-handle-color").value = PAGE_STATE.selectionHandle || "#f59e0b";
       document.getElementById("selection-handle-size").value = PAGE_STATE.selectionHandleSize || 8;
       document.getElementById("group-indicator-color").value = PAGE_STATE.groupIndicator || "#4fd1c5";
       document.getElementById("canvas-gradient-top").value = PAGE_STATE.canvasGradientTop || "#1e2532";
       document.getElementById("canvas-gradient-bottom").value = PAGE_STATE.canvasGradientBottom || "#050608";
       document.getElementById("canvas-border-color").value = PAGE_STATE.canvasBorder || "#475569";
       document.getElementById("canvas-grid-color").value = PAGE_STATE.canvasGrid || "#475569";
       document.getElementById("canvas-grid-size").value = PAGE_STATE.canvasGridSize || 50;
       document.getElementById("rack-frame-fill").value = PAGE_STATE.rackFrameFill || "#0f172a";
       document.getElementById("rack-frame-stroke").value = PAGE_STATE.rackFrameStroke || "#4fd1c5";
       document.getElementById("rack-line-color").value = PAGE_STATE.rackLineColor || "#475569";
       document.getElementById("rack-text-color").value = PAGE_STATE.rackTextColor || "#4fd1c5";
        document.getElementById("auto-ping-enabled").checked = autoPingEnabled;
        document.getElementById("auto-ping-interval").value = autoPingInterval;
        document.getElementById("auto-ping-settings").style.display = autoPingEnabled ? 'block' : 'none';
        document.getElementById("view-only-mode").checked = PAGE_STATE.viewOnly === true;
        settingsModal.classList.add("active");
       });
       settingsClose.addEventListener("click", () => {
        settingsModal.classList.remove("active");
       });
	   document.getElementById("view-only-mode").addEventListener("change", (e) => {
       PAGE_STATE.viewOnly = e.target.checked;
       if (e.target.checked) {
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        document.getElementById("rect-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.setProperty('display', 'none', 'important');
        document.getElementById("draw-toolbar").style.setProperty('display', 'none', 'important');
        currentNodeId = null;
        currentEdgeId = null;
        currentRectId = null;
        currentTextId = null;
        selectedNodes.clear();
        selectedRects.clear();
        selectedTexts.clear();
        selectedEdges.clear();
        const bulkToolbar = document.getElementById("bulk-toolbar");
        const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active", "selected"));
        document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
        document.querySelectorAll(".rect-group").forEach(r => r.classList.remove("active"));
        document.querySelectorAll(".text-element").forEach(t => t.classList.remove("active"));
       }
       wieldThePower();
       if (!e.target.checked) {
        updateDrawToolbarVisibility();
        updateTopologyToolbarVisibility();
       }
       forgeTheTopology();
      });
       settingsModal.addEventListener("click", (e) => {
        if (e.target === settingsModal) {
         settingsModal.classList.remove("active");
        }
       });
       document.getElementById("page-bg-color").addEventListener("input", (e) => {
        PAGE_STATE.background = e.target.value;
        wieldThePower();
       });
       document.getElementById("topbar-bg-color").addEventListener("input", (e) => {
        PAGE_STATE.topbarBg = e.target.value;
        wieldThePower();
       });
       document.getElementById("topbar-border-color").addEventListener("input", (e) => {
        PAGE_STATE.topbarBorder = e.target.value;
        wieldThePower();
       });
       document.getElementById("panel-color").addEventListener("input", (e) => {
        PAGE_STATE.panel = e.target.value;
        wieldThePower();
       });
       document.getElementById("panel-alt-color").addEventListener("input", (e) => {
       PAGE_STATE.panelAlt = e.target.value;
       wieldThePower();
      });
      document.getElementById("sidebar-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.sidebarBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("btn-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.btnBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("btn-text-color").addEventListener("input", (e) => {
       PAGE_STATE.btnText = e.target.value;
       wieldThePower();
      });
      document.getElementById("tag-fill-color").addEventListener("input", (e) => {
       PAGE_STATE.tagFill = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("tag-text-color").addEventListener("input", (e) => {
       PAGE_STATE.tagText = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("tag-border-color").addEventListener("input", (e) => {
       PAGE_STATE.tagBorder = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("selection-fill-color").addEventListener("input", function() {
       selectionBoxStyle.fillColor = this.value;
      });
      document.getElementById("selection-fill-opacity").addEventListener("input", function() {
       selectionBoxStyle.fillOpacity = parseFloat(this.value);
       document.getElementById("selection-fill-opacity-val").textContent = Math.round(this.value * 100) + "%";
      });
      document.getElementById("selection-stroke-color").addEventListener("input", function() {
       selectionBoxStyle.strokeColor = this.value;
      });
      document.getElementById("selection-stroke-width").addEventListener("input", function() {
       selectionBoxStyle.strokeWidth = parseInt(this.value) || 2;
      });
      document.getElementById("selection-stroke-style").addEventListener("change", function() {
       selectionBoxStyle.strokeDasharray = this.value;
      });
      document.getElementById("input-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.inputBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-text-color").addEventListener("input", (e) => {
       PAGE_STATE.inputText = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-border-color").addEventListener("input", (e) => {
       PAGE_STATE.inputBorder = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-font-family").addEventListener("change", (e) => {
       PAGE_STATE.inputFont = e.target.value;
       wieldThePower();
      });
	  document.getElementById("input-font-size").addEventListener("input", (e) => {
       PAGE_STATE.inputFontSize = parseInt(e.target.value) || 14;
       wieldThePower();
      });
      document.getElementById("toolbar-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-border-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBorder = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-text-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarText = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-btn-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBtnBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-btn-text-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBtnText = e.target.value;
       wieldThePower();
      });
      document.getElementById("minimap-dots-color").addEventListener("input", (e) => {
       PAGE_STATE.minimapDots = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("canvas-hint-enabled").addEventListener("change", (e) => {
       PAGE_STATE.canvasHintEnabled = e.target.checked;
       wieldThePower();
      });
      document.getElementById("canvas-hint-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-hint-text-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintColor = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-hint-text").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintText = e.target.value;
       wieldThePower();
      });
       document.getElementById("accent-color").addEventListener("input", (e) => {
        PAGE_STATE.accent = e.target.value;
        wieldThePower();
       });
       document.getElementById("danger-color").addEventListener("input", (e) => {
        PAGE_STATE.danger = e.target.value;
        wieldThePower();
       });
       document.getElementById("text-main-color").addEventListener("input", (e) => {
        PAGE_STATE.textMain = e.target.value;
        wieldThePower();
       });
       document.getElementById("text-soft-color").addEventListener("input", (e) => {
       PAGE_STATE.textSoft = e.target.value;
       wieldThePower();
      });
      document.getElementById("node-fill-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeFill = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-stroke-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeStroke = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-title-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeTitle = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-sub-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeSub = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-title-size").addEventListener("input", (e) => {
       PAGE_STATE.nodeTitleSize = parseInt(e.target.value) || 18;
       forgeTheTopology();
      });
      document.getElementById("node-sub-size").addEventListener("input", (e) => {
       PAGE_STATE.nodeSubSize = parseInt(e.target.value) || 13;
       forgeTheTopology();
      });
      document.getElementById("node-font-family").addEventListener("change", (e) => {
       PAGE_STATE.nodeFont = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("default-edge-color").addEventListener("input", (e) => {
       PAGE_STATE.defaultEdge = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("selection-handle-color").addEventListener("input", (e) => {
       PAGE_STATE.selectionHandle = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("selection-handle-size").addEventListener("input", (e) => {
       PAGE_STATE.selectionHandleSize = parseInt(e.target.value) || 8;
       forgeTheTopology();
      });
      document.getElementById("group-indicator-color").addEventListener("input", (e) => {
       PAGE_STATE.groupIndicator = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-gradient-top").addEventListener("input", (e) => {
       PAGE_STATE.canvasGradientTop = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-gradient-bottom").addEventListener("input", (e) => {
       PAGE_STATE.canvasGradientBottom = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-border-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasBorder = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-grid-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasGrid = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-grid-size").addEventListener("input", (e) => {
       PAGE_STATE.canvasGridSize = parseInt(e.target.value) || 50;
       forgeTheTopology();
      });
      document.getElementById("rack-frame-fill").addEventListener("input", (e) => {
       PAGE_STATE.rackFrameFill = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-frame-stroke").addEventListener("input", (e) => {
       PAGE_STATE.rackFrameStroke = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-line-color").addEventListener("input", (e) => {
       PAGE_STATE.rackLineColor = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-text-color").addEventListener("input", (e) => {
       PAGE_STATE.rackTextColor = e.target.value;
       forgeTheTopology();
      });
      (function initializeResizers() {
         const headerResizer = document.getElementById('header-resizer');
         const sidebarResizer = document.getElementById('sidebar-resizer');
         const mobileFooterResizer = document.getElementById('mobile-footer-resizer');
         let isResizing = false;
         let currentResizer = null;
         let startY = 0;
         let startX = 0;
         let startHeight = 0;
         let startWidth = 0;
         function getClientPos(e) {
           if (e.touches && e.touches.length > 0) {
             return { x: e.touches[0].clientX, y: e.touches[0].clientY };
           }
           return { x: e.clientX, y: e.clientY };
         }
         function startResize(resizer, type, e) {
           isResizing = true;
           currentResizer = type;
           const pos = getClientPos(e);
           if (type === 'header') {
             startY = pos.y;
             startHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--topbar-height'));
           } else if (type === 'sidebar') {
             startX = pos.x;
             startWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width'));
           } else if (type === 'mobile-footer') {
             startY = pos.y;
             const currentVh = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--mobile-footer-height'));
             startHeight = (currentVh / 100) * window.innerHeight;
           }
           resizer.classList.add('resizing');
           document.body.classList.add('resizing');
           document.body.style.cursor = (type === 'sidebar') ? 'col-resize' : 'row-resize';
           e.preventDefault();
         }
         if (headerResizer) {
           headerResizer.addEventListener('mousedown', (e) => startResize(headerResizer, 'header', e));
           headerResizer.addEventListener('touchstart', (e) => startResize(headerResizer, 'header', e), { passive: false });
         }
         if (sidebarResizer) {
           sidebarResizer.addEventListener('mousedown', (e) => startResize(sidebarResizer, 'sidebar', e));
           sidebarResizer.addEventListener('touchstart', (e) => startResize(sidebarResizer, 'sidebar', e), { passive: false });
         }
         if (mobileFooterResizer) {
           mobileFooterResizer.addEventListener('mousedown', (e) => startResize(mobileFooterResizer, 'mobile-footer', e));
           mobileFooterResizer.addEventListener('touchstart', (e) => startResize(mobileFooterResizer, 'mobile-footer', e), { passive: false });
         }
         function handleMove(e) {
           if (!isResizing) return;
           const pos = getClientPos(e);
           if (currentResizer === 'header') {
             const deltaY = pos.y - startY;
             const newHeight = Math.max(40, Math.min(150, startHeight + deltaY));
             document.documentElement.style.setProperty('--topbar-height', newHeight + 'px');
           } else if (currentResizer === 'sidebar') {
             const deltaX = startX - pos.x;
             const newWidth = Math.max(200, Math.min(800, startWidth + deltaX));
             document.documentElement.style.setProperty('--sidebar-width', newWidth + 'px');
           } else if (currentResizer === 'mobile-footer') {
             const deltaY = startY - pos.y;
             const newHeight = startHeight + deltaY;
             const newVh = Math.max(15, Math.min(80, (newHeight / window.innerHeight) * 100));
             document.documentElement.style.setProperty('--mobile-footer-height', newVh + 'vh');
           }
           e.preventDefault();
         }
         document.addEventListener('mousemove', handleMove);
         document.addEventListener('touchmove', handleMove, { passive: false });
         function handleEnd() {
           if (isResizing) {
             isResizing = false;
             if (currentResizer === 'header') {
               PAGE_STATE.topbarHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--topbar-height'));
               headerResizer.classList.remove('resizing');
             } else if (currentResizer === 'sidebar') {
               PAGE_STATE.sidebarWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width'));
               sidebarResizer.classList.remove('resizing');
             } else if (currentResizer === 'mobile-footer') {
               PAGE_STATE.mobileFooterHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--mobile-footer-height'));
               mobileFooterResizer.classList.remove('resizing');
             }
             document.body.classList.remove('resizing');
             document.body.style.cursor = '';
             currentResizer = null;
           }
         }
         document.addEventListener('mouseup', handleEnd);
         document.addEventListener('touchend', handleEnd);
         document.addEventListener('touchcancel', handleEnd);
       })();
       document.getElementById("auto-ping-enabled").addEventListener("change", (e) => {
        autoPingEnabled = e.target.checked;
        PAGE_STATE.autoPingEnabled = autoPingEnabled;
        document.getElementById("auto-ping-settings").style.display = autoPingEnabled ? 'block' : 'none';
        if (autoPingEnabled) {
         startAutoPing();
        } else {
         stopAutoPing();
        }
       });
       document.getElementById("auto-ping-interval").addEventListener("change", (e) => {
        const newInterval = parseInt(e.target.value, 10);
        if (newInterval >= 5 && newInterval <= 3600) {
         autoPingInterval = newInterval;
         PAGE_STATE.autoPingInterval = autoPingInterval;
         if (autoPingEnabled) {
          startAutoPing();
         }
        }
       });
       document.getElementById("export-data-btn").addEventListener("click", () => {
        const data = captureTheQuickening();
        const jsonStr = JSON.stringify(data, null, 2);
        const blob = new Blob([jsonStr], {
         type: "application/json"
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        const safeTitle = (PAGE_STATE.title || "network-topology").toLowerCase().replace(/[^a-z0-9\-]+/g, "-");
        const timestamp = new Date().toISOString().split("T")[0];
        a.download = `${safeTitle}-data-${timestamp}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
		logAuditEvent("export", `Exported JSON: ${a.download}`);
       });
       document.getElementById("import-data-btn").addEventListener("click", () => {
        document.getElementById("import-data-file").click();
       });
       document.getElementById("import-data-file").addEventListener("change", async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        try {
         const text = await file.text();
         const data = JSON.parse(text);
         if (!data.nodeData || !data.edgeData) {
          alert("Invalid data file. Missing required fields.");
          return;
         }
         const confirmMsg = `This will replace all current data with the imported data.\n\nImporting:\n- ${Object.keys(data.nodeData).length} nodes\n- ${data.edgeData.list?.length || 0} connections\n- ${data.documentTabs?.length || 1} tab(s)\n\nContinue?`;         if (!confirm(confirmMsg)) {
          e.target.value = "";
          return;
         }
         NODE_DATA = data.nodeData || {};
         EDGE_DATA = data.edgeData || {
          list: []
         };
         EDGE_LEGEND = data.edgeLegend || {};
         RECT_DATA = data.rectData || { list: [] };
         TEXT_DATA = data.textData || { list: [] };
         savedPositions = data.nodePositions || {};
         savedSizes = data.nodeSizes || {};
         savedStyles = data.nodeStyles || {};
         if (data.page) {
          PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, data.page, );
          wieldThePower();
         }
      if (data.autoPingEnabled !== undefined) {
      autoPingEnabled = data.autoPingEnabled;
      PAGE_STATE.autoPingEnabled = autoPingEnabled;
      document.getElementById("auto-ping-enabled").checked = autoPingEnabled;
      }
      if (data.autoPingInterval !== undefined) {
      autoPingInterval = data.autoPingInterval;
      PAGE_STATE.autoPingInterval = autoPingInterval;
      document.getElementById("auto-ping-interval").value = autoPingInterval;
      }
         if (data.canvas) {
          canvasState.zoom = data.canvas.zoom || 1;
          canvasState.panX = data.canvas.panX || 0;
          canvasState.panY = data.canvas.panY || 0;
         }
         if (data.page?.title) {
         document.title = data.page.title;
         document.querySelector(".editable-page-title", ).textContent = data.page.title;
        }
        if (data.documentTabs) {
         documentTabs = data.documentTabs;
         currentTabIndex = data.currentTabIndex || 0;
        }
        if (data.savedTopologyView) {
         savedTopologyView = data.savedTopologyView;
        }
        if (data.encryptedSections) {
         encryptedSections = data.encryptedSections;
        }
        if (data.auditLog && Array.isArray(data.auditLog)) {
         auditLog = data.auditLog;
         try {
           localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
         } catch (e) {
           console.warn("Failed to sync audit log to localStorage:", e);
         }
        }
        forgeTheTopology();
        forgeTheLegend();
        logAuditEvent("import", `Imported JSON: ${file.name} (${Object.keys(data.nodeData).length} nodes, ${data.edgeData.list?.length || 0} connections)`);
        updateViewBox();
      if (autoPingEnabled) {
      startAutoPing();
      } else {
      stopAutoPing();
      }
         const nodeIds = Object.keys(NODE_DATA);
         if (nodeIds.length > 0) {
          claimTheImmortal(nodeIds[0]);
         } else {
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("topology-toolbar").style.display = "none";
         }
         alert("Data imported successfully!");
         e.target.value = "";
        } catch (err) {
         console.error("Import error:", err);
         alert(`Failed to import data: ${err.message}`);
         e.target.value = "";
        }
       });
       const saveHelpBtn = document.getElementById("save-help-btn");
       const saveInfoModal = document.getElementById("save-info-modal");
       const saveInfoClose = document.getElementById("save-info-close");
       saveHelpBtn.addEventListener("click", () => {
        saveInfoModal.classList.add("active");
       });
       saveInfoClose.addEventListener("click", () => {
        saveInfoModal.classList.remove("active");
       });
       saveInfoModal.addEventListener("click", (e) => {
       if (e.target === saveInfoModal) {
        saveInfoModal.classList.remove("active");
       }
      });
      document.querySelectorAll(".help-tab").forEach(tab => {
        tab.addEventListener("click", () => {
          document.querySelectorAll(".help-tab").forEach(t => { t.style.background = "var(--panel)"; t.style.color = "var(--text-main)"; });
          tab.style.background = "var(--accent)"; tab.style.color = "var(--bg)";
          document.querySelectorAll(".help-tab-content").forEach(c => c.style.display = "none");
          document.getElementById("help-tab-" + tab.dataset.tab).style.display = "block";
        });
      });
      async function deriveKey(password, salt) {
      const encoder = new TextEncoder();
      const keyMaterial = await crypto.subtle.importKey(
      "raw",
      encoder.encode(password),
      "PBKDF2",
      false,
      ["deriveKey"]
      );
      return crypto.subtle.deriveKey(
      {
      name: "PBKDF2",
      salt: salt,
      iterations: 200000,
      hash: "SHA-256"
      },
      keyMaterial,
      {
      name: "AES-GCM",
      length: 256
      },
      false,
      ["encrypt", "decrypt"]
      );
      }
       async function encryptData(data, password) {
      const encoder = new TextEncoder();
      const salt = crypto.getRandomValues(new Uint8Array(16));
      const iv   = crypto.getRandomValues(new Uint8Array(12));
      const key = await deriveKey(password, salt);
      const encrypted = await crypto.subtle.encrypt(
      { name: "AES-GCM", iv },
      key,
      encoder.encode(data)
      );
      const encryptedU8 = new Uint8Array(encrypted);
      const result = new Uint8Array(salt.length + iv.length + encryptedU8.length);
      result.set(salt, 0);
      result.set(iv, salt.length);
      result.set(encryptedU8, salt.length + iv.length);
      return "ENCRYPTED:" + u8ToBase64(result);
      }
       async function decryptData(encryptedData, password) {
      const base64Data = encryptedData.replace("ENCRYPTED:", "");
      const fullData   = base64ToU8(base64Data);
      const salt      = fullData.slice(0, 16);
      const iv        = fullData.slice(16, 28);
      const encrypted = fullData.slice(28);
      const key = await deriveKey(password, salt);
      const decrypted = await crypto.subtle.decrypt(
      { name: "AES-GCM", iv },
      key,
      encrypted
      );
      const decoder = new TextDecoder();
      return decoder.decode(decrypted);
      }
       function isEncrypted(data) {
        return typeof data === "string" && data.startsWith("ENCRYPTED:");
       }
       function captureTheQuickening() {
      const currentTab = documentTabs[currentTabIndex];
      currentTab.nodes = JSON.parse(JSON.stringify(NODE_DATA));
      currentTab.edges = JSON.parse(JSON.stringify(EDGE_DATA));
      currentTab.positions = JSON.parse(JSON.stringify(savedPositions));
      currentTab.sizes = JSON.parse(JSON.stringify(savedSizes));
      currentTab.styles = JSON.parse(JSON.stringify(savedStyles));
      currentTab.legend = JSON.parse(JSON.stringify(EDGE_LEGEND));
      currentTab.rects = JSON.parse(JSON.stringify(RECT_DATA));
      currentTab.texts = JSON.parse(JSON.stringify(TEXT_DATA));
      currentTab.pageState = JSON.parse(JSON.stringify(PAGE_STATE));
      return {
      nodeData: NODE_DATA,
       edgeData: EDGE_DATA,
       rectData: RECT_DATA,
       textData: TEXT_DATA,
       edgeLegend: EDGE_LEGEND,
       nodePositions: savedPositions,
       nodeSizes: savedSizes,
       nodeStyles: savedStyles,
       iconCache: IconLibrary.iconCache,
       page: PAGE_STATE,
       autoPingEnabled: autoPingEnabled,
       autoPingInterval: autoPingInterval,
       canvas: {
         zoom: canvasState.zoom,
         panX: canvasState.panX,
         panY: canvasState.panY,
       },
       savedTopologyView: savedTopologyView,
       documentTabs: documentTabs,
       currentTabIndex: currentTabIndex,
       encryptedSections: encryptedSections,
	   auditLog: auditLog,
       };
      }
       function assembleTheImmortalForm() {
	   const canvasHintEl = document.getElementById("canvas-hint");
       const savedHintHTML = canvasHintEl ? canvasHintEl.innerHTML : "";
       if (canvasHintEl) canvasHintEl.innerHTML = DEFAULT_CANVAS_HINT;
        const clone = document.documentElement.cloneNode(true);
       ["edge-legend-mini", "minimap-mini", "draw-toolbar-mini", "topology-toolbar-mini"].forEach(id => {
        const all = clone.querySelectorAll("#" + id);
        for (let i = 1; i < all.length; i++) {
         all[i].remove();
        }
       });
       const nodeScript = clone.querySelector("#nodes-json");
        if (nodeScript) {
         nodeScript.textContent = JSON.stringify(NODE_DATA, null, 2);
        }
        let stateScript = clone.querySelector("#topology-state");
        if (!stateScript) {
         stateScript = document.createElement("script");
         stateScript.id = "topology-state";
         stateScript.type = "application/json";
         const body = clone.querySelector("body") || clone;
         body.appendChild(stateScript);
        }
        stateScript.textContent = JSON.stringify(captureTheQuickening(), null, 2, );
        return " <!DOCTYPE html> \n " + clone.outerHTML;
       }
       async function becomeImmortal() {
        const encryptEnabled = document.getElementById("encrypt-toggle").checked;
        let stateData = JSON.stringify(captureTheQuickening(), null, 2);
        if (encryptEnabled) {
         const password = prompt("Enter a password to encrypt your data:\n(Remember this password! You will need it to open this file and its non recoverable!)", );
         if (!password) {
          alert("Encryption cancelled. File not saved.");
          return;
         }
         const confirmPassword = prompt("Confirm your password:");
         if (password !== confirmPassword) {
          alert("Passwords do not match. File not saved.");
          return;
         }
         try {
          stateData = await encryptData(stateData, password);
         } catch (e) {
          alert("Encryption failed: " + e.message);
          return;
         }
        }
       const canvasHintEl = document.getElementById("canvas-hint");
       const savedHintHTML = canvasHintEl ? canvasHintEl.innerHTML : "";
       if (canvasHintEl) canvasHintEl.innerHTML = DEFAULT_CANVAS_HINT;
       const clone = document.documentElement.cloneNode(true);
       ["edge-legend-mini", "minimap-mini", "draw-toolbar-mini", "topology-toolbar-mini"].forEach(id => {
        const all = clone.querySelectorAll("#" + id);
        for (let i = 1; i < all.length; i++) {
         all[i].remove();
        }
       });
       const nodeScript = clone.querySelector("#nodes-json");
        if (nodeScript) {
         if (encryptEnabled) {
          nodeScript.textContent = JSON.stringify({}, null, 2);
         } else {
          nodeScript.textContent = JSON.stringify(NODE_DATA, null, 2);
         }
        }
        let stateScript = clone.querySelector("#topology-state");
        if (!stateScript) {
         stateScript = document.createElement("script");
         stateScript.id = "topology-state";
         stateScript.type = "application/json";
         const body = clone.querySelector("body") || clone;
         body.appendChild(stateScript);
        }
        stateScript.textContent = stateData;
        const html = "<!DOCTYPE html> \n " + clone.outerHTML;
        const blob = new Blob([html], {
         type: "text/html"
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        const safeTitle = (PAGE_STATE.title || document.title || "network-topology").toLowerCase().replace(/[^a-z0-9\-]+/g, "-");
        a.download = safeTitle + ".html";
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
		if (canvasHintEl) canvasHintEl.innerHTML = savedHintHTML;
        saveRollbackVersion("Manual save");
		logAuditEvent("save", `File saved: ${safeTitle}.html`);
       }
      function captureState() {
      return {
        nodes: JSON.parse(JSON.stringify(NODE_DATA)),
        edges: JSON.parse(JSON.stringify(EDGE_DATA)),
        positions: JSON.parse(JSON.stringify(savedPositions)),
        sizes: JSON.parse(JSON.stringify(savedSizes)),
        styles: JSON.parse(JSON.stringify(savedStyles)),
        legend: JSON.parse(JSON.stringify(EDGE_LEGEND)),
        rects: JSON.parse(JSON.stringify(RECT_DATA)),
        texts: JSON.parse(JSON.stringify(TEXT_DATA))
        };
      }
      function pushUndo(action = "") {
       const state = captureState();
       undoStack.push(state);
       if (undoStack.length > MAX_UNDO_STACK) {
        undoStack.shift();
       }
       redoStack = [];
       updateUndoButtons();
       if (action) {
        const actionTypeMap = {
          "create node": "node",
          "delete node": "node",
          "add node": "node",
          "edit": "node",
          "clone node": "node",
          "paste node": "node",
          "move nodes": "node",
          "nudge": "node",
          "nudge nodes": "node",
          "align nodes": "node",
          "distribute nodes": "node",
          "snap to grid": "node",
          "toggle group": "node",
          "toggle lock": "node",
          "create rack": "rack",
          "add rack": "rack",
          "edit rack": "rack",
          "edit mac": "rack",
          "edit U height": "rack",
          "change rack capacity": "rack",
          "change assigned rack": "rack",
          "add connection": "connection",
          "delete connection": "connection",
          "delete edge": "connection",
          "clone edge": "connection",
          "paste edge": "connection",
          "style change": "style",
          "change layer": "layer",
          "add text": "text",
          "edit text": "text",
          "delete text": "text",
          "clone text": "text",
          "paste text": "text",
          "draw zone": "zone",
          "delete zone": "zone",
          "delete rect": "zone",
          "clone rect": "zone",
          "paste rect": "zone",
          "change zone line style": "zone",
          "delete selected": "bulk",
          "clone selected": "bulk",
        };
        const type = actionTypeMap[action] || "edit";
        logAuditEvent(type, action);
       }
      }
      function undo() {
       if (undoStack.length === 0) return;
       const currentState = captureState();
       redoStack.push(currentState);
       const previousState = undoStack.pop();
       restoreState(previousState);
       updateUndoButtons();
       logAuditEvent("undo", "Undo action performed");
      }
      function redo() {
       if (redoStack.length === 0) return;
       logAuditEvent("redo", "Redo action performed");
       const currentState = captureState();
       undoStack.push(currentState);
       const nextState = redoStack.pop();
       restoreState(nextState);
       updateUndoButtons();
      }
      function restoreState(state) {
      NODE_DATA = state.nodes;
       EDGE_DATA = state.edges;
       savedPositions = state.positions;
       savedSizes = state.sizes;
       savedStyles = state.styles;
       EDGE_LEGEND = state.legend;
       RECT_DATA = state.rects || { list: [] };
       TEXT_DATA = state.texts || { list: [] };
       forgeTheTopology();
       if (currentNodeId && NODE_DATA[currentNodeId]) {
       claimTheImmortal(currentNodeId);
       } else if (currentEdgeId) {
       selectTheConnection(currentEdgeId);
       }
      }
      function updateUndoButtons() {
       const undoBtn = document.getElementById("undo-btn");
       const redoBtn = document.getElementById("redo-btn");
       if (undoBtn) {
        undoBtn.disabled = undoStack.length === 0;
        undoBtn.style.opacity = undoStack.length === 0 ? "0.5" : "1";
       }
       if (redoBtn) {
        redoBtn.disabled = redoStack.length === 0;
        redoBtn.style.opacity = redoStack.length === 0 ? "0.5" : "1";
       }
      }
      function clearSelection() {
       selectedNodes.clear();
       selectedEdges.clear();
       selectedRects.clear();
       selectedTexts.clear();
       updateAllSelections();
      }
      function updateAllSelections() {
      updateNodeSelection();
      clearSearchHighlight();
      document.querySelectorAll(".edge").forEach(el => {
      const edgeId = el.dataset.edgeId;
      if (selectedEdges.has(edgeId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      document.querySelectorAll(".rect-group").forEach(el => {
      const rectId = el.dataset.rectId;
      if (selectedRects.has(rectId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      document.querySelectorAll(".text-group").forEach(el => {
      const textId = el.dataset.textId;
      if (selectedTexts.has(textId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
      const bulkToolbar = document.getElementById("bulk-toolbar");
      const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
      const bulkCount = document.getElementById("bulk-count");
      const bulkCountMobile = document.getElementById("bulk-count-mobile");
      if (total > 0) {
      if (bulkToolbar) bulkToolbar.style.display = "flex";
      if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
      if (bulkCount) bulkCount.textContent = total;
      if (bulkCountMobile) bulkCountMobile.textContent = total;
      } else {
      if (bulkToolbar) bulkToolbar.style.display = "none";
      if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
      }
      }
      function updateNodeSelection() {
       if (isViewOnly()) {
        selectedNodes.clear();
        selectedRects.clear();
        selectedTexts.clear();
        const bulkToolbar = document.getElementById("bulk-toolbar");
        const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        return;
       }
       document.querySelectorAll(".node-group").forEach(node => {
        const nodeId = node.dataset.nodeId;
        if (selectedNodes.has(nodeId)) {
         node.classList.add("selected");
        } else {
         node.classList.remove("selected");
        }
       });
       const bulkToolbar = document.getElementById("bulk-toolbar");
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       const bulkCount = document.getElementById("bulk-count");
       const bulkCountMobile = document.getElementById("bulk-count-mobile");
       const bulkCountModal = document.getElementById("bulk-count-modal");
       if (selectedNodes.size > 0) {
        if (bulkToolbar) bulkToolbar.style.display = "flex";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
        if (bulkCount) bulkCount.textContent = selectedNodes.size;
        if (bulkCountMobile) bulkCountMobile.textContent = selectedNodes.size;
        if (bulkCountModal) bulkCountModal.textContent = selectedNodes.size;
       } else {
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        const modal = document.getElementById("bulk-actions-modal");
        if (modal) modal.style.display = "none";
       }
      }
      function deleteSelected() {
       const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
       if (total === 0) return;
       let nodesInsideRacks = [];
       selectedNodes.forEach(nodeId => {
        if (NODE_DATA[nodeId]?.isRack) {
         Object.entries(NODE_DATA).forEach(([id, n]) => {
          if (n.assignedRack === nodeId) nodesInsideRacks.push(n.name || id);
         });
        }
       });
       let message = `Delete ${total} selected item(s)?`;
       if (nodesInsideRacks.length > 0) {
        message += `\n\nThis will also delete ${nodesInsideRacks.length} node(s) inside rack(s):\n‚Ä¢ ${nodesInsideRacks.join('\n‚Ä¢ ')}`;
       }
       challengeTheImmortal(message, () => {
        pushUndo("delete selected");
        selectedNodes.forEach(nodeId => {
         if (NODE_DATA[nodeId]?.isRack) {
          Object.keys(NODE_DATA).forEach(id => {
           if (NODE_DATA[id]?.assignedRack === nodeId) {
            EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== id && e.to !== id);
            delete NODE_DATA[id];
            delete savedPositions[id];
            delete savedSizes[id];
            delete savedStyles[id];
           }
          });
         }
         delete NODE_DATA[nodeId];
         delete savedPositions[nodeId];
         delete savedSizes[nodeId];
         delete savedStyles[nodeId];
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== nodeId && e.to !== nodeId);
        });
        selectedEdges.forEach(edgeId => {
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.id !== edgeId);
        });
        selectedRects.forEach(rectId => {
         RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== rectId);
        });
        selectedTexts.forEach(textId => {
         TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== textId);
        });
        clearSelection();
        forgeTheTopology();
       });
      }
      function startSelection(event) {
       const svgEl = document.getElementById("map");
       const pt = svgEl.createSVGPoint();
       pt.x = event.clientX;
       pt.y = event.clientY;
       const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
       isSelecting = true;
       selectionStart = { x: svgP.x, y: svgP.y };
       if (!selectionRect || !selectionRect.parentNode) {
        selectionRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        selectionRect.setAttribute("fill", selectionBoxStyle.fillColor);
        selectionRect.setAttribute("fill-opacity", selectionBoxStyle.fillOpacity);
        selectionRect.setAttribute("stroke", selectionBoxStyle.strokeColor);
        selectionRect.setAttribute("stroke-width", selectionBoxStyle.strokeWidth);
        selectionRect.setAttribute("stroke-dasharray", selectionBoxStyle.strokeDasharray);
        selectionRect.style.pointerEvents = "none";
        svgEl.appendChild(selectionRect);
       }
       clearSelection();
       preDragSelectedNodes = new Set(selectedNodes);
       preDragSelectedEdges = new Set(selectedEdges);
       preDragSelectedRects = new Set(selectedRects);
       preDragSelectedTexts = new Set(selectedTexts);
      }
      function updateSelection(event) {
       if (!isSelecting || !selectionStart) return;
       const svgEl = document.getElementById("map");
       const pt = svgEl.createSVGPoint();
       pt.x = event.clientX;
       pt.y = event.clientY;
       const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
       const x = Math.min(selectionStart.x, svgP.x);
       const y = Math.min(selectionStart.y, svgP.y);
       const width = Math.abs(svgP.x - selectionStart.x);
       const height = Math.abs(svgP.y - selectionStart.y);
       selectionRect.setAttribute("x", x);
       selectionRect.setAttribute("y", y);
       selectionRect.setAttribute("width", width);
       selectionRect.setAttribute("height", height);
       selectionRect.style.display = "block";
       const box = { x, y, width, height };
       Object.entries(savedPositions).forEach(([nodeId, pos]) => {
        const size = savedSizes[nodeId] || 50;
        const halfSize = size / 2;
        const nodeBox = { x: pos.x - halfSize, y: pos.y - halfSize, width: size, height: size };
        if (boxesIntersect(box, nodeBox)) {
         selectedNodes.add(nodeId);
        } else if (!preDragSelectedNodes.has(nodeId)) {
         selectedNodes.delete(nodeId);
        }
       });
       EDGE_DATA.list.forEach(edge => {
        if (!edge.points || edge.points.length === 0) return;
        for (let i = 0; i < edge.points.length - 1; i++) {
         const p1 = edge.points[i];
         const p2 = edge.points[i + 1];
         if (lineIntersectsBox(p1.x, p1.y, p2.x, p2.y, box)) {
          selectedEdges.add(edge.id);
          return;
         }
        }
        if (!preDragSelectedEdges.has(edge.id)) {
         selectedEdges.delete(edge.id);
        }
       });
       RECT_DATA.list.forEach(rect => {
        const rectBox = { x: rect.x, y: rect.y, width: rect.width, height: rect.height };
        if (boxesIntersect(box, rectBox)) {
         selectedRects.add(rect.id);
        } else if (!preDragSelectedRects.has(rect.id)) {
         selectedRects.delete(rect.id);
        }
       });
       TEXT_DATA.list.forEach(text => {
        const fontSize = text.fontSize || 18;
        const textBox = { x: text.x - 50, y: text.y - fontSize, width: 100, height: fontSize * 1.5 };
        if (boxesIntersect(box, textBox)) {
         selectedTexts.add(text.id);
        } else if (!preDragSelectedTexts.has(text.id)) {
         selectedTexts.delete(text.id);
        }
       });
       updateAllSelectionVisuals();
      }
      function endSelection() {
       isSelecting = false;
       selectionStart = null;
       if (selectionRect) {
        selectionRect.style.display = "none";
       }
      }
      function boxesIntersect(a, b) {
       return !(a.x + a.width < b.x || b.x + b.width < a.x || a.y + a.height < b.y || b.y + b.height < a.y);
      }
      function lineIntersectsBox(x1, y1, x2, y2, box) {
       if (pointInBox(x1, y1, box) || pointInBox(x2, y2, box)) return true;
       const lines = [
        [box.x, box.y, box.x + box.width, box.y],
        [box.x + box.width, box.y, box.x + box.width, box.y + box.height],
        [box.x + box.width, box.y + box.height, box.x, box.y + box.height],
        [box.x, box.y + box.height, box.x, box.y]
       ];
       for (const [bx1, by1, bx2, by2] of lines) {
        if (linesIntersect(x1, y1, x2, y2, bx1, by1, bx2, by2)) return true;
       }
       return false;
      }
      function pointInBox(x, y, box) {
       return x >= box.x && x <= box.x + box.width && y >= box.y && y <= box.y + box.height;
      }
      function linesIntersect(x1, y1, x2, y2, x3, y3, x4, y4) {
       const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
       if (Math.abs(denom) < 0.0001) return false;
       const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom;
       const ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denom;
       return ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1;
      }
      function updateAllSelectionVisuals() {
       document.querySelectorAll(".node-group").forEach(node => {
        const nodeId = node.dataset.nodeId;
        if (selectedNodes.has(nodeId)) {
         node.classList.add("selected");
        } else {
         node.classList.remove("selected");
        }
       });
       document.querySelectorAll(".edge").forEach(edge => {
        const edgeId = edge.dataset.edgeId;
        if (selectedEdges.has(edgeId)) {
         edge.style.filter = "drop-shadow(0 0 6px #4fd1c5)";
        } else {
         edge.style.filter = "";
        }
       });
       document.querySelectorAll(".rect-group rect").forEach(el => {
        const rectId = el.closest(".rect-group")?.dataset?.rectId;
        if (selectedRects.has(rectId)) {
         el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
        } else {
         el.style.filter = "";
        }
       });
       document.querySelectorAll(".text-group, .text-element").forEach(el => {
        const textId = el.dataset?.textId;
        if (selectedTexts.has(textId)) {
         el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
        } else {
         el.style.filter = "";
        }
       });
       const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
       const bulkToolbar = document.getElementById("bulk-toolbar");
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       const bulkCount = document.getElementById("bulk-count");
       const bulkCountMobile = document.getElementById("bulk-count-mobile");
       if (total > 0) {
        if (bulkToolbar) bulkToolbar.style.display = "flex";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
        if (bulkCount) bulkCount.textContent = total;
        if (bulkCountMobile) bulkCountMobile.textContent = total;
       } else {
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
       }
      }
      function cloneNode(sourceId, skipUndo) {
       const source = NODE_DATA[sourceId];
       if (!source) return;
       if (!skipUndo) pushUndo("clone node");
       let baseName = source.name;
       let copyNum = 0;
       let newName = baseName + " copy";
       while (Object.values(NODE_DATA).some(n => n.name === newName)) {
        copyNum++;
        newName = baseName + " copy " + copyNum;
       }
       const newId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
       NODE_DATA[newId] = {
        shape: source.shape,
        name: newName,
        ip: source.ip,
        role: source.role,
        tags: [...source.tags],
        notes: [...source.notes],
        mac: source.mac || "",
        rackUnit: source.rackUnit || "",
        uHeight: source.uHeight || "1",
        ping: source.ping ? JSON.parse(JSON.stringify(source.ping)) : {
         enabled: false,
         protocol: 'http',
         customUrl: '',
         timeout: 3000,
         status: 'unknown',
         lastCheck: null
        },
        layer: source.layer || "physical",
        assignedRack: source.assignedRack || "",
        rackCapacity: source.rackCapacity || "42",
        isRack: source.isRack || false
       };
       if (source.isRack) {
        const childNodes = Object.entries(NODE_DATA).filter(([id, n]) =>
         id !== newId && n.assignedRack === sourceId
        );
        childNodes.forEach(([childId, childNode]) => {
         let childBaseName = childNode.name;
         let c = 0;
         let childNewName = childBaseName + " copy";
         while (Object.values(NODE_DATA).some(n => n.name === childNewName)) {
          c++;
          childNewName = childBaseName + " copy " + c;
         }
         const childNewId = childNewName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
         NODE_DATA[childNewId] = {
          ...JSON.parse(JSON.stringify(childNode)),
          name: childNewName,
          assignedRack: newId
         };
         if (savedPositions[childId]) {
          savedPositions[childNewId] = { ...savedPositions[childId] };
         }
         if (savedSizes[childId]) {
          savedSizes[childNewId] = savedSizes[childId];
         }
         if (savedStyles[childId]) {
          savedStyles[childNewId] = JSON.parse(JSON.stringify(savedStyles[childId]));
         }
        });
       }
       if (savedSizes[sourceId]) {
        savedSizes[newId] = savedSizes[sourceId];
       }
       if (savedStyles[sourceId]) {
        savedStyles[newId] = JSON.parse(JSON.stringify(savedStyles[sourceId]));
       }
      if (currentView.mode === "rack" && currentView.rackId) {
        NODE_DATA[newId].assignedRack = currentView.rackId;
       }
       const sourcePos = savedPositions[sourceId];
       savedPositions[newId] = {
        x: sourcePos.x + 100,
        y: sourcePos.y + 100
       };
       forgeTheTopology();
       claimTheImmortal(newId);
      }
      function alignSelectedNodes(direction) {
       if (selectedNodes.size < 2) return;
       pushUndo("align nodes");
       const nodeIds = Array.from(selectedNodes);
       const positions = nodeIds.map(id => ({ id, pos: savedPositions[id] }));
       switch(direction) {
        case "left":
         const minX = Math.min(...positions.map(p => p.pos.x));
         positions.forEach(p => savedPositions[p.id].x = minX);
         break;
        case "right":
         const maxX = Math.max(...positions.map(p => p.pos.x));
         positions.forEach(p => savedPositions[p.id].x = maxX);
         break;
        case "top":
         const minY = Math.min(...positions.map(p => p.pos.y));
         positions.forEach(p => savedPositions[p.id].y = minY);
         break;
        case "bottom":
         const maxY = Math.max(...positions.map(p => p.pos.y));
         positions.forEach(p => savedPositions[p.id].y = maxY);
         break;
        case "center-h":
         const avgX = positions.reduce((sum, p) => sum + p.pos.x, 0) / positions.length;
         positions.forEach(p => savedPositions[p.id].x = avgX);
         break;
        case "center-v":
         const avgY = positions.reduce((sum, p) => sum + p.pos.y, 0) / positions.length;
         positions.forEach(p => savedPositions[p.id].y = avgY);
         break;
       }
       forgeTheTopology();
      }
      function distributeSelectedNodes(direction) {
       if (selectedNodes.size < 3) return;
       pushUndo("distribute nodes");
       const nodeIds = Array.from(selectedNodes);
       const positions = nodeIds.map(id => ({ id, pos: savedPositions[id] }));
       if (direction === "horizontal") {
        positions.sort((a, b) => a.pos.x - b.pos.x);
        const minX = positions[0].pos.x;
        const maxX = positions[positions.length - 1].pos.x;
        const gap = (maxX - minX) / (positions.length - 1);
        positions.forEach((p, i) => {
         savedPositions[p.id].x = minX + (gap * i);
        });
       } else if (direction === "vertical") {
        positions.sort((a, b) => a.pos.y - b.pos.y);
        const minY = positions[0].pos.y;
        const maxY = positions[positions.length - 1].pos.y;
        const gap = (maxY - minY) / (positions.length - 1);
        positions.forEach((p, i) => {
         savedPositions[p.id].y = minY + (gap * i);
        });
       }
       forgeTheTopology();
      }
      function snapToGrid(nodeId, gridSize = 50) {
       if (!savedPositions[nodeId]) return;
       pushUndo("snap to grid");
       const pos = savedPositions[nodeId];
       pos.x = Math.round(pos.x / gridSize) * gridSize;
       pos.y = Math.round(pos.y / gridSize) * gridSize;
       forgeTheTopology();
      }
      function nudgeSelectedNodes(direction, distance) {
        const nodesToNudge = selectedNodes.size > 0
          ? Array.from(selectedNodes)
          : (currentNodeId ? [currentNodeId] : []);
        if (nodesToNudge.length === 0) return;
        const unlockedNodes = nodesToNudge.filter(id => !NODE_DATA[id]?.locked);
        if (unlockedNodes.length === 0) {
          return;
        }
        pushUndo("nudge nodes");
        unlockedNodes.forEach(id => {
          if (!savedPositions[id]) {
            savedPositions[id] = { x: 0, y: 0 };
          }
          switch(direction) {
            case "ArrowUp":
              savedPositions[id].y -= distance;
              break;
            case "ArrowDown":
              savedPositions[id].y += distance;
              break;
            case "ArrowLeft":
              savedPositions[id].x -= distance;
              break;
            case "ArrowRight":
              savedPositions[id].x += distance;
              break;
          }
        });
        forgeTheTopology();
      }
      function cycleNodes(reverse = false) {
        const nodeIds = Object.keys(NODE_DATA).filter(id => {
          if (currentView.mode === "rack") {
           const node = NODE_DATA[id];
           return node && node.assignedRack === currentView.rackId;
          }
          return isNodeVisible(id);
         });
        if (nodeIds.length === 0) return;
        let currentIndex = nodeIds.indexOf(currentNodeId);
        if (reverse) {
          currentIndex = currentIndex <= 0 ? nodeIds.length - 1 : currentIndex - 1;
        } else {
          currentIndex = currentIndex >= nodeIds.length - 1 ? 0 : currentIndex + 1;
        }
        const nextNodeId = nodeIds[currentIndex];
        claimTheImmortal(nextNodeId);
        selectedNodes.clear();
        updateNodeSelection();
      }
      function focusOnSelected() {
        let minX = Infinity, minY = Infinity;
        let maxX = -Infinity, maxY = -Infinity;
        let hasItems = false;
        const nodesToFocus = selectedNodes.size > 0
          ? Array.from(selectedNodes)
          : (currentNodeId ? [currentNodeId] : []);
        nodesToFocus.forEach(id => {
          const pos = savedPositions[id];
          if (pos) {
            hasItems = true;
            const size = savedSizes[id] || 50;
            minX = Math.min(minX, pos.x - size/2);
            minY = Math.min(minY, pos.y - size/2);
            maxX = Math.max(maxX, pos.x + size/2);
            maxY = Math.max(maxY, pos.y + size/2);
          }
        });
        const rectsToFocus = selectedRects.size > 0 ? Array.from(selectedRects) : (currentRectId ? [currentRectId] : []);
        rectsToFocus.forEach(id => {
          const r = RECT_DATA.list.find(x => x.id === id);
          if (r) {
            hasItems = true;
            minX = Math.min(minX, r.x);
            minY = Math.min(minY, r.y);
            maxX = Math.max(maxX, r.x + r.width);
            maxY = Math.max(maxY, r.y + r.height);
          }
        });
        const textsToFocus = selectedTexts.size > 0 ? Array.from(selectedTexts) : (currentTextId ? [currentTextId] : []);
        textsToFocus.forEach(id => {
          const t = TEXT_DATA.list.find(x => x.id === id);
          if (t) {
            hasItems = true;
            minX = Math.min(minX, t.x - 50);
            minY = Math.min(minY, t.y - 20);
            maxX = Math.max(maxX, t.x + 50);
            maxY = Math.max(maxY, t.y + 20);
          }
        });
        const edgesToFocus = selectedEdges.size > 0 ? Array.from(selectedEdges) : (currentEdgeId ? [currentEdgeId] : []);
        edgesToFocus.forEach(id => {
          const e = EDGE_DATA.list.find(x => x.id === id);
          if (e) {
            const fromPos = savedPositions[e.from];
            const toPos = savedPositions[e.to];
            if (fromPos && toPos) {
              hasItems = true;
              minX = Math.min(minX, fromPos.x, toPos.x);
              minY = Math.min(minY, fromPos.y, toPos.y);
              maxX = Math.max(maxX, fromPos.x, toPos.x);
              maxY = Math.max(maxY, fromPos.y, toPos.y);
            }
          }
        });
        if (!hasItems || !isFinite(minX)) return;
        const padding = 100;
        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;
        const width = maxX - minX + padding * 2;
        const height = maxY - minY + padding * 2;
        const zoomX = CANVAS_WIDTH / width;
        const zoomY = CANVAS_HEIGHT / height;
        const targetZoom = Math.min(zoomX, zoomY, 2);
        canvasState.zoom = targetZoom;
        canvasState.panX = centerX - (CANVAS_WIDTH / targetZoom) / 2;
        canvasState.panY = centerY - (CANVAS_HEIGHT / targetZoom) / 2;
        forgeTheTopology();
      }
      function toggleLockSelected() {
        const nodesToToggle = selectedNodes.size > 0
          ? Array.from(selectedNodes)
          : (currentNodeId ? [currentNodeId] : []);
        const rectsToToggle = selectedRects.size > 0
          ? Array.from(selectedRects)
          : (currentRectId ? [currentRectId] : []);
        const textsToToggle = selectedTexts.size > 0
          ? Array.from(selectedTexts)
          : (currentTextId ? [currentTextId] : []);
        if (nodesToToggle.length === 0 && rectsToToggle.length === 0 && textsToToggle.length === 0) return;
        pushUndo("toggle lock");
        let hasUnlocked = nodesToToggle.some(id => !NODE_DATA[id]?.locked);
        hasUnlocked = hasUnlocked || rectsToToggle.some(id => { const r = RECT_DATA.list.find(x => x.id === id); return r && !r.locked; });
        hasUnlocked = hasUnlocked || textsToToggle.some(id => { const t = TEXT_DATA.list.find(x => x.id === id); return t && !t.locked; });
        nodesToToggle.forEach(id => {
          if (NODE_DATA[id]) NODE_DATA[id].locked = hasUnlocked;
        });
        rectsToToggle.forEach(id => {
          const r = RECT_DATA.list.find(x => x.id === id);
          if (r) r.locked = hasUnlocked;
        });
        textsToToggle.forEach(id => {
          const t = TEXT_DATA.list.find(x => x.id === id);
          if (t) t.locked = hasUnlocked;
        });
        forgeTheTopology();
      }
      function toggleGroupSelected() {
      const nodesToGroup = Array.from(selectedNodes);
      const rectsToGroup = Array.from(selectedRects);
      const textsToGroup = Array.from(selectedTexts);
      const edgesToGroup = Array.from(selectedEdges);
      const totalItems = nodesToGroup.length + rectsToGroup.length + textsToGroup.length + edgesToGroup.length;
      if (totalItems < 2) return;
      pushUndo("toggle group");
      const allGroupIds = [];
      nodesToGroup.forEach(id => { if (NODE_DATA[id]?.groupId) allGroupIds.push(NODE_DATA[id].groupId); });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r?.groupId) allGroupIds.push(r.groupId); });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t?.groupId) allGroupIds.push(t.groupId); });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e?.groupId) allGroupIds.push(e.groupId); });
      const uniqueGroups = [...new Set(allGroupIds)];
      if (uniqueGroups.length === 1 && allGroupIds.length === totalItems) {
      nodesToGroup.forEach(id => { if (NODE_DATA[id]) NODE_DATA[id].groupId = null; });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r) r.groupId = null; });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t) t.groupId = null; });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e) e.groupId = null; });
      } else {
      const newGroupId = "group-" + Date.now();
      nodesToGroup.forEach(id => { if (NODE_DATA[id]) NODE_DATA[id].groupId = newGroupId; });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r) r.groupId = newGroupId; });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t) t.groupId = newGroupId; });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e) e.groupId = newGroupId; });
      }
      forgeTheTopology();
      }
      function handleKeyDown(event) {
       if (event.target.tagName === "INPUT" || event.target.tagName === "TEXTAREA" || event.target.isContentEditable) {
        return;
       }
       if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(event.key)) {
        event.preventDefault();
        const distance = event.shiftKey ? 10 : 1;
        nudgeSelectedNodes(event.key, distance);
       }
       if (event.key === "Tab") {
        event.preventDefault();
        cycleNodes(event.shiftKey);
       }
       if (event.key === "f" || event.key === "F") {
        event.preventDefault();
        focusOnSelected();
       }
       if (event.key === "l" || event.key === "L") {
        event.preventDefault();
        toggleLockSelected();
       }
       if (event.key === "g" || event.key === "G") {
        event.preventDefault();
        toggleGroupSelected();
       }
       if (event.ctrlKey && event.key === "z" && !event.shiftKey) {
        event.preventDefault();
        undo();
       }
       if ((event.ctrlKey && event.key === "y") || (event.ctrlKey && event.shiftKey && event.key === "z")) {
        event.preventDefault();
        redo();
       }
       if (event.ctrlKey && event.key === "c") {
        event.preventDefault();
        clipboard = null;
        if (currentNodeId && NODE_DATA[currentNodeId]) {
         clipboard = {
          type: "node",
          data: JSON.parse(JSON.stringify(NODE_DATA[currentNodeId])),
          size: savedSizes[currentNodeId],
          style: savedStyles[currentNodeId] ? JSON.parse(JSON.stringify(savedStyles[currentNodeId])) : null
         };
        } else if (currentEdgeId) {
         const edge = EDGE_DATA.list.find(e => e.id === currentEdgeId);
         if (edge) clipboard = { type: "edge", data: JSON.parse(JSON.stringify(edge)) };
        } else if (currentRectId) {
         const rect = RECT_DATA.list.find(r => r.id === currentRectId);
         if (rect) clipboard = { type: "rect", data: JSON.parse(JSON.stringify(rect)) };
        } else if (currentTextId) {
         const text = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (text) clipboard = { type: "text", data: JSON.parse(JSON.stringify(text)) };
        }
       }
       if (event.ctrlKey && event.key === "v") {
        event.preventDefault();
        if (!clipboard) return;
        const svgEl = document.getElementById("map");
        const rect = svgEl.getBoundingClientRect();
        const pt = svgEl.createSVGPoint();
        pt.x = rect.left + rect.width / 2;
        pt.y = rect.top + rect.height / 2;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const centerX = svgP.x;
        const centerY = svgP.y;
        if (clipboard.type === "node") {
         let newName = clipboard.data.name + " copy";
         let counter = 1;
         while (Object.values(NODE_DATA).some(n => n.name === newName)) {
          newName = clipboard.data.name + " copy " + counter;
          counter++;
         }
         let newId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
         counter = 1;
         while (NODE_DATA[newId]) {
          newId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-") + "-" + counter;
          counter++;
         }
         pushUndo("paste node");
         NODE_DATA[newId] = { ...JSON.parse(JSON.stringify(clipboard.data)), name: newName };
         savedPositions[newId] = { x: centerX, y: centerY };
         if (clipboard.size) savedSizes[newId] = clipboard.size;
         if (clipboard.style) savedStyles[newId] = JSON.parse(JSON.stringify(clipboard.style));
         forgeTheTopology();
         claimTheImmortal(newId);
        } else if (clipboard.type === "edge") {
         pushUndo("paste edge");
         const newEdge = { ...clipboard.data, id: "edge-" + Date.now() };
         EDGE_DATA.list.push(newEdge);
         forgeTheTopology();
         selectTheConnection(newEdge.id);
        } else if (clipboard.type === "rect") {
         pushUndo("paste rect");
         const newRect = { ...clipboard.data, id: "rect-" + Date.now(), x: centerX - (clipboard.data.width || 100) / 2, y: centerY - (clipboard.data.height || 100) / 2 };
         RECT_DATA.list.push(newRect);
         forgeTheTopology();
         selectTheRect(newRect.id);
        } else if (clipboard.type === "text") {
         pushUndo("paste text");
         const newText = { ...clipboard.data, id: "text-" + Date.now(), x: centerX, y: centerY };
         TEXT_DATA.list.push(newText);
         forgeTheTopology();
         showTextPanel(newText.id);
        }
       }
       if (event.ctrlKey && event.key === "d") {
        event.preventDefault();
        if (currentNodeId && NODE_DATA[currentNodeId]) {
         cloneNode(currentNodeId);
        } else if (currentEdgeId) {
         const edge = EDGE_DATA.list.find(e => e.id === currentEdgeId);
         if (edge) {
          pushUndo("clone edge");
          const newEdge = { ...JSON.parse(JSON.stringify(edge)), id: "edge-" + Date.now() };
          EDGE_DATA.list.push(newEdge);
          forgeTheTopology();
          selectTheConnection(newEdge.id);
         }
        } else if (currentRectId) {
         const rect = RECT_DATA.list.find(r => r.id === currentRectId);
         if (rect) {
          pushUndo("clone rect");
          const newRect = { ...JSON.parse(JSON.stringify(rect)), id: "rect-" + Date.now(), x: rect.x + 50, y: rect.y + 50 };
          RECT_DATA.list.push(newRect);
          forgeTheTopology();
          selectTheRect(newRect.id);
         }
        } else if (currentTextId) {
         const text = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (text) {
          pushUndo("clone text");
          const newText = { ...JSON.parse(JSON.stringify(text)), id: "text-" + Date.now(), x: text.x + 50, y: text.y + 50 };
          TEXT_DATA.list.push(newText);
          forgeTheTopology();
          showTextPanel(newText.id);
         }
        }
       }
       if (event.key === "Delete") {
        event.preventDefault();
        const totalSelected = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
        if (totalSelected > 0) {
         deleteSelected();
        } else if (currentNodeId && NODE_DATA[currentNodeId]) {
         challengeTheImmortal(`Delete node "${NODE_DATA[currentNodeId].name}"?`, () => {
          pushUndo("delete node");
          delete NODE_DATA[currentNodeId];
          delete savedPositions[currentNodeId];
          delete savedSizes[currentNodeId];
          delete savedStyles[currentNodeId];
          EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== currentNodeId && e.to !== currentNodeId);
          currentNodeId = null;
          forgeTheTopology();
          document.getElementById("node-panel").style.display = "none";
         });
        } else if (currentEdgeId) {
         challengeTheImmortal("Delete this line?", () => {
          pushUndo("delete edge");
          EDGE_DATA.list = EDGE_DATA.list.filter(e => e.id !== currentEdgeId);
          currentEdgeId = null;
          forgeTheTopology();
          document.getElementById("edge-panel").style.display = "none";
         });
        } else if (currentRectId) {
         challengeTheImmortal("Delete this zone?", () => {
          pushUndo("delete rect");
          RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== currentRectId);
          currentRectId = null;
          forgeTheTopology();
          document.getElementById("rect-panel").style.display = "none";
         });
        } else if (currentTextId) {
         const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (textItem) {
          challengeTheImmortal(`Delete text "${textItem.content.substring(0, 30)}..."?`, () => {
           pushUndo("delete text");
           TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== currentTextId);
           currentTextId = null;
           forgeTheTopology();
           document.getElementById("text-panel").style.display = "none";
          });
         }
        }
       }
       if (event.ctrlKey && event.key === "a") {
        event.preventDefault();
        Object.keys(NODE_DATA).forEach(id => selectedNodes.add(id));
        EDGE_DATA.list.forEach(e => selectedEdges.add(e.id));
        RECT_DATA.list.forEach(r => selectedRects.add(r.id));
        TEXT_DATA.list.forEach(t => selectedTexts.add(t.id));
        updateAllSelections();
       }
       if (event.key === "Escape") {
        clearSelection();
       }
      }
      function searchNodes(query) {
   if (!query) {
    clearSearchHighlight();
    return [];
   }
   query = query.toLowerCase();
   const results = [];
   Object.entries(NODE_DATA).forEach(([id, data]) => {
    try {
     const nameMatch = data.name && data.name.toLowerCase().includes(query);
     const ipMatch = data.ip && data.ip.toLowerCase().includes(query);
     const roleMatch = data.role && data.role.toLowerCase().includes(query);
     const tagsMatch = data.tags && Array.isArray(data.tags) && data.tags.some(tag => tag && tag.toLowerCase().includes(query));
     const macMatch = data.mac && data.mac.toLowerCase().includes(query);
     const rackUnitMatch = data.rackUnit && String(data.rackUnit).toLowerCase().includes(query);
     if (nameMatch || ipMatch || roleMatch || tagsMatch || macMatch || rackUnitMatch) {
      results.push(id);
     }
    } catch (e) {
     console.warn("Search error for node:", id, e);
    }
   });
   highlightSearchResults(results);
   return results;
}
		function highlightSearchResults(nodeIds, hasQuery = true) {
		   document.querySelectorAll(".node-group").forEach(node => {
			const nodeId = node.dataset.nodeId;
			if (nodeIds.includes(nodeId)) {
			 node.classList.add("search-highlight");
			 node.classList.remove("search-faded");
			} else {
			 node.classList.remove("search-highlight");
			 if (hasQuery) {
			  node.classList.add("search-faded");
			 } else {
			  node.classList.remove("search-faded");
			 }
			}
		   });
		   document.querySelectorAll(".edge-group, .edge").forEach(edge => {
			if (hasQuery) {
			 edge.classList.add("search-faded");
			} else {
			 edge.classList.remove("search-faded");
			}
		   });
		}
		function clearSearchHighlight() {
		   document.querySelectorAll(".search-highlight").forEach(node => {
			node.classList.remove("search-highlight");
		   });
		   document.querySelectorAll(".search-faded").forEach(el => {
			el.classList.remove("search-faded");
		   });
		}
      function editNodeMac(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       document.getElementById("modal-title").textContent = "Edit MAC Address";
       document.getElementById("modal-input").value = node.mac || "";
       document.getElementById("edit-modal").style.display = "flex";
       document.getElementById("modal-input").focus();
       const saveHandler = () => {
        pushUndo("edit mac");
        const value = document.getElementById("modal-input").value.trim();
        node.mac = value;
        document.getElementById("edit-modal").style.display = "none";
        claimTheImmortal(id);
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       const cancelHandler = () => {
        document.getElementById("edit-modal").style.display = "none";
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       document.getElementById("edit-modal").addEventListener("click", function bgHandler(e) {
        if (e.target === document.getElementById("edit-modal")) {
         cancelHandler();
         document.getElementById("edit-modal").removeEventListener("click", bgHandler);
        }
       });
      }
      function editNodeRack(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       document.getElementById("modal-title").textContent = "Edit Rack Unit";
       document.getElementById("modal-input").value = node.rackUnit || "";
       document.getElementById("edit-modal").style.display = "flex";
       document.getElementById("modal-input").focus();
       const saveHandler = () => {
        pushUndo("edit rack");
        const value = document.getElementById("modal-input").value.trim();
        node.rackUnit = value;
        document.getElementById("edit-modal").style.display = "none";
        claimTheImmortal(id);
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       const cancelHandler = () => {
        document.getElementById("edit-modal").style.display = "none";
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       document.getElementById("edit-modal").addEventListener("click", function bgHandler(e) {
        if (e.target === document.getElementById("edit-modal")) {
         cancelHandler();
         document.getElementById("edit-modal").removeEventListener("click", bgHandler);
        }
       });
      }
      function editNodeUHeight(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       document.getElementById("modal-title").textContent = "Edit U Height";
       document.getElementById("modal-input").value = node.uHeight || "1";
       document.getElementById("edit-modal").style.display = "flex";
       document.getElementById("modal-input").focus();
       const saveHandler = () => {
        pushUndo("edit U height");
        const value = document.getElementById("modal-input").value.trim();
        node.uHeight = value;
        document.getElementById("edit-modal").style.display = "none";
        claimTheImmortal(id);
        forgeTheTopology();
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       const cancelHandler = () => {
        document.getElementById("edit-modal").style.display = "none";
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       document.getElementById("edit-modal").addEventListener("click", function bgHandler(e) {
        if (e.target === document.getElementById("edit-modal")) {
         cancelHandler();
         document.getElementById("edit-modal").removeEventListener("click", bgHandler);
        }
       });
      }
      function updateEdgePortLabels(edgeId) {
       const edge = EDGE_DATA.list.find(e => e.id === edgeId);
       if (!edge) return;
       const fromPortInput = document.getElementById("edge-from-port");
       const toPortInput = document.getElementById("edge-to-port");
       edge.fromPort = fromPortInput ? fromPortInput.value.trim() : "";
       edge.toPort = toPortInput ? toPortInput.value.trim() : "";
       forgeTheTopology();
      }
      document.addEventListener("keydown", handleKeyDown);
      const undoBtn = document.getElementById("undo-btn");
      const redoBtn = document.getElementById("redo-btn");
      if (undoBtn) undoBtn.addEventListener("click", undo);
      if (redoBtn) redoBtn.addEventListener("click", redo);
      const backToTopologyBtn = document.getElementById("back-to-topology-btn");
      if (backToTopologyBtn) {
       backToTopologyBtn.addEventListener("click", exitRack);
      }
      const bulkToolbarClose = document.getElementById("bulk-toolbar-close");
      if (bulkToolbarClose) {
       bulkToolbarClose.addEventListener("click", clearSelection);
      }
      const bulkAlignLeft = document.getElementById("bulk-align-left");
      if (bulkAlignLeft) {
       bulkAlignLeft.addEventListener("click", () => alignSelectedNodes("left"));
      }
      const bulkAlignRight = document.getElementById("bulk-align-right");
      if (bulkAlignRight) {
       bulkAlignRight.addEventListener("click", () => alignSelectedNodes("right"));
      }
      const bulkAlignTop = document.getElementById("bulk-align-top");
      if (bulkAlignTop) {
       bulkAlignTop.addEventListener("click", () => alignSelectedNodes("top"));
      }
      const bulkAlignBottom = document.getElementById("bulk-align-bottom");
      if (bulkAlignBottom) {
       bulkAlignBottom.addEventListener("click", () => alignSelectedNodes("bottom"));
      }
      const bulkDistributeH = document.getElementById("bulk-distribute-h");
      if (bulkDistributeH) {
       bulkDistributeH.addEventListener("click", () => distributeSelectedNodes("horizontal"));
      }
      const bulkDistributeV = document.getElementById("bulk-distribute-v");
      if (bulkDistributeV) {
       bulkDistributeV.addEventListener("click", () => distributeSelectedNodes("vertical"));
      }
      const bulkClone = document.getElementById("bulk-clone");
      if (bulkClone) {
       bulkClone.addEventListener("click", () => {
        if (selectedNodes.size === 0) return;
        pushUndo("clone selected");
        const nodesToClone = Array.from(selectedNodes);
        selectedNodes.clear();
       nodesToClone.forEach(id => {
         cloneNode(id, true);
         selectedNodes.add(currentNodeId);
        });
        updateNodeSelection();
       });
      }
      const bulkDelete = document.getElementById("bulk-delete");
      if (bulkDelete) {
       bulkDelete.addEventListener("click", deleteSelected);
      }
      const bulkMobileBtn = document.getElementById("bulk-mobile-btn");
      const bulkActionsModal = document.getElementById("bulk-actions-modal");
      const bulkModalClose = document.getElementById("bulk-modal-close");
      if (bulkMobileBtn) {
       bulkMobileBtn.addEventListener("click", () => {
        if (bulkActionsModal) bulkActionsModal.style.display = "block";
       });
      }
      if (bulkModalClose) {
       bulkModalClose.addEventListener("click", () => {
        if (bulkActionsModal) bulkActionsModal.style.display = "none";
       });
      }
      const closeModalAfterAction = () => {
       if (bulkActionsModal) bulkActionsModal.style.display = "none";
      };
      const bulkAlignLeftMobile = document.getElementById("bulk-align-left-mobile");
      if (bulkAlignLeftMobile) {
       bulkAlignLeftMobile.addEventListener("click", () => {
        alignSelectedNodes("left");
        closeModalAfterAction();
       });
      }
      const bulkAlignRightMobile = document.getElementById("bulk-align-right-mobile");
      if (bulkAlignRightMobile) {
       bulkAlignRightMobile.addEventListener("click", () => {
        alignSelectedNodes("right");
        closeModalAfterAction();
       });
      }
      const bulkAlignTopMobile = document.getElementById("bulk-align-top-mobile");
      if (bulkAlignTopMobile) {
       bulkAlignTopMobile.addEventListener("click", () => {
        alignSelectedNodes("top");
        closeModalAfterAction();
       });
      }
      const bulkAlignBottomMobile = document.getElementById("bulk-align-bottom-mobile");
      if (bulkAlignBottomMobile) {
       bulkAlignBottomMobile.addEventListener("click", () => {
        alignSelectedNodes("bottom");
        closeModalAfterAction();
       });
      }
      const bulkDistributeHMobile = document.getElementById("bulk-distribute-h-mobile");
      if (bulkDistributeHMobile) {
       bulkDistributeHMobile.addEventListener("click", () => {
        distributeSelectedNodes("horizontal");
        closeModalAfterAction();
       });
      }
      const bulkDistributeVMobile = document.getElementById("bulk-distribute-v-mobile");
      if (bulkDistributeVMobile) {
       bulkDistributeVMobile.addEventListener("click", () => {
        distributeSelectedNodes("vertical");
        closeModalAfterAction();
       });
      }
      const bulkCloneMobile = document.getElementById("bulk-clone-mobile");
      if (bulkCloneMobile) {
       bulkCloneMobile.addEventListener("click", () => {
        if (selectedNodes.size === 0) return;
        pushUndo("clone selected");
        const nodesToClone = Array.from(selectedNodes);
        selectedNodes.clear();
        nodesToClone.forEach(id => {
         cloneNode(id, true);
         selectedNodes.add(currentNodeId);
        });
        updateNodeSelection();
        closeModalAfterAction();
       });
      }
      const bulkDeleteMobile = document.getElementById("bulk-delete-mobile");
      if (bulkDeleteMobile) {
       bulkDeleteMobile.addEventListener("click", () => {
        deleteSelected();
        closeModalAfterAction();
       });
      }
      const bulkLockMobile = document.getElementById("bulk-lock-mobile");
      if (bulkLockMobile) {
       bulkLockMobile.addEventListener("click", () => {
        toggleLockSelected();
        closeModalAfterAction();
       });
      }
      const bulkGroupMobile = document.getElementById("bulk-group-mobile");
      if (bulkGroupMobile) {
       bulkGroupMobile.addEventListener("click", () => {
        toggleGroupSelected();
        closeModalAfterAction();
       });
      }
      const bulkClearMobile = document.getElementById("bulk-clear-mobile");
      if (bulkClearMobile) {
       bulkClearMobile.addEventListener("click", () => {
        clearSelection();
        closeModalAfterAction();
       });
      }
      const searchInput = document.getElementById("search-nodes");
if (searchInput) {
 searchInput.addEventListener("input", (e) => {
  searchNodes(e.target.value);
 });
}
       document.getElementById("save-file-btn").addEventListener("click", becomeImmortal);
       document.getElementById("check-all-ping-btn").addEventListener("click", checkAllNodesStatus);
       const addNodeBtn = document.getElementById("add-node-btn");
       const addNodeModal = document.getElementById("add-node-modal");
       const addNodeCancel = document.getElementById("add-node-cancel");
       const addNodeSave = document.getElementById("add-node-save");
       addNodeBtn.addEventListener("click", () => {
	    if (isViewOnly()) return;
        document.getElementById("new-node-name").value = "";
        document.getElementById("new-node-ip").value = "";
        document.getElementById("new-node-tags").value = "";
        document.getElementById("new-node-shape").value = "circle";
        document.getElementById("new-node-pingable").checked = false;
        document.getElementById("new-node-ping-protocol").value = "http";
        document.getElementById("new-node-custom-url").value = "";
        document.getElementById("new-node-ping-timeout").value = "3000";
        document.getElementById("new-node-ping-options").style.display = "none";
        document.getElementById("new-node-custom-url-container").style.display = "none";
        newNodeIconTags = [];
        document.getElementById("new-node-icon-tags").style.display = "none";
        document.getElementById("new-node-icon-tags-list").innerHTML = "";
        addNodeModal.classList.add("active");
        document.getElementById("new-node-name").focus();
       });
       const canvasViewport = document.getElementById("canvas-viewport");
       if (canvasViewport) {
        canvasViewport.addEventListener("dblclick", (e) => {
         if (currentView.mode === "rack" && e.target.id === "map") {
          exitRack();
         }
        });
       }
       const layersBtn = document.getElementById("layers-btn");
       const layerModal = document.getElementById("layer-modal");
       const layerModalClose = document.getElementById("layer-modal-close");
       if (layersBtn && layerModal) {
        layersBtn.addEventListener("click", () => {
         layerModal.classList.add("active");
        });
       }
       if (layerModalClose && layerModal) {
        layerModalClose.addEventListener("click", () => {
         layerModal.classList.remove("active");
        });
       }
       if (layerModal) {
        layerModal.addEventListener("click", (e) => {
         if (e.target === layerModal) {
          layerModal.classList.remove("active");
         }
        });
       }
       const tabsBtn = document.getElementById("tabs-btn");
       const tabsModal = document.getElementById("tabs-modal");
       const tabsModalClose = document.getElementById("tabs-modal-close");
       if (tabsBtn && tabsModal) {
         tabsBtn.addEventListener("click", () => {
           displayTabs();
           tabsModal.classList.add("active");
         });
       }
       if (tabsModalClose && tabsModal) {
         tabsModalClose.addEventListener("click", () => {
           tabsModal.classList.remove("active");
         });
       }
       if (tabsModal) {
         tabsModal.addEventListener("click", (e) => {
           if (e.target === tabsModal) {
             tabsModal.classList.remove("active");
           }
         });
       }
       const rollbackBtn = document.getElementById("rollback-btn");
       const rollbackModal = document.getElementById("rollback-modal");
       const rollbackModalClose = document.getElementById("rollback-modal-close");
       if (rollbackBtn && rollbackModal) {
         rollbackBtn.addEventListener("click", () => {
           loadRollbackVersions();
           rollbackModal.classList.add("active");
         });
       }
       if (rollbackModalClose && rollbackModal) {
         rollbackModalClose.addEventListener("click", () => {
           rollbackModal.classList.remove("active");
         });
       }
       if (rollbackModal) {
         rollbackModal.addEventListener("click", (e) => {
           if (e.target === rollbackModal) {
             rollbackModal.classList.remove("active");
           }
         });
       }
       const auditLogBtn = document.getElementById("audit-log-btn");
       const auditLogModal = document.getElementById("audit-log-modal");
       const auditLogModalClose = document.getElementById("audit-log-modal-close");
       if (auditLogBtn && auditLogModal) {
         auditLogBtn.addEventListener("click", () => {
           loadAuditLog();
           displayAuditLog();
           auditLogModal.classList.add("active");
         });
       }
       if (auditLogModalClose && auditLogModal) {
         auditLogModalClose.addEventListener("click", () => {
           auditLogModal.classList.remove("active");
         });
       }
       if (auditLogModal) {
         auditLogModal.addEventListener("click", (e) => {
           if (e.target === auditLogModal) {
             auditLogModal.classList.remove("active");
           }
         });
       }
       const auditFilter = document.getElementById("audit-filter");
       if (auditFilter) {
         auditFilter.addEventListener("change", (e) => {
           displayAuditLog(e.target.value);
         });
       }
       const secretsBtn = document.getElementById("secrets-btn");
       const secretsModal = document.getElementById("secrets-modal");
       const secretsModalClose = document.getElementById("secrets-modal-close");
       if (secretsBtn && secretsModal) {
         secretsBtn.addEventListener("click", () => {
           displaySecrets();
           secretsModal.classList.add("active");
         });
       }
       if (secretsModalClose && secretsModal) {
         secretsModalClose.addEventListener("click", () => {
           secretsModal.classList.remove("active");
         });
       }
       if (secretsModal) {
         secretsModal.addEventListener("click", (e) => {
           if (e.target === secretsModal) {
             secretsModal.classList.remove("active");
           }
         });
       }
       const secretEditorModal = document.getElementById("secret-editor-modal");
       if (secretEditorModal) {
         secretEditorModal.addEventListener("click", (e) => {
           if (e.target === secretEditorModal) {
             closeSecretEditor();
           }
         });
       }
       ["physical", "logical", "security", "application"].forEach(layer => {
        const checkbox = document.getElementById(`layer-${layer}`);
        if (checkbox) {
         checkbox.addEventListener("change", applyLayerFilter);
        }
       });
       const layerSelect = document.getElementById("node-layer");
       if (layerSelect) {
        layerSelect.addEventListener("change", (e) => {
         if (currentNodeId) {
          pushUndo("change layer");
          NODE_DATA[currentNodeId].layer = e.target.value;
          forgeTheTopology();
         }
        });
       }
       const assignedRackSelect = document.getElementById("node-assigned-rack");
       if (assignedRackSelect) {
        assignedRackSelect.addEventListener("change", (e) => {
      if (currentNodeId) {
      pushUndo("change assigned rack");
      EDGE_DATA.list = EDGE_DATA.list.filter(edge => edge.from !== currentNodeId && edge.to !== currentNodeId);
      NODE_DATA[currentNodeId].assignedRack = e.target.value;
      forgeTheTopology();
      claimTheImmortal(currentNodeId);
      }
      });
       }
       const rackCapacitySelect = document.getElementById("node-rack-capacity");
       if (rackCapacitySelect) {
        rackCapacitySelect.addEventListener("change", (e) => {
         if (currentNodeId) {
          pushUndo("change rack capacity");
          NODE_DATA[currentNodeId].rackCapacity = e.target.value;
          forgeTheTopology();
         }
        });
       }
       const addRackBtn = document.getElementById("add-rack-btn");
       const addRackModal = document.getElementById("add-rack-modal");
       const addRackCancel = document.getElementById("add-rack-cancel");
       const addRackSave = document.getElementById("add-rack-save");
       if (addRackBtn && addRackModal) {
        addRackBtn.addEventListener("click", () => {
		if (isViewOnly()) return;
         document.getElementById("new-rack-name").value = "";
         document.getElementById("new-rack-ip").value = "";
         document.getElementById("new-rack-tags").value = "";
         document.getElementById("new-rack-shape").value = "server";
         document.getElementById("new-rack-capacity").value = "42";
         selectedRackIconData = null;
         document.getElementById('selected-rack-icon').style.display = 'none';
         addRackModal.classList.add("active");
         document.getElementById("new-rack-name").focus();
        });
       }
       if (addRackCancel && addRackModal) {
        addRackCancel.addEventListener("click", () => {
         addRackModal.classList.remove("active");
        });
       }
       if (addRackModal) {
        addRackModal.addEventListener("click", (e) => {
         if (e.target === addRackModal) {
          addRackModal.classList.remove("active");
         }
        });
       }
       if (addRackSave && addRackModal) {
        addRackSave.addEventListener("click", () => {
         const name = document.getElementById("new-rack-name").value.trim();
         const ip = document.getElementById("new-rack-ip").value.trim();
         const tagsStr = document.getElementById("new-rack-tags").value.trim();
         const shape = document.getElementById("new-rack-shape").value;
         const capacity = document.getElementById("new-rack-capacity").value;
         if (!name) {
          alert("Please enter a rack name.");
          return;
         }
         const tags = tagsStr ? tagsStr.split(",").map((t) => t.trim()).filter((t) => t) : [];
         let baseId = name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");
         if (!baseId) baseId = "rack";
         let nodeId = baseId;
         let counter = 1;
         while (NODE_DATA[nodeId]) {
          nodeId = baseId + "-" + counter;
          counter++;
         }
         pushUndo("add rack");
         NODE_DATA[nodeId] = {
          shape: shape,
          name: name,
          ip: ip || "",
          role: "Rack",
          tags: tags,
          notes: [],
          mac: "",
          rackUnit: "",
          uHeight: "1",
          layer: "physical",
          assignedRack: "",
          rackCapacity: capacity,
          isRack: true,
          locked: false,
          groupId: null
         };
         const viewWidth = CANVAS_WIDTH / canvasState.zoom;
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         const centerX = canvasState.panX + (viewWidth / 2);
         const centerY = canvasState.panY + (viewHeight / 2);
         savedPositions[nodeId] = {
          x: centerX,
          y: centerY
         };
         if (selectedRackIconData) {
          if (!savedStyles[nodeId]) {
           savedStyles[nodeId] = {};
          }
          if (!savedStyles[nodeId]['all']) {
           savedStyles[nodeId]['all'] = {};
          }
          savedStyles[nodeId]['all'].icon = {
           library: selectedRackIconData.library,
           name: selectedRackIconData.name
          };
          selectedRackIconData = null;
          document.getElementById('selected-rack-icon').style.display = 'none';
         }
         addRackModal.classList.remove("active");
         forgeTheTopology();
         claimTheImmortal(nodeId);
        });
        ["new-rack-name", "new-rack-ip", "new-rack-tags"].forEach((inputId) => {
         const input = document.getElementById(inputId);
         if (input) {
          input.addEventListener("keypress", (e) => {
           if (e.key === "Enter") {
            addRackSave.click();
           }
          });
         }
        });
       }
       addNodeCancel.addEventListener("click", () => {
        addNodeModal.classList.remove("active");
       });
       addNodeModal.addEventListener("click", (e) => {
        if (e.target === addNodeModal) {
         addNodeModal.classList.remove("active");
        }
       });
       addNodeSave.addEventListener("click", () => {
        const name = document.getElementById("new-node-name").value.trim();
        const ip = document.getElementById("new-node-ip").value.trim();
        const tagsStr = document.getElementById("new-node-tags").value.trim();
        const shape = document.getElementById("new-node-shape").value;
        const pingable = document.getElementById("new-node-pingable").checked;
        const pingProtocol = document.getElementById("new-node-ping-protocol").value;
        const pingCustomUrl = document.getElementById("new-node-custom-url").value.trim();
        const pingTimeout = parseInt(document.getElementById("new-node-ping-timeout").value) || 3000;
        if (!name) {
         alert("Please enter a node name.");
         return;
        }
        const tags = tagsStr ? tagsStr.split(",").map((t) => t.trim()).filter((t) => t) : [];
        if (newNodeIconTags.length > 0) {
         tags.push(...newNodeIconTags);
        }
        let baseId = name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");
        if (!baseId) baseId = "node";
        let nodeId = baseId;
        let counter = 1;
        while (NODE_DATA[nodeId]) {
         nodeId = baseId + "-" + counter;
         counter++;
        }
		pushUndo("add node");
        NODE_DATA[nodeId] = {
         shape: shape || "circle",
         name: name,
         ip: ip || "0.0.0.0",
         role: "",
         tags: tags,
         notes: [],
         mac: "",
         rackUnit: "",
         uHeight: "1",
         ping: {
          enabled: pingable,
          protocol: pingProtocol,
          customUrl: pingCustomUrl,
          timeout: pingTimeout,
          status: 'unknown',
          lastCheck: null
         },
         locked: false,
         groupId: null
        };
        if (currentView.mode === "rack" && currentView.rackId) {
         NODE_DATA[nodeId].assignedRack = currentView.rackId;
         NODE_DATA[nodeId].layer = "physical";
         const rackCapacity = getRackCapacity(currentView.rackId);
         const rackUHeight = getRackUHeight(currentView.rackId);
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         const centerY = canvasState.panY + (viewHeight / 2);
         let unit = rackCapacity - Math.round((centerY - RACK_START_Y) / rackUHeight);
         unit = Math.max(1, Math.min(rackCapacity, unit));
         NODE_DATA[nodeId].rackUnit = String(unit);
        }
        if (selectedNodeIconData) {
         if (!savedStyles[nodeId]) savedStyles[nodeId] = {};
         if (!savedStyles[nodeId]['all']) savedStyles[nodeId]['all'] = {};
         savedStyles[nodeId]['all'].icon = {
          library: selectedNodeIconData.library,
          name: selectedNodeIconData.name
         };
         selectedNodeIconData = null;
         document.getElementById('selected-node-icon').style.display = 'none';
        }
        newNodeIconTags = [];
      const viewWidth = CANVAS_WIDTH / canvasState.zoom;
      const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
      const centerX = canvasState.panX + (viewWidth / 2);
      const centerY = canvasState.panY + (viewHeight / 2);
      savedPositions[nodeId] = {
      x: centerX,
      y: centerY
      };
        addNodeModal.classList.remove("active");
        forgeTheTopology();
        claimTheImmortal(nodeId);
       });
       ["new-node-name", "new-node-ip", "new-node-tags"].forEach(
        (inputId) => {
         document.getElementById(inputId).addEventListener("keypress", (e) => {
          if (e.key === "Enter") {
           addNodeSave.click();
          }
         });
        }, );
       document.getElementById('new-node-pingable').addEventListener('change', (e) => {
        const pingOptions = document.getElementById('new-node-ping-options');
        pingOptions.style.display = e.target.checked ? 'block' : 'none';
       });
       document.getElementById('new-node-ping-protocol').addEventListener('change', (e) => {
        const customUrlContainer = document.getElementById('new-node-custom-url-container');
        customUrlContainer.style.display = e.target.value === 'custom' ? 'block' : 'none';
       });
       document.getElementById('pick-rack-icon-btn').addEventListener('click', () => {
        openIconPicker((iconData) => {
         selectedRackIconData = iconData;
         const preview = document.getElementById('selected-rack-icon-preview');
         const container = document.getElementById('selected-rack-icon');
         const parser = new DOMParser();
         const doc = parser.parseFromString(iconData.svg, 'image/svg+xml');
         const svgEl = doc.querySelector('svg');
         preview.innerHTML = '';
         if (svgEl) {
          preview.appendChild(svgEl.cloneNode(true));
         }
         const nameSpan = document.createElement('span');
         nameSpan.textContent = iconData.name;
         preview.appendChild(nameSpan);
         container.style.display = 'block';
        });
       });
       document.getElementById('pick-node-icon-btn').addEventListener('click', () => {
        openIconPicker((iconData) => {
         selectedNodeIconData = iconData;
         const preview = document.getElementById('selected-node-icon-preview');
         const container = document.getElementById('selected-node-icon');
         const parser = new DOMParser();
         const doc = parser.parseFromString(iconData.svg, 'image/svg+xml');
         const svgEl = doc.querySelector('svg');
         preview.innerHTML = '';
         if (svgEl) {
          preview.appendChild(svgEl.cloneNode(true));
         }
         const nameSpan = document.createElement('span');
         nameSpan.textContent = iconData.name;
         preview.appendChild(nameSpan);
         container.style.display = 'block';
        });
       });
       document.getElementById('pick-tag-icon-btn').addEventListener('click', () => {
        if (!currentNodeId) return;
        openIconPicker((iconData) => {
         if (!currentNodeId || !NODE_DATA[currentNodeId]) return;
         if (!NODE_DATA[currentNodeId].tags) {
          NODE_DATA[currentNodeId].tags = [];
         }
         NODE_DATA[currentNodeId].tags.push({
          type: 'icon',
          library: iconData.library,
          name: iconData.name
         });
         forgeTheTopology();
         claimTheImmortal(currentNodeId);
        });
       });
       document.getElementById('pick-new-node-tag-icon-btn').addEventListener('click', () => {
        openIconPicker((iconData) => {
         newNodeIconTags.push({
          type: 'icon',
          library: iconData.library,
          name: iconData.name
         });
         const container = document.getElementById('new-node-icon-tags');
         const list = document.getElementById('new-node-icon-tags-list');
         const badge = document.createElement('div');
         badge.className = 'icon-badge';
         badge.style.cssText = 'display: inline-flex; align-items: center; gap: 6px; padding: 6px 10px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; font-size: 13px;';
         const iconPreview = document.createElement('div');
         iconPreview.style.cssText = 'width: 16px; height: 16px; display: flex; align-items: center; justify-content: center;';
         IconLibrary.getIcon(iconData.library, iconData.name).then(svg => {
          if (svg) {
           const parser = new DOMParser();
           const doc = parser.parseFromString(svg, 'image/svg+xml');
           const svgEl = doc.querySelector('svg');
           if (svgEl) {
            svgEl.setAttribute('width', '16');
            svgEl.setAttribute('height', '16');
            svgEl.style.fill = 'var(--text-main)';
            iconPreview.appendChild(svgEl);
           }
          }
         });
         const name = document.createElement('span');
         name.textContent = iconData.name;
         name.style.color = 'var(--text-soft)';
         const removeBtn = document.createElement('button');
         removeBtn.textContent = '√ó';
         removeBtn.style.cssText = 'background: none; border: none; color: var(--danger); cursor: pointer; font-size: 18px; line-height: 1; padding: 0 4px;';
         removeBtn.addEventListener('click', () => {
          const index = newNodeIconTags.findIndex(t => t.type === 'icon' && t.library === iconData.library && t.name === iconData.name);
          if (index > -1) {
           newNodeIconTags.splice(index, 1);
          }
          badge.remove();
          if (list.children.length === 0) {
           container.style.display = 'none';
          }
         });
         badge.appendChild(iconPreview);
         badge.appendChild(name);
         badge.appendChild(removeBtn);
         list.appendChild(badge);
         container.style.display = 'block';
        });
       });
       document.getElementById('pick-shape-icon-btn').addEventListener('click', () => {
        if (!currentNodeId) return;
        openIconPicker((iconData) => {
         if (!savedStyles[currentNodeId]) {
          savedStyles[currentNodeId] = {};
         }
         if (!savedStyles[currentNodeId][currentStyleScope]) {
          savedStyles[currentNodeId][currentStyleScope] = {};
         }
         savedStyles[currentNodeId][currentStyleScope].icon = {
          library: iconData.library,
          name: iconData.name
         };
		 delete savedStyles[currentNodeId][currentStyleScope].circleColor;
         delete savedStyles[currentNodeId][currentStyleScope].circleBorder;
         const shapeSelect = document.getElementById('shape-select');
         if (!shapeSelect.querySelector('option[value="custom-icon"]')) {
          const opt = document.createElement('option');
          opt.value = 'custom-icon';
          opt.textContent = 'Custom Icon';
          shapeSelect.insertBefore(opt, shapeSelect.firstChild);
         }
         shapeSelect.value = 'custom-icon';
         forgeTheTopology();
        });
       });
       document.getElementById('add-tag-btn').addEventListener('click', () => {
        if (!currentNodeId) return;
        if (!NODE_DATA[currentNodeId]) return;
        const input = document.getElementById('new-tag-input');
        const tagText = input.value.trim();
        if (!tagText) return;
        if (!NODE_DATA[currentNodeId].tags) {
         NODE_DATA[currentNodeId].tags = [];
        }
        NODE_DATA[currentNodeId].tags.push(tagText);
        input.value = '';
        forgeTheTopology();
        claimTheImmortal(currentNodeId);
       });
      function saveRollbackVersion(description = "Auto-save") {
        const version = {
          timestamp: Date.now(),
          description,
          data: captureTheQuickening()
        };
        try {
          const stored = localStorage.getItem(ROLLBACK_STORAGE_KEY);
          rollbackVersions = stored ? JSON.parse(stored) : [];
        } catch (e) {
          rollbackVersions = [];
        }
        rollbackVersions.unshift(version);
        if (rollbackVersions.length > MAX_ROLLBACK_VERSIONS) {
          rollbackVersions = rollbackVersions.slice(0, MAX_ROLLBACK_VERSIONS);
        }
        try {
          localStorage.setItem(ROLLBACK_STORAGE_KEY, JSON.stringify(rollbackVersions));
        } catch (e) {
          console.warn("Failed to save rollback version:", e);
        }
      }
      function loadRollbackVersions() {
        try {
          const stored = localStorage.getItem(ROLLBACK_STORAGE_KEY);
          rollbackVersions = stored ? JSON.parse(stored) : [];
          displayRollbackVersions();
        } catch (e) {
          console.warn("Failed to load rollback versions:", e);
          rollbackVersions = [];
        }
      }
      function displayRollbackVersions() {
        const listEl = document.getElementById("rollback-list");
        if (!listEl) return;
        if (rollbackVersions.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No version history yet. Versions are saved automatically when you save the file.</div>';
          return;
        }
        listEl.innerHTML = rollbackVersions.map((version, index) => {
          const date = new Date(version.timestamp);
          const timeStr = date.toLocaleString();
          const nodeCount = Object.keys(version.data.nodeData || {}).length;
          const edgeCount = (version.data.edgeData?.list || []).length;
          return `
            <div class="version-item" onclick="restoreRollbackVersion(${index})">
              <div class="version-info">
                <div class="timestamp">${timeStr}</div>
                <div class="details">${version.description} ‚Ä¢ ${nodeCount} nodes ‚Ä¢ ${edgeCount} connections</div>
              </div>
              <div class="version-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteRollbackVersion(${index})" title="Delete this version">üóëÔ∏è</button>
              </div>
            </div>
          `;
        }).join('');
      }
      function restoreRollbackVersion(index) {
        if (!confirm(`Restore version from ${new Date(rollbackVersions[index].timestamp).toLocaleString()}?\n\nYour current work will be lost unless you save first.`)) {
          return;
        }
        const version = rollbackVersions[index];
        const data = version.data;
        NODE_DATA = data.nodeData || {};
        EDGE_DATA = data.edgeData || { list: [] };
        RECT_DATA = data.rectData || { list: [] };
        TEXT_DATA = data.textData || { list: [] };
        EDGE_LEGEND = data.edgeLegend || {};
        savedPositions = data.nodePositions || {};
        savedSizes = data.nodeSizes || {};
        savedStyles = data.nodeStyles || {};
        PAGE_STATE = data.page || PAGE_STATE;
        if (data.canvas) {
          canvasState.zoom = data.canvas.zoom;
          canvasState.panX = data.canvas.panX;
          canvasState.panY = data.canvas.panY;
        }
        wieldThePower();
        forgeTheTopology();
        document.getElementById("rollback-modal").classList.remove("active");
        logAuditEvent("rollback", `Restored version from ${new Date(version.timestamp).toLocaleString()}`);
      }
      function deleteRollbackVersion(index) {
        if (!confirm("Delete this version from history?")) return;
        rollbackVersions.splice(index, 1);
        try {
          localStorage.setItem(ROLLBACK_STORAGE_KEY, JSON.stringify(rollbackVersions));
        } catch (e) {
          console.warn("Failed to delete version:", e);
        }
        displayRollbackVersions();
      }
      function clearRollbackHistory() {
        if (!confirm("Clear all version history?\n\nThis cannot be undone.")) return;
        rollbackVersions = [];
        localStorage.removeItem(ROLLBACK_STORAGE_KEY);
        displayRollbackVersions();
      }
      function createManualSnapshot() {
        const description = prompt("Enter a description for this snapshot:", "Manual snapshot");
        if (!description) return;
        saveRollbackVersion(description);
        displayRollbackVersions();
      }
      function switchTab(index) {
        if (index === currentTabIndex) return;
        const currentTab = documentTabs[currentTabIndex];
        currentTab.nodes = JSON.parse(JSON.stringify(NODE_DATA));
        currentTab.edges = JSON.parse(JSON.stringify(EDGE_DATA));
        currentTab.positions = JSON.parse(JSON.stringify(savedPositions));
        currentTab.sizes = JSON.parse(JSON.stringify(savedSizes));
        currentTab.styles = JSON.parse(JSON.stringify(savedStyles));
        currentTab.legend = JSON.parse(JSON.stringify(EDGE_LEGEND));
        currentTab.rects = JSON.parse(JSON.stringify(RECT_DATA));
        currentTab.texts = JSON.parse(JSON.stringify(TEXT_DATA));
        currentTab.pageState = JSON.parse(JSON.stringify(PAGE_STATE));
        currentTabIndex = index;
        const newTab = documentTabs[index];
        NODE_DATA = JSON.parse(JSON.stringify(newTab.nodes));
        EDGE_DATA = JSON.parse(JSON.stringify(newTab.edges));
        savedPositions = JSON.parse(JSON.stringify(newTab.positions));
        savedSizes = JSON.parse(JSON.stringify(newTab.sizes));
        savedStyles = JSON.parse(JSON.stringify(newTab.styles));
        EDGE_LEGEND = JSON.parse(JSON.stringify(newTab.legend));
        RECT_DATA = JSON.parse(JSON.stringify(newTab.rects));
        TEXT_DATA = JSON.parse(JSON.stringify(newTab.texts));
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, newTab.pageState || {});
        wieldThePower();
        document.title = PAGE_STATE.title || newTab.name;
        document.getElementById("page-title").textContent = PAGE_STATE.title || newTab.name;
        forgeTheTopology();
        currentNodeId = null;
        currentEdgeId = null;
        currentTextId = null;
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        displayTabs();
        logAuditEvent("tab", `Switched to tab: ${newTab.name}`);
      }
      function createNewTab() {
        const nameInput = document.getElementById("new-tab-name");
        const name = nameInput.value.trim();
        if (!name) {
          alert("Please enter a tab name");
          return;
        }
        const newTab = {
          id: `tab-${Date.now()}`,
          name,
          nodes: {},
          edges: { list: [] },
          positions: {},
          sizes: {},
          styles: {},
          legend: {},
          rects: { list: [] },
          texts: { list: [] },
      pageState: null
        };
        documentTabs.push(newTab);
        nameInput.value = "";
        displayTabs();
        logAuditEvent("tab", `Created new tab: ${name}`);
      }
      function renameTab(index) {
        const tab = documentTabs[index];
        const newName = prompt("Enter new name:", tab.name);
        if (!newName || newName === tab.name) return;
        tab.name = newName;
        displayTabs();
        logAuditEvent("tab", `Renamed tab to: ${newName}`);
      }
      function deleteTab(index) {
        if (documentTabs.length === 1) {
          alert("Cannot delete the last tab");
          return;
        }
        if (!confirm(`Delete tab "${documentTabs[index].name}"?`)) return;
        documentTabs.splice(index, 1);
        if (currentTabIndex >= documentTabs.length) {
          currentTabIndex = documentTabs.length - 1;
        }
        if (currentTabIndex === index) {
          switchTab(currentTabIndex);
        }
        displayTabs();
      }
      function displayTabs() {
        const listEl = document.getElementById("tabs-list");
        if (!listEl) return;
        listEl.innerHTML = documentTabs.map((tab, index) => {
          const nodeCount = Object.keys(tab.nodes).length;
          const edgeCount = tab.edges.list.length;
          const isActive = index === currentTabIndex;
          return `
            <div class="tab-item ${isActive ? 'active' : ''}" onclick="switchTab(${index})">
              <div class="tab-name">${tab.name}</div>
              <div class="tab-stats">${nodeCount} nodes ‚Ä¢ ${edgeCount} connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(${index})" title="Rename tab">‚úèÔ∏è</button>
                ${documentTabs.length > 1 ? '<button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(${index})" title="Delete tab">üóëÔ∏è</button>' : ''}
              </div>
            </div>
          `;
        }).join('');
      }
      function logAuditEvent(type, description, details = {}) {
        const event = {
          timestamp: Date.now(),
          type,
          description,
          details,
          tab: documentTabs[currentTabIndex]?.name || "Main"
        };
        auditLog.unshift(event);
        if (auditLog.length > MAX_AUDIT_ENTRIES) {
          auditLog = auditLog.slice(0, MAX_AUDIT_ENTRIES);
        }
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to save audit log:", e);
        }
      }
      function loadAuditLog() {
        let embeddedLog = [];
        let localLog = [];
        try {
          const stateScript = document.getElementById("topology-state");
          if (stateScript) {
            const stateData = JSON.parse(stateScript.textContent);
            if (stateData.auditLog && Array.isArray(stateData.auditLog)) {
              embeddedLog = stateData.auditLog;
            }
          }
        } catch (e) {
          console.warn("Failed to load embedded audit log:", e);
        }
        try {
          const stored = localStorage.getItem(AUDIT_STORAGE_KEY);
          if (stored) {
            localLog = JSON.parse(stored);
          }
        } catch (e) {
          console.warn("Failed to load localStorage audit log:", e);
        }
        const merged = [...embeddedLog, ...localLog];
        const seen = new Set();
        auditLog = merged.filter(entry => {
          const key = entry.timestamp + entry.description;
          if (seen.has(key)) return false;
          seen.add(key);
          return true;
        }).sort((a, b) => b.timestamp - a.timestamp);
        if (auditLog.length > MAX_AUDIT_ENTRIES) {
          auditLog = auditLog.slice(0, MAX_AUDIT_ENTRIES);
        }
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to sync audit log:", e);
        }
      }
      function displayAuditLog(filter = "all") {
        const listEl = document.getElementById("audit-log-list");
        if (!listEl) return;
        const filtered = filter === "all" ? auditLog : auditLog.filter(e => e.type === filter);
        if (filtered.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No audit entries yet</div>';
          return;
        }
        listEl.innerHTML = filtered.map(event => {
          const date = new Date(event.timestamp);
          const timeStr = date.toLocaleString();
          return `<div class="audit-entry ${event.type}">
              <div class="time">[${timeStr}] ${event.tab}</div>
              <div class="action">[${event.type.toUpperCase()}] ${event.description}</div>
            </div>
          `;
        }).join('');
      }
      function clearAuditLog() {
        if (!confirm("Clear all audit log entries?\n\nThis cannot be undone.")) return;
        auditLog = [];
        localStorage.removeItem(AUDIT_STORAGE_KEY);
        displayAuditLog();
      }
      function exportAuditLog() {
        if (auditLog.length === 0) {
          alert("No audit entries to export");
          return;
        }
        const csv = [
          ["Timestamp", "Tab", "Type", "Description"],
          ...auditLog.map(e => [
            new Date(e.timestamp).toISOString(),
            e.tab,
            e.type,
            e.description
          ])
        ].map(row => row.map(cell => `"${cell}"`).join(",")).join("\n");
        const blob = new Blob([csv], { type: "text/csv" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `audit-log-${Date.now()}.csv`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }
      let currentSecretName = null;
      function createNewSecret() {
        const nameInput = document.getElementById("new-secret-name");
        const name = nameInput.value.trim();
        if (!name) {
          alert("Please enter a note name");
          return;
        }
        if (encryptedSections[name]) {
          alert("A note note with this name already exists");
          return;
        }
        currentSecretName = name;
        encryptedSections[name] = { encrypted: false, data: "" };
        nameInput.value = "";
        document.getElementById("secret-editor-title").textContent = `New note: ${name}`;
        document.getElementById("secret-editor-content").value = "";
        document.getElementById("secrets-modal").classList.remove("active");
        document.getElementById("secret-editor-modal").classList.add("active");
        displaySecrets();
      }
      function editSecret(name) {
        currentSecretName = name;
        const section = encryptedSections[name];
        if (section.encrypted) {
          const password = prompt(`Enter password to decrypt "${name}":`);
          if (!password) return;
          try {
            decryptData(section.data, password).then(decrypted => {
              document.getElementById("secret-editor-title").textContent = `Edit Secret: ${name}`;
              document.getElementById("secret-editor-content").value = decrypted;
              document.getElementById("secrets-modal").classList.remove("active");
              document.getElementById("secret-editor-modal").classList.add("active");
            }).catch(e => {
              alert("Failed to decrypt. Wrong password?");
            });
          } catch (e) {
            alert("Failed to decrypt. Wrong password?");
          }
        } else {
          document.getElementById("secret-editor-title").textContent = `Edit note: ${name}`;
          document.getElementById("secret-editor-content").value = section.data;
          document.getElementById("secrets-modal").classList.remove("active");
          document.getElementById("secret-editor-modal").classList.add("active");
        }
      }
      async function saveSecret() {
        if (!currentSecretName) return;
        const content = document.getElementById("secret-editor-content").value;
        const autoEncrypt = document.getElementById("secret-auto-encrypt").checked;
        if (autoEncrypt) {
          const password = prompt(`Enter password to encrypt "${currentSecretName}":`);
          if (!password) return;
          const confirmPassword = prompt("Confirm password:");
          if (password !== confirmPassword) {
            alert("Passwords do not match");
            return;
          }
          try {
            const encrypted = await encryptData(content, password);
            encryptedSections[currentSecretName] = { encrypted: true, data: encrypted };
          } catch (e) {
            alert("Encryption failed: " + e.message);
            return;
          }
        } else {
          encryptedSections[currentSecretName] = { encrypted: false, data: content };
        }
        closeSecretEditor();
        displaySecrets();
        logAuditEvent("secret", `Saved note section: ${currentSecretName}`);
      }
      function closeSecretEditor() {
        document.getElementById("secret-editor-modal").classList.remove("active");
        document.getElementById("secrets-modal").classList.add("active");
        currentSecretName = null;
      }
      function deleteSecret(name) {
        if (!confirm(`Delete note "${name}"?`)) return;
        delete encryptedSections[name];
        displaySecrets();
        logAuditEvent("secret", `Deleted note: ${name}`);
      }
      function displaySecrets() {
        const listEl = document.getElementById("secrets-list");
        if (!listEl) return;
        const secrets = Object.keys(encryptedSections);
        if (secrets.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No notes yet</div>';
          return;
        }
        listEl.innerHTML = secrets.map(name => {
          const section = encryptedSections[name];
          const status = section.encrypted ? "üîí Encrypted" : "üîì Plaintext";
          return `
            <div class="secret-item">
              <div class="secret-name">${name}</div>
              <div class="secret-status">${status}</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="editSecret('${name}')" title="Edit note">‚úèÔ∏è</button>
                <button class="btn-cancel" onclick="deleteSecret('${name}')" title="Delete note">üóëÔ∏è</button>
              </div>
            </div>
          `;
        }).join('');
      }
       const clearAllBtn = document.getElementById("clear-all-btn");
       const clearAllModal = document.getElementById("clear-all-modal");
       const clearAllCancel = document.getElementById("clear-all-cancel");
       const clearAllConfirm = document.getElementById("clear-all-confirm");
       clearAllBtn.addEventListener("click", () => {
        clearAllModal.classList.add("active");
       });
       clearAllCancel.addEventListener("click", () => {
        clearAllModal.classList.remove("active");
       });
       clearAllModal.addEventListener("click", (e) => {
        if (e.target === clearAllModal) {
         clearAllModal.classList.remove("active");
        }
       });
       clearAllConfirm.addEventListener("click", () => {
        pushUndo("clear all");
        NODE_DATA = {};
        EDGE_DATA = {
         list: []
        };
        EDGE_LEGEND = {};
        RECT_DATA = { list: [] };
        TEXT_DATA = { list: [] };
        savedPositions = {};
        savedSizes = {};
        savedStyles = {};
		logAuditEvent("clear", "Cleared all data from canvas");
        clearAllModal.classList.remove("active");
      autoPingEnabled = false;
      autoPingInterval = 30;
      PAGE_STATE.autoPingEnabled = false;
      PAGE_STATE.autoPingInterval = autoPingInterval;
      stopAutoPing();
      document.getElementById("auto-ping-enabled").checked = false;
      document.getElementById("auto-ping-settings").style.display = "none";
      document.getElementById("auto-ping-interval").value = autoPingInterval;
        forgeTheTopology();
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.display = "none";
        currentNodeId = null;
        currentEdgeId = null;
        currentTextId = null;
       });
       (function addDeleteNodeButton() {
       const nodePanel = document.getElementById("node-panel");
       if (!nodePanel) return;
       let deleteBtn = document.getElementById("delete-node-btn");
       if (!deleteBtn) {
        deleteBtn = document.createElement("button");
        deleteBtn.id = "delete-node-btn";
        deleteBtn.textContent = "Delete Node";
        deleteBtn.style.cssText = "margin-top:15px; padding:10px 16px; background:var(--danger); color:#fff; border:none; border-radius:6px; cursor:pointer; font-size:clamp(14px,1.6vw,18px); font-weight:600; width:100%;";
        nodePanel.appendChild(deleteBtn);
       }
       deleteBtn.addEventListener("click", () => {
        if (!currentNodeId) return;
        const nodeData = NODE_DATA[currentNodeId];
        let confirmMessage;
        let nodesInsideRack = [];
        if (nodeData?.isRack) {
         nodesInsideRack = Object.entries(NODE_DATA)
          .filter(([id, n]) => n.assignedRack === currentNodeId)
          .map(([id, n]) => n.name || id);
         if (nodesInsideRack.length > 0) {
          confirmMessage = `Delete rack "${nodeData.name}"?\n\nThis will also delete ${nodesInsideRack.length} node(s) inside:\n‚Ä¢ ${nodesInsideRack.join('\n‚Ä¢ ')}`;
         } else {
          confirmMessage = `Delete rack "${nodeData.name}"? (empty rack)`;
         }
        } else {
         confirmMessage = `Delete node "${nodeData?.name || currentNodeId}" and all its connections?`;
        }
        challengeTheImmortal(confirmMessage, () => {
         pushUndo("delete node");
         if (nodeData?.isRack) {
          Object.keys(NODE_DATA).forEach(id => {
           if (NODE_DATA[id]?.assignedRack === currentNodeId) {
            EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== id && e.to !== id);
            delete NODE_DATA[id];
            delete savedPositions[id];
            delete savedSizes[id];
            delete savedStyles[id];
           }
          });
         }
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== currentNodeId && e.to !== currentNodeId);
         delete NODE_DATA[currentNodeId];
         delete savedPositions[currentNodeId];
         delete savedSizes[currentNodeId];
         delete savedStyles[currentNodeId];
         currentNodeId = null;
         currentEdgeId = null;
         forgeTheTopology();
         const remainingNodes = Object.keys(NODE_DATA);
         if (remainingNodes.length > 0) {
          claimTheImmortal(remainingNodes[0]);
         } else {
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("topology-toolbar").style.display = "none";
         }
        });
       });
      })();
       function screenshotCanvas() {
        const svg = document.getElementById("map");
        const svgClone = svg.cloneNode(true);
        const viewBox = svg.getAttribute("viewBox").split(" ").map(Number);
        const [x, y, width, height] = viewBox;
        svgClone.setAttribute("width", width);
        svgClone.setAttribute("height", height);
        svgClone.setAttribute("viewBox", `${x} ${y} ${width} ${height}`);
        const wrapper = document.createElement("div");
        wrapper.style.position = "absolute";
        wrapper.style.left = "-9999px";
        wrapper.appendChild(svgClone);
        document.body.appendChild(wrapper);
        function inlineStyles(original, clone) {
         const elements = original.querySelectorAll("*");
         const clonedElements = clone.querySelectorAll("*");
         const rootStyles = getComputedStyle(document.documentElement);
         const bgColor = rootStyles.getPropertyValue("--bg").trim() || "#050608";
         const bgRect = document.createElementNS("http://www.w3.org/2000/svg", "rect", );
         bgRect.setAttribute("x", x);
         bgRect.setAttribute("y", y);
         bgRect.setAttribute("width", width);
         bgRect.setAttribute("height", height);
         bgRect.setAttribute("fill", bgColor);
         clone.insertBefore(bgRect, clone.firstChild);
         elements.forEach((el, index) => {
          const clonedEl = clonedElements[index];
          if (!clonedEl) return;
          const computedStyle = getComputedStyle(el);
          const svgProps = ["fill", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin", "opacity", "font-family", "font-size", "font-weight", "font-style", "text-anchor", "dominant-baseline", "marker-start", "marker-end", ];
          svgProps.forEach((prop) => {
           const value = computedStyle.getPropertyValue(prop);
           if (value && value !== "none" && value !== "normal") {
            clonedEl.style[prop] = value;
           }
          });
          clonedEl.removeAttribute("class");
         });
        }
        inlineStyles(svg, svgClone);
        const svgData = new XMLSerializer().serializeToString(svgClone);
        document.body.removeChild(wrapper);
        const svgBlob = new Blob([svgData], {
         type: "image/svg+xml;charset=utf-8",
        });
        const url = URL.createObjectURL(svgBlob);
        const img = new Image();
        img.onload = function() {
         const canvas = document.createElement("canvas");
         canvas.width = width;
         canvas.height = height;
         const ctx = canvas.getContext("2d");
         ctx.drawImage(img, 0, 0);
         canvas.toBlob(function(blob) {
          const link = document.createElement("a");
          const timestamp = new Date().toISOString().slice(0, 10);
          link.download = `topology-${timestamp}.png`;
          link.href = URL.createObjectURL(blob);
          link.click();
          URL.revokeObjectURL(url);
          URL.revokeObjectURL(link.href);
         }, "image/png");
        };
        img.onerror = function() {
         console.error("Failed to load SVG image");
         alert("Screenshot failed. Please try again.");
         URL.revokeObjectURL(url);
        };
        img.src = url;
       }
       function exportCanvasSVG() {
        const svg = document.getElementById("map");
        const svgClone = svg.cloneNode(true);
        const viewBox = svg.getAttribute("viewBox").split(" ").map(Number);
        const [x, y, width, height] = viewBox;
        svgClone.setAttribute("width", width);
        svgClone.setAttribute("height", height);
        const rootStyles = getComputedStyle(document.documentElement);
        const bgColor = rootStyles.getPropertyValue("--bg").trim() || "#050608";
        const bgRect = document.createElementNS("http://www.w3.org/2000/svg", "rect", );
        bgRect.setAttribute("x", x);
        bgRect.setAttribute("y", y);
        bgRect.setAttribute("width", width);
        bgRect.setAttribute("height", height);
        bgRect.setAttribute("fill", bgColor);
        svgClone.insertBefore(bgRect, svgClone.firstChild);
        const wrapper = document.createElement("div");
        wrapper.style.position = "absolute";
        wrapper.style.left = "-9999px";
        wrapper.appendChild(svgClone);
        document.body.appendChild(wrapper);
        const elements = svg.querySelectorAll("*");
        const clonedElements = svgClone.querySelectorAll("*");
        elements.forEach((el, index) => {
         const clonedEl = clonedElements[index];
         if (!clonedEl) return;
         const computedStyle = getComputedStyle(el);
         const svgProps = ["fill", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin", "opacity", "font-family", "font-size", "font-weight", "font-style", "text-anchor", "dominant-baseline", "marker-start", "marker-end", ];
         svgProps.forEach((prop) => {
          const value = computedStyle.getPropertyValue(prop);
          if (value && value !== "none" && value !== "normal") {
           clonedEl.setAttribute(prop, value);
          }
         });
         clonedEl.removeAttribute("class");
        });
        const svgData = new XMLSerializer().serializeToString(svgClone);
        document.body.removeChild(wrapper);
        const blob = new Blob([svgData], {
         type: "image/svg+xml;charset=utf-8",
        });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        const timestamp = new Date().toISOString().slice(0, 10);
        link.download = `topology-${timestamp}.svg`;
        link.href = url;
        link.click();
        URL.revokeObjectURL(url);
       }
      let resizeTimeout;
       window.addEventListener('resize', () => {
       clearTimeout(resizeTimeout);
       resizeTimeout = setTimeout(() => {
       updateDrawToolbarVisibility();
       updateTopologyToolbarVisibility();
       }, 100);
      });
    </script>
</body></html>