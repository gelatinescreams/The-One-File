<!DOCTYPE html> 
 <html lang="en" style="--panel: #2f0e0e; --panel-alt: #10141b; --accent: #a75252; --danger: #f56565; --text-main: #e2e8f0; --text-soft: #94a3b8; --topbar-bg: rgba(9, 12, 20, 0.9); --topbar-border: #1f2533; --topbar-height: 112px; --sidebar-width: 350px; --mobile-footer-height: 40vh; --draw-toolbar-height: 45px; --sidebar-bg: #10141b; --btn-bg: #0b0e13; --btn-text: #e2e8f0; --tag-fill: #1e293b; --tag-text: #e2e8f0; --tag-border: #475569; --input-bg: #0b0e13; --input-text: #e2e8f0; --input-border: #1f2937; --input-font: Inter, system-ui, sans-serif; --input-font-size: 14px; --toolbar-bg: #441215; --toolbar-border: #1f2937; --toolbar-text: #94a3b8; --toolbar-btn-bg: #0b0e13; --toolbar-btn-text: #e2e8f0; --minimap-dots: #94a3b8; --canvas-hint-bg: #0f172a; --canvas-hint-color: #94a3b8; --node-fill: #1e293b; --node-stroke: #475569; --node-title: #e2e8f0; --node-sub: #94a3b8; --node-title-size: 18px; --node-sub-size: 13px; --node-font: Inter, system-ui, sans-serif; --default-edge: #475569; --selection-handle: #f59e0b; --selection-handle-size: 8px; --group-indicator: #4fd1c5;"><head>
    <meta charset="UTF-8">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>The One File</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- 
      * ==================================================================================
      * The One File: The Networkening
      * !!!!!!!!!!!!!!!!!!!NOTE: THIS IS THE ONLINE VERSION!!!!!!!!!!!!!!!!!!!!!!
      * Online version uses 3 cdn calls from cdn.jsdelivr.net to display additional icons
      * Since 3.0 Online version uses http as a form of ping to display uptime
      * "There can be only one". A all in one file topology maker.
      * 
      * This is your last backup when all others fail. A completely self-contained
      * network topology visualization tool that works as a single HTML file.
      * Open it anywhere, anytime and the idea lives forever.
      * ==================================================================================
      -->
    <style>
      :root {
      color-scheme: dark;
      --bg: #050608;
      --panel: #0b0e13;
      --panel-alt: #10141b;
      --accent: #4fd1c5;
      --danger: #f56565;
      --text-main: #e2e8f0;
      --text-soft: #94a3b8;
      --edge-main: #475569;
      --node-min: 35px;
      --node-max: 70px;
      --topbar-bg: rgba(9, 12, 20, 0.9);
      --topbar-border: #1f2533;
      }
	  html, body, svg, .map-container {
      touch-action: none;
      }
      * {
      box-sizing: border-box;
      user-select: none;
      }
      input,
      textarea,
      [contenteditable="true"] {
      user-select: text;
      -webkit-user-select: text;
      }
      body {
      margin: 0;
      font-family: system-ui, sans-serif;
      background: radial-gradient(circle at top, #1e2532 0, #050608 70%);
      color: var(--text-main);
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
      }
      header {
      padding: 0 20px;
      height: var(--topbar-height, 52px);
      min-height: var(--topbar-height, 52px);
      background: var(--topbar-bg);
      backdrop-filter: blur(6px);
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid var(--topbar-border);
      gap: 16px;
      }
      .title-block {
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-width: 0;
      }
      header h1 {
      font-size: clamp(22px, 3vw, 32px);
      margin: 0;
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
      }
      .editable-page-title {
      cursor: pointer;
      transition: opacity 0.2s;
      }
      .editable-page-title:hover {
      opacity: 0.7;
      }
      .save-row {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      }
      .save-btn {
      padding: 6px 12px;
      background: var(--accent);
      color: var(--bg);
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      white-space: nowrap;
      }
      .save-btn:hover {
      opacity: 0.9;
      }
      .help-icon {
      width: 22px;
      height: 22px;
      border-radius: 50%;
      border: 1px solid var(--edge-main);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      cursor: pointer;
      color: var(--text-soft);
      background: rgba(15, 23, 42, 0.9);
      flex-shrink: 0;
      }
      .help-icon:hover {
      color: var(--accent);
      border-color: var(--accent);
      }
      #settings-btn {
      background: var(--btn-bg, var(--panel));
      color: var(--btn-text, var(--text-main));
      border: 1px solid var(--edge-main);
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 16px;
      flex-shrink: 0;
      }
      #settings-btn:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .header-resizer {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 6px;
      background: transparent;
      cursor: row-resize;
      z-index: 1000;
      transition: background 0.2s;
      }
      .header-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .header-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      .sidebar-resizer {
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 6px;
      background: transparent;
      cursor: col-resize;
      z-index: 1000;
      transition: background 0.2s;
      }
      .sidebar-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .sidebar-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      .mobile-footer-resizer {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 6px;
      background: transparent;
      cursor: row-resize;
      z-index: 1000;
      transition: background 0.2s;
      display: none;
      }
      .mobile-footer-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .mobile-footer-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      @media (max-width: 900px) {
      .mobile-footer-resizer {
      display: block;
      height: 12px;
      }
      .sidebar-resizer {
      display: none;
      }
      .header-resizer {
      height: 12px;
      }
      }
      @media (pointer: coarse) {
      .header-resizer {
      height: 16px;
      }
      .mobile-footer-resizer {
      height: 16px;
      }
      .sidebar-resizer {
      width: 16px;
      }
      }
      .resizer-icon {
      position: absolute;
      opacity: 0.5;
      transition: opacity 0.2s, transform 0.2s;
      pointer-events: none;
      fill: var(--accent);
      }
      .header-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .sidebar-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .mobile-footer-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .header-resizer:hover .resizer-icon,
      .sidebar-resizer:hover .resizer-icon,
      .mobile-footer-resizer:hover .resizer-icon {
      opacity: 1;
      }
      .header-resizer.resizing .resizer-icon,
      .sidebar-resizer.resizing .resizer-icon,
      .mobile-footer-resizer.resizing .resizer-icon {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1.2);
      }
      body.resizing {
      user-select: none;
      }
      body.resizing * {
      cursor: inherit !important;
      pointer-events: none;
      }
      header {
      position: relative;
      }
      .details-panel {
      position: relative;
      }
      main {
      display: grid;
      grid-template-columns: 1fr var(--sidebar-width, 350px);
      flex: 1;
      }
      main.sidebar-collapsed {
      grid-template-columns: 1fr 0;
      }
      @media (max-width: 900px) {
      main {
      grid-template-columns: 1fr;
      grid-template-rows: calc(100vh - var(--topbar-height, 52px) - var(--mobile-footer-height, 40vh)) var(--mobile-footer-height, 40vh);
      }
      main.sidebar-collapsed {
      grid-template-rows: 1fr 0;
      }
      .details-panel {
      max-height: var(--mobile-footer-height, 40vh);
      height: 100%;
      }
      }
      .topology-panel {
      background: var(--panel);
      border-right: 1px solid #111827;
      position: relative;
      overflow: hidden;
      }
      .topology-toolbar {
      position: absolute;
      top: 10px;
      right: 10px;
      display: none;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      z-index: 99;
      font-size: 13px;
      color: var(--toolbar-text, #94a3b8);
      }
      .topology-toolbar label {
      color: var(--toolbar-text, var(--text-soft));
      }
      .topology-toolbar select {
      padding: 4px 6px;
      background: var(--toolbar-btn-bg, var(--panel));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 13px;
      cursor: pointer;
      }
      .topology-toolbar button {
      padding: 4px 10px;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      }
      .topology-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .bulk-toolbar-desktop,
      .bulk-toolbar-mobile {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 9999;
      }
      .bulk-toolbar-desktop {
      position: absolute;
      top: 10px;
      right: 10px;
      bottom: auto;
      left: auto;
      transform: none;
      }
      @media (min-width: 768px) {
      .bulk-toolbar-mobile {
      display: none !important;
      }
      }	  
      .bulk-action-btn {
      padding: 16px;
      background: var(--panel-main);
      border: 1px solid var(--edge-main);
      border-radius: 8px;
      color: var(--text-main);
      font-size: 24px;
      cursor: pointer;
      text-align: center;
      line-height: 1.2;
      }
      .bulk-action-btn:active {
      transform: scale(0.95);
      background: var(--accent);
      }
      .draw-toolbar {
      position: absolute;
      top: 10px;
      left: 10px;
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 8px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      z-index: 99;
      font-size: 13px;
      pointer-events: auto;
      color: var(--toolbar-text, #94a3b8);
      }
      .draw-toolbar button {
      padding: 4px 8px;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      }
      .draw-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .draw-toolbar input[type="color"] {
      width: 30px;
      height: 22px;
      border-radius: 4px;
      border: 1px solid var(--edge-main);
      padding: 0;
      background: transparent;
      cursor: pointer;
      }
      .draw-toolbar select {
      padding: 4px 6px;
      background: var(--toolbar-btn-bg, var(--panel));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 13px;
      cursor: pointer;
      }
      .legend-container {
      position: absolute;
      left: 10px;
      bottom: 10px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      padding: 8px 10px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      font-size: 12px;
      z-index: 20;
      max-width: 260px;
      pointer-events: auto;
      color: var(--toolbar-text, #94a3b8);
      }
      .legend-container {
      padding-right: 22px;
      }
      @media (max-width: 900px) {
      .legend-container {
      max-height: calc(100vh - var(--topbar-height, 100px) - 120px);
      overflow-y: auto;
      }
      }
      @media (max-width: 900px) {
      .bulk-toolbar-desktop,
      .topology-toolbar {
      display: none !important;
      }
      }
      .legend-close-btn {
      position: absolute;
      top: 5px;
      right: 5px;
      width: 18px;
      height: 18px;
      border-radius: 999px;
      border: 1px solid var(--edge-main);
      background: var(--panel-alt);
      color: var(--text-soft);
      font-size: 11px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      }
      .legend-close-btn:hover {
      background: var(--danger);
      color: #fff;
      }
      .legend-mini-btn {
      position: absolute;
      left: 10px;
      padding: 4px 8px;
      border-radius: 4px;
      border: 1px solid var(--toolbar-border, #1f2937);
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 11px;
      cursor: pointer;
      z-index: 20;
      display: none;
      transition: all 0.2s;
      }
      .legend-mini-btn:hover,
      .legend-mini-btn:active {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
      }
      .legend-title {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: var(--toolbar-text, var(--text-soft));
      margin-bottom: 2px;
      }
      .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      }
      .legend-swatch {
      width: 14px;
      height: 14px;
      border-radius: 3px;
      border: 1px solid #020617;
      flex-shrink: 0;
      }
      .legend-label {
      outline: none;
      cursor: text;
      flex: 1;
      min-width: 60px;
      user-select: text;
      -webkit-user-select: text;
      }
      .legend-label.editing {
      border-bottom: 1px dashed var(--accent);
      }
      .canvas-viewport {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      overflow: hidden;
      }
      .canvas-viewport.panning {
      cursor: grabbing !important;
      }
      .canvas-viewport.panning * {
      cursor: grabbing !important;
      }
      .canvas-viewport svg {
      width: 100%;
      height: 100%;
      display: block;
      background: linear-gradient(rgba(71, 85, 105, 0.1) 1px,
      transparent 1px),
      linear-gradient(90deg,
      rgba(71, 85, 105, 0.1) 1px,
      transparent 1px),
      linear-gradient(rgba(71, 85, 105, 0.05) 1px, transparent 1px),
      linear-gradient(90deg,
      rgba(71, 85, 105, 0.05) 1px,
      transparent 1px);
      background-size:
      100px 100px,
      100px 100px,
      20px 20px,
      20px 20px;
      background-position:
      -1px -1px,
      -1px -1px,
      -1px -1px,
      -1px -1px;
      }
      .zoom-toolbar {
      display: flex;
      gap: 4px;
      padding: 6px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      }
      .zoom-toolbar button {
      width: 32px;
      height: 32px;
      padding: 0;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 18px;
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
      }
      .zoom-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .zoom-toolbar .zoom-level {
      font-size: 11px;
      color: var(--toolbar-text, var(--text-soft));
      text-align: center;
      padding: 2px 0;
      min-width: 32px;
      }
      .zoom-toolbar .divider {
      height: 1px;
      background: var(--toolbar-border, var(--edge-main));
      margin: 2px 0;
      }
      .minimap-zoom-wrapper {
      position: absolute;
      bottom: 10px;
      right: 10px;
      z-index: 99;
      }
      .minimap-container {
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      overflow: hidden;
      margin-bottom: 4px;
      }
      .minimap-container svg {
      width: 100%;
      height: 100%;
      }
      .minimap-viewport {
      fill: rgba(79, 209, 197, 0.2);
      stroke: var(--accent);
      stroke-width: 2;
      cursor: move;
      }
      .minimap-node {
      fill: var(--minimap-dots, var(--text-soft));
      }
      .minimap-edge {
      stroke: var(--edge-main);
      stroke-width: 1;
      }
	  .minimap-close-btn {
      position: absolute;
      top: 2px;
      right: 2px;
      width: 18px;
      height: 18px;
      background: var(--toolbar-btn-bg, rgba(15, 23, 42, 0.9));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 3px;
      color: var(--toolbar-text, var(--text-soft));
      font-size: 11px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
      padding: 0;
      line-height: 1;
      }
      .minimap-close-btn:hover {
      background: var(--danger);
      color: white;
      border-color: var(--danger);
      }
	  .toolbar-close-btn {
      width: 24px;
      height: 24px;
      background: var(--toolbar-btn-bg, rgba(15, 23, 42, 0.9));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-text, var(--text-soft));
      font-size: 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      line-height: 1;
      flex-shrink: 0;
      }
      .toolbar-close-btn:hover {
      background: var(--danger);
      color: white;
      border-color: var(--danger);
      }
	  .canvas-hint {
      position: absolute;
      top: 50px;
      left: 50%;
      transform: translateX(-50%);
      padding: 8px 16px;
      background: var(--canvas-hint-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      font-size: 12px;
      color: var(--canvas-hint-color, var(--text-soft));
      z-index: 18;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
      }
      .canvas-hint.visible {
      opacity: 1;
      }
      .edge {
      stroke: var(--edge-main);
      stroke-width: 4;
      opacity: 0.75;
      transition: 0.25s ease-in-out;
      cursor: pointer;
      }
      .edge.backup {
      stroke: var(--danger);
      stroke-width: 5;
      }
      .edge.active {
      opacity: 1;
      stroke-width: 7;
      filter: drop-shadow(0 0 8px var(--accent, #4fd1c5));
      }
      .rect-group.active .rect-shape {
      filter: drop-shadow(0 0 10px var(--accent, #4fd1c5));
      animation: pulse 1.2s infinite ease-in-out;
      }
      .text-element.active {
      filter: drop-shadow(0 0 10px var(--accent, #4fd1c5));
      animation: pulse 1.2s infinite ease-in-out;
      }
      .free-preview {
      fill: none;
      stroke-dasharray: 4 4;
      pointer-events: none;
      }
      .free-point {
      fill: #e5e7eb;
      stroke: #0f172a;
      stroke-width: 1.5;
      cursor: grab;
      }
      .node-circle {
      fill: var(--node-fill, #1e293b);
      stroke: var(--node-stroke, #475569);
      stroke-width: 2;
      transition: 0.25s ease;
      transform-origin: center center;
      }
      .node-hit-area {
      cursor: grab;
      pointer-events: all;
      }
      .node-group:hover .node-circle {
      filter: drop-shadow(0 0 10px rgba(79, 209, 197, 0.45));
      }
      .node-group.active .node-circle {
      stroke: var(--accent);
      animation: pulse 1.2s infinite ease-in-out;
      }
      @keyframes pulse {
      0% {
      filter: drop-shadow(0 0 4px #4fd1c5);
      }
      50% {
      filter: drop-shadow(0 0 14px #4fd1c5);
      }
      100% {
      filter: drop-shadow(0 0 4px #4fd1c5);
      }
      }
      .node-label {
      fill: var(--text-main);
      font-size: 18px;
      text-anchor: middle;
      font-weight: 600;
      }
      .node-sub {
      fill: var(--text-soft);
      font-size: 13px;
      text-anchor: middle;
      }
      .ping-indicator {
      fill: #6b7280;
      stroke: #4b5563;
      stroke-width: 1;
      }
      .ping-indicator.online {
      fill: #10b981;
      stroke: #059669;
      }
      .ping-indicator.offline {
      fill: #ef4444;
      stroke: #dc2626;
      }
      .ping-indicator.checking {
      fill: #f59e0b;
      stroke: #d97706;
      }
      @media (max-width: 1024px) {
      .node-label {
      font-size: 28px;
      }
      .node-sub {
      font-size: 20px;
      }
      }
      @media (max-width: 768px) {
      .node-label {
      font-size: 70px;
      }
      .node-sub {
      font-size: 50px;
      }
      }
      @media (max-width: 380px) {
      .node-label {
      font-size: 60px;
      }
      .node-sub {
      font-size: 42px;
      }
      }
      .details-panel {
      background: var(--sidebar-bg, var(--panel-alt));
      padding: 22px;
      padding-bottom: 80px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 15px;
      position: relative;
      transition:
      width 0.3s ease,
      min-width 0.3s ease,
      padding 0.3s ease,
      opacity 0.3s ease;
      }
      .details-panel {
      min-width: 260px !important;
      }
      .details-panel {
      overflow-y: auto !important;
      overflow-x: hidden;
      }
      .details-panel.collapsed {
      width: 0 !important;
      min-width: 0 !important;
      padding: 0 !important;
      overflow: hidden;
      opacity: 0;
      }
      body {
      overflow-x: hidden;
      overflow-y: hidden;
      }
      main {
      overflow-x: hidden;
      overflow-y: visible;
      }
      .details-panel {
      overflow-y: auto !important;
      overflow-x: hidden;
      }
      .details-panel.collapsed {
      min-width: 0 !important;
      }
      .sidebar-toggle {
      position: absolute;
      left: -16px;
      top: 50%;
      transform: translateY(-50%);
      width: 16px;
      height: 60px;
      background: var(--sidebar-bg, var(--panel-alt));
      border: 1px solid var(--edge-main);
      border-right: none;
      border-radius: 8px 0 0 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text-soft);
      font-size: 10px;
      z-index: 25;
      transition:
      background 0.2s,
      color 0.2s;
      }
      .sidebar-toggle:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .sidebar-toggle.collapsed {
      left: 0;
      border-right: 1px solid var(--edge-main);
      border-radius: 0 8px 8px 0;
      position: fixed;
      right: 0;
      left: auto;
      }
      .details-name {
      font-size: clamp(22px, 2.5vw, 30px);
      font-weight: 700;
      }
      .details-ip {
      font-size: clamp(16px, 2vw, 22px);
      color: var(--text-soft);
      }
      .details-role {
      font-size: clamp(16px, 2vw, 22px);
      color: var(--accent);
      }
      .size-controls {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-top: 10px;
      }
      .size-controls label {
      font-size: clamp(14px, 1.6vw, 18px);
      color: var(--text-soft);
      }
      .size-controls input[type="range"] {
      flex: 1;
      accent-color: var(--accent);
      }
      .size-controls button {
      padding: 6px 12px;
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      font-size: clamp(12px, 1.4vw, 16px);
      }
      .size-controls button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .style-section {
      margin-top: 15px;
      padding-top: 15px;
      border-top: 1px solid var(--edge-main);
      }
      .style-section summary {
      cursor: pointer;
      font-size: clamp(14px, 1.6vw, 20px);
      text-transform: uppercase;
      color: var(--text-soft);
      list-style: none;
      display: flex;
      justify-content: space-between;
      align-items: center;
      user-select: none;
      }
      .style-section summary::-webkit-details-marker {
      display: none;
      }
      .password-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #ffffff;
      z-index: 9999;
      }
      .style-section summary::after {
      content: "‚ñº";
      transition: transform 0.2s;
      }
      .style-section[open] summary::after {
      transform: rotate(180deg);
      }
      .style-content {
      margin-top: 10px;
      }
      .style-row {
      display: flex;
      gap: 10px;
      align-items: center;
      margin: 8px 0;
      }
      .style-row label {
      font-size: clamp(13px, 1.5vw, 17px);
      color: var(--text-soft);
      min-width: 80px;
      }
      .style-row input[type="color"] {
      width: 50px;
      height: 30px;
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      background: transparent;
      }
      .style-row input[type="number"] {
      width: 70px;
      padding: 4px 8px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(12px, 1.4vw, 16px);
      }
      .style-row select {
      flex: 1;
      padding: 4px 8px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(12px, 1.4vw, 16px);
      cursor: pointer;
      }
      .editable-text {
      cursor: pointer;
      transition: opacity 0.2s;
      }
      .editable-text:hover {
      opacity: 0.7;
      }
      .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 999999;
      justify-content: center;
      align-items: center;
      overflow: auto;
      }
      .modal.active {
      display: inline-grid;
      }
      .modal-content {
      background: var(--panel-alt);
      padding: 25px;
      border-radius: 8px;
      border: 1px solid var(--edge-main);
      min-width: 300px;
      max-width: 90%;
      }
      .modal-content h3 {
      margin: 0 0 15px 0;
      color: var(--text-main);
      font-size: clamp(18px, 2vw, 24px);
      }
      .modal-content p {
      color: var(--text-soft);
      font-size: clamp(14px, 1.6vw, 18px);
      margin: 0 0 20px 0;
      }
      .modal-content input:not([type="color"]),
      .modal-content select {
      width: 100%;
      padding: 10px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(14px, 1.6vw, 18px);
      margin-bottom: 15px;
      user-select: text;
      -webkit-user-select: text;
      }
      .modal-content input[type="color"] {
      width: 60px;
      height: 36px;
      padding: 2px;
      border: 2px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      background: none;
      -webkit-appearance: none;
      appearance: none;
      }
      .modal-content input[type="color"]::-webkit-color-swatch-wrapper {
      padding: 0;
      }
      .modal-content input[type="color"]::-webkit-color-swatch {
      border: none;
      border-radius: 4px;
      }
      .modal-buttons {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
      margin-top: 10px;
      }
      .modal-buttons button {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: clamp(14px, 1.6vw, 18px);
      font-weight: 600;
      }
      .modal-buttons .btn-cancel {
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      }
      .modal-buttons .btn-save {
      background: var(--accent);
      color: var(--bg);
      }
      .modal-buttons .btn-delete {
      background: var(--danger);
      color: white;
      }
      .confirm-modal p {
      color: var(--text-soft);
      font-size: clamp(14px, 1.6vw, 18px);
      margin: 0 0 20px 0;
      }
      .context-menu-item {
      transition: background 0.15s;
      }
      .context-menu-item:hover {
      background: var(--panel);
      }
      .details-info-row {
      display: flex;
      align-items: center;
      margin: 6px 0;
      }
	 .node-group.selected .node-circle {
      stroke: var(--selection-handle, #f59e0b);
      stroke-width: 3;
      }
	  .node-group.layer-faded {
      pointer-events: none;
      }
      .edge.layer-faded {
      pointer-events: none;
      }
      .node-group.search-highlight .node-circle,
      .node-group.search-highlight rect,
      .node-group.search-highlight polygon {
      stroke: #10b981;
      stroke-width: 3;
      filter: drop-shadow(0 0 8px #10b981);
      }
      .badge-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      }
     .badge {
      background: var(--tag-fill, #1e293b);
      color: var(--tag-text, #e2e8f0);
      border: 1px solid var(--tag-border, var(--edge-main));
      padding: 5px 12px;
      border-radius: 22px;
      font-size: clamp(12px, 1.4vw, 18px);
      }
	  .badge.wg {
      color: var(--accent);
      border-color: var(--accent);
      }
	  input[type="text"],
      input[type="number"],
      input[type="password"],
      textarea,
      select {
      background: var(--input-bg, #0b0e13) !important;
      color: var(--input-text, #e2e8f0) !important;
      border-color: var(--input-border, #1f2937) !important;
      font-family: var(--input-font, Inter, system-ui, sans-serif) !important;
      font-size: var(--input-font-size, 14px) !important;
      }
      .section-label {
      margin-top: 8px;
      font-size: clamp(14px, 1.6vw, 20px);
      text-transform: uppercase;
      color: var(--text-soft);
      }
      .list li {
      margin: 6px 0;
      font-size: clamp(14px, 1.6vw, 20px);
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      }
      .list li:hover {
      color: var(--accent);
      }
      .delete-note {
      color: var(--danger);
      font-size: 18px;
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.2s;
      flex-shrink: 0;
      }
      .list li:hover .delete-note {
      opacity: 1;
      }
      .editing {
      outline: 2px solid var(--accent);
      background: #0d141f;
      padding: 4px;
      border-radius: 6px;
      user-select: text;
      -webkit-user-select: text;
      }
      .mobile-menu-btn {
      display: none;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      color: var(--text-main);
      font-size: 22px;
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      }
      #topbar-menu {
      gap: 8px;
      }
      @media (min-width: 721px) {
      #topbar-menu {
      display: flex !important;
      }
      }
      @media (max-width: 720px) {
      #topbar-menu {
      display: none;
      }
      #topbar-menu.open {
      display: flex;
      }
      }
      @media (max-width: 720px) {
      .mobile-menu-btn {
      display: block;
      }
      #topbar-menu {
      position: absolute;
      top: var(--topbar-height);
      right: 0;
      background: var(--panel-alt);
      border-left: 1px solid var(--topbar-border);
      border-bottom: 1px solid var(--topbar-border);
      padding: 12px;
      display: none;
      flex-direction: column;
      width: 180px;
      z-index: 999;
      }
      #topbar-menu.open {
      display: flex;
      }
      header {
      position: relative;
      z-index: 9999;
      }
      }
      @media (max-width: 720px) {
      .draw-toolbar {
      position: absolute;
      top: auto;
      bottom: auto;
      left: 10px !important;
      right: auto !important;
      width: auto;
      gap: 6px;
      padding: 8px;
      }	  
      .topology-toolbar {
      position: absolute;
      top: auto;
      bottom: auto;
      width: auto;
      gap: 6px;
      padding: 8px;
      }
      .draw-toolbar {
      top: 10px !important;
      }
      .topology-toolbar {
      top: calc(10px + var(--draw-toolbar-height, 50px)) !important;
      }
      .canvas-hint {
      top: calc(10px + 120px);
      }
      }
      .icon-picker-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      z-index: 999999999;
      justify-content: center;
      align-items: center;
      }
      .icon-picker-modal.active {
      display: flex;
      }
      .icon-picker-content {
      background: var(--panel);
      border-radius: 12px;
      width: 90%;
      max-width: 800px;
      max-height: 80vh;
      display: flex;
      flex-direction: column;
      border: 1px solid var(--edge-main);
      }
      .icon-picker-header {
      padding: 20px;
      border-bottom: 1px solid var(--edge-main);
      }
      .icon-picker-header h3 {
      margin: 0 0 15px 0;
      color: var(--text-main);
      }
      .icon-picker-tabs {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
      flex-wrap: wrap;
      }
      .icon-picker-tab {
      padding: 8px 16px;
      background: var(--panel-alt);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      color: var(--text-soft);
      font-size: 14px;
      transition: all 0.2s;
      }
      .icon-picker-tab:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .icon-picker-tab.active {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
      }
      .icon-picker-search {
      width: 100%;
      padding: 10px 15px;
      background: var(--panel-alt);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      color: var(--text-main);
      font-size: 14px;
      }
      .icon-picker-search::placeholder {
      color: var(--text-soft);
      }
      .icon-picker-body {
      padding: 20px;
      overflow-y: auto;
      flex: 1;
      }
      .icon-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
      gap: 10px;
      }
      .icon-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 15px 10px;
      background: var(--panel-alt);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .icon-item:hover {
      background: var(--accent);
      border-color: var(--accent);
      transform: scale(1.05);
      }
      .icon-item svg {
      width: 32px;
      height: 32px;
      fill: var(--text-main);
      }
      .icon-item:hover svg {
      fill: var(--bg);
      }
      .icon-item-name {
      margin-top: 8px;
      font-size: 10px;
      color: var(--text-soft);
      text-align: center;
      word-break: break-word;
      }
      .icon-item:hover .icon-item-name {
      color: var(--bg);
      }
      .icon-picker-loading {
      text-align: center;
      padding: 40px;
      color: var(--text-soft);
      }
      .icon-picker-footer {
      padding: 15px 20px;
      border-top: 1px solid var(--edge-main);
      display: flex;
      justify-content: flex-end;
      }
      .icon-btn-cancel {
      padding: 8px 20px;
      background: var(--panel-alt);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      }
      .icon-btn-cancel:hover {
      background: var(--edge-main);
      }
      .icon-badge {
      display: inline-flex;
      align-items: center;
      gap: 5px;
      padding: 4px 8px;
      background: var(--panel-alt);
      border-radius: 4px;
      font-size: 12px;
      margin: 2px;
      }
      .icon-badge svg {
      width: 16px;
      height: 16px;
      fill: currentColor;
      }
      .pick-icon-btn {
      padding: 6px 12px;
      background: var(--accent);
      color: var(--bg);
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      margin-top: 8px;
      width: 100%;
      }
      .pick-icon-btn:hover {
      opacity: 0.9;
      }
      @media (max-width: 768px) {
      .icon-picker-content {
      width: 95%;
      max-height: 90vh;	
      }
      .modal-content {
      background: var(--panel-alt);
      }
      #search-input {
      width: 100%;
      }
      }
      .version-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .version-item:hover {
      background: var(--panel-alt);
      border-color: var(--accent);
      }
      .version-item.current {
      border-color: var(--accent);
      background: rgba(79, 209, 197, 0.1);
      }
      .version-info {
      flex: 1;
      }
      .version-info .timestamp {
      font-size: 13px;
      color: var(--text-main);
      font-weight: 600;
      }
      .version-info .details {
      font-size: 11px;
      color: var(--text-soft);
      margin-top: 4px;
      }
      .version-actions {
      display: flex;
      gap: 6px;
      }
      .audit-entry {
      padding: 8px 12px;
      background: var(--panel);
      border-left: 3px solid var(--edge-main);
      border-radius: 4px;
      font-size: 12px;
      }
      .audit-entry.node { border-left-color: #4fd1c5; }
      .audit-entry.connection { border-left-color: #9f7aea; }
      .audit-entry.style { border-left-color: #ed8936; }
      .audit-entry.rack { border-left-color: #48bb78; }
      .audit-entry.layer { border-left-color: #4299e1; }
      .audit-entry .time {
      color: var(--text-soft);
      font-size: 10px;
      }
      .audit-entry .action {
      color: var(--text-main);
      font-weight: 500;
      }
      .tab-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .tab-item:hover {
      background: var(--panel-alt);
      }
      .tab-item.active {
      border-color: var(--accent);
      background: rgba(79, 209, 197, 0.1);
      }
      .tab-item .tab-name {
      font-weight: 600;
      color: var(--text-main);
      flex: 1;
      }
      .tab-item .tab-stats {
      font-size: 11px;
      color: var(--text-soft);
      margin-right: 10px;
      }
      .tab-actions {
      display: flex;
      gap: 6px;
      }
      .secret-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      border-left: 3px solid var(--danger);
      }
      .secret-item .secret-name {
      font-weight: 600;
      color: var(--text-main);
      flex: 1;
      }
      .secret-item .secret-status {
      font-size: 11px;
      color: var(--text-soft);
      margin-right: 10px;
      }   
	  body.view-only-mode:not(.view-only-inspect) #node-panel,
      body.view-only-mode:not(.view-only-inspect) #edge-panel,
      body.view-only-mode:not(.view-only-inspect) #text-panel,
      body.view-only-mode:not(.view-only-inspect) #rect-panel {
        display: none !important;
      }
      body.view-only-mode .node-group,
      body.view-only-mode .edge,
      body.view-only-mode .rect-group,
      body.view-only-mode .text-element {
        cursor: default !important;
      }
      body.view-only-mode .resize-handle,
      body.view-only-mode .edge-control-point {
        display: none !important;
      }
      body.view-only-mode #bulk-toolbar,
      body.view-only-mode #bulk-toolbar-mobile,
      body.view-only-mode #bulk-actions-modal {
        display: none !important;
      }
      body.view-only-mode::after {
        content: "VIEW ONLY ‚Ä¢ click 5√ó to inspect";
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(245, 101, 101, 0.9);
        color: white;
        padding: 6px 16px;
        border-radius: 20px;
        font-size: 12px;
        font-weight: 600;
        letter-spacing: 1px;
        z-index: 9999;
        pointer-events: none;
      }
    </style>
  </head>
  <body style="background: radial-gradient(circle at center top, rgb(30, 37, 50) 0px, rgb(5, 6, 8) 70%);" class="">
    <div class="icon-picker-modal" id="icon-picker-modal">
      <div class="icon-picker-content">
        <div class="icon-picker-header">
          <h3>Select Icon</h3>
          <div class="icon-picker-tabs">
            <button class="icon-picker-tab" data-library="mdi">MDI</button>
            <button class="icon-picker-tab" data-library="simple">Simple Icons</button>
            <button class="icon-picker-tab active" data-library="selfhst">selfh.st/icons</button>
          </div>
          <input type="text" class="icon-picker-search" id="icon-search" placeholder="Search icons..." style="display: none;">
        </div>
        <div class="icon-picker-body" id="icon-picker-body">
        </div>
        <div class="icon-picker-footer">
          <button class="icon-btn-cancel" id="icon-picker-cancel">Cancel</button>
        </div>
      </div>
    </div>
    <div class="modal" id="tabs-modal">
      <div class="modal-content" style="max-width: 600px;">
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Manage multiple topologies</p>
        <div id="tabs-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 400px; overflow-y: auto; margin-bottom: 15px;">
            <div class="tab-item " onclick="switchTab(0)">
              <div class="tab-name">Corporate Site B</div>
              <div class="tab-stats">105 nodes ‚Ä¢ 65 connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(0)" title="Rename tab">‚úèÔ∏è</button>
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(${index})" title="Delete tab">üóëÔ∏è</button>
              </div>
            </div>
          
            <div class="tab-item active" onclick="switchTab(1)">
              <div class="tab-name">Homelab 2</div>
              <div class="tab-stats">11 nodes ‚Ä¢ 10 connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(1)" title="Rename tab">‚úèÔ∏è</button>
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(${index})" title="Delete tab">üóëÔ∏è</button>
              </div>
            </div>
          </div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="new-tab-name" placeholder="New tab name..." style="flex: 1; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <button class="btn-save" onclick="createNewTab()">+ Add Tab</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="tabs-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="rollback-modal">
      <div class="modal-content" style="max-width: 700px;">
        <h3>Version History</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Limit: Snapshots</p>
        <div id="rollback-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 450px; overflow-y: auto; margin-bottom: 15px;">
          <div style="text-align: center; padding: 40px; color: var(--text-soft);">No version history yet. Versions are saved automatically when you save the file.</div>
        </div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <button class="btn-cancel" onclick="clearRollbackHistory()">Clear History</button>
          <button class="btn-save" onclick="createManualSnapshot()">Create Snapshot</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="rollback-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="audit-log-modal">
      <div class="modal-content" style="max-width: 800px;">
        <h3>Audit Log</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Track all changes made to your topology</p>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <select id="audit-filter" style="padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
            <option value="all">All Events</option>
            <option value="node">Node Operations</option>
            <option value="connection">Connections</option>
            <option value="style">Style Changes</option>
            <option value="rack">Rack Operations</option>
            <option value="layer">Layer Changes</option>
          </select>
          <button class="btn-save" onclick="exportAuditLog()">Export</button>
        </div>
        <div id="audit-log-list" style="display: flex; flex-direction: column; gap: 4px; max-height: 450px; overflow-y: auto; margin-bottom: 15px; font-family: monospace; font-size: 12px;">
          <div style="text-align: center; padding: 40px; color: var(--text-soft);">No audit entries yet</div>
        </div>
        <div style="display: flex; gap: 8px;">
          <button class="btn-cancel" onclick="clearAuditLog()">Clear Log</button>
          <button class="btn-cancel" id="audit-log-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="secrets-modal">
      <div class="modal-content" style="max-width: 600px;">
        <h3>Notes</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Notes can also be stored with AES 256 encryption</p>
        <div id="secrets-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 350px; overflow-y: auto; margin-bottom: 15px;">
        </div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="new-secret-name" placeholder="Section name (e.g., 'Root Passwords')..." style="flex: 1; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <button class="btn-save" onclick="createNewSecret()">+ Add Note</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="secrets-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="secret-editor-modal">
      <div class="modal-content" style="max-width: 600px;">
        <h3 id="secret-editor-title">Edit Note</h3>
        <textarea id="secret-editor-content" placeholder="Enter sensitive information here..." style="width: 100%; height: 200px; padding: 12px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main); font-family: monospace; resize: vertical; margin-bottom: 15px;"></textarea>
        <div style="margin-bottom: 15px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
          <input type="checkbox" id="secret-auto-encrypt" checked="" style="cursor: pointer;">
          <span>Encrypt Note</span>
          </label>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" onclick="closeSecretEditor()">Cancel</button>
          <button class="btn-save" onclick="saveSecret()">Save</button>
        </div>
      </div>
    </div>
    <div class="modal" id="edit-modal">
      <div class="modal-content">
        <h3 id="modal-title">Edit Name</h3>
        <input type="text" id="modal-input">
        <div class="modal-buttons">
          <button class="btn-cancel" id="modal-cancel">Cancel</button>
          <button class="btn-save" id="modal-save">Save</button>
        </div>
      </div>
    </div>
    <div class="modal confirm-modal" id="confirm-modal">
      <div class="modal-content">
        <h3>Confirm</h3>
        <p id="confirm-message"> Are you sure you want to delete this line? </p>
        <div class="modal-buttons">
          <button class="btn-cancel" id="confirm-cancel">Cancel</button>
          <button class="btn-delete" id="confirm-delete">Delete</button>
        </div>
      </div>
    </div>
    <div class="modal" id="save-info-modal">
      <div class="modal-content" style="max-width: 700px; max-height: 80vh; overflow-y: auto;">
        <h3 style="margin-bottom: 16px;">Help</h3>
        <div style="display: flex; gap: 8px; margin-bottom: 16px; flex-wrap: wrap;">
          <button class="help-tab active" data-tab="general" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--accent); color: var(--bg); border-radius: 6px; cursor: pointer; font-weight: 600;">General</button>
          <button class="help-tab" data-tab="desktop" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--panel); color: var(--text-main); border-radius: 6px; cursor: pointer; font-weight: 600;">Desktop</button>
          <button class="help-tab" data-tab="mobile" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--panel); color: var(--text-main); border-radius: 6px; cursor: pointer; font-weight: 600;">Mobile</button>
        </div>
        <div id="help-tab-general" class="help-tab-content" style="display: block;">
          <ul style="margin-left: 20px; margin-bottom: 12px; line-height: 1.8;">
            <li><strong>Add Nodes:</strong> Click "+ Node" or "+ Rack" in the top menu</li>
            <li><strong>Connect Nodes:</strong> Select a node, then use "Add Connection" in the panel</li>
            <li><strong>Move Nodes:</strong> Drag nodes to reposition them</li>
            <li><strong>Enter Rack View:</strong> Double click on desktop or Long press on mobile</li>
            <li><strong>Multi Select:</strong> Right click (desktop) or double tap (mobile)</li>
            <li><strong>Pan Canvas:</strong> Drag empty space or hold Space + drag</li>
            <li><strong>Zoom:</strong> Scroll wheel or pinch gesture</li>
            <li><strong>Free Draw:</strong> Use draw toolbar for drawing lines, boxes/zones , and text</li>
          </ul>
          <h4 style="color: var(--accent); margin-bottom: 8px;">Saving &amp; Encryption</h4>
          <p style="margin-bottom: 8px;">Browsers cannot overwrite local files. Click <strong>Save File</strong> to download an updated HTML with all changes. Replace your old file to keep edits.</p>
          <p style="margin-bottom: 8px;"><strong>Encryption of data:</strong> Check "Encrypt" before saving to password protect your data. Beware! No recovery possible without password!!</p>
          <p><strong>Decryption of data:</strong> Export via JSON in top settings menu after successful password validation to decrypt your data. You can then reimport back into the same file and save!</p>
        </div>
        <div id="help-tab-desktop" class="help-tab-content" style="display: none;">
          <h4 style="color: var(--accent); margin-bottom: 12px;">Navigation</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Arrow Keys</code></td>
              <td style="padding: 8px;">Move selected 1px</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Shift + Arrows</code></td>
              <td style="padding: 8px;">Move selected 10px</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Tab / Shift+Tab</code></td>
              <td style="padding: 8px;">Cycle through nodes</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">F</code></td>
              <td style="padding: 8px;">Focus on selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Space + Drag</code></td>
              <td style="padding: 8px;">Pan canvas</td>
            </tr>
          </tbody></table>
          <h4 style="color: var(--accent); margin-bottom: 12px;">Management</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">L</code></td>
              <td style="padding: 8px;">Lock/unlock selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">G</code></td>
              <td style="padding: 8px;">Group/ungroup selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+C / Ctrl+V</code></td>
              <td style="padding: 8px;">Copy / Paste</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+D</code></td>
              <td style="padding: 8px;">Duplicate</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+A</code></td>
              <td style="padding: 8px;">Select all</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Delete</code></td>
              <td style="padding: 8px;">Delete selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Escape</code></td>
              <td style="padding: 8px;">Clear selection</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+Z / Ctrl+Y</code></td>
              <td style="padding: 8px;">Undo / Redo</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Right Click</code></td>
              <td style="padding: 8px;">Multi select toggle</td>
            </tr>
          </tbody></table>
        </div>
        <div id="help-tab-mobile" class="help-tab-content" style="display: none;">
          <h4 style="color: var(--accent); margin-bottom: 12px;">Basic Gestures</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Tap node</strong></td>
              <td style="padding: 8px;">Select &amp; open properties</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Tap empty</strong></td>
              <td style="padding: 8px;">Deselect all</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Drag node</strong></td>
              <td style="padding: 8px;">Move node</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Drag empty</strong></td>
              <td style="padding: 8px;">Pan canvas</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Pinch</strong></td>
              <td style="padding: 8px;">Zoom in/out</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Double-tap node</strong></td>
              <td style="padding: 8px;">Add/remove from selection</td>
            </tr>
          </tbody></table>
          <h4 style="color: var(--accent); margin-bottom: 12px;">Rack View</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Long-press rack</strong></td>
              <td style="padding: 8px;">Enter rack view</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Double-tap empty</strong></td>
              <td style="padding: 8px;">Exit rack view</td>
            </tr>
          </tbody></table>
        </div>
        <div class="modal-buttons" style="margin-top: 16px;">
          <button class="btn-cancel" id="save-info-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="settings-modal">
	
	
	<div class="modal-content">
        <h2>Settings</h2>
        <details class="style-section">
          <summary>View Only Mode</summary>
          <div class="style-content">
            <div class="style-row">
              <label>View Only (disable all editing)</label>
              <input type="checkbox" id="view-only-mode" style="width:auto;">
            </div>
            <p style="margin-top:4px;font-size:12px;color:var(--text-soft);">When enabled, all editing of the canvas is disabled. Pan and zoom still work.</p>
          </div>
        </details>
        <details class="style-section">
          <summary>General Theme</summary>
          <div class="style-content">
		    <div class="style-row">
              <label>Main Background</label>
              <input type="color" id="panel-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Modal Window (popup) Background</label>
              <input type="color" id="panel-alt-color" value="#10141b">
            </div>
            <div class="style-row">
              <label>Accent Buttons</label>
              <input type="color" id="accent-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Danger Buttons</label>
              <input type="color" id="danger-color" value="#f56565">
            </div>
            <div class="style-row">
              <label>Primary Text</label>
              <input type="color" id="text-main-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Secondary Text</label>
              <input type="color" id="text-soft-color" value="#94a3b8">
            </div>
          </div>
        </details>
		
        <details class="style-section">
          <summary>Top Bar</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="topbar-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="topbar-border-color" value="#1f2533">
            </div>
          </div>
		  <div class="style-content">
            <div class="style-row">
              <label>Button Fill</label>
              <input type="color" id="btn-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Button Text</label>
              <input type="color" id="btn-text-color" value="#e2e8f0">
            </div>
          </div>
        </details>
		
        <details class="style-section">
          <summary>Main Canvas</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="canvas-border-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Grid Lines</label>
              <input type="color" id="canvas-grid-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Grid Size</label>
              <input type="number" id="canvas-grid-size" value="50" min="20" max="200" style="width:60px;">
            </div>
		    <div class="style-row">
              <label>Background Top</label>
              <input type="color" id="canvas-gradient-top" value="#1e2532">
            </div>
            <div class="style-row">
              <label>Background Bottom</label>
              <input type="color" id="canvas-gradient-bottom" value="#050608">
            </div>
            <div class="style-row">
              <label>Solid Background</label>
              <input type="color" id="page-bg-color" value="#050608">
            </div>
            <p style="margin-top:4px;font-size:12px;color:var(--text-soft);">Set solid background to override gradient.</p>
          </div>
        </details>
        <details class="style-section">
          <summary>Rack Canvas</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Frame Fill</label>
              <input type="color" id="rack-frame-fill" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Frame Border</label>
              <input type="color" id="rack-frame-stroke" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Grid Lines</label>
              <input type="color" id="rack-line-color" value="#475569">
            </div>
            <div class="style-row">
              <label>U Labels</label>
              <input type="color" id="rack-text-color" value="#4fd1c5">
            </div>
          </div>
       </details>
	   <details class="style-section">
          <summary>Canvas Toolbars</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="toolbar-bg-color" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="toolbar-border-color" value="#1f2937">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="toolbar-text-color" value="#94a3b8">
            </div>
            <div class="style-row">
              <label>Button Fill</label>
              <input type="color" id="toolbar-btn-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Button Text</label>
              <input type="color" id="toolbar-btn-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Minimap Dots</label>
              <input type="color" id="minimap-dots-color" value="#94a3b8">
            </div>
          </div>
        </details>
		
        <details class="style-section">
          <summary>Nodes</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Fill</label>
              <input type="color" id="node-fill-color" value="#1e293b">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="node-stroke-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Title Color</label>
              <input type="color" id="node-title-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Title Size</label>
              <input type="number" id="node-title-size" value="18" min="8" max="48" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Subtitle Color</label>
              <input type="color" id="node-sub-color" value="#94a3b8">
            </div>
            <div class="style-row">
              <label>Subtitle Size</label>
              <input type="number" id="node-sub-size" value="13" min="8" max="48" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Font</label>
              <select id="node-font-family" style="flex:1;padding:4px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;">
                <option value="Inter, system-ui, sans-serif">Inter</option>
                <option value="Arial, sans-serif">Arial</option>
                <option value="Helvetica, sans-serif">Helvetica</option>
                <option value="Georgia, serif">Georgia</option>
                <option value="monospace">Monospace</option>
              </select>
            </div>
          </div>
        </details>
        
        <details class="style-section">
          <summary>Connections</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Default Color</label>
              <input type="color" id="default-edge-color" value="#475569">
            </div>
          </div>
        </details>
        
        <details class="style-section">
          <summary>Groups &amp; Editing</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Resize handle Color</label>
              <input type="color" id="selection-handle-color" value="#f59e0b">
            </div>
            <div class="style-row">
              <label>Resize Handle Size</label>
              <input type="number" id="selection-handle-size" value="8" min="4" max="16" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Grouped Icon Outline</label>
              <input type="color" id="group-indicator-color" value="#4fd1c5">
            </div>
          </div>
		  <div class="style-content">
            <div class="style-row">
              <label>Multiselect Fill Color (Desktop)</label>
              <input type="color" id="selection-fill-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Multiselect Fill Opacity (Desktop)</label>
              <input type="range" id="selection-fill-opacity" min="0" max="1" step="0.05" value="0.1">
              <span id="selection-fill-opacity-val" style="min-width:35px;text-align:right;">10%</span>
            </div>
            <div class="style-row">
              <label>Multiselect Border Color (Desktop)</label>
              <input type="color" id="selection-stroke-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Multiselect Border Width (Desktop)</label>
              <input type="number" id="selection-stroke-width" min="1" max="10" value="2">
            </div>
            <div class="style-row">
              <label>Multiselect Border Style (Desktop)</label>
              <select id="selection-stroke-style">
                <option value="5,5">Dashed</option>
                <option value="2,4">Dotted</option>
                <option value="none">Solid</option>
              </select>
            </div>
          </div>
        </details>
   
		<details class="style-section">
          <summary>Inputs &amp; Dropdowns</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="input-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="input-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="input-border-color" value="#1f2937">
            </div>
            <div class="style-row">
              <label>Font</label>
              <select id="input-font-family" style="flex:1;padding:4px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;">
                <option value="Inter, system-ui, sans-serif">Inter</option>
                <option value="Arial, sans-serif">Arial</option>
                <option value="Helvetica, sans-serif">Helvetica</option>
                <option value="Georgia, serif">Georgia</option>
                <option value="monospace">Monospace</option>
              </select>
            </div>
            <div class="style-row">
              <label>Font Size</label>
              <input type="number" id="input-font-size" value="14" min="10" max="24" style="width:60px;">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Welcome Message</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Enabled</label>
              <input type="checkbox" id="canvas-hint-enabled" checked="" style="width:auto;">
            </div>
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="canvas-hint-bg-color" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Text Color</label>
              <input type="color" id="canvas-hint-text-color" value="#94a3b8">
            </div>
            <div class="style-row" style="flex-direction:column;align-items:stretch;">
              <label>Custom Text (HTML)</label>
              <textarea id="canvas-hint-text" rows="4" style="width:100%;margin-top:4px;padding:6px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;font-size:12px;resize:vertical;" placeholder="Leave empty for default"></textarea>
            </div>
          </div>
        </details>
        
        <details class="style-section">
          <summary>Sidebar / Mobile Footer</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="sidebar-bg-color" value="#10141b">
            </div>
          </div>
        </details>
        
        <details class="style-section">
          <summary>Tags</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Fill</label>
              <input type="color" id="tag-fill-color" value="#1e293b">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="tag-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="tag-border-color" value="#475569">
            </div>
          </div>
        </details>     
        <details class="style-section" open="">
          <summary>Import / Export / Upgrade JSON</summary>
          <div class="style-content">
            <button id="export-data-btn" style="width:100%;margin-bottom:10px;padding:10px;background:var(--accent);color:var(--bg);border:none;border-radius:6px;cursor:pointer;font-size:14px;font-weight:600;">Export JSON</button>
            <button id="import-data-btn" style="width:100%;padding:10px;background:var(--panel);color:var(--text-main);border:1px solid var(--edge-main);border-radius:6px;cursor:pointer;font-size:14px;font-weight:600;">Import JSON</button>
            <input type="file" id="import-data-file" accept=".json" style="display:none">
          </div>
        </details>
         <details class="style-section">
          <summary>Auto Status Checking</summary>
          <div class="style-content">
            <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 16px; cursor: pointer;">
            <input type="checkbox" id="auto-ping-enabled" style="cursor: pointer;">
            <span style="font-size: 14px; font-weight: 600;">Enable automatic status checking</span>
            </label>
            <div id="auto-ping-settings" style="display: none; padding-left: 20px; border-left: 2px solid var(--edge-main);">
              <div class="style-row" style="margin-bottom: 12px;">
                <label>Check Interval (seconds):</label>
                <input type="number" id="auto-ping-interval" min="5" max="3600" value="30" style="width: 80px; padding: 6px; background: var(--panel); border: 1px solid var(--edge-main); border-radius: 4px; color: var(--text-main);">
              </div>
              <div style="padding: 10px; background: var(--panel); border-radius: 6px; border: 1px solid var(--edge-main); font-size: 12px; color: var(--text-soft);">
                <div style="margin-bottom: 4px;"><span id="auto-ping-next-check">Next check in: --</span></div>
                <div><span id="auto-ping-last-run">Last run: 1:15:07 PM</span></div>
              </div>
            </div>
            <p style="margin-top: 12px; font-size: 12px; color: var(--text-soft); font-style: italic;">
              Automatically checks all ping enabled nodes at the specified interval. I recommend 30 to 60 seconds for local networks.
            </p>
			</div>
        </details>
        <details class="style-section" open="">
          <summary>Danger Zone</summary>
          <div class="style-content">
            <p style="margin-bottom:12px;font-size:13px;color:var(--text-soft);">Permanently delete everything on the canvas.</p>
            <button id="clear-all-btn" title="Clear all nodes" style="padding:6px 12px;background:var(--danger);color:#fff;border:none;border-radius:6px;cursor:pointer;font-size:14px;font-weight:600;">Clear All</button>
            <input type="file" id="import-data-file" accept=".json" style="display:none">
          </div>
        </details>
        
        <div class="modal-buttons">
          <button class="btn-cancel" id="settings-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="add-node-modal">
      <div class="modal-content">
        <h3>Add New Node</h3>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Basic Information</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Name</label>
          <input type="text" id="new-node-name" placeholder="e.g. web server, jellyfin">
          <label style="display: block;margin-bottom: 4px;margin-top: 12px;color: var(--text-soft);font-size: 13px;">IP / Subtitle</label>
          <input type="text" id="new-node-ip" placeholder="e.g. 192.168.1.100">
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Tags</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Text Tags (comma separated)</label>
          <input type="text" id="new-node-tags" placeholder="e.g. Docker, nginx, WG: vpn">
          <button class="pick-icon-btn" id="pick-new-node-tag-icon-btn" style="margin-top: 10px;">Add Icon Tag</button>
          <div id="new-node-icon-tags" style="margin-top: 10px; display: none;">
            <label style="display: block; margin-bottom: 8px; color: var(--text-soft); font-size: 13px;">Icon Tags:</label>
            <div id="new-node-icon-tags-list" style="display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 10px;"></div>
          </div>
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Node Appearance</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Basic Shapes</label>
          <select id="new-node-shape">
            <optgroup label="Basic Shapes">
            <option value="circle">Circle</option>
            <option value="square">Square</option>
            <option value="rectangle">Rectangle</option>
            <option value="triangle">Triangle</option>
            <option value="hexagon">Hexagon</option>
            <option value="diamond">Diamond</option>
            <option value="star">Star</option>
            <option value="stop-sign">Stop Sign</option>
            <option value="octagon">Octagon</option>
            <option value="pentagon">Pentagon</option>
            <option value="cross">Cross</option>
            <option value="rounded-square">Rounded Square</option>
            <option value="pill">Pill</option>
            <option value="parallelogram">Parallelogram</option>
            <option value="trapezoid">Trapezoid</option>
          </optgroup>
          <optgroup label="Computers &amp; Devices">
            <option value="server">Server</option>
            <option value="pc">PC / Desktop</option>
            <option value="laptop">Laptop</option>
            <option value="phone">Phone / Mobile</option>
            <option value="printer">Printer</option>
            <option value="pi">Raspberry Pi</option>
            <option value="sensor">Sensor / IoT</option>
          </optgroup>
          <optgroup label="Network Equipment">
            <option value="router">Router</option>
            <option value="switch">Switch</option>
            <option value="firewall">Firewall</option>
            <option value="access-point">Access Point</option>
            <option value="load-balancer">Load Balancer</option>
            <option value="gateway">Gateway</option>
            <option value="vpn">VPN / Tunnel</option>
            <option value="nas">NAS / Storage</option>
          </optgroup>
          <optgroup label="Cloud &amp; Services">
            <option value="cloud">Cloud</option>
            <option value="database">Database</option>
			<option value="docker">Docker</option>
            <option value="container">Container</option>
            <option value="vm">Virtual Machine</option>
            <option value="kubernetes">Kubernetes</option>
            <option value="api">API / Endpoint</option>
            <option value="queue">Queue / Message</option>
            <option value="lambda">Lambda / Function</option>
            <option value="bucket">Bucket / S3</option>
          </optgroup>
          <optgroup label="Security &amp; Monitoring">
            <option value="shield">Shield</option>
            <option value="camera">Camera / CCTV</option>
            <option value="monitor">Monitor / Dashboard</option>
          </optgroup>
          </select>
          <button class="pick-icon-btn" id="pick-node-icon-btn" style="margin-top: 10px;"> Or search web icons</button>
          <div id="selected-node-icon" style="margin-top: 10px; display: none;">
            <label style="display: block; margin-bottom: 8px; color: var(--text-soft); font-size: 13px;">Selected Icon:</label>
            <div class="icon-badge" id="selected-node-icon-preview">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24">
                <image href="https://cdn.jsdelivr.net/gh/selfhst/icons@master/png/docker.png" width="24" height="24"></image>
              </svg>
              <span>docker</span>
            </div>
          </div>
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Ping / Status Monitoring</div>
          <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px; cursor: pointer;">
          <input type="checkbox" id="new-node-pingable" style="cursor: pointer;">
          <span style="color: var(--text-soft); font-size: 13px;">Enable ping/status check for this node</span>
          </label>
          <div id="new-node-ping-options" style="display: block; padding-left: 24px; border-left: 2px solid var(--edge-main);">
            <label style="display: block; margin-bottom: 4px; color: var(--text-soft); font-size: 13px;">Protocol</label>
            <select id="new-node-ping-protocol" style="margin-bottom: 12px;">
              <option value="http">HTTP (port 80) uses IP field</option>
              <option value="https">HTTPS (port 443) uses IP field</option>
              <option value="custom">Custom URL</option>
            </select>
            <div id="new-node-custom-url-container" style="display: block;">
              <label style="display: block; margin-bottom: 4px; color: var(--text-soft); font-size: 13px;">Custom URL</label>
              <input type="text" id="new-node-custom-url" placeholder="e.g. http://192.168.1.1:8080">
            </div>
            <label style="display: block; margin-bottom: 4px; margin-top: 8px; color: var(--text-soft); font-size: 13px;">
            Timeout (ms)
            </label>
            <input type="number" id="new-node-ping-timeout" value="3000" min="1000" max="10000" step="500">
          </div>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="add-node-cancel">Cancel</button>
          <button class="btn-save" id="add-node-save">Add Node</button>
        </div>
      </div>
    </div>
    <div class="modal" id="add-rack-modal">
      <div class="modal-content">
        <h3>Add New Rack</h3>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Basic Information</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Rack Name</label>
          <input type="text" id="new-rack-name" placeholder="e.g. Rack-A, DC1-R01, Production-01">
          <label style="display: block;margin-bottom: 4px;margin-top: 12px;color: var(--text-soft);font-size: 13px;">IP / Network Range (optional)</label>
          <input type="text" id="new-rack-ip" placeholder="e.g. 192.168.1.0/24">
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Tags</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Text Tags (comma separated)</label>
          <input type="text" id="new-rack-tags" placeholder="e.g. Production, Data Center 1, Row A">
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Rack Appearance</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Icon / Shape</label>
          <select id="new-rack-shape">
            <optgroup label="Basic Shapes">
            <option value="circle">Circle</option>
            <option value="square">Square</option>
            <option value="rectangle">Rectangle</option>
            <option value="triangle">Triangle</option>
            <option value="hexagon">Hexagon</option>
            <option value="diamond">Diamond</option>
            <option value="star">Star</option>
            <option value="stop-sign">Stop Sign</option>
            <option value="octagon">Octagon</option>
            <option value="pentagon">Pentagon</option>
            <option value="cross">Cross</option>
            <option value="rounded-square">Rounded Square</option>
            <option value="pill">Pill</option>
            <option value="parallelogram">Parallelogram</option>
            <option value="trapezoid">Trapezoid</option>
          </optgroup>
          <optgroup label="Computers &amp; Devices">
            <option value="server">Server</option>
            <option value="pc">PC / Desktop</option>
            <option value="laptop">Laptop</option>
            <option value="phone">Phone / Mobile</option>
            <option value="printer">Printer</option>
            <option value="pi">Raspberry Pi</option>
            <option value="sensor">Sensor / IoT</option>
          </optgroup>
          <optgroup label="Network Equipment">
            <option value="router">Router</option>
            <option value="switch">Switch</option>
            <option value="firewall">Firewall</option>
            <option value="access-point">Access Point</option>
            <option value="load-balancer">Load Balancer</option>
            <option value="gateway">Gateway</option>
            <option value="vpn">VPN / Tunnel</option>
            <option value="nas">NAS / Storage</option>
          </optgroup>
          <optgroup label="Cloud &amp; Services">
            <option value="cloud">Cloud</option>
            <option value="database">Database</option>
			<option value="docker">Docker</option>
            <option value="container">Container</option>
            <option value="vm">Virtual Machine</option>
            <option value="kubernetes">Kubernetes</option>
            <option value="api">API / Endpoint</option>
            <option value="queue">Queue / Message</option>
            <option value="lambda">Lambda / Function</option>
            <option value="bucket">Bucket / S3</option>
          </optgroup>
          <optgroup label="Security &amp; Monitoring">
            <option value="shield">Shield</option>
            <option value="camera">Camera / CCTV</option>
            <option value="monitor">Monitor / Dashboard</option>
          </optgroup>
          </select>
          <button class="pick-icon-btn" id="pick-rack-icon-btn" style="margin-top: 10px;">Or Search Web Icons</button>
          <div id="selected-rack-icon" style="margin-top: 10px; display: none;">
            <label style="display: block; margin-bottom: 8px; color: var(--text-soft); font-size: 13px;">Selected Icon:</label>
            <div class="icon-badge" id="selected-rack-icon-preview">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24">
                <image href="" width="24" height="24"></image>
              </svg>
              <span></span>
            </div>
          </div>
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Rack Configuration</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Rack Capacity</label>
          <select id="new-rack-capacity">
            <option value="42" selected="">42U (Standard Full Rack)</option>
            <option value="48">48U (Large Rack)</option>
            <option value="24">24U (Half Rack)</option>
            <option value="12">12U (Small/Wall Mount)</option>
            <option value="6">6U (Mini Rack)</option>
          </select>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="add-rack-cancel">Cancel</button>
          <button class="btn-save" id="add-rack-save">Add Rack</button>
        </div>
      </div>
    </div>
    <div class="modal confirm-modal" id="clear-all-modal">
      <div class="modal-content">
        <h3>Clear All Nodes</h3>
        <p> This will remove ALL nodes and connections. This cannot be undone until you reload without saving. Are you sure? </p>
        <div class="modal-buttons">
          <button class="btn-cancel" id="clear-all-cancel">Cancel</button>
          <button class="btn-delete" id="clear-all-confirm">Clear Everything</button>
        </div>
      </div>
    </div>
    <div class="modal" id="layer-modal">
      <div class="modal-content" style="max-width: 400px;">
        <h3>Layer Visibility</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Toggle which layers are visible on the canvas</p>
        <div style="display: flex; flex-direction: column; gap: 10px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-physical" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Physical Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-logical" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Logical Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-security" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Security Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-application" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Application Layer</span>
          </label>
        </div>
        <div style="margin-top: 15px; display: flex; gap: 8px;">
          <button class="btn-cancel" style="flex: 1;" onclick="document.querySelectorAll('#layer-modal input[type=checkbox]').forEach(cb =&gt; cb.checked = false); applyLayerFilter();">Hide All</button>
          <button class="btn-save" style="flex: 1;" onclick="document.querySelectorAll('#layer-modal input[type=checkbox]').forEach(cb =&gt; cb.checked = true); applyLayerFilter();">Show All</button>
        </div>
        <div class="modal-buttons" style="margin-top: 10px;">
          <button class="btn-cancel" id="layer-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div id="context-menu" style="display: none !important;">
    </div>
    <header>
      <div class="title-block">
        <h1 id="page-title" class="editable-page-title">The One File</h1>
        <div class="save-row">
          <button id="save-file-btn" class="save-btn" type="button">Save File</button>
          <label style="display: flex;align-items: center;gap: 4px;font-size: 12px;color: var(--text-soft);cursor: pointer;user-select: none;">
          <input type="checkbox" id="encrypt-toggle" style="cursor: pointer">
          <span title="Encrypt data with password">Encrypt</span>
          </label>
          <span id="save-help-btn" class="help-icon" title="Why save?">?</span>
        </div>
      </div>
      <div id="topbar-menu">
        <button id="back-to-topology-btn" title="Exit rack view and return to topology" style="padding: 6px 12px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;display: none;">‚Üê Back to Topology</button>
        <button id="add-node-btn" class="save-btn" title="Add new node" style="background: var(--accent)">+ Node</button>
        <button id="add-rack-btn" class="save-btn" title="Add new rack" style="background: var(--accent); margin-left: 8px;">+ Rack</button>
        <button id="undo-btn" title="Undo (Ctrl+Z)" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;" disabled="">‚Ü∂</button>
        <button id="redo-btn" title="Redo (Ctrl+Y)" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;" disabled="">‚Ü∑</button>
<input type="text" id="search-nodes" placeholder="Search nodes..." title="Search by name, IP, MAC, role, or tag" style="padding: 6px 12px;background: var(--input-bg);color: var(--input-text);border: 1px solid var(--input-border);border-radius: 6px;font-family: var(--input-font);font-size: var(--input-font-size);width: 180px;">
        <button id="check-all-ping-btn" title="Check status of all enabled nodes" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600">Check Pings</button>
        <button id="layers-btn" title="Toggle layer visibility" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Layers</button>
        <button id="tabs-btn" title="Manage document tabs" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Tabs</button>
        <button id="rollback-btn" title="View version history" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Snapshots</button>
        <button id="audit-log-btn" title="View audit log" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Audit</button>
        <button id="secrets-btn" title="Manage encrypted notes" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Notes</button>
        <button onclick="screenshotCanvas()" title="Export canvas as PNG image" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">PNG</button>
        <button onclick="exportCanvasSVG()" title="Export canvas as SVG vector" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">SVG</button>
        <button id="settings-btn" title="Page settings">‚öôÔ∏è</button>
      </div>
      <button id="mobile-menu-toggle" class="mobile-menu-btn">‚ò∞</button>
      <div class="header-resizer" id="header-resizer">
        <svg class="resizer-icon" width="40" height="6" viewBox="0 0 40 6" xmlns="http://www.w3.org/2000/svg">
          <circle cx="14" cy="3" r="2"></circle>
          <circle cx="20" cy="3" r="2"></circle>
          <circle cx="26" cy="3" r="2"></circle>
        </svg>
      </div>
    </header>
    <main>
      <section class="topology-panel">
        <div class="draw-toolbar" id="draw-toolbar" style="display: flex !important;">
          <button type="button" class="toolbar-close-btn" id="draw-toolbar-close-btn" title="Hide draw toolbar">‚úï</button>
          <button id="draw-toggle" title="Draw custom line">‚úèÔ∏è</button>
          <button id="rect-toggle" title="Draw zone">‚ñ≠</button>
          <button id="text-toggle" title="Add text">T</button>
          <select id="rect-style" title="zone style">
            <option value="filled">Filled</option>
            <option value="outlined">Outlined</option>
          </select>
          <input type="color" id="draw-color" value="#f97316" title="Line color">
          <select id="draw-style" title="Line style">
            <option value="solid">Solid</option>
            <option value="dashed">Dashed</option>
            <option value="dotted">Dotted</option>
          </select>
          <select id="draw-arrow" title="Arrow direction">
            <option value="none">No arrows</option>
            <option value="forward">‚Üí Right</option>
            <option value="backward">‚Üê Left</option>
            <option value="both">‚Üî Both</option>
          </select>
          <button id="draw-undo" style="display: none" title="Undo last point">Undo</button>
        </div>
        <div class="topology-toolbar" id="topology-toolbar" style="display: flex !important;">
          <button type="button" class="toolbar-close-btn" id="topology-toolbar-close-btn" title="Hide add line toolbar">‚úï</button>
          <label for="add-line-select">Add line to:</label>
          <select id="add-line-select"><option value="core-router-2">Core Router 2</option><option value="fw-external-1">External FW 1</option><option value="fw-external-2">External FW 2</option><option value="fw-internal">Internal FW</option><option value="core-switch-1">Core Switch 1</option><option value="core-switch-2">Core Switch 2</option><option value="dc-rack-a1">DC Rack A1</option><option value="dc-rack-a2">DC Rack A2</option><option value="dc-rack-b1">DC Rack B1</option><option value="dc-rack-b2">DC Rack B2</option><option value="dmz-rack">DMZ Rack</option><option value="mgmt-rack">Management Rack</option><option value="wlc-primary">WLC Primary</option><option value="wlc-secondary">WLC Secondary</option><option value="mobile-zone-hq">HQ Mobile Zone</option><option value="mobile-zone-guest">Guest WiFi Zone</option><option value="mobile-zone-iot">IoT Device Zone</option><option value="branch-router-ny">NYC Branch Router</option><option value="branch-router-la">LA Branch Router</option><option value="branch-router-chi">Chicago Branch Router</option><option value="branch-router-lon">London Branch Router</option><option value="branch-router-tokyo">Tokyo Branch Router</option><option value="cloud-aws">AWS Cloud</option><option value="cloud-azure">Azure Cloud</option><option value="cloud-gcp">GCP Cloud</option><option value="isp-primary">ISP Primary</option><option value="isp-secondary">ISP Secondary</option><option value="proxy-server-1">Proxy Server 1</option><option value="proxy-server-2">Proxy Server 2</option><option value="vpn-concentrator">VPN Concentrator</option><option value="nac-server">NAC Server</option><option value="voip-cluster">VoIP Cluster</option><option value="video-conf">Video Conference</option><option value="security-cameras">Security Cameras</option><option value="dev-server-1">Dev Server 1</option><option value="dev-server-2">Dev Server 2</option><option value="test-environment">Test Environment</option><option value="erp-system">ERP System</option><option value="crm-system">CRM System</option><option value="endpoint-1000">Corporate Endpoints</option><option value="dist-switch-floor1">Floor 1 Switch</option><option value="dist-switch-floor2">Floor 2 Switch</option><option value="dist-switch-floor3">Floor 3 Switch</option><option value="dist-switch-floor4">Floor 4 Switch</option><option value="ap-floor1-zone1">AP Floor 1 Zone 1</option><option value="ap-floor2-zone1">AP Floor 2 Zone 1</option><option value="ap-floor3-zone1">AP Floor 3 Zone 1</option><option value="ap-floor4-zone1">AP Floor 4 Zone 1</option><option value="ups-dc-1">UPS DC-1</option><option value="ups-dc-2">UPS DC-2</option><option value="cooling-1">CRAC Unit 1</option><option value="cooling-2">CRAC Unit 2</option></select>
<input type="color" id="add-line-color" value="#475569" title="Line color" style="width: 30px;height: 24px;border: 1px solid var(--toolbar-border);border-radius: 4px;cursor: pointer;background: transparent;padding: 0;">          <select id="add-line-direction" title="Line direction">
            <option value="none">No arrows</option>
            <option value="forward">‚Üí Forward</option>
            <option value="backward">‚Üê Backward</option>
            <option value="both">‚Üî Both</option>
          </select>
          <button id="add-line-btn">Add</button>
        </div>
        <div class="topology-toolbar bulk-toolbar-desktop" id="bulk-toolbar" style="display: none">
          <button type="button" class="toolbar-close-btn" id="bulk-toolbar-close" title="Clear selection">‚úï</button>
          <label style="font-weight: 600; color: var(--accent)">Selected: <span id="bulk-count">0</span></label>
          <button id="bulk-align-left" title="Align left">‚¨Ö Left</button>
          <button id="bulk-align-right" title="Align right">‚û° Right</button>
          <button id="bulk-align-top" title="Align top">‚¨Ü Top</button>
          <button id="bulk-align-bottom" title="Align bottom">‚¨á Bottom</button>
          <button id="bulk-distribute-h" title="Distribute horizontally">‚Üî Distribute H</button>
          <button id="bulk-distribute-v" title="Distribute vertically">‚Üï Distribute V</button>
          <button id="bulk-clone" title="Clone selected">üìã Clone</button>
          <button id="bulk-delete" title="Delete selected" style="background: var(--danger); color: white;">Delete</button>
        </div>
        <div class="bulk-toolbar-mobile" id="bulk-toolbar-mobile" style="display: none">
          <button type="button" id="bulk-mobile-btn" style="background: var(--accent);color: white;padding: 12px 20px;border-radius: 25px;font-weight: 600;font-size: 16px;box-shadow: 0 4px 12px rgba(0,0,0,0.3);border: none;cursor: pointer;display: flex;align-items: center;gap: 8px;">
          <span id="bulk-count-mobile">0</span>Selected</button>
        </div>
        <div id="bulk-actions-modal" style="display: none;position: fixed;bottom: 0;left: 0;right: 0;background: var(--panel-alt);border-top-left-radius:20px;border-top-right-radius:20px;padding:20px;padding-bottom:(safe-area-inset-bottom, 20px);box-shadow: 0 -4px 20px rgba(0,0,0,0.5);z-index: 10000;max-height: calc(100vh - 80px);overflow-y: auto;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            <h3 style="margin: 0; color: var(--accent); font-size: 20px;">
              <span id="bulk-count-modal">0</span> Nodes Selected
            </h3>
            <button id="bulk-modal-close" style="background: none;border: none;font-size: 24px;cursor: pointer;color: var(--text-main);padding: 0;width: 32px;height: 32px;">‚úï</button>
          </div>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
            <button id="bulk-align-left-mobile" class="bulk-action-btn">‚¨Ö<br><span style="font-size: 12px;">Align Left</span></button>
            <button id="bulk-align-right-mobile" class="bulk-action-btn">‚û°<br><span style="font-size: 12px;">Align Right</span></button>
            <button id="bulk-align-top-mobile" class="bulk-action-btn">‚¨Ü<br><span style="font-size: 12px;">Align Top</span></button>
            <button id="bulk-align-bottom-mobile" class="bulk-action-btn">‚¨á<br><span style="font-size: 12px;">Align Bottom</span></button>
            <button id="bulk-distribute-h-mobile" class="bulk-action-btn">‚Üî<br><span style="font-size: 12px;">Distribute H</span></button>
            <button id="bulk-distribute-v-mobile" class="bulk-action-btn">‚Üï<br><span style="font-size: 12px;">Distribute V</span></button>
            <button id="bulk-lock-mobile" class="bulk-action-btn">üîí<br><span style="font-size: 12px;">Lock Toggle</span></button>
            <button id="bulk-group-mobile" class="bulk-action-btn">‚≠ï<br><span style="font-size: 12px;">Group Toggle</span></button>
            <button id="bulk-clone-mobile" class="bulk-action-btn">üìã<br><span style="font-size: 12px;">Clone All</span></button>
            <button id="bulk-delete-mobile" class="bulk-action-btn" style="background: var(--danger); color: white;">üóë<br><span style="font-size: 12px;">Delete All</span></button>
          </div>
          <button id="bulk-clear-mobile" style="width: 100%;margin-top: 16px;padding: 14px;background: var(--panel-main);border: 1px solid var(--edge-main);border-radius: 8px;color: var(--text-main);font-size: 16px;cursor: pointer;">Clear Selection</button>
        </div>
        <div class="canvas-hint" id="canvas-hint"></div>
        <div class="legend-container" id="edge-legend" style="display: flex;"><div class="legend-title">Line Legend</div><button type="button" class="legend-close-btn">‚úï</button><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(85, 226, 8); cursor: pointer;"></span><span class="legend-label" contenteditable="true">ISP LINE</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(76, 0, 255); cursor: pointer;"></span><span class="legend-label" contenteditable="true">MY Guest NETWORK</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(128, 255, 0); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(251, 0, 255); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(255, 0, 208); cursor: pointer;"></span><span class="legend-label" contenteditable="true">iPhone (always guest iPhone)</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(249, 115, 22); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div></div>
        <div class="canvas-viewport" id="canvas-viewport">
          <svg id="map" viewBox="1254.5197896196048 -147.55422459755366 2648.185035176588 1986.138776382441" style=""><defs><marker id="arrow-forward" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto" markerUnits="strokeWidth"><path d="M0,0 L0,6 L9,3 z" fill="context-stroke"></path></marker><marker id="arrow-backward" markerWidth="10" markerHeight="10" refX="0" refY="3" orient="auto" markerUnits="strokeWidth"><path d="M9,0 L9,6 L0,3 z" fill="context-stroke"></path></marker></defs><rect x="100" y="100" width="3800" height="2800" fill="none" stroke="#4755694D" stroke-width="20" stroke-dasharray="10 5" rx="8"></rect><g id="canvas-grid"><line x1="100" y1="100" x2="100" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="150" y1="100" x2="150" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="200" y1="100" x2="200" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="250" y1="100" x2="250" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="300" y1="100" x2="300" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="350" y1="100" x2="350" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="400" y1="100" x2="400" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="450" y1="100" x2="450" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="500" y1="100" x2="500" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="550" y1="100" x2="550" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="600" y1="100" x2="600" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="650" y1="100" x2="650" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="700" y1="100" x2="700" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="750" y1="100" x2="750" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="800" y1="100" x2="800" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="850" y1="100" x2="850" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="900" y1="100" x2="900" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="950" y1="100" x2="950" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1000" y1="100" x2="1000" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1050" y1="100" x2="1050" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1100" y1="100" x2="1100" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="1150" y1="100" x2="1150" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1200" y1="100" x2="1200" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1250" y1="100" x2="1250" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1300" y1="100" x2="1300" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1350" y1="100" x2="1350" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="1400" y1="100" x2="1400" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1450" y1="100" x2="1450" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1500" y1="100" x2="1500" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1550" y1="100" x2="1550" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1600" y1="100" x2="1600" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="1650" y1="100" x2="1650" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1700" y1="100" x2="1700" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1750" y1="100" x2="1750" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1800" y1="100" x2="1800" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1850" y1="100" x2="1850" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="1900" y1="100" x2="1900" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1950" y1="100" x2="1950" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2000" y1="100" x2="2000" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2050" y1="100" x2="2050" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2100" y1="100" x2="2100" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="2150" y1="100" x2="2150" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2200" y1="100" x2="2200" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2250" y1="100" x2="2250" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2300" y1="100" x2="2300" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2350" y1="100" x2="2350" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="2400" y1="100" x2="2400" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2450" y1="100" x2="2450" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2500" y1="100" x2="2500" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2550" y1="100" x2="2550" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2600" y1="100" x2="2600" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="2650" y1="100" x2="2650" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2700" y1="100" x2="2700" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2750" y1="100" x2="2750" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2800" y1="100" x2="2800" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2850" y1="100" x2="2850" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="2900" y1="100" x2="2900" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2950" y1="100" x2="2950" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3000" y1="100" x2="3000" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3050" y1="100" x2="3050" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3100" y1="100" x2="3100" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="3150" y1="100" x2="3150" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3200" y1="100" x2="3200" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3250" y1="100" x2="3250" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3300" y1="100" x2="3300" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3350" y1="100" x2="3350" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="3400" y1="100" x2="3400" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3450" y1="100" x2="3450" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3500" y1="100" x2="3500" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3550" y1="100" x2="3550" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3600" y1="100" x2="3600" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="3650" y1="100" x2="3650" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3700" y1="100" x2="3700" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3750" y1="100" x2="3750" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3800" y1="100" x2="3800" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3850" y1="100" x2="3850" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="3900" y1="100" x2="3900" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="100" x2="3900" y2="100" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="150" x2="3900" y2="150" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="200" x2="3900" y2="200" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="250" x2="3900" y2="250" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="300" x2="3900" y2="300" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="350" x2="3900" y2="350" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="400" x2="3900" y2="400" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="450" x2="3900" y2="450" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="500" x2="3900" y2="500" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="550" x2="3900" y2="550" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="600" x2="3900" y2="600" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="650" x2="3900" y2="650" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="700" x2="3900" y2="700" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="750" x2="3900" y2="750" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="800" x2="3900" y2="800" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="850" x2="3900" y2="850" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="900" x2="3900" y2="900" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="950" x2="3900" y2="950" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1000" x2="3900" y2="1000" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1050" x2="3900" y2="1050" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1100" x2="3900" y2="1100" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="1150" x2="3900" y2="1150" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1200" x2="3900" y2="1200" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1250" x2="3900" y2="1250" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1300" x2="3900" y2="1300" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1350" x2="3900" y2="1350" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="1400" x2="3900" y2="1400" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1450" x2="3900" y2="1450" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1500" x2="3900" y2="1500" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1550" x2="3900" y2="1550" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1600" x2="3900" y2="1600" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="1650" x2="3900" y2="1650" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1700" x2="3900" y2="1700" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1750" x2="3900" y2="1750" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1800" x2="3900" y2="1800" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1850" x2="3900" y2="1850" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="1900" x2="3900" y2="1900" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1950" x2="3900" y2="1950" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2000" x2="3900" y2="2000" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2050" x2="3900" y2="2050" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2100" x2="3900" y2="2100" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="2150" x2="3900" y2="2150" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2200" x2="3900" y2="2200" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2250" x2="3900" y2="2250" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2300" x2="3900" y2="2300" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2350" x2="3900" y2="2350" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="2400" x2="3900" y2="2400" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2450" x2="3900" y2="2450" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2500" x2="3900" y2="2500" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2550" x2="3900" y2="2550" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2600" x2="3900" y2="2600" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="2650" x2="3900" y2="2650" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2700" x2="3900" y2="2700" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2750" x2="3900" y2="2750" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2800" x2="3900" y2="2800" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2850" x2="3900" y2="2850" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="2900" x2="3900" y2="2900" stroke="#47556933" stroke-width="1"></line></g><g class="rect-group" data-rect-id="rect-1765238219615"><rect class="rect-shape" x="2680.053955078125" y="251.44879150390625" width="814.10400390625" height="389.26678466796875" style="fill: rgb(236, 9, 153); fill-opacity: 0.3; stroke: rgb(236, 9, 153); stroke-width: 2px; stroke-dasharray: none; cursor: move;"></rect><g class="rect-delete-btn" style="cursor: pointer; display: none;"><circle cx="3484.157958984375" cy="261.44879150390625" r="12" style="fill: rgb(245, 101, 101); stroke: white; stroke-width: 2;"></circle><text x="3484.157958984375" y="261.44879150390625" text-anchor="middle" dominant-baseline="middle" style="fill: white; font-size: 16px; font-weight: bold; pointer-events: none;">√ó</text></g></g><path d="M 2103.968290880771 268 Q 2085.4680212352528 370.70595670887826 2066.9677515897347 473.4119134177565" fill="none" class="edge" data-edge-id="internet-internet-copy-1765238145151" data-from="internet" data-to="internet-copy" style="stroke: rgb(85, 226, 8); stroke-width: 4;"></path><path d="M 2103.968290880771 268 Q 2085.4680212352528 370.70595670887826 2066.9677515897347 473.4119134177565" fill="none" data-edge-id="internet-internet-copy-1765238145151" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 1920.4039088162972 569.9938683738112 1773.8400660428597 666.5758233298659" fill="none" class="edge" data-edge-id="internet-copy-opnsense-copy-1765238187451" data-from="internet-copy" data-to="opnsense-copy" style="stroke: rgb(76, 0, 255); stroke-width: 4;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 1920.4039088162972 569.9938683738112 1773.8400660428597 666.5758233298659" fill="none" data-edge-id="internet-copy-opnsense-copy-1765238187451" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 1999.08282329894 627.8447547749242 1931.1978950081452 782.2775961320921" fill="none" class="edge" data-edge-id="internet-copy-docker-copy-1765238242477" data-from="internet-copy" data-to="docker-copy" style="stroke: rgb(76, 0, 255); stroke-width: 4;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 1999.08282329894 627.8447547749242 1931.1978950081452 782.2775961320921" fill="none" data-edge-id="internet-copy-docker-copy-1765238242477" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2112.546995662221 620.5620704487524 2158.1262397347077 767.7122274797483" fill="none" class="edge" data-edge-id="internet-copy-docker-copy-1-1765238244637" data-from="internet-copy" data-to="docker-copy-1" style="stroke: rgb(76, 0, 255); stroke-width: 4;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2112.546995662221 620.5620704487524 2158.1262397347077 767.7122274797483" fill="none" data-edge-id="internet-copy-docker-copy-1-1765238244637" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2204.617064021596 552.590055067893 2342.2663764534577 631.7681967180296" fill="none" class="edge" data-edge-id="internet-copy-docker-copy-2-1765238246233" data-from="internet-copy" data-to="docker-copy-2" style="stroke: rgb(76, 0, 255); stroke-width: 4;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2204.617064021596 552.590055067893 2342.2663764534577 631.7681967180296" fill="none" data-edge-id="internet-copy-docker-copy-2-1765238246233" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2103.968290880771 268 Q 2430.923885484287 287.80585580459456 2757.879480087803 307.6117116091891" fill="none" class="edge" data-edge-id="internet-opnsense-copy-1-1765238266117" data-from="internet" data-to="opnsense-copy-1" style="stroke: rgb(128, 255, 0); stroke-width: 4;"></path><path d="M 2103.968290880771 268 Q 2430.923885484287 287.80585580459456 2757.879480087803 307.6117116091891" fill="none" data-edge-id="internet-opnsense-copy-1-1765238266117" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2757.879480087803 307.6117116091891 Q 2979.171899521397 314.04065142852505 3200.4643189549906 320.469591247861" fill="none" class="edge" data-edge-id="opnsense-copy-1-dns-1765238347996" data-from="opnsense-copy-1" data-to="dns" style="stroke: rgb(251, 0, 255); stroke-width: 4;"></path><path d="M 2757.879480087803 307.6117116091891 Q 2979.171899521397 314.04065142852505 3200.4643189549906 320.469591247861" fill="none" data-edge-id="opnsense-copy-1-dns-1765238347996" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 3200.4643189549906 320.469591247861 Q 3086.0821778417094 400.59916888457974 2971.700036728428 480.7287465212985" fill="none" class="edge" data-edge-id="dns-desktop-1765238386101" data-from="dns" data-to="desktop" style="stroke: rgb(255, 0, 208); stroke-width: 4;"></path><path d="M 3200.4643189549906 320.469591247861 Q 3086.0821778417094 400.59916888457974 2971.700036728428 480.7287465212985" fill="none" data-edge-id="dns-desktop-1765238386101" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 3312.857751572178 502.58220111114224 Q 3256.6610352635844 411.5258961795016 3200.4643189549906 320.469591247861" fill="none" class="edge" data-edge-id="phone-dns-1765238391156" data-from="phone" data-to="dns" style="stroke: rgb(255, 0, 208); stroke-width: 4;"></path><path d="M 3312.857751572178 502.58220111114224 Q 3256.6610352635844 411.5258961795016 3200.4643189549906 320.469591247861" fill="none" data-edge-id="phone-dns-1765238391156" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><polyline class="edge" data-edge-id="custom-1765239449323" fill="none" marker-end="url(#arrow-forward)" points="2936.464111328125,786.07958984375 3184.112060546875,887.6153564453125 2763.110107421875,981.7216796875" style="stroke: rgb(249, 115, 22); stroke-width: 4; stroke-dasharray: none;"></polyline><polyline points="2936.464111328125,786.07958984375 3184.112060546875,887.6153564453125 2763.110107421875,981.7216796875" data-edge-id="custom-1765239449323" style="fill: none; stroke: transparent; stroke-width: 20; cursor: pointer;"></polyline><g class="node-group" data-node-id="internet" transform="translate(2103.968290880771,268)" style="cursor: grab;"><circle r="252" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" viewBox="0 0 512 512" width="201.6" height="201.6" x="-100.8" y="-100.8" style="fill: rgb(255, 255, 255); stroke: rgb(255, 255, 255);"><path d="M144.3 214.1c0 6.3.7 11.4 1.9 15.2 1.4 3.7 3.1 7.8 5.4 12.3.9 1.4 1.2 2.7 1.2 3.9 0 1.7-1 3.4-3.2 5.1l-10.7 7.2c-1.5 1-3.1 1.5-4.4 1.5-1.7 0-3.4-.9-5.1-2.4-2.4-2.6-4.4-5.3-6.1-8-1.7-2.9-3.4-6.1-5.3-10-13.3 15.7-30 23.5-50.1 23.5-14.3 0-25.7-4.1-34.1-12.3-8.3-8.2-12.6-19.1-12.6-32.7 0-14.5 5.1-26.2 15.5-35.1S60.8 169 78.4 169c5.8 0 11.7.5 18.1 1.4s12.8 2.2 19.6 3.7v-12.4c0-12.9-2.7-22-8-27.2-5.4-5.3-14.6-7.8-27.8-7.8-6 0-12.1.7-18.4 2.2s-12.4 3.4-18.4 5.8c-2.7 1.2-4.8 1.9-6 2.2s-2 .5-2.7.5c-2.4 0-3.6-1.7-3.6-5.3v-8.3c0-2.7.3-4.8 1.2-6s2.4-2.4 4.8-3.6c6-3.1 13.1-5.6 21.5-7.7 8.3-2.2 17.2-3.2 26.6-3.2 20.3 0 35.1 4.6 44.6 13.8 9.4 9.2 14.1 23.2 14.1 41.9v55.2zM75.2 240c5.6 0 11.4-1 17.5-3.1 6.1-2 11.6-5.8 16.2-10.9 2.7-3.2 4.8-6.8 5.8-10.9s1.7-9 1.7-14.8v-7.2c-4.9-1.2-10.2-2.2-15.7-2.9-5.4-.7-10.7-1-16-1-11.4 0-19.8 2.2-25.4 6.8S51 207.1 51 215.6c0 8 2 14 6.3 18.1 4.1 4.2 10 6.3 17.9 6.3m136.7 18.4c-3.1 0-5.1-.5-6.5-1.7-1.4-1-2.6-3.4-3.6-6.6l-40-131.6c-1-3.4-1.5-5.6-1.5-6.8 0-2.7 1.4-4.3 4.1-4.3h16.7c3.2 0 5.4.5 6.6 1.7 1.4 1 2.4 3.4 3.4 6.6l28.6 112.7 26.6-112.7c.9-3.4 1.9-5.6 3.2-6.6 1.4-1 3.7-1.7 6.8-1.7H270c3.2 0 5.4.5 6.8 1.7 1.4 1 2.6 3.4 3.2 6.6l26.9 114.1 29.5-114.1c1-3.4 2.2-5.6 3.4-6.6 1.4-1 3.6-1.7 6.6-1.7h15.8c2.7 0 4.3 1.4 4.3 4.3 0 .9-.2 1.7-.3 2.7-.2 1-.5 2.4-1.2 4.3l-41 131.6q-1.5 5.1-3.6 6.6c-1.4 1-3.6 1.7-6.5 1.7h-14.6c-3.2 0-5.4-.5-6.8-1.7s-2.6-3.4-3.2-6.8l-26.4-109.8L236.7 250c-.9 3.4-1.9 5.6-3.2 6.8-1.4 1.2-3.7 1.7-6.8 1.7zm218.8 4.6c-8.9 0-17.7-1-26.2-3.1-8.5-2-15.2-4.3-19.6-6.8-2.7-1.5-4.6-3.2-5.3-4.8s-1-3.2-1-4.8v-8.7c0-3.6 1.4-5.3 3.9-5.3 1 0 2 .2 3.1.5 1 .3 2.6 1 4.3 1.7 5.8 2.6 12.1 4.6 18.7 6 6.8 1.4 13.5 2 20.3 2 10.7 0 19.1-1.9 24.9-5.6s8.9-9.2 8.9-16.2c0-4.8-1.5-8.7-4.6-11.9s-8.9-6.1-17.2-8.9l-24.7-7.7c-12.4-3.9-21.6-9.7-27.2-17.4-5.6-7.5-8.5-15.8-8.5-24.7 0-7.2 1.5-13.5 4.6-18.9s7.2-10.2 12.3-14c5.1-3.9 10.9-6.8 17.7-8.9 6.8-2 14-2.9 21.5-2.9 3.7 0 7.7.2 11.4.7 3.9.5 7.5 1.2 11.1 1.9 3.4.9 6.6 1.7 9.7 2.7s5.4 2 7.2 3.1c2.4 1.4 4.1 2.7 5.1 4.3 1 1.4 1.5 3.2 1.5 5.6v8c0 3.6-1.4 5.4-3.9 5.4-1.4 0-3.6-.7-6.5-2q-14.55-6.6-32.7-6.6c-9.7 0-17.4 1.5-22.6 4.8s-8 8.2-8 15.2c0 4.8 1.7 8.9 5.1 12.1s9.7 6.5 18.7 9.4l24.2 7.7c12.3 3.9 21.1 9.4 26.4 16.3s7.8 15 7.8 23.8c0 7.3-1.5 14-4.4 19.8-3.1 5.8-7.2 10.9-12.4 15-5.3 4.3-11.6 7.3-18.9 9.5-8 2.5-16 3.7-24.7 3.7" style="fill: rgb(255, 255, 255); stroke: rgb(255, 255, 255);"></path><path d="M462.9 345.7c-56 41.4-137.4 63.3-207.4 63.3-98.1 0-186.5-36.3-253.2-96.6-5.3-4.8-.5-11.2 5.8-7.5 72.2 41.9 161.3 67.3 253.4 67.3 62.2 0 130.4-12.9 193.3-39.5 9.3-4.2 17.3 6.2 8.1 13m23.3-26.5c-7.2-9.2-47.3-4.4-65.6-2.2-5.4.7-6.3-4.1-1.4-7.7 32-22.5 84.6-16 90.8-8.5 6.1 7.7-1.7 60.3-31.7 85.5-4.6 3.9-9 1.9-7-3.2 6.9-16.9 22.1-54.9 14.9-63.9" style="fill-rule: evenodd; clip-rule: evenodd; fill: rgb(255, 255, 255); stroke: rgb(255, 255, 255);"></path></svg></g><text class="node-label" x="0" y="-47.040000000000006" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Internet</text><text class="node-sub" x="0" y="67.2" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="internet-copy" transform="translate(2066.9677515897347,473.4119134177565)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" viewBox="0 0 512 512" width="66" height="66" x="-33" y="-33"><path d="M512 160.2V400H400V112H112V0h240.4zM112 112H0v240.4L160.2 512H400V400H112z" style="fill:#de3c07"></path></svg></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">OPNSENSE</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="opnsense-copy" transform="translate(1773.8400660428597,666.5758233298659)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" viewBox="0 0 512 512" width="66" height="66" x="-33" y="-33"><path d="M462.2 512H49.8C22.3 512 0 489.7 0 462.2V49.8C0 22.3 22.3 0 49.8 0h412.4C489.7 0 512 22.3 512 49.8v412.4c0 27.5-22.3 49.8-49.8 49.8" style="fill:#2e2f33"></path><path d="M108.2 63.9h140.9c97.2 0 154.6 30.4 154.6 129.5v3.4c0 99.4-57.2 129.5-154.5 129.5h-30.7V447H108.2zm134.5 177.8c30.1 0 46-11.2 46-44.6v-3.9c0-33.2-15.8-44.6-46-44.6h-24.2v93.1zM313 358h90.3v90.1H313z" style="fill:#f7f6f3"></path></svg></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Docker</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="docker-copy" transform="translate(1931.1978950081452,782.2775961320921)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" viewBox="0 0 512 512" width="66" height="66" x="-33" y="-33"><path d="M438.6 0H73.4C33.1 0 .3 32.8.3 73.1v365.7c0 40.3 32.8 73.1 73.1 73.1h365.3c40.3 0 73.1-32.8 73.1-73.1V73.1C511.7 32.8 478.9 0 438.6 0" style="fill-rule:evenodd;clip-rule:evenodd;fill:#8b3bd0"></path><path d="M356.8 53.6v261.3c0 39.3-13.9 72.8-41.8 100.7s-61.4 41.8-100.7 41.8l-23.8-95h23.8c13 0 24.1-4.6 33.2-13.8 9.5-9.5 14.3-20.7 14.3-33.7V148.6H157.3v-95z" style="fill:#fff"></path></svg></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Docker2</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="docker-copy-1" transform="translate(2158.1262397347077,767.7122274797483)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" viewBox="0 0 512 512" width="66" height="66" x="-33" y="-33"><path d="M0 0h512v512H0z" style="fill:#111827"></path><path d="M170.7 85.3 369.8 256 170.7 426.7z" style="fill:#f59e0b"></path></svg></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Docker3</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="docker-copy-2" transform="translate(2342.2663764534577,631.7681967180296)" style="cursor: grab;"><circle r="123" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" viewBox="0 0 512 512" width="98.39999999999999" height="98.39999999999999" x="-49.199999999999996" y="-49.199999999999996"><path d="M501.4 212.3c-11.5-8-38-11-58.6-7-2.4-20-13.5-37.5-32.7-53l-11-8-7.7 11.5c-9.6 15-14.4 36-13 56 .5 7 2.9 19.5 10.1 30.5-6.7 4-20.7 9-38.9 9H2.3l-1 4c-3.4 20-3.4 82.5 36 130.5 29.8 36.5 74 55 132.1 55 125.9 0 219.1-60.5 262.8-170 17.3.5 54.3 0 73-37.5.5-1 1.4-3 4.8-10.5l1.9-4zM280 71.3h-52.8v50H280zm0 60h-52.8v50H280zm-62.5 0h-52.8v50h52.8zm-62.4 0h-52.8v50h52.8zm-62.5 60H39.8v50h52.8zm62.5 0h-52.8v50h52.8zm62.4 0h-52.8v50h52.8zm62.5 0h-52.8v50H280zm62.4 0h-52.8v50h52.8z" style="fill:#2396ed"></path></svg></g><text class="node-label" x="0" y="-22.96" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Docker 4</text><text class="node-sub" x="0" y="32.800000000000004" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="opnsense-copy-1" transform="translate(2757.879480087803,307.6117116091891)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" viewBox="0 0 512 512" width="66" height="66" x="-33" y="-33"><path d="M503.1 465.4v2.1c-6 25.5-28.4 44.5-55 44.5H7.3v-46.6h38.3v7.3h403c1.1 0 2 0 2.9-.1 1.8-.1 3.6-.6 5.2-1.3 2.9-1.3 5.3-3.3 7-5.9zM63.9 0c-26.5 0-49 19-55 44.5V47H48c2.7-4.3 7.3-7.2 12.6-7.6 1-.1 2-.1 3.2-.1h402.6V47h38.3V0z" style="fill:#898b8d"></path><path d="M466.1 157.7V197H319.5v-39.3zM45.9 315.4v39.3h146.6v-39.3zm0-157.7V197h146.6v-39.3zm273.6 157.7v39.3h146.6v-39.3z" style="fill:#58595b"></path><path d="M83.8 78.6H428v39.3H83.8zm0 315.9H428v39.3H83.8z" style="fill:#403f41"></path><linearGradient id="opnsense-v1_svg__a" x1="-1460.617" x2="-1375.11" y1="1248.095" y2="1248.095" gradientTransform="matrix(.1853 .356 .6722 -.353 -90.66 993.802)" gradientUnits="userSpaceOnUse"><stop offset="0" style="stop-color:#737373"></stop><stop offset="1" style="stop-color:#333"></stop></linearGradient><path d="m466.5 78.6 38.2-20.5.1-39.5-38.3 20.7" style="fill:url(#opnsense-v1_svg__a)"></path><linearGradient id="opnsense-v1_svg__b" x1="4.634" x2="50.301" y1="462.6" y2="462.6" gradientTransform="matrix(1 0 0 -1 0 514)" gradientUnits="userSpaceOnUse"><stop offset="0" style="stop-color:#737373"></stop><stop offset="1" style="stop-color:#333"></stop></linearGradient><path d="M45.6 64.5v-8.9c0-5.3 2.6-10 6.5-13l-34-18.5c-6.7 9.5-10.8 21.3-10.9 34l38.3 20.6v-14c.1-.1.1-.2.1-.2" style="fill:url(#opnsense-v1_svg__b)"></path><linearGradient id="opnsense-v1_svg__c" x1="-1587.887" x2="-1498.137" y1="-2208.165" y2="-2208.165" gradientTransform="matrix(-.1853 -.356 -.6722 .353 -1743.836 694.098)" gradientUnits="userSpaceOnUse"><stop offset="0" style="stop-color:#737373"></stop><stop offset="1" style="stop-color:#333"></stop></linearGradient><path d="M45.6 472.7v-38.9L7.3 454.5v39.7l39.9-21.5z" style="fill:url(#opnsense-v1_svg__c)"></path><linearGradient id="opnsense-v1_svg__d" x1="460.439" x2="504.436" y1="53" y2="53" gradientTransform="matrix(1 0 0 -1 0 514)" gradientUnits="userSpaceOnUse"><stop offset="0" style="stop-color:#737373"></stop><stop offset="1" style="stop-color:#333"></stop></linearGradient><path d="M466.5 456.4c0 5.5-2.7 10.3-6.9 13.2l34.2 18.4c6.8-9.5 10.8-21.2 10.9-33.8L466.5 434v12.8" style="fill:url(#opnsense-v1_svg__d)"></path><linearGradient id="opnsense-v1_svg__e" x1="2521.902" x2="2684.464" y1="-2476.233" y2="-2476.233" gradientTransform="matrix(-1.508 -1.0166 -3.1265 -1.519 -3697.438 -937.952)" gradientUnits="userSpaceOnUse"><stop offset=".107" style="stop-color:#58595b"></stop><stop offset="1" style="stop-color:#000"></stop></linearGradient><path d="M192.5 197v-.4l-72.4-38.9H45.9v.2l72.5 39.1z" style="fill:url(#opnsense-v1_svg__e)"></path><linearGradient id="opnsense-v1_svg__f" x1="-1594.953" x2="-1432.391" y1="278.458" y2="278.458" gradientTransform="matrix(1.508 -1.0166 3.1265 -1.519 1804.196 -937.952)" gradientUnits="userSpaceOnUse"><stop offset=".107" style="stop-color:#58595b"></stop><stop offset="1" style="stop-color:#000"></stop></linearGradient><path d="M466.1 157.7h-74l-72.6 39.1v.2h74.2l72.4-38.9z" style="fill:url(#opnsense-v1_svg__f)"></path><linearGradient id="opnsense-v1_svg__g" x1="-4327.142" x2="-4164.581" y1="1572.387" y2="1572.387" gradientTransform="matrix(1.508 1.0166 3.1265 1.519 1863.938 2252.352)" gradientUnits="userSpaceOnUse"><stop offset=".107" style="stop-color:#58595b"></stop><stop offset="1" style="stop-color:#000"></stop></linearGradient><path d="M466.1 354.7v-.4l-72.4-38.9h-74.2v.2l72.6 39.1z" style="fill:url(#opnsense-v1_svg__g)"></path><linearGradient id="opnsense-v1_svg__h" x1="-413.668" x2="-246.99" y1="-1046.618" y2="-1046.618" gradientTransform="matrix(-1.508 1.0166 -3.1265 1.519 -3638.692 2252.352)" gradientUnits="userSpaceOnUse"><stop offset=".107" style="stop-color:#58595b"></stop><stop offset="1" style="stop-color:#000"></stop></linearGradient><path d="M192.5 315.4h-74.1l-72.5 39.1v.2h74.2l72.4-38.9z" style="fill:url(#opnsense-v1_svg__h)"></path><linearGradient id="opnsense-v1_svg__i" x1="74.725" x2="261.062" y1="132.65" y2="132.65" gradientTransform="matrix(.9914 0 0 -1 -66.782 260.2)" gradientUnits="userSpaceOnUse"><stop offset=".237" style="stop-color:#a6a8ab"></stop><stop offset="1" style="stop-color:#404040"></stop></linearGradient><path d="M192.8 157.7V197L7.3 97.4V58.1z" style="fill:url(#opnsense-v1_svg__i)"></path><linearGradient id="opnsense-v1_svg__j" x1="-2461.056" x2="-2274.718" y1="132.65" y2="132.65" gradientTransform="matrix(-.9914 0 0 -1 -1935.19 260.2)" gradientUnits="userSpaceOnUse"><stop offset=".237" style="stop-color:#a6a8ab"></stop><stop offset="1" style="stop-color:#404040"></stop></linearGradient><path d="M319.2 157.7V197l185.5-99.6V58.1z" style="fill:url(#opnsense-v1_svg__j)"></path><linearGradient id="opnsense-v1_svg__k" x1="-2291.845" x2="-2105.508" y1="-739.55" y2="-739.55" gradientTransform="matrix(-.9914 0 0 1 -1767.435 1124.6)" gradientUnits="userSpaceOnUse"><stop offset=".237" style="stop-color:#a6a8ab"></stop><stop offset="1" style="stop-color:#404040"></stop></linearGradient><path d="M319.2 355.2v-39.8L504.7 415v39.7z" style="fill:url(#opnsense-v1_svg__k)"></path><linearGradient id="opnsense-v1_svg__l" x1="-94.103" x2="91.934" y1="-739.55" y2="-739.55" gradientTransform="matrix(.9914 0 0 1 100.993 1124.6)" gradientUnits="userSpaceOnUse"><stop offset=".237" style="stop-color:#a6a8ab"></stop><stop offset="1" style="stop-color:#404040"></stop></linearGradient><path d="M192.8 355.2v-39.8L7.3 415v39.7z" style="fill:url(#opnsense-v1_svg__l)"></path><path d="m319.2 276.1 108.9 58.5v-39.7l-35.3-18.8h111.9v-39.8H392.8l35.3-18.8v-39.3l-108.9 58.1zM83.8 334.6l109-58.5v-39.8l-109-58.1v39.3l35.7 18.8H7.3v39.8h111.9l-35.3 18.8v39.7z" style="fill:#e24525"></path></svg></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">OPNSENSE GUEST</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="phone" transform="translate(3312.857751572178,502.58220111114224)" style="cursor: grab;"><circle r="181.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-54.45" y="-121" width="108.9" height="242" rx="8"></rect><rect x="-45.980000000000004" y="-102.85" width="91.96000000000001" height="193.60000000000002" rx="4" style="fill: rgb(30, 41, 59);"></rect><rect x="-18.15" y="99.22" width="36.3" height="7.26" rx="2" style="fill: rgb(71, 85, 105);"></rect></g><text class="node-label" x="0" y="-33.88" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Phone</text><text class="node-sub" x="0" y="48.400000000000006" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="desktop" transform="translate(2971.700036728428,480.7287465212985)" style="cursor: grab;"><circle r="220.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-132.3" y="-117.60000000000001" width="264.6" height="176.4" rx="4"></rect><rect x="-110.25" y="-95.55" width="220.5" height="132.3" rx="2" style="fill: rgb(30, 41, 59);"></rect><rect x="-22.05" y="58.800000000000004" width="44.1" height="44.1"></rect><rect x="-73.5" y="102.89999999999999" width="147" height="22.05" rx="2"></rect></g><text class="node-label" x="0" y="-41.160000000000004" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Desktop</text><text class="node-sub" x="0" y="58.800000000000004" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="dns" transform="translate(3200.4643189549906,320.469591247861)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><path d="
             M -44 11
             Q -60.50000000000001 11 -60.50000000000001 -5.5
             Q -60.50000000000001 -27.5 -38.5 -27.5
             Q -38.5 -49.5 -11 -49.5
             Q 5.5 -60.50000000000001 27.5 -44
             Q 55 -44 60.50000000000001 -16.5
             Q 71.5 -5.5 60.50000000000001 11
             Q 60.50000000000001 27.5 38.5 27.5
             L -27.5 27.5
             Q -49.5 27.5 -49.5 11
             Z
            " class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"></path><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">DNS</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="racked" transform="translate(2645.5845448279656,970.7820678889219)" style="cursor: grab;"><circle r="205.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" id="mdi-server-security" viewBox="0 0 24 24" width="164.4" height="164.4" x="-82.2" y="-82.2" style="fill: rgb(1, 8, 19); stroke: rgb(255, 255, 255);"><path d="M3,1H19A1,1 0 0,1 20,2V6A1,1 0 0,1 19,7H3A1,1 0 0,1 2,6V2A1,1 0 0,1 3,1M3,9H19A1,1 0 0,1 20,10V10.67L17.5,9.56L11,12.44V15H3A1,1 0 0,1 2,14V10A1,1 0 0,1 3,9M3,17H11C11.06,19.25 12,21.4 13.46,23H3A1,1 0 0,1 2,22V18A1,1 0 0,1 3,17M8,5H9V3H8V5M8,13H9V11H8V13M8,21H9V19H8V21M4,3V5H6V3H4M4,11V13H6V11H4M4,19V21H6V19H4M17.5,12L22,14V17C22,19.78 20.08,22.37 17.5,23C14.92,22.37 13,19.78 13,17V14L17.5,12M17.5,13.94L15,15.06V17.72C15,19.26 16.07,20.7 17.5,21.06V13.94Z" style="fill: rgb(1, 8, 19); stroke: rgb(255, 255, 255);"></path></svg></g><text class="node-label" x="0" y="-38.36000000000001" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Racked</text><text class="node-sub" x="0" y="54.800000000000004" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;"></text></g><g class="text-group" data-text-id="text-1765238422602"><text class="text-element" x="2466.35986328125" y="741.6801147460938" dominant-baseline="middle" style="fill: rgb(226, 232, 240); font-size: 40px; font-weight: normal; font-style: normal; text-anchor: start; text-decoration: none; opacity: 1; cursor: move; user-select: none;"><tspan x="2466.35986328125" dy="0">Double click on desktop</tspan><tspan x="2466.35986328125" dy="48">or long press on mobile</tspan><tspan x="2466.35986328125" dy="48">to enter rack canvas view</tspan></text><g class="text-delete-btn" style="cursor: pointer; display: none;"><circle cx="2486.35986328125" cy="701.6801147460938" r="12" style="fill: rgb(245, 101, 101); stroke: white; stroke-width: 2;"></circle><text x="2486.35986328125" y="701.6801147460938" text-anchor="middle" dominant-baseline="middle" style="fill: white; font-size: 16px; font-weight: bold; pointer-events: none;">√ó</text></g></g></svg>
        </div>
        <div class="minimap-zoom-wrapper" id="minimap-zoom-wrapper" style="display: block;">
          <button type="button" class="minimap-close-btn" id="minimap-close-btn" title="Hide map &amp; zoom">‚úï</button>
          <div class="minimap-container" id="minimap-container">
            <svg id="minimap" viewBox="0 0 4000 3000">
              <line x1="2103.968290880771" y1="268" x2="2066.9677515897347" y2="473.4119134177565" class="minimap-edge"></line><line x1="2066.9677515897347" y1="473.4119134177565" x2="1773.8400660428597" y2="666.5758233298659" class="minimap-edge"></line><line x1="2066.9677515897347" y1="473.4119134177565" x2="1931.1978950081452" y2="782.2775961320921" class="minimap-edge"></line><line x1="2066.9677515897347" y1="473.4119134177565" x2="2158.1262397347077" y2="767.7122274797483" class="minimap-edge"></line><line x1="2066.9677515897347" y1="473.4119134177565" x2="2342.2663764534577" y2="631.7681967180296" class="minimap-edge"></line><line x1="2103.968290880771" y1="268" x2="2757.879480087803" y2="307.6117116091891" class="minimap-edge"></line><line x1="2757.879480087803" y1="307.6117116091891" x2="3200.4643189549906" y2="320.469591247861" class="minimap-edge"></line><line x1="3200.4643189549906" y1="320.469591247861" x2="2971.700036728428" y2="480.7287465212985" class="minimap-edge"></line><line x1="3312.857751572178" y1="502.58220111114224" x2="3200.4643189549906" y2="320.469591247861" class="minimap-edge"></line><circle cx="2103.968290880771" cy="268" r="40" class="minimap-node"></circle><circle cx="2066.9677515897347" cy="473.4119134177565" r="40" class="minimap-node"></circle><circle cx="1773.8400660428597" cy="666.5758233298659" r="40" class="minimap-node"></circle><circle cx="1931.1978950081452" cy="782.2775961320921" r="40" class="minimap-node"></circle><circle cx="2158.1262397347077" cy="767.7122274797483" r="40" class="minimap-node"></circle><circle cx="2342.2663764534577" cy="631.7681967180296" r="40" class="minimap-node"></circle><circle cx="2757.879480087803" cy="307.6117116091891" r="40" class="minimap-node"></circle><circle cx="3312.857751572178" cy="502.58220111114224" r="40" class="minimap-node"></circle><circle cx="2971.700036728428" cy="480.7287465212985" r="40" class="minimap-node"></circle><circle cx="3200.4643189549906" cy="320.469591247861" r="40" class="minimap-node"></circle><circle cx="2645.5845448279656" cy="970.7820678889219" r="40" class="minimap-node"></circle><rect class="minimap-viewport" id="minimap-viewport" x="1254.5197896196048" y="-147.55422459755366" width="2648.185035176588" height="1986.138776382441"></rect>
            </svg>
          </div>
          <div class="zoom-toolbar" id="zoom-toolbar">
            <button id="zoom-in-btn" title="Zoom in">+</button>
            <div class="zoom-level" id="zoom-level">151%</div>
            <button id="zoom-out-btn" title="Zoom out">-</button>
            <div class="divider"></div>
            <button id="zoom-fit-btn" title="Fit to view">[ ]</button>
            <button id="zoom-reset-btn" title="Reset view">R</button>
          </div>
        </div>
        <button type="button" id="edge-legend-mini" class="legend-mini-btn" style="bottom: 10px; display: none;">Line Legend</button>
        <button type="button" id="minimap-mini" class="legend-mini-btn" style="right: 10px; left: auto; bottom: 10px; display: none;">Map</button>
        <button type="button" id="draw-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: 10px; right: auto; display: none;">Draw</button>
        <button type="button" id="topology-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: auto; right: 40px; display: none;">Add Line</button>
     </section>
      <aside class="details-panel" id="details-panel">
        <div class="sidebar-resizer" id="sidebar-resizer">
          <svg class="resizer-icon" width="6" height="40" viewBox="0 0 6 40" xmlns="http://www.w3.org/2000/svg">
            <circle cx="3" cy="14" r="2"></circle>
            <circle cx="3" cy="20" r="2"></circle>
            <circle cx="3" cy="26" r="2"></circle>
          </svg>
        </div>
        <div class="mobile-footer-resizer" id="mobile-footer-resizer">
          <svg class="resizer-icon" width="40" height="6" viewBox="0 0 40 6" xmlns="http://www.w3.org/2000/svg">
            <circle cx="14" cy="3" r="2"></circle>
            <circle cx="20" cy="3" r="2"></circle>
            <circle cx="26" cy="3" r="2"></circle>
          </svg>
        </div>
        <div id="node-panel" style="display: none;">
          <div class="details-name editable-text" id="node-name">Core Router 1</div>
          <div class="details-ip editable-text" id="node-ip">10.0.0.1</div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">MAC:</span>
            <span class="editable-text" id="node-mac" style="flex: 1; cursor: pointer; color: var(--text-main);">00:1A:2B:3C:4D:01</span>
          </div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">Rack Unit:</span>
            <span class="editable-text" id="node-rack" style="flex: 1; cursor: pointer; color: var(--text-main);">--</span>
          </div>
          <div class="details-info-row" id="uheight-row" style="display: none;">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">U Height:</span>
            <span class="editable-text" id="node-uheight" style="flex: 1; cursor: pointer; color: var(--text-main);">2U</span>
          </div>
          <div class="details-info-row" id="assigned-rack-row" style="display: flex;">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">Assigned Rack:</span>
            <select id="node-assigned-rack" style="flex: 1; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;"><option value="">None</option><option value="dc-rack-a1">DC Rack A1</option><option value="dc-rack-a2">DC Rack A2</option><option value="dc-rack-b1">DC Rack B1</option><option value="dc-rack-b2">DC Rack B2</option><option value="dmz-rack">DMZ Rack</option><option value="mgmt-rack">Management Rack</option></select>
          </div>
          <div class="details-info-row" id="rack-capacity-row" style="display: none;">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">Rack Capacity:</span>
            <select id="node-rack-capacity" style="flex: 1; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;">
              <option value="42">42U</option>
              <option value="48">48U</option>
              <option value="24">24U</option>
              <option value="12">12U</option>
              <option value="6">6U</option>
            </select>
          </div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">Layer:</span>
            <select id="node-layer" style="flex: 1; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;">
              <option value="physical">Physical</option>
              <option value="logical">Logical</option>
              <option value="security">Security</option>
              <option value="application">Application</option>
            </select>
          </div>
          <div class="details-role" id="node-role">Core Routing</div>
		  <details id="rack-contents-section" style="display: none; margin-top: 12px; margin-bottom: 12px; padding: 10px; background: var(--panel-alt); border-radius: 6px;" open="">
            <summary style="color: var(--accent); font-weight: 600; font-size: 14px; cursor: pointer;">Nodes in Rack (<span id="rack-contents-count">0</span>)</summary>
            <div id="rack-contents-list" style="max-height: 200px; overflow-y: auto; margin-top: 8px;"></div>
          </details>
          <div class="badge-row" id="node-tags"><span class="badge" style="cursor: pointer; position: relative;"><span>core</span><span style="opacity: 0.6; margin-left: 4px; font-size: 10px;"> ‚úï</span></span><span class="badge" style="cursor: pointer; position: relative;"><span>tier-1</span><span style="opacity: 0.6; margin-left: 4px; font-size: 10px;"> ‚úï</span></span><span class="badge" style="cursor: pointer; position: relative;"><span>redundant</span><span style="opacity: 0.6; margin-left: 4px; font-size: 10px;"> ‚úï</span></span><span class="badge" style="cursor: pointer; opacity: 0.6; border-style: dashed;">+ Add Tag</span></div>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-tag-input" placeholder="Add tag..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-tag-btn" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button class="pick-icon-btn" id="pick-tag-icon-btn">Add Icon Tag</button>
          <div class="section-label">Size</div>
          <div class="size-controls">
            <label>Size:</label>
            <input type="range" id="size-slider" min="20" max="200" value="55">
            <span id="size-value">55</span>
            <button id="reset-size">Reset</button>
          </div>
          <details class="style-section">
            <summary>Styling</summary>
            <div class="style-content">
              <div class="style-row">
                <label>Screen:</label>
                <select id="style-scope">
                  <option value="all">All</option>
                  <option value="desktop">Desktop</option>
                  <option value="tablet">Tablet</option>
                  <option value="mobile">Mobile</option>
                  <option value="fold">Fold</option>
                </select>
              </div>
              <div class="style-row">
                <label>Shape:</label>
                <select id="shape-select"><option value="custom-icon">Custom Icon</option>
                  <optgroup label="Basic Shapes">
            <option value="circle">Circle</option>
            <option value="square">Square</option>
            <option value="rectangle">Rectangle</option>
            <option value="triangle">Triangle</option>
            <option value="hexagon">Hexagon</option>
            <option value="diamond">Diamond</option>
            <option value="star">Star</option>
            <option value="stop-sign">Stop Sign</option>
            <option value="octagon">Octagon</option>
            <option value="pentagon">Pentagon</option>
            <option value="cross">Cross</option>
            <option value="rounded-square">Rounded Square</option>
            <option value="pill">Pill</option>
            <option value="parallelogram">Parallelogram</option>
            <option value="trapezoid">Trapezoid</option>
          </optgroup>
          <optgroup label="Computers &amp; Devices">
            <option value="server">Server</option>
            <option value="pc">PC / Desktop</option>
            <option value="laptop">Laptop</option>
            <option value="phone">Phone / Mobile</option>
            <option value="printer">Printer</option>
            <option value="pi">Raspberry Pi</option>
            <option value="sensor">Sensor / IoT</option>
          </optgroup>
          <optgroup label="Network Equipment">
            <option value="router">Router</option>
            <option value="switch">Switch</option>
            <option value="firewall">Firewall</option>
            <option value="access-point">Access Point</option>
            <option value="load-balancer">Load Balancer</option>
            <option value="gateway">Gateway</option>
            <option value="vpn">VPN / Tunnel</option>
            <option value="nas">NAS / Storage</option>
          </optgroup>
          <optgroup label="Cloud &amp; Services">
            <option value="cloud">Cloud</option>
            <option value="database">Database</option>
			<option value="docker">Docker</option>
            <option value="container">Container</option>
            <option value="vm">Virtual Machine</option>
            <option value="kubernetes">Kubernetes</option>
            <option value="api">API / Endpoint</option>
            <option value="queue">Queue / Message</option>
            <option value="lambda">Lambda / Function</option>
            <option value="bucket">Bucket / S3</option>
          </optgroup>
          <optgroup label="Security &amp; Monitoring">
            <option value="shield">Shield</option>
            <option value="camera">Camera / CCTV</option>
            <option value="monitor">Monitor / Dashboard</option>
          </optgroup>
                </select>
              </div>
              <button class="pick-icon-btn" id="pick-shape-icon-btn">Or Search Web Icons</button>
              <div class="style-row">
                <label>Fill Color:</label>
                <input type="color" id="circle-color" value="#1e293b">
              </div>
              <div class="style-row">
                <label>Border Color:</label>
                <input type="color" id="circle-border" value="#475569">
              </div>
              <div class="style-row">
                <label>Title Color:</label>
                <input type="color" id="title-color" value="#e2e8f0">
              </div>
              <div class="style-row">
                <label>Title Font:</label>
                <select id="title-font">
                  <option value="system-ui, sans-serif">System UI</option>
                  <option value="monospace">Monospace</option>
                  <option value="serif">Serif</option>
                  <option value="cursive">Cursive</option>
                  <option value="'Courier New', monospace">Courier</option>
                  <option value="Arial, sans-serif">Arial</option>
                  <option value="'Times New Roman', serif">Times</option>
                </select>
              </div>
              <div class="style-row">
                <label>Title Size:</label>
                <input type="number" id="title-size" min="8" max="100" value="18">
              </div>
              <div class="style-row">
                <label>Sub Color:</label>
                <input type="color" id="sub-color" value="#94a3b8">
              </div>
              <div class="style-row">
                <label>Sub Font:</label>
                <select id="sub-font">
                  <option value="system-ui, sans-serif">System UI</option>
                  <option value="monospace">Monospace</option>
                  <option value="serif">Serif</option>
                  <option value="cursive">Cursive</option>
                  <option value="'Courier New', monospace">Courier</option>
                  <option value="Arial, sans-serif">Arial</option>
                  <option value="'Times New Roman', serif">Times</option>
                </select>
              </div>
              <div class="style-row">
                <label>Sub Size:</label>
                <input type="number" id="sub-size" min="6" max="80" value="13">
              </div>
              <div style="
                margin-top: 12px;
                padding-top: 10px;
                border-top: 1px solid var(--edge-main);
                ">
                <div style="font-size: 12px;color: var(--text-soft);margin-bottom: 8px;text-transform: uppercase;">Text Position</div>
                <div class="style-row">
                  <label>Name Y:</label>
                  <input type="number" id="title-offset-y" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>Name X:</label>
                  <input type="number" id="title-offset-x" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>IP Y:</label>
                  <input type="number" id="sub-offset-y" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>IP X:</label>
                  <input type="number" id="sub-offset-x" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div style="margin-top: 16px; font-size: 12px; color: var(--text-soft); text-transform: uppercase;">
                  Ping Indicator Position
                </div>
                <div class="style-row">
                  <label>Ping X:</label>
                  <input type="number" id="ping-offset-x" min="-200" max="200" value="0" style="width: 60px;">
                </div>
                <div class="style-row">
                  <label>Ping Y:</label>
                  <input type="number" id="ping-offset-y" min="-200" max="200" value="0" style="width: 60px;">
                </div>
              </div>
              <button id="reset-styles" style="width: 100%;margin-top: 10px;padding: 8px;background: var(--panel);color: var(--text-main);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: clamp(13px, 1.5vw, 17px);">Reset Styles</button>
            </div>
          </details>
          <details class="style-section">
            <summary>Ping / Status Monitoring</summary>
            <div class="style-content">
              <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px; cursor: pointer;">
              <input type="checkbox" id="node-pingable" style="cursor: pointer;">
              <span style="font-size: 14px;">Enable status check for this node</span>
              </label>
              <div id="node-ping-options" style="display: none;">
                <div class="style-row">
                  <label>Protocol:</label>
                  <select id="node-ping-protocol">
                    <option value="http">HTTP (port 80)</option>
                    <option value="https">HTTPS (port 443)</option>
                    <option value="custom">Custom URL</option>
                  </select>
                </div>
                <div id="node-custom-url-container" style="display: block; margin-top: 8px;">
                  <label style="display: block; margin-bottom: 4px; font-size: 13px;">Custom URL:</label>
                  <input type="text" id="node-custom-url" placeholder="e.g. http://192.168.1.1:8080" style="width: 100%;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: 14px;">
                </div>
                <div class="style-row" style="margin-top: 8px;">
                  <label>Timeout (ms):</label>
                  <input type="number" id="node-ping-timeout" value="3000" min="1000" max="10000" step="500" style="width: 100px;">
                </div>
                <div style="margin-top: 12px; padding: 10px; background: var(--panel); border-radius: 6px; border: 1px solid var(--edge-main);">
                  <div style="font-size: 12px; color: var(--text-soft); margin-bottom: 8px;">Current Status:</div>
                  <div id="node-ping-status" style="font-size: 14px; font-weight: 600; color: var(--accent);">‚óè Online</div>
                  <div id="node-ping-last-check" style="font-size: 11px; color: var(--text-soft); margin-top: 4px;">Last checked: 2:25:19 PM</div>
                </div>
                <button id="check-ping-now" style="width: 100%;margin-top: 10px;padding: 8px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Check Status Now</button>
              </div>
            </div>
          </details>
          <div class="section-label">Notes</div>
          <ul class="list" id="node-notes"><li><span style="flex: 1 1 0%;">Primary core router</span><span class="delete-note">‚úï</span></li><li><span style="flex: 1 1 0%;">BGP peering enabled</span><span class="delete-note">‚úï</span></li></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-note-input" placeholder="Type new note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-note-btn" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-node-btn" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: rgb(255, 255, 255);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;width: 100%;">Delete Node</button>
        </div>
        <div id="edge-panel" style="display: none">
          <div class="details-name" id="edge-title">Custom line</div>
          <div class="style-row" style="margin-top: 10px">
            <label>Width:</label>
            <input type="number" id="edge-width" min="1" max="20" value="4">
          </div>
          <div class="style-row">
            <label>Color:</label>
            <input type="color" id="edge-color" value="#475569">
          </div>
          <div class="style-row">
            <label>Line Style:</label>
            <select id="edge-line-style">
              <option value="solid">Solid</option>
              <option value="dashed">Dashed</option>
              <option value="dotted">Dotted</option>
            </select>
          </div>
          <div class="style-row">
            <label>Direction:</label>
            <select id="edge-direction">
              <option value="none">No arrows</option>
              <option value="forward">‚Üí Forward</option>
              <option value="backward">‚Üê Backward</option>
              <option value="both">‚Üî Bidirectional</option>
            </select>
          </div>
          <div class="style-row" id="edge-port-fields">
            <label>From Port:</label>
            <input type="text" id="edge-from-port" placeholder="e.g. eth0, gi0/1" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);font-size: 14px;">
          </div>
          <div class="style-row" id="edge-port-fields-to">
            <label>To Port:</label>
            <input type="text" id="edge-to-port" placeholder="e.g. eth1, gi0/2" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);font-size: 14px;">
          </div>
          <div class="section-label">Line Notes</div>
          <ul class="list" id="edge-notes"></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-edge-note" placeholder="Add note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-edge-note" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-edge" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Delete Line</button>
        </div>
        <div id="rect-panel" style="display: none">
          <div class="details-name" id="rect-title">Zone</div>
          <div class="style-row" id="rect-fill-row" style="margin-top: 10px">
            <label>Fill Color:</label>
            <input type="color" id="rect-color" value="#f97316">
          </div>
          <div class="style-row">
            <label>Border Color:</label>
            <input type="color" id="rect-border-color" value="#f97316">
          </div>
          <div class="style-row">
            <label>Border Width:</label>
            <input type="number" id="rect-border-width" min="0" max="20" value="2">
          </div>
          <div class="style-row">
            <label>Style:</label>
            <select id="rect-style-select">
              <option value="filled">Filled</option>
              <option value="outlined">Outlined</option>
            </select>
          </div>
		  <div class="style-row">
            <label>Line Style:</label>
            <select id="rect-line-style">
              <option value="solid">Solid</option>
              <option value="dashed">Dashed</option>
              <option value="dotted">Dotted</option>
            </select>
          </div>
          <div class="section-label">Zone Notes</div>
          <ul class="list" id="rect-notes"></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-rect-note" placeholder="Add note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-rect-note" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-rect" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Delete Zone</button>
        </div>
        <div id="text-panel" style="display: none">
          <div class="details-name" id="text-title">Text Element</div>
          <div class="style-row" style="margin-top: 10px">
            <label>Content:</label>
            <textarea id="text-content" placeholder="Enter text..." style="width: 100%;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: 14px;min-height: 80px;resize: vertical;font-family: inherit;"></textarea>
          </div>
          <div class="style-row">
            <label>Font Size:</label>
            <input type="number" id="text-font-size" min="8" max="200" value="18" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);">
          </div>
          <div class="style-row">
            <label>Color:</label>
            <input type="color" id="text-color" value="#e2e8f0">
          </div>
          <div class="style-row">
            <label>Font Weight:</label>
            <select id="text-font-weight" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="normal">Normal</option>
              <option value="bold">Bold</option>
              <option value="600">Semi-Bold</option>
              <option value="300">Light</option>
            </select>
          </div>
          <div class="style-row">
            <label>Font Style:</label>
            <select id="text-font-style" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="normal">Normal</option>
              <option value="italic">Italic</option>
            </select>
          </div>
          <div class="style-row">
            <label>Text Align:</label>
            <select id="text-align" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="start">Left</option>
              <option value="middle">Center</option>
              <option value="end">Right</option>
            </select>
          </div>
          <div class="style-row">
            <label>Text Decoration:</label>
            <select id="text-decoration" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="none">None</option>
              <option value="underline">Underline</option>
              <option value="line-through">Strike Through</option>
            </select>
          </div>
          <div class="style-row">
            <label>Background:</label>
            <input type="color" id="text-bg-color" value="#000000">
            <label style="margin-left: 10px; display: flex; align-items: center; gap: 6px;">
            <input type="checkbox" id="text-bg-enabled" style="cursor: pointer;">
            <span style="font-size: 13px;">Enable</span>
            </label>
          </div>
          <div class="style-row">
            <label>Opacity:</label>
            <input type="range" id="text-opacity" min="0" max="1" step="0.1" value="1" style="flex: 1">
            <span id="text-opacity-val" style="min-width: 35px; text-align: right">100%</span>
          </div>
          <button id="delete-text" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;width: 100%;">Delete Text</button>
        </div>
     <details class="style-section">
          <summary>Page Layout</summary>
          <div class="style-content">
            <div style="padding: 12px; background: var(--panel-alt); border-radius: 6px; color: var(--text-soft); font-size: 13px; line-height: 1.6;">
              <strong style="color: var(--accent); display: block; margin-bottom: 8px;">Drag to Resize:</strong>
              ‚Ä¢ <strong>Header:</strong> Drag the bottom edge of the header bar<br>
              ‚Ä¢ <strong>Sidebar:</strong> Drag the left edge of the sidebar panel<br>
              ‚Ä¢ <strong>Mobile:</strong> Drag the top edge of the footer panel<br>
              <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--edge-main); font-size: 12px;">
                Hover over panel edges to see resize handles
              </div>
            </div>
          </div>
        </details>
      </aside>
    </main>
    <script id="nodes-json" type="application/json">{}</script>
    <script id="topology-state" type="application/json">ENCRYPTED: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</script>
    <script>
	Object.keys(localStorage).forEach(key => {
       if (key.startsWith('icon-selfhst-')) {
        const val = localStorage.getItem(key);
        if (val && val.includes('<image href=')) {
         localStorage.removeItem(key);
        }
       }
      });
      const IconLibrary = {
       libraries: {
        mdi: {
         name: 'Material Design Icons',
         cdnBase: 'https://cdn.jsdelivr.net/npm/@mdi/svg@latest/svg/',
         metaUrl: 'https://cdn.jsdelivr.net/npm/@mdi/svg@latest/meta.json',
         icons: []
        },
        simple: {
         name: 'Simple Icons',
         cdnBase: 'https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/',
         indexUrl: 'https://cdn.jsdelivr.net/npm/@iconify-json/simple-icons@latest/icons.json',
         icons: []
        },
        selfhst: {
         name: 'selfh.st/icons',
         cdnBase: 'https://cdn.jsdelivr.net/gh/selfhst/icons@master/svg/',
         indexUrl: 'https://raw.githubusercontent.com/selfhst/icons/refs/heads/main/index.json',
         icons: []
        }
       },
       currentLibrary: 'selfhst',
       iconCache: {},
       indexCache: {},
       indexLoading: {},
       async loadLibraryIndex(library) {
        if (this.indexCache[library]) {
         return this.indexCache[library];
        }
        if (this.indexLoading[library]) {
         return this.indexLoading[library];
        }
        const lib = this.libraries[library];
        this.indexLoading[library] = (async () => {
         try {
          if (library === 'selfhst') {
           const response = await fetch(lib.indexUrl);
           const data = await response.json();
           const icons = data.filter(item => item.SVG === "Yes").map(item => ({
            name: item.Reference,
            displayName: item.Name,
            tags: item.Tags ? item.Tags.split(',').map(t => t.trim()).filter(t => t) : [],
            category: item.Category
           }));
           this.indexCache[library] = icons;
           lib.icons = icons;
           return icons;
          } else if (library === 'simple') {
           const response = await fetch('https://cdn.jsdelivr.net/npm/@iconify-json/simple-icons@latest/icons.json');
           const data = await response.json();
           const icons = Object.keys(data.icons).map(slug => ({
            name: slug,
            displayName: data.icons[slug].title || slug,
            tags: data.aliases && data.aliases[slug] ? [data.aliases[slug].parent] : [],
            hex: data.icons[slug].hex
           }));
           this.indexCache[library] = icons;
           lib.icons = icons;
           return icons;
          } else if (library === 'mdi') {
           const response = await fetch(lib.metaUrl);
           const data = await response.json();
           const icons = data.map(item => ({
            name: item.name,
            displayName: item.name,
            tags: item.tags || [],
            author: item.author
           }));
           this.indexCache[library] = icons;
           lib.icons = icons;
           return icons;
          }
         } catch (error) {
          console.error(`Failed to load index for ${library}:`, error);
          this.indexCache[library] = [];
          lib.icons = [];
          return [];
         } finally {
          delete this.indexLoading[library];
         }
        })();
        return this.indexLoading[library];
       },
       async getIcon(library, name) {
        const cacheKey = `${library}-${name}`;
        if (this.iconCache[cacheKey]) {
         return this.iconCache[cacheKey];
        }
        const cached = localStorage.getItem(`icon-${cacheKey}`);
        if (cached) {
         this.iconCache[cacheKey] = cached;
         return cached;
        }
        const lib = this.libraries[library];
        const url = `${lib.cdnBase}${name}.svg`;
        try {
         const response = await fetch(url);
         if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
         }
         const svg = await response.text();
         this.iconCache[cacheKey] = svg;
         localStorage.setItem(`icon-${cacheKey}`, svg);
         return svg;
        } catch (error) {
         console.error(`Failed to fetch icon ${cacheKey}:`, error);
         return null;
        }
       },
       searchIcons(library, query) {
        const lib = this.libraries[library];
        if (!lib.icons.length) return [];
        const q = query.toLowerCase();
        return lib.icons.filter(icon => {
         const nameMatch = icon.name.toLowerCase().includes(q);
         const displayMatch = icon.displayName && icon.displayName.toLowerCase().includes(q);
         const tagMatch = icon.tags && icon.tags.some(t => t.toLowerCase().includes(q));
         const categoryMatch = icon.category && icon.category.toLowerCase().includes(q);
         return nameMatch || displayMatch || tagMatch || categoryMatch;
        }).slice(0, 50);
       }
      };
      let iconPickerCallback = null;
      let selectedNodeIconData = null;
      let selectedRackIconData = null;
      let newNodeIconTags = [];
      let freeDrawMode = false;
      async function checkNodeStatus(nodeId) {
       const data = NODE_DATA[nodeId];
       if (!data || !data.ping || !data.ping.enabled) return;
       
       data.ping.status = 'checking';
       data.ping.lastCheck = new Date().toISOString();
       updatePingIndicator(nodeId);
       if (currentNodeId === nodeId) {
        updatePingStatusDisplay(nodeId);
       }
       
       let url;
       if (data.ping.protocol === 'custom') {
        url = data.ping.customUrl;
       } else {
        const ip = data.ip || '0.0.0.0';
        const protocol = data.ping.protocol || 'http';
        url = `${protocol}://${ip}`;
       }
       
       if (!url) {
        data.ping.status = 'unknown';
        updatePingIndicator(nodeId);
        if (currentNodeId === nodeId) {
         updatePingStatusDisplay(nodeId);
        }
        return;
       }
       
       try {
        const controller = new AbortController();
        const timeout = data.ping.timeout || 3000;
        const timeoutId = setTimeout(() => controller.abort(), timeout);
        
        const response = await fetch(url, {
         method: 'HEAD',
         mode: 'no-cors', 
         signal: controller.signal
        });
        
        clearTimeout(timeoutId);
        
        data.ping.status = 'online';
       } catch (error) {
        data.ping.status = 'offline';
       }
       
       data.ping.lastCheck = new Date().toISOString();
       updatePingIndicator(nodeId);
       if (currentNodeId === nodeId) {
        updatePingStatusDisplay(nodeId);
       }
      }
      function rgbaToHex(val) {
      if (!val) return "#000000";
      if (val.startsWith("#")) return val;
      
      const m = val.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
      if (!m) return "#000000";
      
      const r = Number(m[1]).toString(16).padStart(2, "0");
      const g = Number(m[2]).toString(16).padStart(2, "0");
      const b = Number(m[3]).toString(16).padStart(2, "0");
      
      return `#${r}${g}${b}`;
      }
      function updatePingIndicator(nodeId) {
      const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
      if (!nodeGroup) return;
      
      const data = NODE_DATA[nodeId];
      if (!data || !data.ping || !data.ping.enabled) {
       const existingIndicator = nodeGroup.querySelector('.ping-indicator');
       if (existingIndicator) existingIndicator.remove();
       return;
      }
      
      let indicator = nodeGroup.querySelector('.ping-indicator');
      const label = nodeGroup.querySelector('.node-label');
      
      if (!indicator && label) {
       indicator = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
       indicator.classList.add('ping-indicator');
       nodeGroup.appendChild(indicator);
      }
      
      if (indicator && label) {
       const size = savedSizes[nodeId] || getDefaultSize();
       const radius = Math.max(4, size * 0.06);
      
       indicator.setAttribute('r', radius);
      
       const labelBBox = label.getBBox();
       const labelX = parseFloat(label.getAttribute('x') || 0);
       const labelY = parseFloat(label.getAttribute('y') || 0);
      
       const styles = resolveStylesForNode(nodeId);
      const offX = styles.pingOffsetX || 0;
      const offY = styles.pingOffsetY || 0;
      
      indicator.setAttribute('cx', (labelX - labelBBox.width / 2 - radius * 1.1) + offX);
      indicator.setAttribute('cy', (labelY - radius * 0.7) + offY);
      }
      
      if (indicator) {
       indicator.classList.remove('online', 'offline', 'checking');
       if (data.ping.status) indicator.classList.add(data.ping.status);
      }
      }
      
      
      function checkAllNodesStatus() {
       Object.keys(NODE_DATA).forEach(nodeId => {
        const data = NODE_DATA[nodeId];
        if (data && data.ping && data.ping.enabled) {
         checkNodeStatus(nodeId);
        }
       });
      }
      
      function startAutoPing() {
       stopAutoPing();
       
       checkAllNodesStatus();
       updateAutoPingLastRun();
       
       autoPingSecondsRemaining = autoPingInterval;
       
      
       autoPingTimer = setInterval(() => {
        checkAllNodesStatus();
        updateAutoPingLastRun();
        autoPingSecondsRemaining = autoPingInterval;
       }, autoPingInterval * 1000);
       
       autoPingCountdown = setInterval(() => {
        autoPingSecondsRemaining--;
        updateAutoPingCountdown();
        if (autoPingSecondsRemaining <= 0) {
         autoPingSecondsRemaining = autoPingInterval;
        }
       }, 1000);
       
       updateAutoPingCountdown();
      }
      
      function stopAutoPing() {
       if (autoPingTimer) {
        clearInterval(autoPingTimer);
        autoPingTimer = null;
       }
       if (autoPingCountdown) {
        clearInterval(autoPingCountdown);
        autoPingCountdown = null;
       }
       autoPingSecondsRemaining = 0;
       updateAutoPingCountdown();
      }
      
      function updateAutoPingCountdown() {
       const nextCheckEl = document.getElementById('auto-ping-next-check');
       if (nextCheckEl) {
        if (autoPingSecondsRemaining > 0 && autoPingEnabled) {
         const mins = Math.floor(autoPingSecondsRemaining / 60);
         const secs = autoPingSecondsRemaining % 60;
         if (mins > 0) {
          nextCheckEl.textContent = `Next check in: ${mins}m ${secs}s`;
         } else {
          nextCheckEl.textContent = `Next check in: ${secs}s`;
         }
        } else {
         nextCheckEl.textContent = 'Next check in: --';
        }
       }
      }
      
      function updateAutoPingLastRun() {
       const lastRunEl = document.getElementById('auto-ping-last-run');
       if (lastRunEl) {
        const now = new Date();
        lastRunEl.textContent = `Last run: ${now.toLocaleTimeString()}`;
       }
      }
      
      function openIconPicker(callback) {
       iconPickerCallback = callback;
       const modal = document.getElementById('icon-picker-modal');
       modal.classList.add('active');
       const searchInput = document.getElementById('icon-search');
       searchInput.style.display = 'none';
       loadIconsForCurrentLibrary();
      }
      
      function closeIconPicker() {
       const modal = document.getElementById('icon-picker-modal');
       modal.classList.remove('active');
       iconPickerCallback = null;
      }
      async function loadIconsForCurrentLibrary() {
       const body = document.getElementById('icon-picker-body');
       const libNames = {
        mdi: 'MDI (Material Design Icons)',
        simple: 'Simple Icons',
        selfhst: 'selfh.st/icons'
       };
       body.innerHTML = `<div style="padding: 20px;"><p style="color: var(--text-soft); margin-bottom: 15px; text-align: center;">Search ${libNames[IconLibrary.currentLibrary]}:</p><input type="text" id="icon-search-field" placeholder="Search icons..." style="width: 100%; padding: 12px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main); font-size: 16px; margin-bottom: 20px;"><div id="icon-grid-container" style="max-height: 400px; overflow-y: auto;"><div style="text-align: center; color: var(--text-soft); padding: 40px;">Loading icons...</div></div></div>`;
       const searchField = document.getElementById('icon-search-field');
       const gridContainer = document.getElementById('icon-grid-container');
       await IconLibrary.loadLibraryIndex(IconLibrary.currentLibrary);
       const renderIcons = (icons) => {
        if (!icons || icons.length === 0) {
         gridContainer.innerHTML = '<div style="text-align: center; color: var(--text-soft); padding: 40px;">No icons found</div>';
         return;
        }
        const grid = document.createElement('div');
        grid.style.cssText = 'display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 15px; padding: 10px;';
        icons.forEach(icon => {
         const item = document.createElement('div');
         item.style.cssText = 'display: flex; flex-direction: column; align-items: center; gap: 8px; padding: 15px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; cursor: pointer; transition: all 0.2s;';
         item.onmouseover = () => {
          item.style.background = 'var(--panel)';
          item.style.borderColor = 'var(--accent)';
         };
         item.onmouseout = () => {
          item.style.background = 'var(--panel-alt)';
          item.style.borderColor = 'var(--edge-main)';
         };
         const iconPreview = document.createElement('div');
         iconPreview.style.cssText = 'width: 48px; height: 48px; display: flex; align-items: center; justify-content: center;';
         iconPreview.innerHTML = '<div style="color: var(--text-soft); font-size: 12px;">...</div>';
         IconLibrary.getIcon(IconLibrary.currentLibrary, icon.name).then(svg => {
          if (svg) {
           const parser = new DOMParser();
           const doc = parser.parseFromString(svg, 'image/svg+xml');
           const svgEl = doc.querySelector('svg');
           if (svgEl) {
            svgEl.setAttribute('width', '48');
            svgEl.setAttribute('height', '48');
            svgEl.style.fill = 'var(--text-main)';
            iconPreview.innerHTML = '';
            iconPreview.appendChild(svgEl);
           }
          }
         });
         const name = document.createElement('div');
         name.textContent = icon.displayName || icon.name;
         name.style.cssText = 'font-size: 11px; color: var(--text-soft); text-align: center; word-break: break-word; max-width: 100%;';
         item.appendChild(iconPreview);
         item.appendChild(name);
         item.addEventListener('click', async () => {
          const svg = await IconLibrary.getIcon(IconLibrary.currentLibrary, icon.name);
          if (iconPickerCallback && svg) {
           iconPickerCallback({
            library: IconLibrary.currentLibrary,
            name: icon.name,
            svg: svg
           });
          }
          closeIconPicker();
         });
         grid.appendChild(item);
        });
        gridContainer.innerHTML = '';
        gridContainer.appendChild(grid);
       };
       gridContainer.innerHTML = '<div style="text-align: center; color: var(--text-soft); padding: 40px;">Type to search icons</div>';
       let searchTimeout;
       searchField.addEventListener('input', (e) => {
        clearTimeout(searchTimeout);
        const query = e.target.value.trim();
        searchTimeout = setTimeout(() => {
         if (!query) {
          gridContainer.innerHTML = '<div style="text-align: center; color: var(--text-soft); padding: 40px;">Type to search icons</div>';
          return;
         }
         const results = IconLibrary.searchIcons(IconLibrary.currentLibrary, query);
         renderIcons(results);
        }, 300);
       });
       searchField.focus();
      }
      async function displayIcons(icons) {
       const body = document.getElementById('icon-picker-body');
       const grid = document.createElement('div');
       grid.className = 'icon-grid';
       for (const icon of icons) {
        const item = document.createElement('div');
        item.className = 'icon-item';
        const svg = await IconLibrary.getIcon(icon.library, icon.name);
        if (svg) {
         const parser = new DOMParser();
         const doc = parser.parseFromString(svg, 'image/svg+xml');
         const svgEl = doc.querySelector('svg');
         if (svgEl) {
          item.innerHTML = svgEl.outerHTML;
         }
        } else {
         item.innerHTML = '<svg width = "32" height = "32"><rect width = "32" height = "32" fill = "currentColor"/> </svg>';
        }
        const name = document.createElement('div');
        name.className = 'icon-item-name';
        name.textContent = icon.name;
        item.appendChild(name);
        item.addEventListener('click', () => {
         if (iconPickerCallback) {
          iconPickerCallback({
           library: icon.library,
           name: icon.name,
           svg: svg
          });
         }
         closeIconPicker();
        });
        grid.appendChild(item);
       }
       body.innerHTML = '';
       body.appendChild(grid);
      }
      window.addEventListener('DOMContentLoaded', () => {
       document.querySelectorAll('.icon-picker-tab').forEach(tab => {
        tab.addEventListener('click', () => {
         document.querySelectorAll('.icon-picker-tab').forEach(t => t.classList.remove('active'));
         tab.classList.add('active');
         IconLibrary.currentLibrary = tab.dataset.library;
         loadIconsForCurrentLibrary();
        });
       });
       document.getElementById('icon-picker-cancel').addEventListener('click', closeIconPicker);
       document.getElementById('icon-picker-modal').addEventListener('click', (e) => {
        if (e.target.id === 'icon-picker-modal') {
         closeIconPicker();
        }
       });
      });
      let textDrawMode = false;
      const BASE_NODE_DATA = JSON.parse(document.getElementById("nodes-json").textContent, );
      let currentNodeId = "host";
      let currentEdgeId = null;
      let currentStyleScope = "all";
      let NODE_DATA = {};
      let EDGE_DATA = {
       list: []
      };
      let currentRectId = null;
      let currentTextId = null;
      let rectDrawMode = false;
      let RECT_DATA = {
       list: []
      };
      let TEXT_DATA = {
       list: []
      };
      let EDGE_LEGEND = {};
      let savedPositions = {};
      let savedSizes = {};
      let savedStyles = {};
      let legendCollapsed = false;
      let minimapCollapsed = false;
      let drawToolbarCollapsed = false;
      let currentView = {
       mode: "topology",
       rackId: null
      };
      let savedTopologyView = null;
      let activeLayers = new Set(["physical", "logical", "security", "application"]);
      let topologyToolbarCollapsed = false;
      let legendMiniBtn = null;
      let minimapMiniBtn = null;
      let drawToolbarMiniBtn = null;
      let topologyToolbarMiniBtn = null;
      
      let autoPingEnabled = false;
      let autoPingInterval = 30;
      let autoPingTimer = null;
      let autoPingCountdown = null;
      let autoPingSecondsRemaining = 0;
      
      const ROLLBACK_STORAGE_KEY = "theonefile_rollback_history";
      let rollbackVersions = [];
      const MAX_ROLLBACK_VERSIONS = 50;
      let currentRollbackIndex = -1;
      
      const AUDIT_STORAGE_KEY = "theonefile_audit_log";
      let auditLog = [];
      const MAX_AUDIT_ENTRIES = 1000;
      
      let documentTabs = [{
        id: "main",
        name: "Main Topology",
        nodes: {},
        edges: { list: [] },
        positions: {},
        sizes: {},
        styles: {},
        legend: {},
        rects: { list: [] },
        texts: { list: [] },
      pageState: null
      }];
      let currentTabIndex = 0;
      
      let encryptedSections = {};
      
      let undoStack = [];
      let redoStack = [];
      const MAX_UNDO_STACK = 50;
      let selectedNodes = new Set();
      let selectedEdges = new Set();
      let selectedRects = new Set();
      let selectedTexts = new Set();
      let isSelecting = false;
      let selectionStart = null;
      let preDragSelectedNodes = new Set();
      let preDragSelectedEdges = new Set();
      let preDragSelectedRects = new Set();
      let preDragSelectedTexts = new Set();
      let selectionRect = null;
      let isDraggingSelection = false;
      let dragSelectionStart = null;
      let selectionBoxStyle = {
       fillColor: "#4fd1c5",
       fillOpacity: 0.1,
       strokeColor: "#4fd1c5",
       strokeWidth: 2,
       strokeDasharray: "5,5"
      };
      let clipboard = null;
      
      const MobileManager = {
        isMobile: false,
        detect() {
      
          if (navigator.userAgentData?.mobile === true) {
            this.isMobile = true;
            return true;
          }
          const coarse = matchMedia("(pointer: coarse)").matches;
          const width = window.innerWidth <= 900;
          const portrait = matchMedia("(orientation: portrait)").matches;
          this.isMobile = coarse && (width || portrait);
          return this.isMobile;
        },
        applyInitialCollapse() {
          if (!this.isMobile) return;
          legendCollapsed = true;
          minimapCollapsed = true;
          drawToolbarCollapsed = true;
          topologyToolbarCollapsed = true;
          if (typeof updateLegendVisibility === "function") updateLegendVisibility();
          if (typeof updateMinimapVisibility === "function") updateMinimapVisibility();
          if (typeof updateDrawToolbarVisibility === "function") updateDrawToolbarVisibility();
          if (typeof updateTopologyToolbarVisibility === "function") updateTopologyToolbarVisibility();
        },
        updateBulkToolbar() {
          const desktop = document.getElementById("bulk-toolbar");
          const mobile = document.getElementById("bulk-toolbar-mobile");
          if (!desktop || !mobile) return;
          
          if (typeof isViewOnly === 'function' && isViewOnly()) {
           desktop.style.display = "none";
           mobile.style.display = "none";
           return;
          }
          
          if (typeof selectedNodes === 'undefined' || selectedNodes.size === 0) {
           desktop.style.display = "none";
           mobile.style.display = "none";
           return;
          }
          
          const isVisible = desktop.style.display !== "none" || mobile.style.display !== "none";
          
          if (this.isMobile) {
            desktop.style.display = "none";
            if (isVisible) {
              mobile.style.display = "flex";
            }
          } else {
            mobile.style.display = "none";
            if (isVisible) {
              desktop.style.display = "flex";
            }
          }
        },
        updateLayout() {
          const main = document.querySelector("main");
          if (!main) return;
        },
        updateCanvasHint() {
      const hint = document.getElementById("canvas-hint");
      if (!hint) return;
      
      if (PAGE_STATE.canvasHintText !== undefined && PAGE_STATE.canvasHintText !== "") {
        hint.innerHTML = PAGE_STATE.canvasHintText;
        return;
      }
      
      const items = this.isMobile
      ? [
        "Pinch to zoom",
        "Drag to pan",
        "Add node from top menu",
        "Double tap to clone and align",
        "Double tap to select multiple",
        "You have the power",	
        "Your time is NOW!",
      ]
      : [
        "Scroll to zoom",
        "Drag to pan",
        "Right click to clone and align",
        "Right click to select multiple",
        "You have the power",
        "Your time is NOW!",
      ];
      
      const list = document.createElement("ul");
      for (const item of items) {
      const li = document.createElement("li");
      li.textContent = item;
      list.appendChild(li);
      }
      
      hint.replaceChildren(list);
      },
        autoSelectStyleScope() {
          const scope = document.getElementById("style-scope");
          if (!scope) return;
          if (this.isMobile) scope.value = "mobile";
        },
        updateToolbarStack() {
          if (!this.isMobile) return;
          const draw = document.getElementById("draw-toolbar");
          const topo = document.getElementById("topology-toolbar");
          if (!draw || !topo) return;
          const h = draw.getBoundingClientRect().height;
          document.documentElement.style.setProperty("--draw-toolbar-height", h + "px");
        },
        updateLayoutControls() {
          const sidebarRow = document.getElementById("sidebar-width-row");
          const footerRow = document.getElementById("mobile-footer-row");
          if (sidebarRow && footerRow) {
            if (this.isMobile) {
              sidebarRow.style.display = "none";
              footerRow.style.display = "flex";
            } else {
              sidebarRow.style.display = "flex";
              footerRow.style.display = "none";
            }
          }
        },
        applyAll() {
          this.detect();
          this.applyInitialCollapse();
          this.updateBulkToolbar();
          this.updateLayout();
          this.updateCanvasHint();
          this.autoSelectStyleScope();
          this.updateToolbarStack();
          this.updateLayoutControls();
        }
      };
      function isMobileDevice() {
        return MobileManager.isMobile;
      }
      
      function ensureLegendMiniButton() {
		if (legendMiniBtn) return legendMiniBtn;
		const handleClick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			legendCollapsed = false;
			updateLegendVisibility();
		};
		const preventTouch = (e) => { e.preventDefault(); };
		const existing = document.getElementById("edge-legend-mini");
		if (existing) {
			existing.addEventListener("click", handleClick);
			existing.addEventListener("touchstart", preventTouch, { passive: false });
			existing.addEventListener("touchend", handleClick);
			legendMiniBtn = existing;
			return existing;
		}
		const panel = document.querySelector(".topology-panel");
		if (!panel) return null;
		   const btn = document.createElement("button");
		   btn.type = "button";
		   btn.id = "edge-legend-mini";
		   btn.className = "legend-mini-btn";
		   btn.textContent = "Legend";
		   btn.style.bottom = "10px";
		   btn.addEventListener("click", handleClick);
		   btn.addEventListener("touchstart", preventTouch, { passive: false });
		   btn.addEventListener("touchend", handleClick);
		   panel.appendChild(btn);
		   legendMiniBtn = btn;
		   return btn;
		}
      
			 function ensureMinimapMiniButton() {
		   if (minimapMiniBtn) return minimapMiniBtn;
		   const handleClick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			minimapCollapsed = false;
			updateMinimapVisibility();
		   };
		   const preventTouch = (e) => { e.preventDefault(); };
		   const existing = document.getElementById("minimap-mini");
		   if (existing) {
			existing.addEventListener("click", handleClick);
			existing.addEventListener("touchstart", preventTouch, { passive: false });
			existing.addEventListener("touchend", handleClick);
			minimapMiniBtn = existing;
			return existing;
		   }
		   const panel = document.querySelector(".topology-panel");
		   if (!panel) return null;
		   const btn = document.createElement("button");
		   btn.type = "button";
		   btn.id = "minimap-mini";
		   btn.className = "legend-mini-btn";
		   btn.textContent = "Map";
		   btn.style.right = "10px";
		   btn.style.left = "auto";
		   btn.style.bottom = "10px";
		   btn.addEventListener("click", handleClick);
		   btn.addEventListener("touchstart", preventTouch, { passive: false });
		   btn.addEventListener("touchend", handleClick);
		   panel.appendChild(btn);
		   minimapMiniBtn = btn;
		   return btn;
		}
      
			  function ensureDrawToolbarMiniButton() {
		   if (drawToolbarMiniBtn) return drawToolbarMiniBtn;
		   const handleClick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			drawToolbarCollapsed = false;
			updateDrawToolbarVisibility();
		   };
		   const preventTouch = (e) => { e.preventDefault(); };
		   const existing = document.getElementById("draw-toolbar-mini");
		   if (existing) {
			existing.addEventListener("click", handleClick);
			existing.addEventListener("touchstart", preventTouch, { passive: false });
			existing.addEventListener("touchend", handleClick);
			drawToolbarMiniBtn = existing;
			return existing;
		   }
		   const panel = document.querySelector(".topology-panel");
		   if (!panel) return null;
		   const btn = document.createElement("button");
		   btn.type = "button";
		   btn.id = "draw-toolbar-mini";
		   btn.className = "legend-mini-btn";
		   btn.textContent = "Draw";
		   btn.style.top = "10px";
		   btn.style.left = "10px";
		   btn.style.right = "auto";
		   btn.addEventListener("click", handleClick);
		   btn.addEventListener("touchstart", preventTouch, { passive: false });
		   btn.addEventListener("touchend", handleClick);
		   panel.appendChild(btn);
		   drawToolbarMiniBtn = btn;
		   return btn;
		}
			  
		  function ensureTopologyToolbarMiniButton() {
	   if (topologyToolbarMiniBtn) return topologyToolbarMiniBtn;
	   const handleClick = (e) => {
		e.stopPropagation();
		e.preventDefault();
		topologyToolbarCollapsed = false;
		updateTopologyToolbarVisibility();
	   };
	   const preventTouch = (e) => { e.preventDefault(); };
	   const existing = document.getElementById("topology-toolbar-mini");
	   if (existing) {
		existing.addEventListener("click", handleClick);
		existing.addEventListener("touchstart", preventTouch, { passive: false });
		existing.addEventListener("touchend", handleClick);
		topologyToolbarMiniBtn = existing;
		return existing;
	   }
	   const panel = document.querySelector(".topology-panel");
	   if (!panel) return null;
	   const btn = document.createElement("button");
	   btn.type = "button";
	   btn.id = "topology-toolbar-mini";
	   btn.className = "legend-mini-btn";
	   btn.textContent = "Add Line";
	   btn.style.top = "10px";
	   btn.style.left = "auto";
	   btn.style.right = "40px";
	   btn.addEventListener("click", handleClick);
	   btn.addEventListener("touchstart", preventTouch, { passive: false });
	   btn.addEventListener("touchend", handleClick);
	   panel.appendChild(btn);
	   topologyToolbarMiniBtn = btn;
	   return btn;
	}
		  
      function updateToolbarStack() {
       if (!isMobileDevice()) return;
       const draw = document.getElementById("draw-toolbar");
       const topo = document.getElementById("topology-toolbar");
       if (!draw || !topo) return;
       const h = draw.getBoundingClientRect().height;
       document.documentElement.style.setProperty("--draw-toolbar-height", h + "px");
      }
      window.addEventListener("resize", updateToolbarStack);
      window.addEventListener("DOMContentLoaded", updateToolbarStack);
      updateToolbarStack();
      
      function updateLegendVisibility() {
       const legend = document.getElementById("edge-legend");
       const mini = ensureLegendMiniButton();
       if (!legend || !mini) return;
       const hasItems = legend.querySelectorAll(".legend-item").length > 0;
       if (!hasItems) {
        legend.style.display = "none";
        mini.style.display = "none";
        return;
       }
       if (legendCollapsed) {
        legend.style.display = "none";
        mini.style.display = "inline-flex";
       } else {
        legend.style.display = "flex";
        mini.style.display = "none";
       }
      }
      
      function updateMinimapVisibility() {
       const wrapper = document.getElementById("minimap-zoom-wrapper");
       const mini = ensureMinimapMiniButton();
       if (!wrapper || !mini) return;
       if (minimapCollapsed) {
        wrapper.style.display = "none";
        mini.style.display = "inline-flex";
       } else {
        wrapper.style.display = "block";
        mini.style.display = "none";
       }
      }
      
      function updateDrawToolbarVisibility() {
       const toolbar = document.getElementById("draw-toolbar");
       const mini = ensureDrawToolbarMiniButton();
       if (!toolbar || !mini) return;
       if (typeof isViewOnly === 'function' && isViewOnly()) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "none";
        return;
       }
       if (drawToolbarCollapsed) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "inline-flex";
       } else {
      if (isMobileDevice()) {    	   
        toolbar.style.setProperty('display', 'grid', 'important');
        mini.style.display = "none";
        } else {   
        toolbar.style.setProperty('display', 'flex', 'important');
        mini.style.display = "none";	  
      }
       }
      }
      
      function u8ToBase64(u8) {
      let binary = "";
      for (let i = 0; i < u8.length; i++) binary += String.fromCharCode(u8[i]);
      return btoa(binary);
      }
      
      function base64ToU8(base64) {
      const binary = atob(base64);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
      return bytes;
      }  
      
      function updateTopologyToolbarVisibility() {
       const toolbar = document.getElementById("topology-toolbar");
       const mini = ensureTopologyToolbarMiniButton();
       if (!toolbar || !mini) return;
       if (typeof isViewOnly === 'function' && isViewOnly()) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "none";
        return;
       }
       const hasSelectedNode = currentNodeId !== null;
       if (!hasSelectedNode) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "none";
       } else if (topologyToolbarCollapsed) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "inline-flex";
       } else {   
      if (isMobileDevice()) {    	   
        toolbar.style.setProperty('display', 'grid', 'important');
        mini.style.display = "none";
        } else {   
        toolbar.style.setProperty('display', 'flex', 'important');
        mini.style.display = "none";	  
      }
       }
      }
      const DEFAULT_CANVAS_HINT = document.getElementById("canvas-hint")?.innerHTML || "";
      const DEFAULT_PAGE_STATE = {
       title: "The One File: The Networkening",
       background: "",
       topbarBg: "rgba(9, 12, 20, 0.9)",
       topbarBorder: "#1f2533",
       panel: "#0b0e13",
       panelAlt: "#10141b",
       accent: "#4fd1c5",
       sidebarBg: "#10141b",
       btnBg: "#0b0e13",
       btnText: "#e2e8f0",
       tagFill: "#1e293b",
       tagText: "#e2e8f0",
       tagBorder: "#475569",
       inputBg: "#0b0e13",
       inputText: "#e2e8f0",
       inputBorder: "#1f2937",
       inputFont: "Inter, system-ui, sans-serif",
       inputFontSize: 14,
       toolbarBg: "#0f172a",
       toolbarBorder: "#1f2937",
       toolbarText: "#94a3b8",
       toolbarBtnBg: "#0b0e13",
       toolbarBtnText: "#e2e8f0",
       minimapDots: "#94a3b8",
       canvasHintEnabled: true,
       canvasHintText: "",
       canvasHintBg: "#0f172a",
       canvasHintColor: "#94a3b8",
       danger: "#f56565",
       textMain: "#e2e8f0",
       textSoft: "#94a3b8",
       topbarHeight: 52,
       sidebarWidth: 350,
       mobileFooterHeight: 40,
       sidebarCollapsed: false,
       nodeFill: "#1e293b",
       nodeStroke: "#475569",
       nodeTitle: "#e2e8f0",
       nodeSub: "#94a3b8",
       nodeTitleSize: 18,
       nodeSubSize: 13,
       nodeFont: "Inter, system-ui, sans-serif",
       defaultEdge: "#475569",
       selectionHandle: "#f59e0b",
       selectionHandleSize: 8,
       groupIndicator: "#4fd1c5",
       canvasGradientTop: "#1e2532",
       canvasGradientBottom: "#050608",
       canvasBorder: "#475569",
       canvasGrid: "#475569",
       canvasGridSize: 50,
       rackFrameFill: "#0f172a",
       rackFrameStroke: "#4fd1c5",
       rackLineColor: "#475569",
       rackTextColor: "#4fd1c5",
	   viewOnly: false,
      };
      let PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE);
	  function isViewOnly() {
       return PAGE_STATE.viewOnly === true;
      }
      
      let viewOnlyClickCount = 0;
      let viewOnlyClickTimer = null;
      let viewOnlyClickTarget = null;
      
      function handleViewOnlyClick(id, type) {
       if (!isViewOnly()) return false;
       
       if (viewOnlyClickTarget !== id) {
        viewOnlyClickCount = 0;
        viewOnlyClickTarget = id;
       }
       
       viewOnlyClickCount++;
       
       clearTimeout(viewOnlyClickTimer);
       viewOnlyClickTimer = setTimeout(() => {
        viewOnlyClickCount = 0;
        viewOnlyClickTarget = null;
       }, 2000);
       
       if (viewOnlyClickCount >= 5) {
        viewOnlyClickCount = 0;
        viewOnlyClickTarget = null;
        
        document.body.classList.add("view-only-inspect");
        
        if (type === 'node') {
         currentNodeId = id;
         const data = NODE_DATA[id];
         if (data) {
          document.querySelectorAll(".node-group").forEach((n) => {
           n.classList.toggle("active", n.dataset.nodeId === id);
          });
          document.getElementById("node-panel").style.display = "block";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("node-name").textContent = data.name;
          document.getElementById("node-ip").textContent = data.ip;
          document.getElementById("node-role").textContent = data.role;
          document.getElementById("node-mac").textContent = data.mac || "--";
          document.getElementById("node-rack").textContent = data.rackUnit || "--";
          document.getElementById("node-uheight").textContent = (data.uHeight || "1") + "U";
          
          const tagList = document.getElementById("node-tags");
          if (tagList) {
           tagList.innerHTML = "";
           if (data.tags && data.tags.length > 0) {
            data.tags.forEach((tag) => {
             const li = document.createElement("li");
             li.textContent = tag;
             tagList.appendChild(li);
            });
           }
          }
          
          const noteList = document.getElementById("node-notes");
          if (noteList) {
           noteList.innerHTML = "";
           if (data.notes && data.notes.length > 0) {
            data.notes.forEach((note) => {
             const li = document.createElement("li");
             li.textContent = note;
             noteList.appendChild(li);
            });
           }
          }
         }
        } else if (type === 'edge') {
         currentEdgeId = id;
         const edge = EDGE_DATA.list.find(e => e.id === id);
         if (edge) {
          document.querySelectorAll(".edge").forEach((e) => {
           e.classList.toggle("active", e.dataset.edgeId === id);
          });
          document.getElementById("edge-panel").style.display = "block";
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-from").textContent = NODE_DATA[edge.from]?.name || edge.from;
          document.getElementById("edge-to").textContent = NODE_DATA[edge.to]?.name || edge.to;
          document.getElementById("edge-label").value = edge.label || "";
         }
        }
        return true;
       }
       return false;
      }
      const CANVAS_WIDTH = 4000;
      let CANVAS_HEIGHT = 3000;
      const BASE_CANVAS_HEIGHT = 3000;
      const CANVAS_PADDING = 100;
      
      const RACK_U_HEIGHT = 70;
      const RACK_WIDTH = 600;
      const RACK_START_X = CANVAS_WIDTH / 2;
      const RACK_START_Y = CANVAS_PADDING + 100;
      function getRackUHeight(rackId) {
      const capacity = getRackCapacity(rackId);
      const availableHeight = CANVAS_HEIGHT - RACK_START_Y - 200;
      return Math.floor(availableHeight / capacity);
      }
      let canvasState = {
       zoom: 1,
       panX: 0,
       panY: 0,
       minZoom: 0.25,
       maxZoom: 4,
       isPanning: false,
       panStartX: 0,
       panStartY: 0,
       spacePressed: false,
      };
      
      function getViewBox() {
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       return {
        x: canvasState.panX,
        y: canvasState.panY,
        width: viewWidth,
        height: viewHeight,
       };
      }
      
      function updateViewBox() {
       const svg = document.getElementById("map");
       const vb = getViewBox();
       svg.setAttribute("viewBox", `${vb.x} ${vb.y} ${vb.width} ${vb.height}`, );
       const zoomLevel = document.getElementById("zoom-level");
       if (zoomLevel) {
        zoomLevel.textContent = Math.round(canvasState.zoom * 100) + "%";
       }
       updateMinimap();
      }
      
      function updateMinimap() {
       const minimapViewport = document.getElementById("minimap-viewport");
       const minimapSvg = document.getElementById("minimap");
       if (!minimapViewport || !minimapSvg) return;
       const vb = getViewBox();
       minimapViewport.setAttribute("x", vb.x);
       minimapViewport.setAttribute("y", vb.y);
       minimapViewport.setAttribute("width", vb.width);
       minimapViewport.setAttribute("height", vb.height);
       const minimapNodes = minimapSvg.querySelectorAll(".minimap-node");
       minimapNodes.forEach((n) => n.remove());
       const minimapEdges = minimapSvg.querySelectorAll(".minimap-edge");
       minimapEdges.forEach((e) => e.remove());
       
       EDGE_DATA.list.forEach((edge) => {
        if (edge.type === "custom") return;
        
        const fromNode = NODE_DATA[edge.from];
        const toNode = NODE_DATA[edge.to];
        if (!fromNode || !toNode) return;
        
        if (currentView.mode === "rack") {
         if (fromNode.assignedRack !== currentView.rackId || 
             toNode.assignedRack !== currentView.rackId) {
          return;
         }
        } else {
         if (fromNode.assignedRack || toNode.assignedRack) {
          return;
         }
        }
        
        const p1 = savedPositions[edge.from];
        const p2 = savedPositions[edge.to];
        if (!p1 || !p2) return;
        const line = document.createElementNS("http://www.w3.org/2000/svg", "line", );
        line.setAttribute("x1", p1.x);
        line.setAttribute("y1", p1.y);
        line.setAttribute("x2", p2.x);
        line.setAttribute("y2", p2.y);
        line.classList.add("minimap-edge");
        minimapSvg.insertBefore(line, minimapViewport);
       });
      
       Object.entries(savedPositions).forEach(([id, pos]) => {
        const node = NODE_DATA[id];
        if (!node) return;
        
        if (currentView.mode === "rack") {
         if (node.assignedRack !== currentView.rackId) {
          return;
         }
        } else {
         if (node.assignedRack) {
          return;
         }
        }
        
        const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle", );
        circle.setAttribute("cx", pos.x);
        circle.setAttribute("cy", pos.y);
        circle.setAttribute("r", 40);
        circle.classList.add("minimap-node");
        minimapSvg.insertBefore(circle, minimapViewport);
       });
      }
      
      function zoomTo(newZoom, centerX, centerY) {
       const oldZoom = canvasState.zoom;
       newZoom = Math.max(canvasState.minZoom, Math.min(canvasState.maxZoom, newZoom), );
       if (centerX !== undefined && centerY !== undefined) {
        const oldWidth = CANVAS_WIDTH / oldZoom;
        const oldHeight = CANVAS_HEIGHT / oldZoom;
        const newWidth = CANVAS_WIDTH / newZoom;
        const newHeight = CANVAS_HEIGHT / newZoom;
        const pointX = canvasState.panX + centerX * oldWidth;
        const pointY = canvasState.panY + centerY * oldHeight;
        canvasState.panX = pointX - centerX * newWidth;
        canvasState.panY = pointY - centerY * newHeight;
       }
       canvasState.zoom = newZoom;
       constrainPan();
       updateViewBox();
      }
      
      function constrainPan() {
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       const minVisiblePortion = 0.1;
       const maxPanX = CANVAS_WIDTH - viewWidth * minVisiblePortion;
       const maxPanY = CANVAS_HEIGHT - viewHeight * minVisiblePortion;
       const minPanX = -viewWidth * (1 - minVisiblePortion);
       const minPanY = -viewHeight * (1 - minVisiblePortion);
       canvasState.panX = Math.max(minPanX, Math.min(maxPanX, canvasState.panX), );
       canvasState.panY = Math.max(minPanY, Math.min(maxPanY, canvasState.panY), );
      }
      
      function fitToContent() {
       const positions = Object.values(savedPositions);
       if (positions.length === 0) {
        resetView();
        return;
       }
       let minX = Infinity,
        minY = Infinity,
        maxX = -Infinity,
        maxY = -Infinity;
       positions.forEach((pos) => {
        minX = Math.min(minX, pos.x - 100);
        minY = Math.min(minY, pos.y - 100);
        maxX = Math.max(maxX, pos.x + 100);
        maxY = Math.max(maxY, pos.y + 100);
       });
       const contentWidth = maxX - minX + 200;
       const contentHeight = maxY - minY + 200;
       const viewport = document.getElementById("canvas-viewport");
       const vpRect = viewport.getBoundingClientRect();
       const aspectRatio = vpRect.width / vpRect.height;
       const contentAspect = contentWidth / contentHeight;
       let newZoom;
       if (contentAspect > aspectRatio) {
        newZoom = (vpRect.width / contentWidth) * (CANVAS_WIDTH / vpRect.width);
       } else {
        newZoom = (vpRect.height / contentHeight) * (CANVAS_HEIGHT / vpRect.height);
       }
       newZoom = Math.max(canvasState.minZoom, Math.min(2, newZoom));
       const viewWidth = CANVAS_WIDTH / newZoom;
       const viewHeight = CANVAS_HEIGHT / newZoom;
       canvasState.zoom = newZoom;
       canvasState.panX = minX - 100 - (viewWidth - contentWidth) / 2;
       canvasState.panY = minY - 100 - (viewHeight - contentHeight) / 2;
       constrainPan();
       updateViewBox();
      }
      
      function resetView() {
       canvasState.zoom = 1;
       canvasState.panX = 0;
       canvasState.panY = 0;
       updateViewBox();
      }
      window.addEventListener("DOMContentLoaded", () => {
       const toggle = document.getElementById("mobile-menu-toggle");
       const menu = document.getElementById("topbar-menu");
       if (!toggle || !menu) return;
       toggle.addEventListener("click", () => {
        menu.classList.toggle("open");
       });
       menu.addEventListener("click", (e) => {
        const target = e.target.closest("a, button");
        if (!target) return;
        if (isMobileDevice()) {
       menu.classList.remove("open");
      }
       });
       const minimapCloseBtn = document.getElementById("minimap-close-btn");
       if (minimapCloseBtn) {
        const handleMinimapClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         minimapCollapsed = true;
         updateMinimapVisibility();
        };
        minimapCloseBtn.addEventListener("click", handleMinimapClose);
        minimapCloseBtn.addEventListener("touchend", handleMinimapClose);
       }
       const drawToolbarCloseBtn = document.getElementById("draw-toolbar-close-btn");
       if (drawToolbarCloseBtn) {
        const handleDrawClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         drawToolbarCollapsed = true;
         updateDrawToolbarVisibility();
        };
        drawToolbarCloseBtn.addEventListener("click", handleDrawClose);
        drawToolbarCloseBtn.addEventListener("touchend", handleDrawClose);
       }
       const topologyToolbarCloseBtn = document.getElementById("topology-toolbar-close-btn");
       if (topologyToolbarCloseBtn) {
        const handleTopologyClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         topologyToolbarCollapsed = true;
         updateTopologyToolbarVisibility();
        };
        topologyToolbarCloseBtn.addEventListener("click", handleTopologyClose);
        topologyToolbarCloseBtn.addEventListener("touchstart", (e) => e.preventDefault(), {
         passive: false
        });
        topologyToolbarCloseBtn.addEventListener("touchend", handleTopologyClose);
       }
      
       updateMinimapVisibility();
       updateDrawToolbarVisibility();
       updateTopologyToolbarVisibility();
      });
      
      function applyLayerFilter() {  
       activeLayers.clear(); 
       if (document.getElementById("layer-physical").checked) activeLayers.add("physical");    
       if (document.getElementById("layer-logical").checked) activeLayers.add("logical");    
       if (document.getElementById("layer-security").checked) activeLayers.add("security");     
       if (document.getElementById("layer-application").checked) activeLayers.add("application");
       forgeTheTopology();    
      }
      
      function isNodeVisible(nodeId) {  
       const node = NODE_DATA[nodeId];    
       if (!node) return false;     
       const nodeLayer = node.layer || "physical";     
       return activeLayers.has(nodeLayer);     
      }
      
      function enterRack(rackId) {
      if (!NODE_DATA[rackId] || !NODE_DATA[rackId].isRack) return;
      const rackCapacity = getRackCapacity(rackId);
      const neededHeight = RACK_START_Y + (rackCapacity * RACK_U_HEIGHT) + 200;
      if (neededHeight > BASE_CANVAS_HEIGHT) {
      CANVAS_HEIGHT = neededHeight;
      }
       
       currentView.mode = "rack";
       currentView.rackId = rackId;
       
       const backBtn = document.getElementById("back-to-topology-btn");
       if (backBtn) backBtn.style.display = "inline-block";
       
       const hint = document.getElementById("canvas-hint");
       if (hint) {
        hint.textContent = `Viewing: ${NODE_DATA[rackId].name} | Double click empty space to exit`;
        hint.classList.add("visible");
       }
       
      
      const rackUHeight = getRackUHeight(rackId);
      const rackHeight = rackCapacity * rackUHeight;
      const rackCenterX = RACK_START_X;
      const rackCenterY = RACK_START_Y + (rackHeight / 2);
       
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       
       canvasState.panX = rackCenterX - (viewWidth / 2);
       canvasState.panY = rackCenterY - (viewHeight / 2);
       
       constrainPan();
       updateViewBox();
       
       forgeTheTopology();
      }
      
      function exitRack() {
      CANVAS_HEIGHT = BASE_CANVAS_HEIGHT;
      currentView.mode = "topology";
      currentView.rackId = null;
       
       const backBtn = document.getElementById("back-to-topology-btn");
       if (backBtn) backBtn.style.display = "none";
       
       const hint = document.getElementById("canvas-hint");
       if (hint) {
        hint.classList.remove("visible");
       }
       
       if (savedTopologyView) {
        canvasState.zoom = savedTopologyView.zoom;
        canvasState.panX = savedTopologyView.panX;
        canvasState.panY = savedTopologyView.panY;
        updateViewBox();
       }
       
       forgeTheTopology();
      }
      
      function getRackCapacity(rackId) {
       const node = NODE_DATA[rackId];
       return node && node.rackCapacity ? parseInt(node.rackCapacity) : 42;
      }
      
      function populateRackDropdown() {
       const dropdown = document.getElementById("node-assigned-rack");
       if (!dropdown) return;
       
       dropdown.innerHTML = '<option value="">None</option>';
       
       Object.keys(NODE_DATA).forEach(id => {
        if (NODE_DATA[id].isRack) {
         const option = document.createElement("option");
         option.value = id;
         option.textContent = NODE_DATA[id].name;
         dropdown.appendChild(option);
        }
       });
      }
      
      function wieldThePower() {
       const root = document.documentElement;
       root.style.setProperty("--panel", PAGE_STATE.panel);
       root.style.setProperty("--panel-alt", PAGE_STATE.panelAlt);
       root.style.setProperty("--sidebar-bg", PAGE_STATE.sidebarBg || PAGE_STATE.panelAlt);
       root.style.setProperty("--btn-bg", PAGE_STATE.btnBg || PAGE_STATE.panel);
       root.style.setProperty("--btn-text", PAGE_STATE.btnText || "#e2e8f0");
       root.style.setProperty("--tag-fill", PAGE_STATE.tagFill || "#1e293b");
       root.style.setProperty("--tag-text", PAGE_STATE.tagText || "#e2e8f0");
       root.style.setProperty("--tag-border", PAGE_STATE.tagBorder || "#475569");
       root.style.setProperty("--input-bg", PAGE_STATE.inputBg || "#0b0e13");
       root.style.setProperty("--input-text", PAGE_STATE.inputText || "#e2e8f0");
       root.style.setProperty("--input-border", PAGE_STATE.inputBorder || "#1f2937");
       root.style.setProperty("--input-font", PAGE_STATE.inputFont || "Inter, system-ui, sans-serif");
       root.style.setProperty("--input-font-size", (PAGE_STATE.inputFontSize || 14) + "px");
       root.style.setProperty("--toolbar-bg", PAGE_STATE.toolbarBg || "#0f172a");
       root.style.setProperty("--toolbar-border", PAGE_STATE.toolbarBorder || "#1f2937");
       root.style.setProperty("--toolbar-text", PAGE_STATE.toolbarText || "#94a3b8");
       root.style.setProperty("--toolbar-btn-bg", PAGE_STATE.toolbarBtnBg || "#0b0e13");
       root.style.setProperty("--toolbar-btn-text", PAGE_STATE.toolbarBtnText || "#e2e8f0");
       root.style.setProperty("--minimap-dots", PAGE_STATE.minimapDots || "#94a3b8");
       root.style.setProperty("--canvas-hint-bg", PAGE_STATE.canvasHintBg || "#0f172a");
       root.style.setProperty("--canvas-hint-color", PAGE_STATE.canvasHintColor || "#94a3b8");
       
       const canvasHint = document.getElementById("canvas-hint");
       if (canvasHint) {
        canvasHint.style.display = PAGE_STATE.canvasHintEnabled === false ? "none" : "";
        if (PAGE_STATE.canvasHintText !== undefined && PAGE_STATE.canvasHintText !== "") {
         canvasHint.innerHTML = PAGE_STATE.canvasHintText;
        } else {
         canvasHint.innerHTML = DEFAULT_CANVAS_HINT;
        }
       }
       root.style.setProperty("--accent", PAGE_STATE.accent);
       root.style.setProperty("--danger", PAGE_STATE.danger);
       root.style.setProperty("--text-main", PAGE_STATE.textMain);
       root.style.setProperty("--text-soft", PAGE_STATE.textSoft);
       root.style.setProperty("--topbar-bg", PAGE_STATE.topbarBg);
       root.style.setProperty("--topbar-border", PAGE_STATE.topbarBorder);
       root.style.setProperty("--node-fill", PAGE_STATE.nodeFill || "#1e293b");
       root.style.setProperty("--node-stroke", PAGE_STATE.nodeStroke || "#475569");
       root.style.setProperty("--node-title", PAGE_STATE.nodeTitle || "#e2e8f0");
       root.style.setProperty("--node-sub", PAGE_STATE.nodeSub || "#94a3b8");
       root.style.setProperty("--node-title-size", (PAGE_STATE.nodeTitleSize || 18) + "px");
       root.style.setProperty("--node-sub-size", (PAGE_STATE.nodeSubSize || 13) + "px");
       root.style.setProperty("--node-font", PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif");
       root.style.setProperty("--default-edge", PAGE_STATE.defaultEdge || "#475569");
       root.style.setProperty("--selection-handle", PAGE_STATE.selectionHandle || "#f59e0b");
       root.style.setProperty("--selection-handle-size", (PAGE_STATE.selectionHandleSize || 8) + "px");
       root.style.setProperty("--group-indicator", PAGE_STATE.groupIndicator || "#4fd1c5");
       const topbarHeight = PAGE_STATE.topbarHeight || 52;
       const sidebarWidth = PAGE_STATE.sidebarWidth || 350;
       const mobileFooterHeight = PAGE_STATE.mobileFooterHeight || 40;
       root.style.setProperty("--topbar-height", topbarHeight + "px");
       root.style.setProperty("--sidebar-width", sidebarWidth + "px");
       root.style.setProperty("--mobile-footer-height", mobileFooterHeight + "vh", );
       const mainEl = document.querySelector("main");
       const detailsPanel = document.getElementById("details-panel");
       const sidebarToggle = document.getElementById("sidebar-toggle");
       if (PAGE_STATE.sidebarCollapsed) {
        if (mainEl) mainEl.classList.add("sidebar-collapsed");
        if (detailsPanel) detailsPanel.classList.add("collapsed");
        if (sidebarToggle) {
         sidebarToggle.classList.add("collapsed");
         sidebarToggle.textContent = "‚ñ∂";
        }
       } else {
        if (mainEl) mainEl.classList.remove("sidebar-collapsed");
        if (detailsPanel) detailsPanel.classList.remove("collapsed");
        if (sidebarToggle) {
         sidebarToggle.classList.remove("collapsed");
         sidebarToggle.textContent = "‚óÄ";
        }
       }
       if (PAGE_STATE.background) {
        document.body.style.background = PAGE_STATE.background;
       } else {
        document.body.style.background = `radial-gradient(circle at top, ${PAGE_STATE.canvasGradientTop || "#1e2532"} 0, ${PAGE_STATE.canvasGradientBottom || "#050608"} 70%)`;
       }
       document.title = PAGE_STATE.title || DEFAULT_PAGE_STATE.title;
       const titleEl = document.getElementById("page-title");
       if (titleEl) {
        titleEl.textContent = PAGE_STATE.title || DEFAULT_PAGE_STATE.title;
       }
       const viewOnlyMode = PAGE_STATE.viewOnly === true;
       const addNodeBtn = document.getElementById("add-node-btn");
       const addRackBtn = document.getElementById("add-rack-btn");
       const bulkToolbar = document.getElementById("bulk-toolbar");
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       
       if (viewOnlyMode) {
        if (addNodeBtn) addNodeBtn.style.display = "none";
        if (addRackBtn) addRackBtn.style.display = "none";
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        ["draw-toolbar-mini", "topology-toolbar-mini"].forEach(id => {
         const el = document.getElementById(id);
         if (el) el.style.display = "none";
        });
        document.body.classList.remove("view-only-inspect");
       } else {
        if (addNodeBtn) addNodeBtn.style.display = "";
        if (addRackBtn) addRackBtn.style.display = "";
       }
       
       document.body.classList.toggle("view-only-mode", viewOnlyMode);
       
       if (!viewOnlyMode) {
        if (typeof updateDrawToolbarVisibility === 'function') updateDrawToolbarVisibility();
        if (typeof updateTopologyToolbarVisibility === 'function') updateTopologyToolbarVisibility();
       }
      }
      (async function awakeTheImmortal() {
       let initialState = {};
       let decryptionCancelled = false;
       const stateEl = document.getElementById("topology-state");
       if (stateEl && stateEl.textContent.trim()) {
        try {
         let stateText = stateEl.textContent.trim();
         if (isEncrypted(stateText)) {
          let decrypted = false;
          let attempts = 0;
          const maxAttempts = 3;
          while (!decrypted && attempts < maxAttempts) {
           const password = prompt("This file is encrypted. Enter password to decrypt:\n(Attempt " + (attempts + 1) + " of " + maxAttempts + ")", );
           if (!password) {
            alert("Decryption cancelled. The file will not be loaded.", );
            decryptionCancelled = true;
            break;
           }
           try {
            stateText = await decryptData(stateText, password);
            decrypted = true;
           } catch (e) {
            attempts++;
            if (attempts < maxAttempts) {
             alert("Incorrect password. Please try again.");
            } else {
             alert("Maximum attempts reached. The file will not be loaded.", );
             decryptionCancelled = true;
            }
           }
          }
          if (!decrypted) {
           stateText = "{}";
          }
         }
         initialState = JSON.parse(stateText);
        } catch (e) {
         console.error("Failed to load state:", e);
         initialState = {};
        }
       }
       if (decryptionCancelled) {
        NODE_DATA = {};
        EDGE_DATA = {
         list: []
        };
        RECT_DATA = { list: [] };
        TEXT_DATA = { list: [] };
        EDGE_LEGEND = {};
        savedPositions = {};
        savedSizes = {};
        savedStyles = {};
       } else {
        NODE_DATA = initialState.nodeData ? initialState.nodeData : BASE_NODE_DATA;
        
        Object.keys(NODE_DATA).forEach(nodeId => {
         if (!NODE_DATA[nodeId].ping) {
          NODE_DATA[nodeId].ping = {
           enabled: false,
           protocol: 'http',
           customUrl: '',
           timeout: 3000,
           status: 'unknown',
           lastCheck: null
          };
         }
        });
        
        EDGE_DATA = initialState.edgeData ? initialState.edgeData : {
         list: [],
        };
        RECT_DATA = initialState.rectData ? initialState.rectData : { list: [] };
        TEXT_DATA = initialState.textData ? initialState.textData : { list: [] };
        EDGE_LEGEND = initialState.edgeLegend || {};
        savedPositions = initialState.nodePositions || {};
        savedSizes = initialState.nodeSizes || {};
        savedStyles = initialState.nodeStyles || {};
        if (initialState.iconCache) {
         IconLibrary.iconCache = initialState.iconCache;
        }
       }
       if (initialState.page) {
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, initialState.page, );
       }
       
       if (PAGE_STATE.autoPingEnabled !== undefined) {
        autoPingEnabled = PAGE_STATE.autoPingEnabled;
       }
       if (PAGE_STATE.autoPingInterval !== undefined) {
        autoPingInterval = PAGE_STATE.autoPingInterval;
       }
       
       if (initialState.canvas) {
        canvasState.zoom = initialState.canvas.zoom || 1;
        canvasState.panX = initialState.canvas.panX || 0;
        canvasState.panY = initialState.canvas.panY || 0;
       }
       
       if (initialState.savedTopologyView) {
        savedTopologyView = initialState.savedTopologyView;
       }
       
       if (initialState.documentTabs) {
        documentTabs = initialState.documentTabs;
        if (initialState.currentTabIndex !== undefined) {
          currentTabIndex = initialState.currentTabIndex;
          const currentTab = documentTabs[currentTabIndex];
          if (currentTab) {
            NODE_DATA = currentTab.nodes || NODE_DATA;
            EDGE_DATA = currentTab.edges || EDGE_DATA;
            savedPositions = currentTab.positions || savedPositions;
            savedSizes = currentTab.sizes || savedSizes;
            savedStyles = currentTab.styles || savedStyles;
            EDGE_LEGEND = currentTab.legend || EDGE_LEGEND;
            RECT_DATA = currentTab.rects || RECT_DATA;
            TEXT_DATA = currentTab.texts || TEXT_DATA;
            if (currentTab.pageState) PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, currentTab.pageState);
          }
        }
       }
       
       if (initialState.encryptedSections) {
        encryptedSections = initialState.encryptedSections;
       }
       
       wieldThePower();
       forgeTheTopology();
       updateViewBox();
       
       MobileManager.applyAll();
       
       if (autoPingEnabled) {
        startAutoPing();
       }
       
       const initialNodes = Object.keys(NODE_DATA);
       if (initialNodes.length > 0) {
        claimTheImmortal(initialNodes.includes("host") ? "host" : initialNodes[0], );
       } else {
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.display = "none";
       }
      })();
      
      let resizeDebounceTimer = null;
      window.addEventListener("resize", () => {
        clearTimeout(resizeDebounceTimer);
        resizeDebounceTimer = setTimeout(() => {
          MobileManager.applyAll();
          if (typeof updateDrawToolbarVisibility === 'function') updateDrawToolbarVisibility();
          if (typeof updateTopologyToolbarVisibility === 'function') updateTopologyToolbarVisibility();
        }, 100);
      });
      
      function getBreakpointKey() {
       const w = window.innerWidth;
       if (w <= 380) return "fold";
       if (w <= 768) return "mobile";
       if (w <= 1024) return "tablet";
       return "desktop";
      }
      
      function resolveStylesEntry(styleEntry) {
       if (!styleEntry) return {};
       if (styleEntry.circleColor || styleEntry.titleColor || styleEntry.titleFont || styleEntry.titleSize || styleEntry.subColor || styleEntry.subFont || styleEntry.subSize) {
        return styleEntry;
       }
       const bp = getBreakpointKey();
       const base = styleEntry.all || {};
       const bpStyles = styleEntry[bp] || {};
       return Object.assign({}, base, bpStyles);
      }
      
      function resolveStylesForNode(id) {
       const styleEntry = savedStyles[id];
       if (!styleEntry) return {};
       return resolveStylesEntry(styleEntry);
      }
      
      function ensureStyleEntry(id) {
       if (!savedStyles[id]) savedStyles[id] = {};
       const entry = savedStyles[id];
       const flatProps = ["circleColor", "circleBorder", "titleColor", "titleFont", "titleSize", "subColor", "subFont", "subSize", ];
       const isFlat = flatProps.some((p) => Object.prototype.hasOwnProperty.call(entry, p), );
       if (isFlat) {
        const all = entry.all || {};
        flatProps.forEach((p) => {
         if (entry[p] !== undefined) {
          all[p] = entry[p];
          delete entry[p];
         }
        });
        entry.all = all;
       }
       return entry;
      }
      
      function getDefaultSize() {
       if (window.innerWidth <= 380) return 120;
       if (window.innerWidth <= 768) return 140;
       if (window.innerWidth <= 1024) return 70;
       return 55;
      }
      
      function createShapeElement(shape, size) {
       const ns = "http://www.w3.org/2000/svg";
       if (shape === "circle") {
        const c = document.createElementNS(ns, "circle");
        c.setAttribute("r", size);
        return c;
       }
       if (shape === "square") {
        const r = document.createElementNS(ns, "rect");
        const s = size * 2;
        r.setAttribute("x", -size);
        r.setAttribute("y", -size);
        r.setAttribute("width", s);
        r.setAttribute("height", s);
        r.setAttribute("rx", 4);
        return r;
       }
       if (shape === "rectangle") {
        const r = document.createElementNS(ns, "rect");
        r.setAttribute("x", -size * 1.4);
        r.setAttribute("y", -size * 0.8);
        r.setAttribute("width", size * 2.8);
        r.setAttribute("height", size * 1.6);
        r.setAttribute("rx", 6);
        return r;
       }
       if (shape === "triangle") {
        const p = document.createElementNS(ns, "polygon");
        const h = size * 1.8;
        const w = size * 2;
        p.setAttribute("points", `0,${-h} ${w / 2},${h / 2} ${-w / 2},${h / 2}`, );
        return p;
       }
       if (shape === "hexagon") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        const pts = [
         [0, -s],
         [s * 0.86, -s * 0.5],
         [s * 0.86, s * 0.5],
         [0, s],
         [-s * 0.86, s * 0.5],
         [-s * 0.86, -s * 0.5],
        ].map((pt) => pt.join(",")).join(" ");
        p.setAttribute("points", pts);
        return p;
       }
       if (shape === "stop-sign") {
        const p = document.createElementNS(ns, "polygon");
        const r = size;
        const ptsArr = [];
        for (let i = 0; i < 8; i++) {
         const a = (Math.PI / 4) * i + Math.PI / 8;
         ptsArr.push([Math.cos(a) * r, Math.sin(a) * r]);
        }
        const pts = ptsArr.map((pt) => pt.join(",")).join(" ");
        p.setAttribute("points", pts);
        return p;
       }
       if (shape === "star") {
        const p = document.createElementNS(ns, "polygon");
        const outer = size;
        const inner = size * 0.45;
        let pts = "";
        for (let i = 0; i < 10; i++) {
         const a = (Math.PI / 5) * i - Math.PI / 2;
         const r = i % 2 === 0 ? outer : inner;
         pts += `${Math.cos(a) * r},${Math.sin(a) * r} `;
        }
        p.setAttribute("points", pts.trim());
        return p;
       }
       if (shape === "diamond") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `0,${-s} ${s},0 0,${s} ${-s},0`);
        return p;
       }
       if (shape === "server") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.2);
        body.setAttribute("y", -size * 0.6);
        body.setAttribute("width", size * 2.4);
        body.setAttribute("height", size * 1.2);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 3; i++) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", -size * 0.9 + i * size * 0.5);
         line.setAttribute("y1", -size * 0.3);
         line.setAttribute("x2", -size * 0.9 + i * size * 0.5);
         line.setAttribute("y2", size * 0.3);
         line.style.stroke = "currentColor";
         line.style.strokeWidth = "2";
         line.style.opacity = "0.5";
         g.appendChild(line);
        }
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", size * 0.9);
        led.setAttribute("cy", 0);
        led.setAttribute("r", size * 0.1);
        led.style.fill = "#4ade80";
        g.appendChild(led);
        return g;
       }
       if (shape === "pc" || shape === "desktop") {
        const g = document.createElementNS(ns, "g");
        const monitor = document.createElementNS(ns, "rect");
        monitor.setAttribute("x", -size * 0.9);
        monitor.setAttribute("y", -size * 0.8);
        monitor.setAttribute("width", size * 1.8);
        monitor.setAttribute("height", size * 1.2);
        monitor.setAttribute("rx", 4);
        g.appendChild(monitor);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.75);
        screen.setAttribute("y", -size * 0.65);
        screen.setAttribute("width", size * 1.5);
        screen.setAttribute("height", size * 0.9);
        screen.setAttribute("rx", 2);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        const neck = document.createElementNS(ns, "rect");
        neck.setAttribute("x", -size * 0.15);
        neck.setAttribute("y", size * 0.4);
        neck.setAttribute("width", size * 0.3);
        neck.setAttribute("height", size * 0.3);
        g.appendChild(neck);
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.5);
        base.setAttribute("y", size * 0.7);
        base.setAttribute("width", size * 1);
        base.setAttribute("height", size * 0.15);
        base.setAttribute("rx", 2);
        g.appendChild(base);
        return g;
       }
       if (shape === "laptop") {
        const g = document.createElementNS(ns, "g");
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.8);
        screen.setAttribute("y", -size * 0.9);
        screen.setAttribute("width", size * 1.6);
        screen.setAttribute("height", size * 1.1);
        screen.setAttribute("rx", 4);
        g.appendChild(screen);
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.9);
        base.setAttribute("y", size * 0.25);
        base.setAttribute("width", size * 1.8);
        base.setAttribute("height", size * 0.6);
        base.setAttribute("rx", 4);
        g.appendChild(base);
        const pad = document.createElementNS(ns, "rect");
        pad.setAttribute("x", -size * 0.25);
        pad.setAttribute("y", size * 0.45);
        pad.setAttribute("width", size * 0.5);
        pad.setAttribute("height", size * 0.25);
        pad.setAttribute("rx", 2);
        pad.style.fill = "#1e293b";
        g.appendChild(pad);
        return g;
       }
       if (shape === "phone" || shape === "mobile") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.45);
        body.setAttribute("y", -size);
        body.setAttribute("width", size * 0.9);
        body.setAttribute("height", size * 2);
        body.setAttribute("rx", 8);
        g.appendChild(body);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.38);
        screen.setAttribute("y", -size * 0.85);
        screen.setAttribute("width", size * 0.76);
        screen.setAttribute("height", size * 1.6);
        screen.setAttribute("rx", 4);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        const btn = document.createElementNS(ns, "rect");
        btn.setAttribute("x", -size * 0.15);
        btn.setAttribute("y", size * 0.82);
        btn.setAttribute("width", size * 0.3);
        btn.setAttribute("height", size * 0.06);
        btn.setAttribute("rx", 2);
        btn.style.fill = "#475569";
        g.appendChild(btn);
        return g;
       }
       if (shape === "router") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.1);
        body.setAttribute("y", -size * 0.3);
        body.setAttribute("width", size * 2.2);
        body.setAttribute("height", size * 0.8);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        for (let i = -1; i <= 1; i++) {
         const ant = document.createElementNS(ns, "rect");
         ant.setAttribute("x", i * size * 0.6 - size * 0.05);
         ant.setAttribute("y", -size * 0.9);
         ant.setAttribute("width", size * 0.1);
         ant.setAttribute("height", size * 0.6);
         ant.setAttribute("rx", 2);
         g.appendChild(ant);
         const tip = document.createElementNS(ns, "circle");
         tip.setAttribute("cx", i * size * 0.6);
         tip.setAttribute("cy", -size * 0.95);
         tip.setAttribute("r", size * 0.08);
         g.appendChild(tip);
        }
        for (let i = 0; i < 4; i++) {
         const led = document.createElementNS(ns, "circle");
         led.setAttribute("cx", -size * 0.7 + i * size * 0.35);
         led.setAttribute("cy", size * 0.1);
         led.setAttribute("r", size * 0.06);
         led.style.fill = i < 2 ? "#4ade80" : "#facc15";
         g.appendChild(led);
        }
        return g;
       }
       if (shape === "switch") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.4);
        body.setAttribute("y", -size * 0.4);
        body.setAttribute("width", size * 2.8);
        body.setAttribute("height", size * 0.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 8; i++) {
         const port = document.createElementNS(ns, "rect");
         port.setAttribute("x", -size * 1.2 + i * size * 0.32);
         port.setAttribute("y", -size * 0.15);
         port.setAttribute("width", size * 0.22);
         port.setAttribute("height", size * 0.3);
         port.setAttribute("rx", 1);
         port.style.fill = "#1e293b";
         g.appendChild(port);
        }
        return g;
       }
       if (shape === "firewall") {
        const g = document.createElementNS(ns, "g");
        const wall = document.createElementNS(ns, "rect");
        wall.setAttribute("x", -size);
        wall.setAttribute("y", -size * 0.8);
        wall.setAttribute("width", size * 2);
        wall.setAttribute("height", size * 1.6);
        wall.setAttribute("rx", 4);
        g.appendChild(wall);
        for (let row = 0; row < 3; row++) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", -size * 0.85);
         line.setAttribute("y1", -size * 0.5 + row * size * 0.45);
         line.setAttribute("x2", size * 0.85);
         line.setAttribute("y2", -size * 0.5 + row * size * 0.45);
         line.style.stroke = "#475569";
         line.style.strokeWidth = "2";
         g.appendChild(line);
        }
        for (let row = 0; row < 4; row++) {
         const offset = row % 2 === 0 ? 0 : size * 0.35;
         for (let col = 0; col < 3; col++) {
          const line = document.createElementNS(ns, "line");
          const x = -size * 0.5 + col * size * 0.7 + offset;
          if (x > -size * 0.85 && x < size * 0.85) {
           line.setAttribute("x1", x);
           line.setAttribute("y1", -size * 0.8 + row * size * 0.45, );
           line.setAttribute("x2", x);
           line.setAttribute("y2", -size * 0.8 + row * size * 0.45 + size * 0.45, );
           line.style.stroke = "#475569";
           line.style.strokeWidth = "2";
           g.appendChild(line);
          }
         }
        }
        return g;
       }
       if (shape === "cloud") {
        const p = document.createElementNS(ns, "path");
        const s = size;
        p.setAttribute("d", `
             M ${-s * 0.8} ${s * 0.2}
             Q ${-s * 1.1} ${s * 0.2} ${-s * 1.1} ${-s * 0.1}
             Q ${-s * 1.1} ${-s * 0.5} ${-s * 0.7} ${-s * 0.5}
             Q ${-s * 0.7} ${-s * 0.9} ${-s * 0.2} ${-s * 0.9}
             Q ${s * 0.1} ${-s * 1.1} ${s * 0.5} ${-s * 0.8}
             Q ${s * 1} ${-s * 0.8} ${s * 1.1} ${-s * 0.3}
             Q ${s * 1.3} ${-s * 0.1} ${s * 1.1} ${s * 0.2}
             Q ${s * 1.1} ${s * 0.5} ${s * 0.7} ${s * 0.5}
             L ${-s * 0.5} ${s * 0.5}
             Q ${-s * 0.9} ${s * 0.5} ${-s * 0.9} ${s * 0.2}
             Z
            `, );
        return p;
       }
       if (shape === "database") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.7);
        body.setAttribute("y", -size * 0.6);
        body.setAttribute("width", size * 1.4);
        body.setAttribute("height", size * 1.4);
        g.appendChild(body);
        const top = document.createElementNS(ns, "ellipse");
        top.setAttribute("cx", 0);
        top.setAttribute("cy", -size * 0.6);
        top.setAttribute("rx", size * 0.7);
        top.setAttribute("ry", size * 0.25);
        g.appendChild(top);
        const bottom = document.createElementNS(ns, "ellipse");
        bottom.setAttribute("cx", 0);
        bottom.setAttribute("cy", size * 0.8);
        bottom.setAttribute("rx", size * 0.7);
        bottom.setAttribute("ry", size * 0.25);
        g.appendChild(bottom);
        const mid1 = document.createElementNS(ns, "ellipse");
        mid1.setAttribute("cx", 0);
        mid1.setAttribute("cy", -size * 0.15);
        mid1.setAttribute("rx", size * 0.7);
        mid1.setAttribute("ry", size * 0.2);
        mid1.style.fill = "none";
        mid1.style.stroke = "#475569";
        mid1.style.strokeWidth = "2";
        g.appendChild(mid1);
        const mid2 = document.createElementNS(ns, "ellipse");
        mid2.setAttribute("cx", 0);
        mid2.setAttribute("cy", size * 0.35);
        mid2.setAttribute("rx", size * 0.7);
        mid2.setAttribute("ry", size * 0.2);
        mid2.style.fill = "none";
        mid2.style.stroke = "#475569";
        mid2.style.strokeWidth = "2";
        g.appendChild(mid2);
        return g;
       }
       if (shape === "printer") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.4);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size * 0.9);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const trayTop = document.createElementNS(ns, "rect");
        trayTop.setAttribute("x", -size * 0.7);
        trayTop.setAttribute("y", -size * 0.8);
        trayTop.setAttribute("width", size * 1.4);
        trayTop.setAttribute("height", size * 0.4);
        trayTop.setAttribute("rx", 2);
        trayTop.style.fill = "#1e293b";
        g.appendChild(trayTop);
        const trayOut = document.createElementNS(ns, "rect");
        trayOut.setAttribute("x", -size * 0.6);
        trayOut.setAttribute("y", size * 0.5);
        trayOut.setAttribute("width", size * 1.2);
        trayOut.setAttribute("height", size * 0.35);
        trayOut.setAttribute("rx", 2);
        g.appendChild(trayOut);
        const paper = document.createElementNS(ns, "rect");
        paper.setAttribute("x", -size * 0.5);
        paper.setAttribute("y", size * 0.3);
        paper.setAttribute("width", size * 1);
        paper.setAttribute("height", size * 0.5);
        paper.style.fill = "#e2e8f0";
        g.appendChild(paper);
        return g;
       }
       if (shape === "access-point" || shape === "wifi") {
        const g = document.createElementNS(ns, "g");
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.3);
        base.setAttribute("y", size * 0.2);
        base.setAttribute("width", size * 0.6);
        base.setAttribute("height", size * 0.3);
        base.setAttribute("rx", 3);
        g.appendChild(base);
        for (let i = 1; i <= 3; i++) {
         const arc = document.createElementNS(ns, "path");
         const r = size * 0.3 * i;
         arc.setAttribute("d", `M ${-r * 0.7} ${size * 0.1 - r * 0.5} A ${r} ${r} 0 0 1 ${r * 0.7} ${size * 0.1 - r * 0.5}`);
         arc.style.fill = "none";
         arc.style.stroke = "currentColor";
         arc.style.strokeWidth = "2";
         arc.style.opacity = 1 - (i * 0.2);
         g.appendChild(arc);
        }
        return g;
       }
       if (shape === "load-balancer") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.5);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        const bar = document.createElementNS(ns, "line");
        bar.setAttribute("x1", -size * 0.6);
        bar.setAttribute("y1", 0);
        bar.setAttribute("x2", size * 0.6);
        bar.setAttribute("y2", 0);
        bar.style.stroke = "#4ade80";
        bar.style.strokeWidth = "3";
        g.appendChild(bar);
        [-1, 1].forEach(dir => {
         const arrow = document.createElementNS(ns, "path");
         arrow.setAttribute("d", `M ${dir * size * 0.3} ${-size * 0.2} L ${dir * size * 0.6} 0 L ${dir * size * 0.3} ${size * 0.2}`);
         arrow.style.fill = "none";
         arrow.style.stroke = "#4ade80";
         arrow.style.strokeWidth = "2";
         g.appendChild(arrow);
        });
        return g;
       }
       if (shape === "nas" || shape === "storage") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.8);
        body.setAttribute("y", -size * 0.9);
        body.setAttribute("width", size * 1.6);
        body.setAttribute("height", size * 1.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 4; i++) {
         const bay = document.createElementNS(ns, "rect");
         bay.setAttribute("x", -size * 0.6);
         bay.setAttribute("y", -size * 0.7 + i * size * 0.4);
         bay.setAttribute("width", size * 1.2);
         bay.setAttribute("height", size * 0.3);
         bay.setAttribute("rx", 2);
         bay.style.fill = "#1e293b";
         g.appendChild(bay);
        }
        return g;
       }
       if (shape === "gateway" || shape === "modem") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.5);
        body.setAttribute("y", -size * 0.9);
        body.setAttribute("width", size);
        body.setAttribute("height", size * 1.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 4; i++) {
         const led = document.createElementNS(ns, "circle");
         led.setAttribute("cx", 0);
         led.setAttribute("cy", -size * 0.6 + i * size * 0.35);
         led.setAttribute("r", size * 0.08);
         led.style.fill = ["#4ade80", "#4ade80", "#facc15", "#60a5fa"][i];
         g.appendChild(led);
        }
        return g;
       }
       if (shape === "vpn" || shape === "tunnel") {
        const g = document.createElementNS(ns, "g");
        const outer = document.createElementNS(ns, "ellipse");
        outer.setAttribute("cx", 0);
        outer.setAttribute("cy", 0);
        outer.setAttribute("rx", size);
        outer.setAttribute("ry", size * 0.6);
        g.appendChild(outer);
        const inner = document.createElementNS(ns, "ellipse");
        inner.setAttribute("cx", 0);
        inner.setAttribute("cy", 0);
        inner.setAttribute("rx", size * 0.5);
        inner.setAttribute("ry", size * 0.3);
        inner.style.fill = "#1e293b";
        g.appendChild(inner);
        const lock = document.createElementNS(ns, "rect");
        lock.setAttribute("x", -size * 0.15);
        lock.setAttribute("y", -size * 0.1);
        lock.setAttribute("width", size * 0.3);
        lock.setAttribute("height", size * 0.25);
        lock.setAttribute("rx", 2);
        lock.style.fill = "#4ade80";
        g.appendChild(lock);
        return g;
       }
       
       if (shape === "container") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.5);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 3; i++) {
         const block = document.createElementNS(ns, "rect");
         block.setAttribute("x", -size * 0.8 + i * size * 0.55);
         block.setAttribute("y", -size * 0.3);
         block.setAttribute("width", size * 0.45);
         block.setAttribute("height", size * 0.6);
         block.setAttribute("rx", 2);
         block.style.fill = "#1e293b";
         g.appendChild(block);
        }
        return g;
       }
       if (shape === "vm" || shape === "virtual") {
        const g = document.createElementNS(ns, "g");
        const shadow = document.createElementNS(ns, "rect");
        shadow.setAttribute("x", -size * 0.85 + 4);
        shadow.setAttribute("y", -size * 0.65 + 4);
        shadow.setAttribute("width", size * 1.7);
        shadow.setAttribute("height", size * 1.3);
        shadow.setAttribute("rx", 4);
        shadow.style.opacity = "0.3";
        g.appendChild(shadow);
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.85);
        body.setAttribute("y", -size * 0.65);
        body.setAttribute("width", size * 1.7);
        body.setAttribute("height", size * 1.3);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.65);
        screen.setAttribute("y", -size * 0.45);
        screen.setAttribute("width", size * 1.3);
        screen.setAttribute("height", size * 0.7);
        screen.setAttribute("rx", 2);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        return g;
       }
       if (shape === "kubernetes" || shape === "k8s") {
        const g = document.createElementNS(ns, "g");
        const outer = document.createElementNS(ns, "circle");
        outer.setAttribute("cx", 0);
        outer.setAttribute("cy", 0);
        outer.setAttribute("r", size);
        g.appendChild(outer);
        const inner = document.createElementNS(ns, "circle");
        inner.setAttribute("cx", 0);
        inner.setAttribute("cy", 0);
        inner.setAttribute("r", size * 0.4);
        inner.style.fill = "#1e293b";
        g.appendChild(inner);
        for (let i = 0; i < 7; i++) {
         const angle = (Math.PI * 2 / 7) * i - Math.PI / 2;
         const spoke = document.createElementNS(ns, "line");
         spoke.setAttribute("x1", Math.cos(angle) * size * 0.4);
         spoke.setAttribute("y1", Math.sin(angle) * size * 0.4);
         spoke.setAttribute("x2", Math.cos(angle) * size * 0.85);
         spoke.setAttribute("y2", Math.sin(angle) * size * 0.85);
         spoke.style.stroke = "#326ce5";
         spoke.style.strokeWidth = "3";
         g.appendChild(spoke);
        }
        return g;
       }
       if (shape === "shield" || shape === "security") {
        const p = document.createElementNS(ns, "path");
        const s = size;
        p.setAttribute("d", `M 0 ${-s} L ${s * 0.85} ${-s * 0.5} L ${s * 0.85} ${s * 0.2} Q ${s * 0.7} ${s * 0.9} 0 ${s} Q ${-s * 0.7} ${s * 0.9} ${-s * 0.85} ${s * 0.2} L ${-s * 0.85} ${-s * 0.5} Z`);
        return p;
       }
       if (shape === "camera" || shape === "cctv") {
        const g = document.createElementNS(ns, "g");
        const mount = document.createElementNS(ns, "rect");
        mount.setAttribute("x", -size * 1.1);
        mount.setAttribute("y", -size * 0.5);
        mount.setAttribute("width", size * 0.25);
        mount.setAttribute("height", size * 0.6);
        mount.setAttribute("rx", 2);
        g.appendChild(mount);
        const arm = document.createElementNS(ns, "rect");
        arm.setAttribute("x", -size * 0.9);
        arm.setAttribute("y", -size * 0.15);
        arm.setAttribute("width", size * 0.5);
        arm.setAttribute("height", size * 0.15);
        g.appendChild(arm);
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.45);
        body.setAttribute("y", -size * 0.35);
        body.setAttribute("width", size * 1.1);
        body.setAttribute("height", size * 0.7);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const lensHousing = document.createElementNS(ns, "circle");
        lensHousing.setAttribute("cx", size * 0.85);
        lensHousing.setAttribute("cy", 0);
        lensHousing.setAttribute("r", size * 0.4);
        g.appendChild(lensHousing);
        const lensOuter = document.createElementNS(ns, "circle");
        lensOuter.setAttribute("cx", size * 0.85);
        lensOuter.setAttribute("cy", 0);
        lensOuter.setAttribute("r", size * 0.28);
        lensOuter.style.fill = "#1e293b";
        g.appendChild(lensOuter);
        const lensInner = document.createElementNS(ns, "circle");
        lensInner.setAttribute("cx", size * 0.85);
        lensInner.setAttribute("cy", 0);
        lensInner.setAttribute("r", size * 0.15);
        lensInner.style.fill = "#3b82f6";
        g.appendChild(lensInner);
        const reflection = document.createElementNS(ns, "circle");
        reflection.setAttribute("cx", size * 0.8);
        reflection.setAttribute("cy", -size * 0.05);
        reflection.setAttribute("r", size * 0.05);
        reflection.style.fill = "#93c5fd";
        g.appendChild(reflection);
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", -size * 0.2);
        led.setAttribute("cy", -size * 0.15);
        led.setAttribute("r", size * 0.06);
        led.style.fill = "#ef4444";
        g.appendChild(led);
        return g;
       }
       if (shape === "monitor" || shape === "dashboard") {
        const g = document.createElementNS(ns, "g");
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size);
        screen.setAttribute("y", -size * 0.7);
        screen.setAttribute("width", size * 2);
        screen.setAttribute("height", size * 1.2);
        screen.setAttribute("rx", 4);
        g.appendChild(screen);
        const graph = document.createElementNS(ns, "polyline");
        graph.setAttribute("points", `${-size * 0.8},${size * 0.2} ${-size * 0.3},${-size * 0.2} ${size * 0.2},${size * 0.1} ${size * 0.7},${-size * 0.3}`);
        graph.style.fill = "none";
        graph.style.stroke = "#4ade80";
        graph.style.strokeWidth = "3";
        g.appendChild(graph);
        return g;
       }
       if (shape === "docker" || shape === "whale") {
        const g = document.createElementNS(ns, "g");
        const s = size;
        const body = document.createElementNS(ns, "path");
        body.setAttribute("d", `
         M ${-s * 0.9} ${s * 0.2}
         Q ${-s * 1.1} ${s * 0.5} ${-s * 0.7} ${s * 0.7}
         Q ${-s * 0.3} ${s * 0.85} ${s * 0.3} ${s * 0.75}
         Q ${s * 0.8} ${s * 0.6} ${s * 1.0} ${s * 0.3}
         Q ${s * 1.1} ${s * 0.1} ${s * 1.0} ${-s * 0.1}
         L ${s * 0.85} ${-s * 0.1}
         Q ${s * 0.7} ${-s * 0.15} ${s * 0.4} ${-s * 0.2}
         L ${-s * 0.5} ${-s * 0.2}
         Q ${-s * 0.8} ${-s * 0.1} ${-s * 0.9} ${s * 0.2}
         Z
        `);
        body.style.fill = "#0db7ed";
        g.appendChild(body);
        const tail = document.createElementNS(ns, "path");
        tail.setAttribute("d", `
         M ${-s * 0.85} ${s * 0.1}
         Q ${-s * 1.2} ${-s * 0.2} ${-s * 1.0} ${-s * 0.55}
         Q ${-s * 0.95} ${-s * 0.35} ${-s * 0.8} ${-s * 0.15}
         Z
        `);
        tail.style.fill = "#0db7ed";
        g.appendChild(tail);
        const belly = document.createElementNS(ns, "path");
        belly.setAttribute("d", `
         M ${-s * 0.5} ${s * 0.65}
         Q ${s * 0.1} ${s * 0.75} ${s * 0.6} ${s * 0.55}
         Q ${s * 0.8} ${s * 0.45} ${s * 0.9} ${s * 0.25}
         Q ${s * 0.7} ${s * 0.5} ${s * 0.3} ${s * 0.6}
         Q ${-s * 0.1} ${s * 0.7} ${-s * 0.5} ${s * 0.65}
         Z
        `);
        belly.style.fill = "#ffffff";
        belly.style.opacity = "0.3";
        g.appendChild(belly);
        for (let row = 0; row < 2; row++) {
         for (let col = 0; col < 3; col++) {
          const container = document.createElementNS(ns, "rect");
          container.setAttribute("x", -s * 0.45 + col * s * 0.35);
          container.setAttribute("y", -s * 0.7 + row * s * 0.28);
          container.setAttribute("width", s * 0.3);
          container.setAttribute("height", s * 0.23);
          container.setAttribute("rx", 2);
          container.style.fill = "#0db7ed";
          container.style.stroke = "#0a9ed8";
          container.style.strokeWidth = "1.5";
          g.appendChild(container);
         }
        }
        const topContainer = document.createElementNS(ns, "rect");
        topContainer.setAttribute("x", -s * 0.1);
        topContainer.setAttribute("y", -s * 0.95);
        topContainer.setAttribute("width", s * 0.3);
        topContainer.setAttribute("height", s * 0.23);
        topContainer.setAttribute("rx", 2);
        topContainer.style.fill = "#0db7ed";
        topContainer.style.stroke = "#0a9ed8";
        topContainer.style.strokeWidth = "1.5";
        g.appendChild(topContainer);
        const eye = document.createElementNS(ns, "circle");
        eye.setAttribute("cx", s * 0.65);
        eye.setAttribute("cy", s * 0.25);
        eye.setAttribute("r", s * 0.08);
        eye.style.fill = "#0a5f7a";
        g.appendChild(eye);
        
        return g;
       }
       if (shape === "rounded-square") {
        const r = document.createElementNS(ns, "rect");
        const s = size * 1.6;
        r.setAttribute("x", -s / 2);
        r.setAttribute("y", -s / 2);
        r.setAttribute("width", s);
        r.setAttribute("height", s);
        r.setAttribute("rx", size * 0.4);
        return r;
       }
       if (shape === "pill" || shape === "capsule") {
        const r = document.createElementNS(ns, "rect");
        r.setAttribute("x", -size * 1.2);
        r.setAttribute("y", -size * 0.5);
        r.setAttribute("width", size * 2.4);
        r.setAttribute("height", size);
        r.setAttribute("rx", size * 0.5);
        return r;
       }
       if (shape === "octagon") {
        const p = document.createElementNS(ns, "polygon");
        const r = size;
        const pts = [];
        for (let i = 0; i < 8; i++) {
         const a = (Math.PI / 4) * i - Math.PI / 8;
         pts.push([Math.cos(a) * r, Math.sin(a) * r]);
        }
        p.setAttribute("points", pts.map(pt => pt.join(",")).join(" "));
        return p;
       }
       if (shape === "pentagon") {
        const p = document.createElementNS(ns, "polygon");
        const pts = [];
        for (let i = 0; i < 5; i++) {
         const a = (Math.PI * 2 / 5) * i - Math.PI / 2;
         pts.push([Math.cos(a) * size, Math.sin(a) * size]);
        }
        p.setAttribute("points", pts.map(pt => pt.join(",")).join(" "));
        return p;
       }
       if (shape === "cross" || shape === "plus") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        const t = size * 0.35;
        p.setAttribute("points", `${-t},${-s} ${t},${-s} ${t},${-t} ${s},${-t} ${s},${t} ${t},${t} ${t},${s} ${-t},${s} ${-t},${t} ${-s},${t} ${-s},${-t} ${-t},${-t}`);
        return p;
       }
       if (shape === "parallelogram") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `${-s * 0.6},${-s * 0.6} ${s * 1.2},${-s * 0.6} ${s * 0.6},${s * 0.6} ${-s * 1.2},${s * 0.6}`);
        return p;
       }
       if (shape === "trapezoid") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `${-s * 0.6},${-s * 0.6} ${s * 0.6},${-s * 0.6} ${s},${s * 0.6} ${-s},${s * 0.6}`);
        return p;
       }
       if (shape === "sensor" || shape === "iot") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "circle");
        body.setAttribute("cx", 0);
        body.setAttribute("cy", 0);
        body.setAttribute("r", size * 0.7);
        g.appendChild(body);
        const ant = document.createElementNS(ns, "line");
        ant.setAttribute("x1", 0);
        ant.setAttribute("y1", -size * 0.7);
        ant.setAttribute("x2", 0);
        ant.setAttribute("y2", -size);
        ant.style.stroke = "currentColor";
        ant.style.strokeWidth = "2";
        g.appendChild(ant);
        const tip = document.createElementNS(ns, "circle");
        tip.setAttribute("cx", 0);
        tip.setAttribute("cy", -size);
        tip.setAttribute("r", size * 0.1);
        tip.style.fill = "#4ade80";
        g.appendChild(tip);
        return g;
       }
       if (shape === "pi" || shape === "sbc" || shape === "raspberry") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.65);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size * 1.3);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 10; i++) {
         const pin = document.createElementNS(ns, "rect");
         pin.setAttribute("x", -size * 0.85 + i * size * 0.19);
         pin.setAttribute("y", -size * 0.8);
         pin.setAttribute("width", size * 0.08);
         pin.setAttribute("height", size * 0.15);
         pin.style.fill = "#facc15";
         g.appendChild(pin);
        }
        const port = document.createElementNS(ns, "rect");
        port.setAttribute("x", size * 0.6);
        port.setAttribute("y", -size * 0.2);
        port.setAttribute("width", size * 0.35);
        port.setAttribute("height", size * 0.4);
        port.style.fill = "#1e293b";
        g.appendChild(port);
        return g;
       }
       if (shape === "api" || shape === "endpoint") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.9);
        body.setAttribute("y", -size * 0.7);
        body.setAttribute("width", size * 1.8);
        body.setAttribute("height", size * 1.4);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        const left = document.createElementNS(ns, "text");
        left.setAttribute("x", -size * 0.5);
        left.setAttribute("y", size * 0.15);
        left.setAttribute("font-size", size * 0.9);
        left.setAttribute("fill", "#4ade80");
        left.setAttribute("font-family", "monospace");
        left.textContent = "{";
        g.appendChild(left);
        const right = document.createElementNS(ns, "text");
        right.setAttribute("x", size * 0.15);
        right.setAttribute("y", size * 0.15);
        right.setAttribute("font-size", size * 0.9);
        right.setAttribute("fill", "#4ade80");
        right.setAttribute("font-family", "monospace");
        right.textContent = "}";
        g.appendChild(right);
        return g;
       }
       if (shape === "queue" || shape === "message") {
        const g = document.createElementNS(ns, "g");
        for (let i = 2; i >= 0; i--) {
         const card = document.createElementNS(ns, "rect");
         card.setAttribute("x", -size * 0.7 + i * 4);
         card.setAttribute("y", -size * 0.5 + i * 4);
         card.setAttribute("width", size * 1.4);
         card.setAttribute("height", size * 0.8);
         card.setAttribute("rx", 3);
         card.style.opacity = 1 - i * 0.25;
         g.appendChild(card);
        }
        return g;
       }
       if (shape === "lambda" || shape === "function") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.8);
        body.setAttribute("y", -size * 0.8);
        body.setAttribute("width", size * 1.6);
        body.setAttribute("height", size * 1.6);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const lambda = document.createElementNS(ns, "text");
        lambda.setAttribute("x", 0);
        lambda.setAttribute("y", size * 0.2);
        lambda.setAttribute("font-size", size * 1.2);
        lambda.setAttribute("fill", "#f59e0b");
        lambda.setAttribute("text-anchor", "middle");
        lambda.setAttribute("font-family", "serif");
        lambda.textContent = "Œª";
        g.appendChild(lambda);
        return g;
       }
       if (shape === "bucket" || shape === "s3") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "path");
        body.setAttribute("d", `M ${-size * 0.8} ${-size * 0.7} L ${-size * 0.6} ${size * 0.8} Q ${-size * 0.5} ${size} 0 ${size} Q ${size * 0.5} ${size} ${size * 0.6} ${size * 0.8} L ${size * 0.8} ${-size * 0.7} Z`);
        g.appendChild(body);
        const rim = document.createElementNS(ns, "ellipse");
        rim.setAttribute("cx", 0);
        rim.setAttribute("cy", -size * 0.7);
        rim.setAttribute("rx", size * 0.8);
        rim.setAttribute("ry", size * 0.25);
        g.appendChild(rim);
        return g;
       }
       const c = document.createElementNS(ns, "circle");
       c.setAttribute("r", size);
       return c;
      }
      
      function createNodeShape(id, size) {
       const styles = resolveStylesForNode(id);
       if (styles.icon && styles.icon.library && styles.icon.name) {
        const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
        g.classList.add("node-circle");
        IconLibrary.getIcon(styles.icon.library, styles.icon.name).then(svgText => {
         if (svgText) {
          const parser = new DOMParser();
          const doc = parser.parseFromString(svgText, 'image/svg+xml');
          const svgEl = doc.querySelector('svg');
          if (svgEl) {
           svgEl.setAttribute('width', size * 1.2);
           svgEl.setAttribute('height', size * 1.2);
           svgEl.setAttribute('x', -size * 0.6);
           svgEl.setAttribute('y', -size * 0.6);
           if (styles.circleColor) {
            svgEl.style.fill = styles.circleColor;
            svgEl.querySelectorAll('path, circle, rect, polygon, ellipse').forEach(el => {
             el.style.fill = styles.circleColor;
            });
           }
           if (styles.circleBorder) {
            svgEl.style.stroke = styles.circleBorder;
            svgEl.querySelectorAll('path, circle, rect, polygon, ellipse').forEach(el => {
             el.style.stroke = styles.circleBorder;
            });
           }
           g.innerHTML = svgEl.outerHTML;
          }
         }
        });
        return g;
       }
       const shapeType = (NODE_DATA[id] && NODE_DATA[id].shape) || "circle";
       const shapeEl = createShapeElement(shapeType, size);
       shapeEl.classList.add("node-circle");
       shapeEl.style.fill = styles.circleColor || PAGE_STATE.nodeFill || "#1e293b";
       shapeEl.style.stroke = styles.circleBorder || PAGE_STATE.nodeStroke || "#475569";
       return shapeEl;
      }
      
      function forgeTheLegend() {
       const container = document.getElementById("edge-legend");
       if (!container) return;
       container.innerHTML = "";
       const title = document.createElement("div");
       title.className = "legend-title";
       title.textContent = "Line Legend";
       container.appendChild(title);
       const closeBtn = document.createElement("button");
       closeBtn.type = "button";
       closeBtn.className = "legend-close-btn";
       closeBtn.textContent = "‚úï";
       closeBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        legendCollapsed = true;
        updateLegendVisibility();
       });
       container.appendChild(closeBtn);
       const colors = [...new Set(EDGE_DATA.list.map((e) => e.color).filter(Boolean))];
       if (colors.length === 0) {
        updateLegendVisibility();
        return;
       }
       colors.forEach((color) => {
         if (!EDGE_LEGEND[color]) {
          EDGE_LEGEND[color] = "you can edit me too";
         }
         const item = document.createElement("div");
         item.className = "legend-item";
         item.addEventListener("mousedown", (e) => e.stopPropagation());
         item.addEventListener("click", (e) => e.stopPropagation());
         const swatch = document.createElement("span");
         swatch.className = "legend-swatch";
         swatch.style.backgroundColor = color;
         swatch.style.cursor = "pointer";
         swatch.addEventListener("click", (e) => {
          e.stopPropagation();
          const edgeWithColor = EDGE_DATA.list.find(edge => edge.color === color);
          if (edgeWithColor) {
           selectTheConnection(edgeWithColor.id);
          }
         });
         let swatchTouchStart = null;
         let swatchTouchMoved = false;
         swatch.addEventListener("touchstart", (e) => {
         swatchTouchStart = Date.now();
         swatchTouchMoved = false;
         if (e.touches[0]) {
          swatchTouchStartX = e.touches[0].clientX;
          swatchTouchStartY = e.touches[0].clientY;
         }
        }, {
          passive: false
         });
         let swatchTouchStartX = 0, swatchTouchStartY = 0;
        swatch.addEventListener("touchmove", (e) => {
         if (e.touches[0]) {
          const dx = Math.abs(e.touches[0].clientX - swatchTouchStartX);
          const dy = Math.abs(e.touches[0].clientY - swatchTouchStartY);
          if (dx > 10 || dy > 10) swatchTouchMoved = true;
         }
        }, {
          passive: false
         });
         swatch.addEventListener("touchend", (e) => {
          if (swatchTouchStart && !swatchTouchMoved && Date.now() - swatchTouchStart < 400) {
           e.stopPropagation();
           e.preventDefault();
           const edgeWithColor = EDGE_DATA.list.find(edge => edge.color === color);
           if (edgeWithColor) {
            selectTheConnection(edgeWithColor.id);
           }
          }
          swatchTouchStart = null;
          swatchTouchMoved = false;
         }, {
          passive: false
         });
        const label = document.createElement("span");
        label.className = "legend-label";
        label.textContent = EDGE_LEGEND[color];
        if (isMobileDevice()) {
         label.style.cursor = "pointer";
         let labelTapStart = null;
         let labelTapMoved = false;
         label.addEventListener("touchstart", (e) => {
          labelTapStart = Date.now();
          labelTapMoved = false;
          if (e.touches[0]) {
           labelTapStartX = e.touches[0].clientX;
           labelTapStartY = e.touches[0].clientY;
          }
          e.stopPropagation();
         });
         let labelTapStartX = 0, labelTapStartY = 0;
         label.addEventListener("touchmove", (e) => {
          if (e.touches[0]) {
           const dx = Math.abs(e.touches[0].clientX - labelTapStartX);
           const dy = Math.abs(e.touches[0].clientY - labelTapStartY);
           if (dx > 10 || dy > 10) labelTapMoved = true;
          }
         });
         label.addEventListener("touchend", (e) => {
          if (labelTapStart && !labelTapMoved && Date.now() - labelTapStart < 400) {
           e.preventDefault();
           e.stopPropagation();
           const currentText = label.textContent;
           const newText = prompt("Edit legend label:", currentText);
           if (newText !== null && newText.trim()) {
            label.textContent = newText.trim();
            EDGE_LEGEND[color] = newText.trim();
            
           }
          }
          labelTapStart = null;
          labelTapMoved = false;
         });
        } else {
           label.contentEditable = true;
           label.addEventListener("focus", () => {
            label.classList.add("editing");
           });
           label.addEventListener("blur", () => {
            label.classList.remove("editing");
            const text = label.textContent.trim() || "you can edit me too";
            EDGE_LEGEND[color] = text;
            
           });
           label.addEventListener("keydown", (e) => {
            if (e.key === "Enter") {
             e.preventDefault();
             label.blur();
            }
           });
          }
          item.append(swatch, label); container.appendChild(item);
         }); updateLegendVisibility();
       }
      
       function deleteRectangle(rectId) {
      pushUndo("delete zone");
        RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== rectId);
        forgeTheTopology();
       }
      
       function updateRectangleDeleteButtons() {
        const deleteButtons = document.querySelectorAll('.rect-delete-btn');
        deleteButtons.forEach(btn => {
         btn.style.display = rectDrawMode ? 'block' : 'none';
        });
       }
      
      
       function forgeTheTopology() {
        if (!NODE_DATA || !EDGE_DATA) {
         console.warn("forgeTheTopology called before data initialized");
         return;
        }
        const svg = document.getElementById("map");
        svg.innerHTML = "";
        const ns = "http://www.w3.org/2000/svg";
        const defs = document.createElementNS(ns, "defs");
        const markerForward = document.createElementNS(ns, "marker");
        markerForward.id = "arrow-forward";
        markerForward.setAttribute("markerWidth", "10");
        markerForward.setAttribute("markerHeight", "10");
        markerForward.setAttribute("refX", "9");
        markerForward.setAttribute("refY", "3");
        markerForward.setAttribute("orient", "auto");
        markerForward.setAttribute("markerUnits", "strokeWidth");
        const pathForward = document.createElementNS(ns, "path");
        pathForward.setAttribute("d", "M0,0 L0,6 L9,3 z");
        pathForward.setAttribute("fill", "context-stroke");
        markerForward.appendChild(pathForward);
        defs.appendChild(markerForward);
        const markerBackward = document.createElementNS(ns, "marker");
        markerBackward.id = "arrow-backward";
        markerBackward.setAttribute("markerWidth", "10");
        markerBackward.setAttribute("markerHeight", "10");
        markerBackward.setAttribute("refX", "0");
        markerBackward.setAttribute("refY", "3");
        markerBackward.setAttribute("orient", "auto");
        markerBackward.setAttribute("markerUnits", "strokeWidth");
        const pathBackward = document.createElementNS(ns, "path");
        pathBackward.setAttribute("d", "M9,0 L9,6 L0,3 z");
        pathBackward.setAttribute("fill", "context-stroke");
        markerBackward.appendChild(pathBackward);
        defs.appendChild(markerBackward);
        svg.appendChild(defs);
        const boundary = document.createElementNS(ns, "rect");
        boundary.setAttribute("x", CANVAS_PADDING);
        boundary.setAttribute("y", CANVAS_PADDING);
        boundary.setAttribute("width", CANVAS_WIDTH - CANVAS_PADDING * 2);
        boundary.setAttribute("height", CANVAS_HEIGHT - CANVAS_PADDING * 2);
        boundary.setAttribute("fill", "none");
        boundary.setAttribute("stroke", (PAGE_STATE.canvasBorder || "#475569") + "4D");
        boundary.setAttribute("stroke-width", "20");
        boundary.setAttribute("stroke-dasharray", "10 5");
        boundary.setAttribute("rx", "8");
        svg.appendChild(boundary);
       
       if (currentView.mode !== "rack") {
        const gridGroup = document.createElementNS(ns, "g");
        gridGroup.id = "canvas-grid";
        const gridSize = PAGE_STATE.canvasGridSize || 50;
        const gridColor = (PAGE_STATE.canvasGrid || "#475569") + "33";
        const majorGridColor = (PAGE_STATE.canvasGrid || "#475569") + "66";
        
        for (let x = CANVAS_PADDING; x <= CANVAS_WIDTH - CANVAS_PADDING; x += gridSize) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", x);
         line.setAttribute("y1", CANVAS_PADDING);
         line.setAttribute("x2", x);
         line.setAttribute("y2", CANVAS_HEIGHT - CANVAS_PADDING);
         line.setAttribute("stroke", (x - CANVAS_PADDING) % (gridSize * 5) === 0 ? majorGridColor : gridColor);
         line.setAttribute("stroke-width", (x - CANVAS_PADDING) % (gridSize * 5) === 0 ? "2" : "1");
         gridGroup.appendChild(line);
        }
        
        for (let y = CANVAS_PADDING; y <= CANVAS_HEIGHT - CANVAS_PADDING; y += gridSize) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", CANVAS_PADDING);
         line.setAttribute("y1", y);
         line.setAttribute("x2", CANVAS_WIDTH - CANVAS_PADDING);
         line.setAttribute("y2", y);
         line.setAttribute("stroke", (y - CANVAS_PADDING) % (gridSize * 5) === 0 ? majorGridColor : gridColor);
         line.setAttribute("stroke-width", (y - CANVAS_PADDING) % (gridSize * 5) === 0 ? "2" : "1");
         gridGroup.appendChild(line);
        }
        
        svg.appendChild(gridGroup);
       }
       
       if (currentView.mode === "rack" && currentView.rackId) {
         const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
         const rackGroup = document.createElementNS(ns, "g");
         rackGroup.id = "rack-visualization";       
         const rackFrame = document.createElementNS(ns, "rect");
         rackFrame.setAttribute("x", RACK_START_X - RACK_WIDTH / 2);
         rackFrame.setAttribute("y", RACK_START_Y);
         rackFrame.setAttribute("width", RACK_WIDTH);
         rackFrame.setAttribute("height", rackCapacity * rackUHeight);
      
         rackFrame.setAttribute("fill", (PAGE_STATE.rackFrameFill || "#0f172a") + "4D");
         rackFrame.setAttribute("stroke", PAGE_STATE.rackFrameStroke || "#4fd1c5");
         rackFrame.setAttribute("stroke-width", "3");
         rackFrame.setAttribute("rx", "4");
         rackGroup.appendChild(rackFrame);
         
         for (let u = 0; u <= rackCapacity; u++) {
          const y = RACK_START_Y + u * rackUHeight;
        
          const line = document.createElementNS(ns, "line");
          line.setAttribute("x1", RACK_START_X - RACK_WIDTH / 2);
          line.setAttribute("y1", y);
          line.setAttribute("x2", RACK_START_X + RACK_WIDTH / 2);
          line.setAttribute("y2", y);
          line.setAttribute("stroke", (PAGE_STATE.rackLineColor || "#475569") + "66");
          line.setAttribute("stroke-width", u % 5 === 0 ? "2" : "1");
          line.setAttribute("stroke-dasharray", u % 5 === 0 ? "none" : "5,5");
          rackGroup.appendChild(line);
          
          if (u < rackCapacity) {
           const uNumber = rackCapacity - u;
           const text = document.createElementNS(ns, "text");
           text.setAttribute("x", RACK_START_X - RACK_WIDTH / 2 - 30);
           text.setAttribute("y", y + rackUHeight / 2);
           text.setAttribute("text-anchor", "middle");
           text.setAttribute("dominant-baseline", "middle");
           text.style.fill = PAGE_STATE.rackTextColor || "#4fd1c5";
           text.style.fontSize = "14px";
           text.style.fontWeight = "bold";
           text.textContent = `U${uNumber}`;
           rackGroup.appendChild(text);
           
           const textRight = document.createElementNS(ns, "text");
           textRight.setAttribute("x", RACK_START_X + RACK_WIDTH / 2 + 30);
           textRight.setAttribute("y", y + rackUHeight / 2);
           textRight.setAttribute("text-anchor", "middle");
           textRight.setAttribute("dominant-baseline", "middle");
           textRight.style.fill = PAGE_STATE.rackTextColor || "#4fd1c5";
           textRight.style.fontSize = "14px";
           textRight.style.fontWeight = "bold";
           textRight.textContent = `U${uNumber}`;
           rackGroup.appendChild(textRight);
          }
         }
         
         svg.appendChild(rackGroup);
        }
      
        const centerX = CANVAS_WIDTH / 2;
      
        if (RECT_DATA && RECT_DATA.list) {
         RECT_DATA.list.forEach((rect) => {
          if (currentView.mode === "rack") return;
          
          if (rect.style === "filled") {
           const g = document.createElementNS(ns, "g");
           g.classList.add("rect-group");
           g.dataset.rectId = rect.id;
           
           const rectEl = document.createElementNS(ns, "rect");
           rectEl.classList.add("rect-shape");
           rectEl.setAttribute("x", rect.x);
           rectEl.setAttribute("y", rect.y);
           rectEl.setAttribute("width", rect.width);
           rectEl.setAttribute("height", rect.height);
           rectEl.style.fill = rect.color;
           rectEl.style.fillOpacity = "0.3";
           rectEl.style.stroke = rect.borderColor || rect.color;
           rectEl.style.strokeWidth = (rect.borderWidth !== undefined ? rect.borderWidth : 2) + "px";
           if (rect.lineStyle === "dashed") { rectEl.style.strokeDasharray = "10,5"; }
           else if (rect.lineStyle === "dotted") { rectEl.style.strokeDasharray = "2,4"; }
           else { rectEl.style.strokeDasharray = "none"; }
           rectEl.style.cursor = "move";
           
           rectEl.addEventListener("click", (e) => {
		   if (isViewOnly()) return;
             if (rectDrawMode) return;
             e.stopPropagation();
             currentRectId = rect.id;
             selectTheRect(rect.id);
           });
           
           rectEl.addEventListener("contextmenu", (e) => {
		    if (isViewOnly()) return;
             e.preventDefault();
             e.stopPropagation();
             if (selectedRects.has(rect.id)) {
               selectedRects.delete(rect.id);
             } else {
               selectedRects.add(rect.id);
             }
             updateAllSelections();
           });
           
           let rectLastTap = 0;
           rectEl.addEventListener("touchend", (e) => {
             const now = Date.now();
             if (now - rectLastTap < 300) {
               e.preventDefault();
               if (selectedRects.has(rect.id)) {
                 selectedRects.delete(rect.id);
               } else {
                 selectedRects.add(rect.id);
               }
               updateAllSelections();
               if (navigator.vibrate) navigator.vibrate(50);
               rectLastTap = 0;
             } else {
               rectLastTap = now;
             }
           }, { passive: false });
           
           const deleteBtn = document.createElementNS(ns, "g");
           deleteBtn.classList.add("rect-delete-btn");
           deleteBtn.style.cursor = "pointer";
           deleteBtn.style.display = rectDrawMode ? "block" : "none";
           
           const deleteBg = document.createElementNS(ns, "circle");
           deleteBg.setAttribute("cx", rect.x + rect.width - 10);
           deleteBg.setAttribute("cy", rect.y + 10);
           deleteBg.setAttribute("r", 12);
           deleteBg.style.fill = "#f56565";
           deleteBg.style.stroke = "white";
           deleteBg.style.strokeWidth = "2";
           
           const deleteX = document.createElementNS(ns, "text");
           deleteX.setAttribute("x", rect.x + rect.width - 10);
           deleteX.setAttribute("y", rect.y + 10);
           deleteX.setAttribute("text-anchor", "middle");
           deleteX.setAttribute("dominant-baseline", "middle");
           deleteX.style.fill = "white";
           deleteX.style.fontSize = "16px";
           deleteX.style.fontWeight = "bold";
           deleteX.style.pointerEvents = "none";
           deleteX.textContent = "√ó";
           
           deleteBtn.appendChild(deleteBg);
           deleteBtn.appendChild(deleteX);
           
           deleteBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            e.preventDefault();
            deleteRectangle(rect.id);
           });
           
           deleteBtn.addEventListener("touchend", (e) => {
      e.stopPropagation();
           e.preventDefault();
           deleteRectangle(rect.id);
           });
      
           let isDragging = false;
           let dragStartX, dragStartY;
           let rectStartX, rectStartY;
           
           rectEl.addEventListener("mousedown", (e) => {
      if (rectDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      rectStartX = rect.x;
      rectStartY = rect.y;
      rectEl.style.cursor = "grabbing";
      
      if (selectedRects.has(rect.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
           
      const moveHandler = (e) => {
      if (!isDragging || rectDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      rect.x = rectStartX + dx;
      rect.y = rectStartY + dy;
      if (selectedRects.has(rect.id)) {
      selectedNodes.forEach(nodeId => { if (initialPositions[nodeId]) { savedPositions[nodeId] = { x: initialPositions[nodeId].x + dx, y: initialPositions[nodeId].y + dy }; } });
      selectedRects.forEach(rectId => { if (rectId === rect.id) return; const r = RECT_DATA.list.find(x => x.id === rectId); if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; } });
      selectedTexts.forEach(textId => { const t = TEXT_DATA.list.find(x => x.id === textId); if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; } });
      selectedEdges.forEach(edgeId => { const ed = EDGE_DATA.list.find(x => x.id === edgeId); if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); } });
      }
      forgeTheTopology();
      };
           
           const upHandler = () => {
            if (isDragging) {
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           };
           
           document.addEventListener("mousemove", moveHandler);
           document.addEventListener("mouseup", upHandler);
           
           let touchStartX, touchStartY;
           let touchRectStartX, touchRectStartY;
           
           rectEl.addEventListener("touchstart", (e) => {
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchRectStartX = rect.x;
            touchRectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           }, { passive: false });
           
           rectEl.addEventListener("touchmove", (e) => {
            if (!isDragging || rectDrawMode) return;
            if (!e.touches[0]) return;
            e.preventDefault();
            e.stopPropagation();
            
            const svgEl = svg;
            const pt1 = svgEl.createSVGPoint();
            pt1.x = touchStartX;
            pt1.y = touchStartY;
            const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
            
            const touch = e.touches[0];
            const pt2 = svgEl.createSVGPoint();
            pt2.x = touch.clientX;
            pt2.y = touch.clientY;
            const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
            
            const dx = svgP2.x - svgP1.x;
            const dy = svgP2.y - svgP1.y;
            
            rect.x = touchRectStartX + dx;
            rect.y = touchRectStartY + dy;
            
            forgeTheTopology();
           }, { passive: false });
           
           rectEl.addEventListener("touchend", (e) => {
            if (isDragging) {
             e.preventDefault();
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           }, { passive: false });
            if (currentRectId === rect.id) {
      const corners = [
      { cx: rect.x, cy: rect.y, cursor: 'nwse-resize', dx: -1, dy: -1 },
      { cx: rect.x + rect.width, cy: rect.y, cursor: 'nesw-resize', dx: 1, dy: -1 },
      { cx: rect.x, cy: rect.y + rect.height, cursor: 'nesw-resize', dx: -1, dy: 1 },
      { cx: rect.x + rect.width, cy: rect.y + rect.height, cursor: 'nwse-resize', dx: 1, dy: 1 }
      ];
      corners.forEach((corner, idx) => {
      const handle = document.createElementNS(ns, "circle");
      handle.setAttribute("cx", corner.cx);
      handle.setAttribute("cy", corner.cy);
      handle.setAttribute("r", 8);
      handle.style.fill = "#f59e0b";
      handle.style.stroke = "#fff";
      handle.style.strokeWidth = "2";
      handle.style.cursor = corner.cursor;
      handle.addEventListener("mousedown", (e) => {
      e.preventDefault();
      e.stopPropagation();
      let dragging = true;
      const startX = e.clientX, startY = e.clientY;
      const origX = rect.x, origY = rect.y, origW = rect.width, origH = rect.height;
      const moveHandler = (ev) => {
        if (!dragging) return;
        const pt1 = svg.createSVGPoint(); pt1.x = startX; pt1.y = startY;
        const pt2 = svg.createSVGPoint(); pt2.x = ev.clientX; pt2.y = ev.clientY;
        const svgP1 = pt1.matrixTransform(svg.getScreenCTM().inverse());
        const svgP2 = pt2.matrixTransform(svg.getScreenCTM().inverse());
        const dx = svgP2.x - svgP1.x, dy = svgP2.y - svgP1.y;
        if (corner.dx < 0) { rect.x = origX + dx; rect.width = origW - dx; }
        else { rect.width = origW + dx; }
        if (corner.dy < 0) { rect.y = origY + dy; rect.height = origH - dy; }
        else { rect.height = origH + dy; }
        if (rect.width < 20) rect.width = 20;
        if (rect.height < 20) rect.height = 20;
        forgeTheTopology();
      };
      const upHandler = () => { dragging = false; document.removeEventListener("mousemove", moveHandler); document.removeEventListener("mouseup", upHandler); };
      document.addEventListener("mousemove", moveHandler);
      document.addEventListener("mouseup", upHandler);
      });
      g.appendChild(handle);
      });
      }
            if (rect.groupId) {
             const groupIndicator = document.createElementNS(ns, "rect");
             groupIndicator.setAttribute("x", rect.x - 4);
             groupIndicator.setAttribute("y", rect.y - 4);
             groupIndicator.setAttribute("width", rect.width + 8);
             groupIndicator.setAttribute("height", rect.height + 8);
             groupIndicator.style.fill = "none";
        groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
             groupIndicator.style.strokeWidth = "3";
             groupIndicator.style.strokeDasharray = "5,5";
             groupIndicator.style.pointerEvents = "none";
             g.insertBefore(groupIndicator, g.firstChild);
           }
           g.appendChild(rectEl);
           g.appendChild(deleteBtn);
           svg.appendChild(g);
          }
         });
        }
        const centerY = CANVAS_HEIGHT / 2;
        let positions = {};
        
        Object.keys(NODE_DATA).forEach((id) => {
         if (currentView.mode === "rack") {
          const node = NODE_DATA[id];
          if (!node || node.assignedRack !== currentView.rackId) {
           return;
          }
         }
         
         positions[id] = savedPositions[id] || {
          x: centerX,
          y: centerY
         };
        });
        if (Object.keys(savedPositions).length === 0) {
         const nodeIds = Object.keys(NODE_DATA).filter(id => {
          if (currentView.mode === "rack") {
           const node = NODE_DATA[id];
           return node && node.assignedRack === currentView.rackId;
          }
          return true;
         });
         
         const baseY = centerY - 300;
         if (nodeIds.length > 0) {
          positions[nodeIds[0]] = {
           x: centerX,
           y: baseY
          };
          const remaining = nodeIds.slice(1);
          const radius = 350;
          const startAngle = Math.PI * 0.3;
          const endAngle = Math.PI * 0.7;
          remaining.forEach((id, i) => {
           const angle = startAngle + (endAngle - startAngle) * (i / Math.max(1, remaining.length - 1));
           positions[id] = {
            x: centerX + Math.cos(angle) * radius * (i % 2 === 0 ? 1 : 1.3),
            y: baseY + 200 + Math.sin(angle) * radius * 0.8 + i * 80,
           };
          });
         }
        }
        Object.keys(positions).forEach((id) => {
         let pos = savedPositions[id] || positions[id];
         const nodeSize = savedSizes[id] || 55;
         pos.x = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, pos.x), );
         pos.y = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, pos.y), );
         positions[id] = {
          x: pos.x,
          y: pos.y
         };
         savedPositions[id] = {
          x: pos.x,
          y: pos.y
         };
        });
        const edgePairCount = {};
        const edgePairIndex = {};
        EDGE_DATA.list.forEach((edge) => {
         if (edge.type === "custom") return;
         const key = [edge.from, edge.to].sort().join("||");
         edgePairCount[key] = (edgePairCount[key] || 0) + 1;
        });
        EDGE_DATA.list.forEach((edge) => {
         if (edge.type === "custom") return;
         const key = [edge.from, edge.to].sort().join("||");
         if (!edgePairIndex[key]) edgePairIndex[key] = 0;
         edge._pairIndex = edgePairIndex[key];
         edge._pairTotal = edgePairCount[key];
         edgePairIndex[key]++;
        });
        EDGE_DATA.list.forEach((edge) => {
         if (edge.type === "custom" && Array.isArray(edge.points) && edge.points.length >= 2) {
          const customEdgeFaded = currentView.mode !== "rack" && edge.from && edge.to && (!isNodeVisible(edge.from) || !isNodeVisible(edge.to));
          const poly = document.createElementNS(ns, "polyline");
          poly.classList.add("edge");
          if (customEdgeFaded) {
           poly.style.opacity = "0.25";
           poly.classList.add("layer-faded");
          }
          poly.dataset.edgeId = edge.id;
poly.style.stroke = edge.color || PAGE_STATE.defaultEdge || "#475569";
          poly.style.strokeWidth = edge.width || 4;
          poly.setAttribute("fill", "none");
          const lineStyle = edge.lineStyle || "solid";
          if (lineStyle === "dashed") {
           poly.style.strokeDasharray = "10,5";
          } else if (lineStyle === "dotted") {
           poly.style.strokeDasharray = "2,4";
          } else {
           poly.style.strokeDasharray = "none";
          }
          const direction = edge.direction || "none";
          if (direction === "forward") {
           poly.setAttribute("marker-end", "url(#arrow-forward)");
          } else if (direction === "backward") {
           poly.setAttribute("marker-start", "url(#arrow-backward)");
          } else if (direction === "both") {
           poly.setAttribute("marker-start", "url(#arrow-backward)");
           poly.setAttribute("marker-end", "url(#arrow-forward)");
          }
          const ptsStr = edge.points.map((p) => `${p.x},${p.y}`).join(" ");
          poly.setAttribute("points", ptsStr);
          const polyHit = document.createElementNS(ns, "polyline");
          polyHit.setAttribute("points", ptsStr);
          polyHit.style.fill = "none";
          polyHit.style.stroke = "transparent";
          polyHit.style.strokeWidth = "20";
          polyHit.style.cursor = "pointer";
          polyHit.dataset.edgeId = edge.id;
          polyHit.addEventListener("click", (e) => {
           e.stopPropagation();
           selectTheConnection(edge.id);
          });
          let edgeTouchStart = null;
          let edgeTouchMoved = false;
          polyHit.addEventListener("touchstart", (e) => {
          edgeTouchStart = Date.now();
          edgeTouchMoved = false;
          if (e.touches[0]) {
           edgeTouchStartX = e.touches[0].clientX;
           edgeTouchStartY = e.touches[0].clientY;
          }
         }, {
           passive: false
          });
          let edgeTouchStartX = 0, edgeTouchStartY = 0;
         polyHit.addEventListener("touchmove", (e) => {
          if (e.touches[0]) {
           const dx = Math.abs(e.touches[0].clientX - edgeTouchStartX);
           const dy = Math.abs(e.touches[0].clientY - edgeTouchStartY);
           if (dx > 10 || dy > 10) edgeTouchMoved = true;
          }
         }, {
           passive: false
          });
          polyHit.addEventListener("touchend", (e) => {
           if (edgeTouchStart && !edgeTouchMoved && Date.now() - edgeTouchStart < 400) {
            e.stopPropagation();
            e.preventDefault();
            selectTheConnection(edge.id);
           }
           edgeTouchStart = null;
           edgeTouchMoved = false;
          }, {
           passive: false
          });
          poly.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         
         polyHit.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (selectedEdges.has(edge.id)) {
           selectedEdges.delete(edge.id);
          } else {
           selectedEdges.add(edge.id);
          }
          updateAllSelections();
         });
         
         let customEdgeLastTap = 0;
         polyHit.addEventListener("touchend", (e) => {
          const now = Date.now();
          if (now - customEdgeLastTap < 300) {
           e.preventDefault();
           if (selectedEdges.has(edge.id)) {
            selectedEdges.delete(edge.id);
           } else {
            selectedEdges.add(edge.id);
           }
           updateAllSelections();
           if (navigator.vibrate) navigator.vibrate(50);
           customEdgeLastTap = 0;
          } else {
           customEdgeLastTap = now;
          }
         }, { passive: false });
         
         poly.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (selectedEdges.has(edge.id)) {
           selectedEdges.delete(edge.id);
          } else {
           selectedEdges.add(edge.id);
          }
          updateAllSelections();
         });
         
         let edgeLastTap = 0;
         poly.addEventListener("touchend", (e) => {
          const now = Date.now();
          if (now - edgeLastTap < 300) {
           e.preventDefault();
           if (selectedEdges.has(edge.id)) {
            selectedEdges.delete(edge.id);
           } else {
            selectedEdges.add(edge.id);
           }
           updateAllSelections();
           if (navigator.vibrate) navigator.vibrate(50);
           edgeLastTap = 0;
          } else {
           edgeLastTap = now;
          }
         });
          
          if (currentView.mode === "rack") {
           return;
          }
          if (edge.groupId) {
      const bounds = edge.points.reduce((acc, p) => ({ minX: Math.min(acc.minX, p.x), minY: Math.min(acc.minY, p.y), maxX: Math.max(acc.maxX, p.x), maxY: Math.max(acc.maxY, p.y) }), { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity });
      const groupIndicator = document.createElementNS(ns, "rect");
      groupIndicator.setAttribute("x", bounds.minX - 8);
      groupIndicator.setAttribute("y", bounds.minY - 8);
      groupIndicator.setAttribute("width", bounds.maxX - bounds.minX + 16);
      groupIndicator.setAttribute("height", bounds.maxY - bounds.minY + 16);
      groupIndicator.setAttribute("rx", "4");
      groupIndicator.style.fill = "none";
  groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
      groupIndicator.style.strokeWidth = "3";
      groupIndicator.style.strokeDasharray = "5,5";
      groupIndicator.style.pointerEvents = "none";
      svg.appendChild(groupIndicator);
      }
         let lineDragging = false;
      let lineDragStartX, lineDragStartY;
      let linePointsStart = [];
      
      polyHit.addEventListener("mousedown", (e) => {
      if (freeDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      lineDragging = true;
      lineDragStartX = e.clientX;
      lineDragStartY = e.clientY;
      linePointsStart = edge.points.map(p => ({x: p.x, y: p.y}));
      
      if (selectedEdges.has(edge.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
      
      const lineMoveHandler = (e) => {
      if (!lineDragging || freeDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = lineDragStartX;
      pt1.y = lineDragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      
      edge.points.forEach((p, i) => { p.x = linePointsStart[i].x + dx; p.y = linePointsStart[i].y + dy; });
      
      if (selectedEdges.has(edge.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       savedPositions[nodeId] = { x: initialPositions[nodeId].x + dx, y: initialPositions[nodeId].y + dy };
      }
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      if (edgeId === edge.id) return;
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      forgeTheTopology();
      };
      
      const lineUpHandler = () => { lineDragging = false; };
      document.addEventListener("mousemove", lineMoveHandler);
      document.addEventListener("mouseup", lineUpHandler);
      
      svg.appendChild(poly);
      svg.appendChild(polyHit);
         
         if (currentEdgeId === edge.id) {
          edge.points.forEach((p, idx) => {
           const c = document.createElementNS(ns, "circle");
           c.classList.add("edge-edit-point");
           c.setAttribute("cx", p.x);
           c.setAttribute("cy", p.y);
		   c.setAttribute("r", PAGE_STATE.selectionHandleSize || 8);
           c.style.fill = PAGE_STATE.selectionHandle || "#f59e0b";
           c.style.stroke = "#fff";
           c.style.strokeWidth = "2";
           c.style.cursor = "move";
           c.dataset.edgeId = edge.id;
           c.dataset.pointIndex = String(idx);
           
           c.addEventListener("mousedown", (e) => {
            e.preventDefault();
            e.stopPropagation();
            let dragging = true;
            const svgEl = svg;
            const moveHandler = (ev) => {
             if (!dragging) return;
             const pt = svgEl.createSVGPoint();
             pt.x = ev.clientX;
             pt.y = ev.clientY;
             const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
             edge.points[idx].x = svgP.x;
             edge.points[idx].y = svgP.y;
             forgeTheTopology();
            };
            const upHandler = () => {
             dragging = false;
             document.removeEventListener("mousemove", moveHandler);
             document.removeEventListener("mouseup", upHandler);
            };
            document.addEventListener("mousemove", moveHandler);
            document.addEventListener("mouseup", upHandler);
           });
           
           c.addEventListener("touchstart", (e) => {
            e.preventDefault();
            e.stopPropagation();
            let dragging = true;
            const svgEl = svg;
            const touchMoveHandler = (ev) => {
             if (!dragging || !ev.touches[0]) return;
             const pt = svgEl.createSVGPoint();
             pt.x = ev.touches[0].clientX;
             pt.y = ev.touches[0].clientY;
             const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
             edge.points[idx].x = svgP.x;
             edge.points[idx].y = svgP.y;
             forgeTheTopology();
            };
            const touchUpHandler = () => {
             dragging = false;
             document.removeEventListener("touchmove", touchMoveHandler);
             document.removeEventListener("touchend", touchUpHandler);
            };
            document.addEventListener("touchmove", touchMoveHandler);
            document.addEventListener("touchend", touchUpHandler);
           }, { passive: false });
           
           svg.appendChild(c);
          });
         }
         
         return;
         }
         const p1 = positions[edge.from];
         const p2 = positions[edge.to];
         if (!p1 || !p2) return;
         const edgeFaded = currentView.mode !== "rack" && (!isNodeVisible(edge.from) || !isNodeVisible(edge.to));
         const pairTotal = edge._pairTotal || 1;
         const pairIndex = edge._pairIndex || 0;
         const midX = (p1.x + p2.x) / 2;
         const midY = (p1.y + p2.y) / 2;
         const dx = p2.x - p1.x;
         const dy = p2.y - p1.y;
         const len = Math.sqrt(dx * dx + dy * dy) || 1;
         const perpX = -dy / len;
         const perpY = dx / len;
         let offsetAmount = 0;
         if (pairTotal > 1) {
          offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
         }
         const ctrlX = midX + perpX * offsetAmount;
         const ctrlY = midY + perpY * offsetAmount;
         const path = document.createElementNS(ns, "path");
         path.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
         path.setAttribute("fill", "none");
         path.classList.add("edge");
         if (edgeFaded) {
          path.style.opacity = "0.25";
          path.classList.add("layer-faded");
         }
         if (edge.type === "backup") path.classList.add("backup");
         path.dataset.edgeId = edge.id;
         path.dataset.from = edge.from;
         path.dataset.to = edge.to;
         path.style.stroke = edge.color;
         path.style.strokeWidth = edge.width;
         const pathHit = document.createElementNS(ns, "path");
         pathHit.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
         pathHit.setAttribute("fill", "none");
         pathHit.style.stroke = "transparent";
         pathHit.style.strokeWidth = "20";
         pathHit.style.cursor = "pointer";
         pathHit.dataset.edgeId = edge.id;
         pathHit.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         let pathTouchStart = null;
         let pathTouchMoved = false;
         pathHit.addEventListener("touchstart", (e) => {
         pathTouchStart = Date.now();
         pathTouchMoved = false;
         if (e.touches[0]) {
          pathTouchStartX = e.touches[0].clientX;
          pathTouchStartY = e.touches[0].clientY;
         }
        }, {
          passive: false
         });
         let pathTouchStartX = 0, pathTouchStartY = 0;
        pathHit.addEventListener("touchmove", (e) => {
         if (e.touches[0]) {
          const dx = Math.abs(e.touches[0].clientX - pathTouchStartX);
          const dy = Math.abs(e.touches[0].clientY - pathTouchStartY);
          if (dx > 10 || dy > 10) pathTouchMoved = true;
         }
        }, {
          passive: false
         });
         pathHit.addEventListener("touchend", (e) => {
          if (pathTouchStart && !pathTouchMoved && Date.now() - pathTouchStart < 400) {
           e.stopPropagation();
           e.preventDefault();
           selectTheConnection(edge.id);
          }
          pathTouchStart = null;
          pathTouchMoved = false;
         }, {
          passive: false
         });
         path.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         
         if (currentView.mode === "rack") {
          const fromNode = NODE_DATA[edge.from];
          const toNode = NODE_DATA[edge.to];
          if (!fromNode || !toNode || 
              fromNode.assignedRack !== currentView.rackId || 
              toNode.assignedRack !== currentView.rackId) {
           return;
          }
         }
         
         svg.appendChild(path);
         svg.appendChild(pathHit);
         
         if (edge.fromPort || edge.toPort) {
          const ns = "http://www.w3.org/2000/svg";
          
          if (edge.fromPort) {
           const fromLabel = document.createElementNS(ns, "text");
           fromLabel.textContent = edge.fromPort;
           fromLabel.setAttribute("x", p1.x);
           fromLabel.setAttribute("y", p1.y - 10);
           fromLabel.setAttribute("text-anchor", "middle");
           fromLabel.style.fill = "#94a3b8";
           fromLabel.style.fontSize = "12px";
           fromLabel.style.fontWeight = "600";
           fromLabel.style.pointerEvents = "none";
           fromLabel.classList.add("port-label");
           svg.appendChild(fromLabel);
          }
      
          if (edge.toPort) {
           const toLabel = document.createElementNS(ns, "text");
           toLabel.textContent = edge.toPort;
           toLabel.setAttribute("x", p2.x);
           toLabel.setAttribute("y", p2.y - 10);
           toLabel.setAttribute("text-anchor", "middle");
           toLabel.style.fill = "#94a3b8";
           toLabel.style.fontSize = "12px";
           toLabel.style.fontWeight = "600";
           toLabel.style.pointerEvents = "none";
           toLabel.classList.add("port-label");
           svg.appendChild(toLabel);
          }
         }
        });
        Object.entries(positions).forEach(([id, pos]) => {
         const node = NODE_DATA[id];
         if (!node) return;
         
         if (currentView.mode === "rack") {
          if (node.assignedRack !== currentView.rackId) return;
          
         const rackUnit = parseInt(node.rackUnit) || 1;
      const uHeight = parseInt(node.uHeight) || 1;
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      pos.x = RACK_START_X;
      pos.y = RACK_START_Y + (rackCapacity - rackUnit - uHeight + 1) * rackUHeight + (uHeight * rackUHeight) / 2;
         } else {
          if (node.assignedRack) return;
         }
         
         const g = document.createElementNS("http://www.w3.org/2000/svg", "g", );
         g.classList.add("node-group");
         g.dataset.nodeId = id;
         g.setAttribute("transform", `translate(${pos.x},${pos.y})`);
         if (currentView.mode !== "rack" && !isNodeVisible(id)) {
          g.style.opacity = "0.25";
          g.classList.add("layer-faded");
         }
         let r = savedSizes[id] || 55;
         if (!savedSizes[id]) {
          if (window.innerWidth <= 380) r = 120;
          else if (window.innerWidth <= 768) r = 140;
          else if (window.innerWidth <= 1024) r = 70;
         }
         const styles = resolveStylesForNode(id);
         const ns = "http://www.w3.org/2000/svg";
         const hitArea = document.createElementNS(ns, "circle");
         hitArea.setAttribute("r", r * 1.5);
         hitArea.style.fill = "transparent";
         hitArea.style.stroke = "none";
         hitArea.style.cursor = "grab";
         hitArea.classList.add("node-hit-area");
         const shapeEl = createNodeShape(id, r);
         const titleOffsetX = styles.titleOffsetX || 0;
         const titleOffsetY = styles.titleOffsetY || 0;
         const subOffsetX = styles.subOffsetX || 0;
         const subOffsetY = styles.subOffsetY || 0;
         const label = document.createElementNS("http://www.w3.org/2000/svg", "text", );
         label.classList.add("node-label");
         label.setAttribute("x", titleOffsetX);
         label.setAttribute("y", -r * 0.28 + titleOffsetY);
         const labelFontSize = styles.titleSize || PAGE_STATE.nodeTitleSize || r * 0.33;
        label.style.fontSize = labelFontSize + "px";
         label.textContent = NODE_DATA[id].name;
label.style.fill = styles.titleColor || PAGE_STATE.nodeTitle || "#e2e8f0";
        label.style.fontFamily = styles.titleFont || PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
         label.style.pointerEvents = "none";
         const sub = document.createElementNS("http://www.w3.org/2000/svg", "text", );
         sub.classList.add("node-sub");
         sub.setAttribute("x", subOffsetX);
         sub.setAttribute("y", r * 0.4 + subOffsetY);
         const subFontSize = styles.subSize || PAGE_STATE.nodeSubSize || r * 0.24;
        sub.style.fontSize = subFontSize + "px";
         sub.textContent = NODE_DATA[id].ip;
sub.style.fill = styles.subColor || PAGE_STATE.nodeSub || "#94a3b8";
        sub.style.fontFamily = styles.subFont || PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
         sub.style.pointerEvents = "none";
         g.append(hitArea, shapeEl, label, sub);
         
         if (NODE_DATA[id]?.locked) {
           const lockIndicator = document.createElementNS(ns, "text");
           lockIndicator.textContent = "üîí";
           lockIndicator.setAttribute("x", r * 0.7);
           lockIndicator.setAttribute("y", -r * 0.7);
           lockIndicator.style.fontSize = (r * 0.3) + "px";
           lockIndicator.style.pointerEvents = "none";
           lockIndicator.classList.add("lock-indicator");
           g.appendChild(lockIndicator);
         }
         
         if (NODE_DATA[id]?.groupId) {
           const groupIndicator = document.createElementNS(ns, "circle");
           groupIndicator.setAttribute("r", r + 4);
           groupIndicator.style.fill = "none";
         groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
           groupIndicator.style.strokeWidth = "3";
           groupIndicator.style.strokeDasharray = "5,5";
           groupIndicator.style.pointerEvents = "none";
           groupIndicator.classList.add("group-indicator");
           
           g.insertBefore(groupIndicator, g.firstChild);
         }
         
         let isDragging = false;
         let startX, startY;
         let initialPositions = {};
         let longPressTimer = null;
         let longPressTriggered = false;
         
         g.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (isViewOnly()) return;
          
          if (selectedNodes.has(id)) {
           selectedNodes.delete(id);
          } else {
           selectedNodes.add(id);
          }
          updateNodeSelection();
          return false;
         });
         
        g.addEventListener("touchstart", (e) => {
         if (NODE_DATA[id].isRack) {
          const touch = e.touches[0];
          longPressStartX = touch.clientX;
          longPressStartY = touch.clientY;
          longPressTimer = setTimeout(() => {
           longPressTriggered = true;
           if (navigator.vibrate) {
            navigator.vibrate(100);
           }
           enterRack(id);
          }, 500);
         }
        }, { passive: true });
        
        g.addEventListener("dblclick", (e) => {
         e.preventDefault();
         e.stopPropagation();
         if (NODE_DATA[id].isRack) {
          enterRack(id);
         }
        });
        
        let lastTapTime = 0;
        let lastTapNode = null;
        
        g.addEventListener("touchend", (e) => {
         const currentTime = new Date().getTime();
         const tapLength = currentTime - lastTapTime;
         
         if (tapLength < 300 && tapLength > 0 && lastTapNode === id) {
          e.preventDefault();
          e.stopPropagation();
          if (isViewOnly()) return;
          
          if (selectedNodes.has(id)) {
           selectedNodes.delete(id);
          } else {
           selectedNodes.add(id);
          }
          updateNodeSelection();
          
          if (navigator.vibrate) {
           navigator.vibrate(50);
          }
          
          lastTapTime = 0;
          lastTapNode = null;
         } else {
          lastTapTime = currentTime;
          lastTapNode = id;
         }
        });
         
         g.addEventListener("touchend", (e) => {
          if (longPressTimer) {
           clearTimeout(longPressTimer);
           longPressTimer = null;
          }
          if (longPressTriggered) {
           e.preventDefault();
           e.stopPropagation();
           longPressTriggered = false;
          }
         });
         
         let longPressStartX = 0;
        let longPressStartY = 0;
        g.addEventListener("touchmove", (e) => {
         if (longPressTimer) {
          const touch = e.touches[0];
          const dx = Math.abs(touch.clientX - longPressStartX);
          const dy = Math.abs(touch.clientY - longPressStartY);
          if (dx > 15 || dy > 15) {
           clearTimeout(longPressTimer);
           longPressTimer = null;
           longPressTriggered = false;
          }
         }
        });
         
         g.addEventListener("mousedown", (e) => {
          if (isViewOnly()) return;
          if (e.button === 2) {
           return;
          }
          
          if (NODE_DATA[id]?.locked) {
           return;
          }
          
          e.preventDefault();
          isDragging = true;
          const svgEl = document.getElementById("map");
          const pt = svgEl.createSVGPoint();
          pt.x = e.clientX;
          pt.y = e.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          startX = svgP.x;
          startY = svgP.y;
          
          let nodesToCollect = [];
      
      
      if (selectedNodes.has(id)) {
      initialPositions = {};
      const allSelectedRects = Array.from(selectedRects);
      const allSelectedTexts = Array.from(selectedTexts);
      const allSelectedEdges = Array.from(selectedEdges).map(eid => EDGE_DATA.list.find(e => e.id === eid)).filter(Boolean);
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) {
      initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      }
      });
      Array.from(selectedRects).forEach(rectId => {
        const rect = RECT_DATA.list.find(r => r.id === rectId);
        if (rect) { rect._dragStartX = rect.x; rect._dragStartY = rect.y; }
      });
      Array.from(selectedTexts).forEach(textId => {
        const text = TEXT_DATA.list.find(t => t.id === textId);
        if (text) { text._dragStartX = text.x; text._dragStartY = text.y; }
      });
      Array.from(selectedEdges).forEach(edgeId => {
        const edge = EDGE_DATA.list.find(e => e.id === edgeId);
        if (edge && edge.points) { edge._dragStartPoints = edge.points.map(p => ({x: p.x, y: p.y})); }
      });
      
      
      } else {
      initialPositions = { [id]: { x: pos.x, y: pos.y } };
      }
          
          const groupIds = new Set();
          nodesToCollect.forEach(nodeId => {
           const groupId = NODE_DATA[nodeId]?.groupId;
           if (groupId) {
             groupIds.add(groupId);
           }
          });
          
          if (groupIds.size > 0) {
           Object.keys(NODE_DATA).forEach(nodeId => {
             const nodeGroupId = NODE_DATA[nodeId]?.groupId;
             if (nodeGroupId && groupIds.has(nodeGroupId)) {
               if (!nodesToCollect.includes(nodeId)) {
                 nodesToCollect.push(nodeId);
               }
             }
           });
          }
          
          nodesToCollect = nodesToCollect.filter(nodeId => !NODE_DATA[nodeId]?.locked);
          
          if (nodesToCollect.length === 0) {
           return;
          }
          
          initialPositions = {};
          nodesToCollect.forEach(nodeId => {
           const nodePos = savedPositions[nodeId];
           if (nodePos) {
            initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
           }
          });
          
          g.style.cursor = "grabbing";
          hitArea.style.cursor = "grabbing";
          e.stopPropagation();
         });
         const handleMouseMove = (e) => {
          if (!isDragging) return;
          e.preventDefault();
          const svgEl = document.getElementById("map");
          const pt = svgEl.createSVGPoint();
          pt.x = e.clientX;
          pt.y = e.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          const dx = svgP.x - startX;
          const dy = svgP.y - startY;
          
          const nodesToMove = selectedNodes.has(id) ? Array.from(selectedNodes) : [id];
          nodesToMove.forEach(nodeId => {
           if (!initialPositions[nodeId]) return;
           const initialPos = initialPositions[nodeId];
           let newX = initialPos.x + dx;
           let newY = initialPos.y + dy;
           const nodeSize = savedSizes[nodeId] || 55;
           newX = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, newX), );
           newY = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, newY), );
           
           savedPositions[nodeId] = { x: newX, y: newY };
           positions[nodeId] = { x: newX, y: newY };
           
           if (nodeId === id) {
            pos.x = newX;
            pos.y = newY;
           }
           
           const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
          if (nodeGroup) {
           nodeGroup.setAttribute("transform", `translate(${newX},${newY})`);
          }
         });
         
         Array.from(selectedRects).forEach(rectId => {
           const rect = RECT_DATA.list.find(r => r.id === rectId);
           if (rect && rect._dragStartX !== undefined) {
             rect.x = rect._dragStartX + dx;
             rect.y = rect._dragStartY + dy;
           }
         });
         Array.from(selectedTexts).forEach(textId => {
           const text = TEXT_DATA.list.find(t => t.id === textId);
           if (text && text._dragStartX !== undefined) {
             text.x = text._dragStartX + dx;
             text.y = text._dragStartY + dy;
           }
         });
         Array.from(selectedEdges).forEach(edgeId => {
           const edge = EDGE_DATA.list.find(e => e.id === edgeId);
           if (edge && edge._dragStartPoints) {
             edge.points.forEach((p, i) => {
               p.x = edge._dragStartPoints[i].x + dx;
               p.y = edge._dragStartPoints[i].y + dy;
             });
           }
         });
         forgeTheTopology();
         
         updateMinimap();
          document.querySelectorAll(".edge").forEach((edgeEl) => {
           const fromId = edgeEl.dataset.from;
           const toId = edgeEl.dataset.to;
           if (nodesToMove.includes(fromId) || nodesToMove.includes(toId)) {
            const p1 = savedPositions[fromId] || positions[fromId] || {
             x: 600,
             y: 350
            };
            const p2 = savedPositions[toId] || positions[toId] || {
             x: 600,
             y: 350
            };
            if (edgeEl.tagName === "line") {
             edgeEl.setAttribute("x1", p1.x);
             edgeEl.setAttribute("y1", p1.y);
             edgeEl.setAttribute("x2", p2.x);
             edgeEl.setAttribute("y2", p2.y);
            } else if (edgeEl.tagName === "path") {
             const edgeId = edgeEl.dataset.edgeId;
             const edge = EDGE_DATA.list.find(
              (e) => e.id === edgeId, );
             if (edge) {
              const pairTotal = edge._pairTotal || 1;
              const pairIndex = edge._pairIndex || 0;
              const midX = (p1.x + p2.x) / 2;
              const midY = (p1.y + p2.y) / 2;
              const dx = p2.x - p1.x;
              const dy = p2.y - p1.y;
              const len = Math.sqrt(dx * dx + dy * dy) || 1;
              const perpX = -dy / len;
              const perpY = dx / len;
              let offsetAmount = 0;
              if (pairTotal > 1) {
               offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
              }
              const ctrlX = midX + perpX * offsetAmount;
              const ctrlY = midY + perpY * offsetAmount;
              edgeEl.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
             }
            }
           }
          });
         };
      const handleMouseUp = () => {
      if (isDragging) {
      pushUndo("move nodes");
      isDragging = false;
      g.style.cursor = "grab";
      hitArea.style.cursor = "grab";
      if (currentView.mode === "rack" && NODE_DATA[id]?.assignedRack === currentView.rackId) {
      const draggedY = savedPositions[id]?.y || pos.y;
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      let newUnit = rackCapacity - Math.round((draggedY - RACK_START_Y) / rackUHeight);
      newUnit = Math.max(1, Math.min(newUnit, rackCapacity));
      NODE_DATA[id].rackUnit = newUnit;
      forgeTheTopology();
      claimTheImmortal(id);
      }
      }
      };
         document.addEventListener("mousemove", handleMouseMove);
         document.addEventListener("mouseup", handleMouseUp);
         let touchStartTime = 0;
         let touchStartX = 0;
         let touchStartY = 0;
         let touchMoved = false;
       g.addEventListener("touchstart",
         (e) => {
          if (NODE_DATA[id]?.locked) {
           return;
          }
          
          e.preventDefault();
          touchStartTime = Date.now();
          touchMoved = false;
          const svgEl = document.getElementById("map");
          const pt = svgEl.createSVGPoint();
          const touch = e.touches[0];
          pt.x = touch.clientX;
          pt.y = touch.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          touchStartX = svgP.x;
          touchStartY = svgP.y;
          startX = svgP.x;
          startY = svgP.y;
          
          let nodesToCollect = [];
          if (selectedNodes.has(id)) {
           nodesToCollect = Array.from(selectedNodes);
          } else {
           nodesToCollect = [id];
          }
          
          const groupIds = new Set();
          nodesToCollect.forEach(nodeId => {
           const groupId = NODE_DATA[nodeId]?.groupId;
           if (groupId) {
             groupIds.add(groupId);
           }
          });
          
          if (groupIds.size > 0) {
           Object.keys(NODE_DATA).forEach(nodeId => {
             const nodeGroupId = NODE_DATA[nodeId]?.groupId;
             if (nodeGroupId && groupIds.has(nodeGroupId)) {
               if (!nodesToCollect.includes(nodeId)) {
                 nodesToCollect.push(nodeId);
               }
             }
           });
          }
          
          nodesToCollect = nodesToCollect.filter(nodeId => !NODE_DATA[nodeId]?.locked);
          
          if (nodesToCollect.length === 0) {
           return;
          }
          
          initialPositions = {};
          nodesToCollect.forEach(nodeId => {
           const nodePos = savedPositions[nodeId];
           if (nodePos) {
            initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
           }
          });
          
          e.stopPropagation();
         }, {
          passive: false
         }, );
         g.addEventListener("touchmove", (e) => {
         e.preventDefault();
         const svgEl = document.getElementById("map");
         const pt = svgEl.createSVGPoint();
         const touch = e.touches[0];
         pt.x = touch.clientX;
         pt.y = touch.clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
         const dx = Math.abs(svgP.x - touchStartX);
         const dy = Math.abs(svgP.y - touchStartY);
         if (dx > (isMobileDevice() ? 4 : 10) || dy > (isMobileDevice() ? 4 : 10)) {
      touchMoved = true;
      isDragging = true;
      }
         if (!isDragging) return;
         
         const deltaX = svgP.x - startX;
         const deltaY = svgP.y - startY;
         
         const nodesToMove = selectedNodes.has(id) ? Array.from(selectedNodes) : [id];
         nodesToMove.forEach(nodeId => {
          if (!initialPositions[nodeId]) return;
          const initialPos = initialPositions[nodeId];
          let newX = initialPos.x + deltaX;
          let newY = initialPos.y + deltaY;
          const nodeSize = savedSizes[nodeId] || 55;
          newX = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, newX), );
          newY = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, newY), );
          
          savedPositions[nodeId] = { x: newX, y: newY };
          positions[nodeId] = { x: newX, y: newY };
          
          if (nodeId === id) {
           pos.x = newX;
           pos.y = newY;
          }
          
          const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
          if (nodeGroup) {
           nodeGroup.setAttribute("transform", `translate(${newX},${newY})`);
          }
         });
         
         updateMinimap();
         document.querySelectorAll(".edge").forEach((edgeEl) => {
          const fromId = edgeEl.dataset.from;
          const toId = edgeEl.dataset.to;
          if (nodesToMove.includes(fromId) || nodesToMove.includes(toId)) {
            const p1 = savedPositions[fromId] || positions[fromId] || {
             x: 600,
             y: 350
            };
            const p2 = savedPositions[toId] || positions[toId] || {
             x: 600,
             y: 350
            };
            if (edgeEl.tagName === "line") {
             edgeEl.setAttribute("x1", p1.x);
             edgeEl.setAttribute("y1", p1.y);
             edgeEl.setAttribute("x2", p2.x);
             edgeEl.setAttribute("y2", p2.y);
            } else if (edgeEl.tagName === "path") {
             const edgeId = edgeEl.dataset.edgeId;
             const edge = EDGE_DATA.list.find(
              (e) => e.id === edgeId, );
             if (edge) {
              const pairTotal = edge._pairTotal || 1;
              const pairIndex = edge._pairIndex || 0;
              const midX = (p1.x + p2.x) / 2;
              const midY = (p1.y + p2.y) / 2;
              const dx = p2.x - p1.x;
              const dy = p2.y - p1.y;
              const len = Math.sqrt(dx * dx + dy * dy) || 1;
              const perpX = -dy / len;
              const perpY = dx / len;
              let offsetAmount = 0;
              if (pairTotal > 1) {
               offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
              }
              const ctrlX = midX + perpX * offsetAmount;
              const ctrlY = midY + perpY * offsetAmount;
              edgeEl.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
             }
            }
           }
          });
         }, {
          passive: false
         });
      g.addEventListener("touchend", (e) => {
      const touchDuration = Date.now() - touchStartTime;
      if (!touchMoved && touchDuration < 400) {
       if (isViewOnly()) {
        handleViewOnlyClick(id, 'node');
        return;
       }
       claimTheImmortal(id);
      }
      if (isDragging) {
      const draggedY = pos.y;
      isDragging = false;
      savedPositions[id] = {
      x: pos.x,
      y: pos.y
      };
      if (currentView.mode === "rack" && NODE_DATA[id]?.assignedRack === currentView.rackId) {
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      let newUnit = rackCapacity - Math.round((draggedY - RACK_START_Y) / rackUHeight);
      newUnit = Math.max(1, Math.min(newUnit, rackCapacity));
      NODE_DATA[id].rackUnit = newUnit;
      forgeTheTopology();
      claimTheImmortal(id);
      }
      }
      touchMoved = false;
      });
         g.style.cursor = "grab";
         g.addEventListener("click", (e) => {
          if (!isDragging) {
           if (isViewOnly()) {
            handleViewOnlyClick(id, 'node');
            return;
           }
           claimTheImmortal(id);
          }
         });
         svg.appendChild(g);
        });
        
        if (RECT_DATA && RECT_DATA.list) {
         RECT_DATA.list.forEach((rect) => {
          if (currentView.mode === "rack") return;
          if (rect.style === "outlined") {
           const g = document.createElementNS(ns, "g");
           g.classList.add("rect-group");
           g.dataset.rectId = rect.id;
           
           const rectEl = document.createElementNS(ns, "rect");
           rectEl.classList.add("rect-shape");
           rectEl.setAttribute("x", rect.x);
           rectEl.setAttribute("y", rect.y);
           rectEl.setAttribute("width", rect.width);
           rectEl.setAttribute("height", rect.height);
           rectEl.style.fill = "none";
           rectEl.style.stroke = rect.borderColor || rect.color;
           rectEl.style.strokeWidth = (rect.borderWidth !== undefined ? rect.borderWidth : 3) + "px";
      if (rect.lineStyle === "dashed") { rectEl.style.strokeDasharray = "10,5"; }
           else if (rect.lineStyle === "dotted") { rectEl.style.strokeDasharray = "2,4"; }
           else { rectEl.style.strokeDasharray = "none"; }
           rectEl.style.cursor = "move";
           
           rectEl.addEventListener("click", (e) => {
             if (rectDrawMode) return;
             e.stopPropagation();
             currentRectId = rect.id;
             selectTheRect(rect.id);
           });
           
           rectEl.addEventListener("contextmenu", (e) => {
             e.preventDefault();
             e.stopPropagation();
             if (selectedRects.has(rect.id)) {
               selectedRects.delete(rect.id);
             } else {
               selectedRects.add(rect.id);
             }
             updateAllSelections();
           });
           
           let rectLastTap = 0;
           rectEl.addEventListener("touchend", (e) => {
             const now = Date.now();
             if (now - rectLastTap < 300) {
               e.preventDefault();
               if (selectedRects.has(rect.id)) {
                 selectedRects.delete(rect.id);
               } else {
                 selectedRects.add(rect.id);
               }
               updateAllSelections();
               if (navigator.vibrate) navigator.vibrate(50);
               rectLastTap = 0;
             } else {
               rectLastTap = now;
             }
           }, { passive: false });
           
           const deleteBtn = document.createElementNS(ns, "g");
           deleteBtn.classList.add("rect-delete-btn");
           deleteBtn.style.cursor = "pointer";
           deleteBtn.style.display = rectDrawMode ? "block" : "none";
           
           const deleteBg = document.createElementNS(ns, "circle");
           deleteBg.setAttribute("cx", rect.x + rect.width - 10);
           deleteBg.setAttribute("cy", rect.y + 10);
           deleteBg.setAttribute("r", 12);
           deleteBg.style.fill = "#f56565";
           deleteBg.style.stroke = "white";
           deleteBg.style.strokeWidth = "2";
           
           const deleteX = document.createElementNS(ns, "text");
           deleteX.setAttribute("x", rect.x + rect.width - 10);
           deleteX.setAttribute("y", rect.y + 10);
           deleteX.setAttribute("text-anchor", "middle");
           deleteX.setAttribute("dominant-baseline", "middle");
           deleteX.style.fill = "white";
           deleteX.style.fontSize = "16px";
           deleteX.style.fontWeight = "bold";
           deleteX.style.pointerEvents = "none";
           deleteX.textContent = "√ó";
           
           deleteBtn.appendChild(deleteBg);
           deleteBtn.appendChild(deleteX);
           
           deleteBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            e.preventDefault();
            deleteRectangle(rect.id);
           });
           
           let isDragging = false;
           let dragStartX, dragStartY;
           let rectStartX, rectStartY;
           
           rectEl.addEventListener("mousedown", (e) => {
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            dragStartX = e.clientX;
            dragStartY = e.clientY;
            rectStartX = rect.x;
            rectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           });
           
      const moveHandler = (e) => {
      if (!isDragging || rectDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      rect.x = rectStartX + dx;
      rect.y = rectStartY + dy;
      if (selectedRects.has(rect.id)) {
      selectedNodes.forEach(nodeId => { if (initialPositions[nodeId]) { savedPositions[nodeId] = { x: initialPositions[nodeId].x + dx, y: initialPositions[nodeId].y + dy }; } });
      selectedRects.forEach(rectId => { if (rectId === rect.id) return; const r = RECT_DATA.list.find(x => x.id === rectId); if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; } });
      selectedTexts.forEach(textId => { const t = TEXT_DATA.list.find(x => x.id === textId); if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; } });
      selectedEdges.forEach(edgeId => { const ed = EDGE_DATA.list.find(x => x.id === edgeId); if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); } });
      }
      forgeTheTopology();
      };
           
           const upHandler = () => {
            if (isDragging) {
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           };
           
           document.addEventListener("mousemove", moveHandler);
           document.addEventListener("mouseup", upHandler);
           
           let touchStartX, touchStartY;
           let touchRectStartX, touchRectStartY;
           
           rectEl.addEventListener("touchstart", (e) => {
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchRectStartX = rect.x;
            touchRectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           }, { passive: false });
           
           rectEl.addEventListener("touchmove", (e) => {
            if (!isDragging || rectDrawMode) return;
            if (!e.touches[0]) return;
            e.preventDefault();
            e.stopPropagation();
            
            const svgEl = svg;
            const pt1 = svgEl.createSVGPoint();
            pt1.x = touchStartX;
            pt1.y = touchStartY;
            const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
            
            const touch = e.touches[0];
            const pt2 = svgEl.createSVGPoint();
            pt2.x = touch.clientX;
            pt2.y = touch.clientY;
            const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
            
            const dx = svgP2.x - svgP1.x;
            const dy = svgP2.y - svgP1.y;
            
            rect.x = touchRectStartX + dx;
            rect.y = touchRectStartY + dy;
            
            forgeTheTopology();
           }, { passive: false });
           
           rectEl.addEventListener("touchend", (e) => {
            if (isDragging) {
             e.preventDefault();
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           }, { passive: false });
           
           if (currentRectId === rect.id) {
             const corners = [
               { cx: rect.x, cy: rect.y, cursor: 'nwse-resize', dx: -1, dy: -1 },
               { cx: rect.x + rect.width, cy: rect.y, cursor: 'nesw-resize', dx: 1, dy: -1 },
               { cx: rect.x, cy: rect.y + rect.height, cursor: 'nesw-resize', dx: -1, dy: 1 },
               { cx: rect.x + rect.width, cy: rect.y + rect.height, cursor: 'nwse-resize', dx: 1, dy: 1 }
             ];
             corners.forEach((corner) => {
               const handle = document.createElementNS(ns, "circle");
               handle.setAttribute("cx", corner.cx);
               handle.setAttribute("cy", corner.cy);
handle.setAttribute("r", PAGE_STATE.selectionHandleSize || 8);
      handle.style.fill = PAGE_STATE.selectionHandle || "#f59e0b";
               handle.style.stroke = "#fff";
               handle.style.strokeWidth = "2";
               handle.style.cursor = corner.cursor;
               handle.addEventListener("mousedown", (e) => {
                 e.preventDefault();
                 e.stopPropagation();
                 let dragging = true;
                 const startX = e.clientX, startY = e.clientY;
                 const origX = rect.x, origY = rect.y, origW = rect.width, origH = rect.height;
                 const moveHandler = (ev) => {
                   if (!dragging) return;
                   const pt1 = svg.createSVGPoint(); pt1.x = startX; pt1.y = startY;
                   const pt2 = svg.createSVGPoint(); pt2.x = ev.clientX; pt2.y = ev.clientY;
                   const svgP1 = pt1.matrixTransform(svg.getScreenCTM().inverse());
                   const svgP2 = pt2.matrixTransform(svg.getScreenCTM().inverse());
                   const dx = svgP2.x - svgP1.x, dy = svgP2.y - svgP1.y;
                   if (corner.dx < 0) { rect.x = origX + dx; rect.width = origW - dx; }
                   else { rect.width = origW + dx; }
                   if (corner.dy < 0) { rect.y = origY + dy; rect.height = origH - dy; }
                   else { rect.height = origH + dy; }
                   if (rect.width < 20) rect.width = 20;
                   if (rect.height < 20) rect.height = 20;
                   forgeTheTopology();
                 };
                 const upHandler = () => { dragging = false; document.removeEventListener("mousemove", moveHandler); document.removeEventListener("mouseup", upHandler); };
                 document.addEventListener("mousemove", moveHandler);
                 document.addEventListener("mouseup", upHandler);
               });
               g.appendChild(handle);
             });
           }
           if (rect.groupId) {
             const groupIndicator = document.createElementNS(ns, "rect");
             groupIndicator.setAttribute("x", rect.x - 4);
             groupIndicator.setAttribute("y", rect.y - 4);
             groupIndicator.setAttribute("width", rect.width + 8);
             groupIndicator.setAttribute("height", rect.height + 8);
             groupIndicator.style.fill = "none";
         groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
             groupIndicator.style.strokeWidth = "3";
             groupIndicator.style.strokeDasharray = "5,5";
             groupIndicator.style.pointerEvents = "none";
             g.insertBefore(groupIndicator, g.firstChild);
           }
           g.appendChild(rectEl);
           g.appendChild(deleteBtn);
           svg.appendChild(g);
          }
         });
        }
        
        if (TEXT_DATA && TEXT_DATA.list) {
         TEXT_DATA.list.forEach((textItem) => {
          if (currentView.mode === "rack") return;
          
          const g = document.createElementNS(ns, "g");
          g.classList.add("text-group");
          g.dataset.textId = textItem.id;
          
          if (textItem.bgEnabled) {
           const bgRect = document.createElementNS(ns, "rect");
           bgRect.classList.add("text-bg");
      
           bgRect.setAttribute("x", textItem.x - 5);
           bgRect.setAttribute("y", textItem.y - textItem.fontSize - 2);
           bgRect.setAttribute("width", 100);
           bgRect.setAttribute("height", textItem.fontSize + 10);
           bgRect.style.fill = textItem.bgColor;
           bgRect.style.opacity = "0.7";
           bgRect.style.rx = "4";
           g.appendChild(bgRect);
          }
          
          const textEl = document.createElementNS(ns, "text");
          textEl.classList.add("text-element");
          textEl.setAttribute("x", textItem.x);
          textEl.setAttribute("y", textItem.y);
          textEl.style.fill = textItem.color;
          textEl.style.fontSize = textItem.fontSize + "px";
          textEl.style.fontWeight = textItem.fontWeight;
          textEl.style.fontStyle = textItem.fontStyle;
          textEl.style.textAnchor = textItem.textAlign;
          textEl.style.textDecoration = textItem.textDecoration;
          textEl.style.opacity = textItem.opacity;
          textEl.style.cursor = "move";
          textEl.style.userSelect = "none";
          textEl.setAttribute("dominant-baseline", "middle");
          
          const lines = textItem.content.split('\n');
          if (lines.length === 1) {
           textEl.textContent = textItem.content;
          } else {
           lines.forEach((line, i) => {
            const tspan = document.createElementNS(ns, "tspan");
            tspan.textContent = line;
            tspan.setAttribute("x", textItem.x);
            tspan.setAttribute("dy", i === 0 ? 0 : textItem.fontSize * 1.2);
            textEl.appendChild(tspan);
           });
          }
          
          g.appendChild(textEl);
          
          if (textItem.bgEnabled) {
           setTimeout(() => {
            try {
             const bbox = textEl.getBBox();
             const bgRect = g.querySelector('.text-bg');
             if (bgRect && bbox) {
              bgRect.setAttribute("x", bbox.x - 5);
              bgRect.setAttribute("y", bbox.y - 2);
              bgRect.setAttribute("width", bbox.width + 10);
              bgRect.setAttribute("height", bbox.height + 4);
             }
            } catch (e) {
            }
           }, 0);
          }
          
          const deleteBtn = document.createElementNS(ns, "g");
          deleteBtn.classList.add("text-delete-btn");
          deleteBtn.style.cursor = "pointer";
          deleteBtn.style.display = textDrawMode ? "block" : "none";
          
          const deleteBg = document.createElementNS(ns, "circle");
          deleteBg.setAttribute("cx", textItem.x + 20);
          deleteBg.setAttribute("cy", textItem.y - textItem.fontSize);
          deleteBg.setAttribute("r", 12);
          deleteBg.style.fill = "#f56565";
          deleteBg.style.stroke = "white";
          deleteBg.style.strokeWidth = "2";
          
          const deleteX = document.createElementNS(ns, "text");
          deleteX.setAttribute("x", textItem.x + 20);
          deleteX.setAttribute("y", textItem.y - textItem.fontSize);
          deleteX.setAttribute("text-anchor", "middle");
          deleteX.setAttribute("dominant-baseline", "middle");
          deleteX.style.fill = "white";
          deleteX.style.fontSize = "16px";
          deleteX.style.fontWeight = "bold";
          deleteX.style.pointerEvents = "none";
          deleteX.textContent = "√ó";
          
          deleteBtn.appendChild(deleteBg);
          deleteBtn.appendChild(deleteX);
          
          deleteBtn.addEventListener("click", (e) => {
           e.stopPropagation();
           e.preventDefault();
           deleteText(textItem.id);
          });
          
          let isDragging = false;
          let dragStartX, dragStartY;
          let textStartX, textStartY;
          
          textEl.addEventListener("mousedown", (e) => {
      if (textDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      textStartX = textItem.x;
      textStartY = textItem.y;
      textEl.style.cursor = "grabbing";
      
      showTextPanel(textItem.id);
      
      if (selectedTexts.has(textItem.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
          
          const moveHandler = (e) => {
      if (!isDragging || textDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      
      textItem.x = textStartX + dx;
      textItem.y = textStartY + dy;
      
      if (selectedTexts.has(textItem.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       const newX = initialPositions[nodeId].x + dx;
       const newY = initialPositions[nodeId].y + dy;
       savedPositions[nodeId] = { x: newX, y: newY };
      }
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      if (textId === textItem.id) return;
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      
      forgeTheTopology();
      };
          
          const upHandler = () => {
           if (isDragging) {
            isDragging = false;
            textEl.style.cursor = "move";
           }
          };
          
          document.addEventListener("mousemove", moveHandler);
          document.addEventListener("mouseup", upHandler);
          
          let touchStartX = 0, touchStartY = 0;
          let textTouchStartX = 0, textTouchStartY = 0;
          
          textEl.addEventListener("touchstart", (e) => {
           if (textDrawMode) return;
           if (e.touches.length !== 1) return;
           
           e.preventDefault();
           e.stopPropagation();
           const touch = e.touches[0];
           isDragging = true;
           touchStartX = touch.clientX;
           touchStartY = touch.clientY;
           textTouchStartX = textItem.x;
           textTouchStartY = textItem.y;
           
           showTextPanel(textItem.id);
          }, { passive: false });
          
          textEl.addEventListener("touchmove", (e) => {
           if (!isDragging || textDrawMode) return;
           if (e.touches.length !== 1) return;
           
           e.preventDefault();
           const touch = e.touches[0];
           const svgEl = svg;
           
           const pt1 = svgEl.createSVGPoint();
           pt1.x = touchStartX;
           pt1.y = touchStartY;
           const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
           
           const pt2 = svgEl.createSVGPoint();
           pt2.x = touch.clientX;
           pt2.y = touch.clientY;
           const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
           
           const dx = svgP2.x - svgP1.x;
           const dy = svgP2.y - svgP1.y;
           
           textItem.x = textTouchStartX + dx;
           textItem.y = textTouchStartY + dy;
           
           forgeTheTopology();
          }, { passive: false });
          
          textEl.addEventListener("touchend", () => {
           if (isDragging) {
            isDragging = false;
           }
          }, { passive: false });
          
          textEl.addEventListener("contextmenu", (e) => {
           e.preventDefault();
           e.stopPropagation();
           if (selectedTexts.has(textItem.id)) {
            selectedTexts.delete(textItem.id);
           } else {
            selectedTexts.add(textItem.id);
           }
           updateAllSelections();
          });
          
          let textLastTap = 0;
          g.addEventListener("touchend", (e) => {
           const now = Date.now();
           if (now - textLastTap < 300) {
            e.preventDefault();
            if (selectedTexts.has(textItem.id)) {
             selectedTexts.delete(textItem.id);
            } else {
             selectedTexts.add(textItem.id);
            }
            updateAllSelections();
            if (navigator.vibrate) navigator.vibrate(50);
            textLastTap = 0;
           } else {
            textLastTap = now;
           }
          }, { passive: false });
          
          if (textItem.groupId) {
            const groupIndicator = document.createElementNS(ns, "rect");
            groupIndicator.setAttribute("x", textItem.x - 54);
            groupIndicator.setAttribute("y", textItem.y - 24);
            groupIndicator.setAttribute("width", 108);
            groupIndicator.setAttribute("height", 48);
            groupIndicator.setAttribute("rx", "8");
            groupIndicator.style.fill = "none";
       groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
            groupIndicator.style.strokeWidth = "3";
            groupIndicator.style.strokeDasharray = "5,5";
            groupIndicator.style.pointerEvents = "none";
            g.insertBefore(groupIndicator, g.firstChild);
          }
          g.appendChild(deleteBtn);
          svg.appendChild(g);
         });
        }
        
        
        Object.keys(NODE_DATA).forEach(nodeId => {
         updatePingIndicator(nodeId);
        });
        
        forgeTheLegend();
        updateMinimap();
       }
      
       function showEditModal(title, currentValue, onSave) {
        const modal = document.getElementById("edit-modal");
        const input = document.getElementById("modal-input");
        const titleEl = document.getElementById("modal-title");
        const saveBtn = document.getElementById("modal-save");
        const cancelBtn = document.getElementById("modal-cancel");
        titleEl.textContent = title;
        input.value = currentValue;
        modal.classList.add("active");
        input.focus();
        input.select();
        const handleSave = () => {
         if (input.value.trim()) {
          onSave(input.value.trim());
         }
         modal.classList.remove("active");
         saveBtn.removeEventListener("click", handleSave);
         cancelBtn.removeEventListener("click", handleCancel);
         input.removeEventListener("keypress", handleEnter);
        };
        const handleCancel = () => {
         modal.classList.remove("active");
         saveBtn.removeEventListener("click", handleSave);
         cancelBtn.removeEventListener("click", handleCancel);
         input.removeEventListener("keypress", handleEnter);
        };
        const handleEnter = (e) => {
         if (e.key === "Enter") handleSave();
        };
        saveBtn.addEventListener("click", handleSave);
        cancelBtn.addEventListener("click", handleCancel);
        input.addEventListener("keypress", handleEnter);
        modal.addEventListener("click", function bgHandler(e) {
         if (e.target === modal) {
          handleCancel();
          modal.removeEventListener("click", bgHandler);
         }
        });
       }
      
       function challengeTheImmortal(message, onConfirm) {
        const modal = document.getElementById("confirm-modal");
        const messageEl = document.getElementById("confirm-message");
        const deleteBtn = document.getElementById("confirm-delete");
        const cancelBtn = document.getElementById("confirm-cancel");
        messageEl.textContent = message;
        modal.classList.add("active");
        const handleConfirm = () => {
         onConfirm();
         modal.classList.remove("active");
         deleteBtn.removeEventListener("click", handleConfirm);
         cancelBtn.removeEventListener("click", handleCancel);
        };
        const handleCancel = () => {
         modal.classList.remove("active");
         deleteBtn.removeEventListener("click", handleConfirm);
         cancelBtn.removeEventListener("click", handleCancel);
        };
        deleteBtn.addEventListener("click", handleConfirm);
        cancelBtn.addEventListener("click", handleCancel);
        modal.addEventListener("click", function bgHandler(e) {
         if (e.target === modal) {
          handleCancel();
          modal.removeEventListener("click", bgHandler);
         }
        });
       }
       const pageTitleEl = document.getElementById("page-title");
       if (pageTitleEl) {
        pageTitleEl.addEventListener("click", () => {
         showEditModal("Edit Title", PAGE_STATE.title || DEFAULT_PAGE_STATE.title,
          (newTitle) => {
           PAGE_STATE.title = newTitle;
           wieldThePower();
          }, );
        });
       }
      
       function editNodeName(id) {
        if (!NODE_DATA[id]) return;
        showEditModal("Edit Name", NODE_DATA[id].name, (newName) => {
         if (!NODE_DATA[id]) return;
         NODE_DATA[id].name = newName;
         const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`, );
         if (nodeGroup) {
          const label = nodeGroup.querySelector(".node-label");
          if (label) label.textContent = newName;
         }
         if (currentNodeId === id) {
          document.getElementById("node-name").textContent = newName;
         }
        });
       }
      
       function editNodeIp(id) {
        if (!NODE_DATA[id]) return;
        showEditModal("Edit IP/Subtitle", NODE_DATA[id].ip, (newIp) => {
         if (!NODE_DATA[id]) return;
         NODE_DATA[id].ip = newIp;
         const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`, );
         if (nodeGroup) {
          const sub = nodeGroup.querySelector(".node-sub");
          if (sub) sub.textContent = newIp;
         }
         if (currentNodeId === id) {
          document.getElementById("node-ip").textContent = newIp;
         }
        });
       }
      
       function claimTheImmortal(id) {
	   if (isViewOnly()) return;
        if (!NODE_DATA[id]) return;
        currentNodeId = id;
        currentEdgeId = null;
        currentRectId = null;
        currentTextId = null;
        const data = NODE_DATA[id];
        document.querySelectorAll(".node-group").forEach((n) => {
         n.classList.toggle("active", n.dataset.nodeId === id);
        });
        document.querySelectorAll(".edge").forEach((e) => {
        const active = e.dataset.from === id || e.dataset.to === id;
        e.classList.toggle("active", active);
       });
       document.querySelectorAll(".rect-group").forEach((r) => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach((t) => t.classList.remove("active"));
       document.getElementById("node-panel").style.display = "block";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        const toolbar = document.getElementById("topology-toolbar");
        if (!topologyToolbarCollapsed) {
         toolbar.style.display = "flex";
        }
        updateTopologyToolbarVisibility();
        document.getElementById("node-name").textContent = data.name;
        document.getElementById("node-ip").textContent = data.ip;
        document.getElementById("node-mac").textContent = data.mac || "--";
        document.getElementById("node-rack").textContent = data.rackUnit || "--";
        document.getElementById("node-uheight").textContent = (data.uHeight || "1") + "U";
        document.getElementById("node-role").textContent = data.role;
      
        populateRackDropdown();
        const assignedRackSelect = document.getElementById("node-assigned-rack");
        if (assignedRackSelect) {
         assignedRackSelect.value = data.assignedRack || "";
        }
        
        const rackCapacitySelect = document.getElementById("node-rack-capacity");
        if (rackCapacitySelect) {
         rackCapacitySelect.value = data.rackCapacity || "42";
        }
        
        const isRack = data.isRack === true;
        const isAssignedToRack = !!data.assignedRack;
        const assignedRackRow = document.getElementById("assigned-rack-row");
        const rackCapacityRow = document.getElementById("rack-capacity-row");
        const uheightRow = document.getElementById("uheight-row");
        if (assignedRackRow) assignedRackRow.style.display = isRack ? "none" : "flex";
        if (rackCapacityRow) rackCapacityRow.style.display = isRack ? "flex" : "none";
        if (uheightRow) uheightRow.style.display = isAssignedToRack ? "flex" : "none";
		const delBtn = document.getElementById("delete-node-btn");
        if (delBtn) delBtn.textContent = isRack ? "Delete Rack" : "Delete Node";	
		const rackContentsSection = document.getElementById("rack-contents-section");
        const rackContentsList = document.getElementById("rack-contents-list");
        const rackContentsCount = document.getElementById("rack-contents-count");
        if (rackContentsSection && rackContentsList) {
        if (isRack) {
         const nodesInRack = Object.entries(NODE_DATA).filter(([nid, n]) => n.assignedRack === id);
         rackContentsCount.textContent = nodesInRack.length;
         if (nodesInRack.length > 0) {
          rackContentsList.innerHTML = nodesInRack.map(([nid, n]) => {
           const tags = (n.tags || []).map(t => `<span style="background: var(--accent); color: var(--bg); padding: 2px 6px; border-radius: 4px; font-size: 11px; margin-left: 4px;">${t}</span>`).join('');
           return `<div style="padding: 8px 4px; border-bottom: 1px solid var(--edge-main); cursor: pointer;" onclick="claimTheImmortal('${nid}')">
            <span style="color: var(--text-main);">${n.name}</span>${tags}
           </div>`;
          }).join('');
         } else {
          rackContentsList.innerHTML = '<div style="color: var(--text-soft); font-style: italic; padding: 8px 4px;">No nodes assigned</div>';
         }
         rackContentsSection.style.display = "block";
         } else {
         rackContentsSection.style.display = "none";
         }
        }    
        document.getElementById("node-name").onclick = () => editNodeName(id);
        document.getElementById("node-ip").onclick = () => editNodeIp(id);
        document.getElementById("node-mac").onclick = () => editNodeMac(id);
        document.getElementById("node-rack").onclick = () => editNodeRack(id);
        document.getElementById("node-uheight").onclick = () => editNodeUHeight(id);
        const currentSize = savedSizes[id] || getDefaultSize();
        document.getElementById("size-slider").value = currentSize;
        document.getElementById("size-value").textContent = currentSize;
        const styleEntry = savedStyles[id] || {};
        const resolvedStyles = resolveStylesEntry(styleEntry);
        const scopeKey = currentStyleScope || "all";
        const flatProps = ["circleColor", "circleBorder", "titleColor", "titleFont", "titleSize", "subColor", "subFont", "subSize", ];
        const isFlat = flatProps.some((p) => Object.prototype.hasOwnProperty.call(styleEntry, p), );
        const scopedStyles = isFlat ? styleEntry : styleEntry[scopeKey] || {};
        const circleColorInput = document.getElementById("circle-color");
        const titleColorInput = document.getElementById("title-color");
        const titleFontSelect = document.getElementById("title-font");
        const titleSizeInput = document.getElementById("title-size");
        const subColorInput = document.getElementById("sub-color");
        const subFontSelect = document.getElementById("sub-font");
        const subSizeInput = document.getElementById("sub-size");
        const shapeSelect = document.getElementById("shape-select");
        const scopeSelect = document.getElementById("style-scope");
        circleColorInput.value = scopedStyles.circleColor || resolvedStyles.circleColor || PAGE_STATE.nodeFill || "#1e293b";
       const circleBorderInput = document.getElementById("circle-border");
       circleBorderInput.value = scopedStyles.circleBorder || resolvedStyles.circleBorder || PAGE_STATE.nodeStroke || "#475569";
        titleColorInput.value = scopedStyles.titleColor || resolvedStyles.titleColor || PAGE_STATE.textMain || "#e2e8f0";
        titleFontSelect.value = scopedStyles.titleFont || resolvedStyles.titleFont || "system-ui, sans-serif";
        titleSizeInput.value = scopedStyles.titleSize || resolvedStyles.titleSize || 18;
        subColorInput.value = scopedStyles.subColor || resolvedStyles.subColor || PAGE_STATE.textSoft || "#94a3b8";
        subFontSelect.value = scopedStyles.subFont || resolvedStyles.subFont || "system-ui, sans-serif";
        subSizeInput.value = scopedStyles.subSize || resolvedStyles.subSize || 13;
        const hasWebIcon = resolvedStyles.icon && resolvedStyles.icon.library;
        const customOpt = shapeSelect.querySelector('option[value="custom-icon"]');
        if (hasWebIcon) {
         if (!customOpt) {
          const opt = document.createElement('option');
          opt.value = 'custom-icon';
          opt.textContent = 'Custom Icon';
          shapeSelect.insertBefore(opt, shapeSelect.firstChild);
         }
         shapeSelect.value = 'custom-icon';
        } else {
         if (customOpt) customOpt.remove();
         shapeSelect.value = data.shape || "circle";
        }
        const layerSelect = document.getElementById("node-layer");
        if (layerSelect) {
         layerSelect.value = data.layer || "physical";
        }
        scopeSelect.value = currentStyleScope || "all";
        document.getElementById("title-offset-y").value = scopedStyles.titleOffsetY || resolvedStyles.titleOffsetY || 0;
        document.getElementById("title-offset-x").value = scopedStyles.titleOffsetX || resolvedStyles.titleOffsetX || 0;
        document.getElementById("sub-offset-y").value = scopedStyles.subOffsetY || resolvedStyles.subOffsetY || 0;
        document.getElementById("sub-offset-x").value = scopedStyles.subOffsetX || resolvedStyles.subOffsetX || 0;
      
      const pingOffsetXInput = document.getElementById("ping-offset-x");
      const pingOffsetYInput = document.getElementById("ping-offset-y");
      
      if (pingOffsetXInput && pingOffsetYInput) {
      pingOffsetXInput.value =
       (scopedStyles.pingOffsetX !== undefined
         ? scopedStyles.pingOffsetX
         : (resolvedStyles.pingOffsetX !== undefined
             ? resolvedStyles.pingOffsetX
             : 0));
      
      pingOffsetYInput.value =
       (scopedStyles.pingOffsetY !== undefined
         ? scopedStyles.pingOffsetY
         : (resolvedStyles.pingOffsetY !== undefined
             ? resolvedStyles.pingOffsetY
             : 0));
      }
        const tagEl = document.getElementById("node-tags");
        tagEl.innerHTML = "";
        data.tags.forEach((tag, i) => {
         const b = document.createElement("span");
         b.className = "badge";
         const isIconTag = typeof tag === 'object' && tag.type === 'icon';
         if (!isIconTag && typeof tag === 'string' && tag.toLowerCase().includes("wg")) b.classList.add("wg");
         b.style.cursor = "pointer";
         b.style.position = "relative";
         const tagContent = document.createElement("span");
         if (isIconTag) {
          b.classList.add("icon-badge");
          IconLibrary.getIcon(tag.library, tag.name).then(svgText => {
           if (svgText) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(svgText, 'image/svg+xml');
            const svgEl = doc.querySelector('svg');
            if (svgEl) {
             svgEl.setAttribute('width', '16');
             svgEl.setAttribute('height', '16');
             tagContent.innerHTML = '';
             tagContent.appendChild(svgEl);
             const nameSpan = document.createElement('span');
             nameSpan.textContent = tag.name;
             nameSpan.style.marginLeft = '4px';
             tagContent.appendChild(nameSpan);
            }
           }
          });
         } else {
          tagContent.textContent = tag;
          tagContent.addEventListener("click", (e) => {
           e.stopPropagation();
           showEditModal("Edit Tag", tag, (newTag) => {
            if (newTag) {
             data.tags[i] = newTag;
             claimTheImmortal(id);
            }
           });
          });
         }
         const deleteTag = document.createElement("span");
         deleteTag.textContent = " ‚úï";
         deleteTag.style.opacity = "0.6";
         deleteTag.style.marginLeft = "4px";
         deleteTag.style.fontSize = "10px";
         deleteTag.addEventListener("click", (e) => {
          e.stopPropagation();
          data.tags.splice(i, 1);
          claimTheImmortal(id);
         });
         b.append(tagContent, deleteTag);
         tagEl.append(b);
        });
        const addTagBtn = document.createElement("span");
        addTagBtn.className = "badge";
        addTagBtn.style.cursor = "pointer";
        addTagBtn.style.opacity = "0.6";
        addTagBtn.style.borderStyle = "dashed";
        addTagBtn.textContent = "+ Add Tag";
        addTagBtn.addEventListener("click", () => {
         showEditModal("Add Tag(s) : comma separated", "",
          (newTagStr) => {
           if (newTagStr) {
            const newTags = newTagStr.split(",").map((t) => t.trim()).filter((t) => t);
            newTags.forEach((t) => data.tags.push(t));
            claimTheImmortal(id);
           }
          }, );
        });
        tagEl.append(addTagBtn);
        const notesEl = document.getElementById("node-notes");
        notesEl.innerHTML = "";
        data.notes.forEach((note, i) => {
         const li = document.createElement("li");
         const noteText = document.createElement("span");
         noteText.textContent = note;
         noteText.style.flex = "1";
         const deleteBtn = document.createElement("span");
         deleteBtn.className = "delete-note";
         deleteBtn.textContent = "‚úï";
         deleteBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          challengeTheImmortal("Are you sure you want to delete this note?",
           () => {
            data.notes.splice(i, 1);
            claimTheImmortal(id);
           }, );
         });
         li.append(noteText, deleteBtn);
         noteText.addEventListener("dblclick", () => {
          noteText.classList.add("editing");
          noteText.contentEditable = true;
          noteText.focus();
         });
         noteText.addEventListener("blur", () => {
          noteText.classList.remove("editing");
          noteText.contentEditable = false;
          data.notes[i] = noteText.textContent;
         });
         notesEl.append(li);
        });
        const addLineSelect = document.getElementById("add-line-select");
      addLineSelect.innerHTML = "";
      const currentRack = data.assignedRack || "";
      Object.entries(NODE_DATA).forEach(([nodeId, node]) => {
      if (nodeId !== id) {
      const nodeRack = node.assignedRack || "";
      if (currentRack === nodeRack) {
      const opt = document.createElement("option");
      opt.value = nodeId;
      opt.textContent = node.name;
      addLineSelect.appendChild(opt);
      }
      }
      });
        
        const pingEnabled = data.ping && data.ping.enabled;
        document.getElementById('node-pingable').checked = pingEnabled;
        document.getElementById('node-ping-options').style.display = pingEnabled ? 'block' : 'none';
        
        if (data.ping) {
         document.getElementById('node-ping-protocol').value = data.ping.protocol || 'http';
         document.getElementById('node-custom-url').value = data.ping.customUrl || '';
         document.getElementById('node-ping-timeout').value = data.ping.timeout || 3000;
         document.getElementById('node-custom-url-container').style.display = 
          data.ping.protocol === 'custom' ? 'block' : 'none';
         
         updatePingStatusDisplay(id);
        }
       }
      
       function updatePingStatusDisplay(nodeId) {
        const data = NODE_DATA[nodeId];
        if (!data || !data.ping) return;
        
        const statusEl = document.getElementById('node-ping-status');
        const lastCheckEl = document.getElementById('node-ping-last-check');
        
        const statusColors = {
         online: 'var(--accent)',
         offline: 'var(--danger)',
         checking: '#f59e0b',
         unknown: 'var(--text-soft)'
        };
        
        const statusTexts = {
         online: '‚óè Online',
         offline: '‚óè Offline',
         checking: '‚óè Checking...',
         unknown: '‚óè Unknown'
        };
        
        statusEl.textContent = statusTexts[data.ping.status] || statusTexts.unknown;
        statusEl.style.color = statusColors[data.ping.status] || statusColors.unknown;
        
        if (data.ping.lastCheck) {
         const checkTime = new Date(data.ping.lastCheck);
         lastCheckEl.textContent = `Last checked: ${checkTime.toLocaleTimeString()}`;
        } else {
         lastCheckEl.textContent = 'Never checked';
        }
       }
      
       function selectTheConnection(id) {
	   if (isViewOnly()) return;
        currentEdgeId = id;
        currentNodeId = null;
        currentRectId = null;
        currentTextId = null;
		
		if (isMobileDevice()) {
        const currentHeight = PAGE_STATE.mobileFooterHeight || 40;
        if (currentHeight <= 20) {
         PAGE_STATE.mobileFooterHeight = 80;
         const root = document.documentElement;
         root.style.setProperty("--mobile-footer-height", "80vh");
         const mobileFooterHeightInput = document.getElementById("mobile-footer-height");
         const mobileFooterHeightVal = document.getElementById("mobile-footer-height-val");
         if (mobileFooterHeightInput) mobileFooterHeightInput.value = 80;
         if (mobileFooterHeightVal) mobileFooterHeightVal.textContent = "80%";
        }
       }
	   
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "block";
        document.getElementById("text-panel").style.display = "none";
       document.getElementById("rect-panel").style.display = "none";
       document.getElementById("topology-toolbar").style.display = "none";
       document.querySelectorAll(".node-group").forEach((n) => n.classList.remove("active"));
       document.querySelectorAll(".rect-group").forEach((r) => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach((t) => t.classList.remove("active"));
       document.querySelectorAll(".edge").forEach((e) => {
        e.classList.toggle("active", e.dataset.edgeId === id);
       });
        const edge = EDGE_DATA.list.find((e) => e.id === id);
        if (!edge) return;
        const directionSymbols = {
         none: "‚áÑ",
         forward: "‚Üí",
         backward: "‚Üê",
         both: "‚Üî",
        };
        const dirSymbol = directionSymbols[edge.direction] || "‚áÑ";
        let titleText = "Custom line";
        if (edge.from || edge.to) {
         const fromName = edge.from ? NODE_DATA[edge.from]?.name || edge.from : "";
         const toName = edge.to ? NODE_DATA[edge.to]?.name || edge.to : "";
         titleText = `${fromName || "?"} ${dirSymbol} ${toName || "?"}`;
        }
        document.getElementById("edge-title").textContent = titleText;
        const widthInput = document.getElementById("edge-width");
        const colorInput = document.getElementById("edge-color");
        const directionSelect = document.getElementById("edge-direction");
        const lineStyleSelect = document.getElementById("edge-line-style");
        widthInput.value = edge.width;
        colorInput.value = edge.color;
        directionSelect.value = edge.direction || "none";
        lineStyleSelect.value = edge.lineStyle || "solid";
        
        const fromPortInput = document.getElementById("edge-from-port");
        const toPortInput = document.getElementById("edge-to-port");
        const portFieldsFrom = document.getElementById("edge-port-fields");
        const portFieldsTo = document.getElementById("edge-port-fields-to");
        
        if (edge.type === "custom") {
         if (portFieldsFrom) portFieldsFrom.style.display = "none";
         if (portFieldsTo) portFieldsTo.style.display = "none";
        } else {
         if (portFieldsFrom) portFieldsFrom.style.display = "flex";
         if (portFieldsTo) portFieldsTo.style.display = "flex";
         if (fromPortInput) {
          fromPortInput.value = edge.fromPort || "";
          fromPortInput.onchange = () => updateEdgePortLabels(id);
         }
         if (toPortInput) {
          toPortInput.value = edge.toPort || "";
          toPortInput.onchange = () => updateEdgePortLabels(id);
         }
        }
        
        const list = document.getElementById("edge-notes");
        list.innerHTML = "";
        edge.notes.forEach((note, i) => {
         const li = document.createElement("li");
         const txt = document.createElement("span");
         txt.textContent = note;
         txt.style.flex = "1";
         const del = document.createElement("span");
         del.className = "delete-note";
         del.textContent = "‚úï";
         del.addEventListener("click", (e) => {
          e.stopPropagation();
          challengeTheImmortal("Delete this line note?", () => {
           edge.notes.splice(i, 1);
          
           selectTheConnection(id);
          });
         });
         txt.addEventListener("dblclick", () => {
          txt.classList.add("editing");
          txt.contentEditable = true;
          txt.focus();
         });
         txt.addEventListener("blur", () => {
          txt.classList.remove("editing");
          txt.contentEditable = false;
          edge.notes[i] = txt.textContent;
         
         });
         li.append(txt, del);
         list.appendChild(li);
       });
       
       if (edge.type === "custom" && Array.isArray(edge.points)) {
        forgeTheTopology();
       }
      }
       window.addEventListener("resize", () => {
        forgeTheTopology();
        if (currentEdgeId) {
         selectTheConnection(currentEdgeId);
        } else if (currentNodeId && NODE_DATA[currentNodeId]) {
         claimTheImmortal(currentNodeId);
        } else {
         const availableNodes = Object.keys(NODE_DATA);
         if (availableNodes.length > 0) {
          claimTheImmortal(availableNodes[0]);
         }
        }
       });
       (function initZoomPan() {
        const viewport = document.getElementById("canvas-viewport");
        const svg = document.getElementById("map");
        const hint = document.getElementById("canvas-hint");
        setTimeout(() => {
         hint.classList.add("visible");
         setTimeout(() => hint.classList.remove("visible"), 4000);
        }, 1000);
        viewport.addEventListener("wheel",
         (e) => {
          e.preventDefault();
          const rect = viewport.getBoundingClientRect();
          const mouseX = (e.clientX - rect.left) / rect.width;
          const mouseY = (e.clientY - rect.top) / rect.height;
          const delta = e.deltaY > 0 ? 0.9 : 1.1;
          zoomTo(canvasState.zoom * delta, mouseX, mouseY);
         }, {
          passive: false
         }, );
        let initialPinchDistance = 0;
        let initialPinchZoom = 1;
        let pinchCenter = {
         x: 0.5,
         y: 0.5
        };
        viewport.addEventListener("touchstart",
         (e) => {
          if (e.touches.length === 2) {
           e.preventDefault();
           const touch1 = e.touches[0];
           const touch2 = e.touches[1];
           initialPinchDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY, );
           initialPinchZoom = canvasState.zoom;
           const rect = viewport.getBoundingClientRect();
           const centerX = (touch1.clientX + touch2.clientX) / 2;
           const centerY = (touch1.clientY + touch2.clientY) / 2;
           pinchCenter.x = (centerX - rect.left) / rect.width;
           pinchCenter.y = (centerY - rect.top) / rect.height;
          }
         }, {
          passive: false
         }, );
        viewport.addEventListener("touchmove",
         (e) => {
          if (e.touches.length === 2) {
           e.preventDefault();
           const touch1 = e.touches[0];
           const touch2 = e.touches[1];
           const currentDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY, );
           if (initialPinchDistance > 0) {
            const scale = currentDistance / initialPinchDistance;
            const newZoom = initialPinchZoom * scale;
            zoomTo(newZoom, pinchCenter.x, pinchCenter.y);
           }
          }
         }, {
          passive: false
         }, );
        let panStartViewX = 0;
        let panStartViewY = 0;
        
        let lastEmptyTapTime = 0;
        let emptyTapTimeout = null;
        let emptyTapMoved = false;
        let emptyTapStartX = 0;
        let emptyTapStartY = 0;
        
        viewport.addEventListener("touchend", (e) => {
          if (currentView.mode !== "rack") return;
          
          if (e.changedTouches.length !== 1) return;
          
      const isNodeOrEdge = e.target.closest(".node-group") || e.target.closest(".edge-group");
         if (isNodeOrEdge) return;
          
          if (emptyTapMoved) {
            emptyTapMoved = false;
            return;
          }
          
          const currentTime = new Date().getTime();
          const tapGap = currentTime - lastEmptyTapTime;
          
          if (tapGap < 300 && tapGap > 0) {
            e.preventDefault();
            
            exitRack();
            
            if (navigator.vibrate) {
              navigator.vibrate(50);
            }
            
            lastEmptyTapTime = 0;
            if (emptyTapTimeout) {
              clearTimeout(emptyTapTimeout);
              emptyTapTimeout = null;
            }
          } else {
            lastEmptyTapTime = currentTime;
            
            if (emptyTapTimeout) clearTimeout(emptyTapTimeout);
            emptyTapTimeout = setTimeout(() => {
              lastEmptyTapTime = 0;
            }, 300);
          }
        }, { passive: false });
        
        viewport.addEventListener("mousedown", (e) => {
         if (e.target.closest(".draw-toolbar") || e.target.closest(".topology-toolbar") || e.target.closest(".legend-container")) {
          return;
         }
         if (freeDrawMode || rectDrawMode) {
          return;
         }
      const isEmptySpace = e.target === svg || e.target === viewport || e.target.tagName === "svg";
      const isEdgeElement = e.target.closest('.edge') || e.target.classList.contains('edge-edit-point');
      const isTextElement = e.target.closest('.text-group') || e.target.closest('.text-element');
      const isRectElement = e.target.closest('.rect-group');
      if (!isEdgeElement && !isTextElement && !isRectElement && currentEdgeId) {
      currentEdgeId = null;
      forgeTheTopology();
      }
      if (!isRectElement && currentRectId) {
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      }
         if (isViewOnly()) {
         document.body.classList.remove("view-only-inspect");
         document.getElementById("node-panel").style.display = "none";
         document.getElementById("edge-panel").style.display = "none";
        }
         if (isEmptySpace && e.shiftKey && e.button === 0) {
         if (isViewOnly()) return;
         e.preventDefault();
         startSelection(e);
         return;
        }
        if (isEmptySpace || e.button === 2 || e.button === 1) {
          e.preventDefault();
          canvasState.isPanning = true;
          canvasState.panStartX = e.clientX;
          canvasState.panStartY = e.clientY;
          panStartViewX = canvasState.panX;
          panStartViewY = canvasState.panY;
          viewport.classList.add("panning");
         }
        });
        viewport.addEventListener("touchstart",
         (e) => {
          if (e.target.closest(".draw-toolbar") || e.target.closest(".topology-toolbar") || e.target.closest(".legend-container")) {
           return;
          }
          if (freeDrawMode || rectDrawMode) {
           return;
          }
      const isEmptySpace = e.target === svg || e.target === viewport || e.target.tagName === "svg";
      const isEdgeElement = e.target.closest('.edge') || e.target.classList.contains('edge-edit-point');
      const isTextElement = e.target.closest('.text-group') || e.target.closest('.text-element');
      const isRectElement = e.target.closest('.rect-group');
      if (!isEdgeElement && !isTextElement && !isRectElement && currentEdgeId) {
      currentEdgeId = null;
      forgeTheTopology();
      }
      if (!isRectElement && currentRectId) {
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      }
          if (isEmptySpace && e.touches.length === 1) {
           e.preventDefault();
           emptyTapMoved = false;
           emptyTapStartX = e.touches[0].clientX;
           emptyTapStartY = e.touches[0].clientY;
           canvasState.isPanning = true;
           canvasState.panStartX = e.touches[0].clientX;
           canvasState.panStartY = e.touches[0].clientY;
           panStartViewX = canvasState.panX;
           panStartViewY = canvasState.panY;
           viewport.classList.add("panning");
          }
         }, {
          passive: false
         }, );
        document.addEventListener("mousemove", (e) => {
         if (isSelecting) {
          updateSelection(e);
          return;
         }
         if (!canvasState.isPanning) return;
         const dx = e.clientX - canvasState.panStartX;
         const dy = e.clientY - canvasState.panStartY;
         const rect = viewport.getBoundingClientRect();
         const viewWidth = CANVAS_WIDTH / canvasState.zoom;
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         const canvasDx = (dx / rect.width) * viewWidth;
         const canvasDy = (dy / rect.height) * viewHeight;
         canvasState.panX = panStartViewX - canvasDx;
         canvasState.panY = panStartViewY - canvasDy;
         constrainPan();
         updateViewBox();
        });
       document.addEventListener("touchmove", (e) => {
        if (!canvasState.isPanning || !e.touches[0]) return;
        const moveDx = Math.abs(e.touches[0].clientX - emptyTapStartX);
        const moveDy = Math.abs(e.touches[0].clientY - emptyTapStartY);
        if (moveDx > 15 || moveDy > 15) {
         emptyTapMoved = true;
        }
        const dx = e.touches[0].clientX - canvasState.panStartX;
         const dy = e.touches[0].clientY - canvasState.panStartY;
         const rect = viewport.getBoundingClientRect();
         const viewWidth = CANVAS_WIDTH / canvasState.zoom;
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         const canvasDx = (dx / rect.width) * viewWidth;
         const canvasDy = (dy / rect.height) * viewHeight;
         canvasState.panX = panStartViewX - canvasDx;
         canvasState.panY = panStartViewY - canvasDy;
         constrainPan();
         updateViewBox();
        });
        document.addEventListener("mouseup", () => {
         if (isSelecting) {
          endSelection();
         }
         if (canvasState.isPanning) {
          canvasState.isPanning = false;
          viewport.classList.remove("panning");
         }
        });
        document.addEventListener("touchend", () => {
         if (canvasState.isPanning) {
          canvasState.isPanning = false;
          viewport.classList.remove("panning");
         }
        });
        document.addEventListener("keydown", (e) => {
         const isEditing = document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "TEXTAREA" || document.activeElement.isContentEditable;
         if (e.code === "Space" && !e.repeat && !isEditing) {
          e.preventDefault();
          canvasState.spacePressed = true;
          viewport.style.cursor = "grab";
         }
        });
        document.addEventListener("keyup", (e) => {
         if (e.code === "Space") {
          canvasState.spacePressed = false;
          viewport.style.cursor = "";
         }
        });
        document.getElementById("zoom-in-btn").addEventListener("click", () => {
         zoomTo(canvasState.zoom * 1.25, 0.5, 0.5);
        });
        document.getElementById("zoom-out-btn").addEventListener("click", () => {
         zoomTo(canvasState.zoom * 0.8, 0.5, 0.5);
        });
        document.getElementById("zoom-fit-btn").addEventListener("click", fitToContent);
        document.getElementById("zoom-reset-btn").addEventListener("click", resetView);
        const minimapContainer = document.getElementById("minimap-container");
        const minimapSvg = document.getElementById("minimap");
        let minimapDragging = false;
        minimapContainer.addEventListener("mousedown", (e) => {
         e.preventDefault();
         minimapDragging = true;
         updatePanFromMinimap(e);
        });
        minimapContainer.addEventListener("touchstart",
         (e) => {
          e.preventDefault();
          minimapDragging = true;
          updatePanFromMinimapTouch(e);
         }, {
          passive: false
         }, );
        document.addEventListener("mousemove", (e) => {
         if (minimapDragging) {
          updatePanFromMinimap(e);
         }
        });
        document.addEventListener("touchmove", (e) => {
         if (minimapDragging && e.touches[0]) {
          updatePanFromMinimapTouch(e);
         }
        });
        document.addEventListener("mouseup", () => {
         minimapDragging = false;
        });
        document.addEventListener("touchend", () => {
         minimapDragging = false;
        });
      
        function updatePanFromMinimap(e) {
         const rect = minimapContainer.getBoundingClientRect();
         const x = (e.clientX - rect.left) / rect.width;
         const y = (e.clientY - rect.top) / rect.height;
         const viewWidth = CANVAS_WIDTH / canvasState.zoom;
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         canvasState.panX = x * CANVAS_WIDTH - viewWidth / 2;
         canvasState.panY = y * CANVAS_HEIGHT - viewHeight / 2;
         constrainPan();
         updateViewBox();
        }
      
        function updatePanFromMinimapTouch(e) {
         const rect = minimapContainer.getBoundingClientRect();
         const touch = e.touches[0];
         const x = (touch.clientX - rect.left) / rect.width;
         const y = (touch.clientY - rect.top) / rect.height;
         const viewWidth = CANVAS_WIDTH / canvasState.zoom;
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         canvasState.panX = x * CANVAS_WIDTH - viewWidth / 2;
         canvasState.panY = y * CANVAS_HEIGHT - viewHeight / 2;
         constrainPan();
         updateViewBox();
        }
        document.addEventListener("keydown", (e) => {
         if (document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "TEXTAREA") return;
         if (
          (e.key === "+" || e.key === "=") && (e.ctrlKey || e.metaKey)) {
          e.preventDefault();
          zoomTo(canvasState.zoom * 1.25, 0.5, 0.5);
         } else if (e.key === "-" && (e.ctrlKey || e.metaKey)) {
          e.preventDefault();
          zoomTo(canvasState.zoom * 0.8, 0.5, 0.5);
         } else if (e.key === "0" && (e.ctrlKey || e.metaKey)) {
          e.preventDefault();
          resetView();
         }
        });
        setTimeout(() => {
         fitToContent();
        }, 100);
       })();
       const sizeSlider = document.getElementById("size-slider");
       const sizeValue = document.getElementById("size-value");
       const resetSizeBtn = document.getElementById("reset-size");
       sizeSlider.addEventListener("input", () => {
        const newSize = parseInt(sizeSlider.value, 10);
        sizeValue.textContent = newSize;
        savedSizes[currentNodeId] = newSize;
        const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
        if (nodeGroup) {
         const oldShape = nodeGroup.querySelector(".node-circle");
         if (oldShape) oldShape.remove();
         const newShape = createNodeShape(currentNodeId, newSize);
         nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
         const styles = resolveStylesForNode(currentNodeId);
         if (styles.circleColor) newShape.style.fill = styles.circleColor;
      if (styles.circleBorder) newShape.style.stroke = styles.circleBorder;
         const label = nodeGroup.querySelector(".node-label");
         const sub = nodeGroup.querySelector(".node-sub");
         if (label) {
          label.setAttribute("y", -newSize * 0.28);
          const labelSize = styles.titleSize || newSize * 0.33;
          label.style.fontSize = labelSize + "px";
         }
         if (sub) {
          sub.setAttribute("y", newSize * 0.4);
          const subSize = styles.subSize || newSize * 0.24;
          sub.style.fontSize = subSize + "px";
         }
       updatePingIndicator(currentNodeId);
        }
       });
       resetSizeBtn.addEventListener("click", () => {
        delete savedSizes[currentNodeId];
        const defaultSize = getDefaultSize();
        sizeSlider.value = defaultSize;
        sizeValue.textContent = defaultSize;
        const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
        if (nodeGroup) {
         const oldShape = nodeGroup.querySelector(".node-circle");
         if (oldShape) oldShape.remove();
         const shapeType = (NODE_DATA[currentNodeId] && NODE_DATA[currentNodeId].shape) || "circle";
         const newShape = createNodeShape(currentNodeId, defaultSize);
         nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
         const styles = resolveStylesForNode(currentNodeId);
         if (styles.circleColor) newShape.style.fill = styles.circleColor;
      if (styles.circleBorder) newShape.style.stroke = styles.circleBorder;
         const label = nodeGroup.querySelector(".node-label");
         const sub = nodeGroup.querySelector(".node-sub");
         if (label) {
          label.setAttribute("y", -defaultSize * 0.28);
          const labelSize = styles.titleSize || defaultSize * 0.33;
          label.style.fontSize = labelSize + "px";
         }
         if (sub) {
          sub.setAttribute("y", defaultSize * 0.4);
          const subSize = styles.subSize || defaultSize * 0.24;
          sub.style.fontSize = subSize + "px";
         }
          updatePingIndicator(currentNodeId);
      
        }
       });
       const applyStyle = (property, value) => {
        const styleEntry = ensureStyleEntry(currentNodeId);
        const scopeKey = currentStyleScope || "all";
        if (!styleEntry[scopeKey]) styleEntry[scopeKey] = {};
        styleEntry[scopeKey][property] = value;
        const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
        if (!nodeGroup) return;
        const shapeEl = nodeGroup.querySelector(".node-circle");
        const label = nodeGroup.querySelector(".node-label");
        const sub = nodeGroup.querySelector(".node-sub");
        const isWebIcon = shapeEl && shapeEl.querySelector('svg');
        if (property === "circleColor" && shapeEl) {
         if (isWebIcon) {
          shapeEl.querySelectorAll('svg, path, circle, rect, polygon, ellipse').forEach(el => el.style.fill = value);
         } else {
          shapeEl.style.fill = value;
         }
        } else if (property === "circleBorder" && shapeEl) {
         if (isWebIcon) {
          shapeEl.querySelectorAll('svg, path, circle, rect, polygon, ellipse').forEach(el => el.style.stroke = value);
         } else {
          shapeEl.style.stroke = value;
         }
        } else if (property === "titleColor" && label) label.style.fill = value;
        else if (property === "titleFont" && label) label.style.fontFamily = value;
        else if (property === "titleSize" && label) label.style.fontSize = value + "px";
        else if (property === "subColor" && sub) sub.style.fill = value;
        else if (property === "subFont" && sub) sub.style.fontFamily = value;
        else if (property === "subSize" && sub) sub.style.fontSize = value + "px";
       };
       document.getElementById("circle-color").addEventListener("input", (e) => applyStyle("circleColor", e.target.value), );
      document.getElementById("circle-border").addEventListener("input", (e) => applyStyle("circleBorder", e.target.value), );
       document.getElementById("title-color").addEventListener("input", (e) => applyStyle("titleColor", e.target.value), );
       document.getElementById("title-font").addEventListener("change", (e) => applyStyle("titleFont", e.target.value), );
       document.getElementById("title-size").addEventListener("input", (e) => applyStyle("titleSize", parseInt(e.target.value, 10)), );
       document.getElementById("sub-color").addEventListener("input", (e) => applyStyle("subColor", e.target.value), );
       document.getElementById("sub-font").addEventListener("change", (e) => applyStyle("subFont", e.target.value), );
       document.getElementById("sub-size").addEventListener("input", (e) => applyStyle("subSize", parseInt(e.target.value, 10)), );
       document.getElementById("title-offset-y").addEventListener("input", (e) => {
        applyStyle("titleOffsetY", parseInt(e.target.value, 10) || 0);
        forgeTheTopology();
        if (currentNodeId) claimTheImmortal(currentNodeId);
       });
       document.getElementById("title-offset-x").addEventListener("input", (e) => {
        applyStyle("titleOffsetX", parseInt(e.target.value, 10) || 0);
        forgeTheTopology();
        if (currentNodeId) claimTheImmortal(currentNodeId);
       });
       document.getElementById("sub-offset-y").addEventListener("input", (e) => {
        applyStyle("subOffsetY", parseInt(e.target.value, 10) || 0);
        forgeTheTopology();
        if (currentNodeId) claimTheImmortal(currentNodeId);
       });
       document.getElementById("sub-offset-x").addEventListener("input", (e) => {
        applyStyle("subOffsetX", parseInt(e.target.value, 10) || 0);
        forgeTheTopology();
        if (currentNodeId) claimTheImmortal(currentNodeId);
       });
      document.getElementById("ping-offset-x").addEventListener("input", (e) => {
      applyStyle("pingOffsetX", parseInt(e.target.value, 10) || 0);
      updatePingIndicator(currentNodeId);
      if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      
      document.getElementById("ping-offset-y").addEventListener("input", (e) => {
      applyStyle("pingOffsetY", parseInt(e.target.value, 10) || 0);
      updatePingIndicator(currentNodeId);
      if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      
       document.getElementById("reset-styles").addEventListener("click", () => {
        delete savedStyles[currentNodeId];
        forgeTheTopology();
        claimTheImmortal(currentNodeId);
       });
       document.getElementById("style-scope").addEventListener("change", (e) => {
        currentStyleScope = e.target.value || "all";
        claimTheImmortal(currentNodeId);
       });
       document.getElementById("shape-select").addEventListener("change", (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId]) return;
        const shape = e.target.value || "circle";
        if (shape === 'custom-icon') return;
        NODE_DATA[currentNodeId].shape = shape;
        if (savedStyles[currentNodeId]) {
         Object.keys(savedStyles[currentNodeId]).forEach(scope => {
          if (savedStyles[currentNodeId][scope] && savedStyles[currentNodeId][scope].icon) {
           delete savedStyles[currentNodeId][scope].icon;
          }
         });
        }
        const customOpt = e.target.querySelector('option[value="custom-icon"]');
        if (customOpt) customOpt.remove();
        forgeTheTopology();
       });
       const addNoteBtn = document.getElementById("add-note-btn");
       const noteInput = document.getElementById("new-note-input");
       addNoteBtn.addEventListener("click", () => {
        const newNote = noteInput.value.trim();
        if (newNote && currentNodeId && NODE_DATA[currentNodeId]) {
         NODE_DATA[currentNodeId].notes.push(newNote);
         claimTheImmortal(currentNodeId);
         noteInput.value = "";
        }
       });
       noteInput.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
         addNoteBtn.click();
        }
       });
       
       document.getElementById('node-pingable').addEventListener('change', (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId]) return;
        if (!NODE_DATA[currentNodeId].ping) {
         NODE_DATA[currentNodeId].ping = {
          enabled: false,
          protocol: 'http',
          customUrl: '',
          timeout: 3000,
          status: 'unknown',
          lastCheck: null
         };
        }
        NODE_DATA[currentNodeId].ping.enabled = e.target.checked;
        document.getElementById('node-ping-options').style.display = e.target.checked ? 'block' : 'none';
        forgeTheTopology();
       });
       
       document.getElementById('node-ping-protocol').addEventListener('change', (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId].ping) return;
        NODE_DATA[currentNodeId].ping.protocol = e.target.value;
        document.getElementById('node-custom-url-container').style.display = 
         e.target.value === 'custom' ? 'block' : 'none';
       });
       
       document.getElementById('node-custom-url').addEventListener('change', (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId].ping) return;
        NODE_DATA[currentNodeId].ping.customUrl = e.target.value.trim();
       });
       
       document.getElementById('node-ping-timeout').addEventListener('change', (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId].ping) return;
        NODE_DATA[currentNodeId].ping.timeout = parseInt(e.target.value) || 3000;
       });
       
       document.getElementById('check-ping-now').addEventListener('click', () => {
        if (!currentNodeId) return;
        checkNodeStatus(currentNodeId);
       });
       
       document.getElementById("edge-width").addEventListener("input", () => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        const v = parseInt(document.getElementById("edge-width").value, 10);
        if (Number.isNaN(v) || v <= 0) return;
        edge.width = v;
       
        const el = document.querySelector(`.edge[data-edge-id="${currentEdgeId}"]`, );
        if (el) el.style.strokeWidth = v;
       });
       document.getElementById("edge-color").addEventListener("input", () => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        const color = document.getElementById("edge-color").value;
        edge.color = color;
       
        const el = document.querySelector(`.edge[data-edge-id="${currentEdgeId}"]`, );
        if (el) el.style.stroke = color;
        forgeTheLegend();
       });
       document.getElementById("edge-direction").addEventListener("change", () => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        edge.direction = document.getElementById("edge-direction").value;
       
        forgeTheTopology();
        selectTheConnection(currentEdgeId);
       });
       document.getElementById("edge-line-style").addEventListener("change", () => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        edge.lineStyle = document.getElementById("edge-line-style").value;
       
        forgeTheTopology();
        selectTheConnection(currentEdgeId);
       });
       const addEdgeNoteBtn = document.getElementById("add-edge-note");
       const newEdgeNoteInput = document.getElementById("new-edge-note");
       addEdgeNoteBtn.addEventListener("click", () => {
        const txt = newEdgeNoteInput.value.trim();
        if (!txt || !currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        edge.notes.push(txt);
       
        newEdgeNoteInput.value = "";
        selectTheConnection(currentEdgeId);
       });
       newEdgeNoteInput.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
         addEdgeNoteBtn.click();
        }
       });
	   
      function selectTheRect(id) {
	  if (isViewOnly()) return;
      currentRectId = id;
      currentNodeId = null;
      currentEdgeId = null;
      currentTextId = null;
      document.getElementById("node-panel").style.display = "none";
      document.getElementById("edge-panel").style.display = "none";
      document.getElementById("text-panel").style.display = "none";
      document.getElementById("rect-panel").style.display = "block";
      document.getElementById("topology-toolbar").style.display = "none";
      document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active"));
      document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
      document.querySelectorAll(".text-element").forEach(t => t.classList.remove("active"));
      document.querySelectorAll(".rect-group").forEach(r => r.classList.toggle("active", r.dataset.rectId === id));
      
      const rect = RECT_DATA.list.find(r => r.id === id);
      if (!rect) return;
      
      document.getElementById("rect-title").textContent = "";
      document.getElementById("rect-color").value = rect.color || "#f97316";
      document.getElementById("rect-border-color").value = rect.borderColor || rect.color || "#f97316";
      document.getElementById("rect-border-width").value = rect.borderWidth !== undefined ? rect.borderWidth : 2;
      document.getElementById("rect-style-select").value = rect.style || "filled";
      document.getElementById("rect-line-style").value = rect.lineStyle || "solid";
      document.getElementById("rect-fill-row").style.display = (rect.style === "outlined") ? "none" : "flex";
      
      const list = document.getElementById("rect-notes");
      list.innerHTML = "";
      (rect.notes || []).forEach((note, i) => {
      const li = document.createElement("li");
      const txt = document.createElement("span");
      txt.textContent = note;
      txt.style.flex = "1";
      const del = document.createElement("span");
      del.className = "delete-note";
      del.textContent = "‚úï";
      del.addEventListener("click", (e) => {
      e.stopPropagation();
      challengeTheImmortal("Delete this note?", () => {
        rect.notes.splice(i, 1);
        selectTheRect(id);
      });
      });
      li.appendChild(txt);
      li.appendChild(del);
      list.appendChild(li);
      });
      
      forgeTheTopology();
      }
      
      document.getElementById("rect-color").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      rect.color = document.getElementById("rect-color").value;
      forgeTheTopology();
      });
      
      document.getElementById("rect-border-color").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      rect.borderColor = document.getElementById("rect-border-color").value;
      forgeTheTopology();
      });
      
      document.getElementById("rect-border-width").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      rect.borderWidth = parseInt(document.getElementById("rect-border-width").value) || 2;
      forgeTheTopology();
      });
      
      document.getElementById("rect-style-select").addEventListener("change", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      rect.style = document.getElementById("rect-style-select").value;
      forgeTheTopology();
      selectTheRect(currentRectId);
      });
      
	  document.getElementById("rect-line-style").addEventListener("change", () => {
      if (!currentRectId) return;
      pushUndo("change zone line style");
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      rect.lineStyle = document.getElementById("rect-line-style").value;
      forgeTheTopology();
      });
	  
      document.getElementById("add-rect-note").addEventListener("click", () => {
      const input = document.getElementById("new-rect-note");
      const txt = input.value.trim();
      if (!txt || !currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      if (!rect.notes) rect.notes = [];
      rect.notes.push(txt);
      input.value = "";
      selectTheRect(currentRectId);
      });
      
      document.getElementById("new-rect-note").addEventListener("keypress", (e) => {
      if (e.key === "Enter") {
      document.getElementById("add-rect-note").click();
      }
      });
      
      document.getElementById("delete-rect").addEventListener("click", () => {
      if (!currentRectId) return;
      challengeTheImmortal("Delete this box?", () => {
      RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== currentRectId);
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      });
      });
       document.getElementById("delete-edge").addEventListener("click", () => {
        if (!currentEdgeId) return;
        challengeTheImmortal("Are you sure you want to delete this line?",
         () => {
          EDGE_DATA.list = EDGE_DATA.list.filter(
           (e) => e.id !== currentEdgeId, );
         
          currentEdgeId = null;
          forgeTheTopology();
          const availableNodes = Object.keys(NODE_DATA);
          if (availableNodes.length > 0) {
           claimTheImmortal(availableNodes[0]);
          } else {
           document.getElementById("node-panel").style.display = "none";
           document.getElementById("edge-panel").style.display = "none";
           document.getElementById("topology-toolbar", ).style.display = "none";
          }
         }, );
       });
       document.getElementById("add-line-btn").addEventListener("click", () => {
        if (!currentNodeId) return;
        const select = document.getElementById("add-line-select");
        const directionSelect = document.getElementById("add-line-direction");
        const colorInput = document.getElementById("add-line-color");
        const targetId = select.value;
        if (!targetId || targetId === currentNodeId) return;
        const direction = directionSelect.value || "none";
        const lineColor = colorInput.value || "#475569";
        const newId = `${currentNodeId}-${targetId}-${Date.now()}`;
        const newEdge = {
         id: newId,
         from: currentNodeId,
         to: targetId,
         width: 4,
         color: lineColor,
         direction: direction,
         type: "main",
         notes: [],
         fromPort: "",
         toPort: "",
        };
        EDGE_DATA.list.push(newEdge);
       
        forgeTheTopology();
        claimTheImmortal(currentNodeId);
       });
       let rectStartPoint = null;
       let rectPreviewEl = null;
       let rectStyle = "filled";
       let freeDrawPoints = [];
       let freeDrawPolylineEl = null;
       let freeDrawPointEls = [];
       const drawToggleBtn = document.getElementById("draw-toggle");
       const drawUndoBtn = document.getElementById("draw-undo");
       const drawColorInput = document.getElementById("draw-color");
       const drawStyleSelect = document.getElementById("draw-style");
       const drawArrowSelect = document.getElementById("draw-arrow");
       const svgMap = document.getElementById("map");
      
       function updateFreeDrawGraphics() {
        const ns = "http://www.w3.org/2000/svg";
        const svg = svgMap;
        if (!freeDrawPolylineEl && freeDrawPoints.length > 0) {
         freeDrawPolylineEl = document.createElementNS(ns, "polyline");
         freeDrawPolylineEl.classList.add("edge", "free-preview");
         freeDrawPolylineEl.setAttribute("fill", "none");
         svg.appendChild(freeDrawPolylineEl);
        }
        if (freeDrawPolylineEl) {
         if (freeDrawPoints.length === 0) {
          freeDrawPolylineEl.remove();
          freeDrawPolylineEl = null;
         } else {
          const ptsStr = freeDrawPoints.map((p) => `${p.x},${p.y}`).join(" ");
          freeDrawPolylineEl.setAttribute("points", ptsStr);
          freeDrawPolylineEl.style.stroke = drawColorInput.value || "#475569";
          freeDrawPolylineEl.style.strokeWidth = 3;
          const lineStyle = drawStyleSelect.value || "solid";
          if (lineStyle === "dashed") {
           freeDrawPolylineEl.style.strokeDasharray = "10,5";
          } else if (lineStyle === "dotted") {
           freeDrawPolylineEl.style.strokeDasharray = "2,4";
          } else {
           freeDrawPolylineEl.style.strokeDasharray = "none";
          }
         }
        }
        freeDrawPointEls.forEach((el) => el.remove());
        freeDrawPointEls = [];
        freeDrawPoints.forEach((p, idx) => {
         const c = document.createElementNS(ns, "circle");
         c.classList.add("free-point");
         c.setAttribute("cx", p.x);
         c.setAttribute("cy", p.y);
         c.setAttribute("r", 5);
         c.dataset.index = String(idx);
         c.addEventListener("mousedown", (e) => {
          if (!freeDrawMode) return;
          e.preventDefault();
          e.stopPropagation();
          let dragging = true;
          const svgEl = svgMap;
          const moveHandler = (ev) => {
           if (!dragging) return;
           const pt = svgEl.createSVGPoint();
           pt.x = ev.clientX;
           pt.y = ev.clientY;
           const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
           const i = parseInt(c.dataset.index, 10);
           if (Number.isNaN(i) || !freeDrawPoints[i]) return;
           freeDrawPoints[i].x = svgP.x;
           freeDrawPoints[i].y = svgP.y;
           updateFreeDrawGraphics();
          };
          const upHandler = () => {
           dragging = false;
           document.removeEventListener("mousemove", moveHandler);
           document.removeEventListener("mouseup", upHandler);
          };
          document.addEventListener("mousemove", moveHandler);
          document.addEventListener("mouseup", upHandler);
         });
         c.addEventListener("touchstart",
          (e) => {
           if (!freeDrawMode) return;
           e.preventDefault();
           e.stopPropagation();
           let dragging = true;
           const svgEl = svgMap;
           const touchMoveHandler = (ev) => {
            if (!dragging || !ev.touches[0]) return;
            const pt = svgEl.createSVGPoint();
            pt.x = ev.touches[0].clientX;
            pt.y = ev.touches[0].clientY;
            const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
            const i = parseInt(c.dataset.index, 10);
            if (Number.isNaN(i) || !freeDrawPoints[i]) return;
            freeDrawPoints[i].x = svgP.x;
            freeDrawPoints[i].y = svgP.y;
            updateFreeDrawGraphics();
           };
           const touchUpHandler = () => {
            dragging = false;
            document.removeEventListener("touchmove", touchMoveHandler, );
            document.removeEventListener("touchend", touchUpHandler, );
           };
           document.addEventListener("touchmove", touchMoveHandler);
           document.addEventListener("touchend", touchUpHandler);
          }, {
           passive: false
          }, );
         svg.appendChild(c);
         freeDrawPointEls.push(c);
        });
        drawUndoBtn.style.display = freeDrawPoints.length ? "inline-block" : "none";
       }
      
       function addFreeDrawPoint(x, y) {
        freeDrawPoints.push({
         x,
         y
        });
        updateFreeDrawGraphics();
       }
      
       function startFreeDraw() {
        freeDrawMode = true;
        freeDrawPoints = [];
        if (freeDrawPolylineEl) {
         freeDrawPolylineEl.remove();
         freeDrawPolylineEl = null;
        }
        freeDrawPointEls.forEach((el) => el.remove());
        freeDrawPointEls = [];
        svgMap.style.cursor = "crosshair";
        drawToggleBtn.textContent = "Done";
        drawUndoBtn.style.display = "none";
       }
      
       function finishFreeDraw() {
        freeDrawMode = false;
        svgMap.style.cursor = "";
        drawToggleBtn.textContent = "‚úèÔ∏è";
        if (freeDrawPoints.length >= 2) {
         const color = drawColorInput.value || "#475569";
         const lineStyle = drawStyleSelect.value || "solid";
         const arrowDir = drawArrowSelect.value || "none";
         const newId = "custom-" + Date.now();
         const pointsCopy = freeDrawPoints.map((p) => ({
          x: p.x,
          y: p.y,
         }));
         EDGE_DATA.list.push({
          id: newId,
          type: "custom",
          color,
          width: 4,
          lineStyle: lineStyle,
          direction: arrowDir,
          points: pointsCopy,
          notes: [],
         });
        
         freeDrawPoints = [];
         if (freeDrawPolylineEl) {
          freeDrawPolylineEl.remove();
          freeDrawPolylineEl = null;
         }
         freeDrawPointEls.forEach((el) => el.remove());
         freeDrawPointEls = [];
         forgeTheTopology();
         selectTheConnection(newId);
        } else {
         freeDrawPoints = [];
         if (freeDrawPolylineEl) {
          freeDrawPolylineEl.remove();
          freeDrawPolylineEl = null;
         }
         freeDrawPointEls.forEach((el) => el.remove());
         freeDrawPointEls = [];
         forgeTheLegend();
        }
        drawUndoBtn.style.display = "none";
       }
       drawToggleBtn.addEventListener("click", () => {
        if (currentView.mode === "rack") {
         alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
         return;
        }
        
        if (freeDrawMode) {
         finishFreeDraw();
        } else {
         startFreeDraw();
        }
       });
       drawUndoBtn.addEventListener("click", () => {
        if (!freeDrawMode || !freeDrawPoints.length) return;
        freeDrawPoints.pop();
        updateFreeDrawGraphics();
       });
       const drawToolbar = document.getElementById("draw-toolbar");
       drawToolbar.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       drawToolbar.addEventListener("click", (e) => {
        if (e.target !== drawToggleBtn && e.target !== drawUndoBtn) {
         e.stopPropagation();
        }
       });
       drawStyleSelect.addEventListener("change", () => {
        if (freeDrawMode) {
         updateFreeDrawGraphics();
        }
       });
       drawArrowSelect.addEventListener("change", () => {
        if (freeDrawMode) {
         updateFreeDrawGraphics();
        }
       });
       drawColorInput.addEventListener("input", () => {
        if (freeDrawMode) {
         updateFreeDrawGraphics();
        }
       });
       drawStyleSelect.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       drawStyleSelect.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       drawArrowSelect.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       drawArrowSelect.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       drawColorInput.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       drawColorInput.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       svgMap.addEventListener("click", (e) => {
        if (!freeDrawMode) return;
        if (e.button !== 0) return;
        const target = e.target;
        if (target && target.classList && target.classList.contains("free-point")) return;
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        addFreeDrawPoint(svgP.x, svgP.y);
       });
       svgMap.addEventListener("touchend",
        (e) => {
         if (!freeDrawMode) return;
         const target = e.target;
         if (target && target.classList && target.classList.contains("free-point")) return;
         if (e.changedTouches && e.changedTouches[0]) {
          e.preventDefault();
          const svgEl = svgMap;
          const pt = svgEl.createSVGPoint();
          pt.x = e.changedTouches[0].clientX;
          pt.y = e.changedTouches[0].clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          addFreeDrawPoint(svgP.x, svgP.y);
         }
        }, {
         passive: false
        }, );
       const settingsBtn = document.getElementById("settings-btn");
      
       const rectToggleBtn = document.getElementById("rect-toggle");
       const rectStyleSelect = document.getElementById("rect-style");
      
       function updateRectPreview() {
        if (!rectPreviewEl || !rectStartPoint) return;
        
        const ns = "http://www.w3.org/2000/svg";
        const svg = svgMap;
        
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
       }
      
       function startRectDraw() {
        rectDrawMode = true;
        rectStartPoint = null;
        rectPreviewEl = null;
        svgMap.style.cursor = "crosshair";
        rectToggleBtn.textContent = "Done";
        rectStyle = rectStyleSelect.value || "filled";
        
        if (freeDrawMode) {
         finishFreeDraw();
        }
        updateRectangleDeleteButtons();
       }
      
       function finishRectDraw() {
        rectDrawMode = false;
        svgMap.style.cursor = "";
        rectToggleBtn.textContent = "‚ñ≠";
        
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
		updateRectangleDeleteButtons();
       }
      
       rectToggleBtn.addEventListener("click", () => {
        if (currentView.mode === "rack") {
         alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
         return;
        }
        
        if (rectDrawMode) {
         finishRectDraw();
        } else {
         startRectDraw();
        }
       });
      
       rectStyleSelect.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       rectStyleSelect.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       rectStyleSelect.addEventListener("change", () => {
        if (rectDrawMode) {
         rectStyle = rectStyleSelect.value || "filled";
        }
       });
      
       svgMap.addEventListener("mousedown", (e) => {
        if (!rectDrawMode) return;
        if (e.button !== 0) return;
        e.preventDefault();
        e.stopPropagation();
        
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        rectStartPoint = { x: svgP.x, y: svgP.y };
        
        const ns = "http://www.w3.org/2000/svg";
        rectPreviewEl = document.createElementNS(ns, "rect");
        rectPreviewEl.classList.add("rect-preview");
        rectPreviewEl.setAttribute("x", svgP.x);
        rectPreviewEl.setAttribute("y", svgP.y);
        rectPreviewEl.setAttribute("width", 0);
        rectPreviewEl.setAttribute("height", 0);
        
        const color = drawColorInput.value || "#f97316";
        rectPreviewEl.style.stroke = color;
        rectPreviewEl.style.strokeWidth = 2;
        rectPreviewEl.style.strokeDasharray = "5,5";
        
        if (rectStyle === "filled") {
         rectPreviewEl.style.fill = color;
         rectPreviewEl.style.fillOpacity = "0.3";
        } else {
         rectPreviewEl.style.fill = "none";
        }
        
        svgEl.appendChild(rectPreviewEl);
       });
      
       svgMap.addEventListener("mousemove", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        
        rectPreviewEl.setAttribute("x", x);
        rectPreviewEl.setAttribute("y", y);
        rectPreviewEl.setAttribute("width", width);
        rectPreviewEl.setAttribute("height", height);
       });
      
       svgMap.addEventListener("mouseup", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        
        if (width > 10 && height > 10) {
      pushUndo("draw zone"); 
         const color = drawColorInput.value || "#f97316";
         const newId = "rect-" + Date.now();
         
         const lineStyle = document.getElementById("draw-style").value || "solid";
         RECT_DATA.list.push({
          id: newId,
          x: x,
          y: y,
          width: width,
          height: height,
          color: color,
          style: rectStyle,
          lineStyle: lineStyle,
          notes: []
         });
         
         forgeTheTopology();
        }
        
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
       });
      
       let rectTouchStart = null;
       
       svgMap.addEventListener("touchstart", (e) => {
        if (!rectDrawMode) return;
        if (e.touches.length !== 1) return;
        
        e.preventDefault();
        const touch = e.touches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        rectStartPoint = { x: svgP.x, y: svgP.y };
        rectTouchStart = { x: svgP.x, y: svgP.y };
        
        const ns = "http://www.w3.org/2000/svg";
        rectPreviewEl = document.createElementNS(ns, "rect");
        rectPreviewEl.classList.add("rect-preview");
        rectPreviewEl.setAttribute("x", svgP.x);
        rectPreviewEl.setAttribute("y", svgP.y);
        rectPreviewEl.setAttribute("width", 0);
        rectPreviewEl.setAttribute("height", 0);
        
        const color = drawColorInput.value || "#f97316";
        rectPreviewEl.style.stroke = color;
        rectPreviewEl.style.strokeWidth = 2;
        rectPreviewEl.style.strokeDasharray = "5,5";
        
        if (rectStyle === "filled") {
         rectPreviewEl.style.fill = color;
         rectPreviewEl.style.fillOpacity = "0.3";
        } else {
         rectPreviewEl.style.fill = "none";
        }
        
        svgEl.appendChild(rectPreviewEl);
       }, { passive: false });
      
       svgMap.addEventListener("touchmove", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        if (e.touches.length !== 1) return;
        
        e.preventDefault();
        const touch = e.touches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        
        rectPreviewEl.setAttribute("x", x);
        rectPreviewEl.setAttribute("y", y);
        rectPreviewEl.setAttribute("width", width);
        rectPreviewEl.setAttribute("height", height);
       }, { passive: false });
      
       svgMap.addEventListener("touchend", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        if (!rectTouchStart) return;
        
        e.preventDefault();
        const touch = e.changedTouches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        
        if (width > 10 && height > 10) {
      pushUndo("draw zone");
         const color = drawColorInput.value || "#f97316";
         const newId = "rect-" + Date.now();
         
         const lineStyle = document.getElementById("draw-style").value || "solid";
         RECT_DATA.list.push({
          id: newId,
          x: x,
          y: y,
          width: width,
          height: height,
          color: color,
          style: rectStyle,
          lineStyle: lineStyle,
          notes: []
         });
         
         forgeTheTopology();
        }
        
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
        rectTouchStart = null;
       }, { passive: false });
      
       const textToggleBtn = document.getElementById("text-toggle");
       
       function startTextMode() {
        textDrawMode = true;
        svgMap.style.cursor = "crosshair";
        textToggleBtn.textContent = "Done";
        textToggleBtn.style.background = "var(--accent)";
        textToggleBtn.style.color = "var(--bg)";
        
        if (freeDrawMode) {
         finishFreeDraw();
        }
        if (rectDrawMode) {
         finishRectDraw();
        }
        
        updateTextDeleteButtons();
       }
       
       function finishTextMode() {
        textDrawMode = false;
        svgMap.style.cursor = "";
        textToggleBtn.textContent = "T";
        textToggleBtn.style.background = "";
        textToggleBtn.style.color = "";
        updateTextDeleteButtons();
       }
       
       textToggleBtn.addEventListener("click", () => {
        if (currentView.mode === "rack") {
         alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
         return;
        }
        
        if (textDrawMode) {
         finishTextMode();
        } else {
         startTextMode();
        }
       });
       
       function handleTextPlacement(e) {
        if (!textDrawMode) return;
        
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        
        const newId = "text-" + Date.now();
      pushUndo("add text");
        TEXT_DATA.list.push({
         id: newId,
         x: svgP.x,
         y: svgP.y,
         content: "New Text",
         fontSize: 18,
         color: "#e2e8f0",
         fontWeight: "normal",
         fontStyle: "normal",
         textAlign: "start",
         textDecoration: "none",
         bgColor: "#000000",
         bgEnabled: false,
         opacity: 1
        });
        
        forgeTheTopology();
        
        showTextPanel(newId);
       }
       
       svgMap.addEventListener("click", (e) => {
        if (!textDrawMode) return;
        if (e.target.closest('.text-delete-btn')) return;
        if (e.target.closest('.text-group')) return;
        
        e.preventDefault();
        e.stopPropagation();
        handleTextPlacement(e);
       });
       
       svgMap.addEventListener("touchend", (e) => {
        if (!textDrawMode) return;
        if (e.target.closest('.text-delete-btn')) return;
        if (e.target.closest('.text-group')) return;
        if (e.touches.length > 0) return;
        
        e.preventDefault();
        const touch = e.changedTouches[0];
        const fakeEvent = {
         clientX: touch.clientX,
         clientY: touch.clientY,
         preventDefault: () => {},
         stopPropagation: () => {}
        };
        handleTextPlacement(fakeEvent);
       }, { passive: false });
       
       function showTextPanel(textId) {
	   if (isViewOnly()) return;
       currentTextId = textId;
       currentNodeId = null;
       currentEdgeId = null;
       currentRectId = null;
       const textItem = TEXT_DATA.list.find(t => t.id === textId);
       if (!textItem) return;
       
       document.getElementById("node-panel").style.display = "none";
       document.getElementById("edge-panel").style.display = "none";
       document.getElementById("rect-panel").style.display = "none";
       
       const textPanel = document.getElementById("text-panel");
       textPanel.style.display = "block";
       document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active"));
       document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
       document.querySelectorAll(".rect-group").forEach(r => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach(t => t.classList.toggle("active", t.dataset.textId === textId));
        
        document.getElementById("text-content").value = textItem.content;
        document.getElementById("text-font-size").value = textItem.fontSize;
        document.getElementById("text-color").value = textItem.color;
        document.getElementById("text-font-weight").value = textItem.fontWeight;
        document.getElementById("text-font-style").value = textItem.fontStyle;
        document.getElementById("text-align").value = textItem.textAlign;
        document.getElementById("text-decoration").value = textItem.textDecoration;
        document.getElementById("text-bg-color").value = textItem.bgColor;
        document.getElementById("text-bg-enabled").checked = textItem.bgEnabled;
        document.getElementById("text-opacity").value = textItem.opacity;
        document.getElementById("text-opacity-val").textContent = Math.round(textItem.opacity * 100) + "%";
       }
       
       function updateTextDeleteButtons() {
        const deleteButtons = document.querySelectorAll('.text-delete-btn');
        deleteButtons.forEach(btn => {
         btn.style.display = textDrawMode ? 'block' : 'none';
        });
       }
       
       function deleteText(textId) {
      pushUndo("delete text");
        TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== textId);
        forgeTheTopology();
        
        if (currentTextId === textId) {
         document.getElementById("text-panel").style.display = "none";
         currentTextId = null;
        }
       }
       
       document.getElementById("text-content").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
      pushUndo("edit text");
         textItem.content = e.target.value;
         forgeTheTopology();
        }
       });
       
       document.getElementById("text-font-size").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         textItem.fontSize = parseInt(e.target.value);
         forgeTheTopology();
        }
       });
       
       document.getElementById("text-color").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         textItem.color = e.target.value;
         forgeTheTopology();
        }
       });
       
       document.getElementById("text-font-weight").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         textItem.fontWeight = e.target.value;
         forgeTheTopology();
        }
       });
       
       document.getElementById("text-font-style").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         textItem.fontStyle = e.target.value;
         forgeTheTopology();
        }
       });
       
       document.getElementById("text-align").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         textItem.textAlign = e.target.value;
         forgeTheTopology();
        }
       });
       
       document.getElementById("text-decoration").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         textItem.textDecoration = e.target.value;
         forgeTheTopology();
        }
       });
       
       document.getElementById("text-bg-color").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         textItem.bgColor = e.target.value;
         forgeTheTopology();
        }
       });
       
       document.getElementById("text-bg-enabled").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         textItem.bgEnabled = e.target.checked;
         forgeTheTopology();
        }
       });
       
       document.getElementById("text-opacity").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         textItem.opacity = parseFloat(e.target.value);
         document.getElementById("text-opacity-val").textContent = Math.round(textItem.opacity * 100) + "%";
         forgeTheTopology();
        }
       });
       
       document.getElementById("delete-text").addEventListener("click", () => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         challengeTheImmortal(`Delete text "${textItem.content.substring(0, 30)}..."?`, () => {
          deleteText(currentTextId);
         });
        }
       });
      
       const settingsModal = document.getElementById("settings-modal");
       const settingsClose = document.getElementById("settings-close");
       settingsBtn.addEventListener("click", () => {	 
       document.getElementById("page-bg-color").value = rgbaToHex(PAGE_STATE.background) || "#050608";
       document.getElementById("topbar-bg-color").value = rgbaToHex(PAGE_STATE.topbarBg) || "#0b0e13";
       document.getElementById("topbar-border-color").value = rgbaToHex(PAGE_STATE.topbarBorder) || "#1f2533";	 
       document.getElementById("panel-color").value = rgbaToHex(PAGE_STATE.panel) || "#0b0e13";
       document.getElementById("panel-alt-color").value = PAGE_STATE.panelAlt || "#10141b";
       document.getElementById("sidebar-bg-color").value = PAGE_STATE.sidebarBg || "#10141b";
       document.getElementById("btn-bg-color").value = PAGE_STATE.btnBg || "#0b0e13";
       document.getElementById("btn-text-color").value = PAGE_STATE.btnText || "#e2e8f0";
       document.getElementById("tag-fill-color").value = PAGE_STATE.tagFill || "#1e293b";
       document.getElementById("tag-text-color").value = PAGE_STATE.tagText || "#e2e8f0";
       document.getElementById("tag-border-color").value = PAGE_STATE.tagBorder || "#475569";
       document.getElementById("input-bg-color").value = PAGE_STATE.inputBg || "#0b0e13";
       document.getElementById("input-text-color").value = PAGE_STATE.inputText || "#e2e8f0";
	   document.getElementById("input-border-color").value = PAGE_STATE.inputBorder || "#1f2937";
       document.getElementById("input-font-family").value = PAGE_STATE.inputFont || "Inter, system-ui, sans-serif";
       document.getElementById("input-font-size").value = PAGE_STATE.inputFontSize || 14;
       document.getElementById("toolbar-bg-color").value = PAGE_STATE.toolbarBg || "#0f172a";
       document.getElementById("toolbar-border-color").value = PAGE_STATE.toolbarBorder || "#1f2937";
       document.getElementById("toolbar-text-color").value = PAGE_STATE.toolbarText || "#94a3b8";
       document.getElementById("toolbar-btn-bg-color").value = PAGE_STATE.toolbarBtnBg || "#0b0e13";
       document.getElementById("toolbar-btn-text-color").value = PAGE_STATE.toolbarBtnText || "#e2e8f0";
       document.getElementById("minimap-dots-color").value = PAGE_STATE.minimapDots || "#94a3b8";
       document.getElementById("canvas-hint-enabled").checked = PAGE_STATE.canvasHintEnabled !== false;
       document.getElementById("canvas-hint-bg-color").value = PAGE_STATE.canvasHintBg || "#0f172a";
       document.getElementById("canvas-hint-text-color").value = PAGE_STATE.canvasHintColor || "#94a3b8";
       document.getElementById("canvas-hint-text").value = PAGE_STATE.canvasHintText || "";
       document.getElementById("accent-color").value = rgbaToHex(PAGE_STATE.accent) || "#4fd1c5";
       document.getElementById("danger-color").value = rgbaToHex(PAGE_STATE.danger) || "#f56565";
       document.getElementById("text-main-color").value = rgbaToHex(PAGE_STATE.textMain) || "#e2e8f0";
       document.getElementById("text-soft-color").value = PAGE_STATE.textSoft || "#94a3b8";
       document.getElementById("node-fill-color").value = PAGE_STATE.nodeFill || "#1e293b";
       document.getElementById("node-stroke-color").value = PAGE_STATE.nodeStroke || "#475569";
       document.getElementById("node-title-color").value = PAGE_STATE.nodeTitle || "#e2e8f0";
       document.getElementById("node-sub-color").value = PAGE_STATE.nodeSub || "#94a3b8";
       document.getElementById("node-title-size").value = PAGE_STATE.nodeTitleSize || 18;
       document.getElementById("node-sub-size").value = PAGE_STATE.nodeSubSize || 13;
       document.getElementById("node-font-family").value = PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
       document.getElementById("default-edge-color").value = PAGE_STATE.defaultEdge || "#475569";
       document.getElementById("selection-handle-color").value = PAGE_STATE.selectionHandle || "#f59e0b";
       document.getElementById("selection-handle-size").value = PAGE_STATE.selectionHandleSize || 8;
       document.getElementById("group-indicator-color").value = PAGE_STATE.groupIndicator || "#4fd1c5";
       document.getElementById("canvas-gradient-top").value = PAGE_STATE.canvasGradientTop || "#1e2532";
       document.getElementById("canvas-gradient-bottom").value = PAGE_STATE.canvasGradientBottom || "#050608";
       document.getElementById("canvas-border-color").value = PAGE_STATE.canvasBorder || "#475569";
       document.getElementById("canvas-grid-color").value = PAGE_STATE.canvasGrid || "#475569";
       document.getElementById("canvas-grid-size").value = PAGE_STATE.canvasGridSize || 50;
       document.getElementById("rack-frame-fill").value = PAGE_STATE.rackFrameFill || "#0f172a";
       document.getElementById("rack-frame-stroke").value = PAGE_STATE.rackFrameStroke || "#4fd1c5";
       document.getElementById("rack-line-color").value = PAGE_STATE.rackLineColor || "#475569";
       document.getElementById("rack-text-color").value = PAGE_STATE.rackTextColor || "#4fd1c5";
      
        
        document.getElementById("auto-ping-enabled").checked = autoPingEnabled;
        document.getElementById("auto-ping-interval").value = autoPingInterval;
        document.getElementById("auto-ping-settings").style.display = autoPingEnabled ? 'block' : 'none';
        document.getElementById("view-only-mode").checked = PAGE_STATE.viewOnly === true;
        settingsModal.classList.add("active");
       });
       settingsClose.addEventListener("click", () => {
        settingsModal.classList.remove("active");
       });
	   document.getElementById("view-only-mode").addEventListener("change", (e) => {
       PAGE_STATE.viewOnly = e.target.checked;
       
       if (e.target.checked) {
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        document.getElementById("rect-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.setProperty('display', 'none', 'important');
        document.getElementById("draw-toolbar").style.setProperty('display', 'none', 'important');
        currentNodeId = null;
        currentEdgeId = null;
        currentRectId = null;
        currentTextId = null;
        selectedNodes.clear();
        selectedRects.clear();
        selectedTexts.clear();
        selectedEdges.clear();
        const bulkToolbar = document.getElementById("bulk-toolbar");
        const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active", "selected"));
        document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
        document.querySelectorAll(".rect-group").forEach(r => r.classList.remove("active"));
        document.querySelectorAll(".text-element").forEach(t => t.classList.remove("active"));
       }
       
       wieldThePower();
       if (!e.target.checked) {
        updateDrawToolbarVisibility();
        updateTopologyToolbarVisibility();
       }
       forgeTheTopology();
      });
       settingsModal.addEventListener("click", (e) => {
        if (e.target === settingsModal) {
         settingsModal.classList.remove("active");
        }
       });
       document.getElementById("page-bg-color").addEventListener("input", (e) => {
        PAGE_STATE.background = e.target.value;
        wieldThePower();
       });
       document.getElementById("topbar-bg-color").addEventListener("input", (e) => {
        PAGE_STATE.topbarBg = e.target.value;
        wieldThePower();
       });
       document.getElementById("topbar-border-color").addEventListener("input", (e) => {
        PAGE_STATE.topbarBorder = e.target.value;
        wieldThePower();
       });
       document.getElementById("panel-color").addEventListener("input", (e) => {
        PAGE_STATE.panel = e.target.value;
        wieldThePower();
       });
       document.getElementById("panel-alt-color").addEventListener("input", (e) => {
       PAGE_STATE.panelAlt = e.target.value;
       wieldThePower();
      });
      document.getElementById("sidebar-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.sidebarBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("btn-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.btnBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("btn-text-color").addEventListener("input", (e) => {
       PAGE_STATE.btnText = e.target.value;
       wieldThePower();
      });
      document.getElementById("tag-fill-color").addEventListener("input", (e) => {
       PAGE_STATE.tagFill = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("tag-text-color").addEventListener("input", (e) => {
       PAGE_STATE.tagText = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("tag-border-color").addEventListener("input", (e) => {
       PAGE_STATE.tagBorder = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("selection-fill-color").addEventListener("input", function() {
       selectionBoxStyle.fillColor = this.value;
      });
      document.getElementById("selection-fill-opacity").addEventListener("input", function() {
       selectionBoxStyle.fillOpacity = parseFloat(this.value);
       document.getElementById("selection-fill-opacity-val").textContent = Math.round(this.value * 100) + "%";
      });
      document.getElementById("selection-stroke-color").addEventListener("input", function() {
       selectionBoxStyle.strokeColor = this.value;
      });
      document.getElementById("selection-stroke-width").addEventListener("input", function() {
       selectionBoxStyle.strokeWidth = parseInt(this.value) || 2;
      });
      document.getElementById("selection-stroke-style").addEventListener("change", function() {
       selectionBoxStyle.strokeDasharray = this.value;
      });
      document.getElementById("input-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.inputBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-text-color").addEventListener("input", (e) => {
       PAGE_STATE.inputText = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-border-color").addEventListener("input", (e) => {
       PAGE_STATE.inputBorder = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-font-family").addEventListener("change", (e) => {
       PAGE_STATE.inputFont = e.target.value;
       wieldThePower();
      });
	  document.getElementById("input-font-size").addEventListener("input", (e) => {
       PAGE_STATE.inputFontSize = parseInt(e.target.value) || 14;
       wieldThePower();
      });
      document.getElementById("toolbar-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-border-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBorder = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-text-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarText = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-btn-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBtnBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-btn-text-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBtnText = e.target.value;
       wieldThePower();
      });
      document.getElementById("minimap-dots-color").addEventListener("input", (e) => {
       PAGE_STATE.minimapDots = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("canvas-hint-enabled").addEventListener("change", (e) => {
       PAGE_STATE.canvasHintEnabled = e.target.checked;
       wieldThePower();
      });
      document.getElementById("canvas-hint-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-hint-text-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintColor = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-hint-text").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintText = e.target.value;
       wieldThePower();
      });
       document.getElementById("accent-color").addEventListener("input", (e) => {
        PAGE_STATE.accent = e.target.value;
        wieldThePower();
       });
       document.getElementById("danger-color").addEventListener("input", (e) => {
        PAGE_STATE.danger = e.target.value;
        wieldThePower();
       });
       document.getElementById("text-main-color").addEventListener("input", (e) => {
        PAGE_STATE.textMain = e.target.value;
        wieldThePower();
       });
       document.getElementById("text-soft-color").addEventListener("input", (e) => {
       PAGE_STATE.textSoft = e.target.value;
       wieldThePower();
      });
      document.getElementById("node-fill-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeFill = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-stroke-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeStroke = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-title-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeTitle = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-sub-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeSub = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-title-size").addEventListener("input", (e) => {
       PAGE_STATE.nodeTitleSize = parseInt(e.target.value) || 18;
       forgeTheTopology();
      });
      document.getElementById("node-sub-size").addEventListener("input", (e) => {
       PAGE_STATE.nodeSubSize = parseInt(e.target.value) || 13;
       forgeTheTopology();
      });
      document.getElementById("node-font-family").addEventListener("change", (e) => {
       PAGE_STATE.nodeFont = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("default-edge-color").addEventListener("input", (e) => {
       PAGE_STATE.defaultEdge = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("selection-handle-color").addEventListener("input", (e) => {
       PAGE_STATE.selectionHandle = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("selection-handle-size").addEventListener("input", (e) => {
       PAGE_STATE.selectionHandleSize = parseInt(e.target.value) || 8;
       forgeTheTopology();
      });
      document.getElementById("group-indicator-color").addEventListener("input", (e) => {
       PAGE_STATE.groupIndicator = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-gradient-top").addEventListener("input", (e) => {
       PAGE_STATE.canvasGradientTop = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-gradient-bottom").addEventListener("input", (e) => {
       PAGE_STATE.canvasGradientBottom = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-border-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasBorder = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-grid-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasGrid = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-grid-size").addEventListener("input", (e) => {
       PAGE_STATE.canvasGridSize = parseInt(e.target.value) || 50;
       forgeTheTopology();
      });
      document.getElementById("rack-frame-fill").addEventListener("input", (e) => {
       PAGE_STATE.rackFrameFill = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-frame-stroke").addEventListener("input", (e) => {
       PAGE_STATE.rackFrameStroke = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-line-color").addEventListener("input", (e) => {
       PAGE_STATE.rackLineColor = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-text-color").addEventListener("input", (e) => {
       PAGE_STATE.rackTextColor = e.target.value;
       forgeTheTopology();
      });
      
      (function initializeResizers() {
         const headerResizer = document.getElementById('header-resizer');
         const sidebarResizer = document.getElementById('sidebar-resizer');
         const mobileFooterResizer = document.getElementById('mobile-footer-resizer');
         
         let isResizing = false;
         let currentResizer = null;
         let startY = 0;
         let startX = 0;
         let startHeight = 0;
         let startWidth = 0;
         
         function getClientPos(e) {
           if (e.touches && e.touches.length > 0) {
             return { x: e.touches[0].clientX, y: e.touches[0].clientY };
           }
           return { x: e.clientX, y: e.clientY };
         }
         
         function startResize(resizer, type, e) {
           isResizing = true;
           currentResizer = type;
           const pos = getClientPos(e);
           
           if (type === 'header') {
             startY = pos.y;
             startHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--topbar-height'));
           } else if (type === 'sidebar') {
             startX = pos.x;
             startWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width'));
           } else if (type === 'mobile-footer') {
             startY = pos.y;
             const currentVh = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--mobile-footer-height'));
             startHeight = (currentVh / 100) * window.innerHeight;
           }
           
           resizer.classList.add('resizing');
           document.body.classList.add('resizing');
           document.body.style.cursor = (type === 'sidebar') ? 'col-resize' : 'row-resize';
           e.preventDefault();
         }
         
         if (headerResizer) {
           headerResizer.addEventListener('mousedown', (e) => startResize(headerResizer, 'header', e));
           headerResizer.addEventListener('touchstart', (e) => startResize(headerResizer, 'header', e), { passive: false });
         }
         
         if (sidebarResizer) {
           sidebarResizer.addEventListener('mousedown', (e) => startResize(sidebarResizer, 'sidebar', e));
           sidebarResizer.addEventListener('touchstart', (e) => startResize(sidebarResizer, 'sidebar', e), { passive: false });
         }
         
         if (mobileFooterResizer) {
           mobileFooterResizer.addEventListener('mousedown', (e) => startResize(mobileFooterResizer, 'mobile-footer', e));
           mobileFooterResizer.addEventListener('touchstart', (e) => startResize(mobileFooterResizer, 'mobile-footer', e), { passive: false });
         }
         
         function handleMove(e) {
           if (!isResizing) return;
           
           const pos = getClientPos(e);
           
           if (currentResizer === 'header') {
             const deltaY = pos.y - startY;
             const newHeight = Math.max(40, Math.min(150, startHeight + deltaY));
             document.documentElement.style.setProperty('--topbar-height', newHeight + 'px');
           } else if (currentResizer === 'sidebar') {
             const deltaX = startX - pos.x;
             const newWidth = Math.max(200, Math.min(800, startWidth + deltaX));
             document.documentElement.style.setProperty('--sidebar-width', newWidth + 'px');
           } else if (currentResizer === 'mobile-footer') {
             const deltaY = startY - pos.y;
             const newHeight = startHeight + deltaY;
             const newVh = Math.max(15, Math.min(80, (newHeight / window.innerHeight) * 100));
             document.documentElement.style.setProperty('--mobile-footer-height', newVh + 'vh');
           }
           
           e.preventDefault();
         }
         
         document.addEventListener('mousemove', handleMove);
         document.addEventListener('touchmove', handleMove, { passive: false });
         
         function handleEnd() {
           if (isResizing) {
             isResizing = false;
             
             if (currentResizer === 'header') {
               PAGE_STATE.topbarHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--topbar-height'));
               headerResizer.classList.remove('resizing');
             } else if (currentResizer === 'sidebar') {
               PAGE_STATE.sidebarWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width'));
               sidebarResizer.classList.remove('resizing');
             } else if (currentResizer === 'mobile-footer') {
               PAGE_STATE.mobileFooterHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--mobile-footer-height'));
               mobileFooterResizer.classList.remove('resizing');
             }
             
             document.body.classList.remove('resizing');
             document.body.style.cursor = '';
             currentResizer = null;
           }
         }
         
         document.addEventListener('mouseup', handleEnd);
         document.addEventListener('touchend', handleEnd);
         document.addEventListener('touchcancel', handleEnd);
       })();
       
       document.getElementById("auto-ping-enabled").addEventListener("change", (e) => {
        autoPingEnabled = e.target.checked;
        PAGE_STATE.autoPingEnabled = autoPingEnabled;
        document.getElementById("auto-ping-settings").style.display = autoPingEnabled ? 'block' : 'none';
        
        if (autoPingEnabled) {
         startAutoPing();
        } else {
         stopAutoPing();
        }
       });
       
       document.getElementById("auto-ping-interval").addEventListener("change", (e) => {
        const newInterval = parseInt(e.target.value, 10);
        if (newInterval >= 5 && newInterval <= 3600) {
         autoPingInterval = newInterval;
         PAGE_STATE.autoPingInterval = autoPingInterval;
         
         if (autoPingEnabled) {
          startAutoPing();
         }
        }
       });
       
       document.getElementById("export-data-btn").addEventListener("click", () => {
        const data = captureTheQuickening();
        const jsonStr = JSON.stringify(data, null, 2);
        const blob = new Blob([jsonStr], {
         type: "application/json"
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        const safeTitle = (PAGE_STATE.title || "network-topology").toLowerCase().replace(/[^a-z0-9\-]+/g, "-");
        const timestamp = new Date().toISOString().split("T")[0];
        a.download = `${safeTitle}-data-${timestamp}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
		logAuditEvent("export", `Exported JSON: ${a.download}`);
       });
       document.getElementById("import-data-btn").addEventListener("click", () => {
        document.getElementById("import-data-file").click();
       });
       document.getElementById("import-data-file").addEventListener("change", async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        try {
         const text = await file.text();
         const data = JSON.parse(text);
         if (!data.nodeData || !data.edgeData) {
          alert("Invalid data file. Missing required fields.");
          return;
         }
         const confirmMsg = `This will replace all current data with the imported data.\n\nImporting:\n- ${Object.keys(data.nodeData).length} nodes\n- ${data.edgeData.list?.length || 0} connections\n- ${data.documentTabs?.length || 1} tab(s)\n\nContinue?`;         if (!confirm(confirmMsg)) {
          e.target.value = "";
          return;
         }
         NODE_DATA = data.nodeData || {};
         EDGE_DATA = data.edgeData || {
          list: []
         };
         EDGE_LEGEND = data.edgeLegend || {};
         RECT_DATA = data.rectData || { list: [] };
         TEXT_DATA = data.textData || { list: [] };
         savedPositions = data.nodePositions || {};
         savedSizes = data.nodeSizes || {};
         savedStyles = data.nodeStyles || {};
         if (data.page) {
          PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, data.page, );
          wieldThePower();
         }
      
      if (data.autoPingEnabled !== undefined) {
      autoPingEnabled = data.autoPingEnabled;
      PAGE_STATE.autoPingEnabled = autoPingEnabled;
      document.getElementById("auto-ping-enabled").checked = autoPingEnabled;
      }
      
      if (data.autoPingInterval !== undefined) {
      autoPingInterval = data.autoPingInterval;
      PAGE_STATE.autoPingInterval = autoPingInterval;
      document.getElementById("auto-ping-interval").value = autoPingInterval;
      }
         if (data.canvas) {
          canvasState.zoom = data.canvas.zoom || 1;
          canvasState.panX = data.canvas.panX || 0;
          canvasState.panY = data.canvas.panY || 0;
         }
         if (data.page?.title) {
         document.title = data.page.title;
         document.querySelector(".editable-page-title", ).textContent = data.page.title;
        }
        if (data.documentTabs) {
         documentTabs = data.documentTabs;
         currentTabIndex = data.currentTabIndex || 0;
        }
        if (data.savedTopologyView) {
         savedTopologyView = data.savedTopologyView;
        }
        if (data.encryptedSections) {
         encryptedSections = data.encryptedSections;
        }
        if (data.auditLog && Array.isArray(data.auditLog)) {
         auditLog = data.auditLog;
         try {
           localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
         } catch (e) {
           console.warn("Failed to sync audit log to localStorage:", e);
         }
        }
        forgeTheTopology();
        forgeTheLegend();
        logAuditEvent("import", `Imported JSON: ${file.name} (${Object.keys(data.nodeData).length} nodes, ${data.edgeData.list?.length || 0} connections)`);
        updateViewBox();
      
      if (autoPingEnabled) {
      startAutoPing();
      } else {
      stopAutoPing();
      }
      
         const nodeIds = Object.keys(NODE_DATA);
         if (nodeIds.length > 0) {
          claimTheImmortal(nodeIds[0]);
         } else {
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("topology-toolbar").style.display = "none";
         }
         alert("Data imported successfully!");
         e.target.value = "";
        } catch (err) {
         console.error("Import error:", err);
         alert(`Failed to import data: ${err.message}`);
         e.target.value = "";
        }
       });
       const saveHelpBtn = document.getElementById("save-help-btn");
       const saveInfoModal = document.getElementById("save-info-modal");
       const saveInfoClose = document.getElementById("save-info-close");
       saveHelpBtn.addEventListener("click", () => {
        saveInfoModal.classList.add("active");
       });
       saveInfoClose.addEventListener("click", () => {
        saveInfoModal.classList.remove("active");
       });
       saveInfoModal.addEventListener("click", (e) => {
       if (e.target === saveInfoModal) {
        saveInfoModal.classList.remove("active");
       }
      });
      document.querySelectorAll(".help-tab").forEach(tab => {
        tab.addEventListener("click", () => {
          document.querySelectorAll(".help-tab").forEach(t => { t.style.background = "var(--panel)"; t.style.color = "var(--text-main)"; });
          tab.style.background = "var(--accent)"; tab.style.color = "var(--bg)";
          document.querySelectorAll(".help-tab-content").forEach(c => c.style.display = "none");
          document.getElementById("help-tab-" + tab.dataset.tab).style.display = "block";
        });
      });
      async function deriveKey(password, salt) {
      const encoder = new TextEncoder();
      
      const keyMaterial = await crypto.subtle.importKey(
      "raw",
      encoder.encode(password),
      "PBKDF2",
      false,
      ["deriveKey"]
      );
      
      return crypto.subtle.deriveKey(
      {
      name: "PBKDF2",
      salt: salt,
      iterations: 200000,  
      hash: "SHA-256"
      },
      keyMaterial,
      {
      name: "AES-GCM",
      length: 256
      },
      false,
      ["encrypt", "decrypt"]
      );
      }
      
       async function encryptData(data, password) {
      const encoder = new TextEncoder();
      const salt = crypto.getRandomValues(new Uint8Array(16));
      const iv   = crypto.getRandomValues(new Uint8Array(12));
      
      const key = await deriveKey(password, salt);
      const encrypted = await crypto.subtle.encrypt(
      { name: "AES-GCM", iv },
      key,
      encoder.encode(data)
      );
      
      const encryptedU8 = new Uint8Array(encrypted);
      
      const result = new Uint8Array(salt.length + iv.length + encryptedU8.length);
      result.set(salt, 0);
      result.set(iv, salt.length);
      result.set(encryptedU8, salt.length + iv.length);
      
      return "ENCRYPTED:" + u8ToBase64(result);
      }
      
       async function decryptData(encryptedData, password) {
      const base64Data = encryptedData.replace("ENCRYPTED:", "");
      const fullData   = base64ToU8(base64Data);
      
      const salt      = fullData.slice(0, 16);
      const iv        = fullData.slice(16, 28);
      const encrypted = fullData.slice(28);
      
      const key = await deriveKey(password, salt);
      
      const decrypted = await crypto.subtle.decrypt(
      { name: "AES-GCM", iv },
      key,
      encrypted
      );
      
      const decoder = new TextDecoder();
      return decoder.decode(decrypted);
      }
      
      
       function isEncrypted(data) {
        return typeof data === "string" && data.startsWith("ENCRYPTED:");
       }
      
       function captureTheQuickening() {
      const currentTab = documentTabs[currentTabIndex];
      currentTab.nodes = JSON.parse(JSON.stringify(NODE_DATA));
      currentTab.edges = JSON.parse(JSON.stringify(EDGE_DATA));
      currentTab.positions = JSON.parse(JSON.stringify(savedPositions));
      currentTab.sizes = JSON.parse(JSON.stringify(savedSizes));
      currentTab.styles = JSON.parse(JSON.stringify(savedStyles));
      currentTab.legend = JSON.parse(JSON.stringify(EDGE_LEGEND));
      currentTab.rects = JSON.parse(JSON.stringify(RECT_DATA));
      currentTab.texts = JSON.parse(JSON.stringify(TEXT_DATA));
      currentTab.pageState = JSON.parse(JSON.stringify(PAGE_STATE));
       
      return {
      nodeData: NODE_DATA,
       edgeData: EDGE_DATA,
       rectData: RECT_DATA,
       textData: TEXT_DATA,
       edgeLegend: EDGE_LEGEND,
       nodePositions: savedPositions,
       nodeSizes: savedSizes,
       nodeStyles: savedStyles,
       iconCache: IconLibrary.iconCache,
      
       page: PAGE_STATE,
      
       autoPingEnabled: autoPingEnabled,
       autoPingInterval: autoPingInterval,
      
       canvas: {
         zoom: canvasState.zoom,
         panX: canvasState.panX,
         panY: canvasState.panY,
       },
       
       savedTopologyView: savedTopologyView,
       
       documentTabs: documentTabs,
       currentTabIndex: currentTabIndex,
       encryptedSections: encryptedSections,
	   auditLog: auditLog,
       };
      }
      
       function assembleTheImmortalForm() {
	   const canvasHintEl = document.getElementById("canvas-hint");
       const savedHintHTML = canvasHintEl ? canvasHintEl.innerHTML : "";
       if (canvasHintEl) canvasHintEl.innerHTML = DEFAULT_CANVAS_HINT;
        const clone = document.documentElement.cloneNode(true);
       ["edge-legend-mini", "minimap-mini", "draw-toolbar-mini", "topology-toolbar-mini"].forEach(id => {
        const all = clone.querySelectorAll("#" + id);
        for (let i = 1; i < all.length; i++) {
         all[i].remove();
        }
       });
       const nodeScript = clone.querySelector("#nodes-json");
        if (nodeScript) {
         nodeScript.textContent = JSON.stringify(NODE_DATA, null, 2);
        }
        let stateScript = clone.querySelector("#topology-state");
        if (!stateScript) {
         stateScript = document.createElement("script");
         stateScript.id = "topology-state";
         stateScript.type = "application/json";
         const body = clone.querySelector("body") || clone;
         body.appendChild(stateScript);
        }
        stateScript.textContent = JSON.stringify(captureTheQuickening(), null, 2, );
        return " <!DOCTYPE html> \n " + clone.outerHTML;
       }
       async function becomeImmortal() {
        const encryptEnabled = document.getElementById("encrypt-toggle").checked;
        let stateData = JSON.stringify(captureTheQuickening(), null, 2);
        if (encryptEnabled) {
         const password = prompt("Enter a password to encrypt your data:\n(Remember this password! You will need it to open this file and its non recoverable!)", );
         if (!password) {
          alert("Encryption cancelled. File not saved.");
          return;
         }
         const confirmPassword = prompt("Confirm your password:");
         if (password !== confirmPassword) {
          alert("Passwords do not match. File not saved.");
          return;
         }
         try {
          stateData = await encryptData(stateData, password);
         } catch (e) {
          alert("Encryption failed: " + e.message);
          return;
         }
        }
       const canvasHintEl = document.getElementById("canvas-hint");
       const savedHintHTML = canvasHintEl ? canvasHintEl.innerHTML : "";
       if (canvasHintEl) canvasHintEl.innerHTML = DEFAULT_CANVAS_HINT;
       
       const clone = document.documentElement.cloneNode(true);
       ["edge-legend-mini", "minimap-mini", "draw-toolbar-mini", "topology-toolbar-mini"].forEach(id => {
        const all = clone.querySelectorAll("#" + id);
        for (let i = 1; i < all.length; i++) {
         all[i].remove();
        }
       });  
       const nodeScript = clone.querySelector("#nodes-json");
        if (nodeScript) {
         if (encryptEnabled) {
          nodeScript.textContent = JSON.stringify({}, null, 2);
         } else {
          nodeScript.textContent = JSON.stringify(NODE_DATA, null, 2);
         }
        }
        let stateScript = clone.querySelector("#topology-state");
        if (!stateScript) {
         stateScript = document.createElement("script");
         stateScript.id = "topology-state";
         stateScript.type = "application/json";
         const body = clone.querySelector("body") || clone;
         body.appendChild(stateScript);
        }
        stateScript.textContent = stateData;
        const html = "<!DOCTYPE html> \n " + clone.outerHTML;
        const blob = new Blob([html], {
         type: "text/html"
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        const safeTitle = (PAGE_STATE.title || document.title || "network-topology").toLowerCase().replace(/[^a-z0-9\-]+/g, "-");
        a.download = safeTitle + ".html";
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url); 
		if (canvasHintEl) canvasHintEl.innerHTML = savedHintHTML;
        saveRollbackVersion("Manual save");
		logAuditEvent("save", `File saved: ${safeTitle}.html`);
       }
       
      function captureState() {
      return {
        nodes: JSON.parse(JSON.stringify(NODE_DATA)),
        edges: JSON.parse(JSON.stringify(EDGE_DATA)),
        positions: JSON.parse(JSON.stringify(savedPositions)),
        sizes: JSON.parse(JSON.stringify(savedSizes)),
        styles: JSON.parse(JSON.stringify(savedStyles)),
        legend: JSON.parse(JSON.stringify(EDGE_LEGEND)),
        rects: JSON.parse(JSON.stringify(RECT_DATA)),
        texts: JSON.parse(JSON.stringify(TEXT_DATA))
        };
      }
      
      function pushUndo(action = "") {
       const state = captureState();
       undoStack.push(state);
       if (undoStack.length > MAX_UNDO_STACK) {
        undoStack.shift();
       }
       redoStack = [];
       updateUndoButtons();
       
       if (action) {
        const actionTypeMap = {
          "create node": "node",
          "delete node": "node",
          "add node": "node",
          "edit": "node",
          "clone node": "node",
          "paste node": "node",
          "move nodes": "node",
          "nudge": "node",
          "nudge nodes": "node",
          "align nodes": "node",
          "distribute nodes": "node",
          "snap to grid": "node",
          "toggle group": "node",
          "toggle lock": "node",
          "create rack": "rack",
          "add rack": "rack",
          "edit rack": "rack",
          "edit mac": "rack",
          "edit U height": "rack",
          "change rack capacity": "rack",
          "change assigned rack": "rack",
          "add connection": "connection",
          "delete connection": "connection",
          "delete edge": "connection",
          "clone edge": "connection",
          "paste edge": "connection",
          "style change": "style",
          "change layer": "layer",
          "add text": "text",
          "edit text": "text",
          "delete text": "text",
          "clone text": "text",
          "paste text": "text",
          "draw zone": "zone",
          "delete zone": "zone",
          "delete rect": "zone",
          "clone rect": "zone",
          "paste rect": "zone",
          "change zone line style": "zone",
          "delete selected": "bulk",
          "clone selected": "bulk",
        };
        
        const type = actionTypeMap[action] || "edit";
        logAuditEvent(type, action);
       }
      }
      
      function undo() {
       if (undoStack.length === 0) return;
       const currentState = captureState();
       redoStack.push(currentState);
       const previousState = undoStack.pop();
       restoreState(previousState);
       updateUndoButtons();
       logAuditEvent("undo", "Undo action performed");
      }
      
      function redo() {
       if (redoStack.length === 0) return;
       logAuditEvent("redo", "Redo action performed");
       const currentState = captureState();
       undoStack.push(currentState);
       const nextState = redoStack.pop();
       restoreState(nextState);
       updateUndoButtons();
      }
      
      function restoreState(state) {
      NODE_DATA = state.nodes;
       EDGE_DATA = state.edges;
       savedPositions = state.positions;
       savedSizes = state.sizes;
       savedStyles = state.styles;
       EDGE_LEGEND = state.legend;
       RECT_DATA = state.rects || { list: [] };
       TEXT_DATA = state.texts || { list: [] };
       forgeTheTopology();
       if (currentNodeId && NODE_DATA[currentNodeId]) {
       claimTheImmortal(currentNodeId);
       } else if (currentEdgeId) {
       selectTheConnection(currentEdgeId);
       }
      }
      
      function updateUndoButtons() {
       const undoBtn = document.getElementById("undo-btn");
       const redoBtn = document.getElementById("redo-btn");
       if (undoBtn) {
        undoBtn.disabled = undoStack.length === 0;
        undoBtn.style.opacity = undoStack.length === 0 ? "0.5" : "1";
       }
       if (redoBtn) {
        redoBtn.disabled = redoStack.length === 0;
        redoBtn.style.opacity = redoStack.length === 0 ? "0.5" : "1";
       }
      }
      
      function clearSelection() {
       selectedNodes.clear();
       selectedEdges.clear();
       selectedRects.clear();
       selectedTexts.clear();
       updateAllSelections();
      }
      
      function updateAllSelections() {
      updateNodeSelection();
      clearSearchHighlight();
      document.querySelectorAll(".edge").forEach(el => {
      const edgeId = el.dataset.edgeId;
      if (selectedEdges.has(edgeId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      
      document.querySelectorAll(".rect-group").forEach(el => {
      const rectId = el.dataset.rectId;
      if (selectedRects.has(rectId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      
      document.querySelectorAll(".text-group").forEach(el => {
      const textId = el.dataset.textId;
      if (selectedTexts.has(textId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      
      const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
      const bulkToolbar = document.getElementById("bulk-toolbar");
      const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
      const bulkCount = document.getElementById("bulk-count");
      const bulkCountMobile = document.getElementById("bulk-count-mobile");
      
      if (total > 0) {
      if (bulkToolbar) bulkToolbar.style.display = "flex";
      if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
      if (bulkCount) bulkCount.textContent = total;
      if (bulkCountMobile) bulkCountMobile.textContent = total;
      } else {
      if (bulkToolbar) bulkToolbar.style.display = "none";
      if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
      }
      }
      
      
      function updateNodeSelection() {
       if (isViewOnly()) {
        selectedNodes.clear();
        selectedRects.clear();
        selectedTexts.clear();
        const bulkToolbar = document.getElementById("bulk-toolbar");
        const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        return;
       }
       document.querySelectorAll(".node-group").forEach(node => {
        const nodeId = node.dataset.nodeId;
        if (selectedNodes.has(nodeId)) {
         node.classList.add("selected");
        } else {
         node.classList.remove("selected");
        }
       });
       
       const bulkToolbar = document.getElementById("bulk-toolbar");
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       const bulkCount = document.getElementById("bulk-count");
       const bulkCountMobile = document.getElementById("bulk-count-mobile");
       const bulkCountModal = document.getElementById("bulk-count-modal");
       
       if (selectedNodes.size > 0) {
        if (bulkToolbar) bulkToolbar.style.display = "flex";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
        if (bulkCount) bulkCount.textContent = selectedNodes.size;
        if (bulkCountMobile) bulkCountMobile.textContent = selectedNodes.size;
        if (bulkCountModal) bulkCountModal.textContent = selectedNodes.size;
       } else {
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        const modal = document.getElementById("bulk-actions-modal");
        if (modal) modal.style.display = "none";
       }
      }
      
      function deleteSelected() {
       const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
       if (total === 0) return;
       
       let nodesInsideRacks = [];
       selectedNodes.forEach(nodeId => {
        if (NODE_DATA[nodeId]?.isRack) {
         Object.entries(NODE_DATA).forEach(([id, n]) => {
          if (n.assignedRack === nodeId) nodesInsideRacks.push(n.name || id);
         });
        }
       });
       
       let message = `Delete ${total} selected item(s)?`;
       if (nodesInsideRacks.length > 0) {
        message += `\n\nThis will also delete ${nodesInsideRacks.length} node(s) inside rack(s):\n‚Ä¢ ${nodesInsideRacks.join('\n‚Ä¢ ')}`;
       }
       
       challengeTheImmortal(message, () => {
        pushUndo("delete selected");
        selectedNodes.forEach(nodeId => {
         if (NODE_DATA[nodeId]?.isRack) {
          Object.keys(NODE_DATA).forEach(id => {
           if (NODE_DATA[id]?.assignedRack === nodeId) {
            EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== id && e.to !== id);
            delete NODE_DATA[id];
            delete savedPositions[id];
            delete savedSizes[id];
            delete savedStyles[id];
           }
          });
         }
         delete NODE_DATA[nodeId];
         delete savedPositions[nodeId];
         delete savedSizes[nodeId];
         delete savedStyles[nodeId];
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== nodeId && e.to !== nodeId);
        });
        selectedEdges.forEach(edgeId => {
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.id !== edgeId);
        });
        selectedRects.forEach(rectId => {
         RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== rectId);
        });
        selectedTexts.forEach(textId => {
         TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== textId);
        });
        clearSelection();
       
        forgeTheTopology();
       });
      }
      
      function startSelection(event) {
       const svgEl = document.getElementById("map");
       const pt = svgEl.createSVGPoint();
       pt.x = event.clientX;
       pt.y = event.clientY;
       const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
       
       isSelecting = true;
       selectionStart = { x: svgP.x, y: svgP.y };
       
       if (!selectionRect || !selectionRect.parentNode) {
        selectionRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        selectionRect.setAttribute("fill", selectionBoxStyle.fillColor);
        selectionRect.setAttribute("fill-opacity", selectionBoxStyle.fillOpacity);
        selectionRect.setAttribute("stroke", selectionBoxStyle.strokeColor);
        selectionRect.setAttribute("stroke-width", selectionBoxStyle.strokeWidth);
        selectionRect.setAttribute("stroke-dasharray", selectionBoxStyle.strokeDasharray);
        selectionRect.style.pointerEvents = "none";
        svgEl.appendChild(selectionRect);
       }
       
       if (!event.shiftKey) {
        selectedNodes.clear();
        selectedEdges.clear();
        selectedRects.clear();
        selectedTexts.clear();
       }
       
       preDragSelectedNodes = new Set(selectedNodes);
       preDragSelectedEdges = new Set(selectedEdges);
       preDragSelectedRects = new Set(selectedRects);
       preDragSelectedTexts = new Set(selectedTexts);
      }
      
      function updateSelection(event) {
       if (!isSelecting || !selectionStart) return;
       
       const svgEl = document.getElementById("map");
       const pt = svgEl.createSVGPoint();
       pt.x = event.clientX;
       pt.y = event.clientY;
       const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
       
       const x = Math.min(selectionStart.x, svgP.x);
       const y = Math.min(selectionStart.y, svgP.y);
       const width = Math.abs(svgP.x - selectionStart.x);
       const height = Math.abs(svgP.y - selectionStart.y);
       
       selectionRect.setAttribute("x", x);
       selectionRect.setAttribute("y", y);
       selectionRect.setAttribute("width", width);
       selectionRect.setAttribute("height", height);
       selectionRect.style.display = "block";
       
       const box = { x, y, width, height };
       
       Object.entries(savedPositions).forEach(([nodeId, pos]) => {
        const size = savedSizes[nodeId] || 50;
        const halfSize = size / 2;
        const nodeBox = { x: pos.x - halfSize, y: pos.y - halfSize, width: size, height: size };
        if (boxesIntersect(box, nodeBox)) {
         selectedNodes.add(nodeId);
        } else if (!preDragSelectedNodes.has(nodeId)) {
         selectedNodes.delete(nodeId);
        }
       });
       
       EDGE_DATA.list.forEach(edge => {
        if (!edge.points || edge.points.length === 0) return;
        for (let i = 0; i < edge.points.length - 1; i++) {
         const p1 = edge.points[i];
         const p2 = edge.points[i + 1];
         if (lineIntersectsBox(p1.x, p1.y, p2.x, p2.y, box)) {
          selectedEdges.add(edge.id);
          return;
         }
        }
        if (!preDragSelectedEdges.has(edge.id)) {
         selectedEdges.delete(edge.id);
        }
       });
       
       RECT_DATA.list.forEach(rect => {
        const rectBox = { x: rect.x, y: rect.y, width: rect.width, height: rect.height };
        if (boxesIntersect(box, rectBox)) {
         selectedRects.add(rect.id);
        } else if (!preDragSelectedRects.has(rect.id)) {
         selectedRects.delete(rect.id);
        }
       });
       
       TEXT_DATA.list.forEach(text => {
        const fontSize = text.fontSize || 18;
        const textBox = { x: text.x - 50, y: text.y - fontSize, width: 100, height: fontSize * 1.5 };
        if (boxesIntersect(box, textBox)) {
         selectedTexts.add(text.id);
        } else if (!preDragSelectedTexts.has(text.id)) {
         selectedTexts.delete(text.id);
        }
       });
       
       updateAllSelectionVisuals();
      }
      
      function endSelection() {
       isSelecting = false;
       selectionStart = null;
       if (selectionRect) {
        selectionRect.style.display = "none";
       }
      }
      
      function boxesIntersect(a, b) {
       return !(a.x + a.width < b.x || b.x + b.width < a.x || a.y + a.height < b.y || b.y + b.height < a.y);
      }
      
      function lineIntersectsBox(x1, y1, x2, y2, box) {
       if (pointInBox(x1, y1, box) || pointInBox(x2, y2, box)) return true;
       const lines = [
        [box.x, box.y, box.x + box.width, box.y],
        [box.x + box.width, box.y, box.x + box.width, box.y + box.height],
        [box.x + box.width, box.y + box.height, box.x, box.y + box.height],
        [box.x, box.y + box.height, box.x, box.y]
       ];
       for (const [bx1, by1, bx2, by2] of lines) {
        if (linesIntersect(x1, y1, x2, y2, bx1, by1, bx2, by2)) return true;
       }
       return false;
      }
      
      function pointInBox(x, y, box) {
       return x >= box.x && x <= box.x + box.width && y >= box.y && y <= box.y + box.height;
      }
      
      function linesIntersect(x1, y1, x2, y2, x3, y3, x4, y4) {
       const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
       if (Math.abs(denom) < 0.0001) return false;
       const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom;
       const ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denom;
       return ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1;
      }
      
      function updateAllSelectionVisuals() {
       document.querySelectorAll(".node-group").forEach(node => {
        const nodeId = node.dataset.nodeId;
        if (selectedNodes.has(nodeId)) {
         node.classList.add("selected");
        } else {
         node.classList.remove("selected");
        }
       });
       
       document.querySelectorAll(".edge").forEach(edge => {
        const edgeId = edge.dataset.edgeId;
        if (selectedEdges.has(edgeId)) {
         edge.style.filter = "drop-shadow(0 0 6px #4fd1c5)";
        } else {
         edge.style.filter = "";
        }
       });
       
       document.querySelectorAll(".rect-group rect").forEach(el => {
        const rectId = el.closest(".rect-group")?.dataset?.rectId;
        if (selectedRects.has(rectId)) {
         el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
        } else {
         el.style.filter = "";
        }
       });
       
       document.querySelectorAll(".text-group, .text-element").forEach(el => {
        const textId = el.dataset?.textId;
        if (selectedTexts.has(textId)) {
         el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
        } else {
         el.style.filter = "";
        }
       });
       
       const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
       const bulkToolbar = document.getElementById("bulk-toolbar");
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       const bulkCount = document.getElementById("bulk-count");
       const bulkCountMobile = document.getElementById("bulk-count-mobile");
       
       if (total > 0) {
        if (bulkToolbar) bulkToolbar.style.display = "flex";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
        if (bulkCount) bulkCount.textContent = total;
        if (bulkCountMobile) bulkCountMobile.textContent = total;
       } else {
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
       }
      }
      
      function cloneNode(sourceId) {
       const source = NODE_DATA[sourceId];
       if (!source) return;
       
       pushUndo("clone node");
       
       let baseName = source.name;
       let copyNum = 0;
       let newName = baseName + " copy";
       while (Object.values(NODE_DATA).some(n => n.name === newName)) {
        copyNum++;
        newName = baseName + " copy " + copyNum;
       }
       
       const newId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
       
       NODE_DATA[newId] = {
        shape: source.shape,
        name: newName,
        ip: source.ip,
        role: source.role,
        tags: [...source.tags],
        notes: [...source.notes],
        mac: source.mac || "",
        rackUnit: source.rackUnit || "",
        uHeight: source.uHeight || "1",
        ping: source.ping ? JSON.parse(JSON.stringify(source.ping)) : {
         enabled: false,
         protocol: 'http',
         customUrl: '',
         timeout: 3000,
         status: 'unknown',
         lastCheck: null
        },
        layer: source.layer || "physical",
        assignedRack: source.assignedRack || "",
        rackCapacity: source.rackCapacity || "42",
        isRack: source.isRack || false
       };
      
       if (source.isRack) {
        const childNodes = Object.entries(NODE_DATA).filter(([id, n]) => 
         id !== newId && n.assignedRack === sourceId
        );
        childNodes.forEach(([childId, childNode]) => {
         let childBaseName = childNode.name;
         let c = 0;
         let childNewName = childBaseName + " copy";
         while (Object.values(NODE_DATA).some(n => n.name === childNewName)) {
          c++;
          childNewName = childBaseName + " copy " + c;
         }
         const childNewId = childNewName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
         NODE_DATA[childNewId] = {
          ...JSON.parse(JSON.stringify(childNode)),
          name: childNewName,
          assignedRack: newId
         };
         if (savedPositions[childId]) {
          savedPositions[childNewId] = { ...savedPositions[childId] };
         }
         if (savedSizes[childId]) {
          savedSizes[childNewId] = savedSizes[childId];
         }
         if (savedStyles[childId]) {
          savedStyles[childNewId] = JSON.parse(JSON.stringify(savedStyles[childId]));
         }
        });
       }
       
       if (savedSizes[sourceId]) {
        savedSizes[newId] = savedSizes[sourceId];
       }
       
       if (savedStyles[sourceId]) {
        savedStyles[newId] = JSON.parse(JSON.stringify(savedStyles[sourceId]));
       }
       
      if (currentView.mode === "rack" && currentView.rackId) {
        NODE_DATA[newId].assignedRack = currentView.rackId;
       }
       
       const sourcePos = savedPositions[sourceId];
       savedPositions[newId] = {
        x: sourcePos.x + 100,
        y: sourcePos.y + 100
       };
       
       forgeTheTopology();
       claimTheImmortal(newId);
      }
      
      function alignSelectedNodes(direction) {
       if (selectedNodes.size < 2) return;
       
       pushUndo("align nodes");
       
       const nodeIds = Array.from(selectedNodes);
       const positions = nodeIds.map(id => ({ id, pos: savedPositions[id] }));
       
       switch(direction) {
        case "left":
         const minX = Math.min(...positions.map(p => p.pos.x));
         positions.forEach(p => savedPositions[p.id].x = minX);
         break;
        case "right":
         const maxX = Math.max(...positions.map(p => p.pos.x));
         positions.forEach(p => savedPositions[p.id].x = maxX);
         break;
        case "top":
         const minY = Math.min(...positions.map(p => p.pos.y));
         positions.forEach(p => savedPositions[p.id].y = minY);
         break;
        case "bottom":
         const maxY = Math.max(...positions.map(p => p.pos.y));
         positions.forEach(p => savedPositions[p.id].y = maxY);
         break;
        case "center-h":
         const avgX = positions.reduce((sum, p) => sum + p.pos.x, 0) / positions.length;
         positions.forEach(p => savedPositions[p.id].x = avgX);
         break;
        case "center-v":
         const avgY = positions.reduce((sum, p) => sum + p.pos.y, 0) / positions.length;
         positions.forEach(p => savedPositions[p.id].y = avgY);
         break;
       }
       
       forgeTheTopology();
      }
      
      function distributeSelectedNodes(direction) {
       if (selectedNodes.size < 3) return;
       
       pushUndo("distribute nodes");
       
       const nodeIds = Array.from(selectedNodes);
       const positions = nodeIds.map(id => ({ id, pos: savedPositions[id] }));
       
       if (direction === "horizontal") {
        positions.sort((a, b) => a.pos.x - b.pos.x);
        const minX = positions[0].pos.x;
        const maxX = positions[positions.length - 1].pos.x;
        const gap = (maxX - minX) / (positions.length - 1);
        positions.forEach((p, i) => {
         savedPositions[p.id].x = minX + (gap * i);
        });
       } else if (direction === "vertical") {
        positions.sort((a, b) => a.pos.y - b.pos.y);
        const minY = positions[0].pos.y;
        const maxY = positions[positions.length - 1].pos.y;
        const gap = (maxY - minY) / (positions.length - 1);
        positions.forEach((p, i) => {
         savedPositions[p.id].y = minY + (gap * i);
        });
       }
       
       forgeTheTopology();
      }
      
      function snapToGrid(nodeId, gridSize = 50) {
       if (!savedPositions[nodeId]) return;
       
       pushUndo("snap to grid");
       
       const pos = savedPositions[nodeId];
       pos.x = Math.round(pos.x / gridSize) * gridSize;
       pos.y = Math.round(pos.y / gridSize) * gridSize;
       
       forgeTheTopology();
      }
      
      function nudgeSelectedNodes(direction, distance) {
        const nodesToNudge = selectedNodes.size > 0 
          ? Array.from(selectedNodes) 
          : (currentNodeId ? [currentNodeId] : []);
        
        if (nodesToNudge.length === 0) return;
        
        const unlockedNodes = nodesToNudge.filter(id => !NODE_DATA[id]?.locked);
        
        if (unlockedNodes.length === 0) {
          return;
        }
        
        pushUndo("nudge nodes");
        
        unlockedNodes.forEach(id => {
          if (!savedPositions[id]) {
            savedPositions[id] = { x: 0, y: 0 };
          }
          
          switch(direction) {
            case "ArrowUp":
              savedPositions[id].y -= distance;
              break;
            case "ArrowDown":
              savedPositions[id].y += distance;
              break;
            case "ArrowLeft":
              savedPositions[id].x -= distance;
              break;
            case "ArrowRight":
              savedPositions[id].x += distance;
              break;
          }
        });
        
        forgeTheTopology();
      }
      
      function cycleNodes(reverse = false) {
        const nodeIds = Object.keys(NODE_DATA).filter(id => {
          if (currentView.mode === "rack") {
           const node = NODE_DATA[id];
           return node && node.assignedRack === currentView.rackId;
          }
          return isNodeVisible(id);
         });
        
        if (nodeIds.length === 0) return;
        
        let currentIndex = nodeIds.indexOf(currentNodeId);
        
        if (reverse) {
          currentIndex = currentIndex <= 0 ? nodeIds.length - 1 : currentIndex - 1;
        } else {
          currentIndex = currentIndex >= nodeIds.length - 1 ? 0 : currentIndex + 1;
        }
        
        const nextNodeId = nodeIds[currentIndex];
        claimTheImmortal(nextNodeId);
        
        selectedNodes.clear();
        updateNodeSelection();
      }
      
      function focusOnSelected() {
        let minX = Infinity, minY = Infinity;
        let maxX = -Infinity, maxY = -Infinity;
        let hasItems = false;
        
        const nodesToFocus = selectedNodes.size > 0 
          ? Array.from(selectedNodes) 
          : (currentNodeId ? [currentNodeId] : []);
        nodesToFocus.forEach(id => {
          const pos = savedPositions[id];
          if (pos) {
            hasItems = true;
            const size = savedSizes[id] || 50;
            minX = Math.min(minX, pos.x - size/2);
            minY = Math.min(minY, pos.y - size/2);
            maxX = Math.max(maxX, pos.x + size/2);
            maxY = Math.max(maxY, pos.y + size/2);
          }
        });
        
        const rectsToFocus = selectedRects.size > 0 ? Array.from(selectedRects) : (currentRectId ? [currentRectId] : []);
        rectsToFocus.forEach(id => {
          const r = RECT_DATA.list.find(x => x.id === id);
          if (r) {
            hasItems = true;
            minX = Math.min(minX, r.x);
            minY = Math.min(minY, r.y);
            maxX = Math.max(maxX, r.x + r.width);
            maxY = Math.max(maxY, r.y + r.height);
          }
        });
        
        const textsToFocus = selectedTexts.size > 0 ? Array.from(selectedTexts) : (currentTextId ? [currentTextId] : []);
        textsToFocus.forEach(id => {
          const t = TEXT_DATA.list.find(x => x.id === id);
          if (t) {
            hasItems = true;
            minX = Math.min(minX, t.x - 50);
            minY = Math.min(minY, t.y - 20);
            maxX = Math.max(maxX, t.x + 50);
            maxY = Math.max(maxY, t.y + 20);
          }
        });
        
        const edgesToFocus = selectedEdges.size > 0 ? Array.from(selectedEdges) : (currentEdgeId ? [currentEdgeId] : []);
        edgesToFocus.forEach(id => {
          const e = EDGE_DATA.list.find(x => x.id === id);
          if (e) {
            const fromPos = savedPositions[e.from];
            const toPos = savedPositions[e.to];
            if (fromPos && toPos) {
              hasItems = true;
              minX = Math.min(minX, fromPos.x, toPos.x);
              minY = Math.min(minY, fromPos.y, toPos.y);
              maxX = Math.max(maxX, fromPos.x, toPos.x);
              maxY = Math.max(maxY, fromPos.y, toPos.y);
            }
          }
        });
        
        if (!hasItems || !isFinite(minX)) return;
        
        const padding = 100;
        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;
        const width = maxX - minX + padding * 2;
        const height = maxY - minY + padding * 2;
        
        const zoomX = CANVAS_WIDTH / width;
        const zoomY = CANVAS_HEIGHT / height;
        const targetZoom = Math.min(zoomX, zoomY, 2); 
        
        canvasState.zoom = targetZoom;
        canvasState.panX = centerX - (CANVAS_WIDTH / targetZoom) / 2;
        canvasState.panY = centerY - (CANVAS_HEIGHT / targetZoom) / 2;
        
        forgeTheTopology();
      }
      
      function toggleLockSelected() {
        const nodesToToggle = selectedNodes.size > 0 
          ? Array.from(selectedNodes) 
          : (currentNodeId ? [currentNodeId] : []);
        const rectsToToggle = selectedRects.size > 0 
          ? Array.from(selectedRects) 
          : (currentRectId ? [currentRectId] : []);
        const textsToToggle = selectedTexts.size > 0 
          ? Array.from(selectedTexts) 
          : (currentTextId ? [currentTextId] : []);
        
        if (nodesToToggle.length === 0 && rectsToToggle.length === 0 && textsToToggle.length === 0) return;
        
        pushUndo("toggle lock");
        
        let hasUnlocked = nodesToToggle.some(id => !NODE_DATA[id]?.locked);
        hasUnlocked = hasUnlocked || rectsToToggle.some(id => { const r = RECT_DATA.list.find(x => x.id === id); return r && !r.locked; });
        hasUnlocked = hasUnlocked || textsToToggle.some(id => { const t = TEXT_DATA.list.find(x => x.id === id); return t && !t.locked; });
        
        nodesToToggle.forEach(id => {
          if (NODE_DATA[id]) NODE_DATA[id].locked = hasUnlocked;
        });
        rectsToToggle.forEach(id => {
          const r = RECT_DATA.list.find(x => x.id === id);
          if (r) r.locked = hasUnlocked;
        });
        textsToToggle.forEach(id => {
          const t = TEXT_DATA.list.find(x => x.id === id);
          if (t) t.locked = hasUnlocked;
        });
        
        forgeTheTopology();
      }
      
      function toggleGroupSelected() {
      const nodesToGroup = Array.from(selectedNodes);
      const rectsToGroup = Array.from(selectedRects);
      const textsToGroup = Array.from(selectedTexts);
      const edgesToGroup = Array.from(selectedEdges);
      const totalItems = nodesToGroup.length + rectsToGroup.length + textsToGroup.length + edgesToGroup.length;
      if (totalItems < 2) return;
      
      pushUndo("toggle group");
      
      const allGroupIds = [];
      nodesToGroup.forEach(id => { if (NODE_DATA[id]?.groupId) allGroupIds.push(NODE_DATA[id].groupId); });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r?.groupId) allGroupIds.push(r.groupId); });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t?.groupId) allGroupIds.push(t.groupId); });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e?.groupId) allGroupIds.push(e.groupId); });
      const uniqueGroups = [...new Set(allGroupIds)];
      
      if (uniqueGroups.length === 1 && allGroupIds.length === totalItems) {
      nodesToGroup.forEach(id => { if (NODE_DATA[id]) NODE_DATA[id].groupId = null; });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r) r.groupId = null; });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t) t.groupId = null; });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e) e.groupId = null; });
      } else {
      const newGroupId = "group-" + Date.now();
      nodesToGroup.forEach(id => { if (NODE_DATA[id]) NODE_DATA[id].groupId = newGroupId; });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r) r.groupId = newGroupId; });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t) t.groupId = newGroupId; });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e) e.groupId = newGroupId; });
      }
      
      forgeTheTopology();
      }
      
      function handleKeyDown(event) {
       if (event.target.tagName === "INPUT" || event.target.tagName === "TEXTAREA" || event.target.isContentEditable) {
        return;
       }
      
       if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(event.key)) {
        event.preventDefault();
        const distance = event.shiftKey ? 10 : 1;
        nudgeSelectedNodes(event.key, distance);
       }
       
       if (event.key === "Tab") {
        event.preventDefault();
        cycleNodes(event.shiftKey);
       }
       
       if (event.key === "f" || event.key === "F") {
        event.preventDefault();
        focusOnSelected();
       }
       
       if (event.key === "l" || event.key === "L") {
        event.preventDefault();
        toggleLockSelected();
       }
       
       if (event.key === "g" || event.key === "G") {
        event.preventDefault();
        toggleGroupSelected();
       }
       
       if (event.ctrlKey && event.key === "z" && !event.shiftKey) {
        event.preventDefault();
        undo();
       }
       
       if ((event.ctrlKey && event.key === "y") || (event.ctrlKey && event.shiftKey && event.key === "z")) {
        event.preventDefault();
        redo();
       }
       
       if (event.ctrlKey && event.key === "c") {
        event.preventDefault();
        clipboard = null;
        if (currentNodeId && NODE_DATA[currentNodeId]) {
         clipboard = {
          type: "node",
          data: JSON.parse(JSON.stringify(NODE_DATA[currentNodeId])),
          size: savedSizes[currentNodeId],
          style: savedStyles[currentNodeId] ? JSON.parse(JSON.stringify(savedStyles[currentNodeId])) : null
         };
        } else if (currentEdgeId) {
         const edge = EDGE_DATA.list.find(e => e.id === currentEdgeId);
         if (edge) clipboard = { type: "edge", data: JSON.parse(JSON.stringify(edge)) };
        } else if (currentRectId) {
         const rect = RECT_DATA.list.find(r => r.id === currentRectId);
         if (rect) clipboard = { type: "rect", data: JSON.parse(JSON.stringify(rect)) };
        } else if (currentTextId) {
         const text = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (text) clipboard = { type: "text", data: JSON.parse(JSON.stringify(text)) };
        }
       }
       
       if (event.ctrlKey && event.key === "v") {
        event.preventDefault();
        if (!clipboard) return;
        const svgEl = document.getElementById("map");
        const rect = svgEl.getBoundingClientRect();
        const pt = svgEl.createSVGPoint();
        pt.x = rect.left + rect.width / 2;
        pt.y = rect.top + rect.height / 2;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const centerX = svgP.x;
        const centerY = svgP.y;
        
        if (clipboard.type === "node") {
         let newName = clipboard.data.name + " copy";
         let counter = 1;
         while (Object.values(NODE_DATA).some(n => n.name === newName)) {
          newName = clipboard.data.name + " copy " + counter;
          counter++;
         }
         let newId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
         counter = 1;
         while (NODE_DATA[newId]) {
          newId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-") + "-" + counter;
          counter++;
         }
         pushUndo("paste node");
         NODE_DATA[newId] = { ...JSON.parse(JSON.stringify(clipboard.data)), name: newName };
         savedPositions[newId] = { x: centerX, y: centerY };
         if (clipboard.size) savedSizes[newId] = clipboard.size;
         if (clipboard.style) savedStyles[newId] = JSON.parse(JSON.stringify(clipboard.style));
         forgeTheTopology();
         claimTheImmortal(newId);
        } else if (clipboard.type === "edge") {
         pushUndo("paste edge");
         const newEdge = { ...clipboard.data, id: "edge-" + Date.now() };
         EDGE_DATA.list.push(newEdge);
        
         forgeTheTopology();
         selectTheConnection(newEdge.id);
        } else if (clipboard.type === "rect") {
         pushUndo("paste rect");
         const newRect = { ...clipboard.data, id: "rect-" + Date.now(), x: centerX - (clipboard.data.width || 100) / 2, y: centerY - (clipboard.data.height || 100) / 2 };
         RECT_DATA.list.push(newRect);
         forgeTheTopology();
         selectTheRect(newRect.id);
        } else if (clipboard.type === "text") {
         pushUndo("paste text");
         const newText = { ...clipboard.data, id: "text-" + Date.now(), x: centerX, y: centerY };
         TEXT_DATA.list.push(newText);
         forgeTheTopology();
         showTextPanel(newText.id);
        }
       }
       
       if (event.ctrlKey && event.key === "d") {
        event.preventDefault();
        if (currentNodeId && NODE_DATA[currentNodeId]) {
         cloneNode(currentNodeId);
        } else if (currentEdgeId) {
         const edge = EDGE_DATA.list.find(e => e.id === currentEdgeId);
         if (edge) {
          pushUndo("clone edge");
          const newEdge = { ...JSON.parse(JSON.stringify(edge)), id: "edge-" + Date.now() };
          EDGE_DATA.list.push(newEdge);
         
          forgeTheTopology();
          selectTheConnection(newEdge.id);
         }
        } else if (currentRectId) {
         const rect = RECT_DATA.list.find(r => r.id === currentRectId);
         if (rect) {
          pushUndo("clone rect");
          const newRect = { ...JSON.parse(JSON.stringify(rect)), id: "rect-" + Date.now(), x: rect.x + 50, y: rect.y + 50 };
          RECT_DATA.list.push(newRect);
          forgeTheTopology();
          selectTheRect(newRect.id);
         }
        } else if (currentTextId) {
         const text = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (text) {
          pushUndo("clone text");
          const newText = { ...JSON.parse(JSON.stringify(text)), id: "text-" + Date.now(), x: text.x + 50, y: text.y + 50 };
          TEXT_DATA.list.push(newText);
          forgeTheTopology();
          showTextPanel(newText.id);
         }
        }
       }
       
       if (event.key === "Delete") {
        event.preventDefault();
        const totalSelected = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
        if (totalSelected > 0) {
         deleteSelected();
        } else if (currentNodeId && NODE_DATA[currentNodeId]) {
         challengeTheImmortal(`Delete node "${NODE_DATA[currentNodeId].name}"?`, () => {
          pushUndo("delete node");
          delete NODE_DATA[currentNodeId];
          delete savedPositions[currentNodeId];
          delete savedSizes[currentNodeId];
          delete savedStyles[currentNodeId];
          EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== currentNodeId && e.to !== currentNodeId);
          currentNodeId = null;
         
          forgeTheTopology();
          document.getElementById("node-panel").style.display = "none";
         });
        } else if (currentEdgeId) {
         challengeTheImmortal("Delete this line?", () => {
          pushUndo("delete edge");
          EDGE_DATA.list = EDGE_DATA.list.filter(e => e.id !== currentEdgeId);
          currentEdgeId = null;
         
          forgeTheTopology();
          document.getElementById("edge-panel").style.display = "none";
         });
        } else if (currentRectId) {
         challengeTheImmortal("Delete this zone?", () => {
          pushUndo("delete rect");
          RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== currentRectId);
          currentRectId = null;
          forgeTheTopology();
          document.getElementById("rect-panel").style.display = "none";
         });
        } else if (currentTextId) {
         const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (textItem) {
          challengeTheImmortal(`Delete text "${textItem.content.substring(0, 30)}..."?`, () => {
           pushUndo("delete text");
           TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== currentTextId);
           currentTextId = null;
           forgeTheTopology();
           document.getElementById("text-panel").style.display = "none";
          });
         }
        }
       }
       
       if (event.ctrlKey && event.key === "a") {
        event.preventDefault();
        Object.keys(NODE_DATA).forEach(id => selectedNodes.add(id));
        EDGE_DATA.list.forEach(e => selectedEdges.add(e.id));
        RECT_DATA.list.forEach(r => selectedRects.add(r.id));
        TEXT_DATA.list.forEach(t => selectedTexts.add(t.id));
        updateNodeSelection();
       }
       
       if (event.key === "Escape") {
        clearSelection();
       }
      }
      
      function searchNodes(query) {
       clearSearchHighlight();
       
       if (!query || query.trim() === "") return;
       
       const lowerQuery = query.toLowerCase();
       const matchingIds = [];
       
       Object.entries(NODE_DATA).forEach(([id, node]) => {
        const searchableText = [
         node.name,
         node.ip,
         node.role,
         ...(node.tags || []),
         node.mac || "",
         node.rackUnit || ""
        ].join(" ").toLowerCase();
        
        if (searchableText.includes(lowerQuery)) {
         matchingIds.push(id);
        }
       });
       
       highlightSearchResults(matchingIds);
      }
      
      function highlightSearchResults(nodeIds) {
       clearSearchHighlight();
       nodeIds.forEach(id => {
        const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`);
        if (nodeGroup) {
         nodeGroup.classList.add("search-highlight");
        }
       });
      }
      
      function clearSearchHighlight() {
       document.querySelectorAll(".node-group").forEach(node => {
        node.classList.remove("search-highlight");
       });
      }
      
      function editNodeMac(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       
       document.getElementById("modal-title").textContent = "Edit MAC Address";
       document.getElementById("modal-input").value = node.mac || "";
       document.getElementById("edit-modal").style.display = "flex";
       document.getElementById("modal-input").focus();
       
       const saveHandler = () => {
        pushUndo("edit mac");
        const value = document.getElementById("modal-input").value.trim();
        node.mac = value;
        document.getElementById("edit-modal").style.display = "none";
        claimTheImmortal(id);
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       
       const cancelHandler = () => {
        document.getElementById("edit-modal").style.display = "none";
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       
       document.getElementById("edit-modal").addEventListener("click", function bgHandler(e) {
        if (e.target === document.getElementById("edit-modal")) {
         cancelHandler();
         document.getElementById("edit-modal").removeEventListener("click", bgHandler);
        }
       });
      }
      
      function editNodeRack(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       
       document.getElementById("modal-title").textContent = "Edit Rack Unit";
       document.getElementById("modal-input").value = node.rackUnit || "";
       document.getElementById("edit-modal").style.display = "flex";
       document.getElementById("modal-input").focus();
       
       const saveHandler = () => {
        pushUndo("edit rack");
        const value = document.getElementById("modal-input").value.trim();
        node.rackUnit = value;
        document.getElementById("edit-modal").style.display = "none";
        claimTheImmortal(id);
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       
       const cancelHandler = () => {
        document.getElementById("edit-modal").style.display = "none";
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       
       document.getElementById("edit-modal").addEventListener("click", function bgHandler(e) {
        if (e.target === document.getElementById("edit-modal")) {
         cancelHandler();
         document.getElementById("edit-modal").removeEventListener("click", bgHandler);
        }
       });
      }
      
      function editNodeUHeight(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       
       document.getElementById("modal-title").textContent = "Edit U Height";
       document.getElementById("modal-input").value = node.uHeight || "1";
       document.getElementById("edit-modal").style.display = "flex";
       document.getElementById("modal-input").focus();
       
       const saveHandler = () => {
        pushUndo("edit U height");
        const value = document.getElementById("modal-input").value.trim();
        node.uHeight = value;
        document.getElementById("edit-modal").style.display = "none";
        claimTheImmortal(id);
        forgeTheTopology();
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       
       const cancelHandler = () => {
        document.getElementById("edit-modal").style.display = "none";
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       
       document.getElementById("edit-modal").addEventListener("click", function bgHandler(e) {
        if (e.target === document.getElementById("edit-modal")) {
         cancelHandler();
         document.getElementById("edit-modal").removeEventListener("click", bgHandler);
        }
       });
      }
      
      function updateEdgePortLabels(edgeId) {
       const edge = EDGE_DATA.list.find(e => e.id === edgeId);
       if (!edge) return;
       
       const fromPortInput = document.getElementById("edge-from-port");
       const toPortInput = document.getElementById("edge-to-port");
       
       edge.fromPort = fromPortInput ? fromPortInput.value.trim() : "";
       edge.toPort = toPortInput ? toPortInput.value.trim() : "";
       
      
       forgeTheTopology();
      }
      
      document.addEventListener("keydown", handleKeyDown);
      
      const undoBtn = document.getElementById("undo-btn");
      const redoBtn = document.getElementById("redo-btn");
      if (undoBtn) undoBtn.addEventListener("click", undo);
      if (redoBtn) redoBtn.addEventListener("click", redo);
      
      const backToTopologyBtn = document.getElementById("back-to-topology-btn");
      if (backToTopologyBtn) {
       backToTopologyBtn.addEventListener("click", exitRack);
      }
      
      const bulkToolbarClose = document.getElementById("bulk-toolbar-close");
      if (bulkToolbarClose) {
       bulkToolbarClose.addEventListener("click", clearSelection);
      }
      
      const bulkAlignLeft = document.getElementById("bulk-align-left");
      if (bulkAlignLeft) {
       bulkAlignLeft.addEventListener("click", () => alignSelectedNodes("left"));
      }
      
      const bulkAlignRight = document.getElementById("bulk-align-right");
      if (bulkAlignRight) {
       bulkAlignRight.addEventListener("click", () => alignSelectedNodes("right"));
      }
      
      const bulkAlignTop = document.getElementById("bulk-align-top");
      if (bulkAlignTop) {
       bulkAlignTop.addEventListener("click", () => alignSelectedNodes("top"));
      }
      
      const bulkAlignBottom = document.getElementById("bulk-align-bottom");
      if (bulkAlignBottom) {
       bulkAlignBottom.addEventListener("click", () => alignSelectedNodes("bottom"));
      }
      
      const bulkDistributeH = document.getElementById("bulk-distribute-h");
      if (bulkDistributeH) {
       bulkDistributeH.addEventListener("click", () => distributeSelectedNodes("horizontal"));
      }
      
      const bulkDistributeV = document.getElementById("bulk-distribute-v");
      if (bulkDistributeV) {
       bulkDistributeV.addEventListener("click", () => distributeSelectedNodes("vertical"));
      }
      
      const bulkClone = document.getElementById("bulk-clone");
      if (bulkClone) {
       bulkClone.addEventListener("click", () => {
        if (selectedNodes.size === 0) return;
        pushUndo("clone selected");
        const nodesToClone = Array.from(selectedNodes);
        selectedNodes.clear();
        nodesToClone.forEach(id => {
         cloneNode(id);
         selectedNodes.add(currentNodeId);
        });
        updateNodeSelection();
       });
      }
      
      const bulkDelete = document.getElementById("bulk-delete");
      if (bulkDelete) {
       bulkDelete.addEventListener("click", deleteSelected);
      }
      
      const bulkMobileBtn = document.getElementById("bulk-mobile-btn");
      const bulkActionsModal = document.getElementById("bulk-actions-modal");
      const bulkModalClose = document.getElementById("bulk-modal-close");
      
      if (bulkMobileBtn) {
       bulkMobileBtn.addEventListener("click", () => {
        if (bulkActionsModal) bulkActionsModal.style.display = "block";
       });
      }
      
      if (bulkModalClose) {
       bulkModalClose.addEventListener("click", () => {
        if (bulkActionsModal) bulkActionsModal.style.display = "none";
       });
      }
      
      const closeModalAfterAction = () => {
       if (bulkActionsModal) bulkActionsModal.style.display = "none";
      };
      
      const bulkAlignLeftMobile = document.getElementById("bulk-align-left-mobile");
      if (bulkAlignLeftMobile) {
       bulkAlignLeftMobile.addEventListener("click", () => {
        alignSelectedNodes("left");
        closeModalAfterAction();
       });
      }
      
      const bulkAlignRightMobile = document.getElementById("bulk-align-right-mobile");
      if (bulkAlignRightMobile) {
       bulkAlignRightMobile.addEventListener("click", () => {
        alignSelectedNodes("right");
        closeModalAfterAction();
       });
      }
      
      const bulkAlignTopMobile = document.getElementById("bulk-align-top-mobile");
      if (bulkAlignTopMobile) {
       bulkAlignTopMobile.addEventListener("click", () => {
        alignSelectedNodes("top");
        closeModalAfterAction();
       });
      }
      
      const bulkAlignBottomMobile = document.getElementById("bulk-align-bottom-mobile");
      if (bulkAlignBottomMobile) {
       bulkAlignBottomMobile.addEventListener("click", () => {
        alignSelectedNodes("bottom");
        closeModalAfterAction();
       });
      }
      
      const bulkDistributeHMobile = document.getElementById("bulk-distribute-h-mobile");
      if (bulkDistributeHMobile) {
       bulkDistributeHMobile.addEventListener("click", () => {
        distributeSelectedNodes("horizontal");
        closeModalAfterAction();
       });
      }
      
      const bulkDistributeVMobile = document.getElementById("bulk-distribute-v-mobile");
      if (bulkDistributeVMobile) {
       bulkDistributeVMobile.addEventListener("click", () => {
        distributeSelectedNodes("vertical");
        closeModalAfterAction();
       });
      }
      
      const bulkCloneMobile = document.getElementById("bulk-clone-mobile");
      if (bulkCloneMobile) {
       bulkCloneMobile.addEventListener("click", () => {
        if (selectedNodes.size === 0) return;
        pushUndo("clone selected");
        const nodesToClone = Array.from(selectedNodes);
        selectedNodes.clear();
        nodesToClone.forEach(id => {
         cloneNode(id);
         selectedNodes.add(currentNodeId);
        });
        updateNodeSelection();
        closeModalAfterAction();
       });
      }
      
      const bulkDeleteMobile = document.getElementById("bulk-delete-mobile");
      if (bulkDeleteMobile) {
       bulkDeleteMobile.addEventListener("click", () => {
        deleteSelected();
        closeModalAfterAction();
       });
      }
      
      const bulkLockMobile = document.getElementById("bulk-lock-mobile");
      if (bulkLockMobile) {
       bulkLockMobile.addEventListener("click", () => {
        toggleLockSelected();
        closeModalAfterAction();
       });
      }
      
      const bulkGroupMobile = document.getElementById("bulk-group-mobile");
      if (bulkGroupMobile) {
       bulkGroupMobile.addEventListener("click", () => {
        toggleGroupSelected();
        closeModalAfterAction();
       });
      }
      
      const bulkClearMobile = document.getElementById("bulk-clear-mobile");
      if (bulkClearMobile) {
       bulkClearMobile.addEventListener("click", () => {
        clearSelection();
        closeModalAfterAction();
       });
      }
      
      const searchInput = document.getElementById("search-input");
      if (searchInput) {
       searchInput.addEventListener("input", (e) => {
        searchNodes(e.target.value);
       });
      }
      
       document.getElementById("save-file-btn").addEventListener("click", becomeImmortal);
       document.getElementById("check-all-ping-btn").addEventListener("click", checkAllNodesStatus);
       const addNodeBtn = document.getElementById("add-node-btn");
       const addNodeModal = document.getElementById("add-node-modal");
       const addNodeCancel = document.getElementById("add-node-cancel");
       const addNodeSave = document.getElementById("add-node-save");
       addNodeBtn.addEventListener("click", () => {
	    if (isViewOnly()) return;
        document.getElementById("new-node-name").value = "";
        document.getElementById("new-node-ip").value = "";
        document.getElementById("new-node-tags").value = "";
        document.getElementById("new-node-shape").value = "circle";
        document.getElementById("new-node-pingable").checked = false;
        document.getElementById("new-node-ping-protocol").value = "http";
        document.getElementById("new-node-custom-url").value = "";
        document.getElementById("new-node-ping-timeout").value = "3000";
        document.getElementById("new-node-ping-options").style.display = "none";
        document.getElementById("new-node-custom-url-container").style.display = "none";
        newNodeIconTags = [];
        document.getElementById("new-node-icon-tags").style.display = "none";
        document.getElementById("new-node-icon-tags-list").innerHTML = "";
        addNodeModal.classList.add("active");
        document.getElementById("new-node-name").focus();
       });
       
       const canvasViewport = document.getElementById("canvas-viewport");
       if (canvasViewport) {
        canvasViewport.addEventListener("dblclick", (e) => {
         if (currentView.mode === "rack" && e.target.id === "map") {
          exitRack();
         }
        });
       }
       
       const layersBtn = document.getElementById("layers-btn");
       const layerModal = document.getElementById("layer-modal");
       const layerModalClose = document.getElementById("layer-modal-close");
       if (layersBtn && layerModal) {
        layersBtn.addEventListener("click", () => {
         layerModal.classList.add("active");
        });
       }
       if (layerModalClose && layerModal) {
        layerModalClose.addEventListener("click", () => {
         layerModal.classList.remove("active");
        });
       }
       if (layerModal) {
        layerModal.addEventListener("click", (e) => {
         if (e.target === layerModal) {
          layerModal.classList.remove("active");
         }
        });
       }
      
       const tabsBtn = document.getElementById("tabs-btn");
       const tabsModal = document.getElementById("tabs-modal");
       const tabsModalClose = document.getElementById("tabs-modal-close");
       if (tabsBtn && tabsModal) {
         tabsBtn.addEventListener("click", () => {
           displayTabs();
           tabsModal.classList.add("active");
         });
       }
       if (tabsModalClose && tabsModal) {
         tabsModalClose.addEventListener("click", () => {
           tabsModal.classList.remove("active");
         });
       }
       if (tabsModal) {
         tabsModal.addEventListener("click", (e) => {
           if (e.target === tabsModal) {
             tabsModal.classList.remove("active");
           }
         });
       }
       
       const rollbackBtn = document.getElementById("rollback-btn");
       const rollbackModal = document.getElementById("rollback-modal");
       const rollbackModalClose = document.getElementById("rollback-modal-close");
       if (rollbackBtn && rollbackModal) {
         rollbackBtn.addEventListener("click", () => {
           loadRollbackVersions();
           rollbackModal.classList.add("active");
         });
       }
       if (rollbackModalClose && rollbackModal) {
         rollbackModalClose.addEventListener("click", () => {
           rollbackModal.classList.remove("active");
         });
       }
       if (rollbackModal) {
         rollbackModal.addEventListener("click", (e) => {
           if (e.target === rollbackModal) {
             rollbackModal.classList.remove("active");
           }
         });
       }
       
       const auditLogBtn = document.getElementById("audit-log-btn");
       const auditLogModal = document.getElementById("audit-log-modal");
       const auditLogModalClose = document.getElementById("audit-log-modal-close");
       if (auditLogBtn && auditLogModal) {
         auditLogBtn.addEventListener("click", () => {
           loadAuditLog();
           displayAuditLog();
           auditLogModal.classList.add("active");
         });
       }
       if (auditLogModalClose && auditLogModal) {
         auditLogModalClose.addEventListener("click", () => {
           auditLogModal.classList.remove("active");
         });
       }
       if (auditLogModal) {
         auditLogModal.addEventListener("click", (e) => {
           if (e.target === auditLogModal) {
             auditLogModal.classList.remove("active");
           }
         });
       }
      
       const auditFilter = document.getElementById("audit-filter");
       if (auditFilter) {
         auditFilter.addEventListener("change", (e) => {
           displayAuditLog(e.target.value);
         });
       }
       
       const secretsBtn = document.getElementById("secrets-btn");
       const secretsModal = document.getElementById("secrets-modal");
       const secretsModalClose = document.getElementById("secrets-modal-close");
       if (secretsBtn && secretsModal) {
         secretsBtn.addEventListener("click", () => {
           displaySecrets();
           secretsModal.classList.add("active");
         });
       }
       if (secretsModalClose && secretsModal) {
         secretsModalClose.addEventListener("click", () => {
           secretsModal.classList.remove("active");
         });
       }
       if (secretsModal) {
         secretsModal.addEventListener("click", (e) => {
           if (e.target === secretsModal) {
             secretsModal.classList.remove("active");
           }
         });
       }
       
       const secretEditorModal = document.getElementById("secret-editor-modal");
       if (secretEditorModal) {
         secretEditorModal.addEventListener("click", (e) => {
           if (e.target === secretEditorModal) {
             closeSecretEditor();
           }
         });
       }
       
       ["physical", "logical", "security", "application"].forEach(layer => {
        const checkbox = document.getElementById(`layer-${layer}`);
        if (checkbox) {
         checkbox.addEventListener("change", applyLayerFilter);
        }
       });
       
       const layerSelect = document.getElementById("node-layer");
       if (layerSelect) {
        layerSelect.addEventListener("change", (e) => {
         if (currentNodeId) {
          pushUndo("change layer");
          NODE_DATA[currentNodeId].layer = e.target.value;
          forgeTheTopology();
         }
        });
       }
       
       const assignedRackSelect = document.getElementById("node-assigned-rack");
       if (assignedRackSelect) {
        assignedRackSelect.addEventListener("change", (e) => {
      if (currentNodeId) {
      pushUndo("change assigned rack");
      EDGE_DATA.list = EDGE_DATA.list.filter(edge => edge.from !== currentNodeId && edge.to !== currentNodeId);
      NODE_DATA[currentNodeId].assignedRack = e.target.value;
      forgeTheTopology();
      claimTheImmortal(currentNodeId);
      }
      });
       }
       
       const rackCapacitySelect = document.getElementById("node-rack-capacity");
       if (rackCapacitySelect) {
        rackCapacitySelect.addEventListener("change", (e) => {
         if (currentNodeId) {
          pushUndo("change rack capacity");
          NODE_DATA[currentNodeId].rackCapacity = e.target.value;
          forgeTheTopology();
         }
        });
       }
       
       const addRackBtn = document.getElementById("add-rack-btn");
       const addRackModal = document.getElementById("add-rack-modal");
       const addRackCancel = document.getElementById("add-rack-cancel");
       const addRackSave = document.getElementById("add-rack-save");
       
       if (addRackBtn && addRackModal) {
        addRackBtn.addEventListener("click", () => {
		if (isViewOnly()) return;
         document.getElementById("new-rack-name").value = "";
         document.getElementById("new-rack-ip").value = "";
         document.getElementById("new-rack-tags").value = "";
         document.getElementById("new-rack-shape").value = "server";
         document.getElementById("new-rack-capacity").value = "42";
         selectedRackIconData = null;
         document.getElementById('selected-rack-icon').style.display = 'none';
         addRackModal.classList.add("active");
         document.getElementById("new-rack-name").focus();
        });
       }
       
       if (addRackCancel && addRackModal) {
        addRackCancel.addEventListener("click", () => {
         addRackModal.classList.remove("active");
        });
       }
       
       if (addRackModal) {
        addRackModal.addEventListener("click", (e) => {
         if (e.target === addRackModal) {
          addRackModal.classList.remove("active");
         }
        });
       }
       
       if (addRackSave && addRackModal) {
        addRackSave.addEventListener("click", () => {
         const name = document.getElementById("new-rack-name").value.trim();
         const ip = document.getElementById("new-rack-ip").value.trim();
         const tagsStr = document.getElementById("new-rack-tags").value.trim();
         const shape = document.getElementById("new-rack-shape").value;
         const capacity = document.getElementById("new-rack-capacity").value;
         
         if (!name) {
          alert("Please enter a rack name.");
          return;
         }
         
         const tags = tagsStr ? tagsStr.split(",").map((t) => t.trim()).filter((t) => t) : [];
         let baseId = name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");
         if (!baseId) baseId = "rack";
         let nodeId = baseId;
         let counter = 1;
         while (NODE_DATA[nodeId]) {
          nodeId = baseId + "-" + counter;
          counter++;
         }
         
         pushUndo("add rack");
         
         NODE_DATA[nodeId] = {
          shape: shape,
          name: name,
          ip: ip || "",
          role: "Rack",
          tags: tags,
          notes: [],
          mac: "",
          rackUnit: "",
          uHeight: "1",
          layer: "physical",
          assignedRack: "",
          rackCapacity: capacity,
          isRack: true,
          locked: false,
          groupId: null
         };
         
         const viewWidth = CANVAS_WIDTH / canvasState.zoom;
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         const centerX = canvasState.panX + (viewWidth / 2);
         const centerY = canvasState.panY + (viewHeight / 2);
         savedPositions[nodeId] = {
          x: centerX,
          y: centerY
         };
         
         if (selectedRackIconData) {
          if (!savedStyles[nodeId]) {
           savedStyles[nodeId] = {};
          }
          if (!savedStyles[nodeId]['all']) {
           savedStyles[nodeId]['all'] = {};
          }
          savedStyles[nodeId]['all'].icon = {
           library: selectedRackIconData.library,
           name: selectedRackIconData.name
          };
          selectedRackIconData = null;
          document.getElementById('selected-rack-icon').style.display = 'none';
         }
         
         addRackModal.classList.remove("active");
         forgeTheTopology();
         claimTheImmortal(nodeId);
        });
        
        ["new-rack-name", "new-rack-ip", "new-rack-tags"].forEach((inputId) => {
         const input = document.getElementById(inputId);
         if (input) {
          input.addEventListener("keypress", (e) => {
           if (e.key === "Enter") {
            addRackSave.click();
           }
          });
         }
        });
       }
       
       addNodeCancel.addEventListener("click", () => {
        addNodeModal.classList.remove("active");
       });
       addNodeModal.addEventListener("click", (e) => {
        if (e.target === addNodeModal) {
         addNodeModal.classList.remove("active");
        }
       });
       addNodeSave.addEventListener("click", () => {
        const name = document.getElementById("new-node-name").value.trim();
        const ip = document.getElementById("new-node-ip").value.trim();
        const tagsStr = document.getElementById("new-node-tags").value.trim();
        const shape = document.getElementById("new-node-shape").value;
        const pingable = document.getElementById("new-node-pingable").checked;
        const pingProtocol = document.getElementById("new-node-ping-protocol").value;
        const pingCustomUrl = document.getElementById("new-node-custom-url").value.trim();
        const pingTimeout = parseInt(document.getElementById("new-node-ping-timeout").value) || 3000;
        
        if (!name) {
         alert("Please enter a node name.");
         return;
        }
        const tags = tagsStr ? tagsStr.split(",").map((t) => t.trim()).filter((t) => t) : [];
        if (newNodeIconTags.length > 0) {
         tags.push(...newNodeIconTags);
        }
        let baseId = name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");
        if (!baseId) baseId = "node";
        let nodeId = baseId;
        let counter = 1;
        while (NODE_DATA[nodeId]) {
         nodeId = baseId + "-" + counter;
         counter++;
        }
        NODE_DATA[nodeId] = {
         shape: shape || "circle",
         name: name,
         ip: ip || "0.0.0.0",
         role: "",
         tags: tags,
         notes: [],
         mac: "",
         rackUnit: "",
         uHeight: "1",
         ping: {
          enabled: pingable,
          protocol: pingProtocol,
          customUrl: pingCustomUrl,
          timeout: pingTimeout,
          status: 'unknown',
          lastCheck: null
         },
         locked: false, 
         groupId: null 
        };
        
        if (currentView.mode === "rack" && currentView.rackId) {
         NODE_DATA[nodeId].assignedRack = currentView.rackId;
         NODE_DATA[nodeId].layer = "physical";
         const rackCapacity = getRackCapacity(currentView.rackId);
         const rackUHeight = getRackUHeight(currentView.rackId);
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         const centerY = canvasState.panY + (viewHeight / 2);
         let unit = rackCapacity - Math.round((centerY - RACK_START_Y) / rackUHeight);
         unit = Math.max(1, Math.min(rackCapacity, unit));
         NODE_DATA[nodeId].rackUnit = String(unit);
        }
        
        if (selectedNodeIconData) {
         if (!savedStyles[nodeId]) savedStyles[nodeId] = {};
         if (!savedStyles[nodeId]['all']) savedStyles[nodeId]['all'] = {};
         savedStyles[nodeId]['all'].icon = {
          library: selectedNodeIconData.library,
          name: selectedNodeIconData.name
         };
         selectedNodeIconData = null;
         document.getElementById('selected-node-icon').style.display = 'none';
        }
        newNodeIconTags = [];
      const viewWidth = CANVAS_WIDTH / canvasState.zoom;
      const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
      const centerX = canvasState.panX + (viewWidth / 2);
      const centerY = canvasState.panY + (viewHeight / 2);
      savedPositions[nodeId] = {
      x: centerX,
      y: centerY
      };
        addNodeModal.classList.remove("active");
        forgeTheTopology();
        claimTheImmortal(nodeId);
       });
       ["new-node-name", "new-node-ip", "new-node-tags"].forEach(
        (inputId) => {
         document.getElementById(inputId).addEventListener("keypress", (e) => {
          if (e.key === "Enter") {
           addNodeSave.click();
          }
         });
        }, );
       
       document.getElementById('new-node-pingable').addEventListener('change', (e) => {
        const pingOptions = document.getElementById('new-node-ping-options');
        pingOptions.style.display = e.target.checked ? 'block' : 'none';
       });
       
       document.getElementById('new-node-ping-protocol').addEventListener('change', (e) => {
        const customUrlContainer = document.getElementById('new-node-custom-url-container');
        customUrlContainer.style.display = e.target.value === 'custom' ? 'block' : 'none';
       });
       
       document.getElementById('pick-rack-icon-btn').addEventListener('click', () => {
        openIconPicker((iconData) => {
         selectedRackIconData = iconData;
         const preview = document.getElementById('selected-rack-icon-preview');
         const container = document.getElementById('selected-rack-icon');
         const parser = new DOMParser();
         const doc = parser.parseFromString(iconData.svg, 'image/svg+xml');
         const svgEl = doc.querySelector('svg');
         preview.innerHTML = '';
         if (svgEl) {
          preview.appendChild(svgEl.cloneNode(true));
         }
         const nameSpan = document.createElement('span');
         nameSpan.textContent = iconData.name;
         preview.appendChild(nameSpan);
         container.style.display = 'block';
        });
       });
       
       document.getElementById('pick-node-icon-btn').addEventListener('click', () => {
        openIconPicker((iconData) => {
         selectedNodeIconData = iconData;
         const preview = document.getElementById('selected-node-icon-preview');
         const container = document.getElementById('selected-node-icon');
         const parser = new DOMParser();
         const doc = parser.parseFromString(iconData.svg, 'image/svg+xml');
         const svgEl = doc.querySelector('svg');
         preview.innerHTML = '';
         if (svgEl) {
          preview.appendChild(svgEl.cloneNode(true));
         }
         const nameSpan = document.createElement('span');
         nameSpan.textContent = iconData.name;
         preview.appendChild(nameSpan);
         container.style.display = 'block';
        });
       });
       document.getElementById('pick-tag-icon-btn').addEventListener('click', () => {
        if (!currentNodeId) return;
        openIconPicker((iconData) => {
         if (!currentNodeId || !NODE_DATA[currentNodeId]) return;
         if (!NODE_DATA[currentNodeId].tags) {
          NODE_DATA[currentNodeId].tags = [];
         }
         NODE_DATA[currentNodeId].tags.push({
          type: 'icon',
          library: iconData.library,
          name: iconData.name
         });
         forgeTheTopology();
         claimTheImmortal(currentNodeId);
        });
       });
       document.getElementById('pick-new-node-tag-icon-btn').addEventListener('click', () => {
        openIconPicker((iconData) => {
         newNodeIconTags.push({
          type: 'icon',
          library: iconData.library,
          name: iconData.name
         });
         const container = document.getElementById('new-node-icon-tags');
         const list = document.getElementById('new-node-icon-tags-list');
         const badge = document.createElement('div');
         badge.className = 'icon-badge';
         badge.style.cssText = 'display: inline-flex; align-items: center; gap: 6px; padding: 6px 10px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; font-size: 13px;';
         const iconPreview = document.createElement('div');
         iconPreview.style.cssText = 'width: 16px; height: 16px; display: flex; align-items: center; justify-content: center;';
         IconLibrary.getIcon(iconData.library, iconData.name).then(svg => {
          if (svg) {
           const parser = new DOMParser();
           const doc = parser.parseFromString(svg, 'image/svg+xml');
           const svgEl = doc.querySelector('svg');
           if (svgEl) {
            svgEl.setAttribute('width', '16');
            svgEl.setAttribute('height', '16');
            svgEl.style.fill = 'var(--text-main)';
            iconPreview.appendChild(svgEl);
           }
          }
         });
         const name = document.createElement('span');
         name.textContent = iconData.name;
         name.style.color = 'var(--text-soft)';
         const removeBtn = document.createElement('button');
         removeBtn.textContent = '√ó';
         removeBtn.style.cssText = 'background: none; border: none; color: var(--danger); cursor: pointer; font-size: 18px; line-height: 1; padding: 0 4px;';
         removeBtn.addEventListener('click', () => {
          const index = newNodeIconTags.findIndex(t => t.type === 'icon' && t.library === iconData.library && t.name === iconData.name);
          if (index > -1) {
           newNodeIconTags.splice(index, 1);
          }
          badge.remove();
          if (list.children.length === 0) {
           container.style.display = 'none';
          }
         });
         badge.appendChild(iconPreview);
         badge.appendChild(name);
         badge.appendChild(removeBtn);
         list.appendChild(badge);
         container.style.display = 'block';
        });
       });
       document.getElementById('pick-shape-icon-btn').addEventListener('click', () => {
        if (!currentNodeId) return;
        openIconPicker((iconData) => {
         if (!savedStyles[currentNodeId]) {
          savedStyles[currentNodeId] = {};
         }
         if (!savedStyles[currentNodeId][currentStyleScope]) {
          savedStyles[currentNodeId][currentStyleScope] = {};
         }
         savedStyles[currentNodeId][currentStyleScope].icon = {
          library: iconData.library,
          name: iconData.name
         };
		 delete savedStyles[currentNodeId][currentStyleScope].circleColor;
         delete savedStyles[currentNodeId][currentStyleScope].circleBorder;
         const shapeSelect = document.getElementById('shape-select');
         if (!shapeSelect.querySelector('option[value="custom-icon"]')) {
          const opt = document.createElement('option');
          opt.value = 'custom-icon';
          opt.textContent = 'Custom Icon';
          shapeSelect.insertBefore(opt, shapeSelect.firstChild);
         }
         shapeSelect.value = 'custom-icon';
         forgeTheTopology();
        });
       });
       document.getElementById('add-tag-btn').addEventListener('click', () => {
        if (!currentNodeId) return;
        if (!NODE_DATA[currentNodeId]) return;
        const input = document.getElementById('new-tag-input');
        const tagText = input.value.trim();
        if (!tagText) return;
        if (!NODE_DATA[currentNodeId].tags) {
         NODE_DATA[currentNodeId].tags = [];
        }
        NODE_DATA[currentNodeId].tags.push(tagText);
        input.value = '';
        forgeTheTopology();
        claimTheImmortal(currentNodeId);
       });
      
      function saveRollbackVersion(description = "Auto-save") {
        const version = {
          timestamp: Date.now(),
          description,
          data: captureTheQuickening()
        };
        
        try {
          const stored = localStorage.getItem(ROLLBACK_STORAGE_KEY);
          rollbackVersions = stored ? JSON.parse(stored) : [];
        } catch (e) {
          rollbackVersions = [];
        }
        
        rollbackVersions.unshift(version);
        
        if (rollbackVersions.length > MAX_ROLLBACK_VERSIONS) {
          rollbackVersions = rollbackVersions.slice(0, MAX_ROLLBACK_VERSIONS);
        }
        
        try {
          localStorage.setItem(ROLLBACK_STORAGE_KEY, JSON.stringify(rollbackVersions));
        } catch (e) {
          console.warn("Failed to save rollback version:", e);
        }
      }
      
      function loadRollbackVersions() {
        try {
          const stored = localStorage.getItem(ROLLBACK_STORAGE_KEY);
          rollbackVersions = stored ? JSON.parse(stored) : [];
          displayRollbackVersions();
        } catch (e) {
          console.warn("Failed to load rollback versions:", e);
          rollbackVersions = [];
        }
      }
      
      function displayRollbackVersions() {
        const listEl = document.getElementById("rollback-list");
        if (!listEl) return;
        
        if (rollbackVersions.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No version history yet. Versions are saved automatically when you save the file.</div>';
          return;
        }
        
        listEl.innerHTML = rollbackVersions.map((version, index) => {
          const date = new Date(version.timestamp);
          const timeStr = date.toLocaleString();
          const nodeCount = Object.keys(version.data.nodeData || {}).length;
          const edgeCount = (version.data.edgeData?.list || []).length;
          
          return `
            <div class="version-item" onclick="restoreRollbackVersion(${index})">
              <div class="version-info">
                <div class="timestamp">${timeStr}</div>
                <div class="details">${version.description} ‚Ä¢ ${nodeCount} nodes ‚Ä¢ ${edgeCount} connections</div>
              </div>
              <div class="version-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteRollbackVersion(${index})" title="Delete this version">üóëÔ∏è</button>
              </div>
            </div>
          `;
        }).join('');
      }
      
      function restoreRollbackVersion(index) {
        if (!confirm(`Restore version from ${new Date(rollbackVersions[index].timestamp).toLocaleString()}?\n\nYour current work will be lost unless you save first.`)) {
          return;
        }
        
        const version = rollbackVersions[index];
        const data = version.data;
        
        NODE_DATA = data.nodeData || {};
        EDGE_DATA = data.edgeData || { list: [] };
        RECT_DATA = data.rectData || { list: [] };
        TEXT_DATA = data.textData || { list: [] };
        EDGE_LEGEND = data.edgeLegend || {};
        savedPositions = data.nodePositions || {};
        savedSizes = data.nodeSizes || {};
        savedStyles = data.nodeStyles || {};
        PAGE_STATE = data.page || PAGE_STATE;
        
        if (data.canvas) {
          canvasState.zoom = data.canvas.zoom;
          canvasState.panX = data.canvas.panX;
          canvasState.panY = data.canvas.panY;
        }
        
        wieldThePower();
        forgeTheTopology();
        
        document.getElementById("rollback-modal").classList.remove("active");
        
        logAuditEvent("rollback", `Restored version from ${new Date(version.timestamp).toLocaleString()}`);
      }
      
      function deleteRollbackVersion(index) {
        if (!confirm("Delete this version from history?")) return;
        
        rollbackVersions.splice(index, 1);
        try {
          localStorage.setItem(ROLLBACK_STORAGE_KEY, JSON.stringify(rollbackVersions));
        } catch (e) {
          console.warn("Failed to delete version:", e);
        }
        displayRollbackVersions();
      }
      
      function clearRollbackHistory() {
        if (!confirm("Clear all version history?\n\nThis cannot be undone.")) return;
        
        rollbackVersions = [];
        localStorage.removeItem(ROLLBACK_STORAGE_KEY);
        displayRollbackVersions();
      }
      
      function createManualSnapshot() {
        const description = prompt("Enter a description for this snapshot:", "Manual snapshot");
        if (!description) return;
        
        saveRollbackVersion(description);
        displayRollbackVersions();
      }
      
      function switchTab(index) {
        if (index === currentTabIndex) return;
        
        const currentTab = documentTabs[currentTabIndex];
        currentTab.nodes = JSON.parse(JSON.stringify(NODE_DATA));
        currentTab.edges = JSON.parse(JSON.stringify(EDGE_DATA));
        currentTab.positions = JSON.parse(JSON.stringify(savedPositions));
        currentTab.sizes = JSON.parse(JSON.stringify(savedSizes));
        currentTab.styles = JSON.parse(JSON.stringify(savedStyles));
        currentTab.legend = JSON.parse(JSON.stringify(EDGE_LEGEND));
        currentTab.rects = JSON.parse(JSON.stringify(RECT_DATA));
        currentTab.texts = JSON.parse(JSON.stringify(TEXT_DATA));
        currentTab.pageState = JSON.parse(JSON.stringify(PAGE_STATE));
      
        currentTabIndex = index;
        const newTab = documentTabs[index];
        NODE_DATA = JSON.parse(JSON.stringify(newTab.nodes));
        EDGE_DATA = JSON.parse(JSON.stringify(newTab.edges));
        savedPositions = JSON.parse(JSON.stringify(newTab.positions));
        savedSizes = JSON.parse(JSON.stringify(newTab.sizes));
        savedStyles = JSON.parse(JSON.stringify(newTab.styles));
        EDGE_LEGEND = JSON.parse(JSON.stringify(newTab.legend));
        RECT_DATA = JSON.parse(JSON.stringify(newTab.rects));
        TEXT_DATA = JSON.parse(JSON.stringify(newTab.texts));
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, newTab.pageState || {});
        wieldThePower();
        document.title = PAGE_STATE.title || newTab.name;
        document.getElementById("page-title").textContent = PAGE_STATE.title || newTab.name;
        forgeTheTopology();
        currentNodeId = null;
        currentEdgeId = null;
        currentTextId = null;
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        displayTabs();
        
        logAuditEvent("tab", `Switched to tab: ${newTab.name}`);
      }
      
      function createNewTab() {
        const nameInput = document.getElementById("new-tab-name");
        const name = nameInput.value.trim();
        
        if (!name) {
          alert("Please enter a tab name");
          return;
        }
        
        const newTab = {
          id: `tab-${Date.now()}`,
          name,
          nodes: {},
          edges: { list: [] },
          positions: {},
          sizes: {},
          styles: {},
          legend: {},
          rects: { list: [] },
          texts: { list: [] },
      pageState: null
        };
        
        documentTabs.push(newTab);
        nameInput.value = "";
        displayTabs();
        
        logAuditEvent("tab", `Created new tab: ${name}`);
      }
      
      function renameTab(index) {
        const tab = documentTabs[index];
        const newName = prompt("Enter new name:", tab.name);
        if (!newName || newName === tab.name) return;
        
        tab.name = newName;
        displayTabs();
        
        logAuditEvent("tab", `Renamed tab to: ${newName}`);
      }
      
      function deleteTab(index) {
        if (documentTabs.length === 1) {
          alert("Cannot delete the last tab");
          return;
        }
        
        if (!confirm(`Delete tab "${documentTabs[index].name}"?`)) return;
        
        documentTabs.splice(index, 1);
        
        if (currentTabIndex >= documentTabs.length) {
          currentTabIndex = documentTabs.length - 1;
        }
        
        if (currentTabIndex === index) {
          switchTab(currentTabIndex);
        }
        
        displayTabs();
      }
      
      function displayTabs() {
        const listEl = document.getElementById("tabs-list");
        if (!listEl) return;
        
        listEl.innerHTML = documentTabs.map((tab, index) => {
          const nodeCount = Object.keys(tab.nodes).length;
          const edgeCount = tab.edges.list.length;
          const isActive = index === currentTabIndex;
          
          return `
            <div class="tab-item ${isActive ? 'active' : ''}" onclick="switchTab(${index})">
              <div class="tab-name">${tab.name}</div>
              <div class="tab-stats">${nodeCount} nodes ‚Ä¢ ${edgeCount} connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(${index})" title="Rename tab">‚úèÔ∏è</button>
                ${documentTabs.length > 1 ? '<button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(${index})" title="Delete tab">üóëÔ∏è</button>' : ''}
              </div>
            </div>
          `;
        }).join('');
      }
      
      function logAuditEvent(type, description, details = {}) {
        const event = {
          timestamp: Date.now(),
          type,
          description,
          details,
          tab: documentTabs[currentTabIndex]?.name || "Main"
        };
        
        auditLog.unshift(event);
        
        if (auditLog.length > MAX_AUDIT_ENTRIES) {
          auditLog = auditLog.slice(0, MAX_AUDIT_ENTRIES);
        }
        
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to save audit log:", e);
        }
      }
      
      function loadAuditLog() {
        let embeddedLog = [];
        let localLog = [];
        try {
          const stateScript = document.getElementById("topology-state");
          if (stateScript) {
            const stateData = JSON.parse(stateScript.textContent);
            if (stateData.auditLog && Array.isArray(stateData.auditLog)) {
              embeddedLog = stateData.auditLog;
            }
          }
        } catch (e) {
          console.warn("Failed to load embedded audit log:", e);
        }
        try {
          const stored = localStorage.getItem(AUDIT_STORAGE_KEY);
          if (stored) {
            localLog = JSON.parse(stored);
          }
        } catch (e) {
          console.warn("Failed to load localStorage audit log:", e);
        }
        const merged = [...embeddedLog, ...localLog];
        const seen = new Set();
        auditLog = merged.filter(entry => {
          const key = entry.timestamp + entry.description;
          if (seen.has(key)) return false;
          seen.add(key);
          return true;
        }).sort((a, b) => b.timestamp - a.timestamp);
        if (auditLog.length > MAX_AUDIT_ENTRIES) {
          auditLog = auditLog.slice(0, MAX_AUDIT_ENTRIES);
        }
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to sync audit log:", e);
        }
      }
      
      function displayAuditLog(filter = "all") {
        const listEl = document.getElementById("audit-log-list");
        if (!listEl) return;
        
        const filtered = filter === "all" ? auditLog : auditLog.filter(e => e.type === filter);
        
        if (filtered.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No audit entries yet</div>';
          return;
        }
        
        listEl.innerHTML = filtered.map(event => {
          const date = new Date(event.timestamp);
          const timeStr = date.toLocaleString();
          
          return `<div class="audit-entry ${event.type}">
              <div class="time">[${timeStr}] ${event.tab}</div>
              <div class="action">[${event.type.toUpperCase()}] ${event.description}</div>
            </div>
          `;
        }).join('');
      }
      
      function clearAuditLog() {
        if (!confirm("Clear all audit log entries?\n\nThis cannot be undone.")) return;
        
        auditLog = [];
        localStorage.removeItem(AUDIT_STORAGE_KEY);
        displayAuditLog();
      }
      
      function exportAuditLog() {
        if (auditLog.length === 0) {
          alert("No audit entries to export");
          return;
        }
        
        const csv = [
          ["Timestamp", "Tab", "Type", "Description"],
          ...auditLog.map(e => [
            new Date(e.timestamp).toISOString(),
            e.tab,
            e.type,
            e.description
          ])
        ].map(row => row.map(cell => `"${cell}"`).join(",")).join("\n");
        
        const blob = new Blob([csv], { type: "text/csv" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `audit-log-${Date.now()}.csv`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }
      
      let currentSecretName = null;
      
      function createNewSecret() {
        const nameInput = document.getElementById("new-secret-name");
        const name = nameInput.value.trim();
        
        if (!name) {
          alert("Please enter a note name");
          return;
        }
        
        if (encryptedSections[name]) {
          alert("A note note with this name already exists");
          return;
        }
        
        currentSecretName = name;
        encryptedSections[name] = { encrypted: false, data: "" };
        nameInput.value = "";
        
        document.getElementById("secret-editor-title").textContent = `New note: ${name}`;
        document.getElementById("secret-editor-content").value = "";
        document.getElementById("secrets-modal").classList.remove("active");
        document.getElementById("secret-editor-modal").classList.add("active");
        
        displaySecrets();
      }
      
      function editSecret(name) {
        currentSecretName = name;
        const section = encryptedSections[name];
        
        if (section.encrypted) {
          const password = prompt(`Enter password to decrypt "${name}":`);
          if (!password) return;
          
          try {
            decryptData(section.data, password).then(decrypted => {
              document.getElementById("secret-editor-title").textContent = `Edit Secret: ${name}`;
              document.getElementById("secret-editor-content").value = decrypted;
              document.getElementById("secrets-modal").classList.remove("active");
              document.getElementById("secret-editor-modal").classList.add("active");
            }).catch(e => {
              alert("Failed to decrypt. Wrong password?");
            });
          } catch (e) {
            alert("Failed to decrypt. Wrong password?");
          }
        } else {
          document.getElementById("secret-editor-title").textContent = `Edit note: ${name}`;
          document.getElementById("secret-editor-content").value = section.data;
          document.getElementById("secrets-modal").classList.remove("active");
          document.getElementById("secret-editor-modal").classList.add("active");
        }
      }
      
      async function saveSecret() {
        if (!currentSecretName) return;
        
        const content = document.getElementById("secret-editor-content").value;
        const autoEncrypt = document.getElementById("secret-auto-encrypt").checked;
        
        if (autoEncrypt) {
          const password = prompt(`Enter password to encrypt "${currentSecretName}":`);
          if (!password) return;
          
          const confirmPassword = prompt("Confirm password:");
          if (password !== confirmPassword) {
            alert("Passwords do not match");
            return;
          }
          
          try {
            const encrypted = await encryptData(content, password);
            encryptedSections[currentSecretName] = { encrypted: true, data: encrypted };
          } catch (e) {
            alert("Encryption failed: " + e.message);
            return;
          }
        } else {
          encryptedSections[currentSecretName] = { encrypted: false, data: content };
        }
        
        closeSecretEditor();
        displaySecrets();
        
        logAuditEvent("secret", `Saved note section: ${currentSecretName}`);
      }
      
      function closeSecretEditor() {
        document.getElementById("secret-editor-modal").classList.remove("active");
        document.getElementById("secrets-modal").classList.add("active");
        currentSecretName = null;
      }
      
      function deleteSecret(name) {
        if (!confirm(`Delete note "${name}"?`)) return;
        
        delete encryptedSections[name];
        displaySecrets();
        
        logAuditEvent("secret", `Deleted note: ${name}`);
      }
      
      function displaySecrets() {
        const listEl = document.getElementById("secrets-list");
        if (!listEl) return;
        
        const secrets = Object.keys(encryptedSections);
        
        if (secrets.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No notes yet</div>';
          return;
        }
        
        listEl.innerHTML = secrets.map(name => {
          const section = encryptedSections[name];
          const status = section.encrypted ? "üîí Encrypted" : "üîì Plaintext";
          
          return `
            <div class="secret-item">
              <div class="secret-name">${name}</div>
              <div class="secret-status">${status}</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="editSecret('${name}')" title="Edit note">‚úèÔ∏è</button>
                <button class="btn-cancel" onclick="deleteSecret('${name}')" title="Delete note">üóëÔ∏è</button>
              </div>
            </div>
          `;
        }).join('');
      }
      
       const clearAllBtn = document.getElementById("clear-all-btn");
       const clearAllModal = document.getElementById("clear-all-modal");
       const clearAllCancel = document.getElementById("clear-all-cancel");
       const clearAllConfirm = document.getElementById("clear-all-confirm");
       clearAllBtn.addEventListener("click", () => {
        clearAllModal.classList.add("active");
       });
       clearAllCancel.addEventListener("click", () => {
        clearAllModal.classList.remove("active");
       });
       clearAllModal.addEventListener("click", (e) => {
        if (e.target === clearAllModal) {
         clearAllModal.classList.remove("active");
        }
       });
       clearAllConfirm.addEventListener("click", () => {
        NODE_DATA = {};
        EDGE_DATA = {
         list: []
        };
        EDGE_LEGEND = {};
        RECT_DATA = { list: [] };
        TEXT_DATA = { list: [] };
        savedPositions = {};
        savedSizes = {};
        savedStyles = {};
		logAuditEvent("clear", "Cleared all data from canvas");
        clearAllModal.classList.remove("active");
      
      autoPingEnabled = false;
      autoPingInterval = 30;
      PAGE_STATE.autoPingEnabled = false;
      PAGE_STATE.autoPingInterval = autoPingInterval;
      
      stopAutoPing();
      
      document.getElementById("auto-ping-enabled").checked = false;
      document.getElementById("auto-ping-settings").style.display = "none";
      document.getElementById("auto-ping-interval").value = autoPingInterval;
        forgeTheTopology();
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.display = "none";
        currentNodeId = null;
        currentEdgeId = null;
        currentTextId = null;
       });
       (function addDeleteNodeButton() {
       const nodePanel = document.getElementById("node-panel");
       if (!nodePanel) return;
       let deleteBtn = document.getElementById("delete-node-btn");
       if (!deleteBtn) {
        deleteBtn = document.createElement("button");
        deleteBtn.id = "delete-node-btn";
        deleteBtn.textContent = "Delete Node";
        deleteBtn.style.cssText = "margin-top:15px; padding:10px 16px; background:var(--danger); color:#fff; border:none; border-radius:6px; cursor:pointer; font-size:clamp(14px,1.6vw,18px); font-weight:600; width:100%;";
        nodePanel.appendChild(deleteBtn);
       }
       deleteBtn.addEventListener("click", () => {
        if (!currentNodeId) return;
        const nodeData = NODE_DATA[currentNodeId];
        let confirmMessage;
        let nodesInsideRack = [];
        
        if (nodeData?.isRack) {
         nodesInsideRack = Object.entries(NODE_DATA)
          .filter(([id, n]) => n.assignedRack === currentNodeId)
          .map(([id, n]) => n.name || id);
         if (nodesInsideRack.length > 0) {
          confirmMessage = `Delete rack "${nodeData.name}"?\n\nThis will also delete ${nodesInsideRack.length} node(s) inside:\n‚Ä¢ ${nodesInsideRack.join('\n‚Ä¢ ')}`;
         } else {
          confirmMessage = `Delete rack "${nodeData.name}"? (empty rack)`;
         }
        } else {
         confirmMessage = `Delete node "${nodeData?.name || currentNodeId}" and all its connections?`;
        }
        
        challengeTheImmortal(confirmMessage, () => {
         pushUndo("delete node");
         if (nodeData?.isRack) {
          Object.keys(NODE_DATA).forEach(id => {
           if (NODE_DATA[id]?.assignedRack === currentNodeId) {
            EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== id && e.to !== id);
            delete NODE_DATA[id];
            delete savedPositions[id];
            delete savedSizes[id];
            delete savedStyles[id];
           }
          });
         }
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== currentNodeId && e.to !== currentNodeId);
         delete NODE_DATA[currentNodeId];
         delete savedPositions[currentNodeId];
         delete savedSizes[currentNodeId];
         delete savedStyles[currentNodeId];
         currentNodeId = null;
         currentEdgeId = null;
         forgeTheTopology();
         const remainingNodes = Object.keys(NODE_DATA);
         if (remainingNodes.length > 0) {
          claimTheImmortal(remainingNodes[0]);
         } else {
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("topology-toolbar").style.display = "none";
         }
        });
       });
      })();
      
       function screenshotCanvas() {
        const svg = document.getElementById("map");
        const svgClone = svg.cloneNode(true);
        const viewBox = svg.getAttribute("viewBox").split(" ").map(Number);
        const [x, y, width, height] = viewBox;
        svgClone.setAttribute("width", width);
        svgClone.setAttribute("height", height);
        svgClone.setAttribute("viewBox", `${x} ${y} ${width} ${height}`);
        const wrapper = document.createElement("div");
        wrapper.style.position = "absolute";
        wrapper.style.left = "-9999px";
        wrapper.appendChild(svgClone);
        document.body.appendChild(wrapper);
      
        function inlineStyles(original, clone) {
         const elements = original.querySelectorAll("*");
         const clonedElements = clone.querySelectorAll("*");
         const rootStyles = getComputedStyle(document.documentElement);
         const bgColor = rootStyles.getPropertyValue("--bg").trim() || "#050608";
         const bgRect = document.createElementNS("http://www.w3.org/2000/svg", "rect", );
         bgRect.setAttribute("x", x);
         bgRect.setAttribute("y", y);
         bgRect.setAttribute("width", width);
         bgRect.setAttribute("height", height);
         bgRect.setAttribute("fill", bgColor);
         clone.insertBefore(bgRect, clone.firstChild);
         elements.forEach((el, index) => {
          const clonedEl = clonedElements[index];
          if (!clonedEl) return;
          const computedStyle = getComputedStyle(el);
          const svgProps = ["fill", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin", "opacity", "font-family", "font-size", "font-weight", "font-style", "text-anchor", "dominant-baseline", "marker-start", "marker-end", ];
          svgProps.forEach((prop) => {
           const value = computedStyle.getPropertyValue(prop);
           if (value && value !== "none" && value !== "normal") {
            clonedEl.style[prop] = value;
           }
          });
          clonedEl.removeAttribute("class");
         });
        }
        inlineStyles(svg, svgClone);
        const svgData = new XMLSerializer().serializeToString(svgClone);
        document.body.removeChild(wrapper);
        const svgBlob = new Blob([svgData], {
         type: "image/svg+xml;charset=utf-8",
        });
        const url = URL.createObjectURL(svgBlob);
        const img = new Image();
        img.onload = function() {
         const canvas = document.createElement("canvas");
         canvas.width = width;
         canvas.height = height;
         const ctx = canvas.getContext("2d");
         ctx.drawImage(img, 0, 0);
         canvas.toBlob(function(blob) {
          const link = document.createElement("a");
          const timestamp = new Date().toISOString().slice(0, 10);
          link.download = `topology-${timestamp}.png`;
          link.href = URL.createObjectURL(blob);
          link.click();
          URL.revokeObjectURL(url);
          URL.revokeObjectURL(link.href);
         }, "image/png");
        };
        img.onerror = function() {
         console.error("Failed to load SVG image");
         alert("Screenshot failed. Please try again.");
         URL.revokeObjectURL(url);
        };
        img.src = url;
       }
      
       function exportCanvasSVG() {
        const svg = document.getElementById("map");
        const svgClone = svg.cloneNode(true);
        const viewBox = svg.getAttribute("viewBox").split(" ").map(Number);
        const [x, y, width, height] = viewBox;
        svgClone.setAttribute("width", width);
        svgClone.setAttribute("height", height);
        const rootStyles = getComputedStyle(document.documentElement);
        const bgColor = rootStyles.getPropertyValue("--bg").trim() || "#050608";
        const bgRect = document.createElementNS("http://www.w3.org/2000/svg", "rect", );
        bgRect.setAttribute("x", x);
        bgRect.setAttribute("y", y);
        bgRect.setAttribute("width", width);
        bgRect.setAttribute("height", height);
        bgRect.setAttribute("fill", bgColor);
        svgClone.insertBefore(bgRect, svgClone.firstChild);
        const wrapper = document.createElement("div");
        wrapper.style.position = "absolute";
        wrapper.style.left = "-9999px";
        wrapper.appendChild(svgClone);
        document.body.appendChild(wrapper);
        const elements = svg.querySelectorAll("*");
        const clonedElements = svgClone.querySelectorAll("*");
        elements.forEach((el, index) => {
         const clonedEl = clonedElements[index];
         if (!clonedEl) return;
         const computedStyle = getComputedStyle(el);
         const svgProps = ["fill", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin", "opacity", "font-family", "font-size", "font-weight", "font-style", "text-anchor", "dominant-baseline", "marker-start", "marker-end", ];
         svgProps.forEach((prop) => {
          const value = computedStyle.getPropertyValue(prop);
          if (value && value !== "none" && value !== "normal") {
           clonedEl.setAttribute(prop, value);
          }
         });
         clonedEl.removeAttribute("class");
        });
        const svgData = new XMLSerializer().serializeToString(svgClone);
        document.body.removeChild(wrapper);
        const blob = new Blob([svgData], {
         type: "image/svg+xml;charset=utf-8",
        });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        const timestamp = new Date().toISOString().slice(0, 10);
        link.download = `topology-${timestamp}.svg`;
        link.href = url;
        link.click();
        URL.revokeObjectURL(url);
       }
      let resizeTimeout;
       window.addEventListener('resize', () => {
       clearTimeout(resizeTimeout);
       resizeTimeout = setTimeout(() => {
       updateDrawToolbarVisibility();
       updateTopologyToolbarVisibility();
       }, 100);
      });	   
    </script>
  
</body></html>